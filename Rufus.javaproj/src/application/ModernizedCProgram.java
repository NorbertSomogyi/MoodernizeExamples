package application;

public class ModernizedCProgram {
	public static Object __jbd_kmalloc;
	public static int jfs_has_feature_checksum;
	public static Object jfs_set_feature_checksum;
	public static Object jfs_clear_feature_checksum;
	public static int jfs_has_feature_revoke;
	public static Object jfs_set_feature_revoke;
	public static Object jfs_clear_feature_revoke;
	public static int jfs_has_feature_64bit;
	public static Object jfs_set_feature_64bit;
	public static Object jfs_clear_feature_64bit;
	public static int jfs_has_feature_async_commit;
	public static Object jfs_set_feature_async_commit;
	public static Object jfs_clear_feature_async_commit;
	public static int jfs_has_feature_csum2;
	public static Object jfs_set_feature_csum2;
	public static Object jfs_clear_feature_csum2;
	public static int jfs_has_feature_csum3;
	public static Object jfs_set_feature_csum3;
	public static Object jfs_clear_feature_csum3;
	public static int journal_blocks_per_page;
	public static int jbd_blocks_per_page;
	public static byte NtStatusError;
	public static DWORD LastWinError = 0;
	public static ULONG RtlNtStatusToDosError_t = new ULONG();
	public static RtlNtStatusToDosError_t pfRtlNtStatusToDosError = ((Object)0);
	public static  NtClose_t = new ();
	public static NtClose_t pfNtClose = ((Object)0);
	public static  NtOpenFile_t = new ();
	public static NtOpenFile_t pfNtOpenFile = ((Object)0);
	public static  NtFlushBuffersFile_t = new ();
	public static NtFlushBuffersFile_t pfNtFlushBuffersFile = ((Object)0);
	public static  NtReadFile_t = new ();
	public static NtReadFile_t pfNtReadFile = ((Object)0);
	public static  NtWriteFile_t = new ();
	public static NtWriteFile_t pfNtWriteFile = ((Object)0);
	public static  NtDeviceIoControlFile_t = new ();
	public static NtDeviceIoControlFile_t pfNtDeviceIoControlFile = ((Object)0);
	public static  NtFsControlFile_t = new ();
	public static NtFsControlFile_t pfNtFsControlFile = ((Object)0);
	public static  NtDelayExecution_t = new ();
	public static NtDelayExecution_t pfNtDelayExecution = ((Object)0);
	public static  nt_open = new ();
	public static  nt_close = new ();
	public static  nt_set_blksize = new ();
	public static  nt_read_blk = new ();
	public static  nt_write_blk = new ();
	public static  nt_flush = new ();
	public static struct_io_manager struct_nt_manager = new struct_io_manager(/*Error: Invalid initializer*/, /*Error: Invalid initializer*/, /*Error: Invalid initializer*/, /*Error: Invalid initializer*/, /*Error: Invalid initializer*/, /*Error: Invalid initializer*/, /*Error: Invalid initializer*/, /*Error: Invalid initializer*/);
	public static ERROR_ENTRY[] ErrorTable = new ERROR_ENTRY[]{new ERROR_ENTRY(-1024, 22), new ERROR_ENTRY(-1024, 2), new ERROR_ENTRY(-1024, 2), new ERROR_ENTRY(-1024, 24), new ERROR_ENTRY(-1024, 13), new ERROR_ENTRY(-1024, 9), new ERROR_ENTRY(-1024, 12), new ERROR_ENTRY(-1024, 12), new ERROR_ENTRY(-1024, 12), new ERROR_ENTRY(-1024, 7), new ERROR_ENTRY(-1024, 8), new ERROR_ENTRY(-1024, 22), new ERROR_ENTRY(-1024, 22), new ERROR_ENTRY(-1024, 2), new ERROR_ENTRY(-1024, 13), new ERROR_ENTRY(-1024, 18), new ERROR_ENTRY(-1024, 2), new ERROR_ENTRY(-1024, 13), new ERROR_ENTRY(-1024, 2), new ERROR_ENTRY(-1024, 13), new ERROR_ENTRY(-1024, 2), new ERROR_ENTRY(-1024, 17), new ERROR_ENTRY(-1024, 13), new ERROR_ENTRY(-1024, 13), new ERROR_ENTRY(-1024, 22), new ERROR_ENTRY(-1024, 11), new ERROR_ENTRY(-1024, 13), new ERROR_ENTRY(-1024, 32), new ERROR_ENTRY(-1024, 28), new ERROR_ENTRY(-1024, 9), new ERROR_ENTRY(-1024, 22), new ERROR_ENTRY(-1024, 10), new ERROR_ENTRY(-1024, 10), new ERROR_ENTRY(-1024, 9), new ERROR_ENTRY(-1024, 22), new ERROR_ENTRY(-1024, 13), new ERROR_ENTRY(-1024, 41), new ERROR_ENTRY(-1024, 13), new ERROR_ENTRY(-1024, 2), new ERROR_ENTRY(-1024, 11), new ERROR_ENTRY(-1024, 13), new ERROR_ENTRY(-1024, 17), new ERROR_ENTRY(-1024, 2), new ERROR_ENTRY(-1024, 11), new ERROR_ENTRY(-1024, 12)};
	public static _CdioList CdioList_t = new _CdioList();
	public static _CdioListNode CdioListNode_t = new _CdioListNode();
	public static int _cdio_list_cmp_func_t;
	public static int _cdio_list_iterfunc_t;
	public static CdioList_t _cdio_list_new = new CdioList_t();
	public static Object _cdio_list_free;
	public static int _cdio_list_length;
	public static Object _cdio_list_prepend;
	public static Object _cdio_list_append;
	public static Object _cdio_list_foreach;
	public static CdioListNode_t _cdio_list_find = new CdioListNode_t();
	public static CdioListNode_t _cdio_list_begin = new CdioListNode_t();
	public static CdioListNode_t _cdio_list_end = new CdioListNode_t();
	public static CdioListNode_t _cdio_list_node_next = new CdioListNode_t();
	public static Object _cdio_list_node_free;
	public static Object _cdio_list_node_data;
	public static byte cmdline_hogger = /*
	 * Rufus: The Reliable USB Formatting Utility
	 * Copyright Â© 2011-2019 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 *//* Memory leaks detection - define _CRTDBG_MAP_ALLOC as preprocessor macro */"rufus.com";
	public static byte ep_reg = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer";
	public static byte vs_reg = "Software\\Microsoft\\VisualStudio";
	public static BOOL existing_key = 0;
	public static BOOL size_check = 1;
	public static BOOL log_displayed = 0;
	public static BOOL iso_provided = 0;
	public static BOOL user_notified = 0;
	public static BOOL relaunch = 0;
	public static BOOL dont_display_image_name = 0;
	public static BOOL user_changed_label = 0;
	public static BOOL app_changed_label = 0;
	public static BOOL[] allowed_filesystem = new BOOL[]{0};
	public static int64_t last_iso_blocking_status = new int64_t();
	public static int selected_pt = -1;
	public static int selected_fs = fs_type.FS_UNKNOWN;
	public static int preselected_fs = fs_type.FS_UNKNOWN;
	public static int image_index = 0;
	public static int select_index = 0;
	public static RECT relaunch_rc = new RECT(-65536, -65536, 0, 0);
	public static UINT uMBRChecked = 0;
	public static HANDLE format_thid = ((Object)0);
	public static HWND hSelectImage = ((Object)0);
	public static HWND hStart = ((Object)0);
	public static byte[] szTimer = "00:00:00";
	public static int timer;
	public static byte[][] uppercase_select = new byte[2][64];
	public static byte[] uppercase_start = new byte[64];
	public static byte[] uppercase_close = new byte[64];
	public static byte[] uppercase_cancel = new byte[64];
	public static HANDLE update_check_thread = new HANDLE();
	public static BOOL enable_iso = new BOOL();
	public static BOOL enable_joliet = new BOOL();
	public static BOOL enable_rockridge = new BOOL();
	public static BYTE fido_script = new BYTE();
	public static HWND hFidoDlg = new HWND();
	public static uint8_t grub2_buf = new uint8_t();
	public static long grub2_len;
	public static byte szStatusMessage;
	public static byte[] old_c32_name = new byte[2];
	public static byte[] cert_name = new byte[3];
	public static byte[] FileSystemLabel = new byte[fs_type.FS_MAX/*
	 * Globals
	 */];
	public static HMODULE[] OpenedLibrariesHandle = new HMODULE();
	public static uint16_t OpenedLibrariesHandleSize = 0;
	public static RUFUS_UPDATE update = new RUFUS_UPDATE(new RUFUS_UPDATE(0, 0, 0), new RUFUS_UPDATE(0, 0), ((Object)0), ((Object)0));
	public static HINSTANCE hMainInstance = new HINSTANCE();
	public static HWND hMainDialog = new HWND();
	public static HWND hMultiToolbar = new HWND();
	public static HWND hSaveToolbar = new HWND();
	public static HWND hHashToolbar = new HWND();
	public static HWND hAdvancedDeviceToolbar = new HWND();
	public static HWND hAdvancedFormatToolbar = new HWND();
	public static HWND hUpdatesDlg = ((Object)0);
	public static HFONT hInfoFont = new HFONT();
	public static uint8_t image_options = -1024;
	public static uint16_t[] rufus_version = new uint16_t();
	public static uint16_t[] embedded_sl_version = new uint16_t();
	public static uint32_t dur_mins = new uint32_t();
	public static uint32_t dur_secs = new uint32_t();
	public static uint32_t[] DrivePort = new uint32_t();
	public static loc_cmd selected_locale = ((Object)0);
	public static WORD selected_langid = ((((WORD)(true)) << 10) | (WORD)(true));
	public static DWORD MainThreadId = new DWORD();
	public static HWND hDeviceList = new HWND();
	public static HWND hPartitionScheme = new HWND();
	public static HWND hTargetSystem = new HWND();
	public static HWND hFileSystem = new HWND();
	public static HWND hClusterSize = new HWND();
	public static HWND hLabel = new HWND();
	public static HWND hBootType = new HWND();
	public static HWND hNBPasses = new HWND();
	public static HWND hLog = ((Object)0);
	public static HWND hLogDialog = ((Object)0);
	public static HWND hProgress = ((Object)0);
	public static HWND hDiskID = new HWND();
	public static HANDLE dialog_handle = ((Object)0);
	public static BOOL is_x86_32 = new BOOL();
	public static BOOL[] use_own_c32 = new BOOL[]{0, 0};
	public static BOOL mbr_selected_by_user = 0;
	public static BOOL op_in_progress = 1;
	public static BOOL right_to_left_mode = 0;
	public static BOOL has_uefi_csm = 0;
	public static BOOL its_a_me_mario = 0;
	public static BOOL enable_HDDs = 0;
	public static BOOL enable_ntfs_compression = 0;
	public static BOOL no_confirmation_on_cancel = 0;
	public static BOOL lock_drive = 1;
	public static BOOL advanced_mode_device = new BOOL();
	public static BOOL advanced_mode_format = new BOOL();
	public static BOOL allow_dual_uefi_bios = new BOOL();
	public static BOOL detect_fakes = new BOOL();
	public static BOOL enable_vmdk = new BOOL();
	public static BOOL force_large_fat32 = new BOOL();
	public static BOOL usb_debug = new BOOL();
	public static BOOL use_fake_units = new BOOL();
	public static BOOL preserve_timestamps = 0;
	public static BOOL fast_zeroing = 0;
	public static BOOL app_changed_size = 0;
	public static BOOL zero_drive = 0;
	public static BOOL list_non_usb_removable_drives = 0;
	public static BOOL enable_file_indexing = new BOOL();
	public static BOOL large_drive = 0;
	public static BOOL write_as_image = 0;
	public static BOOL installed_uefi_ntfs = 0;
	public static BOOL enable_fido = 0;
	public static BOOL use_vds = 0;
	public static double fScale = 1.0;
	public static int dialog_showing = 0;
	public static int selection_default = boot_type.BT_IMAGE;
	public static int windows_to_go_selection = 0;
	public static int persistence_unit_selection = -1;
	public static int default_fs;
	public static int fs_type;
	public static int boot_type;
	public static int partition_type;
	public static int target_type;
	public static int force_update = 0;
	public static byte[] szFolderPath = new byte[260];
	public static byte[] app_dir = new byte[260];
	public static byte[] system_dir = new byte[260];
	public static byte[] temp_dir = new byte[260];
	public static byte[] sysnative_dir = new byte[260];
	public static byte[][] embedded_sl_version_str = new byte[][]{"?.??", "?.??"};
	public static byte[][] embedded_sl_version_ext = new byte[2][32];
	public static byte[][] ClusterSizeLabel = new byte[18][64];
	public static byte[] msgbox = new byte[1024];
	public static byte[] msgbox_title = new byte[32];
	public static byte ini_file = ((Object)0);
	public static byte image_path = ((Object)0);
	public static byte short_image_path;
	public static byte[] image_option_txt = new byte[128];
	public static byte fido_url = ((Object)0);
	public static StrArray DriveId = new StrArray();
	public static StrArray DriveName = new StrArray();
	public static StrArray DriveLabel = new StrArray();
	public static StrArray DriveHub = new StrArray();
	public static StrArray BlockingProcess = new StrArray();
	public static StrArray ImageList = new StrArray();
	public static int[] nb_steps = new int[]{5, 5, 12, 1, 10, 1, 1, 1, 1};
	public static byte[] flash_type = new byte[]{"SLC", "MLC", "TLC"};
	public static HWND hStatus = new HWND();
	public static size_t ubuffer_pos = /*
	 * Rufus: The Reliable USB Formatting Utility
	 * Standard User I/O Routines (logging, status, error, etc.)
	 * Copyright Â© 2011-2019 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 *//*
	 * Globals
	 */0;
	public static byte[] ubuffer = new byte[4096];
	public static int gid_t;
	public static int uid_t;
	public static smallint bb_got_signal = new smallint();
	public static uint32_t global_crc32_table = new uint32_t();
	public static jmp_buf bb_error_jmp = new jmp_buf();
	public static byte bb_virtual_buf;
	public static size_t bb_virtual_len = new size_t();
	public static size_t bb_virtual_pos = new size_t();
	public static int bb_virtual_fd;
	public static uint32_t crc32_filltable = new uint32_t();
	public static uint32_t crc32_le = new uint32_t();
	public static uint32_t crc32_be = new uint32_t();
	public static Object bled_printf;
	public static Object bled_progress;
	public static long bled_cancel_request;
	public static uint64_t bb_total_rb = new uint64_t();
	public static byte[] mbr_dos_f2_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* First 446 bytes of MBR from Dos 3.3 onwards and Windows 95A */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static Object ext2fs_rb_insert_color;
	public static Object ext2fs_rb_erase;
	public static Object rb_augment_f;
	public static Object ext2fs_rb_augment_insert;
	public static rb_node ext2fs_rb_augment_erase_begin = new rb_node();
	public static Object ext2fs_rb_augment_erase_end;
	public static rb_node ext2fs_rb_next = new rb_node();
	public static rb_node ext2fs_rb_prev = new rb_node();
	public static rb_node ext2fs_rb_first = new rb_node();
	public static rb_node ext2fs_rb_last = new rb_node();
	public static Object ext2fs_rb_replace_node;
	public static ext2fs_struct_generic_bitmap_64 ext2fs_generic_bitmap_64 = new ext2fs_struct_generic_bitmap_64();
	public static ext2_bitmap_ops ext2fs_blkmap64_bitarray = new ext2_bitmap_ops();
	public static ext2_bitmap_ops ext2fs_blkmap64_rbtree = new ext2_bitmap_ops();
	public static byte optarg;
	public static int optind = /* Getopt for GNU.
	   NOTE: getopt is now part of the C library, so if you don't know what
	   "Keep this file name-space clean" means, talk to drepper@gnu.org
	   before changing it!
	   Copyright (C) 1987,88,89,90,91,92,93,94,95,96,98,99,2000,2001
	   	Free Software Foundation, Inc.
	   This file is part of the GNU C Library.
	
	   The GNU C Library is free software; you can redistribute it and/or
	   modify it under the terms of the GNU Lesser General Public
	   License as published by the Free Software Foundation; either
	   version 2.1 of the License, or (at your option) any later version.
	
	   The GNU C Library is distributed in the hope that it will be useful,
	   but WITHOUT ANY WARRANTY; without even the implied warranty of
	   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	   Lesser General Public License for more details.
	
	   You should have received a copy of the GNU Lesser General Public
	   License along with the GNU C Library; if not, write to the Free
	   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
	   02111-1307 USA.  *//* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
	   Ditto for AIX 3.2 and <stdlib.h>.  *//* This is a separate conditional since some stdc systems
	   reject `defined (const)'.  *//* Comment out all this code if we are using the GNU C Library, and are not
	   actually compiling the library itself.  This code is part of the GNU C
	   Library, but also included in many other GNU distributions.  Compiling
	   and linking in this code is a waste when using the GNU C library
	   (especially if it is a shared library).  Rather than having every GNU
	   program understand `configure --with-gnu-libc' and omit the object files,
	   it is simpler to just do this in the source for each such file.  *//* This needs to come after some library #include
	   to get __GNU_LIBRARY__ defined.  *//* This needs to come after some library #include
	   to get __GNU_LIBRARY__ defined.  *//* Don't include stdlib.h for non-GNU C libraries because some of them
	   contain conflicting prototypes for getopt.  *//* GNU C library.  *//* This is for other GNU distributions with internationalized messages.  *//* This is for other GNU distributions with internationalized messages.  *//* This version of `getopt' appears to the caller like standard Unix `getopt'
	   but it behaves differently for the user, since it allows the user
	   to intersperse the options with the other arguments.
	
	   As `getopt' works, it permutes the elements of ARGV so that,
	   when it is done, all the options precede everything else.  Thus
	   all application programs are extended to handle flexible argument order.
	
	   Setting the environment variable POSIXLY_CORRECT disables permutation.
	   Then the behavior is completely standard.
	
	   GNU application programs can use a third alternative mode in which
	   they can distinguish the relative order of options and other arguments.  *//* For communication from `getopt' to the caller.
	   When `getopt' finds an option that takes an argument,
	   the argument value is returned here.
	   Also, when `ordering' is RETURN_IN_ORDER,
	   each non-option ARGV-element is returned here.  *//* Index in ARGV of the next element to be scanned.
	   This is used for communication to and from the caller
	   and for communication between successive calls to `getopt'.
	
	   On entry to `getopt', zero means this is the first call; initialize.
	
	   When `getopt' returns -1, this is the index of the first of the
	   non-option elements that the caller should itself scan.
	
	   Otherwise, `optind' communicates from one call to the next
	   how much of ARGV has been scanned so far.  *//* 1003.2 says this must be 1 before any call.  */1/* Formerly, initialization of getopt depended on optind==0, which
	   causes problems with re-calling getopt as programs generally don't
	   know that. *//* The next char to be scanned in the option-element
	   in which the last option character we returned was found.
	   This allows us to pick up the scan where we left off.
	
	   If this is zero, or a null string, it means resume the scan
	   by advancing to the next ARGV-element.  */;
	public static int __getopt_initialized;
	public static byte nextchar;
	public static int opterr = /* Callers store zero here to inhibit the error message
	   for unrecognized options.  */1/* Set to an option character which was unrecognized.
	   This must be initialized on some systems to avoid linking in the
	   system's own getopt implementation.  */;
	public static int optopt = (byte)'?'/* Describe how to deal with options that follow non-option ARGV-elements.
	
	   If the caller did not specify anything,
	   the default is REQUIRE_ORDER if the environment variable
	   POSIXLY_CORRECT is defined, PERMUTE otherwise.
	
	   REQUIRE_ORDER means don't recognize them as options;
	   stop option processing when the first non-option is seen.
	   This is what Unix does.
	   This mode of operation is selected by either setting the environment
	   variable POSIXLY_CORRECT, or using `+' as the first character
	   of the list of option characters.
	
	   PERMUTE is the default.  We permute the contents of ARGV as we scan,
	   so that eventually all the non-options are at the end.  This allows options
	   to be given in any order, even with programs that were not written to
	   expect this.
	
	   RETURN_IN_ORDER is an option available to programs that were written
	   to expect options and other ARGV-elements in any order and that care about
	   the ordering of the two.  We describe each non-option ARGV-element
	   as if it were the argument of an option with character code 1.
	   Using `-' as the first character of the list of option characters
	   selects this mode of operation.
	
	   The special argument `--' forces an end of option-scanning regardless
	   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
	   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */;
	public static byte posixly_correct;
	public static byte getenv;
	public static int first_nonopt;
	public static int last_nonopt;
	public static Object exchange;
	public static byte _getopt_initialize;
	public static byte[] discmode2str = new byte[]{/*
	  Copyright (C) 2003, 2004, 2005, 2008, 2011, 2012, 2014
	   Rocky Bernstein <rocky@gnu.org>
	  Copyright (C) 2001 Herbert Valerio Riedel <hvr@gnu.org>
	
	  This program is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  This program is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*//* Must match discmode enumeration */"CD-DA", "CD-DATA (Mode 1)", "CD DATA (Mode 2)", "CD-ROM Mixed", "DVD-ROM", "DVD-RAM", "DVD-R", "DVD-RW", "HD DVD ROM", "HD_DVD RAM", "HD DVD-R", "DVD+R", "DVD+RW", "DVD+RW DL", "DVD+R DL", "Unknown/unclassified DVD", "No information", "Error in getting information", "CD-i"/*! 
	  Get cdtext information for a CdIo object .
	  
	  @param obj the CD object that may contain CD-TEXT information.
	  @return the CD-TEXT object or NULL if obj is NULL
	  or CD-TEXT information does not exist.
	*/};
	public static cdio_charset_coverter_s cdio_charset_coverter_t = new cdio_charset_coverter_s();
	public static cdio_charset_coverter_t cdio_charset_converter_create = new cdio_charset_coverter_t();
	public static Object cdio_charset_converter_destroy;
	public static  cdio_charset_convert = new ();
	public static  cdio_charset_from_utf8 = new ();
	public static  cdio_charset_to_utf8 = new ();
	public static  cdio_utf8_to_wchar = new ();
	public static FILE fopen_utf8 = new FILE();
	public static byte[] br_fat32pe_0x1800 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static bb_struct_u64_list bb_badblocks_list = new bb_struct_u64_list();
	public static bb_struct_u64_iterate bb_badblocks_iterate = new bb_struct_u64_iterate();
	public static bb_struct_u64_list bb_u64_list = new bb_struct_u64_list();
	public static bb_struct_u64_iterate bb_u64_iterate = new bb_struct_u64_iterate();
	public static BOOL BadBlocks = new BOOL();
	public static BYTE DiskImage = /*
	 * Rufus: The Reliable USB Formatting Utility
	 * DOS boot file extraction, from the FAT12 floppy image in diskcopy.dll
	 * (MS WinME DOS) or from the embedded FreeDOS resource files
	 * Copyright Â© 2011-2017 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 *//* Memory leaks detection - define _CRTDBG_MAP_ALLOC as preprocessor macro */((Object)0/*
	 * FAT time conversion, from ReactOS' time.c
	 */);
	public static DWORD DiskImageSize = new DWORD();
	public static UCHAR[][] MonthLengths = new UCHAR[][]{new UCHAR(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31), new UCHAR(31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)};
	public static struct_ext2_filsys ext2_filsys = new struct_ext2_filsys();
	public static ext2fs_struct_generic_bitmap_base ext2fs_generic_bitmap = new ext2fs_struct_generic_bitmap_base();
	public static ext2fs_struct_generic_bitmap_base ext2fs_inode_bitmap = new ext2fs_struct_generic_bitmap_base();
	public static ext2fs_struct_generic_bitmap_base ext2fs_block_bitmap = new ext2fs_struct_generic_bitmap_base();
	public static ext2_struct_u32_list ext2_badblocks_list = new ext2_struct_u32_list();
	public static ext2_struct_u32_iterate ext2_badblocks_iterate = new ext2_struct_u32_iterate();
	public static ext2_struct_u32_list ext2_u32_list = new ext2_struct_u32_list();
	public static ext2_struct_u32_iterate ext2_u32_iterate = new ext2_struct_u32_iterate();
	public static ext2_struct_u32_list badblocks_list = new ext2_struct_u32_list();
	public static ext2_struct_u32_iterate badblocks_iterate = new ext2_struct_u32_iterate();
	public static ext2_struct_dblist ext2_dblist = new ext2_struct_dblist();
	public static ext2_file ext2_file_t = new ext2_file();
	public static ext2_extent_handle ext2_extent_handle_t = new ext2_extent_handle();
	public static ext2_extent_path ext2_extent_path_t = new ext2_extent_path();
	public static ext2_struct_inode_scan ext2_inode_scan = new ext2_struct_inode_scan();
	public static ext2_icount ext2_icount_t = new ext2_icount();
	public static stat ext2fs_struct_stat = new stat();
	public static Object ext2fs_clear_block_uninit;
	public static  ext2fs_new_inode = new ();
	public static  ext2fs_new_block = new ();
	public static  ext2fs_new_block2 = new ();
	public static  ext2fs_new_block3 = new ();
	public static  ext2fs_get_free_blocks = new ();
	public static  ext2fs_get_free_blocks2 = new ();
	public static  ext2fs_alloc_block = new ();
	public static  ext2fs_alloc_block2 = new ();
	public static  ext2fs_alloc_block3 = new ();
	public static Object ext2fs_set_alloc_block_callback;
	public static  ext2fs_find_inode_goal = new ();
	public static Object ext2fs_set_new_range_callback;
	public static Object ext2fs_set_block_alloc_stats_range_callback;
	public static  ext2fs_new_range = new ();
	public static  ext2fs_alloc_range = new ();
	public static int ext2fs_reserve_super_and_bgd;
	public static Object ext2fs_set_block_alloc_stats_callback;
	public static Object ext2fs_inode_alloc_stats;
	public static Object ext2fs_inode_alloc_stats2;
	public static Object ext2fs_block_alloc_stats;
	public static Object ext2fs_block_alloc_stats2;
	public static Object ext2fs_block_alloc_stats_range;
	public static  ext2fs_allocate_tables = new ();
	public static  ext2fs_allocate_group_table = new ();
	public static  ext2fs_u32_list_create = new ();
	public static  ext2fs_u32_list_add = new ();
	public static int ext2fs_u32_list_find;
	public static int ext2fs_u32_list_test;
	public static  ext2fs_u32_list_iterate_begin = new ();
	public static int ext2fs_u32_list_iterate;
	public static Object ext2fs_u32_list_iterate_end;
	public static  ext2fs_u32_copy = new ();
	public static int ext2fs_u32_list_equal;
	public static  ext2fs_badblocks_list_create = new ();
	public static  ext2fs_badblocks_list_add = new ();
	public static int ext2fs_badblocks_list_test;
	public static int ext2fs_u32_list_del;
	public static Object ext2fs_badblocks_list_del;
	public static  ext2fs_badblocks_list_iterate_begin = new ();
	public static int ext2fs_badblocks_list_iterate;
	public static Object ext2fs_badblocks_list_iterate_end;
	public static  ext2fs_badblocks_copy = new ();
	public static int ext2fs_badblocks_equal;
	public static int ext2fs_u32_list_count;
	public static  badblocks_list_create = new ();
	public static  badblocks_list_add = new ();
	public static int badblocks_list_test;
	public static  badblocks_list_iterate_begin = new ();
	public static int badblocks_list_iterate;
	public static Object badblocks_list_iterate_end;
	public static Object badblocks_list_free;
	public static  ext2fs_update_bb_inode = new ();
	public static Object ext2fs_free_block_bitmap;
	public static Object ext2fs_free_inode_bitmap;
	public static  ext2fs_copy_bitmap = new ();
	public static  ext2fs_write_inode_bitmap = new ();
	public static  ext2fs_write_block_bitmap = new ();
	public static  ext2fs_read_inode_bitmap = new ();
	public static  ext2fs_read_block_bitmap = new ();
	public static  ext2fs_allocate_block_bitmap = new ();
	public static  ext2fs_allocate_subcluster_bitmap = new ();
	public static int ext2fs_get_bitmap_granularity;
	public static  ext2fs_allocate_inode_bitmap = new ();
	public static  ext2fs_fudge_inode_bitmap_end = new ();
	public static  ext2fs_fudge_block_bitmap_end = new ();
	public static  ext2fs_fudge_block_bitmap_end2 = new ();
	public static Object ext2fs_clear_inode_bitmap;
	public static Object ext2fs_clear_block_bitmap;
	public static  ext2fs_read_bitmaps = new ();
	public static  ext2fs_write_bitmaps = new ();
	public static  ext2fs_resize_inode_bitmap = new ();
	public static  ext2fs_resize_inode_bitmap2 = new ();
	public static  ext2fs_resize_block_bitmap = new ();
	public static  ext2fs_resize_block_bitmap2 = new ();
	public static  ext2fs_compare_block_bitmap = new ();
	public static  ext2fs_compare_inode_bitmap = new ();
	public static  ext2fs_set_inode_bitmap_range = new ();
	public static  ext2fs_set_inode_bitmap_range2 = new ();
	public static  ext2fs_get_inode_bitmap_range = new ();
	public static  ext2fs_get_inode_bitmap_range2 = new ();
	public static  ext2fs_set_block_bitmap_range = new ();
	public static  ext2fs_set_block_bitmap_range2 = new ();
	public static  ext2fs_get_block_bitmap_range = new ();
	public static  ext2fs_get_block_bitmap_range2 = new ();
	public static  ext2fs_inode_bitmap_checksum = new ();
	public static  ext2fs_block_bitmap_checksum = new ();
	public static  ext2fs_group_of_blk2 = new ();
	public static  ext2fs_group_first_block2 = new ();
	public static  ext2fs_group_last_block2 = new ();
	public static int ext2fs_group_blocks_count;
	public static  ext2fs_inode_data_blocks2 = new ();
	public static  ext2fs_inode_i_blocks = new ();
	public static  ext2fs_blocks_count = new ();
	public static Object ext2fs_blocks_count_set;
	public static Object ext2fs_blocks_count_add;
	public static  ext2fs_r_blocks_count = new ();
	public static Object ext2fs_r_blocks_count_set;
	public static Object ext2fs_r_blocks_count_add;
	public static  ext2fs_free_blocks_count = new ();
	public static Object ext2fs_free_blocks_count_set;
	public static Object ext2fs_free_blocks_count_add;
	public static ext2_group_desc ext2fs_group_desc = new ext2_group_desc();
	public static  ext2fs_block_bitmap_csum = new ();
	public static  ext2fs_block_bitmap_loc = new ();
	public static Object ext2fs_block_bitmap_loc_set;
	public static  ext2fs_inode_bitmap_csum = new ();
	public static  ext2fs_inode_bitmap_loc = new ();
	public static Object ext2fs_inode_bitmap_loc_set;
	public static  ext2fs_inode_table_loc = new ();
	public static Object ext2fs_inode_table_loc_set;
	public static  ext2fs_bg_free_blocks_count = new ();
	public static Object ext2fs_bg_free_blocks_count_set;
	public static  ext2fs_bg_free_inodes_count = new ();
	public static Object ext2fs_bg_free_inodes_count_set;
	public static  ext2fs_bg_used_dirs_count = new ();
	public static Object ext2fs_bg_used_dirs_count_set;
	public static  ext2fs_bg_itable_unused = new ();
	public static Object ext2fs_bg_itable_unused_set;
	public static  ext2fs_bg_flags = new ();
	public static Object ext2fs_bg_flags_zap;
	public static int ext2fs_bg_flags_test;
	public static Object ext2fs_bg_flags_set;
	public static Object ext2fs_bg_flags_clear;
	public static  ext2fs_bg_checksum = new ();
	public static Object ext2fs_bg_checksum_set;
	public static  ext2fs_file_acl_block = new ();
	public static Object ext2fs_file_acl_block_set;
	public static  ext2fs_inode_size_set = new ();
	public static  ext2fs_block_iterate = new ();
	public static  ext2fs_block_iterate2 = new ();
	public static  ext2fs_block_iterate3 = new ();
	public static  ext2fs_bmap = new ();
	public static  ext2fs_bmap2 = new ();
	public static  ext2fs_map_cluster_block = new ();
	public static  ext2fs_check_desc = new ();
	public static  ext2fs_close = new ();
	public static  ext2fs_close2 = new ();
	public static  ext2fs_close_free = new ();
	public static  ext2fs_flush = new ();
	public static  ext2fs_flush2 = new ();
	public static int ext2fs_bg_has_super;
	public static  ext2fs_super_and_bgd_loc2 = new ();
	public static int ext2fs_super_and_bgd_loc;
	public static Object ext2fs_update_dynamic_rev;
	public static  ext2fs_crc32_be = new ();
	public static  ext2fs_crc32c_le = new ();
	public static Object ext2fs_init_csum_seed;
	public static  ext2fs_mmp_csum_set = new ();
	public static int ext2fs_mmp_csum_verify;
	public static int ext2fs_verify_csum_type;
	public static  ext2fs_superblock_csum_set = new ();
	public static int ext2fs_superblock_csum_verify;
	public static  ext2fs_ext_attr_block_csum_set = new ();
	public static int ext2fs_ext_attr_block_csum_verify;
	public static Object ext2fs_initialize_dirent_tail;
	public static int ext2fs_dirent_has_tail;
	public static int ext2fs_dirent_csum_verify;
	public static int ext2fs_dir_block_csum_verify;
	public static  ext2fs_dir_block_csum_set = new ();
	public static  ext2fs_get_dx_countlimit = new ();
	public static  ext2fs_extent_block_csum_set = new ();
	public static int ext2fs_extent_block_csum_verify;
	public static  ext2fs_block_bitmap_csum_set = new ();
	public static int ext2fs_block_bitmap_csum_verify;
	public static  ext2fs_inode_bitmap_csum_set = new ();
	public static int ext2fs_inode_bitmap_csum_verify;
	public static  ext2fs_inode_csum_set = new ();
	public static int ext2fs_inode_csum_verify;
	public static Object ext2fs_group_desc_csum_set;
	public static int ext2fs_group_desc_csum_verify;
	public static  ext2fs_set_gdt_csum = new ();
	public static  ext2fs_group_desc_csum = new ();
	public static  ext2fs_init_dblist = new ();
	public static  ext2fs_add_dir_block = new ();
	public static  ext2fs_add_dir_block2 = new ();
	public static Object ext2fs_dblist_sort;
	public static Object ext2fs_dblist_sort2;
	public static  ext2fs_dblist_iterate = new ();
	public static  ext2fs_dblist_iterate2 = new ();
	public static  ext2fs_dblist_iterate3 = new ();
	public static  ext2fs_set_dir_block = new ();
	public static  ext2fs_set_dir_block2 = new ();
	public static  ext2fs_copy_dblist = new ();
	public static int ext2fs_dblist_count;
	public static  ext2fs_dblist_count2 = new ();
	public static  ext2fs_dblist_get_last = new ();
	public static  ext2fs_dblist_get_last2 = new ();
	public static  ext2fs_dblist_drop_last = new ();
	public static  ext2fs_dblist_dir_iterate = new ();
	public static  ext2fs_read_dir_block = new ();
	public static  ext2fs_read_dir_block2 = new ();
	public static  ext2fs_read_dir_block3 = new ();
	public static  ext2fs_read_dir_block4 = new ();
	public static  ext2fs_write_dir_block = new ();
	public static  ext2fs_write_dir_block2 = new ();
	public static  ext2fs_write_dir_block3 = new ();
	public static  ext2fs_write_dir_block4 = new ();
	public static  ext2fs_dirhash = new ();
	public static  ext2fs_dirhash2 = new ();
	public static  ext2fs_get_rec_len = new ();
	public static  ext2fs_set_rec_len = new ();
	public static  ext2fs_dir_iterate = new ();
	public static  ext2fs_dir_iterate2 = new ();
	public static  ext2fs_dup_handle = new ();
	public static  ext2fs_expand_dir = new ();
	public static  ext2fs_ext_attr_hash_entry = new ();
	public static  ext2fs_ext_attr_hash_entry2 = new ();
	public static  ext2fs_read_ext_attr = new ();
	public static  ext2fs_read_ext_attr2 = new ();
	public static  ext2fs_read_ext_attr3 = new ();
	public static  ext2fs_write_ext_attr = new ();
	public static  ext2fs_write_ext_attr2 = new ();
	public static  ext2fs_write_ext_attr3 = new ();
	public static  ext2fs_adjust_ea_refcount = new ();
	public static  ext2fs_adjust_ea_refcount2 = new ();
	public static  ext2fs_adjust_ea_refcount3 = new ();
	public static  ext2fs_xattrs_write = new ();
	public static  ext2fs_xattrs_read = new ();
	public static  ext2fs_xattrs_iterate = new ();
	public static  ext2fs_xattr_get = new ();
	public static  ext2fs_xattr_set = new ();
	public static  ext2fs_xattr_remove = new ();
	public static  ext2fs_xattrs_open = new ();
	public static  ext2fs_xattrs_close = new ();
	public static  ext2fs_free_ext_attr = new ();
	public static  ext2fs_xattrs_count = new ();
	public static  ext2fs_xattr_inode_max_size = new ();
	public static  ext2fs_xattrs_flags = new ();
	public static Object ext2fs_ext_attr_block_rehash;
	public static  ext2fs_get_ea_inode_hash = new ();
	public static Object ext2fs_set_ea_inode_hash;
	public static  ext2fs_get_ea_inode_ref = new ();
	public static Object ext2fs_set_ea_inode_ref;
	public static  ext2fs_extent_header_verify = new ();
	public static  ext2fs_extent_open = new ();
	public static  ext2fs_extent_open2 = new ();
	public static Object ext2fs_extent_free;
	public static  ext2fs_extent_get = new ();
	public static  ext2fs_extent_node_split = new ();
	public static  ext2fs_extent_replace = new ();
	public static  ext2fs_extent_insert = new ();
	public static  ext2fs_extent_set_bmap = new ();
	public static  ext2fs_extent_delete = new ();
	public static  ext2fs_extent_get_info = new ();
	public static  ext2fs_extent_goto = new ();
	public static  ext2fs_extent_goto2 = new ();
	public static  ext2fs_extent_fix_parents = new ();
	public static size_t ext2fs_max_extent_depth = new size_t();
	public static  ext2fs_fix_extents_checksums = new ();
	public static  ext2fs_fallocate = new ();
	public static  ext2fs_file_open2 = new ();
	public static  ext2fs_file_open = new ();
	public static ext2_filsys ext2fs_file_get_fs = new ext2_filsys();
	public static ext2_inode ext2fs_file_get_inode = new ext2_inode();
	public static  ext2fs_file_get_inode_num = new ();
	public static  ext2fs_file_close = new ();
	public static  ext2fs_file_flush = new ();
	public static  ext2fs_file_read = new ();
	public static  ext2fs_file_write = new ();
	public static  ext2fs_file_llseek = new ();
	public static  ext2fs_file_lseek = new ();
	public static  ext2fs_file_get_lsize = new ();
	public static  ext2fs_file_get_size = new ();
	public static  ext2fs_file_set_size = new ();
	public static  ext2fs_file_set_size2 = new ();
	public static byte ext2fs_find_block_device;
	public static  ext2fs_sync_device = new ();
	public static Object ext2fs_free;
	public static Object ext2fs_free_dblist;
	public static Object ext2fs_badblocks_list_free;
	public static Object ext2fs_u32_list_free;
	public static Object ext2fs_free_generic_bitmap;
	public static  ext2fs_make_generic_bitmap = new ();
	public static  ext2fs_allocate_generic_bitmap = new ();
	public static  ext2fs_copy_generic_bitmap = new ();
	public static Object ext2fs_clear_generic_bitmap;
	public static  ext2fs_fudge_generic_bitmap_end = new ();
	public static Object ext2fs_set_generic_bitmap_padding;
	public static  ext2fs_resize_generic_bitmap = new ();
	public static  ext2fs_compare_generic_bitmap = new ();
	public static  ext2fs_get_generic_bitmap_range = new ();
	public static  ext2fs_set_generic_bitmap_range = new ();
	public static  ext2fs_find_first_zero_generic_bitmap = new ();
	public static  ext2fs_find_first_set_generic_bitmap = new ();
	public static Object ext2fs_free_generic_bmap;
	public static  ext2fs_alloc_generic_bmap = new ();
	public static  ext2fs_copy_generic_bmap = new ();
	public static Object ext2fs_clear_generic_bmap;
	public static  ext2fs_fudge_generic_bmap_end = new ();
	public static Object ext2fs_set_generic_bmap_padding;
	public static  ext2fs_resize_generic_bmap = new ();
	public static  ext2fs_compare_generic_bmap = new ();
	public static  ext2fs_get_generic_bmap_range = new ();
	public static  ext2fs_set_generic_bmap_range = new ();
	public static  ext2fs_convert_subcluster_bitmap = new ();
	public static  ext2fs_get_num_dirs = new ();
	public static  ext2fs_get_device_size = new ();
	public static  ext2fs_get_device_size2 = new ();
	public static int ext2fs_get_dio_alignment;
	public static  ext2fs_get_device_sectsize = new ();
	public static  ext2fs_get_device_phys_sectsize = new ();
	public static  ext2fs_iblk_add_blocks = new ();
	public static  ext2fs_iblk_sub_blocks = new ();
	public static  ext2fs_iblk_set = new ();
	public static  ext2fs_image_inode_write = new ();
	public static  ext2fs_image_inode_read = new ();
	public static  ext2fs_image_super_write = new ();
	public static  ext2fs_image_super_read = new ();
	public static  ext2fs_image_bitmap_write = new ();
	public static  ext2fs_image_bitmap_read = new ();
	public static  ext2fs_read_ind_block = new ();
	public static  ext2fs_write_ind_block = new ();
	public static  ext2fs_initialize = new ();
	public static Object ext2fs_free_icount;
	public static  ext2fs_create_icount_tdb = new ();
	public static  ext2fs_create_icount2 = new ();
	public static  ext2fs_create_icount = new ();
	public static  ext2fs_icount_fetch = new ();
	public static  ext2fs_icount_increment = new ();
	public static  ext2fs_icount_decrement = new ();
	public static  ext2fs_icount_store = new ();
	public static  ext2fs_get_icount_size = new ();
	public static  ext2fs_icount_validate = new ();
	public static  ext2fs_get_memalign = new ();
	public static  ext2fs_inline_data_init = new ();
	public static  ext2fs_inline_data_size = new ();
	public static  ext2fs_inline_data_get = new ();
	public static  ext2fs_inline_data_set = new ();
	public static  ext2fs_create_inode_cache = new ();
	public static Object ext2fs_free_inode_cache;
	public static  ext2fs_flush_icache = new ();
	public static  ext2fs_get_next_inode_full = new ();
	public static  ext2fs_open_inode_scan = new ();
	public static Object ext2fs_close_inode_scan;
	public static  ext2fs_get_next_inode = new ();
	public static  ext2fs_inode_scan_goto_blockgroup = new ();
	public static Object ext2fs_set_inode_callback;
	public static int ext2fs_inode_scan_flags;
	public static  ext2fs_read_inode_full = new ();
	public static  ext2fs_read_inode = new ();
	public static  ext2fs_read_inode2 = new ();
	public static  ext2fs_write_inode_full = new ();
	public static  ext2fs_write_inode = new ();
	public static  ext2fs_write_inode2 = new ();
	public static  ext2fs_write_new_inode = new ();
	public static  ext2fs_get_blocks = new ();
	public static  ext2fs_check_directory = new ();
	public static  inode_io_manager = new ();
	public static  ext2fs_inode_io_intern = new ();
	public static  ext2fs_inode_io_intern2 = new ();
	public static  ext2fs_check_if_mounted = new ();
	public static  ext2fs_check_mount_point = new ();
	public static  ext2fs_punch = new ();
	public static  ext2fs_lookup = new ();
	public static  ext2fs_namei = new ();
	public static  ext2fs_namei_follow = new ();
	public static  ext2fs_follow_link = new ();
	public static int ext2fs_native_flag;
	public static  ext2fs_new_dir_block = new ();
	public static  ext2fs_new_dir_inline_data = new ();
	public static  ext2fs_mkdir = new ();
	public static  ext2fs_zero_blocks = new ();
	public static  ext2fs_zero_blocks2 = new ();
	public static  ext2fs_create_journal_superblock = new ();
	public static  ext2fs_add_journal_device = new ();
	public static  ext2fs_add_journal_inode = new ();
	public static  ext2fs_add_journal_inode2 = new ();
	public static int ext2fs_default_journal_size;
	public static int ext2fs_journal_sb_start;
	public static  ext2fs_open = new ();
	public static  ext2fs_open2 = new ();
	public static  ext2fs_descriptor_block_loc2 = new ();
	public static  ext2fs_descriptor_block_loc = new ();
	public static  ext2fs_get_data_io = new ();
	public static  ext2fs_set_data_io = new ();
	public static  ext2fs_rewrite_to_io = new ();
	public static  ext2fs_get_pathname = new ();
	public static  ext2fs_link = new ();
	public static  ext2fs_unlink = new ();
	public static  ext2fs_symlink = new ();
	public static int ext2fs_is_fast_symlink;
	public static  ext2fs_mmp_read = new ();
	public static  ext2fs_mmp_write = new ();
	public static  ext2fs_mmp_clear = new ();
	public static  ext2fs_mmp_init = new ();
	public static  ext2fs_mmp_start = new ();
	public static  ext2fs_mmp_update = new ();
	public static  ext2fs_mmp_update2 = new ();
	public static  ext2fs_mmp_stop = new ();
	public static int ext2fs_mmp_new_seq;
	public static  ext2fs_read_bb_inode = new ();
	public static  ext2fs_read_bb_FILE2 = new ();
	public static  ext2fs_read_bb_FILE = new ();
	public static  ext2fs_create_resize_inode = new ();
	public static Object ext2fs_sha512;
	public static  ext2fs_dirent_swab_in2 = new ();
	public static  ext2fs_dirent_swab_in = new ();
	public static  ext2fs_dirent_swab_out2 = new ();
	public static  ext2fs_dirent_swab_out = new ();
	public static Object ext2fs_swap_ext_attr;
	public static Object ext2fs_swap_ext_attr_header;
	public static Object ext2fs_swap_ext_attr_entry;
	public static Object ext2fs_swap_super;
	public static Object ext2fs_swap_group_desc;
	public static Object ext2fs_swap_group_desc2;
	public static Object ext2fs_swap_inode_full;
	public static Object ext2fs_swap_inode;
	public static Object ext2fs_swap_mmp;
	public static int ext2fs_open_file;
	public static int ext2fs_stat;
	public static int ext2fs_fstat;
	public static int ext2fs_inode_has_valid_blocks;
	public static int ext2fs_inode_has_valid_blocks2;
	public static int ext2fs_parse_version_string;
	public static int ext2fs_get_library_version;
	public static  ext2fs_write_bb_FILE = new ();
	public static  ext2fs_print_progress = new ();
	public static uint32_t LIBFAT_SECTOR_SHIFT = new uint32_t();
	public static uint32_t LIBFAT_SECTOR_SIZE = new uint32_t();
	public static uint32_t LIBFAT_SECTOR_MASK = new uint32_t();
	public static uint64_t libfat_sector_t = new uint64_t();
	public static libfat_filesystem libfat_open = new libfat_filesystem();
	public static Object libfat_close;
	public static libfat_sector_t libfat_clustertosector = new libfat_sector_t();
	public static libfat_sector_t libfat_nextsector = new libfat_sector_t();
	public static Object libfat_flush;
	public static Object libfat_get_sector;
	public static int32_t libfat_searchdir = new int32_t();
	public static int libfat_dumpdir;
	public static loc_parse[] parse_cmd = new loc_parse[]{new loc_parse((byte)'l', loc_command_type.LC_LOCALE, "ssu"), new loc_parse((byte)'b', loc_command_type.LC_BASE, "s"), new loc_parse((byte)'v', loc_command_type.LC_VERSION, "u"), new loc_parse((byte)'t', loc_command_type.LC_TEXT, "cs"), new loc_parse((byte)'g', loc_command_type.LC_GROUP, "c"), new loc_parse((byte)'f', loc_command_type.LC_FONT, "si"), new loc_parse((byte)'a', loc_command_type.LC_ATTRIBUTES, "s")};
	public static htab_table htab_loc = new htab_table(((Object)0), 0, /* Hash table for reused translation commands */0);
	public static int loc_line_nr;
	public static list_head locale_list = new list_head(((Object)0), ((Object)/* Globals */0));
	public static byte loc_filename = ((Object)0);
	public static byte embedded_loc_filename = "embedded.loc";
	public static BOOL localization_initialized = 0;
	public static byte[] default_msg_table = new byte[]{"%s", /* Message table */0};
	public static byte[] current_msg_table = new byte[]{"%s", 0};
	public static byte msg_table = ((Object)0);
	public static byte[][][] szMessage = new byte[][][]{{"", ""}, {"", ""}};
	public static BOOL bStatusTimerArmed = 0;
	public static BOOL[] bOutputTimerArmed = new BOOL[]{0, 0};
	public static byte[] output_msg = new byte[2];
	public static uint64_t[] last_msg_time = new uint64_t[]{0, 0};
	public static Object PRINT_FUNCTION;
	public static PRINT_FUNCTION[] PrintMessage = new PRINT_FUNCTION[]{PrintInfoMessage, PrintStatusMessage/*
	 * The following timer call is used, along with MAX_REFRESH, to prevent obnoxious flicker
	 * on the Info and Status fields due to messages being updated too quickly.
	 */};
	public static BOOL found_lang = new BOOL();
	public static byte[] br_ntfs_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static S_NTFSSECT_EXTENT_ S_NTFSSECT_EXTENT = new S_NTFSSECT_EXTENT_();
	public static S_NTFSSECT_VOLINFO_ S_NTFSSECT_VOLINFO = new S_NTFSSECT_VOLINFO_();
	public static S_NTFSSECT_XPFUNCS_ S_NTFSSECT_XPFUNCS = new S_NTFSSECT_XPFUNCS_();
	public static  NtfsSectGetFileVcnExtent = new ();
	public static  NtfsSectGetVolumeInfo = new ();
	public static  NtfsSectGetVolumeInfoFromFileName = new ();
	public static  NtfsSectLcnToLba = new ();
	public static  NtfsSectLoadXpFuncs = new ();
	public static  NtfsSectUnloadXpFuncs = new ();
	public static  NtfsSectLastErrorMessage = new ();
	public static  extent_bmap = new ();
	public static long errcode_t;
	public static Object _uprintf;
	public static byte error_message;
	public static Object com_err_hook;
	public static Object set_com_err_hook;
	public static Object reset_com_err_hook;
	public static int init_error_table;
	public static byte set_com_err_gettext;
	public static errcode_t add_error_table = new errcode_t();
	public static errcode_t remove_error_table = new errcode_t();
	public static Object add_to_error_table;
	public static byte com_right;
	public static byte com_right_r;
	public static Object initialize_error_table_r;
	public static Object free_error_table;
	public static int et_list_lock;
	public static int et_list_unlock;
	public static byte[] br_fat16_0x3e = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static byte[] track_format2str = new byte[/*
	    Copyright (C) 2005, 2006, 2008, 2012 Rocky Bernstein <rocky@gnu.org>
	
	    This program is free software: you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation, either version 3 of the License, or
	    (at your option) any later version.
	
	    This program is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*//** \file track.h
	 *  \brief  The top-level header for track-related libcdio calls.
	 *//* __cplusplus *//*! Printable tags for track_format_t enumeration.  */6/**< Audio track, e.g. CD-DA *//**< CD-i. How this is different from DATA below? *//**< Mode2 of some sort *//**< Mode1 of some sort *//**< Playstation CD. Like audio but only 2336 bytes
	                           *   of user data.
	                           *//**< Dunno what is, or some other error. */];
	public static  cdio_get_first_track_num = new ();
	public static  cdio_get_last_track_num = new ();
	public static  cdio_get_track = new ();
	public static int cdio_get_track_channels;
	public static track_flag_t cdio_get_track_copy_permit = new track_flag_t();
	public static track_format_t cdio_get_track_format = new track_format_t();
	public static  cdio_get_track_green = new ();
	public static  cdio_get_track_last_lsn = new ();
	public static  cdio_get_track_lba = new ();
	public static  cdio_get_track_lsn = new ();
	public static  cdio_get_track_pregap_lba = new ();
	public static  cdio_get_track_pregap_lsn = new ();
	public static byte cdio_get_track_isrc;
	public static  cdio_get_track_msf = new ();
	public static track_flag_t cdio_get_track_preemphasis = new track_flag_t();
	public static int cdio_get_track_sec_count;
	public static byte[] br_fat32kos_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static int PRAGMA_BEGIN_PACKED;
	public static ea_name_index[] ea_names = new ea_name_index[]{new ea_name_index(3, "system.posix_acl_default"), new ea_name_index(2, "system.posix_acl_access"), new ea_name_index(8, "system.richacl"), new ea_name_index(6, "security."), new ea_name_index(4, "trusted."), new ea_name_index(7, "system."), new ea_name_index(1, "user."), new ea_name_index(0, ((Object)0))};
	public static byte[] mbr_zero_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* First 446 bytes of a zeroed MBR*/-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static PVOID RtlCreateHeap_t = new PVOID();
	public static RtlCreateHeap_t pfRtlCreateHeap = /*
	 * Rufus: The Reliable USB Formatting Utility
	 * Process search functionality
	 *
	 * Modified from Process Hacker:
	 *   https://github.com/processhacker2/processhacker2/
	 * Copyright Â© 2017-2019 Pete Batard <pete@akeo.ie>
	 * Copyright Â© 2017 dmex
	 * Copyright Â© 2009-2016 wj32
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */((Object)0);
	public static PVOID RtlDestroyHeap_t = new PVOID();
	public static RtlDestroyHeap_t pfRtlDestroyHeap = ((Object)0);
	public static PVOID RtlAllocateHeap_t = new PVOID();
	public static RtlAllocateHeap_t pfRtlAllocateHeap = ((Object)0);
	public static BOOLEAN RtlFreeHeap_t = new BOOLEAN();
	public static RtlFreeHeap_t pfRtlFreeHeap = ((Object)0);
	public static NTSTATUS NtQuerySystemInformation_t = new NTSTATUS();
	public static NtQuerySystemInformation_t pfNtQuerySystemInformation = ((Object)0);
	public static NTSTATUS NtQueryInformationFile_t = new NTSTATUS();
	public static NtQueryInformationFile_t pfNtQueryInformationFile = ((Object)0);
	public static NTSTATUS NtQueryInformationProcess_t = new NTSTATUS();
	public static NtQueryInformationProcess_t pfNtQueryInformationProcess = ((Object)0);
	public static NTSTATUS NtWow64QueryInformationProcess64_t = new NTSTATUS();
	public static NtWow64QueryInformationProcess64_t pfNtWow64QueryInformationProcess64 = ((Object)0);
	public static NTSTATUS NtWow64ReadVirtualMemory64_t = new NTSTATUS();
	public static NtWow64ReadVirtualMemory64_t pfNtWow64ReadVirtualMemory64 = ((Object)0);
	public static NTSTATUS NtQueryObject_t = new NTSTATUS();
	public static NtQueryObject_t pfNtQueryObject = ((Object)0);
	public static NTSTATUS NtDuplicateObject_t = new NTSTATUS();
	public static NtDuplicateObject_t pfNtDuplicateObject = ((Object)0);
	public static NTSTATUS NtOpenProcess_t = new NTSTATUS();
	public static NtOpenProcess_t pfNtOpenProcess = ((Object)0);
	public static NTSTATUS NtOpenProcessToken_t = new NTSTATUS();
	public static NtOpenProcessToken_t pfNtOpenProcessToken = ((Object)0);
	public static NTSTATUS NtAdjustPrivilegesToken_t = new NTSTATUS();
	public static NtAdjustPrivilegesToken_t pfNtAdjustPrivilegesToken = ((Object)0);
	public static BOOL QueryFullProcessImageNameW_t = new BOOL();
	public static QueryFullProcessImageNameW_t pfQueryFullProcessImageNameW = ((Object)0);
	public static PVOID PhHeapHandle = ((Object)0)/*
	 * Convert an NT Status to an error message
	 *
	 * \param Status An operattonal status.
	 *
	 * \return An error message string.
	 *
	 */;
	public static wchar_t _wHandleName = new wchar_t();
	public static BOOL _bPartialMatch = new BOOL();
	public static BOOL _bIgnoreSelf = new BOOL();
	public static BOOL _bQuiet = new BOOL();
	public static BYTE access_mask = new BYTE();
	public static error_table et_ext2_error_table = new error_table();
	public static Object initialize_ext2_error_table;
	public static Object initialize_ext2_error_table_r;
	public static int[][] __mon_yday = new int[][]{{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, /* Normal years.  */.DAYS_PER_YEAR}, {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, .DAYS_PER_YEAR + /* Leap years.  */1}};
	public static [] year_seconds = new []{(.SECS_PER_DAY * (.DAYS_PER_YEAR * 0 + 0) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 1 + 0) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 2 + 0) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 3 + 1) + /*1970*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 4 + 1) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 5 + 1) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 6 + 1) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 7 + 2) + /*1974*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 8 + 2) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 9 + 2) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 10 + 2) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 11 + 3) + /*1978*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 12 + 3) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 13 + 3) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 14 + 3) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 15 + 4) + /*1982*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 16 + 4) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 17 + 4) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 18 + 4) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 19 + 5) + /*1986*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 20 + 5) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 21 + 5) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 22 + 5) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 23 + 6) + /*1990*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 24 + 6) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 25 + 6) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 26 + 6) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 27 + 7) + /*1994*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 28 + 7) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 29 + 7) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 30 + 7) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 31 + 8) + /*1998*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 32 + 8) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 33 + 8) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 34 + 8) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 35 + 9) + /*2002*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 36 + 9) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 37 + 9) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 38 + 9) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 39 + 10) + /*2006*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 40 + 10) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 41 + 10) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 42 + 10) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 43 + 11) + /*2010*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 44 + 11) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 45 + 11) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 46 + 11) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 47 + 12) + /*2014*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 48 + 12) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 49 + 12) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 50 + 12) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 51 + 13) + /*2018*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 52 + 13) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 53 + 13) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 54 + 13) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 55 + 14) + /*2022*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 56 + 14) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 57 + 14) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 58 + 14) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 59 + 15) + /*2026*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 60 + 15) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 61 + 15) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 62 + 15) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 63 + 16) + /*2030*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 64 + 16) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 65 + 16) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 66 + 16) + 0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 67 + 17) + /*2034*/0), (.SECS_PER_DAY * (.DAYS_PER_YEAR * 68 + 17) + /*2038*/0)};
	public static int crc16_t;
	public static crc16_t ext2fs_crc16 = new crc16_t();
	public static int contains_data;
	public static int read_data;
	public static int write_data;
	public static int64_t write_sectors = new int64_t();
	public static int64_t read_sectors = new int64_t();
	public static byte[] br_fat32ros_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static int ssize_t;
	public static DWORD DownloadStatus = new DWORD();
	public static BOOL close_fido_cookie_prompts = new BOOL();
	public static DWORD error_code = new DWORD();
	public static DWORD fido_len = 0;
	public static BOOL force_update_check = 0/*
	 * FormatMessage does not handle internet errors
	 * https://docs.microsoft.com/en-us/windows/desktop/wininet/wininet-errors
	 */;
	public static Object set_bytes_per_sector;
	public static uint32_t read_windows_disk_signature = new uint32_t();
	public static int write_windows_disk_signature;
	public static uint16_t read_mbr_copy_protect_bytes = new uint16_t();
	public static byte read_mbr_copy_protect_bytes_explained;
	public static int is_br;
	public static int is_lilo_br;
	public static int is_dos_mbr;
	public static int is_dos_f2_mbr;
	public static int is_95b_mbr;
	public static int is_2000_mbr;
	public static int is_vista_mbr;
	public static int is_win7_mbr;
	public static int is_rufus_mbr;
	public static int is_rufus_gpt_mbr;
	public static int is_reactos_mbr;
	public static int is_grub4dos_mbr;
	public static int is_grub2_mbr;
	public static int is_kolibrios_mbr;
	public static int is_syslinux_mbr;
	public static int is_syslinux_gpt_mbr;
	public static int is_zero_mbr;
	public static int is_zero_mbr_not_including_disk_signature_or_copy_protect;
	public static int write_dos_mbr;
	public static int write_95b_mbr;
	public static int write_2000_mbr;
	public static int write_vista_mbr;
	public static int write_win7_mbr;
	public static int write_rufus_mbr;
	public static int write_rufus_gpt_mbr;
	public static int write_reactos_mbr;
	public static int write_grub4dos_mbr;
	public static int write_grub2_mbr;
	public static int write_kolibrios_mbr;
	public static int write_syslinux_mbr;
	public static int write_syslinux_gpt_mbr;
	public static int write_zero_mbr;
	public static int is_ntfs_fs;
	public static int is_ntfs_br;
	public static int entire_ntfs_br_matches;
	public static int write_ntfs_br;
	public static DWORD NtfsSectGetVolumeHandle = new DWORD();
	public static DWORD NtfsSectGetVolumePartitionLba = new DWORD();
	public static int udf_checktag;
	public static  uint32_t = new ();
	public static  uint16_t = new ();
	public static  uint64_t = new ();
	public static byte[] ms_kb1 = new byte[]{"be", "br", "cf", "cz", "dk", "fr", "gr", "hu", "it", /*
	 * Rufus: The Reliable USB Formatting Utility
	 * DOS keyboard locale setup
	 * Copyright Â© 2011-2013 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 *//* Memory leaks detection - define _CRTDBG_MAP_ALLOC as preprocessor macro *//*
	 * Note: if you want a book that can be used as a keyboards and codepages bible, I
	 * would recommend the "OS/2 Warp Server for e-business - Keyboards and Codepages".
	 * See http://www.borgendale.com/keyboard.pdf
	 *//* WinME DOS keyboard 2 letter codes & supported keyboard ID(s), as retrieved
	 * from the Millenium disk image in diskcopy.dll on a Windows 7 system
	 *
	 *	KEYBOARD.SYS
	 *		GR 129*
	 *		SP 172
	 *		PO 163*
	 *		FR 120*, 189*
	 *		DK 159*
	 *		SG 000*
	 *		IT 141*, 142*
	 *		UK 166*, 168*
	 *		SF 150*
	 *		BE 120*
	 *		NL 143*
	 *		NO 155*
	 *		CF 058*
	 *		SV 153*
	 *		SU 153
	 *		LA 171*
	 *		BR 274*
	 *		PL 214*
	 *		CZ 243*
	 *		SL 245*
	 *		YU 234*
	 *		HU 208*
	 *		US/XX 103*
	 *		JP defines ID:194 but points to SP entry
	 *
	 *	KEYBRD2.SYS
	 *		GR 129*
	 *		RU 441
	 *		IT 141*, 142*
	 *		UK 166*, 168*
	 *		NO 155*
	 *		CF 058*
	 *		SV 153*
	 *		SU 153
	 *		BR 274*, 275*
	 *		BG 442*
	 *		PL 214*
	 *		CZ 243*
	 *		SL 245*
	 *		YU 234*
	 *		YC 118
	 *		HU 208*
	 *		RO 333
	 *		IS 161*
	 *		TR 179*, 440*
	 *		GK 319*
	 *		US/XX 103*
	 *
	 *	KEYBRD3.SYS
	 *		GR 129*
	 *		SP 172*
	 *		FR 189*
	 *		DK 159*
	 *		SG 000*
	 *		IT 141*
	 *		UK 166*
	 *		SF 150*
	 *		BE 120*
	 *		NL 143*
	 *		SV 153*
	 *		SU 153
	 *		PL 214*
	 *		CZ 243*
	 *		SL 245*
	 *		YU 234*
	 *		HU 208*
	 *		RU 091*, 092*, 093*, 341*
	 *		UR 094*, 095*, 096*
	 *		BL 097*, 098*, 099*
	 *		US/XX 103*
	 *		JP defines ID:194 but points to SP entry
	 *
	 *	KEYBRD4.SYS
	 *		GK 101*, 319*, 220*
	 *		PL 214*
	 *		ET 425*
	 *		HE 400*
	 *		AR 401*, 402*, 403*
	 *		US/XX 103*
	 *//*
	 * The following lists the keyboard code that are supported in each
	 * of the WinMe DOS KEYBOARD.SYS, KEYBRD2.SYS, ...
	 */"la", "nl", "no", "pl", "po", "sf", "sg", "sl", "sp", "su", "sv", "uk", "us", "yu"};
	public static byte[] ms_kb2 = new byte[]{"bg", "br", "cf", "cz", "gk", "gr", "hu", "is", "it", "no", "pl", "ro", "ru", "sl", "su", "sv", "tr", "uk", "us", "yc", "yu"};
	public static byte[] ms_kb3 = new byte[]{"be", "bl", "cz", "dk", "fr", "gr", "hu", "it", "nl", "pl", "ru", "sf", "sg", "sl", "sp", "su", "sv", "uk", "ur", "us", "yu"};
	public static byte[] ms_kb4 = new byte[]{"ar", "et", "gk", "he", "pl", "us"/*
	 * The following lists the keyboard code that are supported in each
	 * of the FreeDOS DOS KEYBOARD.SYS, KEYBRD2.SYS, ...
	 */};
	public static byte[] fd_kb1 = new byte[]{"be", "br", "cf", "co", "cz", "dk", "dv", "fr", "gr", "hu", "it", "jp", "la", "lh", "nl", "no", "pl", "po", "rh", "sf", "sg", "sk", "sp", "su", "sv", "uk", "us", "yu"};
	public static byte[] fd_kb2 = new byte[]{"bg", "ce", "gk", "is", "ro", "ru", "rx", "tr", "tt", "yc"};
	public static byte[] fd_kb3 = new byte[]{"az", "bl", "et", "fo", "hy", "il", "ka", "kk", "ky", "lt", "lv", "mk", "mn", "mt", "ph", "sq", "tj", "tm", "ur", "uz", "vi"};
	public static byte[] fd_kb4 = new byte[]{"ar", "bn", "bx", "fx", "ix", "kx", "ne", "ng", "px", "sx", "ux"};
	public static kb_default[] kbdrv_data = new kb_default[]{new kb_default("keyboard.sys", 437), new kb_default("keybrd2.sys", 850), new kb_default("keybrd3.sys", 850), new kb_default("keybrd4.sys", 853)};
	public static kb_list[] ms_kb_list = new kb_list[]{new kb_list((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), ms_kb1), new kb_list((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), ms_kb2), new kb_list((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), ms_kb3), new kb_list((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), ms_kb4)};
	public static kb_list[] fd_kb_list = new kb_list[]{new kb_list((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), fd_kb1), new kb_list((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), fd_kb2), new kb_list((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), fd_kb3), new kb_list((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), fd_kb4)};
	public static byte[][] kb_hr_list = new byte[][]{{"ar", "Arabic"}, {"bg", "Bulgarian"}, {"ch", "Chinese"}, {"cz", "Czech"}, {"dk", "Danish"}, {"gr", "German"}, {"sg", "Swiss-German"}, {"gk", "Greek"}, {"us", "US-English"}, {"uk", "UK-English"}, {"cf", "CA-French"}, {"dv", "US-Dvorak"}, {"lh", "US-Dvorak (LH)"}, {"rh", "US-Dvorak (RH)"}, {"sp", "Spanish"}, {"la", "Latin-American"}, {"su", "Finnish"}, {"fr", "French"}, {"be", "Belgian-French"}, {"sf", "Swiss-French"}, {"il", "Hebrew"}, {"hu", "Hungarian"}, {"is", "Icelandic"}, {"it", "Italian"}, {"jp", "Japanese"}, {"nl", "Dutch"}, {"no", "Norwegian"}, {"pl", "Polish"}, {"br", "Brazilian"}, {"po", "Portuguese"}, {"ro", "Romanian"}, {"ru", "Russian"}, {"yu", "YU-Latin"}, {"yc", "YU-Cyrillic"}, {"sl", "Slovak"}, {"sq", "Albanian"}, {"sv", "Swedish"}, {"tr", "Turkish"}, {"ur", "Ukrainian"}, {"bl", "Belarusian"}, {"et", "Estonian"}, {"lv", "Latvian"}, {"lt", "Lithuanian"}, {"tj", "Tajik"}, {"vi", "Vietnamese"}, {"hy", "Armenian"}, {"az", "Azeri"}, {"mk", "Macedonian"}, {"ka", "Georgian"}, {"fo", "Faeroese"}, {"mt", "Maltese"}, {"kk", "Kazakh"}, {"ky", "Kyrgyz"}, {"uz", "Uzbek"}, {"tm", "Turkmen"}, {"tt", "Tatar"}};
	public static cp_list[] cp_hr_list = new cp_list[]{new cp_list(113, "Lat-Yugoslavian"), new cp_list(437, "US-English"), new cp_list(667, "Polish"), new cp_list(668, "Polish (Alt)"), new cp_list(708, "Arabic (708)"), new cp_list(709, "Arabic (709)"), new cp_list(710, "Arabic (710)"), new cp_list(720, "Arabic (DOS)"), new cp_list(737, "Greek (DOS)"), new cp_list(770, "Baltic"), new cp_list(771, "Cyr-Russian (KBL)"), new cp_list(772, "Cyr-Russian"), new cp_list(773, "Baltic Rim (Old)"), new cp_list(774, "Lithuanian"), new cp_list(775, "Baltic Rim"), new cp_list(777, "Acc-Lithuanian (Old)"), new cp_list(778, "Acc-Lithuanian"), new cp_list(790, "Mazovian-Polish"), new cp_list(808, "Cyr-Russian (Euro)"), new cp_list(848, "Cyr-Ukrainian (Euro)"), new cp_list(849, "Cyr-Belarusian (Euro)"), new cp_list(850, "Western-European"), new cp_list(851, "Greek"), new cp_list(852, "Central-European"), new cp_list(853, "Southern-European"), new cp_list(855, "Cyr-South-Slavic"), new cp_list(856, "Hebrew II"), new cp_list(857, "Turkish"), new cp_list(858, "Western-European (Euro)"), new cp_list(859, "Western-European (Alt)"), new cp_list(860, "Portuguese"), new cp_list(861, "Icelandic"), new cp_list(862, "Hebrew"), new cp_list(863, "Canadian-French"), new cp_list(864, "Arabic"), new cp_list(865, "Nordic"), new cp_list(866, "Cyr-Russian"), new cp_list(867, "Czech Kamenicky"), new cp_list(869, "Modern Greek"), new cp_list(872, "Cyr-South-Slavic (Euro)"), new cp_list(874, "Thai"), new cp_list(895, "Czech Kamenicky (Alt)"), new cp_list(899, "Armenian"), new cp_list(932, "Japanese"), new cp_list(936, "Chinese (Simplified)"), new cp_list(949, "Korean"), new cp_list(950, "Chinese (Traditional)"), new cp_list(991, "Mazovian-Polish (Zloty)"), new cp_list(1116, "Estonian"), new cp_list(1117, "Latvian"), new cp_list(1118, "Lithuanian"), new cp_list(1119, "Cyr-Russian (Alt)"), new cp_list(1125, "Cyr-Ukrainian"), new cp_list(1131, "Cyr-Belarusian"), new cp_list(1250, "Central European"), new cp_list(1251, "Cyrillic"), new cp_list(1252, "Western European"), new cp_list(1253, "Greek"), new cp_list(1254, "Turkish"), new cp_list(1255, "Hebrew"), new cp_list(1256, "Arabic"), new cp_list(1257, "Baltic"), new cp_list(1258, "Vietnamese"), new cp_list(1361, "Korean"), new cp_list(3012, "Cyr-Latvian"), new cp_list(3021, "Cyr-Bulgarian"), new cp_list(3845, "Hungarian"), new cp_list(3846, "Turkish"), new cp_list(3848, "Brazilian (ABICOMP)"), new cp_list(30000, "Saami"), new cp_list(30001, "Celtic"), new cp_list(30002, "Cyr-Tajik"), new cp_list(30003, "Latin American"), new cp_list(30004, "Greenlandic"), new cp_list(30005, "Nigerian"), new cp_list(30006, "Vietnamese"), new cp_list(30007, "Latin"), new cp_list(30008, "Cyr-Ossetian"), new cp_list(30009, "Romani"), new cp_list(30010, "Cyr-Moldovan"), new cp_list(30011, "Cyr-Chechen"), new cp_list(30012, "Cyr-Siberian"), new cp_list(30013, "Cyr-Turkic"), new cp_list(30014, "Cyr-Finno-Ugric"), new cp_list(30015, "Cyr-Khanty"), new cp_list(30016, "Cyr-Mansi"), new cp_list(30017, "Cyr-Northwestern"), new cp_list(30018, "Lat-Tatar"), new cp_list(30019, "Lat-Chechen"), new cp_list(30020, "Low-Saxon and Frisian"), new cp_list(30021, "Oceanian"), new cp_list(30022, "First Nations"), new cp_list(30023, "Southern African"), new cp_list(30024, "North & East African"), new cp_list(30025, "Western African"), new cp_list(30026, "Central African"), new cp_list(30027, "Beninese"), new cp_list(30028, "Nigerian (Alt)"), new cp_list(30029, "Mexican"), new cp_list(30030, "Mexican (Alt)"), new cp_list(30031, "Northern-European"), new cp_list(30032, "Nordic"), new cp_list(30033, "Crimean-Tatar (Hryvnia)"), new cp_list(30034, "Cherokee"), new cp_list(30039, "Cyr-Ukrainian (Hryvnia)"), new cp_list(30040, "Cyr-Russian (Hryvnia)"), new cp_list(58152, "Cyr-Kazakh (Euro)"), new cp_list(58210, "Cyr-Azeri"), new cp_list(58335, "Kashubian"), new cp_list(59234, "Cyr-Tatar"), new cp_list(59829, "Georgian"), new cp_list(60258, "Lat-Azeri"), new cp_list(60853, "Georgian (Alt)"), new cp_list(62306, "Cyr-Uzbek")};
	public static [] CDIO_SECTOR_SYNC_HEADER = new []{0, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, 0};
	public static  SetDOSLocale = new ();
	public static Object _cdio_memdup;
	public static byte _cdio_strdup_upper;
	public static byte _cdio_strdup_fixpath;
	public static Object _cdio_strfreev;
	public static size_t _cdio_strlenv = new size_t();
	public static byte _cdio_strsplit;
	public static  cdio_to_bcd8 = new ();
	public static  cdio_from_bcd8 = new ();
	public static byte cdio_realpath;
	public static int[] section_control_ids = new int[]{/*
	 * Rufus: The Reliable USB Formatting Utility
	 * UI element lists
	 * Copyright Â© 2018 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */2016, 2017, 2018};
	public static int[] section_vpos = new int[/*Error: Function owner not recognized*/ARRAYSIZE(section_control_ids)];
	public static int[] image_option_move_ids = new int[]{2001, 1004, 2013, 1017, 2005, 1043, 1022, 1021, 1016, 1020, 2017, 2004, 1007, 2002, 1002, 2003, 1005, 1044, 1008, 1009, 1012, 1015, 2018, 1010, 1052, 1054, 1047, 1013, 1003, 2, 1006, 1023};
	public static int[][] image_option_toggle_ids = new int[][]{{2014, -1024}, {1026, -1024}, {1027, -1024}, {1018, -1024}, {1019, -1024}};
	public static int[] advanced_device_move_ids = new int[]{1022, 1021, 1016, 2017, 2004, 1007, 2002, 1002, 2003, 1005, 1044, 1008, 1009, 1012, 1015, 2018, 1010, 1052, 1054, 1047, 1013, 1003, 2, 1006, 1023};
	public static int[] advanced_device_toggle_ids = new int[]{1045, 1022, 1021, 1016, 1020};
	public static int[] advanced_format_move_ids = new int[]{2018, 1010, 1052, 1054, 1047, 1013, 1003, 2, 1006, 1023};
	public static int[] advanced_format_toggle_ids = new int[]{1008, 1009, 1012, 1015};
	public static int[] main_button_ids = new int[]{1014, 1003, 2};
	public static int[] full_width_controls = new int[]{2000, 2015, 2014, 1026, 2004, 1007, 1028, 1022, 1021, 1029, 1008, 1015, 1010};
	public static int[] full_width_checkboxes = new int[]{1022, 1021, 1008, 1015};
	public static int[] half_width_ids = new int[]{1009, 1016, 2001, 1004, 1002, 2013, 1017, 1020, 2003, 1005, 1012};
	public static int[][] adjust_dpi_ids = new int[][]{{2000, 1001, 1045, 0, 0}, {2015, 1011, 1046, 1014, 0}, {2014, 1026, 1027, 1018, 1019}, {2001, 1004, 2013, 1017, 2005}, {1043, 0, 0, 0, 0}, {1022, 0, 0, 0, 0}, {1021, 0, 0, 0, 0}, {1016, 1020, 0, 0, 0}, {2017, 0, 0, 0, 0}, {2004, 1007, 0, 0, 0}, {2002, 1002, 2003, 1005, 0}, {1044, 0, 0, 0, 0}, {1008, 0, 0, 0, 0}, {1015, 0, 0, 0, 0}, {1009, 1012, 0, 0, 0}, {2018, 0, 0, 0, 0}, {1010, 0, 0, 0, 0}, {1047, 1013, 1003, 2, 0}};
	public static int[] multitoolbar_icons = new int[]{121, 122, 123, 124};
	public static BOOLEAN FILE_SYSTEM_CALLBACK = new BOOLEAN();
	public static Object FormatEx_t;
	public static LONG Chkdsk_t = new LONG();
	public static BOOLEAN EnableVolumeCompression_t = new BOOLEAN();
	public static  nt_io_manager = new ();
	public static DWORD ext2_last_winerror = new DWORD();
	public static byte sfd_name = /*
	 * Rufus: The Reliable USB Formatting Utility
	 * Drive access function calls
	 * Copyright Â© 2011-2019 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */"Super Floppy Disk";
	public static byte groot_name = "\\\\?\\GLOBALROOT";
	public static size_t groot_len = /*Error: sizeof expression not supported yet*/ - 1;
	public static GUID PARTITION_BASIC_DATA_GUID = new GUID(-1024, -1024, -1024, new GUID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static GUID PARTITION_MSFT_RESERVED_GUID = new GUID(-1024, -1024, -1024, new GUID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static GUID PARTITION_SYSTEM_GUID = new GUID(-1024, -1024, -1024, new GUID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static GUID PARTITION_LINUX_HOME_GUID = new GUID(-1024, -1024, -1024, new GUID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static IID CLSID_VdsLoader = new IID(-1024, -1024, -1024, new IID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static IID IID_IVdsServiceLoader = new IID(-1024, -1024, -1024, new IID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static IID IID_IVdsProvider = new IID(-1024, -1024, -1024, new IID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static IID IID_IVdsSwProvider = new IID(-1024, -1024, -1024, new IID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static IID IID_IVdsPack = new IID(-1024, -1024, -1024, new IID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static IID IID_IVdsDisk = new IID(-1024, -1024, -1024, new IID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static IID IID_IVdsAdvancedDisk = new IID(-1024, -1024, -1024, new IID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static IID IID_IVdsVolume = new IID(-1024, -1024, -1024, new IID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static IID IID_IVdsVolumeMF3 = new IID(-1024, -1024, -1024, new IID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static  NtQueryVolumeInformationFile_t = new ();
	public static NtQueryVolumeInformationFile_t pfNtQueryVolumeInformationFile = ((Object)0/*
	 * Globals
	 */);
	public static RUFUS_DRIVE_INFO SelectedDrive = new RUFUS_DRIVE_INFO();
	public static uint64_t[] partition_offset = new uint64_t();
	public static uint64_t persistence_size = 0/*
	 * The following methods get or set the AutoMount setting (which is different from AutoRun)
	 * Rufus needs AutoMount to be set as the format process may fail for fixed drives otherwise.
	 * See https://github.com/pbatard/rufus/issues/386.
	 *
	 * Reverse engineering diskpart and mountvol indicates that the former uses the IVdsService
	 * ClearFlags()/SetFlags() to set VDS_SVF_AUTO_MOUNT_OFF whereas mountvol on uses
	 * IOCTL_MOUNTMGR_SET_AUTO_MOUNT on "\\\\.\\MountPointManager".
	 * As the latter is MUCH simpler this is what we'll use too
	 */;
	public static long iso9660_seek_read_framesize;
	public static  stat_root_t = new ();
	public static  stat_traverse_t = new ();
	public static  iso9660_readdir_t = new ();
	public static byte[] br_fat32ros_0x1c00 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static long unpacker_t;
	public static boolean bled_initialized = false;
	public static unpacker_t[] unpacker = new unpacker_t[]{unpack_none, unpack_zip_stream, unpack_Z_stream, unpack_gz_stream, unpack_lzma_stream, unpack_bz2_stream, unpack_xz_stream, unpack_none};
	public static cdio_log_level_t cdio_loglevel_default = new cdio_log_level_t();
	public static Object cdio_log_handler_t;
	public static Object cdio_default_log_handler;
	public static cdio_log_handler_t cdio_log_set_handler = new cdio_log_handler_t();
	public static Object cdio_log;
	public static Object cdio_debug;
	public static Object cdio_info;
	public static Object cdio_warn;
	public static Object cdio_error;
	public static IVdsServiceLoader IVdsServiceLoader = new IVdsServiceLoader();
	public static IVdsService IVdsService = new IVdsService();
	public static IVdsProvider IVdsProvider = new IVdsProvider();
	public static IVdsSwProvider IVdsSwProvider = new IVdsSwProvider();
	public static IEnumVdsObject IEnumVdsObject = new IEnumVdsObject();
	public static IVdsPack IVdsPack = new IVdsPack();
	public static IVdsDisk IVdsDisk = new IVdsDisk();
	public static IVdsAdvancedDisk IVdsAdvancedDisk = new IVdsAdvancedDisk();
	public static IVdsAdviseSink IVdsAdviseSink = new IVdsAdviseSink();
	public static IVdsAsync IVdsAsync = new IVdsAsync();
	public static IVdsVolume IVdsVolume = new IVdsVolume();
	public static IVdsVolumeMF3 IVdsVolumeMF3 = new IVdsVolumeMF3();
	public static BOOL SetAutoMount = new BOOL();
	public static BOOL GetAutoMount = new BOOL();
	public static byte GetPhysicalName;
	public static BOOL DeletePartitions = new BOOL();
	public static HANDLE GetPhysicalHandle = new HANDLE();
	public static byte GetLogicalName;
	public static byte AltGetLogicalName;
	public static BOOL WaitForLogical = new BOOL();
	public static HANDLE GetLogicalHandle = new HANDLE();
	public static int GetDriveNumber;
	public static BOOL GetDriveLetters = new BOOL();
	public static UINT GetDriveTypeFromIndex = new UINT();
	public static byte GetUnusedDriveLetter;
	public static BOOL GetDriveLabel = new BOOL();
	public static uint64_t GetDriveSize = new uint64_t();
	public static BOOL IsMediaPresent = new BOOL();
	public static BOOL AnalyzeMBR = new BOOL();
	public static BOOL AnalyzePBR = new BOOL();
	public static BOOL GetDrivePartitionData = new BOOL();
	public static BOOL UnmountVolume = new BOOL();
	public static BOOL MountVolume = new BOOL();
	public static BOOL AltUnmountVolume = new BOOL();
	public static byte AltMountVolume;
	public static BOOL RemountVolume = new BOOL();
	public static BOOL CreatePartition = new BOOL();
	public static BOOL InitializeDisk = new BOOL();
	public static BOOL RefreshDriveLayout = new BOOL();
	public static byte GetPartitionType;
	public static byte GetExtFsLabel;
	public static BOOL GetDevices = new BOOL();
	public static BOOL CyclePort = new BOOL();
	public static int CycleDevice;
	public static BOOL RefreshLayout = new BOOL();
	public static BOOL GetOpticalMedia = new BOOL();
	public static int rb_insert_extent;
	public static Object rb_get_new_extent;
	public static DWORD DEVNODE = new DWORD();
	public static DWORD DEVINST = new DWORD();
	public static DEVNODE PDEVNODE = new DEVNODE();
	public static DEVNODE PDEVINST = new DEVNODE();
	public static DWORD RETURN_TYPE = new DWORD();
	public static RETURN_TYPE CONFIGRET = new RETURN_TYPE();
	public static CHAR DEVINSTID_A = new CHAR();
	public static CONFIGRET CM_Get_Device_IDA = new CONFIGRET();
	public static CONFIGRET CM_Get_Device_ID_List_SizeA = new CONFIGRET();
	public static CONFIGRET CM_Get_Device_ID_ListA = new CONFIGRET();
	public static CONFIGRET CM_Locate_DevNodeA = new CONFIGRET();
	public static CONFIGRET CM_Get_Child = new CONFIGRET();
	public static CONFIGRET CM_Get_Parent = new CONFIGRET();
	public static CONFIGRET CM_Get_Sibling = new CONFIGRET();
	public static CONFIGRET CM_Get_DevNode_Status = new CONFIGRET();
	public static int PF_TYPE_DECL;
	public static GUID GUID_DEVINTERFACE_USB_HUB = new GUID(-1024, -1024, -1024, new GUID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
	public static int ext2fs_process_dir_block;
	public static  ext2fs_inline_data_ea_remove = new ();
	public static  ext2fs_inline_data_expand = new ();
	public static int ext2fs_inline_data_dir_iterate;
	public static ext2fs_progress_ops ext2fs_numeric_progress_ops = new ext2fs_progress_ops();
	public static Object ext2fs_numeric_progress_init;
	public static Object ext2fs_numeric_progress_update;
	public static Object ext2fs_numeric_progress_close;
	public static int ext2fs_mark_generic_bmap;
	public static int ext2fs_unmark_generic_bmap;
	public static int ext2fs_test_generic_bmap;
	public static Object ext2fs_warn_bitmap32;
	public static int ext2fs_mem_is_zero;
	public static int ext2fs_file_block_offset_too_big;
	public static Object ext2_exit_fn;
	public static  ext2fs_add_exit_fn = new ();
	public static  ext2fs_remove_exit_fn = new ();
	public static block_entry block_entry_t = new block_entry();
	public static BOOL UpdateDriverForPlugAndPlayDevicesW = new BOOL();
	public static xz_dec_lzma2 xz_dec_lzma2_create = new xz_dec_lzma2();
	public static xz_ret xz_dec_lzma2_reset;
	public static xz_ret xz_dec_lzma2_run;
	public static Object xz_dec_lzma2_end;
	public static xz_dec_bcj xz_dec_bcj_create = new xz_dec_bcj();
	public static xz_ret xz_dec_bcj_reset;
	public static xz_ret xz_dec_bcj_run;
	public static byte[] mbr_kolibri_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* First 440 bytes of MBR from KolibriOS */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static byte[] mbr_grub2_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /*
	 * First 432 bytes of MBR from Grub2 (boot.img), with 2 bytes NOPed @0x66
	 * as per grub2's setup.c comments:
	 *   If DEST_DRIVE is a hard disk, enable the workaround, which is
	 *   for buggy BIOSes which don't pass boot drive correctly. Instead,
	 *   they pass 0x00 or 0x01 even when booted from 0x80.
	 */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static uint8_t[] sha256db = new uint8_t[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /*
	 * Rufus: The Reliable USB Formatting Utility
	 * DB of the hash values we know for downloadable content (GRUB, Syslinux, etc.)
	 * Copyright Â© 2016-2019 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 *//*
	 * NB: Table data was generated from the files/ directory on the server with:
	 * find . -not -name "*.txt" -not -name "*.sig" -not -name "*.sh" -not -name "*pre*" -type f -print0 | xargs -0 sha256sum | sort | uniq -w 64 | awk -F '' '{ printf "    "; for(i=1; i<=64; i+=2) {printf "0x%s%s, ", $i,$(i+1);}} {print "// " substr($0,69)}'
	 */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static [] crc16_table = new []{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024/**
	 * Compute the CRC-16 for the data buffer
	 *
	 * @param crc     previous CRC value
	 * @param buffer  data pointer
	 * @param len     number of bytes in the buffer
	 * @return        the updated CRC value
	 */};
	public static iso_rock_enums iso_rock_enums;
	public static  iso_rock_nm_flag = new ();
	public static  iso_rock_sl_flag = new ();
	public static  iso_rock_tf_flag = new ();
	public static int nWindowsVersion = /*
	 * Rufus: The Reliable USB Formatting Utility
	 * Standard Windows function calls
	 * Copyright Â© 2013-2019 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */WindowsVersion.WINDOWS_UNDEFINED;
	public static int nWindowsBuildNumber = -1;
	public static byte[] WindowsVersionStr = "Windows ";
	public static byte[] br_fat32_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* br_fat32_0x52.h
	//
	// ANI
	// substring gmbh/tw 14.9.04 
	// modified cluster code 0x3f0 to support FreeDOS
	*/-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static byte[] br_fat12_0x3e = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static uint8_t ubyte = new uint8_t();
	public static msf_s msf_t = new msf_s();
	public static byte cdio_utf8_t;
	public static int bitfield_t;
	public static int32_t lba_t = new int32_t();
	public static int32_t lsn_t = new int32_t();
	public static uint8_t track_t = new uint8_t();
	public static uint8_t session_t = new uint8_t();
	public static byte[] cdio_mcn_t = new byte[/*!
	    Constant for invalid LSN
	  *//*!
	    Number of ASCII bytes in a media catalog number (MCN).
	    We include an extra 0 byte so these can be used as C strings.
	  */13 + /*!
	    Type to hold ASCII bytes in a media catalog number (MCN).
	    We include an extra 0 byte so these can be used as C strings.
	  */1/*!
	    Number of ASCII bytes in International Standard Recording Codes (ISRC)
	  */];
	public static byte[] cdio_isrc_t = new byte[12 + /*!
	    Type to hold ASCII bytes in a ISRC.
	    We include an extra 0 byte so these can be used as C strings.
	  */1/*!
	    track flags
	    Q Sub-channel Control Field (4.2.3.3)
	  */];
	public static int cdio_fs_anal_t;
	public static Object CdioDataFree_t;
	public static byte[] mbr_2000_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* First 446 bytes of MBR from Windows 2000, XP and 2003 *//* This is English version. Bytes 0x12c onwards vary with language. *//* Last three bytes 1b5-1b7 point to language-specific messages.    *//* Support of other languages is an exercise for the reader!        *//* see: http://thestarman.pcministry.com/asm/mbr/Win2kmbr.htm       */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024/* Next four bytes used for Windows Disk Signature / Drive serial number *//*
	unsigned char mbr_2000_0x1b8[] = {
	                                                  0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00
	};
	*/};
	public static byte[] br_fat32nt_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static byte[] br_fat32ros_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static int write_partition_number_of_heads;
	public static int write_partition_start_sector_number;
	public static int write_partition_physical_disk_drive_id_fat32;
	public static int write_partition_physical_disk_drive_id_fat16;
	public static byte[] label_11_char = new byte[]{(byte)'N', (byte)'O', (byte)' ', (byte)'N', (byte)'A', (byte)'M', (byte)'E', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
	public static [][] crc32table_be = new [][]{new (/*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024)), new (/*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024)), new (/*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024)), new (/*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024)), new (/*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024)), new (/*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024)), new (/*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024)), new (/*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024), /*Error: Function owner not recognized*/tobe(-1024))};
	public static [][] crc32ctable_le = new [][]{new (/*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024)), new (/*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024)), new (/*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024)), new (/*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024)), new (/*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024)), new (/*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024)), new (/*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024)), new (/*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024), /*Error: Function owner not recognized*/tole(-1024))};
	public static  cdio_audio_get_volume = new ();
	public static  cdio_audio_get_msf_seconds = new ();
	public static  cdio_audio_pause = new ();
	public static  cdio_audio_play_msf = new ();
	public static  cdio_audio_play_track_index = new ();
	public static  cdio_audio_read_subchannel = new ();
	public static  cdio_audio_resume = new ();
	public static  cdio_audio_set_volume = new ();
	public static  cdio_audio_stop = new ();
	public static byte cdio_lba_to_msf_str;
	public static byte cdio_msf_to_str;
	public static  cdio_lba_to_lsn = new ();
	public static Object cdio_lba_to_msf;
	public static  cdio_lsn_to_lba = new ();
	public static Object cdio_lsn_to_msf;
	public static  cdio_msf_to_lba = new ();
	public static  cdio_msf_to_lsn = new ();
	public static  cdio_msf3_to_lba = new ();
	public static  cdio_mmssff_to_lba = new ();
	public static HICON hMessageIcon = /*
	 * Rufus: The Reliable USB Formatting Utility
	 * Standard Dialog Routines (Browse for folder, About, etc)
	 * Copyright Â© 2011-2019 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 *//* Memory leaks detection - define _CRTDBG_MAP_ALLOC as preprocessor macro */(HICON)(HANDLE)(/* Globals */true);
	public static byte szMessageText = ((Object)0);
	public static byte szMessageTitle = ((Object)0);
	public static byte szDialogItem;
	public static int nDialogItems;
	public static HWND hBrowseEdit = new HWND();
	public static WNDPROC pOrgBrowseWndproc = new WNDPROC();
	public static SETTEXTEX friggin_microsoft_unicode_amateurs = new SETTEXTEX(0, 65001);
	public static BOOL notification_is_question = new BOOL();
	public static notification_info notification_more_info = new notification_info();
	public static byte notification_dont_display_setting;
	public static WNDPROC update_original_proc = ((Object)0);
	public static HWINEVENTHOOK ap_weh = ((Object)0);
	public static byte[][] title_str = new byte[3][128];
	public static byte[] button_str = new byte[128];
	public static int[] update_settings_reposition_ids = new int[]{1061, 2006, 2007, 2008, 1062, 1063, 2012, 1066, 2/*
	 * https://blogs.msdn.microsoft.com/oldnewthing/20040802-00/?p=38283/
	 */};
	public static  ptbl = ((Object)/*
	 * Windows 7 taskbar icon handling (progress bar overlay, etc)
	 */0);
	public static long ext2_loff_t;
	public static ext2_loff_t ext2fs_llseek = new ext2_loff_t();
	public static struct_io_manager io_manager = new struct_io_manager();
	public static struct_io_channel io_channel = new struct_io_channel();
	public static struct_io_stats io_stats = new struct_io_stats();
	public static  io_channel_set_options = new ();
	public static  io_channel_write_byte = new ();
	public static  io_channel_read_blk64 = new ();
	public static  io_channel_write_blk64 = new ();
	public static  io_channel_discard = new ();
	public static  io_channel_zeroout = new ();
	public static  io_channel_alloc_buf = new ();
	public static  io_channel_cache_readahead = new ();
	public static io_manager unix_io_manager = new io_manager();
	public static io_manager unixfd_io_manager = new io_manager();
	public static io_manager sparse_io_manager = new io_manager();
	public static io_manager sparsefd_io_manager = new io_manager();
	public static io_manager undo_io_manager = new io_manager();
	public static  set_undo_io_backing_manager = new ();
	public static  set_undo_io_backup_file = new ();
	public static io_manager test_io_manager = new io_manager();
	public static io_manager test_io_backing_manager = new io_manager();
	public static Object test_io_cb_read_blk;
	public static Object test_io_cb_write_blk;
	public static Object test_io_cb_read_blk64;
	public static Object test_io_cb_write_blk64;
	public static Object test_io_cb_set_blksize;
	public static Object cdio_free;
	public static byte[] mbr_syslinux_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* This version is from mbr.bin from syslinux 6.02 */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static DWORD FormatStatus = 0;
	public static DWORD LastWriteError = 0;
	public static badblocks_report report = new badblocks_report(0);
	public static double format_percent = 0.0;
	public static int task_number = 0;
	public static uint32_t wim_nb_files = new uint32_t();
	public static uint32_t wim_proc_files = new uint32_t();
	public static uint32_t wim_extra_files = new uint32_t();
	public static int actual_fs_type;
	public static int wintogo_index = -1;
	public static int wininst_index = 0;
	public static BOOL WritePBR = new BOOL();
	public static double ext2_percent_start = 0.0;
	public static double ext2_percent_share = 0.5;
	public static double ext2_max_marker = 80.0;
	public static int cdio_data_open_t;
	public static  cdio_data_read_t = new ();
	public static int cdio_data_seek_t;
	public static  cdio_data_stat_t = new ();
	public static int cdio_data_close_t;
	public static Object cdio_data_free_t;
	public static  cdio_stream_getpos = new ();
	public static CdioDataSource_t cdio_stream_new = new CdioDataSource_t();
	public static  cdio_stream_read = new ();
	public static int cdio_stream_seek;
	public static  cdio_stream_stat = new ();
	public static Object cdio_stream_destroy;
	public static Object cdio_stream_close;
	public static byte about_blurb_format = /*
	 * Rufus: The Reliable USB Formatting Utility
	 * Licensing Data
	 * Copyright Â© 2011-2015 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */"{\\rtf1\\ansi\n\\b\\fs20%s\\b0\\line\n\\fs18%s\\line\n\\line\n%s\\line\n";
	public static byte additional_copyrights = "{\\rtf1\\ansi\nUI redesign concept by Fahad Al-Riyami\\line\nUsed with kind authorization\\line\n\\line\nRufus icon by PC Unleashed:\\line\nFreeware\\line\n\\line\nAdditional icons courtesy of Axialis Software:\\line\nhttps://axialis.com/\\line\nCC BY-ND 4.0, when used as native resolution bitmaps\\line\n\\line\nBoot record handling from ms-sys by Henrik Carlqvist:\\line\nhttp://ms-sys.sourceforge.net/\\line\nGNU General Public License (GPL) v2 or later\\line\n\\line\nFreeDOS support from the FreeDOS project:\\line\nhttps://www.freedos.org/\\line\nGNU General Public License (GPL) v2 or later, with binary redistribution allowed\\line\n\\line\nISO extraction support from libcdio by Rocky Bernstein et al.:\\line\nhttps://www.gnu.org/software/libcdio\\line\nGNU General Public License (GPL) v3 or later\\line\n\\line\nSyslinux support from Syslinux by H. Peter Anvin et al.:\\line\nhttps://syslinux.org/\\line\nGNU General Public License (GPL) v2 or later\\line\n\\line\nGrub4DOS support from Grub4DOS by chenall, itself based on GRUB Legacy by the Free Software Foundation:\\line\nhttps://github.com/chenall/grub4dos\\line\nGNU General Public License (GPL) v2 or later\\line\n\\line\nGRUB 2 support from GNU GRUB by the Free Software Foundation:\\line\nhttps://www.gnu.org/software/grub\\line\nGNU General Public License (GPL) v3 or later\\line\n\\line\nReactOS support & additional FAT and time-conversion handling by ReactOS:\\line\nhttps://www.reactos.org/\\line\nhttps://svn.reactos.org/reactos/trunk\\line\nGNU General Public License (GPL) v2 or later\\line\n\\line\nBad blocks testing and ext2/ext3 formattinmg from e2fsprogs by Theodore T'so et al.:\\line\nhttp://e2fsprogs.sourceforge.net/\\line\nGNU General Public License (GPL) v3 compatible\\line\n\\line\nLarge FAT32 volume formatting from fat32format by Tom Thornhill:\\line\nhttp://www.ridgecrop.demon.co.uk/index.htm?fat32format.htm\\line\nGNU General Public License (GPL) v2 or later\\line\n\\line\nfmifs.dll usage based on Formatx by Mark Russinovich:\\line\nhttps://svn.reactos.org/reactos/trunk/reactos/dll/win32/fmifs\\line\nPublic Domain\\line\n\\line\nDevice enumeration based on TestUSBDriveEject.cpp by ahmd:\\line\nhttps://www.codeguru.com/forum/showthread.php?p=1951973\\line\nPublic Domain\\line\n\\line\nHandle search & process enumeration from Process Hacker by wj32 & dmex:\\line\nhttps://processhacker.sourceforge.io/\\line\nGNU General Public License (GPL) v3 or later\\line\n\\line\nDecompression support from BusyBox/Bled:\\line\nhttps://www.busybox.net/\\line\nhttps://github.com/pbatard/bled\\line\nGNU General Public License (GPL) v2 or later\\line\n\\line\nUSB vs HDD and additional functions calls derived from smartmontools:\\line\nhttps://sourceforge.net/projects/smartmontools\\line\nGNU General Public License (GPL) v2 or later\\line\n\\line\nFS Type description from GNU fdisk:\\line\nhttps://www.gnu.org/software/fdisk\\line\nGNU General Public License (GPL) v3 or later\\line\n\\line\nSpeed/ETA computation from GNU wget:\\line\nhttps://www.gnu.org/software/wget\\line\nGNU General Public License (GPL) v3 or later\\line\n\\line\nAdditional bootloaders from KolibriOS:\\line\nhttps://kolibrios.org/\\line\nGNU General Public License (GPL) v2 or later\\line\n\\line\nMD5 checksum by Ron Rivest, Colin Plumb et al.\\line\nPublic Domain\\line\n\\line\nSHA-1 checksum from GnuPG:\\line\nhttps://www.gnupg.org/\\line\nGNU General Public License (GPL) v3 or later\\line\n\\line\nSHA-256 checksum from 7-zip by Igor Pavlov and Crypto++ by Wei Dai:\\line\nhttps://7-zip.org/\\line\nhttps://github.com/weidai11/cryptopp/\\line\nPublic Domain\\line\n\\line\nAbout and License dialogs inspired by WinSCP by Martin Prikryl\\line\nhttps://winscp.net/\\line\nGNU General Public License (GPL) v3 or later\\line\n\\line\nCheck for Update dialog inspired by TortoiseSVN & TortoiseGit\\line\nhttps://tortoisesvn.net/, https://tortoisegit.org/\\line\nGNU General Public License (GPL) v2 or later\\line\n\\line\n\\line\nAll other references can be found in the source.\\line\n}";
	public static byte update_policy = "{\\rtf1\\ansi{\\fonttbl{\\f0\\fnil\\fcharset0 Microsoft Sans Serif;}}\n\\fs16\\b %s\\b0\\line\n%s\\par\n\\fs20â¢\\fs16  %s\\par\n\\fs20â¢\\fs16  %s\\par\n\\fs20â¢\\fs16  %s\\line\n\\line\n%s\\line\n\\line\n\\b %s\\b0\\line\n%s\\line\n}";
	public static byte gplv3 = "                    GNU GENERAL PUBLIC LICENSE\r\n                       Version 3, 29 June 2007\r\n\r\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\r\n Everyone is permitted to copy and distribute verbatim copies\r\n of this license document, but changing it is not allowed.\r\n\r\n                            Preamble\r\n\r\n  The GNU General Public License is a free, copyleft license for\r\nsoftware and other kinds of works.\r\n\r\n  The licenses for most software and other practical works are designed\r\nto take away your freedom to share and change the works.  By contrast,\r\nthe GNU General Public License is intended to guarantee your freedom to\r\nshare and change all versions of a program--to make sure it remains free\r\nsoftware for all its users.  We, the Free Software Foundation, use the\r\nGNU General Public License for most of our software; it applies also to\r\nany other work released this way by its authors.  You can apply it to\r\nyour programs, too.\r\n\r\n  When we speak of free software, we are referring to freedom, not\r\nprice.  Our General Public Licenses are designed to make sure that you\r\nhave the freedom to distribute copies of free software (and charge for\r\nthem if you wish), that you receive source code or can get it if you\r\nwant it, that you can change the software or use pieces of it in new\r\nfree programs, and that you know you can do these things.\r\n\r\n  To protect your rights, we need to prevent others from denying you\r\nthese rights or asking you to surrender the rights.  Therefore, you have\r\ncertain responsibilities if you distribute copies of the software, or if\r\nyou modify it: responsibilities to respect the freedom of others.\r\n\r\n  For example, if you distribute copies of such a program, whether\r\ngratis or for a fee, you must pass on to the recipients the same\r\nfreedoms that you received.  You must make sure that they, too, receive\r\nor can get the source code.  And you must show them these terms so they\r\nknow their rights.\r\n\r\n  Developers that use the GNU GPL protect your rights with two steps:\r\n(1) assert copyright on the software, and (2) offer you this License\r\ngiving you legal permission to copy, distribute and/or modify it.\r\n\r\n  For the developers' and authors' protection, the GPL clearly explains\r\nthat there is no warranty for this free software.  For both users' and\r\nauthors' sake, the GPL requires that modified versions be marked as\r\nchanged, so that their problems will not be attributed erroneously to\r\nauthors of previous versions.\r\n\r\n  Some devices are designed to deny users access to install or run\r\nmodified versions of the software inside them, although the manufacturer\r\ncan do so.  This is fundamentally incompatible with the aim of\r\nprotecting users' freedom to change the software.  The systematic\r\npattern of such abuse occurs in the area of products for individuals to\r\nuse, which is precisely where it is most unacceptable.  Therefore, we\r\nhave designed this version of the GPL to prohibit the practice for those\r\nproducts.  If such problems arise substantially in other domains, we\r\nstand ready to extend this provision to those domains in future versions\r\nof the GPL, as needed to protect the freedom of users.\r\n\r\n  Finally, every program is threatened constantly by software patents.\r\nStates should not allow patents to restrict development and use of\r\nsoftware on general-purpose computers, but in those that do, we wish to\r\navoid the special danger that patents applied to a free program could\r\nmake it effectively proprietary.  To prevent this, the GPL assures that\r\npatents cannot be used to render the program non-free.\r\n\r\n  The precise terms and conditions for copying, distribution and\r\nmodification follow.\r\n\r\n                       TERMS AND CONDITIONS\r\n\r\n  0. Definitions.\r\n\r\n  \"This License\" refers to version 3 of the GNU General Public License.\r\n\r\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\r\nworks, such as semiconductor masks.\r\n\r\n  \"The Program\" refers to any copyrightable work licensed under this\r\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\r\n\"recipients\" may be individuals or organizations.\r\n\r\n  To \"modify\" a work means to copy from or adapt all or part of the work\r\nin a fashion requiring copyright permission, other than the making of an\r\nexact copy.  The resulting work is called a \"modified version\" of the\r\nearlier work or a work \"based on\" the earlier work.\r\n\r\n  A \"covered work\" means either the unmodified Program or a work based\r\non the Program.\r\n\r\n  To \"propagate\" a work means to do anything with it that, without\r\npermission, would make you directly or secondarily liable for\r\ninfringement under applicable copyright law, except executing it on a\r\ncomputer or modifying a private copy.  Propagation includes copying,\r\ndistribution (with or without modification), making available to the\r\npublic, and in some countries other activities as well.\r\n\r\n  To \"convey\" a work means any kind of propagation that enables other\r\nparties to make or receive copies.  Mere interaction with a user through\r\na computer network, with no transfer of a copy, is not conveying.\r\n\r\n  An interactive user interface displays \"Appropriate Legal Notices\"\r\nto the extent that it includes a convenient and prominently visible\r\nfeature that (1) displays an appropriate copyright notice, and (2)\r\ntells the user that there is no warranty for the work (except to the\r\nextent that warranties are provided), that licensees may convey the\r\nwork under this License, and how to view a copy of this License.  If\r\nthe interface presents a list of user commands or options, such as a\r\nmenu, a prominent item in the list meets this criterion.\r\n\r\n  1. Source Code.\r\n\r\n  The \"source code\" for a work means the preferred form of the work\r\nfor making modifications to it.  \"Object code\" means any non-source\r\nform of a work.\r\n\r\n  A \"Standard Interface\" means an interface that either is an official\r\nstandard defined by a recognized standards body, or, in the case of\r\ninterfaces specified for a particular programming language, one that\r\nis widely used among developers working in that language.\r\n\r\n  The \"System Libraries\" of an executable work include anything, other\r\nthan the work as a whole, that (a) is included in the normal form of\r\npackaging a Major Component, but which is not part of that Major\r\nComponent, and (b) serves only to enable use of the work with that\r\nMajor Component, or to implement a Standard Interface for which an\r\nimplementation is available to the public in source code form.  A\r\n\"Major Component\", in this context, means a major essential component\r\n(kernel, window system, and so on) of the specific operating system\r\n(if any) on which the executable work runs, or a compiler used to\r\nproduce the work, or an object code interpreter used to run it.\r\n\r\n  The \"Corresponding Source\" for a work in object code form means all\r\nthe source code needed to generate, install, and (for an executable\r\nwork) run the object code and to modify the work, including scripts to\r\ncontrol those activities.  However, it does not include the work's\r\nSystem Libraries, or general-purpose tools or generally available free\r\nprograms which are used unmodified in performing those activities but\r\nwhich are not part of the work.  For example, Corresponding Source\r\nincludes interface definition files associated with source files for\r\nthe work, and the source code for shared libraries and dynamically\r\nlinked subprograms that the work is specifically designed to require,\r\nsuch as by intimate data communication or control flow between those\r\nsubprograms and other parts of the work.\r\n\r\n  The Corresponding Source need not include anything that users\r\ncan regenerate automatically from other parts of the Corresponding\r\nSource.\r\n\r\n  The Corresponding Source for a work in source code form is that\r\nsame work.\r\n\r\n  2. Basic Permissions.\r\n\r\n  All rights granted under this License are granted for the term of\r\ncopyright on the Program, and are irrevocable provided the stated\r\nconditions are met.  This License explicitly affirms your unlimited\r\npermission to run the unmodified Program.  The output from running a\r\ncovered work is covered by this License only if the output, given its\r\ncontent, constitutes a covered work.  This License acknowledges your\r\nrights of fair use or other equivalent, as provided by copyright law.\r\n\r\n  You may make, run and propagate covered works that you do not\r\nconvey, without conditions so long as your license otherwise remains\r\nin force.  You may convey covered works to others for the sole purpose\r\nof having them make modifications exclusively for you, or provide you\r\nwith facilities for running those works, provided that you comply with\r\nthe terms of this License in conveying all material for which you do\r\nnot control copyright.  Those thus making or running the covered works\r\nfor you must do so exclusively on your behalf, under your direction\r\nand control, on terms that prohibit them from making any copies of\r\nyour copyrighted material outside their relationship with you.\r\n\r\n  Conveying under any other circumstances is permitted solely under\r\nthe conditions stated below.  Sublicensing is not allowed; section 10\r\nmakes it unnecessary.\r\n\r\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\r\n\r\n  No covered work shall be deemed part of an effective technological\r\nmeasure under any applicable law fulfilling obligations under article\r\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\r\nsimilar laws prohibiting or restricting circumvention of such\r\nmeasures.\r\n\r\n  When you convey a covered work, you waive any legal power to forbid\r\ncircumvention of technological measures to the extent such circumvention\r\nis effected by exercising rights under this License with respect to\r\nthe covered work, and you disclaim any intention to limit operation or\r\nmodification of the work as a means of enforcing, against the work's\r\nusers, your or third parties' legal rights to forbid circumvention of\r\ntechnological measures.\r\n\r\n  4. Conveying Verbatim Copies.\r\n\r\n  You may convey verbatim copies of the Program's source code as you\r\nreceive it, in any medium, provided that you conspicuously and\r\nappropriately publish on each copy an appropriate copyright notice;\r\nkeep intact all notices stating that this License and any\r\nnon-permissive terms added in accord with section 7 apply to the code;\r\nkeep intact all notices of the absence of any warranty; and give all\r\nrecipients a copy of this License along with the Program.\r\n\r\n  You may charge any price or no price for each copy that you convey,\r\nand you may offer support or warranty protection for a fee.\r\n\r\n  5. Conveying Modified Source Versions.\r\n\r\n  You may convey a work based on the Program, or the modifications to\r\nproduce it from the Program, in the form of source code under the\r\nterms of section 4, provided that you also meet all of these conditions:\r\n\r\n    a) The work must carry prominent notices stating that you modified\r\n    it, and giving a relevant date.\r\n\r\n    b) The work must carry prominent notices stating that it is\r\n    released under this License and any conditions added under section\r\n    7.  This requirement modifies the requirement in section 4 to\r\n    \"keep intact all notices\".\r\n\r\n    c) You must license the entire work, as a whole, under this\r\n    License to anyone who comes into possession of a copy.  This\r\n    License will therefore apply, along with any applicable section 7\r\n    additional terms, to the whole of the work, and all its parts,\r\n    regardless of how they are packaged.  This License gives no\r\n    permission to license the work in any other way, but it does not\r\n    invalidate such permission if you have separately received it.\r\n\r\n    d) If the work has interactive user interfaces, each must display\r\n    Appropriate Legal Notices; however, if the Program has interactive\r\n    interfaces that do not display Appropriate Legal Notices, your\r\n    work need not make them do so.\r\n\r\n  A compilation of a covered work with other separate and independent\r\nworks, which are not by their nature extensions of the covered work,\r\nand which are not combined with it such as to form a larger program,\r\nin or on a volume of a storage or distribution medium, is called an\r\n\"aggregate\" if the compilation and its resulting copyright are not\r\nused to limit the access or legal rights of the compilation's users\r\nbeyond what the individual works permit.  Inclusion of a covered work\r\nin an aggregate does not cause this License to apply to the other\r\nparts of the aggregate.\r\n\r\n  6. Conveying Non-Source Forms.\r\n\r\n  You may convey a covered work in object code form under the terms\r\nof sections 4 and 5, provided that you also convey the\r\nmachine-readable Corresponding Source under the terms of this License,\r\nin one of these ways:\r\n\r\n    a) Convey the object code in, or embodied in, a physical product\r\n    (including a physical distribution medium), accompanied by the\r\n    Corresponding Source fixed on a durable physical medium\r\n    customarily used for software interchange.\r\n\r\n    b) Convey the object code in, or embodied in, a physical product\r\n    (including a physical distribution medium), accompanied by a\r\n    written offer, valid for at least three years and valid for as\r\n    long as you offer spare parts or customer support for that product\r\n    model, to give anyone who possesses the object code either (1) a\r\n    copy of the Corresponding Source for all the software in the\r\n    product that is covered by this License, on a durable physical\r\n    medium customarily used for software interchange, for a price no\r\n    more than your reasonable cost of physically performing this\r\n    conveying of source, or (2) access to copy the\r\n    Corresponding Source from a network server at no charge.\r\n\r\n    c) Convey individual copies of the object code with a copy of the\r\n    written offer to provide the Corresponding Source.  This\r\n    alternative is allowed only occasionally and noncommercially, and\r\n    only if you received the object code with such an offer, in accord\r\n    with subsection 6b.\r\n\r\n    d) Convey the object code by offering access from a designated\r\n    place (gratis or for a charge), and offer equivalent access to the\r\n    Corresponding Source in the same way through the same place at no\r\n    further charge.  You need not require recipients to copy the\r\n    Corresponding Source along with the object code.  If the place to\r\n    copy the object code is a network server, the Corresponding Source\r\n    may be on a different server (operated by you or a third party)\r\n    that supports equivalent copying facilities, provided you maintain\r\n    clear directions next to the object code saying where to find the\r\n    Corresponding Source.  Regardless of what server hosts the\r\n    Corresponding Source, you remain obligated to ensure that it is\r\n    available for as long as needed to satisfy these requirements.\r\n\r\n    e) Convey the object code using peer-to-peer transmission, provided\r\n    you inform other peers where the object code and Corresponding\r\n    Source of the work are being offered to the general public at no\r\n    charge under subsection 6d.\r\n\r\n  A separable portion of the object code, whose source code is excluded\r\nfrom the Corresponding Source as a System Library, need not be\r\nincluded in conveying the object code work.\r\n\r\n  A \"User Product\" is either (1) a \"consumer product\", which means any\r\ntangible personal property which is normally used for personal, family,\r\nor household purposes, or (2) anything designed or sold for incorporation\r\ninto a dwelling.  In determining whether a product is a consumer product,\r\ndoubtful cases shall be resolved in favor of coverage.  For a particular\r\nproduct received by a particular user, \"normally used\" refers to a\r\ntypical or common use of that class of product, regardless of the status\r\nof the particular user or of the way in which the particular user\r\nactually uses, or expects or is expected to use, the product.  A product\r\nis a consumer product regardless of whether the product has substantial\r\ncommercial, industrial or non-consumer uses, unless such uses represent\r\nthe only significant mode of use of the product.\r\n\r\n  \"Installation Information\" for a User Product means any methods,\r\nprocedures, authorization keys, or other information required to install\r\nand execute modified versions of a covered work in that User Product from\r\na modified version of its Corresponding Source.  The information must\r\nsuffice to ensure that the continued functioning of the modified object\r\ncode is in no case prevented or interfered with solely because\r\nmodification has been made.\r\n\r\n  If you convey an object code work under this section in, or with, or\r\nspecifically for use in, a User Product, and the conveying occurs as\r\npart of a transaction in which the right of possession and use of the\r\nUser Product is transferred to the recipient in perpetuity or for a\r\nfixed term (regardless of how the transaction is characterized), the\r\nCorresponding Source conveyed under this section must be accompanied\r\nby the Installation Information.  But this requirement does not apply\r\nif neither you nor any third party retains the ability to install\r\nmodified object code on the User Product (for example, the work has\r\nbeen installed in ROM).\r\n\r\n  The requirement to provide Installation Information does not include a\r\nrequirement to continue to provide support service, warranty, or updates\r\nfor a work that has been modified or installed by the recipient, or for\r\nthe User Product in which it has been modified or installed.  Access to a\r\nnetwork may be denied when the modification itself materially and\r\nadversely affects the operation of the network or violates the rules and\r\nprotocols for communication across the network.\r\n\r\n  Corresponding Source conveyed, and Installation Information provided,\r\nin accord with this section must be in a format that is publicly\r\ndocumented (and with an implementation available to the public in\r\nsource code form), and must require no special password or key for\r\nunpacking, reading or copying.\r\n\r\n  7. Additional Terms.\r\n\r\n  \"Additional permissions\" are terms that supplement the terms of this\r\nLicense by making exceptions from one or more of its conditions.\r\nAdditional permissions that are applicable to the entire Program shall\r\nbe treated as though they were included in this License, to the extent\r\nthat they are valid under applicable law.  If additional permissions\r\napply only to part of the Program, that part may be used separately\r\nunder those permissions, but the entire Program remains governed by\r\nthis License without regard to the additional permissions.\r\n\r\n  When you convey a copy of a covered work, you may at your option\r\nremove any additional permissions from that copy, or from any part of\r\nit.  (Additional permissions may be written to require their own\r\nremoval in certain cases when you modify the work.)  You may place\r\nadditional permissions on material, added by you to a covered work,\r\nfor which you have or can give appropriate copyright permission.\r\n\r\n  Notwithstanding any other provision of this License, for material you\r\nadd to a covered work, you may (if authorized by the copyright holders of\r\nthat material) supplement the terms of this License with terms:\r\n\r\n    a) Disclaiming warranty or limiting liability differently from the\r\n    terms of sections 15 and 16 of this License; or\r\n\r\n    b) Requiring preservation of specified reasonable legal notices or\r\n    author attributions in that material or in the Appropriate Legal\r\n    Notices displayed by works containing it; or\r\n\r\n    c) Prohibiting misrepresentation of the origin of that material, or\r\n    requiring that modified versions of such material be marked in\r\n    reasonable ways as different from the original version; or\r\n\r\n    d) Limiting the use for publicity purposes of names of licensors or\r\n    authors of the material; or\r\n\r\n    e) Declining to grant rights under trademark law for use of some\r\n    trade names, trademarks, or service marks; or\r\n\r\n    f) Requiring indemnification of licensors and authors of that\r\n    material by anyone who conveys the material (or modified versions of\r\n    it) with contractual assumptions of liability to the recipient, for\r\n    any liability that these contractual assumptions directly impose on\r\n    those licensors and authors.\r\n\r\n  All other non-permissive additional terms are considered \"further\r\nrestrictions\" within the meaning of section 10.  If the Program as you\r\nreceived it, or any part of it, contains a notice stating that it is\r\ngoverned by this License along with a term that is a further\r\nrestriction, you may remove that term.  If a license document contains\r\na further restriction but permits relicensing or conveying under this\r\nLicense, you may add to a covered work material governed by the terms\r\nof that license document, provided that the further restriction does\r\nnot survive such relicensing or conveying.\r\n\r\n  If you add terms to a covered work in accord with this section, you\r\nmust place, in the relevant source files, a statement of the\r\nadditional terms that apply to those files, or a notice indicating\r\nwhere to find the applicable terms.\r\n\r\n  Additional terms, permissive or non-permissive, may be stated in the\r\nform of a separately written license, or stated as exceptions;\r\nthe above requirements apply either way.\r\n\r\n  8. Termination.\r\n\r\n  You may not propagate or modify a covered work except as expressly\r\nprovided under this License.  Any attempt otherwise to propagate or\r\nmodify it is void, and will automatically terminate your rights under\r\nthis License (including any patent licenses granted under the third\r\nparagraph of section 11).\r\n\r\n  However, if you cease all violation of this License, then your\r\nlicense from a particular copyright holder is reinstated (a)\r\nprovisionally, unless and until the copyright holder explicitly and\r\nfinally terminates your license, and (b) permanently, if the copyright\r\nholder fails to notify you of the violation by some reasonable means\r\nprior to 60 days after the cessation.\r\n\r\n  Moreover, your license from a particular copyright holder is\r\nreinstated permanently if the copyright holder notifies you of the\r\nviolation by some reasonable means, this is the first time you have\r\nreceived notice of violation of this License (for any work) from that\r\ncopyright holder, and you cure the violation prior to 30 days after\r\nyour receipt of the notice.\r\n\r\n  Termination of your rights under this section does not terminate the\r\nlicenses of parties who have received copies or rights from you under\r\nthis License.  If your rights have been terminated and not permanently\r\nreinstated, you do not qualify to receive new licenses for the same\r\nmaterial under section 10.\r\n\r\n  9. Acceptance Not Required for Having Copies.\r\n\r\n  You are not required to accept this License in order to receive or\r\nrun a copy of the Program.  Ancillary propagation of a covered work\r\noccurring solely as a consequence of using peer-to-peer transmission\r\nto receive a copy likewise does not require acceptance.  However,\r\nnothing other than this License grants you permission to propagate or\r\nmodify any covered work.  These actions infringe copyright if you do\r\nnot accept this License.  Therefore, by modifying or propagating a\r\ncovered work, you indicate your acceptance of this License to do so.\r\n\r\n  10. Automatic Licensing of Downstream Recipients.\r\n\r\n  Each time you convey a covered work, the recipient automatically\r\nreceives a license from the original licensors, to run, modify and\r\npropagate that work, subject to this License.  You are not responsible\r\nfor enforcing compliance by third parties with this License.\r\n\r\n  An \"entity transaction\" is a transaction transferring control of an\r\norganization, or substantially all assets of one, or subdividing an\r\norganization, or merging organizations.  If propagation of a covered\r\nwork results from an entity transaction, each party to that\r\ntransaction who receives a copy of the work also receives whatever\r\nlicenses to the work the party's predecessor in interest had or could\r\ngive under the previous paragraph, plus a right to possession of the\r\nCorresponding Source of the work from the predecessor in interest, if\r\nthe predecessor has it or can get it with reasonable efforts.\r\n\r\n  You may not impose any further restrictions on the exercise of the\r\nrights granted or affirmed under this License.  For example, you may\r\nnot impose a license fee, royalty, or other charge for exercise of\r\nrights granted under this License, and you may not initiate litigation\r\n(including a cross-claim or counterclaim in a lawsuit) alleging that\r\nany patent claim is infringed by making, using, selling, offering for\r\nsale, or importing the Program or any portion of it.\r\n\r\n  11. Patents.\r\n\r\n  A \"contributor\" is a copyright holder who authorizes use under this\r\nLicense of the Program or a work on which the Program is based.  The\r\nwork thus licensed is called the contributor's \"contributor version\".\r\n\r\n  A contributor's \"essential patent claims\" are all patent claims\r\nowned or controlled by the contributor, whether already acquired or\r\nhereafter acquired, that would be infringed by some manner, permitted\r\nby this License, of making, using, or selling its contributor version,\r\nbut do not include claims that would be infringed only as a\r\nconsequence of further modification of the contributor version.  For\r\npurposes of this definition, \"control\" includes the right to grant\r\npatent sublicenses in a manner consistent with the requirements of\r\nthis License.\r\n\r\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\r\npatent license under the contributor's essential patent claims, to\r\nmake, use, sell, offer for sale, import and otherwise run, modify and\r\npropagate the contents of its contributor version.\r\n\r\n  In the following three paragraphs, a \"patent license\" is any express\r\nagreement or commitment, however denominated, not to enforce a patent\r\n(such as an express permission to practice a patent or covenant not to\r\nsue for patent infringement).  To \"grant\" such a patent license to a\r\nparty means to make such an agreement or commitment not to enforce a\r\npatent against the party.\r\n\r\n  If you convey a covered work, knowingly relying on a patent license,\r\nand the Corresponding Source of the work is not available for anyone\r\nto copy, free of charge and under the terms of this License, through a\r\npublicly available network server or other readily accessible means,\r\nthen you must either (1) cause the Corresponding Source to be so\r\navailable, or (2) arrange to deprive yourself of the benefit of the\r\npatent license for this particular work, or (3) arrange, in a manner\r\nconsistent with the requirements of this License, to extend the patent\r\nlicense to downstream recipients.  \"Knowingly relying\" means you have\r\nactual knowledge that, but for the patent license, your conveying the\r\ncovered work in a country, or your recipient's use of the covered work\r\nin a country, would infringe one or more identifiable patents in that\r\ncountry that you have reason to believe are valid.\r\n\r\n  If, pursuant to or in connection with a single transaction or\r\narrangement, you convey, or propagate by procuring conveyance of, a\r\ncovered work, and grant a patent license to some of the parties\r\nreceiving the covered work authorizing them to use, propagate, modify\r\nor convey a specific copy of the covered work, then the patent license\r\nyou grant is automatically extended to all recipients of the covered\r\nwork and works based on it.\r\n\r\n  A patent license is \"discriminatory\" if it does not include within\r\nthe scope of its coverage, prohibits the exercise of, or is\r\nconditioned on the non-exercise of one or more of the rights that are\r\nspecifically granted under this License.  You may not convey a covered\r\nwork if you are a party to an arrangement with a third party that is\r\nin the business of distributing software, under which you make payment\r\nto the third party based on the extent of your activity of conveying\r\nthe work, and under which the third party grants, to any of the\r\nparties who would receive the covered work from you, a discriminatory\r\npatent license (a) in connection with copies of the covered work\r\nconveyed by you (or copies made from those copies), or (b) primarily\r\nfor and in connection with specific products or compilations that\r\ncontain the covered work, unless you entered into that arrangement,\r\nor that patent license was granted, prior to 28 March 2007.\r\n\r\n  Nothing in this License shall be construed as excluding or limiting\r\nany implied license or other defenses to infringement that may\r\notherwise be available to you under applicable patent law.\r\n\r\n  12. No Surrender of Others' Freedom.\r\n\r\n  If conditions are imposed on you (whether by court order, agreement or\r\notherwise) that contradict the conditions of this License, they do not\r\nexcuse you from the conditions of this License.  If you cannot convey a\r\ncovered work so as to satisfy simultaneously your obligations under this\r\nLicense and any other pertinent obligations, then as a consequence you may\r\nnot convey it at all.  For example, if you agree to terms that obligate you\r\nto collect a royalty for further conveying from those to whom you convey\r\nthe Program, the only way you could satisfy both those terms and this\r\nLicense would be to refrain entirely from conveying the Program.\r\n\r\n  13. Use with the GNU Affero General Public License.\r\n\r\n  Notwithstanding any other provision of this License, you have\r\npermission to link or combine any covered work with a work licensed\r\nunder version 3 of the GNU Affero General Public License into a single\r\ncombined work, and to convey the resulting work.  The terms of this\r\nLicense will continue to apply to the part which is the covered work,\r\nbut the special requirements of the GNU Affero General Public License,\r\nsection 13, concerning interaction through a network will apply to the\r\ncombination as such.\r\n\r\n  14. Revised Versions of this License.\r\n\r\n  The Free Software Foundation may publish revised and/or new versions of\r\nthe GNU General Public License from time to time.  Such new versions will\r\nbe similar in spirit to the present version, but may differ in detail to\r\naddress new problems or concerns.\r\n\r\n  Each version is given a distinguishing version number.  If the\r\nProgram specifies that a certain numbered version of the GNU General\r\nPublic License \"or any later version\" applies to it, you have the\r\noption of following the terms and conditions either of that numbered\r\nversion or of any later version published by the Free Software\r\nFoundation.  If the Program does not specify a version number of the\r\nGNU General Public License, you may choose any version ever published\r\nby the Free Software Foundation.\r\n\r\n  If the Program specifies that a proxy can decide which future\r\nversions of the GNU General Public License can be used, that proxy's\r\npublic statement of acceptance of a version permanently authorizes you\r\nto choose that version for the Program.\r\n\r\n  Later license versions may give you additional or different\r\npermissions.  However, no additional obligations are imposed on any\r\nauthor or copyright holder as a result of your choosing to follow a\r\nlater version.\r\n\r\n  15. Disclaimer of Warranty.\r\n\r\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\r\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\r\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\r\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\r\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\r\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\r\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\r\n\r\n  16. Limitation of Liability.\r\n\r\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\r\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\r\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\r\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\r\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\r\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\r\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\r\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\r\nSUCH DAMAGES.\r\n\r\n  17. Interpretation of Sections 15 and 16.\r\n\r\n  If the disclaimer of warranty and limitation of liability provided\r\nabove cannot be given local legal effect according to their terms,\r\nreviewing courts shall apply local law that most closely approximates\r\nan absolute waiver of all civil liability in connection with the\r\nProgram, unless a warranty or assumption of liability accompanies a\r\ncopy of the Program in return for a fee.\r\n\r\n                     END OF TERMS AND CONDITIONS";
	public static int bb__aliased_int;
	public static long bb__aliased_long;
	public static uint16_t bb__aliased_uint16_t = new uint16_t();
	public static uint32_t bb__aliased_uint32_t = new uint32_t();
	public static uint64_t bb__aliased_uint64_t = new uint64_t();
	public static byte smallint;
	public static byte smalluint;
	public static byte[] syslinux_ldlinux = new byte[/* ----------------------------------------------------------------------- *
	 *
	 *   Copyright 1998-2008 H. Peter Anvin - All Rights Reserved
	 *
	 *   This program is free software; you can redistribute it and/or modify
	 *   it under the terms of the GNU General Public License as published by
	 *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
	 *   Boston MA 02111-1307, USA; either version 2 of the License, or
	 *   (at your option) any later version; incorporated herein by reference.
	 *
	 * ----------------------------------------------------------------------- *//* The standard boot sector and ldlinux image */2];
	public static long[] syslinux_ldlinux_len = new long[2];
	public static int[] syslinux_ldlinux_mtime = new int[2];
	public static byte[] syslinux_mbr;
	public static int syslinux_mbr_len;
	public static int syslinux_mbr_mtime;
	public static uint32_t SECTOR_SHIFT = new uint32_t();
	public static uint32_t SECTOR_SIZE = new uint32_t();
	public static Object syslinux_make_bootsect;
	public static byte syslinux_check_bootsect;
	public static uint64_t sector_t = new uint64_t();
	public static int syslinux_patch;
	public static byte[] ISO_XA_MARKER_STRING = new byte[8/*! \brief "Extended Architecture" according to the Philips Yellow Book.
	 
	CD-ROM EXtended Architecture is a modification to the CD-ROM
	specification that defines two new types of sectors.  CD-ROM XA was
	developed jointly by Sony, Philips, and Microsoft, and announced in
	August 1988. Its specifications were published in an extension to the
	Yellow Book.  CD-i, Photo CD, Video CD and CD-EXTRA have all
	subsequently been based on CD-ROM XA.
	
	CD-XA defines another way of formatting sectors on a CD-ROM, including
	headers in the sectors that describe the type (audio, video, data) and
	some additional info (markers, resolution in case of a video or audio
	sector, file numbers, etc).
	
	The data written on a CD-XA is consistent with and can be in ISO-9660
	file system format and therefore be readable by ISO-9660 file system
	translators. But also a CD-I player can also read CD-XA discs even if
	its own `Green Book' file system only resembles ISO 9660 and isn't
	fully compatible. 
	
	 Note structure is big-endian.
	*/];
	public static  iso9660_get_posix_filemode_from_xa = new ();
	public static byte iso9660_get_xa_attr_str;
	public static  iso9660_xa_init = new ();
	public static Object iso9660_xa_free;
	public static  mmc_run_cmd_fn_t = new ();
	public static loc_control_id[] control_id = new loc_control_id[]{new loc_control_id("IDD_DIALOG", /*
	 * Rufus: The Reliable USB Formatting Utility
	 * Localization tables - autogenerated from resource.h
	 * Copyright Â© 2013-2018 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */101), new loc_control_id("IDD_ABOUTBOX", 102), new loc_control_id("IDD_NOTIFICATION", 103), new loc_control_id("IDD_SELECTION", 104), new loc_control_id("IDD_LICENSE", 105), new loc_control_id("IDD_LOG", 106), new loc_control_id("IDD_UPDATE_POLICY", 107), new loc_control_id("IDD_NEW_VERSION", 108), new loc_control_id("IDD_CHECKSUM", 109), new loc_control_id("IDD_LIST", 110), new loc_control_id("IDC_DEVICE", 1001), new loc_control_id("IDC_FILE_SYSTEM", 1002), new loc_control_id("IDC_START", 1003), new loc_control_id("IDC_PARTITION_TYPE", 1004), new loc_control_id("IDC_CLUSTER_SIZE", 1005), new loc_control_id("IDC_STATUS", 1006), new loc_control_id("IDC_LABEL", 1007), new loc_control_id("IDC_QUICK_FORMAT", 1008), new loc_control_id("IDC_BAD_BLOCKS", 1009), new loc_control_id("IDC_PROGRESS", 1010), new loc_control_id("IDC_BOOT_SELECTION", 1011), new loc_control_id("IDC_NB_PASSES", 1012), new loc_control_id("IDC_TEST", 1013), new loc_control_id("IDC_SELECT", 1014), new loc_control_id("IDC_EXTENDED_LABEL", 1015), new loc_control_id("IDC_RUFUS_MBR", 1016), new loc_control_id("IDC_TARGET_SYSTEM", 1017), new loc_control_id("IDC_PERSISTENCE_SIZE", 1018), new loc_control_id("IDC_PERSISTENCE_UNITS", 1019), new loc_control_id("IDC_DISK_ID", 1020), new loc_control_id("IDC_OLD_BIOS_FIXES", 1021), new loc_control_id("IDC_LIST_USB_HDD", 1022), new loc_control_id("IDC_STATUS_TOOLBAR", 1023), new loc_control_id("IDC_SAVE", 1024), new loc_control_id("IDC_HASH", 1025), new loc_control_id("IDC_IMAGE_OPTION", 1026), new loc_control_id("IDC_PERSISTENCE_SLIDER", 1027), new loc_control_id("IDC_ADVANCED_DRIVE_PROPERTIES", 1028), new loc_control_id("IDC_ADVANCED_FORMAT_OPTIONS", 1029), new loc_control_id("IDC_ABOUT_LICENSE", 1030), new loc_control_id("IDC_ABOUT_ICON", 1031), new loc_control_id("IDC_ABOUT_COPYRIGHTS", 1032), new loc_control_id("IDC_ABOUT_BLURB", 1033), new loc_control_id("IDC_LICENSE_TEXT", 1034), new loc_control_id("IDC_NOTIFICATION_ICON", 1040), new loc_control_id("IDC_NOTIFICATION_TEXT", 1041), new loc_control_id("IDC_NOTIFICATION_LINE", 1042), new loc_control_id("IDC_ADVANCED_DEVICE_TOOLBAR", 1043), new loc_control_id("IDC_ADVANCED_FORMAT_TOOLBAR", 1044), new loc_control_id("IDC_SAVE_TOOLBAR", 1045), new loc_control_id("IDC_HASH_TOOLBAR", 1046), new loc_control_id("IDC_MULTI_TOOLBAR", 1047), new loc_control_id("IDC_LANG", 1051), new loc_control_id("IDC_ABOUT", 1052), new loc_control_id("IDC_SETTINGS", 1053), new loc_control_id("IDC_LOG", 1054), new loc_control_id("IDC_LOG_EDIT", 1055), new loc_control_id("IDC_LOG_SAVE", 1056), new loc_control_id("IDC_LOG_CLEAR", 1057), new loc_control_id("IDC_DONT_DISPLAY_AGAIN", 1059), new loc_control_id("IDC_MORE_INFO", 1060), new loc_control_id("IDC_POLICY", 1061), new loc_control_id("IDC_UPDATE_FREQUENCY", 1062), new loc_control_id("IDC_INCLUDE_BETAS", 1063), new loc_control_id("IDC_RELEASE_NOTES", 1064), new loc_control_id("IDC_DOWNLOAD", 1065), new loc_control_id("IDC_CHECK_NOW", 1066), new loc_control_id("IDC_WEBSITE", 1067), new loc_control_id("IDC_YOUR_VERSION", 1068), new loc_control_id("IDC_LATEST_VERSION", 1069), new loc_control_id("IDC_DOWNLOAD_URL", 1070), new loc_control_id("IDC_MD5", 1071), new loc_control_id("IDC_SHA1", 1072), new loc_control_id("IDC_SHA256", 1073), new loc_control_id("IDC_SELECTION_ICON", 1074), new loc_control_id("IDC_SELECTION_TEXT", 1075), new loc_control_id("IDC_SELECTION_LINE", 1076), new loc_control_id("IDC_SELECTION_CHOICE1", 1077), new loc_control_id("IDC_SELECTION_CHOICE2", 1078), new loc_control_id("IDC_SELECTION_CHOICE3", 1079), new loc_control_id("IDC_SELECTION_CHOICE4", 1080), new loc_control_id("IDC_SELECTION_CHOICE5", 1081), new loc_control_id("IDC_SELECTION_CHOICE6", 1082), new loc_control_id("IDC_SELECTION_CHOICE7", 1083), new loc_control_id("IDC_SELECTION_CHOICE8", 1084), new loc_control_id("IDC_SELECTION_CHOICE9", 1085), new loc_control_id("IDC_SELECTION_CHOICE10", 1086), new loc_control_id("IDC_SELECTION_CHOICE11", 1087), new loc_control_id("IDC_SELECTION_CHOICE12", 1088), new loc_control_id("IDC_SELECTION_CHOICE13", 1089), new loc_control_id("IDC_SELECTION_CHOICE14", 1090), new loc_control_id("IDC_SELECTION_CHOICE15", 1091), new loc_control_id("IDC_SELECTION_CHOICEMAX", 1092), new loc_control_id("IDC_LIST_ICON", 1093), new loc_control_id("IDC_LIST_TEXT", 1094), new loc_control_id("IDC_LIST_LINE", 1095), new loc_control_id("IDC_LIST_ITEM1", 1096), new loc_control_id("IDC_LIST_ITEM2", 1097), new loc_control_id("IDC_LIST_ITEM3", 1098), new loc_control_id("IDC_LIST_ITEM4", 1099), new loc_control_id("IDC_LIST_ITEM5", 1100), new loc_control_id("IDC_LIST_ITEM6", 1101), new loc_control_id("IDC_LIST_ITEM7", 1102), new loc_control_id("IDC_LIST_ITEM8", 1103), new loc_control_id("IDC_LIST_ITEM9", 1104), new loc_control_id("IDC_LIST_ITEM10", 1105), new loc_control_id("IDC_LIST_ITEM11", 1106), new loc_control_id("IDC_LIST_ITEM12", 1107), new loc_control_id("IDC_LIST_ITEM13", 1108), new loc_control_id("IDC_LIST_ITEM14", 1109), new loc_control_id("IDC_LIST_ITEM15", 1110), new loc_control_id("IDC_LIST_ITEMMAX", 1111), new loc_control_id("IDS_DEVICE_TXT", 2000), new loc_control_id("IDS_PARTITION_TYPE_TXT", 2001), new loc_control_id("IDS_FILE_SYSTEM_TXT", 2002), new loc_control_id("IDS_CLUSTER_SIZE_TXT", 2003), new loc_control_id("IDS_LABEL_TXT", 2004), new loc_control_id("IDS_CSM_HELP_TXT", 2005), new loc_control_id("IDS_UPDATE_SETTINGS_GRP", 2006), new loc_control_id("IDS_UPDATE_FREQUENCY_TXT", 2007), new loc_control_id("IDS_INCLUDE_BETAS_TXT", 2008), new loc_control_id("IDS_NEW_VERSION_AVAIL_TXT", 2009), new loc_control_id("IDS_NEW_VERSION_DOWNLOAD_GRP", 2010), new loc_control_id("IDS_NEW_VERSION_NOTES_GRP", 2011), new loc_control_id("IDS_CHECK_NOW_GRP", 2012), new loc_control_id("IDS_TARGET_SYSTEM_TXT", 2013), new loc_control_id("IDS_IMAGE_OPTION_TXT", 2014), new loc_control_id("IDS_BOOT_SELECTION_TXT", 2015), new loc_control_id("IDS_DRIVE_PROPERTIES_TXT", 2016), new loc_control_id("IDS_FORMAT_OPTIONS_TXT", 2017), new loc_control_id("IDS_STATUS_TXT", 2018), new loc_control_id("MSG_000", 3000), new loc_control_id("MSG_001", 3001), new loc_control_id("MSG_002", 3002), new loc_control_id("MSG_003", 3003), new loc_control_id("MSG_004", 3004), new loc_control_id("MSG_005", 3005), new loc_control_id("MSG_006", 3006), new loc_control_id("MSG_007", 3007), new loc_control_id("MSG_008", 3008), new loc_control_id("MSG_009", 3009), new loc_control_id("MSG_010", 3010), new loc_control_id("MSG_011", 3011), new loc_control_id("MSG_012", 3012), new loc_control_id("MSG_013", 3013), new loc_control_id("MSG_014", 3014), new loc_control_id("MSG_015", 3015), new loc_control_id("MSG_016", 3016), new loc_control_id("MSG_017", 3017), new loc_control_id("MSG_018", 3018), new loc_control_id("MSG_019", 3019), new loc_control_id("MSG_020", 3020), new loc_control_id("MSG_021", 3021), new loc_control_id("MSG_022", 3022), new loc_control_id("MSG_023", 3023), new loc_control_id("MSG_024", 3024), new loc_control_id("MSG_025", 3025), new loc_control_id("MSG_026", 3026), new loc_control_id("MSG_027", 3027), new loc_control_id("MSG_028", 3028), new loc_control_id("MSG_029", 3029), new loc_control_id("MSG_030", 3030), new loc_control_id("MSG_031", 3031), new loc_control_id("MSG_032", 3032), new loc_control_id("MSG_033", 3033), new loc_control_id("MSG_034", 3034), new loc_control_id("MSG_035", 3035), new loc_control_id("MSG_036", 3036), new loc_control_id("MSG_037", 3037), new loc_control_id("MSG_038", 3038), new loc_control_id("MSG_039", 3039), new loc_control_id("MSG_040", 3040), new loc_control_id("MSG_041", 3041), new loc_control_id("MSG_042", 3042), new loc_control_id("MSG_043", 3043), new loc_control_id("MSG_044", 3044), new loc_control_id("MSG_045", 3045), new loc_control_id("MSG_046", 3046), new loc_control_id("MSG_047", 3047), new loc_control_id("MSG_048", 3048), new loc_control_id("MSG_049", 3049), new loc_control_id("MSG_050", 3050), new loc_control_id("MSG_051", 3051), new loc_control_id("MSG_052", 3052), new loc_control_id("MSG_053", 3053), new loc_control_id("MSG_054", 3054), new loc_control_id("MSG_055", 3055), new loc_control_id("MSG_056", 3056), new loc_control_id("MSG_057", 3057), new loc_control_id("MSG_058", 3058), new loc_control_id("MSG_059", 3059), new loc_control_id("MSG_060", 3060), new loc_control_id("MSG_061", 3061), new loc_control_id("MSG_062", 3062), new loc_control_id("MSG_063", 3063), new loc_control_id("MSG_064", 3064), new loc_control_id("MSG_065", 3065), new loc_control_id("MSG_066", 3066), new loc_control_id("MSG_067", 3067), new loc_control_id("MSG_068", 3068), new loc_control_id("MSG_069", 3069), new loc_control_id("MSG_070", 3070), new loc_control_id("MSG_071", 3071), new loc_control_id("MSG_072", 3072), new loc_control_id("MSG_073", 3073), new loc_control_id("MSG_074", 3074), new loc_control_id("MSG_075", 3075), new loc_control_id("MSG_076", 3076), new loc_control_id("MSG_077", 3077), new loc_control_id("MSG_078", 3078), new loc_control_id("MSG_079", 3079), new loc_control_id("MSG_080", 3080), new loc_control_id("MSG_081", 3081), new loc_control_id("MSG_082", 3082), new loc_control_id("MSG_083", 3083), new loc_control_id("MSG_084", 3084), new loc_control_id("MSG_085", 3085), new loc_control_id("MSG_086", 3086), new loc_control_id("MSG_087", 3087), new loc_control_id("MSG_088", 3088), new loc_control_id("MSG_089", 3089), new loc_control_id("MSG_090", 3090), new loc_control_id("MSG_091", 3091), new loc_control_id("MSG_092", 3092), new loc_control_id("MSG_093", 3093), new loc_control_id("MSG_094", 3094), new loc_control_id("MSG_095", 3095), new loc_control_id("MSG_096", 3096), new loc_control_id("MSG_097", 3097), new loc_control_id("MSG_098", 3098), new loc_control_id("MSG_099", 3099), new loc_control_id("MSG_100", 3100), new loc_control_id("MSG_101", 3101), new loc_control_id("MSG_102", 3102), new loc_control_id("MSG_103", 3103), new loc_control_id("MSG_104", 3104), new loc_control_id("MSG_105", 3105), new loc_control_id("MSG_106", 3106), new loc_control_id("MSG_107", 3107), new loc_control_id("MSG_108", 3108), new loc_control_id("MSG_109", 3109), new loc_control_id("MSG_110", 3110), new loc_control_id("MSG_111", 3111), new loc_control_id("MSG_112", 3112), new loc_control_id("MSG_113", 3113), new loc_control_id("MSG_114", 3114), new loc_control_id("MSG_115", 3115), new loc_control_id("MSG_116", 3116), new loc_control_id("MSG_117", 3117), new loc_control_id("MSG_118", 3118), new loc_control_id("MSG_119", 3119), new loc_control_id("MSG_120", 3120), new loc_control_id("MSG_121", 3121), new loc_control_id("MSG_122", 3122), new loc_control_id("MSG_123", 3123), new loc_control_id("MSG_124", 3124), new loc_control_id("MSG_125", 3125), new loc_control_id("MSG_126", 3126), new loc_control_id("MSG_127", 3127), new loc_control_id("MSG_128", 3128), new loc_control_id("MSG_129", 3129), new loc_control_id("MSG_130", 3130), new loc_control_id("MSG_131", 3131), new loc_control_id("MSG_132", 3132), new loc_control_id("MSG_133", 3133), new loc_control_id("MSG_134", 3134), new loc_control_id("MSG_135", 3135), new loc_control_id("MSG_136", 3136), new loc_control_id("MSG_137", 3137), new loc_control_id("MSG_138", 3138), new loc_control_id("MSG_139", 3139), new loc_control_id("MSG_140", 3140), new loc_control_id("MSG_141", 3141), new loc_control_id("MSG_142", 3142), new loc_control_id("MSG_143", 3143), new loc_control_id("MSG_144", 3144), new loc_control_id("MSG_145", 3145), new loc_control_id("MSG_146", 3146), new loc_control_id("MSG_147", 3147), new loc_control_id("MSG_148", 3148), new loc_control_id("MSG_149", 3149), new loc_control_id("MSG_150", 3150), new loc_control_id("MSG_151", 3151), new loc_control_id("MSG_152", 3152), new loc_control_id("MSG_153", 3153), new loc_control_id("MSG_154", 3154), new loc_control_id("MSG_155", 3155), new loc_control_id("MSG_156", 3156), new loc_control_id("MSG_157", 3157), new loc_control_id("MSG_158", 3158), new loc_control_id("MSG_159", 3159), new loc_control_id("MSG_160", 3160), new loc_control_id("MSG_161", 3161), new loc_control_id("MSG_162", 3162), new loc_control_id("MSG_163", 3163), new loc_control_id("MSG_164", 3164), new loc_control_id("MSG_165", 3165), new loc_control_id("MSG_166", 3166), new loc_control_id("MSG_167", 3167), new loc_control_id("MSG_168", 3168), new loc_control_id("MSG_169", 3169), new loc_control_id("MSG_170", 3170), new loc_control_id("MSG_171", 3171), new loc_control_id("MSG_172", 3172), new loc_control_id("MSG_173", 3173), new loc_control_id("MSG_174", 3174), new loc_control_id("MSG_175", 3175), new loc_control_id("MSG_176", 3176), new loc_control_id("MSG_177", 3177), new loc_control_id("MSG_178", 3178), new loc_control_id("MSG_179", 3179), new loc_control_id("MSG_180", 3180), new loc_control_id("MSG_181", 3181), new loc_control_id("MSG_182", 3182), new loc_control_id("MSG_183", 3183), new loc_control_id("MSG_184", 3184), new loc_control_id("MSG_185", 3185), new loc_control_id("MSG_186", 3186), new loc_control_id("MSG_187", 3187), new loc_control_id("MSG_188", 3188), new loc_control_id("MSG_189", 3189), new loc_control_id("MSG_190", 3190), new loc_control_id("MSG_191", 3191), new loc_control_id("MSG_192", 3192), new loc_control_id("MSG_193", 3193), new loc_control_id("MSG_194", 3194), new loc_control_id("MSG_195", 3195), new loc_control_id("MSG_196", 3196), new loc_control_id("MSG_197", 3197), new loc_control_id("MSG_198", 3198), new loc_control_id("MSG_199", 3199), new loc_control_id("MSG_200", 3200), new loc_control_id("MSG_201", 3201), new loc_control_id("MSG_202", 3202), new loc_control_id("MSG_203", 3203), new loc_control_id("MSG_204", 3204), new loc_control_id("MSG_205", 3205), new loc_control_id("MSG_206", 3206), new loc_control_id("MSG_207", 3207), new loc_control_id("MSG_208", 3208), new loc_control_id("MSG_209", 3209), new loc_control_id("MSG_210", 3210), new loc_control_id("MSG_211", 3211), new loc_control_id("MSG_212", 3212), new loc_control_id("MSG_213", 3213), new loc_control_id("MSG_214", 3214), new loc_control_id("MSG_215", 3215), new loc_control_id("MSG_216", 3216), new loc_control_id("MSG_217", 3217), new loc_control_id("MSG_218", 3218), new loc_control_id("MSG_219", 3219), new loc_control_id("MSG_220", 3220), new loc_control_id("MSG_221", 3221), new loc_control_id("MSG_222", 3222), new loc_control_id("MSG_223", 3223), new loc_control_id("MSG_224", 3224), new loc_control_id("MSG_225", 3225), new loc_control_id("MSG_226", 3226), new loc_control_id("MSG_227", 3227), new loc_control_id("MSG_228", 3228), new loc_control_id("MSG_229", 3229), new loc_control_id("MSG_230", 3230), new loc_control_id("MSG_231", 3231), new loc_control_id("MSG_232", 3232), new loc_control_id("MSG_233", 3233), new loc_control_id("MSG_234", 3234), new loc_control_id("MSG_235", 3235), new loc_control_id("MSG_236", 3236), new loc_control_id("MSG_237", 3237), new loc_control_id("MSG_238", 3238), new loc_control_id("MSG_239", 3239), new loc_control_id("MSG_240", 3240), new loc_control_id("MSG_241", 3241), new loc_control_id("MSG_242", 3242), new loc_control_id("MSG_243", 3243), new loc_control_id("MSG_244", 3244), new loc_control_id("MSG_245", 3245), new loc_control_id("MSG_246", 3246), new loc_control_id("MSG_247", 3247), new loc_control_id("MSG_248", 3248), new loc_control_id("MSG_249", 3249), new loc_control_id("MSG_250", 3250), new loc_control_id("MSG_251", 3251), new loc_control_id("MSG_252", 3252), new loc_control_id("MSG_253", 3253), new loc_control_id("MSG_254", 3254), new loc_control_id("MSG_255", 3255), new loc_control_id("MSG_256", 3256), new loc_control_id("MSG_257", 3257), new loc_control_id("MSG_258", 3258), new loc_control_id("MSG_259", 3259), new loc_control_id("MSG_260", 3260), new loc_control_id("MSG_261", 3261), new loc_control_id("MSG_262", 3262), new loc_control_id("MSG_263", 3263), new loc_control_id("MSG_264", 3264), new loc_control_id("MSG_265", 3265), new loc_control_id("MSG_266", 3266), new loc_control_id("MSG_267", 3267), new loc_control_id("MSG_268", 3268), new loc_control_id("MSG_269", 3269), new loc_control_id("MSG_270", 3270), new loc_control_id("MSG_271", 3271), new loc_control_id("MSG_272", 3272), new loc_control_id("MSG_273", 3273), new loc_control_id("MSG_274", 3274), new loc_control_id("MSG_275", 3275), new loc_control_id("MSG_276", 3276), new loc_control_id("MSG_277", 3277), new loc_control_id("MSG_278", 3278), new loc_control_id("MSG_279", 3279), new loc_control_id("MSG_280", 3280), new loc_control_id("MSG_281", 3281), new loc_control_id("MSG_282", 3282), new loc_control_id("MSG_283", 3283), new loc_control_id("MSG_284", 3284), new loc_control_id("MSG_285", 3285), new loc_control_id("MSG_286", 3286), new loc_control_id("MSG_287", 3287), new loc_control_id("MSG_288", 3288), new loc_control_id("MSG_289", 3289), new loc_control_id("MSG_290", 3290), new loc_control_id("MSG_291", 3291), new loc_control_id("MSG_292", 3292), new loc_control_id("MSG_293", 3293), new loc_control_id("MSG_294", 3294), new loc_control_id("MSG_295", 3295), new loc_control_id("MSG_296", 3296), new loc_control_id("MSG_297", 3297), new loc_control_id("MSG_298", 3298), new loc_control_id("MSG_299", 3299), new loc_control_id("MSG_300", 3300), new loc_control_id("MSG_301", 3301), new loc_control_id("MSG_302", 3302), new loc_control_id("MSG_303", 3303), new loc_control_id("MSG_304", 3304), new loc_control_id("MSG_305", 3305), new loc_control_id("MSG_306", 3306), new loc_control_id("MSG_307", 3307), new loc_control_id("MSG_308", 3308), new loc_control_id("MSG_309", 3309), new loc_control_id("MSG_310", 3310), new loc_control_id("MSG_311", 3311), new loc_control_id("MSG_312", 3312), new loc_control_id("MSG_313", 3313), new loc_control_id("MSG_314", 3314), new loc_control_id("MSG_315", 3315), new loc_control_id("MSG_316", 3316), new loc_control_id("MSG_317", 3317), new loc_control_id("MSG_318", 3318), new loc_control_id("MSG_319", 3319), new loc_control_id("MSG_320", 3320), new loc_control_id("MSG_MAX", 3321), new loc_control_id("IDOK", 1), new loc_control_id("IDCANCEL", 2), new loc_control_id("IDABORT", 3), new loc_control_id("IDRETRY", 4), new loc_control_id("IDIGNORE", 5), new loc_control_id("IDYES", 6), new loc_control_id("IDNO", 7), new loc_control_id("IDCLOSE", 8), new loc_control_id("IDHELP", 9)};
	public static loc_dlg_list[] loc_dlg = new loc_dlg_list[]{{101, ((Object)0), new loc_dlg_list(((Object)0), ((Object)0))}, {102, ((Object)0), new loc_dlg_list(((Object)0), ((Object)0))}, {103, ((Object)0), new loc_dlg_list(((Object)0), ((Object)0))}, {104, ((Object)0), new loc_dlg_list(((Object)0), ((Object)0))}, {105, ((Object)0), new loc_dlg_list(((Object)0), ((Object)0))}, {106, ((Object)0), new loc_dlg_list(((Object)0), ((Object)0))}, {107, ((Object)0), new loc_dlg_list(((Object)0), ((Object)0))}, {108, ((Object)0), new loc_dlg_list(((Object)0), ((Object)0))}, {109, ((Object)0), new loc_dlg_list(((Object)0), ((Object)0))}, {110, ((Object)0), new loc_dlg_list(((Object)0), ((Object)0))}};
	public static  debugger_xa_misc_enum = new ();
	public static ext2fs_struct_generic_bitmap_32 ext2fs_generic_bitmap_32 = new ext2fs_struct_generic_bitmap_32();
	public static Object _uprintfs;
	public static INT_PTR Callback_t = new INT_PTR();
	public static RUFUS_IMG_REPORT img_report = new RUFUS_IMG_REPORT();
	public static HWND hCapacity = new HWND();
	public static HWND hInfo = new HWND();
	public static int64_t iso_blocking_status = new int64_t();
	public static uint8_t popcnt8 = new uint8_t();
	public static Object GetWindowsVersion;
	public static BOOL is_x64 = new BOOL();
	public static BOOL GetCpuArch = new BOOL();
	public static byte WindowsErrorString;
	public static Object DumpBufferHex;
	public static Object PrintStatusInfo;
	public static Object UpdateProgress;
	public static Object UpdateProgressWithInfo;
	public static byte StrError;
	public static byte GuidToString;
	public static byte SizeToHumanReadable;
	public static byte TimestampToHumanReadable;
	public static HWND MyCreateDialog = new HWND();
	public static INT_PTR MyDialogBox = new INT_PTR();
	public static Object CenterDialog;
	public static Object ResizeMoveCtrl;
	public static Object ResizeButtonHeight;
	public static Object CreateStatusBar;
	public static Object CreateStaticFont;
	public static Object SetTitleBarIcon;
	public static BOOL CreateTaskbarList = new BOOL();
	public static BOOL SetTaskbarProgressState = new BOOL();
	public static BOOL SetTaskbarProgressValue = new BOOL();
	public static INT_PTR CreateAboutBox = new INT_PTR();
	public static BOOL CreateTooltip = new BOOL();
	public static Object DestroyTooltip;
	public static Object DestroyAllTooltips;
	public static BOOL Notification = new BOOL();
	public static int SelectionDialog;
	public static Object ListDialog;
	public static SIZE GetTextSize = new SIZE();
	public static BOOL ExtractAppIcon = new BOOL();
	public static BOOL ExtractDOS = new BOOL();
	public static BOOL ExtractISO = new BOOL();
	public static int64_t ExtractISOFile = new int64_t();
	public static BOOL HasEfiImgBootLoaders = new BOOL();
	public static BOOL DumpFatDir = new BOOL();
	public static byte MountISO;
	public static Object UnMountISO;
	public static BOOL InstallSyslinux = new BOOL();
	public static uint16_t GetSyslinuxVersion = new uint16_t();
	public static BOOL SetAutorun = new BOOL();
	public static byte FileDialog;
	public static BOOL FileIO = new BOOL();
	public static byte GetResource;
	public static DWORD GetResourceSize = new DWORD();
	public static DWORD RunCommand = new DWORD();
	public static BOOL CompareGUID = new BOOL();
	public static BOOL SetLGP = new BOOL();
	public static LONG GetEntryWidth = new LONG();
	public static uint64_t DownloadToFileOrBuffer = new uint64_t();
	public static DWORD DownloadSignedFile = new DWORD();
	public static HANDLE DownloadSignedFileThreaded = new HANDLE();
	public static INT_PTR UpdateCallback = new INT_PTR();
	public static BOOL SetUpdateCheck = new BOOL();
	public static BOOL CheckForUpdates = new BOOL();
	public static Object DownloadNewVersion;
	public static BOOL DownloadISO = new BOOL();
	public static BOOL IsDownloadable = new BOOL();
	public static BOOL IsShown = new BOOL();
	public static byte get_token_data_file_indexed;
	public static byte set_token_data_file;
	public static byte get_token_data_buffer;
	public static byte insert_section_data;
	public static byte replace_in_token_data;
	public static byte replace_char;
	public static Object parse_update;
	public static Object get_data_from_asn1;
	public static uint8_t WimExtractCheck = new uint8_t();
	public static BOOL WimExtractFile = new BOOL();
	public static BOOL WimExtractFile_API = new BOOL();
	public static BOOL WimExtractFile_7z = new BOOL();
	public static BOOL WimApplyImage = new BOOL();
	public static BOOL IsBootableImage = new BOOL();
	public static BOOL AppendVHDFooter = new BOOL();
	public static int SetWinToGoIndex;
	public static int IsHDD;
	public static byte GetSignatureName;
	public static uint64_t GetSignatureTimeStamp = new uint64_t();
	public static LONG ValidateSignature = new LONG();
	public static BOOL ValidateOpensslSignature = new BOOL();
	public static BOOL IsFontAvailable = new BOOL();
	public static BOOL WriteFileWithRetry = new BOOL();
	public static BOOL SetThreadAffinity = new BOOL();
	public static BOOL HashFile = new BOOL();
	public static BOOL HashBuffer = new BOOL();
	public static BOOL IsFileInDB = new BOOL();
	public static BOOL IsBufferInDB = new BOOL();
	public static byte _printbits;
	public static BOOL IsCurrentProcessElevated = new BOOL();
	public static byte GetCurrentMUI;
	public static Object SetAlertPromptMessages;
	public static BOOL SetAlertPromptHook = new BOOL();
	public static Object ClrAlertPromptHook;
	public static DWORD CheckDriveAccess = new DWORD();
	public static BYTE SearchProcess = new BYTE();
	public static BOOL EnablePrivileges = new BOOL();
	public static Object FlashTaskbar;
	public static DWORD WaitForSingleObjectWithMessages = new DWORD();
	public static HICON CreateMirroredIcon = new HICON();
	public static DWORD FormatThread = new DWORD();
	public static DWORD SaveImageThread = new DWORD();
	public static DWORD SumThread = new DWORD();
	public static BOOL htab_create = new BOOL();
	public static Object htab_destroy;
	public static uint32_t htab_hash = new uint32_t();
	public static Object StrArrayCreate;
	public static int32_t StrArrayAdd = new int32_t();
	public static int32_t StrArrayFind = new int32_t();
	public static Object StrArrayClear;
	public static Object StrArrayDestroy;
	public static  cdio_drive_read_cap_t = new ();
	public static  cdio_drive_write_cap_t = new ();
	public static  cdio_drive_misc_cap_t = new ();
	public static driver_id_t[] cdio_drivers = new driver_id_t();
	public static driver_id_t[] cdio_device_drivers = new driver_id_t();
	public static driver_id_t cdio_os_driver = new driver_id_t();
	public static driver_return_code_t cdio_close_tray = new driver_return_code_t();
	public static byte cdio_driver_errmsg;
	public static driver_return_code_t cdio_eject_media = new driver_return_code_t();
	public static driver_return_code_t cdio_eject_media_drive = new driver_return_code_t();
	public static Object cdio_free_device_list;
	public static byte cdio_get_default_device;
	public static byte cdio_get_default_device_driver;
	public static byte cdio_get_devices;
	public static byte cdio_get_devices_with_cap;
	public static byte cdio_get_devices_with_cap_ret;
	public static byte cdio_get_devices_ret;
	public static Object cdio_get_drive_cap;
	public static Object cdio_get_drive_cap_dev;
	public static byte cdio_get_driver_name;
	public static byte cdio_get_driver_name_from_id;
	public static driver_id_t cdio_get_driver_id = new driver_id_t();
	public static  cdio_get_hwinfo = new ();
	public static driver_return_code_t cdio_get_last_session = new driver_return_code_t();
	public static int cdio_get_media_changed;
	public static  cdio_have_atapi = new ();
	public static  cdio_have_driver = new ();
	public static Object cdio_destroy;
	public static byte cdio_driver_describe;
	public static  cdio_open = new ();
	public static  cdio_open_am = new ();
	public static  cdio_open_bincue = new ();
	public static  cdio_open_am_bincue = new ();
	public static  cdio_open_cdrdao = new ();
	public static  cdio_open_am_cdrdao = new ();
	public static byte cdio_get_default_device_bincue;
	public static byte cdio_get_devices_bincue;
	public static byte cdio_get_default_device_cdrdao;
	public static byte cdio_get_devices_cdrdao;
	public static  cdio_open_cd = new ();
	public static  cdio_open_am_cd = new ();
	public static  cdio_open_cue = new ();
	public static  cdio_open_am_aix = new ();
	public static  cdio_open_aix = new ();
	public static byte cdio_get_default_device_aix;
	public static byte cdio_get_devices_aix;
	public static  cdio_open_bsdi = new ();
	public static  cdio_open_am_bsdi = new ();
	public static byte cdio_get_default_device_bsdi;
	public static byte cdio_get_devices_bsdi;
	public static  cdio_open_freebsd = new ();
	public static  cdio_open_am_freebsd = new ();
	public static byte cdio_get_default_device_freebsd;
	public static byte cdio_get_devices_freebsd;
	public static  cdio_open_linux = new ();
	public static  cdio_open_am_linux = new ();
	public static byte cdio_get_default_device_linux;
	public static byte cdio_get_devices_linux;
	public static  cdio_open_solaris = new ();
	public static  cdio_open_am_solaris = new ();
	public static byte cdio_get_default_device_solaris;
	public static byte cdio_get_devices_solaris;
	public static  cdio_open_osx = new ();
	public static  cdio_open_am_osx = new ();
	public static byte cdio_get_default_device_osx;
	public static byte cdio_get_devices_osx;
	public static  cdio_open_win32 = new ();
	public static  cdio_open_am_win32 = new ();
	public static byte cdio_get_default_device_win32;
	public static byte cdio_get_devices_win32;
	public static  cdio_open_os2 = new ();
	public static  cdio_open_am_os2 = new ();
	public static byte cdio_get_default_device_os2;
	public static byte cdio_get_devices_os2;
	public static  cdio_open_nrg = new ();
	public static  cdio_open_am_nrg = new ();
	public static byte cdio_get_default_device_nrg;
	public static byte cdio_get_devices_nrg;
	public static byte cdio_is_binfile;
	public static byte cdio_is_cuefile;
	public static  cdio_is_nrg = new ();
	public static  cdio_is_tocfile = new ();
	public static  cdio_is_device = new ();
	public static driver_return_code_t cdio_set_blocksize = new driver_return_code_t();
	public static driver_return_code_t cdio_set_speed = new driver_return_code_t();
	public static byte cdio_get_arg;
	public static driver_return_code_t cdio_set_arg = new driver_return_code_t();
	public static  cdio_init = new ();
	public static cdio_drive_cap_misc_t debug_cdio_drive_cap_misc = new cdio_drive_cap_misc_t();
	public static cdio_drive_cap_read_t debug_cdio_drive_cap_read_t = new cdio_drive_cap_read_t();
	public static cdio_drive_cap_write_t debug_drive_cap_write_t = new cdio_drive_cap_write_t();
	public static cdio_mmc_hw_len_t debug_cdio_mmc_hw_len = new cdio_mmc_hw_len_t();
	public static cdio_src_category_mask_t debug_cdio_src_category_mask = new cdio_src_category_mask_t();
	public static  open_namei = new ();
	public static byte[] mbr_vista_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* First 446 bytes of MBR from Windows Vista *//* This is English version. Bytes 0x162 onwards vary with language. *//* Last three bytes 1b5-1b7 point to language-specific messages.    *//* Support of other languages is an exercise for the reader!        *//* see: http://thestarman.pcministry.com/asm/mbr/VistaMBR.htm       */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024/* Next four bytes used for Windows Disk Signature / Drive serial number *//*
	unsigned char mbr_vista_0x1b8[] = {
	                                                  0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00
	};
	*/};
	public static byte[] mbr_grub_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /*
	 * First 423 bytes of MBR from Grub4DOS (Converted from res/grub/grldr.mbr)
	 */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static  iso711_t = new ();
	public static  iso712_t = new ();
	public static  iso721_t = new ();
	public static  iso722_t = new ();
	public static  iso723_t = new ();
	public static  iso731_t = new ();
	public static  iso732_t = new ();
	public static  iso733_t = new ();
	public static byte achar_t;
	public static byte dchar_t;
	public static byte[] ISO_STANDARD_ID = new byte[/*! \brief Maximum number of characters in a publisher id. *//*! \brief Maximum number of characters in an application id. *//*! \brief Maximum number of characters in a volume id. *//*! \brief Maximum number of characters in a volume-set id. *//*! \brief Maximum number of multi file extent licdio supports. *//*Error: sizeof expression not supported yet*/ - /*! String inside frame which identifies an ISO 9660 filesystem. This
	    string is the "id" field of an iso9660_pvd_t or an iso9660_svd_t.
	*/1];
	public static iso9660_dtime_s iso9660_dtime_t = new iso9660_dtime_s();
	public static iso9660_ltime_s iso9660_ltime_t = new iso9660_ltime_s();
	public static iso9660_dir_s iso9660_dir_t = new iso9660_dir_s();
	public static iso9660_stat_s iso9660_stat_t = new iso9660_stat_s();
	public static iso9660_pvd_s iso9660_pvd_t = new iso9660_pvd_s();
	public static iso9660_svd_s iso9660_svd_t = new iso9660_svd_s();
	public static  CdioISO9660FileList_t = new ();
	public static  CdioISO9660DirList_t = new ();
	public static  iso_extension_mask_t = new ();
	public static _iso9660_s iso9660_t = new _iso9660_s();
	public static  iso9660_close = new ();
	public static iso9660_t iso9660_open = new iso9660_t();
	public static iso9660_t iso9660_open_ext = new iso9660_t();
	public static iso9660_t iso9660_open_fuzzy = new iso9660_t();
	public static iso9660_t iso9660_open_fuzzy_ext = new iso9660_t();
	public static  iso9660_ifs_fuzzy_read_superblock = new ();
	public static long iso9660_iso_seek_read;
	public static  iso9660_fs_read_pvd = new ();
	public static  iso9660_ifs_read_pvd = new ();
	public static  iso9660_fs_read_superblock = new ();
	public static  iso9660_ifs_read_superblock = new ();
	public static Object iso9660_set_dtime;
	public static Object iso9660_set_dtime_with_timezone;
	public static Object iso9660_set_ltime;
	public static Object iso9660_set_ltime_with_timezone;
	public static  iso9660_get_dtime = new ();
	public static  iso9660_get_ltime = new ();
	public static  iso9660_is_dchar = new ();
	public static  iso9660_is_achar = new ();
	public static int iso9660_name_translate;
	public static int iso9660_name_translate_ext;
	public static byte iso9660_strncpy_pad;
	public static  iso9660_dirname_valid_p = new ();
	public static byte iso9660_pathname_isofy;
	public static  iso9660_pathname_valid_p = new ();
	public static Object iso9660_dir_init_new;
	public static Object iso9660_dir_init_new_su;
	public static Object iso9660_dir_add_entry_su;
	public static int iso9660_dir_calc_record_size;
	public static iso9660_stat_t iso9660_find_fs_lsn = new iso9660_stat_t();
	public static iso9660_stat_t iso9660_fs_find_lsn_with_path = new iso9660_stat_t();
	public static iso9660_stat_t iso9660_ifs_find_lsn = new iso9660_stat_t();
	public static iso9660_stat_t iso9660_ifs_find_lsn_with_path = new iso9660_stat_t();
	public static Object iso9660_stat_free;
	public static iso9660_stat_t iso9660_fs_stat = new iso9660_stat_t();
	public static iso9660_stat_t iso9660_fs_stat_translate = new iso9660_stat_t();
	public static iso9660_stat_t iso9660_ifs_stat = new iso9660_stat_t();
	public static iso9660_stat_t iso9660_ifs_stat_translate = new iso9660_stat_t();
	public static CdioISO9660FileList_t iso9660_filelist_new = new CdioISO9660FileList_t();
	public static CdioISO9660DirList_t iso9660_dirlist_new = new CdioISO9660DirList_t();
	public static Object iso9660_filelist_free;
	public static Object iso9660_dirlist_free;
	public static  iso9660_fs_readdir = new ();
	public static  iso9660_ifs_readdir = new ();
	public static byte iso9660_get_application_id;
	public static  iso9660_ifs_get_application_id = new ();
	public static  iso9660_ifs_get_joliet_level = new ();
	public static  iso9660_get_dir_len = new ();
	public static byte iso9660_dir_to_name;
	public static  iso9660_get_posix_filemode = new ();
	public static byte iso9660_get_preparer_id;
	public static  iso9660_ifs_get_preparer_id = new ();
	public static byte iso9660_get_publisher_id;
	public static  iso9660_ifs_get_publisher_id = new ();
	public static  iso9660_get_pvd_type = new ();
	public static byte iso9660_get_pvd_id;
	public static int iso9660_get_pvd_space_size;
	public static int iso9660_get_pvd_block_size;
	public static int iso9660_get_pvd_version;
	public static byte iso9660_get_system_id;
	public static  iso9660_have_rr = new ();
	public static  iso9660_ifs_get_system_id = new ();
	public static  iso9660_get_root_lsn = new ();
	public static byte iso9660_get_volume_id;
	public static  iso9660_ifs_get_volume_id = new ();
	public static byte iso9660_get_volumeset_id;
	public static  iso9660_ifs_get_volumeset_id = new ();
	public static Object iso9660_pathtable_init;
	public static int iso9660_pathtable_get_size;
	public static  iso9660_pathtable_l_add_entry = new ();
	public static  iso9660_pathtable_m_add_entry = new ();
	public static Object iso9660_set_pvd;
	public static Object iso9660_set_evd;
	public static  iso9660_ifs_is_xa = new ();
	public static byte ext2fs_block_string;
	public static byte ext2fs_inode_string;
	public static byte ext2fs_mark_string;
	public static byte ext2fs_unmark_string;
	public static byte ext2fs_test_string;
	public static Object ext2fs_warn_bitmap;
	public static Object ext2fs_warn_bitmap2;
	public static Object ext2fs_mark_block_bitmap_range;
	public static Object ext2fs_unmark_block_bitmap_range;
	public static int ext2fs_test_block_bitmap_range;
	public static int ext2fs_test_inode_bitmap_range;
	public static int ext2fs_mark_generic_bitmap;
	public static int ext2fs_unmark_generic_bitmap;
	public static int ext2fs_test_generic_bitmap;
	public static Object ext2fs_set_bitmap_padding;
	public static  ext2fs_get_generic_bitmap_start = new ();
	public static  ext2fs_get_generic_bitmap_end = new ();
	public static int ext2fs_test_block_bitmap_range2;
	public static  ext2fs_get_generic_bmap_start = new ();
	public static  ext2fs_get_generic_bmap_end = new ();
	public static Object ext2fs_mark_block_bitmap_range2;
	public static Object ext2fs_unmark_block_bitmap_range2;
	public static  ext2fs_find_first_zero_generic_bmap = new ();
	public static  ext2fs_find_first_set_generic_bmap = new ();
	public static int ext2fs_set_bit64;
	public static int ext2fs_clear_bit64;
	public static int ext2fs_test_bit64;
	public static int ext2fs_bitcount;
	public static byte[] br_fat16_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static FILE log_fd = /*
	 * badblocks.c - Bad blocks checker
	 *
	 * Copyright 1992-1994 Remy Card <card@masi.ibp.fr>
	 * Copyright 1995-1999 Theodore Ts'o
	 * Copyright 1999 David Beattie
	 * Copyright 2011-2019 Pete Batard <pete@akeo.ie>
	 *
	 * This file is based on the minix file system programs fsck and mkfs
	 * written and copyrighted by Linus Torvalds <Linus.Torvalds@cs.helsinki.fi>
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Public License.
	 * %End-Header%
	 */((Object)0);
	public static byte[] abort_msg = "Too many bad blocks, aborting test\n";
	public static byte[] bb_prefix = "Bad Blocks: "/*
	 *From e2fsprogs/lib/ext2fs/badblocks.c
	 */;
	public static int v_flag = /*
	 * from e2fsprogs/misc/badblocks.c
	 *//* verbose */1;
	public static int s_flag = /* show progress of test */1;
	public static int cancel_ops = /* abort current operation */0;
	public static int cur_pattern;
	public static int nr_pattern;
	public static int cur_op;
	public static int max_bb = /* Abort test if more than this number of bad blocks has been encountered */256;
	public static  currently_testing = 0;
	public static  num_blocks = 0;
	public static uint32_t num_read_errors = 0;
	public static uint32_t num_write_errors = 0;
	public static uint32_t num_corruption_errors = 0;
	public static bb_badblocks_list bb_list = ((Object)0);
	public static  next_bad = 0;
	public static bb_badblocks_iterate bb_iter = ((Object)0);
	public static cdtext_s cdtext_t = new cdtext_s();
	public static byte cdtext_genre2str;
	public static byte cdtext_lang2str;
	public static byte cdtext_field2str;
	public static cdtext_t cdtext_init = new cdtext_t();
	public static int cdtext_data_init;
	public static Object cdtext_destroy;
	public static byte cdtext_get;
	public static byte cdtext_get_const;
	public static cdtext_genre_t cdtext_get_genre = new cdtext_genre_t();
	public static cdtext_lang_t cdtext_get_language = new cdtext_lang_t();
	public static  cdtext_get_first_track = new ();
	public static  cdtext_get_last_track = new ();
	public static  cdtext_select_language = new ();
	public static cdtext_lang_t cdtext_list_languages = new cdtext_lang_t();
	public static Object cdtext_set;
	public static byte[] br_ntfs_0x54 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static  cdio_generic_unimplemented_eject_media = new ();
	public static  cdio_generic_unimplemented_set_blocksize = new ();
	public static  cdio_generic_unimplemented_set_speed = new ();
	public static Object cdio_generic_free;
	public static  cdio_generic_init = new ();
	public static  cdio_generic_lseek = new ();
	public static  cdio_generic_read = new ();
	public static int cdio_generic_read_form1_sector;
	public static Object cdio_generic_stdio_free;
	public static  cdio_is_device_win32 = new ();
	public static  cdio_is_device_os2 = new ();
	public static  cdio_is_device_generic = new ();
	public static  cdio_is_device_quiet_generic = new ();
	public static  get_cdtext_generic = new ();
	public static  get_first_track_num_generic = new ();
	public static  get_num_tracks_generic = new ();
	public static  get_discmode_generic = new ();
	public static  get_discmode_cd_generic = new ();
	public static int get_track_channels_generic;
	public static  get_track_copy_permit_generic = new ();
	public static  get_track_preemphasis_generic = new ();
	public static  read_cdtext_generic = new ();
	public static Object set_track_flags;
	public static  read_data_sectors_generic = new ();
	public static byte[] br_fat32pe_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static byte[][] sum_str = new byte[checksum_type.CHECKSUM_MAX][/*
	 * Rufus: The Reliable USB Formatting Utility
	 * Message-Digest algorithms (md5sum, sha1sum, sha256sum)
	 * Copyright Â© 1998-2001 Free Software Foundation, Inc.
	 * Copyright Â© 2004 g10 Code GmbH
	 * Copyright Â© 2002-2015 Wei Dai & Igor Pavlov
	 * Copyright Â© 2015-2019 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 *//*
	 * SHA-1 code taken from GnuPG, as per copyrights above.
	 *
	 * SHA-256 taken from 7-zip's Sha256.c, itself based on Crypto++ - Public Domain
	 *
	 * MD5 code from various public domain sources sharing the following
	 * copyright declaration:
	 *
	 * This code implements the MD5 message-digest algorithm.
	 * The algorithm is due to Ron Rivest.  This code was
	 * written by Colin Plumb in 1993, no copyright is claimed.
	 * This code is in the public domain; do with it what you wish.
	 *
	 * Equivalent code is available from RSA Data Security, Inc.
	 * This code has been tested against that, and is equivalent,
	 * except that you don't need to include two pages of legalese
	 * with every copy.
	 *
	 * To compute the message digest of a chunk of bytes, declare an
	 * MD5Context structure, pass it to MD5Init, call MD5Update as
	 * needed on buffers full of bytes, and then call MD5Final, which
	 * will fill a supplied 16-byte array with the digest.
	 *//* Globals */65];
	public static uint32_t bufnum = new uint32_t();
	public static uint32_t[] sum_count = new uint32_t[]{16, 20, 32};
	public static HANDLE[] data_ready = new HANDLE[]{0};
	public static HANDLE[] thread_ready = new HANDLE[]{0};
	public static DWORD[] read_size = new DWORD();
	public static byte[][] buffer = new byte[2][(64 * -1024/*
	 * Rotate 32 bit integers by n bytes.
	 * Don't bother trying to hand-optimize those, as the
	 * compiler usually does a pretty good job at that.
	 */)];
	public static uint32_t[] K = new uint32_t[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024/*
	 * For convenience, we use a common context for all the checksum algorithms,
	 * which means some elements may be unused...
	 */};
	public static Object sum_init_t;
	public static Object sum_write_t;
	public static Object sum_final_t;
	public static sum_init_t[] sum_init = new sum_init_t[]{md5_init, sha1_init, sha256_init};
	public static sum_write_t[] sum_write = new sum_write_t[]{md5_write, sha1_write, sha256_write};
	public static sum_final_t[] sum_final = new sum_final_t[]{md5_final, sha1_final, sha256_final};
	public static  _handler = cdio_default_log_handler;
	public static HANDLE WIMCreateFile_t = new HANDLE();
	public static WIMCreateFile_t pfWIMCreateFile = ((Object)0);
	public static BOOL WIMSetTemporaryPath_t = new BOOL();
	public static WIMSetTemporaryPath_t pfWIMSetTemporaryPath = ((Object)0);
	public static HANDLE WIMLoadImage_t = new HANDLE();
	public static WIMLoadImage_t pfWIMLoadImage = ((Object)0);
	public static BOOL WIMApplyImage_t = new BOOL();
	public static WIMApplyImage_t pfWIMApplyImage = ((Object)0);
	public static BOOL WIMExtractImagePath_t = new BOOL();
	public static WIMExtractImagePath_t pfWIMExtractImagePath = ((Object)0);
	public static BOOL WIMGetImageInformation_t = new BOOL();
	public static WIMGetImageInformation_t pfWIMGetImageInformation = ((Object)0);
	public static BOOL WIMCloseHandle_t = new BOOL();
	public static WIMCloseHandle_t pfWIMCloseHandle = ((Object)0);
	public static DWORD WIMRegisterMessageCallback_t = new DWORD();
	public static WIMRegisterMessageCallback_t pfWIMRegisterMessageCallback = ((Object)0);
	public static DWORD WIMUnregisterMessageCallback_t = new DWORD();
	public static WIMUnregisterMessageCallback_t pfWIMUnregisterMessageCallback = ((Object)0);
	public static RPC_STATUS UuidCreate_t = new RPC_STATUS();
	public static UuidCreate_t pfUuidCreate = ((Object)0);
	public static uint8_t wim_flags = 0;
	public static byte[] sevenzip_path = new byte[260];
	public static byte[] conectix_str = new byte[]{(byte)'c', (byte)'o', (byte)'n', (byte)'e', (byte)'c', (byte)'t', (byte)'i', (byte)'x'};
	public static BOOL count_files = new BOOL();
	public static comp_assoc[] file_assoc = new comp_assoc[]{new comp_assoc(".zip", BLED_COMPRESSION_ZIP), new comp_assoc(".Z", BLED_COMPRESSION_LZW), new comp_assoc(".gz", BLED_COMPRESSION_GZIP), new comp_assoc(".lzma", BLED_COMPRESSION_LZMA), new comp_assoc(".bz2", BLED_COMPRESSION_BZIP2), new comp_assoc(".xz", BLED_COMPRESSION_XZ)};
	public static byte _image;
	public static byte _dst;
	public static int _index;
	public static uint8_t __u8 = new uint8_t();
	public static int8_t __s8 = new int8_t();
	public static uint16_t __u16 = new uint16_t();
	public static int16_t __s16 = new int16_t();
	public static uint32_t __u32 = new uint32_t();
	public static int32_t __s32 = new int32_t();
	public static uint64_t __u64 = new uint64_t();
	public static int64_t __s64 = new int64_t();
	public static __u16 __le16 = new __u16();
	public static __u32 __le32 = new __u32();
	public static __u64 __le64 = new __u64();
	public static __u16 __be16 = new __u16();
	public static __u32 __be32 = new __u32();
	public static __u64 __be64 = new __u64();
	public static  posix_mode_t = new ();
	public static  posix_nlink_t = new ();
	public static  posix_uid_t = new ();
	public static  posix_gid_t = new ();
	public static  unicode16_t = new ();
	public static byte[] syslinux_adv = new byte[/* ----------------------------------------------------------------------- *
	 *
	 *   Copyright 2007-2008 H. Peter Anvin - All Rights Reserved
	 *   Copyright 2010 Intel Corporation; author: H. Peter Anvin
	 *
	 *   This program is free software; you can redistribute it and/or modify
	 *   it under the terms of the GNU General Public License as published by
	 *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
	 *   Boston MA 02111-1307, USA; either version 2 of the License, or
	 *   (at your option) any later version; incorporated herein by reference.
	 *
	 * ----------------------------------------------------------------------- *//*
	 * setadv.c
	 *
	 * (Over)write a data item in the auxiliary data vector.  To
	 * delete an item, set its length to zero.
	 *
	 * Return 0 on success, -1 on error, and set errno.
	 *
	 */2 * 512/* Head signature *//* Total checksum */];
	public static byte cdio_dirname;
	public static byte cdio_abspath;
	public static _CdioDataSource CdioDataSource_t = new _CdioDataSource();
	public static  cdio_new = new ();
	public static CdIo_driver_t[] CdIo_driver = new CdIo_driver_t();
	public static int CdIo_last_driver;
	public static CdIo_driver_t[] CdIo_all_drivers = new CdIo_driver_t();
	public static Object cdio_add_device_list;
	public static  close_tray_bsdi = new ();
	public static  close_tray_freebsd = new ();
	public static  close_tray_linux = new ();
	public static  close_tray_netbsd = new ();
	public static  close_tray_osx = new ();
	public static  close_tray_solaris = new ();
	public static  close_tray_win32 = new ();
	public static  cdio_have_netbsd = new ();
	public static  cdio_open_netbsd = new ();
	public static byte cdio_get_default_device_netbsd;
	public static byte cdio_get_devices_netbsd;
	public static  cdio_open_am_netbsd = new ();
	public static  cdio_have_aix = new ();
	public static  cdio_have_bsdi = new ();
	public static  cdio_have_freebsd = new ();
	public static  cdio_have_linux = new ();
	public static  cdio_have_solaris = new ();
	public static  cdio_have_os2 = new ();
	public static  cdio_have_osx = new ();
	public static  cdio_have_win32 = new ();
	public static  cdio_have_nrg = new ();
	public static  cdio_have_bincue = new ();
	public static  cdio_have_cdrdao = new ();
	public static  udf_Uint8_t = new ();
	public static  udf_Uint16_t = new ();
	public static  udf_Uint32_t = new ();
	public static  udf_Uint64_t = new ();
	public static byte udf_dstring;
	public static udf_charspec_s udf_charspec_t = new udf_charspec_s();
	public static udf_timestamp_s udf_timestamp_t = new udf_timestamp_s();
	public static udf_id_suffix_s udf_id_suffix_t = new udf_id_suffix_s();
	public static udf_regid_s udf_regid_t = new udf_regid_s();
	public static byte[] VSD_STD_ID_BEA01 = new byte[/*Error: sizeof expression not supported yet*/ - /** Standard Identifier (ECMA 167r3 2/9.1.2) *//* The below const definitions are to faciltate debugging of the
	   values #define'd below. */1];
	public static byte[] VSD_STD_ID_BOOT2 = new byte[/*Error: sizeof expression not supported yet*/ - 1];
	public static byte[] VSD_STD_ID_CD001 = new byte[/*Error: sizeof expression not supported yet*/ - 1];
	public static byte[] VSD_STD_ID_CDW01 = new byte[/*Error: sizeof expression not supported yet*/ - 1];
	public static byte[] VSD_STD_ID_NSR03 = new byte[/*Error: sizeof expression not supported yet*/ - 1];
	public static byte[] VSD_STD_ID_TEA01 = new byte[/*Error: sizeof expression not supported yet*/ - 1/**< ECMA-167 2/9.2 *//**< ECMA-167 2/9.4 *//**< ECMA-119 *//**< ECMA-168 *//**< ECMA-167, 3/9.1 
	                                               NOTE: ECMA-167, 2nd edition */];
	public static udf_extent_ad_s udf_extent_ad_t = new udf_extent_ad_s();
	public static udf_tag_s udf_tag_t = new udf_tag_s();
	public static udf_pvd_s udf_pvd_t = new udf_pvd_s();
	public static anchor_vol_desc_ptr_s anchor_vol_desc_ptr_t = new anchor_vol_desc_ptr_s();
	public static partition_desc_s partition_desc_t = new partition_desc_s();
	public static udf_lb_addr_s udf_lb_addr_t = new udf_lb_addr_s();
	public static udf_short_ad_s udf_short_ad_t = new udf_short_ad_s();
	public static udf_long_ad_s udf_long_ad_t = new udf_long_ad_s();
	public static logical_vol_desc_s logical_vol_desc_t = new logical_vol_desc_s();
	public static udf_ext_ad_s udf_ext_ad_t = new udf_ext_ad_s();
	public static udf_fsd_s udf_fsd_t = new udf_fsd_s();
	public static partition_header_desc_s partition_header_desc_t = new partition_header_desc_s();
	public static udf_fileid_desc_s udf_fileid_desc_t = new udf_fileid_desc_s();
	public static udf_icbtag_s udf_icbtag_t = new udf_icbtag_s();
	public static udf_file_entry_s udf_file_entry_t = new udf_file_entry_s();
	public static logical_vol_header_desc_s logical_vol_header_desc_t = new logical_vol_header_desc_s();
	public static tag_id_t debug_tagid = new tag_id_t();
	public static file_characteristics_t debug_file_characteristics = new file_characteristics_t();
	public static icbtag_file_type_enum_t debug_icbtag_file_type_enum = new icbtag_file_type_enum_t();
	public static icbtag_flag_enum_t debug_flag_enum = new icbtag_flag_enum_t();
	public static ecma_167_enum1_t debug_ecma_167_enum1 = new ecma_167_enum1_t();
	public static ecma_167_timezone_enum_t debug_ecma_167_timezone_enum = new ecma_167_timezone_enum_t();
	public static str_score_t[] str_score = new str_score_t[]{new str_score_t("IC#", 10), new str_score_t("ST#", 10), new str_score_t("MX#", 10), new str_score_t("WDC", 10), new str_score_t("IBM", 10), new str_score_t("STM#", 10), new str_score_t("HDS#", 10), new str_score_t("HDP#", 10), new str_score_t("HDT#", 10), new str_score_t("HTE#", 10), new str_score_t("HTS#", 10), new str_score_t("HUA#", 10), new str_score_t("APPLE", 10), new str_score_t("INTEL", 10), new str_score_t("MAXTOR", 10), new str_score_t("HITACHI", 10), new str_score_t("SEAGATE", 10), new str_score_t("SAMSUNG", 5), new str_score_t("FUJITSU", 10), new str_score_t("TOSHIBA", 5), new str_score_t("QUANTUM", 10), new str_score_t("EXCELSTOR", 10), new str_score_t("CORSAIR", -15), new str_score_t("KINGMAX", -15), new str_score_t("KINGSTON", -15), new str_score_t("LEXAR", -15), new str_score_t("MUSHKIN", -15), new str_score_t("PNY", -15), new str_score_t("SANDISK", -15), new str_score_t("TRANSCEND", -15)};
	public static str_score_t[] str_adjust = new str_score_t[]{new str_score_t("Gadget", -10), new str_score_t("Flash", -10/* The lists belows set a score according to VID & VID:PID
	 * These were constructed as follows:
	 * 1. Pick all the VID:PIDs from http://svn.code.sf.net/p/smartmontools/code/trunk/smartmontools/drivedb.h
	 * 2. Check that VID against http://flashboot.ru/iflash/saved/ as well as http://www.linux-usb.org/usb.ids
	 * 3. If a lot of flash or card reader devices are returned, add the VID:PID, with a positive score,
	 *    in the vidpid table (so that the default will be UFD, and HDD the exception)
	 * 4. If only a few flash devices are returned, add the VID to our list with a positive score and
	 *    add the flash entries in the VID:PID list with a negative score
	 * 5. Add common UFD providers from http://flashboot.ru/iflash/saved/ with a negative score
	 * These lists MUST be kept in increasing VID/VID:PID order
	 */)};
	public static vid_score_t[] vid_score = new vid_score_t[]{new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -10), new vid_score_t(-1024, 5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 10), new vid_score_t(-1024, 7), new vid_score_t(-1024, 5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 7), new vid_score_t(-1024, 5), new vid_score_t(-1024, 10), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 7), new vid_score_t(-1024, -2), new vid_score_t(-1024, -5), new vid_score_t(-1024, 8), new vid_score_t(-1024, -5), new vid_score_t(-1024, 10), new vid_score_t(-1024, -8), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 10), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 10), new vid_score_t(-1024, 10), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 10), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 10), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 10), new vid_score_t(-1024, -5), new vid_score_t(-1024, 3), new vid_score_t(-1024, 8), new vid_score_t(-1024, -2), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 10), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -2), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, 10), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5), new vid_score_t(-1024, -5)};
	public static vidpid_score_t[] vidpid_score = new vidpid_score_t[]{new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 2), new vidpid_score_t(-1024, -1024, 5), new vidpid_score_t(-1024, -1024, 7), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 5), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 8), new vidpid_score_t(-1024, -1024, 10), new vidpid_score_t(-1024, -1024, 8), new vidpid_score_t(-1024, -1024, 8), new vidpid_score_t(-1024, -1024, 2), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -10), new vidpid_score_t(-1024, -1024, -10), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -20), new vidpid_score_t(-1024, -1024, -10)};
	public static byte[] br_fat32_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* br_fat32_0x52.h
	//
	// ANI
	// substring gmbh/tw 14.9.04 
	// modified bootstrap code 0x052 to support FreeDOS
	*/-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static byte cdio_version_string;
	public static int libcdio_version_num;
	public static byte[] br_fat12_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static byte[] mbr_gpt_rufus_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /*
	 * Rufus Protective MBR for GPT systems
	 * https://github.com/pbatard/rufus/tree/master/res/mbr
	 * Copyright Â© 2019 Pete Batard <pete@akeo.ie>
	 */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static  cdio_lseek = new ();
	public static  cdio_read = new ();
	public static  cdio_read_audio_sector = new ();
	public static  cdio_read_audio_sectors = new ();
	public static  cdio_read_data_sectors = new ();
	public static  cdio_read_mode1_sector = new ();
	public static  cdio_read_mode1_sectors = new ();
	public static  cdio_read_mode2_sector = new ();
	public static  cdio_read_sector = new ();
	public static  cdio_read_mode2_sectors = new ();
	public static  cdio_read_sectors = new ();
	public static byte[] mbr_dos_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* First 446 bytes of MBR from Dos 3.3 onwards and Windows 95A */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024/* Next four bytes used for Windows Disk Signature / Drive serial number *//*
	unsigned char mbr_dos_0x1b8[] = {
	                                                  0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00
	};
	*/};
	public static int is_fat_16_fs;
	public static int is_fat_16_br;
	public static int entire_fat_16_br_matches;
	public static int write_fat_16_br;
	public static int entire_fat_16_fd_br_matches;
	public static int write_fat_16_fd_br;
	public static int entire_fat_16_ros_br_matches;
	public static int write_fat_16_ros_br;
	public static byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static int syslinux_setadv;
	public static Object syslinux_reset_adv;
	public static int syslinux_validate_adv;
	public static int read_adv;
	public static int write_adv;
	public static  AtaPassthroughFn_t = new ();
	public static CdioDataSource_t cdio_stdio_new = new CdioDataSource_t();
	public static Object cdio_stdio_destroy;
	public static byte[] mbr_gpt_syslinux_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* This version is from gptmbr.bin from syslinux 6.02 */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static ext2fs_hashmap ext2fs_hashmap_create = new ext2fs_hashmap();
	public static Object ext2fs_hashmap_add;
	public static Object ext2fs_hashmap_lookup;
	public static Object ext2fs_hashmap_iter_in_order;
	public static Object ext2fs_hashmap_del;
	public static Object ext2fs_hashmap_free;
	public static uint32_t ext2fs_djb2_hash = new uint32_t();
	public static  vli_type = new ();
	public static byte[] mbr_win7_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* First 446 bytes of MBR from Windows 7 *//* This is English version. Bytes 0x163 onwards vary with language. *//* Last three bytes 1b5-1b7 point to language-specific messages.    *//* Support of other languages is an exercise for the reader!        *//* see: http://thestarman.pcministry.com/asm/mbr/W7MBR.htm          */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024/* Next four bytes used for Windows Disk Signature / Drive serial number *//*
	unsigned char mbr_win7_0x1b8[] = {
	                                                  0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00
	};
	*/};
	public static byte[] br_fat32nt_0x1800 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static UINT_PTR UM_LANGUAGE_MENU_MAX = new UINT_PTR();
	public static int advanced_device_section_height;
	public static int advanced_format_section_height;
	public static int cbw;
	public static int ddw;
	public static int ddbh;
	public static int bh;
	public static int update_progress_type;
	public static Object SetComboEntry;
	public static Object GetBasicControlsWidth;
	public static Object GetMainButtonsWidth;
	public static Object GetHalfDropwdownWidth;
	public static Object GetFullWidth;
	public static Object PositionMainControls;
	public static Object AdjustForLowDPI;
	public static Object SetSectionHeaders;
	public static Object SetPersistencePos;
	public static Object SetPersistenceSize;
	public static Object TogglePersistenceControls;
	public static Object ToggleAdvancedDeviceOptions;
	public static Object ToggleAdvancedFormatOptions;
	public static Object ToggleImageOptions;
	public static Object CreateSmallButtons;
	public static Object CreateAdditionalControls;
	public static Object InitProgress;
	public static Object ShowLanguageMenu;
	public static Object SetPassesTooltip;
	public static Object SetBootTypeDropdownWidth;
	public static Object OnPaint;
	public static long ulBytesPerSector = /******************************************************************
	    Copyright (C) 2009-2015  Henrik Carlqvist
	
	    This program is free software; you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation; either version 2 of the License, or
	    (at your option) any later version.
	
	    This program is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with this program; if not, write to the Free Software
	    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
	******************************************************************/512;
	public static Object nls_init;
	public static  en_msg_mode = new ();
	public static Object free_loc_cmd;
	public static  dispatch_loc_cmd = new ();
	public static Object _init_localization;
	public static Object _exit_localization;
	public static Object apply_localization;
	public static Object reset_localization;
	public static Object free_dialog_list;
	public static byte lmprintf;
	public static  get_supported_locales = new ();
	public static  get_loc_data_file = new ();
	public static Object free_locale_list;
	public static loc_cmd get_locale_from_lcid = new loc_cmd();
	public static loc_cmd get_locale_from_name = new loc_cmd();
	public static Object toggle_default_locale;
	public static byte get_name_from_id;
	public static  get_language_id = new ();
	public static time_t udf_get_access_time = new time_t();
	public static time_t udf_get_attribute_time = new time_t();
	public static time_t udf_get_modification_time = new time_t();
	public static  udf_get_access_timestamp = new ();
	public static  udf_get_modification_timestamp = new ();
	public static  udf_get_attr_timestamp = new ();
	public static time_t udf_stamp_to_time = new time_t();
	public static  udf_timespec_to_stamp = new ();
	public static byte[] error_msg = /*
	 * Rufus: The Reliable USB Formatting Utility
	 * Commandline hogger, C version
	 * Copyright © 2014 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */"Unable to synchronize with UI application.";
	public static iso_enum1_s iso_enums1;
	public static iso_flag_enum_s iso_flag_enums;
	public static iso_vd_enum_s iso_vd_enums;
	public static iso_extension_enum_s iso_extension_enums;
	public static Object pathtable_get_size_and_entries;
	public static int mode_t;
	public static int NTSTATUS;
	public static  cdio_get_cdtext_raw = new ();
	public static  cdio_get_cdtext = new ();
	public static discmode_t cdio_get_discmode = new discmode_t();
	public static  cdio_get_disc_last_lsn = new ();
	public static  cdio_get_joliet_level = new ();
	public static byte cdio_get_mcn;
	public static  cdio_get_num_tracks = new ();
	public static  cdio_is_discmode_cdrom = new ();
	public static  cdio_is_discmode_dvd = new ();
	public static xz_dec xz_dec_init = new xz_dec();
	public static xz_ret xz_dec_run;
	public static Object xz_dec_reset;
	public static Object xz_dec_end;
	public static Object xz_crc32_init;
	public static uint32_t xz_crc32 = new uint32_t();
	public static ext2fs_ba_private_struct ext2fs_ba_private = new ext2fs_ba_private_struct();
	public static _CdIo CdIo_t = new _CdIo();
	public static uint32_t GetInstallWimVersion = new uint32_t();
	public static BOOL has_ldlinux_c32 = new BOOL();
	public static byte psz_extract_dir;
	public static byte bootmgr_name = "bootmgr";
	public static byte bootmgr_efi_name = "bootmgr.efi";
	public static byte grldr_name = "grldr";
	public static byte ldlinux_name = "ldlinux.sys";
	public static byte ldlinux_c32 = "ldlinux.c32";
	public static byte casper_dirname = "/casper";
	public static byte efi_dirname = "/efi/boot";
	public static byte[] efi_bootname = new byte[]{"bootia32.efi", "bootia64.efi", "bootx64.efi", "bootarm.efi", "bootaa64.efi", "bootebc.efi"};
	public static byte sources_str = "/sources";
	public static byte[] wininst_name = new byte[]{"install.wim", "install.esd", "install.swm"};
	public static byte grub_dirname = "/boot/grub/i386-pc";
	public static byte grub_cfg = "grub.cfg";
	public static byte menu_cfg = "menu.cfg";
	public static byte[] syslinux_cfg = new byte[]{"isolinux.cfg", "syslinux.cfg", "extlinux.conf", "txt.cfg"};
	public static byte[] isolinux_bin = new byte[]{"isolinux.bin", "boot.bin"};
	public static byte[] pe_dirname = new byte[]{"/i386", "/amd64", "/minint"};
	public static byte[] pe_file = new byte[]{"ntdetect.com", "setupldr.bin", "txtsetup.sif"};
	public static byte reactos_name = "setupldr.sys";
	public static byte kolibri_name = "kolibri.img";
	public static byte autorun_name = "autorun.inf";
	public static byte manjaro_marker = ".miso";
	public static byte pop_os_name = "pop-os";
	public static byte stupid_antivirus = "  NOTE: This is usually caused by a poorly designed security solution. See https://goo.gl/QTobxX.\r\n  This file will be skipped for now, but you should really look into using a *SMARTER* antivirus solution.";
	public static int64_t[] old_c32_threshold = new int64_t[]{53500, 148000};
	public static uint8_t joliet_level = 0;
	public static uint64_t total_blocks = new uint64_t();
	public static uint64_t nb_blocks = new uint64_t();
	public static BOOL scan_only = 0;
	public static StrArray config_path = new StrArray();
	public static StrArray isolinux_path = new StrArray();
	public static DWORD OpenVirtualDisk_t = new DWORD();
	public static OpenVirtualDisk_t pfOpenVirtualDisk = ((Object)0);
	public static DWORD AttachVirtualDisk_t = new DWORD();
	public static AttachVirtualDisk_t pfAttachVirtualDisk = ((Object)0);
	public static DWORD DetachVirtualDisk_t = new DWORD();
	public static DetachVirtualDisk_t pfDetachVirtualDisk = ((Object)0);
	public static DWORD GetVirtualDiskPhysicalPath_t = new DWORD();
	public static GetVirtualDiskPhysicalPath_t pfGetVirtualDiskPhysicalPath = ((Object)0);
	public static byte[] physical_path = "";
	public static HANDLE mounted_handle = (HANDLE)(true);
	public static Object printf_t;
	public static Object progress_t;
	public static int64_t bled_uncompress = new int64_t();
	public static int64_t bled_uncompress_with_handles = new int64_t();
	public static int64_t bled_uncompress_to_buffer = new int64_t();
	public static int64_t bled_uncompress_from_buffer_to_buffer = new int64_t();
	public static int bled_init;
	public static Object bled_exit;
	public static uint8_t le8_t = new uint8_t();
	public static uint8_t[] le16_t = new uint8_t();
	public static uint8_t[] le32_t = new uint8_t();
	public static  udf_get_fileid_descriptor = new ();
	public static byte udf_get_filename;
	public static  udf_get_file_entry = new ();
	public static  udf_get_link_count = new ();
	public static  udf_get_file_length = new ();
	public static  udf_get_posix_filemode = new ();
	public static  udf_opendir = new ();
	public static  udf_read_block = new ();
	public static  udf_readdir = new ();
	public static  udf_dirent_free = new ();
	public static  udf_is_dir = new ();
	public static byte[] mbr_95b_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* First 446 bytes of MBR from Windows 95B, 98, 98SE and ME */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024/* Next 6 bytes used to write boot drive and time by some Windows OSs *//*
	unsigned char mbr_95b_0x0da[] = {
	              0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	*/};
	public static byte[] mbr_95b_0x0e0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024/* Next four bytes used for Windows Disk Signature / Drive serial number *//*
	unsigned char mbr_95b_0x1b8[] = {
	                                                  0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00
	};
	*/};
	public static byte syslinux_mboot = ((Object)0);
	public static long syslinux_mboot_len;
	public static byte[] br_fat32pe_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static byte[] mbr_rufus_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /*
	 * First 440 bytes of Rufus MBR
	 * https://github.com/pbatard/rufus/tree/master/res/mbr
	 * Copyright Â© 2012-2014 Pete Batard <pete@akeo.ie>
	 */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static int tid_t;
	public static journal_s journal_t = new journal_s();
	public static kdev_s kdev_t = new kdev_s();
	public static  u64 = new ();
	public static SysType[] msdos_systypes = new SysType[]{new SysType(-1024, "Empty"), new SysType(-1024, "FAT12"), new SysType(-1024, "XENIX root"), new SysType(-1024, "XENIX usr"), new SysType(-1024, "Small FAT16"), new SysType(-1024, "Extended"), new SysType(-1024, "FAT16"), new SysType(-1024, "NTFS/exFAT/UDF"), new SysType(-1024, "AIX"), new SysType(-1024, "AIX Bootable"), new SysType(-1024, "OS/2 Boot Manager"), new SysType(-1024, "FAT32"), new SysType(-1024, "FAT32 LBA"), new SysType(-1024, "FAT16 LBA"), new SysType(-1024, "Extended LBA"), new SysType(-1024, "OPUS"), new SysType(-1024, "Hidden FAT12"), new SysType(-1024, "Compaq Diagnostics"), new SysType(-1024, "Hidden Small FAT16"), new SysType(-1024, "Hidden FAT16"), new SysType(-1024, "Hidden NTFS"), new SysType(-1024, "AST SmartSleep"), new SysType(-1024, "Hidden FAT32"), new SysType(-1024, "Hidden FAT32 LBA"), new SysType(-1024, "Hidden FAT16 LBA"), new SysType(-1024, "Windows Mobile XIP"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "Windows Mobile XIP"), new SysType(-1024, "NEC DOS"), new SysType(-1024, "Windows Mobile IMGFS"), new SysType(-1024, "Hidden NTFS WinRE"), new SysType(-1024, "Plan 9"), new SysType(-1024, "PMagic Recovery"), new SysType(-1024, "Venix 80286"), new SysType(-1024, "PPC PReP Boot"), new SysType(-1024, "SFS"), new SysType(-1024, "QNX4.x"), new SysType(-1024, "QNX4.x"), new SysType(-1024, "QNX4.x"), new SysType(-1024, "OnTrack DM"), new SysType(-1024, "OnTrack DM"), new SysType(-1024, "CP/M"), new SysType(-1024, "OnTrack DM"), new SysType(-1024, "OnTrack DM"), new SysType(-1024, "EZ Drive"), new SysType(-1024, "Golden Bow"), new SysType(-1024, "Priam EDisk"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "GNU HURD/SysV"), new SysType(-1024, "Netware"), new SysType(-1024, "Netware"), new SysType(-1024, "Netware"), new SysType(-1024, "Netware"), new SysType(-1024, "Netware"), new SysType(-1024, "Netware"), new SysType(-1024, "DiskSecure MultiBoot"), new SysType(-1024, "PC/IX"), new SysType(-1024, "Novell"), new SysType(-1024, "XOSL"), new SysType(-1024, "F.I.X."), new SysType(-1024, "AODPS"), new SysType(-1024, "Minix"), new SysType(-1024, "Minix"), new SysType(-1024, "GNU/Linux Swap"), new SysType(-1024, "GNU/Linux"), new SysType(-1024, "Windows Hibernation"), new SysType(-1024, "GNU/Linux Extended"), new SysType(-1024, "NTFS Volume Set"), new SysType(-1024, "NTFS Volume Set"), new SysType(-1024, "GNU/Linux Plaintext"), new SysType(-1024, "FreeDOS Hidden FAT12"), new SysType(-1024, "GNU/Linux LVM"), new SysType(-1024, "FreeDOS Hidden FAT16"), new SysType(-1024, "FreeDOS Hidden Extended"), new SysType(-1024, "FreeDOS Hidden FAT16"), new SysType(-1024, "GNU/Linux Hidden"), new SysType(-1024, "CHRP ISO-9660"), new SysType(-1024, "FreeDOS Hidden FAT32"), new SysType(-1024, "FreeDOS Hidden FAT32"), new SysType(-1024, "FreeDOS Hidden FAT16"), new SysType(-1024, "FreeDOS Hidden Extended"), new SysType(-1024, "BSD/OS"), new SysType(-1024, "Hibernation"), new SysType(-1024, "Hibernation"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "FreeBSD"), new SysType(-1024, "OpenBSD"), new SysType(-1024, "NeXTSTEP"), new SysType(-1024, "Darwin UFS"), new SysType(-1024, "NetBSD"), new SysType(-1024, "Darwin Boot"), new SysType(-1024, "HFS/HFS+"), new SysType(-1024, "BootStar Dummy"), new SysType(-1024, "QNX"), new SysType(-1024, "QNX"), new SysType(-1024, "QNX"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "BSDI"), new SysType(-1024, "BSDI Swap"), new SysType(-1024, "BootWizard Hidden"), new SysType(-1024, "Acronis SZ"), new SysType(-1024, "Solaris Boot"), new SysType(-1024, "Solaris"), new SysType(-1024, "Secured FAT"), new SysType(-1024, "DR DOS FAT12"), new SysType(-1024, "GNU/Linux Hidden"), new SysType(-1024, "GNU/Linux Hidden Swap"), new SysType(-1024, "DR DOS FAT16"), new SysType(-1024, "DR DOS Extended"), new SysType(-1024, "DR DOS FAT16"), new SysType(-1024, "Syrinx"), new SysType(-1024, "Non-FS Data"), new SysType(-1024, "CP/M"), new SysType(-1024, "Dell Utility"), new SysType(-1024, "BootIt"), new SysType(-1024, "ST AVFS"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "LUKS"), new SysType(-1024, "Rufus Extra"), new SysType(-1024, "BeOS/Haiku"), new SysType(-1024, "SkyFS"), new SysType(-1024, "GPT Hybrid MBR"), new SysType(-1024, "GPT Protective MBR"), new SysType(-1024, "EFI FAT"), new SysType(-1024, "PA-RISC Boot"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "DOS secondary"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "SpeedStor"), new SysType(-1024, "Bochs"), new SysType(-1024, "VMware VMFS"), new SysType(-1024, "VMware VMKCORE"), new SysType(-1024, "GNU/Linux RAID Auto"), new SysType(-1024, "LANstep"), new SysType(-1024, "XENIX BBT"), new SysType(0, NULL)};
	public static uint16_t[] mask_bits = new uint16_t[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* This is a generic part *//* Use global data segment *//* Use global data segment *//*nothing*//*nothing*//*nothing*//*nothing*//*nothing*//* Use malloc space *//* Use malloc space */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static uint16_t[] cplens = new uint16_t[]{3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, /* Copy lengths for literal codes 257..285 */59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
	public static uint8_t[] cplext = new uint8_t[]{0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, /* note: see note #13 above about the 258 in this list. *//* Extra bits for literal codes 257..285 */5, 5, 5, 5, 0, 99, 99/* 99 == invalid */};
	public static uint16_t[] cpdist = new uint16_t[]{1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, /* Copy offsets for distance codes 0..29 */513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};
	public static uint8_t[] cpdext = new uint8_t[]{0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, /* Extra bits for distance codes */10, 11, 11, 12, 12, 13, 13};
	public static uint8_t[] border = new uint8_t[]{16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, /* Tables for deflate from PKZIP's appnote.txt. *//* Order of the bit length code lengths */15/*
	 * Free the malloc'ed tables built by huft_build(), which makes a linked
	 * list of the tables it made, with the links in a dummy first entry of
	 * each table.
	 * t: table to free
	 */};
	public static Object abort_unzip;
	public static int PRAGMA_END_PACKED;
	public static int get_rock_ridge_filename;
	public static int parse_rock_ridge_stat;
	public static  iso9660_get_posix_filemode_from_rock = new ();
	public static byte iso9660_get_rock_attr_str;
	public static HIMAGELIST hUpImageList = new HIMAGELIST();
	public static HIMAGELIST hDownImageList = new HIMAGELIST();
	public static int rh;
	public static int ddh;
	public static int bw;
	public static int hw;
	public static int fw;
	public static int sw;
	public static int mw;
	public static int bsw;
	public static int sbw;
	public static int ssw;
	public static int tw;
	public static int dbw;
	public static WNDPROC progress_original_proc = ((Object)0);
	public static wchar_t[][] wtbtext = new wchar_t();
	public static int[] nb_slots = new int[action_type.OP_MAX];
	public static double[] slot_end = new double[action_type.OP_MAX + 1];
	public static double previous_end;
	public static  debug_udf_enum1 = new ();
	public static  udf_new_dirent = new ();
	public static int getopt;
	public static int getopt_long;
	public static int getopt_long_only;
	public static int _getopt_internal;
	public static byte[] br_fat32nt_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static byte cert_country = "IE";
	public static uint8_t[] rsa_pubkey_modulus = new uint8_t[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024/*
	 * FormatMessage does not handle PKI errors
	 */};
	public static int PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN;
	public static archive_handle_t init_handle = new archive_handle_t();
	public static int FAST_FUNC;
	public static byte filter_accept_all;
	public static byte filter_accept_list;
	public static byte filter_accept_list_reassign;
	public static byte filter_accept_reject_list;
	public static Object unpack_ar_archive;
	public static Object data_skip;
	public static Object data_extract_all;
	public static Object data_extract_to_stdout;
	public static Object data_extract_to_command;
	public static Object header_skip;
	public static Object header_list;
	public static Object header_verbose_list;
	public static byte get_header_ar;
	public static byte get_header_cpio;
	public static byte get_header_tar;
	public static byte get_header_tar_gz;
	public static byte get_header_tar_bz2;
	public static byte get_header_tar_lzma;
	public static byte get_header_tar_xz;
	public static Object seek_by_jump;
	public static Object seek_by_read;
	public static byte strip_unsafe_prefix;
	public static Object data_align;
	public static  find_list_entry = new ();
	public static  find_list_entry2 = new ();
	public static bunzip_data bunzip_data = new bunzip_data();
	public static int start_bunzip;
	public static int read_bunzip;
	public static Object dealloc_bunzip;
	public static Object init_transformer_state;
	public static  transformer_write = new ();
	public static  xtransformer_write = new ();
	public static int check_signature16;
	public static int IF_DESKTOP;
	public static int inflate_unzip;
	public static int unpack_zip_stream;
	public static int unpack_Z_stream;
	public static int unpack_gz_stream;
	public static int unpack_bz2_stream;
	public static int unpack_lzma_stream;
	public static int unpack_xz_stream;
	public static byte append_ext;
	public static Object check_errors_in_children;
	public static Object fork_transformer;
	public static int set_bad_block_proc;
	public static int clear_bad_block_proc;
	public static  partition_num_t = new ();
	public static udf_s udf_t = new udf_s();
	public static udf_file_s udf_file_t = new udf_file_s();
	public static  udf_close = new ();
	public static  udf_read_sectors = new ();
	public static udf_t udf_open = new udf_t();
	public static  udf_get_part_number = new ();
	public static udf_dirent_t udf_get_root = new udf_dirent_t();
	public static int udf_get_volume_id;
	public static int udf_get_volumeset_id;
	public static int udf_get_logical_volume_id;
	public static udf_dirent_t udf_fopen = new udf_dirent_t();
	public static byte udf_mode_string;
	public static  udf_get_lba = new ();
	public static byte[] space = /*
	 * Rufus: The Reliable USB Formatting Utility
	 * Elementary Unicode compliant find/replace parser
	 * Copyright Â© 2012-2018 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 *//* Memory leaks detection - define _CRTDBG_MAP_ALLOC as preprocessor macro */" \t";
	public static wchar_t[] wspace = L" \t";
	public static byte conversion_error = "Could not convert '%s' to UTF-16";
	public static int is_fat_12_fs;
	public static int entire_fat_12_br_matches;
	public static int write_fat_12_br;
	public static int is_fat_32_fs;
	public static int is_fat_32_br;
	public static int entire_fat_32_br_matches;
	public static int write_fat_32_br;
	public static int entire_fat_32_fd_br_matches;
	public static int write_fat_32_fd_br;
	public static int entire_fat_32_nt_br_matches;
	public static int write_fat_32_nt_br;
	public static int entire_fat_32_pe_br_matches;
	public static int write_fat_32_pe_br;
	public static int entire_fat_32_ros_br_matches;
	public static int write_fat_32_ros_br;
	public static int entire_fat_32_kos_br_matches;
	public static int write_fat_32_kos_br;
	public static byte[] mbr_reactos_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* First 267 bytes of MBR from ReactOS */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	
	
	/*
	 * alloc_sb.c --- Allocate the superblock and block group descriptors for a
	 * newly initialized filesystem.  Used by mke2fs when initializing a filesystem
	 *
	 * Copyright (C) 1994, 1995, 1996, 2003 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/*
	 * This function reserves the superblock and block group descriptors
	 * for a given block group.  It currently returns the number of free
	 * blocks assuming that inode table and allocation bitmaps will be in
	 * the group.  This is not necessarily the case when the flex_bg
	 * feature is enabled, so callers should take care!  It was only
	 * really intended for use by mke2fs, and even there it's not that
	 * useful.  In the future, when we redo this function for 64-bit block
	 * numbers, we should probably return the number of blocks used by the
	 * super block and group descriptors instead.
	 *
	 * See also the comment for ext2fs_super_and_bgd_loc()
	 */
	public static int ext2fs_reserve_super_and_bgd(Object fs, Object group, Object bmap) {
		 super_blk = new ();
		 old_desc_blk = new ();
		 new_desc_blk = new ();
		 used_blks = new ();
		int old_desc_blocks;
		int num_blocks;
		ModernizedCProgram.ext2fs_super_and_bgd_loc2(fs, group, super_blk, old_desc_blk, new_desc_blk, used_blks);
		if (fs.getSuper().ext2fs_has_feature_meta_bg()) {
			old_desc_blocks = fs.getSuper().getS_first_meta_bg();
		} else {
				old_desc_blocks = fs.getDesc_blocks() + fs.getSuper().getS_reserved_gdt_blocks();
		} 
		if (super_blk || (group == 0)) {
			ModernizedCProgram.ext2fs_mark_block_bitmap2(bmap, super_blk);
		} 
		if ((group == 0) && (fs.getBlocksize() == 1024) && (-1024 << (fs).getCluster_ratio_bits()) > 1) {
			ModernizedCProgram.ext2fs_mark_block_bitmap2(bmap, 0);
		} 
		if (old_desc_blk) {
			num_blocks = old_desc_blocks;
			if (old_desc_blk + num_blocks >= fs.getSuper().ext2fs_blocks_count()) {
				num_blocks = fs.getSuper().ext2fs_blocks_count() - old_desc_blk;
			} 
			ModernizedCProgram.ext2fs_mark_block_bitmap_range2(bmap, old_desc_blk, num_blocks);
		} 
		if (new_desc_blk) {
			ModernizedCProgram.ext2fs_mark_block_bitmap2(bmap, new_desc_blk);
		} 
		num_blocks = ModernizedCProgram.ext2fs_group_blocks_count(fs, group);
		num_blocks -= 2 + fs.getInode_blocks_per_group() + used_blks;
		return num_blocks;
	}
	public static int tid_gt(Object x, Object y) {
		int difference = (x - y);
		return (difference > 0);
	}
	public static int tid_geq(Object x, Object y) {
		int difference = (x - y);
		return (difference >= 0/* (defined(E2FSCK_INCLUDE_INLINE_FUNCS) || !defined(NO_INLINE_FUNCS)) */);
	}
	/* vi: set sw=4 ts=4: */
	/*
	 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
	 */
	public static void header_skip(Object file_header) {
	}
	public static Object nt_io_manager() {
		return ModernizedCProgram.struct_nt_manager;
	}
	public static int _MapDosError(Object WinError) {
		int i;
		ModernizedCProgram.LastWinError = WinError;
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); ++i) {
			if (WinError == ModernizedCProgram.ErrorTable[i].getWinError()) {
				return ModernizedCProgram.ErrorTable[i].getErrnocode();
			} 
		}
		// Not in table. Check rangesif ((WinError >= -1024) && (WinError <= -1024)) {
			return 13;
		}  else if ((WinError >= -1024) && (WinError <= -1024)) {
			return 8;
		} else {
				return 22;
		} 
	}
	// Map NT status to dos error.
	public static int _MapNtStatus(Object Status) {
		if (ModernizedCProgram.pfRtlNtStatusToDosError == ((Object)0)) {
			ModernizedCProgram.pfRtlNtStatusToDosError = (RtlNtStatusToDosError_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "RtlNtStatusToDosError");
		} 
		return (ModernizedCProgram.pfRtlNtStatusToDosError == ((Object)0)) ? 14 : ModernizedCProgram._MapDosError(/*Error: Function owner not recognized*/pfRtlNtStatusToDosError(Status));
	}
	// Return the last Windows Error
	public static Object ext2_last_winerror(Object default_error) {
		return -1024 | (3 << 16) | (ModernizedCProgram.LastWinError ? ModernizedCProgram.LastWinError : default_error);//
	}
	// Helper functions
	//
	public static Object _OpenNtName(Object Name, Object Readonly, Object Handle, Object OpenedReadonly) {
		 UnicodeString = new ();
		WCHAR[] Buffer = new WCHAR();
		 Status = 14;
		 ObjectAttributes = new ();
		 IoStatusBlock = new ();
		if (ModernizedCProgram.pfNtDelayExecution == ((Object)0)) {
			ModernizedCProgram.pfNtDelayExecution = (NtDelayExecution_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "NtDelayExecution");
		} 
		do {
			if (ModernizedCProgram.pfNtOpenFile == ((Object)0)) {
				ModernizedCProgram.pfNtOpenFile = (NtOpenFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "NtOpenFile");
			} 
			if (ModernizedCProgram.pfNtOpenFile == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "NtOpenFile", "Ntdll", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		/*Error: Function owner not recognized*/// Make Unicode name from input string/*Error: Function owner not recognized*/// Make Unicode name from input stringMultiByteToWideChar(65001, 0, Name, -1, Buffer, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
		UnicodeString.setBuffer(Buffer);
		UnicodeString.setLength((USHORT)/*Error: Function owner not recognized*/wcslen(Buffer) * 2);
		// in bytes!!!// in bytes!!!UnicodeString.setMaximumLength(/*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*/// Initialize object/*Error: Function owner not recognized*/// Initialize objectInitializeObjectAttributes(ObjectAttributes, UnicodeString, OBJ_CASE_INSENSITIVE, ((Object)0), ((Object)0));
		// Try to open it in initial modeif (((CHAR)((ULONG_PTR)(OpenedReadonly)) != (CHAR)(((Object)0)))) {
			OpenedReadonly = Readonly;
		} 
		Status = /*Error: Function owner not recognized*/pfNtOpenFile(Handle, -1024 | -1024 | (Readonly ? 0 : -1024), ObjectAttributes, IoStatusBlock, -1024 | -1024, -1024);
		if (!/*Error: Function owner not recognized*/NT_SUCCESS(Status)) {
			LARGE_INTEGER Interval = new LARGE_INTEGER();
			Interval.setQuadPart(-5000000);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfNtDelayExecution(0, Interval);
			Status = /*Error: Function owner not recognized*/pfNtOpenFile(Handle, -1024 | -1024 | (Readonly ? 0 : -1024), ObjectAttributes, IoStatusBlock, -1024 | -1024, -1024);
			if ((Status == (()-1024)) && !Readonly) {
				if (((CHAR)((ULONG_PTR)(OpenedReadonly)) != (CHAR)(((Object)0)))) {
					OpenedReadonly = 1;
				} 
				Status = /*Error: Function owner not recognized*/pfNtOpenFile(Handle, -1024 | -1024, ObjectAttributes, IoStatusBlock, -1024 | -1024, -1024);
			} 
		} 
		// Maybe was just mounted? wait 0.5 sec and retry.
	}
	public static Object _OpenDriveLetter(Object Letter, Object ReadOnly, Object Handle, Object OpenedReadonly) {
		CHAR[] Buffer = new CHAR();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/sprintf(Buffer, "\\DosDevices\\%c:", Letter);
		return ModernizedCProgram._OpenNtName(Buffer, ReadOnly, Handle, OpenedReadonly);
	}
	public static Object _FlushDrive(Object Handle) {
		 IoStatusBlock = new ();
		if (ModernizedCProgram.pfNtFlushBuffersFile == ((Object)0)) {
			ModernizedCProgram.pfNtFlushBuffersFile = (NtFlushBuffersFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtFlushBuffersFile");
		} 
		return (ModernizedCProgram.pfNtFlushBuffersFile == ((Object)0)) ? STATUS_DLL_NOT_FOUND : /*Error: Function owner not recognized*/pfNtFlushBuffersFile(Handle, IoStatusBlock);
	}
	public static Object _LockDrive(Object Handle) {
		 IoStatusBlock = new ();
		if (ModernizedCProgram.pfNtFsControlFile == ((Object)0)) {
			ModernizedCProgram.pfNtFsControlFile = (NtFsControlFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtFsControlFile");
		} 
		return (ModernizedCProgram.pfNtFsControlFile == ((Object)0)) ? STATUS_DLL_NOT_FOUND : /*Error: Function owner not recognized*/pfNtFsControlFile(Handle, 0, 0, 0, IoStatusBlock, FSCTL_LOCK_VOLUME, 0, 0, 0, 0);
	}
	public static Object _UnlockDrive(Object Handle) {
		 IoStatusBlock = new ();
		if (ModernizedCProgram.pfNtFsControlFile == ((Object)0)) {
			ModernizedCProgram.pfNtFsControlFile = (NtFsControlFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtFsControlFile");
		} 
		return (ModernizedCProgram.pfNtFsControlFile == ((Object)0)) ? STATUS_DLL_NOT_FOUND : /*Error: Function owner not recognized*/pfNtFsControlFile(Handle, 0, 0, 0, IoStatusBlock, FSCTL_UNLOCK_VOLUME, 0, 0, 0, 0);
	}
	public static Object _DismountDrive(Object Handle) {
		 IoStatusBlock = new ();
		if (ModernizedCProgram.pfNtFsControlFile == ((Object)0)) {
			ModernizedCProgram.pfNtFsControlFile = (NtFsControlFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtFsControlFile");
		} 
		return (ModernizedCProgram.pfNtFsControlFile == ((Object)0)) ? STATUS_DLL_NOT_FOUND : /*Error: Function owner not recognized*/pfNtFsControlFile(Handle, 0, 0, 0, IoStatusBlock, FSCTL_DISMOUNT_VOLUME, 0, 0, 0, 0);
	}
	public static Object _IsMounted(Object Handle) {
		 IoStatusBlock = new ();
		 Status = STATUS_DLL_NOT_FOUND;
		if (ModernizedCProgram.pfNtFsControlFile == ((Object)0)) {
			ModernizedCProgram.pfNtFsControlFile = (NtFsControlFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtFsControlFile");
		} 
		if (ModernizedCProgram.pfNtFsControlFile != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfNtFsControlFile(Handle, 0, 0, 0, IoStatusBlock, FSCTL_IS_VOLUME_MOUNTED, 0, 0, 0, 0);
		} 
		return (BOOLEAN)(Status == (()-1024));
	}
	public static Object _CloseDisk(Object Handle) {
		if (ModernizedCProgram.pfNtClose == ((Object)0)) {
			ModernizedCProgram.pfNtClose = (NtClose_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "NtClose");
		} 
		return (ModernizedCProgram.pfNtClose == ((Object)0)) ? STATUS_DLL_NOT_FOUND : /*Error: Function owner not recognized*/pfNtClose(Handle);
	}
	public static Object _NormalizeDeviceName(Object Device, Object NormalizedDeviceNameBuffer, Object Offset, Object Size) {
		Offset = Size = -1024// Convert non NT paths to NT;// Convert non NT paths to NT
		if (Device[0] == (byte)'\\') {
			if ((/*Error: Function owner not recognized*/strlen(Device) < 4) || (Device[3] != (byte)'\\')) {
				return Device;
			} 
			if (/*Error: Function owner not recognized*/sscanf(Device, "%s %I64u %I64u", NormalizedDeviceNameBuffer, Offset, Size) < 1) {
				return ((Object)0);
			} 
			if ((NormalizedDeviceNameBuffer[1] == (byte)'\\') || (NormalizedDeviceNameBuffer[1] == (byte)'.')) {
				NormalizedDeviceNameBuffer[1] = (byte)'?';
			} 
			if (NormalizedDeviceNameBuffer[2] == (byte)'.') {
				NormalizedDeviceNameBuffer[2] = (byte)'?';
			} 
			return NormalizedDeviceNameBuffer;
		} 
		// Don't allow the conversion of non absolute paths.// Too easy to get a C:\ drive altered on a mishap otherwise...return ((Object)0);
	}
	public static void _GetDeviceSize(Object h, Integer FsSize) {
		 pi = new ();
		 gi = new ();
		 Status = new ();
		 IoStatusBlock = new ();
		LARGE_INTEGER li = new LARGE_INTEGER();
		FsSize = 0;
		if (ModernizedCProgram.pfNtDeviceIoControlFile == ((Object)0)) {
			ModernizedCProgram.pfNtDeviceIoControlFile = (NtDeviceIoControlFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtDeviceIoControlFile");
		} 
		if (ModernizedCProgram.pfNtDeviceIoControlFile == ((Object)0)) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(((pi)), (false), ((/*Error: sizeof expression not supported yet*/)));
		Status = /*Error: Function owner not recognized*/pfNtDeviceIoControlFile(h, ((Object)0), ((Object)0), ((Object)0), IoStatusBlock, IOCTL_DISK_GET_PARTITION_INFO_EX, pi, /*Error: sizeof expression not supported yet*/, pi, /*Error: sizeof expression not supported yet*/);
		Object generatedQuadPart = li.getQuadPart();
		if (/*Error: Function owner not recognized*/NT_SUCCESS(Status)) {
			FsSize = pi.getPartitionLength().getQuadPart();
		}  else if (Status == (()-1024)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(((gi)), (false), ((/*Error: sizeof expression not supported yet*/)));
			Status = /*Error: Function owner not recognized*/pfNtDeviceIoControlFile(h, ((Object)0), ((Object)0), ((Object)0), IoStatusBlock, IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, gi, /*Error: sizeof expression not supported yet*/, gi, /*Error: sizeof expression not supported yet*/);
			if (/*Error: Function owner not recognized*/NT_SUCCESS(Status)) {
				FsSize = gi.getDiskSize().getQuadPart();
			} 
		}  else if (Status == STATUS_INVALID_PARAMETER) {
			if (/*Error: Function owner not recognized*/GetFileSizeEx(h, li)) {
				FsSize = generatedQuadPart;
			} 
		} 
	}
	public static Object _Ext2OpenDevice(Object Name, Object ReadOnly, Object Handle, Object Offset, Object Size, Object OpenedReadonly, Object Errno) {
		CHAR[] NormalizedDeviceName = new CHAR();
		 Status = new ();
		ModernizedCProgram.LastWinError = 0;
		if (Name == ((Object)0)) {
			ModernizedCProgram.LastWinError = -1024;
			if (((CHAR)((ULONG_PTR)(Errno)) != (CHAR)(((Object)0)))) {
				Errno = 2;
			} 
			return 0;
		} 
		if ((((Name) | -1024) >= (byte)'a') && (((Name) | -1024) <= (byte)'z') && ((byte)':' == (Name + 1)) && ((byte)'\0' == (Name + 2))) {
			Status = ModernizedCProgram._OpenDriveLetter(Name, ReadOnly, Handle, OpenedReadonly);
		} else {
				Name = ModernizedCProgram._NormalizeDeviceName(Name, NormalizedDeviceName, Offset, Size);
				if (Name == ((Object)0)) {
					ModernizedCProgram.LastWinError = -1024;
					if (((CHAR)((ULONG_PTR)(Errno)) != (CHAR)(((Object)0)))) {
						Errno = 2;
					} 
					return 0;
				} 
				Status = ModernizedCProgram._OpenNtName(Name, ReadOnly, Handle, OpenedReadonly);
		} 
		if (!/*Error: Function owner not recognized*/NT_SUCCESS(Status)) {
			if (((CHAR)((ULONG_PTR)(Errno)) != (CHAR)(((Object)0)))) {
				Errno = ModernizedCProgram._MapNtStatus(Status);
			} 
			return 0;
		} 
		return 1;
	}
	public static Object _BlockIo(Object Handle, Object Bytes, Object Buffer, Object Read, Object Errno) {
		 IoStatusBlock = new ();
		 Status = STATUS_DLL_NOT_FOUND;
		do {
			if (ModernizedCProgram.pfNtReadFile == ((Object)0)) {
				ModernizedCProgram.pfNtReadFile = (NtReadFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtReadFile");
			} 
			if (ModernizedCProgram.pfNtReadFile == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "NtReadFile", "NtDll", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfNtWriteFile == ((Object)0)) {
				ModernizedCProgram.pfNtWriteFile = (NtWriteFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtWriteFile");
			} 
			if (ModernizedCProgram.pfNtWriteFile == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "NtWriteFile", "NtDll", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		// Should be aligned// Should be aligned(((Bytes % 512) == 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(Bytes % 512) == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\nt_io.c", 397));
		Object generatedLowPart = this.getLowPart();
		(((generatedLowPart % 512) == 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(Offset.LowPart % 512) == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\nt_io.c", 398));
		ModernizedCProgram.LastWinError = 0// Perform io;// Perform io
		if (Read) {
			Status = /*Error: Function owner not recognized*/pfNtReadFile(Handle, ((Object)0), ((Object)0), ((Object)0), IoStatusBlock, Buffer, Bytes, Offset, ((Object)0));
		} else {
				Status = /*Error: Function owner not recognized*/pfNtWriteFile(Handle, ((Object)0), ((Object)0), ((Object)0), IoStatusBlock, Buffer, Bytes, Offset, ((Object)0));
		} 
		if (((CHAR)((ULONG_PTR)(Errno)) != (CHAR)(((Object)0)))) {
			Errno = 0;
		} 
		return 1;
	}
	public static Object _RawWrite(Object Handle, Object Bytes, Object Buffer, Object Errno) {
		return Offset._BlockIo(Handle, Bytes, (PCHAR)Buffer, 0, Errno);
	}
	public static Object _RawRead(Object Handle, Object Bytes, Object Buffer, Object Errno) {
		return Offset._BlockIo(Handle, Bytes, Buffer, 1, Errno);
	}
	public static Object _SetPartType(Object Handle, Object Type) {
		 IoStatusBlock = new ();
		if (ModernizedCProgram.pfNtDeviceIoControlFile == ((Object)0)) {
			ModernizedCProgram.pfNtDeviceIoControlFile = (NtDeviceIoControlFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtDeviceIoControlFile");
		} 
		if (ModernizedCProgram.pfNtDeviceIoControlFile == ((Object)0)) {
			return 0;
		} 
		return /*Error: Function owner not recognized*/NT_SUCCESS(/*Error: Function owner not recognized*/pfNtDeviceIoControlFile(Handle, ((Object)0), ((Object)0), ((Object)0), IoStatusBlock, IOCTL_DISK_SET_PARTITION_INFO, Type, /*Error: sizeof expression not supported yet*/, ((Object)0), 0));//
	}
	// Interface functions.
	// Is_mounted is set to 1 if the device is mounted, 0 otherwise
	//
	public static Object ext2fs_check_if_mounted(Object file, Integer mount_flags) {
		 errcode = 0;
		 Offset = new ();
		 Size = new ();
		HANDLE h = new HANDLE();
		BOOLEAN Readonly = new BOOLEAN();
		mount_flags = 0;
		if (!ModernizedCProgram._Ext2OpenDevice(file, 1, h, Offset, Size, Readonly, errcode)) {
			return errcode;
		} 
		mount_flags &=  ModernizedCProgram._IsMounted(h) ? 1 : 0;
		ModernizedCProgram._CloseDisk(h);
		return 0;
	}
	// Not implemented
	public static Object ext2fs_check_mount_point(Object file, Integer mount_flags, Byte mtpt, int mtlen) {
		return EXT2_ET_OP_NOT_SUPPORTED;// Returns the number of blocks in a partition
	}
	// Note: Do *NOT* be tempted to cache the device size according to the NT path as
	// different removable devices (e.g. UFD) may be remounted under the same path.
	public static Object ext2fs_get_device_size2(Object file, int blocksize, Object retblocks) {
		 errcode = 0;
		 Offset = new ();
		 Size = 0;
		HANDLE h = new HANDLE();
		BOOLEAN Readonly = new BOOLEAN();
		if (!ModernizedCProgram._Ext2OpenDevice(file, 1, h, Offset, Size, Readonly, errcode)) {
			return errcode;
		} 
		if (Size == -1024) {
			ModernizedCProgram._GetDeviceSize(h, Size);
		} 
		ModernizedCProgram._CloseDisk(h);
		retblocks = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(Size / blocksize);
		return 0;
	}
	// Standard interface prototypes
	//
	//
	// Table elements
	//
	public static Object nt_open(Object name, int flags, Object channel) {
		 io = ((Object)0);
		PNT_PRIVATE_DATA nt_data = ((Object)0);
		 errcode = 0;
		if (name == ((Object)0)) {
			return EXT2_ET_BAD_DEVICE_NAME;
		} 
		// Allocate buffers// Allocate buffersio = ()/*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/);
		if (io == ((Object)0)) {
			errcode = 12;
			;
		} 
		io.setName(/*Error: Function owner not recognized*/calloc(/*Error: Function owner not recognized*/strlen(name) + 1, 1));
		if (io.getName() == ((Object)0)) {
			errcode = 12;
			;
		} 
		nt_data = (PNT_PRIVATE_DATA)/*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/);
		if (nt_data == ((Object)0)) {
			errcode = 12;
			;
		} 
		nt_data.setBuffer(/*Error: Function owner not recognized*/malloc(EXT2_MIN_BLOCK_SIZE));
		if (nt_data.getBuffer() == ((Object)0)) {
			errcode = 12;
			;
		} 
		// Initialize data// Initialize dataio.setMagic(EXT2_ET_MAGIC_IO_CHANNEL);
		io.setManager(ModernizedCProgram.nt_io_manager());
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(io.getName(), name);
		io.setBlock_size(EXT2_MIN_BLOCK_SIZE);
		io.setRefcount(1);
		nt_data.setMagic(-1024);
		nt_data.setBuffer_block_number(-1024);
		nt_data.setBuffer_size(EXT2_MIN_BLOCK_SIZE);
		io.setPrivate_data(nt_data);
		// Open the deviceif (!ModernizedCProgram._Ext2OpenDevice(name, (BOOLEAN)!((BOOLEAN)((((flags) & (true)) != 0))), nt_data.getHandle(), nt_data.getOffset(), nt_data.getSize(), nt_data.getRead_only(), errcode)) {
			if (!errcode) {
				errcode = 5;
			} 
			;
		} 
		// Done// Donechannel = io;
		return errcode;
	}
	public static Object nt_close(Object channel) {
		PNT_PRIVATE_DATA nt_data = ((Object)0);
		if (channel == ((Object)0)) {
			return 0;
		} 
		if (!(channel) || (channel).getMagic() != (EXT2_ET_MAGIC_IO_CHANNEL)) {
			return (EXT2_ET_MAGIC_IO_CHANNEL);
		} 
		nt_data = (PNT_PRIVATE_DATA)channel.getPrivate_data();
		if (!(nt_data) || (nt_data).getMagic() != (true)) {
			return (true);
		} 
		if (--channel.getRefcount() > 0) {
			return 0;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(channel.getName());
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(channel);
		if (nt_data != ((Object)0)) {
			if (nt_data.getHandle() != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(nt_data.getHandle());
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(nt_data.getBuffer());
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(nt_data);
		} 
		return 0;
	}
	public static Object nt_set_blksize(Object channel, int blksize) {
		PNT_PRIVATE_DATA nt_data = ((Object)0);
		if (!(channel) || (channel).getMagic() != (EXT2_ET_MAGIC_IO_CHANNEL)) {
			return (EXT2_ET_MAGIC_IO_CHANNEL);
		} 
		nt_data = (PNT_PRIVATE_DATA)channel.getPrivate_data();
		if (!(nt_data) || (nt_data).getMagic() != (true)) {
			return (true);
		} 
		if (channel.getBlock_size() != blksize) {
			channel.setBlock_size(blksize);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(nt_data.getBuffer());
			nt_data.setBuffer_block_number(-1024);
			nt_data.setBuffer_size(channel.getBlock_size());
			(((nt_data.getBuffer_size() % 512) == 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(nt_data->buffer_size % 512) == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\nt_io.c", 613));
			nt_data.setBuffer(/*Error: Function owner not recognized*/malloc(nt_data.getBuffer_size()));
			if (nt_data.getBuffer() == ((Object)0)) {
				return 12;
			} 
		} 
		return 0;
	}
	public static Object nt_read_blk(Object channel, long block, int count, Object buf) {
		PVOID read_buffer = new PVOID();
		ULONG read_size = new ULONG();
		ULONG size = new ULONG();
		LARGE_INTEGER offset = new LARGE_INTEGER();
		PNT_PRIVATE_DATA nt_data = ((Object)0);
		 errcode = 0;
		if (!(channel) || (channel).getMagic() != (EXT2_ET_MAGIC_IO_CHANNEL)) {
			return (EXT2_ET_MAGIC_IO_CHANNEL);
		} 
		nt_data = (PNT_PRIVATE_DATA)channel.getPrivate_data();
		if (!(nt_data) || (nt_data).getMagic() != (true)) {
			return (true);
		} 
		// If it's in the cache, use it!if ((count == 1) && (block == nt_data.getBuffer_block_number()) && (nt_data.getBuffer_block_number() != -1024)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(buf, nt_data.getBuffer(), channel.getBlock_size());
			return 0;
		} 
		size = (count < 0) ? (ULONG)(-count) : (ULONG)(count * channel.getBlock_size());
		offset.setQuadPart(block * channel.getBlock_size() + nt_data.getOffset());
		// If not fit to the blockif (size <= nt_data.getBuffer_size()) {
			nt_data.setBuffer_block_number(block);
			read_buffer = nt_data.getBuffer();
			read_size = nt_data.getBuffer_size();
		} else {
				read_size = size;
				read_buffer = buf;
				(((read_size % channel.getBlock_size()) == 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(read_size % channel->block_size) == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\nt_io.c", 656));
		} 
		// Update the cache
		if (!offset._RawRead(nt_data.getHandle(), read_size, read_buffer, errcode)) {
			if (channel.getRead_error()) {
				return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(channel, block, count, buf, size, 0, errcode);
			} else {
					return errcode;
			} 
		} 
		if (read_buffer != buf) {
			((size <= read_size) ? (Object)0 : /*Error: Function owner not recognized*/_assert("size <= read_size", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\nt_io.c", 667));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(buf, read_buffer, size);
		} 
		return 0;
	}
	public static Object nt_write_blk(Object channel, long block, int count, Object buf) {
		ULONG write_size = new ULONG();
		LARGE_INTEGER offset = new LARGE_INTEGER();
		PNT_PRIVATE_DATA nt_data = ((Object)0);
		 errcode = 0;
		if (!(channel) || (channel).getMagic() != (EXT2_ET_MAGIC_IO_CHANNEL)) {
			return (EXT2_ET_MAGIC_IO_CHANNEL);
		} 
		nt_data = (PNT_PRIVATE_DATA)channel.getPrivate_data();
		if (!(nt_data) || (nt_data).getMagic() != (true)) {
			return (true);
		} 
		if (nt_data.getRead_only()) {
			return 13;
		} 
		if (count == 1) {
			write_size = channel.getBlock_size();
		} else {
				nt_data.setBuffer_block_number(-1024);
				if (count < 0) {
					write_size = (ULONG)(-count);
				} else {
						write_size = (ULONG)(count * channel.getBlock_size());
				} 
		} 
		(((write_size % 512) == 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(write_size % 512) == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\nt_io.c", 699));
		offset.setQuadPart(block * channel.getBlock_size() + nt_data.getOffset());
		if (!offset._RawWrite(nt_data.getHandle(), write_size, buf, errcode)) {
			if (channel.getWrite_error()) {
				return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(channel, block, count, buf, write_size, 0, errcode);
			} else {
					return errcode;
			} 
		} 
		// Stash a copy.if (write_size >= nt_data.getBuffer_size()) {
			nt_data.setBuffer_block_number(block);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(nt_data.getBuffer(), buf, nt_data.getBuffer_size());
		} 
		nt_data.setWritten(1);
		return 0;
	}
	public static Object nt_flush(Object channel) {
		PNT_PRIVATE_DATA nt_data = ((Object)0);
		if (!(channel) || (channel).getMagic() != (EXT2_ET_MAGIC_IO_CHANNEL)) {
			return (EXT2_ET_MAGIC_IO_CHANNEL);
		} 
		nt_data = (PNT_PRIVATE_DATA)channel.getPrivate_data();
		if (!(nt_data) || (nt_data).getMagic() != (true)) {
			return (true);
		} 
		if (nt_data.getRead_only()) {
			return 0;
		} 
		// Flush file buffers.// Flush file buffers.ModernizedCProgram._FlushDrive(nt_data.getHandle());
		// Test and correct partition type.if (nt_data.getWritten()) {
			ModernizedCProgram._SetPartType(nt_data.getHandle(), -1024);
		} 
		return 0;
	}
	// For LGP set/restore
	// file system, boot type, partition type, target type
	// Number of steps for each FS for FCC_STRUCTURE_PROGRESS
	// TODO: Remember to update copyright year in stdlg's AboutCallback() WM_INITDIALOG,
	// localization_data.sh and the .rc when the year changes!
	// Fill in the cluster size names
	public static void SetClusterSizeLabels() {
		int i;
		int j;
		int msg_id;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ClusterSizeLabel[0], 64, ModernizedCProgram.lmprintf(3029));
			(ModernizedCProgram.ClusterSizeLabel[0])[(true) - 1] = 0;
		} while (0);
		for (; j < 18; ) {
			if (i > 8192) {
				i /= 1024;
				msg_id++;
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ClusterSizeLabel[j], 64, "%d %s", i, ModernizedCProgram.lmprintf(msg_id));
				(ModernizedCProgram.ClusterSizeLabel[j])[(true) - 1] = 0;
			} while (0);
		}
	}
	public static void SetAllowedFileSystems() {
		int i;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.allowed_filesystem, 0, /*Error: sizeof expression not supported yet*/)// Nothing is allowed if we don't have a drive;// Nothing is allowed if we don't have a drive
		if (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 327, 0, 0)) < 0) {
			return /*Error: Unsupported expression*/;
		} 
		switch (ModernizedCProgram.selection_default) {
		case boot_type.BT_NON_BOOTABLE:
				for (i = 0; i < fs_type.FS_MAX; i++) {
					ModernizedCProgram.allowed_filesystem[i] = 1;
				}
				break;
		case boot_type.BT_GRUB2:
				ModernizedCProgram.allowed_filesystem[fs_type.FS_FAT16] = 1;
				ModernizedCProgram.allowed_filesystem[fs_type.FS_FAT32] = 1;
				break;
		case boot_type.BT_UEFI_NTFS:
				ModernizedCProgram.allowed_filesystem[fs_type.FS_NTFS] = 1;
				break;
		case boot_type.BT_REACTOS:
		case boot_type.BT_MSDOS:
		case boot_type.BT_FREEDOS:
				ModernizedCProgram.allowed_filesystem[fs_type.FS_FAT16] = 1;
				ModernizedCProgram.allowed_filesystem[fs_type.FS_FAT32] = 1;
				break;
		case boot_type.BT_SYSLINUX_V4:
		case boot_type.BT_GRUB4DOS:
				ModernizedCProgram.allowed_filesystem[fs_type.FS_NTFS] = 1;
		case boot_type.BT_SYSLINUX_V6:
		case boot_type.BT_IMAGE:
				ModernizedCProgram.allowed_filesystem[fs_type.FS_NTFS] = 1;
				if ((ModernizedCProgram.image_path != ((Object)0)) && (ModernizedCProgram.img_report.getHas_4GB_file())) {
					break;
				} 
				if (!(((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getUses_minint()) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) || (ModernizedCProgram.target_type != target_type.TT_BIOS) || ModernizedCProgram.allow_dual_uefi_bios) {
					if (!(((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) && (ModernizedCProgram.img_report.getHas_efi() != 0) && (ModernizedCProgram.img_report.getWininst_index() != 0)) || (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1026)), 327, 0, 0)) != 1)) {
						ModernizedCProgram.allowed_filesystem[fs_type.FS_FAT16] = 1;
						ModernizedCProgram.allowed_filesystem[fs_type.FS_FAT32] = 1;
					} 
				} 
				break;
		}
		// Reset disk ID to 0x80 if Rufus MBR is usedif (ModernizedCProgram.selection_default != boot_type.BT_IMAGE) {
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDiskID), 334, (WPARAM)(int)(false), 0)));
			} while (0);
		} 
	}
	// Populate the Boot selection dropdown
	public static void SetBootOptions() {
		byte[] tmp = new byte[32];
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 331, 0, 0)));
		} while (0);
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hBootType, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3279)))), (LPARAM)(boot_type.BT_NON_BOOTABLE))));
		} while (0);
		// The diskcopy.dll along with its MS-DOS floppy image was removed in Windows 10if (ModernizedCProgram.nWindowsVersion < WindowsVersion.WINDOWS_10) {
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hBootType, 323, (WPARAM)0, "MS-DOS"))), (LPARAM)(boot_type.BT_MSDOS))));
			} while (0);
		} 
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hBootType, 323, (WPARAM)0, "FreeDOS"))), (LPARAM)(boot_type.BT_FREEDOS))));
		} while (0);
		ModernizedCProgram.image_index = (ModernizedCProgram.nWindowsVersion < WindowsVersion.WINDOWS_10) ? 3 : 2;
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hBootType, 323, (WPARAM)0, (ModernizedCProgram.image_path == ((Object)0)) ? ModernizedCProgram.lmprintf(3281, ModernizedCProgram.lmprintf(3280)) : ModernizedCProgram.short_image_path))), (LPARAM)(boot_type.BT_IMAGE))));
		} while (0);
		if ((!ModernizedCProgram.advanced_mode_device) && (ModernizedCProgram.selection_default >= boot_type.BT_SYSLINUX_V4)) {
			ModernizedCProgram.selection_default = boot_type.BT_IMAGE;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1020, 0);
		} 
		ModernizedCProgram.SetComboEntry(ModernizedCProgram.hBootType, ModernizedCProgram.selection_default);
	}
	public static void SetPartitionSchemeAndTargetSystem(Object only_target) {
		//                                   MBR,  GPT,  SFDBOOL[] allowed_partition_scheme = new BOOL[]{1, 1, 0};
		//                                   BIOS, UEFI, DUAL
		BOOL[] allowed_target_system = new BOOL[]{1, 1, 0};
		BOOL is_windows_to_go_selected = new BOOL();
		if (!only_target) {
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hPartitionScheme), 331, 0, 0)));
			} while (0);
		} 
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hTargetSystem), 331, 0, 0)));
		} while (0);
		ModernizedCProgram.boot_type = (int)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 327, 0, 0))), 0));
		is_windows_to_go_selected = (ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.image_path != ((Object)0)) && (((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) && (ModernizedCProgram.img_report.getHas_efi() != 0) && (ModernizedCProgram.img_report.getWininst_index() != 0)) && (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1026)), 327, 0, 0)) == 1);
		// If no device is selected, don't populate anythingif (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 327, 0, 0)) < 0) {
			return /*Error: Unsupported expression*/;
		} 
		switch (ModernizedCProgram.boot_type) {
		case boot_type.BT_SYSLINUX_V6:
		case boot_type.BT_MSDOS:
		case boot_type.BT_GRUB2:
				allowed_partition_scheme[_PARTITION_STYLE.PARTITION_STYLE_GPT] = 0;
				allowed_target_system[1] = 0;
				break;
		case boot_type.BT_SYSLINUX_V4:
		case boot_type.BT_UEFI_NTFS:
				allowed_target_system[0] = 0;
				break;
		case boot_type.BT_NON_BOOTABLE:
				allowed_partition_scheme[_PARTITION_STYLE.PARTITION_STYLE_RAW] = 1;
				allowed_target_system[0] = 0;
				allowed_target_system[1] = 0;
				allowed_target_system[2] = 1;
				break;
		case boot_type.BT_FREEDOS:
		case boot_type.BT_GRUB4DOS:
		case boot_type.BT_REACTOS:
		case boot_type.BT_IMAGE:
				if (ModernizedCProgram.image_path == ((Object)0)) {
					break;
				} 
				if (!(ModernizedCProgram.img_report.getHas_efi() != 0)) {
					allowed_partition_scheme[_PARTITION_STYLE.PARTITION_STYLE_GPT] = 0;
					allowed_target_system[1] = 0;
					break;
				} 
				if ((((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getSl_version() != 0) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024)) || ((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos())) || (ModernizedCProgram.img_report.getReactos_path()[0] != 0) || (ModernizedCProgram.img_report.getHas_kolibrios()))) {
					if (!(((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getUses_minint()) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) || ModernizedCProgram.allow_dual_uefi_bios || is_windows_to_go_selected) {
						allowed_target_system[0] = 0;
						allowed_target_system[1] = 1;
						allowed_target_system[2] = 1;
					} 
				} else {
						allowed_target_system[0] = 0;
				} 
				break;
		}
		if (!only_target) {
			if (ModernizedCProgram.SelectedDrive.getDiskSize() > 2 * -1024) {
				ModernizedCProgram.selected_pt = _PARTITION_STYLE.PARTITION_STYLE_GPT;
			} 
			int preferred_pt = ModernizedCProgram.SelectedDrive.getPartitionStyle();
			if (allowed_partition_scheme[_PARTITION_STYLE.PARTITION_STYLE_MBR]) {
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hPartitionScheme), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hPartitionScheme, 323, (WPARAM)0, "MBR"))), (LPARAM)(_PARTITION_STYLE.PARTITION_STYLE_MBR))));
				} while (0);
			} 
			if (allowed_partition_scheme[_PARTITION_STYLE.PARTITION_STYLE_GPT]) {
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hPartitionScheme), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hPartitionScheme, 323, (WPARAM)0, "GPT"))), (LPARAM)(_PARTITION_STYLE.PARTITION_STYLE_GPT))));
				} while (0);
			} 
			if (allowed_partition_scheme[_PARTITION_STYLE.PARTITION_STYLE_RAW]) {
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hPartitionScheme), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hPartitionScheme, 323, (WPARAM)0, ModernizedCProgram.sfd_name))), (LPARAM)(_PARTITION_STYLE.PARTITION_STYLE_RAW))));
				} while (0);
			} 
			if (ModernizedCProgram.boot_type == boot_type.BT_NON_BOOTABLE) {
				preferred_pt = (ModernizedCProgram.selected_pt >= 0) ? ModernizedCProgram.selected_pt : _PARTITION_STYLE.PARTITION_STYLE_MBR;
			}  else if (ModernizedCProgram.boot_type == boot_type.BT_UEFI_NTFS) {
				preferred_pt = (ModernizedCProgram.selected_pt >= 0) ? ModernizedCProgram.selected_pt : _PARTITION_STYLE.PARTITION_STYLE_GPT;
			}  else if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.image_path != ((Object)0)) && (ModernizedCProgram.img_report.getIs_iso())) {
				if ((((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getUses_minint()) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) && ModernizedCProgram.img_report.getHas_efi()) {
					preferred_pt = ModernizedCProgram.allow_dual_uefi_bios ? _PARTITION_STYLE.PARTITION_STYLE_MBR : ((ModernizedCProgram.selected_pt >= 0) ? ModernizedCProgram.selected_pt : _PARTITION_STYLE.PARTITION_STYLE_GPT);
				} 
				if (ModernizedCProgram.img_report.getIs_bootable_img()) {
					preferred_pt = (ModernizedCProgram.selected_pt >= 0) ? ModernizedCProgram.selected_pt : _PARTITION_STYLE.PARTITION_STYLE_MBR;
				} 
			} 
			ModernizedCProgram.SetComboEntry(ModernizedCProgram.hPartitionScheme, preferred_pt);
			ModernizedCProgram.partition_type = (int)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hPartitionScheme), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hPartitionScheme), 327, 0, 0))), 0));
		} 
		// Override partition type selection to GPT for drives larger than 2TB
		ModernizedCProgram.has_uefi_csm = 0;
		if (allowed_target_system[0] && (ModernizedCProgram.partition_type != _PARTITION_STYLE.PARTITION_STYLE_GPT)) {
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hTargetSystem), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hTargetSystem, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3031)))), (LPARAM)(target_type.TT_BIOS))));
			} while (0);
			ModernizedCProgram.has_uefi_csm = 1;
		} 
		if (allowed_target_system[1] && !((ModernizedCProgram.partition_type == _PARTITION_STYLE.PARTITION_STYLE_MBR) && (ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getSl_version() != 0) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024)) || ((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos())) || (ModernizedCProgram.img_report.getReactos_path()[0] != 0) || (ModernizedCProgram.img_report.getHas_kolibrios())) && (ModernizedCProgram.img_report.getHas_efi() != 0))) {
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hTargetSystem), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hTargetSystem, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3032)))), (LPARAM)(target_type.TT_UEFI))));
			} while (0);
		} 
		if (allowed_target_system[2] && ((ModernizedCProgram.partition_type != _PARTITION_STYLE.PARTITION_STYLE_GPT) || (ModernizedCProgram.boot_type == boot_type.BT_NON_BOOTABLE))) {
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hTargetSystem), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hTargetSystem, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3033)))), (LPARAM)(target_type.TT_BIOS))));
			} while (0);
		} 
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hTargetSystem), 334, (WPARAM)(int)(false), 0)));
		} while (0);
		ModernizedCProgram.target_type = (int)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hTargetSystem), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hTargetSystem), 327, 0, 0))), 0))// Can't update a tooltip from a thread, so we send a message instead;// Can't update a tooltip from a thread, so we send a message instead
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_UPDATE_CSM_TOOLTIP, 0, 0);
	}
	// Populate the Allocation unit size field
	public static Object SetClusterSizes(int FSType) {
		byte szClustSize;
		int i;
		int k;
		int default_index = 0;
		ULONG j = new ULONG();
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hClusterSize), 331, 0, 0)));
		} while (0);
		if ((FSType < 0) || (FSType >= fs_type.FS_MAX)) {
			return 0;
		} 
		if ((ModernizedCProgram.SelectedDrive.getClusterSize()[FSType].getAllowed() == 0) || (ModernizedCProgram.SelectedDrive.getClusterSize()[FSType].getDefault() == 0)) {
			return 0;
		} 
		for (; j < -1024; ) {
			if (j & ModernizedCProgram.SelectedDrive.getClusterSize()[FSType].getAllowed()) {
				if (j == ModernizedCProgram.SelectedDrive.getClusterSize()[FSType].getDefault()) {
					szClustSize = ModernizedCProgram.lmprintf(3030, ModernizedCProgram.ClusterSizeLabel[i]);
					default_index = k;
				} else {
						szClustSize = ModernizedCProgram.ClusterSizeLabel[i];
				} 
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hClusterSize), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hClusterSize, 323, (WPARAM)0, szClustSize))), (LPARAM)(j))));
				} while (0);
				k++;
			} 
		}
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hClusterSize), 334, (WPARAM)(int)(default_index), 0)));
		} while (0);
		return 1;
	}
	// Populate the File System and Cluster Size dropdowns
	public static Object SetFileSystemAndClusterSize(Byte fs_name) {
		int fs_index;
		LONGLONG i = new LONGLONG();
		byte[] tmp = "";
		byte entry;
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 331, 0, 0)));
		} while (0);
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hClusterSize), 331, 0, 0)));
		} while (0);
		ModernizedCProgram.default_fs = fs_type.FS_UNKNOWN;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.SelectedDrive.getClusterSize(), 0, /*Error: sizeof expression not supported yet*/);
		// FAT 16if (ModernizedCProgram.SelectedDrive.getDiskSize() < 4 * -1024) {
			ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_FAT16].setAllowed(-1024);
			for (i = 32; i <= 4096; i <<=  1) {
				if (ModernizedCProgram.SelectedDrive.getDiskSize() < i * -1024) {
					ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_FAT16].setDefault(16 * (ULONG)i);
					break;
				} 
				ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_FAT16].getAllowed() <<=  1;
			}
			ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_FAT16].getAllowed() &=  -1024;
		} 
		// > 32GB FAT32 is not supported by MS and FormatEx but is achieved using fat32format// See: http://www.ridgecrop.demon.co.uk/index.htm?fat32format.htm// < 32 MB FAT32 is not allowed by FormatEx, so we don't botherif ((ModernizedCProgram.SelectedDrive.getDiskSize() >= 32 * -1024) && (1.0 * ModernizedCProgram.SelectedDrive.getDiskSize() < 1.0 * 2.0 * -1024)) {
			ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_FAT32].setAllowed(-1024);
			for (i = 32; i <= (32 * 1024); i <<=  1) {
				if (ModernizedCProgram.SelectedDrive.getDiskSize() * 1.0 < i * -1024 * 1.011) {
					ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_FAT32].setDefault(8 * (ULONG)i);
					break;
				} 
				ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_FAT32].getAllowed() <<=  1;
			}
			ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_FAT32].getAllowed() &=  -1024;
			if ((ModernizedCProgram.SelectedDrive.getDiskSize() >= 256 * -1024) && (ModernizedCProgram.SelectedDrive.getDiskSize() < 32 * -1024)) {
				for (i = 8; i <= 32; i <<=  1) {
					if (ModernizedCProgram.SelectedDrive.getDiskSize() * 1.0 < i * -1024 * 1.011) {
						ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_FAT32].setDefault(((ULONG)i / 2) * -1024);
						break;
					} 
				}
			} 
			if (ModernizedCProgram.SelectedDrive.getDiskSize() >= 32 * -1024) {
				ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_FAT32].getAllowed() &=  -1024;
				ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_FAT32].setDefault(-1024);
			} 
		} 
		if (ModernizedCProgram.SelectedDrive.getDiskSize() < 256 * -1024) {
			ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_NTFS].setAllowed(-1024);
			for (i = 16; i <= 256; i <<=  1) {
				if (ModernizedCProgram.SelectedDrive.getDiskSize() < i * -1024) {
					ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_NTFS].setDefault(((ULONG)i / 4) * -1024);
					break;
				} 
			}
			ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_EXFAT].setAllowed(-1024);
			if (ModernizedCProgram.SelectedDrive.getDiskSize() < 256 * -1024) {
				ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_EXFAT].setDefault(4 * -1024);
			}  else if (ModernizedCProgram.SelectedDrive.getDiskSize() < 32 * -1024) {
				ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_EXFAT].setDefault(32 * -1024);
			} else {
					ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_EXFAT].setDefault(128 * -1024);
			} 
			ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_UDF].setAllowed(-1024);
			ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_UDF].setDefault(1);
			if (ModernizedCProgram.advanced_mode_format) {
				ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_EXT2].setAllowed(-1024);
				ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_EXT2].setDefault(1);
				ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_EXT3].setAllowed(-1024);
				ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_EXT3].setDefault(1);
			} 
			if (ModernizedCProgram.SelectedDrive.getDiskSize() >= 512 * -1024) {
				if ((ModernizedCProgram.nWindowsVersion >= WindowsVersion.WINDOWS_8_1) && (ModernizedCProgram.SelectedDrive.getMediaType() == _MEDIA_TYPE.FixedMedia)) {
					ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_REFS].setAllowed(-1024);
					ModernizedCProgram.SelectedDrive.getClusterSize()[fs_type.FS_REFS].setDefault(1);
				} 
			} 
		} 
		// NTFS
		// Only add the filesystems we can service// Only add the filesystems we can serviceModernizedCProgram.SetAllowedFileSystems();
		ModernizedCProgram.SetClusterSizeLabels();
		for (fs_index = 0; fs_index < fs_type.FS_MAX; fs_index++) {
			if (ModernizedCProgram.SelectedDrive.getClusterSize()[fs_index].getAllowed() != -1024) {
				ModernizedCProgram.SelectedDrive.getClusterSize()[fs_index].getAllowed() &=  ~(ModernizedCProgram.SelectedDrive.getSectorSize() - 1);
				if ((ModernizedCProgram.SelectedDrive.getClusterSize()[fs_index].getDefault() & ModernizedCProgram.SelectedDrive.getClusterSize()[fs_index].getAllowed()) == 0) {
					ModernizedCProgram.SelectedDrive.getClusterSize()[fs_index].setDefault(ModernizedCProgram.SelectedDrive.getClusterSize()[fs_index].getAllowed() & (-(LONG)ModernizedCProgram.SelectedDrive.getClusterSize()[fs_index].getAllowed()));
				} 
			} 
			if (ModernizedCProgram.SelectedDrive.getClusterSize()[fs_index].getAllowed() != 0) {
				tmp[0] = 0;
				if ((fs_index == fs_type.FS_FAT32) && ((ModernizedCProgram.SelectedDrive.getDiskSize() > (32 * -1024)) || (ModernizedCProgram.force_large_fat32))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(tmp, "Large ", (((size_t)(((((byte)"Large ") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Large ")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)tmp) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp)) - 1)) ? ((size_t)(((((byte)"Large ") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Large ")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)tmp) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp)) - 1))));
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(tmp, ModernizedCProgram.FileSystemLabel[fs_index], (((size_t)(((((byte)ModernizedCProgram.FileSystemLabel[fs_index]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.FileSystemLabel[fs_index])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)tmp) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp)) - 1)) ? ((size_t)(((((byte)ModernizedCProgram.FileSystemLabel[fs_index]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.FileSystemLabel[fs_index])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)tmp) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp)) - 1))));
				if (ModernizedCProgram.default_fs == fs_type.FS_UNKNOWN) {
					entry = ModernizedCProgram.lmprintf(3030, tmp);
					ModernizedCProgram.default_fs = fs_index;
				} else {
						entry = tmp;
				} 
				if (ModernizedCProgram.allowed_filesystem[fs_index]) {
					do {
						(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hFileSystem, 323, (WPARAM)0, entry))), (LPARAM)(fs_index))));
					} while (0);
				} 
			} 
		}// Remove all cluster sizes that are below the sector size
		// re-select existing FS if it's one we know// re-select existing FS if it's one we knowModernizedCProgram.SelectedDrive.setFSType(fs_type.FS_UNKNOWN);
		if (((((byte)fs_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(fs_name)) != 0) {
			for (ModernizedCProgram.SelectedDrive.setFSType(fs_type.FS_MAX - 1); ModernizedCProgram.SelectedDrive.getFSType() >= 0; ModernizedCProgram.SelectedDrive.getFSType()--) {
				if (/*Error: Function owner not recognized*/strcmp(((fs_name == ((Object)0)) ? "<NULL>" : fs_name), ((ModernizedCProgram.FileSystemLabel[ModernizedCProgram.SelectedDrive.getFSType()] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.FileSystemLabel[ModernizedCProgram.SelectedDrive.getFSType()])) == 0) {
					break;
				} 
			}
		} else {
				ModernizedCProgram.SelectedDrive.setFSType(ModernizedCProgram.selected_fs);
		} 
		for (i = 0; i < ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 326, 0, 0)); i++) {
			if (((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 336, (WPARAM)(int)(i), 0)) == ModernizedCProgram.SelectedDrive.getFSType()) {
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 334, (WPARAM)(int)(i), 0)));
				} while (0);
				break;
			} 
		}
		if (i == ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 326, 0, 0))) {
			ModernizedCProgram.SetComboEntry(ModernizedCProgram.hFileSystem, ModernizedCProgram.default_fs);
		} 
		// failed to reselect => pick default
		return ModernizedCProgram.SetClusterSizes((int)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 327, 0, 0))), 0)));
	}
	public static void SetFSFromISO() {
		int i;
		int fs_tmp;
		int preferred_fs = fs_type.FS_UNKNOWN;
		uint32_t fs_mask = fs_type.FS_FAT32 | fs_type.FS_NTFS;
		BOOL windows_to_go = (ModernizedCProgram.image_options & -1024) && (ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) && (ModernizedCProgram.img_report.getHas_efi() != 0) && (ModernizedCProgram.img_report.getWininst_index() != 0)) && (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1026)), 327, 0, 0)) == 1);
		if (ModernizedCProgram.image_path == ((Object)0)) {
			return /*Error: Unsupported expression*/;
		} 
		// Create a mask of all the FS's availablefor (i = 0; i < ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 326, 0, 0)); i++) {
			fs_tmp = (int)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 336, (WPARAM)(int)(i), 0));
			fs_mask |=  1 << fs_tmp;
		}
		if ((preferred_fs == fs_type.FS_UNKNOWN) && (ModernizedCProgram.preselected_fs != fs_type.FS_UNKNOWN)) {
			if (fs_mask & (1 << ModernizedCProgram.preselected_fs)) {
				preferred_fs = ModernizedCProgram.preselected_fs;
			} 
		} 
		// If the FS requested from the command line is valid use it
		if (preferred_fs == fs_type.FS_UNKNOWN) {
			if (((ModernizedCProgram.img_report.getSl_version() != 0)) || ((ModernizedCProgram.img_report.getReactos_path()[0] != 0)) || (ModernizedCProgram.img_report.getHas_kolibrios()) || ((ModernizedCProgram.img_report.getHas_efi() != 0) && (ModernizedCProgram.target_type == target_type.TT_UEFI) && (!windows_to_go))) {
				if (fs_mask & (1 << fs_type.FS_FAT32)) {
					preferred_fs = fs_type.FS_FAT32;
				}  else if ((fs_mask & (1 << fs_type.FS_FAT16)) && !(ModernizedCProgram.img_report.getHas_kolibrios())) {
					preferred_fs = fs_type.FS_FAT16;
				} 
			}  else if ((windows_to_go) || ((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) {
				if (fs_mask & (1 << fs_type.FS_NTFS)) {
					preferred_fs = fs_type.FS_NTFS;
				} 
			} 
		} 
		// Syslinux and EFI have precedence over bootmgr (unless the user selected BIOS as target type)
		// The presence of a 4GB file forces the use of NTFS as default FS if availableif (ModernizedCProgram.img_report.getHas_4GB_file() && (fs_mask & (1 << fs_type.FS_NTFS))) {
			preferred_fs = fs_type.FS_NTFS;
		} 
		// Try to select the FSfor (i = 0; i < ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 326, 0, 0)); i++) {
			fs_tmp = (int)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 336, (WPARAM)(int)(i), 0));
			if (fs_tmp == preferred_fs) {
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 334, (WPARAM)(int)(i), 0)));
				} while (0);
				break;
			} 
		}
		if (ModernizedCProgram.selected_fs == fs_type.FS_UNKNOWN) {
			ModernizedCProgram.selected_fs = preferred_fs;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, 273, ((1 + 256) << 16) | 1002, ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 327, 0, 0)));
	}
	public static void SetMBRProps() {
		BOOL needs_masquerading = (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024)) && (!ModernizedCProgram.img_report.getUses_minint());
		if ((!ModernizedCProgram.mbr_selected_by_user) && ((ModernizedCProgram.image_path == ((Object)0)) || (ModernizedCProgram.boot_type != boot_type.BT_IMAGE) || (ModernizedCProgram.fs_type != fs_type.FS_NTFS) || ((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos())) || ((ModernizedCProgram.image_options & -1024) && (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1026)), 327, 0, 0)) == 1)))) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1016, 0);
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDiskID), 334, (WPARAM)(int)(false), 0)));
			} while (0);
			return /*Error: Unsupported expression*/;
		} 
		ModernizedCProgram.uMBRChecked = (needs_masquerading || ((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || ModernizedCProgram.mbr_selected_by_user) ? 1 : 0;
		if (/*Error: Function owner not recognized*/IsWindowEnabled(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1016))) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1016, ModernizedCProgram.uMBRChecked);
		} 
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDiskID), 334, (WPARAM)(int)(needs_masquerading ? 1 : 0), 0)));
		} while (0);
	}
	public static void SetProposedLabel(int ComboIndex) {
		byte[] no_label = "NO_LABEL";
		byte[] empty = "";
		ModernizedCProgram.app_changed_label = 1// If bootable ISO creation is selected, and we have an ISO selected with a valid name, use that;// If bootable ISO creation is selected, and we have an ISO selected with a valid name, use that
		// Also some distros (eg. Arch) require the USB to have the same label as the ISOif ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.image_path != ((Object)0)) && (ModernizedCProgram.img_report.getLabel()[0] != 0)) {
			ModernizedCProgram.SetWindowTextU(ModernizedCProgram.hLabel, ModernizedCProgram.img_report.getLabel());
			ModernizedCProgram.user_changed_label = 0;
			return /*Error: Unsupported expression*/;
		} 
		// If the user manually changed the label, try to preserve itif (ModernizedCProgram.user_changed_label) {
			ModernizedCProgram.app_changed_label = 0;
			return /*Error: Unsupported expression*/;
		} 
		// Empty the label if no device is currently selectedif (ComboIndex < 0) {
			ModernizedCProgram.SetWindowTextU(ModernizedCProgram.hLabel, "");
			return /*Error: Unsupported expression*/;
		} 
		// Else if no existing label is available, propose one according to the size (eg: "256MB", "8GB")if ((/*Error: Function owner not recognized*/_stricmp(no_label, ModernizedCProgram.DriveLabel.getString()[ComboIndex]) == 0) || (/*Error: Function owner not recognized*/_stricmp(no_label, empty) == 0) || (/*Error: Function owner not recognized*/_stricmp(((ModernizedCProgram.lmprintf(3207) == ((Object)0)) ? "<NULL>" : ModernizedCProgram.lmprintf(3207)), ((ModernizedCProgram.DriveLabel.getString()[ComboIndex] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.DriveLabel.getString()[ComboIndex])) == 0)) {
			ModernizedCProgram.SetWindowTextU(ModernizedCProgram.hLabel, ModernizedCProgram.SelectedDrive.getProposed_label());
		} else {
				ModernizedCProgram.SetWindowTextU(ModernizedCProgram.hLabel, ModernizedCProgram.DriveLabel.getString()[ComboIndex]);
		} 
	}
	// This handles the enabling/disabling of the "Add fixes for old BIOSes" and "Use Rufus MBR" controls
	public static void EnableMBRBootOptions(Object enable, Object remove_checkboxes) {
		BOOL actual_enable_mbr = (ModernizedCProgram.boot_type > boot_type.BT_IMAGE) ? 0 : enable;
		BOOL actual_enable_fix = enable;
		UINT uXPartChecked = 0;
		if ((ModernizedCProgram.partition_type != _PARTITION_STYLE.PARTITION_STYLE_MBR) || (ModernizedCProgram.target_type != target_type.TT_BIOS) || (ModernizedCProgram.boot_type == boot_type.BT_NON_BOOTABLE) || ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (!(((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getSl_version() != 0) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024)) || ((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos())) || (ModernizedCProgram.img_report.getReactos_path()[0] != 0) || (ModernizedCProgram.img_report.getHas_kolibrios())) || (ModernizedCProgram.img_report.getIs_bootable_img() && (!ModernizedCProgram.img_report.getIs_iso() || ModernizedCProgram.img_report.getDisable_iso()))))) {
			actual_enable_mbr = 0;
			actual_enable_fix = 0;
		} else {
				if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && !(((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024)) && !((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi()))) {
					actual_enable_mbr = 0;
					ModernizedCProgram.mbr_selected_by_user = 0;
				} 
				if (ModernizedCProgram.boot_type == boot_type.BT_NON_BOOTABLE) {
					actual_enable_fix = 0;
				} 
		} 
		if (remove_checkboxes) {
			if (/*Error: Function owner not recognized*/IsWindowEnabled(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1016)) && !actual_enable_mbr) {
				ModernizedCProgram.uMBRChecked = (/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1016) == 1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1016, 0);
			}  else if (!/*Error: Function owner not recognized*/IsWindowEnabled(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1016)) && actual_enable_mbr) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1016, ModernizedCProgram.uMBRChecked);
			} 
			if (/*Error: Function owner not recognized*/IsWindowEnabled(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1021)) && !actual_enable_fix) {
				uXPartChecked = (/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1021) == 1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1021, 0);
			}  else if (!/*Error: Function owner not recognized*/IsWindowEnabled(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1021)) && actual_enable_fix) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1021, uXPartChecked);
			} 
		} 
		// Store/Restore the checkbox states
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1021), actual_enable_fix);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1016), actual_enable_mbr);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hDiskID, actual_enable_mbr);
	}
	public static void EnableExtendedLabel(Object enable, Object remove_checkboxes) {
		UINT checked = new UINT();
		UINT state = 0;
		HWND hCtrl = /*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1015);
		if ((ModernizedCProgram.fs_type >= fs_type.FS_EXT2) || ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getIs_bootable_img() && (!ModernizedCProgram.img_report.getIs_iso() || ModernizedCProgram.img_report.getDisable_iso())))) {
			enable = 0;
		} 
		if (remove_checkboxes) {
			if (!enable && (state != 1)) {
				checked = (/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1015) == 1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1015, 0);
				state = 1;
			}  else if (enable && !/*Error: Function owner not recognized*/IsWindowEnabled(hCtrl) && (state != 2)) {
				if (state != 0) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1015, checked);
				} 
				state = 2;
			} 
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(hCtrl, enable);
	}
	public static void EnableQuickFormat(Object enable, Object remove_checkboxes) {
		UINT checked = new UINT();
		UINT state = 0;
		HWND hCtrl = /*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1008);
		if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getIs_bootable_img() && (!ModernizedCProgram.img_report.getIs_iso() || ModernizedCProgram.img_report.getDisable_iso()))) {
			enable = 0;
		} 
		// Disable/restore the quick format control depending on large FAT32 or ReFSif (((ModernizedCProgram.fs_type == fs_type.FS_FAT32) && ((ModernizedCProgram.SelectedDrive.getDiskSize() > (32 * -1024)) || (ModernizedCProgram.force_large_fat32))) || (ModernizedCProgram.fs_type == fs_type.FS_REFS)) {
			enable = 0;
			remove_checkboxes = 0;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1008, 1);
		} 
		if (remove_checkboxes) {
			if (!enable && (state != 1)) {
				checked = (/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1008) == 1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1008, 0);
				state = 1;
			}  else if (enable && !/*Error: Function owner not recognized*/IsWindowEnabled(hCtrl) && (state != 2)) {
				if (state != 0) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1008, checked);
				} 
				state = 2;
			} 
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(hCtrl, enable);
	}
	public static void EnableBootOptions(Object enable, Object remove_checkboxes) {
		BOOL actual_enable_bb = new BOOL();
		BOOL actual_enable = enable;
		// If no device is selected, don't enable anythingif (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 327, 0, 0)) < 0) {
			actual_enable = 0;
		} 
		if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.image_path == ((Object)0))) {
			actual_enable = 0;
		} 
		actual_enable_bb = actual_enable// If we are dealing with a pure DD image, remove all options except Bad Blocks check;// If we are dealing with a pure DD image, remove all options except Bad Blocks check
		if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getIs_bootable_img()) && (!ModernizedCProgram.img_report.getIs_iso())) {
			actual_enable = 0;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1026), actual_enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1027), actual_enable)// Make sure we set the range if we have persistence;// Make sure we set the range if we have persistence
		if ((ModernizedCProgram.image_path != ((Object)0)) && (((ModernizedCProgram.img_report.getSl_version() != 0) || ((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos()))) && !((((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getUses_minint()) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) || (ModernizedCProgram.img_report.getReactos_path()[0] != 0) || (ModernizedCProgram.img_report.getHas_kolibrios())))) {
			ModernizedCProgram.SetPersistenceSize();
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1018), (ModernizedCProgram.persistence_size != 0) && actual_enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1019), (ModernizedCProgram.persistence_size != 0) && actual_enable);
		ModernizedCProgram.EnableMBRBootOptions(actual_enable, remove_checkboxes);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1007), actual_enable);
		if (ModernizedCProgram.boot_type == boot_type.BT_IMAGE) {
			if ((ModernizedCProgram.img_report.getIs_bootable_img() && (!ModernizedCProgram.img_report.getIs_iso() || ModernizedCProgram.img_report.getDisable_iso()))) {
				remove_checkboxes = 1;
			}  else if (ModernizedCProgram.image_path == ((Object)0)) {
				remove_checkboxes = 0;
			} 
		} 
		ModernizedCProgram.EnableQuickFormat(actual_enable, remove_checkboxes);
		ModernizedCProgram.EnableExtendedLabel(actual_enable, remove_checkboxes);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1009), actual_enable_bb);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1012), actual_enable_bb);
	}
	// Toggle controls according to operation
	public static void EnableControls(Object enable, Object remove_checkboxes) {
		ModernizedCProgram.op_in_progress = !enable// The following only get disabled on format/checksum and otherwise remain enabled,;// The following only get disabled on format/checksum and otherwise remain enabled,
		/*Error: Function owner not recognized*/// even if no device or image are selected/*Error: Function owner not recognized*/// even if no device or image are selectedEnableWindow(ModernizedCProgram.hDeviceList, enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hBootType, enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hSelectImage, enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1022), enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hAdvancedDeviceToolbar, enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hAdvancedFormatToolbar, enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMultiToolbar, (1024 + 1), (WPARAM)1051, (LPARAM)enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMultiToolbar, (1024 + 1), (WPARAM)1052, (LPARAM)enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMultiToolbar, (1024 + 1), (WPARAM)1053, (LPARAM)enable);
		/*Error: Function owner not recognized*/// Checksum button is enabled if an image has been selected/*Error: Function owner not recognized*/// Checksum button is enabled if an image has been selectedEnableWindow(ModernizedCProgram.hHashToolbar, enable && (ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.image_path != ((Object)0)));
		// Toggle CLOSE/CANCEL// Toggle CLOSE/CANCELModernizedCProgram.SetDlgItemTextU(ModernizedCProgram.hMainDialog, 2, enable ? ModernizedCProgram.uppercase_close : ModernizedCProgram.uppercase_cancel);
		// Only enable the following controls if a device is active// Only enable the following controls if a device is activeenable = (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 327, 0, 0)) < 0) ? 0 : enable;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1026), enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hSaveToolbar, enable);
		// Enable or disable the Start button and the other boot options// Enable or disable the Start button and the other boot optionsenable = ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.image_path == ((Object)0))) ? 0 : enable;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hStart, enable);
		ModernizedCProgram.EnableBootOptions(enable, remove_checkboxes);
		// Finally, only enable the half-size dropdowns if we aren't dealing with a pure DD image// Finally, only enable the half-size dropdowns if we aren't dealing with a pure DD imageenable = ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.image_path != ((Object)0)) && (!ModernizedCProgram.img_report.getIs_iso())) ? 0 : enable;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hPartitionScheme, enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hTargetSystem, enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 2005), enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hFileSystem, enable);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hClusterSize, enable);
	}
	// Populate the UI main dropdown properties.
	// This should be called on device or boot type change.
	public static Object PopulateProperties() {
		byte device_tooltip;
		int device_index = ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 327, 0, 0));
		byte[] fs_name = new byte[32];
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.SelectedDrive, 0, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(ModernizedCProgram.hStart, 0);
		if (device_index < 0) {
			;
		} 
		ModernizedCProgram.persistence_unit_selection = -1// Get data from the currently selected drive;// Get data from the currently selected drive
		ModernizedCProgram.SelectedDrive.setDeviceNumber((DWORD)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 336, (WPARAM)(int)(device_index), 0)))// This fills the SelectedDrive properties;// This fills the SelectedDrive properties
		ModernizedCProgram.GetDrivePartitionData(ModernizedCProgram.SelectedDrive.getDeviceNumber(), fs_name, /*Error: sizeof expression not supported yet*/, 0);
		ModernizedCProgram.SetPartitionSchemeAndTargetSystem(0)// Attempt to reselect the last file system explicitly set by the user;// Attempt to reselect the last file system explicitly set by the user
		if (!ModernizedCProgram.SetFileSystemAndClusterSize((ModernizedCProgram.selected_fs == fs_type.FS_UNKNOWN) ? fs_name : ((Object)0))) {
			ModernizedCProgram.SetProposedLabel(-1);
			ModernizedCProgram._uprintf("No file system is selectable for this drive\n");
			return 0;
		} 
		ModernizedCProgram.EnableControls(1, 0);
		// Set a proposed label according to the size (eg: "256MB", "8GB")do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.SelectedDrive.getProposed_label(), /*Error: sizeof expression not supported yet*/, ModernizedCProgram.SizeToHumanReadable(ModernizedCProgram.SelectedDrive.getDiskSize(), 0, ModernizedCProgram.use_fake_units));
			(ModernizedCProgram.SelectedDrive.getProposed_label())[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		// Add a tooltip (with the size of the device in parenthesis)// Add a tooltip (with the size of the device in parenthesis)device_tooltip = (byte)/*Error: Function owner not recognized*/malloc(((((byte)ModernizedCProgram.DriveName.getString()[device_index]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.DriveName.getString()[device_index])) + 32);
		if (device_tooltip != ((Object)0)) {
			if (ModernizedCProgram.right_to_left_mode) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(device_tooltip, ((((byte)ModernizedCProgram.DriveName.getString()[device_index]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.DriveName.getString()[device_index])) + 32, "(%s) %s", ModernizedCProgram.SizeToHumanReadable(ModernizedCProgram.SelectedDrive.getDiskSize(), 0, 0), ModernizedCProgram.DriveName.getString()[device_index]);
					(device_tooltip)[(((((byte)ModernizedCProgram.DriveName.getString()[device_index]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.DriveName.getString()[device_index])) + 32) - 1] = 0;
				} while (0);
			} else {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(device_tooltip, ((((byte)ModernizedCProgram.DriveName.getString()[device_index]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.DriveName.getString()[device_index])) + 32, "%s (%s)", ModernizedCProgram.DriveName.getString()[device_index], ModernizedCProgram.SizeToHumanReadable(ModernizedCProgram.SelectedDrive.getDiskSize(), 0, 0));
						(device_tooltip)[(((((byte)ModernizedCProgram.DriveName.getString()[device_index]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.DriveName.getString()[device_index])) + 32) - 1] = 0;
					} while (0);
			} 
			ModernizedCProgram.CreateTooltip(ModernizedCProgram.hDeviceList, device_tooltip, -1);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(device_tooltip);
		} 
		return 1;
	}
	// Callback for the log window
	public static Object LogCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		HDC hDC = new HDC();
		HFONT hf = new HFONT();
		LONG lfHeight = new LONG();
		LONG_PTR style = new LONG_PTR();
		DWORD log_size = new DWORD();
		byte log_buffer = ((Object)0);
		byte filepath;
		byte[] _log_ext_x = new byte[]{"*.log"};
		byte[] _log_ext_d = new byte[]{"Rufus log"};
		ext_t log_ext = new ext_t((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), "rufus.log", _log_ext_x, _log_ext_d);
		switch (message) {
		case 273:
				switch (((WORD)((DWORD)(wParam)))) {
				case 1057:
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowTextA(ModernizedCProgram.hLog, "");
						return 1;
				case 2:
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(hDlg, 0);
						ModernizedCProgram.log_displayed = 0;
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, 40, (WPARAM)/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 2), 1);
						return 1;
				case 1056:
						log_size = ModernizedCProgram.GetWindowTextLengthU(ModernizedCProgram.hLog);
						if (log_size <= 0) {
							break;
						} 
						log_buffer = (byte)/*Error: Function owner not recognized*/malloc(log_size);
						if (log_buffer != ((Object)0)) {
							log_size = ModernizedCProgram.GetDlgItemTextU(hDlg, 1055, log_buffer, log_size);
							if (log_size != 0) {
								log_size--;
								filepath = ModernizedCProgram.FileDialog(1, ModernizedCProgram.app_dir, log_ext, 0);
								if (filepath != ((Object)0)) {
									ModernizedCProgram.FileIO(1, filepath, log_buffer, log_size);
								} 
								do {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)filepath);
									filepath = ((Object)0);
								} while (0);
							} 
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)log_buffer);
								log_buffer = ((Object)0);
							} while (0);
						} 
						break;
				}
				break;
		case user_message_type.UM_RESIZE_BUTTONS:
				ModernizedCProgram.ResizeButtonHeight(hDlg, 2);
				ModernizedCProgram.ResizeButtonHeight(hDlg, 1056);
				ModernizedCProgram.ResizeButtonHeight(hDlg, 1057);
				return 1;
		case 272:
				ModernizedCProgram.apply_localization(106, hDlg);
				ModernizedCProgram.hLog = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1055);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(ModernizedCProgram.hLog, 197, -1024, 0);
				hDC = /*Error: Function owner not recognized*/GetDC(((Object)0));
				lfHeight = -/*Error: Function owner not recognized*/MulDiv(8, /*Error: Function owner not recognized*/GetDeviceCaps(hDC, 90), 72);
				do {
					if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(((Object)0), hDC);
						hDC = ((Object)0);
					} 
				} while (0);
				hf = /*Error: Function owner not recognized*/CreateFontA(lfHeight, 0, 0, 0, 400, 0, 0, 0, 1, 0, 0, 2, 0, "Arial Unicode MS");
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendDlgItemMessageA(hDlg, 1055, 48, (WPARAM)hf, 1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hDlg, 40, (WPARAM)/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), 1);
				style = /*Error: Function owner not recognized*/GetWindowLongA(ModernizedCProgram.hLog, (true));
				style &=  ~(-1024 | -1024 | -1024);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowLongA(ModernizedCProgram.hLog, (true), style);
				style = /*Error: Function owner not recognized*/GetWindowLongA(ModernizedCProgram.hLog, (true));
				style &=  ~(true);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowLongA(ModernizedCProgram.hLog, (true), style);
				break;
		case 16:
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(hDlg, 0);
				ModernizedCProgram.reset_localization(106);
				ModernizedCProgram.log_displayed = 0;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, 40, (WPARAM)/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 2), 1);
				return 1;
		}
		return 0;
	}
	// Timer in the right part of the status area
	public static void ClockTimer(Object hWnd, Object uMsg, Object idEvent, Object dwTime) {
		ModernizedCProgram.timer++;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.szTimer, /*Error: sizeof expression not supported yet*/, "%02d:%02d:%02d", ModernizedCProgram.timer / 3600, (ModernizedCProgram.timer % 3600) / 60, ModernizedCProgram.timer % 60);
			(ModernizedCProgram.szTimer)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hStatus, (1024 + 1), -1024 | 1, (LPARAM)ModernizedCProgram.szTimer);
	}
	// Device Refresh Timer
	public static void RefreshTimer(Object hWnd, Object uMsg, Object idEvent, Object dwTime) {
		/*Error: Function owner not recognized*/// DO NOT USE WM_DEVICECHANGE - IT MAY BE FILTERED OUT BY WINDOWS!/*Error: Function owner not recognized*/// DO NOT USE WM_DEVICECHANGE - IT MAY BE FILTERED OUT BY WINDOWS!SendMessageA(hWnd, user_message_type.UM_MEDIA_CHANGE, 0, 0);
	}
	// Detect and notify about a blocking operation during ISO extraction cancellation
	public static void BlockingTimer(Object hWnd, Object uMsg, Object idEvent, Object dwTime) {
		if (ModernizedCProgram.iso_blocking_status < 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/KillTimer(ModernizedCProgram.hMainDialog, timer_type.TID_BLOCKING_TIMER);
			ModernizedCProgram.user_notified = 0;
			ModernizedCProgram._uprintf("Killed blocking I/O timer\n");
		}  else if (!ModernizedCProgram.user_notified) {
			if (ModernizedCProgram.last_iso_blocking_status == ModernizedCProgram.iso_blocking_status) {
				ModernizedCProgram.user_notified = 1;
				ModernizedCProgram._uprintf("Blocking I/O operation detected\n");
				ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3080), ModernizedCProgram.lmprintf(3048), 0 | 64 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
			} else {
					ModernizedCProgram.last_iso_blocking_status = ModernizedCProgram.iso_blocking_status;
			} 
		} 
	}
	// Report the features of the selected ISO images
	public static void DisplayISOProps() {
		byte[] inst_str = " [1/#]";
		int i;
		ModernizedCProgram._uprintf("ISO label: '%s'", ModernizedCProgram.img_report.getLabel());
		ModernizedCProgram._uprintf("  Size: %s (Projected)", ModernizedCProgram.SizeToHumanReadable(ModernizedCProgram.img_report.getProjected_size(), 0, 0));
		if (ModernizedCProgram.img_report.getMismatch_size() > 0) {
			ModernizedCProgram._uprintf("  ERROR: Detected that file on disk has been truncated by %s!", ModernizedCProgram.SizeToHumanReadable(ModernizedCProgram.img_report.getMismatch_size(), 0, 0));
			ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3298, ModernizedCProgram.SizeToHumanReadable(ModernizedCProgram.img_report.getMismatch_size(), 0, 0)), ModernizedCProgram.lmprintf(3297), -1024 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
		}  else if (ModernizedCProgram.img_report.getMismatch_size() < 0) {
			ModernizedCProgram._uprintf("  Note: File on disk is larger than reported ISO size by %s...", ModernizedCProgram.SizeToHumanReadable(-ModernizedCProgram.img_report.getMismatch_size(), 0, 0));
		} 
		do {
			if (ModernizedCProgram.img_report.getHas_4GB_file()) {
				ModernizedCProgram._uprintf("  Has a >4GB file");
			} 
		} while (0);
		do {
			if (ModernizedCProgram.img_report.getHas_long_filename()) {
				ModernizedCProgram._uprintf("  Has a >64 chars filename");
			} 
		} while (0);
		do {
			if ((ModernizedCProgram.img_report.getSl_version() != 0)) {
				ModernizedCProgram._uprintf("  Uses: Syslinux/Isolinux v%s", ModernizedCProgram.img_report.getSl_version_str());
			} 
		} while (0);
		if ((ModernizedCProgram.img_report.getSl_version() != 0) && (((uint8_t)((ModernizedCProgram.img_report.getSl_version()) >> 8)) < 5)) {
			for (i = 0; i < 2; i++) {
				do {
					if (ModernizedCProgram.img_report.getHas_old_c32()[i]) {
						ModernizedCProgram._uprintf("    With an old %s", ModernizedCProgram.old_c32_name[i]);
					} 
				} while (0);
			}
		} 
		do {
			if ((ModernizedCProgram.img_report.getHas_kolibrios())) {
				ModernizedCProgram._uprintf("  Uses: KolibriOS");
			} 
		} while (0);
		do {
			if ((ModernizedCProgram.img_report.getReactos_path()[0] != 0)) {
				ModernizedCProgram._uprintf("  Uses: ReactOS");
			} 
		} while (0);
		do {
			if (ModernizedCProgram.img_report.getHas_grub4dos()) {
				ModernizedCProgram._uprintf("  Uses: Grub4DOS");
			} 
		} while (0);
		do {
			if (ModernizedCProgram.img_report.getHas_grub2()) {
				ModernizedCProgram._uprintf("  Uses: GRUB2");
			} 
		} while (0);
		if (ModernizedCProgram.img_report.getHas_efi() == -1024) {
			ModernizedCProgram._uprintf("  Uses: EFI (through '%s')", ModernizedCProgram.img_report.getEfi_img_path());
		} else {
				do {
					if (ModernizedCProgram.img_report.getHas_efi()) {
						ModernizedCProgram._uprintf("  Uses: EFI %s", ((ModernizedCProgram.img_report.getHas_efi() == 1) && (ModernizedCProgram.img_report.getWininst_index() != 0)) ? "(win7_x64)" : "");
					} 
				} while (0);
		} 
		do {
			if (((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi()))) {
				ModernizedCProgram._uprintf("  Uses: Bootmgr (%s)", (ModernizedCProgram.img_report.getHas_bootmgr()) ? ((ModernizedCProgram.img_report.getHas_bootmgr_efi()) ? "BIOS and UEFI" : "BIOS only") : "UEFI only");
			} 
		} while (0);
		do {
			if ((((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) {
				ModernizedCProgram._uprintf("  Uses: WinPE %s", (ModernizedCProgram.img_report.getUses_minint()) ? "(with /minint)" : "");
			} 
		} while (0);
		if ((ModernizedCProgram.img_report.getWininst_index() != 0)) {
			inst_str[4] = (byte)'0' + ModernizedCProgram.img_report.getWininst_index();
			ModernizedCProgram._uprintf("  Uses: Install.%s%s (version %d.%d.%d%s)", ModernizedCProgram.img_report.getWininst_path()[0][/*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getWininst_path()[0]) - 3], (ModernizedCProgram.img_report.getWininst_index() > 1) ? inst_str : "", (ModernizedCProgram.img_report.getWininst_version() >> 24) & -1024, (ModernizedCProgram.img_report.getWininst_version() >> 16) & -1024, (ModernizedCProgram.img_report.getWininst_version() >> 8) & -1024, (ModernizedCProgram.img_report.getWininst_version() >= -1024) ? "+" : "");
		} 
		do {
			if (ModernizedCProgram.img_report.getHas_symlinks()) {
				ModernizedCProgram._uprintf("  Note: This ISO uses symbolic links, which will not be replicated due to file system limitations.");
			} 
		} while (0);
		do {
			if (ModernizedCProgram.img_report.getHas_symlinks()) {
				ModernizedCProgram._uprintf("  Because of this, some features from this image may not work...");
			} 
		} while (0);
	}
	// Insert the image name into the Boot selection dropdown
	public static void UpdateImage() {
		((ModernizedCProgram.image_index != 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("image_index != 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\rufus.c", 1075));
		if (((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 336, (WPARAM)(int)(ModernizedCProgram.image_index), 0)) == boot_type.BT_IMAGE) {
			((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 324, (WPARAM)(int)(ModernizedCProgram.image_index), 0));
		} 
		((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hBootType, 330, (WPARAM)ModernizedCProgram.image_index, (ModernizedCProgram.image_path == ((Object)0)) ? ModernizedCProgram.lmprintf(3281, ModernizedCProgram.lmprintf(3280)) : ModernizedCProgram.short_image_path));
		((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 337, (WPARAM)(int)(ModernizedCProgram.image_index), (LPARAM)(boot_type.BT_IMAGE)));
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 334, (WPARAM)(int)(ModernizedCProgram.image_index), 0)));
		} while (0);
		ModernizedCProgram.boot_type = (int)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 327, 0, 0))), 0));
		ModernizedCProgram.SetBootTypeDropdownWidth();
	}
	// The scanning process can be blocking for message processing => use a thread
	public static Object ISOScanThread(Object param) {
		int i;
		if (ModernizedCProgram.image_path == ((Object)0)) {
			;
		} 
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3202);
		ModernizedCProgram.user_notified = 0;
		ModernizedCProgram.EnableControls(0, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.img_report, 0, /*Error: sizeof expression not supported yet*/);
		ModernizedCProgram.img_report.setIs_iso((BOOLEAN)ModernizedCProgram.ExtractISO(ModernizedCProgram.image_path, "", 1));
		ModernizedCProgram.img_report.setIs_bootable_img((BOOLEAN)ModernizedCProgram.IsBootableImage(ModernizedCProgram.image_path));
		if ((ModernizedCProgram.FormatStatus == (-1024 | (3 << 16) | -1024)) || (ModernizedCProgram.img_report.getImage_size() == 0) || (!ModernizedCProgram.img_report.getIs_iso() && !ModernizedCProgram.img_report.getIs_bootable_img())) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_PROGRESS_EXIT, 0, 0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.image_path);
				ModernizedCProgram.image_path = ((Object)0);
			} while (0);
			ModernizedCProgram.UpdateImage();
			ModernizedCProgram.SetMBRProps();
			ModernizedCProgram.PopulateProperties();
			ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3203);
			ModernizedCProgram.PrintStatusInfo(0, 0, 0, 3203);
			ModernizedCProgram.EnableControls(1, 0);
			;
		} 
		if (ModernizedCProgram.img_report.getIs_bootable_img()) {
			ModernizedCProgram._uprintf("  Image is a %sbootable %s image", (ModernizedCProgram.img_report.getCompression_type() != BLED_COMPRESSION_NONE) ? "compressed " : "", ModernizedCProgram.img_report.getIs_vhd() ? "VHD" : "disk");
			ModernizedCProgram.selection_default = boot_type.BT_IMAGE;
		} 
		if (ModernizedCProgram.img_report.getIs_iso()) {
			ModernizedCProgram.DisplayISOProps();
			if ((ModernizedCProgram.img_report.getIs_bootable_img()) && (ModernizedCProgram.img_report.getDisable_iso() || (!(((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getSl_version() != 0) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024)) || ((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos())) || (ModernizedCProgram.img_report.getReactos_path()[0] != 0) || (ModernizedCProgram.img_report.getHas_kolibrios())) && !(ModernizedCProgram.img_report.getHas_efi() != 0)))) {
				ModernizedCProgram._uprintf("Note: ISO mode will be disabled because this ISOHybrid is not compatible with ISO boot.");
				ModernizedCProgram.img_report.setIs_iso(0);
			} 
			ModernizedCProgram.selection_default = boot_type.BT_IMAGE;
		} 
		if (!(ModernizedCProgram.img_report.getIs_bootable_img()) && !(((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getSl_version() != 0) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024)) || ((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos())) || (ModernizedCProgram.img_report.getReactos_path()[0] != 0) || (ModernizedCProgram.img_report.getHas_kolibrios())) && !(ModernizedCProgram.img_report.getHas_efi() != 0)) {
			ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3081);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.image_path);
				ModernizedCProgram.image_path = ((Object)0);
			} while (0);
			ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3082), ModernizedCProgram.lmprintf(3081), 0 | 64 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
			ModernizedCProgram.PrintStatusInfo(0, 0, 0, 3086);
			ModernizedCProgram.EnableControls(1, 0);
			ModernizedCProgram.SetMBRProps();
		} else {
				if (!ModernizedCProgram.dont_display_image_name) {
					for (i = (int)((((byte)ModernizedCProgram.image_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.image_path)); (i > 0) && (ModernizedCProgram.image_path[i] != (byte)'\\'); i--) {
						;
					}
					if (i != 0) {
						i++;
					} 
					ModernizedCProgram.short_image_path = ModernizedCProgram.image_path[i];
					ModernizedCProgram.PrintStatusInfo(0, 0, 0, 3205, ModernizedCProgram.short_image_path);
					ModernizedCProgram.UpdateImage();
					ModernizedCProgram._uprintf("Using image: %s (%s)", ModernizedCProgram.short_image_path, ModernizedCProgram.SizeToHumanReadable(ModernizedCProgram.img_report.getImage_size(), 0, 0));
				} 
				ModernizedCProgram.ToggleImageOptions();
				ModernizedCProgram.EnableControls(1, 0);
				if (ModernizedCProgram.img_report.getIs_iso()) {
					do {
						(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 334, (WPARAM)(int)(ModernizedCProgram.image_index), 0)));
					} while (0);
					ModernizedCProgram.SetPartitionSchemeAndTargetSystem(0);
					ModernizedCProgram.SetFileSystemAndClusterSize(((Object)0));
					ModernizedCProgram.SetFSFromISO();
					ModernizedCProgram.SetMBRProps();
					ModernizedCProgram.SetProposedLabel(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 327, 0, 0)));
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, 273, ((1 + 256) << 16) | 1002, ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 327, 0, 0)));
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, 40, (WPARAM)0, 0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, 40, (WPARAM)ModernizedCProgram.hStart, 1);
		} 
		// No boot method that we support
		/*Error: Function owner not recognized*/// Oh and we need to invoke BOTH RedrawWindow() and InvalidateRect() because UI refresh// in the Microsoft worlds SUCKS!!!! (we may lose the disabled "Start" button otherwise)/*Error: Function owner not recognized*/// Oh and we need to invoke BOTH RedrawWindow() and InvalidateRect() because UI refresh// in the Microsoft worlds SUCKS!!!! (we may lose the disabled "Start" button otherwise)RedrawWindow(ModernizedCProgram.hMainDialog, ((Object)0), ((Object)0), 128 | 256);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/InvalidateRect(ModernizedCProgram.hMainDialog, ((Object)0), 1);
		ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3210);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExitThread(0);
	}
	// Likewise, boot check will block message processing => use a thread
	public static Object BootCheckThread(Object param) {
		int i;
		int r;
		FILE fd = new FILE();
		DWORD len = new DWORD();
		WPARAM ret = -1;
		BOOL in_files_dir = 0;
		byte grub = "grub";
		byte core_img = "core.img";
		byte ldlinux = "ldlinux";
		byte syslinux = "syslinux";
		byte[] ldlinux_ext = new byte[]{"sys", "bss", "c32"};
		byte[] tmp = new byte[260];
		byte[] tmp2 = new byte[260];
		ModernizedCProgram.syslinux_ldlinux_len[0] = 0;
		ModernizedCProgram.syslinux_ldlinux_len[1] = 0;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.grub2_buf);
			ModernizedCProgram.grub2_buf = ((Object)0);
		} while (0);
		if (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 327, 0, 0)) == (true)) {
			;
		} 
		if ((ModernizedCProgram.zero_drive) || (ModernizedCProgram.boot_type == boot_type.BT_NON_BOOTABLE)) {
			ret = 0;
			;
		} 
		// Nothing to check
		if (ModernizedCProgram.boot_type == boot_type.BT_IMAGE) {
			((ModernizedCProgram.image_path != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("image_path != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\rufus.c", 1209));
			if (ModernizedCProgram.image_path == ((Object)0)) {
				;
			} 
			if ((ModernizedCProgram.size_check) && (ModernizedCProgram.img_report.getProjected_size() > (uint64_t)ModernizedCProgram.SelectedDrive.getDiskSize())) {
				ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3089), ModernizedCProgram.lmprintf(3088), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
				;
			} 
			if ((ModernizedCProgram.img_report.getIs_bootable_img()) && !ModernizedCProgram.img_report.getIs_iso()) {
				ret = 0;
				;
			} 
			if ((ModernizedCProgram.image_options & -1024) && (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1026)), 327, 0, 0)) == 1)) {
				if (ModernizedCProgram.fs_type != fs_type.FS_NTFS) {
					ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3097, "Windows To Go"), ModernizedCProgram.lmprintf(3092), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
					;
				} 
				if (ModernizedCProgram.SelectedDrive.getMediaType() != _MEDIA_TYPE.FixedMedia) {
					if ((ModernizedCProgram.target_type == target_type.TT_UEFI) && (ModernizedCProgram.partition_type == _PARTITION_STYLE.PARTITION_STYLE_GPT) && (ModernizedCProgram.nWindowsBuildNumber < 15000)) {
						ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3198), ModernizedCProgram.lmprintf(3190), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
						;
					} 
				} 
				switch (ModernizedCProgram.SetWinToGoIndex()) {
				case -2:
						;
				case -1:
						ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3073), ModernizedCProgram.lmprintf(3291), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
				default:
						break;
				}
			}  else if (ModernizedCProgram.target_type == target_type.TT_UEFI) {
				if (!(ModernizedCProgram.img_report.getHas_efi() != 0)) {
					ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3091), ModernizedCProgram.lmprintf(3090), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
					;
				} 
				if (((ModernizedCProgram.img_report.getHas_efi() == 1) && (ModernizedCProgram.img_report.getWininst_index() != 0)) && (!ModernizedCProgram.WimExtractCheck())) {
					if (ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3102), ModernizedCProgram.lmprintf(3101), 4 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid) == 6) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShellExecuteA(ModernizedCProgram.hMainDialog, "open", "https://www.7-zip.org", ((Object)0), ((Object)0), 1);
					} 
					;
				} 
			}  else if (((ModernizedCProgram.fs_type == fs_type.FS_NTFS) && !(((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getUses_minint()) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) && !((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos())) && (!(ModernizedCProgram.img_report.getSl_version() != 0) || (((uint8_t)((ModernizedCProgram.img_report.getSl_version()) >> 8)) <= 5))) || ((((ModernizedCProgram.fs_type == fs_type.FS_FAT16) || (ModernizedCProgram.fs_type == fs_type.FS_FAT32))) && (!(ModernizedCProgram.img_report.getSl_version() != 0)) && (!ModernizedCProgram.allow_dual_uefi_bios) && !(ModernizedCProgram.img_report.getHas_efi() != 0) && (!(ModernizedCProgram.img_report.getReactos_path()[0] != 0)) && !(ModernizedCProgram.img_report.getHas_kolibrios()) && (!((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos())))) || ((((ModernizedCProgram.fs_type == fs_type.FS_FAT16) || (ModernizedCProgram.fs_type == fs_type.FS_FAT32))) && ((((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getUses_minint()) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) || (ModernizedCProgram.img_report.getWininst_index() != 0)) && (!ModernizedCProgram.allow_dual_uefi_bios))) {
				ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3096), ModernizedCProgram.lmprintf(3092), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
				;
			}  else if ((ModernizedCProgram.fs_type == fs_type.FS_FAT16) && (ModernizedCProgram.img_report.getHas_kolibrios())) {
				ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3189), ModernizedCProgram.lmprintf(3099), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
				;
			} 
			if ((((ModernizedCProgram.fs_type == fs_type.FS_FAT16) || (ModernizedCProgram.fs_type == fs_type.FS_FAT32))) && (ModernizedCProgram.img_report.getHas_4GB_file())) {
				ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3100), ModernizedCProgram.lmprintf(3099), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
				;
			} 
			if (ModernizedCProgram.target_type != target_type.TT_BIOS) {
				;
			} 
			if ((ModernizedCProgram.partition_type == _PARTITION_STYLE.PARTITION_STYLE_MBR) && (ModernizedCProgram.img_report.getHas_grub2()) && (ModernizedCProgram.img_report.getGrub2_version()[0] != 0) && (/*Error: Function owner not recognized*/strcmp(ModernizedCProgram.img_report.getGrub2_version(), GRUB2_PACKAGE_VERSION) != 0)) {
				do {
					(Object)(ModernizedCProgram._chdirU(ModernizedCProgram.app_dir));
				} while (0);
				do {
					(Object)(/*Error: Function owner not recognized*/_mkdir("rufus_files"));
				} while (0);
				do {
					(Object)(/*Error: Function owner not recognized*/_chdir("rufus_files"));
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s-%s/%s", grub, ModernizedCProgram.img_report.getGrub2_version(), core_img);
					(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				fd = /*Error: Function owner not recognized*/fopen(tmp, "rb");
				if (fd != ((Object)0)) {
					ModernizedCProgram._uprintf("Will reuse '%s' from './rufus_files/%s-%s/' for Grub 2.x installation", core_img, grub, ModernizedCProgram.img_report.getGrub2_version());
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fseek(fd, 0, 2);
					ModernizedCProgram.grub2_len = /*Error: Function owner not recognized*/ftell(fd);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fseek(fd, 0, 0);
					if (ModernizedCProgram.grub2_len > 0) {
						ModernizedCProgram.grub2_buf = /*Error: Function owner not recognized*/malloc(ModernizedCProgram.grub2_len);
					} 
					if ((ModernizedCProgram.grub2_buf == ((Object)0)) || (/*Error: Function owner not recognized*/fread(ModernizedCProgram.grub2_buf, 1, (size_t)ModernizedCProgram.grub2_len, fd) != (size_t)ModernizedCProgram.grub2_len)) {
						ModernizedCProgram._uprintf("Failed to read existing '%s' data - will use embedded version", core_img);
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.grub2_buf);
							ModernizedCProgram.grub2_buf = ((Object)0);
						} while (0);
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
				} else {
						r = ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3116, ModernizedCProgram.img_report.getGrub2_version(), GRUB2_PACKAGE_VERSION), ModernizedCProgram.lmprintf(3115), 3 | -1024 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
						if (r == 2) {
							;
						}  else if (r == 6) {
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s-%s", grub, ModernizedCProgram.img_report.getGrub2_version());
								(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
							} while (0);
							do {
								(Object)(/*Error: Function owner not recognized*/_mkdir(tmp));
							} while (0);
							do {
								(Object)(/*Error: Function owner not recognized*/_chdir(tmp));
							} while (0);
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s/%s-%s/%s", "https://rufus.ie/files", grub, ModernizedCProgram.img_report.getGrub2_version(), core_img);
								(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
							} while (0);
							ModernizedCProgram.grub2_len = (long)ModernizedCProgram.DownloadSignedFile(tmp, core_img, ModernizedCProgram.hMainDialog, 0);
							if ((ModernizedCProgram.grub2_len == 0) && (ModernizedCProgram.DownloadStatus == 404)) {
								BOOL first_dot = 1;
								ModernizedCProgram._uprintf("Extended version was not found, trying main version...");
								do {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(tmp2, ModernizedCProgram.img_report.getGrub2_version(), (((size_t)(((((byte)ModernizedCProgram.img_report.getGrub2_version()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getGrub2_version())) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.img_report.getGrub2_version()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getGrub2_version())) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
									((byte)tmp2)[(((size_t)(((((byte)ModernizedCProgram.img_report.getGrub2_version()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getGrub2_version())) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.img_report.getGrub2_version()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getGrub2_version())) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
								} while (0);
								for (i = 0; ((tmp2[i] >= (byte)'0') && (tmp2[i] <= (byte)'9')) || ((tmp2[i] == (byte)'.') && first_dot); i++) {
									if (tmp2[i] == (byte)'.') {
										first_dot = 0;
									} 
								}
								tmp2[i] = 0;
								do {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s/%s-%s/%s", "https://rufus.ie/files", grub, tmp2, core_img);
									(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
								} while (0);
								ModernizedCProgram.grub2_len = (long)ModernizedCProgram.DownloadSignedFile(tmp, core_img, ModernizedCProgram.hMainDialog, 0);
								do {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s/%s-%s/%s", "https://rufus.ie/files", grub, ModernizedCProgram.img_report.getGrub2_version(), core_img);
									(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
								} while (0);
							} 
							if (ModernizedCProgram.grub2_len <= 0) {
								ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3195, "Grub2");
								ModernizedCProgram._uprintf("%s was not found - will use embedded version", tmp);
							} else {
									ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3193, tmp);
									fd = /*Error: Function owner not recognized*/fopen(core_img, "rb");
									ModernizedCProgram.grub2_buf = /*Error: Function owner not recognized*/malloc(ModernizedCProgram.grub2_len);
									if ((fd == ((Object)0)) || (ModernizedCProgram.grub2_buf == ((Object)0)) || (/*Error: Function owner not recognized*/fread(ModernizedCProgram.grub2_buf, 1, (size_t)ModernizedCProgram.grub2_len, fd) != (size_t)ModernizedCProgram.grub2_len)) {
										ModernizedCProgram._uprintf("Failed to read '%s' data - will use embedded version", core_img);
										do {
											/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.grub2_buf);
											ModernizedCProgram.grub2_buf = ((Object)0);
										} while (0);
									} 
									if (fd != ((Object)0)) {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
									} 
							} 
						} 
				} 
			} 
			if ((ModernizedCProgram.partition_type == _PARTITION_STYLE.PARTITION_STYLE_MBR) && (ModernizedCProgram.img_report.getSl_version() != 0)) {
				if (((uint8_t)((ModernizedCProgram.img_report.getSl_version()) >> 8)) < 5) {
					do {
						(Object)(ModernizedCProgram._chdirU(ModernizedCProgram.app_dir));
					} while (0);
					for (i = 0; i < 2; i++) {
						if (ModernizedCProgram.img_report.getHas_old_c32()[i]) {
							if (!in_files_dir) {
								do {
									(Object)(/*Error: Function owner not recognized*/_mkdir("rufus_files"));
								} while (0);
								do {
									(Object)(/*Error: Function owner not recognized*/_chdir("rufus_files"));
								} while (0);
								in_files_dir = 1;
							} 
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s-%s/%s", syslinux, ModernizedCProgram.embedded_sl_version_str[0], ModernizedCProgram.old_c32_name[i]);
								(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
							} while (0);
							fd = /*Error: Function owner not recognized*/fopen(tmp, "rb");
							if (fd != ((Object)0)) {
								ModernizedCProgram._uprintf("Will replace obsolete '%s' from ISO with the one found in './rufus_files/%s'", ModernizedCProgram.old_c32_name[i], tmp);
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
								ModernizedCProgram.use_own_c32[i] = 1;
							} else {
									ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3204, ModernizedCProgram.old_c32_name[i]);
									if (ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3084, ModernizedCProgram.old_c32_name[i], ModernizedCProgram.old_c32_name[i]), ModernizedCProgram.lmprintf(3083, ModernizedCProgram.old_c32_name[i]), 4 | -1024 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid) == 6) {
										do {
											/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s-%s", syslinux, ModernizedCProgram.embedded_sl_version_str[0]);
											(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
										} while (0);
										do {
											(Object)(/*Error: Function owner not recognized*/_mkdir(tmp));
										} while (0);
										do {
											/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s/%s-%s/%s", "https://rufus.ie/files", syslinux, ModernizedCProgram.embedded_sl_version_str[0], ModernizedCProgram.old_c32_name[i]);
											(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
										} while (0);
										len = ModernizedCProgram.DownloadSignedFile(tmp, tmp[/*Error: sizeof expression not supported yet*/], ModernizedCProgram.hMainDialog, 1);
										if (len == 0) {
											ModernizedCProgram._uprintf("Could not download file - cancelling");
											;
										} 
										ModernizedCProgram.use_own_c32[i] = 1;
									} 
							} 
						} 
					}
				}  else if ((ModernizedCProgram.img_report.getSl_version() != ModernizedCProgram.embedded_sl_version[1]) || (/*Error: Function owner not recognized*/strcmp(((ModernizedCProgram.img_report.getSl_version_ext() == ((Object)0)) ? "<NULL>" : ModernizedCProgram.img_report.getSl_version_ext()), ((ModernizedCProgram.embedded_sl_version_ext[1] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.embedded_sl_version_ext[1])) != 0)) {
					do {
						(Object)(ModernizedCProgram._chdirU(ModernizedCProgram.app_dir));
					} while (0);
					do {
						(Object)(/*Error: Function owner not recognized*/_mkdir("rufus_files"));
					} while (0);
					do {
						(Object)(/*Error: Function owner not recognized*/_chdir("rufus_files"));
					} while (0);
					for (i = 0; i < 2; i++) {
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s-%s%s/%s.%s", syslinux, ModernizedCProgram.img_report.getSl_version_str(), ModernizedCProgram.img_report.getSl_version_ext(), ldlinux, ldlinux_ext[i]);
							(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
						} while (0);
						fd = /*Error: Function owner not recognized*/fopen(tmp, "rb");
						if (fd != ((Object)0)) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fseek(fd, 0, 2);
							ModernizedCProgram.syslinux_ldlinux_len[i] = (DWORD)/*Error: Function owner not recognized*/ftell(fd);
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
						} 
					}
					if ((ModernizedCProgram.syslinux_ldlinux_len[0] != 0) && (ModernizedCProgram.syslinux_ldlinux_len[1] != 0)) {
						ModernizedCProgram._uprintf("Will reuse '%s.%s' and '%s.%s' from './rufus_files/%s/%s-%s%s/' for Syslinux installation", ldlinux, ldlinux_ext[0], ldlinux, ldlinux_ext[1], "rufus_files", syslinux, ModernizedCProgram.img_report.getSl_version_str(), ModernizedCProgram.img_report.getSl_version_ext());
					} else {
							r = ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3114, ModernizedCProgram.img_report.getSl_version_str(), ModernizedCProgram.img_report.getSl_version_ext(), ModernizedCProgram.embedded_sl_version_str[1], ModernizedCProgram.embedded_sl_version_ext[1]), ModernizedCProgram.lmprintf(3115), 4 | -1024 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
							if (r != 6) {
								;
							} 
							for (i = 0; i < 2; i++) {
								do {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s-%s", syslinux, ModernizedCProgram.img_report.getSl_version_str());
									(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
								} while (0);
								do {
									(Object)(/*Error: Function owner not recognized*/_mkdir(tmp));
								} while (0);
								if (ModernizedCProgram.img_report.getSl_version_ext() != 0) {
									do {
										(Object)(/*Error: Function owner not recognized*/_chdir(tmp));
									} while (0);
									do {
										(Object)(/*Error: Function owner not recognized*/_mkdir(ModernizedCProgram.img_report.getSl_version_ext()[1]));
									} while (0);
									do {
										(Object)(/*Error: Function owner not recognized*/_chdir(".."));
									} while (0);
								} 
								do {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s/%s-%s%s/%s.%s", "https://rufus.ie/files", syslinux, ModernizedCProgram.img_report.getSl_version_str(), ModernizedCProgram.img_report.getSl_version_ext(), ldlinux, ldlinux_ext[i]);
									(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
								} while (0);
								ModernizedCProgram.syslinux_ldlinux_len[i] = ModernizedCProgram.DownloadSignedFile(tmp, tmp[/*Error: sizeof expression not supported yet*/], ModernizedCProgram.hMainDialog, (ModernizedCProgram.img_report.getSl_version_ext() == 0));
								if ((ModernizedCProgram.syslinux_ldlinux_len[i] == 0) && (ModernizedCProgram.DownloadStatus == 404) && (ModernizedCProgram.img_report.getSl_version_ext() != 0)) {
									ModernizedCProgram._uprintf("Extended version was not found, trying main version...");
									do {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s/%s-%s/%s.%s", "https://rufus.ie/files", syslinux, ModernizedCProgram.img_report.getSl_version_str(), ldlinux, ldlinux_ext[i]);
										(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
									} while (0);
									ModernizedCProgram.syslinux_ldlinux_len[i] = ModernizedCProgram.DownloadSignedFile(tmp, tmp[/*Error: sizeof expression not supported yet*/], ModernizedCProgram.hMainDialog, (ModernizedCProgram.img_report.getSl_version_ext() == 0));
									if (ModernizedCProgram.syslinux_ldlinux_len[i] != 0) {
										do {
											/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s-%s\\%s.%s", syslinux, ModernizedCProgram.img_report.getSl_version_str(), ldlinux, ldlinux_ext[i]);
											(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
										} while (0);
										do {
											/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp2, /*Error: sizeof expression not supported yet*/, "%s-%s\\%s\\%s.%s", syslinux, ModernizedCProgram.img_report.getSl_version_str(), ModernizedCProgram.img_report.getSl_version_ext()[1], ldlinux, ldlinux_ext[i]);
											(tmp2)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
										} while (0);
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CopyFileA(tmp, tmp2, 0);
									} 
								} 
								if (ModernizedCProgram.syslinux_ldlinux_len[i] == 0) {
									if (ModernizedCProgram.img_report.getSl_version() == ModernizedCProgram.embedded_sl_version[1]) {
										ModernizedCProgram._uprintf("Could not download the file - will try to use embedded %s version instead", ModernizedCProgram.img_report.getSl_version_str());
									} else {
											ModernizedCProgram._uprintf("Could not download the file - cancelling");
											;
									} 
								} 
							}
					} 
				} 
			} 
		}  else if (ModernizedCProgram.boot_type == boot_type.BT_SYSLINUX_V6) {
			do {
				(Object)(ModernizedCProgram._chdirU(ModernizedCProgram.app_dir));
			} while (0);
			do {
				(Object)(/*Error: Function owner not recognized*/_mkdir("rufus_files"));
			} while (0);
			do {
				(Object)(/*Error: Function owner not recognized*/_chdir("rufus_files"));
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s-%s/%s.%s", syslinux, ModernizedCProgram.embedded_sl_version_str[1], ldlinux, ldlinux_ext[2]);
				(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			fd = ModernizedCProgram.fopenU(tmp, "rb");
			if (fd != ((Object)0)) {
				ModernizedCProgram._uprintf("Will reuse './%s/%s' for Syslinux installation", "rufus_files", tmp);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
			} else {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s.%s", ldlinux, ldlinux_ext[2]);
						(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
					ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3206, tmp);
					r = ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3104, "Syslinux v5.0", tmp, "Syslinux v5+", tmp), ModernizedCProgram.lmprintf(3103, tmp), 3 | -1024 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
					if (r == 2) {
						;
					} 
					if (r == 6) {
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s-%s", syslinux, ModernizedCProgram.embedded_sl_version_str[1]);
							(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
						} while (0);
						do {
							(Object)(/*Error: Function owner not recognized*/_mkdir(tmp));
						} while (0);
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s/%s-%s/%s.%s", "https://rufus.ie/files", syslinux, ModernizedCProgram.embedded_sl_version_str[1], ldlinux, ldlinux_ext[2]);
							(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
						} while (0);
						if (ModernizedCProgram.DownloadSignedFile(tmp, tmp[/*Error: sizeof expression not supported yet*/], ModernizedCProgram.hMainDialog, 1) == 0) {
							;
						} 
					} 
			} 
		}  else if (ModernizedCProgram.boot_type == boot_type.BT_MSDOS) {
			if ((ModernizedCProgram.size_check) && (((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hClusterSize), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hClusterSize), 327, 0, 0))), 0)) >= 65536)) {
				ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3110), ModernizedCProgram.lmprintf(3111), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
				;
			} 
		}  else if (ModernizedCProgram.boot_type == boot_type.BT_GRUB4DOS) {
			do {
				(Object)(ModernizedCProgram._chdirU(ModernizedCProgram.app_dir));
			} while (0);
			do {
				(Object)(/*Error: Function owner not recognized*/_mkdir("rufus_files"));
			} while (0);
			do {
				(Object)(/*Error: Function owner not recognized*/_chdir("rufus_files"));
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "grub4dos-%s/grldr", GRUB4DOS_VERSION);
				(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			fd = ModernizedCProgram.fopenU(tmp, "rb");
			if (fd != ((Object)0)) {
				ModernizedCProgram._uprintf("Will reuse './%s/%s' for Grub4DOS installation", "rufus_files", tmp);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
			} else {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "grldr");
						(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
					ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3206, tmp);
					r = ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3104, "Grub4DOS 0.4", tmp, "Grub4DOS", tmp), ModernizedCProgram.lmprintf(3103, tmp), 3 | -1024 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
					if (r == 2) {
						;
					} 
					if (r == 6) {
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "grub4dos-%s", GRUB4DOS_VERSION);
							(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
						} while (0);
						do {
							(Object)(/*Error: Function owner not recognized*/_mkdir(tmp));
						} while (0);
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s/grub4dos-%s/grldr", "https://rufus.ie/files", GRUB4DOS_VERSION);
							(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
						} while (0);
						if (ModernizedCProgram.DownloadSignedFile(tmp, tmp[/*Error: sizeof expression not supported yet*/], ModernizedCProgram.hMainDialog, 1) == 0) {
							;
						} 
					} 
			} 
		} 
		ret = 0;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExitThread((DWORD)ret);
	}
	public static Object IsAlphaOrBeta() {
		return " ";
	}
	public static void InitDialog(Object hDlg) {
		DWORD len = new DWORD();
		HWND hCtrl = new HWND();
		HDC hDC = new HDC();
		int i;
		int lfHeight;
		byte[] tmp = new byte[128];
		byte token;
		byte buf;
		byte ext;
		byte msg;
		byte[] resource = new byte[]{(LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)(true)))};
		hDC = /*Error: Function owner not recognized*/GetDC(hDlg);
		lfHeight = -/*Error: Function owner not recognized*/MulDiv(9, /*Error: Function owner not recognized*/GetDeviceCaps(hDC, 90), 72);
		do {
			if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(hDlg, hDC);
				hDC = ((Object)0);
			} 
		} while (0);
		// Quite a burden to carry around as parameters// Quite a burden to carry around as parametersModernizedCProgram.hMainDialog = hDlg;
		ModernizedCProgram.MainThreadId = /*Error: Function owner not recognized*/GetCurrentThreadId();
		ModernizedCProgram.hDeviceList = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1001);
		ModernizedCProgram.hPartitionScheme = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1004);
		ModernizedCProgram.hTargetSystem = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1017);
		ModernizedCProgram.hFileSystem = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1002);
		ModernizedCProgram.hClusterSize = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1005);
		ModernizedCProgram.hLabel = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1007);
		ModernizedCProgram.hProgress = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1010);
		ModernizedCProgram.hBootType = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1011);
		ModernizedCProgram.hSelectImage = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1014);
		ModernizedCProgram.hNBPasses = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1012);
		ModernizedCProgram.hDiskID = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1020);
		ModernizedCProgram.hStart = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1003);
		// Convert the main button labels to uppercase// Convert the main button labels to uppercaseModernizedCProgram.GetWindowTextU(ModernizedCProgram.hStart, ModernizedCProgram.uppercase_start, /*Error: sizeof expression not supported yet*/);
		ModernizedCProgram.CharUpperBuffU(ModernizedCProgram.uppercase_start, /*Error: sizeof expression not supported yet*/);
		ModernizedCProgram.SetWindowTextU(ModernizedCProgram.hStart, ModernizedCProgram.uppercase_start);
		ModernizedCProgram.GetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), ModernizedCProgram.uppercase_close, /*Error: sizeof expression not supported yet*/);
		ModernizedCProgram.CharUpperBuffU(ModernizedCProgram.uppercase_close, /*Error: sizeof expression not supported yet*/)// Hardcoded exception for German;// Hardcoded exception for German
		if (/*Error: Function owner not recognized*/strcmp("SCHLIEÃEN", ModernizedCProgram.uppercase_close) == 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(ModernizedCProgram.uppercase_close, "SCHLIESSEN");
		} 
		ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), ModernizedCProgram.uppercase_close);
		ModernizedCProgram.GetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1014), ModernizedCProgram.uppercase_select[0], /*Error: sizeof expression not supported yet*/);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.uppercase_select[1], ModernizedCProgram.lmprintf(3040), (((size_t)(((((byte)ModernizedCProgram.lmprintf(3040)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3040))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.lmprintf(3040)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3040))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)ModernizedCProgram.uppercase_select[1])[(((size_t)(((((byte)ModernizedCProgram.lmprintf(3040)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3040))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.lmprintf(3040)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3040))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);
		ModernizedCProgram.CharUpperBuffU(ModernizedCProgram.uppercase_select[0], /*Error: sizeof expression not supported yet*/);
		ModernizedCProgram.CharUpperBuffU(ModernizedCProgram.uppercase_select[1], /*Error: sizeof expression not supported yet*/);
		ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1014), ModernizedCProgram.uppercase_select[0]);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.uppercase_cancel, ModernizedCProgram.lmprintf(3007), (((size_t)(((((byte)ModernizedCProgram.lmprintf(3007)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3007))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.lmprintf(3007)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3007))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)ModernizedCProgram.uppercase_cancel)[(((size_t)(((((byte)ModernizedCProgram.lmprintf(3007)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3007))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.lmprintf(3007)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3007))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);
		ModernizedCProgram.CharUpperBuffU(ModernizedCProgram.uppercase_cancel, /*Error: sizeof expression not supported yet*/);
		ModernizedCProgram.CreateSmallButtons(hDlg);
		ModernizedCProgram.GetBasicControlsWidth(hDlg);
		ModernizedCProgram.GetMainButtonsWidth(hDlg);
		ModernizedCProgram.GetHalfDropwdownWidth(hDlg);
		ModernizedCProgram.GetFullWidth(hDlg);
		// Create the font and brush for the progress messages// Create the font and brush for the progress messagesModernizedCProgram.hInfoFont = /*Error: Function owner not recognized*/CreateFontA(lfHeight, 0, 0, 0, 400, 0, 0, 0, 1, 0, 0, 2, 0, "Segoe UI");
		// Create the title bar icon// Create the title bar iconModernizedCProgram.SetTitleBarIcon(hDlg);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowTextA(hDlg, tmp, /*Error: sizeof expression not supported yet*/)// Count on Microsoft for making it more attractive to read a;// Count on Microsoft for making it more attractive to read a
		// version using strtok() than using GetFileVersionInfo()// version using strtok() than using GetFileVersionInfo()token = /*Error: Function owner not recognized*/strtok(tmp, " ");
		for (i = 0; (i < 3) && ((token = /*Error: Function owner not recognized*/strtok(((Object)0), ".")) != ((Object)0)); i++) {
			ModernizedCProgram.rufus_version[i] = (uint16_t)/*Error: Function owner not recognized*/atoi(token);
		}
		// Redefine the title to be able to add "Alpha" or "Beta"do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "Rufus %d.%d.%d%s%s", ModernizedCProgram.rufus_version[0], ModernizedCProgram.rufus_version[1], ModernizedCProgram.rufus_version[2], ModernizedCProgram.IsAlphaOrBeta(), (ModernizedCProgram.ini_file != ((Object)0)) ? "(Portable)" : "");
			(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		ModernizedCProgram.SetWindowTextU(hDlg, tmp)// Now that we have a title, we can find the handle of our Dialog;// Now that we have a title, we can find the handle of our Dialog
		ModernizedCProgram.dialog_handle = /*Error: Function owner not recognized*/FindWindowA(((Object)0), tmp);
		ModernizedCProgram._uprintf("Rufus x86 v%d.%d.%d%s%s", ModernizedCProgram.rufus_version[0], ModernizedCProgram.rufus_version[1], ModernizedCProgram.rufus_version[2], ModernizedCProgram.IsAlphaOrBeta(), (ModernizedCProgram.ini_file != ((Object)0)) ? "(Portable)" : "");
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			buf = (byte)ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, resource[i], (LPSTR)((DWORD)((WORD)(true))), "ldlinux_sys", len, 1);
			if (buf == ((Object)0)) {
				ModernizedCProgram._uprintf("Warning: could not read embedded Syslinux v%d version", i + 4);
			} else {
					ModernizedCProgram.embedded_sl_version[i] = ModernizedCProgram.GetSyslinuxVersion(buf, len, ext);
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.embedded_sl_version_str[i], /*Error: sizeof expression not supported yet*/, "%d.%02d", ((uint8_t)((ModernizedCProgram.embedded_sl_version[i]) >> 8)), ((uint8_t)(ModernizedCProgram.embedded_sl_version[i])));
						(ModernizedCProgram.embedded_sl_version_str[i])[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.embedded_sl_version_ext[i], ext, (((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
						((byte)ModernizedCProgram.embedded_sl_version_ext[i])[(((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
					} while (0);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buf);
			} 
		}
		ModernizedCProgram._uprintf("Windows version: %s", ModernizedCProgram.WindowsVersionStr);
		ModernizedCProgram._uprintf("Syslinux versions: %s%s, %s%s", ModernizedCProgram.embedded_sl_version_str[0], ModernizedCProgram.embedded_sl_version_ext[0], ModernizedCProgram.embedded_sl_version_str[1], ModernizedCProgram.embedded_sl_version_ext[1]);
		ModernizedCProgram._uprintf("Grub versions: %s, %s", GRUB4DOS_VERSION, GRUB2_PACKAGE_VERSION);
		ModernizedCProgram._uprintf("System locale ID: 0x%04X (%s)", /*Error: Function owner not recognized*/GetUserDefaultUILanguage(), ModernizedCProgram.GetCurrentMUI());
		do {
			if (ModernizedCProgram.ubuffer_pos) {
				ModernizedCProgram._uprintf("%s", ModernizedCProgram.ubuffer);
			} 
			ModernizedCProgram.ubuffer_pos = 0;
		} while (0);
		if (ModernizedCProgram.selected_locale.getCtrl_id() & -1024) {
			ModernizedCProgram._uprintf("NOTE: The %s translation requires an update, but the current translator hasn't submitted one. Because of this, some messages will only be displayed in English.", ModernizedCProgram.selected_locale.getTxt()[1]);
			ModernizedCProgram._uprintf("If you think you can help update this translation, please e-mail the author of this application");
		} 
		ModernizedCProgram.CreateTaskbarList();
		ModernizedCProgram.SetTaskbarProgressState(TASKBAR_PROGRESS_FLAGS.TASKBAR_NORMAL);
		/*Error: Function owner not recognized*/// Use maximum granularity for the progress bar/*Error: Function owner not recognized*/// Use maximum granularity for the progress barSendMessageA(ModernizedCProgram.hProgress, (1024 + 1), 0, (-1024 << 16) & -1024);
		// Fill up the passesfor (i = 1; i <= 5; i++) {
			msg = (i == 1) ? ModernizedCProgram.lmprintf(3034, 1) : ModernizedCProgram.lmprintf(3035, (i == 2) ? 2 : 4, (i == 2) ? "" : ModernizedCProgram.lmprintf(3087, ModernizedCProgram.flash_type[i - 3]));
			do {
				(Object)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hNBPasses, 323, (WPARAM)0, msg)));
			} while (0);
		}
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hNBPasses), 334, (WPARAM)(int)(false), 0)));
		} while (0);
		ModernizedCProgram.SetPassesTooltip();
		// Fill up the boot options dropdown// Fill up the boot options dropdownModernizedCProgram.SetBootOptions();
		// Fill up the Image Options Windows To Go dropdown// Fill up the Image Options Windows To Go dropdownhCtrl = /*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1026);
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hCtrl), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(hCtrl, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3117)))), (LPARAM)(false))));
		} while (0);
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hCtrl), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(hCtrl, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3118)))), (LPARAM)(true))));
		} while (0);
		// Fill up the MBR masqueraded disk IDs ("8 disks should be enough for anybody")do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDiskID), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hDiskID, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3030, "âª0x80â¬")))), (LPARAM)(true))));
		} while (0);
		for (i = 1; i <= 7; i++) {
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDiskID), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hDiskID, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3109, -1024 + i, i + 1)))), (LPARAM)(-1024 + i))));
			} while (0);
		}
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDiskID), 334, (WPARAM)(int)(false), 0)));
		} while (0);
		// Create the string arrays// Create the string arraysModernizedCProgram.DriveId.StrArrayCreate((-1024 - -1024));
		ModernizedCProgram.DriveName.StrArrayCreate((-1024 - -1024));
		ModernizedCProgram.DriveLabel.StrArrayCreate((-1024 - -1024));
		ModernizedCProgram.DriveHub.StrArrayCreate((-1024 - -1024));
		ModernizedCProgram.BlockingProcess.StrArrayCreate(16);
		ModernizedCProgram.ImageList.StrArrayCreate(16)// Set various checkboxes;// Set various checkboxes
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(hDlg, 1008, 1);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(hDlg, 1015, 1);
		ModernizedCProgram.CreateAdditionalControls(hDlg);
		ModernizedCProgram.SetSectionHeaders(hDlg);
		ModernizedCProgram.PositionMainControls(hDlg);
		ModernizedCProgram.AdjustForLowDPI(hDlg)// Because we created the log dialog before we computed our sizes, we need to send a custom message;// Because we created the log dialog before we computed our sizes, we need to send a custom message
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hLogDialog, user_message_type.UM_RESIZE_BUTTONS, 0, 0)// Limit the amount of characters for the Persistence size field;// Limit the amount of characters for the Persistence size field
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1018), 197, 7, 0)// Create the status line and initialize the taskbar icon for progress overlay;// Create the status line and initialize the taskbar icon for progress overlay
		ModernizedCProgram.CreateStatusBar();
		// Set the various tooltips// Set the various tooltipsModernizedCProgram.CreateTooltip(ModernizedCProgram.hFileSystem, ModernizedCProgram.lmprintf(3157), -1);
		ModernizedCProgram.CreateTooltip(ModernizedCProgram.hClusterSize, ModernizedCProgram.lmprintf(3158), -1);
		ModernizedCProgram.CreateTooltip(ModernizedCProgram.hLabel, ModernizedCProgram.lmprintf(3159), -1);
		ModernizedCProgram.CreateTooltip(ModernizedCProgram.hAdvancedDeviceToolbar, ModernizedCProgram.lmprintf(3160), -1);
		ModernizedCProgram.CreateTooltip(ModernizedCProgram.hAdvancedFormatToolbar, ModernizedCProgram.lmprintf(3160), -1);
		ModernizedCProgram.CreateTooltip(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1009), ModernizedCProgram.lmprintf(3161), -1);
		ModernizedCProgram.CreateTooltip(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1008), ModernizedCProgram.lmprintf(3162), -1);
		ModernizedCProgram.CreateTooltip(ModernizedCProgram.hBootType, ModernizedCProgram.lmprintf(3164), -1);
		ModernizedCProgram.CreateTooltip(ModernizedCProgram.hSelectImage, ModernizedCProgram.lmprintf(3165), -1);
		ModernizedCProgram.CreateTooltip(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1015), ModernizedCProgram.lmprintf(3166), 10000);
		ModernizedCProgram.CreateTooltip(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1016), ModernizedCProgram.lmprintf(3167), 10000);
		ModernizedCProgram.CreateTooltip(ModernizedCProgram.hDiskID, ModernizedCProgram.lmprintf(3168), 10000);
		ModernizedCProgram.CreateTooltip(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1021), ModernizedCProgram.lmprintf(3169), -1);
		ModernizedCProgram.CreateTooltip(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1022), ModernizedCProgram.lmprintf(3170), -1);
		ModernizedCProgram.CreateTooltip(ModernizedCProgram.hStart, ModernizedCProgram.lmprintf(3171), -1);
		ModernizedCProgram.CreateTooltip(ModernizedCProgram.hPartitionScheme, ModernizedCProgram.lmprintf(3163), -1);
		ModernizedCProgram.CreateTooltip(ModernizedCProgram.hTargetSystem, ModernizedCProgram.lmprintf(3150), 30000);
		ModernizedCProgram.CreateTooltip(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2005), ModernizedCProgram.lmprintf(3151), 30000);
		ModernizedCProgram.CreateTooltip(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1026), ModernizedCProgram.lmprintf(3305), 30000);
		ModernizedCProgram.CreateTooltip(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1027), ModernizedCProgram.lmprintf(3125), 30000);
		ModernizedCProgram.CreateTooltip(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1018), ModernizedCProgram.lmprintf(3125), 30000);
		ModernizedCProgram.CreateTooltip(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1019), ModernizedCProgram.lmprintf(3126), 30000);
		// Hide as needed, since we display the advanced controls by defaultif (!ModernizedCProgram.advanced_mode_device) {
			ModernizedCProgram.ToggleAdvancedDeviceOptions(0);
		} 
		if (!ModernizedCProgram.advanced_mode_format) {
			ModernizedCProgram.ToggleAdvancedFormatOptions(0);
		} 
		ModernizedCProgram.ToggleImageOptions();
		// Process commandline parametersif (ModernizedCProgram.iso_provided) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(hDlg, 273, 1014, 0);
		} 
		// Simulate a button click for image selection
		ModernizedCProgram.SetBootTypeDropdownWidth();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1022, ModernizedCProgram.enable_HDDs ? 1 : 0);
		ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3210);
	}
	public static void PrintStatusTimeout(Object str, Object val) {
		ModernizedCProgram.PrintStatusInfo(0, 0, 3500, (val) ? 3250 : 3251, str);
	}
	public static void SaveVHD() {
		IMG_SAVE img_save = new IMG_SAVE(0);
		byte[] filename = new byte[128];
		byte[] path = new byte[260];
		int DriveIndex = ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 327, 0, 0));
		byte[] _img_ext_x = new byte[]{"*.vhd"};
		byte[] _img_ext_d = new byte[]{ModernizedCProgram.lmprintf(3095)};
		ext_t img_ext = new ext_t((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), filename, _img_ext_x, _img_ext_d);
		ULARGE_INTEGER free_space = new ULARGE_INTEGER();
		if ((DriveIndex < 0) || (ModernizedCProgram.format_thid != ((Object)0))) {
			return /*Error: Unsupported expression*/;
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(filename, /*Error: sizeof expression not supported yet*/, "%s.vhd", ModernizedCProgram.DriveLabel.getString()[DriveIndex]);
			(filename)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		img_save.setType(1);
		img_save.setDeviceNum((DWORD)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 336, (WPARAM)(int)(DriveIndex), 0)));
		img_save.setImagePath(ModernizedCProgram.FileDialog(1, ((Object)0), img_ext, 0));
		img_save.setBufSize(65536);
		img_save.setDeviceSize(ModernizedCProgram.SelectedDrive.getDiskSize());
		Object generatedImagePath = img_save.getImagePath();
		Object generatedQuadPart = free_space.getQuadPart();
		if (generatedImagePath != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_PROGRESS_INIT, 0, 0);
			ModernizedCProgram.FormatStatus = 0;
			free_space.setQuadPart(0);
			if ((/*Error: Function owner not recognized*/GetVolumePathNameA(generatedImagePath, path, /*Error: sizeof expression not supported yet*/)) && (/*Error: Function owner not recognized*/GetDiskFreeSpaceExA(path, free_space, ((Object)0), ((Object)0))) && ((LONGLONG)generatedQuadPart > (ModernizedCProgram.SelectedDrive.getDiskSize() + 512))) {
				ModernizedCProgram.EnableControls(0, 0);
				ModernizedCProgram.FormatStatus = 0;
				ModernizedCProgram.InitProgress(1);
				ModernizedCProgram.format_thid = /*Error: Function owner not recognized*/CreateThread(((Object)0), 0, ModernizedCProgram.SaveImageThread, img_save, 0, ((Object)0));
				if (ModernizedCProgram.format_thid != ((Object)0)) {
					ModernizedCProgram._uprintf("\r\nSave to VHD operation started");
					ModernizedCProgram.PrintStatusInfo(1, 0, 0, -1);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_TIMER_START, 0, 0);
				} else {
						ModernizedCProgram._uprintf("Unable to start VHD save thread");
						ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)generatedImagePath);
							img_save.setImagePath(((Object)0));
						} while (0);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_FORMAT_COMPLETED, (WPARAM)0, 0);
				} 
			} else {
					if (generatedQuadPart == 0) {
						ModernizedCProgram._uprintf("Unable to isolate drive name for VHD save");
						ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
					} else {
							ModernizedCProgram._uprintf("The VHD size is too large for the target drive");
							ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | ERROR_FILE_TOO_LARGE;
					} 
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)generatedImagePath);
						img_save.setImagePath(((Object)0));
					} while (0);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_FORMAT_COMPLETED, (WPARAM)0, 0);
			} 
		} 
		// Reset all progress bars
	}
	public static void SaveISO() {
		IMG_SAVE img_save = new IMG_SAVE(0);
		byte[] filename = "disc_image.iso";
		byte[] _img_ext_x = new byte[]{"*.iso"};
		byte[] _img_ext_d = new byte[]{ModernizedCProgram.lmprintf(3036)};
		ext_t img_ext = new ext_t((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), filename, _img_ext_x, _img_ext_d);
		if (ModernizedCProgram.op_in_progress || (ModernizedCProgram.format_thid != ((Object)0))) {
			return /*Error: Unsupported expression*/;
		} 
		img_save.setType(2);
		if (!img_save.GetOpticalMedia()) {
			ModernizedCProgram._uprintf("No dumpable optical media found.");
			return /*Error: Unsupported expression*/;
		} 
		Object generatedBufSize = img_save.getBufSize();
		Object generatedDeviceSize = img_save.getDeviceSize();
		// Adjust the buffer size according to the disc size so that we get a decent speed.for (img_save.setBufSize(32 * -1024); (generatedBufSize > 8 * -1024) && (generatedDeviceSize <= generatedBufSize * 64); generatedBufSize /= 2) {
			;
		}
		Object generatedLabel = img_save.getLabel();
		if ((generatedLabel != ((Object)0)) && (generatedLabel[0] != 0)) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(filename, /*Error: sizeof expression not supported yet*/, "%s.iso", generatedLabel);
				(filename)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
		} 
		ModernizedCProgram._uprintf("ISO media size %s", ModernizedCProgram.SizeToHumanReadable(generatedDeviceSize, 0, 0));
		img_save.setImagePath(ModernizedCProgram.FileDialog(1, ((Object)0), img_ext, 0));
		Object generatedImagePath = img_save.getImagePath();
		if (generatedImagePath == ((Object)0)) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_PROGRESS_INIT, 0, 0);
		ModernizedCProgram.FormatStatus = 0// Disable all controls except cancel;// Disable all controls except cancel
		ModernizedCProgram.EnableControls(0, 0);
		ModernizedCProgram.InitProgress(1);
		ModernizedCProgram.format_thid = /*Error: Function owner not recognized*/CreateThread(((Object)0), 0, ModernizedCProgram.SaveImageThread, img_save, 0, ((Object)0));
		if (ModernizedCProgram.format_thid != ((Object)0)) {
			ModernizedCProgram._uprintf("\r\nSave to ISO operation started");
			ModernizedCProgram.PrintStatusInfo(1, 0, 0, -1);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_TIMER_START, 0, 0);
		} else {
				ModernizedCProgram._uprintf("Unable to start ISO save thread");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)generatedImagePath);
					img_save.setImagePath(((Object)0));
				} while (0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_FORMAT_COMPLETED, (WPARAM)0, 0);
		} 
	}
	// dwTimeOut is the maximum amount of time we allow for this call to execute (in ms)
	// If bPrompt is false, the return value is the amount of time remaining before
	// dwTimeOut would expire (or zero if we spent more than dwTimeout in this procedure).
	// If bPrompt is true, the return value is 0 on error, dwTimeOut on success.
	public static Object CheckDriveAccess(Object dwTimeOut, Object bPrompt) {
		uint32_t i = new uint32_t();
		uint32_t j = new uint32_t();
		DWORD ret = 0;
		DWORD proceed = 1;
		BYTE access_mask = new BYTE();
		byte PhysicalPath = ((Object)0);
		byte[] DevPath = new byte[260];
		byte[] drive_letter = new byte[27];
		byte[] drive_name = "?:";
		byte[] title = new byte[128];
		uint64_t start_time = /*Error: Function owner not recognized*/GetTickCount64();
		uint64_t cur_time = new uint64_t();
		uint64_t end_time = start_time + dwTimeOut;
		// Get the current selected deviceDWORD DeviceNum = (DWORD)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 327, 0, 0))), 0));
		if ((DeviceNum < -1024) || (DeviceNum == (DWORD)-1)) {
			return 0;
		} 
		// "Checking for conflicting processes..."if (bPrompt) {
			ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3278);
		} 
		// Search for any blocking processes against the physical drive// Search for any blocking processes against the physical drivePhysicalPath = ModernizedCProgram.GetPhysicalName(DeviceNum);
		if (/*Error: Function owner not recognized*/QueryDosDeviceA(PhysicalPath[4], DevPath, /*Error: sizeof expression not supported yet*/) != 0) {
			access_mask = ModernizedCProgram.SearchProcess(DevPath, dwTimeOut, 1, 1, 1);
			if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
				;
			} 
			if (access_mask != 0) {
				proceed = 0;
				ModernizedCProgram._uprintf("Found potentially blocking process(es) against %s:", PhysicalPath[4]);
				for (j = 0; j < ModernizedCProgram.BlockingProcess.getIndex(); j++) {
					ModernizedCProgram._uprintf(ModernizedCProgram.BlockingProcess.getString()[j]);
				}
			} 
		} 
		// Search for any blocking processes against the logical volume(s)// Search for any blocking processes against the logical volume(s)ModernizedCProgram.GetDriveLetters(DeviceNum, drive_letter);
		for (i = 0; drive_letter[i]; i++) {
			drive_name[0] = drive_letter[i];
			if (/*Error: Function owner not recognized*/QueryDosDeviceA(drive_name, DevPath, /*Error: sizeof expression not supported yet*/) != 0) {
				ModernizedCProgram.BlockingProcess.StrArrayClear();
				cur_time = /*Error: Function owner not recognized*/GetTickCount64();
				if (cur_time >= end_time) {
					break;
				} 
				access_mask = ModernizedCProgram.SearchProcess(DevPath, (DWORD)(end_time - cur_time), 1, 1, 1);
				if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
					;
				} 
				if ((access_mask & -1024) || (access_mask == -1024)) {
					proceed = 0;
					ModernizedCProgram._uprintf("Found potentially blocking process(es) against %s", drive_name);
					for (j = 0; j < ModernizedCProgram.BlockingProcess.getIndex(); j++) {
						ModernizedCProgram._uprintf(ModernizedCProgram.BlockingProcess.getString()[j]);
					}
				} 
			} 
		}
		// Prompt the user if we detected blocking processesif (bPrompt && !proceed) {
			ModernizedCProgram.GetWindowTextU(ModernizedCProgram.hDeviceList, title, /*Error: sizeof expression not supported yet*/);
			proceed = ModernizedCProgram.Notification(notification_type.MSG_WARNING_QUESTION, ((Object)0), ((Object)0), title, ModernizedCProgram.lmprintf(3132));
		} 
		if (bPrompt) {
			ret = proceed ? dwTimeOut : 0;
		} else {
				ret = (DWORD)(/*Error: Function owner not recognized*/GetTickCount64() - start_time);
				ret = (dwTimeOut > ret) ? (dwTimeOut - ret) : 0;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(PhysicalPath);
		return ret/*
		 * Main dialog callback
		 */;
	}
	public static Object MainCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		DWORD DeviceNum = 0;
		uint64_t LastRefresh = 0;
		BOOL first_log_display = 1;
		BOOL isMarquee = 0;
		BOOL queued_hotplug_event = 0;
		ULONG ulRegister = 0;
		LPITEMIDLIST pidlDesktop = ((Object)0);
		 NotifyEntry = new ();
		DWORD_PTR[] thread_affinity = new DWORD_PTR();
		HFONT hyperlink_font = ((Object)0);
		LONG lPos = new LONG();
		BOOL set_selected_fs = new BOOL();
		DRAWITEMSTRUCT pDI = new DRAWITEMSTRUCT();
		LPTOOLTIPTEXT lpttt = new LPTOOLTIPTEXT();
		 pDropDown = new ();
		HDROP droppedFileInfo = new HDROP();
		HMENU hMenu = new HMENU();
		POINT Point = new POINT();
		RECT rc = new RECT();
		RECT DialogRect = new RECT();
		RECT DesktopRect = new RECT();
		HDC hDC = new HDC();
		PAINTSTRUCT ps = new PAINTSTRUCT();
		int nDeviceIndex;
		int i;
		int nWidth;
		int nHeight;
		int nb_devices;
		int selected_language;
		int offset;
		int tb_state;
		int tb_flags;
		byte[] tmp = new byte[128];
		wchar_t wbuffer = ((Object)0);
		loc_cmd lcmd = ((Object)0);
		wchar_t[] wtooltip = new wchar_t();
		list_head generatedList = lcmd.getList();
		list_head generatedNext = generatedList.getNext();
		Object generatedRight = DialogRect.getRight();
		Object generatedLeft = DialogRect.getLeft();
		Object generatedBottom = DialogRect.getBottom();
		Object generatedTop = DialogRect.getTop();
		Object generatedX = Point.getX();
		Object generatedY = Point.getY();
		Object generatedHDC = pDI.getHDC();
		Object generatedRcItem = pDI.getRcItem();
		Object generatedItemID = pDI.getItemID();
		return (INT_PTR)0;
	}
	public static void PrintUsage(Byte appname) {
		byte[] fname = new byte[256];
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_splitpath(appname, ((Object)0), ((Object)0), fname, ((Object)0));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("\nUsage: %s [-x] [-g] [-h] [-f FILESYSTEM] [-i PATH] [-l LOCALE] [-w TIMEOUT]\n", fname);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("  -x, --extra-devs\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("     List extra devices, such as USB HDDs\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("  -g, --gui\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("     Start in GUI mode (disable the 'rufus.com' commandline hogger)\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("  -i PATH, --iso=PATH\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("     Select the ISO image pointed by PATH to be used on startup\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("  -l LOCALE, --locale=LOCALE\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("     Select the locale to be used on startup\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("  -f FILESYSTEM, --filesystem=FILESYSTEM\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("     Preselect the file system to be preferred when formatting\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("  -w TIMEOUT, --wait=TIMEOUT\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("     Wait TIMEOUT tens of seconds for the global application mutex to be released.\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("     Used when launching a newer version of Rufus from a running application.\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("  -h, --help\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("     This usage guide.\n");
	}
	public static Object SetHogger() {
		 input = new ();
		BYTE hog_data = new BYTE();
		DWORD hog_size = new DWORD();
		DWORD Size = new DWORD();
		HANDLE hogmutex = ((Object)0);
		HANDLE hFile = ((Object)0);
		int i;
		hog_data = ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)(true))), ModernizedCProgram.cmdline_hogger, hog_size, 0);
		if (hog_data != ((Object)0)) {
			hogmutex = /*Error: Function owner not recognized*/CreateMutexA(((Object)0), 1, "Global/Rufus_CmdLine");
			hFile = /*Error: Function owner not recognized*/CreateFileA(ModernizedCProgram.cmdline_hogger, -1024 | -1024, -1024, ((Object)0), 2, -1024, ((Object)0));
			if (hFile != (HANDLE)(true)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WriteFile(hFile, hog_data, hog_size, Size, ((Object)0));
			} 
			do {
				if ((hFile != (HANDLE)(true)) && (hFile != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hFile);
					hFile = (HANDLE)(true);
				} 
			} while (0);
			input = ()/*Error: Function owner not recognized*/calloc(/*Error: Function owner not recognized*/strlen(ModernizedCProgram.cmdline_hogger) + 1, /*Error: Unsupported expression*/);
			if (input != ((Object)0)) {
				for (i = 0; i < (int)/*Error: Function owner not recognized*/strlen(ModernizedCProgram.cmdline_hogger); i++) {
					input[i].setType(INPUT_KEYBOARD);
					input[i].getKi().setDwFlags(KEYEVENTF_UNICODE);
					input[i].getKi().setWScan((wchar_t)ModernizedCProgram.cmdline_hogger[i]);
				}
				input[i].setType(INPUT_KEYBOARD);
				input[i].getKi().setWVk(13);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendInput(i + 1, input, /*Error: Unsupported expression*/);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(input);
			} 
		} 
		// Create our synchronisation mutex
		if (hogmutex != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(200);
		} 
		return hogmutex/*
		 * Application Entrypoint
		 */;
	}
	public static int WinMain(Object hInstance, Object hPrevInstance, Object lpCmdLine, int nCmdShow) {
		byte rufus_loc = "rufus.loc";
		wchar_t[] kernel32_path = new wchar_t();
		int i;
		int opt;
		int option_index = 0;
		int argc = 0;
		int si = 0;
		int lcid = /*Error: Function owner not recognized*/GetUserDefaultUILanguage();
		int wait_for_mutex = 0;
		FILE fd = new FILE();
		BOOL attached_console = 0;
		BOOL external_loc_file = 0;
		BOOL lgp_set = 0;
		BOOL automount = 1;
		BOOL disable_hogger = 0;
		BOOL previous_enable_HDDs = 0;
		BOOL vc = ModernizedCProgram.IsRegistryNode(((HKEY)-1024), ModernizedCProgram.vs_reg);
		BOOL alt_pressed = 0;
		BOOL alt_command = 0;
		BYTE loc_data = new BYTE();
		DWORD loc_size = new DWORD();
		DWORD u = new DWORD();
		DWORD size = /*Error: sizeof expression not supported yet*/;
		byte[] tmp_path = "";
		byte[] loc_file = "";
		byte[] ini_path = "";
		byte[] ini_flags = "rb";
		byte tmp;
		byte locale_name = ((Object)0);
		byte argv = ((Object)0);
		wchar_t wenv = new wchar_t();
		wchar_t wargv = new wchar_t();
		int __wgetmainargs_t;
		__wgetmainargs_t pf__wgetmainargs = ((Object)0);
		BOOL SetDefaultDllDirectories_t = new BOOL();
		SetDefaultDllDirectories_t pfSetDefaultDllDirectories = ((Object)0);
		HANDLE mutex = ((Object)0);
		HANDLE hogmutex = ((Object)0);
		HANDLE hFile = ((Object)0);
		HWND hDlg = ((Object)0);
		HDC hDC = new HDC();
		MSG msg = new MSG();
		option[] long_options = new option[]{new option("extra-devs", .no_argument, ((Object)0), (byte)'x'), new option("gui", .no_argument, ((Object)0), (byte)'g'), new option("help", .no_argument, ((Object)0), (byte)'h'), new option("iso", .required_argument, ((Object)0), (byte)'i'), new option("locale", .required_argument, ((Object)0), (byte)'l'), new option("filesystem", .required_argument, ((Object)0), (byte)'f'), new option("wait", .required_argument, ((Object)0), (byte)'w'), new option(0, 0, ((Object)0), 0)};
		/*Error: Function owner not recognized*/// Disable loading system DLLs from the current directory (sideloading mitigation)// PS: You know that official MSDN documentation for SetDllDirectory() that explicitly// indicates that "If the parameter is an empty string (""), the call removes the current// directory from the default DLL search order"? Yeah, that doesn't work. At all.// Still, we invoke it, for platforms where the following call might actually work.../*Error: Function owner not recognized*/// Disable loading system DLLs from the current directory (sideloading mitigation)// PS: You know that official MSDN documentation for SetDllDirectory() that explicitly// indicates that "If the parameter is an empty string (""), the call removes the current// directory from the default DLL search order"? Yeah, that doesn't work. At all.// Still, we invoke it, for platforms where the following call might actually work...SetDllDirectoryA("")// Also, even if you use SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32), you're// still going to be brought down if you link to wininet.lib or dwmapi.lib, as these two// perform their DLL invocations before you've had a chance to execute anything.// Of course, this is not something that security "researchers" will bother looking into;// Also, even if you use SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32), you're// still going to be brought down if you link to wininet.lib or dwmapi.lib, as these two// perform their DLL invocations before you've had a chance to execute anything.// Of course, this is not something that security "researchers" will bother looking into
		/*Error: Function owner not recognized*/// to try to help fellow developers, when they can get an ego fix by simply throwing// generic URLs around and deliberately refusing to practice *responsible disclosure*...// Finally, we need to perform the whole gymkhana below, where we can't call on// SetDefaultDllDirectories() directly, because Windows 7 doesn't have the API exposed./*Error: Function owner not recognized*/// to try to help fellow developers, when they can get an ego fix by simply throwing// generic URLs around and deliberately refusing to practice *responsible disclosure*...// Finally, we need to perform the whole gymkhana below, where we can't call on// SetDefaultDllDirectories() directly, because Windows 7 doesn't have the API exposed.GetSystemDirectoryW(kernel32_path, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/wcsncat(kernel32_path, L"\\kernel32.dll", (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/) - /*Error: Function owner not recognized*/wcslen(kernel32_path) - 1)// NB: Because kernel32 should already be loaded, what we do above to ensure that we// (re)pick the system one is mostly unnecessary. But since for a hammer everything is a;// NB: Because kernel32 should already be loaded, what we do above to ensure that we// (re)pick the system one is mostly unnecessary. But since for a hammer everything is a
		// nail... Also, no, Coverity, we never need to care about freeing kernel32 as a library.// coverity[leaked_storage]// nail... Also, no, Coverity, we never need to care about freeing kernel32 as a library.// coverity[leaked_storage]pfSetDefaultDllDirectories = (SetDefaultDllDirectories_t)/*Error: Function owner not recognized*/GetProcAddress(/*Error: Function owner not recognized*/LoadLibraryW(kernel32_path), "SetDefaultDllDirectories");
		if (pfSetDefaultDllDirectories != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfSetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32);
		} 
		ModernizedCProgram._uprintf("*** Rufus init ***\n");
		ModernizedCProgram.its_a_me_mario = /*Error: Function owner not recognized*/GetUserNameA((byte)(uintptr_t)u, size) && (u == 7104878)// coverity[pointless_string_compare];// coverity[pointless_string_compare]
		ModernizedCProgram.is_x86_32 = (/*Error: Function owner not recognized*/strcmp("x86", "x86") == 0);
		// We have to process the arguments before we acquire the lock and process the localeif (pf__wgetmainargs == ((Object)0)) {
			pf__wgetmainargs = (__wgetmainargs_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Msvcrt"), "__wgetmainargs");
		} 
		if (pf__wgetmainargs != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pf__wgetmainargs(argc, wargv, wenv, 1, si);
			argv = (byte)/*Error: Function owner not recognized*/calloc(argc, /*Error: Unsupported expression*/);
			if (argv != ((Object)0)) {
				for (i = 0; i < argc; i++) {
					argv[i] = ModernizedCProgram.wchar_to_utf8(wargv[i]);
					if (/*Error: Function owner not recognized*/strcmp(argv[i], "/W") == 0) {
						wait_for_mutex = 150;
					} 
					if ((/*Error: Function owner not recognized*/strcmp(argv[i], "-g") == 0) || (/*Error: Function owner not recognized*/strcmp(argv[i], "--gui") == 0)) {
						disable_hogger = 1;
					} 
				}
				tmp = argv[0][/*Error: Function owner not recognized*/strlen(argv[0]) - 1];
				while ((((uintptr_t)tmp) > ((uintptr_t)argv[0])) && (tmp != (byte)'\\')) {
					tmp--;
				}
				if ((/*Error: Function owner not recognized*/strchr(tmp, (byte)'p') != ((Object)0)) || ((/*Error: Function owner not recognized*/strchr(tmp, (byte)'P') != ((Object)0)) && (/*Error: Function owner not recognized*/strchr(tmp, (byte)'P')[1] != (byte)'H'))) {
					ini_flags[0] = (byte)'a';
				} 
				if (!disable_hogger) {
					if (/*Error: Function owner not recognized*/AttachConsole(ATTACH_PARENT_PROCESS) != 0) {
						attached_console = 1;
						do {
							(Object)(/*Error: Function owner not recognized*/freopen("CONIN$", "r", (_iob[0])));
						} while (0);
						do {
							(Object)(/*Error: Function owner not recognized*/freopen("CONOUT$", "w", (_iob[1])));
						} while (0);
						do {
							(Object)(/*Error: Function owner not recognized*/freopen("CONOUT$", "w", (_iob[2])));
						} while (0);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_flushall();
						hogmutex = ModernizedCProgram.SetHogger();
					} 
				} 
				while ((opt = ModernizedCProgram.getopt_long(argc, argv, "?xghf:i:w:l:", long_options, option_index)) != (true)) {
					switch (opt) {
					case (byte)'x':
							ModernizedCProgram.enable_HDDs = 1;
							break;
					case (byte)'f':
							if (/*Error: Function owner not recognized*/isdigit((byte)(ModernizedCProgram.optarg[0]))) {
								ModernizedCProgram.preselected_fs = (int)/*Error: Function owner not recognized*/strtol(ModernizedCProgram.optarg, ((Object)0), 0);
							} else {
									for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
										if (/*Error: Function owner not recognized*/_stricmp(((ModernizedCProgram.optarg == ((Object)0)) ? "<NULL>" : ModernizedCProgram.optarg), ((ModernizedCProgram.FileSystemLabel[i] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.FileSystemLabel[i])) == 0) {
											ModernizedCProgram.preselected_fs = i;
											break;
										} 
									}
							} 
							if ((ModernizedCProgram.preselected_fs < fs_type.FS_UNKNOWN) || (ModernizedCProgram.preselected_fs >= fs_type.FS_MAX)) {
								ModernizedCProgram.preselected_fs = fs_type.FS_UNKNOWN;
							} 
							ModernizedCProgram.selected_fs = ModernizedCProgram.preselected_fs;
							break;
					case (byte)'i':
							if (/*Error: Function owner not recognized*/_access(ModernizedCProgram.optarg, 0) != -1) {
								do {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.image_path);
									ModernizedCProgram.image_path = ((Object)0);
								} while (0);
								ModernizedCProgram.image_path = /*Error: Function owner not recognized*/_strdup(ModernizedCProgram.optarg);
								ModernizedCProgram.iso_provided = 1;
							} else {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Could not find ISO image '%s'\n", ModernizedCProgram.optarg);
							} 
							break;
					case (byte)'l':
							if (/*Error: Function owner not recognized*/isdigit((byte)(ModernizedCProgram.optarg[0]))) {
								lcid = (int)/*Error: Function owner not recognized*/strtol(ModernizedCProgram.optarg, ((Object)0), 0);
							} else {
									do {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)locale_name);
										locale_name = ((Object)0);
									} while (0);
									locale_name = /*Error: Function owner not recognized*/_strdup(ModernizedCProgram.optarg);
							} 
							break;
					case (byte)'?':
					case (byte)'h':
					case (byte)'g':
							break;
					case (byte)'w':
							wait_for_mutex = /*Error: Function owner not recognized*/atoi(ModernizedCProgram.optarg);
							break;
					default:
							ModernizedCProgram.PrintUsage(argv[0]);
							;
					}
				}
			} 
		} else {
				ModernizedCProgram._uprintf("Could not access UTF-16 args");
		} 
		// Retrieve various app & system directoriesif (ModernizedCProgram.GetCurrentDirectoryU(/*Error: sizeof expression not supported yet*/, ModernizedCProgram.app_dir) == 0) {
			ModernizedCProgram._uprintf("Could not get current directory: %s", ModernizedCProgram.WindowsErrorString());
			ModernizedCProgram.app_dir[0] = 0;
		} 
		if (ModernizedCProgram.GetSystemDirectoryU(ModernizedCProgram.system_dir, /*Error: sizeof expression not supported yet*/) == 0) {
			ModernizedCProgram._uprintf("Could not get system directory: %s", ModernizedCProgram.WindowsErrorString());
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.system_dir, "C:\\Windows\\System32", (((size_t)(((((byte)"C:\\Windows\\System32") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("C:\\Windows\\System32")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"C:\\Windows\\System32") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("C:\\Windows\\System32")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
				((byte)ModernizedCProgram.system_dir)[(((size_t)(((((byte)"C:\\Windows\\System32") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("C:\\Windows\\System32")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"C:\\Windows\\System32") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("C:\\Windows\\System32")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
			} while (0);
		} 
		if (ModernizedCProgram.GetTempPathU(/*Error: sizeof expression not supported yet*/, ModernizedCProgram.temp_dir) == 0) {
			ModernizedCProgram._uprintf("Could not get temp directory: %s", ModernizedCProgram.WindowsErrorString());
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.temp_dir, ".\\", (((size_t)(((((byte)".\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".\\")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)".\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".\\")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
				((byte)ModernizedCProgram.temp_dir)[(((size_t)(((((byte)".\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".\\")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)".\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".\\")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
			} while (0);
		} 
		// By default (64bit app running on 64 bit OS or 32 bit app running on 32 bit OS)// Sysnative and System32 are the samedo {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.sysnative_dir, ModernizedCProgram.system_dir, (((size_t)(((((byte)ModernizedCProgram.system_dir) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.system_dir)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.system_dir) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.system_dir)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)ModernizedCProgram.sysnative_dir)[(((size_t)(((((byte)ModernizedCProgram.system_dir) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.system_dir)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.system_dir) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.system_dir)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);// But if the app is 32 bit and the OS is 64 bit, Sysnative must differ from System32
		if (ModernizedCProgram.is_x64()) {
			if (ModernizedCProgram.GetSystemWindowsDirectoryU(ModernizedCProgram.sysnative_dir, /*Error: sizeof expression not supported yet*/) == 0) {
				ModernizedCProgram._uprintf("Could not get Windows directory: %s", ModernizedCProgram.WindowsErrorString());
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.sysnative_dir, "C:\\Windows", (((size_t)(((((byte)"C:\\Windows") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("C:\\Windows")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"C:\\Windows") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("C:\\Windows")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)ModernizedCProgram.sysnative_dir)[(((size_t)(((((byte)"C:\\Windows") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("C:\\Windows")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"C:\\Windows") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("C:\\Windows")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(ModernizedCProgram.sysnative_dir, "\\Sysnative", (((size_t)(((((byte)"\\Sysnative") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\Sysnative")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)ModernizedCProgram.sysnative_dir) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.sysnative_dir)) - 1)) ? ((size_t)(((((byte)"\\Sysnative") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\Sysnative")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)ModernizedCProgram.sysnative_dir) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.sysnative_dir)) - 1))));
		} 
		// Look for a .ini file in the current app directorydo {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ini_path, /*Error: sizeof expression not supported yet*/, "%s\\rufus.ini", ModernizedCProgram.app_dir);
			(ini_path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		// Will create the file if portable mode is requested// Will create the file if portable mode is requestedfd = ModernizedCProgram.fopenU(ini_path, ini_flags);
		vc |=  (/*Error: Function owner not recognized*/strcmp(((ModernizedCProgram.GetSignatureName(((Object)0), ((Object)0)) == ((Object)0)) ? "<NULL>" : ModernizedCProgram.GetSignatureName(((Object)0), ((Object)0))), ((ModernizedCProgram.cert_name[0] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.cert_name[0])) == 0);
		if (fd != ((Object)0)) {
			ModernizedCProgram.ini_file = ini_path;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
		} 
		ModernizedCProgram._uprintf("Will use settings from %s", (ModernizedCProgram.ini_file != ((Object)0)) ? "INI file" : "registry");
		// Use the locale specified by the settings, if any// Use the locale specified by the settings, if anytmp = ModernizedCProgram.ReadSettingStr("Locale");
		if (tmp[0] != 0) {
			locale_name = /*Error: Function owner not recognized*/_strdup(tmp);
			ModernizedCProgram._uprintf("found locale '%s'", locale_name);
		} 
		// Restore user-saved settings// Restore user-saved settingsModernizedCProgram.advanced_mode_device = ModernizedCProgram.ReadSettingBool("ShowAdvancedDriveProperties");
		ModernizedCProgram.advanced_mode_format = ModernizedCProgram.ReadSettingBool("ShowAdvancedFormatOptions");
		ModernizedCProgram.preserve_timestamps = ModernizedCProgram.ReadSettingBool("PreserveTimestamps");
		ModernizedCProgram.use_fake_units = !ModernizedCProgram.ReadSettingBool("UseProperSizeUnits");
		ModernizedCProgram.use_vds = ModernizedCProgram.ReadSettingBool("UseVds");
		ModernizedCProgram.usb_debug = ModernizedCProgram.ReadSettingBool("EnableUsbDebug");
		ModernizedCProgram.detect_fakes = !ModernizedCProgram.ReadSettingBool("DisableFakeDrivesCheck");
		ModernizedCProgram.allow_dual_uefi_bios = ModernizedCProgram.ReadSettingBool("EnableWindowsDualUefiBiosMode");
		ModernizedCProgram.force_large_fat32 = ModernizedCProgram.ReadSettingBool("ForceLargeFat32Formatting");
		ModernizedCProgram.enable_vmdk = ModernizedCProgram.ReadSettingBool("EnableVmdkDetection");
		ModernizedCProgram.enable_file_indexing = ModernizedCProgram.ReadSettingBool("EnableFileIndexing");
		// Initialize the global scaling, in case we need it before we initialize the dialog// Initialize the global scaling, in case we need it before we initialize the dialoghDC = /*Error: Function owner not recognized*/GetDC(((Object)0));
		ModernizedCProgram.fScale = /*Error: Function owner not recognized*/GetDeviceCaps(hDC, 88) / 96.0;
		do {
			if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(((Object)0), hDC);
				hDC = ((Object)0);
			} 
		} while (0);
		// Init localization// Init localizationModernizedCProgram._init_localization(0);
		// Seek for a loc file in the current directoryif (ModernizedCProgram.GetFileAttributesU(rufus_loc) == ((DWORD)-1)) {
			ModernizedCProgram._uprintf("loc file not found in current directory - embedded one will be used");
			loc_data = (BYTE)ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)(true))), "embedded.loc", loc_size, 0);
			if ((ModernizedCProgram.GetTempFileNameU(ModernizedCProgram.temp_dir, "Rufus", 0, loc_file) == 0) || (loc_file[0] == 0)) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(loc_file, rufus_loc, (((size_t)(((((byte)rufus_loc) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(rufus_loc)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)rufus_loc) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(rufus_loc)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)loc_file)[(((size_t)(((((byte)rufus_loc) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(rufus_loc)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)rufus_loc) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(rufus_loc)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
			} 
			hFile = ModernizedCProgram.CreateFileU(loc_file, -1024 | -1024, -1024, ((Object)0), 2, -1024, ((Object)0));
			if ((hFile == (HANDLE)(true)) || (!ModernizedCProgram.WriteFileWithRetry(hFile, loc_data, loc_size, size, 4))) {
				ModernizedCProgram._uprintf("localization: unable to extract '%s': %s", loc_file, ModernizedCProgram.WindowsErrorString());
				do {
					if ((hFile != (HANDLE)(true)) && (hFile != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hFile);
						hFile = (HANDLE)(true);
					} 
				} while (0);
				;
			} 
			ModernizedCProgram._uprintf("localization: extracted data to '%s'", loc_file);
			do {
				if ((hFile != (HANDLE)(true)) && (hFile != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hFile);
					hFile = (HANDLE)(true);
				} 
			} while (0);
		} else {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(loc_file, /*Error: sizeof expression not supported yet*/, "%s\\%s", ModernizedCProgram.app_dir, rufus_loc);
					(loc_file)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				external_loc_file = 1;
				ModernizedCProgram._uprintf("using external loc file '%s'", loc_file);
		} 
		loc_cmd_struct loc_cmd_struct = new loc_cmd_struct();
		loc_cmd_struct loc_cmd_struct = new loc_cmd_struct();
		if ((!ModernizedCProgram.get_supported_locales(loc_file)) || ((ModernizedCProgram.selected_locale = ((locale_name == ((Object)0)) ? loc_cmd_struct.get_locale_from_lcid(lcid, 1) : loc_cmd_struct.get_locale_from_name(locale_name, 1))) == ((Object)0))) {
			ModernizedCProgram._uprintf("FATAL: Could not access locale!");
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MessageBoxA(((Object)0), "The locale data is missing or invalid. This application will now exit.", "Fatal error", 16 | 4096);
			;
		} 
		ModernizedCProgram.selected_langid = ModernizedCProgram.selected_locale.get_language_id();
		// Set the Windows version// Set the Windows versionModernizedCProgram.GetWindowsVersion();
		// ...and nothing of value was lostif (ModernizedCProgram.nWindowsVersion < WindowsVersion.WINDOWS_7) {
			ModernizedCProgram.selected_locale.get_loc_data_file(loc_file);
			ModernizedCProgram.right_to_left_mode = ((ModernizedCProgram.selected_locale.getCtrl_id()) & -1024);
			ModernizedCProgram.MessageBoxExU(((Object)0), ModernizedCProgram.lmprintf(3294), ModernizedCProgram.lmprintf(3293), 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0) | 4096, ModernizedCProgram.selected_langid);
			;
		} 
		// Load the translation before we print the error
		// This is needed as there appears to be a *FLAW* in Windows allowing the app to run unelevated with some// weirdly configured user accounts, even as we explicitly set 'requireAdministrator' in the manifest...if (!ModernizedCProgram.IsCurrentProcessElevated()) {
			ModernizedCProgram._uprintf("FATAL: No administrative privileges!");
			ModernizedCProgram.selected_locale.get_loc_data_file(loc_file);
			ModernizedCProgram.right_to_left_mode = ((ModernizedCProgram.selected_locale.getCtrl_id()) & -1024);
			ModernizedCProgram.MessageBoxExU(((Object)0), ModernizedCProgram.lmprintf(3289), ModernizedCProgram.lmprintf(3288), 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0) | 4096, ModernizedCProgram.selected_langid);
			;
		} 
		// Prevent 2 applications from running at the same time, unless "/W" is passed as an option// in which case we wait for the mutex to be relinquishedif ((((((byte)lpCmdLine) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(lpCmdLine)) == 2) && (lpCmdLine[0] == (byte)'/') && (lpCmdLine[1] == (byte)'W')) {
			wait_for_mutex = 150;
		} 
		mutex = /*Error: Function owner not recognized*/CreateMutexA(((Object)0), 1, "Global/Rufus");
		for (; (wait_for_mutex > 0) && (mutex != ((Object)0)) && (/*Error: Function owner not recognized*/GetLastError() == -1024); wait_for_mutex--) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(mutex);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(100);
			mutex = /*Error: Function owner not recognized*/CreateMutexA(((Object)0), 1, "Global/Rufus");
		}
		if ((mutex == ((Object)0)) || (/*Error: Function owner not recognized*/GetLastError() == -1024)) {
			ModernizedCProgram.selected_locale.get_loc_data_file(loc_file);
			ModernizedCProgram.right_to_left_mode = ((ModernizedCProgram.selected_locale.getCtrl_id()) & -1024);
			ModernizedCProgram.MessageBoxExU(((Object)0), ModernizedCProgram.lmprintf(3002), ModernizedCProgram.lmprintf(3001), 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0) | 4096, ModernizedCProgram.selected_langid);
			;
		} 
		// Load the translation before we print the error
		// Save instance of the application for further reference// Save instance of the application for further referenceModernizedCProgram.hMainInstance = hInstance;
		// Initialize COM for folder selectiondo {
			(Object)(/*Error: Function owner not recognized*/CoInitializeEx(((Object)0), tagCOINIT.COINIT_APARTMENTTHREADED | tagCOINIT.COINIT_DISABLE_OLE1DDE));
		} while (0);
		// Some dialogs have Rich Edit controls and won't display without thisif (ModernizedCProgram.GetLibraryHandle("Riched20") == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not load RichEdit library - some dialogs may not display: %s\n", ModernizedCProgram.WindowsErrorString());
		} 
		// Increase the application privileges (SE_DEBUG_PRIVILEGE), so that we can report// the Windows Services preventing access to the disk or volume we want to format.// Increase the application privileges (SE_DEBUG_PRIVILEGE), so that we can report// the Windows Services preventing access to the disk or volume we want to format.ModernizedCProgram.EnablePrivileges()// We use local group policies rather than direct registry manipulation;// We use local group policies rather than direct registry manipulation
		// 0x9e disables removable and fixed drive notifications// 0x9e disables removable and fixed drive notificationslgp_set = ModernizedCProgram.SetLGP(0, ModernizedCProgram.existing_key, ModernizedCProgram.ep_reg, "NoDriveTypeAutorun", -1024);
		// Re-enable AutoMount if neededif (!ModernizedCProgram.GetAutoMount(automount)) {
			ModernizedCProgram._uprintf("Could not get AutoMount status");
			automount = 1;
		}  else if (!automount) {
			ModernizedCProgram._uprintf("AutoMount was detected as disabled - temporarily re-enabling it");
			if (!ModernizedCProgram.SetAutoMount(1)) {
				ModernizedCProgram._uprintf("Failed to enable AutoMount");
			} 
		} 
		ModernizedCProgram.right_to_left_mode = ((ModernizedCProgram.selected_locale.getCtrl_id()) & -1024)// We always launch with the image options displaying;// We always launch with the image options displaying
		ModernizedCProgram.image_options = -1024;
		ModernizedCProgram.image_option_txt[0] = 0;
		ModernizedCProgram.select_index = 0;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.fido_url);
			ModernizedCProgram.fido_url = ((Object)0);
		} while (0);
		ModernizedCProgram.enable_fido = 0;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetProcessDefaultLayout(ModernizedCProgram.right_to_left_mode ? 1 : 0);
		if (ModernizedCProgram.selected_locale.get_loc_data_file(loc_file)) {
			ModernizedCProgram.WriteSettingStr("Locale", ModernizedCProgram.selected_locale.getTxt()[0]);
		} 
		if (!vc) {
			if (ModernizedCProgram.MessageBoxExU(((Object)0), ModernizedCProgram.lmprintf(3296), ModernizedCProgram.lmprintf(3295), 4 | -1024 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0) | 4096, ModernizedCProgram.selected_langid) != 6) {
				;
			} 
			vc = 1;
		} 
		if (hDlg != ((Object)/*
			 * Create the main Window
			 */0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DestroyWindow(hDlg);
		} 
		// Make sure any previous dialog is destroyed (e.g. when switching languages)
		hDlg = ModernizedCProgram.MyCreateDialog(hInstance, 101, ((Object)0), MainCallback);
		if (hDlg == ((Object)0)) {
			ModernizedCProgram.MessageBoxExU(((Object)0), "Could not create Window", "DialogBox failure", 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0) | 4096, ModernizedCProgram.selected_langid);
			;
		} 
		if ((ModernizedCProgram.relaunch_rc.getLeft() > -65536) && (ModernizedCProgram.relaunch_rc.getTop() > -65536)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hDlg, ((HWND)0), ModernizedCProgram.relaunch_rc.getLeft(), ModernizedCProgram.relaunch_rc.getTop(), 0, 0, -1024);
		} 
		/*Error: Function owner not recognized*/// Enable drag-n-drop through the message filter/*Error: Function owner not recognized*/// Enable drag-n-drop through the message filterChangeWindowMessageFilterEx(hDlg, 563, MSGFLT_ADD, ((Object)0));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ChangeWindowMessageFilterEx(hDlg, 74, MSGFLT_ADD, ((Object)0))// CopyGlobalData is needed since we are running elevated;// CopyGlobalData is needed since we are running elevated
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ChangeWindowMessageFilterEx(hDlg, -1024, MSGFLT_ADD, ((Object)0));
		// Set the hook to automatically close Windows' "You need to format the disk in drive..." prompt// Set the hook to automatically close Windows' "You need to format the disk in drive..." promptModernizedCProgram.SetAlertPromptMessages();
		if (!ModernizedCProgram.SetAlertPromptHook()) {
			ModernizedCProgram._uprintf("Warning: Could not set alert prompt hook");
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(hDlg, 1);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/UpdateWindow(hDlg);
		Object generatedMessage = msg.getMessage();
		Object generatedLParam = msg.getLParam();
		Object generatedWParam = msg.getWParam();
		// Do our own event processing and process "magic" commandswhile (/*Error: Function owner not recognized*/GetMessageA(msg, ((Object)0), 0, 0)) {
			BOOL ctrl_without_focus = 0;
			BOOL no_focus = (generatedMessage == 260) && !(generatedLParam & -1024);
			if ((generatedMessage == 260) && (generatedWParam != 18)) {
				alt_command = 1;
			}  else if (/*Error: Function owner not recognized*/GetKeyState(18) & -1024) {
				alt_pressed = 1;
			} 
			if ((/*Error: Function owner not recognized*/IsWindowVisible(ModernizedCProgram.hLogDialog)) && (/*Error: Function owner not recognized*/GetKeyState(17) & -1024) && (generatedMessage == 256) && (generatedWParam == (byte)'A')) {
				((Object)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hLog), 177, (false), (true)));
				continue;
			} 
			if (no_focus && (generatedWParam == 17)) {
				ctrl_without_focus = ModernizedCProgram.op_in_progress;
			} 
			if ((ctrl_without_focus || ((/*Error: Function owner not recognized*/GetKeyState(17) & -1024) && (generatedMessage == 256))) && (generatedWParam == (byte)'L')) {
				ctrl_without_focus = 0;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, 273, 1054, 0);
				continue;
			} 
			if (no_focus && (generatedWParam != 17)) {
				ctrl_without_focus = 0;
			} 
			if (no_focus) {
				continue;
			} 
			if (!ModernizedCProgram.op_in_progress) {
				if ((generatedMessage == 260) && (generatedWParam == VK_OEM_PERIOD)) {
					ModernizedCProgram.usb_debug = !ModernizedCProgram.usb_debug;
					ModernizedCProgram.WriteSettingBool("EnableUsbDebug", ModernizedCProgram.usb_debug);
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3270), ModernizedCProgram.usb_debug);
					ModernizedCProgram.GetDevices(0);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == VK_OEM_COMMA)) {
					ModernizedCProgram.lock_drive = !ModernizedCProgram.lock_drive;
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3282), ModernizedCProgram.lock_drive);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'B')) {
					ModernizedCProgram.detect_fakes = !ModernizedCProgram.detect_fakes;
					ModernizedCProgram.WriteSettingBool("DisableFakeDrivesCheck", !ModernizedCProgram.detect_fakes);
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3256), ModernizedCProgram.detect_fakes);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'C')) {
					int index = ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 327, 0, 0));
					if (index >= 0) {
						ModernizedCProgram.CyclePort(index);
					} 
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'D')) {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp_path, /*Error: sizeof expression not supported yet*/, "%s\\%s", ModernizedCProgram.app_dir, "rufus_files");
						(tmp_path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
					ModernizedCProgram.PrintStatusInfo(0, 0, 2000, 3264, tmp_path);
					ModernizedCProgram.SHDeleteDirectoryExU(((Object)0), tmp_path, 4 | 1024 | 16);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'E')) {
					ModernizedCProgram.allow_dual_uefi_bios = !ModernizedCProgram.allow_dual_uefi_bios;
					ModernizedCProgram.WriteSettingBool("EnableWindowsDualUefiBiosMode", ModernizedCProgram.allow_dual_uefi_bios);
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3266), ModernizedCProgram.allow_dual_uefi_bios);
					ModernizedCProgram.SetPartitionSchemeAndTargetSystem(0);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'F')) {
					ModernizedCProgram.enable_HDDs = !ModernizedCProgram.enable_HDDs;
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3253), ModernizedCProgram.enable_HDDs);
					ModernizedCProgram.GetDevices(0);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1022, ModernizedCProgram.enable_HDDs ? 1 : 0);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'I')) {
					ModernizedCProgram.enable_iso = !ModernizedCProgram.enable_iso;
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3262), ModernizedCProgram.enable_iso);
					if (ModernizedCProgram.image_path != ((Object)0)) {
						ModernizedCProgram.iso_provided = 1;
						ModernizedCProgram.dont_display_image_name = 1;
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hDlg, 273, 1014, 0);
					} 
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'J')) {
					ModernizedCProgram.enable_joliet = !ModernizedCProgram.enable_joliet;
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3257), ModernizedCProgram.enable_joliet);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'K')) {
					ModernizedCProgram.enable_rockridge = !ModernizedCProgram.enable_rockridge;
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3258), ModernizedCProgram.enable_rockridge);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'L')) {
					ModernizedCProgram._uprintf("DAFUQ!?!? LPARAM = 0x%08X", generatedLParam);
					if ((generatedMessage == 260) && !(generatedLParam & -1024)) {
						ModernizedCProgram._uprintf("KIDDING ME?!?!.");
					} 
					ModernizedCProgram.force_large_fat32 = !ModernizedCProgram.force_large_fat32;
					ModernizedCProgram.WriteSettingBool("ForceLargeFat32Formatting", ModernizedCProgram.force_large_fat32);
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3254), ModernizedCProgram.force_large_fat32);
					ModernizedCProgram.GetDevices(0);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'N')) {
					ModernizedCProgram.enable_ntfs_compression = !ModernizedCProgram.enable_ntfs_compression;
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3260), ModernizedCProgram.enable_ntfs_compression);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'O')) {
					ModernizedCProgram.SaveISO();
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'Q')) {
					ModernizedCProgram.enable_file_indexing = !ModernizedCProgram.enable_file_indexing;
					ModernizedCProgram.WriteSettingBool("EnableFileIndexing", ModernizedCProgram.enable_file_indexing);
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3290), !ModernizedCProgram.enable_file_indexing);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'R')) {
					ModernizedCProgram.PrintStatusInfo(0, 0, 2000, ModernizedCProgram.DeleteRegistryKey(((HKEY)-1024), "Akeo Consulting\\Rufus") ? 3248 : 3249);
					ModernizedCProgram.DeleteRegistryKey(((HKEY)-1024), "Akeo Consulting");
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'S')) {
					ModernizedCProgram.size_check = !ModernizedCProgram.size_check;
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3252), ModernizedCProgram.size_check);
					ModernizedCProgram.GetDevices(0);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'T')) {
					ModernizedCProgram.preserve_timestamps = !ModernizedCProgram.preserve_timestamps;
					ModernizedCProgram.WriteSettingBool("PreserveTimestamps", ModernizedCProgram.preserve_timestamps);
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3269), ModernizedCProgram.preserve_timestamps);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'U')) {
					ModernizedCProgram.use_fake_units = !ModernizedCProgram.use_fake_units;
					ModernizedCProgram.WriteSettingBool("UseProperSizeUnits", !ModernizedCProgram.use_fake_units);
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3263), !ModernizedCProgram.use_fake_units);
					ModernizedCProgram.GetDevices(0);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'V')) {
					ModernizedCProgram.use_vds = !ModernizedCProgram.use_vds;
					ModernizedCProgram.WriteSettingBool("UseVds", ModernizedCProgram.use_vds);
					ModernizedCProgram.PrintStatusTimeout("VDS", ModernizedCProgram.use_vds);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'W')) {
					ModernizedCProgram.enable_vmdk = !ModernizedCProgram.enable_vmdk;
					ModernizedCProgram.WriteSettingBool("EnableVmdkDetection", ModernizedCProgram.enable_vmdk);
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3265), ModernizedCProgram.enable_vmdk);
					ModernizedCProgram.GetDevices(0);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'X')) {
					ModernizedCProgram.PrintStatusInfo(0, 0, 2000, 3255);
					ModernizedCProgram.existing_key = 0;
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'Y')) {
					ModernizedCProgram.force_update = (ModernizedCProgram.force_update > 0) ? 0 : 1;
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3259), ModernizedCProgram.force_update);
					continue;
				} 
				if ((generatedMessage == 260) && (generatedWParam == (byte)'Z')) {
					ModernizedCProgram.zero_drive = 1;
					ModernizedCProgram.fast_zeroing = 0;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(hDlg, 273, (WPARAM)1003, 0);
					continue;
				} 
				if ((generatedMessage == 256) && (generatedWParam == (byte)'Z') && (/*Error: Function owner not recognized*/GetKeyState(17) & -1024) && (/*Error: Function owner not recognized*/GetKeyState(18) & -1024)) {
					ModernizedCProgram.zero_drive = 1;
					ModernizedCProgram.fast_zeroing = 1;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(hDlg, 273, (WPARAM)1003, 0);
					continue;
				} 
				if ((generatedMessage == 256) && (generatedWParam == (byte)'F') && (/*Error: Function owner not recognized*/GetKeyState(17) & -1024) && (/*Error: Function owner not recognized*/GetKeyState(18) & -1024)) {
					ModernizedCProgram.list_non_usb_removable_drives = !ModernizedCProgram.list_non_usb_removable_drives;
					if (ModernizedCProgram.list_non_usb_removable_drives) {
						previous_enable_HDDs = ModernizedCProgram.enable_HDDs;
						ModernizedCProgram.enable_HDDs = 1;
					} else {
							ModernizedCProgram.enable_HDDs = previous_enable_HDDs;
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CheckDlgButton(ModernizedCProgram.hMainDialog, 1022, ModernizedCProgram.enable_HDDs ? 1 : 0);
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3287), ModernizedCProgram.list_non_usb_removable_drives);
					ModernizedCProgram._uprintf("%sListing of non-USB removable drives %s", (ModernizedCProgram.list_non_usb_removable_drives) ? "CAUTION: " : "", (ModernizedCProgram.list_non_usb_removable_drives) ? "enabled" : "disabled");
					if (ModernizedCProgram.list_non_usb_removable_drives) {
						ModernizedCProgram._uprintf("By using this unofficial cheat mode you forfeit ANY RIGHT to complain if you lose valuable data!");
					} 
					ModernizedCProgram.GetDevices(0);
					continue;
				} 
				if ((generatedMessage == 256) && (generatedWParam == (byte)'Y') && (/*Error: Function owner not recognized*/GetKeyState(17) & -1024) && (/*Error: Function owner not recognized*/GetKeyState(18) & -1024)) {
					ModernizedCProgram.force_update = (ModernizedCProgram.force_update > 0) ? 0 : 2;
					ModernizedCProgram.PrintStatusTimeout(ModernizedCProgram.lmprintf(3259), ModernizedCProgram.force_update);
					continue;
				} 
			} 
			if (alt_pressed && !(/*Error: Function owner not recognized*/GetKeyState(18) & -1024)) {
				alt_pressed = 0;
				if (!alt_command) {
					ModernizedCProgram.update_progress_type = (ModernizedCProgram.update_progress_type + 1) % update_progress_type.UPT_MAX;
				} 
				alt_command = 0;
			} 
			if (!/*Error: Function owner not recognized*/IsDialogMessageA(hDlg, msg) && !/*Error: Function owner not recognized*/IsDialogMessageA(ModernizedCProgram.hLogDialog, msg)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/TranslateMessage(msg);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DispatchMessageA(msg);
			} 
		}
		if (ModernizedCProgram.hFidoDlg != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hFidoDlg, 16, 0, 0);
		} 
		if (ModernizedCProgram.relaunch) {
			ModernizedCProgram.relaunch = 0;
			do {
				ModernizedCProgram._exit_localization(1);
				ModernizedCProgram._init_localization(1);
			} while (0);
			;
		} 
		// Kill the update check thread if runningif (ModernizedCProgram.update_check_thread != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/TerminateThread(ModernizedCProgram.update_check_thread, 1);
		} 
		if ((!external_loc_file) && (loc_file[0] != 0)) {
			ModernizedCProgram.DeleteFileU(loc_file);
		} 
		ModernizedCProgram.DestroyAllTooltips();
		ModernizedCProgram.ClrAlertPromptHook();
		ModernizedCProgram._exit_localization(0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.image_path);
			ModernizedCProgram.image_path = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)locale_name);
			locale_name = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.update.getDownload_url());
			ModernizedCProgram.update.setDownload_url(((Object)0));
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.update.getRelease_notes());
			ModernizedCProgram.update.setRelease_notes(((Object)0));
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.grub2_buf);
			ModernizedCProgram.grub2_buf = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.fido_url);
			ModernizedCProgram.fido_url = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.fido_script);
			ModernizedCProgram.fido_script = ((Object)0);
		} while (0);
		if (argv != ((Object)0)) {
			for (i = 0; i < argc; i++) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)argv[i]);
					argv[i] = ((Object)0);
				} while (0);
			}
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)argv);
				argv = ((Object)0);
			} while (0);
		} 
		if (lgp_set) {
			ModernizedCProgram.SetLGP(1, ModernizedCProgram.existing_key, ModernizedCProgram.ep_reg, "NoDriveTypeAutorun", 0);
		} 
		if ((!automount) && (!ModernizedCProgram.SetAutoMount(0))) {
			ModernizedCProgram._uprintf("Failed to restore AutoMount to disabled");
		} 
		do {
			if (ModernizedCProgram.ubuffer_pos) {
				ModernizedCProgram._uprintf("%s", ModernizedCProgram.ubuffer);
			} 
			ModernizedCProgram.ubuffer_pos = 0;
		} while (0);// Unconditional delete with retry, just in case...
		for (i = 0; (!/*Error: Function owner not recognized*/DeleteFileA(ModernizedCProgram.cmdline_hogger)) && (i <= 10); i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(200);
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(mutex);
		while (ModernizedCProgram.OpenedLibrariesHandleSize > 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/FreeLibrary(ModernizedCProgram.OpenedLibrariesHandle[--ModernizedCProgram.OpenedLibrariesHandleSize]);
		}
		if (attached_console) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(/*Error: Function owner not recognized*/GetConsoleWindow(), ((HWND)0), 0, 0, 0, 0, -1024 | -1024);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/FreeConsole();
		} 
		ModernizedCProgram._uprintf("*** Rufus exit ***\n");
		return 0;
	}
	// Buffer for ubpushf() messages we don't log right away
	public static void _uprintf(Object format) {
		byte[] buf = new byte[4096];
		byte p = buf;
		wchar_t wbuf = new wchar_t();
		va_list args = new va_list();
		int n;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(args, format);
		// buf-3 is room for CR/LF/NUL// buf-3 is room for CR/LF/NULn = /*Error: Function owner not recognized*/vsnprintf(p, /*Error: sizeof expression not supported yet*/ - 3, format, args);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(args);
		p += (n < 0) ? /*Error: sizeof expression not supported yet*/ - 3 : n;
		while ((p > buf) && (/*Error: Function owner not recognized*/isspace((byte)(p[-1])))) {
			--p = (byte)'\0';
		}
		p++ = (byte)'\r';
		p++ = (byte)'\n';
		p = (byte)'\0';
		// Yay, Windows 10 *FINALLY* added actual Unicode support for OutputDebugStringW()!// Yay, Windows 10 *FINALLY* added actual Unicode support for OutputDebugStringW()!wbuf = ModernizedCProgram.utf8_to_wchar(buf)// Send output to Windows debug facility;// Send output to Windows debug facility
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/OutputDebugStringW(wbuf);
		if ((ModernizedCProgram.hLog != ((Object)0)) && (ModernizedCProgram.hLog != (HANDLE)(true))) {
			((Object)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hLog), 177, (true), (true)));
			((Object)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hLog), 194, 0, (LPARAM)(LPCTSTR)(wbuf)));
			((Object)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hLog), 182, (WPARAM)(false), (LPARAM)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hLog), 186, 0, 0)))));
		} 
		// Send output to our log Window
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(wbuf);
	}
	public static void _uprintfs(Object str) {
		wchar_t wstr = new wchar_t();
		wstr = ModernizedCProgram.utf8_to_wchar(str);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/OutputDebugStringW(wstr);
		if ((ModernizedCProgram.hLog != ((Object)0)) && (ModernizedCProgram.hLog != (HANDLE)(true))) {
			((Object)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hLog), 177, (true), (true)));
			((Object)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hLog), 194, 0, (LPARAM)(LPCTSTR)(wstr)));
			((Object)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hLog), 182, (WPARAM)(false), (LPARAM)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hLog), 186, 0, 0)))));
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(wstr);
	}
	// Prints a bitstring of a number of any size, with or without leading zeroes.
	// See also the printbits() and printbitslz() helper macros in rufus.h
	public static Byte _printbits(Object size, Object ptr, int leading_zeroes) {
		// sizeof(uintmax_t) so that we have enough space to store whatever is thrown at usbyte[] str = new byte[/*Error: Unsupported expression*/ * 8 + 3];
		size_t i = new size_t();
		uint8_t b = (uint8_t)ptr;
		uintmax_t mask = new uintmax_t();
		uintmax_t lzmask = 0;
		uintmax_t val = 0;
		// Little endian, the SCOURGE of any rational computingfor (i = 0; i < size; i++) {
			val |=  ((uintmax_t)b[i]) << (8 * i);
		}
		str[0] = (byte)'0';
		str[1] = (byte)'b';
		if (leading_zeroes) {
			lzmask = -1024 << (size * 8 - 1);
		} 
		for (; mask != 0; mask >>=  1) {
			if ((i > 2) || (lzmask & mask)) {
				str[i++] = (val & mask) ? (byte)'1' : (byte)'0';
			}  else if (val & mask) {
				str[i++] = (byte)'1';
			} 
		}
		str[i] = (byte)'\0';
		return str;
	}
	// Display an hex dump of buffer 'buf'
	public static void DumpBufferHex(Object buf, Object size) {
		byte buffer = (byte)buf;
		size_t i = new size_t();
		size_t j = new size_t();
		size_t k = new size_t();
		byte[] line = "";
		for (i = 0; i < size; i += 16) {
			if (i != 0) {
				ModernizedCProgram._uprintf("%s\n", line);
			} 
			line[0] = 0;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/sprintf(line[/*Error: Function owner not recognized*/strlen(line)], "  %08x  ", (int)i);
			for (; k < 16; ) {
				if (i + j < size) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/sprintf(line[/*Error: Function owner not recognized*/strlen(line)], "%02x", buffer[i + j]);
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/sprintf(line[/*Error: Function owner not recognized*/strlen(line)], "  ");
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/sprintf(line[/*Error: Function owner not recognized*/strlen(line)], " ");
			}
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/sprintf(line[/*Error: Function owner not recognized*/strlen(line)], " ");
			for (; k < 16; ) {
				if (i + j < size) {
					if ((buffer[i + j] < 32) || (buffer[i + j] > 126)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/sprintf(line[/*Error: Function owner not recognized*/strlen(line)], ".");
					} else {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/sprintf(line[/*Error: Function owner not recognized*/strlen(line)], "%c", buffer[i + j]);
					} 
				} 
			}
		}
		ModernizedCProgram._uprintf("%s\n", line)// Count on Microsoft to add a new API while not bothering updating the existing error facilities,// so that the new error messages have to be handled manually. Now, since I don't have all day:;// Count on Microsoft to add a new API while not bothering updating the existing error facilities,// so that the new error messages have to be handled manually. Now, since I don't have all day:
	}
	// 1. Copy text from https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-vds/5102cc53-3143-4268-ba4c-6ea39e999ab4
	// 2. awk '{l[NR%7]=$0} {if (NR%7==0) printf "\tcase %s:\t// %s\n\t\treturn \"%s\";\n", l[1], l[3], l[6]}' vds.txt
	// 3. Filter out the crap we don't need.
	public static Object GetVdsError(Object error_code) {
		switch (error_code) {
		case -1024:
				return "The operation can no longer be canceled.";
		case -1024:
				return "The cookie was not found.";
		case -1024:
				return "No disks were found on the target machine.";
		case -1024:
				return "The media is write-protected.";
		case -1024:
				return "The volume is already dismounted temporarily.";
		case -1024:
				return "The operation timed out.";
		case -1024:
				return "The PNP service sent a corrupted notification to the provider.";
		case -1024:
				return "Failed to dismount/remount the volume after setting the volume flags.";
		case -1024:
		case -1024:
				return "No extents were found for the volume.";
		case -1024:
				return "The volume type is invalid for this operation.";
		case -1024:
				return "Only the first 2TB are usable on large MBR disks.";
		case -1024:
		case -1024:
				return "The cluster size is too small.";
		case -1024:
				return "A partition with an unknown type was detected on the specified disk.";
		case -1024:
				return "Delete is not allowed on a critical volume.";
		case -1024:
		case -1024:
				return "The FORCE parameter MUST be set to TRUE in order to clean a disk that contains a data or OEM volume.";
		case -1024:
				return "Clean is not allowed on a critical disk.";
		case -1024:
				return "The object already exists.";
		case -1024:
				return "This disk is already online.";
		case -1024:
				return "There are no software providers loaded.";
		case -1024:
				return "The disk is not missing.";
		case -1024:
				return "Failed to obtain a file system lock.";
		case -1024:
				return "The specified name is not unique.";
		case -1024:
				return "The disk contains partitions or volumes.";
		case -1024:
				return "Failure initializing the asynchronous object.";
		case -1024:
				return "The specified disk could not be found.";
		case -1024:
				return "The specified partition style is not the same as the disk's partition style.";
		case -1024:
				return "An internal error has occurred in the provider.";
		case -1024:
				return "The specified service flag is invalid.";
		case -1024:
				return "There is not enough space to complete the operation.";
		case -1024:
				return "The provider does not support the VDS_VF_NO DRIVELETTER volume flag.";
		case -1024:
				return "The provider failed to connect to the LDMA service.";
		case -1024:
		case -1024:
				return "Multiple disk extents reported for the system volume - system error.";
		case -1024:
				return "The driver returned an invalid parameter error.";
		case -1024:
				return "The specified path was not found.";
		case -1024:
				return "The specified partition type cannot be created with a non-zero alignment.";
		case -1024:
				return "The volume does not have a retained partition association.";
		case -1024:
				return "The boot partition's partition number will change as a result of the operation.";
		case -1024:
				return "The volume cannot be dismounted permanently because it still has an access path.";
		case -1024:
				return "The volume is already permanently dismounted.";
		case -1024:
				return "The device is currently in use.";
		case -1024:
				return "The pack was not found.";
		case -1024:
				return "The volume already has a retained partition association.";
		case -1024:
				return "The service's cache has become corrupt.";
		case -1024:
				return "The operation was successful, but VDS failed to update the boot options.";
		case -1024:
				return "The operation is not permitted on the specified disk, partition, or volume.";
		case -1024:
		case -1024:
				return "The provider encountered errors while loading the cache.";
		case -1024:
				return "An internal error occurred in the volume management driver.";
		case -1024:
				return "The volume label is not valid.";
		case -1024:
				return "The specified extent size is too small.";
		case -1024:
				return "The disk layout contains partitions which are less than the minimum required size.";
		case -1024:
				return "The operation is not supported on this type of partitions.";
		case -1024:
				return "The specified volume flag is invalid.";
		case -1024:
				return "A reboot is required before any further operations are initiated.";
		case -1024:
				return "The specified provider version string is invalid.";
		case -1024:
				return "The operation is only supported on an OEM, ESP, or unknown partition.";
		case -1024:
				return "A provider returned bad data.";
		case -1024:
				return "The object already exists.";
		case -1024:
				return "The specified provider type is invalid.";
		case -1024:
		case -1024:
				return "The I/O to the disk is failing.";
		case -1024:
				return "The volume length is invalid.";
		case -1024:
				return "The provider returned a NULL subsystem identification string.";
		case -1024:
				return "No disk/volume removal notification was received.";
		case -1024:
				return "Some, but not all, of the properties were successfully retrieved.";
		case -1024:
				return "The file system does not support extending this volume.";
		case -1024:
				return "The volume length is not a multiple of the sector size.";
		case -1024:
				return "The cache for a provider is corrupt.";
		case -1024:
				return "The volume's driver information is corrupted.";
		case -1024:
				return "No disk/volume arrival notification was received.";
		case -1024:
				return "The operation is not supported by the object.";
		case -1024:
				return "VDS or the provider failed to initialize.";
		case -1024:
				return "The flags to be cleared do not match the flags that were set previously.";
		case -1024:
				return "The provider is exiting.";
		case -1024:
				return "Assigning or removing drive letters on the current boot or pagefile volume is not allowed.";
		case -1024:
				return "Failed to open the volume device";
		case -1024:
				return "The specified disk has not been initialized.";
		case -1024:
				return "The specified space is neither free nor valid.";
		case -1024:
				return "A concurrent second call is made on an object before the first call is completed.";
		case -1024:
				return "The pack is offline.";
		case -1024:
		case -1024:
				return "No more partitions can be created on the specified disk.";
		case -1024:
				return "The specified file system does not support compression.";
		case -1024:
				return "The operation failed. Retry the operation.";
		case -1024:
				return "The operation is still in progress.";
		case -1024:
		case -1024:
				return "The alignment is zero.";
		case -1024:
				return "The volume is not online.";
		case -1024:
				return "Disk attributes cannot be changed on the current system disk or BIOS disk 0.";
		case -1024:
				return "An active partition was detected on the selected disk.";
		case -1024:
				return "The provider's cache is not in sync with the driver cache.";
		case -1024:
				return "Cannot set the specified flag as revert-on-close because it is already set.";
		case -1024:
				return "The asynchronous operation is in progress.";
		case -1024:
				return "An unexpected layout change occurred external to the volume manager.";
		case -1024:
				return "The volume is not a mirror.";
		case -1024:
				return "Volume GUID pathnames are not valid input to this method.";
		case -1024:
				return "The cluster size is too large.";
		case -1024:
				return "The provider is already registered.";
		case -1024:
				return "The specified drive letter is not free to be assigned.";
		case -1024:
				return "VDS only supports MBR or GPT partition style disks.";
		case -1024:
				return "The migrated disk failed to load to the cache.";
		case -1024:
				return "The offline operation failed.";
		case -1024:
				return "The disk's partition information does not conform to what is expected on a dynamic disk.";
		case -1024:
				return "The boot entries cannot be updated automatically on WinPE.";
		case -1024:
				return "A system error occurred while retrieving the system disk information.";
		case -1024:
				return "A provider failed to complete an operation.";
		case -1024:
				return "The enumerator is corrupted";
		case -1024:
				return "The object was not found in the driver cache.";
		case -1024:
				return "The specified operation is not valid.";
		case -1024:
				return "The operation is not allowed on a disk that is in the process of being cleaned.";
		case -1024:
				return "The operation failed, because an online pack object already exists.";
		case -1024:
				return "The component that the object represents has failed.";
		case -1024:
				return "A NULL GUID was passed to the provider.";
		case -1024:
				return "The volume is read only.";
		case -1024:
				return "The specified provider name is invalid.";
		case -1024:
				return "A corrupt notification was sent from the LDMA service.";
		case -1024:
				return "One or more of the volumes on the disk could not be mounted/dismounted.";
		case -1024:
				return "There is no removable media in the drive.";
		case -1024:
				return "Cannot assign a mount point to a hidden volume.";
		case -1024:
				return "No volume arrival notification was received.";
		case -1024:
		case -1024:
				return "The volume size is too small.";
		case -1024:
				return "Disk attributes cannot be changed on the boot disk.";
		case -1024:
				return "The specified file system flag is not valid.";
		case -1024:
				return "The input volume id cannot be the id of the volume that is the target of the operation.";
		case -1024:
				return "The volume is failing or has failed.";
		case -1024:
				return "VDS did not call the hardware provider's initialization method.";
		case -1024:
				return "The provider failed to initialize.";
		case -1024:
				return "The volume is incomplete.";
		case -1024:
				return "The sector size MUST be non-zero, a power of 2, and less than the maximum sector size.";
		case -1024:
				return "The media is incompatible with the specified operation.";
		case -1024:
				return "The operation has already been canceled.";
		case -1024:
				return "The requested file system format is not supported on this volume.";
		case -1024:
				return "One or more extents of the disk are already being used by the volume.";
		case -1024:
				return "The partition information cannot be read.";
		case -1024:
				return "The alignment is not a power of two.";
		case -1024:
				return "The specified object type is not valid.";
		case -1024:
				return "The specified partition type is not valid for this operation.";
		case -1024:
				return "The volume is not formattable.";
		case -1024:
				return "The specified disk is not valid.";
		case -1024:
				return "The disk layout contains partitions which are not cylinder aligned.";
		case -1024:
				return "The specified number of drive letters to retrieve is not valid.";
		case -1024:
		case -1024:
				return "The specified volume flag cannot be cleared.";
		case -1024:
				return "The operation is not supported on a non-empty removable disk.";
		case -1024:
				return "The default file system could not be determined.";
		case -1024:
				return "The operation timed out in the LDMA service. Retry the operation.";
		case -1024:
				return "The volume does not consist of a single disk extent.";
		case -1024:
				return "Unable to retrieve the GPT attributes for this volume.";
		case -1024:
				return "Volume disk extent information could not be retrieved for the boot volume.";
		case -1024:
				return "The specified alignment is not a multiple of the sector size.";
		case -1024:
				return "The clean operation was not a full clean or was canceled before it could be completed.";
		case -1024:
				return "Invalid GPT attributes were specified.";
		case -1024:
				return "An unrecoverable error occurred. The service MUST shut down.";
		case -1024:
		case -1024:
				return "A method call to the LDMA service failed.";
		case -1024:
				return "Access is denied. A VDS operation MUST run elevated.";
		case -1024:
				return "Warning: There was a failure while checking for the system partition.";
		case -1024:
		case -1024:
				return "Cannot delete a protected partition without the force protected parameter set.";
		case -1024:
				return "The specified object was not found.";
		case -1024:
				return "The specified disk is not an unallocated disk.";
		case -1024:
				return "The disk's partition information is corrupted.";
		case -1024:
				return "The volume cannot be quick-formatted.";
		case -1024:
				return "This operation is not allowed on disks with volumes.";
		case -1024:
				return "The specified query provider flag is invalid.";
		case -1024:
				return "The specified disk pack is not valid.";
		case -1024:
				return "The online operation failed.";
		case -1024:
				return "The object no longer exists.";
		case -1024:
		case -1024:
				return "The number of clusters is too large to be represented as a 32-bit integer.";
		case -1024:
				return "The specified alignment is beyond the first cylinder.";
		case -1024:
				return "The operation is only supported on simple or spanned volumes.";
		case -1024:
				return "The file system was formatted successfully but could not be compressed.";
		case -1024:
				return "The file system is incompatible with the specified operation.";
		case -1024:
				return "The specified disk does not have enough free space to complete the operation.";
		case -1024:
				return "Format is not allowed on a critical volume.";
		case -1024:
				return "The disk's path could not be retrieved. Some operations on the disk might fail.";
		case -1024:
				return "No import target was set for the subsystem.";
		case -1024:
				return "The volume's layout could not be retrieved.";
		case -1024:
				return "The disk is missing and not all information could be returned.";
		case -1024:
				return "One or more of the specified disks are not online.";
		case -1024:
				return "The volume is not mounted.";
		case -1024:
				return "The name was set successfully but had to be truncated.";
		case -1024:
				return "This operation is not supported on a mirrored volume.";
		case -1024:
				return "An unrecoverable error occurred in the provider.";
		case -1024:
				return "The device form of the volume pathname could not be retrieved.";
		case -1024:
				return "The volume size is too large.";
		case -1024:
				return "The specified drive letter is not valid.";
		case -1024:
				return "The specified partition layout is invalid.";
		case -1024:
				return "An I/O error occurred during the operation.";
		case -1024:
				return "The method call is not supported for the specified provider type.";
		case -1024:
				return "The operation is not supported on removable media.";
		case -1024:
				return "A volume on the specified disk could not be opened.";
		case -1024:
				return "The volume name is not valid.";
		case -1024:
				return "The reference to the object might be stale.";
		case -1024:
				return "The operation cannot be performed on a disk that is offline or read-only.";
		case -1024:
				return "VDS encountered an internal error.";
		case -1024:
				return "The volume spans multiple disks.";
		case -1024:
				return "The disk's extent information is corrupted.";
		case -1024:
				return "The extended partition is not empty.";
		case -1024:
		case -1024:
				return "There are not enough free disk drives in the subsystem to complete the operation.";
		case -1024:
				return "The path could not be retrieved for one or more volumes.";
		case -1024:
				return "The operation could not be completed because the specified revision number is not supported.";
		case -1024:
				return "The specified file system is not valid.";
		case -1024:
				return "Some volume flags are already set.";
		case -1024:
				return "The provider's list of PnP registered disks has become corrupted.";
		case -1024:
				return "The operation cannot be performed on a disk that contains a pagefile, hibernation or crashdump volume.";
		default:
				return ((Object)0);
		}
	}
	// Convert a windows error to human readable string
	public static Object WindowsErrorString() {
		byte[] err_string = new byte[]{0};
		DWORD size = new DWORD();
		DWORD presize = new DWORD();
		DWORD error_code = new DWORD();
		DWORD format_error = new DWORD();
		error_code = /*Error: Function owner not recognized*/GetLastError()// Check for VDS error codes;// Check for VDS error codes
		if (((((error_code) >> 16) & -1024) == 4) && (ModernizedCProgram.GetVdsError(error_code) != ((Object)0))) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(err_string, /*Error: sizeof expression not supported yet*/, "[0x%08lX] %s", error_code, ModernizedCProgram.GetVdsError(error_code));
				(err_string)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			return err_string;
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(err_string, /*Error: sizeof expression not supported yet*/, "[0x%08lX] ", error_code);
			(err_string)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		presize = (DWORD)/*Error: Function owner not recognized*/strlen(err_string);
		size = ModernizedCProgram.FormatMessageU(4096 | 512, ((Object)0), ((error_code) & -1024), ((((WORD)(true)) << 10) | (WORD)(true)), err_string[presize], /*Error: sizeof expression not supported yet*/ - (DWORD)/*Error: Function owner not recognized*/strlen(err_string), ((Object)0));
		if (size == 0) {
			format_error = /*Error: Function owner not recognized*/GetLastError();
			if ((format_error) && (format_error != -1024)) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(err_string, /*Error: sizeof expression not supported yet*/, "Windows error code 0x%08lX (FormatMessage error code 0x%08lX)", error_code, format_error);
					(err_string)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
			} else {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(err_string, /*Error: sizeof expression not supported yet*/, "Unknown error 0x%08lX", error_code);
						(err_string)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
			} 
		} else {
				((presize > 2) ? (Object)0 : /*Error: Function owner not recognized*/_assert("presize > 2", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\stdio.c", 611));
				size += presize - 2;
				while ((err_string[size] == -1024) || (err_string[size] == -1024) || (err_string[size] == -1024)) {
					err_string[size--] = 0;
				}
		} 
		/*Error: Function owner not recognized*/// Make sure we don't change the errorcode on exit/*Error: Function owner not recognized*/// Make sure we don't change the errorcode on exitSetLastError(error_code);
		return err_string;
	}
	public static Byte GuidToString(Object guid) {
		byte[] guid_string = new byte[40];
		if (guid == ((Object)0)) {
			return ((Object)0);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/sprintf(guid_string, "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", (int)guid.getData1(), guid.getData2(), guid.getData3(), guid.getData4()[0], guid.getData4()[1], guid.getData4()[2], guid.getData4()[3], guid.getData4()[4], guid.getData4()[5], guid.getData4()[6], guid.getData4()[7]);
		return guid_string;
	}
	// Find upper power of 2
	public static Object upo2(Object v) {
		v--;
		v |=  v >> 1;
		v |=  v >> 2;
		v |=  v >> 4;
		v |=  v >> 8;
		v++;
		return v;
	}
	// Convert a size to human readable
	public static Byte SizeToHumanReadable(Object size, Object copy_to_log, Object fake_units) {
		int suffix;
		byte[] str_size = new byte[32];
		byte dir = ((ModernizedCProgram.right_to_left_mode) && (!copy_to_log)) ? "â" : "";
		double hr_size = (double)size;
		double t;
		uint16_t i_size = new uint16_t();
		byte _msg_table = copy_to_log ? ModernizedCProgram.default_msg_table : ModernizedCProgram.msg_table;
		double divider = fake_units ? 1000.0 : 1024.0;
		for (suffix = 0; suffix < 6 - 1; suffix++) {
			if (hr_size < divider) {
				break;
			} 
			hr_size /= divider;
		}
		if (suffix == 0) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(str_size, /*Error: sizeof expression not supported yet*/, "%s%d%s %s", dir, (int)hr_size, dir, _msg_table[3020 - 3000]);
				(str_size)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
		}  else if (fake_units) {
			if (hr_size < 8) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(str_size, /*Error: sizeof expression not supported yet*/, (/*Error: Function owner not recognized*/fabs((hr_size * 10.0) - (/*Error: Function owner not recognized*/floor(hr_size + 0.5) * 10.0)) < 0.5) ? "%0.0f%s" : "%0.1f%s", hr_size, _msg_table[3020 + suffix - 3000]);
					(str_size)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
			} else {
					t = (double)ModernizedCProgram.upo2((uint16_t)hr_size);
					i_size = (uint16_t)((/*Error: Function owner not recognized*/fabs(1.0 - (hr_size / t)) < 0.05) ? t : hr_size);
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(str_size, /*Error: sizeof expression not supported yet*/, "%s%d%s %s", dir, i_size, dir, _msg_table[3020 + suffix - 3000]);
						(str_size)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
			} 
		} else {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(str_size, /*Error: sizeof expression not supported yet*/, (hr_size * 10.0 - (/*Error: Function owner not recognized*/floor(hr_size) * 10.0)) < 0.5 ? "%s%0.0f%s %s" : "%s%0.1f%s %s", dir, hr_size, dir, _msg_table[3020 + suffix - 3000]);
					(str_size)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
		} 
		return str_size;
	}
	// Convert a YYYYMMDDHHMMSS UTC timestamp to a more human readable version
	public static Byte TimestampToHumanReadable(Object ts) {
		uint64_t rem = ts;
		uint64_t divisor = -1024;
		uint16_t[] data = new uint16_t();
		int i;
		byte[] str = new byte[64];
		for (i = 0; i < 6; i++) {
			data[i] = (uint16_t)((divisor == 0) ? rem : (rem / divisor));
			rem %= divisor;
			divisor /= -1024;
		}
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(str, /*Error: sizeof expression not supported yet*/, "%04d.%02d.%02d %02d:%02d:%02d (UTC)", data[0], data[1], data[2], data[3], data[4], data[5]);
			(str)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		return str;
	}
	// Convert custom error code to messages
	public static Object _StrError(Object error_code) {
		if ((!((long)(error_code) >> 31 == 1)) || (((error_code) & -1024) == -1024)) {
			return ModernizedCProgram.lmprintf(3050);
		} 
		if ((((error_code) >> 16) & -1024) != 3) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(error_code);
			return ModernizedCProgram.WindowsErrorString();
		} 
		switch (((error_code) & -1024)) {
		case -1024:
				return ModernizedCProgram.lmprintf(3075);
		case -1024:
				return ModernizedCProgram.lmprintf(3076);
		case -1024:
				return ModernizedCProgram.lmprintf(3077);
		case -1024:
				return ModernizedCProgram.lmprintf(3066);
		case -1024:
				return ModernizedCProgram.lmprintf(3056);
		case -1024:
				return ModernizedCProgram.lmprintf(3065);
		case -1024:
				return ModernizedCProgram.lmprintf(3069);
		case -1024:
				return ModernizedCProgram.lmprintf(3172);
		case -1024:
				return ModernizedCProgram.lmprintf(3052);
		case -1024:
				return ModernizedCProgram.lmprintf(3063);
		case -1024:
				return ModernizedCProgram.lmprintf(3070);
		case -1024:
				return ModernizedCProgram.lmprintf(3057);
		case -1024:
				return ModernizedCProgram.lmprintf(3067);
		case -1024:
				return ModernizedCProgram.lmprintf(3072);
		case -1024:
				return ModernizedCProgram.lmprintf(3054);
		case -1024:
				return ModernizedCProgram.lmprintf(3051);
		case -1024:
				return ModernizedCProgram.lmprintf(3058);
		case -1024:
				return ModernizedCProgram.lmprintf(3064);
		case -1024:
				return ModernizedCProgram.lmprintf(3071);
		case -1024:
				return ModernizedCProgram.lmprintf(3061);
		case -1024:
				return ModernizedCProgram.lmprintf(3055);
		case -1024:
				return ModernizedCProgram.lmprintf(3079);
		case -1024:
				return ModernizedCProgram.lmprintf(3053);
		case -1024:
				return ModernizedCProgram.lmprintf(3078);
		case -1024:
				return ModernizedCProgram.lmprintf(3060);
		case -1024:
				return ModernizedCProgram.lmprintf(3062);
		case -1024:
				return ModernizedCProgram.lmprintf(3073);
		case -1024:
				return ModernizedCProgram.lmprintf(3059);
		case -1024:
				return ModernizedCProgram.lmprintf(3074);
		case -1024:
				return ModernizedCProgram.lmprintf(3068);
		default:
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(error_code);
				return ModernizedCProgram.WindowsErrorString();
		}
	}
	public static Object StrError(Object error_code, Object use_default_locale) {
		byte ret;
		if (use_default_locale) {
			ModernizedCProgram.toggle_default_locale();
		} 
		ret = ModernizedCProgram._StrError(error_code);
		if (use_default_locale) {
			ModernizedCProgram.toggle_default_locale();
		} 
		return ret;
	}
	// A WriteFile() equivalent, with up to nNumRetries write attempts on error.
	public static Object WriteFileWithRetry(Object hFile, Object lpBuffer, Object nNumberOfBytesToWrite, Object lpNumberOfBytesWritten, Object nNumRetries) {
		DWORD nTry = new DWORD();
		BOOL readFilePointer = new BOOL();
		LARGE_INTEGER liFilePointer = new LARGE_INTEGER();
		LARGE_INTEGER liZero = new LARGE_INTEGER(new LARGE_INTEGER(0, 0));
		// Need to get the current file pointer in case we need to retry// Need to get the current file pointer in case we need to retryreadFilePointer = /*Error: Function owner not recognized*/SetFilePointerEx(hFile, liZero, liFilePointer, 1);
		if (!readFilePointer) {
			ModernizedCProgram._uprintf("Warning: Could not read file pointer %s", ModernizedCProgram.WindowsErrorString());
		} 
		if (nNumRetries == 0) {
			nNumRetries = 1;
		} 
		for (nTry = 1; nTry <= nNumRetries; nTry++) {
			if ((nTry > 1) && (!/*Error: Function owner not recognized*/SetFilePointerEx(hFile, liFilePointer, ((Object)0), 0))) {
				ModernizedCProgram._uprintf("Could not set file pointer - Aborting");
				break;
			} 
			if (/*Error: Function owner not recognized*/WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, ((Object)0))) {
				ModernizedCProgram.LastWriteError = 0;
				if (nNumberOfBytesToWrite == lpNumberOfBytesWritten) {
					return 1;
				} 
				if (ModernizedCProgram.large_drive && (lpNumberOfBytesWritten == 0)) {
					ModernizedCProgram._uprintf("Warning: Possible short write");
					return 1;
				} 
				ModernizedCProgram._uprintf("Wrote %d bytes but requested %d", lpNumberOfBytesWritten, nNumberOfBytesToWrite);
			} else {
					ModernizedCProgram._uprintf("Write error %s", ModernizedCProgram.WindowsErrorString());
					ModernizedCProgram.LastWriteError = -1024 | (3 << 16) | /*Error: Function owner not recognized*/GetLastError();
			} 
			if (!readFilePointer) {
				break;
			} 
			if (nTry < nNumRetries) {
				ModernizedCProgram._uprintf("Retrying in %d seconds...", 5000 / 1000);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(ModernizedCProgram.CheckDriveAccess(5000, 0));
			} 
		}// Need to rewind our file position on retry - if we can't even do that, just give up
		if (((/*Error: Function owner not recognized*/GetLastError()) & -1024) == -1024) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(-1024 | (3 << 16) | -1024);
		} 
		return 0;
	}
	// A WaitForSingleObject() equivalent that doesn't block Windows messages
	// This is needed, for instance, if you are waiting for a thread that may issue uprintf's
	public static Object WaitForSingleObjectWithMessages(Object hHandle, Object dwMilliseconds) {
		uint64_t CurTime = new uint64_t();
		uint64_t EndTime = /*Error: Function owner not recognized*/GetTickCount64() + dwMilliseconds;
		DWORD res = new DWORD();
		MSG msg = new MSG();
		Object generatedMessage = msg.getMessage();
		do {
			while (/*Error: Function owner not recognized*/PeekMessageA(msg, ((Object)0), 0, 0, 1)) {
				if ((generatedMessage == 18) || (generatedMessage == 16)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(-1024);
					return ((DWORD)-1024);
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DispatchMessageA(msg);
				} 
			}
			res = /*Error: Function owner not recognized*/MsgWaitForMultipleObjects(1, hHandle, 0, dwMilliseconds, 255);
			if (dwMilliseconds != -1024) {
				CurTime = /*Error: Function owner not recognized*/GetTickCount64();
				if (CurTime < EndTime) {
					dwMilliseconds = (DWORD)(EndTime - CurTime);
				} else {
						res = -1024;
				} 
			} 
		} while (res == (0 + 1));// Read all of the messages in this next loop, removing each message as we read it.
		return res;
	}
	public static Object ext2fs_djb2_hash(Object str, Object size) {
		int c;
		byte s = str;
		uint32_t hash = 5381;
		while (size-- > 0) {
			c = s++;
			hash = ((hash << 5) + hash) + c;
		}
		return hash;
	}
	public static Object ext2fs_hashmap_iter_in_order(ext2fs_hashmap h, ext2fs_hashmap_entry it) {
		ext2fs_hashmap_entry generatedList_next = (it).getList_next();
		ext2fs_hashmap_entry generatedFirst = h.getFirst();
		it = it ? generatedList_next : generatedFirst;
		Object generatedData = (it).getData();
		return it ? generatedData : ((Object)0);
	}
	public static Object xrealloc(Object ptr, Object size) {
		Object ret = /*Error: Function owner not recognized*/realloc(ptr, size);
		if (!ret) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(ptr);
		} 
		return ret;
	}
	public static int link(Object oldpath, Object newpath) {
		(/*Error: Function owner not recognized*/_errno()) = 40;
		return -1;
	}
	public static int symlink(Object oldpath, Object newpath) {
		(/*Error: Function owner not recognized*/_errno()) = 40;
		return -1;
	}
	public static int chown(Object path, Object owner, Object group) {
		(/*Error: Function owner not recognized*/_errno()) = 40;
		return -1;
	}
	public static int mknod(Object pathname, Object mode, Object dev) {
		(/*Error: Function owner not recognized*/_errno()) = 40;
		return -1;
	}
	public static int utimes(Object filename, Object times) {
		(/*Error: Function owner not recognized*/_errno()) = 40;
		return -1;
	}
	public static int fnmatch(Object pattern, Object string, int flags) {
		return /*Error: Function owner not recognized*/PathMatchSpecA(string, pattern) ? 0 : 1;
	}
	public static Object wait(Integer status) {
		status = 4;
		return -1;
	}
	/* This override enables the display of a progress based on the number of bytes read */
	public static int full_read(int fd, Object buf, Object count) {
		int rb;
		if (fd < 0) {
			(/*Error: Function owner not recognized*/_errno()) = 9;
			return -1;
		} 
		if (buf == ((Object)0)) {
			(/*Error: Function owner not recognized*/_errno()) = 14;
			return -1;
		} 
		if ((ModernizedCProgram.bled_cancel_request != ((Object)0)) && (ModernizedCProgram.bled_cancel_request != 0)) {
			(/*Error: Function owner not recognized*/_errno()) = 4;
			return -1;
		} 
		if (fd == ModernizedCProgram.bb_virtual_fd) {
			if (ModernizedCProgram.bb_virtual_pos + count > ModernizedCProgram.bb_virtual_len) {
				count = ModernizedCProgram.bb_virtual_len - ModernizedCProgram.bb_virtual_pos;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(buf, ModernizedCProgram.bb_virtual_buf[ModernizedCProgram.bb_virtual_pos], count);
			ModernizedCProgram.bb_virtual_pos += count;
			rb = (int)count;
		} else {
				rb = /*Error: Function owner not recognized*/_read(fd, buf, (int)count);
		} 
		if (rb > 0) {
			ModernizedCProgram.bb_total_rb += rb;
			if (ModernizedCProgram.bled_progress != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_progress(ModernizedCProgram.bb_total_rb);
			} 
		} 
		return rb;
	}
	public static tm localtime_r(Object timep) {
		if (/*Error: Function owner not recognized*/localtime_s(result, timep) != 0) {
			result = ((Object)0);
		} 
		return result;
		tm tmp = /*Error: Function owner not recognized*/localtime(ModernizedCProgram.timer);
		if (tmp) {
			result = tmp;
			return result;
		} 
		return tmp;
	}
	/*
	 * crc32c.c
	 *
	 * August 26, 2011 Darrick J. Wong <djwong at us.ibm.com>
	 * Reuse Bob Pearson's slice-by-8 implementation for e2fsprogs.
	 *
	 * July 20, 2011 Bob Pearson <rpearson at systemfabricworks.com>
	 * added slice by 8 algorithm to the existing conventional and
	 * slice by 4 algorithms.
	 *
	 * Oct 15, 2000 Matt Domsch <Matt_Domsch@dell.com>
	 * Nicer crc32 functions/docs submitted by linux@horizon.com.  Thanks!
	 * Code was from the public domain, copyright abandoned.  Code was
	 * subsequently included in the kernel, thus was re-licensed under the
	 * GNU GPL v2.
	 *
	 * Oct 12, 2000 Matt Domsch <Matt_Domsch@dell.com>
	 * Same crc32 function was used in 5 other places in the kernel.
	 * I made one version, and deleted the others.
	 * There are various incantations of crc32().  Some use a seed of 0 or ~0.
	 * Some xor at the end with ~0.  The generic crc32() function takes
	 * seed as an argument, and doesn't xor at the end.  Then individual
	 * users can do whatever they need.
	 *   drivers/net/smc9194.c uses seed ~0, doesn't xor with ~0.
	 *   fs/jffs2 uses seed 0, doesn't xor with ~0.
	 *   fs/partitions/efi.c uses seed ~0, xor's with ~0.
	 *
	 * This source code is licensed under the GNU General Public License,
	 * Version 2.  See the file COPYING for more details.
	 */
	/* implements slicing-by-4 or slicing-by-8 algorithm */
	public static Object crc32_body(Object crc, Object buf, Object len, Object[] tab) {
		uint32_t b = new uint32_t();
		size_t rem_len = new size_t();
		uint32_t t0 = tab[0];
		uint32_t t1 = tab[1];
		uint32_t t2 = tab[2];
		uint32_t t3 = tab[3];
		uint32_t t4 = tab[4];
		uint32_t t5 = tab[5];
		uint32_t t6 = tab[6];
		uint32_t t7 = tab[7];
		uint32_t q = new uint32_t();
		if (/*Error: Function owner not recognized*/__builtin_expect(!!((uintptr_t)buf & 3 && len), /* Align it */0)) {
			do {
				(crc = t0[(crc ^ (buf++)) & 255] ^ (crc >> 8));
			} while ((--len) && ((uintptr_t)buf) & 3);
		} 
		rem_len = len & 7;
		len = len >> 3;
		b = (uint32_t)buf;
		for (--b; len; --len) {
			q = crc ^ ++/* use pre increment for speed */b;
			crc = (t7[(q) & 255] ^ t6[(q >> 8) & 255] ^ t5[(q >> 16) & 255] ^ t4[(q >> 24) & 255]);
			q = ++b;
			crc ^=  (t3[(q) & 255] ^ t2[(q >> 8) & 255] ^ t1[(q >> 16) & 255] ^ t0[(q >> 24) & 255]);
		}
		len = rem_len;
		if (/* And the last few bytes */len) {
			uint8_t p = (uint8_t)(b + 1) - 1;
			do {
				(crc = t0[(crc ^ (++p)) & 255] ^ (crc >> /* use pre increment for speed */8));
			} while (--len);
		} 
		return crc;/**
		 * crc32_le() - Calculate bitwise little-endian Ethernet AUTODIN II CRC32
		 * @crc: seed value for computation.  ~0 for Ethernet, sometimes 0 for
		 *	other uses, or the previous crc32 value if computing incrementally.
		 * @p: pointer to buffer over which CRC is run
		 * @len: length of buffer @p
		 */
	}
	public static Object crc32_le_generic(Object crc, Object p, Object len, Object tab, Object polynomial) {
		/* aka Sarwate algorithm *//* aka Sarwate algorithm */crc = (crc);
		crc = ModernizedCProgram.crc32_body(crc, p, len, tab);
		crc = (crc);
		return crc;
	}
	public static Object ext2fs_crc32c_le(Object crc, Object p, Object len) {
		return ModernizedCProgram.crc32_le_generic(crc, p, len, ModernizedCProgram.crc32ctable_le, -1024/**
		 * crc32_be() - Calculate bitwise big-endian Ethernet AUTODIN II CRC32
		 * @crc: seed value for computation.  ~0 for Ethernet, sometimes 0 for
		 *	other uses, or the previous crc32 value if computing incrementally.
		 * @p: pointer to buffer over which CRC is run
		 * @len: length of buffer @p
		 */);
	}
	public static Object crc32_be_generic(Object crc, Object p, Object len, Object tab, Object polynomial) {
		crc = (/*Error: Function owner not recognized*/ext2fs_cpu_to_be32((crc)));
		crc = ModernizedCProgram.crc32_body(crc, p, len, tab);
		crc = (/*Error: Function owner not recognized*/ext2fs_be32_to_cpu((crc)));
		return crc;
	}
	public static Object ext2fs_crc32_be(Object crc, Object p, Object len) {
		return ModernizedCProgram.crc32_be_generic(crc, p, len, ModernizedCProgram.crc32table_be, -1024);
	}
	/* random starting crc */
	/* random offset in buf */
	/* random length of test */
	/* expected crc32c_le result */
	/* expected crc32_be result */
	/* UNITTEST */
	/* ----------------------------------------------------------------------- *
	 *
	 *   Copyright 2004-2008 H. Peter Anvin - All Rights Reserved
	 *
	 *   This program is free software; you can redistribute it and/or modify
	 *   it under the terms of the GNU General Public License as published by
	 *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
	 *   Boston MA 02111-1307, USA; either version 2 of the License, or
	 *   (at your option) any later version; incorporated herein by reference.
	 *
	 * ----------------------------------------------------------------------- */
	/*
	 * fatchain.c
	 *
	 * Follow a FAT chain
	 */
	/*
	 * Convert a cluster number (or 0 for the root directory) to a
	 * sector number.  Return -1 on failure.
	 */
	public static Object libfat_clustertosector(Object fs, Object cluster) {
		if (cluster == 0) {
			cluster = fs.getRootcluster();
		} 
		if (cluster == 0) {
			return fs.getRootdir();
		}  else if (cluster < 2 || cluster >= fs.getEndcluster()) {
			return -1;
		} else {
				return fs.getData() + ((libfat_sector_t)(cluster - 2) << fs.getClustshift());
		} 
	}
	/* vi: set sw=4 ts=4: */
	/*
	 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
	 */
	public static void header_list(Object file_header) {
		/*Error: Function owner not recognized*///TODO: cpio -vp DIR should output "DIR/NAME", not just "NAME" *//*Error: Function owner not recognized*///TODO: cpio -vp DIR should output "DIR/NAME", not just "NAME" */puts(file_header.getName());
	}
	/*
	 * Reset the dictionary state. When in single-call mode, set up the beginning
	 * of the dictionary to point to the actual output buffer.
	 */
	public static void dict_reset(dictionary dict, xz_buf b) {
		xz_mode generatedMode = dict.getMode();
		Object generatedOut = b.getOut();
		Object generatedOut_pos = b.getOut_pos();
		Object generatedOut_size = b.getOut_size();
		if (((generatedMode) == xz_mode.XZ_SINGLE)) {
			dict.setBuf(generatedOut + generatedOut_pos);
			dict.setEnd(generatedOut_size - generatedOut_pos);
		} 
		dict.setStart(0);
		dict.setPos(0);
		dict.setLimit(0);
		dict.setFull(0);
	}
	/* Return true if at least one byte can be written into the dictionary. */
	public static boolean dict_has_space(Object dict) {
		return dict.getPos() < dict.getLimit();
	}
	public static Object dict_get(Object dict, Object dist) {
		size_t offset = dict.getPos() - dist - 1;
		if (dist >= dict.getPos()) {
			offset += dict.getEnd();
		} 
		return dict.getFull() > 0 ? dict.getBuf()[offset] : 0/*
		 * Put one byte into the dictionary. It is assumed that there is space for it.
		 */;
	}
	/* Copy uncompressed data as is from input to dictionary and output buffers. */
	public static void dict_uncompressed(dictionary dict, xz_buf b, Object left) {
		size_t copy_size = new size_t();
		Object generatedIn_pos = b.getIn_pos();
		Object generatedIn_size = b.getIn_size();
		Object generatedOut_pos = b.getOut_pos();
		Object generatedOut_size = b.getOut_size();
		Object generatedEnd = dict.getEnd();
		Object generatedPos = dict.getPos();
		Object[] generatedBuf = dict.getBuf();
		Object[] generatedIn = b.getIn();
		Object generatedFull = dict.getFull();
		xz_mode generatedMode = dict.getMode();
		Object generatedOut = b.getOut();
		while (left > 0 && generatedIn_pos < generatedIn_size && generatedOut_pos < generatedOut_size) {
			copy_size = ((generatedIn_size - generatedIn_pos) < (generatedOut_size - generatedOut_pos) ? (generatedIn_size - generatedIn_pos) : (generatedOut_size - generatedOut_pos));
			if (copy_size > generatedEnd - generatedPos) {
				copy_size = generatedEnd - generatedPos;
			} 
			if (copy_size > left) {
				copy_size = left;
			} 
			left -= (uint32_t)copy_size;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBuf + generatedPos, generatedIn + generatedIn_pos, copy_size);
			generatedPos += copy_size;
			if (generatedFull < generatedPos) {
				dict.setFull(generatedPos);
			} 
			if (((generatedMode) != xz_mode.XZ_SINGLE)) {
				if (generatedPos == generatedEnd) {
					dict.setPos(0);
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedOut + generatedOut_pos, generatedIn + generatedIn_pos, copy_size);
			} 
			dict.setStart(generatedPos);
			generatedOut_pos += copy_size;
			generatedIn_pos += copy_size/*
			 * Flush pending data from dictionary to b->out. It is assumed that there is
			 * enough space in b->out. This is guaranteed because caller uses dict_limit()
			 * before decoding data into the dictionary.
			 */;
		}
	}
	public static Object dict_flush(dictionary dict, xz_buf b) {
		Object generatedPos = dict.getPos();
		Object generatedStart = dict.getStart();
		size_t copy_size = generatedPos - generatedStart;
		xz_mode generatedMode = dict.getMode();
		Object generatedEnd = dict.getEnd();
		Object generatedOut = b.getOut();
		Object generatedOut_pos = b.getOut_pos();
		Object[] generatedBuf = dict.getBuf();
		if (((generatedMode) != xz_mode.XZ_SINGLE)) {
			if (generatedPos == generatedEnd) {
				dict.setPos(0);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedOut + generatedOut_pos, generatedBuf + generatedStart, copy_size);
		} 
		dict.setStart(generatedPos);
		generatedOut_pos += copy_size;
		return (uint32_t)copy_size/*****************
		 * Range decoder *
		 *****************/;
	}
	public static boolean rc_read_init(rc_dec rc, xz_buf b) {
		Object generatedInit_bytes_left = rc.getInit_bytes_left();
		Object generatedIn_pos = b.getIn_pos();
		Object generatedIn_size = b.getIn_size();
		Object generatedCode = rc.getCode();
		Object[] generatedIn = b.getIn();
		while (generatedInit_bytes_left > 0) {
			if (generatedIn_pos == generatedIn_size) {
				return 0;
			} 
			rc.setCode((generatedCode << 8) + generatedIn[generatedIn_pos++]);
			--generatedInit_bytes_left;
		}
		return 1;
	}
	/* Return true if there may not be enough input for the next decoding loop. */
	public static boolean rc_limit_exceeded(Object rc) {
		return rc.getIn_pos() > rc.getIn_limit();
	}
	public static boolean rc_is_finished(Object rc) {
		return rc.getCode() == 0;
	}
	/* Decode the length of the match into s->lzma.len. */
	public static void lzma_len(xz_dec_lzma2 s, lzma_len_dec l, Object pos_state) {
		uint16_t probs = new uint16_t();
		uint32_t limit = new uint32_t();
		rc_dec generatedRc = s.getRc();
		Object generatedChoice = l.getChoice();
		Object generatedLow = l.getLow();
		lzma_dec generatedLzma = s.getLzma();
		Object generatedChoice2 = l.getChoice2();
		Object generatedMid = l.getMid();
		Object generatedHigh = l.getHigh();
		if (!generatedRc.rc_bit(generatedChoice)) {
			probs = generatedLow[pos_state];
			limit = (1 << 3);
			generatedLzma.setLen(2);
		} else {
				if (!generatedRc.rc_bit(generatedChoice2)) {
					probs = generatedMid[pos_state];
					limit = (1 << 3);
					generatedLzma.setLen(2 + (1 << 3));
				} else {
						probs = generatedHigh;
						limit = (1 << 8);
						generatedLzma.setLen(2 + (1 << 3) + (1 << 3));
				} 
		} 
		Object generatedLen = generatedLzma.getLen();
		generatedLen += generatedRc.rc_bittree(probs, limit) - limit;
	}
	/*
	 * The LZMA decoder assumes that if the input limit (s->rc.in_limit) hasn't
	 * been exceeded, it is safe to read up to LZMA_IN_REQUIRED bytes. This
	 * wrapper function takes care of making the LZMA decoder's assumption safe.
	 *
	 * As long as there is plenty of input left to be decoded in the current LZMA
	 * chunk, we decode directly from the caller-supplied input buffer until
	 * there's LZMA_IN_REQUIRED bytes left. Those remaining bytes are copied into
	 * s->temp.buf, which (hopefully) gets filled on the next call to this
	 * function. We decode a few bytes from the temporary buffer so that we can
	 * continue decoding from the caller-supplied input buffer again.
	 */
	public static boolean lzma2_lzma(xz_dec_lzma2 s, xz_buf b) {
		size_t in_avail = new size_t();
		uint32_t tmp = new uint32_t();
		Object generatedIn_size = b.getIn_size();
		Object generatedIn_pos = b.getIn_pos();
		in_avail = generatedIn_size - generatedIn_pos;
		 generatedTemp = s.getTemp();
		Object generatedSize = generatedTemp.getSize();
		lzma2_dec generatedLzma2 = s.getLzma2();
		Object generatedCompressed = generatedLzma2.getCompressed();
		Object generatedBuf = generatedTemp.getBuf();
		Object[] generatedIn = b.getIn();
		rc_dec generatedRc = s.getRc();
		if (generatedSize > 0 || generatedCompressed == 0) {
			tmp = 2 * 21 - generatedSize;
			if (tmp > generatedCompressed - generatedSize) {
				tmp = generatedCompressed - generatedSize;
			} 
			if (tmp > in_avail) {
				tmp = (uint32_t)in_avail;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBuf + generatedSize, generatedIn + generatedIn_pos, tmp);
			if (generatedSize + tmp == generatedCompressed) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedBuf + generatedSize + tmp, 0, /*Error: sizeof expression not supported yet*/ - generatedSize - tmp);
				generatedRc.setIn_limit(generatedSize + tmp);
			}  else if (generatedSize + tmp < 21) {
				generatedSize += tmp;
				generatedIn_pos += tmp;
				return 1;
			} else {
					generatedRc.setIn_limit(generatedSize + tmp - 21);
			} 
			generatedRc.setIn(generatedBuf);
			generatedRc.setIn_pos(0);
			if (!s.lzma_main() || generatedIn_pos > generatedSize + tmp) {
				return 0;
			} 
			generatedCompressed -= (uint32_t)generatedIn_pos;
			if (generatedIn_pos < generatedSize) {
				generatedSize -= (uint32_t)generatedIn_pos;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memmove(generatedBuf, generatedBuf + generatedIn_pos, generatedSize);
				return 1;
			} 
			generatedIn_pos += generatedIn_pos - generatedSize;
			generatedTemp.setSize(0);
		} 
		in_avail = generatedIn_size - generatedIn_pos;
		if (in_avail >= 21) {
			generatedRc.setIn(generatedIn);
			generatedRc.setIn_pos(generatedIn_pos);
			if (in_avail >= generatedCompressed + 21) {
				generatedRc.setIn_limit(generatedIn_pos + generatedCompressed);
			} else {
					generatedRc.setIn_limit(generatedIn_size - 21);
			} 
			if (!s.lzma_main()) {
				return 0;
			} 
			in_avail = generatedIn_pos - generatedIn_pos;
			if (in_avail > generatedCompressed) {
				return 0;
			} 
			generatedCompressed -= (uint32_t)in_avail;
			b.setIn_pos(generatedIn_pos);
		} 
		in_avail = generatedIn_size - generatedIn_pos;
		if (in_avail < 21) {
			if (in_avail > generatedCompressed) {
				in_avail = generatedCompressed;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBuf, generatedIn + generatedIn_pos, in_avail);
			generatedTemp.setSize((uint32_t)in_avail);
			generatedIn_pos += in_avail;
		} 
		return 1/*
		 * Take care of the LZMA2 control layer, and forward the job of actual LZMA
		 * decoding or copying of uncompressed chunks to other functions.
		 */;
	}
	public static xz_ret xz_dec_lzma2_run(xz_dec_lzma2 s, xz_buf b) {
		uint32_t tmp = new uint32_t();
		Object generatedIn_pos = b.getIn_pos();
		Object generatedIn_size = b.getIn_size();
		lzma2_dec generatedLzma2 = s.getLzma2();
		lzma2_seq generatedSequence = generatedLzma2.getSequence();
		Object[] generatedIn = b.getIn();
		dictionary generatedDict = s.getDict();
		boolean generatedNeed_dict_reset = generatedLzma2.getNeed_dict_reset();
		boolean generatedNeed_props = generatedLzma2.getNeed_props();
		Object generatedUncompressed = generatedLzma2.getUncompressed();
		Object generatedCompressed = generatedLzma2.getCompressed();
		lzma2_seq generatedNext_sequence = generatedLzma2.getNext_sequence();
		rc_dec generatedRc = s.getRc();
		Object generatedOut_size = b.getOut_size();
		Object generatedOut_pos = b.getOut_pos();
		lzma_dec generatedLzma = s.getLzma();
		Object generatedLen = generatedLzma.getLen();
		 generatedTemp = s.getTemp();
		Object generatedSize = generatedTemp.getSize();
		while (generatedIn_pos < generatedIn_size || generatedSequence == lzma2_seq.SEQ_LZMA_RUN) {
			switch (generatedSequence) {
			case lzma2_seq.SEQ_PROPERTIES:
					if (!s.lzma_props(generatedIn[generatedIn_pos++])) {
						return xz_ret.XZ_DATA_ERROR;
					} 
					generatedLzma2.setSequence(lzma2_seq.SEQ_LZMA_PREPARE);
			case lzma2_seq.SEQ_UNCOMPRESSED_1:
					generatedUncompressed += (uint32_t)generatedIn[generatedIn_pos++] << 8;
					generatedLzma2.setSequence(lzma2_seq.SEQ_UNCOMPRESSED_2);
					break;
			case lzma2_seq.SEQ_LZMA_RUN/*
						 * Set dictionary limit to indicate how much we want
						 * to be encoded at maximum. Decode new data into the
						 * dictionary. Flush the new data from dictionary to
						 * b->out. Check if we finished decoding this chunk.
						 * In case the dictionary got full but we didn't fill
						 * the output buffer yet, we may run this loop
						 * multiple times without changing s->lzma2.sequence.
						 */:
					generatedDict.dict_limit(((generatedOut_size - generatedOut_pos) < (generatedUncompressed) ? (generatedOut_size - generatedOut_pos) : (generatedUncompressed)));
					if (!ModernizedCProgram.lzma2_lzma(s, b)) {
						return xz_ret.XZ_DATA_ERROR;
					} 
					generatedUncompressed -= ModernizedCProgram.dict_flush(generatedDict, b);
					if (generatedUncompressed == 0) {
						if (generatedCompressed > 0 || generatedLen > 0 || !ModernizedCProgram.rc_is_finished(generatedRc)) {
							return xz_ret.XZ_DATA_ERROR;
						} 
						generatedRc.rc_reset();
						generatedLzma2.setSequence(lzma2_seq.SEQ_CONTROL);
					}  else if (generatedOut_pos == generatedOut_size || (generatedIn_pos == generatedIn_size && generatedSize < generatedCompressed)) {
						return xz_ret.XZ_OK;
					} 
					break;
			case lzma2_seq.SEQ_COPY:
					ModernizedCProgram.dict_uncompressed(generatedDict, b, generatedCompressed);
					if (generatedCompressed > 0) {
						return xz_ret.XZ_OK;
					} 
					generatedLzma2.setSequence(lzma2_seq.SEQ_CONTROL);
					break;
			case lzma2_seq.SEQ_CONTROL/*
						 * LZMA2 control byte
						 *
						 * Exact values:
						 *   0x00   End marker
						 *   0x01   Dictionary reset followed by
						 *          an uncompressed chunk
						 *   0x02   Uncompressed chunk (no dictionary reset)
						 *
						 * Highest three bits (s->control & 0xE0):
						 *   0xE0   Dictionary reset, new properties and state
						 *          reset, followed by LZMA compressed chunk
						 *   0xC0   New properties and state reset, followed
						 *          by LZMA compressed chunk (no dictionary
						 *          reset)
						 *   0xA0   State reset using old properties,
						 *          followed by LZMA compressed chunk (no
						 *          dictionary reset)
						 *   0x80   LZMA chunk (no dictionary or state reset)
						 *
						 * For LZMA compressed chunks, the lowest five bits
						 * (s->control & 1F) are the highest bits of the
						 * uncompressed size (bits 16-20).
						 *
						 * A new LZMA2 stream must begin with a dictionary
						 * reset. The first LZMA chunk must set new
						 * properties and reset the LZMA state.
						 *
						 * Values that don't match anything described above
						 * are invalid and we return XZ_DATA_ERROR.
						 */:
					tmp = generatedIn[generatedIn_pos++];
					if (tmp == -1024) {
						return xz_ret.XZ_STREAM_END;
					} 
					if (tmp >= -1024 || tmp == -1024) {
						generatedLzma2.setNeed_props(1);
						generatedLzma2.setNeed_dict_reset(0);
						ModernizedCProgram.dict_reset(generatedDict, b);
					}  else if (generatedNeed_dict_reset) {
						return xz_ret.XZ_DATA_ERROR;
					} 
					if (tmp >= -1024) {
						generatedLzma2.setUncompressed((tmp & -1024) << 16);
						generatedLzma2.setSequence(lzma2_seq.SEQ_UNCOMPRESSED_1);
						if (tmp >= -1024/*
											 * When there are new properties,
											 * state reset is done at
											 * SEQ_PROPERTIES.
											 */) {
							generatedLzma2.setNeed_props(0);
							generatedLzma2.setNext_sequence(lzma2_seq.SEQ_PROPERTIES);
						}  else if (generatedNeed_props) {
							return xz_ret.XZ_DATA_ERROR;
						} else {
								generatedLzma2.setNext_sequence(lzma2_seq.SEQ_LZMA_PREPARE);
								if (tmp >= -1024) {
									s.lzma_reset();
								} 
						} 
					} else {
							if (tmp > -1024) {
								return xz_ret.XZ_DATA_ERROR;
							} 
							generatedLzma2.setSequence(lzma2_seq.SEQ_COMPRESSED_0);
							generatedLzma2.setNext_sequence(lzma2_seq.SEQ_COPY);
					} 
					break;
			case lzma2_seq.SEQ_COMPRESSED_1:
					generatedCompressed += (uint32_t)generatedIn[generatedIn_pos++] + 1;
					generatedLzma2.setSequence(generatedNext_sequence);
					break;
			case lzma2_seq.SEQ_LZMA_PREPARE:
					if (generatedCompressed < 5) {
						return xz_ret.XZ_DATA_ERROR;
					} 
					if (!ModernizedCProgram.rc_read_init(generatedRc, b)) {
						return xz_ret.XZ_OK;
					} 
					generatedCompressed -= 5;
					generatedLzma2.setSequence(lzma2_seq.SEQ_LZMA_RUN);
			case lzma2_seq.SEQ_COMPRESSED_0:
					generatedLzma2.setCompressed((uint32_t)generatedIn[generatedIn_pos++] << 8);
					generatedLzma2.setSequence(lzma2_seq.SEQ_COMPRESSED_1);
					break;
			case lzma2_seq.SEQ_UNCOMPRESSED_2:
					generatedUncompressed += (uint32_t)generatedIn[generatedIn_pos++] + 1;
					generatedLzma2.setSequence(lzma2_seq.SEQ_COMPRESSED_0);
					break;
			}
		}
		return xz_ret.XZ_OK;
	}
	/*
	 * Rufus: The Reliable USB Formatting Utility
	 * SMART HDD vs Flash detection (using ATA over USB, S.M.A.R.T., etc.)
	 * Copyright Â© 2013-2016 Pete Batard <pete@akeo.ie>
	 *
	 * Based in part on scsiata.cpp from Smartmontools: http://smartmontools.sourceforge.net
	 * Copyright Â© 2006-12 Douglas Gilbert <dgilbert@interlog.com>
	 * Copyright Â© 2009-13 Christian Franke <smartmontools-support@lists.sourceforge.net>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	/* Helper functions */
	// Far from complete -- only the commands we *may* use.
	// Most SMART commands require DATA_IN but there are a couple exceptions
	// fall through
	/*
	 * SCSI Passthrough (using IOCTL_SCSI_PASS_THROUGH_DIRECT)
	 * Should be provided a handle to the physical device (R/W) as well as a Cdb and a buffer that is page aligned
	 * Direction should be one of SCSI_IOCTL_DATA_###
	 *
	 * Returns 0 (SPT_SUCCESS) on success, a positive SCSI Status in case of an SCSI error or negative otherwise.
	 */
	// Sanity checks
	// http://en.wikipedia.org/wiki/SCSI_command
	// Opcodes above 0xC0 are unsupported (apart for the special JMicron/Sunplus modes)
	// One of SCSI_IOCTL_DATA_###
	// uprintf("ScsiPassthroughDirect: CDB command 0x%02X failed (SCSI status 0x%02X)\n", Cdb[0], sptdwb.sptd.ScsiStatus);
	// uprintf("ScsiPassthroughDirect: CDB command 0x%02X failed %s\n", Cdb[0], WindowsErrorString()); SetLastError(err);
	/* See ftp://ftp.t10.org/t10/document.04/04-262r8.pdf, http://www.scsitoolbox.com/pdfs/UsingSAT.pdf,
	 * as well as http://nevar.pl/pliki/ATA8-ACS-3.pdfâ */
	/* For 48-bit ATA command (unused here) */
	/* Set to 1 to read register(s) back */
	/* Non-data */
	/* 0 -> to device, 1 -> from device */
	/* 0 -> bytes, 1 -> 512 byte blocks */
	/* 0 -> no data transferred */
	// Set data direction
	// PIO data-in
	// The transfer length is specified in the sector_count field
	// PIO data-out
	// The transfer length is specified in the sector_count field
	// to device
	// (m_port == 0 ? 0xa0 : 0xb0);  // Must be 0 for identify
	/* The only differences between JMicron and Prolific are the extra 2 bytes for the CDB */
	// (m_port == 0 ? 0xa0 : 0xb0);  // Must be 0 for identify
	// Prolific PL3507
	/* UNTESTED!!! */
	/* UNTESTED!!! */
	/* UNTESTED!!! */
	/* See: http://kernel.opensuse.org/cgit/kernel/tree/drivers/usb/storage/cypress_atacb.c */
	// Set IdentifyPacketDevice
	// Features, sector count, lba low, lba med, lba high
	// Units in blocks rather than bytes
	/* The various bridges we will try, in order */
	// You'll get an error here if your compiler does not properly pack the IDENTIFY struct
	/* Generic SMART access. Kept for reference, as it doesn't work for USB to ATA/SATA bridges */
	/*
	 * This attempts to detect whether a drive is an USB HDD or an USB Flash Drive (UFD).
	 * A positive score means that we think it's an USB HDD, zero or negative means that
	 * we think it's an UFD.
	 *
	 * This is done so that, if someone already has an USB HDD plugged in (say as a
	 * backup drive) and plugs an UFD we *try* to do what we can to avoid them formatting
	 * that drive by mistake.
	 * However, because there is no foolproof (let alone easy) way to differentiate UFDs
	 * from HDDs, thanks to every manufacturer, Microsoft, and their mothers, making it
	 * exceedingly troublesome to find what type of hardware we are actually accessing,
	 * you are expected to pay heed to the following:
	 *
	 * WARNING: NO PROMISE IS MADE ABOUT THIS ALGORITHM BEING ABLE TO CORRECTLY
	 * DIFFERENTIATE AN USB HDD FROM AN USB FLASH DRIVE. MOREOVER, YOU ARE REMINDED THAT
	 * THE LICENSE OF THIS APPLICATION MAKES NO PROMISE ABOUT AVOIDING DATA LOSS EITHER
	 * (PROVIDED "AS IS").
	 * THUS, IF DATA LOSS IS INCURRED DUE TO THIS, OR ANY OTHER PART OF THIS APPLICATION,
	 * NOT BEHAVING IN THE MANNER YOU EXPECTED, THE RESPONSIBILITY IS ENTIRELY ON YOU!
	 *
	 * What you have below, then, is our *current best guess* at differentiating UFDs
	 * from HDDs. But short of a crystal ball, this remains just a guess, which may be
	 * way off mark. Still, you are also reminded that Rufus does produce PROMINENT
	 * warnings before you format a drive, and also provides extensive info about the
	 * drive (from the tooltips and the log) => PAY ATTENTION TO THESE OR PAY THE PRICE!
	 *
	 * But let me just elaborate further on why differentiating UFDs from HDDs is not as
	 * 'simple' as it seems:
	 * - many USB flash drives manufacturer will present UFDs as non-removable, which used
	 *   to be reserved for HDDs => we can't use that as differentiator.
	 * - some UFDs (SanDisk Extreme) have added S.M.A.R.T. support, which also used to be
	 *   reserved for HDDs => can't use that either
	 * - even if S.M.A.R.T. was enough, not all USB->IDE or USB->SATA bridges support ATA
	 *   passthrough, which is required S.M.A.R.T. data, and each manufacturer of an
	 *   USB<->(S)ATA bridge seem to have their own method of implementing passthrough.
	 * - SSDs have also changed the deal completely, as you can get something that looks
	 *   like Flash but that is really an HDD.
	 * - Some manufacturers (eg. verbatim) provide both USB Flash Drives and USB HDDs, so
	 *   we can't exactly use the VID to say for sure what we're looking at.
	 * - Finally, Microsoft is absolutely no help either (which is kind of understandable
	 *   from the above) => there is no magic API we can query that will tell us what we're
	 *   really looking at.
	 */
	public static int IsHDD(Object DriveIndex, Object vid, Object pid, Object[] strid) {
		int score = 0;
		size_t i = new size_t();
		size_t mlen = new size_t();
		size_t ilen = new size_t();
		BOOL wc = new BOOL();
		uint64_t drive_size = new uint64_t();
		// Boost the score if fixed, as these are *generally* HDDs
		// NB: Due to a Windows API limitation, drives with no mounted partition will never have DRIVE_FIXEDif (ModernizedCProgram.GetDriveTypeFromIndex(DriveIndex) == 3) {
			score += 3;
		} 
		// Adjust the score depending on the size// Adjust the score depending on the sizedrive_size = ModernizedCProgram.GetDriveSize(DriveIndex);
		if (drive_size > 512 * -1024) {
			score += 10;
		}  else if (drive_size < 8 * -1024) {
			score -= 10;
		} 
		// Check the string against well known HDD identifiersif (strid != ((Object)0)) {
			ilen = /*Error: Function owner not recognized*/strlen(strid);
			for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
				mlen = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.str_score[i].getName());
				if (mlen > ilen) {
					break;
				} 
				wc = (ModernizedCProgram.str_score[i].getName()[mlen - 1] == (byte)'#');
				if ((/*Error: Function owner not recognized*/_strnicmp(strid, ModernizedCProgram.str_score[i].getName(), mlen - ((wc) ? 1 : 0)) == 0) && ((!wc) || ((strid[mlen] >= (byte)'0') && (strid[mlen] <= (byte)'9')))) {
					score += ModernizedCProgram.str_score[i].getScore();
					break;
				} 
			}
		} 
		// Adjust for oddball devicesif (strid != ((Object)0)) {
			for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
				if (/*Error: Function owner not recognized*/strstr(strid, ModernizedCProgram.str_adjust[i].getName()) != ((Object)0)) {
					score += ModernizedCProgram.str_adjust[i].getScore();
				} 
			}
		} 
		// Check against known VIDsfor (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (vid == ModernizedCProgram.vid_score[i].getVid()) {
				score += ModernizedCProgram.vid_score[i].getScore();
				break;
			} 
		}
		// Check against known VID:PIDsfor (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if ((vid == ModernizedCProgram.vidpid_score[i].getVid()) && (pid == ModernizedCProgram.vidpid_score[i].getPid())) {
				score += ModernizedCProgram.vidpid_score[i].getScore();
				break;
			} 
		}
		;
		return score;
	}
	public static Byte my_index(Object str, int chr) {
		while (str) {
			if (str == chr) {
				return (byte)str;
			} 
			str++;
		}
		return 0/* If using GCC, we can safely declare strlen this way.
		   If not using GCC, it is ok not to declare it.  */;/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
		   That was relevant to code that was here before.  */
	}
	/* gcc with -traditional declares the built-in strlen to return int,
	   and has done so at least since version 2.4.5. -- rms.  */
	/* not __STDC__ */
	/* __GNUC__ */
	/* not __GNU_LIBRARY__ */
	/* Handle permutation of arguments.  */
	/* Describe the part of ARGV that contains non-options that have
	   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
	   `last_nonopt' is the index after the last of them.  */
	/* Stored original parameters.
	   XXX This is no good solution.  We should rather copy the args so
	   that we can compare them later.  But we must not use malloc(3).  */
	/* Bash 2.0 gives us an environment variable containing flags
	   indicating ARGV elements that should not be considered arguments.  */
	/* Defined in getopt_init.c  */
	/* !_LIBC */
	/* _LIBC */
	/* Exchange two adjacent subsequences of ARGV.
	   One subsequence is elements [first_nonopt,last_nonopt)
	   which contains all the non-options that have been skipped so far.
	   The other is elements [last_nonopt,optind), which contains all
	   the options processed since those non-options were skipped.
	
	   `first_nonopt' and `last_nonopt' are relocated so that they describe
	   the new indices of the non-options in ARGV after they are moved.  */
	public static void exchange(byte[][] argv) {
		int bottom = ModernizedCProgram.first_nonopt;
		int middle = ModernizedCProgram.last_nonopt;
		int top = ModernizedCProgram.optind;
		byte tem;
		/* Exchange the shorter segment with the far end of the longer segment.
		     That puts the shorter segment into the right place.
		     It leaves the longer segment in the right place overall,
		     but it consists of two parts that need to be swapped next.  *//* First make sure the handling of the `__getopt_nonoption_flags'
		     string can work normally.  Our top argument must be in the range
		     of the string.  *//* We must extend the array.  The user plays games with us and
			 presents new arguments.  */
		while (top > middle && middle > bottom) {
			if (top - middle > middle - bottom) {
				int len = middle - /* Bottom segment is the short one.  */bottom;
				int i;
				for (i = 0; i < len; /* Swap it with the top part of the top segment.  */i++) {
					tem = argv[bottom + i];
					argv[bottom + i] = argv[top - (middle - bottom) + i];
					argv[top - (middle - bottom) + i] = tem;
					;
				}
				top -= /* Exclude the moved bottom segment from further swapping.  */len;
			} else {
					int len = top - /* Top segment is the short one.  */middle;
					int i;
					for (i = 0; i < len; /* Swap it with the bottom part of the bottom segment.  */i++) {
						tem = argv[bottom + i];
						argv[bottom + i] = argv[middle + i];
						argv[middle + i] = tem;
						;
					}
					bottom += /* Exclude the moved top segment from further swapping.  */len;
			} 
		}
		ModernizedCProgram.first_nonopt += (ModernizedCProgram.optind - /* Update records for the slots the non-options now occupy.  */ModernizedCProgram.last_nonopt);
		ModernizedCProgram.last_nonopt = ModernizedCProgram.optind/* Initialize the internal data when the first call is made.  */;
	}
	public static Object _getopt_initialize(int argc, Byte argv, Object[] optstring) {
		size_t posixly_correct_size = 0;
		byte[] posixly_correct_buffer = new byte[16/* Start processing options with ARGV-element 1 (since ARGV-element 0
		     is the program name); the sequence of previously skipped
		     non-option ARGV-elements is empty.  */];
		ModernizedCProgram.first_nonopt = ModernizedCProgram.last_nonopt = ModernizedCProgram.optind;
		ModernizedCProgram.nextchar = ((Object)0);
		if ((/*Error: Function owner not recognized*/getenv_s(posixly_correct_size, posixly_correct_buffer, /*Error: sizeof expression not supported yet*/, "POSIXLY_CORRECT") == 0) && (posixly_correct_size != 0)) {
			ModernizedCProgram.posixly_correct = /*Error: Function owner not recognized*/_strdup(posixly_correct_buffer);
		} 
		if (optstring[0] == /* Determine how to handle the ordering of options and nonoptions.  */(byte)'-') {
			.ordering = .RETURN_IN_ORDER;
			++optstring;
		}  else if (optstring[0] == (byte)'+') {
			.ordering = .REQUIRE_ORDER;
			++optstring;
		}  else if (ModernizedCProgram.posixly_correct != ((Object)0)) {
			.ordering = .REQUIRE_ORDER;
		} else {
				.ordering = .PERMUTE;
		} 
		return optstring/* Scan elements of ARGV (whose length is ARGC) for option characters
		   given in OPTSTRING.
		
		   If an element of ARGV starts with '-', and is not exactly "-" or "--",
		   then it is an option element.  The characters of this element
		   (aside from the initial '-') are option characters.  If `getopt'
		   is called repeatedly, it returns successively each of the option characters
		   from each of the option elements.
		
		   If `getopt' finds another option character, it returns that character,
		   updating `optind' and `nextchar' so that the next call to `getopt' can
		   resume the scan with the following option character or ARGV-element.
		
		   If there are no more option characters, `getopt' returns -1.
		   Then `optind' is the index in ARGV of the first ARGV-element
		   that is not an option.  (The ARGV-elements have been permuted
		   so that those that are not options now come last.)
		
		   OPTSTRING is a string containing the legitimate option characters.
		   If an option character is seen that is not listed in OPTSTRING,
		   return '?' after printing an error message.  If you set `opterr' to
		   zero, the error message is suppressed but we still return '?'.
		
		   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
		   so the following text in the same ARGV-element, or the text of the following
		   ARGV-element, is returned in `optarg'.  Two colons mean an option that
		   wants an optional arg; if there is text in the current ARGV-element,
		   it is returned in `optarg', otherwise `optarg' is set to zero.
		
		   If OPTSTRING starts with `-' or `+', it requests different methods of
		   handling the non-option ARGV-elements.
		   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
		
		   Long-named options begin with `--' instead of `-'.
		   Their names may be abbreviated as long as the abbreviation is unique
		   or is an exact match for some defined option.  If they have an
		   argument, it follows the option name in the same ARGV-element, separated
		   from the option name by a `=', or else the in next ARGV-element.
		   When `getopt' finds a long-named option, it returns 0 if that option's
		   `flag' field is nonzero, the value of the option's `val' field
		   if the `flag' field is zero.
		
		   The elements of ARGV aren't really const, because we permute them.
		   But we pretend they're const in the prototype to be compatible
		   with other systems.
		
		   LONGOPTS is a vector of `struct option' terminated by an
		   element containing a name which is zero.
		
		   LONGIND returns the index in LONGOPT of the long-named option found.
		   It is only valid when a long-named option has been found by the most
		   recent call.
		
		   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
		   long-named options.  */;
	}
	public static int _getopt_internal(int argc, byte[][] argv, Object[] optstring, Object longopts, Integer longind, int long_only) {
		int print_errors = ModernizedCProgram.opterr;
		if (optstring[0] == (byte)':') {
			print_errors = 0;
		} 
		if (argc < 1) {
			return -1;
		} 
		ModernizedCProgram.optarg = ((Object)0);
		if (ModernizedCProgram.optind == 0 || !ModernizedCProgram.__getopt_initialized) {
			if (ModernizedCProgram.optind == 0) {
				ModernizedCProgram.optind = /* Don't scan ARGV[0], the program name.  */1;
			} 
			optstring = ModernizedCProgram._getopt_initialize(argc, argv, optstring);
			ModernizedCProgram.__getopt_initialized = 1/* Test whether ARGV[optind] points to a non-option argument.
			     Either it does not have option syntax, or there is an environment flag
			     from the shell indicating it is not an option.  The later information
			     is only used when the used in the GNU libc.  */;
		} 
		if (ModernizedCProgram.nextchar == ((Object)0) || ModernizedCProgram.nextchar == (byte)'\0'/* Advance to the next ARGV-element.  */) {
			if (ModernizedCProgram.last_nonopt > /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
				 moved back by the user (who may also have changed the arguments).  */ModernizedCProgram.optind) {
				ModernizedCProgram.last_nonopt = ModernizedCProgram.optind;
			} 
			if (ModernizedCProgram.first_nonopt > ModernizedCProgram.optind) {
				ModernizedCProgram.first_nonopt = ModernizedCProgram.optind;
			} 
			if (.ordering == .PERMUTE/* If we have just processed some options following some non-options,
				     exchange them so that the options come first.  */) {
				if (ModernizedCProgram.first_nonopt != ModernizedCProgram.last_nonopt && ModernizedCProgram.last_nonopt != ModernizedCProgram.optind) {
					ModernizedCProgram.exchange((byte)argv);
				}  else if (ModernizedCProgram.last_nonopt != ModernizedCProgram.optind) {
					ModernizedCProgram.first_nonopt = ModernizedCProgram.optind/* Skip any additional non-options
						     and extend the range of non-options previously skipped.  */;
				} 
				while (ModernizedCProgram.optind < argc && (argv[ModernizedCProgram.optind][0] != (byte)'-' || argv[ModernizedCProgram.optind][1] == (byte)'\0')) {
					ModernizedCProgram.optind++;
				}
				ModernizedCProgram.last_nonopt = ModernizedCProgram.optind/* The special ARGV-element `--' means premature end of options.
					 Skip it like a null option,
					 then exchange with previous non-options as if it were an option,
					 then skip everything else like a non-option.  */;
			} 
			if (ModernizedCProgram.optind != argc && !/*Error: Function owner not recognized*/strcmp(argv[ModernizedCProgram.optind], "--")) {
				ModernizedCProgram.optind++;
				if (ModernizedCProgram.first_nonopt != ModernizedCProgram.last_nonopt && ModernizedCProgram.last_nonopt != ModernizedCProgram.optind) {
					ModernizedCProgram.exchange((byte)argv);
				}  else if (ModernizedCProgram.first_nonopt == ModernizedCProgram.last_nonopt) {
					ModernizedCProgram.first_nonopt = ModernizedCProgram.optind;
				} 
				ModernizedCProgram.last_nonopt = argc;
				ModernizedCProgram.optind = argc;
			} 
			if (ModernizedCProgram.optind == /* If we have done all the ARGV-elements, stop the scan
				 and back over any non-options that we skipped and permuted.  */argc) {
				if (ModernizedCProgram.first_nonopt != /* Set the next-arg-index to point at the non-options
					     that we previously skipped, so the caller will digest them.  */ModernizedCProgram.last_nonopt) {
					ModernizedCProgram.optind = ModernizedCProgram.first_nonopt;
				} 
				return -1;
			} 
			if ((argv[ModernizedCProgram.optind][0] != (byte)'-' || argv[ModernizedCProgram.optind][1] == /* If we have come to a non-option and did not permute it,
				 either stop the scan or describe it to the caller and pass it by.  */(byte)'\0')) {
				if (.ordering == .REQUIRE_ORDER) {
					return -1;
				} 
				ModernizedCProgram.optarg = argv[ModernizedCProgram.optind++];
				return 1;
			} 
			ModernizedCProgram.nextchar = (argv[ModernizedCProgram.optind] + /* We have found another option-ARGV-element.
				 Skip the initial punctuation.  */1 + (longopts != ((Object)0) && argv[ModernizedCProgram.optind][1] == (byte)'-'/* Decode the current option-ARGV-element.  *//* Check whether the ARGV-element is a long option.
			
			     If long_only and the ARGV-element has the form "-f", where f is
			     a valid short option, don't consider it an abbreviated form of
			     a long option that starts with f.  Otherwise there would be no
			     way to give the -f short option.
			
			     On the other hand, if there's a long option "fubar" and
			     the ARGV-element is "-fu", do consider that an abbreviation of
			     the long option, just like "--fu", and not "-f" with arg "u".
			
			     This distinction seems to be the most useful approach.  */));
		} 
		if (longopts != ((Object)0) && (argv[ModernizedCProgram.optind][1] == (byte)'-' || (long_only && (argv[ModernizedCProgram.optind][2] || !ModernizedCProgram.my_index(optstring, argv[ModernizedCProgram.optind][1]))))) {
			byte nameend;
			option p = new option();
			option pfound = ((Object)0);
			int exact = 0;
			int ambig = 0;
			int indfound = -1;
			int option_index;
			for (nameend = ModernizedCProgram.nextchar; nameend && nameend != (byte)'='; nameend++) {
				;
			}
			for (; p.getName(); ) {
				if (!/*Error: Function owner not recognized*/strncmp(p.getName(), ModernizedCProgram.nextchar, nameend - ModernizedCProgram.nextchar)) {
					if ((int)(nameend - ModernizedCProgram.nextchar) == (int)/*Error: Function owner not recognized*/strlen(p.getName())) {
						pfound = /* Exact match found.  */p;
						indfound = option_index;
						exact = 1;
						break;
					}  else if (pfound == ((Object)0)) {
						pfound = /* First nonexact match found.  */p;
						indfound = option_index;
					}  else if (long_only || pfound.getHas_arg() != p.getHas_arg() || pfound.getFlag() != p.getFlag() || pfound.getVal() != p.getVal()) {
						ambig = /* Second or later nonexact match found.  */1;
					} 
				} 
			}
			if (ambig && !exact) {
				if (print_errors) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), ("%s: option `%s' is ambiguous\n"), argv[0], argv[ModernizedCProgram.optind]);
				} 
				ModernizedCProgram.nextchar += /*Error: Function owner not recognized*/strlen(ModernizedCProgram.nextchar);
				ModernizedCProgram.optind++;
				ModernizedCProgram.optopt = 0;
				return (byte)'?';
			} 
			if (pfound != ((Object)0)) {
				option_index = indfound;
				ModernizedCProgram.optind++;
				if (nameend) {
					if (pfound.getHas_arg()) {
						ModernizedCProgram.optarg = nameend + 1;
					} else {
							if (print_errors) {
								if (argv[ModernizedCProgram.optind - 1][1] == (byte)'-') {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[/* --option */2]), ("%s: option `--%s' doesn't allow an argument\n"), argv[0], pfound.getName());
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[/* +option or -option */2]), ("%s: option `%c%s' doesn't allow an argument\n"), argv[0], argv[ModernizedCProgram.optind - 1][0], pfound.getName());
								} 
							} 
							ModernizedCProgram.nextchar += /*Error: Function owner not recognized*/strlen(ModernizedCProgram.nextchar);
							ModernizedCProgram.optopt = pfound.getVal();
							return (byte)'?';
					} 
				}  else if (pfound.getHas_arg() == 1) {
					if (ModernizedCProgram.optind < argc) {
						ModernizedCProgram.optarg = argv[ModernizedCProgram.optind++];
					} else {
							if (print_errors) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), ("%s: option `%s' requires an argument\n"), argv[0], argv[ModernizedCProgram.optind - 1]);
							} 
							ModernizedCProgram.nextchar += /*Error: Function owner not recognized*/strlen(ModernizedCProgram.nextchar);
							ModernizedCProgram.optopt = pfound.getVal();
							return optstring[0] == (byte)':' ? (byte)':' : (byte)'?';
					} 
				} 
				ModernizedCProgram.nextchar += /*Error: Function owner not recognized*/strlen(ModernizedCProgram.nextchar);
				if (longind != ((Object)0)) {
					longind = option_index;
				} 
				if (pfound.getFlag()) {
					(pfound.getFlag()) = pfound.getVal();
					return 0;
				} 
				return pfound.getVal();
			} 
			if (!long_only || argv[ModernizedCProgram.optind][1] == (byte)'-' || ModernizedCProgram.my_index(optstring, ModernizedCProgram.nextchar) == ((Object)0)) {
				if (print_errors) {
					if (argv[ModernizedCProgram.optind][1] == (byte)'-') {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), (/* --option */"%s: unrecognized option `--%s'\n"), argv[0], ModernizedCProgram.nextchar);
					} else {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), (/* +option or -option */"%s: unrecognized option `%c%s'\n"), argv[0], argv[ModernizedCProgram.optind][0], ModernizedCProgram.nextchar);
					} 
				} 
				ModernizedCProgram.nextchar = (byte)"";
				ModernizedCProgram.optind++;
				ModernizedCProgram.optopt = 0;
				return (byte)'?';
			} 
		} 
		{ 
			byte c = /* Look at and handle the next short option-character.  */ModernizedCProgram.nextchar++;
			byte temp = ModernizedCProgram.my_index(optstring, c);
			if (ModernizedCProgram.nextchar == /* Increment `optind' when we start to process its last character.  */(byte)'\0') {
				++ModernizedCProgram.optind;
			} 
			if (temp == ((Object)0) || c == (byte)':') {
				if (print_errors) {
					if (ModernizedCProgram.posixly_correct) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), (/* 1003.2 specifies the format of this message.  */"%s: illegal option -- %c\n"), argv[0], c);
					} else {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), ("%s: invalid option -- %c\n"), argv[0], c);
					} 
				} 
				ModernizedCProgram.optopt = c;
				return (byte)'?';
			} 
			if (temp[0] == (byte)'W' && temp[1] == /* Convenience. Treat POSIX -W foo same as long option --foo */(byte)';') {
				byte nameend;
				option p = new option();
				option pfound = ((Object)0);
				int exact = 0;
				int ambig = 0;
				int indfound = 0;
				int option_index;
				if (ModernizedCProgram.nextchar != /* This is an option that requires an argument.  */(byte)'\0') {
					ModernizedCProgram.optarg = ModernizedCProgram.nextchar/* If we end this ARGV-element by taking the rest as an arg,
						       we must advance to the next element now.  */;
					ModernizedCProgram.optind++;
				}  else if (ModernizedCProgram.optind == argc) {
					if (print_errors) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), (/* 1003.2 specifies the format of this message.  */"%s: option requires an argument -- %c\n"), argv[0], c);
					} 
					ModernizedCProgram.optopt = c;
					if (optstring[0] == (byte)':') {
						c = (byte)':';
					} else {
							c = (byte)'?';
					} 
					return c;
				} else {
						ModernizedCProgram.optarg = argv[/* We already incremented `optind' once;
							     increment it again when taking next ARGV-elt as argument.  */ModernizedCProgram.optind/* optarg is now the argument, see if it's in the
							   table of longopts.  */++];
				} 
				for (ModernizedCProgram.nextchar = nameend = ModernizedCProgram.optarg; nameend && nameend != (byte)'='; nameend++) {
					;
				}
				for (; p != ((Object)0) && p.getName(); ) {
					if (!/*Error: Function owner not recognized*/strncmp(p.getName(), ModernizedCProgram.nextchar, nameend - ModernizedCProgram.nextchar)) {
						if ((int)(nameend - ModernizedCProgram.nextchar) == /*Error: Function owner not recognized*/strlen(p.getName())) {
							pfound = /* Exact match found.  */p;
							indfound = option_index;
							exact = 1;
							break;
						}  else if (pfound == ((Object)0)) {
							pfound = /* First nonexact match found.  */p;
							indfound = option_index;
						} else {
								ambig = /* Second or later nonexact match found.  */1;
						} 
					} 
				}
				if (ambig && !exact) {
					if (print_errors) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), ("%s: option `-W %s' is ambiguous\n"), argv[0], argv[ModernizedCProgram.optind]);
					} 
					ModernizedCProgram.nextchar += /*Error: Function owner not recognized*/strlen(ModernizedCProgram.nextchar);
					ModernizedCProgram.optind++;
					return (byte)'?';
				} 
				if (pfound != ((Object)0)) {
					option_index = indfound;
					if (nameend) {
						if (pfound.getHas_arg()) {
							ModernizedCProgram.optarg = nameend + 1;
						} else {
								if (print_errors) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), ("%s: option `-W %s' doesn't allow an argument\n"), argv[0], pfound.getName());
								} 
								ModernizedCProgram.nextchar += /*Error: Function owner not recognized*/strlen(ModernizedCProgram.nextchar);
								return (byte)'?';
						} 
					}  else if (pfound.getHas_arg() == 1) {
						if (ModernizedCProgram.optind < argc) {
							ModernizedCProgram.optarg = argv[ModernizedCProgram.optind++];
						} else {
								if (print_errors) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), ("%s: option `%s' requires an argument\n"), argv[0], argv[ModernizedCProgram.optind - 1]);
								} 
								ModernizedCProgram.nextchar += /*Error: Function owner not recognized*/strlen(ModernizedCProgram.nextchar);
								return optstring[0] == (byte)':' ? (byte)':' : (byte)'?';
						} 
					} 
					ModernizedCProgram.nextchar += /*Error: Function owner not recognized*/strlen(ModernizedCProgram.nextchar);
					if (longind != ((Object)0)) {
						longind = option_index;
					} 
					if (pfound.getFlag()) {
						(pfound.getFlag()) = pfound.getVal();
						return 0;
					} 
					return pfound.getVal();
				} 
				ModernizedCProgram.nextchar = ((Object)0);
				return /* Let the application handle it.   */(byte)'W';
			} 
			if (temp[1] == (byte)':') {
				if (temp[2] == (byte)':') {
					if (ModernizedCProgram.nextchar != /* This is an option that accepts an argument optionally.  */(byte)'\0') {
						ModernizedCProgram.optarg = ModernizedCProgram.nextchar;
						ModernizedCProgram.optind++;
					} else {
							ModernizedCProgram.optarg = ((Object)0);
					} 
					ModernizedCProgram.nextchar = ((Object)0);
				} else {
						if (ModernizedCProgram.nextchar != /* This is an option that requires an argument.  */(byte)'\0') {
							ModernizedCProgram.optarg = ModernizedCProgram.nextchar/* If we end this ARGV-element by taking the rest as an arg,
									   we must advance to the next element now.  */;
							ModernizedCProgram.optind++;
						}  else if (ModernizedCProgram.optind == argc) {
							if (print_errors) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[/* 1003.2 specifies the format of this message.  */2]), ("%s: option requires an argument -- %c\n"), argv[0], c);
							} 
							ModernizedCProgram.optopt = c;
							if (optstring[0] == (byte)':') {
								c = (byte)':';
							} else {
									c = (byte)'?';
							} 
						} else {
								ModernizedCProgram.optarg = argv[/* We already incremented `optind' once;
										 increment it again when taking next ARGV-elt as argument.  */ModernizedCProgram.optind++];
						} 
						ModernizedCProgram.nextchar = ((Object)0);
				} 
			} 
			return c;
		}
	}
	public static int getopt(int argc, Byte argv, Object optstring) {
		return ModernizedCProgram._getopt_internal(argc, argv, optstring, (option)0, (int)0, 0/* Not ELIDE_CODE.  */);
	}
	/* Compile with -DTEST to make an executable for use in testing
	   the above definition of `getopt'.  */
	/* TEST */
	/*
	 * unxz implementation for Bled/busybox
	 *
	 * Copyright Â© 2014-2015 Pete Batard <pete@akeo.ie>
	 * Based on xz-embedded Â© Lasse Collin <lasse.collin@tukaani.org> - Public Domain
	 *
	 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
	 */
	// We get XZ_OPTIONS_ERROR in xz_dec_stream if this is not defined
	public static void xz_crc32_init() {
		if (!ModernizedCProgram.global_crc32_table) {
			ModernizedCProgram.global_crc32_table = ModernizedCProgram.crc32_filltable(((Object)0), 0);
		} 
	}
	public static Object xz_crc32(Object buf, Object size, Object crc) {
		// The XZ CRC32 is INVERTED!return ~ModernizedCProgram.crc32_le(~crc, buf, size, ModernizedCProgram.global_crc32_table);
	}
	public static Object cdio_get_cdtext(Object obj) {
		if (obj == NULL) {
			return NULL;
		} 
		if (NULL != obj.getOp().getGet_cdtext()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(obj.getEnv());
		} else {
				return NULL/*! 
				  Get binary cdtext information for a CdIo object .
				  
				  @param obj the CD object that may contain CD-TEXT information.
				  @return pointer to allocated memory area holding the raw CD-TEXT
				  or NULL if obj is NULL or CD-TEXT does not exist. Return value
				  must be freed with cdio_free() when done with it and not NULL.
				*/;
		} 
	}
	public static Object cdio_get_cdtext_raw(Object obj) {
		if (obj == NULL) {
			return NULL;
		} 
		if (NULL != obj.getOp().getGet_cdtext_raw()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(obj.getEnv());
		} else {
				return NULL/*!
				  Get the size of the CD in logical block address (LBA) units.
				  
				  @param p_cdio the CD object queried
				  @return the lsn. On error 0 or CDIO_INVALD_LSN.
				*/;
		} 
	}
	public static Object cdio_get_disc_last_lsn(Object p_cdio) {
		if (!p_cdio) {
			return CDIO_INVALID_LSN;
		} 
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv());
	}
	public static Object cdio_get_discmode(Object cd_obj) {
		if (!cd_obj) {
			return CDIO_DISC_MODE_ERROR;
		} 
		if (cd_obj.getOp().getGet_discmode()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(cd_obj.getEnv());
		} else {
				return CDIO_DISC_MODE_NO_INFO/*!
				  Return a string containing the name of the driver in use.
				  if CdIo is NULL (we haven't initialized a specific device driver), 
				  then return NULL.
				*/;
		} 
	}
	public static Byte cdio_get_mcn(Object p_cdio) {
		if (p_cdio && p_cdio.getOp().getGet_mcn()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv());
		} else {
				return NULL;
		} 
	}
	public static Object cdio_is_discmode_cdrom(Object discmode) {
		switch (discmode) {
		case CDIO_DISC_MODE_NO_INFO:
				return true;
		case CDIO_DISC_MODE_CD_MIXED:
		case CDIO_DISC_MODE_CD_DA:
		case CDIO_DISC_MODE_CD_DATA:
		case CDIO_DISC_MODE_CD_XA:
		default:
				return false;
		}
	}
	public static Object cdio_is_discmode_dvd(Object discmode) {
		switch (discmode) {
		case CDIO_DISC_MODE_DVD_OTHER:
				return true;
		case CDIO_DISC_MODE_DVD_RAM:
		case CDIO_DISC_MODE_DVD_ROM:
		case CDIO_DISC_MODE_DVD_R:
		case CDIO_DISC_MODE_DVD_PR:
		case CDIO_DISC_MODE_DVD_RW:
		case CDIO_DISC_MODE_DVD_PRW:
		default:
				return false;
		}
	}
	/*
	 * gen_bitmap64.c --- routines to read, write, and manipulate the new qinode and
	 * block bitmaps.
	 *
	 * Copyright (C) 2007, 2008 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Public
	 * License.
	 * %End-Header%
	 */
	/*
	 * Design of 64-bit bitmaps
	 *
	 * In order maintain ABI compatibility with programs that don't
	 * understand about 64-bit blocks/inodes,
	 * ext2fs_allocate_inode_bitmap() and ext2fs_allocate_block_bitmap()
	 * will create old-style bitmaps unless the application passes the
	 * flag EXT2_FLAG_64BITS to ext2fs_open().  If this flag is
	 * passed, then we know the application has been recompiled, so we can
	 * use the new-style bitmaps.  If it is not passed, we have to return
	 * an error if trying to open a filesystem which needs 64-bit bitmaps.
	 *
	 * The new bitmaps use a new set of structure magic numbers, so that
	 * both the old-style and new-style interfaces can identify which
	 * version of the data structure was used.  Both the old-style and
	 * new-style interfaces will support either type of bitmap, although
	 * of course 64-bit operation will only be possible when both the
	 * new-style interface and the new-style bitmap are used.
	 *
	 * For example, the new bitmap interfaces will check the structure
	 * magic numbers and so will be able to detect old-stype bitmap.  If
	 * they see an old-style bitmap, they will pass it to the gen_bitmap.c
	 * functions for handling.  The same will be true for the old
	 * interfaces as well.
	 *
	 * The new-style interfaces will have several different back-end
	 * implementations, so we can support different encodings that are
	 * appropriate for different applications.  In general the default
	 * should be whatever makes sense, and what the application/library
	 * will use.  However, e2fsck may need specialized implementations for
	 * its own uses.  For example, when doing parent directory pointer
	 * loop detections in pass 3, the bitmap will *always* be sparse, so
	 * e2fsck can request an encoding which is optimized for that.
	 */
	public static void warn_bitmap(Object bitmap, int code, Object arg) {
		if (bitmap.getDescription()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, bitmap.getBase_error_code() + code, "#%llu for %s", arg, bitmap.getDescription());
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, bitmap.getBase_error_code() + code, "#%llu", arg);
		} 
	}
	public static Object ext2fs_alloc_generic_bmap(Object fs, Object magic, int type, Object start, Object end, Object real_end, Object descr, Object ret) {
		ext2fs_generic_bitmap_64 bitmap = new ext2fs_generic_bitmap_64();
		ext2_bitmap_ops ops = new ext2_bitmap_ops();
		 num_dirs = new ();
		 retval = new ();
		if (!type) {
			type = 1;
		} 
		switch (type) {
		case 2:
				ops = ModernizedCProgram.ext2fs_blkmap64_rbtree;
				break;
		case 1:
				ops = ModernizedCProgram.ext2fs_blkmap64_bitarray;
				break;
		case 3:
				retval = ModernizedCProgram.ext2fs_get_num_dirs(fs, num_dirs);
				if (retval || num_dirs > (fs.getSuper().getS_inodes_count() / 320)) {
					ops = ModernizedCProgram.ext2fs_blkmap64_bitarray;
				} else {
						ops = ModernizedCProgram.ext2fs_blkmap64_rbtree;
				} 
				break;
		default:
				return 22;
		}
		retval = ModernizedCProgram.ext2fs_get_memzero(/*Error: Unsupported expression*/, bitmap);
		if (retval) {
			return retval;
		} 
		bitmap.setMagic(/* XXX factor out, repeated in copy_bmap */magic);
		bitmap.setFs(fs);
		bitmap.setStart(start);
		bitmap.setEnd(end);
		bitmap.setReal_end(real_end);
		bitmap.setBitmap_ops(ops);
		bitmap.setCluster_bits(0);
		switch (magic) {
		case EXT2_ET_MAGIC_BLOCK_BITMAP64:
				bitmap.setBase_error_code(EXT2_ET_BAD_BLOCK_MARK);
				bitmap.setCluster_bits(fs.getCluster_ratio_bits());
				break;
		case EXT2_ET_MAGIC_INODE_BITMAP64:
				bitmap.setBase_error_code(EXT2_ET_BAD_INODE_MARK);
				break;
		default:
				bitmap.setBase_error_code(EXT2_ET_BAD_GENERIC_MARK);
		}
		if (descr) {
			retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Function owner not recognized*/strlen(descr) + 1, bitmap.getDescription());
			if (retval) {
				ModernizedCProgram.ext2fs_free_mem(bitmap);
				return retval;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(bitmap.getDescription(), descr);
		} else {
				bitmap.setDescription(0);
		} 
		retval = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, bitmap);
		if (retval) {
			ModernizedCProgram.ext2fs_free_mem(bitmap.getDescription());
			ModernizedCProgram.ext2fs_free_mem(bitmap);
			return retval;
		} 
		ret = (ext2fs_generic_bitmap)bitmap;
		return 0;
	}
	/* ENABLE_BMAP_STATS_OPS */
	public static void ext2fs_free_generic_bmap(Object gen_bmap) {
		ext2fs_generic_bitmap_64 bmap = (ext2fs_generic_bitmap_64)gen_bmap;
		if (!bmap) {
			return /*Error: Unsupported expression*/;
		} 
		if ((((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			ModernizedCProgram.ext2fs_free_generic_bitmap(gen_bmap);
			return /*Error: Unsupported expression*/;
		} 
		if (!(((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bmap);
		if (bmap.getDescription()) {
			ModernizedCProgram.ext2fs_free_mem(bmap.getDescription());
			bmap.setDescription(0);
		} 
		bmap.setMagic(0);
		ModernizedCProgram.ext2fs_free_mem(bmap);
	}
	public static Object ext2fs_copy_generic_bmap(Object gen_src, Object dest) {
		ext2fs_generic_bitmap_64 src = (ext2fs_generic_bitmap_64)gen_src;
		byte descr;
		byte new_descr;
		ext2fs_generic_bitmap_64 new_bmap = new ext2fs_generic_bitmap_64();
		 retval = new ();
		if (!src) {
			return 22;
		} 
		if ((((src).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((src).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((src).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			return ModernizedCProgram.ext2fs_copy_generic_bitmap(gen_src, dest);
		} 
		if (!(((src).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((src).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((src).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 22;
		} 
		retval = ModernizedCProgram.ext2fs_get_memzero(/*Error: Unsupported expression*//* Allocate a new bitmap struct */, new_bmap);
		if (retval) {
			return retval;
		} 
		new_bmap.setMagic(src.getMagic());
		new_bmap.setFs(src.getFs());
		new_bmap.setStart(src.getStart());
		new_bmap.setEnd(src.getEnd());
		new_bmap.setReal_end(src.getReal_end());
		new_bmap.setBitmap_ops(src.getBitmap_ops());
		new_bmap.setBase_error_code(src.getBase_error_code());
		new_bmap.setCluster_bits(src.getCluster_bits());
		descr = src.getDescription();
		if (descr) {
			retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Function owner not recognized*/strlen(descr) + 10, new_descr);
			if (retval) {
				ModernizedCProgram.ext2fs_free_mem(new_bmap);
				return retval;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(new_descr, "copy of ");
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcat(new_descr, descr);
			new_bmap.setDescription(new_descr);
		} 
		retval = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(src, new_bmap);
		if (retval) {
			ModernizedCProgram.ext2fs_free_mem(new_bmap.getDescription());
			ModernizedCProgram.ext2fs_free_mem(new_bmap);
			return retval;
		} 
		dest = (ext2fs_generic_bitmap)new_bmap;
		return 0;
	}
	public static Object ext2fs_resize_generic_bmap(Object gen_bmap, Object new_end, Object new_real_end) {
		ext2fs_generic_bitmap_64 bmap = (ext2fs_generic_bitmap_64)gen_bmap;
		if (!bmap) {
			return 22;
		} 
		if ((((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			return ModernizedCProgram.ext2fs_resize_generic_bitmap(gen_bmap.getMagic(), new_end, new_real_end, gen_bmap);
		} 
		if (!(((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 22;
		} 
		;
		;
		;
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bmap, new_end, new_real_end);
	}
	public static Object ext2fs_fudge_generic_bmap_end(Object gen_bitmap, Object neq, Object end, Object oend) {
		ext2fs_generic_bitmap_64 bitmap = (ext2fs_generic_bitmap_64)gen_bitmap;
		if (!bitmap) {
			return 22;
		} 
		if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			 tmp_oend = new ();
			int retval;
			retval = ModernizedCProgram.ext2fs_fudge_generic_bitmap_end(gen_bitmap, bitmap.getMagic(), neq, end, tmp_oend);
			if (oend) {
				oend = tmp_oend;
			} 
			return retval;
		} 
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 22;
		} 
		if (end > bitmap.getReal_end()) {
			return neq;
		} 
		if (oend) {
			oend = bitmap.getEnd();
		} 
		bitmap.setEnd(end);
		return 0;
	}
	public static Object ext2fs_get_generic_bmap_start(Object gen_bitmap) {
		ext2fs_generic_bitmap_64 bitmap = (ext2fs_generic_bitmap_64)gen_bitmap;
		if (!bitmap) {
			return 22;
		} 
		if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			return ModernizedCProgram.ext2fs_get_generic_bitmap_start(gen_bitmap);
		} 
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 22;
		} 
		return bitmap.getStart();
	}
	public static Object ext2fs_get_generic_bmap_end(Object gen_bitmap) {
		ext2fs_generic_bitmap_64 bitmap = (ext2fs_generic_bitmap_64)gen_bitmap;
		if (!bitmap) {
			return 22;
		} 
		if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			return ModernizedCProgram.ext2fs_get_generic_bitmap_end(gen_bitmap);
		} 
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 22;
		} 
		return bitmap.getEnd();
	}
	public static void ext2fs_clear_generic_bmap(Object gen_bitmap) {
		ext2fs_generic_bitmap_64 bitmap = (ext2fs_generic_bitmap_64)gen_bitmap;
		if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			ModernizedCProgram.ext2fs_clear_generic_bitmap(gen_bitmap);
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bitmap);
		} 
	}
	public static int ext2fs_mark_generic_bmap(Object gen_bitmap, Object arg) {
		ext2fs_generic_bitmap_64 bitmap = (ext2fs_generic_bitmap_64)gen_bitmap;
		if (!bitmap) {
			return 0;
		} 
		if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if (arg & ~-1024) {
				ModernizedCProgram.ext2fs_warn_bitmap2(gen_bitmap, 0, -1024);
				return 0;
			} 
			return ModernizedCProgram.ext2fs_mark_generic_bitmap(gen_bitmap, arg);
		} 
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 0;
		} 
		arg >>=  bitmap.getCluster_bits();
		if ((arg < bitmap.getStart()) || (arg > bitmap.getEnd())) {
			ModernizedCProgram.warn_bitmap(bitmap, 0, arg);
			return 0;
		} 
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bitmap, arg);
	}
	public static int ext2fs_unmark_generic_bmap(Object gen_bitmap, Object arg) {
		ext2fs_generic_bitmap_64 bitmap = (ext2fs_generic_bitmap_64)gen_bitmap;
		if (!bitmap) {
			return 0;
		} 
		if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if (arg & ~-1024) {
				ModernizedCProgram.ext2fs_warn_bitmap2(gen_bitmap, 1, -1024);
				return 0;
			} 
			return ModernizedCProgram.ext2fs_unmark_generic_bitmap(gen_bitmap, arg);
		} 
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 0;
		} 
		arg >>=  bitmap.getCluster_bits();
		;
		;
		;
		if ((arg < bitmap.getStart()) || (arg > bitmap.getEnd())) {
			ModernizedCProgram.warn_bitmap(bitmap, 1, arg);
			return 0;
		} 
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bitmap, arg);
	}
	public static int ext2fs_test_generic_bmap(Object gen_bitmap, Object arg) {
		ext2fs_generic_bitmap_64 bitmap = (ext2fs_generic_bitmap_64)gen_bitmap;
		if (!bitmap) {
			return 0;
		} 
		if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if (arg & ~-1024) {
				ModernizedCProgram.ext2fs_warn_bitmap2(gen_bitmap, 2, -1024);
				return 0;
			} 
			return ModernizedCProgram.ext2fs_test_generic_bitmap(gen_bitmap, arg);
		} 
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 0;
		} 
		arg >>=  bitmap.getCluster_bits();
		if ((arg < bitmap.getStart()) || (arg > bitmap.getEnd())) {
			ModernizedCProgram.warn_bitmap(bitmap, 2, arg);
			return 0;
		} 
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bitmap, arg);
	}
	public static Object ext2fs_set_generic_bmap_range(Object gen_bmap, Object start, int num, Object in) {
		ext2fs_generic_bitmap_64 bmap = (ext2fs_generic_bitmap_64)gen_bmap;
		if (!bmap) {
			return 22;
		} 
		if ((((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if ((start + num - 1) & ~-1024) {
				ModernizedCProgram.ext2fs_warn_bitmap2(gen_bmap, 1, -1024);
				return 22;
			} 
			return ModernizedCProgram.ext2fs_set_generic_bitmap_range(gen_bmap, bmap.getMagic(), start, num, in);
		} 
		if (!(((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 22;
		} 
		;
		;
		;
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bmap, start, num, in);
	}
	public static Object ext2fs_get_generic_bmap_range(Object gen_bmap, Object start, int num, Object out) {
		ext2fs_generic_bitmap_64 bmap = (ext2fs_generic_bitmap_64)gen_bmap;
		if (!bmap) {
			return 22;
		} 
		if ((((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if ((start + num - 1) & ~-1024) {
				ModernizedCProgram.ext2fs_warn_bitmap2(gen_bmap, 1, -1024);
				return 22;
			} 
			return ModernizedCProgram.ext2fs_get_generic_bitmap_range(gen_bmap, bmap.getMagic(), start, num, out);
		} 
		if (!(((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 22;
		} 
		;
		;
		;
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bmap, start, num, out);
	}
	public static Object ext2fs_compare_generic_bmap(Object neq, Object gen_bm1, Object gen_bm2) {
		ext2fs_generic_bitmap_64 bm1 = (ext2fs_generic_bitmap_64)gen_bm1;
		ext2fs_generic_bitmap_64 bm2 = (ext2fs_generic_bitmap_64)gen_bm2;
		 i = new ();
		if (!bm1 || !bm2) {
			return 22;
		} 
		if (bm1.getMagic() != bm2.getMagic()) {
			return 22;
		} 
		if ((((bm1).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bm1).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bm1).getMagic() == /* Now we know both bitmaps have the same magic */EXT2_ET_MAGIC_INODE_BITMAP))) {
			return ModernizedCProgram.ext2fs_compare_generic_bitmap(bm1.getMagic(), neq, gen_bm1, gen_bm2);
		} 
		if (!(((bm1).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bm1).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bm1).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 22;
		} 
		if ((bm1.getStart() != bm2.getStart()) || (bm1.getEnd() != bm2.getEnd())) {
			return neq;
		} 
		for (i = bm1.getEnd() - ((bm1.getEnd() - bm1.getStart()) % 8); i <= bm1.getEnd(); i++) {
			if (ModernizedCProgram.ext2fs_test_generic_bmap(gen_bm1, i) != ModernizedCProgram.ext2fs_test_generic_bmap(gen_bm2, i)) {
				return neq;
			} 
		}
		return 0;
	}
	public static void ext2fs_set_generic_bmap_padding(Object gen_bmap) {
		ext2fs_generic_bitmap_64 bmap = (ext2fs_generic_bitmap_64)gen_bmap;
		 start = new ();
		 num = new ();
		if ((((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			ModernizedCProgram.ext2fs_set_generic_bitmap_padding(gen_bmap);
			return /*Error: Unsupported expression*/;
		} 
		start = bmap.getEnd() + 1;
		num = bmap.getReal_end() - bmap.getEnd();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bmap, start, num/* XXX ought to warn on error */);
	}
	public static int ext2fs_test_block_bitmap_range2(Object gen_bmap, Object block, int num) {
		ext2fs_generic_bitmap_64 bmap = (ext2fs_generic_bitmap_64)gen_bmap;
		 end = block + num;
		if (!bmap) {
			return 22;
		} 
		if (num == 1) {
			return !ModernizedCProgram.ext2fs_test_generic_bmap((ext2fs_generic_bitmap)bmap, block);
		} 
		if ((((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if ((block & ~-1024) || ((block + num - 1) & ~-1024)) {
				ModernizedCProgram.ext2fs_warn_bitmap2((ext2fs_generic_bitmap)bmap, 1, -1024);
				return 22;
			} 
			return ModernizedCProgram.ext2fs_test_block_bitmap_range((ext2fs_generic_bitmap)bmap, block, num);
		} 
		if (!(((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 22;
		} 
		;
		;
		;
		block >>=  bmap.getCluster_bits();
		end += (1 << bmap.getCluster_bits()) - 1;
		end >>=  bmap.getCluster_bits();
		num = end - block;
		if ((block < bmap.getStart()) || (block > bmap.getEnd()) || (block + num - 1 > bmap.getEnd())) {
			ModernizedCProgram.ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_TEST, block, bmap.getDescription());
			return 22;
		} 
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bmap, block, num);
	}
	public static void ext2fs_mark_block_bitmap_range2(Object gen_bmap, Object block, int num) {
		ext2fs_generic_bitmap_64 bmap = (ext2fs_generic_bitmap_64)gen_bmap;
		 end = block + num;
		if (!bmap) {
			return /*Error: Unsupported expression*/;
		} 
		if ((((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if ((block & ~-1024) || ((block + num - 1) & ~-1024)) {
				ModernizedCProgram.ext2fs_warn_bitmap2((ext2fs_generic_bitmap)bmap, 1, -1024);
				return /*Error: Unsupported expression*/;
			} 
			ModernizedCProgram.ext2fs_mark_block_bitmap_range((ext2fs_generic_bitmap)bmap, block, num);
		} 
		if (!(((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return /*Error: Unsupported expression*/;
		} 
		;
		;
		;
		block >>=  bmap.getCluster_bits();
		end += (1 << bmap.getCluster_bits()) - 1;
		end >>=  bmap.getCluster_bits();
		num = end - block;
		if ((block < bmap.getStart()) || (block > bmap.getEnd()) || (block + num - 1 > bmap.getEnd())) {
			ModernizedCProgram.ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_MARK, block, bmap.getDescription());
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bmap, block, num);
	}
	public static void ext2fs_unmark_block_bitmap_range2(Object gen_bmap, Object block, int num) {
		ext2fs_generic_bitmap_64 bmap = (ext2fs_generic_bitmap_64)gen_bmap;
		 end = block + num;
		if (!bmap) {
			return /*Error: Unsupported expression*/;
		} 
		if ((((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if ((block & ~-1024) || ((block + num - 1) & ~-1024)) {
				ModernizedCProgram.ext2fs_warn_bitmap2((ext2fs_generic_bitmap)bmap, 1, -1024);
				return /*Error: Unsupported expression*/;
			} 
			ModernizedCProgram.ext2fs_unmark_block_bitmap_range((ext2fs_generic_bitmap)bmap, block, num);
		} 
		if (!(((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return /*Error: Unsupported expression*/;
		} 
		;
		;
		;
		block >>=  bmap.getCluster_bits();
		end += (1 << bmap.getCluster_bits()) - 1;
		end >>=  bmap.getCluster_bits();
		num = end - block;
		if ((block < bmap.getStart()) || (block > bmap.getEnd()) || (block + num - 1 > bmap.getEnd())) {
			ModernizedCProgram.ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_UNMARK, block, bmap.getDescription());
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bmap, block, num);
	}
	public static void ext2fs_warn_bitmap32(Object gen_bitmap, Object func) {
		ext2fs_generic_bitmap_64 bitmap = (ext2fs_generic_bitmap_64)gen_bitmap;
		if (bitmap && bitmap.getDescription()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, EXT2_ET_MAGIC_GENERIC_BITMAP, "called %s with 64-bit bitmap for %s", func, bitmap.getDescription());
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, EXT2_ET_MAGIC_GENERIC_BITMAP, "called %s with 64-bit bitmap", func);
		} 
	}
	public static Object ext2fs_convert_subcluster_bitmap(Object fs, Object bitmap) {
		ext2fs_generic_bitmap_64 bmap = new ext2fs_generic_bitmap_64();
		ext2fs_generic_bitmap_64 cmap = new ext2fs_generic_bitmap_64();
		ext2fs_block_bitmap gen_bmap = bitmap;
		ext2fs_block_bitmap gen_cmap = new ext2fs_block_bitmap();
		 retval = new ();
		 i = new ();
		 b_end = new ();
		 c_end = new ();
		int n;
		int ratio;
		bmap = (ext2fs_generic_bitmap_64)gen_bmap;
		if (fs.getCluster_ratio_bits() == ModernizedCProgram.ext2fs_get_bitmap_granularity(gen_bmap)) {
			return /* Nothing to do */0;
		} 
		retval = ModernizedCProgram.ext2fs_allocate_block_bitmap(fs, "converted cluster bitmap", gen_cmap);
		if (retval) {
			return retval;
		} 
		cmap = (ext2fs_generic_bitmap_64)gen_cmap;
		i = bmap.getStart();
		b_end = bmap.getEnd();
		bmap.setEnd(bmap.getReal_end());
		c_end = cmap.getEnd();
		cmap.setEnd(cmap.getReal_end());
		n = 0;
		ratio = 1 << fs.getCluster_ratio_bits();
		while (i < bmap.getReal_end()) {
			if (ModernizedCProgram.ext2fs_test_block_bitmap2(gen_bmap, i)) {
				ModernizedCProgram.ext2fs_mark_block_bitmap2(gen_cmap, i);
				i += ratio - n;
				n = 0;
				continue;
			} 
			i++;
			n++;
			if (n >= ratio) {
				n = 0;
			} 
		}
		bmap.setEnd(b_end);
		cmap.setEnd(c_end);
		ModernizedCProgram.ext2fs_free_block_bitmap(gen_bmap);
		bitmap = (ext2fs_block_bitmap)cmap;
		return 0;
	}
	public static Object ext2fs_find_first_zero_generic_bmap(Object bitmap, Object start, Object end, Object out) {
		ext2fs_generic_bitmap_64 bmap64 = (ext2fs_generic_bitmap_64)bitmap;
		 cstart = new ();
		 cend = new ();
		 cout = new ();
		 retval = new ();
		if (!bitmap) {
			return 22;
		} 
		if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			 blk = 0;
			if (((start) & ~-1024) || ((end) & ~-1024)) {
				ModernizedCProgram.ext2fs_warn_bitmap2(bitmap, 2, start);
				return 22;
			} 
			retval = ModernizedCProgram.ext2fs_find_first_zero_generic_bitmap(bitmap, start, end, blk);
			if (retval == 0) {
				out = blk;
			} 
			return retval;
		} 
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 22;
		} 
		cstart = start >> bmap64.getCluster_bits();
		cend = end >> bmap64.getCluster_bits();
		if (cstart < bmap64.getStart() || cend > bmap64.getEnd() || start > end) {
			ModernizedCProgram.warn_bitmap(bmap64, 2, start);
			return 22;
		} 
		for (cout = cstart; cout <= cend; cout++) {
			if (!/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bmap64, cout)) {
				;
			} 
		}
		return 2;
	}
	public static Object ext2fs_find_first_set_generic_bmap(Object bitmap, Object start, Object end, Object out) {
		ext2fs_generic_bitmap_64 bmap64 = (ext2fs_generic_bitmap_64)bitmap;
		 cstart = new ();
		 cend = new ();
		 cout = new ();
		 retval = new ();
		if (!bitmap) {
			return 22;
		} 
		if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			 blk = 0;
			if (((start) & ~-1024) || ((end) & ~-1024)) {
				ModernizedCProgram.ext2fs_warn_bitmap2(bitmap, 2, start);
				return 22;
			} 
			retval = ModernizedCProgram.ext2fs_find_first_set_generic_bitmap(bitmap, start, end, blk);
			if (retval == 0) {
				out = blk;
			} 
			return retval;
		} 
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 22;
		} 
		cstart = start >> bmap64.getCluster_bits();
		cend = end >> bmap64.getCluster_bits();
		if (cstart < bmap64.getStart() || cend > bmap64.getEnd() || start > end) {
			ModernizedCProgram.warn_bitmap(bmap64, 2, start);
			return 22;
		} 
		for (cout = cstart; cout <= cend; cout++) {
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bmap64, cout)) {
				;
			} 
		}
		return 2;
	}
	/*
	 * blknum.c --- Functions to handle blk64_t and high/low 64-bit block
	 * number.
	 *
	 * Copyright IBM Corporation, 2007
	 * Author Jose R. Santos <jrs@us.ibm.com>
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Public
	 * License.
	 * %End-Header%
	 */
	/*
	 * Return the group # of a block
	 */
	public static Object ext2fs_group_of_blk2(Object fs, Object blk) {
		return (blk - fs.getSuper().getExt2_super_block()) / fs.getSuper().getExt2_super_block();
	}
	public static Object ext2fs_group_first_block2(Object fs, Object group) {
		return fs.getSuper().getExt2_super_block() + /*Error: Function owner not recognized*/EXT2_GROUPS_TO_BLOCKS(fs.getSuper(), group/*
		 * Return the last block (inclusive) in a group
		 */);
	}
	public static Object ext2fs_group_last_block2(Object fs, Object group) {
		return (group == fs.getGroup_desc_count() - 1 ? fs.getSuper().ext2fs_blocks_count() - 1 : ModernizedCProgram.ext2fs_group_first_block2(fs, group) + (fs.getSuper().getExt2_super_block() - 1/*
		 * Return the number of blocks in a group
		 */));
	}
	public static int ext2fs_group_blocks_count(Object fs, Object group) {
		int num_blocks;
		if (group == fs.getGroup_desc_count() - 1) {
			num_blocks = (fs.getSuper().ext2fs_blocks_count() - fs.getSuper().getExt2_super_block()) % fs.getSuper().getExt2_super_block();
			if (!num_blocks) {
				num_blocks = fs.getSuper().getExt2_super_block();
			} 
		} else {
				num_blocks = fs.getSuper().getExt2_super_block();
		} 
		return num_blocks/*
		 * Return the inode data block count
		 */;
	}
	public static Object ext2fs_block_bitmap_checksum(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		 csum = new ();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		csum = generatedExt4_group_desc;
		if (/*Error: Function owner not recognized*/EXT2_DESC_SIZE(fs.getSuper()) >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_LOCATION) {
			csum |=  (()generatedExt4_group_desc << 16);
		} 
		return csum/*
		 * Return the block bitmap block of a group
		 */;
	}
	public static Object ext2fs_block_bitmap_loc(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		return generatedExt4_group_desc | (fs.getSuper().ext2fs_has_feature_64bit() ? ()generatedExt4_group_desc << 32 : 0/*
		 * Set the block bitmap block of a group
		 */);
	}
	public static void ext2fs_block_bitmap_loc_set(Object fs, Object group, Object blk) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		gdp.setExt4_group_desc(blk);
		if (fs.getSuper().ext2fs_has_feature_64bit()) {
			gdp.setExt4_group_desc(()blk >> 32/*
			 * Return the inode bitmap checksum of a group
			 */);
		} 
	}
	public static Object ext2fs_inode_bitmap_checksum(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		 csum = new ();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		csum = generatedExt4_group_desc;
		if (/*Error: Function owner not recognized*/EXT2_DESC_SIZE(fs.getSuper()) >= EXT4_BG_INODE_BITMAP_CSUM_HI_END) {
			csum |=  (()generatedExt4_group_desc << 16);
		} 
		return csum/*
		 * Return the inode bitmap block of a group
		 */;
	}
	public static Object ext2fs_inode_bitmap_loc(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		return generatedExt4_group_desc | (fs.getSuper().ext2fs_has_feature_64bit() ? ()generatedExt4_group_desc << 32 : 0/*
		 * Set the inode bitmap block of a group
		 */);
	}
	public static void ext2fs_inode_bitmap_loc_set(Object fs, Object group, Object blk) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		gdp.setExt4_group_desc(blk);
		if (fs.getSuper().ext2fs_has_feature_64bit()) {
			gdp.setExt4_group_desc(()blk >> 32/*
			 * Return the inode table block of a group
			 */);
		} 
	}
	public static Object ext2fs_inode_table_loc(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		return generatedExt4_group_desc | (fs.getSuper().ext2fs_has_feature_64bit() ? ()generatedExt4_group_desc << 32 : 0/*
		 * Set the inode table block of a group
		 */);
	}
	public static void ext2fs_inode_table_loc_set(Object fs, Object group, Object blk) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		gdp.setExt4_group_desc(blk);
		if (fs.getSuper().ext2fs_has_feature_64bit()) {
			gdp.setExt4_group_desc(()blk >> 32/*
			 * Return the free blocks count of a group
			 */);
		} 
	}
	public static Object ext2fs_bg_free_blocks_count(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		return generatedExt4_group_desc | (fs.getSuper().ext2fs_has_feature_64bit() ? ()generatedExt4_group_desc << 16 : 0/*
		 * Set the free blocks count of a group
		 */);
	}
	public static void ext2fs_bg_free_blocks_count_set(Object fs, Object group, Object n) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		gdp.setExt4_group_desc(n);
		if (fs.getSuper().ext2fs_has_feature_64bit()) {
			gdp.setExt4_group_desc(()n >> 16/*
			 * Return the free inodes count of a group
			 */);
		} 
	}
	public static Object ext2fs_bg_free_inodes_count(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		return generatedExt4_group_desc | (fs.getSuper().ext2fs_has_feature_64bit() ? ()generatedExt4_group_desc << 16 : 0/*
		 * Set the free inodes count of a group
		 */);
	}
	public static void ext2fs_bg_free_inodes_count_set(Object fs, Object group, Object n) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		gdp.setExt4_group_desc(n);
		if (fs.getSuper().ext2fs_has_feature_64bit()) {
			gdp.setExt4_group_desc(()n >> 16/*
			 * Return the used dirs count of a group
			 */);
		} 
	}
	public static Object ext2fs_bg_used_dirs_count(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		return generatedExt4_group_desc | (fs.getSuper().ext2fs_has_feature_64bit() ? ()generatedExt4_group_desc << 16 : 0/*
		 * Set the used dirs count of a group
		 */);
	}
	public static void ext2fs_bg_used_dirs_count_set(Object fs, Object group, Object n) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		gdp.setExt4_group_desc(n);
		if (fs.getSuper().ext2fs_has_feature_64bit()) {
			gdp.setExt4_group_desc(()n >> 16/*
			 * Return the unused inodes count of a group
			 */);
		} 
	}
	public static Object ext2fs_bg_itable_unused(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		return generatedExt4_group_desc | (fs.getSuper().ext2fs_has_feature_64bit() ? ()generatedExt4_group_desc << 16 : 0/*
		 * Set the unused inodes count of a group
		 */);
	}
	public static void ext2fs_bg_itable_unused_set(Object fs, Object group, Object n) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		gdp.setExt4_group_desc(n);
		if (fs.getSuper().ext2fs_has_feature_64bit()) {
			gdp.setExt4_group_desc(()n >> 16/*
			 * Get the flags for this block group
			 */);
		} 
	}
	public static Object ext2fs_bg_flags(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		return generatedExt4_group_desc;
	}
	public static void ext2fs_bg_flags_zap(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		gdp.setExt4_group_desc(0);
		return /*Error: Unsupported expression*/;/*
		 * Get the value of a particular flag for this block group
		 */
	}
	public static int ext2fs_bg_flags_test(Object fs, Object group, Object bg_flag) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		return generatedExt4_group_desc & bg_flag/*
		 * Set a flag or set of flags for this block group
		 */;
	}
	public static void ext2fs_bg_flags_set(Object fs, Object group, Object bg_flags) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		generatedExt4_group_desc |=  bg_flags;
		return /*Error: Unsupported expression*/;/*
		 * Clear a flag or set of flags for this block group
		 */
	}
	public static void ext2fs_bg_flags_clear(Object fs, Object group, Object bg_flags) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		generatedExt4_group_desc &=  ~bg_flags;
		return /*Error: Unsupported expression*/;/*
		 * Get the checksum for this block group
		 */
	}
	public static Object ext2fs_bg_checksum(Object fs, Object group) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		Object generatedExt4_group_desc = gdp.getExt4_group_desc();
		return generatedExt4_group_desc;
	}
	public static void ext2fs_bg_checksum_set(Object fs, Object group, Object checksum) {
		ext4_group_desc gdp = new ext4_group_desc();
		ext4_group_desc ext4_group_desc = new ext4_group_desc();
		gdp = ext4_group_desc.ext4fs_group_desc(fs, fs.getGroup_desc(), group);
		gdp.setExt4_group_desc(checksum);
		return /*Error: Unsupported expression*/;/*
		 * Get the acl block of a file
		 */
	}
	public static Object ext2fs_file_acl_block(Object fs, Object inode) {
		 blk = inode.getExt2_inode();
		if (fs && fs.getSuper().ext2fs_has_feature_64bit()) {
			blk |=  (()inode.getExt2_inode().getLinux2().getL_i_file_acl_high()) << 32;
		} 
		return blk/*
		 * Set the acl block of a file
		 */;
	}
	/* vi: set sw=4 ts=4: */
	/*
	 * Copyright (C) 2002 by Glenn McGrath
	 *
	 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
	 */
	//#include <fnmatch.h>
	/* Find a string in a shell pattern list */
	public static Object find_list_entry(Object list, Object filename) {
		while (list) {
			if (ModernizedCProgram.fnmatch(list.getData(), filename, 0) == 0) {
				return list;
			} 
			list = list.getLink();
		}
		return ((Object)0/* Same, but compares only path components present in pattern
		 * (extra trailing path components in filename are assumed to match)
		 */);
	}
	public static Object find_list_entry2(Object list, Object filename) {
		byte[] buf = new byte[260];
		int pattern_slash_cnt;
		byte c;
		byte d;
		while (list) {
			c = list.getData();
			pattern_slash_cnt = 0;
			while (c) {
				if (c++ == (byte)'/') {
					pattern_slash_cnt++;
				} 
			}
			c = filename;
			d = buf;
			while (c && d != buf + /*Error: sizeof expression not supported yet*/ - /* paranoia is better than buffer overflows */1) {
				if (c == (byte)'/' && --pattern_slash_cnt < 0) {
					break;
				} 
				d++ = c++;
			}
			d = (byte)'\0';
			if (ModernizedCProgram.fnmatch(list.getData(), buf, 0) == 0) {
				return list;
			} 
			list = list.getLink();
		}
		return ((Object)0);
	}
	public static int IsLeapYear(int Year) {
		return Year % 4 == 0 && (Year % 100 != 0 || Year % 400 == 0) ? 1 : 0;
	}
	public static int DaysSinceEpoch(int Year) {
		int Days;
		/* Don't include a leap day from the current year */Year--;
		Days = Year * 365 + Year / 4 - Year / 100 + Year / 400;
		Days -= (1601 - 1) * 365 + (1601 - 1) / 4 - (1601 - 1) / 100 + (1601 - 1) / 400;
		return Days;
	}
	public static Object RtlTimeFieldsToTime(Object TimeFields, Object Time) {
		int CurMonth;
		TIME_FIELDS IntTimeFields = new TIME_FIELDS();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(IntTimeFields, TimeFields, /*Error: Unsupported expression*/);
		if (TimeFields.getMilliseconds() < 0 || TimeFields.getMilliseconds() > 999 || TimeFields.getSecond() < 0 || TimeFields.getSecond() > 59 || TimeFields.getMinute() < 0 || TimeFields.getMinute() > 59 || TimeFields.getHour() < 0 || TimeFields.getHour() > 23 || TimeFields.getMonth() < 1 || TimeFields.getMonth() > 12 || TimeFields.getDay() < 1 || TimeFields.getDay() > ModernizedCProgram.MonthLengths[ModernizedCProgram.IsLeapYear(TimeFields.getYear())][TimeFields.getMonth() - 1] || TimeFields.getYear() < 1601) {
			return 0;
		} 
		int generatedYear = IntTimeFields.getYear();
		Time.setQuadPart(ModernizedCProgram.DaysSinceEpoch(generatedYear));
		int generatedMonth = IntTimeFields.getMonth();
		for (CurMonth = 1; CurMonth < generatedMonth; CurMonth++) {
			Time.getQuadPart() += ModernizedCProgram.MonthLengths[ModernizedCProgram.IsLeapYear(generatedYear)][CurMonth - 1];
		}
		int generatedDay = IntTimeFields.getDay();
		Time.getQuadPart() += generatedDay - 1;
		Time.getQuadPart() *= 86400;
		int generatedHour = IntTimeFields.getHour();
		int generatedMinute = IntTimeFields.getMinute();
		int generatedSecond = IntTimeFields.getSecond();
		Time.getQuadPart() += generatedHour * 3600 + generatedMinute * 60 + generatedSecond;
		Time.getQuadPart() *= 10000000;
		int generatedMilliseconds = IntTimeFields.getMilliseconds();
		Time.getQuadPart() += generatedMilliseconds * 10000;
		return 1;
	}
	public static void FatDateTimeToSystemTime(Object SystemTime, Object FatDateTime, Object TenMs) {
		TIME_FIELDS TimeFields = new TIME_FIELDS();
		TimeFields.setYear(FatDateTime.getDate().getYear() + /* Setup time fields */1980);
		TimeFields.setMonth(FatDateTime.getDate().getMonth());
		TimeFields.setDay(FatDateTime.getDate().getDay());
		TimeFields.setHour(FatDateTime.getTime().getHour());
		TimeFields.setMinute(FatDateTime.getTime().getMinute());
		TimeFields.setSecond((FatDateTime.getTime().getDoubleSeconds() << 1/* Adjust up to 10 milliseconds
			* if the parameter was supplied
			*/));
		int generatedSecond = TimeFields.getSecond();
		if (((CHAR)((ULONG_PTR)(TenMs)) != (CHAR)((Object)0))) {
			generatedSecond += TenMs / 100;
			TimeFields.setMilliseconds((TenMs % 100) * 10);
		} else {
				TimeFields.setMilliseconds(0);
		} 
		if (generatedSecond > 59) {
			TimeFields.setSecond(/* Fix seconds value that might get beyond the bound */0);
		} 
		if (!ModernizedCProgram.RtlTimeFieldsToTime(TimeFields, /* Perform conversion to system time if possible */SystemTime)) {
			SystemTime.setQuadPart(/* Set to default time if conversion failed */0/* http://www.multiboot.ru/msdos8.htm & http://en.wikipedia.org/wiki/Windows_Me#Real_mode_DOS
			 * COMMAND.COM and IO.SYS from diskcopy.dll are from the WinME crippled version
			 * that removed real mode DOS => they must be patched:
			 * IO.SYS            000003AA          75 -> EB
			 * COMMAND.COM       00006510          75 -> EB
			 */);
		} 
	}
	public static Object Patch_COMMAND_COM(Object filestart, Object filesize) {
		BYTE[] expected = new BYTE[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		ModernizedCProgram._uprintf("Patching COMMAND.COM...\n");
		if (filesize != 93040) {
			ModernizedCProgram._uprintf("  unexpected file size\n");
			return 0;
		} 
		if (/*Error: Function owner not recognized*/memcmp(ModernizedCProgram.DiskImage[filestart + -1024], expected, /*Error: sizeof expression not supported yet*/) != 0) {
			ModernizedCProgram._uprintf("  unexpected binary data\n");
			return 0;
		} 
		ModernizedCProgram.DiskImage[filestart + -1024] = -1024;
		return 1;
	}
	public static Object Patch_IO_SYS(Object filestart, Object filesize) {
		BYTE[] expected = new BYTE[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		ModernizedCProgram._uprintf("Patching IO.SYS...\n");
		if (filesize != 116736) {
			ModernizedCProgram._uprintf("  unexpected file size\n");
			return 0;
		} 
		if (/*Error: Function owner not recognized*/memcmp(ModernizedCProgram.DiskImage[filestart + -1024], expected, /*Error: sizeof expression not supported yet*/) != 0) {
			ModernizedCProgram._uprintf("  unexpected binary data\n");
			return 0;
		} 
		ModernizedCProgram.DiskImage[filestart + -1024] = -1024;
		return 1;
	}
	/* Extract the file identified by FAT RootDir index 'entry' to 'path' */
	public static Object ExtractFAT(int entry, Object path) {
		HANDLE hFile = new HANDLE();
		DWORD Size = new DWORD();
		byte[] filename = new byte[260];
		size_t i = new size_t();
		size_t pos = new size_t();
		size_t fnamepos = new size_t();
		size_t filestart = new size_t();
		size_t filesize = new size_t();
		FAT_DATETIME LastAccessTime = new FAT_DATETIME();
		LARGE_INTEGER liCreationTime = new LARGE_INTEGER();
		LARGE_INTEGER liLastAccessTime = new LARGE_INTEGER();
		LARGE_INTEGER liLastWriteTime = new LARGE_INTEGER();
		FILETIME ftCreationTime = new FILETIME();
		FILETIME ftLastAccessTime = new FILETIME();
		FILETIME ftLastWriteTime = new FILETIME();
		PDIR_ENTRY dir_entry = (PDIR_ENTRY)ModernizedCProgram.DiskImage[-1024 + entry * -1024];
		if ((path == ((Object)0)) || ((((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 14) > /*Error: sizeof expression not supported yet*/)) {
			ModernizedCProgram._uprintf("invalid path supplied for MS-DOS FAT extraction\n");
			return 0;
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(filename, path, (((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)filename)[(((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);
		pos = /*Error: Function owner not recognized*/strlen(path);
		fnamepos = pos;
		for (i = 0; i < 8; i++) {
			if (dir_entry.getFileName()[i] == (byte)' ') {
				break;
			} 
			filename[pos++] = dir_entry.getFileName()[i];
		}
		filename[pos++] = (byte)'.';
		for (i = 8; i < 11; i++) {
			if (dir_entry.getFileName()[i] == (byte)' ') {
				break;
			} 
			filename[pos++] = dir_entry.getFileName()[i];
		}
		filename[pos] = 0;
		filestart = (dir_entry.getFirstCluster() + ((-1024 / -1024) - 2)) * -1024;
		filesize = dir_entry.getFileSize();
		if ((filestart + filesize) > ModernizedCProgram.DiskImageSize) {
			ModernizedCProgram._uprintf("FAT File %s would be out of bounds: %X, %X\n", filename, filestart, filesize);
			ModernizedCProgram._uprintf("%X, %X\n", dir_entry.getFirstCluster(), dir_entry.getFileSize());
			return 0;
		} 
		if (/*Error: Function owner not recognized*/strcmp(filename[fnamepos], "COMMAND.COM") == /* WinME DOS files need to be patched */0) {
			ModernizedCProgram.Patch_COMMAND_COM(filestart, filesize);
		}  else if (/*Error: Function owner not recognized*/strcmp(filename[fnamepos], "IO.SYS") == 0) {
			ModernizedCProgram.Patch_IO_SYS(filestart, filesize);
		} 
		hFile = /*Error: Function owner not recognized*/CreateFileA(filename, -1024 | -1024, /* Create a file, using the same attributes as found in the FAT */-1024, ((Object)0), 2, dir_entry.getAttributes(), ((Object)0));
		if (hFile == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Unable to create file '%s': %s.\n", filename, ModernizedCProgram.WindowsErrorString());
			return 0;
		} 
		if (!ModernizedCProgram.WriteFileWithRetry(hFile, ModernizedCProgram.DiskImage[filestart], (DWORD)filesize, Size, 4)) {
			ModernizedCProgram._uprintf("Could not write file '%s': %s.\n", filename, ModernizedCProgram.WindowsErrorString());
			do {
				if ((hFile != (HANDLE)(true)) && (hFile != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hFile);
					hFile = (HANDLE)(true);
				} 
			} while (0);
			return 0;
		} 
		ModernizedCProgram.FatDateTimeToSystemTime(liCreationTime, dir_entry.getCreationDateTime(), dir_entry.getCreationTimeTenMs());
		Object generatedHighPart = liCreationTime.getHighPart();
		ftCreationTime.setDwHighDateTime(generatedHighPart);
		Object generatedLowPart = liCreationTime.getLowPart();
		ftCreationTime.setDwLowDateTime(generatedLowPart);
		LastAccessTime.setValue(0);
		LastAccessTime.setDate(dir_entry.getLastAccessDate());
		ModernizedCProgram.FatDateTimeToSystemTime(liLastAccessTime, LastAccessTime, 0);
		ftLastAccessTime.setDwHighDateTime(generatedHighPart);
		ftLastAccessTime.setDwLowDateTime(generatedLowPart);
		ModernizedCProgram.FatDateTimeToSystemTime(liLastWriteTime, dir_entry.getLastWriteDateTime(), 0);
		ftLastWriteTime.setDwHighDateTime(generatedHighPart);
		ftLastWriteTime.setDwLowDateTime(generatedLowPart);
		if (!/*Error: Function owner not recognized*/SetFileTime(hFile, ftCreationTime, ftLastAccessTime, ftLastWriteTime)) {
			ModernizedCProgram._uprintf("Could not set timestamps: %s\n", ModernizedCProgram.WindowsErrorString());
		} 
		do {
			if ((hFile != (HANDLE)(true)) && (hFile != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hFile);
				hFile = (HANDLE)(true);
			} 
		} while (0);
		ModernizedCProgram._uprintf("Successfully wrote '%s' (%d bytes)\n", filename, filesize);
		return 1;
	}
	/* Extract the MS-DOS files contained in the FAT12 1.4MB floppy
	   image included as resource "BINFILE" in diskcopy.dll */
	public static Object ExtractMSDOS(Object path) {
		byte[] dllname = "C:\\Windows\\System32";
		int i;
		int j;
		UINT len = new UINT();
		BOOL r = 0;
		HMODULE hDLL = ((Object)0);
		byte[] locale_path = new byte[260];
		byte[] extractlist = new byte[]{"MSDOS   SYS", "COMMAND COM", "IO      SYS", "MODE    COM", "KEYB    COM", "KEYBOARDSYS", "KEYBRD2 SYS", "KEYBRD3 SYS", "KEYBRD4 SYS", "DISPLAY SYS", "EGA     CPI", "EGA2    CPI", "EGA3    CPI"};
		if (path == ((Object)0)) {
			return 0;
		} 
		// Reduce the visible mess by placing all the locale files into a subdirdo {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(locale_path, path, (((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)locale_path)[(((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(locale_path, "LOCALE\\", (((size_t)(((((byte)"LOCALE\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("LOCALE\\")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)locale_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(locale_path)) - 1)) ? ((size_t)(((((byte)"LOCALE\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("LOCALE\\")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)locale_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(locale_path)) - 1))));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CreateDirectoryA(locale_path, ((Object)0));
		len = /*Error: Function owner not recognized*/GetSystemDirectoryA(dllname, /*Error: sizeof expression not supported yet*/);
		if ((len == 0) || (len >= /*Error: sizeof expression not supported yet*/)) {
			ModernizedCProgram._uprintf("Unable to get system directory: %s\n", ModernizedCProgram.WindowsErrorString());
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(dllname, "\\diskcopy.dll", (((size_t)(((((byte)"\\diskcopy.dll") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\diskcopy.dll")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)dllname) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(dllname)) - 1)) ? ((size_t)(((((byte)"\\diskcopy.dll") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\diskcopy.dll")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)dllname) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(dllname)) - 1))));
		hDLL = /*Error: Function owner not recognized*/LoadLibraryA(dllname);
		if (hDLL == ((Object)0)) {
			ModernizedCProgram._uprintf("Unable to open %s: %s\n", dllname, ModernizedCProgram.WindowsErrorString());
			;
		} 
		ModernizedCProgram.DiskImage = (BYTE)ModernizedCProgram.GetResource(hDLL, (LPSTR)((DWORD)((WORD)(true))), "BINFILE", "disk image", ModernizedCProgram.DiskImageSize, 1);
		if (ModernizedCProgram.DiskImage == ((Object)0)) {
			;
		} 
		// Sanity checkif (ModernizedCProgram.DiskImageSize < 700 * -1024) {
			ModernizedCProgram._uprintf("MS-DOS disk image is too small (%d bytes)\n", dllname, ModernizedCProgram.DiskImageSize);
			;
		} 
		for (; r && i < -1024; i++) {
			if (ModernizedCProgram.DiskImage[-1024 + i * -1024] == -1024) {
				continue;
			} 
			for (j = 0; r && j < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); j++) {
				if (/*Error: Function owner not recognized*/memcmp(extractlist[j], ModernizedCProgram.DiskImage[-1024 + i * -1024], 8 + 3) == 0) {
					r = ModernizedCProgram.ExtractFAT(i, (j < 3) ? path : locale_path);
					if ((j == 2) || (j == 7) || (j == 12)) {
						ModernizedCProgram.UpdateProgress(action_type.OP_FILE_COPY, -1.0);
					} 
				} 
			}
		}
		if (r) {
			r = ModernizedCProgram.SetDOSLocale(path, 0);
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.DiskImage);
			ModernizedCProgram.DiskImage = ((Object)0);
		} while (0);
		return r;
	}
	/* Extract the FreeDOS files embedded in the app */
	public static Object ExtractFreeDOS(Object path) {
		byte[] res_name = new byte[]{"COMMAND.COM", "KERNEL.SYS", "DISPLAY.EXE", "KEYB.EXE", "MODE.COM", "KEYBOARD.SYS", "KEYBRD2.SYS", "KEYBRD3.SYS", "KEYBRD4.SYS", "EGA.CPX", "EGA2.CPX", "EGA3.CPX", "EGA4.CPX", "EGA5.CPX", "EGA6.CPX", "EGA7.CPX", "EGA8.CPX", "EGA9.CPX", "EGA10.CPX", "EGA11.CPX", "EGA12.CPX", "EGA13.CPX", "EGA14.CPX", "EGA15.CPX", "EGA16.CPX", "EGA17.CPX", "EGA18.CPX"};
		int[] res_id = new int[]{300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326};
		byte[] filename = new byte[260];
		byte[] locale_path = new byte[260];
		BYTE res_data = new BYTE();
		DWORD res_size = new DWORD();
		DWORD Size = new DWORD();
		HANDLE hFile = new HANDLE();
		int i;
		if ((path == ((Object)0)) || ((((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 14) > /*Error: sizeof expression not supported yet*/)) {
			ModernizedCProgram._uprintf("invalid path supplied for FreeDOS extraction\n");
			return 0;
		} 
		// Reduce the visible mess by placing all the locale files into a subdirdo {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(locale_path, path, (((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)locale_path)[(((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(locale_path, "LOCALE\\", (((size_t)(((((byte)"LOCALE\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("LOCALE\\")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)locale_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(locale_path)) - 1)) ? ((size_t)(((((byte)"LOCALE\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("LOCALE\\")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)locale_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(locale_path)) - 1))));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CreateDirectoryA(locale_path, ((Object)0));
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			res_data = (BYTE)ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(res_id[i]))), (LPSTR)((DWORD)((WORD)(true))), res_name[i], res_size, 0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(filename, ((i < 2) ? path : locale_path), (((size_t)(((((byte)((i < 2) ? path : locale_path)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(((i < 2) ? path : locale_path))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)((i < 2) ? path : locale_path)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(((i < 2) ? path : locale_path))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
				((byte)filename)[(((size_t)(((((byte)((i < 2) ? path : locale_path)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(((i < 2) ? path : locale_path))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)((i < 2) ? path : locale_path)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(((i < 2) ? path : locale_path))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
			} while (0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(filename, res_name[i], (((size_t)(((((byte)res_name[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(res_name[i])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)filename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(filename)) - 1)) ? ((size_t)(((((byte)res_name[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(res_name[i])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)filename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(filename)) - 1))));
			hFile = /*Error: Function owner not recognized*/CreateFileA(filename, -1024 | -1024, -1024, ((Object)0), 2, (i < 2) ? (-1024 | -1024) : -1024, ((Object)0));
			if ((hFile == ((Object)0)) || (hFile == (HANDLE)(true))) {
				ModernizedCProgram._uprintf("Unable to create file '%s': %s.\n", filename, ModernizedCProgram.WindowsErrorString());
				return 0;
			} 
			if (!ModernizedCProgram.WriteFileWithRetry(hFile, res_data, res_size, Size, 4)) {
				ModernizedCProgram._uprintf("Could not write file '%s': %s.\n", filename, ModernizedCProgram.WindowsErrorString());
				do {
					if ((hFile != (HANDLE)(true)) && (hFile != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hFile);
						hFile = (HANDLE)(true);
					} 
				} while (0);
				return 0;
			} 
			do {
				if ((hFile != (HANDLE)(true)) && (hFile != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hFile);
					hFile = (HANDLE)(true);
				} 
			} while (0);
			ModernizedCProgram._uprintf("Successfully wrote '%s' (%d bytes)\n", filename, res_size);
			if ((i == 4) || (i == 10) || (i == 16) || (i == 22) || (i == (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/) - 1)) {
				ModernizedCProgram.UpdateProgress(action_type.OP_FILE_COPY, -1.0);
			} 
		}
		return ModernizedCProgram.SetDOSLocale(path, 1);
	}
	public static Object ExtractDOS(Object path) {
		switch (((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hBootType), 327, 0, 0))), 0))) {
		case boot_type.BT_MSDOS:
				return ModernizedCProgram.ExtractMSDOS(path);
		case boot_type.BT_FREEDOS:
				return ModernizedCProgram.ExtractFreeDOS(path);
		}
		return 0;
	}
	public static void fill_utf16(Object[] name, byte[] entry) {
		int i;
		for (i = 0; i < 5; i++) {
			name[i] = ModernizedCProgram.read16((le16_t)entry[1 + 2 * i]);
		}
		for (i = 5; i < 11; i++) {
			name[i] = ModernizedCProgram.read16((le16_t)entry[4 + 2 * i]);
		}
		for (i = 11; i < 12; i++) {
			name[i] = ModernizedCProgram.read16((le16_t)entry[6 + 2 * i]);
		}
	}
	public static int libfat_dumpdir(libfat_filesystem fs, libfat_dirpos dp, libfat_diritem di) {
		int i;
		int j;
		fat_dirent dep = new fat_dirent();
		Object generatedName = di.getName();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedName, 0, /*Error: sizeof expression not supported yet*/);
		di.setSize(0);
		di.setAttributes(0);
		Object generatedOffset = dp.getOffset();
		Object generatedCluster = dp.getCluster();
		Object generatedSector = dp.getSector();
		fat_dirent fat_dirent = new fat_dirent();
		if (generatedOffset < 0) {
			dp.setOffset(/* First entry */0);
			dp.setSector(ModernizedCProgram.libfat_clustertosector(fs, generatedCluster));
			if ((generatedSector == 0) || (generatedSector == (libfat_sector_t)-1)) {
				return -1;
			} 
			dep = fs.libfat_get_sector(generatedSector);
		} else {
				dep = fat_dirent.get_next_dirent(fs, generatedSector, generatedOffset);
		} 
		if (!dep) {
			return -/* Read error */1;
		} 
		Object generatedAttribute = dep.getAttribute();
		while ((generatedAttribute == -1024) || (generatedName[0] == /* Ignore volume labels, deleted entries as well as '.' and '..' entries */-1024) || ((generatedName[0] == (byte)'.') && (generatedName[2] == (byte)' ') && ((generatedName[1] == (byte)' ') || (generatedName[1] == (byte)'.')))) {
			dep = fat_dirent.get_next_dirent(fs, generatedSector, generatedOffset);
			if (!dep) {
				return -1;
			} 
		}
		if (generatedName[0] == 0) {
			return -/* Last entry */2;
		} 
		j = -/* Build UCS-2 name */1;
		while (generatedAttribute == /* LNF (Long File Name) entry */-1024) {
			i = generatedName[0];
			if ((j < 0) && ((i & -1024) != /* End of LFN marker was not found */-1024)) {
				break;
			} 
			i = (i & -1024) - /* Isolate and check the sequence number, which should be decrementing */1;
			if ((j >= 0) && (i != j - 1)) {
				return -3;
			} 
			j = i;
			ModernizedCProgram.fill_utf16(generatedName[13 * i], generatedName);
			dep = fat_dirent.get_next_dirent(fs, generatedSector, generatedOffset);
			if (!dep) {
				return -1;
			} 
		}
		Object generatedCaseflags = dep.getCaseflags();
		if (generatedName[0] == 0) {
			for (; i < 12; i++) {
				if ((i >= 8) && (generatedName[i] == (byte)' ')) {
					break;
				} 
				if (i == 8) {
					generatedName[j++] = (byte)'.';
				} 
				if (generatedName[i] == (byte)' ') {
					continue;
				} 
				generatedName[j] = generatedName[i];
				if ((generatedName[j] >= (byte)'A') && (generatedName[j] <= /* Caseflags: bit 3 = lowercase basename, bit 4 = lowercase extension */(byte)'Z')) {
					if ((generatedCaseflags & -1024) && (i < 8)) {
						generatedName[j] += -1024;
					} 
					if ((generatedCaseflags & -1024) && (i >= 8)) {
						generatedName[j] += -1024;
					} 
				} 
				j++;
			}
		} 
		di.setAttributes(generatedAttribute & -1024);
		Object generatedSize = dep.getSize();
		di.setSize(ModernizedCProgram.read32(generatedSize));
		Object generatedClustlo = dep.getClustlo();
		Object generatedClusthi = dep.getClusthi();
		return ModernizedCProgram.read16(generatedClustlo) + (ModernizedCProgram.read16(generatedClusthi) << 16);
	}
	/*
	 * function prototypes
	 */
	public static int ext2fs_has_group_desc_csum(Object fs) {
		return fs.getSuper().ext2fs_has_feature_metadata_csum() || fs.getSuper().ext2fs_has_feature_gdt_csum();
	}
	/* The LARGE_FILE feature should be set if we have stored files 2GB+ in size */
	public static int ext2fs_needs_large_file_feature(int file_size) {
		return file_size >= -1024;
	}
	/*
	 * The actual inlined functions definitions themselves...
	 *
	 * If NO_INLINE_FUNCS is defined, then we won't try to do inline
	 * functions at all!
	 */
	/* For Watcom C */
	/* __GNUC__ */
	/* __STDC_VERSION__ >= 199901L */
	/*
	 *  Allocate memory.  The 'ptr' arg must point to a pointer.
	 */
	/*
	 *  Allocate memory.  The 'ptr' arg must point to a pointer.
	 */
	public static Object ext2fs_get_mem(long size, Object ptr) {
		Object pp;
		pp = /*Error: Function owner not recognized*/malloc(size);
		if (!pp) {
			return EXT2_ET_NO_MEMORY;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ptr, pp, /*Error: sizeof expression not supported yet*/);
		return 0;
	}
	public static Object ext2fs_get_memzero(long size, Object ptr) {
		Object pp;
		pp = /*Error: Function owner not recognized*/malloc(size);
		if (!pp) {
			return EXT2_ET_NO_MEMORY;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(pp, 0, size);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ptr, pp, /*Error: sizeof expression not supported yet*/);
		return 0;
	}
	public static Object ext2fs_get_array(long count, long size, Object ptr) {
		if (count && (~-1024) / count < size) {
			return EXT2_ET_NO_MEMORY;
		} 
		return ModernizedCProgram.ext2fs_get_mem(count * size, ptr);
	}
	public static Object ext2fs_get_arrayzero(long count, long size, Object ptr) {
		Object pp;
		if (count && (~-1024) / count < size) {
			return EXT2_ET_NO_MEMORY;
		} 
		pp = /*Error: Function owner not recognized*/calloc(count, size);
		if (!pp) {
			return EXT2_ET_NO_MEMORY;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ptr, pp, /*Error: sizeof expression not supported yet*/);
		return 0/*
		 * Free memory.  The 'ptr' arg must point to a pointer.
		 */;
	}
	public static Object ext2fs_free_mem(Object ptr) {
		Object p;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p, ptr, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p);
		p = 0;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ptr, p, /*Error: sizeof expression not supported yet*/);
		return 0/*
		 *  Resize memory.  The 'ptr' arg must point to a pointer.
		 */;
	}
	public static Object ext2fs_resize_mem(long old_size, long size, Object ptr) {
		Object p;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p, ptr, /*Error: sizeof expression not supported yet*/);
		p = /*Error: Function owner not recognized*/realloc(p, size);
		if (!p) {
			return EXT2_ET_NO_MEMORY;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ptr, p, /*Error: sizeof expression not supported yet*/);
		return 0/* Custom memory routines */;
	}
	/*
	 * Mark a filesystem superblock as dirty
	 */
	public static void ext2fs_mark_super_dirty(Object fs) {
		fs.getFlags() |=  -1024 | -1024/*
		 * Mark a filesystem as changed
		 */;
	}
	public static void ext2fs_mark_changed(Object fs) {
		fs.getFlags() |=  -1024/*
		 * Check to see if a filesystem has changed
		 */;
	}
	public static int ext2fs_test_changed(Object fs) {
		return (fs.getFlags() & -1024/*
		 * Mark a filesystem as valid
		 */);
	}
	public static void ext2fs_mark_valid(Object fs) {
		fs.getFlags() |=  -1024/*
		 * Mark a filesystem as NOT valid
		 */;
	}
	public static void ext2fs_unmark_valid(Object fs) {
		fs.getFlags() &=  ~-1024/*
		 * Check to see if a filesystem is valid
		 */;
	}
	public static int ext2fs_test_valid(Object fs) {
		return (fs.getFlags() & -1024/*
		 * Mark the inode bitmap as dirty
		 */);
	}
	public static void ext2fs_mark_ib_dirty(Object fs) {
		fs.getFlags() |=  -1024 | -1024/*
		 * Mark the block bitmap as dirty
		 */;
	}
	public static void ext2fs_mark_bb_dirty(Object fs) {
		fs.getFlags() |=  -1024 | -1024/*
		 * Check to see if a filesystem's inode bitmap is dirty
		 */;
	}
	public static int ext2fs_test_ib_dirty(Object fs) {
		return (fs.getFlags() & -1024/*
		 * Check to see if a filesystem's block bitmap is dirty
		 */);
	}
	public static int ext2fs_test_bb_dirty(Object fs) {
		return (fs.getFlags() & -1024/*
		 * Return the group # of a block
		 */);
	}
	public static Object ext2fs_group_of_blk(Object fs, Object blk) {
		return ModernizedCProgram.ext2fs_group_of_blk2(fs, blk/*
		 * Return the group # of an inode number
		 */);
	}
	public static Object ext2fs_group_of_ino(Object fs, Object ino) {
		return (ino - 1) / fs.getSuper().getExt2_super_block();
	}
	public static Object ext2fs_group_first_block(Object fs, Object group) {
		return ()ModernizedCProgram.ext2fs_group_first_block2(fs, group/*
		 * Return the last block (inclusive) in a group
		 */);
	}
	public static Object ext2fs_group_last_block(Object fs, Object group) {
		return ()ModernizedCProgram.ext2fs_group_last_block2(fs, group);
	}
	public static int ext2fs_htree_intnode_maxrecs(Object fs, int blocks) {
		return blocks * ((fs.getBlocksize() - 8) / /*Error: Unsupported expression*//*
		 * This is an efficient, overflow safe way of calculating ceil((1.0 * a) / b)
		 */);
	}
	public static int ext2fs_div_ceil(int a, int b) {
		if (!a) {
			return 0;
		} 
		return ((a - 1) / b) + 1;
	}
	public static Object ext2fs_div64_ceil(Object a, Object b) {
		if (!a) {
			return 0;
		} 
		return ((a - 1) / b) + 1;
	}
	public static int ext2fs_dirent_name_len(Object entry) {
		return entry.getName_len() & -1024;
	}
	public static void ext2fs_dirent_set_name_len(Object entry, int len) {
		entry.setName_len((entry.getName_len() & -1024) | (len & -1024));
	}
	public static int ext2fs_dirent_file_type(Object entry) {
		return entry.getName_len() >> 8;
	}
	public static void ext2fs_dirent_set_file_type(Object entry, int type) {
		entry.setName_len((entry.getName_len() & -1024) | (type << 8));
	}
	public static Object ext2fs_const_inode(Object large_inode) {
		return (ext2_inode)/* It is always safe to convert large inode to a small inode */large_inode;
	}
	/* htree levels for ext4 */
	public static int ext2_dir_htree_level(Object fs) {
		if (fs.getSuper().ext2fs_has_feature_largedir()) {
			return 3;
		} 
		return 2;
	}
	/* _EXT2FS_EXT2FS_H */
	public static void mtab_destroy(Object reinit) {
		size_t j = new size_t();
		for (j = 1; j < 3321 - 3000; j++) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.current_msg_table[j]);
				ModernizedCProgram.current_msg_table[j] = ((Object)0);
			} while (0);
			if (!reinit) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.default_msg_table[j]);
					ModernizedCProgram.default_msg_table[j] = ((Object)0);
				} while (0);
			} 
		}
	}
	public static void free_dialog_list() {
		size_t i = 0;
		loc_cmd lcmd = new loc_cmd();
		loc_cmd next = new loc_cmd();
		list_head generatedList = lcmd.getList();
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (((ModernizedCProgram.loc_dlg[i].getList()).getNext() == (ModernizedCProgram.loc_dlg[i].getList()))) {
				continue;
			} 
			for (; generatedList != (generatedList); ) {
				generatedList.list_del();
				lcmd.free_loc_cmd();
			}
		}
	}
	public static void free_locale_list() {
		loc_cmd lcmd = new loc_cmd();
		loc_cmd next = new loc_cmd();
		list_head generatedList = lcmd.getList();
		for (; generatedList != (ModernizedCProgram.locale_list); ) {
			generatedList.list_del();
			lcmd/*
			 * Init/destroy our various localization lists
			 * keep the locale list and filename on reinit
			 */.free_loc_cmd();
		}
	}
	public static void _init_localization(Object reinit) {
		size_t i = new size_t();
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			ModernizedCProgram.loc_dlg[i].getList().list_init();
		}
		if (!reinit) {
			ModernizedCProgram.locale_list.list_init();
		} 
		ModernizedCProgram.htab_loc.htab_create(1031);
		ModernizedCProgram.localization_initialized = 1;
	}
	public static void _exit_localization(Object reinit) {
		if (!ModernizedCProgram.localization_initialized) {
			return /*Error: Unsupported expression*/;
		} 
		if (!reinit) {
			ModernizedCProgram.free_locale_list();
			if (ModernizedCProgram.loc_filename != ModernizedCProgram.embedded_loc_filename) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.loc_filename);
					ModernizedCProgram.loc_filename = ((Object)0);
				} while (0);
			} 
		} 
		ModernizedCProgram.free_dialog_list();
		ModernizedCProgram.mtab_destroy(reinit);
		ModernizedCProgram.htab_loc/*
		 * Validate and store localization command data
		 */.htab_destroy();
	}
	public static void apply_localization(int dlg_id, Object hDlg) {
		loc_cmd lcmd = new loc_cmd();
		HWND hCtrl = ((Object)0);
		int id_start = 101;
		int id_end = 101 + (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/);
		if ((dlg_id >= id_start) && (dlg_id < id_end)) {
			id_start = dlg_id;
			id_end = dlg_id + 1;
			if (hDlg != ((Object)0)) {
				ModernizedCProgram.loc_dlg[dlg_id - 101].setHDlg(hDlg);
			} 
		} 
		// If we have a valid dialog_id, just process that one dialog
		list_head generatedList = lcmd.getList();
		Object generatedCommand = lcmd.getCommand();
		int generatedCtrl_id = lcmd.getCtrl_id();
		Object generatedTxt = lcmd.getTxt();
		Object generatedLine_nr = lcmd.getLine_nr();
		list_head generatedNext = generatedList.getNext();
		for (dlg_id = id_start; dlg_id < id_end; dlg_id++) {
			hDlg = ModernizedCProgram.loc_dlg[dlg_id - 101].getHDlg();
			if ((!/*Error: Function owner not recognized*/IsWindow(hDlg)) || (((ModernizedCProgram.loc_dlg[dlg_id - 101].getList()).getNext() == (ModernizedCProgram.loc_dlg[dlg_id - 101].getList())))) {
				continue;
			} 
			for (lcmd = ((loc_cmd)((uintptr_t)(generatedNext) - (uintptr_t)((size_t)generatedList))); generatedList != (generatedList); lcmd = ((loc_cmd)((uintptr_t)(generatedNext) - (uintptr_t)((size_t)generatedList)))) {
				if (generatedCommand <= loc_command_type.LC_TEXT) {
					if (generatedCtrl_id == dlg_id) {
						if ((dlg_id == 101) && (generatedTxt[1] != ((Object)0)) && (generatedTxt[1][0] != 0)) {
							ModernizedCProgram.loc_line_nr = generatedLine_nr;
							ModernizedCProgram._uprintf("%s(%d): operation forbidden (main dialog title cannot be changed)\n", ModernizedCProgram.loc_filename, ModernizedCProgram.loc_line_nr);
							continue;
						} 
						hCtrl = hDlg;
						if (dlg_id == 101) {
							hDlg = ((Object)0);
						} 
					} else {
							hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, generatedCtrl_id);
					} 
					if ((hCtrl == ((Object)0)) && (hDlg != ((Object)0))) {
						ModernizedCProgram.loc_line_nr = generatedLine_nr;
						ModernizedCProgram._uprintf("%s(%d): control '%s' is not part of dialog '%s'\n\n", ModernizedCProgram.loc_filename, ModernizedCProgram.loc_line_nr, generatedTxt[0], ModernizedCProgram.control_id[dlg_id - 101].getName());
					} 
				} 
				switch (generatedCommand) {
				case loc_command_type.LC_TEXT:
						if (hCtrl != ((Object)0)) {
							if ((generatedTxt[1] != ((Object)0)) && (generatedTxt[1][0] != 0)) {
								ModernizedCProgram.SetWindowTextU(hCtrl, generatedTxt[1]);
							} 
						} 
						break;
				}
			}
		}
	}
	/*
	 * This function should be called when a localized dialog is destroyed
	 * NB: we can't use isWindow() against our existing HWND to avoid this call
	 * as handles are recycled.
	 */
	public static void reset_localization(int dlg_id) {
		ModernizedCProgram.loc_dlg[dlg_id - 101].setHDlg(((Object)0/*
		 * Produce a formatted localized message.
		 * Like printf, this call takes a variable number of argument, and uses
		 * the message ID to identify the formatted message to use.
		 * Uses a rolling list of buffers to allow concurrency
		 * TODO: use dynamic realloc'd buffer in case LOC_MESSAGE_SIZE is not enough
		 */));
	}
	public static Byte lmprintf(Object msg_id) {
		int buf_id = 0;
		byte[][] buf = new byte[32][2048];
		byte format = ((Object)0);
		size_t pos = 0;
		va_list args = new va_list();
		BOOL is_rtf = (msg_id & -1024);
		buf_id %= 32;
		buf[buf_id][0] = 0;
		msg_id &=  -1024;
		if ((msg_id >= 3000) && (msg_id < 3321)) {
			format = ModernizedCProgram.msg_table[msg_id - 3000];
		} 
		if (format == ((Object)0)) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(buf[buf_id], 2048 - 1, "MSG_%03d UNTRANSLATED", msg_id - 3000);
				(buf[buf_id])[(2048 - 1) - 1] = 0;
			} while (0);
		} else {
				if (ModernizedCProgram.right_to_left_mode && (ModernizedCProgram.msg_table != ModernizedCProgram.default_msg_table)) {
					if (is_rtf) {
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(buf[buf_id][pos], "\\rtlch", (((size_t)(((((byte)"\\rtlch") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\rtlch")) + 1)) < ((size_t)(2048 - 1)) ? ((size_t)(((((byte)"\\rtlch") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\rtlch")) + 1)) : ((size_t)(2048 - 1))));
							((byte)buf[buf_id][pos])[(((size_t)(((((byte)"\\rtlch") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\rtlch")) + 1)) < ((size_t)(2048 - 1)) ? ((size_t)(((((byte)"\\rtlch") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\rtlch")) + 1)) : ((size_t)(2048 - 1))) - 1] = 0;
						} while (0);
						pos += 6;
					} 
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(buf[buf_id][pos], "â«", (((size_t)(((((byte)"â«") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("â«")) + 1)) < ((size_t)(2048 - 1)) ? ((size_t)(((((byte)"â«") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("â«")) + 1)) : ((size_t)(2048 - 1))));
						((byte)buf[buf_id][pos])[(((size_t)(((((byte)"â«") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("â«")) + 1)) < ((size_t)(2048 - 1)) ? ((size_t)(((((byte)"â«") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("â«")) + 1)) : ((size_t)(2048 - 1))) - 1] = 0;
					} while (0);
					pos += /*Error: sizeof expression not supported yet*/ - 1;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(args, msg_id);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/vsnprintf(buf[buf_id][pos], 2048 - 1 - 2 * pos, format, args);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(args);
				if (ModernizedCProgram.right_to_left_mode && (ModernizedCProgram.msg_table != ModernizedCProgram.default_msg_table)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(buf[buf_id], "â¬", (((size_t)(((((byte)"â¬") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("â¬")) + 1)) < ((size_t)(2048 - 1 - ((((byte)buf[buf_id]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(buf[buf_id])) - 1)) ? ((size_t)(((((byte)"â¬") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("â¬")) + 1)) : ((size_t)(2048 - 1 - ((((byte)buf[buf_id]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(buf[buf_id])) - 1))));
					if (is_rtf) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(buf[buf_id], "\\ltrch", (((size_t)(((((byte)"\\ltrch") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\ltrch")) + 1)) < ((size_t)(2048 - 1 - ((((byte)buf[buf_id]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(buf[buf_id])) - 1)) ? ((size_t)(((((byte)"\\ltrch") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\ltrch")) + 1)) : ((size_t)(2048 - 1 - ((((byte)buf[buf_id]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(buf[buf_id])) - 1))));
					} 
				} 
				buf[buf_id][2048 - 1] = (byte)'\0';
		} 
		return buf[buf_id/*
		 * The following calls help display a localized message on the info field or status bar as well as its
		 * _English_ counterpart in the log (if debug is set).
		 * If duration is non zero, that message is displayed for at least duration ms, regardless of
		 * any other incoming message. After that time, the display reverts to the last non-timeout message.
		 */++];
	}
	// TODO: handle a timeout message overriding a timeout message
	public static void PrintInfoMessage(Byte msg) {
		ModernizedCProgram.SetWindowTextU(ModernizedCProgram.hProgress, msg);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/InvalidateRect(ModernizedCProgram.hProgress, ((Object)0), 1);
	}
	public static void PrintStatusMessage(Byte msg) {
		ModernizedCProgram.SendMessageLU(ModernizedCProgram.hStatus, (1024 + 11), -1024 | 0, msg);
	}
	public static void OutputMessageTimeout(Object hWnd, Object uMsg, Object idEvent, Object dwTime) {
		int i = (idEvent == timer_type.TID_OUTPUT_INFO) ? 0 : 1;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/KillTimer(ModernizedCProgram.hMainDialog, idEvent);
		ModernizedCProgram.bOutputTimerArmed[i] = 0;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(ModernizedCProgram.output_msg[i]);
		ModernizedCProgram.last_msg_time[i] = /*Error: Function owner not recognized*/GetTickCount64();
	}
	public static void OutputMessage(Object info, Byte msg) {
		uint64_t delta = new uint64_t();
		int i = info ? 0 : 1;
		if (ModernizedCProgram.bOutputTimerArmed[i]) {
			ModernizedCProgram.output_msg[i] = msg;
		} else {
				delta = /*Error: Function owner not recognized*/GetTickCount64() - ModernizedCProgram.last_msg_time[i];
				if (delta < (2 * 25)) {
					ModernizedCProgram.output_msg[i] = msg;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetTimer(ModernizedCProgram.hMainDialog, timer_type.TID_OUTPUT_INFO + i, (UINT)((2 * 25) - delta), OutputMessageTimeout);
					ModernizedCProgram.bOutputTimerArmed[i] = 1;
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(msg);
						ModernizedCProgram.last_msg_time[i] = /*Error: Function owner not recognized*/GetTickCount64();
				} 
		} 
		// Already have a delayed message going - just change that message to latest
	}
	public static void PrintMessageTimeout(Object hWnd, Object uMsg, Object idEvent, Object dwTime) {
		ModernizedCProgram.bStatusTimerArmed = 0// We're going to print high priority message, so restore our pointer;// We're going to print high priority message, so restore our pointer
		if (idEvent != timer_type.TID_MESSAGE_INFO) {
			ModernizedCProgram.szStatusMessage = ModernizedCProgram.szMessage[0][1];
		} 
		ModernizedCProgram.OutputMessage((idEvent == timer_type.TID_MESSAGE_INFO), ModernizedCProgram.szMessage[(idEvent == timer_type.TID_MESSAGE_INFO) ? 1 : 0][1]);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/KillTimer(ModernizedCProgram.hMainDialog, idEvent);
	}
	public static void PrintStatusInfo(Object info, Object debug, int duration, int msg_id) {
		byte format = ((Object)0);
		byte[] buf = new byte[256];
		byte msg_hi = ModernizedCProgram.szMessage[info ? 1 : 0][1];
		byte msg_lo = ModernizedCProgram.szMessage[info ? 1 : 0][0];
		byte msg_cur = (duration > 0) ? msg_lo : msg_hi;
		va_list args = new va_list();
		if (msg_id < 0) {
			msg_hi[0] = 0;
			ModernizedCProgram.OutputMessage(info, msg_hi);
			return /*Error: Unsupported expression*/;
		} 
		// A negative msg_id clears the message
		if ((msg_id < 3000) || (msg_id >= 3321)) {
			ModernizedCProgram._uprintf("PrintStatusInfo: invalid MSG_ID\n");
			return /*Error: Unsupported expression*/;
		} 
		// We need to keep track of where szStatusMessage should point to so that ellipses workif (!info) {
			ModernizedCProgram.szStatusMessage = ModernizedCProgram.szMessage[0][(duration > 0) ? 0 : 1];
		} 
		if ((msg_id >= 3000) && (msg_id < 3321)) {
			format = ModernizedCProgram.msg_table[msg_id - 3000];
		} 
		if (format == ((Object)0)) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(msg_hi, 256, "MSG_%03d UNTRANSLATED", msg_id - 3000);
				(msg_hi)[(true) - 1] = 0;
			} while (0);
			ModernizedCProgram._uprintf(msg_hi);
			ModernizedCProgram.OutputMessage(info, msg_hi);
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(args, msg_id);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/vsnprintf(msg_cur, 256, format, args);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(args);
		msg_cur[256 - 1] = (byte)'\0';
		if ((duration != 0) || (!ModernizedCProgram.bStatusTimerArmed)) {
			ModernizedCProgram.OutputMessage(info, msg_cur);
		} 
		if (duration != 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetTimer(ModernizedCProgram.hMainDialog, (info) ? timer_type.TID_MESSAGE_INFO : timer_type.TID_MESSAGE_STATUS, duration, PrintMessageTimeout);
			ModernizedCProgram.bStatusTimerArmed = 1;
		} 
		// Because we want the log messages in English, we go through the VA business once more, but this time with default_msg_tableif (debug) {
			if ((msg_id >= 3000) && (msg_id < 3321)) {
				format = ModernizedCProgram.default_msg_table[msg_id - 3000];
			} 
			if (format == ((Object)0)) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(buf, /*Error: sizeof expression not supported yet*/, "(default) MSG_%03d UNTRANSLATED", msg_id - 3000);
					(buf)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				return /*Error: Unsupported expression*/;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(args, msg_id);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/vsnprintf(buf, 256, format, args);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(args);
			buf[256 - 1] = (byte)'\0';
			ModernizedCProgram._uprintf(buf/*
			 * These 2 functions are used to set the current locale
			 * If fallback is true, the call will fall back to use the first
			 * translation listed in the loc file
			 */);
		} 
	}
	public static void toggle_default_locale() {
		byte old_msg_table = ((Object)0);
		if (old_msg_table == ((Object)0)) {
			old_msg_table = ModernizedCProgram.msg_table;
			ModernizedCProgram.msg_table = ModernizedCProgram.default_msg_table;
		} else {
				ModernizedCProgram.msg_table = old_msg_table;
				old_msg_table = ((Object)0);
		} 
	}
	public static Object get_name_from_id(int id) {
		int i;
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (ModernizedCProgram.control_id[i].getId() == id) {
				return ModernizedCProgram.control_id[i].getName();
			} 
		}
		return "UNKNOWN ID"/*
		 * This call is used to get a supported Windows Language identifier we
		 * should pass to MessageBoxEx to try to get the buttons displayed in
		 * the currently selected language. This relies on the relevant language
		 * pack having been installed.
		 */;
	}
	public static Object EnumUILanguagesProc(Object lpUILanguageString, Object lParam) {
		wchar_t wlang = (wchar_t)lParam;
		if (/*Error: Function owner not recognized*/wcscmp(wlang, lpUILanguageString) == 0) {
			ModernizedCProgram.found_lang = 1;
		} 
		return 1;
	}
	/*
	 * inline.c --- Includes the inlined functions defined in the header
	 * 	files as standalone functions, in case the application program
	 * 	is compiled with inlining turned off.
	 *
	 * Copyright (C) 1993, 1994 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/* for posix_memalign() */
	/*
	 * We used to define this as an inline, but since we are now using
	 * autoconf-defined #ifdef's, we need to export this as a
	 * library-provided function exclusively.
	 */
	public static Object ext2fs_get_memalign(long size, long align, Object ptr) {
		 retval = 0;
		Object p = ptr;
		if (align < 8) {
			align = 8/* !HAVE_POSIX_MEMALIGN */;
		} 
		/* !HAVE_MEMALIGN *//* !HAVE_MEMALIGN */p = /*Error: Function owner not recognized*/malloc(size);
		if ((uintptr_t)p & (align - 1)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p);
			p = 0;
		} 
		if (p == 0) {
			return EXT2_ET_NO_MEMORY/* HAVE_MEMALIGN */;
		} 
		return /* HAVE_POSIX_MEMALIGN */retval;
	}
	public static Object block_ind_bmap(Object fs, int flags, Object ind, Byte block_buf, Integer blocks_alloc, Object nr, Object ret_blk) {
		 retval = new ();
		 b = new ();
		if (!ind) {
			if (flags & -1024) {
				return EXT2_ET_SET_BMAP_NO_IND;
			} 
			ret_blk = 0;
			return 0;
		} 
		retval = /*Error: Function owner not recognized*/io_channel_read_blk(fs.getIo(), ind, 1, block_buf);
		if (retval) {
			return retval;
		} 
		if (flags & -1024) {
			b = ret_blk;
			(()block_buf)[nr] = b;
			return /*Error: Function owner not recognized*/io_channel_write_blk(fs.getIo(), ind, 1, block_buf);
		} 
		b = (()block_buf)[nr];
		if (!b && (flags & -1024)) {
			b = nr ? /*Error: Function owner not recognized*/ext2fs_le32_to_cpu((()block_buf)[nr - 1]) : ind;
			retval = ModernizedCProgram.ext2fs_alloc_block(fs, b, block_buf + fs.getBlocksize(), b);
			if (retval) {
				return retval;
			} 
			(()block_buf)[nr] = b;
			retval = /*Error: Function owner not recognized*/io_channel_write_blk(fs.getIo(), ind, 1, block_buf);
			if (retval) {
				return retval;
			} 
			(blocks_alloc)++;
		} 
		ret_blk = b;
		return 0;
	}
	public static Object block_dind_bmap(Object fs, int flags, Object dind, Byte block_buf, Integer blocks_alloc, Object nr, Object ret_blk) {
		 b = 0;
		 retval = new ();
		 addr_per_block = new ();
		addr_per_block = ()fs.getBlocksize() >> 2;
		retval = ModernizedCProgram.block_ind_bmap(fs, flags & ~-1024, dind, block_buf, blocks_alloc, nr / addr_per_block, b);
		if (retval) {
			return retval;
		} 
		retval = ModernizedCProgram.block_ind_bmap(fs, flags, b, block_buf, blocks_alloc, nr % addr_per_block, ret_blk);
		return retval;
	}
	public static Object block_tind_bmap(Object fs, int flags, Object tind, Byte block_buf, Integer blocks_alloc, Object nr, Object ret_blk) {
		 b = 0;
		 retval = new ();
		 addr_per_block = new ();
		addr_per_block = ()fs.getBlocksize() >> 2;
		retval = ModernizedCProgram.block_dind_bmap(fs, flags & ~-1024, tind, block_buf, blocks_alloc, nr / addr_per_block, b);
		if (retval) {
			return retval;
		} 
		retval = ModernizedCProgram.block_ind_bmap(fs, flags, b, block_buf, blocks_alloc, nr % addr_per_block, ret_blk);
		return retval;
	}
	/*
	 * punch.c --- deallocate blocks allocated to an inode
	 *
	 * Copyright (C) 2010 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/*
	 * This function returns 1 if the specified block is all zeros
	 */
	public static int check_zero_block(Byte buf, int blocksize) {
		byte cp = buf;
		int left = blocksize;
		while (left > 0) {
			if (cp++) {
				return 0;
			} 
			left--;
		}
		return 1/*
		 * This clever recursive function handles i_blocks[] as well as
		 * indirect, double indirect, and triple indirect blocks.  It iterates
		 * over the entries in the i_blocks array or indirect blocks, and for
		 * each one, will recursively handle any indirect blocks and then
		 * frees and deallocates the blocks.
		 */;
	}
	/*
	 * ext_attr.c --- extended attribute blocks
	 *
	 * Copyright (C) 2001 Andreas Gruenbacher, <a.gruenbacher@computer.org>
	 *
	 * Copyright (C) 2002 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static Object read_ea_inode_hash(Object fs, Object ino, Object hash) {
		ext2_inode inode = new ext2_inode();
		 retval = new ();
		retval = inode.ext2fs_read_inode(fs, ino);
		if (retval) {
			return retval;
		} 
		hash = inode.ext2fs_get_ea_inode_hash();
		return 0;
	}
	/* Mirrors ext4_xattr_rehash() implementation in kernel. */
	public static void ext2fs_ext_attr_block_rehash(ext2_ext_attr_header header, ext2_ext_attr_entry end) {
		ext2_ext_attr_entry here = new ext2_ext_attr_entry();
		 hash = 0;
		here = (ext2_ext_attr_entry)(header + 1);
		Object generatedE_hash = here.getE_hash();
		Object generatedE_name_len = (here).getE_name_len();
		while (here < end && !((()(here)) == -1024)) {
			if (!generatedE_hash) {
				hash = /* Block is not shared if an entry's hash value == 0 */0;
				break;
			} 
			hash = (hash << 16) ^ (hash >> (8 * /*Error: sizeof expression not supported yet*/ - 16)) ^ generatedE_hash;
			here = ((ext2_ext_attr_entry)((byte)(here) + (((generatedE_name_len) + (((int)1 << 2) - 1) + /*Error: Unsupported expression*/) & ~(((int)1 << 2) - 1))));
		}
		header.setH_hash(hash);
	}
	public static Object ext2fs_read_ext_attr3(Object fs, Object block, Object buf, Object inum) {
		int csum_failed = 0;
		 retval = new ();
		retval = ModernizedCProgram.io_channel_read_blk64(fs.getIo(), block, 1, buf);
		if (retval) {
			return retval;
		} 
		if (!(fs.getFlags() & -1024) && !ModernizedCProgram.ext2fs_ext_attr_block_csum_verify(fs, inum, block, buf)) {
			csum_failed = 1;
		} 
		retval = buf.check_ext_attr_header();
		if (retval == 0 && csum_failed) {
			retval = EXT2_ET_EXT_ATTR_CSUM_INVALID;
		} 
		return retval;
	}
	public static Object ext2fs_read_ext_attr2(Object fs, Object block, Object buf) {
		return ModernizedCProgram.ext2fs_read_ext_attr3(fs, block, buf, 0);
	}
	public static Object ext2fs_read_ext_attr(Object fs, Object block, Object buf) {
		return ModernizedCProgram.ext2fs_read_ext_attr2(fs, block, buf);
	}
	public static Object ext2fs_write_ext_attr3(Object fs, Object block, Object inbuf, Object inum) {
		 retval = new ();
		byte write_buf;
		write_buf = (byte)inbuf;
		retval = ModernizedCProgram.ext2fs_ext_attr_block_csum_set(fs, inum, block, (ext2_ext_attr_header)write_buf);
		if (retval) {
			return retval;
		} 
		retval = ModernizedCProgram.io_channel_write_blk64(fs.getIo(), block, 1, write_buf);
		if (!retval) {
			ModernizedCProgram.ext2fs_mark_changed(fs);
		} 
		return retval;
	}
	public static Object ext2fs_write_ext_attr2(Object fs, Object block, Object inbuf) {
		return ModernizedCProgram.ext2fs_write_ext_attr3(fs, block, inbuf, 0);
	}
	public static Object ext2fs_write_ext_attr(Object fs, Object block, Object inbuf) {
		return ModernizedCProgram.ext2fs_write_ext_attr2(fs, block, inbuf/*
		 * This function adjusts the reference count of the EA block.
		 */);
	}
	public static Object ext2fs_adjust_ea_refcount3(Object fs, Object blk, Byte block_buf, int adjust, Object newcount, Object inum) {
		 retval = new ();
		ext2_ext_attr_header header = new ext2_ext_attr_header();
		byte buf = 0;
		if ((blk >= fs.getSuper().ext2fs_blocks_count()) || (blk < fs.getSuper().getS_first_data_block())) {
			return EXT2_ET_BAD_EA_BLOCK_NUM;
		} 
		if (!block_buf) {
			retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), buf);
			if (retval) {
				return retval;
			} 
			block_buf = buf;
		} 
		retval = ModernizedCProgram.ext2fs_read_ext_attr3(fs, blk, block_buf, inum);
		if (retval) {
			;
		} 
		header = (ext2_ext_attr_header)block_buf;
		Object generatedH_refcount = header.getH_refcount();
		generatedH_refcount += adjust;
		if (newcount) {
			newcount = generatedH_refcount;
		} 
		retval = ModernizedCProgram.ext2fs_write_ext_attr3(fs, blk, block_buf, inum);
		if (retval) {
			;
		} 
		return retval;
	}
	public static Object ext2fs_adjust_ea_refcount2(Object fs, Object blk, Byte block_buf, int adjust, Object newcount) {
		return ModernizedCProgram.ext2fs_adjust_ea_refcount3(fs, blk, block_buf, adjust, newcount, 0);
	}
	public static Object ext2fs_adjust_ea_refcount(Object fs, Object blk, Byte block_buf, int adjust, Object newcount) {
		return ModernizedCProgram.ext2fs_adjust_ea_refcount2(fs, blk, block_buf, adjust, newcount);
	}
	public static Object find_ea_prefix(int index) {
		ea_name_index e = new ea_name_index();
		Object generatedName = e.getName();
		int generatedIndex = e.getIndex();
		for (e = ModernizedCProgram.ea_names; generatedName; e++) {
			if (generatedIndex == index) {
				return generatedName;
			} 
		}
		return ((Object)0);
	}
	public static int find_ea_index(Object fullname, Object name, Integer index) {
		ea_name_index e = new ea_name_index();
		Object generatedName = e.getName();
		int generatedIndex = e.getIndex();
		for (e = ModernizedCProgram.ea_names; generatedName; e++) {
			if (/*Error: Function owner not recognized*/strncmp(fullname, generatedName, /*Error: Function owner not recognized*/strlen(generatedName)) == 0) {
				name = fullname + /*Error: Function owner not recognized*/strlen(generatedName);
				index = generatedIndex;
				return 1;
			} 
		}
		return 0;
	}
	public static int posix_acl_xattr_count(Object size) {
		if (size < /*Error: Unsupported expression*/) {
			return -1;
		} 
		size -= /*Error: Unsupported expression*/;
		if (size % /*Error: Unsupported expression*/) {
			return -1;
		} 
		return size / /*Error: Unsupported expression*//*
		 * The lgetxattr function returns data formatted in the POSIX extended
		 * attribute format.  The on-disk format uses a more compact encoding.
		 * See the ext4_acl_to_disk in fs/ext4/acl.c.
		 */;
	}
	public static Object convert_posix_acl_to_disk_buffer(Object value, Object size, Object out_buf, Object size_out) {
		posix_acl_xattr_header header = (posix_acl_xattr_header)value;
		posix_acl_xattr_entry end = new posix_acl_xattr_entry();
		posix_acl_xattr_entry entry = (posix_acl_xattr_entry)(header + 1);
		ext4_acl_header ext_acl = new ext4_acl_header();
		size_t s = new size_t();
		byte e;
		int count;
		if (!value) {
			return 22;
		} 
		if (size < /*Error: Unsupported expression*/) {
			return 12;
		} 
		if (header.getA_version() != /*Error: Function owner not recognized*/ext2fs_cpu_to_le32(-1024)) {
			return 22;
		} 
		count = ModernizedCProgram.posix_acl_xattr_count(size);
		ext_acl = out_buf;
		ext_acl.setA_version(/*Error: Function owner not recognized*/ext2fs_cpu_to_le32(-1024));
		if (count <= 0) {
			return 22;
		} 
		e = (byte)out_buf + /*Error: Unsupported expression*/;
		s = /*Error: Unsupported expression*/;
		for (end = entry + count; entry != end; entry++) {
			ext4_acl_entry disk_entry = (ext4_acl_entry)e;
			disk_entry.setE_tag(/*Error: Function owner not recognized*/ext2fs_cpu_to_le16(entry.getE_tag()));
			disk_entry.setE_perm(/*Error: Function owner not recognized*/ext2fs_cpu_to_le16(entry.getE_perm()));
			switch (entry.getE_tag()) {
			case (true):
			case (true):
			case (true):
			case (true):
					disk_entry.setE_id(/*Error: Function owner not recognized*/ext2fs_cpu_to_le32(entry.getE_id()));
					e += /*Error: Unsupported expression*/;
					s += /*Error: Unsupported expression*/;
					break;
			case (true):
					e += /*Error: Unsupported expression*/;
					s += /*Error: Unsupported expression*/;
					break;
			case (true):
			}
		}
		size_out = s;
		return 0;
	}
	public static Object convert_disk_buffer_to_posix_acl(Object value, Object size, Object out_buf, Object size_out) {
		posix_acl_xattr_header header = new posix_acl_xattr_header();
		posix_acl_xattr_entry entry = new posix_acl_xattr_entry();
		ext4_acl_header ext_acl = (ext4_acl_header)value;
		 err = new ();
		byte cp;
		byte out;
		if ((!value) || (size < /*Error: Unsupported expression*/) || (ext_acl.getA_version() != /*Error: Function owner not recognized*/ext2fs_cpu_to_le32(-1024))) {
			return 22;
		} 
		err = ModernizedCProgram.ext2fs_get_mem(size * 2, out);
		if (err) {
			return err;
		} 
		header = (posix_acl_xattr_header)out;
		header.setA_version(/*Error: Function owner not recognized*/ext2fs_cpu_to_le32(-1024));
		entry = (posix_acl_xattr_entry)(out + /*Error: Unsupported expression*/);
		cp = (byte)value + /*Error: Unsupported expression*/;
		size -= /*Error: Unsupported expression*/;
		Object generatedE_tag = entry.getE_tag();
		while (size > 0) {
			ext4_acl_entry disk_entry = (ext4_acl_entry)cp;
			entry.setE_tag(/*Error: Function owner not recognized*/ext2fs_le16_to_cpu(disk_entry.getE_tag()));
			entry.setE_perm(/*Error: Function owner not recognized*/ext2fs_le16_to_cpu(disk_entry.getE_perm()));
			switch (generatedE_tag) {
			case (true):
			case (true):
			case (true):
					entry.setE_id(0);
					cp += /*Error: Unsupported expression*/;
					size -= /*Error: Unsupported expression*/;
					break;
			case (true):
			case (true):
			case (true):
					entry.setE_id(/*Error: Function owner not recognized*/ext2fs_le32_to_cpu(disk_entry.getE_id()));
					cp += /*Error: Unsupported expression*/;
					size -= /*Error: Unsupported expression*/;
					break;
			default:
					ModernizedCProgram.ext2fs_free_mem(out);
					return 22;
					break;
			}
			entry++;
		}
		out_buf = out;
		size_out = ((byte)entry - out);
		return 0;
	}
	public static Object read_xattrs_from_buffer(ext2_xattr_handle handle, ext2_inode_large inode, ext2_ext_attr_entry entries, int storage_size, Byte value_start) {
		ext2_xattr x = new ext2_xattr();
		ext2_ext_attr_entry entry = new ext2_ext_attr_entry();
		ext2_ext_attr_entry end = new ext2_ext_attr_entry();
		byte prefix;
		int remain;
		int prefix_len;
		 err = new ();
		int values_size = storage_size + ((byte)entries - value_start);
		end = /* find the end */entries;
		remain = storage_size;
		Object generatedE_name_len = end.getE_name_len();
		while (remain >= /*Error: Unsupported expression*/ && !((()(end)) == -1024)) {
			remain -= /*Error: Unsupported expression*//* header eats this space */;
			if ((((generatedE_name_len) + (((int)1 << 2) - 1)) & ~(((int)1 << 2) - 1)) > /* is attribute name valid? */remain) {
				return EXT2_ET_EA_BAD_NAME_LEN;
			} 
			remain -= (((generatedE_name_len) + (((int)1 << 2) - 1)) & ~(((int)1 << 2) - /* attribute len eats this space */1));
			end = ((ext2_ext_attr_entry)((byte)(end) + (((generatedE_name_len) + (((int)1 << 2) - 1) + /*Error: Unsupported expression*/) & ~(((int)1 << 2) - 1))));
		}
		entry = entries;
		remain = storage_size;
		int generatedCount = handle.getCount();
		int generatedCapacity = handle.getCapacity();
		ext2_xattr[] generatedAttrs = handle.getAttrs();
		Object generatedE_name_index = entry.getE_name_index();
		Byte generatedName = x.getName();
		Object generatedFs = handle.getFs();
		Object generatedE_value_inum = entry.getE_value_inum();
		Object generatedE_value_size = entry.getE_value_size();
		Object generatedE_value_offs = entry.getE_value_offs();
		Object generatedValue = x.getValue();
		ext2_inode ext2_inode = new ext2_inode();
		Object generatedI_flags = ea_inode.getI_flags();
		Object generatedI_links_count = ea_inode.getI_links_count();
		Object generatedE_hash = entry.getE_hash();
		Object generatedI_mtime = child.getI_mtime();
		Object generatedIno = handle.getIno();
		Object generatedI_generation = child.getI_generation();
		while (remain >= /*Error: Unsupported expression*/ && !((()(entry)) == -1024)) {
			if (generatedCount == generatedCapacity) {
				err = handle.ext2fs_xattrs_expand(4);
				if (err) {
					return err;
				} 
			} 
			x = generatedAttrs + generatedCount;
			remain -= /*Error: Unsupported expression*//* header eats this space */;
			remain -= (((generatedE_name_len) + (((int)1 << 2) - 1)) & ~(((int)1 << 2) - /* attribute len eats this space */1));
			prefix = ModernizedCProgram.find_ea_prefix(generatedE_name_index);
			prefix_len = (prefix ? /*Error: Function owner not recognized*/strlen(prefix) : 0);
			err = ModernizedCProgram.ext2fs_get_memzero(generatedE_name_len + prefix_len + 1, generatedName);
			if (err) {
				return err;
			} 
			if (prefix) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedName, prefix, prefix_len);
			} 
			if (generatedE_name_len) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedName + prefix_len, (byte)entry + /*Error: sizeof expression not supported yet*/, generatedE_name_len);
			} 
			if (!generatedFs.getSuper().ext2fs_has_feature_ea_inode() && generatedE_value_inum != 0) {
				return EXT2_ET_BAD_EA_BLOCK_NUM;
			} 
			if (generatedE_value_inum == 0) {
				if (generatedE_value_size > remain) {
					return EXT2_ET_EA_BAD_VALUE_SIZE;
				} 
				if (generatedE_value_offs + generatedE_value_size > values_size) {
					return EXT2_ET_EA_BAD_VALUE_OFFSET;
				} 
				if (generatedE_value_size > 0 && value_start + generatedE_value_offs < (byte)end + /*Error: Unsupported expression*/) {
					return EXT2_ET_EA_BAD_VALUE_OFFSET;
				} 
				remain -= generatedE_value_size;
				err = ModernizedCProgram.ext2fs_get_mem(generatedE_value_size, generatedValue);
				if (err) {
					return err;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedValue, value_start + generatedE_value_offs, generatedE_value_size);
			} else {
					ext2_inode ea_inode = new ext2_inode();
					ext2_file_t ea_file = new ext2_file_t();
					if (generatedE_value_offs != 0) {
						return EXT2_ET_EA_BAD_VALUE_OFFSET;
					} 
					if (generatedE_value_size > (64 * 1024)) {
						return EXT2_ET_EA_BAD_VALUE_SIZE;
					} 
					err = ModernizedCProgram.ext2fs_get_mem(generatedE_value_size, generatedValue);
					if (err) {
						return err;
					} 
					err = ModernizedCProgram.ext2fs_file_open(generatedFs, generatedE_value_inum, 0, ea_file);
					if (err) {
						return err;
					} 
					ea_inode = ext2_inode.ext2fs_file_get_inode(ea_file);
					if ((generatedI_flags & -1024) || !(generatedI_flags & -1024) || generatedI_links_count == 0) {
						err = EXT2_ET_EA_INODE_CORRUPTED;
					}  else if (ModernizedCProgram.ext2fs_file_get_size(ea_file) != generatedE_value_size) {
						err = EXT2_ET_EA_BAD_VALUE_SIZE;
					} else {
							err = ModernizedCProgram.ext2fs_file_read(ea_file, generatedValue, generatedE_value_size, 0);
					} 
					ModernizedCProgram.ext2fs_file_close(ea_file);
					if (err) {
						return err;
					} 
			} 
			x.setEa_ino(generatedE_value_inum);
			x.setValue_len(generatedE_value_size);
			if (generatedE_hash != /* e_hash may be 0 in older inode's ea */0) {
				 hash = new ();
				Object data = (generatedE_value_inum != 0) ? 0 : value_start + generatedE_value_offs;
				err = entry.ext2fs_ext_attr_hash_entry2(generatedFs, data, hash);
				if (err) {
					return err;
				} 
				if (generatedE_hash != hash) {
					ext2_inode child = new ext2_inode();
					err = child.ext2fs_read_inode(generatedFs, generatedE_value_inum);
					if (err) {
						return err;
					} 
					if (generatedI_mtime != generatedIno || generatedI_generation != generatedI_generation) {
						return EXT2_ET_BAD_EA_HASH;
					} 
				} 
			} 
			generatedCount++;
			entry = ((ext2_ext_attr_entry)((byte)(entry) + (((generatedE_name_len) + (((int)1 << 2) - 1) + /*Error: Unsupported expression*/) & ~(((int)1 << 2) - 1))));
		}
		return 0;
	}
	public static Object ext2fs_xattr_inode_max_size(Object fs, Object ino, Object size) {
		ext2_ext_attr_entry entry = new ext2_ext_attr_entry();
		ext2_inode_large inode = new ext2_inode_large();
		 ea_inode_magic = new ();
		int minoff;
		byte start;
		size_t i = new size_t();
		 err = new ();
		i = (((fs.getSuper()).getS_rev_level() == 0) ? 128 : (fs.getSuper()).getS_inode_size());
		if (i < /*Error: sizeof expression not supported yet*/) {
			i = /*Error: sizeof expression not supported yet*/;
		} 
		err = ModernizedCProgram.ext2fs_get_memzero(i, inode);
		if (err) {
			return err;
		} 
		err = (ext2_inode)inode.ext2fs_read_inode_full(fs, ino, (((fs.getSuper()).getS_rev_level() == 0) ? 128 : (fs.getSuper()).getS_inode_size()));
		if (err) {
			;
		} 
		Object generatedI_extra_isize = inode.getI_extra_isize();
		if ((((fs.getSuper()).getS_rev_level() == 0) ? 128 : (fs.getSuper()).getS_inode_size()) <= /* Does the inode have size for EA? */128 + generatedI_extra_isize + /*Error: Unsupported expression*/) {
			err = EXT2_ET_INLINE_DATA_NO_SPACE;
			;
		} 
		minoff = (((fs.getSuper()).getS_rev_level() == 0) ? 128 : (fs.getSuper()).getS_inode_size()) - /*Error: sizeof expression not supported yet*/ - /*Error: Unsupported expression*/;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ea_inode_magic, ((byte)inode) + 128 + generatedI_extra_isize, /*Error: Unsupported expression*/);
		Object generatedE_value_inum = entry.getE_value_inum();
		Object generatedE_value_size = entry.getE_value_size();
		Object generatedE_value_offs = entry.getE_value_offs();
		Object generatedE_name_len = (entry).getE_name_len();
		if (ea_inode_magic == -1024) {
			start = ((byte)inode) + /* has xattrs.  calculate the size */128 + generatedI_extra_isize + /*Error: Unsupported expression*/;
			entry = (ext2_ext_attr_entry)start;
			while (!((()(entry)) == -1024)) {
				if (!generatedE_value_inum && generatedE_value_size) {
					int offs = generatedE_value_offs;
					if (offs < minoff) {
						minoff = offs;
					} 
				} 
				entry = ((ext2_ext_attr_entry)((byte)(entry) + (((generatedE_name_len) + (((int)1 << 2) - 1) + /*Error: Unsupported expression*/) & ~(((int)1 << 2) - 1))));
			}
			size = minoff - ((byte)entry - (byte)start) - /*Error: Unsupported expression*/;
		} else {
				size = (((minoff - (((/*Error: Function owner not recognized*/strlen("data")) + (((int)1 << 2) - 1) + /*Error: Unsupported expression*/) & ~(((int)1 << 2) - 1)) - (((int)1 << 2) - 1) - /*Error: Unsupported expression*/) + (((int)1 << 2) - 1)) & ~(((int)1 << 2) - /* no xattr.  return a maximum size */1));
		} 
		return err;
	}
	public static Object xattr_create_ea_inode(Object fs, Object value, Object value_len, Object ea_ino) {
		ext2_inode inode = new ext2_inode();
		 ino = new ();
		ext2_file_t file = new ext2_file_t();
		 hash = new ();
		 ret = new ();
		ret = ModernizedCProgram.ext2fs_new_inode(fs, 0, 0, 0, ino);
		if (ret) {
			return ret;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(inode, 0, /*Error: sizeof expression not supported yet*/);
		Object generatedI_flags = inode.getI_flags();
		generatedI_flags |=  -1024;
		if (fs.getSuper().ext2fs_has_feature_extents()) {
			generatedI_flags |=  -1024;
		} 
		inode.setI_size(0);
		inode.setI_mode(100000 | 600);
		inode.setI_links_count(1);
		ret = inode.ext2fs_write_new_inode(fs, ino);
		if (ret) {
			return ret/*
				 * ref_count and hash utilize inode's i_*time fields.
				 * ext2fs_write_new_inode() call above initializes these fields with
				 * current time. That's why ref count and hash updates are done
				 * separately below.
				 */;
		} 
		inode.ext2fs_set_ea_inode_ref(1);
		hash = ModernizedCProgram.ext2fs_crc32c_le(fs.getCsum_seed(), value, value_len);
		inode.ext2fs_set_ea_inode_hash(hash);
		ret = inode.ext2fs_write_inode(fs, ino);
		if (ret) {
			return ret;
		} 
		ret = ModernizedCProgram.ext2fs_file_open(fs, ino, -1024, file);
		if (ret) {
			return ret;
		} 
		ret = ModernizedCProgram.ext2fs_file_write(file, value, value_len, ((Object)0));
		ModernizedCProgram.ext2fs_file_close(file);
		if (ret) {
			return ret;
		} 
		ModernizedCProgram.ext2fs_inode_alloc_stats2(fs, ino, 1, /* inuse *//* isdir */0);
		ea_ino = ino;
		return 0;
	}
	public static Object xattr_inode_dec_ref(Object fs, Object ino) {
		ext2_inode_large inode = new ext2_inode_large();
		 ref_count = new ();
		 ret = new ();
		ret = (ext2_inode)inode.ext2fs_read_inode_full(fs, ino, /*Error: sizeof expression not supported yet*/);
		if (ret) {
			;
		} 
		ext2_inode ext2_inode = new ext2_inode();
		ref_count = ext2_inode.EXT2_INODE(inode).ext2fs_get_ea_inode_ref();
		ref_count--;
		ext2_inode.EXT2_INODE(inode).ext2fs_set_ea_inode_ref(ref_count);
		if (ref_count) {
			;
		} 
		inode.setI_links_count(0);
		inode.setI_dtime(fs.getNow() ? fs.getNow() : /*Error: Function owner not recognized*/time(0));
		ret = inode.ext2fs_free_ext_attr(fs, ino);
		if (ret) {
			;
		} 
		if ((ext2_inode)inode.ext2fs_inode_has_valid_blocks2(fs)) {
			ret = (ext2_inode)inode.ext2fs_punch(fs, ino, ((Object)0), 0, ~-1024);
			if (ret) {
				;
			} 
		} 
		ModernizedCProgram.ext2fs_inode_alloc_stats2(fs, ino, -1, /* inuse *//* is_dir */0);
	}
	/*
	 * alloc.c --- allocate new inodes, blocks for ext2fs
	 *
	 * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/*
	 * Clear the uninit block bitmap flag if necessary
	 */
	public static void ext2fs_clear_block_uninit(Object fs, Object group) {
		if (group >= fs.getGroup_desc_count() || !ModernizedCProgram.ext2fs_has_group_desc_csum(fs) || !(ModernizedCProgram.ext2fs_bg_flags_test(fs, group, -1024))) {
			return /*Error: Unsupported expression*/;
		} 
		ModernizedCProgram.ext2fs_bg_flags_clear(fs, group, /* uninit block bitmaps are now initialized in read_bitmaps() */-1024);
		ModernizedCProgram.ext2fs_group_desc_csum_set(fs, group);
		ModernizedCProgram.ext2fs_mark_super_dirty(fs);
		ModernizedCProgram.ext2fs_mark_bb_dirty(fs/*
		 * Check for uninit inode bitmaps and deal with them appropriately
		 */);
	}
	public static void check_inode_uninit(Object fs, Object map, Object group) {
		 i = new ();
		 ino = new ();
		if (group >= fs.getGroup_desc_count() || !ModernizedCProgram.ext2fs_has_group_desc_csum(fs) || !(ModernizedCProgram.ext2fs_bg_flags_test(fs, group, -1024))) {
			return /*Error: Unsupported expression*/;
		} 
		ino = (group * fs.getSuper().getS_inodes_per_group()) + 1;
		for (i = 0; i < fs.getSuper().getS_inodes_per_group(); ) {
			ModernizedCProgram.ext2fs_fast_unmark_inode_bitmap2(map, ino);
		}
		ModernizedCProgram.ext2fs_bg_flags_clear(fs, group, -1024);
		ModernizedCProgram.ext2fs_bg_flags_clear(fs, group, /* Mimics what the kernel does */-1024);
		ModernizedCProgram.ext2fs_group_desc_csum_set(fs, group);
		ModernizedCProgram.ext2fs_mark_ib_dirty(fs);
		ModernizedCProgram.ext2fs_mark_super_dirty(fs/*
		 * Right now, just search forward from the parent directory's block
		 * group to find the next free inode.
		 *
		 * Should have a special policy for directories.
		 */);
	}
	public static Object ext2fs_new_inode(Object fs, Object dir, int mode, Object map, Object ret) {
		 start_inode = 0;
		 i = new ();
		 ino_in_group = new ();
		 upto = new ();
		 first_zero = new ();
		 retval = new ();
		 group = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		if (!map) {
			map = fs.getInode_map();
		} 
		if (!map) {
			return EXT2_ET_NO_INODE_BITMAP;
		} 
		if (dir > 0) {
			group = (dir - 1) / ((fs.getSuper()).getS_inodes_per_group());
			start_inode = (group * ((fs.getSuper()).getS_inodes_per_group())) + 1;
		} 
		if (start_inode < (((fs.getSuper()).getS_rev_level() == 0) ? 11 : (fs.getSuper()).getS_first_ino())) {
			start_inode = (((fs.getSuper()).getS_rev_level() == 0) ? 11 : (fs.getSuper()).getS_first_ino());
		} 
		if (start_inode > fs.getSuper().getS_inodes_count()) {
			return EXT2_ET_INODE_ALLOC_FAIL;
		} 
		i = start_inode;
		do {
			ino_in_group = (i - 1) % ((fs.getSuper()).getS_inodes_per_group());
			group = (i - 1) / ((fs.getSuper()).getS_inodes_per_group());
			ModernizedCProgram.check_inode_uninit(fs, map, group);
			upto = i + (((fs.getSuper()).getS_inodes_per_group()) - ino_in_group);
			if (i < start_inode && upto >= start_inode) {
				upto = start_inode - 1;
			} 
			if (upto > fs.getSuper().getS_inodes_count()) {
				upto = fs.getSuper().getS_inodes_count();
			} 
			retval = ModernizedCProgram.ext2fs_find_first_zero_inode_bitmap2(map, i, upto, first_zero);
			if (retval == 0) {
				i = first_zero;
				break;
			} 
			if (retval != 2) {
				return EXT2_ET_INODE_ALLOC_FAIL;
			} 
			i = upto + 1;
			if (i > fs.getSuper().getS_inodes_count()) {
				i = (((fs.getSuper()).getS_rev_level() == 0) ? 11 : (fs.getSuper()).getS_first_ino());
			} 
		} while (i != start_inode);
		if (ModernizedCProgram.ext2fs_test_inode_bitmap2(map, i)) {
			return EXT2_ET_INODE_ALLOC_FAIL;
		} 
		ret = i;
		return 0/*
		 * Stupid algorithm --- we now just search forward starting from the
		 * goal.  Should put in a smarter one someday....
		 */;
	}
	public static Object ext2fs_new_block2(Object fs, Object goal, Object map, Object ret) {
		return ((Object)0).ext2fs_new_block3(fs, goal, map, ret);
	}
	public static Object ext2fs_new_block(Object fs, Object goal, Object map, Object ret) {
		 retval = new ();
		 val = new ();
		retval = ModernizedCProgram.ext2fs_new_block2(fs, goal, map, val);
		if (!retval) {
			ret = ()val;
		} 
		return retval/*
		 * This function zeros out the allocated block, and updates all of the
		 * appropriate filesystem records.
		 */;
	}
	public static Object ext2fs_alloc_block2(Object fs, Object goal, Byte block_buf, Object ret) {
		return ((Object)0).ext2fs_alloc_block3(fs, goal, block_buf, ret);
	}
	public static Object ext2fs_alloc_block(Object fs, Object goal, Byte block_buf, Object ret) {
		 retval = new ();
		 ret64 = new ();
		 goal64 = goal;
		retval = ((Object)0).ext2fs_alloc_block3(fs, goal64, block_buf, ret64);
		if (!retval) {
			ret = ()ret64;
		} 
		return retval;
	}
	public static Object ext2fs_get_free_blocks2(Object fs, Object start, Object finish, int num, Object map, Object ret) {
		 b = start;
		int c_ratio;
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		if (!map) {
			map = fs.getBlock_map();
		} 
		if (!map) {
			return EXT2_ET_NO_BLOCK_BITMAP;
		} 
		if (!b) {
			b = fs.getSuper().getS_first_data_block();
		} 
		if (!finish) {
			finish = start;
		} 
		if (!num) {
			num = 1;
		} 
		c_ratio = 1 << ModernizedCProgram.ext2fs_get_bitmap_granularity(map);
		b &=  ~(c_ratio - 1);
		finish &=  ~(c_ratio - 1);
		do {
			if (b + num - 1 >= fs.getSuper().ext2fs_blocks_count()) {
				if (finish > start) {
					return EXT2_ET_BLOCK_ALLOC_FAIL;
				} 
				b = fs.getSuper().getS_first_data_block();
			} 
			if (ModernizedCProgram.ext2fs_fast_test_block_bitmap_range2(map, b, num)) {
				ret = b;
				return 0;
			} 
			b += c_ratio;
		} while (b != finish);
		return EXT2_ET_BLOCK_ALLOC_FAIL;
	}
	public static Object ext2fs_get_free_blocks(Object fs, Object start, Object finish, int num, Object map, Object ret) {
		 retval = new ();
		 val = new ();
		retval = ModernizedCProgram.ext2fs_get_free_blocks2(fs, start, finish, num, map, val);
		if (!retval) {
			ret = ()val;
		} 
		return retval;
	}
	public static void ext2fs_set_alloc_block_callback(Object fs, Object func, Object old) {
		if (!fs || fs.getMagic() != EXT2_ET_MAGIC_EXT2FS_FILSYS) {
			return /*Error: Unsupported expression*/;
		} 
		if (old) {
			old = fs.getGet_alloc_block();
		} 
		fs.setGet_alloc_block(func);
	}
	public static Object ext2fs_new_range(Object fs, int flags, Object goal, Object len, Object map, Object pblk, Object plen) {
		 retval = new ();
		 start = new ();
		 end = new ();
		 b = new ();
		int looped = 0;
		 max_blocks = fs.getSuper().ext2fs_blocks_count();
		 nrf = new ();
		;
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		if (len == 0 || (flags & ~(true))) {
			return EXT2_ET_INVALID_ARGUMENT;
		} 
		if (!map && fs.getNew_range()) {
			nrf = fs.getNew_range();
			fs.setNew_range(((Object)0));
			retval = /*Error: Function owner not recognized*/nrf(fs, flags, goal, len, pblk, plen);
			fs.setNew_range(nrf);
			if (retval) {
				return retval;
			} 
			start = pblk;
			end = pblk + plen;
			;
		} 
		if (!map) {
			map = fs.getBlock_map();
		} 
		if (!map) {
			return EXT2_ET_NO_BLOCK_BITMAP;
		} 
		if (!goal || goal >= fs.getSuper().ext2fs_blocks_count()) {
			goal = fs.getSuper().getS_first_data_block();
		} 
		start = goal;
	}
	public static void ext2fs_set_new_range_callback(Object fs, Object func, Object old) {
		if (!fs || fs.getMagic() != EXT2_ET_MAGIC_EXT2FS_FILSYS) {
			return /*Error: Unsupported expression*/;
		} 
		if (old) {
			old = fs.getNew_range();
		} 
		fs.setNew_range(func);
	}
	public static Object ext2fs_alloc_range(Object fs, int flags, Object goal, Object len, Object ret) {
		int newr_flags = (true);
		 retval = new ();
		 plen = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		if (len == 0 || (flags & ~(true))) {
			return EXT2_ET_INVALID_ARGUMENT;
		} 
		if (flags & (true)) {
			newr_flags |=  (true);
		} 
		retval = ModernizedCProgram.ext2fs_new_range(fs, newr_flags, goal, len, ((Object)0), ret, plen);
		if (retval) {
			return retval;
		} 
		if (plen < len) {
			return EXT2_ET_BLOCK_ALLOC_FAIL;
		} 
		if (flags & (true)) {
			retval = ModernizedCProgram.ext2fs_zero_blocks2(fs, ret, len, ((Object)0), ((Object)0));
			if (retval) {
				return retval;
			} 
		} 
		ModernizedCProgram.ext2fs_block_alloc_stats_range(fs, ret, len, +1);
		return retval;
	}
	// This one is only available on Vista or later...
	public static Byte NtStatusError(Object Status) {
		byte[] unknown = new byte[32];
		switch (Status) {
		case -1024:
				return "Invalid Handle.";
		case -1024:
				return "Not Enough Quota";
		case ((NTSTATUS)-1024):
				return "Info Length Mismatch";
		case ((NTSTATUS)-1024):
				return "Access Denied";
		case ((NTSTATUS)-1024):
				return "Buffer Overflow";
		case ((NTSTATUS)-1024):
				return "Not Implemented";
		case ((NTSTATUS)-1024):
				return "Object Name Invalid";
		case ((NTSTATUS)-1024):
				return "Object Path Invalid";
		case ((NTSTATUS)-1024):
				return "Insufficient resources";
		case ((NTSTATUS)-1024):
				return "Operation is not supported";
		case ((NTSTATUS)-1024):
				return "Buffer Too Small";
		case ((NTSTATUS)-1024):
				return "Sharing Violation";
		case ((NTSTATUS)-1024):
				return "Operation Successful";
		case ((NTSTATUS)-1024):
				return "Object Name not found";
		case STATUS_INVALID_PARAMETER:
				return "Invalid Parameter";
		case ((NTSTATUS)-1024):
				return "Wrong Type";
		case ((NTSTATUS)-1024):
				return "Operation Failed";
		default:
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(unknown, /*Error: sizeof expression not supported yet*/, "Unknown error 0x%08lx", Status);
					(unknown)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				return unknown;
		}
	}
	public static Object PhCreateHeap() {
		NTSTATUS status = ((NTSTATUS)-1024);
		if (ModernizedCProgram.PhHeapHandle != ((Object)0)) {
			return ((NTSTATUS)-1024);
		} 
		do {
			if (ModernizedCProgram.pfRtlCreateHeap == ((Object)0)) {
				ModernizedCProgram.pfRtlCreateHeap = (RtlCreateHeap_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "RtlCreateHeap");
			} 
			if ((ModernizedCProgram.pfRtlCreateHeap == ((Object)0)) && (/*Error: Function owner not recognized*/NT_SUCCESS(status))) {
				status = ((NTSTATUS)-1024);
			} 
		} while (0);
		if (/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			ModernizedCProgram.PhHeapHandle = /*Error: Function owner not recognized*/pfRtlCreateHeap(1 | 2, ((Object)0), 2 * -1024, 1 * -1024, ((Object)0), ((Object)0));
			if (ModernizedCProgram.PhHeapHandle == ((Object)0)) {
				status = ((NTSTATUS)-1024);
			} 
		} 
		return status;
	}
	public static int status(Integer ) {
	}
	public static Object PhDestroyHeap() {
		NTSTATUS status = ((NTSTATUS)-1024);
		if (ModernizedCProgram.PhHeapHandle == ((Object)0)) {
			return ((NTSTATUS)-1024);
		} 
		do {
			if (ModernizedCProgram.pfRtlDestroyHeap == ((Object)0)) {
				ModernizedCProgram.pfRtlDestroyHeap = (RtlDestroyHeap_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "RtlDestroyHeap");
			} 
			if ((ModernizedCProgram.pfRtlDestroyHeap == ((Object)0)) && (/*Error: Function owner not recognized*/NT_SUCCESS(status))) {
				status = ((NTSTATUS)-1024);
			} 
		} while (0);
		if (/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			if (/*Error: Function owner not recognized*/pfRtlDestroyHeap(ModernizedCProgram.PhHeapHandle) == ((Object)0)) {
				ModernizedCProgram.PhHeapHandle = ((Object)0);
			} else {
					status = ((NTSTATUS)-1024);
			} 
		} 
		return status/**
		 * Allocates a block of memory.
		 *
		 * \param Size The number of bytes to allocate.
		 *
		 * \return A pointer to the allocated block of memory.
		 *
		 */;
	}
	public static Object PhAllocate(Object Size) {
		if (ModernizedCProgram.pfRtlAllocateHeap == ((Object)0)) {
			ModernizedCProgram.pfRtlAllocateHeap = (RtlAllocateHeap_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "RtlAllocateHeap");
		} 
		if (ModernizedCProgram.pfRtlAllocateHeap == ((Object)0)) {
			return ((Object)0);
		} 
		return /*Error: Function owner not recognized*/pfRtlAllocateHeap(ModernizedCProgram.PhHeapHandle, 0, Size/**
		 * Frees a block of memory allocated with PhAllocate().
		 *
		 * \param Memory A pointer to a block of memory.
		 *
		 */);
	}
	public static void PhFree(Object Memory) {
		if (ModernizedCProgram.pfRtlFreeHeap == ((Object)0)) {
			ModernizedCProgram.pfRtlFreeHeap = (RtlFreeHeap_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "RtlFreeHeap");
		} 
		if (ModernizedCProgram.pfRtlFreeHeap != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfRtlFreeHeap(ModernizedCProgram.PhHeapHandle, 0, Memory/**
			 * Enumerates all open handles.
			 *
			 * \param Handles A variable which receives a pointer to a structure containing information about
			 * all opened handles. You must free the structure using PhFree() when you no longer need it.
			 *
			 * \return An NTStatus indicating success or the error code.
			 */);
		} 
	}
	public static Object PhEnumHandlesEx(Object Handles) {
		ULONG initialBufferSize = -1024;
		NTSTATUS status = ((NTSTATUS)-1024);
		PVOID buffer = new PVOID();
		ULONG bufferSize = new ULONG();
		do {
			if (ModernizedCProgram.pfNtQuerySystemInformation == ((Object)0)) {
				ModernizedCProgram.pfNtQuerySystemInformation = (NtQuerySystemInformation_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "NtQuerySystemInformation");
			} 
			if ((ModernizedCProgram.pfNtQuerySystemInformation == ((Object)0)) && (/*Error: Function owner not recognized*/NT_SUCCESS(status))) {
				status = ((NTSTATUS)-1024);
			} 
		} while (0);
		if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			return status;
		} 
		bufferSize = initialBufferSize;
		buffer = ModernizedCProgram.PhAllocate(bufferSize);
		if (buffer == ((Object)0)) {
			return -1024;
		} 
		while ((status = /*Error: Function owner not recognized*/pfNtQuerySystemInformation(64, buffer, bufferSize, ((Object)0))) == ((NTSTATUS)-1024)) {
			ModernizedCProgram.PhFree(buffer);
			bufferSize *= 2;
			if (bufferSize > (256 * 1024 * 1024)) {
				return ((NTSTATUS)-1024);
			} 
			buffer = ModernizedCProgram.PhAllocate(bufferSize);
			if (buffer == ((Object)0)) {
				return -1024;
			} 
		}
		if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			ModernizedCProgram.PhFree(buffer);
			return status;
		} 
		if (bufferSize <= -1024) {
			initialBufferSize = bufferSize;
		} 
		Handles = (PSYSTEM_HANDLE_INFORMATION_EX)buffer;
		return status/**
		 * Opens a process.
		 *
		 * \param ProcessHandle A variable which receives a handle to the process.
		 * \param DesiredAccess The desired access to the process.
		 * \param ProcessId The ID of the process.
		 *
		 * \return An NTStatus indicating success or the error code.
		 */;
	}
	public static Object PhOpenProcess(Object ProcessHandle, Object DesiredAccess, Object ProcessId) {
		NTSTATUS status = ((NTSTATUS)-1024);
		 objectAttributes = new ();
		 clientId = new ();
		if ((LONG_PTR)ProcessId == (LONG_PTR)/*Error: Function owner not recognized*/GetCurrentProcessId()) {
			ProcessHandle = ((HANDLE)(LONG_PTR)-1);
			return 0;
		} 
		do {
			if (ModernizedCProgram.pfNtOpenProcess == ((Object)0)) {
				ModernizedCProgram.pfNtOpenProcess = (NtOpenProcess_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "NtOpenProcess");
			} 
			if ((ModernizedCProgram.pfNtOpenProcess == ((Object)0)) && (/*Error: Function owner not recognized*/NT_SUCCESS(status))) {
				status = ((NTSTATUS)-1024);
			} 
		} while (0);
		if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			return status;
		} 
		clientId.setUniqueProcess(ProcessId);
		clientId.setUniqueThread(((Object)0));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/InitializeObjectAttributes(objectAttributes, ((Object)0), 0, ((Object)0), ((Object)0));
		status = /*Error: Function owner not recognized*/pfNtOpenProcess(ProcessHandle, DesiredAccess, objectAttributes, clientId);
		return status/**
		 * Query processes with open handles to a file, volume or disk.
		 *
		 * \param VolumeOrFileHandle The handle to the target.
		 * \param Information The returned list of processes.
		 *
		 * \return An NTStatus indicating success or the error code.
		 */;
	}
	public static Object PhQueryProcessesUsingVolumeOrFile(Object VolumeOrFileHandle, Object Information) {
		ULONG initialBufferSize = 16 * -1024;
		NTSTATUS status = ((NTSTATUS)-1024);
		PVOID buffer = new PVOID();
		ULONG bufferSize = new ULONG();
		 isb = new ();
		do {
			if (ModernizedCProgram.pfNtQueryInformationFile == ((Object)0)) {
				ModernizedCProgram.pfNtQueryInformationFile = (NtQueryInformationFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtQueryInformationFile");
			} 
			if ((ModernizedCProgram.pfNtQueryInformationFile == ((Object)0)) && (/*Error: Function owner not recognized*/NT_SUCCESS(status))) {
				status = ((NTSTATUS)-1024);
			} 
		} while (0);
		if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			return status;
		} 
		bufferSize = initialBufferSize;
		buffer = ModernizedCProgram.PhAllocate(bufferSize);
		if (buffer == ((Object)0)) {
			return ((NTSTATUS)-1024);
		} 
		while ((status = /*Error: Function owner not recognized*/pfNtQueryInformationFile(VolumeOrFileHandle, isb, buffer, bufferSize, 47)) == ((NTSTATUS)-1024)) {
			ModernizedCProgram.PhFree(buffer);
			bufferSize *= 2;
			if (bufferSize > 64 * -1024) {
				return ((NTSTATUS)-1024);
			} 
			buffer = ModernizedCProgram.PhAllocate(bufferSize);
		}
		if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			ModernizedCProgram.PhFree(buffer);
			return status;
		} 
		if (bufferSize <= 64 * -1024) {
			initialBufferSize = bufferSize;
		} 
		Information = (PFILE_PROCESS_IDS_USING_FILE_INFORMATION)buffer;
		return status/**
		 * Query the full commandline that was used to create a process.
		 * This can be helpful to differentiate between service instances (svchost.exe).
		 * Taken from: https://stackoverflow.com/a/14012919/1069307
		 *
		 * \param hProcess A handle to a process.
		 *
		 * \return A Unicode commandline string, or NULL on error.
		 *         The returned string must be freed by the caller.
		 */;
	}
	public static Object GetProcessCommandLine(Object hProcess) {
		PWSTR wcmdline = ((Object)0);
		BOOL wow = new BOOL();
		DWORD pp_offset = new DWORD();
		DWORD cmd_offset = new DWORD();
		NTSTATUS status = ((NTSTATUS)-1024);
		SYSTEM_INFO si = new SYSTEM_INFO();
		PBYTE peb = ((Object)0);
		PBYTE pp = ((Object)0);
		/*Error: Function owner not recognized*/// Determine if 64 or 32-bit processor/*Error: Function owner not recognized*/// Determine if 64 or 32-bit processorGetNativeSystemInfo(si);
		Object generatedWProcessorArchitecture = si.getWProcessorArchitecture();
		if ((generatedWProcessorArchitecture == 9) || (generatedWProcessorArchitecture == 12)) {
			pp_offset = -1024;
			cmd_offset = -1024;
		} else {
				pp_offset = -1024;
				cmd_offset = -1024;
		} 
		// PEB and Process Parameters (we only need the beginning of these structs)// PEB and Process Parameters (we only need the beginning of these structs)peb = (PBYTE)/*Error: Function owner not recognized*/calloc(pp_offset + 8, 1);
		if (peb == ((Object)0)) {
			;
		} 
		pp = (PBYTE)/*Error: Function owner not recognized*/calloc(cmd_offset + 16, 1);
		if (pp == ((Object)0)) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IsWow64Process(/*Error: Function owner not recognized*/GetCurrentProcess(), wow);
		Object generatedPebBaseAddress = pbi.getPebBaseAddress();
		Object generatedLength = ucmdline.getLength();
		Object generatedBuffer = ucmdline.getBuffer();
		if (wow) {
			PROCESS_BASIC_INFORMATION_WOW64 pbi = new PROCESS_BASIC_INFORMATION_WOW64(0);
			ULONGLONG params = new ULONGLONG();
			UNICODE_STRING_WOW64 ucmdline = new UNICODE_STRING_WOW64();
			do {
				if (ModernizedCProgram.pfNtWow64QueryInformationProcess64 == ((Object)0)) {
					ModernizedCProgram.pfNtWow64QueryInformationProcess64 = (NtWow64QueryInformationProcess64_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtWow64QueryInformationProcess64");
				} 
				if (ModernizedCProgram.pfNtWow64QueryInformationProcess64 == ((Object)0)) {
					ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "NtWow64QueryInformationProcess64", "NtDll", ModernizedCProgram.WindowsErrorString());
					;
				} 
			} while (0);
			do {
				if (ModernizedCProgram.pfNtWow64ReadVirtualMemory64 == ((Object)0)) {
					ModernizedCProgram.pfNtWow64ReadVirtualMemory64 = (NtWow64ReadVirtualMemory64_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtWow64ReadVirtualMemory64");
				} 
				if (ModernizedCProgram.pfNtWow64ReadVirtualMemory64 == ((Object)0)) {
					ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "NtWow64ReadVirtualMemory64", "NtDll", ModernizedCProgram.WindowsErrorString());
					;
				} 
			} while (0);
			status = /*Error: Function owner not recognized*/pfNtWow64QueryInformationProcess64(hProcess, 0, pbi, /*Error: sizeof expression not supported yet*/, ((Object)0));
			if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
				;
			} 
			status = /*Error: Function owner not recognized*/pfNtWow64ReadVirtualMemory64(hProcess, generatedPebBaseAddress, peb, pp_offset + 8, ((Object)0));
			if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
				;
			} 
			params = (ULONGLONG)((ULONGLONG)(peb + pp_offset));
			status = /*Error: Function owner not recognized*/pfNtWow64ReadVirtualMemory64(hProcess, params, pp, cmd_offset + 16, ((Object)0));
			if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
				;
			} 
			ucmdline = (UNICODE_STRING_WOW64)(pp + cmd_offset);
			wcmdline = (PWSTR)/*Error: Function owner not recognized*/calloc(generatedLength + 1, /*Error: Unsupported expression*/);
			if (wcmdline == ((Object)0)) {
				;
			} 
			status = /*Error: Function owner not recognized*/pfNtWow64ReadVirtualMemory64(hProcess, generatedBuffer, wcmdline, generatedLength, ((Object)0));
			if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wcmdline);
					wcmdline = ((Object)0);
				} while (0);
				;
			} 
		} else {
				 pbi = new (0);
				PBYTE params = new PBYTE();
				 ucmdline = new ();
				do {
					if (ModernizedCProgram.pfNtQueryInformationProcess == ((Object)0)) {
						ModernizedCProgram.pfNtQueryInformationProcess = (NtQueryInformationProcess_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtQueryInformationProcess");
					} 
					if (ModernizedCProgram.pfNtQueryInformationProcess == ((Object)0)) {
						ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "NtQueryInformationProcess", "NtDll", ModernizedCProgram.WindowsErrorString());
						;
					} 
				} while (0);
				status = /*Error: Function owner not recognized*/pfNtQueryInformationProcess(hProcess, 0, pbi, /*Error: sizeof expression not supported yet*/, ((Object)0));
				if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
					;
				} 
				if (!/*Error: Function owner not recognized*/ReadProcessMemory(hProcess, generatedPebBaseAddress, peb, pp_offset + 8, ((Object)0))) {
					;
				} 
				params = (PBYTE)(LPVOID)(peb + pp_offset);
				if (!/*Error: Function owner not recognized*/ReadProcessMemory(hProcess, params, pp, cmd_offset + 16, ((Object)0))) {
					;
				} 
				ucmdline = ()(pp + cmd_offset);
				ucmdline.setLength(((generatedLength) < (true) ? (generatedLength) : (true)));
				wcmdline = (PWSTR)/*Error: Function owner not recognized*/calloc(generatedLength + 1, /*Error: Unsupported expression*/);
				if (!/*Error: Function owner not recognized*/ReadProcessMemory(hProcess, generatedBuffer, wcmdline, generatedLength, ((Object)0))) {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wcmdline);
						wcmdline = ((Object)0);
					} while (0);
					;
				} 
		} 
		// 32-bit process running on a 64-bit OS
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(pp);
		return wcmdline;
	}
	public static Object SearchProcessThread(Object param) {
		byte[] access_rights_str = new byte[]{"n", "r", "w", "rw", "x", "rx", "wx", "rwx"};
		byte[] tmp = new byte[260];
		NTSTATUS status = ((NTSTATUS)-1024);
		PSYSTEM_HANDLE_INFORMATION_EX handles = ((Object)0);
		 buffer = ((Object)0);
		ULONG_PTR i = new ULONG_PTR();
		ULONG_PTR[] pid = new ULONG_PTR();
		ULONG_PTR last_access_denied_pid = 0;
		ULONG bufferSize = new ULONG();
		USHORT wHandleNameLen = new USHORT();
		HANDLE dupHandle = ((Object)0);
		HANDLE processHandle = ((Object)0);
		BOOLEAN bFound = 0;
		BOOLEAN bGotCmdLine = new BOOLEAN();
		BOOLEAN verbose = !ModernizedCProgram._bQuiet;
		ULONG access_rights = 0;
		DWORD size = new DWORD();
		byte[] cmdline = new byte[]{0};
		wchar_t[] wexe_path = new wchar_t();
		wchar_t wcmdline = new wchar_t();
		int cur_pid;
		do {
			if (ModernizedCProgram.pfNtQueryObject == ((Object)0)) {
				ModernizedCProgram.pfNtQueryObject = (NtQueryObject_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "NtQueryObject");
			} 
			if ((ModernizedCProgram.pfNtQueryObject == ((Object)0)) && (/*Error: Function owner not recognized*/NT_SUCCESS(status))) {
				status = ((NTSTATUS)-1024);
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfNtDuplicateObject == ((Object)0)) {
				ModernizedCProgram.pfNtDuplicateObject = (NtDuplicateObject_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtDuplicateObject");
			} 
			if ((ModernizedCProgram.pfNtDuplicateObject == ((Object)0)) && (/*Error: Function owner not recognized*/NT_SUCCESS(status))) {
				status = ((NTSTATUS)-1024);
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfNtClose == ((Object)0)) {
				ModernizedCProgram.pfNtClose = (NtClose_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtClose");
			} 
			if ((ModernizedCProgram.pfNtClose == ((Object)0)) && (/*Error: Function owner not recognized*/NT_SUCCESS(status))) {
				status = ((NTSTATUS)-1024);
			} 
		} while (0);
		ModernizedCProgram.BlockingProcess.StrArrayClear();
		if (/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			status = ModernizedCProgram.PhCreateHeap();
		} 
		if (/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			status = ModernizedCProgram.PhEnumHandlesEx(handles);
		} 
		if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			ModernizedCProgram._uprintf("Warning: Could not enumerate process handles: %s", ModernizedCProgram.NtStatusError(status));
			;
		} 
		pid[0] = (ULONG_PTR)0;
		cur_pid = 1;
		wHandleNameLen = (USHORT)/*Error: Function owner not recognized*/wcslen(ModernizedCProgram._wHandleName);
		bufferSize = -1024;
		buffer = ModernizedCProgram.PhAllocate(bufferSize);
		if (buffer == ((Object)0)) {
			;
		} 
		for (i = 0; /*Error: Unsupported expression*/; i++) {
			ULONG attempts = 8;
			PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX handleInfo = (i < handles.getNumberOfHandles()) ? handles.getHandles()[i] : ((Object)0);
			if ((dupHandle != ((Object)0)) && (processHandle != ((HANDLE)(LONG_PTR)-1))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfNtClose(dupHandle);
				dupHandle = ((Object)0);
			} 
			pid[cur_pid] = (handleInfo != ((Object)0)) ? handleInfo.getUniqueProcessId() : -1;
			if (pid[0] != pid[1]) {
				cur_pid = (cur_pid + 1) % 2;
				if (bFound) {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "â? [%06u] %s (%s)", (uint32_t)pid[cur_pid], cmdline, access_rights_str[access_rights & -1024]);
						(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
					do {
						if (verbose) {
							ModernizedCProgram._uprintf(tmp);
						} 
					} while (0);
					ModernizedCProgram.BlockingProcess.StrArrayAdd(tmp, 1);
					bFound = 0;
					access_rights = 0;
				} 
				if (processHandle != ((Object)0)) {
					if (processHandle != ((HANDLE)(LONG_PTR)-1)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfNtClose(processHandle);
					} 
					processHandle = ((Object)0);
				} 
			} 
			if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
				;
			} 
			if (i >= handles.getNumberOfHandles()) {
				break;
			} 
			if (handleInfo.getUniqueProcessId() == last_access_denied_pid) {
				continue;
			} 
			if ((handleInfo.getGrantedAccess() & -1024) == 0) {
				continue;
			} 
			if (pid[0] != pid[1]) {
				status = ModernizedCProgram.PhOpenProcess(processHandle, 64 | 1024 | 16, (HANDLE)handleInfo.getUniqueProcessId());
				if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
					do {
						if (ModernizedCProgram.usb_debug) {
							ModernizedCProgram._uprintf("SearchProcess: Could not open process %ld: %s", handleInfo.getUniqueProcessId(), ModernizedCProgram.NtStatusError(status));
						} 
					} while (0);
					processHandle = ((Object)0);
					if (status == ((NTSTATUS)-1024)) {
						last_access_denied_pid = handleInfo.getUniqueProcessId();
					} 
					continue;
				} 
			} 
			if (processHandle == ((HANDLE)(LONG_PTR)-1)) {
				if (ModernizedCProgram._bIgnoreSelf) {
					continue;
				} 
				dupHandle = (HANDLE)handleInfo.getHandleValue();
			} else {
					status = /*Error: Function owner not recognized*/pfNtDuplicateObject(processHandle, (HANDLE)handleInfo.getHandleValue(), ((HANDLE)(LONG_PTR)-1), dupHandle, 0, 0, 0);
					if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
						continue;
					} 
			} 
			if (/*Error: Function owner not recognized*/GetFileType(dupHandle) != 1) {
				continue;
			} 
			do {
				ULONG returnSize = new ULONG();
				status = /*Error: Function owner not recognized*/pfNtQueryObject(dupHandle, ObjectNameInformation, buffer, bufferSize, returnSize);
				if (status == ((NTSTATUS)-1024) || status == ((NTSTATUS)-1024) || status == ((NTSTATUS)-1024)) {
					do {
						if (ModernizedCProgram.usb_debug) {
							ModernizedCProgram._uprintf("SearchProcess: Realloc from %d to %d", bufferSize, returnSize);
						} 
					} while (0);
					bufferSize = returnSize;
					ModernizedCProgram.PhFree(buffer);
					buffer = ModernizedCProgram.PhAllocate(bufferSize);
				} else {
						break;
				} 
			} while (--attempts);
			if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
				do {
					if (ModernizedCProgram.usb_debug) {
						ModernizedCProgram._uprintf("SearchProcess: NtQueryObject failed for handle %X of process %ld: %s", handleInfo.getHandleValue(), handleInfo.getUniqueProcessId(), ModernizedCProgram.NtStatusError(status));
					} 
				} while (0);
				continue;
			} 
			if ((!ModernizedCProgram._bPartialMatch) && (wHandleNameLen != buffer.getName().getLength())) {
				continue;
			} 
			if ((ModernizedCProgram._bPartialMatch) && (wHandleNameLen > buffer.getName().getLength())) {
				continue;
			} 
			if (/*Error: Function owner not recognized*/wcsncmp(ModernizedCProgram._wHandleName, buffer.getName().getBuffer(), wHandleNameLen) != 0) {
				continue;
			} 
			bFound = 1;
			access_rights |=  handleInfo.getGrantedAccess();
			if (access_rights & -1024) {
				access_rights = (access_rights & -1024) | -1024;
			} 
			ModernizedCProgram.access_mask |=  (BYTE)(access_rights & -1024) + -1024;
			if (cmdline[0] == 0) {
				do {
					if (verbose) {
						ModernizedCProgram._uprintf("WARNING: The following process(es) or service(s) are accessing %S:", ModernizedCProgram._wHandleName);
					} 
				} while (0);
			} 
			bGotCmdLine = 0;
			wcmdline = ModernizedCProgram.GetProcessCommandLine(processHandle);
			if (wcmdline != ((Object)0)) {
				bGotCmdLine = 1;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wcmdline, -1, cmdline, /*Error: sizeof expression not supported yet*/, ((Object)0), ((Object)0));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(wcmdline);
			} 
			if (!bGotCmdLine) {
				bGotCmdLine = (ModernizedCProgram.GetModuleFileNameExU(processHandle, 0, cmdline, 260 - 1) != 0);
			} 
			if (!bGotCmdLine) {
				size = 260;
				if (ModernizedCProgram.pfQueryFullProcessImageNameW == ((Object)0)) {
					ModernizedCProgram.pfQueryFullProcessImageNameW = (QueryFullProcessImageNameW_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("kernel32"), "QueryFullProcessImageNameW");
				} 
				if ((ModernizedCProgram.pfQueryFullProcessImageNameW != ((Object)0)) && (bGotCmdLine = /*Error: Function owner not recognized*/pfQueryFullProcessImageNameW(processHandle, 0, wexe_path, size))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wexe_path, -1, cmdline, /*Error: sizeof expression not supported yet*/, ((Object)0), ((Object)0));
				} 
			} 
			if (!bGotCmdLine) {
				bGotCmdLine = (/*Error: Function owner not recognized*/GetProcessImageFileNameW(processHandle, wexe_path, 260) != 0);
				if (bGotCmdLine) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wexe_path, -1, cmdline, /*Error: sizeof expression not supported yet*/, ((Object)0), ((Object)0));
				} 
			} 
			if (!bGotCmdLine) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(cmdline, /*Error: sizeof expression not supported yet*/, "Unknown_Process_%I64u", (ULONGLONG)handleInfo.getUniqueProcessId());
					(cmdline)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
			} 
		}
		ModernizedCProgram.PhFree(buffer);
		ModernizedCProgram.PhFree(handles);
		ModernizedCProgram.PhDestroyHeap();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExitThread(0/**
		 * Search all the processes and list the ones that have a specific handle open.
		 *
		 * \param HandleName The name of the handle to look for.
		 * \param dwTimeOut The maximum amounf of time (ms) that may be spent searching
		 * \param bPartialMatch Whether partial matches should be allowed.
		 * \param bIgnoreSelf Whether the current process should be listed.
		 * \param bQuiet Prints minimal output.
		 *
		 * \return a byte containing the cummulated access rights (f----xwr) from all the handles found
		 *         with bit 7 ('f') also set if at least one process was found.
		 */);
	}
	public static Object SearchProcess(Byte HandleName, Object dwTimeOut, Object bPartialMatch, Object bIgnoreSelf, Object bQuiet) {
		HANDLE handle = new HANDLE();
		DWORD res = 0;
		ModernizedCProgram._wHandleName = ModernizedCProgram.utf8_to_wchar(HandleName);
		ModernizedCProgram._bPartialMatch = bPartialMatch;
		ModernizedCProgram._bIgnoreSelf = bIgnoreSelf;
		ModernizedCProgram._bQuiet = bQuiet;
		ModernizedCProgram.access_mask = -1024;
		((ModernizedCProgram._wHandleName != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("_wHandleName != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\process.c", 671));
		handle = /*Error: Function owner not recognized*/CreateThread(((Object)0), 0, SearchProcessThread, ((Object)0), 0, ((Object)0));
		if (handle == ((Object)0)) {
			ModernizedCProgram._uprintf("Warning: Unable to create conflicting process search thread");
			;
		} 
		res = ModernizedCProgram.WaitForSingleObjectWithMessages(handle, dwTimeOut);
		if (res == -1024) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/TerminateThread(handle, 0);
			ModernizedCProgram._uprintf("Search for conflicting processes was interrupted due to timeout");
		}  else if (res != 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/TerminateThread(handle, 0);
			ModernizedCProgram._uprintf("Warning: Failed to wait for conflicting process search thread %s", ModernizedCProgram.WindowsErrorString());
		} 
		// Timeout - kill the thread
		return ModernizedCProgram.access_mask/**
		 * Alternative search for processes keeping a handle on a specific disk or volume
		 * Note that this search requires opening the disk or volume, which may not always
		 * be convenient for our usage (since we might be looking for processes preventing
		 * us to open said target in exclusive mode).
		 *
		 * \param HandleName The name of the handle to look for.
		 *
		 * \return TRUE if processes were found, FALSE otherwise.
		 */;
	}
	public static Object SearchProcessAlt(Byte HandleName) {
		NTSTATUS status = ((NTSTATUS)-1024);
		ULONG i = new ULONG();
		HANDLE searchHandle = ((Object)0);
		BOOLEAN bFound = 0;
		PFILE_PROCESS_IDS_USING_FILE_INFORMATION info = ((Object)0);
		status = ModernizedCProgram.PhCreateHeap();
		if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			;
		} 
		// Note that the access rights being used with CreateFile() might matter...// Note that the access rights being used with CreateFile() might matter...searchHandle = /*Error: Function owner not recognized*/CreateFileA(HandleName, -1024, -1024 | -1024, ((Object)0), 3, -1024, ((Object)0));
		status = ModernizedCProgram.PhQueryProcessesUsingVolumeOrFile(searchHandle, info);
		if (/*Error: Function owner not recognized*/NT_SUCCESS(status) && (info.getNumberOfProcessIdsInList() > 0)) {
			bFound = 1;
			ModernizedCProgram._uprintf("WARNING: The following process(es) or service(s) are accessing %s:", HandleName);
			for (i = 0; i < info.getNumberOfProcessIdsInList(); i++) {
				ModernizedCProgram._uprintf("o Process with PID %ld", info.getProcessIdList()[i]);
			}
		} 
		ModernizedCProgram.PhFree(info);
		ModernizedCProgram.PhDestroyHeap();
		if (!/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			ModernizedCProgram._uprintf("SearchProcessAlt('%s') failed: %s", HandleName, ModernizedCProgram.NtStatusError(status));
		} 
		return bFound/**
		 * Increase the privileges of the current application.
		 *
		 * \return TRUE if the request was successful.
		 */;
	}
	public static Object EnablePrivileges() {
		// List of the privileges we require. A list of requestable privileges can// be obtained at https://technet.microsoft.com/en-us/library/dn221963.aspxDWORD[] requestedPrivileges = new DWORD[]{(true)};
		NTSTATUS status = ((NTSTATUS)-1024);
		HANDLE tokenHandle = new HANDLE();
		do {
			if (ModernizedCProgram.pfNtClose == ((Object)0)) {
				ModernizedCProgram.pfNtClose = (NtClose_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtClose");
			} 
			if (ModernizedCProgram.pfNtClose == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "NtClose", "NtDll", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfNtOpenProcessToken == ((Object)0)) {
				ModernizedCProgram.pfNtOpenProcessToken = (NtOpenProcessToken_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtOpenProcessToken");
			} 
			if (ModernizedCProgram.pfNtOpenProcessToken == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "NtOpenProcessToken", "NtDll", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfNtAdjustPrivilegesToken == ((Object)0)) {
				ModernizedCProgram.pfNtAdjustPrivilegesToken = (NtAdjustPrivilegesToken_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("NtDll"), "NtAdjustPrivilegesToken");
			} 
			if (ModernizedCProgram.pfNtAdjustPrivilegesToken == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "NtAdjustPrivilegesToken", "NtDll", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		status = /*Error: Function owner not recognized*/pfNtOpenProcessToken(((HANDLE)(LONG_PTR)-1), (true), tokenHandle);
		if (/*Error: Function owner not recognized*/NT_SUCCESS(status)) {
			CHAR[] privilegesBuffer = new CHAR();
			PTOKEN_PRIVILEGES privileges = new PTOKEN_PRIVILEGES();
			ULONG i = new ULONG();
			privileges = (PTOKEN_PRIVILEGES)privilegesBuffer;
			privileges.setPrivilegeCount((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
			for (i = 0; i < privileges.getPrivilegeCount(); i++) {
				privileges.getPrivileges()[i].setAttributes(2);
				privileges.getPrivileges()[i].getLuid().setHighPart(0);
				privileges.getPrivileges()[0].getLuid().setLowPart(requestedPrivileges[i]);
			}
			status = /*Error: Function owner not recognized*/pfNtAdjustPrivilegesToken(tokenHandle, 0, privileges, 0, ((Object)0), ((Object)0));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfNtClose(tokenHandle);
		} 
		return /*Error: Function owner not recognized*/NT_SUCCESS(status);
	}
	/*
	 * alloc_tables.c --- Allocate tables for a newly initialized
	 * filesystem.  Used by mke2fs when initializing a filesystem
	 *
	 * Copyright (C) 1996 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/*
	 * This routine searches for free blocks that can allocate a full
	 * group of bitmaps or inode tables for a flexbg group.  Returns the
	 * block number with a correct offset were the bitmaps and inode
	 * tables can be allocated continuously and in order.
	 */
	public static Object flexbg_offset(Object fs, Object group, Object start_blk, Object bmap, int rem_grp, int elem_size) {
		int flexbg;
		int flexbg_size;
		int size;
		 last_blk = new ();
		 first_free = 0;
		 last_grp = new ();
		flexbg_size = 1 << fs.getSuper().getS_log_groups_per_flex();
		flexbg = group / flexbg_size;
		size = rem_grp * elem_size;
		if (size > (int)(fs.getSuper().getS_blocks_per_group() / 4)) {
			size = (int)fs.getSuper().getS_blocks_per_group() / 4/*
				 * Don't do a long search if the previous block search is still valid,
				 * but skip minor obstructions such as group descriptor backups.
				 */;
		} 
		if (start_blk && start_blk < fs.getSuper().ext2fs_blocks_count() && ModernizedCProgram.ext2fs_get_free_blocks2(fs, start_blk, start_blk + size, elem_size, bmap, first_free) == 0) {
			return first_free;
		} 
		start_blk = ModernizedCProgram.ext2fs_group_first_block2(fs, flexbg_size * flexbg);
		last_grp = group | (flexbg_size - 1);
		if (last_grp > fs.getGroup_desc_count() - 1) {
			last_grp = fs.getGroup_desc_count() - 1;
		} 
		last_blk = ModernizedCProgram.ext2fs_group_last_block2(fs, last_grp);
		if (ModernizedCProgram.ext2fs_get_free_blocks2(fs, start_blk, last_blk, /* Find the first available block */size, bmap, first_free) == 0) {
			return first_free;
		} 
		if (ModernizedCProgram.ext2fs_get_free_blocks2(fs, start_blk, last_blk, elem_size, bmap, first_free) == 0) {
			return first_free;
		} 
		if (ModernizedCProgram.ext2fs_get_free_blocks2(fs, 0, last_blk, elem_size, bmap, first_free) == 0) {
			return first_free;
		} 
		return first_free;
	}
	public static Object ext2fs_allocate_group_table(Object fs, Object group, Object bmap) {
		 retval = new ();
		 group_blk = new ();
		 start_blk = new ();
		 last_blk = new ();
		 new_blk = new ();
		 last_grp = 0;
		int rem_grps = 0;
		int flexbg_size = 0;
		int table_offset = 0;
		group_blk = ModernizedCProgram.ext2fs_group_first_block2(fs, group);
		last_blk = ModernizedCProgram.ext2fs_group_last_block2(fs, group);
		if (!bmap) {
			bmap = fs.getBlock_map();
		} 
		if (fs.getSuper().ext2fs_has_feature_flex_bg() && fs.getSuper().getS_log_groups_per_flex()) {
			flexbg_size = 1 << fs.getSuper().getS_log_groups_per_flex();
			last_grp = group | (flexbg_size - 1);
			if (last_grp > fs.getGroup_desc_count() - 1) {
				last_grp = fs.getGroup_desc_count() - 1;
			} 
			rem_grps = last_grp - group + 1;
		} 
		if (fs.getStride() && !/*
			 * Allocate the block and inode bitmaps, if necessary
			 */flexbg_size) {
			retval = ModernizedCProgram.ext2fs_get_free_blocks2(fs, group_blk, last_blk, 1, bmap, start_blk);
			if (retval) {
				return retval;
			} 
			start_blk += fs.getInode_blocks_per_group();
			start_blk += ((fs.getStride() * group) % (last_blk - start_blk + 1));
			if (start_blk >= last_blk) {
				start_blk = group_blk;
			} 
		} else {
				start_blk = group_blk;
		} 
		if (flexbg_size) {
			 prev_block = 0;
			table_offset = flexbg_size;
			if (group % flexbg_size) {
				prev_block = ModernizedCProgram.ext2fs_block_bitmap_loc(fs, group - 1) + 1;
			}  else if (last_grp == fs.getGroup_desc_count() - 1/*
						 * If we are allocating for the last flex_bg
						 * keep the metadata tables contiguous
						 */) {
				table_offset = last_grp & (flexbg_size - 1);
				if (table_offset == 0) {
					table_offset = flexbg_size;
				} else {
						table_offset++;
				} 
			} 
			start_blk = ModernizedCProgram.flexbg_offset(fs, group, prev_block, /* FIXME: Take backup group descriptor blocks into account
					 * if the flexbg allocations will grow to overlap them... */bmap, rem_grps, 1);
			last_blk = ModernizedCProgram.ext2fs_group_last_block2(fs, last_grp);
		} 
		if (!ModernizedCProgram.ext2fs_block_bitmap_loc(fs, group)) {
			retval = ModernizedCProgram.ext2fs_get_free_blocks2(fs, start_blk, last_blk, 1, bmap, new_blk);
			if (retval == EXT2_ET_BLOCK_ALLOC_FAIL) {
				retval = ModernizedCProgram.ext2fs_get_free_blocks2(fs, group_blk, last_blk, 1, bmap, new_blk);
			} 
			if (retval) {
				return retval;
			} 
			ModernizedCProgram.ext2fs_mark_block_bitmap2(bmap, new_blk);
			ModernizedCProgram.ext2fs_block_bitmap_loc_set(fs, group, new_blk);
			if (flexbg_size) {
				 gr = ModernizedCProgram.ext2fs_group_of_blk2(fs, new_blk);
				ModernizedCProgram.ext2fs_bg_free_blocks_count_set(fs, gr, ModernizedCProgram.ext2fs_bg_free_blocks_count(fs, gr) - 1);
				fs.getSuper().ext2fs_free_blocks_count_add(-1);
				ModernizedCProgram.ext2fs_bg_flags_clear(fs, gr, -1024);
				ModernizedCProgram.ext2fs_group_desc_csum_set(fs, gr);
			} 
		} 
		if (flexbg_size) {
			 prev_block = 0;
			if (group % flexbg_size) {
				prev_block = ModernizedCProgram.ext2fs_inode_bitmap_loc(fs, group - 1) + 1;
			} else {
					prev_block = ModernizedCProgram.ext2fs_block_bitmap_loc(fs, group) + table_offset/* FIXME: Take backup group descriptor blocks into account
							 * if the flexbg allocations will grow to overlap them... */;
			} 
			start_blk = ModernizedCProgram.flexbg_offset(fs, group, prev_block, bmap, rem_grps, 1);
			last_blk = ModernizedCProgram.ext2fs_group_last_block2(fs, last_grp);
		} 
		if (!ModernizedCProgram.ext2fs_inode_bitmap_loc(fs, group)) {
			retval = ModernizedCProgram.ext2fs_get_free_blocks2(fs, start_blk, last_blk, 1, bmap, new_blk);
			if (retval == EXT2_ET_BLOCK_ALLOC_FAIL) {
				retval = ModernizedCProgram.ext2fs_get_free_blocks2(fs, group_blk, last_blk, 1, bmap, new_blk);
			} 
			if (retval) {
				return retval;
			} 
			ModernizedCProgram.ext2fs_mark_block_bitmap2(bmap, new_blk);
			ModernizedCProgram.ext2fs_inode_bitmap_loc_set(fs, group, new_blk);
			if (flexbg_size) {
				 gr = ModernizedCProgram.ext2fs_group_of_blk2(fs, new_blk);
				ModernizedCProgram.ext2fs_bg_free_blocks_count_set(fs, gr, ModernizedCProgram.ext2fs_bg_free_blocks_count(fs, gr) - 1);
				fs.getSuper().ext2fs_free_blocks_count_add(-1);
				ModernizedCProgram.ext2fs_bg_flags_clear(fs, gr, -1024);
				ModernizedCProgram.ext2fs_group_desc_csum_set(fs, gr);
			} 
		} 
		if (/*
			 * Allocate the inode table
			 */flexbg_size) {
			 prev_block = 0;
			if (group % flexbg_size) {
				prev_block = ModernizedCProgram.ext2fs_inode_table_loc(fs, group - 1) + fs.getInode_blocks_per_group();
			} else {
					prev_block = ModernizedCProgram.ext2fs_inode_bitmap_loc(fs, group) + table_offset;
			} 
			group_blk = ModernizedCProgram.flexbg_offset(fs, group, prev_block, /* FIXME: Take backup group descriptor blocks into account
					 * if the flexbg allocations will grow to overlap them... */bmap, rem_grps, fs.getInode_blocks_per_group());
			last_blk = ModernizedCProgram.ext2fs_group_last_block2(fs, last_grp);
		} 
		if (!ModernizedCProgram.ext2fs_inode_table_loc(fs, group)) {
			retval = ModernizedCProgram.ext2fs_get_free_blocks2(fs, group_blk, last_blk, fs.getInode_blocks_per_group(), bmap, new_blk);
			if (retval) {
				return retval;
			} 
			ModernizedCProgram.ext2fs_mark_block_bitmap_range2(bmap, new_blk, fs.getInode_blocks_per_group());
			if (flexbg_size) {
				 num = new ();
				 blk = new ();
				num = fs.getInode_blocks_per_group();
				blk = new_blk;
				while (num) {
					int gr = ModernizedCProgram.ext2fs_group_of_blk2(fs, blk);
					last_blk = ModernizedCProgram.ext2fs_group_last_block2(fs, gr);
					 n = num;
					if (blk + num > last_blk) {
						n = last_blk - blk + 1;
					} 
					ModernizedCProgram.ext2fs_bg_free_blocks_count_set(fs, gr, ModernizedCProgram.ext2fs_bg_free_blocks_count(fs, gr) - n / (-1024 << (fs).getCluster_ratio_bits()));
					ModernizedCProgram.ext2fs_bg_flags_clear(fs, gr, -1024);
					ModernizedCProgram.ext2fs_group_desc_csum_set(fs, gr);
					fs.getSuper().ext2fs_free_blocks_count_add(-n);
					blk += n;
					num -= n;
				}
			} 
			ModernizedCProgram.ext2fs_inode_table_loc_set(fs, group, new_blk);
		} 
		ModernizedCProgram.ext2fs_group_desc_csum_set(fs, group);
		return 0;
	}
	public static Object ext2fs_allocate_tables(Object fs) {
		 retval = new ();
		 i = new ();
		ext2fs_numeric_progress_struct progress = new ext2fs_numeric_progress_struct();
		if (fs.getProgress_ops() && fs.getProgress_ops().getExt2fs_progress_ops()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, progress, ((Object)0), fs.getGroup_desc_count());
		} 
		for (i = 0; i < fs.getGroup_desc_count(); i++) {
			if (fs.getProgress_ops() && fs.getProgress_ops().getExt2fs_progress_ops()) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, progress, i);
			} 
			retval = ModernizedCProgram.ext2fs_allocate_group_table(fs, i, fs.getBlock_map());
			if (retval) {
				return retval;
			} 
		}
		if (fs.getProgress_ops() && fs.getProgress_ops().getExt2fs_progress_ops()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, progress, ((Object)0));
		} 
		return 0;
	}
	public static Object udf_stamp_to_time(Object dest, Long dest_usec, Object src) {
		int yday;
		 type = src.getType_tz() >> 12;
		 offset = new ();
		if (type == 1) {
			offset = src.getType_tz() << 4;
			offset = (offset >> /* sign extent offset */4);
			if (offset == -/* unspecified offset */2047) {
				offset = 0;
			} 
		} else {
				offset = 0;
		} 
		if ((src.getYear() < .EPOCH_YEAR) || (src.getYear() >= .EPOCH_YEAR + .MAX_YEAR_SECONDS)) {
			dest = -1;
			dest_usec = -1;
			return NULL;
		} 
		dest = ModernizedCProgram.year_seconds[src.getYear() - .EPOCH_YEAR];
		dest -= offset * .SECS_PER_MINUTE;
		yday = ((ModernizedCProgram.__mon_yday[((src.getYear()) % 4 == 0 && ((src.getYear()) % 100 != 0 || (src.getYear()) % 400 == 0))][src.getMonth() - 1]) + (src.getDay() - 1));
		dest += src.getSecond() + (.SECS_PER_MINUTE * (((yday * .HOURS_PER_DAY) + src.getHour()) * 60 + src.getMinute()));
		dest_usec = src.getMicroseconds() + (src.getCentiseconds() * 10000) + (src.getHundreds_of_microseconds() * 100);
		return dest/*!
		  Convert a UDF timestamp to a time_t. If microseconds are desired,
		  use dest_usec. The return value is the same as dest. */;
	}
	/* Adjust DAYS and Y to match the guessed year.  */
	/*!
	  Return the modification time of the file.
	 */
	public static Object udf_get_modification_time(Object p_udf_dirent) {
		if (p_udf_dirent) {
			 ret_time = new ();
			long usec;
			ModernizedCProgram.udf_stamp_to_time(ret_time, usec, p_udf_dirent.getFe().getModification_time());
			return ret_time;
		} 
		return 0/*!
		  Return the access time of the file.
		 */;
	}
	public static Object udf_get_access_time(Object p_udf_dirent) {
		if (p_udf_dirent) {
			 ret_time = new ();
			long usec;
			ModernizedCProgram.udf_stamp_to_time(ret_time, usec, p_udf_dirent.getFe().getAccess_time());
			return ret_time;
		} 
		return 0/*!
		  Return the attribute (most recent create or access) time of the file
		 */;
	}
	public static Object udf_get_attribute_time(Object p_udf_dirent) {
		if (p_udf_dirent) {
			 ret_time = new ();
			long usec;
			ModernizedCProgram.udf_stamp_to_time(ret_time, usec, p_udf_dirent.getFe().getAttribute_time());
			return ret_time;
		} 
		return 0;
	}
	public static int _stdio_open(Object user_data) {
		_UserData ud = user_data;
		Object generatedPathname = ud.getPathname();
		Object generatedFd = ud.getFd();
		Object generatedFd_buf = ud.getFd_buf();
		if ((ud.setFd(ModernizedCProgram.fopen_utf8(generatedPathname, "rb")))) {
			ud.setFd_buf(/*Error: Function owner not recognized*/calloc(1, (128 * 1024)));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/setvbuf(generatedFd, generatedFd_buf, _IOFBF, (128 * 1024));
		} 
		return (generatedFd == NULL);
	}
	public static int _stdio_close(Object user_data) {
		_UserData ud = user_data;
		Object generatedFd = ud.getFd();
		if (/*Error: Function owner not recognized*/fclose(generatedFd)) {
			ModernizedCProgram.cdio_error("fclose (): %s", /*Error: Function owner not recognized*/strerror(errno));
		} 
		ud.setFd(NULL);
		Object generatedFd_buf = ud.getFd_buf();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(generatedFd_buf);
		ud.setFd_buf(NULL);
		return 0;
	}
	public static void _stdio_free(Object user_data) {
		_UserData ud = user_data;
		Object generatedPathname = ud.getPathname();
		if (generatedPathname) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(generatedPathname);
		} 
		Object generatedFd = ud.getFd();
		if (generatedFd) {
			ModernizedCProgram._stdio_close(user_data);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(ud/*!
		  Like fseek/fseeko(3) and in fact may be the same.
		
		  This  function sets the file position indicator for the stream
		  pointed to by stream.  The new position, measured in bytes, is obtained
		  by  adding offset bytes to the position specified by whence.  If whence
		  is set to SEEK_SET, SEEK_CUR, or SEEK_END, the offset  is  relative  to
		  the  start of the file, the current position indicator, or end-of-file,
		  respectively.  A successful call to the fseek function clears the end-
		  of-file indicator for the stream and undoes any effects of the
		  ungetc(3) function on the same stream.
		
		  @return upon successful completion, DRIVER_OP_SUCCESS, else,
		  DRIVER_OP_ERROR is returned and the global variable errno is set to
		  indicate the error.
		*/);
	}
	public static int _stdio_seek(Object p_user_data, Object i_offset, int whence) {
		_UserData ud = p_user_data;
		int ret;
		if ((/*Error: Unsupported expression*/ > /*Error: Unsupported expression*/) && (i_offset != /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME((long)/* Detect if off_t is lossy-truncated to long to avoid data corruption */i_offset))) {
			ModernizedCProgram.cdio_error("fseek (): lossy truncation detected!");
			errno = EFBIG;
			return DRIVER_OP_ERROR;
		} 
		Object generatedFd = ud.getFd();
		if ((ret = /*Error: Function owner not recognized*/fseek(generatedFd, i_offset, whence))) {
			ModernizedCProgram.cdio_error("fseek (): %s", /*Error: Function owner not recognized*/strerror(errno));
		} 
		return ret;
	}
	public static Object _stdio_stat(Object p_user_data) {
		_UserData ud = p_user_data;
		return ud.getSt_size();
	}
	public static Object _stdio_read(Object user_data, Object buf, Object count) {
		_UserData ud = user_data;
		long read_count;
		Object generatedFd = ud.getFd();
		read_count = /*Error: Function owner not recognized*/fread(buf, 1, count, generatedFd);
		if (read_count != count) {
			if (/*Error: Function owner not recognized*/feof(generatedFd)) {
				ModernizedCProgram.cdio_debug("fread (): EOF encountered");
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/clearerr(generatedFd);
			}  else if (/*Error: Function owner not recognized*/ferror(generatedFd)) {
				ModernizedCProgram.cdio_error("fread (): %s", /*Error: Function owner not recognized*/strerror(errno));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/clearerr(generatedFd);
			} else {
					ModernizedCProgram.cdio_debug("fread (): short read and no EOF?!?");
			} 
		} 
		return read_count/*!
		  Deallocate resources assocaited with obj. After this obj is unusable.
		*/;
	}
	/*
	 * freefs.c --- free an ext2 filesystem
	 *
	 * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static void ext2fs_free(Object fs) {
		if (!fs || (fs.getMagic() != EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return /*Error: Unsupported expression*/;
		} 
		if (fs.getImage_io() != fs.getIo()) {
			if (fs.getImage_io()) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/io_channel_close(fs.getImage_io());
			} 
		} 
		if (fs.getIo()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/io_channel_close(fs.getIo());
		} 
		if (fs.getDevice_name()) {
			ModernizedCProgram.ext2fs_free_mem(fs.getDevice_name());
		} 
		if (fs.getSuper()) {
			ModernizedCProgram.ext2fs_free_mem(fs.getSuper());
		} 
		if (fs.getOrig_super()) {
			ModernizedCProgram.ext2fs_free_mem(fs.getOrig_super());
		} 
		if (fs.getGroup_desc()) {
			ModernizedCProgram.ext2fs_free_mem(fs.getGroup_desc());
		} 
		if (fs.getBlock_map()) {
			ModernizedCProgram.ext2fs_free_block_bitmap(fs.getBlock_map());
		} 
		if (fs.getInode_map()) {
			ModernizedCProgram.ext2fs_free_inode_bitmap(fs.getInode_map());
		} 
		if (fs.getImage_header()) {
			ModernizedCProgram.ext2fs_free_mem(fs.getImage_header());
		} 
		if (fs.getBadblocks()) {
			ModernizedCProgram.ext2fs_badblocks_list_free(fs.getBadblocks());
		} 
		fs.setBadblocks(0);
		if (fs.getDblist()) {
			ModernizedCProgram.ext2fs_free_dblist(fs.getDblist());
		} 
		if (fs.getIcache()) {
			fs.getIcache().ext2fs_free_inode_cache();
		} 
		if (fs.getMmp_buf()) {
			ModernizedCProgram.ext2fs_free_mem(fs.getMmp_buf());
		} 
		if (fs.getMmp_cmp()) {
			ModernizedCProgram.ext2fs_free_mem(fs.getMmp_cmp());
		} 
		if (fs.getBlock_sha_map()) {
			fs.getBlock_sha_map().ext2fs_hashmap_free();
		} 
		fs.setMagic(0);
		// coverity[check_return]// coverity[check_return]ModernizedCProgram.ext2fs_zero_blocks2(((Object)0), 0, 0, ((Object)0), ((Object)0));
		ModernizedCProgram.ext2fs_free_mem(fs/*
		 * This procedure frees a badblocks list.
		 */);
	}
	public static void ext2fs_u32_list_free(Object bb) {
		if (bb.getMagic() != EXT2_ET_MAGIC_BADBLOCKS_LIST) {
			return /*Error: Unsupported expression*/;
		} 
		if (bb.getList()) {
			ModernizedCProgram.ext2fs_free_mem(bb.getList());
		} 
		bb.setList(0);
		ModernizedCProgram.ext2fs_free_mem(bb);
	}
	public static void ext2fs_badblocks_list_free(Object bb) {
		ModernizedCProgram.ext2fs_u32_list_free((ext2_u32_list)bb);
	}
	/*
	 * Free a directory block list
	 */
	public static void ext2fs_free_dblist(Object dblist) {
		if (!dblist || (dblist.getMagic() != EXT2_ET_MAGIC_DBLIST)) {
			return /*Error: Unsupported expression*/;
		} 
		if (dblist.getList()) {
			ModernizedCProgram.ext2fs_free_mem(dblist.getList());
		} 
		dblist.setList(0);
		if (dblist.getFs() && dblist.getFs().getDblist() == dblist) {
			dblist.getFs().setDblist(0);
		} 
		dblist.setMagic(0);
		ModernizedCProgram.ext2fs_free_mem(dblist);
	}
	public static Object WinInetErrorString() {
		byte[] error_string = new byte[256];
		DWORD size = /*Error: sizeof expression not supported yet*/;
		BOOL InternetGetLastResponseInfoA_t = new BOOL();
		InternetGetLastResponseInfoA_t pfInternetGetLastResponseInfoA = ((Object)0);
		if (pfInternetGetLastResponseInfoA == ((Object)0)) {
			pfInternetGetLastResponseInfoA = (InternetGetLastResponseInfoA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetGetLastResponseInfoA");
		} 
		ModernizedCProgram.error_code = ((/*Error: Function owner not recognized*/GetLastError()) & -1024);
		if ((ModernizedCProgram.error_code < 12000) || (ModernizedCProgram.error_code > (12000 + 159))) {
			return ModernizedCProgram.WindowsErrorString();
		} 
		switch (ModernizedCProgram.error_code) {
		case (12000 + 130):
		case (12000 + 30):
				return "The connection with the server has been terminated.";
		case (12000 + 131):
		case ERROR_INTERNET_NEED_MSN_SSPI_PKG:
				return "This connection requires an MSN Security Support Provider Interface package.";
		case (12000 + 27):
				return "The format of the request is invalid.";
		case (12000 + 151):
				return "The server did not return any headers.";
		case ERROR_INTERNET_PROXY_SERVER_UNREACHABLE:
				return "Proxy server could not be reached.";
		case (12000 + 33):
				return "The request to the proxy was invalid.";
		case (12000 + 43):
				return "The application is posting data to a server that is not secure.";
		case (12000 + 6):
				return "The URL scheme could not be recognized or is not supported.";
		case (12000 + 29):
				return "The attempt to connect to the server failed.";
		case (12000 + 31):
				return "The connection with the server has been reset.";
		case (12000 + 37):
				return "SSL certificate date that was received from the server is bad. The certificate is expired.";
		case ERROR_INTERNET_DISCONNECTED:
				return "Internet is disconnected.";
		case (12000 + 44):
				return "Client Authentication certificate needed";
		case (12000 + 3):
				if (pfInternetGetLastResponseInfoA != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetGetLastResponseInfoA(ModernizedCProgram.error_code, error_string, size);
					return error_string;
				} 
		case (12000 + 25):
				return "An asynchronous request could not be made because a callback function has not been set.";
		case ERROR_INTERNET_SEC_CERT_REV_FAILED:
				return "The revocation check of the SSL certificate failed.";
		case (12000 + 111):
				return "The FTP operation was not completed because the session was aborted.";
		case (12000 + 135):
		case (12000 + 20):
				return "The request cannot be made via a proxy.";
		case (12000 + 28):
				return "The requested item could not be located.";
		case (12000 + 24):
				return "An asynchronous request could not be made because a zero context value was supplied.";
		case (12000 + 159):
				return "TPC/IP not installed.";
		case (12000 + 14):
				return "The request to connect and log on to an FTP server could not be completed because the supplied password is incorrect.";
		case ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT:
				return "Unable to download script.";
		case (12000 + 153):
				return "The supplied header is invalid.";
		case (12000 + 41):
				return "Some of the content being viewed may have come from unsecured servers.";
		case (12000 + 2):
				return "The request has timed out.";
		case (12000 + 4):
				return "An internal error has occurred.";
		case (12000 + 136):
		case (12000 + 155):
				return "The header could not be added because it already exists.";
		case (12000 + 42):
				return "The application is posting and attempting to change multiple lines of text on a server that is not secure.";
		case (12000 + 15):
				return "The request to connect to and log on to an FTP server failed.";
		case (12000 + 8):
				return "The requested protocol could not be located.";
		case (12000 + 150):
				return "The requested header could not be located.";
		case (12000 + 133):
		case (12000 + 152):
				return "The server response could not be parsed.";
		case (12000 + 18):
				return "The type of handle supplied is incorrect for this operation.";
		case (12000 + 156):
				return "The redirection failed because either the scheme changed or all attempts made to redirect failed.";
		case ERROR_INTERNET_SEC_CERT_NO_REV:
				return "The SSL certificate was not revoked.";
		case (12000 + 134):
		case (12000 + 12):
				return "The Win32 Internet function support is being shut down or unloaded.";
		case (12000 + 137):
		case (12000 + 11):
				return "The request option cannot be set, only queried.";
		case (12000 + 132):
		case (12000 + 13):
				return "The request to connect and log on to an FTP server could not be completed because the supplied user name is incorrect.";
		case ERROR_INTERNET_FAILED_DUETOSECURITYCHECK:
				return "A security check prevented internet connection.";
		case (12000 + 154):
				return "The request made to HttpQueryInfo is invalid.";
		case (12000 + 19):
				return "The requested operation cannot be carried out because the handle supplied is not in the correct state.";
		case (12000 + 36):
				return "The request failed because the handle already exists.";
		case (12000 + 38):
				return "SSL certificate common name (host name field) is incorrect.";
		case ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT:
				return "Bad auto proxy script.";
		case (12000 + 39):
				return "The application is moving from a non-SSL to an SSL connection because of a redirect.";
		case (12000 + 21):
				return "A required registry value could not be located.";
		case ERROR_INTERNET_SEC_INVALID_CERT:
				return "The SSL certificate is invalid.";
		case ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY:
				return "Please ask Microsoft about that one!";
		case (12000 + 5):
				return "The URL is invalid.";
		case (12000 + 32):
				return "Calls for the Win32 Internet function to redo the request.";
		case (12000 + 10):
				return "The length of an option supplied is incorrect for the type of option specified.";
		case (12000 + 17):
				return "The operation was cancelled, usually because the handle on which the request was operating was closed before the operation completed.";
		case ERROR_INTERNET_SEC_CERT_ERRORS:
				return "The SSL certificate contains errors.";
		case (12000 + 157):
				return "This system's SSL library is too old to be able to access this website.";
		case (12000 + 16):
				return "The requested operation is invalid.";
		case (12000 + 1):
				return "No more handles could be generated at this time.";
		case (12000 + 9):
				return "A request specified an invalid option value.";
		case (12000 + 40):
				return "The application is moving from an SSL to an non-SSL connection because of a redirect.";
		case (12000 + 110):
				return "The requested operation cannot be made on the FTP session handle because an operation is already in progress.";
		case ERROR_INTERNET_NOT_INITIALIZED:
				return "Internet has not be initialized.";
		case (12000 + 7):
				return "The server name could not be resolved.";
		case (12000 + 23):
				return "Direct network access cannot be made at this time.";
		case (12000 + 158):
				return "Unable to cache the file.";
		case ERROR_INTERNET_SERVER_UNREACHABLE:
				return "Server could not be reached.";
		case (12000 + 26):
				return "The required operation could not be completed because one or more requests are pending.";
		case (12000 + 138):
				return "Gopher? Really??? What is this, 1994?";
		case (12000 + 22):
				return "A required registry value was located but is an incorrect type or has an invalid value.";
		default:
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(error_string, /*Error: sizeof expression not supported yet*/, "Unknown internet error 0x%08lX", ModernizedCProgram.error_code);
					(error_string)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				return error_string;
		}
	}
	public static Byte GetShortName(Object[] url) {
		byte[] short_name = new byte[128];
		byte p;
		size_t i = new size_t();
		size_t len = ((((byte)url) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(url));
		if (len < 5) {
			return ((Object)0);
		} 
		for (i = len - 2; i > 0; i--) {
			if (url[i] == (byte)'/') {
				i++;
				break;
			} 
		}
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(short_name, url[i], (((size_t)(((((byte)url[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(url[i])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)url[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(url[i])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)short_name)[(((size_t)(((((byte)url[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(url[i])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)url[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(url[i])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);// If the URL is followed by a query, remove that part
		// Make sure we detect escaped queries too// Make sure we detect escaped queries toop = /*Error: Function owner not recognized*/strstr(short_name, "%3F");
		if (p != ((Object)0)) {
			p = 0;
		} 
		p = /*Error: Function owner not recognized*/strstr(short_name, "%3f");
		if (p != ((Object)0)) {
			p = 0;
		} 
		for (i = 0; i < /*Error: Function owner not recognized*/strlen(short_name); i++) {
			if ((short_name[i] == (byte)'?') || (short_name[i] == (byte)'#')) {
				short_name[i] = 0;
				break;
			} 
		}
		return short_name;
	}
	// Open an Internet session
	public static Object GetInternetSession(Object bRetry) {
		int i;
		byte[] agent = new byte[64];
		BOOL r = new BOOL();
		DWORD dwFlags = new DWORD();
		DWORD dwTimeout = 3500;
		HINTERNET hSession = ((Object)0);
		BOOL InternetGetConnectedState_t = new BOOL();
		InternetGetConnectedState_t pfInternetGetConnectedState = ((Object)0);
		HINTERNET InternetOpenA_t = new HINTERNET();
		InternetOpenA_t pfInternetOpenA = ((Object)0);
		BOOL InternetSetOptionA_t = new BOOL();
		InternetSetOptionA_t pfInternetSetOptionA = ((Object)0);
		do {
			if (pfInternetGetConnectedState == ((Object)0)) {
				pfInternetGetConnectedState = (InternetGetConnectedState_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetGetConnectedState");
			} 
			if (pfInternetGetConnectedState == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetGetConnectedState", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfInternetOpenA == ((Object)0)) {
				pfInternetOpenA = (InternetOpenA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetOpenA");
			} 
			if (pfInternetOpenA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetOpenA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfInternetSetOptionA == ((Object)0)) {
				pfInternetSetOptionA = (InternetSetOptionA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetSetOptionA");
			} 
			if (pfInternetSetOptionA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetSetOptionA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		for (i = 0; i <= 4; i++) {
			r = /*Error: Function owner not recognized*/pfInternetGetConnectedState(dwFlags, 0);
			if (r || !bRetry) {
				break;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(1000);
		}
		if (!r) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(ERROR_INTERNET_NOT_INITIALIZED);
			ModernizedCProgram._uprintf("Network is unavailable: %s", ModernizedCProgram.WinInetErrorString());
			;
		} 
		// http://msdn.microsoft.com/en-us/library/windows/desktop/aa384702.aspx is wrong...
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(agent, /*Error: sizeof expression not supported yet*/, "Rufus/%d.%d.%d (Windows NT %d.%d%s)", ModernizedCProgram.rufus_version[0], ModernizedCProgram.rufus_version[1], ModernizedCProgram.rufus_version[2], ModernizedCProgram.nWindowsVersion >> 4, ModernizedCProgram.nWindowsVersion & -1024, ModernizedCProgram.is_x64() ? "; WOW64" : "");
			(agent)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		hSession = /*Error: Function owner not recognized*/pfInternetOpenA(agent, 0, ((Object)0), ((Object)0), 0)// Set the timeouts;// Set the timeouts
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetSetOptionA(hSession, 2, (LPVOID)dwTimeout, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetSetOptionA(hSession, 5, (LPVOID)dwTimeout, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetSetOptionA(hSession, 6, (LPVOID)dwTimeout, /*Error: sizeof expression not supported yet*/);
	}
	public static Object DownloadToFileOrBuffer(Object url, Object file, Object buffer, Object hProgressDialog, Object bTaskBarProgress) {
		byte[] accept_types = new byte[]{"*/*\0", ((Object)0)};
		byte short_name;
		byte[] buf = new byte[10 * -1024];
		byte[] hostname = new byte[64];
		byte[] urlpath = new byte[128];
		byte[] strsize = new byte[32];
		BOOL r = 0;
		DWORD dwSize = new DWORD();
		DWORD dwWritten = new DWORD();
		DWORD dwDownloaded = new DWORD();
		HANDLE hFile = (HANDLE)(true);
		HINTERNET hSession = ((Object)0);
		HINTERNET hConnection = ((Object)0);
		HINTERNET hRequest = ((Object)0);
		URL_COMPONENTSA UrlParts = new URL_COMPONENTSA(/*Error: Unsupported expression*/, ((Object)0), 1, (INTERNET_SCHEME)0, hostname, /*Error: sizeof expression not supported yet*/, 0, ((Object)0), 1, urlpath, /*Error: sizeof expression not supported yet*/, ((Object)0), 1);
		uint64_t size = 0;
		uint64_t total_size = 0;
		// Can't link with wininet.lib because of sideloading issuesBOOL InternetCrackUrlA_t = new BOOL();
		InternetCrackUrlA_t pfInternetCrackUrlA = ((Object)0);
		HINTERNET InternetConnectA_t = new HINTERNET();
		InternetConnectA_t pfInternetConnectA = ((Object)0);
		BOOL InternetReadFile_t = new BOOL();
		InternetReadFile_t pfInternetReadFile = ((Object)0);
		BOOL InternetCloseHandle_t = new BOOL();
		InternetCloseHandle_t pfInternetCloseHandle = ((Object)0);
		HINTERNET HttpOpenRequestA_t = new HINTERNET();
		HttpOpenRequestA_t pfHttpOpenRequestA = ((Object)0);
		BOOL HttpSendRequestA_t = new BOOL();
		HttpSendRequestA_t pfHttpSendRequestA = ((Object)0);
		BOOL HttpQueryInfoA_t = new BOOL();
		HttpQueryInfoA_t pfHttpQueryInfoA = ((Object)0);
		do {
			if (pfInternetCrackUrlA == ((Object)0)) {
				pfInternetCrackUrlA = (InternetCrackUrlA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetCrackUrlA");
			} 
			if (pfInternetCrackUrlA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetCrackUrlA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfInternetConnectA == ((Object)0)) {
				pfInternetConnectA = (InternetConnectA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetConnectA");
			} 
			if (pfInternetConnectA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetConnectA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfInternetReadFile == ((Object)0)) {
				pfInternetReadFile = (InternetReadFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetReadFile");
			} 
			if (pfInternetReadFile == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetReadFile", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfInternetCloseHandle == ((Object)0)) {
				pfInternetCloseHandle = (InternetCloseHandle_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetCloseHandle");
			} 
			if (pfInternetCloseHandle == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetCloseHandle", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfHttpOpenRequestA == ((Object)0)) {
				pfHttpOpenRequestA = (HttpOpenRequestA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "HttpOpenRequestA");
			} 
			if (pfHttpOpenRequestA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "HttpOpenRequestA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfHttpSendRequestA == ((Object)0)) {
				pfHttpSendRequestA = (HttpSendRequestA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "HttpSendRequestA");
			} 
			if (pfHttpSendRequestA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "HttpSendRequestA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfHttpQueryInfoA == ((Object)0)) {
				pfHttpQueryInfoA = (HttpQueryInfoA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "HttpQueryInfoA");
			} 
			if (pfHttpQueryInfoA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "HttpQueryInfoA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		ModernizedCProgram.FormatStatus = 0;
		ModernizedCProgram.DownloadStatus = 404;
		if (hProgressDialog != ((Object)0)) {
			ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_INIT, (int)0, (uint64_t)(uintptr_t)hProgressDialog, 0);
		} 
		;
		((url != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("url != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\net.c", 347));
		if (buffer != ((Object)0)) {
			buffer = ((Object)0);
		} 
		short_name = (file != ((Object)0)) ? ModernizedCProgram.PathFindFileNameU(file) : ModernizedCProgram.PathFindFileNameU(url);
		if (hProgressDialog != ((Object)0)) {
			ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3085, short_name);
			ModernizedCProgram._uprintf("Downloading %s", url);
		} 
		Object generatedLpszHostName = UrlParts.getLpszHostName();
		Object generatedLpszUrlPath = UrlParts.getLpszUrlPath();
		if ((!/*Error: Function owner not recognized*/pfInternetCrackUrlA(url, (DWORD)((((byte)url) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(url)), 0, UrlParts)) || (generatedLpszHostName == ((Object)0)) || (generatedLpszUrlPath == ((Object)0))) {
			ModernizedCProgram._uprintf("Unable to decode URL: %s", ModernizedCProgram.WinInetErrorString());
			;
		} 
		hostname[/*Error: sizeof expression not supported yet*/ - 1] = 0;
		hSession = ModernizedCProgram.GetInternetSession(1);
		if (hSession == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not open Internet session: %s", ModernizedCProgram.WinInetErrorString());
			;
		} 
		Object generatedNPort = UrlParts.getNPort();
		hConnection = /*Error: Function owner not recognized*/pfInternetConnectA(hSession, generatedLpszHostName, generatedNPort, ((Object)0), ((Object)0), 3, 0, (DWORD_PTR)((Object)0));
		if (hConnection == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not connect to server %s:%d: %s", generatedLpszHostName, generatedNPort, ModernizedCProgram.WinInetErrorString());
			;
		} 
		Object generatedNScheme = UrlParts.getNScheme();
		hRequest = /*Error: Function owner not recognized*/pfHttpOpenRequestA(hConnection, "GET", generatedLpszUrlPath, ((Object)0), ((Object)0), accept_types, -1024 | -1024 | -1024 | -1024 | -1024 | -1024 | ((generatedNScheme == .INTERNET_SCHEME_HTTPS) ? -1024 : 0), (DWORD_PTR)((Object)0));
		if (hRequest == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not open URL %s: %s", url, ModernizedCProgram.WinInetErrorString());
			;
		} 
		if (!/*Error: Function owner not recognized*/pfHttpSendRequestA(hRequest, ((Object)0), 0, ((Object)0), 0)) {
			ModernizedCProgram._uprintf("Unable to send request: %s", ModernizedCProgram.WinInetErrorString());
			;
		} 
		// Get the file size// Get the file sizedwSize = /*Error: sizeof expression not supported yet*/;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfHttpQueryInfoA(hRequest, 19 | -1024, (LPVOID)ModernizedCProgram.DownloadStatus, dwSize, ((Object)0));
		if (ModernizedCProgram.DownloadStatus != 200) {
			ModernizedCProgram.error_code = (12000 + 28);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(-1024 | (FACILITY_HTTP << 16) | ModernizedCProgram.error_code);
			ModernizedCProgram._uprintf("Unable to access file: %d", ModernizedCProgram.DownloadStatus);
			;
		} 
		dwSize = /*Error: sizeof expression not supported yet*/;
		if (!/*Error: Function owner not recognized*/pfHttpQueryInfoA(hRequest, 5, (LPVOID)strsize, dwSize, ((Object)0))) {
			ModernizedCProgram._uprintf("Unable to retrieve file length: %s", ModernizedCProgram.WinInetErrorString());
			;
		} 
		total_size = (uint64_t)/*Error: Function owner not recognized*/atoll(strsize);
		if (hProgressDialog != ((Object)0)) {
			byte[] msg = new byte[128];
			ModernizedCProgram._uprintf("File length: %s", ModernizedCProgram.SizeToHumanReadable(total_size, 0, 0));
			if (ModernizedCProgram.right_to_left_mode) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(msg, /*Error: sizeof expression not supported yet*/, "(%s) %s", ModernizedCProgram.SizeToHumanReadable(total_size, 0, 0), ModernizedCProgram.GetShortName(url));
					(msg)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
			} else {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(msg, /*Error: sizeof expression not supported yet*/, "%s (%s)", ModernizedCProgram.GetShortName(url), ModernizedCProgram.SizeToHumanReadable(total_size, 0, 0));
						(msg)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
			} 
			ModernizedCProgram.PrintStatusInfo(0, 0, 0, 3085, msg);
		} 
		if (file != ((Object)0)) {
			hFile = ModernizedCProgram.CreateFileU(file, -1024 | -1024, -1024, ((Object)0), 2, -1024, ((Object)0));
			if (hFile == (HANDLE)(true)) {
				ModernizedCProgram._uprintf("Unable to create file '%s': %s", short_name, ModernizedCProgram.WinInetErrorString());
				;
			} 
		} else {
				if (buffer == ((Object)0)) {
					ModernizedCProgram._uprintf("No buffer pointer provided for download");
					;
				} 
				buffer = /*Error: Function owner not recognized*/calloc((size_t)total_size + 1, 1);
				if (buffer == ((Object)0)) {
					ModernizedCProgram._uprintf("Could not allocate buffer for download");
					;
				} 
		} 
		// Keep checking for data until there is nothing left.while (1) {
			if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
				;
			} 
			if (!/*Error: Function owner not recognized*/pfInternetReadFile(hRequest, buf, /*Error: sizeof expression not supported yet*/, dwDownloaded) || (dwDownloaded == 0)) {
				break;
			} 
			if (hProgressDialog != ((Object)0)) {
				ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_NOOP, 3241, size, total_size);
			} 
			if (file != ((Object)0)) {
				if (!/*Error: Function owner not recognized*/WriteFile(hFile, buf, dwDownloaded, dwWritten, ((Object)0))) {
					ModernizedCProgram._uprintf("Error writing file '%s': %s", short_name, ModernizedCProgram.WinInetErrorString());
					;
				}  else if (dwDownloaded != dwWritten) {
					ModernizedCProgram._uprintf("Error writing file '%s': Only %d/%d bytes written", short_name, dwWritten, dwDownloaded);
					;
				} 
			} else {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((buffer)[size], buf, dwDownloaded);
			} 
			size += dwDownloaded;
		}// User may have cancelled the download
		if (size != total_size) {
			ModernizedCProgram._uprintf("Could not download complete file - read: %lld bytes, expected: %lld bytes", size, total_size);
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} else {
				ModernizedCProgram.DownloadStatus = 200;
				r = 1;
				if (hProgressDialog != ((Object)0)) {
					ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_NOOP, 3241, total_size, total_size);
					ModernizedCProgram._uprintf("Successfully downloaded '%s'", short_name);
				} 
		} 
		if (hFile != (HANDLE)(true)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/FlushFileBuffers(hFile);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hFile);
		} 
		// Force a flush - May help with the PKI API trying to process downloaded updates too early...
		if (!r) {
			if (file != ((Object)0)) {
				ModernizedCProgram.DeleteFileU(file);
			} 
			if (buffer != ((Object)0)) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)buffer);
					buffer = ((Object)0);
				} while (0);
			} 
		} 
		if (hRequest) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetCloseHandle(hRequest);
		} 
		if (hConnection) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetCloseHandle(hConnection);
		} 
		if (hSession) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetCloseHandle(hSession);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(ModernizedCProgram.error_code);
		return r ? size : 0;
	}
	// Download and validate a signed file. The file must have a corresponding '.sig' on the server.
	public static Object DownloadSignedFile(Object url, Object file, Object hProgressDialog, Object bPromptOnError) {
		byte url_sig = ((Object)0);
		BYTE buf = ((Object)0);
		BYTE sig = ((Object)0);
		DWORD buf_len = 0;
		DWORD sig_len = 0;
		DWORD ret = 0;
		HANDLE hFile = (HANDLE)(true);
		((url != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("url != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\net.c", 504));
		url_sig = /*Error: Function owner not recognized*/malloc(/*Error: Function owner not recognized*/strlen(url) + 5);
		if (url_sig == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not allocate signature URL");
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(url_sig, url);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcat(url_sig, ".sig");
		buf_len = (DWORD)ModernizedCProgram.DownloadToFileOrBuffer(url, ((Object)0), buf, hProgressDialog, 0);
		if (buf_len == 0) {
			;
		} 
		sig_len = (DWORD)ModernizedCProgram.DownloadToFileOrBuffer(url_sig, ((Object)0), sig, ((Object)0), 0);
		if ((sig_len != 256) || (!ModernizedCProgram.ValidateOpensslSignature(buf, buf_len, sig, sig_len))) {
			ModernizedCProgram._uprintf("FATAL: Download signature is invalid â");
			ModernizedCProgram.DownloadStatus = 403;
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hProgressDialog, 1010), PBM_SETSTATE, (WPARAM)PBST_ERROR, 0);
			ModernizedCProgram.SetTaskbarProgressState(TASKBAR_PROGRESS_FLAGS.TASKBAR_ERROR);
			;
		} 
		ModernizedCProgram._uprintf("Download signature is valid â");
		// Partial content// Partial contentModernizedCProgram.DownloadStatus = 206;
		hFile = ModernizedCProgram.CreateFileU(file, -1024 | -1024, -1024, ((Object)0), 2, -1024, ((Object)0));
		if (hFile == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Unable to create file '%s': %s", ModernizedCProgram.PathFindFileNameU(file), ModernizedCProgram.WinInetErrorString());
			;
		} 
		if (!/*Error: Function owner not recognized*/WriteFile(hFile, buf, buf_len, ret, ((Object)0))) {
			ModernizedCProgram._uprintf("Error writing file '%s': %s", ModernizedCProgram.PathFindFileNameU(file), ModernizedCProgram.WinInetErrorString());
			ret = 0;
			;
		}  else if (ret != buf_len) {
			ModernizedCProgram._uprintf("Error writing file '%s': Only %d/%d bytes written", ModernizedCProgram.PathFindFileNameU(file), ret, buf_len);
			ret = 0;
			;
		} 
		// Full content// Full contentModernizedCProgram.DownloadStatus = 200;
		if ((bPromptOnError) && (ModernizedCProgram.DownloadStatus != 200)) {
			ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3242);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(ModernizedCProgram.error_code);
			ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) ? ModernizedCProgram.StrError(ModernizedCProgram.FormatStatus, 0) : ModernizedCProgram.WinInetErrorString(), ModernizedCProgram.lmprintf(3044), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
		} 
		do {
			if ((hFile != (HANDLE)(true)) && (hFile != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hFile);
				hFile = (HANDLE)(true);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(url_sig);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buf);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(sig);
		return ret;
	}
	public static Object DownloadSignedFileThread(Object param) {
		DownloadSignedFileThreadArgs args = (DownloadSignedFileThreadArgs)param;
		Object generatedUrl = args.getUrl();
		Object generatedFile = args.getFile();
		Object generatedHProgressDialog = args.getHProgressDialog();
		Object generatedBPromptOnError = args.getBPromptOnError();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExitThread(ModernizedCProgram.DownloadSignedFile(generatedUrl, generatedFile, generatedHProgressDialog, generatedBPromptOnError));
	}
	public static Object DownloadSignedFileThreaded(Object url, Object file, Object hProgressDialog, Object bPromptOnError) {
		DownloadSignedFileThreadArgs args = new DownloadSignedFileThreadArgs();
		args.setUrl(url);
		args.setFile(file);
		args.setHProgressDialog(hProgressDialog);
		args.setBPromptOnError(bPromptOnError);
		return /*Error: Function owner not recognized*/CreateThread(((Object)0), 0, DownloadSignedFileThread, args, 0, ((Object)0));
	}
	public static Object to_uint64_t(Object[] x) {
		int i;
		uint64_t ret = 0;
		for (i = 0; i < 3; i++) {
			ret = (ret << 16) + x[i];
		}
		return ret/*
		 * Background thread to check for updates
		 */;
	}
	public static Object CheckForUpdatesThread(Object param) {
		BOOL releases_only = 1;
		BOOL found_new_version = 0;
		int status = 0;
		byte server_url = "https://rufus.ie/";
		int i;
		int j;
		int k;
		int max_channel;
		int verbose = 0;
		int[] verpos = new int[4];
		byte[] archname = new byte[]{"win_x86", "win_x64", "win_arm", "win_arm64", "win_none"};
		// release channelbyte[] channel = new byte[]{"release", "beta", "test"};
		byte[] accept_types = new byte[]{"*/*\0", ((Object)0)};
		byte buf = ((Object)0);
		byte[] agent = new byte[64];
		byte[] hostname = new byte[64];
		byte[] urlpath = new byte[128];
		byte[] sigpath = new byte[256];
		DWORD dwSize = new DWORD();
		DWORD dwDownloaded = new DWORD();
		DWORD dwTotalSize = new DWORD();
		DWORD dwStatus = new DWORD();
		BYTE sig = ((Object)0);
		OSVERSIONINFOA os_version = new OSVERSIONINFOA(/*Error: Unsupported expression*/, 0, 0, 0, 0, "");
		HINTERNET hSession = ((Object)0);
		HINTERNET hConnection = ((Object)0);
		HINTERNET hRequest = ((Object)0);
		URL_COMPONENTSA UrlParts = new URL_COMPONENTSA(/*Error: Unsupported expression*/, ((Object)0), 1, (INTERNET_SCHEME)0, hostname, /*Error: sizeof expression not supported yet*/, 0, ((Object)0), 1, urlpath, /*Error: sizeof expression not supported yet*/, ((Object)0), 1);
		SYSTEMTIME ServerTime = new SYSTEMTIME();
		SYSTEMTIME LocalTime = new SYSTEMTIME();
		FILETIME FileTime = new FILETIME();
		int64_t local_time = 0;
		int64_t reg_time = new int64_t();
		int64_t server_time = new int64_t();
		int64_t update_interval = new int64_t();
		// Can't link with wininet.lib because of sideloading issuesBOOL InternetCrackUrlA_t = new BOOL();
		InternetCrackUrlA_t pfInternetCrackUrlA = ((Object)0);
		HINTERNET InternetConnectA_t = new HINTERNET();
		InternetConnectA_t pfInternetConnectA = ((Object)0);
		BOOL InternetReadFile_t = new BOOL();
		InternetReadFile_t pfInternetReadFile = ((Object)0);
		BOOL InternetCloseHandle_t = new BOOL();
		InternetCloseHandle_t pfInternetCloseHandle = ((Object)0);
		HINTERNET HttpOpenRequestA_t = new HINTERNET();
		HttpOpenRequestA_t pfHttpOpenRequestA = ((Object)0);
		BOOL HttpSendRequestA_t = new BOOL();
		HttpSendRequestA_t pfHttpSendRequestA = ((Object)0);
		BOOL HttpQueryInfoA_t = new BOOL();
		HttpQueryInfoA_t pfHttpQueryInfoA = ((Object)0);
		do {
			if (pfInternetCrackUrlA == ((Object)0)) {
				pfInternetCrackUrlA = (InternetCrackUrlA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetCrackUrlA");
			} 
			if (pfInternetCrackUrlA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetCrackUrlA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfInternetConnectA == ((Object)0)) {
				pfInternetConnectA = (InternetConnectA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetConnectA");
			} 
			if (pfInternetConnectA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetConnectA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfInternetReadFile == ((Object)0)) {
				pfInternetReadFile = (InternetReadFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetReadFile");
			} 
			if (pfInternetReadFile == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetReadFile", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfInternetCloseHandle == ((Object)0)) {
				pfInternetCloseHandle = (InternetCloseHandle_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetCloseHandle");
			} 
			if (pfInternetCloseHandle == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetCloseHandle", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfHttpOpenRequestA == ((Object)0)) {
				pfHttpOpenRequestA = (HttpOpenRequestA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "HttpOpenRequestA");
			} 
			if (pfHttpOpenRequestA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "HttpOpenRequestA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfHttpSendRequestA == ((Object)0)) {
				pfHttpSendRequestA = (HttpSendRequestA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "HttpSendRequestA");
			} 
			if (pfHttpSendRequestA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "HttpSendRequestA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfHttpQueryInfoA == ((Object)0)) {
				pfHttpQueryInfoA = (HttpQueryInfoA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "HttpQueryInfoA");
			} 
			if (pfHttpQueryInfoA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "HttpQueryInfoA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		verbose = ModernizedCProgram.ReadSetting32("VerboseUpdateCheck")// Without this the FileDialog will produce error 0x8001010E when compiled for Vista or later;// Without this the FileDialog will produce error 0x8001010E when compiled for Vista or later
		do {
			(Object)(/*Error: Function owner not recognized*/CoInitializeEx(((Object)0), tagCOINIT.COINIT_APARTMENTTHREADED));
		} while (0);// Unless the update was forced, wait a while before performing the update check
		Object generatedDwHighDateTime = FileTime.getDwHighDateTime();
		Object generatedDwLowDateTime = FileTime.getDwLowDateTime();
		if (!ModernizedCProgram.force_update_check) {
			do {
				for (i = 0; (i < 30) && (!ModernizedCProgram.force_update_check); i++) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(500);
				}
			} while ((!ModernizedCProgram.force_update_check) && ((ModernizedCProgram.op_in_progress || (ModernizedCProgram.dialog_showing > 0))));
			if (!ModernizedCProgram.force_update_check) {
				if ((ModernizedCProgram.ReadSetting32("UpdateCheckInterval") == -1)) {
					do {
						if (verbose) {
							ModernizedCProgram._uprintf("Check for updates disabled, as per settings.");
						} 
					} while (0);
					;
				} 
				reg_time = ModernizedCProgram.ReadSetting64("LastUpdateCheck");
				update_interval = (int64_t)ModernizedCProgram.ReadSetting32("UpdateCheckInterval");
				if (update_interval == 0) {
					ModernizedCProgram.WriteSetting32("UpdateCheckInterval", (24 * 3600));
					update_interval = (24 * 3600);
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetSystemTime(LocalTime);
				if (!/*Error: Function owner not recognized*/SystemTimeToFileTime(LocalTime, FileTime)) {
					;
				} 
				local_time = ((((int64_t)generatedDwHighDateTime) << 32) + generatedDwLowDateTime) / 10000000;
				do {
					if (verbose > 1) {
						ModernizedCProgram._uprintf("Local time: %I64d", local_time);
					} 
				} while (0);
				if (local_time < reg_time + update_interval) {
					do {
						if (verbose) {
							ModernizedCProgram._uprintf("Next update check in %I64d seconds.", reg_time + update_interval - local_time);
						} 
					} while (0);
					;
				} 
			} 
		} 
		// It would of course be a lot nicer to use a timer and wake the thread, but my
		ModernizedCProgram.PrintStatusInfo(1, 1, 3000, 3243);
		// 1// 1status++;
		if (!/*Error: Function owner not recognized*/GetVersionExA(os_version)) {
			ModernizedCProgram._uprintf("Could not read Windows version - Check for updates cancelled.");
			;
		} 
		if (!/*Error: Function owner not recognized*/pfInternetCrackUrlA(server_url, (DWORD)((((byte)server_url) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(server_url)), 0, UrlParts)) {
			;
		} 
		hostname[/*Error: sizeof expression not supported yet*/ - 1] = 0;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(agent, /*Error: sizeof expression not supported yet*/, "Rufus/%d.%d.%d (Windows NT %d.%d%s)", ModernizedCProgram.rufus_version[0], ModernizedCProgram.rufus_version[1], ModernizedCProgram.rufus_version[2], ModernizedCProgram.nWindowsVersion >> 4, ModernizedCProgram.nWindowsVersion & -1024, ModernizedCProgram.is_x64() ? "; WOW64" : "");
			(agent)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		hSession = ModernizedCProgram.GetInternetSession(0);
		if (hSession == ((Object)0)) {
			;
		} 
		Object generatedLpszHostName = UrlParts.getLpszHostName();
		Object generatedNPort = UrlParts.getNPort();
		hConnection = /*Error: Function owner not recognized*/pfInternetConnectA(hSession, generatedLpszHostName, generatedNPort, ((Object)0), ((Object)0), 3, 0, (DWORD_PTR)((Object)0));
		if (hConnection == ((Object)0)) {
			;
		} 
		// 2// 2status++// BETAs are only made available for x86_32;// BETAs are only made available for x86_32
		if (ModernizedCProgram.is_x86_32) {
			releases_only = !ModernizedCProgram.ReadSettingBool("CheckForBetas");
		} 
		max_channel = releases_only ? 1 : (int)(/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/) - 1;
		do {
			if (verbose) {
				ModernizedCProgram._uprintf("Using %s for the update check", "https://rufus.ie");
			} 
		} while (0);
		Object generatedDwMajorVersion = os_version.getDwMajorVersion();
		Object generatedDwMinorVersion = os_version.getDwMinorVersion();
		Object generatedLpszUrlPath = UrlParts.getLpszUrlPath();
		Object generatedNScheme = UrlParts.getNScheme();
		for (k = 0; (k < max_channel) && (!found_new_version); k++) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)buf);
				buf = ((Object)0);
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)sig);
				sig = ((Object)0);
			} while (0);
			ModernizedCProgram._uprintf("Checking %s channel...", channel[k]);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(urlpath, /*Error: sizeof expression not supported yet*/, "%s%s%s_%s_%lu.%lu.ver", "Rufus", (k == 0) ? "" : "_", (k == 0) ? "" : channel[k], archname[ModernizedCProgram.GetCpuArch()], generatedDwMajorVersion, generatedDwMinorVersion);
				(urlpath)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			do {
				if (verbose) {
					ModernizedCProgram._uprintf("Base update check: %s", urlpath);
				} 
			} while (0);
			for (; (j > 0) && (i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/)); j--) {
				if ((urlpath[j] == (byte)'.') || (urlpath[j] == (byte)'_')) {
					verpos[i++] = j;
				} 
			}
			((i == (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("i == ARRAYSIZE(verpos)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\net.c", 719));
			UrlParts.setLpszUrlPath(urlpath);
			UrlParts.setDwUrlPathLength(/*Error: sizeof expression not supported yet*/);
			for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
				do {
					if (verbose > 1) {
						ModernizedCProgram._uprintf("Trying %s", generatedLpszUrlPath);
					} 
				} while (0);
				hRequest = /*Error: Function owner not recognized*/pfHttpOpenRequestA(hConnection, "GET", generatedLpszUrlPath, ((Object)0), ((Object)0), accept_types, -1024 | -1024 | -1024 | -1024 | -1024 | -1024 | ((generatedNScheme == .INTERNET_SCHEME_HTTPS) ? -1024 : 0), (DWORD_PTR)((Object)0));
				if ((hRequest == ((Object)0)) || (!/*Error: Function owner not recognized*/pfHttpSendRequestA(hRequest, ((Object)0), 0, ((Object)0), 0))) {
					ModernizedCProgram._uprintf("Unable to send request: %s", ModernizedCProgram.WinInetErrorString());
					;
				} 
				dwSize = /*Error: sizeof expression not supported yet*/;
				dwStatus = 404;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfHttpQueryInfoA(hRequest, 19 | -1024, (LPVOID)dwStatus, dwSize, ((Object)0));
				if (dwStatus == 200) {
					break;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetCloseHandle(hRequest);
				hRequest = ((Object)0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(urlpath[verpos[i]], ".ver", (((size_t)(((((byte)".ver") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".ver")) + 1)) < ((size_t)(true)) ? ((size_t)(((((byte)".ver") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".ver")) + 1)) : ((size_t)(true))));
					((byte)urlpath[verpos[i]])[(((size_t)(((((byte)".ver") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".ver")) + 1)) < ((size_t)(true)) ? ((size_t)(((((byte)".ver") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".ver")) + 1)) : ((size_t)(true))) - 1] = 0;
				} while (0);
			}
			if (dwStatus != 200) {
				do {
					if (verbose) {
						ModernizedCProgram._uprintf("Could not find a %s version file on server %s", channel[k], server_url);
					} 
				} while (0);
				if ((releases_only) || (k + 1 >= (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/))) {
					;
				} 
				continue;
			} 
			do {
				if (verbose) {
					ModernizedCProgram._uprintf("Found match for %s on server %s", urlpath, server_url);
				} 
			} while (0);
			dwSize = /*Error: sizeof expression not supported yet*/;
			if ((!/*Error: Function owner not recognized*/pfHttpQueryInfoA(hRequest, 9 | -1024, (LPVOID)ServerTime, dwSize, ((Object)0))) || (!/*Error: Function owner not recognized*/SystemTimeToFileTime(ServerTime, FileTime))) {
				;
			} 
			server_time = ((((int64_t)generatedDwHighDateTime) << 32) + generatedDwLowDateTime) / 10000000;
			do {
				if (verbose > 1) {
					ModernizedCProgram._uprintf("Server time: %I64d", server_time);
				} 
			} while (0);
			ModernizedCProgram.WriteSetting64("LastUpdateCheck", server_time);
			if (!ModernizedCProgram.force_update_check) {
				if ((local_time > server_time + 600) || (local_time < server_time - 600)) {
					ModernizedCProgram._uprintf("IMPORTANT: Your local clock is more than 10 minutes in the %s. Unless you fix this, Rufus may not be able to check for updates...", (local_time > server_time + 600) ? "future" : "past");
				} 
			} 
			dwSize = /*Error: sizeof expression not supported yet*/;
			if (!/*Error: Function owner not recognized*/pfHttpQueryInfoA(hRequest, 5 | -1024, (LPVOID)dwTotalSize, dwSize, ((Object)0))) {
				;
			} 
			buf = (byte)/*Error: Function owner not recognized*/calloc(dwTotalSize + 1, 1);
			if (buf == ((Object)0)) {
				;
			} 
			if (!/*Error: Function owner not recognized*/pfInternetReadFile(hRequest, buf, dwTotalSize, dwDownloaded) || (dwDownloaded != dwTotalSize)) {
				;
			} 
			do {
				if (verbose) {
					ModernizedCProgram._uprintf("Successfully downloaded version file (%d bytes)", dwTotalSize);
				} 
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(sigpath, /*Error: sizeof expression not supported yet*/, "%s/%s.sig", server_url, urlpath);
				(sigpath)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			dwDownloaded = (DWORD)ModernizedCProgram.DownloadToFileOrBuffer(sigpath, ((Object)0), sig, ((Object)0), 0);
			if ((dwDownloaded != 256) || (!ModernizedCProgram.ValidateOpensslSignature(buf, dwTotalSize, sig, dwDownloaded))) {
				ModernizedCProgram._uprintf("FATAL: Version signature is invalid â");
				;
			} 
			do {
				if (verbose) {
					ModernizedCProgram._uprintf("Version signature is valid â");
				} 
			} while (0);
			status++;
			ModernizedCProgram.parse_update(buf, dwTotalSize + 1);
			do {
				if (verbose) {
					ModernizedCProgram._uprintf("UPDATE DATA:");
				} 
			} while (0);
			do {
				if (verbose) {
					ModernizedCProgram._uprintf("  version: %d.%d.%d (%s)", ModernizedCProgram.update.getVersion()[0], ModernizedCProgram.update.getVersion()[1], ModernizedCProgram.update.getVersion()[2], channel[k]);
				} 
			} while (0);
			do {
				if (verbose) {
					ModernizedCProgram._uprintf("  platform_min: %d.%d", ModernizedCProgram.update.getPlatform_min()[0], ModernizedCProgram.update.getPlatform_min()[1]);
				} 
			} while (0);
			do {
				if (verbose) {
					ModernizedCProgram._uprintf("  url: %s", ModernizedCProgram.update.getDownload_url());
				} 
			} while (0);
			found_new_version = ((ModernizedCProgram.to_uint64_t(ModernizedCProgram.update.getVersion()) > ModernizedCProgram.to_uint64_t(ModernizedCProgram.rufus_version)) || (ModernizedCProgram.force_update)) && ((generatedDwMajorVersion > ModernizedCProgram.update.getPlatform_min()[0]) || ((generatedDwMajorVersion == ModernizedCProgram.update.getPlatform_min()[0]) && (generatedDwMinorVersion >= ModernizedCProgram.update.getPlatform_min()[1])));
			ModernizedCProgram._uprintf("N%sew %s version found%c", found_new_version ? "" : "o n", channel[k], found_new_version ? (byte)'!' : (byte)'.');
		}// Free any previous buffers we might have used
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)sig);
			sig = ((Object)0);
		} while (0);
		if (hRequest) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetCloseHandle(hRequest);
		} 
		if (hConnection) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetCloseHandle(hConnection);
		} 
		if (hSession) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetCloseHandle(hSession);
		} 
		switch (status) {
		case 2:
				ModernizedCProgram.PrintStatusInfo(1, 1, 3000, 3245);
				break;
		case 1:
				ModernizedCProgram.PrintStatusInfo(1, 1, 3000, 3244);
				break;
		case 4:
				ModernizedCProgram.PrintStatusInfo(1, 0, 3000, found_new_version ? 3246 : 3247);
		case 3:
		default:
				break;
		}
		// Start the new download after cleanupif (found_new_version) {
			while ((!ModernizedCProgram.force_update_check) && (ModernizedCProgram.op_in_progress || (ModernizedCProgram.dialog_showing > 0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(15000);
			}
			ModernizedCProgram.DownloadNewVersion();
		}  else if (ModernizedCProgram.force_update_check) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_NO_UPDATE, 0, 0);
		} 
		// User may have started an operation while we were checking
		ModernizedCProgram.force_update_check = 0;
		ModernizedCProgram.update_check_thread = ((Object)0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExitThread(0/*
		 * Initiate a check for updates. If force is true, ignore the wait period
		 */);
	}
	public static Object CheckForUpdates(Object force) {
		ModernizedCProgram.force_update_check = force;
		if (ModernizedCProgram.update_check_thread != ((Object)0)) {
			return 0;
		} 
		ModernizedCProgram.update_check_thread = /*Error: Function owner not recognized*/CreateThread(((Object)0), 0, CheckForUpdatesThread, ((Object)0), 0, ((Object)0));
		if (ModernizedCProgram.update_check_thread == ((Object)0)) {
			ModernizedCProgram._uprintf("Unable to start update check thread");
			return 0;
		} 
		return 1/*
		 * Download an ISO through Fido
		 */;
	}
	public static Object DownloadISOThread(Object param) {
		byte[] locale_str = new byte[1024];
		byte[] cmdline = new byte[/*Error: sizeof expression not supported yet*/ + 512];
		byte[] pipe = "\\\\.\\pipe\\";
		byte[] powershell_path = new byte[260];
		byte[] icon_path = "";
		byte[] script_path = "";
		byte url = ((Object)0);
		byte[] sig_url = new byte[128];
		uint64_t uncompressed_size = new uint64_t();
		int64_t size = -1;
		BYTE compressed = ((Object)0);
		BYTE sig = ((Object)0);
		HANDLE hFile = new HANDLE();
		HANDLE hPipe = new HANDLE();
		DWORD dwExitCode = 99;
		DWORD dwCompressedSize = new DWORD();
		DWORD dwSize = new DWORD();
		DWORD dwAvail = new DWORD();
		DWORD dwPipeSize = 4096;
		GUID guid = new GUID();
		ModernizedCProgram.dialog_showing++;
		do {
			(Object)(/*Error: Function owner not recognized*/CoInitializeEx(((Object)0), tagCOINIT.COINIT_APARTMENTTHREADED));
		} while (0);// Use a GUID as random unique string, else ill-intentioned security "researchers"
		// may either spam our pipe or replace our script to fool antivirus solutions into// thinking that Rufus is doing something malicious...do {
			(Object)(/*Error: Function owner not recognized*/CoCreateGuid(guid));
		} while (0);// coverity[fixed_size_dest]
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(pipe[9], ModernizedCProgram.GuidToString(guid));
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(icon_path, /*Error: sizeof expression not supported yet*/, "%s%s.ico", ModernizedCProgram.temp_dir, "Rufus");
			(icon_path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		ModernizedCProgram.ExtractAppIcon(icon_path, 1)//#define FORCE_URL "https://github.com/pbatard/rufus/raw/master/res/loc/test/windows_to_go.iso"//#define FORCE_URL "https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-9.8.0-amd64-netinst.iso";//#define FORCE_URL "https://github.com/pbatard/rufus/raw/master/res/loc/test/windows_to_go.iso"//#define FORCE_URL "https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-9.8.0-amd64-netinst.iso"
		// In test mode, just use our local script// If we don't have the script, download itif (ModernizedCProgram.fido_script == ((Object)0)) {
			dwCompressedSize = (DWORD)ModernizedCProgram.DownloadToFileOrBuffer(ModernizedCProgram.fido_url, ((Object)0), compressed, ModernizedCProgram.hMainDialog, 0);
			if (dwCompressedSize == 0) {
				;
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(sig_url, /*Error: sizeof expression not supported yet*/, "%s.sig", ModernizedCProgram.fido_url);
				(sig_url)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			dwSize = (DWORD)ModernizedCProgram.DownloadToFileOrBuffer(sig_url, ((Object)0), sig, ((Object)0), 0);
			if ((dwSize != 256) || (!ModernizedCProgram.ValidateOpensslSignature(compressed, dwCompressedSize, sig, dwSize))) {
				ModernizedCProgram._uprintf("FATAL: Signature is invalid â");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hProgress, PBM_SETSTATE, (WPARAM)PBST_ERROR, 0);
				ModernizedCProgram.SetTaskbarProgressState(TASKBAR_PROGRESS_FLAGS.TASKBAR_ERROR);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)compressed);
					compressed = ((Object)0);
				} while (0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(sig);
				;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(sig);
			ModernizedCProgram._uprintf("Signature is valid â");
			uncompressed_size = ((uint64_t)compressed[5]);
			if ((uncompressed_size < 1 * -1024) && (ModernizedCProgram.bled_init(ModernizedCProgram._uprintf, ((Object)0), ModernizedCProgram.FormatStatus) >= 0)) {
				ModernizedCProgram.fido_script = /*Error: Function owner not recognized*/malloc((size_t)uncompressed_size);
				size = ModernizedCProgram.bled_uncompress_from_buffer_to_buffer(compressed, dwCompressedSize, ModernizedCProgram.fido_script, (size_t)uncompressed_size, BLED_COMPRESSION_LZMA);
				ModernizedCProgram.bled_exit();
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)compressed);
				compressed = ((Object)0);
			} while (0);
			if (size != uncompressed_size) {
				ModernizedCProgram._uprintf("FATAL: Could not uncompressed download script");
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.fido_script);
					ModernizedCProgram.fido_script = ((Object)0);
				} while (0);
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hProgress, PBM_SETSTATE, (WPARAM)PBST_ERROR, 0);
				ModernizedCProgram.SetTaskbarProgressState(TASKBAR_PROGRESS_FLAGS.TASKBAR_ERROR);
				;
			} 
			ModernizedCProgram.fido_len = (DWORD)size;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hProgress, PBM_SETSTATE, (WPARAM)PBST_NORMAL, 0);
			ModernizedCProgram.SetTaskbarProgressState(TASKBAR_PROGRESS_FLAGS.TASKBAR_NORMAL);
			ModernizedCProgram.SetTaskbarProgressValue(0, -1024);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hProgress, (1024 + 2), 0, 0);
		} 
		ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3148);
		(((ModernizedCProgram.fido_script != ((Object)0)) && (ModernizedCProgram.fido_len != 0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(fido_script != NULL) && (fido_len != 0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\net.c", 941));
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(script_path, /*Error: sizeof expression not supported yet*/, "%s%s.ps1", ModernizedCProgram.temp_dir, ModernizedCProgram.GuidToString(guid));
			(script_path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		hFile = ModernizedCProgram.CreateFileU(script_path, -1024, -1024, ((Object)0), 2, -1024, ((Object)0));
		if (hFile == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Unable to create download script '%s': %s", script_path, ModernizedCProgram.WindowsErrorString());
			;
		} 
		if ((!/*Error: Function owner not recognized*/WriteFile(hFile, ModernizedCProgram.fido_script, ModernizedCProgram.fido_len, dwSize, ((Object)0))) || (dwSize != ModernizedCProgram.fido_len)) {
			ModernizedCProgram._uprintf("Unable to write download script '%s': %s", script_path, ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Because of this limitation, we can't use LockFileEx() on the file we create...do {
			if ((hFile != (HANDLE)(true)) && (hFile != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hFile);
				hFile = (HANDLE)(true);
			} 
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(powershell_path, /*Error: sizeof expression not supported yet*/, "%s\\WindowsPowerShell\\v1.0\\powershell.exe", ModernizedCProgram.system_dir);
			(powershell_path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(locale_str, /*Error: sizeof expression not supported yet*/, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s", ModernizedCProgram.selected_locale.getTxt()[0], ModernizedCProgram.lmprintf(3135), ModernizedCProgram.lmprintf(3136), ModernizedCProgram.lmprintf(3137), ModernizedCProgram.lmprintf(3138), ModernizedCProgram.lmprintf(3139), ModernizedCProgram.lmprintf(3040), ModernizedCProgram.lmprintf(3140), ModernizedCProgram.lmprintf(3141), ModernizedCProgram.lmprintf(3006), ModernizedCProgram.lmprintf(3007), ModernizedCProgram.lmprintf(3042), ModernizedCProgram.lmprintf(3142), ModernizedCProgram.lmprintf(3143), ModernizedCProgram.lmprintf(3144), ModernizedCProgram.lmprintf(3145), ModernizedCProgram.lmprintf(3146));
			(locale_str)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		hPipe = /*Error: Function owner not recognized*/CreateNamedPipeA(pipe, 1, 4 | 2 | 0, 255, dwPipeSize, dwPipeSize, 0, ((Object)0));
		if (hPipe == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Could not create pipe '%s': %s", pipe, ModernizedCProgram.WindowsErrorString);
			;
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(cmdline, /*Error: sizeof expression not supported yet*/, "\"%s\" -NonInteractive -Sta -NoProfile âExecutionPolicy Bypass -File \"%s\" -DisableFirstRunCustomize -PipeName %s -LocData \"%s\" -Icon \"%s\" -AppTitle \"%s\"", powershell_path, script_path, pipe[9], locale_str, icon_path, ModernizedCProgram.lmprintf(3149));
			(cmdline)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		// Signal our Windows alert hook that it should close the IE cookie prompts from Fido// Signal our Windows alert hook that it should close the IE cookie prompts from FidoModernizedCProgram.close_fido_cookie_prompts = 1;
		dwExitCode = ModernizedCProgram.RunCommand(cmdline, ModernizedCProgram.app_dir, 1);
		ModernizedCProgram._uprintf("Exited download script with code: %d", dwExitCode);
		ModernizedCProgram.close_fido_cookie_prompts = 0;
		Object generatedImagePath = img_save.getImagePath();
		if ((dwExitCode == 0) && /*Error: Function owner not recognized*/PeekNamedPipe(hPipe, ((Object)0), dwPipeSize, ((Object)0), dwAvail, ((Object)0)) && (dwAvail != 0)) {
			url = /*Error: Function owner not recognized*/malloc(dwAvail + 1);
			if ((url != ((Object)0)) && /*Error: Function owner not recognized*/ReadFile(hPipe, url, dwAvail, dwSize, ((Object)0)) && (dwSize > 4)) {
				IMG_SAVE img_save = new IMG_SAVE(0);
				url[dwSize] = 0;
				byte[] _img_ext_x = new byte[]{"*.iso"};
				byte[] _img_ext_d = new byte[]{ModernizedCProgram.lmprintf(3036)};
				ext_t img_ext = new ext_t((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), ModernizedCProgram.GetShortName(url), _img_ext_x, _img_ext_d);
				img_save.setType(2);
				img_save.setImagePath(ModernizedCProgram.FileDialog(1, ((Object)0), img_ext, 0));
				if (generatedImagePath == ((Object)0)) {
					;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_PROGRESS_INIT, 0, 0);
				ModernizedCProgram.FormatStatus = 0;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_TIMER_START, 0, 0);
				if (ModernizedCProgram.DownloadToFileOrBuffer(url, generatedImagePath, ((Object)0), ModernizedCProgram.hMainDialog, 1) == 0) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_PROGRESS_EXIT, 0, 0);
					if (((ModernizedCProgram.FormatStatus) & -1024) == -1024) {
						ModernizedCProgram._uprintf("Download cancelled by user");
						ModernizedCProgram.Notification(notification_type.MSG_INFO, ((Object)0), ((Object)0), ModernizedCProgram.lmprintf(3211), ModernizedCProgram.lmprintf(3041));
						ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3211);
					} else {
							ModernizedCProgram.Notification(notification_type.MSG_ERROR, ((Object)0), ((Object)0), ModernizedCProgram.lmprintf(3194, ModernizedCProgram.GetShortName(url)), ModernizedCProgram.lmprintf(3043, ModernizedCProgram.WinInetErrorString()));
							ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3212);
					} 
				} else {
						ModernizedCProgram.image_path = /*Error: Function owner not recognized*/_strdup(generatedImagePath);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_SELECT_ISO, 0, 0);
				} 
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)generatedImagePath);
					img_save.setImagePath(((Object)0));
				} while (0);
			} 
		} 
		if (script_path[0] != 0) {
			ModernizedCProgram.SetFileAttributesU(script_path, -1024);
			ModernizedCProgram.DeleteFileU(script_path);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(url);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_ENABLE_CONTROLS, 0, 0);
		ModernizedCProgram.dialog_showing--;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExitThread(dwExitCode);
	}
	public static Object DownloadISO() {
		if (/*Error: Function owner not recognized*/CreateThread(((Object)0), 0, DownloadISOThread, ((Object)0), 0, ((Object)0)) == ((Object)0)) {
			ModernizedCProgram._uprintf("Unable to start Windows ISO download thread");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_ENABLE_CONTROLS, 0, 0);
			return 0;
		} 
		return 1;
	}
	public static Object IsDownloadable(Object url) {
		DWORD dwSize = new DWORD();
		DWORD dwTotalSize = 0;
		byte[] accept_types = new byte[]{"*/*\0", ((Object)0)};
		byte[] hostname = new byte[64];
		byte[] urlpath = new byte[128];
		HINTERNET hSession = ((Object)0);
		HINTERNET hConnection = ((Object)0);
		HINTERNET hRequest = ((Object)0);
		URL_COMPONENTSA UrlParts = new URL_COMPONENTSA(/*Error: Unsupported expression*/, ((Object)0), 1, (INTERNET_SCHEME)0, hostname, /*Error: sizeof expression not supported yet*/, 0, ((Object)0), 1, urlpath, /*Error: sizeof expression not supported yet*/, ((Object)0), 1);
		BOOL InternetCrackUrlA_t = new BOOL();
		InternetCrackUrlA_t pfInternetCrackUrlA = ((Object)0);
		HINTERNET InternetConnectA_t = new HINTERNET();
		InternetConnectA_t pfInternetConnectA = ((Object)0);
		BOOL InternetCloseHandle_t = new BOOL();
		InternetCloseHandle_t pfInternetCloseHandle = ((Object)0);
		HINTERNET HttpOpenRequestA_t = new HINTERNET();
		HttpOpenRequestA_t pfHttpOpenRequestA = ((Object)0);
		BOOL HttpSendRequestA_t = new BOOL();
		HttpSendRequestA_t pfHttpSendRequestA = ((Object)0);
		BOOL HttpQueryInfoA_t = new BOOL();
		HttpQueryInfoA_t pfHttpQueryInfoA = ((Object)0);
		do {
			if (pfInternetCrackUrlA == ((Object)0)) {
				pfInternetCrackUrlA = (InternetCrackUrlA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetCrackUrlA");
			} 
			if (pfInternetCrackUrlA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetCrackUrlA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfInternetConnectA == ((Object)0)) {
				pfInternetConnectA = (InternetConnectA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetConnectA");
			} 
			if (pfInternetConnectA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetConnectA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfInternetCloseHandle == ((Object)0)) {
				pfInternetCloseHandle = (InternetCloseHandle_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "InternetCloseHandle");
			} 
			if (pfInternetCloseHandle == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "InternetCloseHandle", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfHttpOpenRequestA == ((Object)0)) {
				pfHttpOpenRequestA = (HttpOpenRequestA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "HttpOpenRequestA");
			} 
			if (pfHttpOpenRequestA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "HttpOpenRequestA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfHttpSendRequestA == ((Object)0)) {
				pfHttpSendRequestA = (HttpSendRequestA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "HttpSendRequestA");
			} 
			if (pfHttpSendRequestA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "HttpSendRequestA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (pfHttpQueryInfoA == ((Object)0)) {
				pfHttpQueryInfoA = (HttpQueryInfoA_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("WinInet"), "HttpQueryInfoA");
			} 
			if (pfHttpQueryInfoA == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "HttpQueryInfoA", "WinInet", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		if (url == ((Object)0)) {
			return 0;
		} 
		ModernizedCProgram.FormatStatus = 0;
		ModernizedCProgram.DownloadStatus = 404;
		Object generatedLpszHostName = UrlParts.getLpszHostName();
		Object generatedLpszUrlPath = UrlParts.getLpszUrlPath();
		if ((!/*Error: Function owner not recognized*/pfInternetCrackUrlA(url, (DWORD)((((byte)url) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(url)), 0, UrlParts)) || (generatedLpszHostName == ((Object)0)) || (generatedLpszUrlPath == ((Object)0))) {
			;
		} 
		hostname[/*Error: sizeof expression not supported yet*/ - 1] = 0;
		// Open an Internet session// Open an Internet sessionhSession = ModernizedCProgram.GetInternetSession(0);
		if (hSession == ((Object)0)) {
			;
		} 
		Object generatedNPort = UrlParts.getNPort();
		hConnection = /*Error: Function owner not recognized*/pfInternetConnectA(hSession, generatedLpszHostName, generatedNPort, ((Object)0), ((Object)0), 3, 0, (DWORD_PTR)((Object)0));
		if (hConnection == ((Object)0)) {
			;
		} 
		Object generatedNScheme = UrlParts.getNScheme();
		hRequest = /*Error: Function owner not recognized*/pfHttpOpenRequestA(hConnection, "GET", generatedLpszUrlPath, ((Object)0), ((Object)0), accept_types, -1024 | -1024 | -1024 | -1024 | -1024 | -1024 | ((generatedNScheme == .INTERNET_SCHEME_HTTPS) ? -1024 : 0), (DWORD_PTR)((Object)0));
		if (hRequest == ((Object)0)) {
			;
		} 
		if (!/*Error: Function owner not recognized*/pfHttpSendRequestA(hRequest, ((Object)0), 0, ((Object)0), 0)) {
			;
		} 
		// Get the file size// Get the file sizedwSize = /*Error: sizeof expression not supported yet*/;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfHttpQueryInfoA(hRequest, 19 | -1024, (LPVOID)ModernizedCProgram.DownloadStatus, dwSize, ((Object)0));
		if (ModernizedCProgram.DownloadStatus != 200) {
			;
		} 
		dwSize = /*Error: sizeof expression not supported yet*/;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfHttpQueryInfoA(hRequest, 5 | -1024, (LPVOID)dwTotalSize, dwSize, ((Object)0));
		if (hConnection) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetCloseHandle(hConnection);
		} 
		if (hSession) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfInternetCloseHandle(hSession);
		} 
		return (dwTotalSize > 0);
	}
	/*
	 * dirblock.c --- directory block routines.
	 *
	 * Copyright (C) 1995, 1996 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static Object ext2fs_read_dir_block4(Object fs, Object block, Object buf, int flags, Object ino) {
		 retval = new ();
		int corrupt = 0;
		retval = ModernizedCProgram.io_channel_read_blk64(fs.getIo(), block, 1, buf);
		if (retval) {
			return retval;
		} 
		if (!(fs.getFlags() & -1024) && !(ext2_dir_entry)buf.ext2fs_dir_block_csum_verify(fs, ino)) {
			corrupt = 1;
		} 
		if (!retval && corrupt) {
			retval = EXT2_ET_DIR_CSUM_INVALID;
		} 
		return retval;
	}
	public static Object ext2fs_read_dir_block3(Object fs, Object block, Object buf, int flags) {
		return ModernizedCProgram.ext2fs_read_dir_block4(fs, block, buf, flags, 0);
	}
	public static Object ext2fs_read_dir_block2(Object fs, Object block, Object buf, int flags) {
		return ModernizedCProgram.ext2fs_read_dir_block3(fs, block, buf, flags);
	}
	public static Object ext2fs_read_dir_block(Object fs, Object block, Object buf) {
		return ModernizedCProgram.ext2fs_read_dir_block3(fs, block, buf, 0);
	}
	public static Object ext2fs_write_dir_block4(Object fs, Object block, Object inbuf, int flags, Object ino) {
		 retval = new ();
		byte buf = inbuf;
		retval = (ext2_dir_entry)buf.ext2fs_dir_block_csum_set(fs, ino);
		if (retval) {
			;
		} 
		retval = ModernizedCProgram.io_channel_write_blk64(fs.getIo(), block, 1, buf);
	}
	public static Object ext2fs_write_dir_block3(Object fs, Object block, Object inbuf, int flags) {
		return ModernizedCProgram.ext2fs_write_dir_block4(fs, block, inbuf, flags, 0);
	}
	public static Object ext2fs_write_dir_block2(Object fs, Object block, Object inbuf, int flags) {
		return ModernizedCProgram.ext2fs_write_dir_block3(fs, block, inbuf, flags);
	}
	public static Object ext2fs_write_dir_block(Object fs, Object block, Object inbuf) {
		return ModernizedCProgram.ext2fs_write_dir_block3(fs, block, inbuf, 0);
	}
	/*** Function definitions */
	public static Object NtfsSectGetFileVcnExtent(Object File, _LARGE_INTEGER Vcn, S_NTFSSECT_EXTENT_ Extent) {
		BOOL bad = new BOOL();
		DWORD output_size = new DWORD();
		DWORD rc = new DWORD();
		STARTING_VCN_INPUT_BUFFER input = new STARTING_VCN_INPUT_BUFFER();
		RETRIEVAL_POINTERS_BUFFER output = new RETRIEVAL_POINTERS_BUFFER();
		Object generatedQuadPart = Vcn.getQuadPart();
		bad = (File == (HANDLE)(true) || !Vcn || generatedQuadPart < 0 || !Extent);
		if (bad) {
			return -1024;
		} 
		input.setStartingVcn(Vcn);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DeviceIoControl(File, (((true) << 16) | ((true) << 14) | ((true) << 2) | (true)), input, /*Error: sizeof expression not supported yet*/, output, /*Error: sizeof expression not supported yet*/, output_size, ((Object)0));
		rc = /*Error: Function owner not recognized*/GetLastError();
		Object generatedStartingVcn = output.getStartingVcn();
		Object generatedExtents = output.getExtents();
		switch (rc) {
		case -1024:
				break;
		case -1024:
				Extent.setFirstVcn(generatedStartingVcn);
				Extent.setNextVcn(generatedExtents[0].getNextVcn());
				Extent.setFirstLcn(generatedExtents[0].getLcn());
				return -1024;
		case -1024:
		default:
				(ModernizedCProgram.NtfsSectLastErrorMessage = ("NtfsSectGetFileVcnExtent(): Unknown status!"));
		}
		return rc;
	}
	public static Object NtfsSectLcnToLba(Object VolumeInfo, Object Lcn) {
		BOOL bad = new BOOL();
		bad = (!VolumeInfo || !VolumeInfo.getBytesPerSector() || !VolumeInfo.getSectorsPerCluster() || !Lcn || Lcn.getQuadPart() < 0 || !Lba);
		if (bad) {
			return -1024;
		} 
		this.setQuadPart((VolumeInfo.getPartitionLba().getQuadPart() + Lcn.getQuadPart() * VolumeInfo.getSectorsPerCluster()));
		return -1024;
	}
	/*
	    Copyright (C) 2000, 2004 Herbert Valerio Riedel <hvr@gnu.org>
	    Copyright (C) 2005, 2008, 2012, 2015 Rocky Bernstein <rocky@gnu.org>
	
	    This program is free software: you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation, either version 3 of the License, or
	    (at your option) any later version.
	
	    This program is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/
	/** \file bytesex.h
	 *  \brief  Generic Byte-swapping routines.
	 *
	 *   Note: this header will is slated to get removed and libcdio will
	 *   use glib.h routines instead.
	*/
	/* also defines CDIO_INLINE */
	/** 16-bit big-endian to little-endian */
	/** 32-bit big-endian to little-endian */
	/** 64-bit big-endian to little-endian */
	public static Object uint16_swap_le_be(Object val) {
		return (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()-1024) << 8) | ((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()-1024) >> 8)));
	}
	public static Object uint32_swap_le_be(Object val) {
		return (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()-1024) << 24) | ((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()-1024) << 8) | ((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()-1024) >> 8) | ((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()-1024) >> 24)));
	}
	public static Object uint64_swap_le_be(Object val) {
		return (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()/*Error: Function owner not recognized*/UINT64_C(-1024)) << 56) | ((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()/*Error: Function owner not recognized*/UINT64_C(-1024)) << 40) | ((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()/*Error: Function owner not recognized*/UINT64_C(-1024)) << 24) | ((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()/*Error: Function owner not recognized*/UINT64_C(-1024)) << 8) | ((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()/*Error: Function owner not recognized*/UINT64_C(-1024)) >> 8) | ((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()/*Error: Function owner not recognized*/UINT64_C(-1024)) >> 24) | ((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()/*Error: Function owner not recognized*/UINT64_C(-1024)) >> 40) | ((/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val) & ()/*Error: Function owner not recognized*/UINT64_C(-1024)) >> 56)));
	}
	/** symmetric conversions */
	/** converter function template */
	/** ISO9660-related field conversion routines */
	/** Convert from uint8_t to ISO 9660 7.1.1 format */
	/** Convert from ISO 9660 7.1.1 format to uint8_t */
	/** Convert from uint16_t to ISO 9669 7.2.1 format */
	/** Convert from ISO 9660 7.2.1 format to uint16_t */
	/** Convert from uint16_t to ISO 9669 7.2.2 format */
	/** Convert from ISO 9660 7.2.2 format to uint16_t */
	/** Convert from uint16_t to ISO 9669 7.2.3 format */
	public static int to_723(Object i) {
		return ModernizedCProgram.uint32_swap_le_be(i) | i;
	}
	/** Convert from ISO 9660 7.2.3 format to uint16_t */
	public static int from_723(Object p) {
		 u = ()p;
		return (u[0] | (u[1] << /* Return the little-endian part always, to handle non-specs-compliant images */8));
	}
	public static int from_723_with_err(Object p, Object err) {
		if (ModernizedCProgram.uint32_swap_le_be(p) != p) {
			ModernizedCProgram.cdio_warn("from_723: broken byte order");
			err = true;
		} else {
				err = false;
		} 
		return (-1024 & p/** Convert from uint16_t to ISO 9669 7.3.1 format */);/** Convert from ISO 9660 7.3.1 format to uint32_t */
	}
	/** Convert from uint32_t to ISO 9669 7.3.2 format */
	/** Convert from ISO 9660 7.3.2 format to uint32_t */
	/** Convert from uint16_t to ISO 9669 7.3.3 format */
	public static int to_733(Object i) {
		return ModernizedCProgram.uint64_swap_le_be(i) | i;
	}
	/** Convert from ISO 9660 7.3.3 format to uint32_t */
	public static int from_733(Object p) {
		 u = ()p;
		return (u[0] | (u[1] << 8) | (u[2] << 16) | (u[3] << /* Return the little-endian part always, to handle non-specs-compliant images */24));
	}
	public static int from_733_with_err(Object p, Object err) {
		if (ModernizedCProgram.uint64_swap_le_be(p) != p) {
			ModernizedCProgram.cdio_warn("from_733: broken byte order");
			err = true;
		} else {
				err = false;
		} 
		return (/*Error: Function owner not recognized*/UINT32_C(-1024) & p/* CDIO_BYTESEX_H_ */);/*
		 * Local variables:
		 *  c-file-style: "gnu"
		 *  tab-width: 8
		 *  indent-tabs-mode: nil
		 * End:
		 */
	}
	public static int ms_get_kbdrv(Object kb) {
		int i;
		int j;
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			for (j = 0; j < ModernizedCProgram.ms_kb_list[i].getSize(); j++) {
				if (/*Error: Function owner not recognized*/strcmp(((ModernizedCProgram.ms_kb_list[i].getList()[j] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.ms_kb_list[i].getList()[j]), ((kb == ((Object)0)) ? "<NULL>" : kb)) == 0) {
					return i;
				} 
			}
		}
		return -1;
	}
	public static int fd_get_kbdrv(Object kb) {
		int i;
		int j;
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			for (j = 0; j < ModernizedCProgram.fd_kb_list[i].getSize(); j++) {
				if (/*Error: Function owner not recognized*/strcmp(((ModernizedCProgram.fd_kb_list[i].getList()[j] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.fd_kb_list[i].getList()[j]), ((kb == ((Object)0)) ? "<NULL>" : kb)) == 0) {
					return i;
				} 
			}
		}
		return -1/*
		 * We display human readable descriptions of the locale in the menu
		 * As real estate might be limited, keep it short
		 */;
	}
	// Left enabled, but doesn't seem to work in FreeDOS
	//	{"ko", "Korean"},			// Unsupported by FreeDOS?
	//	{"fa", "Persian"};			// Unsupported by FreeDOS?
	public static Object kb_to_hr(Object kb) {
		int i;
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (/*Error: Function owner not recognized*/strcmp(((kb == ((Object)0)) ? "<NULL>" : kb), ((ModernizedCProgram.kb_hr_list[i][0] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.kb_hr_list[i][0])) == 0) {
				return ModernizedCProgram.kb_hr_list[i][1];
			} 
		}
		// Should never happen, so let's try to get some attention here// Should never happen, so let's try to get some attention here((i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("i < ARRAYSIZE(kb_hr_list)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\dos_locale.c", 292));
		return ((Object)0);
	}
	public static Object cp_to_hr(Object cp) {
		int i;
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (ModernizedCProgram.cp_hr_list[i].getCp() == cp) {
				return ModernizedCProgram.cp_hr_list[i].getName();
			} 
		}
		// Should never happen, so this oughta get some attention// Should never happen, so this oughta get some attention((i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("i < ARRAYSIZE(cp_hr_list)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\dos_locale.c", 429));
		return ((Object)0);
	}
	// http://blogs.msdn.com/b/michkap/archive/2004/12/05/275231.aspx
	public static Object get_kb() {
		int kbid;
		byte[] kbid_str = new byte[9];
		int pass;
		// Count on Microsoft to add convolution to a simple operation.// We use GetKeyboardLayout() because it returns an HKL, which for instance
		/*Error: Function owner not recognized*/// doesn't tell us if the *LAYOUT* is Dvorak or something else. For that we// need an KLID which GetKeyboardLayoutNameA() does return ...but only as a// string of an hex value.../*Error: Function owner not recognized*/// doesn't tell us if the *LAYOUT* is Dvorak or something else. For that we// need an KLID which GetKeyboardLayoutNameA() does return ...but only as a// string of an hex value...GetKeyboardLayoutNameA(kbid_str);
		if (/*Error: Function owner not recognized*/sscanf(kbid_str, "%x", kbid) == 0) {
			ModernizedCProgram._uprintf("Could not scan keyboard layout name - falling back to US as default\n");
			kbid = -1024;
		} 
		ModernizedCProgram._uprintf("Windows KBID 0x%08x\n", kbid);
		for (pass = 0; pass < 3; pass++) {
			switch (kbid) {
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "is";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "nl";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "sg";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "yu";
			case -1024:
					return "yc";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "et";
			case -1024:
			case -1024:
					return "ro";
			case -1024:
			case -1024:
					return "sv";
			case -1024:
			case -1024:
					return "sl";
			case -1024:
					return "mk";
			case -1024:
			case -1024:
					return "sq";
			case -1024:
					return "uz";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "lv";
			case -1024:
					return "dv";
			case -1024:
					return "us";
			case -1024:
					return "la";
			case -1024:
					return "az";
			case -1024:
			case -1024:
			case -1024:
					return "ar";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "vi";
			case -1024:
					return "br";
			case -1024:
					return "bg";
			case -1024:
					return "lt";
			case -1024:
					return "hy";
			case -1024:
					return "fo";
			case -1024:
			case -1024:
					return "rh";
			case -1024:
			case -1024:
					return "sf";
			case -1024:
					return "ru";
			case -1024:
					return "ch";
			case -1024:
			case -1024:
					return "jp";
			case -1024:
					return "tm";
			case -1024:
					return "be";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "su";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "kk";
			case -1024:
			case -1024:
					return "bl";
			case -1024:
					return "ka";
			case -1024:
			case -1024:
					return "sp";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "gk";
			case -1024:
					return "po";
			case -1024:
					return "it";
			case -1024:
			case -1024:
					return "tr";
			case -1024:
					return "tt";
			case -1024:
			case -1024:
					return "lh";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "uk";
			case -1024:
			case -1024:
			case -1024:
					return "mt";
			case -1024:
					return "ur";
			case -1024:
					return "no";
			case -1024:
			case -1024:
			case -1024:
					return "cz";
			case -1024:
					return "cf";
			case -1024:
					return "ky";
			case -1024:
			case -1024:
					return "tj";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "hu";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "dk";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "fr";
			case -1024:
			case -1024:
					return "pl";
			case -1024:
					return "il";
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					return "gr";
			default:
					if (pass == 0) {
						kbid = ((WORD)(kbid) & -1024);
					}  else if (pass == 1) {
						kbid = ((WORD)(/*Error: Function owner not recognized*/GetSystemDefaultLangID()) & -1024);
						ModernizedCProgram._uprintf("Unable to match KBID, trying LangID 0x%04x\n", kbid);
					} 
					break;
			}
		}// Some of these return values are defined in// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout\DosKeybCodes// Others are picked up in FreeDOS official keyboard layouts, v3.0// Note: keyboard values are meant to start at 0x400. The cases below 0x400 are added// to attempt to figure out a "best match" in case we couldn't find a supported keyboard
		ModernizedCProgram._uprintf("Unable to match KBID and LangID - defaulting to US\n");
		return "us"/*
		 * From WinME DOS
		 *
		 *	EGA.CPI:
		 *		0x01B5	437 (United States)
		 *		0x0352	850 (Latin 1)
		 *		0x0354	852 (Latin 2)
		 *		0x035C	860 (Portuguese)
		 *		0x035F	863 (French Canadian)
		 *		0x0361	865 (Nordic)
		 *
		 *	EGA2.CPI:
		 *		0x0352	850 (Latin 1)
		 *		0x0354	852 (Latin 2)
		 *		0x0359	857 (Turkish)
		 *		0x035D	861 (Icelandic)
		 *		0x0365	869 (Greek)
		 *		0x02E1	737 (Greek II)
		 *
		 *	EGA3.CPI:
		 *		0x01B5	437 (United States)
		 *		0x0307	775 (Baltic)
		 *		0x0352	850 (Latin 1)
		 *		0x0354	852 (Latin 2)
		 *		0x0357	855 (Cyrillic I)
		 *		0x0362	866 (Cyrillic II)
		 */;
	}
	// Pick the EGA to use according to the DOS target codepage (see above)
	public static Object ms_get_ega(Object cp) {
		switch (cp) {
		case 737:
				return "ega2.cpi";
		case 866:
				return "ega3.cpi";
		case 860:
		case 857:
		case 852:
		case 850:
		case 861:
		case 855:
		case 869:
		case 775:
		case 437:
		case 865:
				return "ega.cpi";
		case 863:
		default:
				return ((Object)0);
		}
	}
	// Pick the EGA to use according to the DOS target codepage (from CPIDOS' Codepage.txt)
	public static Object fd_get_ega(Object cp) {
		switch (cp) {
		case 1116:
		case 1118:
		case 862:
		case 30026:
		case 867:
				return "ega9.cpx";
		case 30011:
		case 853:
		case 30027:
		case 3846:
		case 777:
		case 30007:
		case 30013:
		case 59829:
		case 899:
		case 3845:
				return "ega10.cpx";
		case 58335:
				return "ega12";
		case 30025:
		case 30002:
		case 866:
		case 774:
		case 851:
		case 30022:
		case 60258:
		case 858:
				return "ega.cpx";
		case 848:
		case 895:
		case 30010:
				return "ega4.cpx";
		case 58152:
		case 855:
		case 667:
		case 30012:
		case 850:
		case 30017:
		case 30030:
		case 30031:
		case 668:
		case 59234:
		case 864:
		case 775:
		case 30021:
				return "ega14.cpx";
		case 30040:
				return "ega17.cpx";
		case 30009:
				return "ega11.cpx";
		case 30039:
		case 30001:
		case 30020:
		case 30019:
				return "ega7.cpx";
		case 30003:
		case 30015:
		case 852:
		case 869:
				return "ega5.cpx";
		case 437:
		case 30034:
		case 856:
		case 30005:
		case 859:
		case 771:
		case 30032:
				return "ega16.cpx";
		case 30028:
				return "ega15.cpx";
		case 1119:
				return "ega2.cpx";
		case 773:
		case 860:
		case 30023:
		case 30016:
		case 3848:
				return "ega18.cpx";
		case 1125:
		case 30008:
		case 30004:
		case 863:
		case 60853:
				return "ega6.cpx";
		case 849:
		case 737:
		case 30033:
		case 1117:
		case 30014:
		case 778:
				return "ega8.cpx";
		case 30000:
		case 808:
		case 3021:
		case 1131:
		case 865:
		case 58210:
		case 30018:
		case 30006:
		case 113:
		case 861:
		case 30024:
		case 790:
		case 62306:
				return "ega13.cpx";
		case 770:
		case 772:
		case 30029:
		case 991:
		case 872:
				return "ega3.cpx";
		case 3012:
		case 857:
		default:
				return ((Object)0);
		}
	}
	// Transliteration of the codepage (to add currency symbol, etc - FreeDOS only)
	public static Object fd_upgrade_cp(Object cp) {
		switch (cp) {
		case 850:
				return 858;
		default:
				return cp;
		}
	}
	// Don't bother about setting up the country or multiple codepages
	public static Object SetDOSLocale(Object path, Object bFreeDOS) {
		FILE fd = new FILE();
		byte[] filename = new byte[260];
		ULONG cp = new ULONG();
		byte kb;
		int kbdrv;
		byte egadrv;
		// First handle the codepage// First handle the codepagekb = ModernizedCProgram.get_kb()// We have a keyboard ID, but that doesn't mean it's supported;// We have a keyboard ID, but that doesn't mean it's supported
		kbdrv = bFreeDOS ? ModernizedCProgram.fd_get_kbdrv(kb) : ModernizedCProgram.ms_get_kbdrv(kb);
		if (kbdrv < 0) {
			ModernizedCProgram._uprintf("Keyboard id '%s' is not supported - falling back to 'us'\n", kb);
			kb = "us";
			kbdrv = bFreeDOS ? ModernizedCProgram.fd_get_kbdrv(kb) : ModernizedCProgram.ms_get_kbdrv(kb);
		} 
		ModernizedCProgram._uprintf("Will use DOS keyboard '%s' [%s]\n", kb, ModernizedCProgram.kb_to_hr(kb));
		// Now get a codepage// Now get a codepagecp = /*Error: Function owner not recognized*/GetOEMCP();
		egadrv = bFreeDOS ? ModernizedCProgram.fd_get_ega(cp) : ModernizedCProgram.ms_get_ega(cp);
		if (egadrv == ((Object)0)) {
			ModernizedCProgram._uprintf("Unable to find an EGA file with codepage %d [%s]\n", cp, ModernizedCProgram.cp_to_hr(cp));
			cp = ModernizedCProgram.kbdrv_data[kbdrv].getDefault_cp();
			egadrv = bFreeDOS ? "ega.cpx" : "ega.cpi";
		}  else if (bFreeDOS) {
			cp = ModernizedCProgram.fd_upgrade_cp(cp);
		} 
		// We need to use the fallback CP from the keyboard we got above, as 437 is not always available
		ModernizedCProgram._uprintf("Will use codepage %d [%s]\n", cp, ModernizedCProgram.cp_to_hr(cp));
		if ((cp == 437) && (/*Error: Function owner not recognized*/strcmp(kb, "us") == 0)) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(filename, path, (((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
				((byte)filename)[(((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
			} while (0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(filename, "\\AUTOEXEC.BAT", (((size_t)(((((byte)"\\AUTOEXEC.BAT") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\AUTOEXEC.BAT")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)filename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(filename)) - 1)) ? ((size_t)(((((byte)"\\AUTOEXEC.BAT") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\AUTOEXEC.BAT")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)filename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(filename)) - 1))));
			fd = /*Error: Function owner not recognized*/fopen(filename, "w+");
			if (fd == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to create 'AUTOEXEC.BAT': %s.\n", ModernizedCProgram.WindowsErrorString());
				return 0;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "@echo off\n");
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "set PATH=.;\\;\\LOCALE\n");
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "echo Using %s keyboard with %s codepage [%d]\n", ModernizedCProgram.kb_to_hr("us"), ModernizedCProgram.cp_to_hr(437), 437);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
			ModernizedCProgram._uprintf("Successfully wrote 'AUTOEXEC.BAT'\n");
			return 1;
		} 
		// Nothing much to do if US/US - just notify in autoexec.bat
		// CONFIG.SYSdo {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(filename, path, (((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)filename)[(((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(filename, "\\CONFIG.SYS", (((size_t)(((((byte)"\\CONFIG.SYS") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\CONFIG.SYS")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)filename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(filename)) - 1)) ? ((size_t)(((((byte)"\\CONFIG.SYS") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\CONFIG.SYS")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)filename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(filename)) - 1))));
		fd = /*Error: Function owner not recognized*/fopen(filename, "w+");
		if (fd == ((Object)0)) {
			ModernizedCProgram._uprintf("Unable to create 'CONFIG.SYS': %s.\n", ModernizedCProgram.WindowsErrorString());
			return 0;
		} 
		if (bFreeDOS) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "!MENUCOLOR=7,0\nMENU\nMENU   FreeDOS Language Selection Menu\n");
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "MENU   \xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\nMENU\n");
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "[MENU]\n");
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "MENUDEFAULT=1,5\n")// Menu item max: 70 characters;// Menu item max: 70 characters
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "%s1%c Use %s keyboard with %s codepage [%d]\n", bFreeDOS ? "MENU " : "MENUITEM=", bFreeDOS ? (byte)')' : (byte)',', ModernizedCProgram.kb_to_hr(kb), ModernizedCProgram.cp_to_hr(cp), (int)cp);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "%s2%c Use %s keyboard with %s codepage [%d]\n", bFreeDOS ? "MENU " : "MENUITEM=", bFreeDOS ? (byte)')' : (byte)',', ModernizedCProgram.kb_to_hr("us"), ModernizedCProgram.cp_to_hr(437), 437);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "%s", bFreeDOS ? "MENU\n12?\n" : "[1]\ndevice=\\locale\\display.sys con=(ega,,1)\n[2]\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
		ModernizedCProgram._uprintf("Successfully wrote 'CONFIG.SYS'\n");
		// AUTOEXEC.BATdo {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(filename, path, (((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)filename)[(((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(filename, "\\AUTOEXEC.BAT", (((size_t)(((((byte)"\\AUTOEXEC.BAT") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\AUTOEXEC.BAT")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)filename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(filename)) - 1)) ? ((size_t)(((((byte)"\\AUTOEXEC.BAT") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\AUTOEXEC.BAT")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)filename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(filename)) - 1))));
		fd = /*Error: Function owner not recognized*/fopen(filename, "w+");
		if (fd == ((Object)0)) {
			ModernizedCProgram._uprintf("Unable to create 'AUTOEXEC.BAT': %s.\n", ModernizedCProgram.WindowsErrorString());
			return 0;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "@echo off\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "set PATH=.;\\;\\LOCALE\n");
		if (bFreeDOS) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "display con=(ega,,1)\n");
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "GOTO %%CONFIG%%\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, ":1\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "mode con codepage prepare=((%d) \\locale\\%s) > NUL\n", (int)cp, egadrv);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "mode con codepage select=%d > NUL\n", (int)cp);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "keyb %s,,\\locale\\%s\n", kb, ModernizedCProgram.kbdrv_data[kbdrv].getName());
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, ":2\n");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
		ModernizedCProgram._uprintf("Successfully wrote 'AUTOEXEC.BAT'\n");
		return 1;
	}
	/*
	 * Rufus: The Reliable USB Formatting Utility
	 * Settings access, through either registry or INI file
	 * Copyright Â© 2015-2019 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	/*
	 * List of setting names used by this application
	 */
	public static Object CheckIniKey(Object key) {
		byte str = ModernizedCProgram.get_token_data_file_indexed(key, ModernizedCProgram.ini_file, 1);
		BOOL ret = (str != ((Object)0));
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)str);
			str = ((Object)0);
		} while (0);
		return ret;
	}
	public static Object ReadIniKey64(Object key) {
		int64_t val = 0;
		byte str = ModernizedCProgram.get_token_data_file_indexed(key, ModernizedCProgram.ini_file, 1);
		if (str != ((Object)0)) {
			val = /*Error: Function owner not recognized*/_strtoi64(str, ((Object)0), 0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(str);
		} 
		return val;
	}
	public static Object WriteIniKey64(Object key, Object val) {
		byte[] str = new byte[24];
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(str, /*Error: sizeof expression not supported yet*/, "%I64i", val);
			(str)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		return (ModernizedCProgram.set_token_data_file(key, str, ModernizedCProgram.ini_file) != ((Object)0));
	}
	public static Object ReadIniKey32(Object key) {
		int32_t val = 0;
		byte str = ModernizedCProgram.get_token_data_file_indexed(key, ModernizedCProgram.ini_file, 1);
		if (str != ((Object)0)) {
			val = /*Error: Function owner not recognized*/strtol(str, ((Object)0), 0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(str);
		} 
		return val;
	}
	public static Object WriteIniKey32(Object key, Object val) {
		byte[] str = new byte[12];
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(str, /*Error: sizeof expression not supported yet*/, "%d", val);
			(str)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		return (ModernizedCProgram.set_token_data_file(key, str, ModernizedCProgram.ini_file) != ((Object)0));
	}
	public static Byte ReadIniKeyStr(Object key) {
		byte[] str = new byte[512];
		byte val;
		str[0] = 0;
		val = ModernizedCProgram.get_token_data_file_indexed(key, ModernizedCProgram.ini_file, 1);
		if (val != ((Object)0)) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(str, val, (((size_t)(((((byte)val) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(val)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)val) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(val)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
				((byte)str)[(((size_t)(((((byte)val) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(val)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)val) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(val)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
			} while (0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(val);
		} 
		return str;
	}
	public static Object WriteIniKeyStr(Object key, Object val) {
		return (ModernizedCProgram.set_token_data_file(key, val, ModernizedCProgram.ini_file) != ((Object)0/* Helpers for boolean operations */));
	}
	/*
	 * Read and store settings from/to ini file or registry
	 */
	public static Object ReadSetting64(Object key) {
		return (ModernizedCProgram.ini_file != ((Object)0)) ? ModernizedCProgram.ReadIniKey64(key) : ModernizedCProgram.ReadRegistryKey64(((HKEY)-1024), key);
	}
	public static Object WriteSetting64(Object key, Object val) {
		return (ModernizedCProgram.ini_file != ((Object)0)) ? ModernizedCProgram.WriteIniKey64(key, val) : ModernizedCProgram.WriteRegistryKey64(((HKEY)-1024), key, val);
	}
	public static Object ReadSetting32(Object key) {
		return (ModernizedCProgram.ini_file != ((Object)0)) ? ModernizedCProgram.ReadIniKey32(key) : ModernizedCProgram.ReadRegistryKey32(((HKEY)-1024), key);
	}
	public static Object WriteSetting32(Object key, Object val) {
		return (ModernizedCProgram.ini_file != ((Object)0)) ? ModernizedCProgram.WriteIniKey32(key, val) : ModernizedCProgram.WriteRegistryKey32(((HKEY)-1024), key, val);
	}
	public static Object ReadSettingBool(Object key) {
		return (ModernizedCProgram.ini_file != ((Object)0)) ? (ModernizedCProgram.ReadIniKey32(key) != 0) : (ModernizedCProgram.ReadRegistryKey32(((HKEY)-1024), key) != 0);
	}
	public static Object WriteSettingBool(Object key, Object val) {
		return (ModernizedCProgram.ini_file != ((Object)0)) ? ModernizedCProgram.WriteIniKey32(key, (val) ? 1 : 0) : ModernizedCProgram.WriteRegistryKey32(((HKEY)-1024), key, (val) ? 1 : 0);
	}
	public static Byte ReadSettingStr(Object key) {
		return (ModernizedCProgram.ini_file != ((Object)0)) ? ModernizedCProgram.ReadIniKeyStr(key) : ModernizedCProgram.ReadRegistryKeyStr(((HKEY)-1024), key);
	}
	public static Object WriteSettingStr(Object key, Byte val) {
		return (ModernizedCProgram.ini_file != ((Object)0)) ? ModernizedCProgram.WriteIniKeyStr(key, val) : ModernizedCProgram._SetRegistryKey(((HKEY)-1024), key, 1, (LPBYTE)val, (DWORD)((((byte)val) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(val)));
	}
	public static Object cdio_lba_to_lsn(Object lba) {
		if (CDIO_INVALID_LBA == lba) {
			return CDIO_INVALID_LSN;
		} 
		return lba - CDIO_PREGAP_SECTORS/*
		   The below is adapted from cdparanoia code which claims it is
		   straight from the MMC3 spec.
		*/;
	}
	public static void cdio_lsn_to_msf(Object lsn, Object msf) {
		int m;
		int s;
		int f;
		((msf != 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("msf != 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\sector.c", 66));
		if (lsn >= -CDIO_PREGAP_SECTORS) {
			m = (lsn + CDIO_PREGAP_SECTORS) / CDIO_CD_FRAMES_PER_MIN;
			lsn -= m * CDIO_CD_FRAMES_PER_MIN;
			s = (lsn + CDIO_PREGAP_SECTORS) / CDIO_CD_FRAMES_PER_SEC;
			lsn -= s * CDIO_CD_FRAMES_PER_SEC;
			f = lsn + CDIO_PREGAP_SECTORS;
		} else {
				m = (lsn + CDIO_CD_MAX_LSN) / CDIO_CD_FRAMES_PER_MIN;
				lsn -= m * (CDIO_CD_FRAMES_PER_MIN);
				s = (lsn + CDIO_CD_MAX_LSN) / CDIO_CD_FRAMES_PER_SEC;
				lsn -= s * CDIO_CD_FRAMES_PER_SEC;
				f = lsn + CDIO_CD_MAX_LSN;
		} 
		if (m > 99) {
			ModernizedCProgram.cdio_warn("number of minutes (%d) truncated to 99.", m);
			m = 99;
		} 
		msf.setM(ModernizedCProgram.cdio_to_bcd8(m));
		msf.setS(ModernizedCProgram.cdio_to_bcd8(s));
		msf.setF(ModernizedCProgram.cdio_to_bcd8(f/*!
		  Convert an LBA into a string representation of the MSF.
		  \warning cdio_lba_to_msf_str returns new allocated string */));
	}
	public static Byte cdio_lba_to_msf_str(Object lba) {
		if (CDIO_INVALID_LBA == lba) {
			return /*Error: Function owner not recognized*/strdup("*INVALID");
		} else {
				 msf = new ();
				msf.setM(msf.setS(msf.setF(0)));
				ModernizedCProgram.cdio_lba_to_msf(lba, msf);
				return ModernizedCProgram.cdio_msf_to_str(msf/*!
				  Convert an LSN into the corresponding LBA.
				  CDIO_INVALID_LBA is returned if there is an error.
				*/);
		} 
	}
	public static Object cdio_lsn_to_lba(Object lsn) {
		if (CDIO_INVALID_LSN == lsn) {
			return CDIO_INVALID_LBA;
		} 
		return lsn + CDIO_PREGAP_SECTORS/*!
		  Convert an LBA into the corresponding MSF.
		*/;
	}
	public static void cdio_lba_to_msf(Object lba, Object msf) {
		((msf != 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("msf != 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\sector.c", 126));
		ModernizedCProgram.cdio_lsn_to_msf(ModernizedCProgram.cdio_lba_to_lsn(lba), msf/*!
		  Convert a MSF into the corresponding LBA.
		  CDIO_INVALID_LBA is returned if there is an error.
		*/);
	}
	public static Object cdio_msf_to_lba(Object msf) {
		 lba = 0;
		((msf != 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("msf != 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\sector.c", 139));
		lba = ModernizedCProgram.cdio_from_bcd8(msf.getM());
		lba *= CDIO_CD_SECS_PER_MIN;
		lba += ModernizedCProgram.cdio_from_bcd8(msf.getS());
		lba *= CDIO_CD_FRAMES_PER_SEC;
		lba += ModernizedCProgram.cdio_from_bcd8(msf.getF());
		return lba/*!
		  Convert a MSF into the corresponding LSN.
		  CDIO_INVALID_LSN is returned if there is an error.
		*/;
	}
	public static Object cdio_msf_to_lsn(Object msf) {
		return ModernizedCProgram.cdio_lba_to_lsn(ModernizedCProgram.cdio_msf_to_lba(msf/*!
		  Convert an LBA into a string representation of the MSF.
		  \warning cdio_lba_to_msf_str returns new allocated string */));
	}
	public static Byte cdio_msf_to_str(Object msf) {
		byte[] buf = new byte[16];
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(buf, /*Error: sizeof expression not supported yet*/, "%2.2x:%2.2x:%2.2x", msf.getM(), msf.getS(), msf.getF());
		return /*Error: Function owner not recognized*/strdup(buf/*!
		  Convert a MSF - broken out as 3 integer components into the
		  corresponding LBA.
		  CDIO_INVALID_LBA is returned if there is an error.
		*/);
	}
	public static Object cdio_msf3_to_lba(int minutes, int seconds, int frames) {
		return ((minutes * CDIO_CD_SECS_PER_MIN + seconds) * CDIO_CD_FRAMES_PER_SEC + frames/*!
		  Convert a string of the form MM:SS:FF into the corresponding LBA.
		  CDIO_INVALID_LBA is returned if there is an error.
		*/);
	}
	public static Object cdio_mmssff_to_lba(Object psz_mmssff) {
		int psz_field;
		 ret = new ();
		byte c;
		if (0 == /*Error: Function owner not recognized*/strcmp(psz_mmssff, "0")) {
			return 0;
		} 
		c = psz_mmssff++;
		if (c >= (byte)'0' && c <= (byte)'9') {
			psz_field = (c - (byte)'0');
		} else {
				return CDIO_INVALID_LBA;
		} 
		while ((byte)':' != (c = psz_mmssff++)) {
			if (c >= (byte)'0' && c <= (byte)'9') {
				psz_field = psz_field * 10 + (c - (byte)'0');
			} else {
					return CDIO_INVALID_LBA;
			} 
		}
		ret = ModernizedCProgram.cdio_msf3_to_lba(psz_field, 0, 0);
		c = psz_mmssff++;
		if (c >= (byte)'0' && c <= (byte)'9') {
			psz_field = (c - (byte)'0');
		} else {
				return CDIO_INVALID_LBA;
		} 
		if ((byte)':' != (c = psz_mmssff++)) {
			if (c >= (byte)'0' && c <= (byte)'9') {
				psz_field = psz_field * 10 + (c - (byte)'0');
				c = psz_mmssff++;
				if (c != (byte)':') {
					return CDIO_INVALID_LBA;
				} 
			} else {
					return CDIO_INVALID_LBA;
			} 
		} 
		if (psz_field >= CDIO_CD_SECS_PER_MIN) {
			return CDIO_INVALID_LBA;
		} 
		ret += ModernizedCProgram.cdio_msf3_to_lba(0, psz_field, 0);
		c = psz_mmssff++;
		if (/*Error: Function owner not recognized*/isdigit(c)) {
			psz_field = (c - (byte)'0');
		} else {
				return -1;
		} 
		if ((byte)'\0' != (c = psz_mmssff++)) {
			if (/*Error: Function owner not recognized*/isdigit(c)) {
				psz_field = psz_field * 10 + (c - (byte)'0');
				c = psz_mmssff++;
			} else {
					return CDIO_INVALID_LBA;
			} 
		} 
		if ((byte)'\0' != c) {
			return CDIO_INVALID_LBA;
		} 
		if (psz_field >= CDIO_CD_FRAMES_PER_SEC) {
			return CDIO_INVALID_LBA;
		} 
		ret += psz_field;
		return ret/*
		 * Local variables:
		 *  c-file-style: "gnu"
		 *  tab-width: 8
		 *  indent-tabs-mode: nil
		 * End:
		 */;
	}
	/* Called once in rc_do_normalize() */
	public static void rc_read() {
		Object generatedFd = this.getFd();
		int buffer_size = ModernizedCProgram.full_read(generatedFd, ((uint8_t)(rc + 1)), -1024);
		//TODO: return -1 instead
		//This will make unlzma delete broken unpacked file on unpack errorsif (buffer_size <= 0) {
			do {
				do {
					if (ModernizedCProgram.bled_printf != ((Object)0)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: unexpected EOF");
					} else {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: unexpected EOF");
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
					} 
				} while (0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/longjmp(ModernizedCProgram.bb_error_jmp, 1);
			} while (0);
		} 
		this.setBuffer_end(((uint8_t)(rc + 1)) + buffer_size);
		this.setPtr(((uint8_t)(rc + 1)));
	}
	/* Called twice, but one callsite is in speed_inline'd rc_is_bit_1() */
	public static void rc_do_normalize() {
		Object generatedPtr = this.getPtr();
		Object generatedBuffer_end = this.getBuffer_end();
		if (generatedPtr >= generatedBuffer_end) {
			rc.rc_read();
		} 
		Object generatedRange = this.getRange();
		generatedRange <<=  8;
		Object generatedCode = this.getCode();
		this.setCode((generatedCode << 8) | generatedPtr++);
	}
	/* Called once */
	/*, int buffer_size) */
	public static  rc_init(int fd) {
		int i;
		rc_t rc = new rc_t();
		rc = /*Error: Function owner not recognized*/calloc(/*Error: sizeof expression not supported yet*/ + -1024, 1);
		rc.setFd(fd/* rc->ptr = rc->buffer_end; */);
		for (i = 0; i < 5; i++) {
			rc.rc_do_normalize();
		}
		rc.setRange(-1024);
		return rc;
	}
	/* Called once  */
	public static void rc_free() {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(rc);
	}
	/* rc_is_bit_1 is called 9 times */
	public static int rc_is_bit_1(Object p) {
		rc.rc_normalize();
		Object generatedRange = this.getRange();
		this.setBound(p * (generatedRange >> 11));
		Object generatedCode = this.getCode();
		Object generatedBound = this.getBound();
		if (generatedCode < generatedBound) {
			this.setRange(generatedBound);
			p += ((1 << 11) - p) >> 5;
			return 0;
		} 
		generatedRange -= generatedBound;
		generatedCode -= generatedBound;
		p -= p >> 5;
		return 1;
	}
	/* Called 4 times in unlzma loop */
	public static int rc_get_bit(Object p, Integer symbol) {
		int ret = rc.rc_is_bit_1(p);
		symbol = symbol * 2 + ret;
		return ret;
	}
	/* Called once */
	public static int rc_direct_bit() {
		rc.rc_normalize();
		Object generatedRange = this.getRange();
		generatedRange >>=  1;
		Object generatedCode = this.getCode();
		if (generatedCode >= generatedRange) {
			generatedCode -= generatedRange;
			return 1;
		} 
		return 0;
	}
	/* Called twice */
	public static void rc_bit_tree_decode(Object p, int num_levels, Integer symbol) {
		int i = num_levels;
		symbol = 1;
		while (i--) {
			rc.rc_get_bit(p + symbol, symbol);
		}
		symbol -= 1 << num_levels;
	}
	/*
	    Copyright (C) 2004, 2005, 2006, 2008, 2010, 2012, 2014
	    Rocky Bernstein <rocky@gnu.org>
	    Copyright (C) 2000 Herbert Valerio Riedel <hvr@gnu.org>
	
	    This program is free software: you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation, either version 3 of the License, or
	    (at your option) any later version.
	
	    This program is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/
	/*!
	   \file util.h
	   \brief Miscellaneous utility functions.
	
	   Warning: this will probably get removed/replaced by using glib.h
	*/
	/* CDIO_INLINE */
	public static Object _cdio_len2blocks(Object i_len, Object i_blocksize) {
		 i_blocks = new ();
		i_blocks = i_len / ()i_blocksize;
		if (i_len % i_blocksize) {
			i_blocks++;
		} 
		return i_blocks/*! free() and NULL out p_obj it is not already null. */;
	}
	/* round up to next block boundary */
	public static int _cdio_ceil2block(int offset, Object i_blocksize) {
		return ModernizedCProgram._cdio_len2blocks(offset, i_blocksize) * i_blocksize;
	}
	public static int _cdio_ofs_add(int offset, int length, Object i_blocksize) {
		if (i_blocksize - (offset % i_blocksize) < length) {
			offset = ModernizedCProgram._cdio_ceil2block(offset, i_blocksize);
		} 
		offset += length;
		return offset;
	}
	public static Object _cdio_bool_str(Object b) {
		return b ? "yes" : "no";
	}
	/*
	 * Private includes and definitions for userspace use of XZ Embedded
	 *
	 * Author: Lasse Collin <lasse.collin@tukaani.org>
	 *
	 * This file has been put into the public domain.
	 * You can do whatever you want with this file.
	 */
	/* Uncomment as needed to enable BCJ filter decoders. */
	/* #define XZ_DEC_POWERPC */
	/* #define XZ_DEC_IA64 */
	/* #define XZ_DEC_ARM */
	/* #define XZ_DEC_ARMTHUMB */
	/* #define XZ_DEC_SPARC */
	/*
	 * Some functions have been marked with __always_inline to keep the
	 * performance reasonable even when the compiler is optimizing for
	 * small code size. You may be able to save a few bytes by #defining
	 * __always_inline to plain inline, but don't complain if the code
	 * becomes slow.
	 *
	 * NOTE: System headers on GNU/Linux may #define this macro already,
	 * so if you want to change it, you need to #undef it first.
	 */
	/*
	 * Some functions are marked to never be inlined to reduce stack usage.
	 * If you don't care about stack usage, you may want to modify this so
	 * that noinline_for_stack is #defined to be empty even when using GCC.
	 * Doing so may save a few bytes in binary size.
	 */
	/* Inline functions to access unaligned unsigned 32-bit integers */
	public static Object get_unaligned_le32(Object[] buf) {
		return (uint32_t)buf[0] | ((uint32_t)buf[1] << 8) | ((uint32_t)buf[2] << 16) | ((uint32_t)buf[3] << 24);
	}
	public static Object get_unaligned_be32(Object[] buf) {
		return (uint32_t)(buf[0] << 24) | ((uint32_t)buf[1] << 16) | ((uint32_t)buf[2] << 8) | (uint32_t)buf[3];
	}
	public static void put_unaligned_le32(Object val, Object[] buf) {
		buf[0] = (uint8_t)val;
		buf[1] = (uint8_t)(val >> 8);
		buf[2] = (uint8_t)(val >> 16);
		buf[3] = (uint8_t)(val >> 24);
	}
	public static void put_unaligned_be32(Object val, Object[] buf) {
		buf[0] = (uint8_t)(val >> 24);
		buf[1] = (uint8_t)(val >> 16);
		buf[2] = (uint8_t)(val >> 8);
		buf[3] = (uint8_t)val/*
		 * Use get_unaligned_le32() also for aligned access for simplicity. On
		 * little endian systems, #define get_le32(ptr) (*(const uint32_t *)(ptr))
		 * could save a few bytes in code size.
		 */;
	}
	/*
	 * Helper functions for multiple mount protection (MMP).
	 *
	 * Copyright (C) 2011 Whamcloud, Inc.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/* since glibc 2.20 _SVID_SOURCE is deprecated */
	public static Object ext2fs_mmp_read(Object fs, Object mmp_blk, Object buf) {
		return EXT2_ET_OP_NOT_SUPPORTED;
	}
	/* ext2fs_open() reserves fd0,1,2 to avoid stdio collision, so checking
		 * mmp_fd <= 0 is OK to validate that the fd is valid.  This opens its
		 * own fd to read the MMP block to ensure that it is using O_DIRECT,
		 * regardless of how the io_manager is doing reads, to avoid caching of
		 * the MMP block by the io_manager or the VM.  It needs to be fresh. */
	public static Object ext2fs_mmp_write(Object fs, Object mmp_blk, Object buf) {
		/* I was tempted to make this use O_DIRECT and the mmp_fd, but
			 * this caused no end of grief, while leaving it as-is works. */return /* Make sure the block gets to disk quickly */EXT2_ET_OP_NOT_SUPPORTED;
	}
	public static int ext2fs_mmp_new_seq() {
		/* Crank the random number generator a few times */return EXT2_ET_OP_NOT_SUPPORTED;
	}
	public static Object ext2fs_mmp_update(Object fs) {
		return ModernizedCProgram.ext2fs_mmp_update2(fs, 0);
	}
	public static Object ext2fs_mmp_clear(Object fs) {
		return EXT2_ET_OP_NOT_SUPPORTED;
	}
	public static Object ext2fs_mmp_init(Object fs) {
		return EXT2_ET_OP_NOT_SUPPORTED;
	}
	/* This is probably excessively large, but who knows? */
	/*
	 * Make sure that the fs is not mounted or being fsck'ed while opening the fs.
	 */
	public static Object ext2fs_mmp_start(Object fs) {
		return EXT2_ET_OP_NOT_SUPPORTED/*
		 * Clear the MMP usage in the filesystem.  If this function returns an
		 * error EXT2_ET_MMP_CHANGE_ABORT it means the filesystem was modified
		 * by some other process while in use, and changes should be dropped, or
		 * risk filesystem corruption.
		 */;
	}
	/*
		 * If check_interval in MMP block is larger, use that instead of
		 * check_interval from the superblock.
		 */
	public static Object ext2fs_mmp_stop(Object fs) {
		if (!fs.getSuper().ext2fs_has_feature_mmp() || !(fs.getFlags() & EXT2_FLAG_RW) || (fs.getFlags() & EXT2_FLAG_SKIP_MMP)) {
			return 0;
		} 
		return EXT2_ET_OP_NOT_SUPPORTED;
	}
	/* Check if the MMP block is not changed. */
	/*
	 * Update the on-disk mmp buffer, after checking that it hasn't been changed.
	 */
	public static Object ext2fs_mmp_update2(Object fs, int immediately) {
		if (!fs.getSuper().ext2fs_has_feature_mmp() || !(fs.getFlags() & EXT2_FLAG_RW) || (fs.getFlags() & EXT2_FLAG_SKIP_MMP)) {
			return 0;
		} 
		return EXT2_ET_OP_NOT_SUPPORTED;
	}
	/*
	 * newdir.c --- create a new directory block
	 *
	 * Copyright (C) 1994, 1995 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/*
	 * Create new directory block
	 */
	public static Object ext2fs_new_dir_block(Object fs, Object dir_ino, Object parent_ino, Byte block) {
		ext2_dir_entry dir = ((Object)0);
		 retval = new ();
		byte buf;
		int rec_len;
		int filetype = 0;
		ext2_dir_entry_tail t = new ext2_dir_entry_tail();
		int csum_size = 0;
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), buf);
		if (retval) {
			return retval;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buf, 0, fs.getBlocksize());
		dir = (ext2_dir_entry)buf;
		if (fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			csum_size = /*Error: Unsupported expression*/;
		} 
		retval = dir.ext2fs_set_rec_len(fs, fs.getBlocksize() - csum_size);
		if (retval) {
			ModernizedCProgram.ext2fs_free_mem(buf);
			return retval;
		} 
		Object generatedName = dir.getName();
		Object generatedRec_len = dir.getRec_len();
		if (dir_ino) {
			if (fs.getSuper().ext2fs_has_feature_filetype()) {
				filetype = 2/*
						 * Set up entry for '.'
						 */;
			} 
			dir.setInode(dir_ino);
			ModernizedCProgram.ext2fs_dirent_set_name_len(dir, 1);
			ModernizedCProgram.ext2fs_dirent_set_file_type(dir, filetype);
			generatedName[0] = (byte)'.';
			rec_len = (fs.getBlocksize() - csum_size) - (((true) + 8 + (4 - 1)) & ~(4 - 1));
			dir.setRec_len((((true) + 8 + (4 - 1)) & ~(4 - 1/*
					 * Set up entry for '..'
					 */)));
			dir = (ext2_dir_entry)(buf + generatedRec_len);
			retval = dir.ext2fs_set_rec_len(fs, rec_len);
			if (retval) {
				ModernizedCProgram.ext2fs_free_mem(buf);
				return retval;
			} 
			dir.setInode(parent_ino);
			ModernizedCProgram.ext2fs_dirent_set_name_len(dir, 2);
			ModernizedCProgram.ext2fs_dirent_set_file_type(dir, filetype);
			generatedName[0] = (byte)'.';
			generatedName[1] = (byte)'.';
		} 
		if (csum_size) {
			t = ((ext2_dir_entry_tail)(((byte)(buf)) + (fs.getBlocksize()) - /*Error: Unsupported expression*/));
			t.ext2fs_initialize_dirent_tail(fs);
		} 
		block = buf;
		return 0/*
		 * Create new directory on inline data
		 */;
	}
	public static Object ext2fs_new_dir_inline_data(Object fs, Object dir_ino, Object parent_ino, Object[] iblock) {
		ext2_dir_entry dir = ((Object)0);
		 retval = new ();
		int rec_len;
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		iblock[0] = /*Error: Function owner not recognized*/ext2fs_cpu_to_le32(parent_ino);
		dir = (ext2_dir_entry)((byte)iblock + (true));
		dir.setInode(0);
		rec_len = ((/*Error: Unsupported expression*/ * (((12 + 1) + 1) + 1))) - (true);
		retval = dir.ext2fs_set_rec_len(fs, rec_len);
		if (retval) {
			;
		} 
	}
	/*
	 * Fill s->temp by copying data starting from b->in[b->in_pos]. Caller
	 * must have set s->temp.pos to indicate how much data we are supposed
	 * to copy into s->temp.buf. Return true once s->temp.pos has reached
	 * s->temp.size.
	 */
	public static boolean fill_temp(xz_dec s, xz_buf b) {
		Object generatedIn_size = b.getIn_size();
		Object generatedIn_pos = b.getIn_pos();
		 generatedTemp = s.getTemp();
		Object generatedSize = generatedTemp.getSize();
		Object generatedPos = generatedTemp.getPos();
		size_t copy_size = ((generatedIn_size - generatedIn_pos) < (generatedSize - generatedPos) ? (generatedIn_size - generatedIn_pos) : (generatedSize - generatedPos));
		Object generatedBuf = generatedTemp.getBuf();
		Object[] generatedIn = b.getIn();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBuf + generatedPos, generatedIn + generatedIn_pos, copy_size);
		generatedIn_pos += copy_size;
		generatedPos += copy_size;
		if (generatedPos == generatedSize) {
			generatedTemp.setPos(0);
			return 1;
		} 
		return 0;
	}
	public static xz_ret dec_block(xz_dec s, xz_buf b) {
		xz_ret ret;
		Object generatedIn_pos = b.getIn_pos();
		s.setIn_start(generatedIn_pos);
		Object generatedOut_pos = b.getOut_pos();
		s.setOut_start(generatedOut_pos);
		boolean generatedBcj_active = s.getBcj_active();
		xz_dec_bcj generatedBcj = s.getBcj();
		xz_dec_lzma2 generatedLzma2 = s.getLzma2();
		if (generatedBcj_active) {
			xz_ret.ret = ModernizedCProgram.xz_dec_bcj_run(generatedBcj, generatedLzma2, b);
		} else {
				xz_ret.ret = ModernizedCProgram.xz_dec_lzma2_run(generatedLzma2, b);
		} 
		 generatedBlock = s.getBlock();
		Object generatedCompressed = generatedBlock.getCompressed();
		Object generatedIn_start = s.getIn_start();
		generatedCompressed += generatedIn_pos - generatedIn_start;
		Object generatedUncompressed = generatedBlock.getUncompressed();
		Object generatedOut_start = s.getOut_start();
		generatedUncompressed += generatedOut_pos - generatedOut_start;
		if (generatedCompressed > generatedCompressed || generatedUncompressed > generatedUncompressed) {
			return xz_ret.XZ_DATA_ERROR;
		} 
		xz_check generatedCheck_type = s.getCheck_type();
		Object generatedOut = b.getOut();
		Object generatedCrc32 = s.getCrc32();
		if (generatedCheck_type == xz_check.XZ_CHECK_CRC32) {
			s.setCrc32(ModernizedCProgram.xz_crc32(generatedOut + generatedOut_start, generatedOut_pos - generatedOut_start, generatedCrc32));
		} 
		Object generatedHash = generatedBlock.getHash();
		 generatedBlock_header = s.getBlock_header();
		Object generatedSize = generatedBlock_header.getSize();
		Object generatedCount = generatedBlock.getCount();
		if (xz_ret.ret == xz_ret.XZ_STREAM_END) {
			if (generatedCompressed != ((vli_type)-1) && generatedCompressed != generatedCompressed) {
				return xz_ret.XZ_DATA_ERROR;
			} 
			if (generatedUncompressed != ((vli_type)-1) && generatedUncompressed != generatedUncompressed) {
				return xz_ret.XZ_DATA_ERROR;
			} 
			generatedHash.getUnpadded() += generatedSize + generatedCompressed;
			if (generatedCheck_type == xz_check.XZ_CHECK_CRC32) {
				generatedHash.getUnpadded() += 4;
			} 
			generatedUncompressed += generatedUncompressed;
			generatedHash.setCrc32(ModernizedCProgram.xz_crc32((uint8_t)generatedHash, /*Error: sizeof expression not supported yet*/, generatedCrc32));
			++generatedCount;
		} 
		return xz_ret.ret;
	}
	public static xz_ret dec_index(xz_dec s, xz_buf b) {
		xz_ret ret;
		 generatedIndex = s.getIndex();
		Object generatedCount = generatedIndex.getCount();
		Object[] generatedIn = b.getIn();
		Object generatedIn_pos = b.getIn_pos();
		Object generatedIn_size = b.getIn_size();
		Object generatedVli = s.getVli();
		Object generatedHash = generatedIndex.getHash();
		Object generatedSequence = generatedIndex.getSequence();
		do {
			xz_ret.ret = s.dec_vli(generatedIn, generatedIn_pos, generatedIn_size);
			if (xz_ret.ret != xz_ret.XZ_STREAM_END) {
				s.index_update(b);
				return xz_ret.ret;
			} 
			switch (generatedSequence) {
			case .SEQ_INDEX_UNCOMPRESSED:
					generatedHash.getUncompressed() += generatedVli;
					generatedHash.setCrc32(ModernizedCProgram.xz_crc32((uint8_t)generatedHash, /*Error: sizeof expression not supported yet*/, generatedHash.getCrc32()));
					--generatedCount;
					generatedIndex.setSequence(.SEQ_INDEX_UNPADDED);
					break;
			case .SEQ_INDEX_UNPADDED:
					generatedHash.getUnpadded() += generatedVli;
					generatedIndex.setSequence(.SEQ_INDEX_UNCOMPRESSED);
					break;
			case .SEQ_INDEX_COUNT:
					generatedIndex.setCount(generatedVli);
					if (generatedCount != generatedCount) {
						return xz_ret.XZ_DATA_ERROR;
					} 
					generatedIndex.setSequence(.SEQ_INDEX_UNPADDED);
					break;
			}
		} while (generatedCount > 0);
		return xz_ret.XZ_STREAM_END/*
		 * Validate that the next four input bytes match the value of s->crc32.
		 * s->pos must be zero when starting to validate the first byte.
		 */;
	}
	public static xz_ret crc32_validate(xz_dec s, xz_buf b) {
		Object generatedPos = s.getPos();
		Object generatedIn_pos = b.getIn_pos();
		Object generatedIn_size = b.getIn_size();
		Object generatedCrc32 = s.getCrc32();
		Object[] generatedIn = b.getIn();
		do {
			if (generatedIn_pos == generatedIn_size) {
				return xz_ret.XZ_OK;
			} 
			if (((generatedCrc32 >> generatedPos) & -1024) != generatedIn[generatedIn_pos++]) {
				return xz_ret.XZ_DATA_ERROR;
			} 
			generatedPos += 8;
		} while (generatedPos < 32);
		s.setCrc32(0);
		s.setPos(0);
		return xz_ret.XZ_STREAM_END/*
		 * Skip over the Check field when the Check ID is not supported.
		 * Returns true once the whole Check field has been skipped over.
		 */;
	}
	public static xz_ret dec_main(xz_dec s, xz_buf b) {
		xz_ret ret;
		/*
			 * Store the start position for the case when we are in the middle
			 * of the Index field.
			 */
		Object generatedIn_pos = b.getIn_pos();
		s.setIn_start(generatedIn_pos);
		Object generatedIn_size = b.getIn_size();
		Object[] generatedIn = b.getIn();
		 generatedBlock_header = s.getBlock_header();
		Object generatedSize = generatedBlock_header.getSize();
		 generatedTemp = s.getTemp();
		 generatedBlock = s.getBlock();
		Object generatedCompressed = generatedBlock.getCompressed();
		xz_check generatedCheck_type = s.getCheck_type();
		Object generatedIn_start = s.getIn_start();
		Object generatedHash = generatedBlock.getHash();
		 generatedSequence = s.getSequence();
		while (1) {
			switch (generatedSequence) {
			case .SEQ_BLOCK_CHECK:
					if (generatedCheck_type == xz_check.XZ_CHECK_CRC32) {
						xz_ret.ret = ModernizedCProgram.crc32_validate(s, b);
						if (xz_ret.ret != xz_ret.XZ_STREAM_END) {
							return xz_ret.ret;
						} 
					} 
					s.setSequence(.SEQ_BLOCK_START);
					break;
			case .SEQ_STREAM_FOOTER:
					if (!ModernizedCProgram.fill_temp(s, b)) {
						return xz_ret.XZ_OK;
					} 
					return s/* Never reached */.dec_stream_footer();
			case .SEQ_BLOCK_START:
					if (generatedIn_pos == generatedIn_size) {
						return xz_ret.XZ_OK;
					} 
					if (generatedIn[generatedIn_pos] == /* See if this is the beginning of the Index field. */0) {
						s.setIn_start(generatedIn_pos++);
						s.setSequence(.SEQ_INDEX);
						break;
					} 
					generatedBlock_header.setSize(((uint32_t)generatedIn[generatedIn_pos] + 1) * 4);
					generatedTemp.setSize(generatedSize);
					generatedTemp.setPos(0);
					s.setSequence(.SEQ_BLOCK_HEADER);
			case .SEQ_BLOCK_UNCOMPRESS:
					xz_ret.ret = ModernizedCProgram.dec_block(s, b);
					if (xz_ret.ret != xz_ret.XZ_STREAM_END) {
						return xz_ret.ret;
					} 
					s.setSequence(.SEQ_BLOCK_PADDING);
			case .SEQ_BLOCK_PADDING/*
						 * Size of Compressed Data + Block Padding
						 * must be a multiple of four. We don't need
						 * s->block.compressed for anything else
						 * anymore, so we use it here to test the size
						 * of the Block Padding field.
						 */:
					while (generatedCompressed & 3) {
						if (generatedIn_pos == generatedIn_size) {
							return xz_ret.XZ_OK;
						} 
						if (generatedIn[generatedIn_pos++] != 0) {
							return xz_ret.XZ_DATA_ERROR;
						} 
						++generatedCompressed;
					}
					s.setSequence(.SEQ_BLOCK_CHECK);
			case .SEQ_STREAM_HEADER/*
						 * Stream Header is copied to s->temp, and then
						 * decoded from there. This way if the caller
						 * gives us only little input at a time, we can
						 * still keep the Stream Header decoding code
						 * simple. Similar approach is used in many places
						 * in this file.
						 */:
					if (!ModernizedCProgram.fill_temp(s, b)) {
						return xz_ret.XZ_OK/*
									 * If dec_stream_header() returns
									 * XZ_UNSUPPORTED_CHECK, it is still possible
									 * to continue decoding if working in multi-call
									 * mode. Thus, update s->sequence before calling
									 * dec_stream_header().
									 */;
					} 
					s.setSequence(.SEQ_BLOCK_START);
					xz_ret.ret = s.dec_stream_header();
					if (xz_ret.ret != xz_ret.XZ_OK) {
						return xz_ret.ret;
					} 
			case .SEQ_INDEX:
					xz_ret.ret = ModernizedCProgram.dec_index(s, b);
					if (xz_ret.ret != xz_ret.XZ_STREAM_END) {
						return xz_ret.ret;
					} 
					s.setSequence(.SEQ_INDEX_PADDING);
			case .SEQ_BLOCK_HEADER:
					if (!ModernizedCProgram.fill_temp(s, b)) {
						return xz_ret.XZ_OK;
					} 
					xz_ret.ret = s.dec_block_header();
					if (xz_ret.ret != xz_ret.XZ_OK) {
						return xz_ret.ret;
					} 
					s.setSequence(.SEQ_BLOCK_UNCOMPRESS);
			case .SEQ_INDEX_CRC32:
					xz_ret.ret = ModernizedCProgram.crc32_validate(s, b);
					if (xz_ret.ret != xz_ret.XZ_STREAM_END) {
						return xz_ret.ret;
					} 
					generatedTemp.setSize(12);
					s.setSequence(.SEQ_STREAM_FOOTER);
			case .SEQ_INDEX_PADDING:
					while ((generatedSize + (generatedIn_pos - generatedIn_start)) & 3) {
						if (generatedIn_pos == generatedIn_size) {
							s.index_update(b);
							return xz_ret.XZ_OK;
						} 
						if (generatedIn[generatedIn_pos++] != 0) {
							return xz_ret.XZ_DATA_ERROR;
						} 
					}
					s.index_update(/* Finish the CRC32 value and Index size. */b);
					if (!(/*Error: Function owner not recognized*/memcmp(generatedHash, generatedHash, /*Error: sizeof expression not supported yet*/) == /* Compare the hashes to validate the Index field. */0)) {
						return xz_ret.XZ_DATA_ERROR;
					} 
					s.setSequence(.SEQ_INDEX_CRC32);
			}
		}
	}
	public static xz_ret xz_dec_run(xz_dec s, xz_buf b) {
		size_t in_start = new size_t();
		size_t out_start = new size_t();
		xz_ret ret;
		xz_mode generatedMode = s.getMode();
		if (((generatedMode) == xz_mode.XZ_SINGLE)) {
			s.xz_dec_reset();
		} 
		Object generatedIn_pos = b.getIn_pos();
		in_start = generatedIn_pos;
		Object generatedOut_pos = b.getOut_pos();
		out_start = generatedOut_pos;
		xz_ret.ret = ModernizedCProgram.dec_main(s, b);
		Object generatedIn_size = b.getIn_size();
		boolean generatedAllow_buf_error = s.getAllow_buf_error();
		if (((generatedMode) == xz_mode.XZ_SINGLE)) {
			if (xz_ret.ret == xz_ret.XZ_OK) {
				xz_ret.ret = generatedIn_pos == generatedIn_size ? xz_ret.XZ_DATA_ERROR : xz_ret.XZ_BUF_ERROR;
			} 
			if (xz_ret.ret != xz_ret.XZ_STREAM_END) {
				b.setIn_pos(in_start);
				b.setOut_pos(out_start);
			} 
		}  else if (xz_ret.ret == xz_ret.XZ_OK && in_start == generatedIn_pos && out_start == generatedOut_pos) {
			if (generatedAllow_buf_error) {
				xz_ret.ret = xz_ret.XZ_BUF_ERROR;
			} 
			s.setAllow_buf_error(1);
		} else {
				s.setAllow_buf_error(0);
		} 
		return xz_ret.ret;
	}
	public static Object SetAutoMount(Object enable) {
		HANDLE hMountMgr = new HANDLE();
		DWORD size = new DWORD();
		BOOL ret = 0;
		hMountMgr = /*Error: Function owner not recognized*/CreateFileA("\\\\.\\MountPointManager", -1024 | -1024, -1024 | -1024, ((Object)0), 3, -1024, ((Object)0));
		if (hMountMgr == ((Object)0)) {
			return 0;
		} 
		ret = /*Error: Function owner not recognized*/DeviceIoControl(hMountMgr, (((((ULONG)(byte)'m')) << 16) | ((-1024 | -1024) << 14) | ((true) << 2) | (false)), enable, /*Error: sizeof expression not supported yet*/, ((Object)0), 0, size, ((Object)0));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hMountMgr);
		return ret;
	}
	public static Object GetAutoMount(Object enabled) {
		HANDLE hMountMgr = new HANDLE();
		DWORD size = new DWORD();
		BOOL ret = 0;
		if (enabled == ((Object)0)) {
			return 0;
		} 
		hMountMgr = /*Error: Function owner not recognized*/CreateFileA("\\\\.\\MountPointManager", -1024 | -1024, -1024 | -1024, ((Object)0), 3, -1024, ((Object)0));
		if (hMountMgr == ((Object)0)) {
			return 0;
		} 
		ret = /*Error: Function owner not recognized*/DeviceIoControl(hMountMgr, (((((ULONG)(byte)'m')) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, enabled, /*Error: sizeof expression not supported yet*/, size, ((Object)0));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hMountMgr);
		return ret/*
		 * Working with drive indexes quite risky (left unchecked,inadvertently passing 0 as
		 * index would return a handle to C:, which we might then proceed to unknowingly
		 * clear the MBR of!), so we mitigate the risk by forcing our indexes to belong to
		 * the specific range [DRIVE_INDEX_MIN; DRIVE_INDEX_MAX].
		 */;
	}
	/*
	 * Open a drive or volume with optional write and lock access
	 * Return INVALID_HANDLE_VALUE (/!\ which is DIFFERENT from NULL /!\) on failure.
	 */
	public static Object GetHandle(byte[] Path, Object bLockDrive, Object bWriteAccess, Object bWriteShare) {
		int i;
		BYTE access_mask = 0;
		DWORD size = new DWORD();
		uint64_t EndTime = new uint64_t();
		HANDLE hDrive = (HANDLE)(true);
		byte[] DevPath = new byte[260];
		if ((((((byte)Path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(Path)) < 5) || (Path[0] != (byte)'\\') || (Path[1] != (byte)'\\') || (Path[3] != (byte)'\\')) {
			;
		} 
		// Resolve a device path, so that we can look for that handle in case of access issues.if (/*Error: Function owner not recognized*/strncmp(((Path == ((Object)0)) ? "<NULL>" : Path), ((ModernizedCProgram.groot_name == ((Object)0)) ? "<NULL>" : ModernizedCProgram.groot_name), ModernizedCProgram.groot_len) == 0) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(DevPath, Path[ModernizedCProgram.groot_len], (((size_t)(((((byte)Path[ModernizedCProgram.groot_len]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(Path[ModernizedCProgram.groot_len])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)Path[ModernizedCProgram.groot_len]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(Path[ModernizedCProgram.groot_len])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
				((byte)DevPath)[(((size_t)(((((byte)Path[ModernizedCProgram.groot_len]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(Path[ModernizedCProgram.groot_len])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)Path[ModernizedCProgram.groot_len]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(Path[ModernizedCProgram.groot_len])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
			} while (0);
		}  else if (/*Error: Function owner not recognized*/QueryDosDeviceA(Path[4], DevPath, /*Error: sizeof expression not supported yet*/) == 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(DevPath, "???");
		} 
		for (i = 0; i < 150; i++) {
			hDrive = /*Error: Function owner not recognized*/CreateFileA(Path, -1024 | (bWriteAccess ? -1024 : 0), -1024 | (bWriteShare ? -1024 : 0), ((Object)0), 3, -1024, ((Object)0));
			if (hDrive != (HANDLE)(true)) {
				break;
			} 
			if ((/*Error: Function owner not recognized*/GetLastError() != -1024) && (/*Error: Function owner not recognized*/GetLastError() != -1024)) {
				break;
			} 
			if (i == 0) {
				ModernizedCProgram._uprintf("Waiting for access on %s [%s]...", Path, DevPath);
			}  else if (!bWriteShare && (i > 150 / 3)) {
				ModernizedCProgram._uprintf("Warning: Could not obtain exclusive rights. Retrying with write sharing enabled...");
				bWriteShare = 1;
				access_mask = ModernizedCProgram.SearchProcess(DevPath, 10000, 1, 1, 0) | -1024;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(15000 / 150);
		}// Try without FILE_SHARE_WRITE (unless specifically requested) so that// we won't be bothered by the OS or other apps when we set up our data.// However this means we might have to wait for an access gap...
		if (hDrive == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Could not open %s: %s", Path, ModernizedCProgram.WindowsErrorString());
			;
		} 
		if (bWriteAccess) {
			ModernizedCProgram._uprintf("Opened %s for %s write access", Path, bWriteShare ? "shared" : "exclusive");
		} 
		if (bLockDrive) {
			if (/*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((true) << 16) | ((true) << 14) | ((true) << 2) | (true)), ((Object)0), 0, ((Object)0), 0, size, ((Object)0))) {
				ModernizedCProgram._uprintf("I/O boundary checks disabled");
			} 
			EndTime = /*Error: Function owner not recognized*/GetTickCount64() + 15000;
			do {
				if (/*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, ((Object)0), 0, size, ((Object)0))) {
					;
				} 
				if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
					break;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(15000 / 150);
			} while (/*Error: Function owner not recognized*/GetTickCount64() < EndTime);
			ModernizedCProgram._uprintf("Could not lock access to %s: %s", Path, ModernizedCProgram.WindowsErrorString());
			if (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (access_mask == 0)) {
				access_mask = ModernizedCProgram.SearchProcess(DevPath, 10000, 1, 1, 0);
			} 
			if ((access_mask & -1024) != -1024) {
				do {
					if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
						hDrive = (HANDLE)(true);
					} 
				} while (0);
			} 
		} 
	}
	public static Byte GetPhysicalName(Object DriveIndex) {
		BOOL success = 0;
		byte[] physical_name = new byte[24];
		do {
			if ((int)DriveIndex < 0) {
				;
			} 
			(((DriveIndex >= -1024) && (DriveIndex <= -1024)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(DriveIndex >= DRIVE_INDEX_MIN) && (DriveIndex <= DRIVE_INDEX_MAX)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 238));
			if ((DriveIndex < -1024) || (DriveIndex > -1024)) {
				;
			} 
			DriveIndex -= -1024;
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(physical_name, /*Error: sizeof expression not supported yet*/, "\\\\.\\PhysicalDrive%lu", DriveIndex);
			(physical_name)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		success = 1;
	}
	public static Object GetPhysicalHandle(Object DriveIndex, Object bLockDrive, Object bWriteAccess, Object bWriteShare) {
		HANDLE hPhysical = (HANDLE)(true);
		byte PhysicalPath = ModernizedCProgram.GetPhysicalName(DriveIndex);
		hPhysical = ModernizedCProgram.GetHandle(PhysicalPath, bLockDrive, bWriteAccess, bWriteShare);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)PhysicalPath);
			PhysicalPath = ((Object)0);
		} while (0);
		return hPhysical/*
		 * Return the GUID volume name for the disk and partition specified, or NULL if not found.
		 * See http://msdn.microsoft.com/en-us/library/cc542456.aspx
		 * If PartitionOffset is 0, the offset is ignored and the first partition found is returned.
		 * The returned string is allocated and must be freed.
		 */;
	}
	public static Byte GetLogicalName(Object DriveIndex, Object PartitionOffset, Object bKeepTrailingBackslash, Object bSilent) {
		byte[] ignore_device = new byte[]{"\\Device\\CdRom", "\\Device\\Floppy"};
		byte volume_start = "\\\\?\\";
		byte ret = ((Object)0);
		byte[] volume_name = new byte[260];
		byte[] path = new byte[260];
		BOOL bPrintHeader = 1;
		HANDLE hDrive = (HANDLE)(true);
		HANDLE hVolume = (HANDLE)(true);
		VOLUME_DISK_EXTENTS_REDEF DiskExtents = new VOLUME_DISK_EXTENTS_REDEF();
		DWORD size = new DWORD();
		UINT drive_type = new UINT();
		StrArray found_name = new StrArray();
		uint64_t[] found_offset = new uint64_t[]{0};
		uint32_t i = new uint32_t();
		uint32_t j = new uint32_t();
		size_t len = new size_t();
		found_name.StrArrayCreate(16);
		do {
			if ((int)DriveIndex < 0) {
				;
			} 
			(((DriveIndex >= -1024) && (DriveIndex <= -1024)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(DriveIndex >= DRIVE_INDEX_MIN) && (DriveIndex <= DRIVE_INDEX_MAX)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 279));
			if ((DriveIndex < -1024) || (DriveIndex > -1024)) {
				;
			} 
			DriveIndex -= -1024;
		} while (0);
		Object generatedNumberOfDiskExtents = DiskExtents.getNumberOfDiskExtents();
		Object generatedExtents = DiskExtents.getExtents();
		Object generatedIndex = found_name.getIndex();
		for (i = 0; hDrive == (HANDLE)(true); i++) {
			if (i == 0) {
				hVolume = /*Error: Function owner not recognized*/FindFirstVolumeA(volume_name, /*Error: sizeof expression not supported yet*/);
				if (hVolume == (HANDLE)(true)) {
					do {
						if (!bSilent) {
							ModernizedCProgram._uprintf("Could not access first GUID volume: %s", ModernizedCProgram.WindowsErrorString());
						} 
					} while (0);
					;
				} 
			} else {
					if (!/*Error: Function owner not recognized*/FindNextVolumeA(hVolume, volume_name, /*Error: sizeof expression not supported yet*/)) {
						if (/*Error: Function owner not recognized*/GetLastError() != -1024) {
							do {
								if (!bSilent) {
									ModernizedCProgram._uprintf("Could not access next GUID volume: %s", ModernizedCProgram.WindowsErrorString());
								} 
							} while (0);
						} 
						break;
					} 
			} 
			len = ((((byte)volume_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(volume_name));
			((len > 4) ? (Object)0 : /*Error: Function owner not recognized*/_assert("len > 4", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 299));
			((/*Error: Function owner not recognized*/_strnicmp(((volume_name == ((Object)0)) ? "<NULL>" : volume_name), ((volume_start == ((Object)0)) ? "<NULL>" : volume_start), 4) == 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("safe_strnicmp(volume_name, volume_start, 4) == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 300));
			((volume_name[len - 1] == (byte)'\\') ? (Object)0 : /*Error: Function owner not recognized*/_assert("volume_name[len - 1] == '\\\\'", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 301));
			drive_type = /*Error: Function owner not recognized*/GetDriveTypeA(volume_name);
			if ((drive_type != 2) && (drive_type != 3)) {
				continue;
			} 
			volume_name[len - 1] = 0;
			if (/*Error: Function owner not recognized*/QueryDosDeviceA(volume_name[4], path, /*Error: sizeof expression not supported yet*/) == 0) {
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Failed to get device path for GUID volume '%s': %s", volume_name, ModernizedCProgram.WindowsErrorString());
					} 
				} while (0);
				continue;
			} 
			for (j = 0; (j < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/)) && (/*Error: Function owner not recognized*/_strnicmp(path, ignore_device[j], ((((byte)ignore_device[j]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ignore_device[j]))) != 0); j++) {
				;
			}
			if (j < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/)) {
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Skipping GUID volume for '%s'", path);
					} 
				} while (0);
				continue;
			} 
			hDrive = /*Error: Function owner not recognized*/CreateFileA(volume_name, -1024, -1024 | -1024, ((Object)0), 3, -1024, ((Object)0));
			if (hDrive == (HANDLE)(true)) {
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Could not open GUID volume '%s': %s", volume_name, ModernizedCProgram.WindowsErrorString());
					} 
				} while (0);
				continue;
			} 
			if ((!/*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((((ULONG)(byte)'V')) << 16) | ((true) << 14) | ((false) << 2) | (false)), ((Object)0), 0, DiskExtents, /*Error: sizeof expression not supported yet*/, size, ((Object)0))) || (size <= 0)) {
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Could not get Disk Extents: %s", ModernizedCProgram.WindowsErrorString());
					} 
				} while (0);
				do {
					if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
						hDrive = (HANDLE)(true);
					} 
				} while (0);
				continue;
			} 
			do {
				if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
					hDrive = (HANDLE)(true);
				} 
			} while (0);
			if (generatedNumberOfDiskExtents == 0) {
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Ignoring volume '%s' because it has no extents...", volume_name);
					} 
				} while (0);
				continue;
			} 
			if (generatedNumberOfDiskExtents != 1) {
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Ignoring volume '%s' because it has more than one extent (RAID?)...", volume_name);
					} 
				} while (0);
				continue;
			} 
			if (generatedExtents[0].getDiskNumber() != DriveIndex) {
				continue;
			} 
			if (generatedIndex == 16) {
				ModernizedCProgram._uprintf("Error: Trying to process a disk with more than %d partitions!", 16);
				;
			} 
			if (bKeepTrailingBackslash) {
				volume_name[len - 1] = (byte)'\\';
			} 
			found_offset[generatedIndex] = generatedExtents[0].getStartingOffset().getQuadPart();
			found_name.StrArrayAdd(volume_name, 1);
			if (!bSilent) {
				if (bPrintHeader) {
					bPrintHeader = 0;
					do {
						if (ModernizedCProgram.usb_debug) {
							ModernizedCProgram._uprintf("Windows volumes from this device:");
						} 
					} while (0);
				} 
				do {
					if (ModernizedCProgram.usb_debug) {
						ModernizedCProgram._uprintf("â? %s @%lld", volume_name, generatedExtents[0].getStartingOffset().getQuadPart());
					} 
				} while (0);
			} 
		}
		if (generatedIndex == 0) {
			;
		} 
		// Now process all the volumes we found, and try to match one with our partition offsetfor (i = 0; (i < generatedIndex) && (PartitionOffset != 0) && (PartitionOffset != found_offset[i]); i++) {
			;
		}
		Object generatedString = found_name.getString();
		if (i < generatedIndex) {
			ret = /*Error: Function owner not recognized*/_strdup(generatedString[i]);
		} else {
				ret = ModernizedCProgram.AltGetLogicalName(DriveIndex + -1024, PartitionOffset, bKeepTrailingBackslash, bSilent);
				if ((ret != ((Object)0)) && (/*Error: Function owner not recognized*/strchr(ret, (byte)' ') != ((Object)0))) {
					ModernizedCProgram._uprintf("Warning: Using physical device to access partition data");
				} 
		} 
		found_name.StrArrayDestroy();
		return ret/*
		 * Alternative version of the above, needed because some volumes, such as ESPs, are not listed
		 * by Windows, be it with VDS or other APIs.
		 * For these, we return the "\\?\GLOBALROOT\Device\HarddiskVolume#" identifier that matches
		 * our "Harddisk#Partition#", as reported by QueryDosDevice().
		 * The returned string is allocated and must be freed.
		*/;
	}
	public static Byte AltGetLogicalName(Object DriveIndex, Object PartitionOffset, Object bKeepTrailingBackslash, Object bSilent) {
		BOOL matching_drive = (DriveIndex == ModernizedCProgram.SelectedDrive.getDeviceNumber());
		DWORD i = new DWORD();
		byte ret = ((Object)0);
		byte[] volume_name = new byte[260];
		byte[] path = new byte[64];
		do {
			if ((int)DriveIndex < 0) {
				;
			} 
			(((DriveIndex >= -1024) && (DriveIndex <= -1024)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(DriveIndex >= DRIVE_INDEX_MIN) && (DriveIndex <= DRIVE_INDEX_MAX)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 402));
			if ((DriveIndex < -1024) || (DriveIndex > -1024)) {
				;
			} 
			DriveIndex -= -1024;
		} while (0);
		// Match the offset to a partition indexif (PartitionOffset == 0) {
			i = 0;
		}  else if (matching_drive) {
			for (i = 0; (i < 16) && (PartitionOffset != ModernizedCProgram.SelectedDrive.getPartitionOffset()[i]); i++) {
				;
			}
			if (i >= 16) {
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Error: Could not find a partition at offset %lld on this disk", PartitionOffset);
					} 
				} while (0);
				;
			} 
		} else {
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Error: Searching for a partition on a non matching disk");
					} 
				} while (0);
				;
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(path, /*Error: sizeof expression not supported yet*/, "Harddisk%luPartition%lu", DriveIndex, i + 1);
			(path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(volume_name, ModernizedCProgram.groot_name, (((size_t)(((((byte)ModernizedCProgram.groot_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.groot_name)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.groot_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.groot_name)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)volume_name)[(((size_t)(((((byte)ModernizedCProgram.groot_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.groot_name)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.groot_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.groot_name)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);
		if (!/*Error: Function owner not recognized*/QueryDosDeviceA(path, volume_name[ModernizedCProgram.groot_len], (DWORD)(260 - ModernizedCProgram.groot_len)) || (/*Error: Function owner not recognized*/strlen(volume_name) < 20)) {
			do {
				if (!bSilent) {
					ModernizedCProgram._uprintf("Could not find a DOS volume name for '%s': %s", path, ModernizedCProgram.WindowsErrorString());
				} 
			} while (0);
			if (!matching_drive) {
				;
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(volume_name, /*Error: sizeof expression not supported yet*/, "\\\\.\\PhysicalDrive%lu%s %I64u %I64u", DriveIndex, bKeepTrailingBackslash ? "\\" : "", ModernizedCProgram.SelectedDrive.getPartitionOffset()[i], ModernizedCProgram.SelectedDrive.getPartitionSize()[i]);
				(volume_name)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
		}  else if (bKeepTrailingBackslash) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(volume_name, "\\", (((size_t)(((((byte)"\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)volume_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(volume_name)) - 1)) ? ((size_t)(((((byte)"\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)volume_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(volume_name)) - 1))));
		} 
		ret = /*Error: Function owner not recognized*/_strdup(volume_name);
	}
	public static Object RefreshLayout(Object DriveIndex) {
		BOOL r = 0;
		HRESULT hr = new HRESULT();
		wchar_t[] wPhysicalName = new wchar_t();
		IVdsServiceLoader pLoader = new IVdsServiceLoader();
		IVdsService pService = new IVdsService();
		IEnumVdsObject pEnum = new IEnumVdsObject();
		do {
			if ((int)DriveIndex < 0) {
				;
			} 
			(((DriveIndex >= -1024) && (DriveIndex <= -1024)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(DriveIndex >= DRIVE_INDEX_MIN) && (DriveIndex <= DRIVE_INDEX_MAX)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 447));
			if ((DriveIndex < -1024) || (DriveIndex > -1024)) {
				;
			} 
			DriveIndex -= -1024;
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/wnsprintfA(wPhysicalName, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), L"\\\\?\\PhysicalDrive%lu", DriveIndex);
		// Initialize COMdo {
			(Object)(/*Error: Function owner not recognized*/CoInitializeEx(((Object)0), tagCOINIT.COINIT_APARTMENTTHREADED));
		} while (0);
		do {
			(Object)(/*Error: Function owner not recognized*/CoInitializeSecurity(((Object)0), -1, ((Object)0), ((Object)0), 2, 3, ((Object)0), 0, ((Object)0)));
		} while (0);
		// Create a VDS Loader Instance// Create a VDS Loader Instancehr = /*Error: Function owner not recognized*/CoCreateInstance(ModernizedCProgram.CLSID_VdsLoader, ((Object)0), tagCLSCTX.CLSCTX_LOCAL_SERVER | tagCLSCTX.CLSCTX_REMOTE_SERVER, ModernizedCProgram.IID_IVdsServiceLoader, (Object)pLoader);
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not create VDS Loader Instance: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Load the VDS Service// Load the VDS Servicehr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pLoader, L"", pService);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pLoader);
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not load VDS Service: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Wait for the Service to become ready if needed// Wait for the Service to become ready if neededhr = (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pService));
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("VDS Service is not ready: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Query the VDS Service Providers// Query the VDS Service Providershr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pService, VDS_QUERY_SOFTWARE_PROVIDERS, pEnum);
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not query VDS Service Providers: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Remove mountpoints// Remove mountpointshr = (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pService));
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not clean up VDS mountpoints: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Invoke layout refresh// Invoke layout refreshhr = (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pService));
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not refresh VDS layout: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Force re-enum// Force re-enumhr = (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pService));
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not refresh VDS layout: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		r = 1;
	}
	public static Object DeletePartitions(Object DriveIndex) {
		BOOL r = 0;
		HRESULT hr = new HRESULT();
		ULONG ulFetched = new ULONG();
		wchar_t[] wPhysicalName = new wchar_t();
		IVdsServiceLoader pLoader = new IVdsServiceLoader();
		IVdsService pService = new IVdsService();
		IEnumVdsObject pEnum = new IEnumVdsObject();
		IUnknown pUnk = new IUnknown();
		do {
			if ((int)DriveIndex < 0) {
				;
			} 
			(((DriveIndex >= -1024) && (DriveIndex <= -1024)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(DriveIndex >= DRIVE_INDEX_MIN) && (DriveIndex <= DRIVE_INDEX_MAX)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 533));
			if ((DriveIndex < -1024) || (DriveIndex > -1024)) {
				;
			} 
			DriveIndex -= -1024;
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/wnsprintfA(wPhysicalName, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), L"\\\\?\\PhysicalDrive%lu", DriveIndex);
		// Initialize COMdo {
			(Object)(/*Error: Function owner not recognized*/CoInitializeEx(((Object)0), tagCOINIT.COINIT_APARTMENTTHREADED));
		} while (0);
		do {
			(Object)(/*Error: Function owner not recognized*/CoInitializeSecurity(((Object)0), -1, ((Object)0), ((Object)0), 2, 3, ((Object)0), 0, ((Object)0)));
		} while (0);
		// Create a VDS Loader Instance// Create a VDS Loader Instancehr = /*Error: Function owner not recognized*/CoCreateInstance(ModernizedCProgram.CLSID_VdsLoader, ((Object)0), tagCLSCTX.CLSCTX_LOCAL_SERVER | tagCLSCTX.CLSCTX_REMOTE_SERVER, ModernizedCProgram.IID_IVdsServiceLoader, (Object)pLoader);
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not create VDS Loader Instance: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Load the VDS Service// Load the VDS Servicehr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pLoader, L"", pService);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pLoader);
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not load VDS Service: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Wait for the Service to become ready if needed// Wait for the Service to become ready if neededhr = (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pService));
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("VDS Service is not ready: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Query the VDS Service Providers// Query the VDS Service Providershr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pService, VDS_QUERY_SOFTWARE_PROVIDERS, pEnum);
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not query VDS Service Providers: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		while (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pEnum, 1, pUnk, ulFetched) == ((HRESULT)-1024)) {
			IVdsProvider pProvider = new IVdsProvider();
			IVdsSwProvider pSwProvider = new IVdsSwProvider();
			IEnumVdsObject pEnumPack = new IEnumVdsObject();
			IUnknown pPackUnk = new IUnknown();
			hr = /*Error: Function owner not recognized*/IUnknown_QueryInterface(pUnk, ModernizedCProgram.IID_IVdsProvider, (Object)pProvider);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IUnknown_Release(pUnk);
			if (hr != ((HRESULT)-1024)) {
				do {
					if (hr == ((HRESULT)-1024)) {
						hr = -1024 | (3 << 16) | -1024;
					} 
					ModernizedCProgram.FormatStatus = hr;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
				} while (0);
				ModernizedCProgram._uprintf("Could not get VDS Provider: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pProvider, ModernizedCProgram.IID_IVdsSwProvider, (Object)pSwProvider);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pProvider);
			if (hr != ((HRESULT)-1024)) {
				do {
					if (hr == ((HRESULT)-1024)) {
						hr = -1024 | (3 << 16) | -1024;
					} 
					ModernizedCProgram.FormatStatus = hr;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
				} while (0);
				ModernizedCProgram._uprintf("Could not get VDS Software Provider: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pSwProvider, pEnumPack);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pSwProvider);
			if (hr != ((HRESULT)-1024)) {
				do {
					if (hr == ((HRESULT)-1024)) {
						hr = -1024 | (3 << 16) | -1024;
					} 
					ModernizedCProgram.FormatStatus = hr;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
				} while (0);
				ModernizedCProgram._uprintf("Could not get VDS Software Provider Packs: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			while (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pEnumPack, 1, pPackUnk, ulFetched) == ((HRESULT)-1024)) {
				IVdsPack pPack = new IVdsPack();
				IEnumVdsObject pEnumDisk = new IEnumVdsObject();
				IUnknown pDiskUnk = new IUnknown();
				hr = /*Error: Function owner not recognized*/IUnknown_QueryInterface(pPackUnk, ModernizedCProgram.IID_IVdsPack, (Object)pPack);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IUnknown_Release(pPackUnk);
				if (hr != ((HRESULT)-1024)) {
					do {
						if (hr == ((HRESULT)-1024)) {
							hr = -1024 | (3 << 16) | -1024;
						} 
						ModernizedCProgram.FormatStatus = hr;
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
					} while (0);
					ModernizedCProgram._uprintf("Could not query VDS Software Provider Pack: %s", ModernizedCProgram.WindowsErrorString());
					;
				} 
				hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pPack, pEnumDisk);
				if (hr != ((HRESULT)-1024)) {
					do {
						if (hr == ((HRESULT)-1024)) {
							hr = -1024 | (3 << 16) | -1024;
						} 
						ModernizedCProgram.FormatStatus = hr;
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
					} while (0);
					ModernizedCProgram._uprintf("Could not query VDS disks: %s", ModernizedCProgram.WindowsErrorString());
					;
				} 
				while (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pEnumDisk, 1, pDiskUnk, ulFetched) == ((HRESULT)-1024)) {
					 diskprop = new ();
					 prop_array = new ();
					LONG i = new LONG();
					LONG prop_array_size = new LONG();
					IVdsDisk pDisk = new IVdsDisk();
					IVdsAdvancedDisk pAdvancedDisk = new IVdsAdvancedDisk();
					hr = /*Error: Function owner not recognized*/IUnknown_QueryInterface(pDiskUnk, ModernizedCProgram.IID_IVdsDisk, (Object)pDisk);
					if (hr != ((HRESULT)-1024)) {
						do {
							if (hr == ((HRESULT)-1024)) {
								hr = -1024 | (3 << 16) | -1024;
							} 
							ModernizedCProgram.FormatStatus = hr;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
						} while (0);
						ModernizedCProgram._uprintf("Could not query VDS Disk Interface: %s", ModernizedCProgram.WindowsErrorString());
						;
					} 
					hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pDisk, diskprop);
					if (hr != ((HRESULT)-1024)) {
						do {
							if (hr == ((HRESULT)-1024)) {
								hr = -1024 | (3 << 16) | -1024;
							} 
							ModernizedCProgram.FormatStatus = hr;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
						} while (0);
						ModernizedCProgram._uprintf("Could not query VDS Disk Properties: %s", ModernizedCProgram.WindowsErrorString());
						;
					} 
					if (/*Error: Function owner not recognized*/_wcsicmp(wPhysicalName, diskprop.getPwszName()) != 0) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pDisk);
						continue;
					} 
					hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pDisk, ModernizedCProgram.IID_IVdsAdvancedDisk, (Object)pAdvancedDisk);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pDisk);
					if (hr != ((HRESULT)-1024)) {
						do {
							if (hr == ((HRESULT)-1024)) {
								hr = -1024 | (3 << 16) | -1024;
							} 
							ModernizedCProgram.FormatStatus = hr;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
						} while (0);
						ModernizedCProgram._uprintf("Could not access VDS Advanced Disk interface: %s", ModernizedCProgram.WindowsErrorString());
						;
					} 
					hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pAdvancedDisk, prop_array, prop_array_size);
					if (hr == ((HRESULT)-1024)) {
						ModernizedCProgram._uprintf("Deleting ALL partition(s) from disk '%S':", diskprop.getPwszName());
						for (i = 0; i < prop_array_size; i++) {
							ModernizedCProgram._uprintf("â? Partition %d (offset: %lld, size: %s)", prop_array[i].getUlPartitionNumber(), prop_array[i].getUllOffset(), ModernizedCProgram.SizeToHumanReadable(prop_array[i].getUllSize(), 0, 0));
							hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pAdvancedDisk, prop_array[i].getUllOffset(), 1, 1);
							if (hr != ((HRESULT)-1024)) {
								r = 0;
								do {
									if (hr == ((HRESULT)-1024)) {
										hr = -1024 | (3 << 16) | -1024;
									} 
									ModernizedCProgram.FormatStatus = hr;
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
								} while (0);
								ModernizedCProgram._uprintf("Could not delete partitions: %s", ModernizedCProgram.WindowsErrorString());
							} 
						}
						r = 1;
					} else {
							ModernizedCProgram._uprintf("No partition to delete on disk '%S'", diskprop.getPwszName());
							r = 1;
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CoTaskMemFree(prop_array);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pAdvancedDisk);
					;
				}
			}
		}
	}
	/* Wait for a logical drive to reappear - Used when a drive has just been repartitioned */
	public static Object WaitForLogical(Object DriveIndex, Object PartitionOffset) {
		uint64_t EndTime = new uint64_t();
		byte LogicalPath = ((Object)0);
		// GetLogicalName() calls may be slow, so use the system time to
		// make sure we don't spend more than DRIVE_ACCESS_TIMEOUT in wait.// make sure we don't spend more than DRIVE_ACCESS_TIMEOUT in wait.EndTime = /*Error: Function owner not recognized*/GetTickCount64() + 15000;
		do {
			LogicalPath = ModernizedCProgram.GetLogicalName(DriveIndex, PartitionOffset, 0, 1);
			if ((LogicalPath != ((Object)0)) && (/*Error: Function owner not recognized*/strncmp(LogicalPath, ModernizedCProgram.groot_name, ModernizedCProgram.groot_len) != 0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(LogicalPath);
				return 1;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(LogicalPath);
			if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
				return 0;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(15000 / 150);
		} while (/*Error: Function owner not recognized*/GetTickCount64() < EndTime);
		ModernizedCProgram._uprintf("Timeout while waiting for logical drive");
		return 0/*
		 * Obtain a handle to the volume identified by DriveIndex + PartitionIndex
		 * Returns INVALID_HANDLE_VALUE on error or NULL if no logical path exists (typical
		 * of unpartitioned drives)
		 */;
	}
	public static Object GetLogicalHandle(Object DriveIndex, Object PartitionOffset, Object bLockDrive, Object bWriteAccess, Object bWriteShare) {
		HANDLE hLogical = (HANDLE)(true);
		byte LogicalPath = ModernizedCProgram.GetLogicalName(DriveIndex, PartitionOffset, 0, 0);
		if (LogicalPath == ((Object)0)) {
			ModernizedCProgram._uprintf("No logical drive found (unpartitioned?)");
			return ((Object)0);
		} 
		hLogical = ModernizedCProgram.GetHandle(LogicalPath, bLockDrive, bWriteAccess, bWriteShare);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(LogicalPath);
		return hLogical/*
		 * Who would have thought that Microsoft would make it so unbelievably hard to
		 * get the frickin' device number for a drive? You have to use TWO different
		 * methods to have a chance to get it!
		 */;
	}
	public static int GetDriveNumber(Object hDrive, Byte path) {
		STORAGE_DEVICE_NUMBER_REDEF DeviceNumber = new STORAGE_DEVICE_NUMBER_REDEF();
		VOLUME_DISK_EXTENTS_REDEF DiskExtents = new VOLUME_DISK_EXTENTS_REDEF();
		DWORD size = new DWORD();
		int r = -1;
		Object generatedNumberOfDiskExtents = DiskExtents.getNumberOfDiskExtents();
		Object generatedDeviceNumber = DeviceNumber.getDeviceNumber();
		Object generatedExtents = DiskExtents.getExtents();
		if (!/*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((((ULONG)(byte)'V')) << 16) | ((true) << 14) | ((false) << 2) | (false)), ((Object)0), 0, DiskExtents, /*Error: sizeof expression not supported yet*/, size, ((Object)0)) || (size <= 0) || (generatedNumberOfDiskExtents < 1)) {
			if (!/*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, DeviceNumber, /*Error: sizeof expression not supported yet*/, size, ((Object)0)) || (size <= 0)) {
				ModernizedCProgram._uprintf("Could not get device number for device %s: %s", path, ModernizedCProgram.WindowsErrorString());
				return -1;
			} 
			r = (int)generatedDeviceNumber;
		}  else if (generatedNumberOfDiskExtents >= 2) {
			ModernizedCProgram._uprintf("Ignoring drive '%s' as it spans multiple disks (RAID?)", path);
			return -1;
		} else {
				r = (int)generatedExtents[0].getDiskNumber();
		} 
		if (r >= (-1024 - -1024)) {
			ModernizedCProgram._uprintf("Device Number for device %s is too big (%d) - ignoring device", path, r);
			return -1;
		} 
		return r/*
		 * Returns the drive letters for all volumes located on the drive identified by DriveIndex,
		 * as well as the drive type. This is used as base for the 2 function calls that follow.
		 */;
	}
	public static Object _GetDriveLettersAndType(Object DriveIndex, byte[] drive_letters, Object drive_type) {
		DWORD size = new DWORD();
		BOOL r = 0;
		HANDLE hDrive = (HANDLE)(true);
		UINT _drive_type = new UINT();
		 io_status_block = new ();
		 file_fs_device_info = new ();
		int i = 0;
		int drive_number;
		byte drive;
		byte[] drives = new byte[26 * 4 + /* "D:\", "E:\", etc., plus one NUL */1];
		byte[] logical_drive = "\\\\.\\#:";
		if (ModernizedCProgram.pfNtQueryVolumeInformationFile == ((Object)0)) {
			ModernizedCProgram.pfNtQueryVolumeInformationFile = (NtQueryVolumeInformationFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Ntdll"), "NtQueryVolumeInformationFile");
		} 
		if (drive_letters != ((Object)0)) {
			drive_letters[0] = 0;
		} 
		if (drive_type != ((Object)0)) {
			drive_type = 0;
		} 
		do {
			if ((int)DriveIndex < 0) {
				;
			} 
			(((DriveIndex >= -1024) && (DriveIndex <= -1024)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(DriveIndex >= DRIVE_INDEX_MIN) && (DriveIndex <= DRIVE_INDEX_MAX)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 829));
			if ((DriveIndex < -1024) || (DriveIndex > -1024)) {
				;
			} 
			DriveIndex -= -1024;
		} while (0);// This call is weird... The buffer needs to have an extra NUL, but you're// supposed to provide the size without the extra NUL. And the returned size// does not include the NUL either *EXCEPT* if your buffer is too small...
		// But then again, this doesn't hold true if you have a 105 byte buffer and// pass a 4*26=104 size, as the the call will return 105 (i.e. *FAILURE*)// instead of 104 as it should => screw Microsoft: We'll include the NUL// always, as each drive string is at least 4 chars long anyway.// But then again, this doesn't hold true if you have a 105 byte buffer and// pass a 4*26=104 size, as the the call will return 105 (i.e. *FAILURE*)// instead of 104 as it should => screw Microsoft: We'll include the NUL// always, as each drive string is at least 4 chars long anyway.size = /*Error: Function owner not recognized*/GetLogicalDriveStringsA(/*Error: sizeof expression not supported yet*/, drives);
		if (size == 0) {
			ModernizedCProgram._uprintf("GetLogicalDriveStrings failed: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		if (size > /*Error: sizeof expression not supported yet*/) {
			ModernizedCProgram._uprintf("GetLogicalDriveStrings: Buffer too small (required %d vs. %d)", size, /*Error: sizeof expression not supported yet*/);
			;
		} 
		// Required to detect drives that don't have volumes assigned// Required to detect drives that don't have volumes assignedr = 1;
		for (drive = drives; drive; drive += ((((byte)drive) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(drive)) + 1) {
			if (!/*Error: Function owner not recognized*/isalpha(drive)) {
				continue;
			} 
			drive = (byte)/*Error: Function owner not recognized*/toupper((int)drive);
			_drive_type = /*Error: Function owner not recognized*/GetDriveTypeA(drive);
			if ((_drive_type != 2) && (_drive_type != 3)) {
				continue;
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(logical_drive, /*Error: sizeof expression not supported yet*/, "\\\\.\\%c:", drive[0]);
				(logical_drive)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			hDrive = /*Error: Function owner not recognized*/CreateFileA(logical_drive, -1024, -1024 | -1024, ((Object)0), 3, -1024, ((Object)0));
			if (hDrive == (HANDLE)(true)) {
				continue;
			} 
			if ((ModernizedCProgram.pfNtQueryVolumeInformationFile != ((Object)0)) && (/*Error: Function owner not recognized*/pfNtQueryVolumeInformationFile(hDrive, io_status_block, file_fs_device_info, /*Error: sizeof expression not supported yet*/, FileFsDeviceInformation) == -1024) && (file_fs_device_info.getCharacteristics() & -1024)) {
				continue;
			} 
			drive_number = ModernizedCProgram.GetDriveNumber(hDrive, logical_drive);
			do {
				if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
					hDrive = (HANDLE)(true);
				} 
			} while (0);
			if (drive_number == DriveIndex) {
				r = 1;
				if (drive_letters != ((Object)0)) {
					drive_letters[i++] = drive;
				} 
				if (drive_type != ((Object)0)) {
					drive_type = _drive_type;
				} 
			} 
		}
		return r;
	}
	// Could have used a #define, but this is clearer
	public static Object GetDriveLetters(Object DriveIndex, Byte drive_letters) {
		return ModernizedCProgram._GetDriveLettersAndType(DriveIndex, drive_letters, ((Object)0));
	}
	// There's already a GetDriveType in the Windows API
	public static Object GetDriveTypeFromIndex(Object DriveIndex) {
		UINT drive_type = new UINT();
		ModernizedCProgram._GetDriveLettersAndType(DriveIndex, ((Object)0), drive_type);
		return drive_type/*
		 * Return the next unused drive letter from the system
		 */;
	}
	public static byte GetUnusedDriveLetter() {
		DWORD size = new DWORD();
		byte drive_letter = (byte)'Z' + 1;
		byte drive;
		byte[] drives = new byte[26 * 4 + /* "D:\", "E:\", etc., plus one NUL */1];
		size = /*Error: Function owner not recognized*/GetLogicalDriveStringsA(/*Error: sizeof expression not supported yet*/, drives);
		if (size == 0) {
			ModernizedCProgram._uprintf("GetLogicalDriveStrings failed: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		if (size > /*Error: sizeof expression not supported yet*/) {
			ModernizedCProgram._uprintf("GetLogicalDriveStrings: Buffer too small (required %d vs. %d)", size, /*Error: sizeof expression not supported yet*/);
			;
		} 
		for (drive_letter = (byte)'C'; drive_letter <= (byte)'Z'; drive_letter++) {
			for (drive = drives; drive; drive += ((((byte)drive) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(drive)) + 1) {
				if (!/*Error: Function owner not recognized*/isalpha(drive)) {
					continue;
				} 
				if (drive_letter == (byte)/*Error: Function owner not recognized*/toupper((int)drive)) {
					break;
				} 
			}
			if (!drive) {
				break;
			} 
		}
	}
	public static Object GetDriveLabel(Object DriveIndex, byte[] letters, Byte label) {
		HANDLE hPhysical = new HANDLE();
		DWORD size = new DWORD();
		DWORD error = new DWORD();
		byte[] VolumeLabel = new byte[]{0};
		byte[] DrivePath = "#:\\";
		byte[] AutorunPath = "#:\\autorun.inf";
		byte AutorunLabel = ((Object)0);
		WCHAR[] VolumeName = new WCHAR[]{0};
		WCHAR[] FileSystemName = new WCHAR();
		DWORD VolumeSerialNumber = new DWORD();
		DWORD MaximumComponentLength = new DWORD();
		DWORD FileSystemFlags = new DWORD();
		label = "NO_LABEL";
		if (!ModernizedCProgram.GetDriveLetters(DriveIndex, letters)) {
			return 0;
		} 
		if (letters[0] == 0) {
			HANDLE h = ModernizedCProgram.GetLogicalHandle(DriveIndex, 0, 0, 0, 0);
			if (/*Error: Function owner not recognized*/GetVolumeInformationByHandleW(h, VolumeName, 64, VolumeSerialNumber, MaximumComponentLength, FileSystemFlags, FileSystemName, 64)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, VolumeName, -1, VolumeLabel, /*Error: sizeof expression not supported yet*/, ((Object)0), ((Object)0));
				label = (VolumeLabel[0] != 0) ? VolumeLabel : "NO_LABEL";
			} 
			return 1;
		} 
		// Even if we don't have a letter, try to obtain the label of the first partition
		// We only care about an autorun.inf if we have a single volume// We only care about an autorun.inf if we have a single volumeAutorunPath[0] = letters[0];
		DrivePath[0] = letters[0]// Try to read an extended label from autorun first. Fallback to regular label if not found.;// Try to read an extended label from autorun first. Fallback to regular label if not found.
		// In the case of card readers with no card, users can get an annoying popup asking them// to insert media. Use IOCTL_STORAGE_CHECK_VERIFY to prevent this// In the case of card readers with no card, users can get an annoying popup asking them// to insert media. Use IOCTL_STORAGE_CHECK_VERIFY to prevent thishPhysical = ModernizedCProgram.GetPhysicalHandle(DriveIndex, 0, 0, 1);
		if (/*Error: Function owner not recognized*/DeviceIoControl(hPhysical, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, ((Object)0), 0, size, ((Object)0))) {
			AutorunLabel = ModernizedCProgram.get_token_data_file_indexed("label", AutorunPath, 1);
		}  else if (/*Error: Function owner not recognized*/GetLastError() == -1024) {
			ModernizedCProgram._uprintf("Ignoring autorun.inf label for drive %c: %s", letters[0], (((/*Error: Function owner not recognized*/GetLastError()) & -1024) == -1024) ? "No media" : ModernizedCProgram.WindowsErrorString());
		} 
		do {
			if ((hPhysical != (HANDLE)(true)) && (hPhysical != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hPhysical);
				hPhysical = (HANDLE)(true);
			} 
		} while (0);
		if (AutorunLabel != ((Object)0)) {
			ModernizedCProgram._uprintf("Using autorun.inf label for drive %c: '%s'", letters[0], AutorunLabel);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(VolumeLabel, AutorunLabel, (((size_t)(((((byte)AutorunLabel) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(AutorunLabel)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)AutorunLabel) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(AutorunLabel)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
				((byte)VolumeLabel)[(((size_t)(((((byte)AutorunLabel) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(AutorunLabel)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)AutorunLabel) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(AutorunLabel)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)AutorunLabel);
				AutorunLabel = ((Object)0);
			} while (0);
			label = VolumeLabel;
		}  else if (ModernizedCProgram.GetVolumeInformationU(DrivePath, VolumeLabel, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), ((Object)0), ((Object)0), ((Object)0), ((Object)0), 0) && (VolumeLabel[0] != 0)) {
			label = VolumeLabel;
		} else {
				error = /*Error: Function owner not recognized*/GetLastError();
				label = (byte)ModernizedCProgram.GetExtFsLabel(DriveIndex, 0);
				if (label == ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(error);
					;
					label = "NO_LABEL";
				} 
		} 
		return 1/*
		 * Return the drive size
		 */;
	}
	public static Object GetDriveSize(Object DriveIndex) {
		BOOL r = new BOOL();
		HANDLE hPhysical = new HANDLE();
		DWORD size = new DWORD();
		BYTE[] geometry = new BYTE();
		PDISK_GEOMETRY_EX DiskGeometry = (PDISK_GEOMETRY_EX)(Object)geometry;
		hPhysical = ModernizedCProgram.GetPhysicalHandle(DriveIndex, 0, 0, 1);
		if (hPhysical == (HANDLE)(true)) {
			return 0;
		} 
		r = /*Error: Function owner not recognized*/DeviceIoControl(hPhysical, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, geometry, /*Error: sizeof expression not supported yet*/, size, ((Object)0));
		do {
			if ((hPhysical != (HANDLE)(true)) && (hPhysical != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hPhysical);
				hPhysical = (HANDLE)(true);
			} 
		} while (0);
		if (!r || size <= 0) {
			return 0;
		} 
		return DiskGeometry.getDiskSize().getQuadPart();
	}
	public static Object IsMediaPresent(Object DriveIndex) {
		BOOL r = new BOOL();
		HANDLE hPhysical = new HANDLE();
		DWORD size = new DWORD();
		BYTE[] geometry = new BYTE();
		hPhysical = ModernizedCProgram.GetPhysicalHandle(DriveIndex, 0, 0, 1);
		r = /*Error: Function owner not recognized*/DeviceIoControl(hPhysical, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, geometry, /*Error: sizeof expression not supported yet*/, size, ((Object)0)) && (size > 0);
		do {
			if ((hPhysical != (HANDLE)(true)) && (hPhysical != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hPhysical);
				hPhysical = (HANDLE)(true);
			} 
		} while (0);
		return r;
	}
	// Returns TRUE if the drive seems bootable, FALSE otherwise
	public static Object AnalyzeMBR(Object hPhysicalDrive, Object TargetName, Object bSilent) {
		byte mbr_name = "Master Boot Record";
		FAKE_FD fake_fd = new FAKE_FD(0);
		FILE fp = (FILE)fake_fd;
		int i;
		fake_fd.set_handle((byte)hPhysicalDrive);
		ModernizedCProgram.set_bytes_per_sector(ModernizedCProgram.SelectedDrive.getSectorSize());
		if (!fp.is_br()) {
			do {
				if (!bSilent) {
					ModernizedCProgram._uprintf("%s does not have an x86 %s", TargetName, mbr_name);
				} 
			} while (0);
			return 0;
		} 
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fp)) {
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("%s has a %s %s", TargetName, known_mbr[i].getStr(), mbr_name);
					} 
				} while (0);
				return 1;
			} 
		}
		do {
			if (!bSilent) {
				ModernizedCProgram._uprintf("%s has an unknown %s", TargetName, mbr_name);
			} 
		} while (0);
		return 1;
	}
	public static Object AnalyzePBR(Object hLogicalVolume) {
		byte pbr_name = "Partition Boot Record";
		FAKE_FD fake_fd = new FAKE_FD(0);
		FILE fp = (FILE)fake_fd;
		int i;
		fake_fd.set_handle((byte)hLogicalVolume);
		ModernizedCProgram.set_bytes_per_sector(ModernizedCProgram.SelectedDrive.getSectorSize());
		if (!fp.is_br()) {
			ModernizedCProgram._uprintf("Volume does not have an x86 %s", pbr_name);
			return 0;
		} 
		if (fp.is_fat_16_br() || fp.is_fat_32_br()) {
			for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
				if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fp)) {
					ModernizedCProgram._uprintf("Drive has a %s %s", known_pbr[i].getStr(), pbr_name);
					return 1;
				} 
			}
			ModernizedCProgram._uprintf("Volume has an unknown FAT16 or FAT32 %s", pbr_name);
		} else {
				ModernizedCProgram._uprintf("Volume has an unknown %s", pbr_name);
		} 
		return 1/*
		 * Fill the drive properties (size, FS, etc)
		 * Returns TRUE if the drive has a partition that can be mounted in Windows, FALSE otherwise
		 */;
	}
	public static Object GetDrivePartitionData(Object DriveIndex, byte[] FileSystemName, Object FileSystemNameSize, Object bSilent) {
		// MBR partition types that can be mounted in Windowsuint8_t[] mbr_mountable = new uint8_t[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		BOOL r = new BOOL();
		BOOL ret = 0;
		BOOL isUefiNtfs = new BOOL();
		HANDLE hPhysical = new HANDLE();
		DWORD size = new DWORD();
		DWORD i = new DWORD();
		DWORD j = new DWORD();
		DWORD super_floppy_disk = 0;
		BYTE[] geometry = new BYTE[]{0};
		BYTE[] layout = new BYTE[]{0};
		BYTE part_type = new BYTE();
		PDISK_GEOMETRY_EX DiskGeometry = (PDISK_GEOMETRY_EX)(Object)geometry;
		PDRIVE_LAYOUT_INFORMATION_EX DriveLayout = (PDRIVE_LAYOUT_INFORMATION_EX)(Object)layout;
		byte volume_name;
		byte buf;
		if (FileSystemName == ((Object)0)) {
			return 0;
		} 
		ModernizedCProgram.SelectedDrive.setNPartitions(0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.SelectedDrive.getPartitionOffset(), 0, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.SelectedDrive.getPartitionSize(), 0, /*Error: sizeof expression not supported yet*/)// Populate the filesystem data;// Populate the filesystem data
		FileSystemName[0] = 0;
		volume_name = ModernizedCProgram.GetLogicalName(DriveIndex, 0, 1, 0);
		if ((volume_name == ((Object)0)) || (!/*Error: Function owner not recognized*/GetVolumeInformationA(volume_name, ((Object)0), 0, ((Object)0), ((Object)0), ((Object)0), FileSystemName, FileSystemNameSize))) {
			do {
				if (!bSilent) {
					ModernizedCProgram._uprintf("No volume information for drive 0x%02x", DriveIndex);
				} 
			} while (0);
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)volume_name);
			volume_name = ((Object)0);
		} while (0);
		hPhysical = ModernizedCProgram.GetPhysicalHandle(DriveIndex, 0, 0, 1);
		if (hPhysical == (HANDLE)(true)) {
			return 0;
		} 
		r = /*Error: Function owner not recognized*/DeviceIoControl(hPhysical, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, geometry, /*Error: sizeof expression not supported yet*/, size, ((Object)0));
		if (!r || size <= 0) {
			do {
				if (!bSilent) {
					ModernizedCProgram._uprintf("Could not get geometry for drive 0x%02x: %s", DriveIndex, ModernizedCProgram.WindowsErrorString());
				} 
			} while (0);
			do {
				if ((hPhysical != (HANDLE)(true)) && (hPhysical != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hPhysical);
					hPhysical = (HANDLE)(true);
				} 
			} while (0);
			return 0;
		} 
		ModernizedCProgram.SelectedDrive.setDiskSize(DiskGeometry.getDiskSize().getQuadPart());
		ModernizedCProgram.SelectedDrive.setSectorSize(DiskGeometry.getGeometry().getBytesPerSector());
		ModernizedCProgram.SelectedDrive.setFirstDataSector(-1024);
		if (ModernizedCProgram.SelectedDrive.getSectorSize() < 512) {
			do {
				if (!bSilent) {
					ModernizedCProgram._uprintf("Warning: Drive 0x%02x reports a sector size of %d - Correcting to 512 bytes.", DriveIndex, ModernizedCProgram.SelectedDrive.getSectorSize());
				} 
			} while (0);
			ModernizedCProgram.SelectedDrive.setSectorSize(512);
		} 
		ModernizedCProgram.SelectedDrive.setSectorsPerTrack(DiskGeometry.getGeometry().getSectorsPerTrack());
		ModernizedCProgram.SelectedDrive.setMediaType(DiskGeometry.getGeometry().getMediaType());
		do {
			if (!bSilent) {
				ModernizedCProgram._uprintf("Disk type: %s, Disk size: %s, Sector size: %d bytes", (ModernizedCProgram.SelectedDrive.getMediaType() == _MEDIA_TYPE.FixedMedia) ? "FIXED" : "Removable", ModernizedCProgram.SizeToHumanReadable(ModernizedCProgram.SelectedDrive.getDiskSize(), 0, 1), ModernizedCProgram.SelectedDrive.getSectorSize());
			} 
		} while (0);
		do {
			if (!bSilent) {
				ModernizedCProgram._uprintf("Cylinders: %I64i, Tracks per cylinder: %d, Sectors per track: %d", DiskGeometry.getGeometry().getCylinders(), DiskGeometry.getGeometry().getTracksPerCylinder(), DiskGeometry.getGeometry().getSectorsPerTrack());
			} 
		} while (0);
		r = /*Error: Function owner not recognized*/DeviceIoControl(hPhysical, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, layout, /*Error: sizeof expression not supported yet*/, size, ((Object)0));
		if (!r || size <= 0) {
			do {
				if (!bSilent) {
					ModernizedCProgram._uprintf("Could not get layout for drive 0x%02x: %s", DriveIndex, ModernizedCProgram.WindowsErrorString());
				} 
			} while (0);
			do {
				if ((hPhysical != (HANDLE)(true)) && (hPhysical != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hPhysical);
					hPhysical = (HANDLE)(true);
				} 
			} while (0);
			return 0;
		} 
		// GCC 4.9 bugs us about the fact that MS defined an expandable array as array[1]switch (DriveLayout.getPartitionStyle()) {
		case _PARTITION_STYLE.PARTITION_STYLE_MBR:
				ModernizedCProgram.SelectedDrive.setPartitionStyle(_PARTITION_STYLE.PARTITION_STYLE_MBR);
				for (i = 0; i < DriveLayout.getPartitionCount(); i++) {
					if (DriveLayout.getPartitionEntry()[i].getMbr().getPartitionType() != 0) {
						ModernizedCProgram.SelectedDrive.getNPartitions()++;
					} 
				}
				if ((DriveLayout.getPartitionEntry()[0].getMbr().getPartitionType() != 0) && (DriveLayout.getPartitionEntry()[0].getStartingOffset().getQuadPart() == -1024)) {
					do {
						if (!bSilent) {
							ModernizedCProgram._uprintf("Partition type: SFD (%s) or Unpartitioned", ModernizedCProgram.sfd_name);
						} 
					} while (0);
					super_floppy_disk = 1;
				} else {
						do {
							if (!bSilent) {
								ModernizedCProgram._uprintf("Partition type: MBR, NB Partitions: %d", ModernizedCProgram.SelectedDrive.getNPartitions());
							} 
						} while (0);
						ModernizedCProgram.SelectedDrive.setHas_mbr_uefi_marker((DriveLayout.getMbr().getSignature() == -1024));
						do {
							if (!bSilent) {
								ModernizedCProgram._uprintf("Disk ID: 0x%08X %s", DriveLayout.getMbr().getSignature(), ModernizedCProgram.SelectedDrive.getHas_mbr_uefi_marker() ? "(UEFI target)" : "");
							} 
						} while (0);
						ModernizedCProgram.AnalyzeMBR(hPhysical, "Drive", bSilent);
				} 
				for (i = 0; i < DriveLayout.getPartitionCount(); i++) {
					isUefiNtfs = 0;
					if (DriveLayout.getPartitionEntry()[i].getMbr().getPartitionType() != 0) {
						part_type = DriveLayout.getPartitionEntry()[i].getMbr().getPartitionType();
						if (part_type == -1024) {
							buf = /*Error: Function owner not recognized*/calloc(ModernizedCProgram.SelectedDrive.getSectorSize(), 1);
							if (buf != ((Object)0)) {
								if (/*Error: Function owner not recognized*/SetFilePointerEx(hPhysical, DriveLayout.getPartitionEntry()[i].getStartingOffset(), ((Object)0), 0) && /*Error: Function owner not recognized*/ReadFile(hPhysical, buf, ModernizedCProgram.SelectedDrive.getSectorSize(), size, ((Object)0))) {
									isUefiNtfs = (/*Error: Function owner not recognized*/strncmp(buf[-1024], "UEFI_NTFS", 9) == 0);
								} 
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buf);
							} 
						} 
						do {
							if (!bSilent) {
								ModernizedCProgram._uprintf("Partition %d%s:", i + (super_floppy_disk ? 0 : 1), isUefiNtfs ? " (UEFI:NTFS)" : "");
							} 
						} while (0);
						for (j = 0; j < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); j++) {
							if (part_type == mbr_mountable[j]) {
								ret = 1;
								break;
							} 
						}
						if (i < 16) {
							ModernizedCProgram.SelectedDrive.getPartitionOffset()[i] = DriveLayout.getPartitionEntry()[i].getStartingOffset().getQuadPart();
							ModernizedCProgram.SelectedDrive.getPartitionSize()[i] = DriveLayout.getPartitionEntry()[i].getPartitionLength().getQuadPart();
						} 
						do {
							if (!bSilent) {
								ModernizedCProgram._uprintf("  Type: %s (0x%02x)\r\n  Size: %s (%I64i bytes)\r\n  Start Sector: %I64i, Boot: %s", ((part_type == -1024 || super_floppy_disk) && (FileSystemName[0] != 0)) ? FileSystemName : ModernizedCProgram.GetPartitionType(part_type), super_floppy_disk ? 0 : part_type, ModernizedCProgram.SizeToHumanReadable(DriveLayout.getPartitionEntry()[i].getPartitionLength().getQuadPart(), 1, 0), DriveLayout.getPartitionEntry()[i].getPartitionLength().getQuadPart(), DriveLayout.getPartitionEntry()[i].getStartingOffset().getQuadPart() / ModernizedCProgram.SelectedDrive.getSectorSize(), DriveLayout.getPartitionEntry()[i].getMbr().getBootIndicator() ? "Yes" : "No");
							} 
						} while (0);
						ModernizedCProgram.SelectedDrive.setFirstDataSector(((ModernizedCProgram.SelectedDrive.getFirstDataSector()) < ((DWORD)(DriveLayout.getPartitionEntry()[i].getStartingOffset().getQuadPart() / ModernizedCProgram.SelectedDrive.getSectorSize())) ? (ModernizedCProgram.SelectedDrive.getFirstDataSector()) : ((DWORD)(DriveLayout.getPartitionEntry()[i].getStartingOffset().getQuadPart() / ModernizedCProgram.SelectedDrive.getSectorSize()))));
						if ((part_type == -1024) || (isUefiNtfs)) {
							--ModernizedCProgram.SelectedDrive.getNPartitions();
						} 
						if (part_type == -1024) {
							ModernizedCProgram.SelectedDrive.setHas_protective_mbr(1);
						} 
					} 
				}
				break;
		case _PARTITION_STYLE.PARTITION_STYLE_GPT:
				ModernizedCProgram.SelectedDrive.setPartitionStyle(_PARTITION_STYLE.PARTITION_STYLE_GPT);
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Partition type: GPT, NB Partitions: %d", DriveLayout.getPartitionCount());
					} 
				} while (0);
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Disk GUID: %s", ModernizedCProgram.GuidToString(DriveLayout.getGpt().getDiskId()));
					} 
				} while (0);
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Max parts: %d, Start Offset: %I64i, Usable = %I64i bytes", DriveLayout.getGpt().getMaxPartitionCount(), DriveLayout.getGpt().getStartingUsableOffset().getQuadPart(), DriveLayout.getGpt().getUsableLength().getQuadPart());
					} 
				} while (0);
				for (i = 0; i < DriveLayout.getPartitionCount(); i++) {
					if (i < 16) {
						ModernizedCProgram.SelectedDrive.getPartitionOffset()[i] = DriveLayout.getPartitionEntry()[i].getStartingOffset().getQuadPart();
						ModernizedCProgram.SelectedDrive.getPartitionSize()[i] = DriveLayout.getPartitionEntry()[i].getPartitionLength().getQuadPart();
					} 
					ModernizedCProgram.SelectedDrive.getNPartitions()++;
					isUefiNtfs = (/*Error: Function owner not recognized*/wcscmp(DriveLayout.getPartitionEntry()[i].getGpt().getName(), L"UEFI:NTFS") == 0);
					do {
						if (!bSilent) {
							ModernizedCProgram._uprintf("Partition %d%s:\r\n  Type: %s\r\n  Name: '%S'", i + 1, isUefiNtfs ? " (UEFI:NTFS)" : "", ModernizedCProgram.GuidToString(DriveLayout.getPartitionEntry()[i].getGpt().getPartitionType()), DriveLayout.getPartitionEntry()[i].getGpt().getName());
						} 
					} while (0);
					do {
						if (!bSilent) {
							ModernizedCProgram._uprintf("  ID: %s\r\n  Size: %s (%I64i bytes)\r\n  Start Sector: %I64i, Attributes: 0x%016I64X", ModernizedCProgram.GuidToString(DriveLayout.getPartitionEntry()[i].getGpt().getPartitionId()), ModernizedCProgram.SizeToHumanReadable(DriveLayout.getPartitionEntry()[i].getPartitionLength().getQuadPart(), 1, 0), DriveLayout.getPartitionEntry()[i].getPartitionLength(), DriveLayout.getPartitionEntry()[i].getStartingOffset().getQuadPart() / ModernizedCProgram.SelectedDrive.getSectorSize(), DriveLayout.getPartitionEntry()[i].getGpt().getAttributes());
						} 
					} while (0);
					ModernizedCProgram.SelectedDrive.setFirstDataSector(((ModernizedCProgram.SelectedDrive.getFirstDataSector()) < ((DWORD)(DriveLayout.getPartitionEntry()[i].getStartingOffset().getQuadPart() / ModernizedCProgram.SelectedDrive.getSectorSize())) ? (ModernizedCProgram.SelectedDrive.getFirstDataSector()) : ((DWORD)(DriveLayout.getPartitionEntry()[i].getStartingOffset().getQuadPart() / ModernizedCProgram.SelectedDrive.getSectorSize()))));
					if (isUefiNtfs || (ModernizedCProgram.CompareGUID(DriveLayout.getPartitionEntry()[i].getGpt().getPartitionType(), ModernizedCProgram.PARTITION_MSFT_RESERVED_GUID)) || (ModernizedCProgram.CompareGUID(DriveLayout.getPartitionEntry()[i].getGpt().getPartitionType(), ModernizedCProgram.PARTITION_SYSTEM_GUID))) {
						--ModernizedCProgram.SelectedDrive.getNPartitions();
					} 
					if (/*Error: Function owner not recognized*/memcmp(ModernizedCProgram.PARTITION_BASIC_DATA_GUID, DriveLayout.getPartitionEntry()[i].getGpt().getPartitionType(), /*Error: Unsupported expression*/) == 0) {
						ret = 1;
					} 
				}
				break;
		default:
				ModernizedCProgram.SelectedDrive.setPartitionStyle(_PARTITION_STYLE.PARTITION_STYLE_MBR);
				do {
					if (!bSilent) {
						ModernizedCProgram._uprintf("Partition type: RAW");
					} 
				} while (0);
				break;
		}
		do {
			if ((hPhysical != (HANDLE)(true)) && (hPhysical != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hPhysical);
				hPhysical = (HANDLE)(true);
			} 
		} while (0);
		return ret/*
		 * Flush file data
		 */;
	}
	public static Object FlushDrive(byte drive_letter) {
		HANDLE hDrive = (HANDLE)(true);
		BOOL r = 0;
		byte[] logical_drive = "\\\\.\\#:";
		logical_drive[4] = drive_letter;
		hDrive = /*Error: Function owner not recognized*/CreateFileA(logical_drive, -1024 | -1024, -1024 | -1024, ((Object)0), 3, -1024, ((Object)0));
		if (hDrive == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Failed to open %c: for flushing: %s", drive_letter, ModernizedCProgram.WindowsErrorString());
			;
		} 
		r = /*Error: Function owner not recognized*/FlushFileBuffers(hDrive);
		if (r == 0) {
			ModernizedCProgram._uprintf("Failed to flush %c: %s", drive_letter, ModernizedCProgram.WindowsErrorString());
		} 
		return r/*
		 * Unmount of volume using the DISMOUNT_VOLUME ioctl
		 */;
	}
	public static Object UnmountVolume(Object hDrive) {
		DWORD size = new DWORD();
		if (!/*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, ((Object)0), 0, size, ((Object)0))) {
			ModernizedCProgram._uprintf("Could not unmount drive: %s", ModernizedCProgram.WindowsErrorString());
			return 0;
		} 
		return 1/*
		 * Mount the volume identified by drive_guid to mountpoint drive_name.
		 * If volume_name is already mounted, but with a different letter than the
		 * one requested then drive_name is updated to use that letter.
		 */;
	}
	public static Object MountVolume(byte[] drive_name, Byte volume_name) {
		byte[] mounted_guid = new byte[52];
		byte[] mounted_letter = new byte[]{0};
		DWORD size = new DWORD();
		if ((drive_name == ((Object)0)) || (volume_name == ((Object)0)) || (drive_name[0] == (byte)'?') || (/*Error: Function owner not recognized*/strncmp(volume_name, ModernizedCProgram.groot_name, ModernizedCProgram.groot_len) == 0)) {
			return 0;
		} 
		// If that is the case, update drive_name to that letter.if ((/*Error: Function owner not recognized*/GetVolumePathNamesForVolumeNameA(volume_name, mounted_letter, /*Error: sizeof expression not supported yet*/, size)) && (size > 1) && (mounted_letter[0] != drive_name[0])) {
			ModernizedCProgram._uprintf("%s is already mounted as %C: instead of %C: - Will now use this target instead...", volume_name, mounted_letter[0], drive_name[0]);
			drive_name[0] = mounted_letter[0];
			return 1;
		} 
		if (!/*Error: Function owner not recognized*/SetVolumeMountPointA(drive_name, volume_name)) {
			if (/*Error: Function owner not recognized*/GetLastError() == -1024) {
				if (!/*Error: Function owner not recognized*/GetVolumeNameForVolumeMountPointA(drive_name, mounted_guid, /*Error: sizeof expression not supported yet*/)) {
					ModernizedCProgram._uprintf("%s is already mounted, but volume GUID could not be checked: %s", drive_name, ModernizedCProgram.WindowsErrorString());
				}  else if (/*Error: Function owner not recognized*/strcmp(((volume_name == ((Object)0)) ? "<NULL>" : volume_name), ((mounted_guid == ((Object)0)) ? "<NULL>" : mounted_guid)) != 0) {
					ModernizedCProgram._uprintf("%s is mounted, but volume GUID doesn't match:\r\n  expected %s, got %s", drive_name, volume_name, mounted_guid);
				} else {
						ModernizedCProgram._uprintf("%s is already mounted as %C:", volume_name, drive_name[0]);
						return 1;
				} 
				ModernizedCProgram._uprintf("Retrying after dismount...");
				if (!/*Error: Function owner not recognized*/DeleteVolumeMountPointA(drive_name)) {
					ModernizedCProgram._uprintf("Warning: Could not delete volume mountpoint: %s", ModernizedCProgram.WindowsErrorString());
				} 
				if (/*Error: Function owner not recognized*/SetVolumeMountPointA(drive_name, volume_name)) {
					return 1;
				} 
				if ((/*Error: Function owner not recognized*/GetLastError() == -1024) && /*Error: Function owner not recognized*/GetVolumeNameForVolumeMountPointA(drive_name, mounted_guid, /*Error: sizeof expression not supported yet*/) && (/*Error: Function owner not recognized*/strcmp(((volume_name == ((Object)0)) ? "<NULL>" : volume_name), ((mounted_guid == ((Object)0)) ? "<NULL>" : mounted_guid)) == 0)) {
					ModernizedCProgram._uprintf("%s was remounted as %C: (second time lucky!)", volume_name, drive_name[0]);
					return 1;
				} 
			} 
			return 0;
		} 
		return 1/*
		 * Alternate version of MountVolume required for ESP's, since Windows (including VDS) does
		 * *NOT* provide any means of mounting these volume but through DefineDosDevice(). Also
		 * note that bcdboot is very finicky about what it may or may not handle, even if the
		 * mount was successful (e.g. '\Device\HarddiskVolume###' vs 'Device\HarddiskVolume###').
		 * Returned string is static (no concurrency) and must not be freed.
		 */;
	}
	public static Byte AltMountVolume(Object DriveIndex, Object PartitionOffset, Object bSilent) {
		byte ret = ((Object)0);
		byte volume_name = ((Object)0);
		byte[] mounted_drive = "?:";
		mounted_drive[0] = ModernizedCProgram.GetUnusedDriveLetter();
		if (mounted_drive[0] == 0) {
			do {
				if (!bSilent) {
					ModernizedCProgram._uprintf("Could not find an unused drive letter");
				} 
			} while (0);
			;
		} 
		// Can't use a regular volume GUID for ESPs...// Can't use a regular volume GUID for ESPs...volume_name = ModernizedCProgram.AltGetLogicalName(DriveIndex, PartitionOffset, 0, 1);
		if ((volume_name == ((Object)0)) || (/*Error: Function owner not recognized*/strncmp(volume_name, ModernizedCProgram.groot_name, ModernizedCProgram.groot_len) != 0)) {
			do {
				if (!bSilent) {
					ModernizedCProgram._uprintf("Unexpected volume name: '%s'", volume_name);
				} 
			} while (0);
			;
		} 
		do {
			if (!bSilent) {
				ModernizedCProgram._uprintf("Mounting '%s' as '%s'", volume_name[14], mounted_drive);
			} 
		} while (0);// bcdboot doesn't like it if you forget the starting '\'
		if (!/*Error: Function owner not recognized*/DefineDosDeviceA(1 | DDD_NO_BROADCAST_SYSTEM, mounted_drive, volume_name[14])) {
			do {
				if (!bSilent) {
					ModernizedCProgram._uprintf("Mount operation failed: %s", ModernizedCProgram.WindowsErrorString());
				} 
			} while (0);
			;
		} 
		ret = mounted_drive;
		return ret/*
		 * Unmount a volume that was mounted by AltmountVolume()
		 */;
	}
	public static Object AltUnmountVolume(Object drive_name, Object bSilent) {
		if (drive_name == ((Object)0)) {
			return 0;
		} 
		if (!/*Error: Function owner not recognized*/DefineDosDeviceA(2 | DDD_NO_BROADCAST_SYSTEM, drive_name, ((Object)0))) {
			do {
				if (!bSilent) {
					ModernizedCProgram._uprintf("Could not unmount '%s': %s", drive_name, ModernizedCProgram.WindowsErrorString());
				} 
			} while (0);
			return 0;
		} 
		do {
			if (!bSilent) {
				ModernizedCProgram._uprintf("Successfully unmounted '%s'", drive_name);
			} 
		} while (0);
		return 1/*
		 * Issue a complete remount of the volume.
		 * Note that drive_name *may* be altered when the volume gets remounted.
		 */;
	}
	public static Object RemountVolume(byte[] drive_name) {
		byte[] volume_name = new byte[51];
		// UDF requires a sync/flush, and it's also a good idea for other FS's// UDF requires a sync/flush, and it's also a good idea for other FS'sModernizedCProgram.FlushDrive(drive_name[0]);
		if (/*Error: Function owner not recognized*/GetVolumeNameForVolumeMountPointA(drive_name, volume_name, /*Error: sizeof expression not supported yet*/)) {
			if (/*Error: Function owner not recognized*/DeleteVolumeMountPointA(drive_name)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(200);
				if (ModernizedCProgram.MountVolume(drive_name, volume_name)) {
					ModernizedCProgram._uprintf("Successfully remounted %s as %C:", volume_name, drive_name[0]);
				} else {
						ModernizedCProgram._uprintf("Failed to remount %s as %C:", volume_name, drive_name[0]);
						ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
						return 0;
				} 
			} else {
					ModernizedCProgram._uprintf("Could not remount %s as %C: %s", volume_name, drive_name[0], ModernizedCProgram.WindowsErrorString());
			} 
		} 
		return 1/*
		 * Zero the first 'size' bytes of a partition. This is needed because we haven't found a way to
		 * properly reset Windows's cached view of a drive partitioning short of cycling the USB port
		 * (especially IOCTL_DISK_UPDATE_PROPERTIES is *USELESS*), and therefore the OS will try to
		 * read the file system data at an old location, even if the partition has just been deleted.
		 * TODO: We should do something like this in DeletePartitions() too.
		 */;
	}
	public static Object ClearPartition(Object hDrive, Object size) {
		BOOL r = 0;
		uint8_t buffer = /*Error: Function owner not recognized*/calloc(size, 1);
		if (buffer == ((Object)0)) {
			return 0;
		} 
		if (!/*Error: Function owner not recognized*/SetFilePointerEx(hDrive, offset, ((Object)0), 0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buffer);
			return 0;
		} 
		r = ModernizedCProgram.WriteFileWithRetry(hDrive, buffer, size, size, 4);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buffer);
		return r/*
		 * Create a partition table
		 * See http://technet.microsoft.com/en-us/library/cc739412.aspx for some background info
		 * NB: if you modify the MBR outside of using the Windows API, Windows still uses the cached
		 * copy it got from the last IOCTL, and ignores your changes until you replug the drive
		 * or issue an IOCTL_DISK_UPDATE_PROPERTIES.
		 */;
	}
	public static Object CreatePartition(Object hDrive, int partition_style, int file_system, Object mbr_uefi_marker, Object extra_partitions) {
		byte[] PartitionTypeName = new byte[]{"MBR", "GPT", "SFD"};
		wchar_t extra_part_name = L"";
		wchar_t main_part_name = L"Main Data Partition";
		LONGLONG bytes_per_track = ((LONGLONG)ModernizedCProgram.SelectedDrive.getSectorsPerTrack()) * ModernizedCProgram.SelectedDrive.getSectorSize();
		DWORD size_to_clear = 128 * ModernizedCProgram.SelectedDrive.getSectorSize();
		uint8_t buffer = new uint8_t();
		size_t uefi_ntfs_size = 0;
		CREATE_DISK CreateDisk = new CREATE_DISK(_PARTITION_STYLE.PARTITION_STYLE_RAW, {new CREATE_DISK(0)});
		DRIVE_LAYOUT_INFORMATION_EX4 DriveLayoutEx = new DRIVE_LAYOUT_INFORMATION_EX4(0);
		BOOL r = new BOOL();
		DWORD i = new DWORD();
		DWORD size = new DWORD();
		DWORD bufsize = new DWORD();
		DWORD pn = 0;
		LONGLONG main_part_size_in_sectors = new LONGLONG();
		LONGLONG extra_part_size_in_tracks = 0;
		LONGLONG ms_esp_size = new LONGLONG();
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3238, PartitionTypeName[partition_style]);
		if (partition_style == _PARTITION_STYLE.PARTITION_STYLE_RAW) {
			return 1;
		} 
		// Nothing to do
		if (extra_partitions & -1024) {
			uefi_ntfs_size = ModernizedCProgram.GetResourceSize(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)(true))), "uefi-ntfs.img");
			if (uefi_ntfs_size == 0) {
				return 0;
			} 
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.partition_offset, 0, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.SelectedDrive.getPartitionOffset(), 0, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.SelectedDrive.getPartitionSize(), 0, /*Error: sizeof expression not supported yet*/);
		Object generatedPartitionEntry = DriveLayoutEx.getPartitionEntry();
		// Compute the start offset of our first partitionif ((partition_style == _PARTITION_STYLE.PARTITION_STYLE_GPT) || (!(/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1021) == 1))) {
			generatedPartitionEntry[pn].getStartingOffset().setQuadPart(-1024);
		} else {
				generatedPartitionEntry[pn].getStartingOffset().setQuadPart(bytes_per_track);
		} 
		// Go with the MS 1 MB wastage at the beginning...
		// If required, set the MSR partition (GPT only - must be created before the data part)if (extra_partitions & -1024) {
			((partition_style == _PARTITION_STYLE.PARTITION_STYLE_GPT) ? (Object)0 : /*Error: Function owner not recognized*/_assert("partition_style == PARTITION_STYLE_GPT", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 1552));
			extra_part_name = L"Microsoft Reserved Partition";
			generatedPartitionEntry[pn].getPartitionLength().setQuadPart(128 * -1024);
			generatedPartitionEntry[pn].getGpt().setPartitionType(ModernizedCProgram.PARTITION_MSFT_RESERVED_GUID);
			ModernizedCProgram._uprintf("â? Creating %S (offset: %lld, size: %s)", extra_part_name, generatedPartitionEntry[pn].getStartingOffset().getQuadPart(), ModernizedCProgram.SizeToHumanReadable(generatedPartitionEntry[pn].getPartitionLength().getQuadPart(), 1, 0));
			do {
				(Object)(/*Error: Function owner not recognized*/CoCreateGuid(generatedPartitionEntry[pn].getGpt().getPartitionId()));
			} while (0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/wcsncpy(generatedPartitionEntry[pn].getGpt().getName(), extra_part_name, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
			if (!generatedPartitionEntry[pn].getStartingOffset().ClearPartition(hDrive, size_to_clear)) {
				ModernizedCProgram._uprintf("Could not zero %S: %s", extra_part_name, ModernizedCProgram.WindowsErrorString());
			} 
			ModernizedCProgram.SelectedDrive.getPartitionOffset()[pn] = generatedPartitionEntry[pn].getStartingOffset().getQuadPart();
			ModernizedCProgram.SelectedDrive.getPartitionSize()[pn] = generatedPartitionEntry[pn].getPartitionLength().getQuadPart();
			pn++;
			generatedPartitionEntry[pn].getStartingOffset().setQuadPart(generatedPartitionEntry[pn - 1].getStartingOffset().getQuadPart() + generatedPartitionEntry[pn - 1].getPartitionLength().getQuadPart());
			extra_partitions &=  ~(true);
		} 
		// Set our main data partition// Set our main data partitionmain_part_size_in_sectors = (ModernizedCProgram.SelectedDrive.getDiskSize() - generatedPartitionEntry[pn].getStartingOffset().getQuadPart()) / ModernizedCProgram.SelectedDrive.getSectorSize() - ((partition_style == _PARTITION_STYLE.PARTITION_STYLE_GPT) ? 33 : 0)// Need 33 sectors at the end for secondary GPT;// Need 33 sectors at the end for secondary GPT
		if (extra_partitions) {
			if (extra_partitions & -1024) {
				extra_part_name = L"EFI System";
				if (ModernizedCProgram.SelectedDrive.getSectorSize() <= 4096) {
					ms_esp_size = 300 * -1024;
				} else {
						ms_esp_size = 1200 * -1024;
				} 
				extra_part_size_in_tracks = (ms_esp_size + bytes_per_track - 1) / bytes_per_track;
			}  else if (extra_partitions & -1024) {
				extra_part_name = L"UEFI:NTFS";
				extra_part_size_in_tracks = ((((1024 * 1024)) > (uefi_ntfs_size) ? ((1024 * 1024)) : (uefi_ntfs_size)) + bytes_per_track - 1) / bytes_per_track;
			}  else if ((extra_partitions & -1024)) {
				((ModernizedCProgram.persistence_size != 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("persistence_size != 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 1594));
				extra_part_name = L"Linux Persistence";
				extra_part_size_in_tracks = ModernizedCProgram.persistence_size / bytes_per_track;
			}  else if (extra_partitions & -1024) {
				extra_part_name = L"BIOS Compatibility";
				extra_part_size_in_tracks = 1;
			} else {
					((false) ? (Object)0 : /*Error: Function owner not recognized*/_assert("FALSE", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 1601));
			} 
			main_part_size_in_sectors = ((main_part_size_in_sectors / ModernizedCProgram.SelectedDrive.getSectorsPerTrack()) - extra_part_size_in_tracks) * ModernizedCProgram.SelectedDrive.getSectorsPerTrack();
		} 
		// Adjust the size according to extra partitions (which we always align to a track)
		if (main_part_size_in_sectors <= 0) {
			ModernizedCProgram._uprintf("Error: Invalid %S size", main_part_name);
			return 0;
		} 
		ModernizedCProgram._uprintf("â? Creating %S (offset: %lld, size: %s)", main_part_name, generatedPartitionEntry[pn].getStartingOffset().getQuadPart(), ModernizedCProgram.SizeToHumanReadable(main_part_size_in_sectors * ModernizedCProgram.SelectedDrive.getSectorSize(), 1, 0));
		// Zero the beginning of this partition to avoid conflicting leftoversif (!generatedPartitionEntry[pn].getStartingOffset().ClearPartition(hDrive, size_to_clear)) {
			ModernizedCProgram._uprintf("Could not zero %S: %s", main_part_name, ModernizedCProgram.WindowsErrorString());
		} 
		generatedPartitionEntry[pn].getPartitionLength().setQuadPart(main_part_size_in_sectors * ModernizedCProgram.SelectedDrive.getSectorSize());
		if (partition_style == _PARTITION_STYLE.PARTITION_STYLE_MBR) {
			generatedPartitionEntry[pn].getMbr().setBootIndicator((ModernizedCProgram.boot_type != boot_type.BT_NON_BOOTABLE));
			switch (file_system) {
			case fs_type.FS_FAT16:
					generatedPartitionEntry[pn].getMbr().setPartitionType(-1024);
					break;
			case fs_type.FS_EXFAT:
			case fs_type.FS_EXT2:
			case fs_type.FS_UDF:
			case fs_type.FS_EXT3:
			case fs_type.FS_FAT32:
					generatedPartitionEntry[pn].getMbr().setPartitionType(-1024);
					break;
			case fs_type.FS_REFS:
					generatedPartitionEntry[pn].getMbr().setPartitionType(-1024);
					break;
			case fs_type.FS_EXT4:
					generatedPartitionEntry[pn].getMbr().setPartitionType(-1024);
					break;
			case fs_type.FS_NTFS:
			default:
					ModernizedCProgram._uprintf("Unsupported file system");
					return 0;
			}
		} else {
				generatedPartitionEntry[pn].getGpt().setPartitionType(ModernizedCProgram.PARTITION_BASIC_DATA_GUID);
				do {
					(Object)(/*Error: Function owner not recognized*/CoCreateGuid(generatedPartitionEntry[pn].getGpt().getPartitionId()));
				} while (0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/wcsncpy(generatedPartitionEntry[pn].getGpt().getName(), main_part_name, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
		} 
		ModernizedCProgram.SelectedDrive.getPartitionOffset()[pn] = generatedPartitionEntry[pn].getStartingOffset().getQuadPart();
		ModernizedCProgram.SelectedDrive.getPartitionSize()[pn] = generatedPartitionEntry[pn].getPartitionLength().getQuadPart();
		ModernizedCProgram.partition_offset[0] = ModernizedCProgram.SelectedDrive.getPartitionOffset()[pn];
		pn++;
		// Set the optional extra partitionif (extra_partitions) {
			generatedPartitionEntry[pn].getStartingOffset().setQuadPart(generatedPartitionEntry[pn - 1].getStartingOffset().getQuadPart() + generatedPartitionEntry[pn - 1].getPartitionLength().getQuadPart());
			generatedPartitionEntry[pn].getPartitionLength().setQuadPart((extra_partitions & -1024) ? uefi_ntfs_size : extra_part_size_in_tracks * bytes_per_track);
			ModernizedCProgram._uprintf("â? Creating %S Partition (offset: %lld, size: %s)", extra_part_name, generatedPartitionEntry[pn].getStartingOffset().getQuadPart(), ModernizedCProgram.SizeToHumanReadable(generatedPartitionEntry[pn].getPartitionLength().getQuadPart(), 1, 0));
			ModernizedCProgram.SelectedDrive.getPartitionOffset()[pn] = generatedPartitionEntry[pn].getStartingOffset().getQuadPart();
			ModernizedCProgram.SelectedDrive.getPartitionSize()[pn] = generatedPartitionEntry[pn].getPartitionLength().getQuadPart();
			if (extra_partitions & -1024) {
				ModernizedCProgram.partition_offset[2] = ModernizedCProgram.SelectedDrive.getPartitionOffset()[pn];
			}  else if (extra_partitions & -1024) {
				ModernizedCProgram.partition_offset[1] = ModernizedCProgram.SelectedDrive.getPartitionOffset()[pn];
			} 
			if (partition_style == _PARTITION_STYLE.PARTITION_STYLE_GPT) {
				generatedPartitionEntry[pn].getGpt().setPartitionType((extra_partitions & -1024) ? ModernizedCProgram.PARTITION_SYSTEM_GUID : ModernizedCProgram.PARTITION_BASIC_DATA_GUID);
				do {
					(Object)(/*Error: Function owner not recognized*/CoCreateGuid(generatedPartitionEntry[pn].getGpt().getPartitionId()));
				} while (0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/wcsncpy(generatedPartitionEntry[pn].getGpt().getName(), (extra_partitions & -1024) ? L"EFI System Partition" : extra_part_name, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
			} else {
					if (extra_partitions & (-1024 | -1024)) {
						generatedPartitionEntry[pn].getMbr().setPartitionType(-1024);
					}  else if (extra_partitions & -1024) {
						generatedPartitionEntry[pn].getMbr().setPartitionType(-1024);
					}  else if (extra_partitions & -1024) {
						generatedPartitionEntry[pn].getMbr().setPartitionType(-1024);
						generatedPartitionEntry[pn].getMbr().setHiddenSectors(ModernizedCProgram.SelectedDrive.getSectorsPerTrack());
					} else {
							((false) ? (Object)0 : /*Error: Function owner not recognized*/_assert("FALSE", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\drive.c", 1682));
					} 
			} 
			if (extra_partitions & -1024) {
				ModernizedCProgram._uprintf("Writing %S data...", extra_part_name);
				if (!/*Error: Function owner not recognized*/SetFilePointerEx(hDrive, generatedPartitionEntry[pn].getStartingOffset(), ((Object)0), 0)) {
					ModernizedCProgram._uprintf("Could not set position");
					return 0;
				} 
				buffer = ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)(true))), "uefi-ntfs.img", bufsize, 0);
				if (buffer == ((Object)0)) {
					ModernizedCProgram._uprintf("Could not access source image");
					return 0;
				} 
				if (!ModernizedCProgram.WriteFileWithRetry(hDrive, buffer, bufsize, size, 4)) {
					ModernizedCProgram._uprintf("Write error: %s", ModernizedCProgram.WindowsErrorString());
					return 0;
				} 
				ModernizedCProgram.installed_uefi_ntfs = 1;
			} 
			pn++;
		} 
		// Should end on a track boundary
		// Initialize the remaining partition datafor (i = 0; i < pn; i++) {
			generatedPartitionEntry[i].setPartitionNumber(i + 1);
			generatedPartitionEntry[i].setPartitionStyle(partition_style);
			generatedPartitionEntry[i].setRewritePartition(1);
		}
		Object generatedMbr = CreateDisk.getMbr();
		Object generatedGpt = CreateDisk.getGpt();
		switch (partition_style) {
		case _PARTITION_STYLE.PARTITION_STYLE_MBR:
				CreateDisk.setPartitionStyle(_PARTITION_STYLE.PARTITION_STYLE_MBR);
				generatedMbr.setSignature(mbr_uefi_marker ? -1024 : (DWORD)/*Error: Function owner not recognized*/GetTickCount64());
				DriveLayoutEx.setPartitionStyle(_PARTITION_STYLE.PARTITION_STYLE_MBR);
				DriveLayoutEx.setPartitionCount(4);
				generatedMbr.setSignature(generatedMbr.getSignature());
				break;
		case _PARTITION_STYLE.PARTITION_STYLE_GPT:
				CreateDisk.setPartitionStyle(_PARTITION_STYLE.PARTITION_STYLE_GPT);
				do {
					(Object)(/*Error: Function owner not recognized*/CoCreateGuid(generatedGpt.getDiskId()));
				} while (0);
				generatedGpt.setMaxPartitionCount(16);
				DriveLayoutEx.setPartitionStyle(_PARTITION_STYLE.PARTITION_STYLE_GPT);
				DriveLayoutEx.setPartitionCount(pn);
				generatedGpt.getStartingUsableOffset().setQuadPart(34 * ModernizedCProgram.SelectedDrive.getSectorSize());
				generatedGpt.getUsableLength().setQuadPart(ModernizedCProgram.SelectedDrive.getDiskSize() - (34 + 33) * ModernizedCProgram.SelectedDrive.getSectorSize());
				generatedGpt.setMaxPartitionCount(16);
				generatedGpt.setDiskId(generatedGpt.getDiskId());
				break;
		}
		// If you don't call IOCTL_DISK_CREATE_DISK, the IOCTL_DISK_SET_DRIVE_LAYOUT_EX call will fail// If you don't call IOCTL_DISK_CREATE_DISK, the IOCTL_DISK_SET_DRIVE_LAYOUT_EX call will failsize = /*Error: sizeof expression not supported yet*/;
		r = /*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((true) << 16) | ((-1024 | -1024) << 14) | ((true) << 2) | (false)), (BYTE)CreateDisk, size, ((Object)0), 0, size, ((Object)0));
		if (!r) {
			ModernizedCProgram._uprintf("Could not reset disk: %s", ModernizedCProgram.WindowsErrorString());
			return 0;
		} 
		// "The goggles, they do nothing!"// "The goggles, they do nothing!"ModernizedCProgram.RefreshDriveLayout(hDrive);
		size = /*Error: sizeof expression not supported yet*/ - ((partition_style == _PARTITION_STYLE.PARTITION_STYLE_GPT) ? ((4 - pn) * /*Error: Unsupported expression*/) : 0);
		r = /*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((true) << 16) | ((-1024 | -1024) << 14) | ((true) << 2) | (false)), (BYTE)DriveLayoutEx, size, ((Object)0), 0, size, ((Object)0));
		if (!r) {
			ModernizedCProgram._uprintf("Could not set drive layout: %s", ModernizedCProgram.WindowsErrorString());
			return 0;
		} 
		if (!ModernizedCProgram.RefreshDriveLayout(hDrive)) {
			return 0;
		} 
		return 1;
	}
	public static Object RefreshDriveLayout(Object hDrive) {
		BOOL r = new BOOL();
		DWORD size = new DWORD();
		// Diskpart does call the following IOCTL this after updating the partition table, so we do too// Diskpart does call the following IOCTL this after updating the partition table, so we do toor = /*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, ((Object)0), 0, size, ((Object)0));
		if (!r) {
			ModernizedCProgram._uprintf("Could not refresh drive layout: %s", ModernizedCProgram.WindowsErrorString());
		} 
		return r;
	}
	/* Initialize disk for partitioning */
	public static Object InitializeDisk(Object hDrive) {
		BOOL r = new BOOL();
		DWORD size = new DWORD();
		CREATE_DISK CreateDisk = new CREATE_DISK(_PARTITION_STYLE.PARTITION_STYLE_RAW, {new CREATE_DISK(0)});
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3239);
		size = /*Error: sizeof expression not supported yet*/;
		r = /*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((true) << 16) | ((-1024 | -1024) << 14) | ((true) << 2) | (false)), (BYTE)CreateDisk, size, ((Object)0), 0, size, ((Object)0));
		if (!r) {
			ModernizedCProgram._uprintf("Could not delete drive layout: %s", ModernizedCProgram.WindowsErrorString());
			do {
				if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
					hDrive = (HANDLE)(true);
				} 
			} while (0);
			return 0;
		} 
		r = /*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, ((Object)0), 0, size, ((Object)0));
		if (!r) {
			ModernizedCProgram._uprintf("Could not refresh drive layout: %s", ModernizedCProgram.WindowsErrorString());
			do {
				if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
					hDrive = (HANDLE)(true);
				} 
			} while (0);
			return 0;
		} 
		return 1/*
		 * Convert a partition type to its human readable form using
		 * (slightly modified) entries from GNU fdisk
		 */;
	}
	public static Object GetPartitionType(Object Type) {
		int i;
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (ModernizedCProgram.msdos_systypes[i].getType() == Type) {
				return ModernizedCProgram.msdos_systypes[i].getName();
			} 
		}
		return "Unknown";
	}
	/* Adjust the p_iso's i_datastart, i_byte_offset and i_framesize
	   based on whether we find a frame header or not.
	*/
	public static void adjust_fuzzy_pvd(Object p_iso) {
		long i_byte_offset;
		if (!p_iso) {
			return /*Error: Unsupported expression*/;
		} 
		i_byte_offset = (ISO_PVD_SECTOR * p_iso.getI_framesize()) + p_iso.getI_fuzzy_offset() + p_iso.getI_datastart();
		if (CDIO_CD_FRAMESIZE_RAW == p_iso.getI_framesize()) {
			byte[] buf = new byte[CDIO_CD_SYNC_SIZE + CDIO_CD_HEADER_SIZE + CDIO_CD_SUBHEADER_SIZE];
			i_byte_offset -= CDIO_CD_SYNC_SIZE + CDIO_CD_HEADER_SIZE + CDIO_CD_SUBHEADER_SIZE;
			if (DRIVER_OP_SUCCESS != p_iso.getStream().cdio_stream_seek(i_byte_offset, SEEK_SET)) {
				return /*Error: Unsupported expression*/;
			} 
			if (/*Error: sizeof expression not supported yet*/ == p_iso.getStream().cdio_stream_read(buf, /*Error: sizeof expression not supported yet*/, 1)) {
				if (!/*Error: Function owner not recognized*/memcmp(ModernizedCProgram.CDIO_SECTOR_SYNC_HEADER, buf + /* Does the sector frame header suggest Mode 1 format? */CDIO_CD_SUBHEADER_SIZE, CDIO_CD_SYNC_SIZE)) {
					if (buf[14 + CDIO_CD_SUBHEADER_SIZE] != -1024) {
						ModernizedCProgram.cdio_warn("Expecting the PVD sector header MSF to be 0x16, is: %x", buf[14]);
					} 
					if (buf[15 + CDIO_CD_SUBHEADER_SIZE] != -1024) {
						ModernizedCProgram.cdio_warn("Expecting the PVD sector mode to be Mode 1 is: %x", buf[15]);
					} 
					p_iso.setB_mode2(nope);
					p_iso.setB_xa(nope);
				}  else if (!/*Error: Function owner not recognized*/memcmp(ModernizedCProgram.CDIO_SECTOR_SYNC_HEADER, buf, CDIO_CD_SYNC_SIZE)) {
					if (buf[14] != /* Frame header indicates Mode 2 Form 1*/-1024) {
						ModernizedCProgram.cdio_warn("Expecting the PVD sector header MSF to be 0x16, is: %x", buf[14]);
					} 
					if (buf[15] != -1024) {
						ModernizedCProgram.cdio_warn("Expecting the PVD sector mode to be Mode 2 is: %x", buf[15]);
					} 
					p_iso.setB_mode2(yep/* Do do: check Mode 2 Form 2? */);
				} else {
						p_iso.setI_framesize(/* Has no frame header */M2RAW_SECTOR_SIZE);
						p_iso.setI_fuzzy_offset((CDIO_CD_FRAMESIZE_RAW - M2RAW_SECTOR_SIZE) * ISO_PVD_SECTOR + p_iso.getI_fuzzy_offset() + p_iso.getI_datastart());
						p_iso.setI_datastart(0);
				} 
			} 
		} 
	}
	/*!
	  Open an ISO 9660 image for reading in either fuzzy mode or not.
	*/
	public static Object iso9660_open_ext_private(Object psz_path, Object iso_extension_mask, Object i_fuzz, Object b_fuzzy) {
		 p_iso = ()/*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/);
		if (!p_iso) {
			return NULL;
		} 
		_CdioDataSource _CdioDataSource = new _CdioDataSource();
		p_iso.setStream(_CdioDataSource.cdio_stdio_new(psz_path));
		if (NULL == p_iso.getStream()) {
			;
		} 
		p_iso.setI_framesize(ISO_BLOCKSIZE);
		p_iso.setB_have_superblock((b_fuzzy) ? ModernizedCProgram.iso9660_ifs_fuzzy_read_superblock(p_iso, iso_extension_mask, i_fuzz) : ModernizedCProgram.iso9660_ifs_read_superblock(p_iso, iso_extension_mask));
		if (!p_iso.getB_have_superblock()) {
			;
		} 
		p_iso.setB_xa(/*Error: Function owner not recognized*/strncmp((byte)(p_iso.getPvd()) + /* Determine if image has XA attributes. */ISO_XA_MARKER_OFFSET, ModernizedCProgram.ISO_XA_MARKER_STRING, /*Error: Unsupported expression*/) ? nope : yep);
		p_iso.setIso_extension_mask(iso_extension_mask);
		return p_iso;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_iso);
		return NULL/*!
		  Open an ISO 9660 image for reading. Maybe in the future we will have
		  a mode. NULL is returned on error.
		
		  @param psz_path full path of ISO9660 file.
		
		  @return a IS9660 structure  is unconditionally returned. The caller
		  should call iso9660_close() when done.
		*/;
	}
	/*, mode*/
	public static Object iso9660_open(Object psz_path) {
		return ModernizedCProgram.iso9660_open_ext(psz_path, ISO_EXTENSION_NONE/*!
		  Open an ISO 9660 image for reading allowing various ISO 9660
		  extensions.  Maybe in the future we will have a mode. NULL is
		  returned on error.
		
		  @see iso9660_open_fuzzy
		*/);
	}
	public static Object iso9660_open_ext(Object psz_path, Object iso_extension_mask) {
		return ModernizedCProgram.iso9660_open_ext_private(psz_path, iso_extension_mask, 0, false/*! Open an ISO 9660 image for "fuzzy" reading. This means that we
		  will try to guess various internal offset based on internal
		  checks. This may be useful when trying to read an ISO 9660 image
		  contained in a file format that libiso9660 doesn't know natively
		  (or knows imperfectly.)
		
		  Some tolerence allowed for positioning the ISO 9660 image. We scan
		  for STANDARD_ID and use that to set the eventual offset to adjust
		  by (as long as that is <= i_fuzz).
		
		  Maybe in the future we will have a mode. NULL is returned on error.
		
		  @see iso9660_open, @see iso9660_fuzzy_ext
		*/);
	}
	/*, mode*/
	public static Object iso9660_open_fuzzy(Object psz_path, Object i_fuzz) {
		return ModernizedCProgram.iso9660_open_fuzzy_ext(psz_path, ISO_EXTENSION_NONE, i_fuzz/*!
		  Open an ISO 9660 image for reading with some tolerence for positioning
		  of the ISO9660 image. We scan for ISO_STANDARD_ID and use that to set
		  the eventual offset to adjust by (as long as that is <= i_fuzz).
		
		  Maybe in the future we will have a mode. NULL is returned on error.
		
		  @see iso9660_open_ext @see iso9660_open_fuzzy
		*/);
	}
	public static Object iso9660_open_fuzzy_ext(Object psz_path, Object iso_extension_mask, Object i_fuzz) {
		return ModernizedCProgram.iso9660_open_ext_private(psz_path, iso_extension_mask, i_fuzz, true/*! Close previously opened ISO 9660 image and free resources
		    associated with the image. Call this when done using using an ISO
		    9660 image.
		
		    @return true is unconditionally returned. If there was an error
		    false would be returned.
		*/);
	}
	public static Object iso9660_close(Object p_iso) {
		if (NULL != p_iso) {
			p_iso.getStream().cdio_stdio_destroy();
			p_iso.setStream(NULL);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_iso);
		} 
		return true;
	}
	public static Object check_pvd(Object p_pvd, Object log_level) {
		if (ISO_VD_PRIMARY != /*Error: Function owner not recognized*/from_711(p_pvd.getType())) {
			return false;
		} 
		// Commented out for Rufus usage
		return true/*!
		  Core procedure for the iso9660_ifs_get_###_id() calls.
		  pvd_member/svd_member is a pointer to an achar_t or dchar_t
		  ID string which we can superset as char.
		  If the Joliet converted string is the same as the achar_t/dchar_t
		  one, we fall back to using the latter, as it may be longer.
		*/;
	}
	public static Object get_member_id(Object p_iso, Object p_psz_member_id, byte[] pvd_member, Byte svd_member, Object max_size) {
		int j;
		 strip = new ();
		if (!p_iso) {
			p_psz_member_id = NULL;
			return false/* Translate USC-2 string from Secondary Volume Descriptor */;
		} 
		/* NB: *p_psz_member_id is never NULL on success. *//* Strip trailing spaces */
		/* Joliet string is not empty and differs from
		             non Joliet one => use it *//* Joliet string is not empty and differs from
		             non Joliet one => use it */p_psz_member_id = /*Error: Function owner not recognized*/calloc(max_size + 1, /*Error: Unsupported expression*//* Joliet string was either empty or same *//*HAVE_JOLIET*/);
		if (!p_psz_member_id) {
			ModernizedCProgram.cdio_warn("Memory allocation error");
			return false;
		} 
		(p_psz_member_id)[max_size] = /* Copy string while removing trailing spaces */0;
		for (; j >= 0; j--) {
			if (strip && (pvd_member[j] == (byte)' ')) {
				continue;
			} 
			strip = false;
			(p_psz_member_id)[j] = pvd_member[j];
		}
		if (/*Error: Function owner not recognized*/strlen(p_psz_member_id) == 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_psz_member_id);
			p_psz_member_id = NULL;
			return false;
		} 
		return true/*!
		  Return the application ID.  NULL is returned in psz_app_id if there
		  is some problem in getting this.
		*/;
	}
	public static Object iso9660_ifs_get_application_id(Object p_iso, Object p_psz_app_id) {
		return ModernizedCProgram.get_member_id(p_iso, p_psz_app_id, (byte)p_iso.getPvd().getApplication_id(), (byte)p_iso.getSvd().getApplication_id(), ISO_MAX_APPLICATION_ID/*!
		  Return the Joliet level recognized for p_iso.
		*/);
	}
	/*out*/
	public static Object iso9660_ifs_get_joliet_level(Object p_iso) {
		if (!p_iso) {
			return 0;
		} 
		return p_iso.getU_joliet_level();
	}
	public static Object iso9660_ifs_get_preparer_id(Object p_iso, Object p_psz_preparer_id) {
		return ModernizedCProgram.get_member_id(p_iso, p_psz_preparer_id, (byte)p_iso.getPvd().getPreparer_id(), (byte)p_iso.getSvd().getPreparer_id(), ISO_MAX_PREPARER_ID/*!
		   Return a string containing the PVD's publisher id with trailing
		   blanks removed.
		*/);
	}
	/*out*/
	public static Object iso9660_ifs_get_publisher_id(Object p_iso, Object p_psz_publisher_id) {
		return ModernizedCProgram.get_member_id(p_iso, p_psz_publisher_id, (byte)p_iso.getPvd().getPublisher_id(), (byte)p_iso.getSvd().getPublisher_id(), ISO_MAX_PUBLISHER_ID/*!
		   Return a string containing the PVD's publisher id with trailing
		   blanks removed.
		*/);
	}
	/*out*/
	public static Object iso9660_ifs_get_system_id(Object p_iso, Object p_psz_system_id) {
		return ModernizedCProgram.get_member_id(p_iso, p_psz_system_id, (byte)p_iso.getPvd().getSystem_id(), (byte)p_iso.getSvd().getSystem_id(), ISO_MAX_SYSTEM_ID/*!
		   Return a string containing the PVD's publisher id with trailing
		   blanks removed.
		*/);
	}
	/*out*/
	public static Object iso9660_ifs_get_volume_id(Object p_iso, Object p_psz_volume_id) {
		return ModernizedCProgram.get_member_id(p_iso, p_psz_volume_id, (byte)p_iso.getPvd().getVolume_id(), (byte)p_iso.getSvd().getVolume_id(), ISO_MAX_VOLUME_ID/*!
		   Return a string containing the PVD's publisher id with trailing
		   blanks removed.
		*/);
	}
	/*out*/
	public static Object iso9660_ifs_get_volumeset_id(Object p_iso, Object p_psz_volumeset_id) {
		return ModernizedCProgram.get_member_id(p_iso, p_psz_volumeset_id, (byte)p_iso.getPvd().getVolume_set_id(), (byte)p_iso.getSvd().getVolume_set_id(), ISO_MAX_VOLUMESET_ID/*!
		  Read the Primary Volume Descriptor for an ISO 9660 image.
		  True is returned if read, and false if there was an error.
		*/);
	}
	/*out*/
	public static Object iso9660_ifs_read_pvd_loglevel(Object p_iso, Object p_pvd, Object log_level) {
		if (0 == ModernizedCProgram.iso9660_iso_seek_read(p_iso, p_pvd, ISO_PVD_SECTOR, 1)) {
			return false;
		} 
		// Commented out for Rufus usage
		return ModernizedCProgram.check_pvd(p_pvd, log_level/*!
		  Read the Primary Volume Descriptor for an ISO 9660 image.
		  True is returned if read, and false if there was an error.
		*/);
	}
	/*out*/
	/*out*/
	public static Object iso9660_ifs_read_pvd(Object p_iso, Object p_pvd) {
		return ModernizedCProgram.iso9660_ifs_read_pvd_loglevel(p_iso, p_pvd, CDIO_LOG_WARN/*!
		  Read the Super block of an ISO 9660 image. This is the
		  Primary Volume Descriptor (PVD) and perhaps a Supplemental Volume
		  Descriptor if (Joliet) extensions are acceptable.
		*/);
	}
	public static Object iso9660_ifs_read_superblock(Object p_iso, Object iso_extension_mask) {
		/* Secondary volume descriptor. */ p_svd = new ();
		int i;
		if (!p_iso || !ModernizedCProgram.iso9660_ifs_read_pvd(p_iso, (p_iso.getPvd()))) {
			return false;
		} 
		p_iso.setU_joliet_level(0);
		for (i = 1; (0 != ModernizedCProgram.iso9660_iso_seek_read(p_iso, p_svd, ISO_PVD_SECTOR + i, 1)); /* There may be multiple Secondary Volume Descriptors (eg. El Torito + Joliet) */i++) {
			if (ISO_VD_END == /*Error: Function owner not recognized*/from_711(p_svd.getType())) {
				break;
			} 
			if (ISO_VD_SUPPLEMENTARY == /*Error: Function owner not recognized*/from_711(p_svd.getType())) {
				if (p_iso.getU_joliet_level() == /* We're only interested in Joliet => make sure the SVD isn't overwritten */0) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_iso.getSvd()), p_svd, /*Error: Unsupported expression*/);
				} 
				if (p_svd.getEscape_sequences()[0] == -1024 && p_svd.getEscape_sequences()[1] == -1024) {
					switch (p_svd.getEscape_sequences()[2]) {
					case -1024:
							if (iso_extension_mask & ISO_EXTENSION_JOLIET_LEVEL1) {
								p_iso.setU_joliet_level(1);
							} 
							break;
					case -1024:
							if (iso_extension_mask & ISO_EXTENSION_JOLIET_LEVEL3) {
								p_iso.setU_joliet_level(3);
							} 
							break;
					case -1024:
							if (iso_extension_mask & ISO_EXTENSION_JOLIET_LEVEL2) {
								p_iso.setU_joliet_level(2);
							} 
							break;
					default:
							ModernizedCProgram.cdio_info("Supplementary Volume Descriptor found, but not Joliet");
					}
					if (p_iso.getU_joliet_level() > 0) {
						ModernizedCProgram.cdio_info("Found Extension: Joliet Level %d", p_iso.getU_joliet_level());
					} 
				} 
			} 
		}
		return true/*!
		  Read the Super block of an ISO 9660 image but determine framesize
		  and datastart and a possible additional offset. Generally here we are
		  not reading an ISO 9660 image but a CD-Image which contains an ISO 9660
		  filesystem.
		*/;
	}
	public static Object iso9660_ifs_fuzzy_read_superblock(Object p_iso, Object iso_extension_mask, Object i_fuzz) {
		/* Got some work to do to find ISO_STANDARD_ID ("CD001") */int i;
		for (i = 0; i < i_fuzz; i++) {
			int j;
			byte pvd = NULL;
			for (j = 0; j <= 1; j++) {
				 lsn = new ();
				 k = new ();
				[] framesizes = new []{ISO_BLOCKSIZE, CDIO_CD_FRAMESIZE_RAW, M2RAW_SECTOR_SIZE};
				if (0 == i && /* We don't need to loop over a zero offset twice*/j) {
					continue;
				} 
				lsn = (j) ? ISO_PVD_SECTOR - i : ISO_PVD_SECTOR + i;
				for (k = 0; k < 3; k++) {
					byte p;
					byte q;
					byte[] frame = new byte[]{(byte)'\0'};
					p_iso.setI_framesize(framesizes[k]);
					p_iso.setI_datastart((ISO_BLOCKSIZE == framesizes[k]) ? 0 : CDIO_CD_SYNC_SIZE);
					p_iso.setI_fuzzy_offset(0);
					if (0 == ModernizedCProgram.iso9660_seek_read_framesize(p_iso, frame, lsn, 1, p_iso.getI_framesize())) {
						return false;
					} 
					q = /*Error: Function owner not recognized*/memchr(frame, (byte)'C', p_iso.getI_framesize());
					for (p = q; p && p < frame + p_iso.getI_framesize(); p = q + 1) {
						q = /*Error: Function owner not recognized*/memchr(p, (byte)'C', p_iso.getI_framesize() - (p - frame));
						if (!q || (pvd = /*Error: Function owner not recognized*/strstr(q, ModernizedCProgram.ISO_STANDARD_ID))) {
							break;
						} 
					}
					if (pvd) {
						p_iso.setI_fuzzy_offset((pvd - frame - /* Yay! Found something */1) - ((ISO_PVD_SECTOR - lsn) * p_iso.getI_framesize()));
						if (ModernizedCProgram.iso9660_ifs_read_pvd_loglevel(p_iso, (p_iso.getPvd()), CDIO_LOG_DEBUG)) {
							ModernizedCProgram.adjust_fuzzy_pvd(p_iso);
							return true;
						} 
					} 
				}
			}
		}
		return false/*!
		  Read the Primary Volume Descriptor for of CD.
		*/;
	}
	/*out*/
	public static Object iso9660_fs_read_pvd(Object p_cdio, Object p_pvd) {
		byte[] buf = new byte[]{/* A bit of a hack, we'll assume track 1 contains ISO_PVD_SECTOR.*/0};
		 driver_return = ModernizedCProgram.cdio_read_data_sectors(p_cdio, buf, ISO_PVD_SECTOR, ISO_BLOCKSIZE, 1);
		if (DRIVER_OP_SUCCESS != driver_return) {
			ModernizedCProgram.cdio_warn("error reading PVD sector (%d) error %d", ISO_PVD_SECTOR, driver_return);
			return false/* The size of a PVD or SVD is smaller than a sector. So we
			     allocated a bigger block above (buf) and now we'll copy just
			     the part we need to save.
			   */;
		} 
		((/*Error: sizeof expression not supported yet*/ >= /*Error: Unsupported expression*/) ? (Object)0 : /*Error: Function owner not recognized*/_assert("sizeof(buf) >= sizeof (iso9660_pvd_t)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 636));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_pvd, buf, /*Error: Unsupported expression*/);
		return ModernizedCProgram.check_pvd(p_pvd, CDIO_LOG_WARN/*!
		  Read the Super block of an ISO 9660 image. This is the
		  Primary Volume Descriptor (PVD) and perhaps a Supplemental Volume
		  Descriptor if (Joliet) extensions are acceptable.
		*/);
	}
	public static Object iso9660_fs_read_superblock(Object p_cdio, Object iso_extension_mask) {
		if (!p_cdio) {
			return false;
		} 
		Object generatedPvd = p_env.getPvd();
		Object generatedSvd = p_env.getSvd();
		Object generatedU_joliet_level = p_env.getU_joliet_level();
		{ 
			generic_img_private_t p_env = (generic_img_private_t)p_cdio.getEnv();
			 p_pvd = (generatedPvd);
			 p_svd = (generatedSvd);
			byte[] buf = new byte[]{0};
			 driver_return = new ();
			if (!ModernizedCProgram.iso9660_fs_read_pvd(p_cdio, p_pvd)) {
				return false;
			} 
			p_env.setU_joliet_level(0);
			driver_return = ModernizedCProgram.cdio_read_data_sectors(p_cdio, buf, ISO_PVD_SECTOR + 1, ISO_BLOCKSIZE, 1);
			if (DRIVER_OP_SUCCESS == driver_return/* The size of a PVD or SVD is smaller than a sector. So we
				 allocated a bigger block above (buf) and now we'll copy just
				 the part we need to save.
			      */) {
				((/*Error: sizeof expression not supported yet*/ >= /*Error: Unsupported expression*/) ? (Object)0 : /*Error: Function owner not recognized*/_assert("sizeof(buf) >= sizeof (iso9660_svd_t)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 675));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_svd, buf, /*Error: Unsupported expression*/);
				if (ISO_VD_SUPPLEMENTARY == /*Error: Function owner not recognized*/from_711(p_svd.getType())) {
					if (p_svd.getEscape_sequences()[0] == -1024 && p_svd.getEscape_sequences()[1] == -1024) {
						switch (p_svd.getEscape_sequences()[2]) {
						case -1024:
								if (iso_extension_mask & ISO_EXTENSION_JOLIET_LEVEL2) {
									p_env.setU_joliet_level(2);
								} 
								break;
						case -1024:
								if (iso_extension_mask & ISO_EXTENSION_JOLIET_LEVEL1) {
									p_env.setU_joliet_level(1);
								} 
								break;
						case -1024:
								if (iso_extension_mask & ISO_EXTENSION_JOLIET_LEVEL3) {
									p_env.setU_joliet_level(3);
								} 
								break;
						default:
								ModernizedCProgram.cdio_info("Supplementary Volume Descriptor found, but not Joliet");
						}
						if (generatedU_joliet_level > 0) {
							ModernizedCProgram.cdio_info("Found Extension: Joliet Level %d", generatedU_joliet_level);
						} 
					} 
				} 
			} 
		}
		return true/*!
		  Seek to a position and then read n blocks. Size read is returned.
		*/;
	}
	public static long iso9660_seek_read_framesize(Object p_iso, Object ptr, Object start, long size, Object i_framesize) {
		long ret;
		 i_byte_offset = new ();
		if (!p_iso) {
			return 0;
		} 
		i_byte_offset = (start * /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_iso.getI_framesize())) + p_iso.getI_fuzzy_offset() + p_iso.getI_datastart();
		ret = p_iso.getStream().cdio_stream_seek(i_byte_offset, SEEK_SET);
		if (ret != 0) {
			return 0;
		} 
		return p_iso.getStream().cdio_stream_read(ptr, i_framesize, size/*!
		  Seek to a position and then read n blocks. Size read is returned.
		*/);
	}
	public static long iso9660_iso_seek_read(Object p_iso, Object ptr, Object start, long size) {
		return ModernizedCProgram.iso9660_seek_read_framesize(p_iso, ptr, start, size, ISO_BLOCKSIZE/*!
		  Check for the end of a directory record list in a single directory
		  block.  If at the end, set the offset to start of the next block and
		  return "true". The caller often skips actions only when at the end
		  of a record list.
		*/);
	}
	public static Object iso9660_check_dir_block_end(Object p_iso9660_dir, Integer offset) {
		if (!ModernizedCProgram.iso9660_get_dir_len(p_iso9660_dir/*
			 Length 0 indicates that no more directory records are in this
			 block. This matches how Linux and libburn's libisofs work.
		
			 Note that assignment below does not exactly round up.
			 If (offset % ISO_BLOCKSIZE) == 0  then offset is incremented
			 by ISO_BLOCKSIZE, i.e. the block is skipped.
		      */)) {
			offset += ISO_BLOCKSIZE - (offset % ISO_BLOCKSIZE);
			return true;
		} 
		if ((offset + ModernizedCProgram.iso9660_get_dir_len(p_iso9660_dir) - 1) / ISO_BLOCKSIZE != offset / ISO_BLOCKSIZE/*
			 Directory record spans over block limit.
			 Hop to next block where a new record is supposed to begin,
			 if it is not after the end of the directory data.
		       */) {
			offset += ISO_BLOCKSIZE - (offset % ISO_BLOCKSIZE);
			return true;
		} 
		return false;
	}
	public static Object _iso9660_dir_to_statbuf(Object p_iso9660_dir, Object last_p_stat, Object b_xa, Object u_joliet_level) {
		 dir_len = ModernizedCProgram.iso9660_get_dir_len(p_iso9660_dir);
		 i_fname = new ();
		int stat_len;
		 p_stat = last_p_stat;
		byte[] rr_fname = "";
		int i_rr_fname;
		if (!dir_len) {
			return NULL;
		} 
		i_fname = /*Error: Function owner not recognized*/from_711(p_iso9660_dir.getFilename().getLen());
		stat_len = /*Error: Unsupported expression*/ + i_fname + /* .. string in statbuf is one longer than in p_iso9660_dir's listing '\1' */2;
		if (!/* Reuse multiextent p_stat if not NULL */p_stat) {
			p_stat = /*Error: Function owner not recognized*/calloc(1, stat_len);
		} 
		if (!p_stat) {
			ModernizedCProgram.cdio_warn("Couldn't calloc(1, %d)", stat_len);
			return NULL;
		} 
		p_stat.setType((p_iso9660_dir.getFile_flags() & ISO_DIRECTORY) ? _STAT_DIR : _STAT_FILE);
		p_stat.getLsn()[p_stat.getExtents()] = ModernizedCProgram.from_733(p_iso9660_dir.getExtent());
		p_stat.getExtsize()[p_stat.getExtents()] = ModernizedCProgram.from_733(p_iso9660_dir.getSize());
		p_stat.getSize() += p_stat.getExtsize()[p_stat.getExtents()];
		p_stat.getSecsize()[p_stat.getExtents()] = ModernizedCProgram._cdio_len2blocks(p_stat.getExtsize()[p_stat.getExtents()], ISO_BLOCKSIZE);
		p_stat.getRr().setB3_rock(/*FIXME should do based on mask */dunno);
		p_stat.setB_xa(false);
		if ((p_iso9660_dir.getFile_flags() & ISO_MULTIEXTENT) == /* Only resolve the full filename when we're not dealing with extent */0) {
			if (p_stat.getExtents() != /* Check if this is the last part of a multiextent file */0) {
				if (/*Error: Function owner not recognized*/strcmp(p_stat.getFilename(), p_iso9660_dir.getFilename().getStr()[1]) != 0) {
					ModernizedCProgram.cdio_warn("Warning: Non consecutive multiextent file parts for '%s'", p_stat.getFilename());
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_stat);
					return NULL;
				} 
			} 
			i_rr_fname = 0;
			if (i_rr_fname > 0) {
				if (i_rr_fname > i_fname/* realloc gives valgrind errors */) {
					 p_stat_new = /*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/ + i_rr_fname + 2);
					if (!p_stat_new) {
						ModernizedCProgram.cdio_warn("Couldn't calloc(1, %d)", (int)(/*Error: Unsupported expression*/ + i_rr_fname + 2));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_stat);
						return NULL;
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_stat_new, p_stat, stat_len);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_stat);
					p_stat = p_stat_new;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(p_stat.getFilename(), rr_fname, i_rr_fname + 1);
			} else {
					if ((byte)'\0' == p_iso9660_dir.getFilename().getStr()[1] && 1 == i_fname) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(p_stat.getFilename(), ".", 2);
					}  else if ((byte)'\1' == p_iso9660_dir.getFilename().getStr()[1] && 1 == i_fname) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(p_stat.getFilename(), "..", 3);
					} else {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(p_stat.getFilename(), p_iso9660_dir.getFilename().getStr()[1], /*HAVE_JOLIET*/i_fname);
					} 
			} 
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(p_stat.getFilename(), p_iso9660_dir.getFilename().getStr()[1], /* Use the plain ISO-9660 name when dealing with a multiextent file part */i_fname);
		} 
		if (p_stat.getExtents() >= ISO_MAX_MULTIEXTENT) {
			ModernizedCProgram.cdio_warn("Warning: Too many multiextent file parts for '%s'", p_stat.getFilename());
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_stat.getRr().getPsz_symlink());
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_stat);
			return NULL;
		} 
		p_stat.getExtents()++;
		(p_stat.getTm()).iso9660_get_dtime((p_iso9660_dir.getRecording_time()), true);
		if (dir_len < /*Error: Unsupported expression*/) {
			ModernizedCProgram.iso9660_stat_free(p_stat);
			return NULL;
		} 
		{ 
			int su_length = ModernizedCProgram.iso9660_get_dir_len(p_iso9660_dir) - /*Error: Unsupported expression*/;
			su_length -= i_fname;
			if (su_length % 2) {
				su_length--;
			} 
			if (su_length < 0 || su_length < /*Error: Unsupported expression*/) {
				return p_stat;
			} 
			if (nope == b_xa) {
				return p_stat;
			} else {
					 xa_data = (Object)(((byte)p_iso9660_dir) + (ModernizedCProgram.iso9660_get_dir_len(p_iso9660_dir) - su_length));
					 loglevel = (yep == b_xa) ? CDIO_LOG_WARN : CDIO_LOG_INFO;
					if (xa_data.getSignature()[0] != (byte)'X' || xa_data.getSignature()[1] != (byte)'A') {
						ModernizedCProgram.cdio_log(loglevel, "XA signature not found in ISO9660's system use area; ignoring XA attributes for this file entry.");
						ModernizedCProgram.cdio_debug("%d %d %d, '%c%c' (%d, %d)", ModernizedCProgram.iso9660_get_dir_len(p_iso9660_dir), i_fname, su_length, xa_data.getSignature()[0], xa_data.getSignature()[1], xa_data.getSignature()[0], xa_data.getSignature()[1]);
						return p_stat;
					} 
					p_stat.setB_xa(true);
					p_stat.setXa(xa_data);
			} 
		}
		return p_stat/*!
		  Return the directory name stored in the iso9660_dir_t
		
		  A string is allocated: the caller must deallocate. This routine
		  can return NULL if memory allocation fails.
		 */;
	}
	public static Byte iso9660_dir_to_name(Object iso9660_dir) {
		 len = ModernizedCProgram.iso9660_get_dir_len(iso9660_dir);
		if (!len) {
			return NULL;
		} 
		((len >= /*Error: Unsupported expression*/) ? (Object)0 : /*Error: Function owner not recognized*/_assert("len >= sizeof (iso9660_dir_t)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 950));
		if (iso9660_dir.getFilename().getStr()[1] == /* (iso9660_dir->file_flags & ISO_DIRECTORY) */(byte)'\0') {
			return /*Error: Function owner not recognized*/strdup(".");
		}  else if (iso9660_dir.getFilename().getStr()[1] == (byte)'\1') {
			return /*Error: Function owner not recognized*/strdup("..");
		} else {
				return /*Error: Function owner not recognized*/strdup(iso9660_dir.getFilename().getStr()[1/*
				   Return a pointer to a ISO 9660 stat buffer or NULL if there's an error
				*/]);
		} 
	}
	public static Object _fs_stat_root(Object p_cdio) {
		if (!p_cdio) {
			return NULL;
		} 
		Object generatedU_joliet_level = p_env.getU_joliet_level();
		Object generatedPvd = p_env.getPvd();
		{ 
			 iso_extension_mask = ISO_EXTENSION_ALL;
			generic_img_private_t p_env = (generic_img_private_t)p_cdio.getEnv();
			 p_iso9660_dir = new ();
			 p_stat = new ();
			 b_xa = new ();
			if (!generatedU_joliet_level) {
				iso_extension_mask &=  ~ISO_EXTENSION_JOLIET;
			} 
			if (!ModernizedCProgram.iso9660_fs_read_superblock(p_cdio, /* FIXME try also with Joliet.*/iso_extension_mask)) {
				ModernizedCProgram.cdio_warn("Could not read ISO-9660 Superblock.");
				return NULL;
			} 
			switch (ModernizedCProgram.cdio_get_discmode(p_cdio)) {
			case CDIO_DISC_MODE_CD_DATA:
					b_xa = nope;
					break;
			case CDIO_DISC_MODE_CD_XA:
					b_xa = yep;
					break;
			default:
					b_xa = dunno;
			}
			p_iso9660_dir = (generatedPvd.getRoot_directory_record());
			p_stat = ModernizedCProgram._iso9660_dir_to_statbuf(p_iso9660_dir, NULL, b_xa, generatedU_joliet_level);
			return p_stat;
		}
	}
	public static Object _ifs_stat_root(Object p_iso) {
		 p_stat = new ();
		 p_iso9660_dir = new ();
		p_iso9660_dir = (p_iso.getPvd().getRoot_directory_record());
		p_stat = ModernizedCProgram._iso9660_dir_to_statbuf(p_iso9660_dir, NULL, p_iso.getB_xa(), p_iso.getU_joliet_level());
		return p_stat;
	}
	public static Object _fs_stat_traverse(Object p_cdio, Object _root, byte[][] splitpath) {
		int offset = 0;
		 _dirbuf = NULL;
		 p_stat = new ();
		generic_img_private_t p_env = (generic_img_private_t)p_cdio.getEnv();
		if (!splitpath[0]) {
			int len = /*Error: Unsupported expression*/ + /*Error: Function owner not recognized*/strlen(_root.getFilename()) + 1;
			p_stat = /*Error: Function owner not recognized*/calloc(1, len);
			((p_stat != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_stat != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1047));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_stat, _root, len);
			p_stat.getRr().setPsz_symlink(/*Error: Function owner not recognized*/calloc(1, p_stat.getRr().getI_symlink_max()));
			((p_stat.getRr().getPsz_symlink() != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_stat->rr.psz_symlink != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1050));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_stat.getRr().getPsz_symlink(), _root.getRr().getPsz_symlink(), p_stat.getRr().getI_symlink_max());
			return p_stat;
		} 
		if (_root.getType() == _STAT_FILE) {
			return NULL;
		} 
		((_root.getType() == _STAT_DIR) ? (Object)0 : /*Error: Function owner not recognized*/_assert("_root->type == _STAT_DIR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1059));
		_dirbuf = /*Error: Function owner not recognized*/calloc(1, _root.getSecsize()[0] * ISO_BLOCKSIZE);
		if (!_dirbuf) {
			ModernizedCProgram.cdio_warn("Couldn't calloc(1, %d)", _root.getSecsize()[0] * ISO_BLOCKSIZE);
			return NULL;
		} 
		if (ModernizedCProgram.cdio_read_data_sectors(p_cdio, _dirbuf, _root.getLsn()[0], ISO_BLOCKSIZE, _root.getSecsize()[0])) {
			return NULL;
		} 
		Object generatedU_joliet_level = p_env.getU_joliet_level();
		while (offset < (_root.getSecsize()[0] * ISO_BLOCKSIZE)) {
			 p_iso9660_dir = (Object)_dirbuf[offset];
			 p_iso9660_stat = new ();
			int cmp;
			if (ModernizedCProgram.iso9660_check_dir_block_end(p_iso9660_dir, offset)) {
				continue;
			} 
			p_iso9660_stat = ModernizedCProgram._iso9660_dir_to_statbuf(p_iso9660_dir, NULL, dunno, generatedU_joliet_level);
			cmp = /*Error: Function owner not recognized*/strcmp(splitpath[0], p_iso9660_stat.getFilename());
			if (0 != cmp && 0 == generatedU_joliet_level && yep != p_iso9660_stat.getRr().getB3_rock()) {
				byte trans_fname = NULL;
				int i_trans_fname = /*Error: Function owner not recognized*/strlen(p_iso9660_stat.getFilename());
				if (i_trans_fname) {
					trans_fname = /*Error: Function owner not recognized*/calloc(1, i_trans_fname + 1);
					if (!trans_fname) {
						ModernizedCProgram.cdio_warn("can't allocate %lu bytes", (long)/*Error: Function owner not recognized*/strlen(p_iso9660_stat.getFilename()));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_iso9660_stat);
						return NULL;
					} 
					ModernizedCProgram.iso9660_name_translate_ext(p_iso9660_stat.getFilename(), trans_fname, generatedU_joliet_level);
					cmp = /*Error: Function owner not recognized*/strcmp(splitpath[0], trans_fname);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(trans_fname);
				} 
			} 
			if (!cmp) {
				 ret_stat = ModernizedCProgram._fs_stat_traverse(p_cdio, p_iso9660_stat, splitpath[1]);
				ModernizedCProgram.iso9660_stat_free(p_iso9660_stat);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_dirbuf);
				return ret_stat;
			} 
			ModernizedCProgram.iso9660_stat_free(p_iso9660_stat);
			offset += ModernizedCProgram.iso9660_get_dir_len(p_iso9660_dir);
		}
		((offset == (_root.getSecsize()[0] * ISO_BLOCKSIZE)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("offset == (_root->secsize[0] * ISO_BLOCKSIZE)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1119));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(/* not found */_dirbuf);
		return NULL;
	}
	public static Object _fs_iso_stat_traverse(Object p_iso, Object _root, byte[][] splitpath) {
		int offset = 0;
		 _dirbuf = NULL;
		int ret;
		int cmp;
		 p_stat = NULL;
		 p_iso9660_dir = NULL;
		if (!splitpath[0]) {
			int len = /*Error: Unsupported expression*/ + /*Error: Function owner not recognized*/strlen(_root.getFilename()) + 1;
			p_stat = /*Error: Function owner not recognized*/calloc(1, len);
			((p_stat != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_stat != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1140));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_stat, _root, len);
			p_stat.getRr().setPsz_symlink(/*Error: Function owner not recognized*/calloc(1, p_stat.getRr().getI_symlink_max()));
			((p_stat.getRr().getPsz_symlink() != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_stat->rr.psz_symlink != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1143));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_stat.getRr().getPsz_symlink(), _root.getRr().getPsz_symlink(), p_stat.getRr().getI_symlink_max());
			return p_stat;
		} 
		if (_root.getType() == _STAT_FILE) {
			return NULL;
		} 
		((_root.getType() == _STAT_DIR) ? (Object)0 : /*Error: Function owner not recognized*/_assert("_root->type == _STAT_DIR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1152));
		_dirbuf = /*Error: Function owner not recognized*/calloc(1, _root.getSecsize()[0] * ISO_BLOCKSIZE);
		if (!_dirbuf) {
			ModernizedCProgram.cdio_warn("Couldn't calloc(1, %d)", _root.getSecsize()[0] * ISO_BLOCKSIZE);
			return NULL;
		} 
		ret = ModernizedCProgram.iso9660_iso_seek_read(p_iso, _dirbuf, _root.getLsn()[0], _root.getSecsize()[0]);
		if (ret != ISO_BLOCKSIZE * _root.getSecsize()[0]) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_dirbuf);
			return NULL;
		} 
		for (offset = 0; offset < (_root.getSecsize()[0] * ISO_BLOCKSIZE); offset += ModernizedCProgram.iso9660_get_dir_len(p_iso9660_dir)) {
			p_iso9660_dir = (Object)_dirbuf[offset];
			if (ModernizedCProgram.iso9660_check_dir_block_end(p_iso9660_dir, offset)) {
				continue;
			} 
			p_stat = ModernizedCProgram._iso9660_dir_to_statbuf(p_iso9660_dir, p_stat, p_iso.getB_xa(), p_iso.getU_joliet_level());
			if (!p_stat) {
				ModernizedCProgram.cdio_warn("Bad directory information for %s", splitpath[0]);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_dirbuf);
				return NULL;
			} 
			if (p_iso9660_dir.getFile_flags() & /* If we have multiextent file parts, loop until the last one */ISO_MULTIEXTENT) {
				continue;
			} 
			cmp = /*Error: Function owner not recognized*/strcmp(splitpath[0], p_stat.getFilename());
			if (0 != cmp && 0 == p_iso.getU_joliet_level() && yep != p_stat.getRr().getB3_rock()) {
				byte trans_fname = NULL;
				int i_trans_fname = /*Error: Function owner not recognized*/strlen(p_stat.getFilename());
				if (i_trans_fname) {
					trans_fname = /*Error: Function owner not recognized*/calloc(1, i_trans_fname + 1);
					if (!trans_fname) {
						ModernizedCProgram.cdio_warn("can't allocate %lu bytes", (long)/*Error: Function owner not recognized*/strlen(p_stat.getFilename()));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_stat);
						return NULL;
					} 
					ModernizedCProgram.iso9660_name_translate_ext(p_stat.getFilename(), trans_fname, p_iso.getU_joliet_level());
					cmp = /*Error: Function owner not recognized*/strcmp(splitpath[0], trans_fname);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(trans_fname);
				} 
			} 
			if (!cmp) {
				 ret_stat = ModernizedCProgram._fs_iso_stat_traverse(p_iso, p_stat, splitpath[1]);
				ModernizedCProgram.iso9660_stat_free(p_stat);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_dirbuf);
				return ret_stat;
			} 
			ModernizedCProgram.iso9660_stat_free(p_stat);
			p_stat = NULL;
		}
		((offset == (_root.getSecsize()[0] * ISO_BLOCKSIZE)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("offset == (_root->secsize[0] * ISO_BLOCKSIZE)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1221));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(/* not found */_dirbuf);
		return NULL/*!
		  Return file status for psz_path. NULL is returned on error.
		
		  @param p_cdio the CD object to read from
		
		  @param psz_path filename path to look up and get information about
		
		  @return ISO 9660 file information
		
		  Important note:
		
		  You make get different results looking up "/" versus "/." and the
		  latter may give more complete information. "/" will take information
		  from the PVD only, whereas "/." will force a directory read of "/" and
		  find "." and in that Rock-Ridge information might be found which fills
		  in more stat information. Ideally iso9660_fs_stat should be fixed.
		  Patches anyone?
		 */;
	}
	public static Object iso9660_fs_stat(Object p_cdio, Object psz_path) {
		 p_root = new ();
		byte p_psz_splitpath;
		 p_stat = new ();
		if (!p_cdio) {
			return NULL;
		} 
		if (!psz_path) {
			return NULL;
		} 
		p_root = ModernizedCProgram._fs_stat_root(p_cdio);
		if (!p_root) {
			return NULL;
		} 
		p_psz_splitpath = ModernizedCProgram._cdio_strsplit(psz_path, (byte)'/');
		p_stat = ModernizedCProgram._fs_stat_traverse(p_cdio, p_root, p_psz_splitpath);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_root);
		ModernizedCProgram._cdio_strfreev(p_psz_splitpath);
		return p_stat;
	}
	/*!
	  Get file status for psz_path into stat. NULL is returned on error.
	  pathname version numbers in the ISO 9660
	  name are dropped, i.e. ;1 is removed and if level 1 ISO-9660 names
	  are lowercased.
	 */
	public static Object fs_stat_translate(Object p_image, Object stat_root, Object stat_traverse, Object psz_path) {
		 p_root = new ();
		byte p_psz_splitpath;
		 p_stat = new ();
		if (!p_image) {
			return NULL;
		} 
		if (!psz_path) {
			return NULL;
		} 
		p_root = /*Error: Function owner not recognized*/stat_root(p_image);
		if (!p_root) {
			return NULL;
		} 
		p_psz_splitpath = ModernizedCProgram._cdio_strsplit(psz_path, (byte)'/');
		p_stat = /*Error: Function owner not recognized*/stat_traverse(p_image, p_root, p_psz_splitpath);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_root);
		ModernizedCProgram._cdio_strfreev(p_psz_splitpath);
		return p_stat/*!
		  Return file status for path name psz_path. NULL is returned on error.
		  pathname version numbers in the ISO 9660 name are dropped, i.e. ;1
		  is removed and if level 1 ISO-9660 names are lowercased.
		
		  @param p_cdio the CD object to read from
		
		  @param psz_path filename path to look up and get information about
		
		  @return ISO 9660 file information.  The caller must free the
		  returned result using iso9660_stat_free().
		
		 */;
	}
	public static Object iso9660_fs_stat_translate(Object p_cdio, Object psz_path) {
		return ModernizedCProgram.fs_stat_translate(p_cdio, (stat_root_t)_fs_stat_root, (stat_traverse_t)_fs_stat_traverse, psz_path/*!
		  @param p_iso the ISO-9660 file image to get data from
		
		  @param psz_path filename path translate
		
		  @return file status for path name psz_path. NULL is returned on
		  error.  pathname version numbers in the ISO 9660 name are dropped,
		  i.e. ;1 is removed and if level 1 ISO-9660 names are lowercased.
		  The caller must free the returned result using iso9660_stat_free().
		 */);
	}
	public static Object iso9660_ifs_stat_translate(Object p_iso, Object psz_path) {
		return ModernizedCProgram.fs_stat_translate(p_iso, (stat_root_t)_ifs_stat_root, (stat_traverse_t)_fs_iso_stat_traverse, psz_path/*!
		
		  @param p_cdio the CD object to read from
		
		  @param pzs_path path the look up
		
		  @return file status for pathname. NULL is returned on error.
		  The caller must free the returned result using iso9660_stat_free().
		 */);
	}
	public static Object iso9660_ifs_stat(Object p_iso, Object psz_path) {
		 p_root = new ();
		byte splitpath;
		 stat = new ();
		if (!p_iso) {
			return NULL;
		} 
		if (!psz_path) {
			return NULL;
		} 
		p_root = ModernizedCProgram._ifs_stat_root(p_iso);
		if (!p_root) {
			return NULL;
		} 
		splitpath = ModernizedCProgram._cdio_strsplit(psz_path, (byte)'/');
		stat = ModernizedCProgram._fs_iso_stat_traverse(p_iso, p_root, splitpath);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_root);
		ModernizedCProgram._cdio_strfreev(splitpath);
		return stat/*!
		  Read psz_path (a directory) and return a list of iso9660_stat_t
		  pointers for the files inside that directory.
		
		  @param p_cdio the CD object to read from
		
		  @param pzs_path path the read the directory from.
		
		  @return file status for psz_path. The caller must free the
		  The caller must free the returned result using iso9660_stat_free().
		*/;
	}
	public static Object iso9660_fs_readdir(Object p_cdio, Object psz_path) {
		generic_img_private_t p_env = new generic_img_private_t();
		 p_iso9660_dir = new ();
		 p_iso9660_stat = NULL;
		 p_stat = new ();
		if (!p_cdio) {
			return NULL;
		} 
		if (!psz_path) {
			return NULL;
		} 
		p_env = (generic_img_private_t)p_cdio.getEnv();
		p_stat = ModernizedCProgram.iso9660_fs_stat(p_cdio, psz_path);
		if (!p_stat) {
			return NULL;
		} 
		if (p_stat.getType() != _STAT_DIR) {
			ModernizedCProgram.iso9660_stat_free(p_stat);
			return NULL;
		} 
		Object generatedU_joliet_level = p_env.getU_joliet_level();
		{ 
			int offset = 0;
			 _dirbuf = NULL;
			 retval = ModernizedCProgram._cdio_list_new();
			_dirbuf = /*Error: Function owner not recognized*/calloc(1, p_stat.getSecsize()[0] * ISO_BLOCKSIZE);
			if (!_dirbuf) {
				ModernizedCProgram.cdio_warn("Couldn't calloc(1, %d)", p_stat.getSecsize()[0] * ISO_BLOCKSIZE);
				ModernizedCProgram.iso9660_stat_free(p_stat);
				ModernizedCProgram.iso9660_dirlist_free(retval);
				return NULL;
			} 
			if (ModernizedCProgram.cdio_read_data_sectors(p_cdio, _dirbuf, p_stat.getLsn()[0], ISO_BLOCKSIZE, p_stat.getSecsize()[0])) {
				ModernizedCProgram.iso9660_stat_free(p_stat);
				ModernizedCProgram.iso9660_dirlist_free(retval);
				return NULL;
			} 
			while (offset < (p_stat.getSecsize()[0] * ISO_BLOCKSIZE)) {
				p_iso9660_dir = (Object)_dirbuf[offset];
				if (ModernizedCProgram.iso9660_check_dir_block_end(p_iso9660_dir, offset)) {
					continue;
				} 
				p_iso9660_stat = ModernizedCProgram._iso9660_dir_to_statbuf(p_iso9660_dir, p_iso9660_stat, dunno, generatedU_joliet_level);
				if ((p_iso9660_stat) && ((p_iso9660_dir.getFile_flags() & ISO_MULTIEXTENT) == 0)) {
					ModernizedCProgram._cdio_list_append(retval, p_iso9660_stat);
					p_iso9660_stat = NULL;
				} 
				offset += ModernizedCProgram.iso9660_get_dir_len(p_iso9660_dir);
			}
			((offset == (p_stat.getSecsize()[0] * ISO_BLOCKSIZE)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("offset == (p_stat->secsize[0] * ISO_BLOCKSIZE)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1444));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_dirbuf);
			ModernizedCProgram.iso9660_stat_free(p_stat);
			return retval/*!
			  Read psz_path (a directory) and return a list of iso9660_stat_t
			  of the files inside that. The caller must free the returned result.
			*/;
		}
	}
	public static Object iso9660_ifs_readdir(Object p_iso, Object psz_path) {
		 p_iso9660_dir = new ();
		 p_iso9660_stat = NULL;
		 p_stat = new ();
		if (!p_iso) {
			return NULL;
		} 
		if (!psz_path) {
			return NULL;
		} 
		p_stat = ModernizedCProgram.iso9660_ifs_stat(p_iso, psz_path);
		if (!p_stat) {
			return NULL;
		} 
		if (p_stat.getType() != _STAT_DIR) {
			ModernizedCProgram.iso9660_stat_free(p_stat);
			return NULL;
		} 
		{ 
			long ret;
			int offset = 0;
			 _dirbuf = NULL;
			 retval = ModernizedCProgram._cdio_list_new();
			 dirbuf_len = p_stat.getSecsize()[0] * ISO_BLOCKSIZE;
			if (!dirbuf_len) {
				ModernizedCProgram.cdio_warn("Invalid directory buffer sector size %u", p_stat.getSecsize()[0]);
				ModernizedCProgram.iso9660_stat_free(p_stat);
				ModernizedCProgram._cdio_list_free(retval, true, NULL);
				return NULL;
			} 
			_dirbuf = /*Error: Function owner not recognized*/calloc(1, dirbuf_len);
			if (!_dirbuf) {
				ModernizedCProgram.cdio_warn("Couldn't calloc(1, %lu)", (long)dirbuf_len);
				ModernizedCProgram.iso9660_stat_free(p_stat);
				ModernizedCProgram._cdio_list_free(retval, true, NULL);
				return NULL;
			} 
			ret = ModernizedCProgram.iso9660_iso_seek_read(p_iso, _dirbuf, p_stat.getLsn()[0], p_stat.getSecsize()[0]);
			if (ret != dirbuf_len) {
				ModernizedCProgram._cdio_list_free(retval, true, NULL);
				ModernizedCProgram.iso9660_stat_free(p_stat);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_dirbuf);
				return NULL;
			} 
			while (offset < (dirbuf_len)) {
				p_iso9660_dir = (Object)_dirbuf[offset];
				if (ModernizedCProgram.iso9660_check_dir_block_end(p_iso9660_dir, offset)) {
					continue;
				} 
				p_iso9660_stat = ModernizedCProgram._iso9660_dir_to_statbuf(p_iso9660_dir, p_iso9660_stat, p_iso.getB_xa(), p_iso.getU_joliet_level());
				if ((p_iso9660_stat) && ((p_iso9660_dir.getFile_flags() & ISO_MULTIEXTENT) == 0)) {
					ModernizedCProgram._cdio_list_append(retval, p_iso9660_stat);
					p_iso9660_stat = NULL;
				} 
				offset += ModernizedCProgram.iso9660_get_dir_len(p_iso9660_dir);
			}
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_dirbuf);
			ModernizedCProgram.iso9660_stat_free(p_stat);
			if (offset != dirbuf_len) {
				ModernizedCProgram._cdio_list_free(retval, true, ()ModernizedCProgram.iso9660_stat_free);
				return NULL;
			} 
			return retval;
		}
	}
	public static Object iso9660_filelist_new() {
		return ()ModernizedCProgram._cdio_list_new();
	}
	public static Object iso9660_dirlist_new() {
		return ()ModernizedCProgram._cdio_list_new();
	}
	public static Object find_lsn_recurse(Object p_image, Object iso9660_readdir, Object psz_path, Object lsn, Byte ppsz_full_filename) {
		 entlist = /*Error: Function owner not recognized*/iso9660_readdir(p_image, /*out*/psz_path);
		 dirlist = ModernizedCProgram.iso9660_filelist_new();
		 entnode = new ();
		((entlist != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("entlist != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1562));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_CDIO_LIST_FOREACH(entnode, /* iterate over each entry in the directory */entlist);
		{ 
			 statbuf = ModernizedCProgram._cdio_list_node_data(entnode);
			byte psz_filename = (byte)statbuf.getFilename();
			int len = /*Error: Function owner not recognized*/strlen(psz_path) + /*Error: Function owner not recognized*/strlen(psz_filename) + 2;
			 extent = new ();
			if (ppsz_full_filename != NULL) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(ppsz_full_filename);
			} 
			ppsz_full_filename = /*Error: Function owner not recognized*/calloc(1, len);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(ppsz_full_filename, len, "%s%s/", psz_path, psz_filename);
			if (statbuf.getType() == _STAT_DIR && /*Error: Function owner not recognized*/strcmp((byte)statbuf.getFilename(), ".") && /*Error: Function owner not recognized*/strcmp((byte)statbuf.getFilename(), "..")) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(ppsz_full_filename, len, "%s%s/", psz_path, psz_filename);
				ModernizedCProgram._cdio_list_append(dirlist, /*Error: Function owner not recognized*/strdup(ppsz_full_filename));
			} 
			for (extent = 0; extent < statbuf.getExtents(); extent++) {
				if (statbuf.getLsn()[extent] == lsn) {
					int len2 = /*Error: Unsupported expression*/ + /*Error: Function owner not recognized*/strlen(statbuf.getFilename()) + 1;
					 ret_stat = /*Error: Function owner not recognized*/calloc(1, len2);
					if (!ret_stat) {
						ModernizedCProgram.iso9660_dirlist_free(dirlist);
						ModernizedCProgram.cdio_warn("Couldn't calloc(1, %d)", len2);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(ppsz_full_filename);
						ppsz_full_filename = NULL;
						return NULL;
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ret_stat, statbuf, len2);
					ModernizedCProgram.iso9660_filelist_free(entlist);
					ModernizedCProgram.iso9660_dirlist_free(dirlist);
					return ret_stat;
				} 
			}
		}
		ModernizedCProgram.iso9660_filelist_free(entlist);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_CDIO_LIST_FOREACH(entnode, /* now recurse/descend over directories encountered */dirlist);
		{ 
			byte psz_path_prefix = ModernizedCProgram._cdio_list_node_data(entnode);
			 ret_stat = new ();
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(ppsz_full_filename);
			ppsz_full_filename = NULL;
			ret_stat = ModernizedCProgram.find_lsn_recurse(p_image, iso9660_readdir, psz_path_prefix, lsn, ppsz_full_filename);
			if (NULL != ret_stat) {
				ModernizedCProgram.iso9660_dirlist_free(dirlist);
				return ret_stat;
			} 
		}
		if (ppsz_full_filename != NULL) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(ppsz_full_filename);
			ppsz_full_filename = NULL;
		} 
		ModernizedCProgram.iso9660_dirlist_free(dirlist);
		return NULL/*!
		   Given a directory pointer, find the filesystem entry that contains
		   lsn and return information about it.
		
		   Returns stat_t of entry if we found lsn, or NULL otherwise.
		 */;
	}
	public static Object iso9660_fs_find_lsn(Object p_cdio, Object i_lsn) {
		byte psz_full_filename = NULL;
		 p_statbuf = new ();
		p_statbuf = ModernizedCProgram.find_lsn_recurse(p_cdio, (iso9660_readdir_t)ModernizedCProgram.iso9660_fs_readdir, "/", i_lsn, psz_full_filename);
		if (psz_full_filename != NULL) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(psz_full_filename);
		} 
		return p_statbuf/*!
		   Given a directory pointer, find the filesystem entry that contains
		   LSN and return information about it.
		
		   @param p_iso the ISO-9660 file image to get data from.
		   @param i_lsn the LSN to find
		   @param ppsz_full_filename the place to store the name of the path that has LSN.
		   On entry this should point to NULL. If not, the value will be freed.
		   On exit a value is malloc'd and the caller is responsible for
		   freeing the result.
		
		   @return stat_t of entry if we found lsn, or NULL otherwise.
		   Caller must free return value using iso9660_stat_free().
		 */;
	}
	public static Object iso9660_fs_find_lsn_with_path(Object p_cdio, Object i_lsn, Byte ppsz_full_filename) {
		return ModernizedCProgram.find_lsn_recurse(p_cdio, (iso9660_readdir_t)ModernizedCProgram.iso9660_fs_readdir, "/", i_lsn, ppsz_full_filename/*!
		   Given a directory pointer, find the filesystem entry that contains
		   lsn and return information about it.
		
		   @param p_iso the ISO-9660 file image to get data from.
		
		   @param i_lsn the LSN to find
		
		   @return stat_t of entry if we found lsn, or NULL otherwise.
		   Caller must free return value using iso9660_stat_free().
		 */);
	}
	/*out*/
	public static Object iso9660_ifs_find_lsn(Object p_iso, Object i_lsn) {
		byte psz_full_filename = NULL;
		 ret = ModernizedCProgram.find_lsn_recurse(p_iso, (iso9660_readdir_t)ModernizedCProgram.iso9660_ifs_readdir, "/", i_lsn, psz_full_filename);
		if (psz_full_filename != NULL) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(psz_full_filename);
		} 
		return ret/*!
		   Given a directory pointer, find the filesystem entry that contains
		   lsn and return information about it.
		
		   @param p_iso pointer to iso_t
		
		   @param i_lsn LSN to find
		
		   @param ppsz_path  full path of lsn filename. On entry *ppsz_path should be
		   NULL. On return it will be allocated an point to the full path of the
		   file at lsn or NULL if the lsn is not found. You should deallocate
		   *ppsz_path when you are done using it.
		
		   @return stat_t of entry if we found lsn, or NULL otherwise.
		   Caller must free return value using iso9660_stat_free().
		 */;
	}
	public static Object iso9660_ifs_find_lsn_with_path(Object p_iso, Object i_lsn, Byte ppsz_full_filename) {
		return ModernizedCProgram.find_lsn_recurse(p_iso, (iso9660_readdir_t)ModernizedCProgram.iso9660_ifs_readdir, "/", i_lsn, ppsz_full_filename/*!
		  Free the passed iso9660_stat_t structure.
		
		  @param p_stat iso9660 stat buffer to free.
		
		 */);
	}
	/*out*/
	public static void iso9660_stat_free(Object p_stat) {
		if (p_stat != NULL) {
			if (p_stat.getRr().getPsz_symlink()) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CDIO_FREE_IF_NOT_NULL(p_stat.getRr().getPsz_symlink());
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_stat/*!
			  Free the passed CdioISOC9660FileList_t structure.
			*/);
		} 
	}
	public static void iso9660_filelist_free(Object p_filelist) {
		ModernizedCProgram._cdio_list_free(p_filelist, true, ()ModernizedCProgram.iso9660_stat_free/*!
		  Free the passed CdioISOC9660DirList_t structure.
		*/);
	}
	public static void iso9660_dirlist_free(Object p_filelist) {
		ModernizedCProgram._cdio_list_free(p_filelist, true, free/*!
		  Return true if ISO 9660 image has extended attrributes (XA).
		*/);
	}
	public static Object iso9660_ifs_is_xa(Object p_iso) {
		if (!p_iso) {
			return false;
		} 
		return yep == p_iso.getB_xa();
	}
	public static Object iso_have_rr_traverse(Object p_iso, Object _root, byte[][] splitpath, Object pu_file_limit) {
		int offset = 0;
		 _dirbuf = NULL;
		int ret;
		 have_rr = nope;
		if (!splitpath[0]) {
			return false;
		} 
		if (_root.getType() == _STAT_FILE) {
			return nope;
		} 
		if (pu_file_limit == 0) {
			return dunno;
		} 
		((_root.getType() == _STAT_DIR) ? (Object)0 : /*Error: Function owner not recognized*/_assert("_root->type == _STAT_DIR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1777));
		_dirbuf = /*Error: Function owner not recognized*/calloc(1, _root.getSecsize()[0] * ISO_BLOCKSIZE);
		if (!_dirbuf) {
			ModernizedCProgram.cdio_warn("Couldn't calloc(1, %d)", _root.getSecsize()[0] * ISO_BLOCKSIZE);
			return dunno;
		} 
		ret = ModernizedCProgram.iso9660_iso_seek_read(p_iso, _dirbuf, _root.getLsn()[0], _root.getSecsize()[0]);
		if (ret != ISO_BLOCKSIZE * _root.getSecsize()[0]) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_dirbuf);
			return false;
		} 
		while (offset < (_root.getSecsize()[0] * ISO_BLOCKSIZE)) {
			 p_iso9660_dir = (Object)_dirbuf[offset];
			 p_stat = new ();
			int i_last_component = 1;
			if (ModernizedCProgram.iso9660_check_dir_block_end(p_iso9660_dir, offset)) {
				continue;
			} 
			p_stat = ModernizedCProgram._iso9660_dir_to_statbuf(p_iso9660_dir, NULL, p_iso.getB_xa(), p_iso.getU_joliet_level());
			have_rr = p_stat.getRr().getB3_rock();
			if (have_rr != yep) {
				if (/*Error: Function owner not recognized*/strlen(splitpath[0]) == 0) {
					have_rr = false;
				} else {
						have_rr = ModernizedCProgram.iso_have_rr_traverse(p_iso, p_stat, splitpath[i_last_component], pu_file_limit);
				} 
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_stat);
			if (have_rr != nope) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_dirbuf);
				return have_rr;
			} 
			offset += ModernizedCProgram.iso9660_get_dir_len(p_iso9660_dir);
			pu_file_limit = (pu_file_limit) - 1;
			if ((pu_file_limit) == 0) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_dirbuf);
				return dunno;
			} 
		}
		((offset == (_root.getSecsize()[0] * ISO_BLOCKSIZE)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("offset == (_root->secsize[0] * ISO_BLOCKSIZE)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660_fs.c", 1825));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(/* not found */_dirbuf);
		return nope/*!
		  Return "yup" if any file has Rock-Ridge extensions. Warning: this can
		  be time consuming. On an ISO 9600 image with lots of files but no Rock-Ridge
		  extensions, the entire directory structure will be scanned up to u_file_limit.
		
		  @param p_iso the ISO-9660 file image to get data from
		
		  @param u_file_limit the maximimum number of (non-rock-ridge) files
		  to consider before giving up and returning "dunno".
		
		  "dunno" can also be returned if there was some error encountered
		  such as not being able to allocate memory in processing.
		
		*/;
	}
	public static Object iso9660_have_rr(Object p_iso, Object u_file_limit) {
		 p_root = new ();
		byte[] p_psz_splitpath = new byte[]{/*Error: Function owner not recognized*/strdup("/"), /*Error: Function owner not recognized*/strdup("")};
		 is_rr = nope;
		if (!p_iso) {
			return false;
		} 
		p_root = ModernizedCProgram._ifs_stat_root(p_iso);
		if (!p_root) {
			return dunno;
		} 
		if (u_file_limit == 0) {
			u_file_limit = UINT64_MAX;
		} 
		is_rr = ModernizedCProgram.iso_have_rr_traverse(p_iso, p_root, p_psz_splitpath, u_file_limit);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_root);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_psz_splitpath[0]);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_psz_splitpath[1]);
		return is_rr;
	}
	/*
	 * Rufus: The Reliable USB Formatting Utility
	 * Registry access
	 * Copyright Â© 2012-2015 Pete Batard <pete@akeo.ie>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	/* Delete a registry key from <key_root>\Software and all its values
	   If the key has subkeys, this call will fail. */
	public static Object DeleteRegistryKey(Object key_root, Object key_name) {
		HKEY hSoftware = ((Object)0);
		LONG s = new LONG();
		if (/*Error: Function owner not recognized*/RegOpenKeyExA(key_root, "SOFTWARE", 0, -1024 | 4, hSoftware) != -1024) {
			return 0;
		} 
		s = /*Error: Function owner not recognized*/RegDeleteKeyA(hSoftware, key_name);
		if ((s != -1024) && (s != -1024)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(s);
			ModernizedCProgram._uprintf("Failed to delete registry key HKCU\\Software\\%s: %s", key_name, (s == -1024) ? "Key is not empty" : ModernizedCProgram.WindowsErrorString());
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/RegCloseKey(hSoftware);
		return ((s == -1024) || (s == -1024));
	}
	/* Find if a registry node exists */
	public static Object IsRegistryNode(Object key_root, Object key_name) {
		BOOL r = new BOOL();
		HKEY hSoftware = ((Object)0);
		r = (/*Error: Function owner not recognized*/RegOpenKeyExA(key_root, key_name, 0, -1024, hSoftware) == -1024);
		if (hSoftware != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/RegCloseKey(hSoftware);
		} 
		return r;
	}
	/* Read a generic registry key value. If a short key_name is used, assume that it belongs to
	   the application and create the app subkey if required */
	public static Object _GetRegistryKey(Object key_root, Object[] key_name, Object reg_type, Object dest, Object dest_size) {
		byte[] software_prefix = "SOFTWARE\\";
		byte[] long_key_name = new byte[]{0};
		BOOL r = 0;
		size_t i = new size_t();
		LONG s = new LONG();
		HKEY hSoftware = ((Object)0);
		HKEY hApp = ((Object)0);
		DWORD dwDisp = new DWORD();
		DWORD dwType = -1;
		DWORD dwSize = dest_size;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(dest, 0, dest_size);
		if (key_name == ((Object)0)) {
			return 0;
		} 
		for (i = ((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)); i > 0; i--) {
			if (key_name[i] == (byte)'\\') {
				break;
			} 
		}
		if (i > 0) {
			if (/*Error: Function owner not recognized*/_strnicmp(key_name, software_prefix, /*Error: sizeof expression not supported yet*/ - 1) != 0) {
				if (i + /*Error: sizeof expression not supported yet*/ >= /*Error: sizeof expression not supported yet*/) {
					return 0;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(long_key_name, software_prefix);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(long_key_name, key_name, (((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)long_key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(long_key_name)) - 1)) ? ((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)long_key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(long_key_name)) - 1))));
				long_key_name[/*Error: sizeof expression not supported yet*/ + i - 1] = 0;
			} else {
					if (i >= /*Error: sizeof expression not supported yet*/) {
						return 0;
					} 
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(long_key_name, key_name, (((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
						((byte)long_key_name)[(((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
					} while (0);
					long_key_name[i] = 0;
			} 
			i++;
			if (/*Error: Function owner not recognized*/RegOpenKeyExA(key_root, long_key_name, 0, -1024, hApp) != -1024) {
				hApp = ((Object)0);
				;
			} 
		} else {
				if (/*Error: Function owner not recognized*/RegOpenKeyExA(key_root, "SOFTWARE", 0, -1024 | 4, hSoftware) != -1024) {
					hSoftware = ((Object)0);
					;
				} 
				if (/*Error: Function owner not recognized*/RegCreateKeyExA(hSoftware, "Akeo Consulting\\Rufus", 0, ((Object)0), 0, 2 | 1 | 4, ((Object)0), hApp, dwDisp) != -1024) {
					hApp = ((Object)0);
					;
				} 
		} 
		// Prefix with "SOFTWARE" if needed
		s = /*Error: Function owner not recognized*/RegQueryValueExA(hApp, key_name[i], ((Object)0), dwType, (LPBYTE)dest, dwSize)// No key means default value of 0 or empty string;// No key means default value of 0 or empty string
		if ((s == -1024) || ((s == -1024) && (dwType == reg_type) && (dwSize > 0))) {
			r = 1;
		} 
		if (hApp != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/RegCloseKey(hApp);
		} 
		return r;
	}
	/* Write a generic registry key value (create the key if it doesn't exist) */
	public static Object _SetRegistryKey(Object key_root, Object[] key_name, Object reg_type, Object src, Object src_size) {
		byte[] software_prefix = "SOFTWARE\\";
		byte[] long_key_name = new byte[]{0};
		BOOL r = 0;
		size_t i = new size_t();
		HKEY hRoot = ((Object)0);
		HKEY hApp = ((Object)0);
		DWORD dwDisp = new DWORD();
		DWORD dwType = reg_type;
		if (key_name == ((Object)0)) {
			return 0;
		} 
		if (/*Error: Function owner not recognized*/RegOpenKeyExA(key_root, ((Object)0), 0, -1024 | 4, hRoot) != -1024) {
			hRoot = ((Object)0);
			;
		} 
		// Find if we're dealing with a short keyfor (i = ((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)); i > 0; i--) {
			if (key_name[i] == (byte)'\\') {
				break;
			} 
		}
		if (i > 0) {
			if (/*Error: Function owner not recognized*/_strnicmp(key_name, software_prefix, /*Error: sizeof expression not supported yet*/ - 1) != 0) {
				if (i + /*Error: sizeof expression not supported yet*/ >= /*Error: sizeof expression not supported yet*/) {
					;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(long_key_name, software_prefix);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(long_key_name, key_name, (((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)long_key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(long_key_name)) - 1)) ? ((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)long_key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(long_key_name)) - 1))));
				long_key_name[/*Error: sizeof expression not supported yet*/ + i - 1] = 0;
			} else {
					if (i >= /*Error: sizeof expression not supported yet*/) {
						;
					} 
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(long_key_name, key_name, (((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
						((byte)long_key_name)[(((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)key_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(key_name)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
					} while (0);
					long_key_name[i] = 0;
			} 
			i++;
			if (/*Error: Function owner not recognized*/RegCreateKeyExA(hRoot, long_key_name, 0, ((Object)0), 0, 2 | 1 | 4, ((Object)0), hApp, dwDisp) != -1024) {
				hApp = ((Object)0);
				;
			} 
		} else {
				if (/*Error: Function owner not recognized*/RegCreateKeyExA(hRoot, "SOFTWARE\\Akeo Consulting\\Rufus", 0, ((Object)0), 0, 2 | 1 | 4, ((Object)0), hApp, dwDisp) != -1024) {
					hApp = ((Object)0);
					;
				} 
		} 
		// Prefix with "SOFTWARE" if needed
		r = (/*Error: Function owner not recognized*/RegSetValueExA(hApp, key_name[i], 0, dwType, src, src_size) == -1024);
		if (hApp != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/RegCloseKey(hApp);
		} 
		return r/* Helpers for 64 bit registry operations */;
	}
	// Check that a key is accessible for R/W (will create a key if not already existing)
	public static Object CheckRegistryKey64(Object root, Object key) {
		LONGLONG val = new LONGLONG();
		return ModernizedCProgram._GetRegistryKey(root, key, 11, (LPBYTE)val, /*Error: Unsupported expression*/);
	}
	public static Object ReadRegistryKey64(Object root, Object key) {
		LONGLONG val = new LONGLONG();
		ModernizedCProgram._GetRegistryKey(root, key, 11, (LPBYTE)val, /*Error: Unsupported expression*/);
		return (int64_t)val;
	}
	public static Object WriteRegistryKey64(Object root, Object key, Object val) {
		LONGLONG tmp = (LONGLONG)val;
		return ModernizedCProgram._SetRegistryKey(root, key, 11, (LPBYTE)tmp, /*Error: Unsupported expression*//* Helpers for 32 bit registry operations */);
	}
	public static Object CheckRegistryKey32(Object root, Object key) {
		DWORD val = new DWORD();
		return (ModernizedCProgram._GetRegistryKey(root, key, 4, (LPBYTE)val, /*Error: Unsupported expression*/) && ModernizedCProgram._SetRegistryKey(root, key, 4, (LPBYTE)val, /*Error: Unsupported expression*/));
	}
	public static Object ReadRegistryKey32(Object root, Object key) {
		DWORD val = new DWORD();
		ModernizedCProgram._GetRegistryKey(root, key, 4, (LPBYTE)val, /*Error: Unsupported expression*/);
		return (int32_t)val;
	}
	public static Object WriteRegistryKey32(Object root, Object key, Object val) {
		DWORD tmp = (DWORD)val;
		return ModernizedCProgram._SetRegistryKey(root, key, 4, (LPBYTE)tmp, /*Error: Unsupported expression*//* Helpers for boolean registry operations */);
	}
	/* Helpers for String registry operations */
	// Use a static buffer - don't allocate
	public static Byte ReadRegistryKeyStr(Object root, Object key) {
		byte[] str = new byte[512];
		str[0] = 0;
		ModernizedCProgram._GetRegistryKey(root, key, 1, (LPBYTE)str, (DWORD)/*Error: sizeof expression not supported yet*/ - 1);
		return str;
	}
	/* Uncompress file 'src', compressed using 'type', to file 'dst' */
	public static Object bled_uncompress(Object src, Object dst, int type) {
		transformer_state_t xstate = new transformer_state_t();
		int64_t ret = new int64_t();
		if (!ModernizedCProgram.bled_initialized) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: The library has not been initialized");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: The library has not been initialized");
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			return -1;
		} 
		ModernizedCProgram.bb_total_rb = 0;
		xstate.init_transformer_state();
		xstate.setSrc_fd(-1);
		xstate.setDst_fd(-1);
		xstate.setCheck_signature(1);
		xstate.setSrc_fd(ModernizedCProgram._openU(src, 0 | -1024, 0));
		Object generatedSrc_fd = xstate.getSrc_fd();
		if (generatedSrc_fd < 0) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Could not open '%s' (errno: %d)", src, (/*Error: Function owner not recognized*/_errno()));
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Could not open '%s' (errno: %d)", src, (/*Error: Function owner not recognized*/_errno()));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			;
		} 
		xstate.setDst_fd(ModernizedCProgram._openU(dst, 1 | -1024 | -1024 | -1024, -1024 | -1024));
		int generatedDst_fd = xstate.getDst_fd();
		if (generatedDst_fd < 0) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Could not open '%s' (errno: %d)", dst, (/*Error: Function owner not recognized*/_errno()));
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Could not open '%s' (errno: %d)", dst, (/*Error: Function owner not recognized*/_errno()));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			;
		} 
		if ((type < 0) || (type >= .BLED_COMPRESSION_MAX)) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Unsupported compression format");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Unsupported compression format");
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			;
		} 
		if (/*Error: Function owner not recognized*/_setjmp(ModernizedCProgram.bb_error_jmp)) {
			;
		} 
		ret = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(xstate);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_close(generatedSrc_fd);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_close(generatedDst_fd);
		return ret;
		if (generatedDst_fd > 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_close(generatedDst_fd);
		} 
		return -1;
	}
	/* Uncompress using Windows handles */
	public static Object bled_uncompress_with_handles(Object hSrc, Object hDst, int type) {
		transformer_state_t xstate = new transformer_state_t();
		if (!ModernizedCProgram.bled_initialized) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: The library has not been initialized");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: The library has not been initialized");
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			return -1;
		} 
		ModernizedCProgram.bb_total_rb = 0;
		xstate.init_transformer_state();
		xstate.setSrc_fd(-1);
		xstate.setDst_fd(-1);
		xstate.setCheck_signature(1);
		xstate.setSrc_fd(/*Error: Function owner not recognized*/_open_osfhandle((intptr_t)hSrc, 0));
		Object generatedSrc_fd = xstate.getSrc_fd();
		if (generatedSrc_fd < 0) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Could not get source descriptor (errno: %d)", (/*Error: Function owner not recognized*/_errno()));
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Could not get source descriptor (errno: %d)", (/*Error: Function owner not recognized*/_errno()));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			return -1;
		} 
		xstate.setDst_fd(/*Error: Function owner not recognized*/_open_osfhandle((intptr_t)hDst, 0));
		int generatedDst_fd = xstate.getDst_fd();
		if (generatedDst_fd < 0) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Could not get target descriptor (errno: %d)", (/*Error: Function owner not recognized*/_errno()));
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Could not get target descriptor (errno: %d)", (/*Error: Function owner not recognized*/_errno()));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			return -1;
		} 
		if ((type < 0) || (type >= .BLED_COMPRESSION_MAX)) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Unsupported compression format");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Unsupported compression format");
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			return -1;
		} 
		if (/*Error: Function owner not recognized*/_setjmp(ModernizedCProgram.bb_error_jmp)) {
			return -1;
		} 
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(xstate);
	}
	/* Uncompress file 'src', compressed using 'type', to buffer 'buf' of size 'size' */
	public static Object bled_uncompress_to_buffer(Object[] src, Byte buf, Object size, int type) {
		transformer_state_t xstate = new transformer_state_t();
		int64_t ret = new int64_t();
		if (!ModernizedCProgram.bled_initialized) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: The library has not been initialized");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: The library has not been initialized");
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			return -1;
		} 
		if ((src == ((Object)0)) || (buf == ((Object)0))) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Invalid parameter");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Invalid parameter");
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			return -1;
		} 
		ModernizedCProgram.bb_total_rb = 0;
		xstate.init_transformer_state();
		xstate.setSrc_fd(-1);
		xstate.setDst_fd(-1);
		xstate.setCheck_signature(1);
		if (src[0] == 0) {
			xstate.setSrc_fd(ModernizedCProgram.bb_virtual_fd);
		} else {
				xstate.setSrc_fd(ModernizedCProgram._openU(src, 0 | -1024, 0));
		} 
		Object generatedSrc_fd = xstate.getSrc_fd();
		if (generatedSrc_fd < 0) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Could not open '%s' (errno: %d)", src, (/*Error: Function owner not recognized*/_errno()));
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Could not open '%s' (errno: %d)", src, (/*Error: Function owner not recognized*/_errno()));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			;
		} 
		xstate.setMem_output_buf(buf);
		xstate.setMem_output_size(0);
		xstate.setMem_output_size_max(size);
		if ((type < 0) || (type >= .BLED_COMPRESSION_MAX)) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Unsupported compression format");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Unsupported compression format");
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			;
		} 
		if (/*Error: Function owner not recognized*/_setjmp(ModernizedCProgram.bb_error_jmp)) {
			;
		} 
		ret = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(xstate);
		if (src[0] != 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_close(generatedSrc_fd);
		} 
		return ret;
		return -1;
	}
	public static Object bled_uncompress_from_buffer_to_buffer(Object src, Object src_len, Byte dst, Object dst_len, int type) {
		int64_t ret = new int64_t();
		if (!ModernizedCProgram.bled_initialized) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: The library has not been initialized");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: The library has not been initialized");
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			return -1;
		} 
		if ((src == ((Object)0)) || (dst == ((Object)0))) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Invalid parameter");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Invalid parameter");
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			return -1;
		} 
		if (ModernizedCProgram.bb_virtual_buf != ((Object)0)) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Can not decompress more than one buffer at once");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Can not decompress more than one buffer at once");
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
			return -1;
		} 
		ModernizedCProgram.bb_virtual_buf = (byte)src;
		ModernizedCProgram.bb_virtual_len = src_len;
		ModernizedCProgram.bb_virtual_pos = 0;
		ModernizedCProgram.bb_virtual_fd = 0;
		ret = ModernizedCProgram.bled_uncompress_to_buffer("", dst, dst_len, type);
		ModernizedCProgram.bb_virtual_buf = ((Object)0);
		ModernizedCProgram.bb_virtual_len = 0;
		ModernizedCProgram.bb_virtual_fd = -1;
		return ret/* Initialize the library.
		 * When the parameters are not NULL you can:
		 * - specify the printf-like function you want to use to output message
		 *   void print_function(const char* format, ...);
		 * - specify the function you want to use to display progress, based on number of source archive bytes read
		 *   void progress_function(const uint64_t read_bytes);
		 * - point to an unsigned long variable, to be used to cancel operations when set to non zero
		 */;
	}
	public static int bled_init(Object print_function, Object progress_function, Long cancel_request) {
		if (ModernizedCProgram.bled_initialized) {
			return -1;
		} 
		ModernizedCProgram.bled_initialized = 1;
		ModernizedCProgram.bled_printf = print_function;
		ModernizedCProgram.bled_progress = progress_function;
		ModernizedCProgram.bled_cancel_request = cancel_request;
		return 0;
	}
	/* This call frees any resource used by the library */
	public static void bled_exit() {
		ModernizedCProgram.bled_printf = ((Object)0);
		ModernizedCProgram.bled_progress = ((Object)0);
		ModernizedCProgram.bled_cancel_request = ((Object)0);
		if (ModernizedCProgram.global_crc32_table) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(ModernizedCProgram.global_crc32_table);
			ModernizedCProgram.global_crc32_table = ((Object)0);
		} 
		ModernizedCProgram.bled_initialized = 0;
	}
	/*
	 * closefs.c --- close an ext2 filesystem
	 *
	 * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static int test_root(int a, int b) {
		while (1) {
			if (a < b) {
				return 0;
			} 
			if (a == b) {
				return 1;
			} 
			if (a % b) {
				return 0;
			} 
			a = a / b;
		}
	}
	public static int ext2fs_bg_has_super(Object fs, Object group) {
		if (group == 0) {
			return 1;
		} 
		if (fs.getSuper().ext2fs_has_feature_sparse_super2()) {
			if (group == fs.getSuper().getS_backup_bgs()[0] || group == fs.getSuper().getS_backup_bgs()[1]) {
				return 1;
			} 
			return 0;
		} 
		if ((group <= 1) || !fs.getSuper().ext2fs_has_feature_sparse_super()) {
			return 1;
		} 
		if (!(group & 1)) {
			return 0;
		} 
		if (ModernizedCProgram.test_root(group, 3) || (ModernizedCProgram.test_root(group, 5)) || ModernizedCProgram.test_root(group, 7)) {
			return 1;
		} 
		return 0/*
		 * ext2fs_super_and_bgd_loc2()
		 * @fs:			ext2 fs pointer
		 * @group		given block group
		 * @ret_super_blk:	if !NULL, returns super block location
		 * @ret_old_desc_blk:	if !NULL, returns location of the old block
		 *			group descriptor
		 * @ret_new_desc_blk:	if !NULL, returns location of meta_bg block
		 *			group descriptor
		 * @ret_used_blks:	if !NULL, returns number of blocks used by
		 *			super block and group_descriptors.
		 *
		 * Returns errcode_t of 0
		 */;
	}
	public static Object ext2fs_super_and_bgd_loc2(Object fs, Object group, Object ret_super_blk, Object ret_old_desc_blk, Object ret_new_desc_blk, Object ret_used_blks) {
		 group_block = new ();
		 super_blk = 0;
		 old_desc_blk = 0;
		 new_desc_blk = 0;
		int meta_bg;
		int meta_bg_size;
		 numblocks = 0;
		 old_desc_blocks = new ();
		int has_super;
		group_block = ModernizedCProgram.ext2fs_group_first_block2(fs, group);
		if (group_block == 0 && fs.getBlocksize() == 1024) {
			group_block = /* Deal with 1024 blocksize && bigalloc */1;
		} 
		if (fs.getSuper().ext2fs_has_feature_meta_bg()) {
			old_desc_blocks = fs.getSuper().getS_first_meta_bg();
		} else {
				old_desc_blocks = fs.getDesc_blocks() + fs.getSuper().getS_reserved_gdt_blocks();
		} 
		has_super = ModernizedCProgram.ext2fs_bg_has_super(fs, group);
		if (has_super) {
			super_blk = group_block;
			numblocks++;
		} 
		meta_bg_size = (((1 << 10) << (fs.getSuper()).getS_log_block_size()) / (((fs.getSuper()).getS_feature_incompat() & -1024) ? (fs.getSuper()).getS_desc_size() : 32));
		meta_bg = group / meta_bg_size;
		if (!fs.getSuper().ext2fs_has_feature_meta_bg() || (meta_bg < fs.getSuper().getS_first_meta_bg())) {
			if (has_super) {
				old_desc_blk = group_block + 1;
				numblocks += old_desc_blocks;
			} 
		} else {
				if (((group % meta_bg_size) == 0) || ((group % meta_bg_size) == 1) || ((group % meta_bg_size) == (meta_bg_size - 1))) {
					if (has_super) {
						has_super = 1;
					} 
					new_desc_blk = group_block + has_super;
					numblocks++;
				} 
		} 
		if (ret_super_blk) {
			ret_super_blk = super_blk;
		} 
		if (ret_old_desc_blk) {
			ret_old_desc_blk = old_desc_blk;
		} 
		if (ret_new_desc_blk) {
			ret_new_desc_blk = new_desc_blk;
		} 
		if (ret_used_blks) {
			ret_used_blks = numblocks;
		} 
		return 0/*
		 * This function returns the location of the superblock, block group
		 * descriptors for a given block group.  It currently returns the
		 * number of free blocks assuming that inode table and allocation
		 * bitmaps will be in the group.  This is not necessarily the case
		 * when the flex_bg feature is enabled, so callers should take care!
		 * It was only really intended for use by mke2fs, and even there it's
		 * not that useful.
		 *
		 * The ext2fs_super_and_bgd_loc2() function is 64-bit block number
		 * capable and returns the number of blocks used by super block and
		 * group descriptors.
		 */;
	}
	public static int ext2fs_super_and_bgd_loc(Object fs, Object group, Object ret_super_blk, Object ret_old_desc_blk, Object ret_new_desc_blk, Integer ret_meta_bg) {
		 ret_super_blk2 = new ();
		 ret_old_desc_blk2 = new ();
		 ret_new_desc_blk2 = new ();
		 ret_used_blks = new ();
		 numblocks = new ();
		int meta_bg_size;
		ModernizedCProgram.ext2fs_super_and_bgd_loc2(fs, group, ret_super_blk2, ret_old_desc_blk2, ret_new_desc_blk2, ret_used_blks);
		numblocks = ModernizedCProgram.ext2fs_group_blocks_count(fs, group);
		if (ret_super_blk) {
			ret_super_blk = ()ret_super_blk2;
		} 
		if (ret_old_desc_blk) {
			ret_old_desc_blk = ()ret_old_desc_blk2;
		} 
		if (ret_new_desc_blk) {
			ret_new_desc_blk = ()ret_new_desc_blk2;
		} 
		if (ret_meta_bg) {
			meta_bg_size = (((1 << 10) << (fs.getSuper()).getS_log_block_size()) / (((fs.getSuper()).getS_feature_incompat() & -1024) ? (fs.getSuper()).getS_desc_size() : 32));
			ret_meta_bg = group / meta_bg_size;
		} 
		numblocks -= 2 + fs.getInode_blocks_per_group() + ret_used_blks;
		return numblocks/*
		 * This function forces out the primary superblock.  We need to only
		 * write out those fields which we have changed, since if the
		 * filesystem is mounted, it may have changed some of the other
		 * fields.
		 *
		 * It takes as input a superblock which has already been byte swapped
		 * (if necessary).
		 *
		 */;
	}
	/*
	 * Updates the revision to EXT2_DYNAMIC_REV
	 */
	public static void ext2fs_update_dynamic_rev(Object fs) {
		ext2_super_block sb = fs.getSuper();
		Object generatedS_rev_level = sb.getS_rev_level();
		if (generatedS_rev_level > 0) {
			return /*Error: Unsupported expression*/;
		} 
		sb.setS_rev_level(1);
		sb.setS_first_ino(11);
		sb.setS_inode_size(128/* s_uuid is handled by e2fsck already *//* other fields should be left alone */);
	}
	public static Object ext2fs_flush(Object fs) {
		return ModernizedCProgram.ext2fs_flush2(fs, 0);
	}
	public static Object ext2fs_flush2(Object fs, int flags) {
		 i = new ();
		 retval = new ();
		long fs_state;
		 feature_incompat = new ();
		ext2_super_block super_shadow = 0;
		opaque_ext2_group_desc group_shadow = 0;
		byte group_ptr;
		 old_desc_blocks = new ();
		ext2fs_numeric_progress_struct progress = new ext2fs_numeric_progress_struct();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		fs_state = fs.getSuper().getS_state();
		feature_incompat = fs.getSuper().getS_feature_incompat();
		fs.getSuper().setS_wtime(fs.getNow() ? fs.getNow() : /*Error: Function owner not recognized*/time(((Object)0)));
		fs.getSuper().setS_block_group_nr(0/*
			 * If the write_bitmaps() function is present, call it to
			 * flush the bitmaps.  This is done this way so that a simple
			 * program that doesn't mess with the bitmaps doesn't need to
			 * drag in the bitmaps.c code.
			 *
			 * Bitmap checksums live in the group descriptor, so the
			 * bitmaps need to be written before the descriptors.
			 */);
		if (fs.getWrite_bitmaps()) {
			retval = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs);
			if (retval) {
				;
			} 
		} 
		fs.getSuper().getS_state() &=  ~-1024;
		fs.getSuper().ext2fs_clear_feature_journal_needs_recovery();
		super_shadow = fs.getSuper();
		group_shadow = fs.getGroup_desc();
		if (fs.getSuper().ext2fs_has_feature_journal_dev()) {
			;
		} 
		group_ptr = (byte)group_shadow;
		if (fs.getSuper().ext2fs_has_feature_meta_bg()) {
			old_desc_blocks = fs.getSuper().getS_first_meta_bg();
			if (old_desc_blocks > fs.getDesc_blocks()) {
				old_desc_blocks = fs.getDesc_blocks();
			} 
		} else {
				old_desc_blocks = fs.getDesc_blocks();
		} 
		if (fs.getProgress_ops() && fs.getProgress_ops().getExt2fs_progress_ops()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, progress, ((Object)0), fs.getGroup_desc_count());
		} 
		for (i = 0; i < fs.getGroup_desc_count(); i++) {
			 super_blk = new ();
			 old_desc_blk = new ();
			 new_desc_blk = new ();
			if (fs.getProgress_ops() && fs.getProgress_ops().getExt2fs_progress_ops()) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, progress, i);
			} 
			ModernizedCProgram.ext2fs_super_and_bgd_loc2(fs, i, super_blk, old_desc_blk, new_desc_blk, 0);
			if (!(fs.getFlags() & -1024) && i && super_blk) {
				retval = super_shadow.write_backup_super(fs, i, super_blk);
				if (retval) {
					;
				} 
			} 
			if (fs.getFlags() & -1024) {
				continue;
			} 
			if ((old_desc_blk) && (!(fs.getFlags() & -1024) || (i == 0))) {
				retval = ModernizedCProgram.io_channel_write_blk64(fs.getIo(), old_desc_blk, old_desc_blocks, group_ptr);
				if (retval) {
					;
				} 
			} 
			if (new_desc_blk) {
				int meta_bg = i / (((1 << 10) << (fs.getSuper()).getS_log_block_size()) / (((fs.getSuper()).getS_feature_incompat() & -1024) ? (fs.getSuper()).getS_desc_size() : 32));
				retval = ModernizedCProgram.io_channel_write_blk64(fs.getIo(), new_desc_blk, 1, group_ptr + (meta_bg * fs.getBlocksize()));
				if (retval) {
					;
				} 
			} 
		}
		if (fs.getProgress_ops() && fs.getProgress_ops().getExt2fs_progress_ops()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, progress, ((Object)0));
		} 
		fs.getSuper().setS_state(fs_state);
		fs.getSuper().setS_feature_incompat(feature_incompat);
		retval = super_shadow.ext2fs_superblock_csum_set(fs);
		if (retval) {
			return retval;
		} 
		if (!(flags & 1)) {
			retval = /*Error: Function owner not recognized*/io_channel_flush(fs.getIo());
			if (retval) {
				;
			} 
		} 
		retval = super_shadow.write_primary_superblock(fs);
		if (retval) {
			;
		} 
		fs.getFlags() &=  ~-1024;
		if (!(flags & 1)) {
			retval = /*Error: Function owner not recognized*/io_channel_flush(fs.getIo());
			if (retval) {
				;
			} 
		} 
		return retval;
	}
	public static Object ext2fs_close_free(Object fs_ptr) {
		 ret = new ();
		ext2_filsys fs = fs_ptr;
		ret = ModernizedCProgram.ext2fs_close2(fs, 0);
		if (ret) {
			ModernizedCProgram.ext2fs_free(fs);
		} 
		fs_ptr = ((Object)0);
		return ret;
	}
	public static Object ext2fs_close(Object fs) {
		return ModernizedCProgram.ext2fs_close2(fs, 0);
	}
	public static Object ext2fs_close2(Object fs, int flags) {
		 retval = new ();
		int meta_blks;
		 stats = 0;
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		if (fs.getWrite_bitmaps()) {
			retval = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs);
			if (retval) {
				return retval;
			} 
		} 
		if (fs.getSuper().getS_kbytes_written() && fs.getIo().getManager().getGet_stats()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs.getIo(), stats);
		} 
		if (stats && stats.getBytes_written() && (fs.getFlags() & -1024)) {
			fs.getSuper().getS_kbytes_written() += stats.getBytes_written() >> 10;
			meta_blks = fs.getDesc_blocks() + 1;
			if (!(fs.getFlags() & -1024)) {
				fs.getSuper().getS_kbytes_written() += meta_blks / (fs.getBlocksize() / 1024);
			} 
			if ((fs.getFlags() & -1024) == 0) {
				fs.getFlags() |=  -1024 | -1024;
			} 
		} 
		if (fs.getFlags() & -1024) {
			retval = ModernizedCProgram.ext2fs_flush2(fs, flags);
			if (retval) {
				return retval;
			} 
		} 
		retval = ModernizedCProgram.ext2fs_mmp_stop(fs);
		if (retval) {
			return retval;
		} 
		ModernizedCProgram.ext2fs_free(fs);
		return 0;
	}
	/* vi: set sw=4 ts=4: */
	/*
	 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
	 */
	public static void header_verbose_list(Object file_header) {
		tm tm_time = new tm();
		//localtime(&file_header->mtime);tm ptm = tm_time/*char gid[sizeof(int)*3 + 2];*/;
		/*sprintf(gid, "%u", (unsigned)file_header->gid);*/
		/* !FEATURE_TAR_UNAME_GNAME */ptm.localtime_r(file_header.getMtime());
		Object generatedTm_year = ptm.getTm_year();
		Object generatedTm_mon = ptm.getTm_mon();
		Object generatedTm_mday = ptm.getTm_mday();
		Object generatedTm_hour = ptm.getTm_hour();
		Object generatedTm_min = ptm.getTm_min();
		Object generatedTm_sec = ptm.getTm_sec();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("%s %u/%u %9I64u %4u-%02u-%02u %02u:%02u:%02u %s", "[not implemented]", (int)file_header.getUid(), (int)file_header.getGid(), file_header.getSize(), 1900 + generatedTm_year, 1 + generatedTm_mon, generatedTm_mday, generatedTm_hour, generatedTm_min, generatedTm_sec, file_header.getName());
		if (file_header.getLink_target()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" -> %s", file_header.getLink_target());
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
	}
	public static Object cdio_get_first_track_num(Object p_cdio) {
		if (NULL == p_cdio) {
			ModernizedCProgram.cdio_info("Null CdIo object passed\n");
			return CDIO_INVALID_TRACK;
		} 
		if (p_cdio.getOp().getGet_first_track_num()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv());
		} else {
				return CDIO_INVALID_TRACK/*!
				  Return the last track number.
				  CDIO_INVALID_TRACK is returned on error.
				*/;
		} 
	}
	public static Object cdio_get_last_track_num(Object p_cdio) {
		if (NULL == p_cdio) {
			ModernizedCProgram.cdio_info("Null CdIo object passed\n");
			return CDIO_INVALID_TRACK;
		} 
		{ 
			 i_first_track = ModernizedCProgram.cdio_get_first_track_num(p_cdio);
			if (CDIO_INVALID_TRACK != i_first_track) {
				 u_tracks = ModernizedCProgram.cdio_get_num_tracks(p_cdio);
				if (CDIO_INVALID_TRACK != u_tracks) {
					return i_first_track + u_tracks - 1;
				} 
			} 
			return CDIO_INVALID_TRACK/*! Return number of channels in track: 2 or 4; -2 if not
			  implemented or -1 for error.
			  Not meaningful if track is not an audio track.
			*/;
		}
	}
	public static int cdio_get_track_channels(Object p_cdio, Object u_track) {
		 u_last_track = new ();
		if (NULL == p_cdio) {
			ModernizedCProgram.cdio_info("Null CdIo object passed\n");
			return -1;
		} 
		u_last_track = ModernizedCProgram.cdio_get_last_track_num(p_cdio);
		if (u_track > u_last_track) {
			ModernizedCProgram.cdio_log(CDIO_LOG_WARN, "Number of tracks exceeds maximum (%d vs. %d)\n", u_track, u_last_track);
			return -1;
		} 
		if (p_cdio.getOp().getGet_track_channels()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), u_track);
		} else {
				return -2/*! Return copy protection status on a track. Is this meaningful
				  if not an audio track?
				*/;
		} 
	}
	public static Object cdio_get_track_copy_permit(Object p_cdio, Object u_track) {
		if (p_cdio.getOp().getGet_track_copy_permit()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), u_track);
		} else {
				return CDIO_TRACK_FLAG_UNKNOWN/*!
				  Get format of track.
				*/;
		} 
	}
	public static Object cdio_get_track_format(Object p_cdio, Object u_track) {
		if (!p_cdio) {
			return TRACK_FORMAT_ERROR;
		} 
		if (p_cdio.getOp().getGet_track_format()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), u_track);
		} else {
				return TRACK_FORMAT_ERROR/*!
				  Return the Joliet level recognized for p_cdio.
				*/;
		} 
	}
	public static Object cdio_get_joliet_level(Object p_cdio) {
		if (!p_cdio) {
			return 0;
		} 
		{ 
			generic_img_private_t p_env = (generic_img_private_t)(p_cdio.getEnv());
			return p_env.getU_joliet_level();
		}
	}
	public static Object cdio_get_num_tracks(Object p_cdio) {
		if (p_cdio == NULL) {
			return CDIO_INVALID_TRACK;
		} 
		if (p_cdio.getOp().getGet_num_tracks()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv());
		} else {
				return CDIO_INVALID_TRACK/*! Find the track which contans lsn.
				    CDIO_INVALID_TRACK is returned if the lsn outside of the CD or
				    if there was some error.
				
				    If the lsn is before the pregap of the first track 0 is returned.
				    Otherwise we return the track that spans the lsn.
				*/;
		} 
	}
	public static Object cdio_get_track(Object p_cdio, Object lsn) {
		if (!p_cdio) {
			return CDIO_INVALID_TRACK;
		} 
		{ 
			 i_low_track = ModernizedCProgram.cdio_get_first_track_num(p_cdio);
			 i_high_track = ModernizedCProgram.cdio_get_last_track_num(p_cdio) + 1;
			 i_lead_track = i_high_track;
			if (CDIO_INVALID_TRACK == i_low_track || CDIO_INVALID_TRACK == i_high_track) {
				return CDIO_INVALID_TRACK;
			} 
			if (lsn < ModernizedCProgram.cdio_get_track_lsn(p_cdio, i_low_track)) {
				return /* We're in the pre-gap of first track */0;
			} 
			if (lsn > ModernizedCProgram.cdio_get_track_lsn(p_cdio, CDIO_CDROM_LEADOUT_TRACK)) {
				return /* We're beyond the end. */CDIO_INVALID_TRACK;
			} 
			do {
				 i_mid = (i_low_track + i_high_track) / 2;
				 i_mid_lsn = ModernizedCProgram.cdio_get_track_lsn(p_cdio, i_mid);
				if (lsn <= i_mid_lsn) {
					i_high_track = i_mid - 1;
				} 
				if (lsn >= i_mid_lsn) {
					i_low_track = i_mid + 1;
				} 
			} while (i_low_track <= i_high_track);
			if (i_low_track > i_high_track + 1) {
				i_high_track++;
			} 
			if (i_high_track == i_lead_track) {
				return CDIO_CDROM_LEADOUT_TRACK;
			} else {
					return i_high_track/*!
					  Return true if we have XA data (green, mode2 form1) or
					  XA data (green, mode2 form2). That is track begins:
					  sync - header - subheader
					  12     4      -  8
					
					  FIXME: there's gotta be a better design for this and get_track_format?
					*/;
			} 
		}
	}
	public static Object cdio_get_track_green(Object p_cdio, Object u_track) {
		if (p_cdio == NULL) {
			return false;
		} 
		if (p_cdio.getOp().getGet_track_green()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), u_track);
		} else {
				return false/*!
				  Return the starting LBA for track number
				  track_num in cdio.  Tracks numbers start at 1.
				  The "leadout" track is specified either by
				  using track_num LEADOUT_TRACK or the total tracks+1.
				  CDIO_INVALID_LBA is returned on error.
				*/;
		} 
	}
	public static Object cdio_get_track_lba(Object p_cdio, Object u_track) {
		if (NULL == p_cdio) {
			ModernizedCProgram.cdio_info("Null CdIo object passed\n");
			return CDIO_INVALID_LBA;
		} 
		if (p_cdio.getOp().getGet_track_lba()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), u_track);
		} else {
				 msf = new ();
				if (p_cdio.getOp().getGet_track_msf()) {
					if (ModernizedCProgram.cdio_get_track_msf(p_cdio, u_track, msf)) {
						return ModernizedCProgram.cdio_msf_to_lba(msf);
					} 
				} 
				return CDIO_INVALID_LBA/*!
				  Return the starting LSN for track number
				  u_track in cdio.  Tracks numbers start at 1.
				  The "leadout" track is specified either by
				  using u_track LEADOUT_TRACK or the total tracks+1.
				  CDIO_INVALID_LSN is returned on error.
				*/;
		} 
	}
	public static Object cdio_get_track_lsn(Object p_cdio, Object u_track) {
		if (NULL == /*track_t u_last_track; */p_cdio) {
			ModernizedCProgram.cdio_info("Null CdIo object passed\n");
			return CDIO_INVALID_LSN/*
			  u_last_track = cdio_get_last_track_num(p_cdio);
			  if (u_track > u_last_track && u_track != CDIO_CDROM_LEADOUT_TRACK) {
			     cdio_log(CDIO_LOG_WARN, "Number of tracks exceeds maximum (%d vs. %d)\n",
			              u_track, u_last_track);
			     return CDIO_INVALID_LSN;
			  }
			  */;
		} 
		if (p_cdio.getOp().getGet_track_lba()) {
			return ModernizedCProgram.cdio_lba_to_lsn(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), u_track));
		} else {
				 msf = new ();
				if (ModernizedCProgram.cdio_get_track_msf(p_cdio, u_track, msf)) {
					return ModernizedCProgram.cdio_msf_to_lsn(msf);
				} 
				return CDIO_INVALID_LSN/*!
				  Return the International Standard Recording Code (ISRC) for track number
				  u_track in p_cdio.  Track numbers start at 1.
				
				  Note: The caller must free the returned string with cdio_free()
				  when done with it.
				*/;
		} 
	}
	public static Byte cdio_get_track_isrc(Object p_cdio, Object u_track) {
		 u_last_track = new ();
		if (NULL == p_cdio) {
			ModernizedCProgram.cdio_info("Null CdIo object passed\n");
			return NULL;
		} 
		u_last_track = ModernizedCProgram.cdio_get_last_track_num(p_cdio);
		if (u_track > u_last_track) {
			ModernizedCProgram.cdio_log(CDIO_LOG_WARN, "Number of tracks exceeds maximum (%d vs. %d)\n", u_track, u_last_track);
			return NULL;
		} 
		if (p_cdio.getOp().getGet_track_isrc()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), u_track);
		} else {
				return NULL/*!
				  Return the starting LBA for the pregap for track number
				  u_track in cdio.  Track numbers start at 1.
				  CDIO_INVALID_LBA is returned on error.
				*/;
		} 
	}
	public static Object cdio_get_track_pregap_lba(Object p_cdio, Object u_track) {
		if (NULL == p_cdio) {
			ModernizedCProgram.cdio_info("Null CdIo object passed\n");
			return CDIO_INVALID_LBA;
		} 
		if (p_cdio.getOp().getGet_track_pregap_lba()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), u_track);
		} else {
				return CDIO_INVALID_LBA/*!
				  Return the starting LSN for the pregap for track number
				  u_track in cdio.  Track numbers start at 1.
				  CDIO_INVALID_LSN is returned on error.
				*/;
		} 
	}
	public static Object cdio_get_track_pregap_lsn(Object p_cdio, Object u_track) {
		return ModernizedCProgram.cdio_lba_to_lsn(ModernizedCProgram.cdio_get_track_pregap_lba(p_cdio, u_track/*!
		  Return the ending LSN for track number
		  u_track in cdio.  CDIO_INVALID_LSN is returned on error.
		*/));
	}
	public static Object cdio_get_track_last_lsn(Object p_cdio, Object u_track) {
		 lsn = ModernizedCProgram.cdio_get_track_lsn(p_cdio, u_track + 1);
		if (CDIO_INVALID_LSN == lsn) {
			return CDIO_INVALID_LSN;
		} 
		return lsn - /* Safe, we've always the leadout. */1/*!
		  Return the starting MSF (minutes/secs/frames) for track number
		  u_track in cdio.  Track numbers start at 1.
		  The "leadout" track is specified either by
		  using u_track LEADOUT_TRACK or the total tracks+1.
		  False is returned if there is no track entry.
		*/;
	}
	/*out*/
	public static Object cdio_get_track_msf(Object p_cdio, Object u_track, Object msf) {
		if (!p_cdio) {
			return false;
		} 
		if (p_cdio.getOp().getGet_track_msf()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), u_track, msf);
		}  else if (p_cdio.getOp().getGet_track_lba()) {
			 lba = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), u_track);
			if (lba == CDIO_INVALID_LBA) {
				return false;
			} 
			ModernizedCProgram.cdio_lba_to_msf(lba, msf);
			return true;
		} else {
				return false/*! Return copy protection status on a track. Is this meaningful
				  if not an audio track?
				*/;
		} 
	}
	public static Object cdio_get_track_preemphasis(Object p_cdio, Object u_track) {
		if (p_cdio.getOp().getGet_track_preemphasis()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), u_track);
		} else {
				return CDIO_TRACK_FLAG_UNKNOWN/*!
				  Return the number of sectors between this track an the next.  This
				  includes any pregap sectors before the start of the next track.
				  Tracks start at 1.
				  0 is returned if there is an error.
				*/;
		} 
	}
	public static int cdio_get_track_sec_count(Object p_cdio, Object u_track) {
		 u_tracks = ModernizedCProgram.cdio_get_num_tracks(p_cdio);
		if (u_track >= 1 && u_track <= u_tracks) {
			return (ModernizedCProgram.cdio_get_track_lba(p_cdio, u_track + 1) - ModernizedCProgram.cdio_get_track_lba(p_cdio, u_track));
		} 
		return 0;
	}
	public static Object UnlockDrive(Object hDrive) {
		DWORD size = new DWORD();
		return /*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, ((Object)0), 0, size, ((Object)0));
	}
	public static void rb_free_extent(ext2fs_rb_private bp, bmap_rb_extent ext) {
		bmap_rb_extent generatedWcursor = bp.getWcursor();
		if (generatedWcursor == ext) {
			bp.setWcursor(((Object)0));
		} 
		bmap_rb_extent generatedRcursor = bp.getRcursor();
		if (generatedRcursor == ext) {
			bp.setRcursor(((Object)0));
		} 
		bmap_rb_extent generatedRcursor_next = bp.getRcursor_next();
		if (generatedRcursor_next == ext) {
			bp.setRcursor_next(((Object)0));
		} 
		ModernizedCProgram.ext2fs_free_mem(ext);
	}
	public static Object rb_alloc_private_data(Object bitmap) {
		ext2fs_rb_private bp = new ext2fs_rb_private();
		 retval = new ();
		retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Unsupported expression*/, bp);
		if (retval) {
			return retval;
		} 
		bp.setRoot(/*Error: Unsupported expression*/);
		bp.setRcursor(((Object)0));
		bp.setRcursor_next(((Object)0));
		bp.setWcursor(((Object)0));
		bitmap.setPrivate((Object)bp);
		return 0;
	}
	public static Object rb_new_bmap(Object fs, Object bitmap) {
		 retval = new ();
		retval = ModernizedCProgram.rb_alloc_private_data(bitmap);
		if (retval) {
			return retval;
		} 
		return 0;
	}
	public static void rb_free_bmap(Object bitmap) {
		ext2fs_rb_private bp = new ext2fs_rb_private();
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		rb_root generatedRoot = bp.getRoot();
		generatedRoot.rb_free_tree();
		ModernizedCProgram.ext2fs_free_mem(bp);
		bp = 0;
	}
	public static Object rb_copy_bmap(Object src, Object dest) {
		ext2fs_rb_private src_bp = new ext2fs_rb_private();
		ext2fs_rb_private dest_bp = new ext2fs_rb_private();
		bmap_rb_extent src_ext = new bmap_rb_extent();
		bmap_rb_extent dest_ext = new bmap_rb_extent();
		rb_node dest_node = new rb_node();
		rb_node src_node = new rb_node();
		rb_node dest_last = new rb_node();
		rb_node n = new rb_node();
		 retval = 0;
		retval = ModernizedCProgram.rb_alloc_private_data(dest);
		if (retval) {
			return retval;
		} 
		src_bp = (ext2fs_rb_private)src.getPrivate();
		dest_bp = (ext2fs_rb_private)dest.getPrivate();
		src_bp.setRcursor(((Object)0));
		dest_bp.setRcursor(((Object)0));
		rb_root generatedRoot = src_bp.getRoot();
		rb_node rb_node = new rb_node();
		src_node = rb_node.ext2fs_rb_first(generatedRoot);
		bmap_rb_extent bmap_rb_extent = new bmap_rb_extent();
		rb_node generatedNode = dest_ext.getNode();
		rb_node generatedRb_node = generatedRoot.getRb_node();
		rb_node rb_node = new rb_node();
		rb_node generatedRb_right = (dest_last).getRb_right();
		while (src_node) {
			src_ext = bmap_rb_extent.node_to_extent(src_node);
			retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Unsupported expression*/, dest_ext);
			if (retval) {
				break;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(dest_ext, src_ext, /*Error: Unsupported expression*/);
			dest_node = generatedNode;
			n = generatedRb_node;
			dest_last = ((Object)0);
			if (n) {
				dest_last = rb_node.ext2fs_rb_last(generatedRoot);
				n = generatedRb_right;
			} 
			dest_node.ext2fs_rb_link_node(dest_last, n);
			ModernizedCProgram.ext2fs_rb_insert_color(dest_node, generatedRoot);
			src_node = src_node.ext2fs_rb_next();
		}
		return retval;
	}
	public static Object rb_resize_bmap(Object bmap, Object new_end, Object new_real_end) {
		ext2fs_rb_private bp = new ext2fs_rb_private();
		bp = (ext2fs_rb_private)bmap.getPrivate();
		bp.setRcursor(((Object)0));
		bp.setWcursor(((Object)0));
		rb_root generatedRoot = bp.getRoot();
		generatedRoot.rb_truncate(((new_end < bmap.getEnd()) ? new_end : bmap.getEnd()) - bmap.getStart());
		bmap.setEnd(new_end);
		bmap.setReal_end(new_real_end);
		if (bmap.getEnd() < bmap.getReal_end()) {
			bp.rb_insert_extent(bmap.getEnd() + 1 - bmap.getStart(), bmap.getReal_end() - bmap.getEnd());
		} 
		return 0;
	}
	public static int rb_mark_bmap(Object bitmap, Object arg) {
		ext2fs_rb_private bp = new ext2fs_rb_private();
		int retval;
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		arg -= bitmap.getStart();
		retval = bp.rb_insert_extent(arg, 1);
		do {
		} while (0);
		return retval;
	}
	public static int rb_unmark_bmap(Object bitmap, Object arg) {
		ext2fs_rb_private bp = new ext2fs_rb_private();
		int retval;
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		arg -= bitmap.getStart();
		retval = bp.rb_remove_extent(arg, 1);
		do {
		} while (0);
		return retval;
	}
	public static int rb_test_bmap(Object bitmap, Object arg) {
		ext2fs_rb_private bp = new ext2fs_rb_private();
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		arg -= bitmap.getStart();
		return bp.rb_test_bit(arg);
	}
	public static void rb_mark_bmap_extent(Object bitmap, Object arg, int num) {
		ext2fs_rb_private bp = new ext2fs_rb_private();
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		arg -= bitmap.getStart();
		bp.rb_insert_extent(arg, num);
		do {
		} while (0);
	}
	public static void rb_unmark_bmap_extent(Object bitmap, Object arg, int num) {
		ext2fs_rb_private bp = new ext2fs_rb_private();
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		arg -= bitmap.getStart();
		bp.rb_remove_extent(arg, num);
		do {
		} while (0);
	}
	public static int rb_test_clear_bmap_extent(Object bitmap, Object start, int len) {
		rb_node parent = ((Object)0);
		rb_node n = new rb_node();
		rb_node node = new rb_node();
		rb_node next = new rb_node();
		ext2fs_rb_private bp = new ext2fs_rb_private();
		bmap_rb_extent ext = new bmap_rb_extent();
		int retval = 1;
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		rb_root generatedRoot = bp.getRoot();
		rb_node generatedRb_node = generatedRoot.getRb_node();
		n = generatedRb_node;
		start -= bitmap.getStart();
		if (len == 0 || generatedRoot.ext2fs_rb_empty_root()) {
			return 1/*
				 * If we find nothing, we should examine whole extent, but
				 * when we find match, the extent is not clean, thus be return
				 * false.
				 */;
		} 
		bmap_rb_extent bmap_rb_extent = new bmap_rb_extent();
		Object generatedStart = ext.getStart();
		rb_node generatedRb_left = (n).getRb_left();
		Object generatedCount = ext.getCount();
		rb_node generatedRb_right = (n).getRb_right();
		while (n) {
			parent = n;
			ext = bmap_rb_extent.node_to_extent(parent);
			if (start < generatedStart) {
				n = generatedRb_left;
			}  else if (start >= (generatedStart + generatedCount)) {
				n = generatedRb_right;
			} else {
					return 0;
			} 
		}
		node = parent;
		while (node) {
			next = node.ext2fs_rb_next();
			ext = bmap_rb_extent.node_to_extent(node);
			node = next;
			if ((generatedStart + generatedCount) <= start) {
				continue;
			} 
			if ((start + len) <= generatedStart) {
				break;
			} 
			retval = 0;
			break;
		}
		return retval;
	}
	public static Object rb_set_bmap_range(Object bitmap, Object start, Object num, Object in) {
		ext2fs_rb_private bp = new ext2fs_rb_private();
		byte cp = in;
		size_t i = new size_t();
		int first_set = -1;
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		for (i = 0; i < num; i++) {
			if ((i & 7) == 0) {
				byte c = cp[i / 8];
				if (c == -1024) {
					if (first_set == -1) {
						first_set = i;
					} 
					i += 7;
					continue;
				} 
				if ((c == -1024) && (first_set == -1)) {
					i += 7;
					continue;
				} 
			} 
			if (ModernizedCProgram.ext2fs_test_bit(i, in)) {
				if (first_set == -1) {
					first_set = i;
				} 
				continue;
			} 
			if (first_set == -1) {
				continue;
			} 
			bp.rb_insert_extent(start + first_set - bitmap.getStart(), i - first_set);
			do {
			} while (0);
			first_set = -1;
		}
		if (first_set != -1) {
			bp.rb_insert_extent(start + first_set - bitmap.getStart(), num - first_set);
			do {
			} while (0);
		} 
		return 0;
	}
	public static Object rb_get_bmap_range(Object bitmap, Object start, Object num, Object out) {
		rb_node parent = ((Object)0);
		rb_node next = new rb_node();
		rb_node n = new rb_node();
		ext2fs_rb_private bp = new ext2fs_rb_private();
		bmap_rb_extent ext = new bmap_rb_extent();
		 count = new ();
		 pos = new ();
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		rb_root generatedRoot = bp.getRoot();
		rb_node generatedRb_node = generatedRoot.getRb_node();
		n = generatedRb_node;
		start -= bitmap.getStart();
		if (generatedRoot.ext2fs_rb_empty_root()) {
			return 0;
		} 
		bmap_rb_extent bmap_rb_extent = new bmap_rb_extent();
		Object generatedStart = ext.getStart();
		rb_node generatedRb_left = (n).getRb_left();
		Object generatedCount = ext.getCount();
		rb_node generatedRb_right = (n).getRb_right();
		while (n) {
			parent = n;
			ext = bmap_rb_extent.node_to_extent(parent);
			if (start < generatedStart) {
				n = generatedRb_left;
			}  else if (start >= (generatedStart + generatedCount)) {
				n = generatedRb_right;
			} else {
					break;
			} 
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(out, 0, (num + 7) >> 3);
		for (; parent != ((Object)0); parent = next) {
			next = parent.ext2fs_rb_next();
			ext = bmap_rb_extent.node_to_extent(parent);
			pos = generatedStart;
			count = generatedCount;
			if (pos >= start + num) {
				break;
			} 
			if (pos < start) {
				if (pos + count < start) {
					continue;
				} 
				count -= start - pos;
				pos = start;
			} 
			if (pos + count > start + num) {
				count = start + num - pos;
			} 
			while (count > 0) {
				if ((count >= 8) && ((pos - start) % 8) == 0) {
					int nbytes = count >> 3;
					int offset = (pos - start) >> 3;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(((byte)out) + offset, -1024, nbytes);
					pos += nbytes << 3;
					count -= nbytes << 3;
					continue;
				} 
				ModernizedCProgram.ext2fs_fast_set_bit64((pos - start), out);
				pos++;
				count--;
			}
		}
		return 0;
	}
	public static void rb_clear_bmap(Object bitmap) {
		ext2fs_rb_private bp = new ext2fs_rb_private();
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		rb_root generatedRoot = bp.getRoot();
		generatedRoot.rb_free_tree();
		bp.setRcursor(((Object)0));
		bp.setRcursor_next(((Object)0));
		bp.setWcursor(((Object)0));
		do {
		} while (0);
	}
	public static Object rb_find_first_zero(Object bitmap, Object start, Object end, Object out) {
		rb_node parent = ((Object)0);
		rb_node n = new rb_node();
		ext2fs_rb_private bp = new ext2fs_rb_private();
		bmap_rb_extent ext = new bmap_rb_extent();
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		rb_root generatedRoot = bp.getRoot();
		rb_node generatedRb_node = generatedRoot.getRb_node();
		n = generatedRb_node;
		start -= bitmap.getStart();
		end -= bitmap.getStart();
		if (start > end) {
			return 22;
		} 
		if (generatedRoot.ext2fs_rb_empty_root()) {
			return 2;
		} 
		bmap_rb_extent bmap_rb_extent = new bmap_rb_extent();
		Object generatedStart = ext.getStart();
		rb_node generatedRb_left = (n).getRb_left();
		Object generatedCount = ext.getCount();
		rb_node generatedRb_right = (n).getRb_right();
		while (n) {
			parent = n;
			ext = bmap_rb_extent.node_to_extent(parent);
			if (start < generatedStart) {
				n = generatedRb_left;
			}  else if (start >= (generatedStart + generatedCount)) {
				n = generatedRb_right;
			}  else if (generatedStart + generatedCount <= end) {
				out = generatedStart + generatedCount + generatedStart;
				return 0;
			} else {
					return 2;
			} 
		}
		out = start + generatedStart;
		return 0;
	}
	public static Object rb_find_first_set(Object bitmap, Object start, Object end, Object out) {
		rb_node parent = ((Object)0);
		rb_node n = new rb_node();
		rb_node node = new rb_node();
		ext2fs_rb_private bp = new ext2fs_rb_private();
		bmap_rb_extent ext = new bmap_rb_extent();
		bp = (ext2fs_rb_private)bitmap.getPrivate();
		rb_root generatedRoot = bp.getRoot();
		rb_node generatedRb_node = generatedRoot.getRb_node();
		n = generatedRb_node;
		start -= bitmap.getStart();
		end -= bitmap.getStart();
		if (start > end) {
			return 22;
		} 
		if (generatedRoot.ext2fs_rb_empty_root()) {
			return 2;
		} 
		bmap_rb_extent bmap_rb_extent = new bmap_rb_extent();
		Object generatedStart = ext.getStart();
		rb_node generatedRb_left = (n).getRb_left();
		Object generatedCount = ext.getCount();
		rb_node generatedRb_right = (n).getRb_right();
		while (n) {
			parent = n;
			ext = bmap_rb_extent.node_to_extent(parent);
			if (start < generatedStart) {
				n = generatedRb_left;
			}  else if (start >= (generatedStart + generatedCount)) {
				n = generatedRb_right;
			} else {
					out = start + generatedStart;
					return 0;
			} 
		}
		node = parent;
		ext = bmap_rb_extent.node_to_extent(node);
		if (generatedStart < start) {
			node = node.ext2fs_rb_next();
			if (node == ((Object)0)) {
				return 2;
			} 
			ext = bmap_rb_extent.node_to_extent(node);
		} 
		if (generatedStart <= end) {
			out = generatedStart + generatedStart;
			return 0;
		} 
		return 2;
	}
	public static void rb_print_stats(Object bitmap) {
	}
	/*
	 * ext2fsP.h --- private header file for ext2 library
	 *
	 * Copyright (C) 1997 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static int ext2fsP_is_disk_device(Object mode) {
		return /*Error: Function owner not recognized*/S_ISBLK(mode);
	}
	public static Object ext2fs_file_open(Object fs, Object ino, int flags, Object ret) {
		return ((Object)0).ext2fs_file_open2(fs, ino, flags, ret/*
		 * This function returns the filesystem handle of a file from the structure
		 */);
	}
	public static Object ext2fs_file_get_fs(Object file) {
		if (file.getMagic() != EXT2_ET_MAGIC_EXT2_FILE) {
			return 0;
		} 
		return file.getFs();
	}
	/* This function returns the inode number from the structure */
	public static Object ext2fs_file_get_inode_num(Object file) {
		if (file.getMagic() != EXT2_ET_MAGIC_EXT2_FILE) {
			return 0;
		} 
		return file.getIno();
	}
	public static Object ext2fs_file_flush(Object file) {
		 retval = new ();
		ext2_filsys fs = new ext2_filsys();
		int ret_flags;
		 dontcare = new ();
		if (!(file) || (file).getMagic() != (EXT2_ET_MAGIC_EXT2_FILE)) {
			return (EXT2_ET_MAGIC_EXT2_FILE);
		} 
		fs = file.getFs();
		if (!(file.getFlags() & -1024) || !(file.getFlags() & -1024)) {
			return 0;
		} 
		if (file.getPhysblock() && file.getInode().getI_flags() & /* Is this an uninit block? */-1024) {
			retval = file.getInode().ext2fs_bmap2(fs, file.getIno(), (file.getBuf() + fs.getBlocksize()), 0, file.getBlockno(), ret_flags, dontcare);
			if (retval) {
				return retval;
			} 
			if (ret_flags & -1024) {
				retval = file.getInode().ext2fs_bmap2(fs, file.getIno(), (file.getBuf() + fs.getBlocksize()), -1024, file.getBlockno(), 0, file.getPhysblock());
				if (retval) {
					return retval;
				} 
			} 
		} 
		if (!file.getPhysblock()) {
			retval = file.getInode().ext2fs_bmap2(fs, file.getIno(), (file.getBuf() + fs.getBlocksize()), file.getIno() ? -1024 : 0, file.getBlockno(), 0, file.getPhysblock());
			if (retval) {
				return retval;
			} 
		} 
		retval = ModernizedCProgram.io_channel_write_blk64(fs.getIo(), file.getPhysblock(), 1, file.getBuf());
		if (retval) {
			return retval;
		} 
		file.getFlags() &=  ~-1024;
		return retval/*
		 * This function synchronizes the file's block buffer and the current
		 * file position, possibly invalidating block buffer if necessary
		 */;
	}
	public static Object sync_buffer_position(Object file) {
		 b = new ();
		 retval = new ();
		b = file.getPos() / file.getFs().getBlocksize();
		if (b != file.getBlockno()) {
			retval = ModernizedCProgram.ext2fs_file_flush(file);
			if (retval) {
				return retval;
			} 
			file.getFlags() &=  ~-1024;
		} 
		file.setBlockno(b);
		return 0/*
		 * This function loads the file's block buffer with valid data from
		 * the disk as necessary.
		 *
		 * If dontfill is true, then skip initializing the buffer since we're
		 * going to be replacing its entire contents anyway.  If set, then the
		 * function basically only sets file->physblock and EXT2_FILE_BUF_VALID
		 */;
	}
	public static Object load_buffer(Object file, int dontfill) {
		ext2_filsys fs = file.getFs();
		 retval = new ();
		int ret_flags;
		if (!(file.getFlags() & -1024)) {
			retval = file.getInode().ext2fs_bmap2(fs, file.getIno(), (file.getBuf() + fs.getBlocksize()), 0, file.getBlockno(), ret_flags, file.getPhysblock());
			if (retval) {
				return retval;
			} 
			if (!dontfill) {
				if (file.getPhysblock() && !(ret_flags & -1024)) {
					retval = ModernizedCProgram.io_channel_read_blk64(fs.getIo(), file.getPhysblock(), 1, file.getBuf());
					if (retval) {
						return retval;
					} 
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(file.getBuf(), 0, fs.getBlocksize());
				} 
			} 
			file.getFlags() |=  -1024;
		} 
		return 0;
	}
	public static Object ext2fs_file_close(Object file) {
		 retval = new ();
		if (!(file) || (file).getMagic() != (EXT2_ET_MAGIC_EXT2_FILE)) {
			return (EXT2_ET_MAGIC_EXT2_FILE);
		} 
		retval = ModernizedCProgram.ext2fs_file_flush(file);
		if (file.getBuf()) {
			ModernizedCProgram.ext2fs_free_mem(file.getBuf());
		} 
		ModernizedCProgram.ext2fs_free_mem(file);
		return retval;
	}
	public static Object ext2fs_file_read_inline_data(Object file, Object buf, int wanted, Integer got) {
		ext2_filsys fs = new ext2_filsys();
		 retval = new ();
		int count = 0;
		size_t size = new size_t();
		fs = file.getFs();
		retval = file.getInode().ext2fs_inline_data_get(fs, file.getIno(), file.getBuf(), size);
		if (retval) {
			return retval;
		} 
		if (file.getPos() >= size) {
			;
		} 
		count = size - file.getPos();
		if (count > wanted) {
			count = wanted;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(buf, file.getBuf() + file.getPos(), count);
		file.getPos() += count;
		buf = (byte)buf + count;
		return retval;
	}
	public static Object ext2fs_file_read(Object file, Object buf, int wanted, Integer got) {
		ext2_filsys fs = new ext2_filsys();
		 retval = 0;
		int start;
		int c;
		int count = 0;
		 left = new ();
		byte ptr = (byte)buf;
		if (!(file) || (file).getMagic() != (EXT2_ET_MAGIC_EXT2_FILE)) {
			return (EXT2_ET_MAGIC_EXT2_FILE);
		} 
		fs = file.getFs();
		if (file.getInode().getI_flags() & /* If an inode has inline data, things get complicated. */-1024) {
			return ModernizedCProgram.ext2fs_file_read_inline_data(file, buf, wanted, got);
		} 
		while ((file.getPos() < ((file.getInode()).getI_size() | (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(file.getInode()).getI_size_high() << 32))) && (wanted > 0)) {
			retval = ModernizedCProgram.sync_buffer_position(file);
			if (retval) {
				;
			} 
			retval = ModernizedCProgram.load_buffer(file, 0);
			if (retval) {
				;
			} 
			start = file.getPos() % fs.getBlocksize();
			c = fs.getBlocksize() - start;
			if (c > wanted) {
				c = wanted;
			} 
			left = ((file.getInode()).getI_size() | (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(file.getInode()).getI_size_high() << 32)) - file.getPos();
			if (c > left) {
				c = left;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ptr, file.getBuf() + start, c);
			file.getPos() += c;
			ptr += c;
			count += c;
			wanted -= c;
		}
		return retval;
	}
	public static Object ext2fs_file_write_inline_data(Object file, Object buf, int nbytes, Integer written) {
		ext2_filsys fs = new ext2_filsys();
		 retval = new ();
		int count = 0;
		size_t size = new size_t();
		fs = file.getFs();
		retval = file.getInode().ext2fs_inline_data_get(fs, file.getIno(), file.getBuf(), size);
		if (retval) {
			return retval;
		} 
		if (file.getPos() < size) {
			count = nbytes - file.getPos();
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(file.getBuf() + file.getPos(), buf, count);
			retval = file.getInode().ext2fs_inline_data_set(fs, file.getIno(), file.getBuf(), count);
			if (retval == EXT2_ET_INLINE_DATA_NO_SPACE) {
				;
			} 
			if (retval) {
				return retval;
			} 
			file.getPos() += count;
			if (count != 0 && ((file.getInode()).getI_size() | (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(file.getInode()).getI_size_high() << 32)) < file.getPos()) {
				 rc = new ();
				rc = ModernizedCProgram.ext2fs_file_set_size2(file, file.getPos());
				if (retval == 0) {
					retval = rc;
				} 
			} 
			if (written) {
				written = count;
			} 
			return 0;
		} 
		if (retval) {
			return retval/*
				 * reload inode and return no space error
				 *
				 * XXX: file->inode could be copied from the outside
				 * in ext2fs_file_open2().  We have no way to modify
				 * the outside inode.
				 */;
		} 
		retval = file.getInode().ext2fs_read_inode(fs, file.getIno());
		if (retval) {
			return retval;
		} 
		return EXT2_ET_INLINE_DATA_NO_SPACE;
	}
	public static Object ext2fs_file_write(Object file, Object buf, int nbytes, Integer written) {
		ext2_filsys fs = new ext2_filsys();
		 retval = 0;
		int start;
		int c;
		int count = 0;
		byte ptr = (byte)buf;
		block_entry_t new_block = ((Object)0);
		block_entry_t old_block = ((Object)0);
		int bmap_flags = 0;
		if (!(file) || (file).getMagic() != (EXT2_ET_MAGIC_EXT2_FILE)) {
			return (EXT2_ET_MAGIC_EXT2_FILE);
		} 
		fs = file.getFs();
		if (!(file.getFlags() & -1024)) {
			return EXT2_ET_FILE_RO;
		} 
		if (file.getInode().getI_flags() & /* If an inode has inline data, things get complicated. */-1024) {
			retval = ModernizedCProgram.ext2fs_file_write_inline_data(file, buf, nbytes, written);
			if (retval != EXT2_ET_INLINE_DATA_NO_SPACE) {
				return retval;
			} 
			retval = /* fall through to read data from the block */0;
		} 
		while (nbytes > 0) {
			retval = ModernizedCProgram.sync_buffer_position(file);
			if (retval) {
				;
			} 
			start = file.getPos() % fs.getBlocksize();
			c = fs.getBlocksize() - start;
			if (c > nbytes) {
				c = nbytes/*
						 * We only need to do a read-modify-update cycle if
						 * we're doing a partial write.
						 */;
			} 
			retval = ModernizedCProgram.load_buffer(file, (c == fs.getBlocksize()));
			if (retval) {
				;
			} 
			file.getFlags() |=  -1024;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(file.getBuf() + start, ptr, c/*
					 * OK, the physical block hasn't been allocated yet.
					 * Allocate it.
					 */);
			if (!file.getPhysblock()) {
				bmap_flags = (file.getIno() ? -1024 : 0);
				if (fs.getFlags() & -1024) {
					new_block = /*Error: Function owner not recognized*/calloc(1, /*Error: sizeof expression not supported yet*/);
					if (!new_block) {
						retval = EXT2_ET_NO_MEMORY;
						;
					} 
					ModernizedCProgram.ext2fs_sha512((byte)file.getBuf(), fs.getBlocksize(), new_block.getSha());
					old_block = fs.getBlock_sha_map().ext2fs_hashmap_lookup(new_block.getSha(), /*Error: sizeof expression not supported yet*/);
				} 
				if (old_block) {
					file.setPhysblock(old_block.getPhysblock());
					bmap_flags |=  -1024;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(new_block);
					new_block = ((Object)0);
				} 
				retval = file.getInode().ext2fs_bmap2(fs, file.getIno(), (file.getBuf() + fs.getBlocksize()), bmap_flags, file.getBlockno(), 0, file.getPhysblock());
				if (retval) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(new_block);
					new_block = ((Object)0);
					;
				} 
				if (new_block) {
					new_block.setPhysblock(file.getPhysblock());
					fs.getBlock_sha_map().ext2fs_hashmap_add(new_block, new_block.getSha(), /*Error: sizeof expression not supported yet*/);
				} 
				if (bmap_flags & -1024) {
					file.getInode().ext2fs_iblk_add_blocks(fs, 1);
					file.getInode().ext2fs_write_inode(fs, file.getIno());
				} 
			} 
			file.getPos() += c;
			ptr += c;
			count += c;
			nbytes -= c;
		}
		if (written) {
			written = count;
		} 
		return retval;
	}
	public static Object ext2fs_file_llseek(Object file, Object offset, int whence, Object ret_pos) {
		if (!(file) || (file).getMagic() != (EXT2_ET_MAGIC_EXT2_FILE)) {
			return (EXT2_ET_MAGIC_EXT2_FILE);
		} 
		if (whence == 0) {
			file.setPos(offset);
		}  else if (whence == 1) {
			file.getPos() += offset;
		}  else if (whence == 2) {
			file.setPos(((file.getInode()).getI_size() | (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(file.getInode()).getI_size_high() << 32)) + offset);
		} else {
				return EXT2_ET_INVALID_ARGUMENT;
		} 
		if (ret_pos) {
			ret_pos = file.getPos();
		} 
		return 0;
	}
	public static Object ext2fs_file_lseek(Object file, Object offset, int whence, Object ret_pos) {
		 loffset = new ();
		 ret_loffset = 0;
		 retval = new ();
		loffset = offset;
		retval = ModernizedCProgram.ext2fs_file_llseek(file, loffset, whence, ret_loffset);
		if (ret_pos) {
			ret_pos = ()ret_loffset;
		} 
		return retval;
	}
	/*
	 * This function returns the size of the file, according to the inode
	 */
	public static Object ext2fs_file_get_lsize(Object file, Object ret_size) {
		if (file.getMagic() != EXT2_ET_MAGIC_EXT2_FILE) {
			return EXT2_ET_MAGIC_EXT2_FILE;
		} 
		ret_size = ((file.getInode()).getI_size() | (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(file.getInode()).getI_size_high() << 32));
		return 0/*
		 * This function returns the size of the file, according to the inode
		 */;
	}
	public static Object ext2fs_file_get_size(Object file) {
		 size = new ();
		if (ModernizedCProgram.ext2fs_file_get_lsize(file, size)) {
			return 0;
		} 
		if ((size >> 32) != 0) {
			return 0;
		} 
		return size;
	}
	/* Zero the parts of the last block that are past EOF. */
	public static Object ext2fs_file_zero_past_offset(Object file, Object offset) {
		ext2_filsys fs = file.getFs();
		byte b = ((Object)0);
		 off = offset % fs.getBlocksize();
		 blk = new ();
		int ret_flags;
		 retval = new ();
		if (off == 0) {
			return 0;
		} 
		retval = ModernizedCProgram.sync_buffer_position(file);
		if (retval) {
			return retval;
		} 
		retval = ((Object)0).ext2fs_bmap2(fs, file.getIno(), ((Object)0), /* Is there an initialized block at the end? */0, offset / fs.getBlocksize(), ret_flags, blk);
		if (retval) {
			return retval;
		} 
		if ((blk == 0) || (ret_flags & -1024)) {
			return 0;
		} 
		retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), /* Zero to the end of the block */b);
		if (retval) {
			return retval;
		} 
		retval = ModernizedCProgram.io_channel_read_blk64(fs.getIo(), blk, 1, /* Read/zero/write block */b);
		if (retval) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(b + off, 0, fs.getBlocksize() - off);
		retval = ModernizedCProgram.io_channel_write_blk64(fs.getIo(), blk, 1, b);
		if (retval) {
			;
		} 
		return retval/*
		 * This function sets the size of the file, truncating it if necessary
		 *
		 */;
	}
	public static Object ext2fs_file_set_size2(Object file, Object size) {
		 old_size = new ();
		 retval = new ();
		 old_truncate = new ();
		 truncate_block = new ();
		if (!(file) || (file).getMagic() != (EXT2_ET_MAGIC_EXT2_FILE)) {
			return (EXT2_ET_MAGIC_EXT2_FILE);
		} 
		if (size && file.getInode().ext2fs_file_block_offset_too_big(file.getFs(), (size - 1) / file.getFs().getBlocksize())) {
			return EXT2_ET_FILE_TOO_BIG;
		} 
		truncate_block = ((size + file.getFs().getBlocksize() - 1) >> ((file.getFs().getSuper()).getS_log_block_size() + 10));
		old_size = ((file.getInode()).getI_size() | (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(file.getInode()).getI_size_high() << 32));
		old_truncate = ((old_size + file.getFs().getBlocksize() - 1) >> ((file.getFs().getSuper()).getS_log_block_size() + 10));
		retval = file.getInode().ext2fs_inode_size_set(file.getFs(), size);
		if (retval) {
			return retval;
		} 
		if (file.getIno()) {
			retval = file.getInode().ext2fs_write_inode(file.getFs(), file.getIno());
			if (retval) {
				return retval;
			} 
		} 
		retval = ModernizedCProgram.ext2fs_file_zero_past_offset(file, size);
		if (retval) {
			return retval;
		} 
		if (truncate_block >= old_truncate) {
			return 0;
		} 
		return file.getInode().ext2fs_punch(file.getFs(), file.getIno(), 0, truncate_block, ~-1024);
	}
	public static Object ext2fs_file_set_size(Object file, Object size) {
		return ModernizedCProgram.ext2fs_file_set_size2(file, size);
	}
	/*
	 * MSAPI_UTF8: Common API calls using UTF-8 strings
	 * Compensating for what Microsoft should have done a long long time ago.
	 * Also see https://utf8everywhere.org
	 *
	 * Copyright Â© 2010-2019 Pete Batard <pete@akeo.ie>
	 *
	 * This library is free software; you can redistribute it and/or
	 * modify it under the terms of the GNU Lesser General Public
	 * License as published by the Free Software Foundation; either
	 * version 3 of the License, or (at your option) any later version.
	 *
	 * This library is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 * Lesser General Public License for more details.
	 *
	 * You should have received a copy of the GNU Lesser General Public
	 * License along with this library; if not, write to the Free Software
	 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
	 */
	// disable VS2012 Code Analysis warnings that are intentional
	// Don't care about bad params
	// Never ever use isdigit() or isspace(), etc. on UTF-8 strings!
	// These calls take an int and char is signed so MS compilers will produce an assert error on anything that's > 0x80
	// NB: other issomething() calls are not implemented as they may require multibyte UTF-8 sequences to be converted
	/*
	 * Converts an UTF-16 string to UTF8 (allocate returned string)
	 * Returns NULL on error
	 */
	public static Byte wchar_to_utf8(Object[] wstr) {
		int size = 0;
		byte str = ((Object)0);
		// Convert the empty string tooif (wstr[0] == 0) {
			return /*Error: Function owner not recognized*/calloc(1, 1);
		} 
		// Find out the size we need to allocate for our converted string// Find out the size we need to allocate for our converted stringsize = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wstr, -1, ((Object)0), 0, ((Object)0), ((Object)0));
		// An empty string would be size 1if (size <= 1) {
			return ((Object)0);
		} 
		if ((str = (byte)/*Error: Function owner not recognized*/calloc(size, 1)) == ((Object)0)) {
			return ((Object)0);
		} 
		if (/*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wstr, -1, str, size, ((Object)0), ((Object)0)) != size) {
			do {
				if (str != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(str));
					str = ((Object)0);
				} 
			} while (0);
			return ((Object)0);
		} 
		return str/*
		 * Converts an UTF8 string to UTF-16 (allocate returned string)
		 * Returns NULL on error
		 */;
	}
	public static Object utf8_to_wchar(Object[] str) {
		int size = 0;
		wchar_t wstr = ((Object)0);
		if (str == ((Object)0)) {
			return ((Object)0);
		} 
		// Convert the empty string tooif (str[0] == 0) {
			return /*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/);
		} 
		// Find out the size we need to allocate for our converted string// Find out the size we need to allocate for our converted stringsize = /*Error: Function owner not recognized*/MultiByteToWideChar(65001, 0, str, -1, ((Object)0), 0);
		// An empty string would be size 1if (size <= 1) {
			return ((Object)0);
		} 
		if ((wstr = (wchar_t)/*Error: Function owner not recognized*/calloc(size, /*Error: Unsupported expression*/)) == ((Object)0)) {
			return ((Object)0);
		} 
		if (/*Error: Function owner not recognized*/MultiByteToWideChar(65001, 0, str, -1, wstr, size) != size) {
			do {
				if (wstr != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wstr));
					wstr = ((Object)0);
				} 
			} while (0);
			return ((Object)0);
		} 
		return wstr/*
		* Converts an non NUL-terminated UTF-16 string of length len to UTF8 (allocate returned string)
		* Returns NULL on error
		*/;
	}
	public static Byte wchar_len_to_utf8(Object wstr, int wlen) {
		int size = 0;
		byte str = ((Object)0);
		// Find out the size we need to allocate for our converted string// Find out the size we need to allocate for our converted stringsize = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wstr, wlen, ((Object)0), 0, ((Object)0), ((Object)0));
		// An empty string would be size 1if (size <= 1) {
			return ((Object)0);
		} 
		if ((str = (byte)/*Error: Function owner not recognized*/calloc(size, 1)) == ((Object)0)) {
			return ((Object)0);
		} 
		if (/*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wstr, wlen, str, size, ((Object)0), ((Object)0)) != size) {
			do {
				if (str != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(str));
					str = ((Object)0);
				} 
			} while (0);
			return ((Object)0);
		} 
		return str;
	}
	public static Object FormatMessageU(Object dwFlags, Object lpSource, Object dwMessageId, Object dwLanguageId, Byte lpBuffer, Object nSize, Object Arguments) {
		DWORD ret = 0;
		DWORD err = -1024;
		// coverity[returned_null]
		wchar_t wlpBuffer = (lpBuffer == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(nSize, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId, wlpBuffer, nSize, Arguments);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpBuffer, -1, lpBuffer, nSize, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
			ret = 0;
		} 
		do {
			if (wlpBuffer != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpBuffer));
				wlpBuffer = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	// SendMessage, with LPARAM as UTF-8 string
	public static Object SendMessageLU(Object hWnd, Object Msg, Object wParam, Object lParam) {
		LRESULT ret = 0;
		DWORD err = -1024;
		wchar_t wlParam = ModernizedCProgram.utf8_to_wchar(lParam);
		ret = /*Error: Function owner not recognized*/SendMessageW(hWnd, Msg, wParam, (LPARAM)wlParam);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlParam != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlParam));
				wlParam = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static int DrawTextExU(Object hDC, Object lpchText, int nCount, Object lpRect, Object uFormat, Object lpDTParams) {
		int ret;
		DWORD err = -1024;
		wchar_t wlpchText = ModernizedCProgram.utf8_to_wchar(lpchText);
		ret = /*Error: Function owner not recognized*/DrawTextExW(hDC, wlpchText, nCount, lpRect, uFormat, lpDTParams);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpchText != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpchText));
				wlpchText = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object SHGetPathFromIDListU(Object pidl, Byte pszPath) {
		BOOL ret = 0;
		DWORD err = -1024;
		// coverity[returned_null]
		wchar_t wpszPath = (pszPath == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(260, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/SHGetPathFromIDListW(pidl, wpszPath);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret) && (/*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wpszPath, -1, pszPath, 260, ((Object)0), ((Object)0)) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
			ret = 0;
		} 
		do {
			if (wpszPath != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wpszPath));
				wpszPath = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object CreateWindowU(Byte lpClassName, Byte lpWindowName, Object dwStyle, int x, int y, int nWidth, int nHeight, Object hWndParent, Object hMenu, Object hInstance, Object lpParam) {
		HWND ret = ((Object)0);
		DWORD err = -1024;
		wchar_t wlpClassName = ModernizedCProgram.utf8_to_wchar(lpClassName);
		wchar_t wlpWindowName = ModernizedCProgram.utf8_to_wchar(lpWindowName);
		ret = /*Error: Function owner not recognized*/CreateWindowExW(0, wlpClassName, wlpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpClassName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpClassName));
				wlpClassName = ((Object)0);
			} 
		} while (0);
		do {
			if (wlpWindowName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpWindowName));
				wlpWindowName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object CreateWindowExU(Object dwExStyle, Byte lpClassName, Byte lpWindowName, Object dwStyle, int x, int y, int nWidth, int nHeight, Object hWndParent, Object hMenu, Object hInstance, Object lpParam) {
		HWND ret = ((Object)0);
		DWORD err = -1024;
		wchar_t wlpClassName = ModernizedCProgram.utf8_to_wchar(lpClassName);
		wchar_t wlpWindowName = ModernizedCProgram.utf8_to_wchar(lpWindowName);
		ret = /*Error: Function owner not recognized*/CreateWindowExW(dwExStyle, wlpClassName, wlpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpClassName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpClassName));
				wlpClassName = ((Object)0);
			} 
		} while (0);
		do {
			if (wlpWindowName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpWindowName));
				wlpWindowName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static int MessageBoxU(Object hWnd, Object lpText, Object lpCaption, Object uType) {
		int ret;
		DWORD err = -1024;
		wchar_t wlpText = ModernizedCProgram.utf8_to_wchar(lpText);
		wchar_t wlpCaption = ModernizedCProgram.utf8_to_wchar(lpCaption);
		ret = /*Error: Function owner not recognized*/MessageBoxW(hWnd, wlpText, wlpCaption, uType);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpText != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpText));
				wlpText = ((Object)0);
			} 
		} while (0);
		do {
			if (wlpCaption != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpCaption));
				wlpCaption = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static int MessageBoxExU(Object hWnd, Object lpText, Object lpCaption, Object uType, Object wLanguageId) {
		int ret;
		DWORD err = -1024;
		wchar_t wlpText = ModernizedCProgram.utf8_to_wchar(lpText);
		wchar_t wlpCaption = ModernizedCProgram.utf8_to_wchar(lpCaption);
		ret = /*Error: Function owner not recognized*/MessageBoxExW(hWnd, wlpText, wlpCaption, uType, wLanguageId);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpText != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpText));
				wlpText = ((Object)0);
			} 
		} while (0);
		do {
			if (wlpCaption != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpCaption));
				wlpCaption = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static int LoadStringU(Object hInstance, Object uID, Object lpBuffer, int nBufferMax) {
		int ret;
		DWORD err = -1024;
		if (nBufferMax == 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(-1024);
			return 0;
		} 
		// read-only pointer to resource mode is not supported
		// coverity[returned_null]wchar_t wlpBuffer = (lpBuffer == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(nBufferMax, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/LoadStringW(hInstance, uID, wlpBuffer, nBufferMax);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret > 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpBuffer, -1, lpBuffer, nBufferMax, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wlpBuffer != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpBuffer));
				wlpBuffer = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object LoadLibraryU(Object lpFileName) {
		HMODULE ret = new HMODULE();
		DWORD err = -1024;
		wchar_t wlpFileName = ModernizedCProgram.utf8_to_wchar(lpFileName);
		ret = /*Error: Function owner not recognized*/LoadLibraryW(wlpFileName);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpFileName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpFileName));
				wlpFileName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static int DrawTextU(Object hDC, Object lpText, int nCount, Object lpRect, Object uFormat) {
		int ret;
		DWORD err = -1024;
		wchar_t wlpText = ModernizedCProgram.utf8_to_wchar(lpText);
		ret = /*Error: Function owner not recognized*/DrawTextW(hDC, wlpText, nCount, lpRect, uFormat);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpText != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpText));
				wlpText = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static int GetWindowTextU(Object hWnd, byte[] lpString, int nMaxCount) {
		int ret = 0;
		DWORD err = -1024;
		// Handle the empty string as GetWindowTextW() returns 0 then
		if ((lpString != ((Object)0)) && (nMaxCount > 0)) {
			lpString[0] = 0;
		} 
		wchar_t wlpString = (lpString == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(nMaxCount, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/GetWindowTextW(hWnd, wlpString, nMaxCount);
		err = /*Error: Function owner not recognized*/GetLastError()// coverity[var_deref_model];// coverity[var_deref_model]
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpString, -1, lpString, nMaxCount, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wlpString != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpString));
				wlpString = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object SetWindowTextU(Object hWnd, Object lpString) {
		BOOL ret = 0;
		DWORD err = -1024;
		wchar_t wlpString = ModernizedCProgram.utf8_to_wchar(lpString);
		ret = /*Error: Function owner not recognized*/SetWindowTextW(hWnd, wlpString);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpString != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpString));
				wlpString = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static int GetWindowTextLengthU(Object hWnd) {
		int ret = 0;
		DWORD err = -1024;
		wchar_t wbuf = ((Object)0);
		byte buf = ((Object)0);
		ret = /*Error: Function owner not recognized*/GetWindowTextLengthW(hWnd);
		err = /*Error: Function owner not recognized*/GetLastError();
		if (ret == 0) {
			;
		} 
		wbuf = /*Error: Function owner not recognized*/calloc(ret, /*Error: Unsupported expression*/);
		err = /*Error: Function owner not recognized*/GetLastError();
		if (wbuf == ((Object)0)) {
			err = -1024;
			ret = 0;
			;
		} 
		ret = /*Error: Function owner not recognized*/GetWindowTextW(hWnd, wbuf, ret);
		err = /*Error: Function owner not recognized*/GetLastError();
		if (ret == 0) {
			;
		} 
		buf = ModernizedCProgram.wchar_to_utf8(wbuf);
		err = /*Error: Function owner not recognized*/GetLastError();
		if (buf == ((Object)0)) {
			err = -1024;
			ret = 0;
			;
		} 
		// GetDlgItemText seems to add a character// GetDlgItemText seems to add a characterret = (int)/*Error: Function owner not recognized*/strlen(buf) + 2;
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (buf != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(buf));
				buf = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object GetDlgItemTextU(Object hDlg, int nIDDlgItem, Byte lpString, int nMaxCount) {
		UINT ret = 0;
		DWORD err = -1024;
		// coverity[returned_null]
		wchar_t wlpString = (lpString == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(nMaxCount, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/GetDlgItemTextW(hDlg, nIDDlgItem, wlpString, nMaxCount);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpString, -1, lpString, nMaxCount, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wlpString != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpString));
				wlpString = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object SetDlgItemTextU(Object hDlg, int nIDDlgItem, Object lpString) {
		BOOL ret = 0;
		DWORD err = -1024;
		wchar_t wlpString = ModernizedCProgram.utf8_to_wchar(lpString);
		ret = /*Error: Function owner not recognized*/SetDlgItemTextW(hDlg, nIDDlgItem, wlpString);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpString != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpString));
				wlpString = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object InsertMenuU(Object hMenu, Object uPosition, Object uFlags, Object uIDNewItem, Object lpNewItem) {
		BOOL ret = 0;
		DWORD err = -1024;
		wchar_t wlpNewItem = ModernizedCProgram.utf8_to_wchar(lpNewItem);
		ret = /*Error: Function owner not recognized*/InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, wlpNewItem);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpNewItem != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpNewItem));
				wlpNewItem = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static int ComboBox_GetLBTextU(Object hCtrl, int index, Byte lpString) {
		int size;
		DWORD err = -1024;
		wchar_t wlpString = new wchar_t();
		if (lpString == ((Object)0)) {
			return (true);
		} 
		size = (int)/*Error: Function owner not recognized*/SendMessageW(hCtrl, 329, (WPARAM)index, (LPARAM)0);
		if (size < 0) {
			return size;
		} 
		wlpString = (wchar_t)/*Error: Function owner not recognized*/calloc(size + 1, /*Error: Unsupported expression*/);
		size = (int)/*Error: Function owner not recognized*/SendMessageW(hCtrl, 328, (WPARAM)index, (LPARAM)wlpString);
		err = /*Error: Function owner not recognized*/GetLastError();
		if (size > 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpString, -1, lpString, size + 1, ((Object)0), ((Object)0));
		} 
		do {
			if (wlpString != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpString));
				wlpString = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return size;
	}
	public static Object CharUpperBuffU(Byte lpString, Object len) {
		DWORD ret = new DWORD();
		wchar_t wlpString = /*Error: Function owner not recognized*/calloc(len, /*Error: Unsupported expression*/);
		if (wlpString == ((Object)0)) {
			return 0;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MultiByteToWideChar(65001, 0, lpString, -1, wlpString, len);
		ret = /*Error: Function owner not recognized*/CharUpperBuffW(wlpString, len);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpString, -1, lpString, len, ((Object)0), ((Object)0));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(wlpString);
		return ret;
	}
	public static Object CreateFileU(Object lpFileName, Object dwDesiredAccess, Object dwShareMode, Object lpSecurityAttributes, Object dwCreationDisposition, Object dwFlagsAndAttributes, Object hTemplateFile) {
		HANDLE ret = (HANDLE)(true);
		DWORD err = -1024;
		wchar_t wlpFileName = ModernizedCProgram.utf8_to_wchar(lpFileName);
		ret = /*Error: Function owner not recognized*/CreateFileW(wlpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpFileName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpFileName));
				wlpFileName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object CreateDirectoryU(Object lpPathName, Object lpSecurityAttributes) {
		BOOL ret = 0;
		DWORD err = -1024;
		wchar_t wlpPathName = ModernizedCProgram.utf8_to_wchar(lpPathName);
		ret = /*Error: Function owner not recognized*/CreateDirectoryW(wlpPathName, lpSecurityAttributes);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpPathName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpPathName));
				wlpPathName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object CopyFileU(Object lpExistingFileName, Object lpNewFileName, Object bFailIfExists) {
		BOOL ret = 0;
		DWORD err = -1024;
		wchar_t wlpExistingFileName = ModernizedCProgram.utf8_to_wchar(lpExistingFileName);
		wchar_t wlpNewFileName = ModernizedCProgram.utf8_to_wchar(lpNewFileName);
		ret = /*Error: Function owner not recognized*/CopyFileW(wlpExistingFileName, wlpNewFileName, bFailIfExists);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpExistingFileName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpExistingFileName));
				wlpExistingFileName = ((Object)0);
			} 
		} while (0);
		do {
			if (wlpNewFileName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpNewFileName));
				wlpNewFileName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object DeleteFileU(Object lpFileName) {
		BOOL ret = 0;
		DWORD err = -1024;
		wchar_t wlpFileName = ModernizedCProgram.utf8_to_wchar(lpFileName);
		ret = /*Error: Function owner not recognized*/DeleteFileW(wlpFileName);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpFileName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpFileName));
				wlpFileName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object PathFileExistsU(Byte szPath) {
		BOOL ret = new BOOL();
		wchar_t wszPath = ModernizedCProgram.utf8_to_wchar(szPath);
		ret = /*Error: Function owner not recognized*/PathFileExistsW(wszPath);
		do {
			if (wszPath != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wszPath));
				wszPath = ((Object)0);
			} 
		} while (0);
		return ret;
	}
	public static int PathGetDriveNumberU(Byte lpPath) {
		int ret = 0;
		DWORD err = -1024;
		wchar_t wlpPath = ModernizedCProgram.utf8_to_wchar(lpPath);
		ret = /*Error: Function owner not recognized*/PathGetDriveNumberW(wlpPath);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpPath != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpPath));
				wlpPath = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	// This one is tricky since we can't blindly convert a
	// UTF-16 position to a UTF-8 one. So we do it manually.
	public static Object PathFindFileNameU(Object[] szPath) {
		size_t i = new size_t();
		if (szPath == ((Object)0)) {
			return ((Object)0);
		} 
		for (i = /*Error: Function owner not recognized*/strlen(szPath); i != 0; i--) {
			if ((szPath[i] == (byte)'/') || (szPath[i] == (byte)'\\')) {
				i++;
				break;
			} 
		}
		return szPath[i];
	}
	// This function differs from regular GetTextExtentPoint in that it uses a zero terminated string
	public static Object GetTextExtentPointU(Object hdc, Object lpString, Object lpSize) {
		BOOL ret = 0;
		DWORD err = -1024;
		wchar_t wlpString = ModernizedCProgram.utf8_to_wchar(lpString);
		if (wlpString == ((Object)0)) {
			return 0;
		} 
		ret = /*Error: Function owner not recognized*/GetTextExtentPoint32W(hdc, wlpString, (int)/*Error: Function owner not recognized*/wcslen(wlpString), lpSize);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpString != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpString));
				wlpString = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object GetCurrentDirectoryU(Object nBufferLength, Byte lpBuffer) {
		DWORD ret = 0;
		DWORD err = -1024;
		// coverity[returned_null]
		wchar_t wlpBuffer = (lpBuffer == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(nBufferLength, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/GetCurrentDirectoryW(nBufferLength, wlpBuffer);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpBuffer, -1, lpBuffer, nBufferLength, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wlpBuffer != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpBuffer));
				wlpBuffer = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object GetSystemDirectoryU(Byte lpBuffer, Object uSize) {
		UINT ret = 0;
		UINT err = -1024;
		// coverity[returned_null]
		wchar_t wlpBuffer = (lpBuffer == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(uSize, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/GetSystemDirectoryW(wlpBuffer, uSize);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpBuffer, -1, lpBuffer, uSize, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wlpBuffer != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpBuffer));
				wlpBuffer = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object GetSystemWindowsDirectoryU(Byte lpBuffer, Object uSize) {
		UINT ret = 0;
		UINT err = -1024;
		// coverity[returned_null]
		wchar_t wlpBuffer = (lpBuffer == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(uSize, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/GetSystemWindowsDirectoryW(wlpBuffer, uSize);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpBuffer, -1, lpBuffer, uSize, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wlpBuffer != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpBuffer));
				wlpBuffer = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object GetTempPathU(Object nBufferLength, Byte lpBuffer) {
		DWORD ret = 0;
		DWORD err = -1024;
		// coverity[returned_null]
		wchar_t wlpBuffer = (lpBuffer == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(nBufferLength, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/GetTempPathW(nBufferLength, wlpBuffer);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpBuffer, -1, lpBuffer, nBufferLength, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wlpBuffer != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpBuffer));
				wlpBuffer = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object GetTempFileNameU(Byte lpPathName, Byte lpPrefixString, Object uUnique, Byte lpTempFileName) {
		DWORD ret = 0;
		DWORD err = -1024;
		wchar_t wlpPathName = ModernizedCProgram.utf8_to_wchar(lpPathName);
		wchar_t wlpPrefixString = ModernizedCProgram.utf8_to_wchar(lpPrefixString);
		// coverity[returned_null]
		wchar_t wlpTempFileName = (lpTempFileName == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(260, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/GetTempFileNameW(wlpPathName, wlpPrefixString, uUnique, wlpTempFileName);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpTempFileName, -1, lpTempFileName, 260, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wlpTempFileName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpTempFileName));
				wlpTempFileName = ((Object)0);
			} 
		} while (0);
		do {
			if (wlpPrefixString != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpPrefixString));
				wlpPrefixString = ((Object)0);
			} 
		} while (0);
		do {
			if (wlpPathName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpPathName));
				wlpPathName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object GetModuleFileNameU(Object hModule, Byte lpFilename, Object nSize) {
		DWORD ret = 0;
		DWORD err = -1024;
		// coverity[returned_null]
		wchar_t wlpFilename = (lpFilename == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(nSize, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/GetModuleFileNameW(hModule, wlpFilename, nSize);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpFilename, -1, lpFilename, nSize, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wlpFilename != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpFilename));
				wlpFilename = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object GetModuleFileNameExU(Object hProcess, Object hModule, Byte lpFilename, Object nSize) {
		DWORD ret = 0;
		DWORD err = -1024;
		// coverity[returned_null]
		wchar_t wlpFilename = (lpFilename == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(nSize, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/GetModuleFileNameExW(hProcess, hModule, wlpFilename, nSize);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpFilename, -1, lpFilename, nSize, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wlpFilename != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpFilename));
				wlpFilename = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object GetFullPathNameU(Object lpFileName, Object nBufferLength, Byte lpBuffer, Byte lpFilePart) {
		DWORD ret = 0;
		DWORD err = -1024;
		wchar_t wlpFilePart = new wchar_t();
		wchar_t wlpFileName = ModernizedCProgram.utf8_to_wchar(lpFileName);
		// coverity[returned_null]
		wchar_t wlpBuffer = (lpBuffer == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(nBufferLength, /*Error: Unsupported expression*/);
		// lpFilePart is not supportedif (lpFilePart != ((Object)0)) {
			;
		} 
		ret = /*Error: Function owner not recognized*/GetFullPathNameW(wlpFileName, nBufferLength, wlpBuffer, wlpFilePart);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpBuffer, -1, lpBuffer, nBufferLength, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wlpFileName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpFileName));
				wlpFileName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object GetFileAttributesU(Object lpFileName) {
		DWORD ret = -1024;
		DWORD err = -1024;
		wchar_t wlpFileName = ModernizedCProgram.utf8_to_wchar(lpFileName);
		// Unlike Microsoft's version, ours doesn't fail if the string is quoted
		if ((wlpFileName[0] == (byte)L'"') && (wlpFileName[/*Error: Function owner not recognized*/wcslen(wlpFileName) - 1] == (byte)L'"')) {
			wlpFileName[/*Error: Function owner not recognized*/wcslen(wlpFileName) - 1] = 0;
			ret = /*Error: Function owner not recognized*/GetFileAttributesW(wlpFileName[1]);
		} else {
				ret = /*Error: Function owner not recognized*/GetFileAttributesW(wlpFileName);
		} 
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpFileName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpFileName));
				wlpFileName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object SetFileAttributesU(Object lpFileName, Object dwFileAttributes) {
		BOOL ret = 0;
		BOOL err = -1024;
		wchar_t wlpFileName = ModernizedCProgram.utf8_to_wchar(lpFileName);
		// Unlike Microsoft's version, ours doesn't fail if the string is quoted
		if ((wlpFileName[0] == (byte)L'"') && (wlpFileName[/*Error: Function owner not recognized*/wcslen(wlpFileName) - 1] == (byte)L'"')) {
			wlpFileName[/*Error: Function owner not recognized*/wcslen(wlpFileName) - 1] = 0;
			ret = /*Error: Function owner not recognized*/SetFileAttributesW(wlpFileName[1], dwFileAttributes);
		} else {
				ret = /*Error: Function owner not recognized*/SetFileAttributesW(wlpFileName, dwFileAttributes);
		} 
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wlpFileName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpFileName));
				wlpFileName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static int SHCreateDirectoryExU(Object hwnd, Object pszPath) {
		int ret = -1024;
		DWORD err = -1024;
		wchar_t wpszPath = ModernizedCProgram.utf8_to_wchar(pszPath);
		ret = /*Error: Function owner not recognized*/SHCreateDirectoryExW(hwnd, wpszPath, psa);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wpszPath != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wpszPath));
				wpszPath = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static int SHDeleteDirectoryExU(Object hwnd, Object pszPath, Object fFlags) {
		int ret;
		// String needs to be double NULL terminated, so we just use the length of the UTF-8 string
		// which is always expected to be larger than our UTF-16 one, and add 2 chars for good measure.size_t wpszPath_len = /*Error: Function owner not recognized*/strlen(pszPath) + 2;
		// coverity[returned_null]
		wchar_t wpszPath = (pszPath == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(wpszPath_len, /*Error: Unsupported expression*/);
		SHFILEOPSTRUCTW shfo = new SHFILEOPSTRUCTW(hwnd, 3, wpszPath, ((Object)0), fFlags, 0, ((Object)0), ((Object)0));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MultiByteToWideChar(65001, 0, pszPath, -1, wpszPath, (int)wpszPath_len)// FOF_SILENT | FOF_NOERRORUI | FOF_NOCONFIRMATION,;// FOF_SILENT | FOF_NOERRORUI | FOF_NOCONFIRMATION,
		ret = /*Error: Function owner not recognized*/SHFileOperationW(shfo);
		do {
			if (wpszPath != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wpszPath));
				wpszPath = ((Object)0);
			} 
		} while (0);
		return ret;
	}
	public static Object ShellExecuteExU() {
		BOOL ret = 0;
		DWORD err = -1024;
		SHELLEXECUTEINFOW wExecInfo = new SHELLEXECUTEINFOW();
		Object generatedCbSize = this.getCbSize();
		// Because we're lazy, we'll assume that the A and W structs inherently have the same sizeif (generatedCbSize != /*Error: Unsupported expression*/) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(-1024);
			return 0;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(wExecInfo, lpExecInfo, generatedCbSize);
		Object generatedLpVerb = this.getLpVerb();
		wExecInfo.setLpVerb(ModernizedCProgram.utf8_to_wchar(generatedLpVerb));
		Object generatedLpFile = this.getLpFile();
		wExecInfo.setLpFile(ModernizedCProgram.utf8_to_wchar(generatedLpFile));
		Object generatedLpParameters = this.getLpParameters();
		wExecInfo.setLpParameters(ModernizedCProgram.utf8_to_wchar(generatedLpParameters));
		Object generatedLpDirectory = this.getLpDirectory();
		wExecInfo.setLpDirectory(ModernizedCProgram.utf8_to_wchar(generatedLpDirectory));
		Object generatedFMask = wExecInfo.getFMask();
		Object generatedLpClass = this.getLpClass();
		if (generatedFMask & -1024) {
			wExecInfo.setLpClass(ModernizedCProgram.utf8_to_wchar(generatedLpClass));
		} else {
				wExecInfo.setLpClass(((Object)0));
		} 
		ret = /*Error: Function owner not recognized*/ShellExecuteExW(wExecInfo);
		err = /*Error: Function owner not recognized*/GetLastError()// Copy the returned values back;// Copy the returned values back
		Object generatedHInstApp = wExecInfo.getHInstApp();
		this.setHInstApp(generatedHInstApp);
		Object generatedHProcess = wExecInfo.getHProcess();
		this.setHProcess(generatedHProcess);
		do {
			if (generatedLpVerb != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpVerb));
				wExecInfo.setLpVerb(((Object)0));
			} 
		} while (0);
		do {
			if (generatedLpFile != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpFile));
				wExecInfo.setLpFile(((Object)0));
			} 
		} while (0);
		do {
			if (generatedLpParameters != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpParameters));
				wExecInfo.setLpParameters(((Object)0));
			} 
		} while (0);
		do {
			if (generatedLpDirectory != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpDirectory));
				wExecInfo.setLpDirectory(((Object)0));
			} 
		} while (0);
		do {
			if (generatedLpClass != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpClass));
				wExecInfo.setLpClass(((Object)0));
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	// Doesn't support LPSTARTUPINFOEX struct
	public static Object CreateProcessU(Object lpApplicationName, Object lpCommandLine, Object lpProcessAttributes, Object lpThreadAttributes, Object bInheritHandles, Object dwCreationFlags, Object lpEnvironment, Object lpCurrentDirectory, Object lpStartupInfo, Object lpProcessInformation) {
		BOOL ret = 0;
		DWORD err = -1024;
		STARTUPINFOW wStartupInfo = new STARTUPINFOW();
		wchar_t wlpApplicationName = ModernizedCProgram.utf8_to_wchar(lpApplicationName);
		wchar_t wlpCommandLine = ModernizedCProgram.utf8_to_wchar(lpCommandLine);
		wchar_t wlpCurrentDirectory = ModernizedCProgram.utf8_to_wchar(lpCurrentDirectory);
		// Because we're lazy, we'll assume that the A and W structs inherently have the same size
		// Also prevents the use of STARTUPINFOEXif (lpStartupInfo.getCb() != /*Error: Unsupported expression*/) {
			err = -1024;
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(wStartupInfo, lpStartupInfo, lpStartupInfo.getCb());
		wStartupInfo.setLpDesktop(ModernizedCProgram.utf8_to_wchar(lpStartupInfo.getLpDesktop()));
		wStartupInfo.setLpTitle(ModernizedCProgram.utf8_to_wchar(lpStartupInfo.getLpTitle()));
		ret = /*Error: Function owner not recognized*/CreateProcessW(wlpApplicationName, wlpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, wlpCurrentDirectory, wStartupInfo, lpProcessInformation);
		err = /*Error: Function owner not recognized*/GetLastError();
		Object generatedLpDesktop = wStartupInfo.getLpDesktop();
		do {
			if (generatedLpDesktop != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpDesktop));
				wStartupInfo.setLpDesktop(((Object)0));
			} 
		} while (0);
		Object generatedLpTitle = wStartupInfo.getLpTitle();
		do {
			if (generatedLpTitle != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpTitle));
				wStartupInfo.setLpTitle(((Object)0));
			} 
		} while (0);
		do {
			if (wlpCommandLine != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpCommandLine));
				wlpCommandLine = ((Object)0);
			} 
		} while (0);
		do {
			if (wlpCurrentDirectory != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpCurrentDirectory));
				wlpCurrentDirectory = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	// NOTE: when used, nFileOffset & nFileExtension MUST be provided
	// in number of Unicode characters, NOT number of UTF-8 bytes
	public static Object GetOpenSaveFileNameU(Object lpofn, Object save) {
		BOOL ret = 0;
		DWORD err = -1024;
		size_t i = new size_t();
		size_t len = new size_t();
		OPENFILENAMEW wofn = new OPENFILENAMEW();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(wofn, 0, /*Error: sizeof expression not supported yet*/);
		wofn.setLStructSize(/*Error: sizeof expression not supported yet*/);
		wofn.setHwndOwner(lpofn.getHwndOwner());
		wofn.setHInstance(lpofn.getHInstance());
		// No support for custom filtersif (lpofn.getLpstrCustomFilter() != ((Object)0)) {
			;
		} 
		// Count on Microsoft to use an moronic scheme for filters
		Object generatedLpstrFilter = wofn.getLpstrFilter();
		// that relies on NULL separators and double NULL terminatorsif (lpofn.getLpstrFilter() != ((Object)0)) {
			for (i = 0; /*Error: Unsupported expression*/; i++) {
				if (lpofn.getLpstrFilter()[i] == 0) {
					((byte)lpofn.getLpstrFilter())[i] = (byte)'\r';
					if (lpofn.getLpstrFilter()[i + 1] == 0) {
						break;
					} 
				} 
			}
			wofn.setLpstrFilter(ModernizedCProgram.utf8_to_wchar(lpofn.getLpstrFilter()));
			len = /*Error: Function owner not recognized*/wcslen(generatedLpstrFilter);
			for (i = 0; i < len; i++) {
				if (generatedLpstrFilter[i] == (byte)'\r') {
					((wchar_t)generatedLpstrFilter)[i] = 0;
				} 
			}
			len = /*Error: Function owner not recognized*/strlen(generatedLpstrFilter);
			for (i = 0; i < len; i++) {
				if (generatedLpstrFilter[i] == (byte)'\r') {
					((byte)generatedLpstrFilter)[i] = 0;
				} 
			}
		} else {
				wofn.setLpstrFilter(((Object)0));
		} 
		// Replace the NULLs by something that can be converted
		wofn.setNMaxCustFilter(lpofn.getNMaxCustFilter());
		wofn.setNFilterIndex(lpofn.getNFilterIndex());
		wofn.setLpstrFile(/*Error: Function owner not recognized*/calloc(lpofn.getNMaxFile(), /*Error: Unsupported expression*/));
		Object generatedLpstrFile = wofn.getLpstrFile();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MultiByteToWideChar(65001, 0, lpofn.getLpstrFile(), -1, generatedLpstrFile, lpofn.getNMaxFile());
		wofn.setNMaxFile(lpofn.getNMaxFile());
		wofn.setLpstrFileTitle(/*Error: Function owner not recognized*/calloc(lpofn.getNMaxFileTitle(), /*Error: Unsupported expression*/));
		Object generatedLpstrFileTitle = wofn.getLpstrFileTitle();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MultiByteToWideChar(65001, 0, lpofn.getLpstrFileTitle(), -1, generatedLpstrFileTitle, lpofn.getNMaxFileTitle());
		wofn.setNMaxFileTitle(lpofn.getNMaxFileTitle());
		wofn.setLpstrInitialDir(ModernizedCProgram.utf8_to_wchar(lpofn.getLpstrInitialDir()));
		wofn.setLpstrTitle(ModernizedCProgram.utf8_to_wchar(lpofn.getLpstrTitle()));
		wofn.setFlags(lpofn.getFlags());
		wofn.setNFileOffset(lpofn.getNFileOffset());
		wofn.setNFileExtension(lpofn.getNFileExtension());
		wofn.setLpstrDefExt(ModernizedCProgram.utf8_to_wchar(lpofn.getLpstrDefExt()));
		wofn.setLCustData(lpofn.getLCustData());
		wofn.setLpfnHook(lpofn.getLpfnHook());
		wofn.setLpTemplateName(ModernizedCProgram.utf8_to_wchar(lpofn.getLpTemplateName()));
		wofn.setPvReserved(lpofn.getPvReserved());
		wofn.setDwReserved(lpofn.getDwReserved());
		wofn.setFlagsEx(lpofn.getFlagsEx());
		if (save) {
			ret = /*Error: Function owner not recognized*/GetSaveFileNameW(wofn);
		} else {
				ret = /*Error: Function owner not recognized*/GetOpenFileNameW(wofn);
		} 
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret) && ((/*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, generatedLpstrFile, -1, generatedLpstrFile, lpofn.getNMaxFile(), ((Object)0), ((Object)0)) == 0) || (/*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, generatedLpstrFileTitle, -1, generatedLpstrFileTitle, lpofn.getNMaxFileTitle(), ((Object)0), ((Object)0)) == 0))) {
			err = /*Error: Function owner not recognized*/GetLastError();
			ret = 0;
		} 
		do {
			if (generatedLpstrFile != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpstrFile));
				wofn.setLpstrFile(((Object)0));
			} 
		} while (0);
		do {
			if (generatedLpstrFileTitle != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpstrFileTitle));
				wofn.setLpstrFileTitle(((Object)0));
			} 
		} while (0);
		do {
			if (generatedLpstrFilter != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpstrFilter));
				wofn.setLpstrFilter(((Object)0));
			} 
		} while (0);
		Object generatedLpstrInitialDir = wofn.getLpstrInitialDir();
		do {
			if (generatedLpstrInitialDir != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpstrInitialDir));
				wofn.setLpstrInitialDir(((Object)0));
			} 
		} while (0);
		Object generatedLpstrTitle = wofn.getLpstrTitle();
		do {
			if (generatedLpstrTitle != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpstrTitle));
				wofn.setLpstrTitle(((Object)0));
			} 
		} while (0);
		Object generatedLpTemplateName = wofn.getLpTemplateName();
		do {
			if (generatedLpTemplateName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(generatedLpTemplateName));
				wofn.setLpTemplateName(((Object)0));
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object UpdateDriverForPlugAndPlayDevicesU(Object hwndParent, Object HardwareId, Object FullInfPath, Object InstallFlags, Object bRebootRequired) {
		BOOL ret = 0;
		DWORD err = -1024;
		wchar_t wHardwareId = ModernizedCProgram.utf8_to_wchar(HardwareId);
		wchar_t wFullInfPath = ModernizedCProgram.utf8_to_wchar(FullInfPath);
		ret = /*Error: Function owner not recognized*/UpdateDriverForPlugAndPlayDevicesW(hwndParent, wHardwareId, wFullInfPath, InstallFlags, bRebootRequired);
		err = /*Error: Function owner not recognized*/GetLastError();
		do {
			if (wHardwareId != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wHardwareId));
				wHardwareId = ((Object)0);
			} 
		} while (0);
		do {
			if (wFullInfPath != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wFullInfPath));
				wFullInfPath = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object SetupCopyOEMInfU(Object SourceInfFileName, Object OEMSourceMediaLocation, Object OEMSourceMediaType, Object CopyStyle, Byte DestinationInfFileName, Object DestinationInfFileNameSize, Object RequiredSize, Object DestinationInfFileNameComponent) {
		BOOL ret = 0;
		DWORD err = -1024;
		wchar_t wSourceInfFileName = ModernizedCProgram.utf8_to_wchar(SourceInfFileName);
		wchar_t wOEMSourceMediaLocation = ModernizedCProgram.utf8_to_wchar(OEMSourceMediaLocation);
		// coverity[returned_null]
		wchar_t wDestinationInfFileName = (DestinationInfFileName == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(DestinationInfFileNameSize, /*Error: Unsupported expression*/);
		// DestinationInfFileNameComponent is not supportedif (DestinationInfFileNameComponent != ((Object)0)) {
			;
		} 
		ret = /*Error: Function owner not recognized*/SetupCopyOEMInfW(wSourceInfFileName, wOEMSourceMediaLocation, OEMSourceMediaType, CopyStyle, wDestinationInfFileName, DestinationInfFileNameSize, RequiredSize, ((Object)0));
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && ((ret = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wDestinationInfFileName, -1, DestinationInfFileName, DestinationInfFileNameSize, ((Object)0), ((Object)0))) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
		} 
		do {
			if (wOEMSourceMediaLocation != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wOEMSourceMediaLocation));
				wOEMSourceMediaLocation = ((Object)0);
			} 
		} while (0);
		do {
			if (wDestinationInfFileName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wDestinationInfFileName));
				wDestinationInfFileName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static int _chdirU(Object dirname) {
		int ret;
		wchar_t wdirname = ModernizedCProgram.utf8_to_wchar(dirname);
		ret = /*Error: Function owner not recognized*/_wchdir(wdirname);
		do {
			if (wdirname != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wdirname));
				wdirname = ((Object)0);
			} 
		} while (0);
		return ret;
	}
	public static _iobuf fopenU(Object filename, Object mode) {
		FILE ret = ((Object)0);
		wchar_t wfilename = ModernizedCProgram.utf8_to_wchar(filename);
		wchar_t wmode = ModernizedCProgram.utf8_to_wchar(mode);
		ret = /*Error: Function owner not recognized*/_wfopen(wfilename, wmode);
		do {
			if (wfilename != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wfilename));
				wfilename = ((Object)0);
			} 
		} while (0);
		do {
			if (wmode != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wmode));
				wmode = ((Object)0);
			} 
		} while (0);
		return ret;
	}
	public static int _openU(Object filename, int oflag, int pmode) {
		int ret = -1;
		wchar_t wfilename = ModernizedCProgram.utf8_to_wchar(filename);
		ret = /*Error: Function owner not recognized*/_wopen(wfilename, oflag, pmode);
		do {
			if (wfilename != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wfilename));
				wfilename = ((Object)0);
			} 
		} while (0);
		return ret;
	}
	// Try to match the share flag to the oflag
	public static int _stat64U(Object path, Object buffer) {
		int ret;
		wchar_t wpath = ModernizedCProgram.utf8_to_wchar(path);
		ret = /*Error: Function owner not recognized*/_wstat64(wpath, buffer);
		do {
			if (wpath != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wpath));
				wpath = ((Object)0);
			} 
		} while (0);
		return ret;
	}
	// returned UTF-8 string must be freed
	public static Byte getenvU(Object varname) {
		wchar_t wvarname = ModernizedCProgram.utf8_to_wchar(varname);
		byte ret = ((Object)0);
		wchar_t wbuf = ((Object)0);
		// _wgetenv() is *BROKEN* in MS compilers => use GetEnvironmentVariableW()
		DWORD dwSize = /*Error: Function owner not recognized*/GetEnvironmentVariableW(wvarname, wbuf, 0);
		wbuf = /*Error: Function owner not recognized*/calloc(dwSize, /*Error: Unsupported expression*/);
		if (wbuf == ((Object)0)) {
			do {
				if (wvarname != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wvarname));
					wvarname = ((Object)0);
				} 
			} while (0);
			return ((Object)0);
		} 
		dwSize = /*Error: Function owner not recognized*/GetEnvironmentVariableW(wvarname, wbuf, dwSize);
		if (dwSize != 0) {
			ret = ModernizedCProgram.wchar_to_utf8(wbuf);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(wbuf);
		do {
			if (wvarname != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wvarname));
				wvarname = ((Object)0);
			} 
		} while (0);
		return ret;
	}
	public static int _mkdirU(Object dirname) {
		wchar_t wdirname = ModernizedCProgram.utf8_to_wchar(dirname);
		int ret;
		ret = /*Error: Function owner not recognized*/_wmkdir(wdirname);
		do {
			if (wdirname != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wdirname));
				wdirname = ((Object)0);
			} 
		} while (0);
		return ret;
	}
	// The following expects PropertyBuffer to contain a single Unicode string
	public static Object SetupDiGetDeviceRegistryPropertyU(Object DeviceInfoSet, Object DeviceInfoData, Object Property, Object PropertyRegDataType, Object PropertyBuffer, Object PropertyBufferSize, Object RequiredSize) {
		BOOL ret = 0;
		DWORD err = -1024;
		// coverity[returned_null]
		wchar_t wPropertyBuffer = (PropertyBuffer == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(PropertyBufferSize, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet, DeviceInfoData, Property, PropertyRegDataType, (PBYTE)wPropertyBuffer, PropertyBufferSize, RequiredSize);
		err = /*Error: Function owner not recognized*/GetLastError();
		if ((ret != 0) && (/*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wPropertyBuffer, -1, (byte)()PropertyBuffer, PropertyBufferSize, ((Object)0), ((Object)0)) == 0)) {
			err = /*Error: Function owner not recognized*/GetLastError();
			ret = 0;
		} 
		do {
			if (wPropertyBuffer != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wPropertyBuffer));
				wPropertyBuffer = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	public static Object GetVolumeInformationU(Object lpRootPathName, Object lpVolumeNameBuffer, Object nVolumeNameSize, Object lpVolumeSerialNumber, Object lpMaximumComponentLength, Object lpFileSystemFlags, Object lpFileSystemNameBuffer, Object nFileSystemNameSize) {
		BOOL ret = 0;
		DWORD err = -1024;
		wchar_t wlpRootPathName = ModernizedCProgram.utf8_to_wchar(lpRootPathName);
		// coverity[returned_null]
		wchar_t wlpVolumeNameBuffer = (lpVolumeNameBuffer == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(nVolumeNameSize, /*Error: Unsupported expression*/);
		// coverity[returned_null]
		wchar_t wlpFileSystemNameBuffer = (lpFileSystemNameBuffer == ((Object)0)) ? ((Object)0) : (wchar_t)/*Error: Function owner not recognized*/calloc(nFileSystemNameSize, /*Error: Unsupported expression*/);
		ret = /*Error: Function owner not recognized*/GetVolumeInformationW(wlpRootPathName, wlpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, wlpFileSystemNameBuffer, nFileSystemNameSize);
		err = /*Error: Function owner not recognized*/GetLastError();
		if (ret) {
			if (((lpVolumeNameBuffer != ((Object)0)) && (/*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpVolumeNameBuffer, -1, lpVolumeNameBuffer, nVolumeNameSize, ((Object)0), ((Object)0)) == 0)) || ((lpFileSystemNameBuffer != ((Object)0)) && (/*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wlpFileSystemNameBuffer, -1, lpFileSystemNameBuffer, nFileSystemNameSize, ((Object)0), ((Object)0)) == 0))) {
				err = /*Error: Function owner not recognized*/GetLastError();
				ret = 0;
			} 
		} 
		do {
			if (wlpVolumeNameBuffer != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpVolumeNameBuffer));
				wlpVolumeNameBuffer = ((Object)0);
			} 
		} while (0);
		do {
			if (wlpFileSystemNameBuffer != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpFileSystemNameBuffer));
				wlpFileSystemNameBuffer = ((Object)0);
			} 
		} while (0);
		do {
			if (wlpRootPathName != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wlpRootPathName));
				wlpRootPathName = ((Object)0);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(err);
		return ret;
	}
	/*
	 * ind_block.c --- indirect block I/O routines
	 *
	 * Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
	 * 	2001, 2002, 2003, 2004, 2005 by  Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static Object ext2fs_read_ind_block(Object fs, Object blk, Object buf) {
		 retval = new ();
		if ((fs.getFlags() & -1024) && (fs.getIo() != fs.getImage_io())) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buf, 0, fs.getBlocksize());
		} else {
				retval = /*Error: Function owner not recognized*/io_channel_read_blk(fs.getIo(), blk, 1, buf);
				if (retval) {
					return retval;
				} 
		} 
		return 0;
	}
	public static Object ext2fs_write_ind_block(Object fs, Object blk, Object buf) {
		if (fs.getFlags() & -1024) {
			return 0;
		} 
		return /*Error: Function owner not recognized*/io_channel_write_blk(fs.getIo(), blk, 1, buf);
	}
	/*
	 * Form a pointer based on a 16-bit patcharea/epa field
	 */
	public static Object ptr(Object img, Object offset_p) {
		return (byte)img + ModernizedCProgram.get_16_sl(offset_p);
	}
	public static Object slptr(Object img, Object offset_p) {
		return (byte)img + ModernizedCProgram.get_16_sl(offset_p/*
		 * This patches the boot sector and the beginning of ldlinux.sys
		 * based on an ldlinux.sys sector map passed in.  Typically this is
		 * handled by writing ldlinux.sys, mapping it, and then overwrite it
		 * with the patched version.  If this isn't safe to do because of
		 * an OS which does block reallocation, then overwrite it with
		 * direct access since the location is known.
		 *
		 * Returns the number of modified bytes in ldlinux.sys if successful,
		 * otherwise -1.
		 */);
	}
	public static int syslinux_patch(Object[] sectp, int nsectors, int stupid, int raid_mode, Object subdir, Object subvol) {
		patch_area patcharea = new patch_area();
		ext_patch_area epa = new ext_patch_area();
		syslinux_extent ex = new syslinux_extent();
		uint32_t wp = new uint32_t();
		int nsect = ((ModernizedCProgram.syslinux_ldlinux_len[0] + ModernizedCProgram.SECTOR_SIZE - 1) >> ModernizedCProgram.SECTOR_SHIFT) + 2;
		uint32_t csum = new uint32_t();
		int i;
		int dw;
		int nptrs;
		fat_boot_sector sbs = (fat_boot_sector)ModernizedCProgram.syslinux_ldlinux[1];
		uint64_t advptrs = new uint64_t();
		if (nsectors < nsect) {
			return -/* The actual file is too small for content */1;
		} 
		dw = (ModernizedCProgram.syslinux_ldlinux_len[0] - /*Error: Unsupported expression*/) >> /* Search for LDLINUX_MAGIC to find the patch area */2;
		for (; (i <= dw) && ((ModernizedCProgram.get_32_sl(wp) != -1024)); ) {
			;
		}
		if (i > /* Not found */dw) {
			return -1;
		} 
		patcharea = (patch_area)wp;
		Object generatedEpaoffset = patcharea.getEpaoffset();
		epa = ModernizedCProgram.slptr(ModernizedCProgram.syslinux_ldlinux[0], generatedEpaoffset);
		Object generatedSect1ptr0 = epa.getSect1ptr0();
		ModernizedCProgram.set_32(ModernizedCProgram.ptr(sbs, generatedSect1ptr0), sectp[/* First sector need pointer in boot sector */0]);
		Object generatedSect1ptr1 = epa.getSect1ptr1();
		ModernizedCProgram.set_32(ModernizedCProgram.ptr(sbs, generatedSect1ptr1), sectp[0] >> 32);
		sectp++;
		Object generatedRaidpatch = epa.getRaidpatch();
		if (/* Handle RAID mode */raid_mode) {
			ModernizedCProgram.set_16(ModernizedCProgram.ptr(sbs, generatedRaidpatch), /* Patch in INT 18h = CD 18 */-1024);
		} 
		dw = ModernizedCProgram.syslinux_ldlinux_len[0] >> /* Set up the totals *//* COMPLETE dwords, excluding ADV */2;
		Object generatedData_sectors = patcharea.getData_sectors();
		ModernizedCProgram.set_16_sl(generatedData_sectors, nsect - /* Not including ADVs */2);
		Object generatedAdv_sectors = patcharea.getAdv_sectors();
		ModernizedCProgram.set_16_sl(generatedAdv_sectors, /* ADVs need 2 sectors */2);
		Object generatedDwords = patcharea.getDwords();
		ModernizedCProgram.set_32_sl(generatedDwords, dw);
		Object generatedMaxtransfer = patcharea.getMaxtransfer();
		if (/* Handle Stupid mode */stupid) {
			ModernizedCProgram.set_16_sl(generatedMaxtransfer, /* Access only one sector at a time */1);
		} 
		Object generatedSecptroffset = epa.getSecptroffset();
		ex = ModernizedCProgram.slptr(ModernizedCProgram.syslinux_ldlinux[0], generatedSecptroffset);
		Object generatedSecptrcnt = epa.getSecptrcnt();
		nptrs = ModernizedCProgram.get_16_sl(generatedSecptrcnt);
		ex.generate_extents(nptrs, sectp, nsect - 1 - /* -1 for the pointer in the boot sector, -2 for the two ADVs */2);
		Object generatedAdvptroffset = epa.getAdvptroffset();
		advptrs = ModernizedCProgram.slptr(ModernizedCProgram.syslinux_ldlinux[0], generatedAdvptroffset);
		ModernizedCProgram.set_64_sl(advptrs[0], sectp[nsect - 1 - 2]);
		ModernizedCProgram.set_64_sl(advptrs[1], sectp[nsect - 1 - 1]);
		Object generatedDirlen = epa.getDirlen();
		Object generatedDiroffset = epa.getDiroffset();
		if (/* Poke in the base directory path */subdir) {
			int sublen = /*Error: Function owner not recognized*/strlen(subdir) + 1;
			if (ModernizedCProgram.get_16_sl(generatedDirlen) < sublen) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), "Subdirectory path too long... aborting install!\n");
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/exit(1);
			} 
			ModernizedCProgram.memcpy_to_sl(ModernizedCProgram.slptr(ModernizedCProgram.syslinux_ldlinux[0], generatedDiroffset), subdir, sublen);
		} 
		Object generatedSubvollen = epa.getSubvollen();
		Object generatedSubvoloffset = epa.getSubvoloffset();
		if (/* Poke in the subvolume information */subvol) {
			int sublen = /*Error: Function owner not recognized*/strlen(subvol) + 1;
			if (ModernizedCProgram.get_16_sl(generatedSubvollen) < sublen) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), "Subvol name too long... aborting install!\n");
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/exit(1);
			} 
			ModernizedCProgram.memcpy_to_sl(ModernizedCProgram.slptr(ModernizedCProgram.syslinux_ldlinux[0], generatedSubvoloffset), subvol, sublen);
		} 
		Object generatedChecksum = patcharea.getChecksum();
		ModernizedCProgram.set_32_sl(generatedChecksum, /* Now produce a checksum */0);
		csum = -1024;
		for (; i < dw; ) {
			csum -= ModernizedCProgram.get_32_sl(/* Negative checksum */wp);
		}
		ModernizedCProgram.set_32_sl(generatedChecksum, csum/*
		     * Assume all bytes modified.  This can be optimized at the expense
		     * of keeping track of what the highest modified address ever was.
		     */);
		return dw << 2;
	}
	public static Object ext2fs_crc16(Object crc, Object buffer, int len) {
		byte cp = buffer;
		while (len/*
				 * for an unknown reason, PPC treats __u16 as signed
				 * and keeps doing sign extension on the value.
				 * Instead, use only the low 16 bits of an unsigned
				 * int for holding the CRC value to avoid this.
				 */--) {
			crc = (((crc >> 8) & -1024) ^ ModernizedCProgram.crc16_table[(crc ^ cp++) & -1024]) & -1024;
		}
		return crc;
	}
	/*in/out*/
	public static Object realloc_symlink(Object p_stat, Object i_grow) {
		if (!p_stat.getRr().getI_symlink()) {
			 i_max = 2 * i_grow + 1;
			p_stat.getRr().setPsz_symlink((byte)/*Error: Function owner not recognized*/calloc(1, i_max));
			p_stat.getRr().setI_symlink_max(i_max);
			return (NULL != p_stat.getRr().getPsz_symlink());
		} else {
				int i_needed = p_stat.getRr().getI_symlink() + i_grow;
				if (i_needed <= p_stat.getRr().getI_symlink_max()) {
					return true;
				} else {
						byte psz_newsymlink = (byte)/*Error: Function owner not recognized*/calloc(1, 2 * i_needed);
						if (!psz_newsymlink) {
							return false;
						} 
						p_stat.getRr().setI_symlink_max(2 * i_needed);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(psz_newsymlink, p_stat.getRr().getPsz_symlink(), p_stat.getRr().getI_symlink());
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_stat.getRr().getPsz_symlink());
						p_stat.getRr().setPsz_symlink(psz_newsymlink);
						return true/* These functions are designed to read the system areas of a directory record
						 * and extract relevant information.  There are different functions provided
						 * depending upon what information we need at the time.  One function fills
						 * out an inode structure, a second one extracts a filename, a third one
						 * returns a symbolic link name, and a fourth one returns the extent number
						 * for the file. */;
				} 
		} 
	}
	/* isonum_721() */
	/* This is a way of ensuring that we have something in the system
	   use fields that is compatible with Rock Ridge */
	/* We define a series of macros because each function must do exactly the
	   same thing in certain places.  We use the macros to ensure that everything
	   is done correctly */
	/* Copy a long or short time from the iso_rock_tf_t into
	   the specified field of a iso_rock_statbuf_t.
	   non-paramater variables are p_stat, rr, and cnt.
	*/
	/*!
	  Get
	  @return length of name field; 0: not found, -1: to be ignored
	*/
	public static int get_rock_ridge_filename(Object p_iso9660_dir, Byte psz_name, Object p_stat) {
		/*in/out*/int len;
		byte chr;
		int symlink_len = 0;
		int cont_extent = 0;
		int cont_offset = 0;
		int cont_size = 0;
		Object buffer = NULL;
		int i_namelen = 0;
		int truncate = 0;
		if (!p_stat || nope == p_stat.getRr().getB3_rock()) {
			return 0;
		} 
		psz_name = 0;
		{ 
			len = /*Error: Unsupported expression*/ + p_iso9660_dir.getFilename().getLen();
			if (len & 1) {
				len++;
			} 
			chr = ((byte)p_iso9660_dir) + len;
			len = ((byte)p_iso9660_dir) - len;
			if (-1024 != p_stat.getRr().getS_rock_offset()) {
				len -= p_stat.getRr().getS_rock_offset();
				chr += p_stat.getRr().getS_rock_offset();
				if (len < 0) {
					len = 0/*repeat:*/;
				} 
			} 
		}
		;
		{ 
			 rr = new ();
			int sig;
			int rootflag;
			while (len > /* There may be one byte for padding somewhere */1) {
				rr = ()chr;
				sig = chr + ((chr + 1) << 8/* We used to check for some vaid values of SIG, specifically
					 SP, CE, ER, RR, PX, PN, SL, NM, CL, PL, TF, and ZF.
					 However there are various extensions to this set. So we
					 skip checking now.
				      */);
				if (rr.getLen() == /* Something got screwed up here */0) {
					;
				} 
				chr += rr.getLen();
				len -= rr.getLen();
				switch (sig) {
				case (((byte)'T') | (((byte)'F') << 8/* Time stamp(s) for a file */)):
						{ 
							int cnt = 0;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_CREATE) {
								p_stat.getRr().getCreate().setB_used(true);
								p_stat.getRr().getCreate().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getCreate().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getCreate().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getCreate().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_MODIFY) {
								p_stat.getRr().getModify().setB_used(true);
								p_stat.getRr().getModify().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getModify().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getModify().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getModify().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_ACCESS) {
								p_stat.getRr().getAccess().setB_used(true);
								p_stat.getRr().getAccess().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getAccess().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getAccess().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getAccess().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_ATTRIBUTES) {
								p_stat.getRr().getAttributes().setB_used(true);
								p_stat.getRr().getAttributes().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getAttributes().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getAttributes().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getAttributes().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_BACKUP) {
								p_stat.getRr().getBackup().setB_used(true);
								p_stat.getRr().getBackup().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getBackup().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getBackup().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getBackup().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_EXPIRATION) {
								p_stat.getRr().getExpiration().setB_used(true);
								p_stat.getRr().getExpiration().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getExpiration().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getExpiration().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getExpiration().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_EFFECTIVE) {
								p_stat.getRr().getEffective().setB_used(true);
								p_stat.getRr().getEffective().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getEffective().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getEffective().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getEffective().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							p_stat.getRr().setB3_rock(yep);
							break;
						}
				case (((byte)'N') | (((byte)'M') << 8)):
						p_stat.getRr().setB3_rock(/* Alternate name */yep);
						if (truncate) {
							break;
						} 
						if (rr.getU().getNM().getFlags() & ISO_ROCK_NM_PARENT) {
							i_namelen = /*Error: sizeof expression not supported yet*/;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(psz_name, "..", i_namelen);
							break;
						}  else if (rr.getU().getNM().getFlags() & ISO_ROCK_NM_CURRENT) {
							i_namelen = /*Error: sizeof expression not supported yet*/;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(psz_name, ".", i_namelen);
							break;
						} 
						if (rr.getU().getNM().getFlags() & ~1) {
							ModernizedCProgram.cdio_info("Unsupported NM flag settings (%d)", rr.getU().getNM().getFlags());
							break;
						} 
						if ((/*Error: Function owner not recognized*/strlen(psz_name) + rr.getLen() - 5) >= 254) {
							truncate = 1;
							break;
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(psz_name, rr.getU().getNM().getName(), rr.getLen() - 5);
						i_namelen += rr.getLen() - 5;
						break;
				case (((byte)'E') | (((byte)'R') << 8)):
						p_stat.getRr().setB3_rock(yep);
						ModernizedCProgram.cdio_debug("ISO 9660 Extensions: ");
						{ 
							int p;
							for (p = 0; p < rr.getU().getER().getLen_id(); p++) {
								ModernizedCProgram.cdio_debug("%c", rr.getU().getER().getData()[p]);
							}
						}
						break;
				case (((byte)'P') | (((byte)'X') << 8)):
						p_stat.getRr().setSt_mode(ModernizedCProgram.from_733(rr.getU().getPX().getSt_mode()));
						p_stat.getRr().setSt_nlinks(ModernizedCProgram.from_733(rr.getU().getPX().getSt_nlinks()));
						p_stat.getRr().setSt_uid(ModernizedCProgram.from_733(rr.getU().getPX().getSt_uid()));
						p_stat.getRr().setSt_gid(ModernizedCProgram.from_733(rr.getU().getPX().getSt_gid()));
						p_stat.getRr().setB3_rock(yep);
						break;
				case (((byte)'S') | (((byte)'L') << 8)):
						{ 
							 slen = new ();
							 p_sl = new ();
							 p_oldsl = new ();
							slen = rr.getLen() - 5;
							p_sl = rr.getU().getSL().getLink();
							p_stat.getRr().setI_symlink(symlink_len);
							while (slen > 1) {
								rootflag = 0;
								switch (p_sl.getFlags() & ~1) {
								case 0:
										ModernizedCProgram.realloc_symlink(p_stat, p_sl.getLen());
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getPsz_symlink()[p_stat.getRr().getI_symlink()]), p_sl.getText(), p_sl.getLen());
										p_stat.getRr().getI_symlink() += p_sl.getLen();
										break;
								case /* continue into next case. */2:
										ModernizedCProgram.realloc_symlink(p_stat, 1);
										p_stat.getRr().getPsz_symlink()[p_stat.getRr().getI_symlink()++] = (byte)'.';
										break;
								case 8:
										rootflag = 1;
										ModernizedCProgram.realloc_symlink(p_stat, 1);
										p_stat.getRr().getPsz_symlink()[p_stat.getRr().getI_symlink()++] = (byte)'/';
										break;
								case 4:
										ModernizedCProgram.realloc_symlink(p_stat, 1);
										p_stat.getRr().getPsz_symlink()[p_stat.getRr().getI_symlink()++] = (byte)'.';
								default:
										ModernizedCProgram.cdio_warn("Symlink component flag not implemented");
								}
								slen -= p_sl.getLen() + 2;
								p_oldsl = p_sl;
								p_sl = ()(((byte)p_sl) + p_sl.getLen() + 2);
								if (slen < 2) {
									if (((rr.getU().getSL().getFlags() & 1) != 0) && ((p_oldsl.getFlags() & 1) == 0)) {
										p_stat.getRr().getI_symlink() += 1;
									} 
									break;
								} 
								if (!rootflag && (p_oldsl.getFlags() & 1) == /*
									     * If this component record isn't continued, then append a '/'.
									     */0) {
									ModernizedCProgram.realloc_symlink(p_stat, 1);
									p_stat.getRr().getPsz_symlink()[p_stat.getRr().getI_symlink()++] = (byte)'/';
								} 
							}
						}
						symlink_len = p_stat.getRr().getI_symlink();
						ModernizedCProgram.realloc_symlink(p_stat, 1);
						p_stat.getRr().getPsz_symlink()[symlink_len] = (byte)'\0';
						break;
				case (((byte)'R') | (((byte)'E') << 8)):
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buffer);
						return -1;
				case (((byte)'C') | (((byte)'E') << 8)):
						{ 
							 i_fname = /*Error: Function owner not recognized*/from_711(p_iso9660_dir.getFilename().getLen());
							if ((byte)'\0' == p_iso9660_dir.getFilename().getStr()[1] && 1 == i_fname) {
								break;
							} 
							if ((byte)'\1' == p_iso9660_dir.getFilename().getStr()[1] && 1 == i_fname) {
								break;
							} 
						}
						{ 
							cont_extent = ModernizedCProgram.from_733(rr.getU().getCE().getExtent());
							cont_offset = ModernizedCProgram.from_733(rr.getU().getCE().getOffset());
							cont_size = ModernizedCProgram.from_733(rr.getU().getCE().getSize());
							(Object)cont_extent;
							;
						}
						;
						break;
				case (((byte)'S') | (((byte)'P') << 8)):
						if (rr.getU().getSP().getMagic()[0] != -1024) {
							;
						} 
						if (rr.getU().getSP().getMagic()[1] != -1024) {
							;
						} 
						p_stat.getRr().setS_rock_offset(rr.getU().getSP().getSkip());
						;
						break;
				default:
						break;
				}
			}
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buffer);
		return /* If 0, this file did not have a NM field */i_namelen;
		return 0;
	}
	/*out*/
	public static int parse_rock_ridge_stat_internal(Object p_iso9660_dir, Object p_stat, int regard_xa) {
		int len;
		byte chr;
		int symlink_len = 0;
		int cont_extent = 0;
		int cont_offset = 0;
		int cont_size = 0;
		Object buffer = NULL;
		if (nope == p_stat.getRr().getB3_rock()) {
			return 0;
		} 
		{ 
			len = /*Error: Unsupported expression*/ + p_iso9660_dir.getFilename().getLen();
			if (len & 1) {
				len++;
			} 
			chr = ((byte)p_iso9660_dir) + len;
			len = ((byte)p_iso9660_dir) - len;
			if (-1024 != p_stat.getRr().getS_rock_offset()) {
				len -= p_stat.getRr().getS_rock_offset();
				chr += p_stat.getRr().getS_rock_offset();
				if (len < 0) {
					len = 0;
				} 
			} 
		}
		;
		if (regard_xa) {
			chr += 14;
			len -= 14;
			if (len < 0) {
				len = 0;
			} 
		} 
		{ 
			int sig;
			 rr = new ();
			int rootflag;
			while (len > /* There may be one byte for padding somewhere */1) {
				rr = ()chr;
				if (rr.getLen() == /* Something got screwed up here */0) {
					;
				} 
				sig = /*Error: Function owner not recognized*/from_721(chr);
				chr += rr.getLen();
				len -= rr.getLen();
				switch (sig) {
				case (((byte)'E') | (((byte)'R') << 8)):
						p_stat.getRr().setB3_rock(yep);
						ModernizedCProgram.cdio_debug("ISO 9660 Extensions: ");
						{ 
							int p;
							for (p = 0; p < rr.getU().getER().getLen_id(); p++) {
								ModernizedCProgram.cdio_debug("%c", rr.getU().getER().getData()[p]);
							}
						}
						break;
				case (((byte)'S') | (((byte)'L') << 8)):
						{ 
							 slen = new ();
							 p_sl = new ();
							 p_oldsl = new ();
							slen = rr.getLen() - 5;
							p_sl = rr.getU().getSL().getLink();
							p_stat.getRr().setI_symlink(symlink_len);
							while (slen > 1) {
								rootflag = 0;
								switch (p_sl.getFlags() & ~1) {
								case 0:
										ModernizedCProgram.realloc_symlink(p_stat, p_sl.getLen());
										if (p_sl.getText() && p_sl.getLen()) {
											/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getPsz_symlink()[p_stat.getRr().getI_symlink()]), p_sl.getText(), p_sl.getLen());
										} 
										p_stat.getRr().getI_symlink() += p_sl.getLen();
										break;
								case /* continue into next case. */2:
										ModernizedCProgram.realloc_symlink(p_stat, 1);
										p_stat.getRr().getPsz_symlink()[p_stat.getRr().getI_symlink()++] = (byte)'.';
										break;
								case 8:
										rootflag = 1;
										ModernizedCProgram.realloc_symlink(p_stat, 1);
										p_stat.getRr().getPsz_symlink()[p_stat.getRr().getI_symlink()++] = (byte)'/';
										p_stat.getRr().getI_symlink()++;
										break;
								case 4:
										ModernizedCProgram.realloc_symlink(p_stat, 1);
										p_stat.getRr().getPsz_symlink()[p_stat.getRr().getI_symlink()++] = (byte)'.';
								default:
										ModernizedCProgram.cdio_warn("Symlink component flag not implemented");
								}
								slen -= p_sl.getLen() + 2;
								p_oldsl = p_sl;
								p_sl = ()(((byte)p_sl) + p_sl.getLen() + 2);
								if (slen < 2) {
									if (((rr.getU().getSL().getFlags() & 1) != 0) && ((p_oldsl.getFlags() & 1) == 0)) {
										p_stat.getRr().getI_symlink() += 1;
									} 
									break;
								} 
								if (!rootflag && (p_oldsl.getFlags() & 1) == /*
									     * If this component record isn't continued, then append a '/'.
									     */0) {
									ModernizedCProgram.realloc_symlink(p_stat, 1);
									p_stat.getRr().getPsz_symlink()[p_stat.getRr().getI_symlink()++] = (byte)'/';
								} 
							}
						}
						symlink_len = p_stat.getRr().getI_symlink();
						ModernizedCProgram.realloc_symlink(p_stat, 1);
						p_stat.getRr().getPsz_symlink()[symlink_len] = (byte)'\0';
						break;
				case (((byte)'C') | (((byte)'E') << 8)):
						{ 
							cont_extent = ModernizedCProgram.from_733(rr.getU().getCE().getExtent());
							cont_offset = ModernizedCProgram.from_733(rr.getU().getCE().getOffset());
							cont_size = ModernizedCProgram.from_733(rr.getU().getCE().getSize());
							(Object)cont_extent;
							;
						}
						;
						break;
				case (((byte)'P') | (((byte)'N') << 8/* Device major,minor number */)):
						{ 
							 high = new ();
							 low = new ();
							high = ModernizedCProgram.from_733(rr.getU().getPN().getDev_high());
							low = ModernizedCProgram.from_733(rr.getU().getPN().getDev_low());
							if ((low & ~-1024) && high == 0) {
								p_stat.getRr().setI_rdev(((low >> 8) << 16 | (low & -1024)));
							} else {
									p_stat.getRr().setI_rdev(((high) << 16 | (low)));
							} 
						}
						break;
				case (((byte)'P') | (((byte)'X') << 8)):
						p_stat.getRr().setSt_mode(ModernizedCProgram.from_733(rr.getU().getPX().getSt_mode()));
						p_stat.getRr().setSt_nlinks(ModernizedCProgram.from_733(rr.getU().getPX().getSt_nlinks()));
						p_stat.getRr().setSt_uid(ModernizedCProgram.from_733(rr.getU().getPX().getSt_uid()));
						p_stat.getRr().setSt_gid(ModernizedCProgram.from_733(rr.getU().getPX().getSt_gid()));
						break;
				case (((byte)'R') | (((byte)'E') << 8)):
						ModernizedCProgram.cdio_warn("Attempt to read p_stat for relocated directory");
						;
				case (((byte)'S') | (((byte)'P') << 8)):
						if (rr.getU().getSP().getMagic()[0] != -1024) {
							;
						} 
						if (rr.getU().getSP().getMagic()[1] != -1024) {
							;
						} 
						p_stat.getRr().setS_rock_offset(rr.getU().getSP().getSkip());
						;
						break;
				case (((byte)'T') | (((byte)'F') << 8/* Time stamp(s) for a file */)):
						{ 
							int cnt = 0;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_CREATE) {
								p_stat.getRr().getCreate().setB_used(true);
								p_stat.getRr().getCreate().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getCreate().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getCreate().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getCreate().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_MODIFY) {
								p_stat.getRr().getModify().setB_used(true);
								p_stat.getRr().getModify().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getModify().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getModify().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getModify().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_ACCESS) {
								p_stat.getRr().getAccess().setB_used(true);
								p_stat.getRr().getAccess().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getAccess().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getAccess().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getAccess().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_ATTRIBUTES) {
								p_stat.getRr().getAttributes().setB_used(true);
								p_stat.getRr().getAttributes().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getAttributes().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getAttributes().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getAttributes().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_BACKUP) {
								p_stat.getRr().getBackup().setB_used(true);
								p_stat.getRr().getBackup().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getBackup().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getBackup().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getBackup().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_EXPIRATION) {
								p_stat.getRr().getExpiration().setB_used(true);
								p_stat.getRr().getExpiration().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getExpiration().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getExpiration().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getExpiration().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							if (rr.getU().getTF().getFlags() & ISO_ROCK_TF_EFFECTIVE) {
								p_stat.getRr().getEffective().setB_used(true);
								p_stat.getRr().getEffective().setB_longdate((0 != (rr.getU().getTF().getFlags() & ISO_ROCK_TF_LONG_FORM)));
								if (p_stat.getRr().getEffective().getB_longdate()) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getEffective().getT().getLtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
									cnt += /*Error: Unsupported expression*/;
								} else {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_stat.getRr().getEffective().getT().getDtime()), (rr.getU().getTF().getTime_bytes()[cnt]), /*Error: Unsupported expression*/);
										cnt += /*Error: Unsupported expression*/;
								} 
							} 
							;
							p_stat.getRr().setB3_rock(yep);
							break;
						}
				default:
						break;
				}
			}
		}
		return 0;
	}
	public static int parse_rock_ridge_stat(Object p_iso9660_dir, Object p_stat) {
		int result;
		if (!p_stat) {
			return 0;
		} 
		result = ModernizedCProgram.parse_rock_ridge_stat_internal(p_iso9660_dir, p_stat, 0/* if Rock-Ridge flag was reset and we didn't look for attributes
		   * behind eventual XA attributes, have a look there */);
		if (-1024 == p_stat.getRr().getS_rock_offset() && nope != p_stat.getRr().getB3_rock()) {
			result = ModernizedCProgram.parse_rock_ridge_stat_internal(p_iso9660_dir, p_stat, 14);
		} 
		return result;
	}
	/*out*/
	/* Return a pointer to a internal free buffer */
	public static Byte _getbuf() {
		byte[][] _buf = new byte[16][/*Error: sizeof expression not supported yet*/];
		int _i = -1;
		_i++;
		_i %= 16;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(_buf[_i], 0, /*Error: sizeof expression not supported yet*/);
		return _buf[_i/*!
		  Returns a string which interpreting the POSIX mode st_mode.
		  For example:
		  \verbatim
		  drwxrws---
		  -rw-rw-r--
		  lrwxrwxrwx
		  \endverbatim
		
		  A description of the characters in the string follows
		  The 1st character is either "b" for a block device,
		  "c" for a character device, "d" if the entry is a directory, "l" for
		  a symbolic link, "p" for a pipe or FIFO, "s" for a "socket",
		  or "-" if none of the these.
		
		  The 2nd to 4th characters refer to permissions for a user while the
		  the 5th to 7th characters refer to permissions for a group while, and
		  the 8th to 10h characters refer to permissions for everyone.
		
		  In each of these triplets the first character (2, 5, 8) is "r" if
		  the entry is allowed to be read.
		
		  The second character of a triplet (3, 6, 9) is "w" if the entry is
		  allowed to be written.
		
		  The third character of a triplet (4, 7, 10) is "x" if the entry is
		  executable but not user (for character 4) or group (for characters
		  6) settable and "s" if the item has the corresponding user/group set.
		
		  For a directory having an executable property on ("x" or "s") means
		  the directory is allowed to be listed or "searched". If the execute
		  property is not allowed for a group or user but the corresponding
		  group/user is set "S" indicates this. If none of these properties
		  holds the "-" indicates this.
		*/];
		byte[][] _buf = new byte[16][80];
		int _num = -1;
		_num++;
		_num %= 16;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(_buf[_num], 0, 80);
		return _buf[_num/*!
		  Returns a string which interpreting the extended attribute xa_attr. 
		  For example:
		  \verbatim
		  d---1xrxrxr
		  ---2--r-r-r
		  -a--1xrxrxr
		  \endverbatim
		
		  A description of the characters in the string follows
		  The 1st character is either "d" if the entry is a directory, or "-" if not.
		  The 2nd character is either "a" if the entry is CDDA (audio), or "-" if not.
		  The 3rd character is either "i" if the entry is interleaved, or "-" if not.
		  The 4th character is either "2" if the entry is mode2 form2 or "-" if not.
		  The 5th character is either "1" if the entry is mode2 form1 or "-" if not.
		   Note that an entry will either be in mode2 form1 or mode form2. That
		   is you will either see "2-" or "-1" in the 4th & 5th positions.
		
		  The 6th and 7th characters refer to permissions for a user while the
		  the 8th and 9th characters refer to permissions for a group while, and 
		  the 10th and 11th characters refer to permissions for a others. 
		 
		  In each of these pairs the first character (6, 8, 10) is "x" if the 
		  entry is executable. For a directory this means the directory is
		  allowed to be listed or "searched".
		  The second character of a pair (7, 9, 11) is "r" if the entry is allowed
		  to be read. 
		*/];
	}
	public static Object iso9660_get_rock_attr_str(Object st_mode) {
		byte result = ModernizedCProgram._getbuf();
		if ((((st_mode) & S_IFMT) == -1024)) {
			result[0] = (byte)'b';
		}  else if (/*Error: Function owner not recognized*/S_ISDIR(st_mode)) {
			result[0] = (byte)'d';
		}  else if (/*Error: Function owner not recognized*/S_ISCHR(st_mode)) {
			result[0] = (byte)'c';
		}  else if (()) {
			result[0] = (byte)'l';
		}  else if ((((st_mode) & S_IFMT) == -1024)) {
			result[0] = (byte)'p';
		}  else if (()) {
			result[0] = (byte)'s'/* May eventually fill in others.. */;
		} else {
				result[0] = (byte)'-';
		} 
		result[1] = (st_mode & ISO_ROCK_IRUSR) ? (byte)'r' : (byte)'-';
		result[2] = (st_mode & ISO_ROCK_IWUSR) ? (byte)'w' : (byte)'-';
		if (st_mode & ISO_ROCK_ISUID) {
			result[3] = (st_mode & ISO_ROCK_IXUSR) ? (byte)'s' : (byte)'S';
		} else {
				result[3] = (st_mode & ISO_ROCK_IXUSR) ? (byte)'x' : (byte)'-';
		} 
		result[4] = (st_mode & ISO_ROCK_IRGRP) ? (byte)'r' : (byte)'-';
		result[5] = (st_mode & ISO_ROCK_IWGRP) ? (byte)'w' : (byte)'-';
		if (st_mode & ISO_ROCK_ISGID) {
			result[6] = (st_mode & ISO_ROCK_IXGRP) ? (byte)'s' : (byte)'S';
		} else {
				result[6] = (st_mode & ISO_ROCK_IXGRP) ? (byte)'x' : (byte)'-';
		} 
		result[7] = (st_mode & ISO_ROCK_IROTH) ? (byte)'r' : (byte)'-';
		result[8] = (st_mode & ISO_ROCK_IWOTH) ? (byte)'w' : (byte)'-';
		result[9] = (st_mode & ISO_ROCK_IXOTH) ? (byte)'x' : (byte)'-';
		result[11] = (byte)'\0';
		return result/*!
		  Returns POSIX mode bitstring for a given file.
		*/;
	}
	public static Object iso9660_get_posix_filemode_from_rock(Object rr) {
		return ()rr.getSt_mode();
	}
	// __popcnt16, __popcnt, __popcnt64 are not available for ARM :(
	public static Object popcnt8(Object val) {
		uint8_t[] nibble_lookup = new uint8_t[]{0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};
		return nibble_lookup[val & -1024] + nibble_lookup[val >> 4/*
		 * Hash table functions - modified From glibc 2.3.2:
		 * [Aho,Sethi,Ullman] Compilers: Principles, Techniques and Tools, 1986
		 * [Knuth]            The Art of Computer Programming, part 3 (6.4)
		 */];
	}
	/*
	 * For the used double hash method the table size has to be a prime. To
	 * correct the user given table size we need a prime test.  This trivial
	 * algorithm is adequate because the code is called only during init and
	 * the number is likely to be small
	 */
	public static Object isprime(Object number) {
		// no even number will be passeduint32_t divider = 3;
		while ((divider * divider < number) && (number % divider != 0)) {
			divider += 2;
		}
		return (number % divider != 0/*
		 * Before using the hash table we must allocate memory for it.
		 * We allocate one element more as the found prime number says.
		 * This is done for more effective indexing as explained in the
		 * comment for the hash function.
		 */);
	}
	public static Object is_x64() {
		BOOL ret = 0;
		BOOL IsWow64Process_t = new BOOL();
		// Detect if we're running a 32 or 64 bit system
		IsWow64Process_t pfIsWow64Process = ((Object)0);
		if (/*Error: Unsupported expression*/ < 8) {
			if (pfIsWow64Process == ((Object)0)) {
				pfIsWow64Process = (IsWow64Process_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Kernel32"), "IsWow64Process");
			} 
			if (pfIsWow64Process != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(/*Error: Function owner not recognized*/GetCurrentProcess(), ret);
			} 
		} else {
				ret = 1;
		} 
		return ret;
	}
	public static int GetCpuArch() {
		SYSTEM_INFO info = new SYSTEM_INFO(0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetNativeSystemInfo(info);
		Object generatedWProcessorArchitecture = info.getWProcessorArchitecture();
		switch (generatedWProcessorArchitecture) {
		case 5:
				return CpuArch.CPU_ARCH_ARM_32;
		case PROCESSOR_ARCHITECTURE_ARM64:
				return CpuArch.CPU_ARCH_ARM_64;
		case 9:
				return CpuArch.CPU_ARCH_X86_64;
		case 0:
				return CpuArch.CPU_ARCH_X86_64;
		default:
				return CpuArch.CPU_ARCH_UNDEFINED;
		}
	}
	// From smartmontools os_win32.cpp
	public static void GetWindowsVersion() {
		OSVERSIONINFOEXA vi = new OSVERSIONINFOEXA();
		OSVERSIONINFOEXA vi2 = new OSVERSIONINFOEXA();
		byte w = 0;
		byte w64 = "32 bit";
		byte vptr;
		size_t vlen = new size_t();
		int major;
		int minor;
		ULONGLONG major_equal = new ULONGLONG();
		ULONGLONG minor_equal = new ULONGLONG();
		BOOL ws = new BOOL();
		ModernizedCProgram.nWindowsVersion = WindowsVersion.WINDOWS_UNDEFINED;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.WindowsVersionStr, "Windows Undefined", (((size_t)(((((byte)"Windows Undefined") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Windows Undefined")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"Windows Undefined") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Windows Undefined")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)ModernizedCProgram.WindowsVersionStr)[(((size_t)(((((byte)"Windows Undefined") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Windows Undefined")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"Windows Undefined") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Windows Undefined")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(vi, 0, /*Error: sizeof expression not supported yet*/);
		vi.setDwOSVersionInfoSize(/*Error: sizeof expression not supported yet*/);
		if (!/*Error: Function owner not recognized*/GetVersionExA((OSVERSIONINFOA)vi)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(vi, 0, /*Error: sizeof expression not supported yet*/);
			vi.setDwOSVersionInfoSize(/*Error: Unsupported expression*/);
			if (!/*Error: Function owner not recognized*/GetVersionExA((OSVERSIONINFOA)vi)) {
				return /*Error: Unsupported expression*/;
			} 
		} 
		Object generatedDwPlatformId = vi.getDwPlatformId();
		Object generatedDwMajorVersion = vi.getDwMajorVersion();
		Object generatedDwMinorVersion = vi.getDwMinorVersion();
		Object generatedWProductType = vi.getWProductType();
		if (generatedDwPlatformId == 2) {
			if (generatedDwMajorVersion > 6 || (generatedDwMajorVersion == 6 && generatedDwMinorVersion >= 2)) {
				major_equal = /*Error: Function owner not recognized*/VerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL);
				for (major = generatedDwMajorVersion; major <= 9; major++) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(vi2, 0, /*Error: sizeof expression not supported yet*/);
					vi2.setDwOSVersionInfoSize(/*Error: sizeof expression not supported yet*/);
					vi2.setDwMajorVersion(major);
					if (!/*Error: Function owner not recognized*/VerifyVersionInfoA(vi2, VER_MAJORVERSION, major_equal)) {
						continue;
					} 
					if (generatedDwMajorVersion < major) {
						vi.setDwMajorVersion(major);
						vi.setDwMinorVersion(0);
					} 
					minor_equal = /*Error: Function owner not recognized*/VerSetConditionMask(0, VER_MINORVERSION, VER_EQUAL);
					for (minor = generatedDwMinorVersion; minor <= 9; minor++) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(vi2, 0, /*Error: sizeof expression not supported yet*/);
						vi2.setDwOSVersionInfoSize(/*Error: sizeof expression not supported yet*/);
						vi2.setDwMinorVersion(minor);
						if (!/*Error: Function owner not recognized*/VerifyVersionInfoA(vi2, VER_MINORVERSION, minor_equal)) {
							continue;
						} 
						vi.setDwMinorVersion(minor);
						break;
					}
					break;
				}
			} 
			if (generatedDwMajorVersion <= -1024 && generatedDwMinorVersion <= -1024) {
				ws = (generatedWProductType <= 1);
				ModernizedCProgram.nWindowsVersion = generatedDwMajorVersion << 4 | generatedDwMinorVersion;
				switch (ModernizedCProgram.nWindowsVersion) {
				case -1024:
						w = (!/*Error: Function owner not recognized*/GetSystemMetrics(89) ? "Server 2003" : "Server 2003_R2");
						break;
				case -1024:
						w = (ws ? "10 (Preview 1)" : "Server 10 (Preview 1)");
						break;
				case -1024:
						w = (ws ? "7" : "Server 2008_R2");
						break;
				case -1024:
						w = (ws ? "8" : "Server 2012");
						break;
				case -1024:
						w = (ws ? "10" : "Server 2016");
						break;
				case -1024:
						w = "XP";
						break;
				case -1024:
						w = (ws ? "Vista" : "Server 2008");
						break;
				case -1024:
						w = (ws ? "8.1" : "Server 2012_R2");
						break;
				default:
						if (ModernizedCProgram.nWindowsVersion < -1024) {
							ModernizedCProgram.nWindowsVersion = WindowsVersion.WINDOWS_UNSUPPORTED;
						} else {
								w = "11 or later";
						} 
						break;
				}
			} 
		} 
		if (ModernizedCProgram.is_x64()) {
			w64 = "64-bit";
		} 
		vptr = ModernizedCProgram.WindowsVersionStr[/*Error: sizeof expression not supported yet*/ - 1];
		vlen = /*Error: sizeof expression not supported yet*/ - /*Error: sizeof expression not supported yet*/ - 1;
		Object generatedWServicePackMinor = vi.getWServicePackMinor();
		Object generatedWServicePackMajor = vi.getWServicePackMajor();
		if (!w) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(vptr, vlen, "%s %u.%u %s", (generatedDwPlatformId == 2 ? "NT" : "??"), (int)generatedDwMajorVersion, (int)generatedDwMinorVersion, w64);
				(vptr)[(vlen) - 1] = 0;
			} while (0);
		}  else if (generatedWServicePackMinor) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(vptr, vlen, "%s SP%u.%u %s", w, generatedWServicePackMajor, generatedWServicePackMinor, w64);
				(vptr)[(vlen) - 1] = 0;
			} while (0);
		}  else if (generatedWServicePackMajor) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(vptr, vlen, "%s SP%u %s", w, generatedWServicePackMajor, w64);
				(vptr)[(vlen) - 1] = 0;
			} while (0);
		} else {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(vptr, vlen, "%s %s", w, w64);
					(vptr)[(vlen) - 1] = 0;
				} while (0);
		} 
		Object generatedDwBuildNumber = vi.getDwBuildNumber();
		// Add the build number for Windows 8.0 and later// Add the build number for Windows 8.0 and laterModernizedCProgram.nWindowsBuildNumber = generatedDwBuildNumber;
		if (ModernizedCProgram.nWindowsVersion >= -1024) {
			vptr = ModernizedCProgram.WindowsVersionStr[((((byte)ModernizedCProgram.WindowsVersionStr) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.WindowsVersionStr))];
			vlen = /*Error: sizeof expression not supported yet*/ - ((((byte)ModernizedCProgram.WindowsVersionStr) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.WindowsVersionStr)) - 1;
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(vptr, vlen, " (Build %d)", ModernizedCProgram.nWindowsBuildNumber);
				(vptr)[(vlen) - 1] = 0;
			} while (0);
		} 
	}
	/*
	 * String array manipulation
	 */
	public static void StrArrayCreate(Object initial_size) {
		if (arr == ((Object)0)) {
			return /*Error: Unsupported expression*/;
		} 
		this.setMax(initial_size);
		this.setIndex(0);
		Object generatedMax = this.getMax();
		this.setString((byte)/*Error: Function owner not recognized*/calloc(generatedMax, /*Error: Unsupported expression*/));
		Object generatedString = this.getString();
		if (generatedString == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not allocate string array\n");
		} 
	}
	public static Object StrArrayAdd(Object str, Object duplicate) {
		byte old_table;
		Object generatedString = this.getString();
		if ((arr == ((Object)0)) || (generatedString == ((Object)0)) || (str == ((Object)0))) {
			return -1;
		} 
		Object generatedIndex = this.getIndex();
		Object generatedMax = this.getMax();
		if (generatedIndex == generatedMax) {
			generatedMax *= 2;
			old_table = generatedString;
			this.setString((byte)/*Error: Function owner not recognized*/realloc(generatedString, generatedMax * /*Error: Unsupported expression*/));
			if (generatedString == ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(old_table);
				ModernizedCProgram._uprintf("Could not reallocate string array\n");
				return -1;
			} 
		} 
		generatedString[generatedIndex] = (duplicate) ? /*Error: Function owner not recognized*/_strdup(str) : (byte)str;
		if (generatedString[generatedIndex] == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not store string in array\n");
			return -1;
		} 
		return generatedIndex++;
	}
	public static Object StrArrayFind(Object str) {
		uint32_t i = new uint32_t();
		Object generatedString = this.getString();
		if ((str == ((Object)0)) || (arr == ((Object)0)) || (generatedString == ((Object)0))) {
			return -1;
		} 
		Object generatedIndex = this.getIndex();
		for (i = 0; i < generatedIndex; i++) {
			if (/*Error: Function owner not recognized*/strcmp(generatedString[i], str) == 0) {
				return (int32_t)i;
			} 
		}
		return -1;
	}
	public static void StrArrayClear() {
		uint32_t i = new uint32_t();
		Object generatedString = this.getString();
		if ((arr == ((Object)0)) || (generatedString == ((Object)0))) {
			return /*Error: Unsupported expression*/;
		} 
		Object generatedIndex = this.getIndex();
		for (i = 0; i < generatedIndex; i++) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)generatedString[i]);
				generatedString[i] = ((Object)0);
			} while (0);
		}
		this.setIndex(0);
	}
	public static void StrArrayDestroy() {
		arr.StrArrayClear();
		Object generatedString = this.getString();
		if (arr != ((Object)0)) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)generatedString);
				this.setString(((Object)0));
			} while (0/*
			 * Retrieve the SID of the current user. The returned PSID must be freed by the caller using LocalFree()
			 */);
		} 
	}
	public static Object GetSID() {
		TOKEN_USER tu = ((Object)0);
		DWORD len = new DWORD();
		HANDLE token = new HANDLE();
		PSID ret = ((Object)0);
		byte psid_string = ((Object)0);
		if (!/*Error: Function owner not recognized*/OpenProcessToken(/*Error: Function owner not recognized*/GetCurrentProcess(), (true), token)) {
			ModernizedCProgram._uprintf("OpenProcessToken failed: %s\n", ModernizedCProgram.WindowsErrorString());
			return ((Object)0);
		} 
		if (!/*Error: Function owner not recognized*/GetTokenInformation(token, _TOKEN_INFORMATION_CLASS.TokenUser, tu, 0, len)) {
			if (/*Error: Function owner not recognized*/GetLastError() != -1024) {
				ModernizedCProgram._uprintf("GetTokenInformation (pre) failed: %s\n", ModernizedCProgram.WindowsErrorString());
				return ((Object)0);
			} 
			tu = (TOKEN_USER)/*Error: Function owner not recognized*/calloc(1, len);
		} 
		if (tu == ((Object)0)) {
			return ((Object)0);
		} 
		Object generatedUser = tu.getUser();
		if (/*Error: Function owner not recognized*/GetTokenInformation(token, _TOKEN_INFORMATION_CLASS.TokenUser, tu, len, len/*
				 * now of course, the interesting thing is that if you return tu->User.Sid
				 * but free tu, the PSID pointer becomes invalid after a while.
				 * The workaround? Convert to string then back to PSID
				 */)) {
			if (!/*Error: Function owner not recognized*/ConvertSidToStringSidA(generatedUser.getSid(), psid_string)) {
				ModernizedCProgram._uprintf("Unable to convert SID to string: %s\n", ModernizedCProgram.WindowsErrorString());
				ret = ((Object)0);
			} else {
					if (!/*Error: Function owner not recognized*/ConvertStringSidToSidA(psid_string, ret)) {
						ModernizedCProgram._uprintf("Unable to convert string back to SID: %s\n", ModernizedCProgram.WindowsErrorString());
						ret = ((Object)0);
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/LocalFree(psid_string);
			} 
		} else {
				ret = ((Object)0);
				ModernizedCProgram._uprintf("GetTokenInformation (real) failed: %s\n", ModernizedCProgram.WindowsErrorString());
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(tu);
		return ret/*
		 * read or write I/O to a file
		 * buffer is allocated by the procedure. path is UTF-8
		 */;
	}
	public static Object FileIO(Object save, Byte path, Byte buffer, Object size) {
		SECURITY_ATTRIBUTES s_attr = new SECURITY_ATTRIBUTES();
		SECURITY_ATTRIBUTES sa = ((Object)0);
		SECURITY_DESCRIPTOR s_desc = new SECURITY_DESCRIPTOR();
		PSID sid = ((Object)0);
		HANDLE handle = new HANDLE();
		BOOL r = new BOOL();
		BOOL ret = 0;
		// Change the owner from admin to regular user// Change the owner from admin to regular usersid = ModernizedCProgram.GetSID();
		if ((sid != ((Object)0)) && /*Error: Function owner not recognized*/InitializeSecurityDescriptor(s_desc, 1) && /*Error: Function owner not recognized*/SetSecurityDescriptorOwner(s_desc, sid, 0)) {
			s_attr.setNLength(/*Error: Unsupported expression*/);
			s_attr.setBInheritHandle(0);
			s_attr.setLpSecurityDescriptor(s_desc);
			sa = s_attr;
		} else {
				ModernizedCProgram._uprintf("Could not set security descriptor: %s\n", ModernizedCProgram.WindowsErrorString());
		} 
		if (!save) {
			buffer = ((Object)0);
		} 
		handle = ModernizedCProgram.CreateFileU(path, save ? -1024 : -1024, -1024, sa, save ? 2 : 3, -1024, ((Object)0));
		if (handle == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Could not %s file '%s'\n", save ? "create" : "open", path);
			;
		} 
		if (save) {
			r = /*Error: Function owner not recognized*/WriteFile(handle, buffer, size, size, ((Object)0));
		} else {
				size = /*Error: Function owner not recognized*/GetFileSize(handle, ((Object)0));
				buffer = (byte)/*Error: Function owner not recognized*/malloc(size);
				if (buffer == ((Object)0)) {
					ModernizedCProgram._uprintf("Could not allocate buffer for reading file\n");
					;
				} 
				r = /*Error: Function owner not recognized*/ReadFile(handle, buffer, size, size, ((Object)0));
		} 
		if (!r) {
			ModernizedCProgram._uprintf("I/O Error: %s\n", ModernizedCProgram.WindowsErrorString());
			;
		} 
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, save ? 3216 : 3215, path);
		ret = 1;
		if (!ret) {
			size = 0;
			if (!save) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)buffer);
					buffer = ((Object)0);
				} while (0);
			} 
		} 
		// Only leave a buffer allocated if successful
		return ret;
	}
	public static Byte GetResource(Object module, Byte name, Byte type, Object desc, Object len, Object duplicate) {
		HGLOBAL res_handle = new HGLOBAL();
		HRSRC res = new HRSRC();
		byte p = ((Object)0);
		res = /*Error: Function owner not recognized*/FindResourceA(module, name, type);
		if (res == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not locate resource '%s': %s\n", desc, ModernizedCProgram.WindowsErrorString());
			;
		} 
		res_handle = /*Error: Function owner not recognized*/LoadResource(module, res);
		if (res_handle == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not load resource '%s': %s\n", desc, ModernizedCProgram.WindowsErrorString());
			;
		} 
		len = /*Error: Function owner not recognized*/SizeofResource(module, res);
		if (duplicate) {
			p = (byte)/*Error: Function owner not recognized*/malloc(len);
			if (p == ((Object)0)) {
				ModernizedCProgram._uprintf("Coult not allocate resource '%s'\n", desc);
				;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p, /*Error: Function owner not recognized*/LockResource(res_handle), len);
		} else {
				p = (byte)/*Error: Function owner not recognized*/LockResource(res_handle);
		} 
	}
	public static Object GetResourceSize(Object module, Byte name, Byte type, Object desc) {
		DWORD len = 0;
		return (ModernizedCProgram.GetResource(module, name, type, desc, len, 0) == ((Object)0)) ? 0 : len;
	}
	// Run a console command, with optional redirection of stdout and stderr to our log
	public static Object RunCommand(Object cmd, Object dir, Object log) {
		DWORD ret = new DWORD();
		DWORD dwRead = new DWORD();
		DWORD dwAvail = new DWORD();
		DWORD dwPipeSize = 4096;
		STARTUPINFOA si = new STARTUPINFOA(0);
		PROCESS_INFORMATION pi = new PROCESS_INFORMATION(0);
		SECURITY_ATTRIBUTES sa = new SECURITY_ATTRIBUTES(/*Error: Unsupported expression*/, ((Object)0), 1);
		HANDLE hOutputRead = (HANDLE)(true);
		HANDLE hOutputWrite = (HANDLE)(true);
		byte output;
		si.setCb(/*Error: sizeof expression not supported yet*/);
		if (log) {
			if (!/*Error: Function owner not recognized*/CreatePipe(hOutputRead, hOutputWrite, sa, dwPipeSize)) {
				ret = /*Error: Function owner not recognized*/GetLastError();
				ModernizedCProgram._uprintf("Could not set commandline pipe: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			si.setDwFlags(1 | 256 | STARTF_PREVENTPINNING | STARTF_TITLEISAPPID);
			si.setWShowWindow(0);
			si.setHStdOutput(hOutputWrite);
			si.setHStdError(hOutputWrite);
		} 
		// NB: The size of a pipe is a suggestion, NOT an absolute guarantee
		if (!ModernizedCProgram.CreateProcessU(((Object)0), cmd, ((Object)0), ((Object)0), 1, -1024 | -1024, ((Object)0), dir, si, pi)) {
			ret = /*Error: Function owner not recognized*/GetLastError();
			ModernizedCProgram._uprintf("Unable to launch command '%s': %s", cmd, ModernizedCProgram.WindowsErrorString());
			;
		} 
		Object generatedHProcess = pi.getHProcess();
		if (log) {
			while (1) {
				if (/*Error: Function owner not recognized*/PeekNamedPipe(hOutputRead, ((Object)0), dwPipeSize, ((Object)0), dwAvail, ((Object)0))) {
					if (dwAvail != 0) {
						output = /*Error: Function owner not recognized*/malloc(dwAvail + 1);
						if ((output != ((Object)0)) && (/*Error: Function owner not recognized*/ReadFile(hOutputRead, output, dwAvail, dwRead, ((Object)0))) && (dwRead != 0)) {
							output[dwAvail] = 0;
							ModernizedCProgram._uprintf(output);
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(output);
					} 
				} 
				if (/*Error: Function owner not recognized*/WaitForSingleObject(generatedHProcess, 0) == 0) {
					break;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(100);
			}
			;
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject(generatedHProcess, -1024);
		} 
		if (!/*Error: Function owner not recognized*/GetExitCodeProcess(generatedHProcess, ret)) {
			ret = /*Error: Function owner not recognized*/GetLastError();
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(generatedHProcess);
		Object generatedHThread = pi.getHThread();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(generatedHThread);
		do {
			if ((hOutputRead != (HANDLE)(true)) && (hOutputRead != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hOutputRead);
				hOutputRead = (HANDLE)(true);
			} 
		} while (0);
		return ret;
	}
	public static Object CompareGUID(Object guid1, Object guid2) {
		if ((guid1 != ((Object)0)) && (guid2 != ((Object)0))) {
			return (/*Error: Function owner not recognized*/memcmp(guid1, guid2, /*Error: Unsupported expression*/) == 0);
		} 
		return 0;
	}
	public static Object EnumFontFamExProc(Object lpelfe, Object lpntme, Object FontType, Object lParam) {
		return 1;
	}
	public static Object IsFontAvailable(Object font_name) {
		BOOL r = new BOOL();
		LOGFONTA lf = new LOGFONTA(0);
		HDC hDC = /*Error: Function owner not recognized*/GetDC(ModernizedCProgram.hMainDialog);
		if (font_name == ((Object)0)) {
			do {
				if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(ModernizedCProgram.hMainDialog, hDC);
					hDC = ((Object)0);
				} 
			} while (0);
			return 0;
		} 
		lf.setLfCharSet(1);
		Object generatedLfFaceName = lf.getLfFaceName();
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedLfFaceName, font_name, (((size_t)(((((byte)font_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(font_name)) + 1)) < ((size_t)(true)) ? ((size_t)(((((byte)font_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(font_name)) + 1)) : ((size_t)(true))));
			((byte)generatedLfFaceName)[(((size_t)(((((byte)font_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(font_name)) + 1)) < ((size_t)(true)) ? ((size_t)(((((byte)font_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(font_name)) + 1)) : ((size_t)(true))) - 1] = 0;
		} while (0);
		r = /*Error: Function owner not recognized*/EnumFontFamiliesExA(hDC, lf, EnumFontFamExProc, 0, 0);
		do {
			if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(ModernizedCProgram.hMainDialog, hDC);
				hDC = ((Object)0);
			} 
		} while (0);
		return r/*
		 * Set or restore a Local Group Policy DWORD key indexed by szPath/SzPolicy
		 */;
	}
	public static Object SetLGPThread(Object param) {
		SetLGP_Params p = (SetLGP_Params)param;
		LONG r = new LONG();
		DWORD disp = new DWORD();
		DWORD regtype = new DWORD();
		DWORD val = 0;
		DWORD val_size = /*Error: Unsupported expression*/;
		HRESULT hr = new HRESULT();
		 pLGPO = new ();
		// Along with global 'existing_key', this static value is used to restore initial state
		DWORD original_val = new DWORD();
		HKEY path_key = ((Object)0);
		HKEY policy_key = ((Object)0);
		// MSVC is finicky about these ones even if you link against gpedit.lib => redefine them
		IID my_IID_IGroupPolicyObject = new IID(-1024, -1024, -1024, new IID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
		IID my_CLSID_GroupPolicyObject = new IID(-1024, -1024, -1024, new IID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
		GUID ext_guid = REGISTRY_EXTENSION_GUID;
		// Can be anything really
		GUID snap_guid = new GUID(-1024, -1024, -1024, new GUID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
		// Reinitialize COM since it's not shared between threadsdo {
			(Object)(/*Error: Function owner not recognized*/CoInitializeEx(((Object)0), tagCOINIT.COINIT_APARTMENTTHREADED));
		} while (0);
		// We need an IGroupPolicyObject instance to set a Local Group Policy// We need an IGroupPolicyObject instance to set a Local Group Policyhr = /*Error: Function owner not recognized*/CoCreateInstance(my_CLSID_GroupPolicyObject, ((Object)0), tagCLSCTX.CLSCTX_INPROC_SERVER, my_IID_IGroupPolicyObject, (LPVOID)pLGPO);
		if (((HRESULT)(hr) < 0)) {
			do {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "SetLGP: CoCreateInstance failed; hr = %lx", hr);
					(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
				} while (0);
				ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
			} while (0);
			;
		} 
		hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pLGPO, GPO_OPEN_LOAD_REGISTRY);
		if (((HRESULT)(hr) < 0)) {
			do {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "SetLGP: OpenLocalMachineGPO failed - error %lx", hr);
					(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
				} while (0);
				ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
			} while (0);
			;
		} 
		hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pLGPO, GPO_SECTION_MACHINE, path_key);
		if (((HRESULT)(hr) < 0)) {
			do {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "SetLGP: GetRegistryKey failed - error %lx", hr);
					(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
				} while (0);
				ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
			} while (0);
			;
		} 
		Object generatedSzPath = p.getSzPath();
		r = /*Error: Function owner not recognized*/RegCreateKeyExA(path_key, generatedSzPath, 0, ((Object)0), 0, 2 | 1, ((Object)0), policy_key, disp);
		if (r != -1024) {
			do {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "SetLGP: Failed to open LGPO path %s - error %lx", generatedSzPath, hr);
					(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
				} while (0);
				ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
			} while (0);
			policy_key = ((Object)0);
			;
		} 
		Object generatedBRestore = p.getBRestore();
		Object generatedBExistingKey = p.getBExistingKey();
		Object generatedSzPolicy = p.getSzPolicy();
		if ((disp == 2) && (!generatedBRestore) && (!((generatedBExistingKey)))) {
			(generatedBExistingKey) = 1;
			regtype = 4;
			r = /*Error: Function owner not recognized*/RegQueryValueExA(policy_key, generatedSzPolicy, ((Object)0), regtype, (LPBYTE)original_val, val_size);
			if (r == -1024) {
				(generatedBExistingKey) = 0;
			}  else if (r != -1024) {
				do {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "SetLGP: Failed to read original %s policy value - error %lx", generatedSzPolicy, r);
						(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
					} while (0);
					ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
					ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
					ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
					ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
				} while (0);
			} 
		} 
		// backup existing value for restore
		Object generatedDwValue = p.getDwValue();
		if ((!generatedBRestore) || ((generatedBExistingKey))) {
			val = (generatedBRestore) ? original_val : generatedDwValue;
			r = /*Error: Function owner not recognized*/RegSetValueExA(policy_key, generatedSzPolicy, 0, 4, (BYTE)val, /*Error: sizeof expression not supported yet*/);
		} else {
				r = /*Error: Function owner not recognized*/RegDeleteValueA(policy_key, generatedSzPolicy);
		} 
		if (r != -1024) {
			do {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "SetLGP: RegSetValueEx / RegDeleteValue failed - error %lx", r);
					(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
				} while (0);
				ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
			} while (0);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/RegCloseKey(policy_key);
		policy_key = ((Object)0);
		// Apply policy// Apply policyhr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pLGPO, 1, (generatedBRestore) ? 0 : 1, ext_guid, snap_guid);
		if (hr != ((HRESULT)-1024)) {
			do {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "SetLGP: Unable to apply %s policy - error %lx", generatedSzPolicy, hr);
					(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
				} while (0);
				ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
			} while (0);
			;
		} else {
				if ((!generatedBRestore) || ((generatedBExistingKey))) {
					do {
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "SetLGP: Successfully %s %s policy to 0x%08lX", (generatedBRestore) ? "restored" : "set", generatedSzPolicy, val);
							(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
						} while (0);
						ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
						ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
						ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
						ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
					} while (0);
				} else {
						do {
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "SetLGP: Successfully removed %s policy key", generatedSzPolicy);
								(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
							} while (0);
							ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
							ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
							ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
							ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
						} while (0);
				} 
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/RegCloseKey(path_key);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pLGPO);
		return 1;
		if (pLGPO != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pLGPO);
		} 
		return 0;
	}
	public static Object SetLGP(Object bRestore, Object bExistingKey, Object szPath, Object szPolicy, Object dwValue) {
		SetLGP_Params params = new SetLGP_Params(bRestore, bExistingKey, szPath, szPolicy, dwValue);
		DWORD r = 0;
		HANDLE thread_id = new HANDLE();
		if (ModernizedCProgram.ReadSettingBool("DisableLGP")) {
			do {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "LPG handling disabled, per settings");
					(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
				} while (0);
				ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
			} while (0);
			return 0;
		} 
		thread_id = /*Error: Function owner not recognized*/CreateThread(((Object)0), 0, SetLGPThread, (LPVOID)params, 0, ((Object)0));
		if (thread_id == ((Object)0)) {
			do {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "SetLGP: Unable to start thread");
					(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
				} while (0);
				ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
			} while (0);
			return 0;
		} 
		if (/*Error: Function owner not recognized*/WaitForSingleObject(thread_id, 5000) != 0) {
			do {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "SetLGP: Killing stuck thread!");
					(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
				} while (0);
				ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
			} while (0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/TerminateThread(thread_id, 0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(thread_id);
			return 0;
		} 
		if (!/*Error: Function owner not recognized*/GetExitCodeThread(thread_id, r)) {
			return 0;
		} 
		return (BOOL)r/*
		 * This call tries to evenly balance the affinities for an array of
		 * num_threads, according to the number of cores at our disposal...
		 */;
	}
	public static Object SetThreadAffinity(Object[] thread_affinity, Object num_threads) {
		size_t i = new size_t();
		size_t j = new size_t();
		size_t pc = new size_t();
		DWORD_PTR affinity = new DWORD_PTR();
		DWORD_PTR dummy = new DWORD_PTR();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(thread_affinity, 0, num_threads * /*Error: Unsupported expression*/);
		if (!/*Error: Function owner not recognized*/GetProcessAffinityMask(/*Error: Function owner not recognized*/GetCurrentProcess(), affinity, dummy)) {
			return 0;
		} 
		do {
			if (ModernizedCProgram.usb_debug) {
				ModernizedCProgram._uprintf("\r\nThread affinities:");
			} 
		} while (0);
		do {
			if (ModernizedCProgram.usb_debug) {
				ModernizedCProgram._uprintf("  avail:\t%s", ModernizedCProgram._printbits(/*Error: sizeof expression not supported yet*/, affinity, 1));
			} 
		} while (0);
		// If we don't have enough virtual cores to evenly spread our load forget it// If we don't have enough virtual cores to evenly spread our load forget itpc = ModernizedCProgram.popcnt64(affinity);
		if (pc < num_threads) {
			return 0;
		} 
		// Spread the affinity as evenly as we can// Spread the affinity as evenly as we canthread_affinity[num_threads - 1] = affinity;
		for (i = 0; i < num_threads - 1; i++) {
			for (j = 0; j < pc / num_threads; j++) {
				thread_affinity[i] |=  affinity & (--1024 * affinity);
				affinity ^=  affinity & (--1024 * affinity);
			}
			do {
				if (ModernizedCProgram.usb_debug) {
					ModernizedCProgram._uprintf("  thr_%d:\t%s", i, ModernizedCProgram._printbits(/*Error: sizeof expression not supported yet*/, thread_affinity[i], 1));
				} 
			} while (0);
			thread_affinity[num_threads - 1] ^=  thread_affinity[i];
		}
		do {
			if (ModernizedCProgram.usb_debug) {
				ModernizedCProgram._uprintf("  thr_%d:\t%s", i, ModernizedCProgram._printbits(/*Error: sizeof expression not supported yet*/, thread_affinity[i], 1));
			} 
		} while (0);
		return 1/*
		 * Returns true if:
		 * 1. The OS supports UAC, UAC is on, and the current process runs elevated, or
		 * 2. The OS doesn't support UAC or UAC is off, and the process is being run by a member of the admin group
		 */;
	}
	public static Object IsCurrentProcessElevated() {
		BOOL r = 0;
		DWORD size = new DWORD();
		HANDLE token = (HANDLE)(true);
		 te = new ();
		SID_IDENTIFIER_AUTHORITY auth = new SID_IDENTIFIER_AUTHORITY(new SID_IDENTIFIER_AUTHORITY(0, 0, 0, 0, 0, 5));
		PSID psid = new PSID();
		if (ModernizedCProgram.ReadRegistryKey32(((HKEY)-1024), "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\EnableLUA") == 1) {
			ModernizedCProgram._uprintf("Note: UAC is active");
			if (!/*Error: Function owner not recognized*/OpenProcessToken(/*Error: Function owner not recognized*/GetCurrentProcess(), (true), token)) {
				ModernizedCProgram._uprintf("Could not get current process token: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			if (!/*Error: Function owner not recognized*/GetTokenInformation(token, TokenElevation, te, /*Error: sizeof expression not supported yet*/, size)) {
				ModernizedCProgram._uprintf("Could not get token information: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			r = (te.getTokenIsElevated() != 0);
		} else {
				ModernizedCProgram._uprintf("Note: UAC is either disabled or not available");
				if (!/*Error: Function owner not recognized*/AllocateAndInitializeSid(auth, 2, 32, -1024, 0, 0, 0, 0, 0, 0, psid)) {
					;
				} 
				if (!/*Error: Function owner not recognized*/CheckTokenMembership(((Object)0), psid, r)) {
					r = 0;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/FreeSid(psid);
		} 
		return r;
	}
	public static Byte GetCurrentMUI() {
		byte[] mui_str = new byte[LOCALE_NAME_MAX_LENGTH];
		wchar_t[] wmui_str = new wchar_t();
		if (/*Error: Function owner not recognized*/LCIDToLocaleName(/*Error: Function owner not recognized*/GetUserDefaultUILanguage(), wmui_str, LOCALE_NAME_MAX_LENGTH, 0) > 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wmui_str, -1, mui_str, LOCALE_NAME_MAX_LENGTH, ((Object)0), ((Object)0));
		} else {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(mui_str, "en-US", (((size_t)(((((byte)"en-US") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("en-US")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"en-US") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("en-US")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)mui_str)[(((size_t)(((((byte)"en-US") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("en-US")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"en-US") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("en-US")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
		} 
		return mui_str;
	}
	/* vi: set sw=4 ts=4: */
	/*
	 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
	 */
	/*  If we are reading through a pipe, or from stdin then we can't lseek,
	 *  we must read and discard the data to skip over it.
	 */
	public static void seek_by_read(int fd, Object amount) {
		if (amount) {
			do {
				if (ModernizedCProgram.bled_printf != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Not implemented");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Not implemented");
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
				} 
			} while (0);
		} 
	}
	/* vi: set sw=4 ts=4: */
	/*
	 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
	 */
	public static void seek_by_jump(int fd, Object amount) {
		if (amount && /*Error: Function owner not recognized*/lseek(fd, amount, 1) == (off_t)-1) {
			if ((/*Error: Function owner not recognized*/_errno()) == 29) {
				ModernizedCProgram.seek_by_read(fd, amount);
			} else {
					do {
						do {
							if (ModernizedCProgram.bled_printf != ((Object)0)) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: seek failure");
							} else {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: seek failure");
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
							} 
						} while (0);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/longjmp(ModernizedCProgram.bb_error_jmp, 1);
					} while (0);
			} 
		} 
	}
	/******************************************************************
	    Copyright (C) 2009  Henrik Carlqvist
	
	    This program is free software; you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation; either version 2 of the License, or
	    (at your option) any later version.
	
	    This program is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with this program; if not, write to the Free Software
	    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
	******************************************************************/
	public static int is_fat_12_fs() {
		byte szMagic = "FAT12   ";
		return fp.contains_data(-1024, szMagic, /*Error: Function owner not recognized*/strlen(szMagic/* is_fat_12_fs */));
	}
	public static int entire_fat_12_br_matches() {
		byte[] br_fat12_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat12_0x3e = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.contains_data(-1024, br_fat12_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat12_0x3e, /*Error: sizeof expression not supported yet*/));
	}
	public static int write_fat_12_br(int bKeepLabel) {
		byte[] label_11_char = new byte[]{(byte)'N', (byte)'O', (byte)' ', (byte)'N', (byte)'A', (byte)'M', (byte)'E', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		byte[] br_fat12_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat12_0x3e = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		if (bKeepLabel) {
			return (fp.write_data(-1024, br_fat12_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat12_0x3e, /*Error: sizeof expression not supported yet*/));
		} else {
				return (fp.write_data(-1024, br_fat12_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, label_11_char, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat12_0x3e, /*Error: sizeof expression not supported yet*/));
		} 
	}
	public static void SetDialogFocus(Object hDlg, Object hCtrl) {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hDlg, 40, (WPARAM)hCtrl, 1/*
		 * We need a sub-callback to read the content of the edit box on exit and update
		 * our path, else if what the user typed does match the selection, it is discarded.
		 * Talk about a convoluted way of producing an intuitive folder selection dialog
		 */);
	}
	public static Object BrowseDlgCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		switch (message) {
		case 2:
				ModernizedCProgram.GetWindowTextU(ModernizedCProgram.hBrowseEdit, ModernizedCProgram.szFolderPath, /*Error: sizeof expression not supported yet*/);
				break;
		}
		return (INT)/*Error: Function owner not recognized*/CallWindowProcA(ModernizedCProgram.pOrgBrowseWndproc, hDlg, message, wParam, lParam/*
		 * Main BrowseInfo callback to set the initial directory and populate the edit control
		 */);
	}
	public static Object BrowseInfoCallback(Object hDlg, Object message, Object lParam, Object pData) {
		byte[] dir = new byte[260];
		wchar_t wpath = new wchar_t();
		LPITEMIDLIST pidl = new LPITEMIDLIST();
		switch (message) {
		case 1:
				ModernizedCProgram.pOrgBrowseWndproc = (WNDPROC)/*Error: Function owner not recognized*/SetWindowLongA(hDlg, (true), (LONG_PTR)BrowseDlgCallback);
				ModernizedCProgram.hBrowseEdit = /*Error: Function owner not recognized*/FindWindowExA(hDlg, ((Object)0), "Edit", ((Object)0));
				ModernizedCProgram.SetWindowTextU(ModernizedCProgram.hBrowseEdit, ModernizedCProgram.szFolderPath);
				ModernizedCProgram.SetDialogFocus(hDlg, ModernizedCProgram.hBrowseEdit);
				wpath = ModernizedCProgram.utf8_to_wchar(ModernizedCProgram.szFolderPath);
				pidl = /*Error: Function owner not recognized*/SHSimpleIDListFromPath(wpath);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wpath);
					wpath = ((Object)0);
				} while (0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageW(hDlg, (1024 + 102), (WPARAM)0, (LPARAM)pidl);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(100);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageW(hDlg, (1024 + 102), (WPARAM)0, (LPARAM)pidl);
				break;
		case 2:
				if (ModernizedCProgram.SHGetPathFromIDListU((LPITEMIDLIST)lParam, dir)) {
					ModernizedCProgram.SendMessageLU(hDlg, (1024 + 100), 0, dir);
					ModernizedCProgram.SetWindowTextU(ModernizedCProgram.hBrowseEdit, dir);
				} 
				break;
		}
		return 0/*
		 * Browse for a folder and update the folder edit box
		 */;
	}
	public static void BrowseForFolder() {
		BROWSEINFOW bi = new BROWSEINFOW();
		LPITEMIDLIST pidl = new LPITEMIDLIST();
		WCHAR wpath = new WCHAR();
		size_t i = new size_t();
		HRESULT hr = new HRESULT();
		 psi = ((Object)0);
		// Automatically freed si_path = ((Object)0);
		 pfod = ((Object)0);
		WCHAR fname = new WCHAR();
		byte tmp_path = ((Object)0);
		ModernizedCProgram.dialog_showing++;
		hr = /*Error: Function owner not recognized*/CoCreateInstance(CLSID_FileOpenDialog, ((Object)0), (tagCLSCTX.CLSCTX_INPROC_SERVER | tagCLSCTX.CLSCTX_INPROC_HANDLER), IID_IFileOpenDialog, (LPVOID)pfod);
		if (((HRESULT)(hr) < 0)) {
			ModernizedCProgram._uprintf("CoCreateInstance for FileOpenDialog failed: error %X\n", hr);
			pfod = ((Object)0);
			;
		} 
		hr = /*Error: Function owner not recognized*/IFileOpenDialog_SetOptions(pfod, FOS_PICKFOLDERS);
		if (((HRESULT)(hr) < 0)) {
			ModernizedCProgram._uprintf("Failed to set folder option for FileOpenDialog: error %X\n", hr);
			;
		} 
		// Set the initial folder (if the path is invalid, will simply use last)// Set the initial folder (if the path is invalid, will simply use last)wpath = ModernizedCProgram.utf8_to_wchar(ModernizedCProgram.szFolderPath)// The new IFileOpenDialog makes us split the path;// The new IFileOpenDialog makes us split the path
		fname = ((Object)0);
		if ((wpath != ((Object)0)) && (/*Error: Function owner not recognized*/wcslen(wpath) >= 1)) {
			for (i = /*Error: Function owner not recognized*/wcslen(wpath) - 1; i != 0; i--) {
				if (wpath[i] == (byte)L'\\') {
					wpath[i] = 0;
					fname = wpath[i + 1];
					break;
				} 
			}
		} 
		hr = /*Error: Function owner not recognized*/SHCreateItemFromParsingName(wpath, ((Object)0), IID_IShellItem, (LPVOID)si_path);
		if (((HRESULT)(hr) >= 0)) {
			if (wpath != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IFileOpenDialog_SetFolder(pfod, si_path);
			} 
			if (fname != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IFileOpenDialog_SetFileName(pfod, fname);
			} 
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wpath);
			wpath = ((Object)0);
		} while (0);
		hr = /*Error: Function owner not recognized*/IFileOpenDialog_Show(pfod, ModernizedCProgram.hMainDialog);
		if (((HRESULT)(hr) >= 0)) {
			hr = /*Error: Function owner not recognized*/IFileOpenDialog_GetResult(pfod, psi);
			if (((HRESULT)(hr) >= 0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IShellItem_GetDisplayName(psi, SIGDN_FILESYSPATH, wpath);
				tmp_path = ModernizedCProgram.wchar_to_utf8(wpath);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CoTaskMemFree(wpath);
				if (tmp_path == ((Object)0)) {
					ModernizedCProgram._uprintf("Could not convert path\n");
				} else {
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.szFolderPath, tmp_path, (((size_t)(((((byte)tmp_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp_path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)tmp_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp_path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
							((byte)ModernizedCProgram.szFolderPath)[(((size_t)(((((byte)tmp_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp_path)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)tmp_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp_path)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
						} while (0);
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)tmp_path);
							tmp_path = ((Object)0);
						} while (0);
				} 
			} else {
					ModernizedCProgram._uprintf("Failed to set folder option for FileOpenDialog: error %X\n", hr);
			} 
		}  else if ((hr & -1024) != -1024) {
			ModernizedCProgram._uprintf("Could not show FileOpenDialog: error %X\n", hr);
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IFileOpenDialog_Release(pfod);
		ModernizedCProgram.dialog_showing--;
		return /*Error: Unsupported expression*/;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(bi, 0, /*Error: Unsupported expression*/);
		bi.setHwndOwner(ModernizedCProgram.hMainDialog);
		bi.setLpszTitle(ModernizedCProgram.utf8_to_wchar(ModernizedCProgram.lmprintf(3106)));
		bi.setLpfn(BrowseInfoCallback)// BIF_NONEWFOLDERBUTTON = 0x00000200 is unknown on MinGW;// BIF_NONEWFOLDERBUTTON = 0x00000200 is unknown on MinGW
		bi.setUlFlags(8 | 1 | 2 | 16 | -1024);
		pidl = /*Error: Function owner not recognized*/SHBrowseForFolderW(bi);
		if (pidl != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CoTaskMemFree(pidl);
		} 
		Object generatedLpszTitle = bi.getLpszTitle();
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)generatedLpszTitle);
			bi.setLpszTitle(((Object)0));
		} while (0);
		ModernizedCProgram.dialog_showing/*
		 * Return the UTF8 path of a file selected through a load or save dialog
		 * All string parameters are UTF-8
		 * IMPORTANT NOTE: Remember that you need to call CoInitializeEx() for
		 * *EACH* thread you invoke FileDialog from, as GetDisplayName() will
		 * return error 0x8001010E otherwise.
		 */--;
	}
	public static Byte FileDialog(Object save, Byte path, Object ext, Object options) {
		DWORD tmp = new DWORD();
		OPENFILENAMEA ofn = new OPENFILENAMEA();
		byte[] selected_name = new byte[260];
		byte ext_string = ((Object)0);
		byte all_files = ((Object)0);
		size_t i = new size_t();
		size_t j = new size_t();
		size_t ext_strlen = new size_t();
		BOOL r = new BOOL();
		byte filepath = ((Object)0);
		HRESULT hr = 0;
		 pfd = ((Object)0);
		 psiResult = new ();
		 filter_spec = ((Object)0);
		wchar_t wpath = ((Object)0);
		wchar_t wfilename = ((Object)0);
		// Automatically freed si_path = ((Object)0);
		if ((ext == ((Object)0)) || (ext.getCount() == 0) || (ext.getExtension() == ((Object)0)) || (ext.getDescription() == ((Object)0))) {
			return ((Object)0);
		} 
		ModernizedCProgram.dialog_showing++;
		filter_spec = ()/*Error: Function owner not recognized*/calloc(ext.getCount() + 1, /*Error: Unsupported expression*/);
		if (filter_spec != ((Object)0)) {
			for (i = 0; i < ext.getCount(); i++) {
				filter_spec[i].setPszSpec(ModernizedCProgram.utf8_to_wchar(ext.getExtension()[i]));
				filter_spec[i].setPszName(ModernizedCProgram.utf8_to_wchar(ext.getDescription()[i]));
			}
			filter_spec[i].setPszSpec(L"*.*");
			filter_spec[i].setPszName(ModernizedCProgram.utf8_to_wchar(ModernizedCProgram.lmprintf(3107)));
			hr = /*Error: Function owner not recognized*/CoCreateInstance(save ? CLSID_FileSaveDialog : CLSID_FileOpenDialog, ((Object)0), (tagCLSCTX.CLSCTX_INPROC_SERVER | tagCLSCTX.CLSCTX_INPROC_HANDLER), IID_IFileDialog, (LPVOID)pfd);
			if (((HRESULT)(hr) < 0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
				ModernizedCProgram._uprintf("CoCreateInstance for FileOpenDialog failed: %s\n", ModernizedCProgram.WindowsErrorString());
				pfd = ((Object)0);
				;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IFileDialog_SetFileTypes(pfd, (UINT)ext.getCount() + 1, filter_spec);
			if (path == ((Object)0)) {
				GUID download_dir_guid = new GUID(-1024, -1024, -1024, new GUID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
				hr = /*Error: Function owner not recognized*/SHGetKnownFolderPath(download_dir_guid, 0, 0, wpath);
				if (((HRESULT)(hr) >= 0)) {
					hr = /*Error: Function owner not recognized*/SHCreateItemFromParsingName(wpath, ((Object)0), IID_IShellItem, (LPVOID)si_path);
					if (((HRESULT)(hr) >= 0)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IFileDialog_SetDefaultFolder(pfd, si_path);
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CoTaskMemFree(wpath);
				} 
			} else {
					wpath = ModernizedCProgram.utf8_to_wchar(path);
					hr = /*Error: Function owner not recognized*/SHCreateItemFromParsingName(wpath, ((Object)0), IID_IShellItem, (LPVOID)si_path);
					if (((HRESULT)(hr) >= 0)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IFileDialog_SetFolder(pfd, si_path);
					} 
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wpath);
						wpath = ((Object)0);
					} while (0);
			} 
			wfilename = ModernizedCProgram.utf8_to_wchar((ext.getFilename() == ((Object)0)) ? "" : ext.getFilename());
			if (wfilename != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IFileDialog_SetFileName(pfd, wfilename);
			} 
			hr = /*Error: Function owner not recognized*/IFileDialog_Show(pfd, ModernizedCProgram.hMainDialog);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wfilename);
				wfilename = ((Object)0);
			} while (0);
			for (i = 0; i < ext.getCount(); i++) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)filter_spec[i].getPszSpec());
					filter_spec[i].setPszSpec(((Object)0));
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)filter_spec[i].getPszName());
					filter_spec[i].setPszName(((Object)0));
				} while (0);
			}
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)filter_spec[i].getPszName());
				filter_spec[i].setPszName(((Object)0));
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)filter_spec);
				filter_spec = ((Object)0);
			} while (0);
			if (((HRESULT)(hr) >= 0)) {
				hr = /*Error: Function owner not recognized*/IFileDialog_GetResult(pfd, psiResult);
				if (((HRESULT)(hr) >= 0)) {
					hr = /*Error: Function owner not recognized*/IShellItem_GetDisplayName(psiResult, SIGDN_FILESYSPATH, wpath);
					if (((HRESULT)(hr) >= 0)) {
						filepath = ModernizedCProgram.wchar_to_utf8(wpath);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CoTaskMemFree(wpath);
					} else {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
							ModernizedCProgram._uprintf("Unable to access file path: %s\n", ModernizedCProgram.WindowsErrorString());
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IShellItem_Release(psiResult);
				} 
			}  else if ((hr & -1024) != -1024) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
				ModernizedCProgram._uprintf("Could not show FileOpenDialog: %s\n", ModernizedCProgram.WindowsErrorString());
				;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IFileDialog_Release(pfd);
			ModernizedCProgram.dialog_showing--;
			return filepath;
		} 
		// Setup the file extension filter table
		if (pfd != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IFileDialog_Release(pfd);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ofn, 0, /*Error: sizeof expression not supported yet*/);
		ofn.setLStructSize(/*Error: sizeof expression not supported yet*/);
		ofn.setHwndOwner(ModernizedCProgram.hMainDialog)// Selected File name;// Selected File name
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(selected_name, /*Error: sizeof expression not supported yet*/, "%s", (ext.getFilename() == ((Object)0)) ? "" : ext.getFilename());
			(selected_name)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		ofn.setLpstrFile(selected_name);
		ofn.setNMaxFile(260)// Set the file extension filters;// Set the file extension filters
		all_files = ModernizedCProgram.lmprintf(3107);
		ext_strlen = 0;
		for (i = 0; i < ext.getCount(); i++) {
			ext_strlen += ((((byte)ext.getDescription()[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext.getDescription()[i])) + 2 * ((((byte)ext.getExtension()[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext.getExtension()[i])) + /*Error: sizeof expression not supported yet*/;
		}
		ext_strlen += ((((byte)all_files) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(all_files)) + /*Error: sizeof expression not supported yet*/;
		ext_string = (byte)/*Error: Function owner not recognized*/malloc(ext_strlen + 1);
		if (ext_string == ((Object)0)) {
			return ((Object)0);
		} 
		ext_string[0] = 0;
		for (; i < ext.getCount(); i++) {
			j += /*Error: Function owner not recognized*/_snprintf(ext_string[j], ext_strlen - j, "%s (%s)\r%s\r", ext.getDescription()[i], ext.getExtension()[i], ext.getExtension()[i]);
		}
		j = /*Error: Function owner not recognized*/_snprintf(ext_string[j], ext_strlen - j, "%s (*.*)\r*.*\r", all_files)// Microsoft could really have picked a better delimiter!;// Microsoft could really have picked a better delimiter!
		for (i = 0; i < ext_strlen; i++) {
			if (ext_string[i] == (byte)'\r') {
				ext_string[i] = 0;
			} 
		}// Since the VS Code Analysis tool is dumb...
		ofn.setLpstrFilter(ext_string);
		ofn.setNFilterIndex(1);
		ofn.setLpstrInitialDir(path);
		ofn.setFlags(2 | options)// Show Dialog;// Show Dialog
		if (save) {
			r = ModernizedCProgram.GetOpenSaveFileNameU(ofn, 1);
		} else {
				r = ModernizedCProgram.GetOpenSaveFileNameU(ofn, 0);
		} 
		if (r) {
			filepath = /*Error: Function owner not recognized*/_strdup(selected_name);
		} else {
				tmp = /*Error: Function owner not recognized*/CommDlgExtendedError();
				if (tmp != 0) {
					ModernizedCProgram._uprintf("Could not select file for %s. Error %X\n", save ? "save" : "open", tmp);
				} 
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ext_string);
			ext_string = ((Object)0);
		} while (0);
		ModernizedCProgram.dialog_showing--;
		return filepath/*
		 * Create the application status bar
		 */;
	}
	public static void CreateStatusBar() {
		RECT rect = new RECT();
		int[] edge = new int[2];
		HFONT hFont = new HFONT();
		// Create the status bar// Create the status barModernizedCProgram.hStatus = /*Error: Function owner not recognized*/CreateWindowExA(0, "msctls_statusbar32", ((Object)0), -1024 | -1024 | SBARS_TOOLTIPS, -1024, -1024, -1024, -1024, ModernizedCProgram.hMainDialog, (HMENU)1006, ModernizedCProgram.hMainInstance, ((Object)0));
		/*Error: Function owner not recognized*/// Create 2 status areas/*Error: Function owner not recognized*/// Create 2 status areasGetClientRect(ModernizedCProgram.hMainDialog, rect);
		Object generatedRight = rect.getRight();
		edge[0] = generatedRight - (int)(58.0 * ModernizedCProgram.fScale);
		edge[1] = generatedRight;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hStatus, (1024 + 4), (WPARAM)(/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), (LPARAM)edge);
		// Set the font// Set the fonthFont = /*Error: Function owner not recognized*/CreateFontA(-/*Error: Function owner not recognized*/MulDiv(9, /*Error: Function owner not recognized*/GetDeviceCaps(/*Error: Function owner not recognized*/GetDC(ModernizedCProgram.hMainDialog), 90), 72), 0, 0, 0, 500, 0, 0, 0, 1, 0, 0, 2, 0, "Segoe UI");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hStatus, 48, (WPARAM)hFont, 1/*
		 * Center a dialog with regards to the main application Window or the desktop
		 * See https://docs.microsoft.com/en-gb/windows/desktop/dlgbox/using-dialog-boxes#initializing-a-dialog-box
		 */);
	}
	public static void CenterDialog(Object hDlg, Object hParent) {
		RECT rc = new RECT();
		RECT rcDlg = new RECT();
		RECT rcParent = new RECT();
		if (hParent == ((Object)0)) {
			hParent = /*Error: Function owner not recognized*/GetParent(hDlg);
		} 
		if (hParent == ((Object)0)) {
			hParent = /*Error: Function owner not recognized*/GetDesktopWindow();
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hParent, rcParent);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hDlg, rcDlg);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CopyRect(rc, rcParent)// Offset the parent and dialog box rectangles so that right and bottom;// Offset the parent and dialog box rectangles so that right and bottom
		Object generatedLeft = rcDlg.getLeft();
		Object generatedTop = rcDlg.getTop();
		/*Error: Function owner not recognized*/// values represent the width and height, and then offset the parent again// to discard space taken up by the dialog box./*Error: Function owner not recognized*/// values represent the width and height, and then offset the parent again// to discard space taken up by the dialog box.OffsetRect(rcDlg, -generatedLeft, -generatedTop);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/OffsetRect(rc, -generatedLeft, -generatedTop);
		Object generatedRight = rcDlg.getRight();
		Object generatedBottom = rcDlg.getBottom();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/OffsetRect(rc, -generatedRight, -generatedBottom);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hDlg, ((HWND)0), generatedLeft + (generatedRight / 2), generatedTop + (generatedBottom / 2) - 25, 0, 0, -1024);
	}
	// http://stackoverflow.com/questions/431470/window-border-width-and-height-in-win32-how-do-i-get-it
	public static tagSIZE GetBorderSize(Object hDlg) {
		RECT rect = new RECT(0, 0, 0, 0);
		SIZE size = new SIZE(0, 0);
		WINDOWINFO wi = new WINDOWINFO();
		wi.setCbSize(/*Error: Unsupported expression*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowInfo(hDlg, wi);
		Object generatedDwStyle = wi.getDwStyle();
		Object generatedDwExStyle = wi.getDwExStyle();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/AdjustWindowRectEx(rect, generatedDwStyle, 0, generatedDwExStyle);
		Object generatedRight = rect.getRight();
		Object generatedLeft = rect.getLeft();
		size.setCx(generatedRight - generatedLeft);
		Object generatedBottom = rect.getBottom();
		Object generatedTop = rect.getTop();
		size.setCy(generatedBottom - generatedTop);
		return size;
	}
	public static void ResizeMoveCtrl(Object hDlg, Object hCtrl, int dx, int dy, int dw, int dh, double scale) {
		RECT rect = new RECT();
		POINT point = new POINT();
		SIZE border = new SIZE();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rect);
		Object generatedRight = rect.getRight();
		Object generatedLeft = rect.getLeft();
		point.setX((ModernizedCProgram.right_to_left_mode && (hDlg != hCtrl)) ? generatedRight : generatedLeft);
		Object generatedTop = rect.getTop();
		point.setY(generatedTop);
		if (hDlg != hCtrl) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ScreenToClient(hDlg, point);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetClientRect(hCtrl, rect);
		// If the control has any borders (dialog, edit box), take them into account// If the control has any borders (dialog, edit box), take them into accountborder = ModernizedCProgram.GetBorderSize(hCtrl);
		Object generatedX = point.getX();
		Object generatedY = point.getY();
		Object generatedCx = border.getCx();
		Object generatedBottom = rect.getBottom();
		Object generatedCy = border.getCy();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MoveWindow(hCtrl, generatedX + (int)(scale * (double)dx), generatedY + (int)(scale * (double)dy), (generatedRight - generatedLeft) + (int)(scale * (double)dw + generatedCx), (generatedBottom - generatedTop) + (int)(scale * (double)dh + generatedCy), 1);
	}
	public static void ResizeButtonHeight(Object hDlg, int id) {
		HWND hCtrl = new HWND();
		HWND hPrevCtrl = new HWND();
		RECT rc = new RECT();
		int dy = 0;
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, id);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		Object generatedBottom = rc.getBottom();
		Object generatedTop = rc.getTop();
		if (generatedBottom - generatedTop < ModernizedCProgram.bh) {
			dy = (ModernizedCProgram.bh - (generatedBottom - generatedTop)) / 2;
		} 
		hPrevCtrl = /*Error: Function owner not recognized*/GetWindow(hCtrl, 3);
		Object generatedLeft = rc.getLeft();
		Object generatedRight = rc.getRight();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, hPrevCtrl, generatedLeft, generatedTop - dy, generatedRight - generatedLeft, ModernizedCProgram.bh, 0/*
		 * License callback
		 */);
	}
	public static Object LicenseCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		LONG_PTR style = new LONG_PTR();
		HWND hLicense = new HWND();
		switch (message) {
		case 273:
				switch (((WORD)((DWORD)(wParam)))) {
				case 2:
						ModernizedCProgram.reset_localization(105);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EndDialog(hDlg, ((WORD)((DWORD)(wParam))));
						return (INT_PTR)1;
				case 1:
				}
		case 272:
				hLicense = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1034);
				ModernizedCProgram.apply_localization(105, hDlg);
				ModernizedCProgram.CenterDialog(hDlg, ((Object)0));
				ModernizedCProgram.ResizeButtonHeight(hDlg, 2);
				style = /*Error: Function owner not recognized*/GetWindowLongA(hLicense, (true));
				style &=  ~(-1024 | -1024 | -1024);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowLongA(hLicense, (true), style);
				style = /*Error: Function owner not recognized*/GetWindowLongA(hLicense, (true));
				style &=  ~(true);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowLongA(hLicense, (true), style);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetDlgItemTextA(hDlg, 1034, ModernizedCProgram.gplv3);
				break;
		}
		return (INT_PTR)0/*
		 * About dialog callback
		 */;
	}
	public static Object AboutCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		int i;
		int dy;
		int[] edit_id = new int[]{1033, 1032};
		byte[] about_blurb = new byte[2048];
		byte[] edit_text = new byte[]{about_blurb, ModernizedCProgram.additional_copyrights};
		HWND[] hEdit = new HWND();
		HWND hCtrl = new HWND();
		TEXTRANGEW tr = new TEXTRANGEW();
		ENLINK enl = new ENLINK();
		RECT rc = new RECT();
		REQRESIZE rsz = new REQRESIZE();
		wchar_t[] wUrl = new wchar_t();
		BOOL resized_already = 1;
		Object generatedBottom = rc.getBottom();
		Object generatedTop = rc.getTop();
		Object generatedLeft = rc.getLeft();
		Object generatedRight = rc.getRight();
		Object generatedMsg = enl.getMsg();
		Object generatedChrg = enl.getChrg();
		Object generatedNmhdr = enl.getNmhdr();
		switch (message) {
		case 272:
				resized_already = 0;
				ModernizedCProgram.apply_localization(102, hDlg);
				ModernizedCProgram.SetTitleBarIcon(hDlg);
				ModernizedCProgram.CenterDialog(hDlg, ((Object)0));
				hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1030);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
				dy = 0;
				if (generatedBottom - generatedTop < ModernizedCProgram.bh) {
					dy = (ModernizedCProgram.bh - (generatedBottom - generatedTop)) / 2;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, ((Object)0), generatedLeft, generatedTop - dy, ((generatedRight - generatedLeft) > (ModernizedCProgram.GetTextSize(hCtrl, ((Object)0)).getCx() + ModernizedCProgram.cbw) ? (generatedRight - generatedLeft) : (ModernizedCProgram.GetTextSize(hCtrl, ((Object)0)).getCx() + ModernizedCProgram.cbw)), ModernizedCProgram.bh, -1024);
				ModernizedCProgram.ResizeButtonHeight(hDlg, 1);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(about_blurb, /*Error: sizeof expression not supported yet*/, ModernizedCProgram.about_blurb_format, ModernizedCProgram.lmprintf(3174 | -1024), ModernizedCProgram.lmprintf(3175 | -1024, ModernizedCProgram.rufus_version[0], ModernizedCProgram.rufus_version[1], ModernizedCProgram.rufus_version[2]), "Copyright Â© 2011-2019 Pete Batard / Akeo", ModernizedCProgram.lmprintf(3176 | -1024), ModernizedCProgram.lmprintf(3177 | -1024), ModernizedCProgram.lmprintf(3178 | -1024));
					(about_blurb)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
					hEdit[i] = /*Error: Function owner not recognized*/GetDlgItem(hDlg, edit_id[i]);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hEdit[i], (1024 + 91), 1, 0/* Can't use SetDlgItemText, because it only works with RichEdit20A... and VS insists
								 * on reverting to RichEdit20W as soon as you edit the dialog. You can try all the W
								 * methods you want, it JUST WON'T WORK unless you use EM_SETTEXTEX. Also see:
								 * http://blog.kowalczyk.info/article/eny/Setting-unicode-rtf-text-in-rich-edit-control.html */);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hEdit[i], (1024 + 97), (WPARAM)ModernizedCProgram.friggin_microsoft_unicode_amateurs, (LPARAM)edit_text[i]);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hEdit[i], 177, -1, -1);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hEdit[i], (1024 + 69), 0, 67108864 | ((i == 0) ? 262144 : 0));
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hEdit[i], (1024 + 67), 0, (LPARAM)/*Error: Function owner not recognized*/GetSysColor(15));
				}
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hEdit[1], 177, 0, 0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hEdit[0], (1024 + 65), 0, 0);
				break;
		case 273:
				switch (((WORD)((DWORD)(wParam)))) {
				case 1030:
						ModernizedCProgram.MyDialogBox(ModernizedCProgram.hMainInstance, 105, hDlg, LicenseCallback);
						break;
				case 1:
				case 2:
						ModernizedCProgram.reset_localization(102);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EndDialog(hDlg, ((WORD)((DWORD)(wParam))));
						return (INT_PTR)1;
				}
				break;
		case 78:
				switch (((LPNMHDR)lParam).getCode()) {
				case 1793:
						if (!resized_already) {
							resized_already = 1;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, edit_id[0]), rc);
							dy = generatedBottom - generatedTop;
							rsz = (REQRESIZE)lParam;
							dy -= generatedBottom - generatedTop;
							ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, edit_id[0]), 0, 0, 0, -dy, 1.0);
							ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, edit_id[1]), 0, -dy, 0, dy, 1.0);
						} 
						break;
				case 1803:
						enl = (ENLINK)lParam;
						if (generatedMsg == 514) {
							tr.setLpstrText(wUrl);
							generatedChrg.setCpMin(generatedChrg.getCpMin());
							generatedChrg.setCpMax(generatedChrg.getCpMax());
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageW(generatedNmhdr.getHwndFrom(), (1024 + 75), 0, (LPARAM)tr);
							wUrl[(/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/) - 1] = 0;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShellExecuteW(hDlg, L"open", wUrl, ((Object)0), ((Object)0), 1);
						} 
						break;
				}
				break;
		}
		return (INT_PTR)0;
	}
	public static Object CreateAboutBox() {
		INT_PTR r = new INT_PTR();
		ModernizedCProgram.dialog_showing++;
		r = ModernizedCProgram.MyDialogBox(ModernizedCProgram.hMainInstance, 102, ModernizedCProgram.hMainDialog, AboutCallback);
		ModernizedCProgram.dialog_showing--;
		return r/*
		 * We use our own MessageBox for notifications to have greater control (center, no close button, etc)
		 */;
	}
	public static Object NotificationCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		LRESULT loc = new LRESULT();
		int i;
		int dh;
		int cbh = 0;
		// Prevent resizing
		LRESULT[] disabled = new LRESULT[]{10, 11, 12, 15, 4, 13, 14, 16, 17};
		HBRUSH background_brush = new HBRUSH();
		HBRUSH separator_brush = new HBRUSH();
		HBRUSH buttonface_brush = new HBRUSH();
		// To use the system message font
		NONCLIENTMETRICS ncm = new NONCLIENTMETRICS();
		HFONT hDlgFont = new HFONT();
		HWND hCtrl = new HWND();
		RECT rc = new RECT();
		HDC hDC = new HDC();
		Object generatedBottom = rc.getBottom();
		Object generatedTop = rc.getTop();
		Object generatedLeft = rc.getLeft();
		Object generatedRight = rc.getRight();
		switch (message) {
		case 312:
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetBkMode((HDC)wParam, 1);
				if ((HWND)lParam == /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1042)) {
					return (INT_PTR)separator_brush;
				} 
				if ((HWND)lParam == /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1059)) {
					return (INT_PTR)buttonface_brush;
				} 
				return (INT_PTR)background_brush;
		case 132:
				loc = /*Error: Function owner not recognized*/DefWindowProcA(hDlg, message, wParam, lParam);
				for (i = 0; i < 9; i++) {
					if (loc == disabled[i]) {
						return (INT_PTR)1;
					} 
				}
				return (INT_PTR)0;
		case 272:
				ncm.setCbSize(/*Error: sizeof expression not supported yet*/);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SystemParametersInfoA(-1024, ncm.getCbSize(), ncm, 0);
				hDlgFont = /*Error: Function owner not recognized*/CreateFontIndirectA((ncm.getLfMessageFont()));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hDlg, 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1041), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1060), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 6), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 7), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				if (ModernizedCProgram.bh != 0) {
					ModernizedCProgram.ResizeButtonHeight(hDlg, 1060);
					ModernizedCProgram.ResizeButtonHeight(hDlg, 6);
					ModernizedCProgram.ResizeButtonHeight(hDlg, 7);
				} 
				ModernizedCProgram.apply_localization(103, hDlg);
				background_brush = /*Error: Function owner not recognized*/CreateSolidBrush(/*Error: Function owner not recognized*/GetSysColor(5));
				separator_brush = /*Error: Function owner not recognized*/CreateSolidBrush(/*Error: Function owner not recognized*/GetSysColor(22));
				buttonface_brush = /*Error: Function owner not recognized*/CreateSolidBrush(/*Error: Function owner not recognized*/GetSysColor(15));
				ModernizedCProgram.SetTitleBarIcon(hDlg);
				ModernizedCProgram.CenterDialog(hDlg, ((Object)0));
				if (((HICON)(UINT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1040)), 368, (WPARAM)(HICON)(ModernizedCProgram.hMessageIcon), 0)) == 0) {
					ModernizedCProgram._uprintf("Could not set dialog icon\n");
				} 
				if (ModernizedCProgram.szMessageTitle != ((Object)0)) {
					ModernizedCProgram.SetWindowTextU(hDlg, ModernizedCProgram.szMessageTitle);
				} 
				if (!ModernizedCProgram.notification_is_question) {
					ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 7), ModernizedCProgram.lmprintf(3006));
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 6), 5);
				} 
				hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1059);
				if (ModernizedCProgram.notification_dont_display_setting != ((Object)0)) {
					ModernizedCProgram.SetWindowTextU(hCtrl, ModernizedCProgram.lmprintf(3127));
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(hCtrl, 0);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
						cbh = generatedBottom - generatedTop;
				} 
				if ((ModernizedCProgram.notification_more_info != ((Object)0)) && (ModernizedCProgram.notification_more_info.getCallback() != ((Object)0))) {
					hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1060);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, ((Object)0), generatedLeft, generatedTop, ((generatedRight - generatedLeft) > (ModernizedCProgram.GetTextSize(hCtrl, ((Object)0)).getCx() + ModernizedCProgram.cbw) ? (generatedRight - generatedLeft) : (ModernizedCProgram.GetTextSize(hCtrl, ((Object)0)).getCx() + ModernizedCProgram.cbw)), generatedBottom - generatedTop, -1024);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(hCtrl, 5);
				} 
				if (ModernizedCProgram.szMessageText != ((Object)0)) {
					hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1041);
					ModernizedCProgram.SetWindowTextU(hCtrl, ModernizedCProgram.szMessageText);
					hDC = /*Error: Function owner not recognized*/GetDC(hCtrl);
					((HFONT)/*Error: Function owner not recognized*/SelectObject((hDC), (HGDIOBJ)(HFONT)(hDlgFont)));
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
					dh = generatedBottom - generatedTop;
					ModernizedCProgram.DrawTextU(hDC, ModernizedCProgram.szMessageText, -1, rc, 1024 | 16);
					dh = ((generatedBottom - generatedTop - dh + (int)(8.0 * ModernizedCProgram.fScale)) > (false) ? (generatedBottom - generatedTop - dh + (int)(8.0 * ModernizedCProgram.fScale)) : (false));
					do {
						if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(hCtrl, hDC);
							hDC = ((Object)0);
						} 
					} while (0);
					ModernizedCProgram.ResizeMoveCtrl(hDlg, hCtrl, 0, 0, 0, dh, 1.0);
					ModernizedCProgram.ResizeMoveCtrl(hDlg, hDlg, 0, 0, 0, dh - cbh, 1.0);
					ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, -1), 0, 0, 0, dh, 1.0);
					ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1076), 0, dh, 0, 0, 1.0);
					ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1059), 0, dh, 0, 0, 1.0);
					ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1060), 0, dh - cbh, 0, 0, 1.0);
					ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 6), 0, dh - cbh, 0, 0, 1.0);
					ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 7), 0, dh - cbh, 0, 0, 1.0);
				} 
				return (INT_PTR)1;
		case 273:
				switch (((WORD)((DWORD)(wParam)))) {
				case 6:
				case 1:
				case 2:
				case 7:
						if (/*Error: Function owner not recognized*/IsDlgButtonChecked(hDlg, 1059) == 1) {
							ModernizedCProgram.WriteSettingBool("DisableSecureBootNotice", 1);
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EndDialog(hDlg, ((WORD)((DWORD)(wParam))));
						return (INT_PTR)1;
				case 1060:
						((ModernizedCProgram.notification_more_info.getCallback() != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("notification_more_info->callback != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\stdlg.c", 792));
						if (ModernizedCProgram.notification_more_info != ((Object)0)) {
							if (ModernizedCProgram.notification_more_info.getId() == -1024) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShellExecuteA(hDlg, "open", ModernizedCProgram.notification_more_info.getUrl(), ((Object)0), ((Object)0), 1);
							} else {
									ModernizedCProgram.MyDialogBox(ModernizedCProgram.hMainInstance, ModernizedCProgram.notification_more_info.getId(), hDlg, ModernizedCProgram.notification_more_info.getCallback());
							} 
						} 
						break;
				}
				break;
		}
		return (INT_PTR)0/*
		 * Display a custom notification
		 */;
	}
	public static Object Notification(int type, Object dont_display_setting, Object more_info, Byte title, Byte format) {
		BOOL ret = new BOOL();
		va_list args = new va_list();
		ModernizedCProgram.dialog_showing++;
		ModernizedCProgram.szMessageText = (byte)/*Error: Function owner not recognized*/malloc(2048);
		if (ModernizedCProgram.szMessageText == ((Object)0)) {
			return 0;
		} 
		ModernizedCProgram.szMessageTitle = /*Error: Function owner not recognized*/_strdup(title);
		if (ModernizedCProgram.szMessageTitle == ((Object)0)) {
			return 0;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(args, format);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/vsnprintf(ModernizedCProgram.szMessageText, 2048 - 1, format, args);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(args);
		ModernizedCProgram.szMessageText[2048 - 1] = 0;
		ModernizedCProgram.notification_more_info = more_info;
		ModernizedCProgram.notification_is_question = 0;
		ModernizedCProgram.notification_dont_display_setting = dont_display_setting;
		switch (type) {
		case notification_type.MSG_QUESTION:
				ModernizedCProgram.hMessageIcon = /*Error: Function owner not recognized*/LoadIconA(((Object)0), (LPSTR)((DWORD)((WORD)(true))));
				ModernizedCProgram.notification_is_question = 1;
				break;
		case notification_type.MSG_WARNING_QUESTION:
				ModernizedCProgram.notification_is_question = 1;
		case notification_type.MSG_INFO:
		case notification_type.MSG_WARNING:
				ModernizedCProgram.hMessageIcon = /*Error: Function owner not recognized*/LoadIconA(((Object)0), (LPSTR)((DWORD)((WORD)(true))));
				break;
		case notification_type.MSG_ERROR:
				ModernizedCProgram.hMessageIcon = /*Error: Function owner not recognized*/LoadIconA(((Object)0), (LPSTR)((DWORD)((WORD)(true))));
				break;
		default:
				ModernizedCProgram.hMessageIcon = /*Error: Function owner not recognized*/LoadIconA(((Object)0), (LPSTR)((DWORD)((WORD)(true))));
				break;
		}
		ret = (ModernizedCProgram.MyDialogBox(ModernizedCProgram.hMainInstance, 103, ModernizedCProgram.hMainDialog, NotificationCallback) == 6);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.szMessageText);
			ModernizedCProgram.szMessageText = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.szMessageTitle);
			ModernizedCProgram.szMessageTitle = ((Object)0);
		} while (0);
		ModernizedCProgram.dialog_showing--;
		return ret/*
		 * Custom dialog for radio button selection dialog
		 */;
	}
	public static Object SelectionCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		LRESULT loc = new LRESULT();
		int i;
		int dh;
		int r = -1;
		// Prevent resizing
		LRESULT[] disabled = new LRESULT[]{10, 11, 12, 15, 4, 13, 14, 16, 17};
		HBRUSH background_brush = new HBRUSH();
		HBRUSH separator_brush = new HBRUSH();
		// To use the system message font
		NONCLIENTMETRICS ncm = new NONCLIENTMETRICS();
		RECT rc = new RECT();
		RECT rc2 = new RECT();
		HFONT hDlgFont = new HFONT();
		HWND hCtrl = new HWND();
		HDC hDC = new HDC();
		Object generatedBottom = rc.getBottom();
		Object generatedTop = rc.getTop();
		switch (message) {
		case 273:
				switch (((WORD)((DWORD)(wParam)))) {
				case 1:
						for (i = 0; (i < ModernizedCProgram.nDialogItems) && (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1077 + i)), 240, 0, 0)) != 1); i++) {
							;
						}
						if (i < ModernizedCProgram.nDialogItems) {
							r = i + 1;
						} 
				case 7:
				case 2:
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EndDialog(hDlg, r);
						return (INT_PTR)1;
				}
				break;
		case 132:
				loc = /*Error: Function owner not recognized*/DefWindowProcA(hDlg, message, wParam, lParam);
				for (i = 0; i < 9; i++) {
					if (loc == disabled[i]) {
						return (INT_PTR)1;
					} 
				}
				return (INT_PTR)0;
		case 272:
				if (ModernizedCProgram.nDialogItems > (1092 - 1077 + 1)) {
					ModernizedCProgram._uprintf("Warning: Too many options requested for Selection (%d vs %d)", ModernizedCProgram.nDialogItems, 1092 - 1077);
					ModernizedCProgram.nDialogItems = 1092 - 1077;
				} 
				ncm.setCbSize(/*Error: sizeof expression not supported yet*/);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SystemParametersInfoA(-1024, ncm.getCbSize(), ncm, 0);
				hDlgFont = /*Error: Function owner not recognized*/CreateFontIndirectA((ncm.getLfMessageFont()));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hDlg, 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1075), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				for (i = 0; i < ModernizedCProgram.nDialogItems; i++) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1077 + i), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				}
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 6), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 7), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				ModernizedCProgram.apply_localization(104, hDlg);
				background_brush = /*Error: Function owner not recognized*/CreateSolidBrush(/*Error: Function owner not recognized*/GetSysColor(5));
				separator_brush = /*Error: Function owner not recognized*/CreateSolidBrush(/*Error: Function owner not recognized*/GetSysColor(22));
				ModernizedCProgram.SetTitleBarIcon(hDlg);
				ModernizedCProgram.CenterDialog(hDlg, ((Object)0));
				((HICON)(UINT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1074)), 368, (WPARAM)(HICON)(/*Error: Function owner not recognized*/LoadIconA(((Object)0), (LPSTR)((DWORD)((WORD)(true))))), 0));
				ModernizedCProgram.SetWindowTextU(hDlg, ModernizedCProgram.szMessageTitle);
				ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), ModernizedCProgram.lmprintf(3007));
				ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1075), ModernizedCProgram.szMessageText);
				for (i = 0; i < ModernizedCProgram.nDialogItems; i++) {
					ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1077 + i), ModernizedCProgram.szDialogItem[i]);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1077 + i), 5);
				}
				hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1075);
				hDC = /*Error: Function owner not recognized*/GetDC(hCtrl);
				((HFONT)/*Error: Function owner not recognized*/SelectObject((hDC), (HGDIOBJ)(HFONT)(hDlgFont)));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
				dh = generatedBottom - generatedTop;
				ModernizedCProgram.DrawTextU(hDC, ModernizedCProgram.szMessageText, -1, rc, 1024 | 16);
				dh = generatedBottom - generatedTop - dh;
				do {
					if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(hCtrl, hDC);
						hDC = ((Object)0);
					} 
				} while (0);
				ModernizedCProgram.ResizeMoveCtrl(hDlg, hCtrl, 0, 0, 0, dh, 1.0);
				for (i = 0; i < ModernizedCProgram.nDialogItems; i++) {
					ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1077 + i), 0, dh, 0, 0, 1.0);
				}
				if (ModernizedCProgram.nDialogItems > 2) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1078), rc);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1077 + ModernizedCProgram.nDialogItems - 1), rc2);
					dh += generatedTop - generatedTop;
				} 
				ModernizedCProgram.ResizeMoveCtrl(hDlg, hDlg, 0, 0, 0, dh, 1.0);
				ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, -1), 0, 0, 0, dh, 1.0);
				ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1076), 0, dh, 0, 0, 1.0);
				ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1), 0, dh, 0, 0, 1.0);
				ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), 0, dh, 0, 0, 1.0);
				ModernizedCProgram.ResizeButtonHeight(hDlg, 1);
				ModernizedCProgram.ResizeButtonHeight(hDlg, 2);
				((Object)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1077)), 241, (WPARAM)(int)(true), 0));
				((Object)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1078)), 241, (WPARAM)(int)(false), 0));
				return (INT_PTR)1;
		case 312:
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetBkMode((HDC)wParam, 1);
				if ((HWND)lParam == /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1042)) {
					return (INT_PTR)separator_brush;
				} 
				return (INT_PTR)background_brush;
		}
		return (INT_PTR)0/*
		 * Display an item selection dialog
		 */;
	}
	public static int SelectionDialog(Byte title, Byte message, Byte choices, int size) {
		int ret;
		ModernizedCProgram.dialog_showing++;
		ModernizedCProgram.szMessageTitle = title;
		ModernizedCProgram.szMessageText = message;
		ModernizedCProgram.szDialogItem = choices;
		ModernizedCProgram.nDialogItems = size;
		ret = (int)ModernizedCProgram.MyDialogBox(ModernizedCProgram.hMainInstance, 104, ModernizedCProgram.hMainDialog, SelectionCallback);
		ModernizedCProgram.dialog_showing--;
		return ret/*
		 * Custom dialog for list dialog
		 */;
	}
	public static Object ListCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		LRESULT loc = new LRESULT();
		int i;
		int dh;
		int r = -1;
		// Prevent resizing
		LRESULT[] disabled = new LRESULT[]{10, 11, 12, 15, 4, 13, 14, 16, 17};
		HBRUSH background_brush = new HBRUSH();
		HBRUSH separator_brush = new HBRUSH();
		// To use the system message font
		NONCLIENTMETRICS ncm = new NONCLIENTMETRICS();
		RECT rc = new RECT();
		RECT rc2 = new RECT();
		HFONT hDlgFont = new HFONT();
		HWND hCtrl = new HWND();
		HDC hDC = new HDC();
		Object generatedBottom = rc.getBottom();
		Object generatedTop = rc.getTop();
		switch (message) {
		case 272:
				if (ModernizedCProgram.nDialogItems > (1111 - 1096 + 1)) {
					ModernizedCProgram._uprintf("Warning: Too many items requested for List (%d vs %d)", ModernizedCProgram.nDialogItems, 1111 - 1096);
					ModernizedCProgram.nDialogItems = 1111 - 1096;
				} 
				ncm.setCbSize(/*Error: sizeof expression not supported yet*/);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SystemParametersInfoA(-1024, ncm.getCbSize(), ncm, 0);
				hDlgFont = /*Error: Function owner not recognized*/CreateFontIndirectA((ncm.getLfMessageFont()));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hDlg, 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1094), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				for (i = 0; i < ModernizedCProgram.nDialogItems; i++) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1096 + i), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				}
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 6), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 7), 48, (WPARAM)hDlgFont, ((LPARAM)((LONG)(((WORD)(true)) | (((DWORD)((WORD)(false))) << 16)))));
				ModernizedCProgram.apply_localization(110, hDlg);
				background_brush = /*Error: Function owner not recognized*/CreateSolidBrush(/*Error: Function owner not recognized*/GetSysColor(5));
				separator_brush = /*Error: Function owner not recognized*/CreateSolidBrush(/*Error: Function owner not recognized*/GetSysColor(22));
				ModernizedCProgram.SetTitleBarIcon(hDlg);
				ModernizedCProgram.CenterDialog(hDlg, ((Object)0));
				((HICON)(UINT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1093)), 368, (WPARAM)(HICON)(/*Error: Function owner not recognized*/LoadIconA(((Object)0), (LPSTR)((DWORD)((WORD)(true))))), 0));
				ModernizedCProgram.SetWindowTextU(hDlg, ModernizedCProgram.szMessageTitle);
				ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), ModernizedCProgram.lmprintf(3007));
				ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1094), ModernizedCProgram.szMessageText);
				for (i = 0; i < ModernizedCProgram.nDialogItems; i++) {
					ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1096 + i), ModernizedCProgram.szDialogItem[i]);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1096 + i), 5);
				}
				hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1094);
				hDC = /*Error: Function owner not recognized*/GetDC(hCtrl);
				((HFONT)/*Error: Function owner not recognized*/SelectObject((hDC), (HGDIOBJ)(HFONT)(hDlgFont)));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
				dh = generatedBottom - generatedTop;
				ModernizedCProgram.DrawTextU(hDC, ModernizedCProgram.szMessageText, -1, rc, 1024 | 16);
				dh = generatedBottom - generatedTop - dh;
				do {
					if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(hCtrl, hDC);
						hDC = ((Object)0);
					} 
				} while (0);
				ModernizedCProgram.ResizeMoveCtrl(hDlg, hCtrl, 0, 0, 0, dh, 1.0);
				for (i = 0; i < ModernizedCProgram.nDialogItems; i++) {
					ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1096 + i), 0, dh, 0, 0, 1.0);
				}
				if (ModernizedCProgram.nDialogItems > 1) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1096), rc);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1096 + ModernizedCProgram.nDialogItems - 1), rc2);
					dh += generatedTop - generatedTop;
				} 
				ModernizedCProgram.ResizeMoveCtrl(hDlg, hDlg, 0, 0, 0, dh, 1.0);
				ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, -1), 0, 0, 0, dh, 1.0);
				ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1095), 0, dh, 0, 0, 1.0);
				ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1), 0, dh, 0, 0, 1.0);
				ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), 0, dh, 0, 0, 1.0);
				ModernizedCProgram.ResizeButtonHeight(hDlg, 1);
				ModernizedCProgram.ResizeButtonHeight(hDlg, 2);
				return (INT_PTR)1;
		case 273:
				switch (((WORD)((DWORD)(wParam)))) {
				case 7:
				case 2:
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EndDialog(hDlg, r);
						return (INT_PTR)1;
				case 1:
				}
				break;
		case 312:
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetBkMode((HDC)wParam, 1);
				if ((HWND)lParam == /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1042)) {
					return (INT_PTR)separator_brush;
				} 
				return (INT_PTR)background_brush;
		case 132:
				loc = /*Error: Function owner not recognized*/DefWindowProcA(hDlg, message, wParam, lParam);
				for (i = 0; i < 9; i++) {
					if (loc == disabled[i]) {
						return (INT_PTR)1;
					} 
				}
				return (INT_PTR)0;
		}
		return (INT_PTR)0/*
		 * Display a dialog with a list of items
		 */;
	}
	public static void ListDialog(Byte title, Byte message, Byte items, int size) {
		ModernizedCProgram.dialog_showing++;
		ModernizedCProgram.szMessageTitle = title;
		ModernizedCProgram.szMessageText = message;
		ModernizedCProgram.szDialogItem = items;
		ModernizedCProgram.nDialogItems = size;
		ModernizedCProgram.MyDialogBox(ModernizedCProgram.hMainInstance, 110, ModernizedCProgram.hMainDialog, ListCallback);
		ModernizedCProgram.dialog_showing--;
	}
	public static Object TooltipCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		LPNMTTDISPINFOW lpnmtdi = new LPNMTTDISPINFOW();
		int i = 128;
		// Make sure we have an original procfor (i = 0; i < 128; i++) {
			if (ttlist[i].getHTip() == hDlg) {
				break;
			} 
		}
		if (i == 128) {
			return (INT_PTR)0;
		} 
		switch (message) {
		case 78:
				switch (((LPNMHDR)lParam).getCode()) {
				case (((UINT)-520) - 10):
						lpnmtdi = (LPNMTTDISPINFOW)lParam;
						lpnmtdi.setLpszText(ttlist[i].getWstring());
						lpnmtdi.getUFlags() &=  ~4;
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hDlg, TTM_SETMAXTIPWIDTH, 0, (LPARAM)(int)(150.0 * ModernizedCProgram.fScale));
						return (INT_PTR)1;
				}
				break;
		}
		return /*Error: Function owner not recognized*/CallWindowProcA(ttlist[i].getOriginal_proc(), hDlg, message, wParam, lParam/*
		 * Create a tooltip for the control passed as first parameter
		 * duration sets the duration in ms. Use -1 for default
		 * message is an UTF-8 string
		 */);
	}
	public static Object CreateTooltip(Object hControl, Object message, int duration) {
		TTTOOLINFOW toolInfo = new TTTOOLINFOW(0);
		int i;
		if ((hControl == ((Object)0)) || (message == ((Object)0))) {
			return 0;
		} 
		// Destroy existing tooltip if any// Destroy existing tooltip if anyModernizedCProgram.DestroyTooltip(hControl);
		// Find an empty slotfor (i = 0; i < 128; i++) {
			if (ttlist[i].getHTip() == ((Object)0)) {
				break;
			} 
		}
		if (i >= 128) {
			ModernizedCProgram._uprintf("Maximum number of tooltips reached (%d)\n", 128);
			return 0;
		} 
		// Create the tooltip window// Create the tooltip windowttlist[i].setHTip(/*Error: Function owner not recognized*/CreateWindowExA(ModernizedCProgram.right_to_left_mode ? -1024 : 0, "tooltips_class32", ((Object)0), -1024 | 2 | 1, -1024, -1024, -1024, -1024, ModernizedCProgram.hMainDialog, ((Object)0), ModernizedCProgram.hMainInstance, ((Object)0)));
		if (ttlist[i].getHTip() == ((Object)0)) {
			return 0;
		} 
		ttlist[i].setHCtrl(hControl);
		// Subclass the tooltip to handle multiline// Subclass the tooltip to handle multilinettlist[i].setOriginal_proc((WNDPROC)/*Error: Function owner not recognized*/SetWindowLongA(ttlist[i].getHTip(), (true), (LONG_PTR)TooltipCallback));
		// Set the string to display (can be multiline)// Set the string to display (can be multiline)ttlist[i].setWstring(ModernizedCProgram.utf8_to_wchar(message));
		/*Error: Function owner not recognized*/// Set tooltip duration (ms)/*Error: Function owner not recognized*/// Set tooltip duration (ms)PostMessageA(ttlist[i].getHTip(), (1024 + 3), (WPARAM)2, (LPARAM)duration);
		// Associate the tooltip to the control// Associate the tooltip to the controltoolInfo.setCbSize(/*Error: sizeof expression not supported yet*/);
		// Set to the tooltip itself to ease up subclassing// Set to the tooltip itself to ease up subclassingtoolInfo.setHwnd(ttlist[i].getHTip());
		toolInfo.setUFlags(1 | 16 | ((ModernizedCProgram.right_to_left_mode) ? 4 : 0))// set TTF_NOTBUTTON and TTF_CENTERTIP if it isn't a button;// set TTF_NOTBUTTON and TTF_CENTERTIP if it isn't a button
		Object generatedUFlags = toolInfo.getUFlags();
		if (!(/*Error: Function owner not recognized*/SendMessageA(hControl, 135, 0, 0) & -1024)) {
			generatedUFlags |=  -1024 | 2;
		} 
		toolInfo.setUId((UINT_PTR)hControl);
		toolInfo.setLpszText(((LPWSTR)-1));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageW(ttlist[i].getHTip(), (1024 + 50), 0, (LPARAM)toolInfo);
		return 1;
	}
	/* Destroy a tooltip. hCtrl = handle of the control the tooltip is associated with */
	public static void DestroyTooltip(Object hControl) {
		int i;
		if (hControl == ((Object)0)) {
			return /*Error: Unsupported expression*/;
		} 
		for (i = 0; i < 128; i++) {
			if (ttlist[i].getHCtrl() == hControl) {
				break;
			} 
		}
		if (i >= 128) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DestroyWindow(ttlist[i].getHTip());
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ttlist[i].getWstring());
			ttlist[i].setWstring(((Object)0));
		} while (0);
		ttlist[i].setOriginal_proc(((Object)0));
		ttlist[i].setHTip(((Object)0));
		ttlist[i].setHCtrl(((Object)0));
	}
	public static void DestroyAllTooltips() {
		int i;
		int j;
		for (; i < 128; i++) {
			if (ttlist[i].getHTip() == ((Object)0)) {
				continue;
			} 
			j++;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DestroyWindow(ttlist[i].getHTip());
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ttlist[i].getWstring());
				ttlist[i].setWstring(((Object)0));
			} while (0);
			ttlist[i].setOriginal_proc(((Object)0));
			ttlist[i].setHTip(((Object)0));
			ttlist[i].setHCtrl(((Object)0));
		}
	}
	/* Determine if a Windows is being displayed or not */
	public static Object IsShown(Object hDlg) {
		WINDOWPLACEMENT placement = new WINDOWPLACEMENT(0);
		placement.setLength(/*Error: Unsupported expression*/);
		if (!/*Error: Function owner not recognized*/GetWindowPlacement(hDlg, placement)) {
			return 0;
		} 
		Object generatedShowCmd = placement.getShowCmd();
		switch (generatedShowCmd) {
		case 1:
		case 10:
				return 1;
		case 3:
		case 5:
		default:
				return 0;
		}
	}
	/* Compute the width of a dropdown list entry */
	public static Object GetEntryWidth(Object hDropDown, Object entry) {
		HDC hDC = new HDC();
		HFONT hFont = new HFONT();
		HFONT hDefFont = ((Object)0);
		SIZE size = new SIZE();
		hDC = /*Error: Function owner not recognized*/GetDC(hDropDown);
		hFont = (HFONT)/*Error: Function owner not recognized*/SendMessageA(hDropDown, 49, 0, 0);
		if (hFont != ((Object)0)) {
			hDefFont = (HFONT)/*Error: Function owner not recognized*/SelectObject(hDC, hFont);
		} 
		if (!ModernizedCProgram.GetTextExtentPointU(hDC, entry, size)) {
			size.setCx(0);
		} 
		if (hFont != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SelectObject(hDC, hDefFont);
		} 
		do {
			if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(hDropDown, hDC);
				hDC = ((Object)0);
			} 
		} while (0);
		Object generatedCx = size.getCx();
		return generatedCx;
	}
	// Create a taskbar icon progressbar
	public static Object CreateTaskbarList() {
		HRESULT hr = new HRESULT();
		hr = /*Error: Function owner not recognized*/CoCreateInstance(CLSID_TaskbarList, ((Object)0), (tagCLSCTX.CLSCTX_INPROC_SERVER | tagCLSCTX.CLSCTX_INPROC_HANDLER | tagCLSCTX.CLSCTX_LOCAL_SERVER), IID_ITaskbarList3, (LPVOID)ModernizedCProgram.ptbl);
		if (((HRESULT)(hr) < 0)) {
			ModernizedCProgram._uprintf("CoCreateInstance for TaskbarList failed: error %X\n", hr);
			ModernizedCProgram.ptbl = ((Object)0);
			return 0;
		} 
		return 1;
	}
	public static Object SetTaskbarProgressState(TASKBAR_PROGRESS_FLAGS tbpFlags) {
		if (ModernizedCProgram.ptbl == ((Object)0)) {
			return 0;
		} 
		return !((HRESULT)(/*Error: Function owner not recognized*/ITaskbarList3_SetProgressState(ModernizedCProgram.ptbl, ModernizedCProgram.hMainDialog, tbpFlags)) < 0);
	}
	public static Object SetTaskbarProgressValue(Object ullCompleted, Object ullTotal) {
		if (ModernizedCProgram.ptbl == ((Object)0)) {
			return 0;
		} 
		return !((HRESULT)(/*Error: Function owner not recognized*/ITaskbarList3_SetProgressValue(ModernizedCProgram.ptbl, ModernizedCProgram.hMainDialog, ullCompleted, ullTotal)) < 0);
	}
	public static void Reposition(Object hDlg, int id, int dx, int dw) {
		HWND hCtrl = new HWND();
		RECT rc = new RECT();
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, id);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		Object generatedLeft = rc.getLeft();
		Object generatedTop = rc.getTop();
		Object generatedRight = rc.getRight();
		Object generatedBottom = rc.getBottom();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, ((HWND)0), generatedLeft + dx, generatedTop, generatedRight - generatedLeft + dw, generatedBottom - generatedTop, 0);
	}
	public static void PositionControls(Object hDlg) {
		RECT rc = new RECT();
		HWND hCtrl = new HWND();
		HWND hPrevCtrl = new HWND();
		// original width, deltaint i;
		int ow;
		int dw;
		/*Error: Function owner not recognized*/// Get the original size of the control/*Error: Function owner not recognized*/// Get the original size of the controlGetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2007), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		Object generatedRight = rc.getRight();
		Object generatedLeft = rc.getLeft();
		ow = generatedRight - generatedLeft;
		dw = ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2007), ((Object)0)).getCx() - ow;
		dw = ((dw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2008), ((Object)0)).getCx() - ow) ? (dw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2008), ((Object)0)).getCx() - ow));
		Object generatedBottom = rc.getBottom();
		Object generatedTop = rc.getTop();
		if (dw > 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hDlg, rc);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hDlg, ((Object)0), -1, -1, generatedRight - generatedLeft + dw, generatedBottom - generatedTop, -1024 | -1024);
			for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
				ModernizedCProgram.Reposition(hDlg, ModernizedCProgram.update_settings_reposition_ids[i], (i < 4) ? 0 : dw, (i >= 4) ? 0 : dw);
			}
		} 
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1062);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ow = generatedRight - generatedLeft;
		dw = ModernizedCProgram.GetTextSize(hCtrl, ModernizedCProgram.lmprintf(3013)).getCx();
		dw = ((dw) > (ModernizedCProgram.GetTextSize(hCtrl, ModernizedCProgram.lmprintf(3030, ModernizedCProgram.lmprintf(3014))).getCx()) ? (dw) : (ModernizedCProgram.GetTextSize(hCtrl, ModernizedCProgram.lmprintf(3030, ModernizedCProgram.lmprintf(3014))).getCx()));
		dw = ((dw) > (ModernizedCProgram.GetTextSize(hCtrl, ModernizedCProgram.lmprintf(3015)).getCx()) ? (dw) : (ModernizedCProgram.GetTextSize(hCtrl, ModernizedCProgram.lmprintf(3015)).getCx()));
		dw = ((dw) > (ModernizedCProgram.GetTextSize(hCtrl, ModernizedCProgram.lmprintf(3016)).getCx()) ? (dw) : (ModernizedCProgram.GetTextSize(hCtrl, ModernizedCProgram.lmprintf(3016)).getCx()));
		dw = ((dw) > (ModernizedCProgram.GetTextSize(hCtrl, ModernizedCProgram.lmprintf(3008)).getCx()) ? (dw) : (ModernizedCProgram.GetTextSize(hCtrl, ModernizedCProgram.lmprintf(3008)).getCx()));
		dw = ((dw) > (ModernizedCProgram.GetTextSize(hCtrl, ModernizedCProgram.lmprintf(3009)).getCx()) ? (dw) : (ModernizedCProgram.GetTextSize(hCtrl, ModernizedCProgram.lmprintf(3009)).getCx()));
		dw -= ow - ModernizedCProgram.ddw;
		if (dw > 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hDlg, rc);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hDlg, ((Object)0), -1, -1, generatedRight - generatedLeft + dw, generatedBottom - generatedTop, -1024 | -1024);
			for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
				if ((i >= 2) && (i <= 3)) {
					continue;
				} 
				ModernizedCProgram.Reposition(hDlg, ModernizedCProgram.update_settings_reposition_ids[i], (i < 6) ? 0 : dw, (i >= 6) ? 0 : dw);
			}
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1066), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ow = generatedRight - generatedLeft;
		dw = ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1066), ((Object)0)).getCx() - ow + ModernizedCProgram.cbw;
		dw = ((dw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), ((Object)0)).getCx() - ow + ModernizedCProgram.cbw) ? (dw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), ((Object)0)).getCx() - ow + ModernizedCProgram.cbw));
		if (dw > 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hDlg, rc);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hDlg, ((Object)0), -1, -1, generatedRight - generatedLeft + dw, generatedBottom - generatedTop, -1024 | -1024);
			for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
				if ((i >= 1) && (i <= 5)) {
					continue;
				} 
				ModernizedCProgram.Reposition(hDlg, ModernizedCProgram.update_settings_reposition_ids[i], 0, dw);
			}
		} 
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1066);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		hPrevCtrl = /*Error: Function owner not recognized*/GetWindow(hCtrl, 3);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, hPrevCtrl, generatedLeft, generatedTop, generatedRight - generatedLeft, ModernizedCProgram.ddbh, 0);
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		hPrevCtrl = /*Error: Function owner not recognized*/GetWindow(hCtrl, 3);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, hPrevCtrl, generatedLeft, generatedTop, generatedRight - generatedLeft, ModernizedCProgram.ddbh, 0/*
		 * Update policy and settings dialog callback
		 */);
	}
	public static Object UpdateCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		int i;
		int dy;
		RECT rect = new RECT();
		REQRESIZE rsz = new REQRESIZE();
		HWND hPolicy = new HWND();
		HWND hFrequency = new HWND();
		HWND hBeta = new HWND();
		int32_t freq = new int32_t();
		byte[] update_policy_text = new byte[4096];
		BOOL resized_already = 1;
		Object generatedBottom = rect.getBottom();
		Object generatedTop = rect.getTop();
		switch (message) {
		case 272:
				resized_already = 0;
				ModernizedCProgram.hUpdatesDlg = hDlg;
				ModernizedCProgram.apply_localization(107, hDlg);
				ModernizedCProgram.PositionControls(hDlg);
				ModernizedCProgram.SetTitleBarIcon(hDlg);
				ModernizedCProgram.CenterDialog(hDlg, ((Object)0));
				hFrequency = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1062);
				hBeta = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1063);
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(hFrequency, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3013)))), (LPARAM)(true))));
				} while (0);
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(hFrequency, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3030, ModernizedCProgram.lmprintf(3014))))), (LPARAM)(true))));
				} while (0);
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(hFrequency, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3015)))), (LPARAM)(true))));
				} while (0);
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(hFrequency, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3016)))), (LPARAM)(true))));
				} while (0);
				freq = ModernizedCProgram.ReadSetting32("UpdateCheckInterval");
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1066), (freq != 0));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(hBeta, (freq >= 0) && ModernizedCProgram.is_x86_32);
				switch (freq) {
				case 86400:
						do {
							(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 334, (WPARAM)(int)(true), 0)));
						} while (0);
						break;
				case -1:
						do {
							(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 334, (WPARAM)(int)(false), 0)));
						} while (0);
						break;
				case 0:
				case 2629800:
						do {
							(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 334, (WPARAM)(int)(true), 0)));
						} while (0);
						break;
				case 604800:
						do {
							(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 334, (WPARAM)(int)(true), 0)));
						} while (0);
						break;
				default:
						do {
							(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(hFrequency, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3017)))), (LPARAM)(freq))));
						} while (0);
						do {
							(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 334, (WPARAM)(int)(true), 0)));
						} while (0);
						break;
				}
				do {
					(Object)(((int)(DWORD)ModernizedCProgram.SendMessageLU(hBeta, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3008))));
				} while (0);
				do {
					(Object)(((int)(DWORD)ModernizedCProgram.SendMessageLU(hBeta, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3009))));
				} while (0);
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hBeta), 334, (WPARAM)(int)((ModernizedCProgram.ReadSettingBool("CheckForBetas") && ModernizedCProgram.is_x86_32) ? 0 : 1), 0)));
				} while (0);
				hPolicy = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1061);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hPolicy, (1024 + 91), 1, 0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(update_policy_text, /*Error: sizeof expression not supported yet*/, ModernizedCProgram.update_policy, ModernizedCProgram.lmprintf(3179 | -1024), ModernizedCProgram.lmprintf(3180 | -1024), ModernizedCProgram.lmprintf(3181 | -1024), ModernizedCProgram.lmprintf(3182 | -1024), ModernizedCProgram.lmprintf(3183 | -1024), ModernizedCProgram.lmprintf(3184 | -1024), ModernizedCProgram.lmprintf(3185 | -1024), ModernizedCProgram.lmprintf(3186 | -1024));
					(update_policy_text)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hPolicy, (1024 + 97), (WPARAM)ModernizedCProgram.friggin_microsoft_unicode_amateurs, (LPARAM)update_policy_text);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hPolicy, 177, -1, -1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hPolicy, (1024 + 69), 0, 67108864 | 262144);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hPolicy, (1024 + 67), 0, (LPARAM)/*Error: Function owner not recognized*/GetSysColor(15));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hPolicy, (1024 + 65), 0, 0);
				break;
		case 78:
				if ((((LPNMHDR)lParam).getCode() == 1793) && (!resized_already)) {
					resized_already = 1;
					hPolicy = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1061);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hPolicy, rect);
					dy = generatedBottom - generatedTop;
					rsz = (REQRESIZE)lParam;
					dy -= generatedBottom - generatedTop + 6;
					ModernizedCProgram.ResizeMoveCtrl(hDlg, hDlg, 0, 0, 0, -dy, 1.0);
					ModernizedCProgram.ResizeMoveCtrl(hDlg, hPolicy, 0, 0, 0, -dy, 1.0);
					for (i = 1; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
						ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, ModernizedCProgram.update_settings_reposition_ids[i]), 0, -dy, 0, 0, 1.0);
					}
				} 
				break;
		case 273:
				switch (((WORD)((DWORD)(wParam)))) {
				case 1062:
						if (((WORD)(((DWORD)(wParam) >> 16) & -1024)) != 1) {
							break;
						} 
						freq = (int32_t)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hFrequency), 327, 0, 0))), 0));
						ModernizedCProgram.WriteSetting32("UpdateCheckInterval", (DWORD)freq);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(hBeta, (freq >= 0));
						return (INT_PTR)1;
				case 1063:
						if (((WORD)(((DWORD)(wParam) >> 16) & -1024)) != 1) {
							break;
						} 
						ModernizedCProgram.WriteSettingBool("CheckForBetas", ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hBeta), 327, 0, 0)) == 0);
						return (INT_PTR)1;
				case 8:
				case 1066:
						ModernizedCProgram.CheckForUpdates(1);
						return (INT_PTR)1;
				case 2:
						ModernizedCProgram.reset_localization(107);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EndDialog(hDlg, ((WORD)((DWORD)(wParam))));
						ModernizedCProgram.hUpdatesDlg = ((Object)0);
						return (INT_PTR)1;
				}
				break;
		}
		return (INT_PTR)0/*
		 * Initial update check setup
		 */;
	}
	public static Object SetUpdateCheck() {
		BOOL enable_updates = new BOOL();
		uint64_t commcheck = /*Error: Function owner not recognized*/GetTickCount64();
		byte[] filename = "";
		byte[] exename = "Rufus.exe";
		size_t fn_len = new size_t();
		size_t exe_len = new size_t();
		// Test if we can read and write settings. If not, forget it.// Test if we can read and write settings. If not, forget it.ModernizedCProgram.WriteSetting64("CommCheck64", commcheck);
		if (ModernizedCProgram.ReadSetting64("CommCheck64") != commcheck) {
			return 0;
		} 
		// If the update interval is not set, this is the first time we run so prompt the userif (ModernizedCProgram.ReadSetting32("UpdateCheckInterval") == 0) {
			notification_info more_info = new notification_info();
			ModernizedCProgram.GetModuleFileNameU(((Object)0), filename, /*Error: sizeof expression not supported yet*/);
			fn_len = ((((byte)filename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(filename));
			exe_len = ((((byte)exename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(exename));
			if ((fn_len > exe_len) && (/*Error: Function owner not recognized*/_stricmp(((filename[fn_len - exe_len] == ((Object)0)) ? "<NULL>" : filename[fn_len - exe_len]), ((exename == ((Object)0)) ? "<NULL>" : exename)) == 0)) {
				ModernizedCProgram._uprintf("Short name used - Disabling initial update policy prompt\n");
				enable_updates = 1;
			} else {
					more_info.setId(107);
					more_info.setCallback(ModernizedCProgram.UpdateCallback);
					enable_updates = ModernizedCProgram.Notification(notification_type.MSG_QUESTION, ((Object)0), more_info, ModernizedCProgram.lmprintf(3004), ModernizedCProgram.lmprintf(3005));
			} 
			if (!enable_updates) {
				ModernizedCProgram.WriteSetting32("UpdateCheckInterval", -1);
				return 0;
			} 
			if ((ModernizedCProgram.ReadSetting32("UpdateCheckInterval") == 0) || ((ModernizedCProgram.ReadSetting32("UpdateCheckInterval") == -1) && enable_updates)) {
				ModernizedCProgram.WriteSetting32("UpdateCheckInterval", 86400);
			} 
		} 
		// - Update check being enabled// - URL for the script being reachableif (((ModernizedCProgram.ReadRegistryKey32(((HKEY)-1024), "Microsoft\\PowerShell\\1\\Install") > 0) || (ModernizedCProgram.ReadRegistryKey32(((HKEY)-1024), "Microsoft\\PowerShell\\3\\Install") > 0)) && (ModernizedCProgram.ReadSetting32("UpdateCheckInterval") > 0)) {
			byte loc = ((Object)0);
			uint64_t loc_len = ModernizedCProgram.DownloadToFileOrBuffer("https://rufus.ie/Fido.ver", ((Object)0), (BYTE)loc, ((Object)0), 0);
			if ((loc_len != 0) && (loc_len < 4 * -1024)) {
				loc_len++;
				ModernizedCProgram.fido_url = ModernizedCProgram.get_token_data_buffer("z1", 1, loc, (size_t)loc_len);
				if (/*Error: Function owner not recognized*/strncmp(((ModernizedCProgram.fido_url == ((Object)0)) ? "<NULL>" : ModernizedCProgram.fido_url), (("https://github.com/pbatard/Fido" == ((Object)0)) ? "<NULL>" : "https://github.com/pbatard/Fido"), 31) != 0) {
					do {
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "WARNING: Download script URL %s is invalid â", ModernizedCProgram.fido_url);
							(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
						} while (0);
						ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
						ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
						ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
						ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
					} while (0);
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.fido_url);
						ModernizedCProgram.fido_url = ((Object)0);
					} while (0);
				} else {
						ModernizedCProgram._uprintf("Fido URL is %s", ModernizedCProgram.fido_url);
						ModernizedCProgram.enable_fido = ModernizedCProgram.IsDownloadable(ModernizedCProgram.fido_url);
				} 
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)loc);
				loc = ((Object)0);
			} while (0);
		} 
		if (!ModernizedCProgram.enable_fido) {
			do {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos], 4096 - ModernizedCProgram.ubuffer_pos - 2, "Notice: The ISO download feature has been deactivated because %s", (ModernizedCProgram.ReadSetting32("UpdateCheckInterval") <= 0) ? "'Check for updates' is disabled in your settings." : "the remote download script can not be accessed.");
					(ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos])[(4096 - ModernizedCProgram.ubuffer_pos - 2) - 1] = 0;
				} while (0);
				ModernizedCProgram.ubuffer_pos = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.ubuffer);
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\r';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos++] = (byte)'\n';
				ModernizedCProgram.ubuffer[ModernizedCProgram.ubuffer_pos] = 0;
			} while (0);
		} 
		return 1;
	}
	public static void CreateStaticFont(Object hDC, Object hFont, Object underlined) {
		TEXTMETRIC tm = new TEXTMETRIC();
		LOGFONT lf = new LOGFONT();
		if (hFont != ((Object)0)) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetTextMetricsA(hDC, tm);
		lf.setLfHeight(tm.getTmHeight());
		lf.setLfWidth(0);
		lf.setLfEscapement(0);
		lf.setLfOrientation(0);
		lf.setLfWeight(tm.getTmWeight());
		lf.setLfItalic(tm.getTmItalic());
		lf.setLfUnderline(underlined);
		lf.setLfStrikeOut(tm.getTmStruckOut());
		lf.setLfCharSet(tm.getTmCharSet());
		lf.setLfOutPrecision(0);
		lf.setLfClipPrecision(0);
		lf.setLfQuality(0);
		lf.setLfPitchAndFamily(tm.getTmPitchAndFamily());
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetTextFaceA(hDC, 32, lf.getLfFaceName());
		hFont = /*Error: Function owner not recognized*/CreateFontIndirectA(lf/*
		 * Work around the limitations of edit control, to display a hand cursor for hyperlinks
		 * NB: The LTEXT control must have SS_NOTIFY attribute for this to work
		 */);
	}
	public static Object update_subclass_callback(Object hDlg, Object message, Object wParam, Object lParam) {
		switch (message) {
		case 32:
				if ((HWND)wParam == /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1067)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetCursor(/*Error: Function owner not recognized*/LoadCursorA(((Object)0), (LPSTR)((DWORD)((WORD)(true)))));
					return (INT_PTR)1;
				} 
				break;
		}
		return /*Error: Function owner not recognized*/CallWindowProcA(ModernizedCProgram.update_original_proc, hDlg, message, wParam, lParam/*
		 * New version notification dialog
		 */);
	}
	public static Object NewVersionCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		byte[] cmdline = "Rufus -w 150";
		byte filepath = ((Object)0);
		int download_status = 0;
		HFONT hyperlink_font = ((Object)0);
		HANDLE hThread = ((Object)0);
		HWND hNotes = new HWND();
		LONG err = new LONG();
		DWORD exit_code = new DWORD();
		STARTUPINFOA si = new STARTUPINFOA();
		PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
		byte[] _dl_ext_x = new byte[]{"*.exe"};
		byte[] _dl_ext_d = new byte[]{ModernizedCProgram.lmprintf(3037)};
		ext_t dl_ext = new ext_t((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), ((Object)0), _dl_ext_x, _dl_ext_d);
		switch (message) {
		case user_message_type.UM_PROGRESS_INIT:
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), 0);
				ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), ModernizedCProgram.lmprintf(3038));
				ModernizedCProgram.FormatStatus = 0;
				download_status = 1;
				return (INT_PTR)1;
		case user_message_type.UM_PROGRESS_EXIT:
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), 1);
				if (wParam != 0) {
					ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), ModernizedCProgram.lmprintf(3039));
					download_status = 2;
				} else {
						ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), ModernizedCProgram.lmprintf(3040));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), ModernizedCProgram.FormatStatus != (-1024 | (3 << 16) | (-1024 | -1024)));
						download_status = 0;
				} 
				return (INT_PTR)1;
		case 312:
				if ((HWND)lParam != /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1067)) {
					return 0;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetBkMode((HDC)wParam, 1);
				ModernizedCProgram.CreateStaticFont((HDC)wParam, hyperlink_font, 1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SelectObject((HDC)wParam, hyperlink_font);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetTextColor((HDC)wParam, ((COLORREF)((BYTE)(false) | ((BYTE)(false) << 8) | ((BYTE)(true) << 16))));
				return (INT_PTR)/*Error: Function owner not recognized*/CreateSolidBrush(/*Error: Function owner not recognized*/GetSysColor(15));
		case 273:
				switch (((WORD)((DWORD)(wParam)))) {
				case 1067:
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShellExecuteA(hDlg, "open", "https://rufus.ie", ((Object)0), ((Object)0), 1);
						break;
				case 8:
				case 2:
						if (download_status != 1) {
							ModernizedCProgram.reset_localization(108);
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)filepath);
								filepath = ((Object)0);
							} while (0);
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EndDialog(hDlg, ((WORD)((DWORD)(wParam))));
						} 
						return (INT_PTR)1;
				case 1065:
						switch (download_status) {
						case 1:
								ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
								download_status = 0;
								hThread = ((Object)0);
								break;
						case 2:
								if ((hThread == ((Object)0)) || (!/*Error: Function owner not recognized*/GetExitCodeThread(hThread, exit_code)) || (exit_code == 0)) {
									hThread = ((Object)0);
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), 0);
									break;
								} 
								hThread = ((Object)0);
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), 0);
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowTextA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), "3");
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(500);
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowTextA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), "2");
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(500);
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowTextA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), "1");
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(500);
								ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), ModernizedCProgram.lmprintf(3142));
								err = ModernizedCProgram.ValidateSignature(hDlg, filepath);
								if ((err != -1024) && ((ModernizedCProgram.force_update < 2) || (err != TRUST_E_TIME_STAMP))) {
									ModernizedCProgram.DeleteFileU(filepath);
									break;
								} 
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(si, 0, /*Error: sizeof expression not supported yet*/);
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(pi, 0, /*Error: sizeof expression not supported yet*/);
								si.setCb(/*Error: sizeof expression not supported yet*/);
								if (!ModernizedCProgram.CreateProcessU(filepath, cmdline, ((Object)0), ((Object)0), 0, 0, ((Object)0), ((Object)0), si, pi)) {
									ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3214);
									ModernizedCProgram._uprintf("Failed to launch new application: %s", ModernizedCProgram.WindowsErrorString());
								} else {
										ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3213);
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(hDlg, 273, (WPARAM)8, 0);
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(ModernizedCProgram.hMainDialog, 16, 0, 0);
								} 
								break;
						default:
								if (ModernizedCProgram.update.getDownload_url() == ((Object)0)) {
									ModernizedCProgram._uprintf("Could not get download URL");
									break;
								} 
								dl_ext.setFilename(ModernizedCProgram.PathFindFileNameU(ModernizedCProgram.update.getDownload_url()));
								filepath = ModernizedCProgram.FileDialog(1, ModernizedCProgram.app_dir, dl_ext, 8);
								if (filepath == ((Object)0)) {
									ModernizedCProgram._uprintf("Could not get save path");
									break;
								} 
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hDlg, 40, (WPARAM)/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), 1);
								hThread = ModernizedCProgram.DownloadSignedFileThreaded(ModernizedCProgram.update.getDownload_url(), filepath, hDlg, 1);
								break;
						}
						return (INT_PTR)1;
				}
				break;
		case 272:
				ModernizedCProgram.apply_localization(108, hDlg);
				download_status = 0;
				ModernizedCProgram.SetTitleBarIcon(hDlg);
				ModernizedCProgram.CenterDialog(hDlg, ((Object)0));
				ModernizedCProgram.update_original_proc = (WNDPROC)/*Error: Function owner not recognized*/SetWindowLongA(hDlg, (true), (LONG_PTR)update_subclass_callback);
				hNotes = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1064);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hNotes, (1024 + 91), 1, 0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hNotes, (1024 + 97), (WPARAM)ModernizedCProgram.friggin_microsoft_unicode_amateurs, (LPARAM)ModernizedCProgram.update.getRelease_notes());
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hNotes, 177, -1, -1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hNotes, (1024 + 69), 0, 67108864);
				ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1068), ModernizedCProgram.lmprintf(3018, ModernizedCProgram.rufus_version[0], ModernizedCProgram.rufus_version[1], ModernizedCProgram.rufus_version[2]));
				ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1069), ModernizedCProgram.lmprintf(3019, ModernizedCProgram.update.getVersion()[0], ModernizedCProgram.update.getVersion()[1], ModernizedCProgram.update.getVersion()[2]));
				ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1070), ModernizedCProgram.update.getDownload_url());
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1010), (1024 + 1), 0, (-1024 << 16) & -1024);
				if (ModernizedCProgram.update.getDownload_url() == ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1065), 0);
				} 
				ModernizedCProgram.ResizeButtonHeight(hDlg, 2);
				break;
		}
		return (INT_PTR)0;
	}
	public static void DownloadNewVersion() {
		ModernizedCProgram.MyDialogBox(ModernizedCProgram.hMainInstance, 108, ModernizedCProgram.hMainDialog, NewVersionCallback);
	}
	public static void SetTitleBarIcon(Object hDlg) {
		int i16;
		int s16;
		int s32;
		HICON hSmallIcon = new HICON();
		HICON hBigIcon = new HICON();
		// High DPI scaling// High DPI scalingi16 = /*Error: Function owner not recognized*/GetSystemMetrics(49)// Adjust icon size lookup;// Adjust icon size lookup
		s16 = i16;
		s32 = (int)(32.0 * ModernizedCProgram.fScale);
		if (s16 >= 54) {
			s16 = 64;
		}  else if (s16 >= 40) {
			s16 = 48;
		}  else if (s16 >= 28) {
			s16 = 32;
		}  else if (s16 >= 20) {
			s16 = 24;
		} 
		if (s32 >= 54) {
			s32 = 64;
		}  else if (s32 >= 40) {
			s32 = 48;
		}  else if (s32 >= 28) {
			s32 = 32;
		}  else if (s32 >= 20) {
			s32 = 24;
		} 
		// Create the title bar icon// Create the title bar iconhSmallIcon = (HICON)/*Error: Function owner not recognized*/LoadImageA(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(true))), 1, s16, s16, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hDlg, 128, 0, (LPARAM)hSmallIcon);
		hBigIcon = (HICON)/*Error: Function owner not recognized*/LoadImageA(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(true))), 1, s32, s32, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hDlg, 128, 1, (LPARAM)hBigIcon);
	}
	// Return the onscreen size of the text displayed by a control
	public static tagSIZE GetTextSize(Object hCtrl, Byte txt) {
		SIZE sz = new SIZE(0, 0);
		HDC hDC = new HDC();
		wchar_t wstr = ((Object)0);
		int len;
		HFONT hFont = new HFONT();
		// Compute the size of the text// Compute the size of the texthDC = /*Error: Function owner not recognized*/GetDC(hCtrl);
		if (hDC == ((Object)0)) {
			;
		} 
		hFont = (HFONT)/*Error: Function owner not recognized*/SendMessageA(hCtrl, 49, 0, 0);
		if (hFont == ((Object)0)) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SelectObject(hDC, hFont);
		if (txt == ((Object)0)) {
			len = /*Error: Function owner not recognized*/GetWindowTextLengthW(hCtrl);
			if (len <= 0) {
				;
			} 
			wstr = /*Error: Function owner not recognized*/calloc(len + 1, /*Error: Unsupported expression*/);
			if (wstr == ((Object)0)) {
				;
			} 
			if (/*Error: Function owner not recognized*/GetWindowTextW(hCtrl, wstr, len + 1) > 0) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetTextExtentPoint32W(hDC, wstr, len, sz);
			} 
		} else {
				wstr = ModernizedCProgram.utf8_to_wchar(txt);
				if (wstr != ((Object)0)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetTextExtentPoint32W(hDC, wstr, (int)/*Error: Function owner not recognized*/wcslen(wstr), sz);
				} 
		} 
		do {
			if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(hCtrl, hDC);
				hDC = ((Object)0);
			} 
		} while (0);
		return sz/*
		 * The following is used to work around dialog template limitations when switching from LTR to RTL
		 * or switching the font. This avoids having to multiply similar templates in the RC.
		 * TODO: Can we use http://stackoverflow.com/questions/6057239/which-font-is-the-default-for-mfc-dialog-controls?
		  */;
	}
	// Produce a dialog template from our RC, and update its RTL and Font settings dynamically
	// See http://blogs.msdn.com/b/oldnewthing/archive/2004/06/21/163596.aspx as well as
	// https://msdn.microsoft.com/en-us/library/windows/desktop/ms645389.aspx for a description
	// of the Dialog structure
	public static Object GetDialogTemplate(int Dialog_ID) {
		int i;
		byte[] thai_id = "th-TH";
		size_t len = new size_t();
		DWORD size = new DWORD();
		DWORD dwBuf = new DWORD();
		WCHAR wBuf = new WCHAR();
		LPCDLGTEMPLATE rcTemplate = (LPCDLGTEMPLATE)ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(Dialog_ID))), (LPSTR)((DWORD)((WORD)(true))), ModernizedCProgram.get_name_from_id(Dialog_ID), size, 1);
		if ((size == 0) || (rcTemplate == ((Object)0))) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)rcTemplate);
				rcTemplate = ((Object)0);
			} while (0);
			return ((Object)0);
		} 
		if (ModernizedCProgram.right_to_left_mode) {
			dwBuf = (DWORD)rcTemplate;
			dwBuf[2] = -1024 | -1024;
		} 
		// Add the RTL styles into our RC copy, so that we don't have to multiply dialog definitions in the RC
		// 2. So that Thai displays properly on RTF controls as it won't work with regular// 'Segoe UI'... but Cyrillic won't work with 'Segoe UI Symbol'// If 'Segoe UI Symbol' is available, and we are using Thai, we're done hereif (ModernizedCProgram.IsFontAvailable("Segoe UI Symbol") && (ModernizedCProgram.selected_locale != ((Object)0)) && (/*Error: Function owner not recognized*/strcmp(((ModernizedCProgram.selected_locale.getTxt()[0] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.selected_locale.getTxt()[0]), ((thai_id == ((Object)0)) ? "<NULL>" : thai_id)) == 0)) {
			return rcTemplate;
		} 
		// 'Segoe UI Symbol' cannot be used => Fall back to the best we have// 'Segoe UI Symbol' cannot be used => Fall back to the best we havewBuf = (WCHAR)rcTemplate;
		// Move to class name// Move to class namewBuf = wBuf[14]// Skip class name and title;// Skip class name and title
		for (i = 0; i < 2; i++) {
			if (wBuf == -1024) {
				wBuf = wBuf[2];
			} else {
					wBuf = wBuf[/*Error: Function owner not recognized*/wcslen(wBuf) + 1];
			} 
		}
		// wBuf[0] = 0x0009;// wBuf[0] = 0x0009;wBuf = wBuf[3]// Make sure we are where we want to be and adjust the font;// Make sure we are where we want to be and adjust the font
		if (/*Error: Function owner not recognized*/wcscmp(L"Segoe UI Symbol", wBuf) == 0) {
			uintptr_t src = new uintptr_t();
			uintptr_t dst = new uintptr_t();
			uintptr_t start = (uintptr_t)rcTemplate;
			wBuf[8] = 0;
			len = /*Error: Function owner not recognized*/wcslen(wBuf);
			wBuf[len + 1] = 0;
			dst = (uintptr_t)wBuf[len + 2];
			dst &=  ~3;
			src = (uintptr_t)wBuf[17];
			src &=  ~3;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memmove((Object)dst, (Object)src, size - (src - start));
		} else {
				ModernizedCProgram._uprintf("Could not locate font for %s!", ModernizedCProgram.get_name_from_id(Dialog_ID));
		} 
		return rcTemplate;
	}
	public static Object MyCreateDialog(Object hInstance, int Dialog_ID, Object hWndParent, Object lpDialogFunc) {
		LPCDLGTEMPLATE rcTemplate = ModernizedCProgram.GetDialogTemplate(Dialog_ID);
		HWND hDlg = /*Error: Function owner not recognized*/CreateDialogIndirectParamA(hInstance, rcTemplate, hWndParent, lpDialogFunc, 0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)rcTemplate);
			rcTemplate = ((Object)0);
		} while (0);
		return hDlg;
	}
	public static Object MyDialogBox(Object hInstance, int Dialog_ID, Object hWndParent, Object lpDialogFunc) {
		INT_PTR ret = new INT_PTR();
		LPCDLGTEMPLATE rcTemplate = ModernizedCProgram.GetDialogTemplate(Dialog_ID);
		// A DialogBox doesn't handle reduce/restore so it won't pass restore messages to the// main dialog if the main dialog was minimized. This can result in situations where the
		/*Error: Function owner not recognized*/// user cannot restore the main window if a new dialog prompt was triggered while the// main dialog was reduced => Ensure the main dialog is visible before we display anything./*Error: Function owner not recognized*/// user cannot restore the main window if a new dialog prompt was triggered while the// main dialog was reduced => Ensure the main dialog is visible before we display anything.ShowWindow(ModernizedCProgram.hMainDialog, 1);
		ret = /*Error: Function owner not recognized*/DialogBoxIndirectParamA(ModernizedCProgram.hMainInstance, rcTemplate, hWndParent, lpDialogFunc, 0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)rcTemplate);
			rcTemplate = ((Object)0);
		} while (0);
		return ret/*
		 * The following function calls are used to automatically detect and close the native
		 * Windows format prompt "You must format the disk in drive X:" as well as the cookies
		 * alert being popped by Windows when running our Download script. To do that, we use
		 * an event hook that gets triggered whenever a window is placed in the foreground.
		 * In that hook, we look for a dialog that has style WS_POPUPWINDOW and has the relevant
		 * title. However, in case of the Format prompt, because the title in itself is too
		 * generic (the expectation is that it will be "Microsoft Windows") we also enumerate
		 * all the child controls from that prompt, using another callback, until we find one
		 * that contains the text we expect for the "Format disk" button.
		 * Oh, and since all of these strings are localized, we must first pick them up from
		 * the relevant mui's.
		 */;
	}
	public static Object AlertPromptCallback(Object hWnd, Object lParam) {
		byte[] str = new byte[128];
		BOOL found = (BOOL)lParam;
		if (ModernizedCProgram.GetWindowTextU(hWnd, str, /*Error: sizeof expression not supported yet*/) == 0) {
			return 1;
		} 
		if (/*Error: Function owner not recognized*/strcmp(((str == ((Object)0)) ? "<NULL>" : str), ((ModernizedCProgram.button_str == ((Object)0)) ? "<NULL>" : ModernizedCProgram.button_str)) == 0) {
			found = 1;
		} 
		return 1;
	}
	public static void AlertPromptHook(Object hWinEventHook, Object Event, Object hWnd, Object idObject, Object idChild, Object dwEventThread, Object dwmsEventTime) {
		byte[] str = new byte[128];
		BOOL found = new BOOL();
		if (Event == EVENT_SYSTEM_FOREGROUND) {
			if (/*Error: Function owner not recognized*/GetWindowLongA(hWnd, (true)) & -1024) {
				str[0] = 0;
				ModernizedCProgram.GetWindowTextU(hWnd, str, /*Error: sizeof expression not supported yet*/);
				if (/*Error: Function owner not recognized*/strcmp(str, ModernizedCProgram.title_str[0]) == 0) {
					found = 0;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnumChildWindows(hWnd, AlertPromptCallback, (LPARAM)found);
					if (found) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hWnd, 273, (WPARAM)2, (LPARAM)0);
						ModernizedCProgram._uprintf("Closed Windows format prompt");
					} 
				}  else if (ModernizedCProgram.close_fido_cookie_prompts && /*Error: Function owner not recognized*/strcmp(str, ModernizedCProgram.title_str[1]) == 0) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hWnd, 273, (WPARAM)2, (LPARAM)0);
				}  else if ((/*Error: Function owner not recognized*/strcmp(str, ModernizedCProgram.title_str[2]) == 0) && (hWnd != ModernizedCProgram.hFidoDlg)) {
					ModernizedCProgram.hFidoDlg = hWnd;
					ModernizedCProgram.CenterDialog(hWnd, ModernizedCProgram.hMainDialog);
				} 
			} 
		} 
	}
	public static void SetAlertPromptMessages() {
		HMODULE mui_lib = new HMODULE();
		byte[] mui_path = new byte[260];
		// Fetch the localized strings in the relevant MUI
		// Must use sysnative_dir rather than system_dir as we may not find the MUI's otherwisedo {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(mui_path, /*Error: sizeof expression not supported yet*/, "%s\\%s\\shell32.dll.mui", ModernizedCProgram.sysnative_dir, ModernizedCProgram.GetCurrentMUI());
			(mui_path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		mui_lib = ModernizedCProgram.LoadLibraryU(mui_path);
		if (mui_lib != ((Object)0)) {
			if (ModernizedCProgram.LoadStringU(mui_lib, 4125, ModernizedCProgram.title_str[0], /*Error: sizeof expression not supported yet*/) <= 0) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.title_str[0], "Microsoft Windows", (((size_t)(((((byte)"Microsoft Windows") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Microsoft Windows")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"Microsoft Windows") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Microsoft Windows")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)ModernizedCProgram.title_str[0])[(((size_t)(((((byte)"Microsoft Windows") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Microsoft Windows")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"Microsoft Windows") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Microsoft Windows")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
				ModernizedCProgram._uprintf("Warning: Could not locate localized format prompt title string in '%s': %s", mui_path, ModernizedCProgram.WindowsErrorString());
			} 
			if (ModernizedCProgram.LoadStringU(mui_lib, 4126, ModernizedCProgram.button_str, /*Error: sizeof expression not supported yet*/) <= 0) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.button_str, "Format disk", (((size_t)(((((byte)"Format disk") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Format disk")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"Format disk") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Format disk")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)ModernizedCProgram.button_str)[(((size_t)(((((byte)"Format disk") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Format disk")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"Format disk") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Format disk")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
				ModernizedCProgram._uprintf("Warning: Could not locate localized format prompt button string in '%s': %s", mui_path, ModernizedCProgram.WindowsErrorString());
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/FreeLibrary(mui_lib);
		} 
		// 4097 = "You need to format the disk in drive %c: before you can use it." (dialog text)// 4125 = "Microsoft Windows" (dialog title)
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(mui_path, /*Error: sizeof expression not supported yet*/, "%s\\%s\\urlmon.dll.mui", ModernizedCProgram.sysnative_dir, ModernizedCProgram.GetCurrentMUI());
			(mui_path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		mui_lib = ModernizedCProgram.LoadLibraryU(mui_path);
		if (mui_lib != ((Object)0)) {
			if (ModernizedCProgram.LoadStringU(mui_lib, 2070, ModernizedCProgram.title_str[1], /*Error: sizeof expression not supported yet*/) <= 0) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.title_str[1], "Windows Security Warning", (((size_t)(((((byte)"Windows Security Warning") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Windows Security Warning")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"Windows Security Warning") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Windows Security Warning")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)ModernizedCProgram.title_str[1])[(((size_t)(((((byte)"Windows Security Warning") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Windows Security Warning")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"Windows Security Warning") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Windows Security Warning")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
				ModernizedCProgram._uprintf("Warning: Could not locate localized cookie prompt title string in '%s': %s", mui_path, ModernizedCProgram.WindowsErrorString());
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/FreeLibrary(mui_lib);
		} 
		// 2070 = "Windows Security Warning" (yes, that's what MS uses for a stupid cookie!)
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.title_str[2], ModernizedCProgram.lmprintf(3149), (((size_t)(((((byte)ModernizedCProgram.lmprintf(3149)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3149))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.lmprintf(3149)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3149))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
			((byte)ModernizedCProgram.title_str[2])[(((size_t)(((((byte)ModernizedCProgram.lmprintf(3149)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3149))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.lmprintf(3149)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3149))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
		} while (0);
	}
	public static Object SetAlertPromptHook() {
		if (ModernizedCProgram.ap_weh != ((Object)0)) {
			return 1;
		} 
		ModernizedCProgram.ap_weh = /*Error: Function owner not recognized*/SetWinEventHook(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, ((Object)0), AlertPromptHook, 0, 0, WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS);
		return (ModernizedCProgram.ap_weh != ((Object)0));
	}
	public static void ClrAlertPromptHook() {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/UnhookWinEvent(ModernizedCProgram.ap_weh);
		ModernizedCProgram.ap_weh = ((Object)0);
	}
	public static void FlashTaskbar(Object handle) {
		 pf = new ();
		if (handle == ((Object)0)) {
			return /*Error: Unsupported expression*/;
		} 
		pf.setCbSize(/*Error: Unsupported expression*/);
		pf.setHwnd(handle)// Could also use FLASHW_ALL to flash the main dialog);// Could also use FLASHW_ALL to flash the main dialog)
		pf.setDwFlags(FLASHW_TIMER | FLASHW_TRAY);
		pf.setUCount(5);
		pf.setDwTimeout(75);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/FlashWindowEx(pf);
	}
	// https://docs.microsoft.com/en-us/globalization/localizability/mirroring-in-win32
	// Note: This function *destroys* the original icon
	public static Object CreateMirroredIcon(Object hiconOrg) {
		HDC hdcScreen = new HDC();
		HDC hdcBitmap = new HDC();
		HDC hdcMask = ((Object)0);
		HBITMAP hbm = new HBITMAP();
		HBITMAP hbmMask = new HBITMAP();
		HBITMAP hbmOld = new HBITMAP();
		HBITMAP hbmOldMask = new HBITMAP();
		BITMAP bm = new BITMAP();
		ICONINFO ii = new ICONINFO();
		HICON hicon = ((Object)0);
		hdcBitmap = /*Error: Function owner not recognized*/CreateCompatibleDC(((Object)0));
		if (hdcBitmap) {
			hdcMask = /*Error: Function owner not recognized*/CreateCompatibleDC(((Object)0));
			if (hdcMask) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLayout(hdcBitmap, 1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLayout(hdcMask, 1);
			} else {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DeleteDC(hdcBitmap);
					hdcBitmap = ((Object)0);
			} 
		} 
		hdcScreen = /*Error: Function owner not recognized*/GetDC(((Object)0));
		Object generatedHbmColor = ii.getHbmColor();
		Object generatedHbmMask = ii.getHbmMask();
		Object generatedBmWidth = bm.getBmWidth();
		Object generatedBmHeight = bm.getBmHeight();
		if (hdcScreen) {
			if (hdcBitmap && hdcMask) {
				if (hiconOrg) {
					if (/*Error: Function owner not recognized*/GetIconInfo(hiconOrg, ii) && /*Error: Function owner not recognized*/GetObjectA(generatedHbmColor, /*Error: Unsupported expression*/, bm)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DeleteObject(generatedHbmMask);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DeleteObject(generatedHbmColor);
						ii.setHbmMask(ii.setHbmColor(((Object)0)));
						hbm = /*Error: Function owner not recognized*/CreateCompatibleBitmap(hdcScreen, generatedBmWidth, generatedBmHeight);
						hbmMask = /*Error: Function owner not recognized*/CreateBitmap(generatedBmWidth, generatedBmHeight, 1, 1, ((Object)0));
						hbmOld = (HBITMAP)/*Error: Function owner not recognized*/SelectObject(hdcBitmap, hbm);
						hbmOldMask = (HBITMAP)/*Error: Function owner not recognized*/SelectObject(hdcMask, hbmMask);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DrawIconEx(hdcBitmap, 0, 0, hiconOrg, generatedBmWidth, generatedBmHeight, 0, ((Object)0), 2);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DrawIconEx(hdcMask, 0, 0, hiconOrg, generatedBmWidth, generatedBmHeight, 0, ((Object)0), 1);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SelectObject(hdcBitmap, hbmOld);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SelectObject(hdcMask, hbmOldMask);
						ii.setHbmMask(hbmMask);
						ii.setHbmColor(hbm);
						hicon = /*Error: Function owner not recognized*/CreateIconIndirect(ii);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DeleteObject(hbm);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DeleteObject(hbmMask);
					} 
				} 
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(((Object)0), hdcScreen);
		} 
		if (hdcBitmap) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DeleteDC(hdcBitmap);
		} 
		if (hdcMask) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DeleteDC(hdcMask);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DestroyIcon(hiconOrg);
		return hicon;
	}
	// Set up a dialog window
	// https://msdn.microsoft.com/en-us/library/windows/desktop/ms645394.aspx:
	// In a standard template for a dialog box, the DLGTEMPLATE structure is always immediately followed by
	// three variable-length arrays that specify the menu, class, and title for the dialog box.
	// When the DS_SETFONT style is specified, these arrays are also followed by a 16-bit value specifying
	// point size and another variable-length array specifying a typeface name. Each array consists of one
	// or more 16-bit elements. The menu, class, title, and font arrays must be aligned on WORD boundaries.
	// No menu
	// Default dialog class
	// Set point size and typeface name if required
	// Add an OK button
	// Button class
	// No creation data
	// Add a Cancel button
	// Add radio buttons
	public static void OutputUTF8Message(Object[] src) {
		int len;
		wchar_t wdst = ((Object)0);
		if (src == ((Object)0)) {
			;
		} 
		len = (int)((((byte)src) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(src));
		while ((len > 0) && ((src[len - 1] == -1024) || (src[len - 1] == -1024) || (src[len - 1] == (byte)' '))) {
			len--;
		}
		if (len == 0) {
			;
		} 
		len = /*Error: Function owner not recognized*/MultiByteToWideChar(1, 0, src, len, ((Object)0), 0);
		if (len == 0) {
			;
		} 
		wdst = (wchar_t)/*Error: Function owner not recognized*/calloc(len + 1, /*Error: Unsupported expression*/);
		if ((wdst == ((Object)0)) || (/*Error: Function owner not recognized*/MultiByteToWideChar(1, 0, src, len, wdst, len + 1) == 0)) {
			;
		} 
		ModernizedCProgram._uprintf("%S", wdst);
	}
	public static Object FormatExCallback( Command, Object Action, Object pData) {
		byte[] percent_str = new byte[8];
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
			return 0;
		} 
		(((ModernizedCProgram.actual_fs_type >= 0) && (ModernizedCProgram.actual_fs_type < fs_type.FS_MAX)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(actual_fs_type >= 0) && (actual_fs_type < FS_MAX)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\format.c", 111));
		switch (Command) {
		case .FCC_PROGRESS:
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(percent_str, /*Error: sizeof expression not supported yet*/, "%lu%%", ((DWORD)pData));
					(percent_str)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3217, percent_str);
				ModernizedCProgram.UpdateProgress(action_type.OP_FORMAT, 1.0 * (((DWORD)pData)));
				break;
		case .FCC_BAD_LABEL:
				ModernizedCProgram._uprintf("Bad label");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				break;
		case .FCC_ACCESS_DENIED:
				ModernizedCProgram._uprintf("Access denied");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				break;
		case .FCC_DONE:
				ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3218, ModernizedCProgram.nb_steps[ModernizedCProgram.actual_fs_type], ModernizedCProgram.nb_steps[ModernizedCProgram.actual_fs_type]);
				ModernizedCProgram.UpdateProgress(action_type.OP_CREATE_FS, 100.0);
				if ((BOOLEAN)pData == 0) {
					ModernizedCProgram._uprintf("Error while formatting");
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				} 
				break;
		case .FCC_DEVICE_NOT_READY:
				ModernizedCProgram._uprintf("The device is not ready");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				break;
		case .FCC_CLUSTER_SIZE_TOO_SMALL:
				ModernizedCProgram._uprintf("Unsupported cluster size");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
				break;
		case .FCC_VOLUME_TOO_SMALL:
				ModernizedCProgram._uprintf("Volume is too %s", (Command == .FCC_VOLUME_TOO_BIG) ? "big" : "small");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
				break;
		case .FCC_VOLUME_IN_USE:
				ModernizedCProgram._uprintf("Volume is in use");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				break;
		case .FCC_NO_MEDIA_IN_DRIVE:
				ModernizedCProgram._uprintf("No media in drive");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				break;
		case .FCC_STRUCTURE_PROGRESS:
				if (ModernizedCProgram.task_number < ModernizedCProgram.nb_steps[ModernizedCProgram.actual_fs_type] - 1) {
					if (ModernizedCProgram.task_number == 0) {
						ModernizedCProgram._uprintf("Creating file system...");
					} 
					ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3218, ++ModernizedCProgram.task_number, ModernizedCProgram.nb_steps[ModernizedCProgram.actual_fs_type]);
					ModernizedCProgram.format_percent += 100.0 / (1.0 * ModernizedCProgram.nb_steps[ModernizedCProgram.actual_fs_type]);
					ModernizedCProgram.UpdateProgress(action_type.OP_CREATE_FS, ModernizedCProgram.format_percent);
				} 
				break;
		case .FCC_OUTPUT:
				ModernizedCProgram.OutputUTF8Message(((PTEXTOUTPUT)pData).getOutput());
				break;
		case .FCC_CANT_QUICK_FORMAT:
				ModernizedCProgram._uprintf("Cannot quick format this volume");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
				break;
		case .FCC_MEDIA_WRITE_PROTECTED:
				ModernizedCProgram._uprintf("Media is write protected");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				break;
		case .FCC_CLUSTER_SIZE_TOO_BIG:
		case .FCC_INCOMPATIBLE_FILE_SYSTEM:
				ModernizedCProgram._uprintf("Incompatible File System");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
				break;
		case .FCC_VOLUME_TOO_BIG:
		case .FCC_DONE_WITH_STRUCTURE:
				break;
		default:
				ModernizedCProgram._uprintf("FormatExCallback: Received unhandled command 0x02%X - aborting", Command);
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				break;
		}
		return (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1/*
		 * Chkdsk callback. Return FALSE to halt operations
		 */));
	}
	public static Object ChkdskCallback( Command, Object Action, Object pData) {
		DWORD percent = new DWORD();
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
			return 0;
		} 
		switch (Command) {
		case .FCC_OUTPUT:
				ModernizedCProgram.OutputUTF8Message(((PTEXTOUTPUT)pData).getOutput());
				break;
		case .FCC_DONE_WITH_STRUCTURE:
				break;
		case .FCC_DONE:
				if ((BOOLEAN)pData == 0) {
					ModernizedCProgram._uprintf("Error while checking disk");
					return 0;
				} 
				break;
		case .FCC_PROGRESS:
		case .FCC_MEDIA_WRITE_PROTECTED:
				ModernizedCProgram._uprintf("Media is write protected");
				return 0;
		case .FCC_CHECKDISK_PROGRESS:
				percent = (DWORD)pData;
				ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3219, percent);
				break;
		case .FCC_ACCESS_DENIED:
				ModernizedCProgram._uprintf("Access denied");
				return 0;
		case .FCC_UNKNOWN1A:
		case .FCC_INCOMPATIBLE_FILE_SYSTEM:
				ModernizedCProgram._uprintf("Incompatible File System");
				return 0;
		case .FCC_VOLUME_IN_USE:
				ModernizedCProgram._uprintf("Volume is in use");
				return 0;
		case .FCC_NO_MEDIA_IN_DRIVE:
				ModernizedCProgram._uprintf("No media in drive");
				return 0;
		case .FCC_READ_ONLY_MODE:
				ModernizedCProgram._uprintf("Media has been switched to read-only - Leaving checkdisk");
				break;
		default:
				ModernizedCProgram._uprintf("ChkdskExCallback: received unhandled command %X", Command);
				break;
		}
		return 1/*
		 * Converts an UTF-8 label to a valid FAT/NTFS one
		 * TODO: Use IVdsService::QueryFileSystemTypes -> VDS_FILE_SYSTEM_TYPE_PROP
		 * to get the list of unauthorised and max length for each FS.
		 */;
	}
	public static void ToValidLabel(Byte Label, Object bFAT) {
		size_t i = new size_t();
		size_t j = new size_t();
		size_t k = new size_t();
		BOOL found = new BOOL();
		WCHAR[] unauthorized = L"*?,;:/\\|+=<>[]\"";
		WCHAR[] to_underscore = L"\t.";
		WCHAR wLabel = ModernizedCProgram.utf8_to_wchar(Label);
		if (wLabel == ((Object)0)) {
			return /*Error: Unsupported expression*/;
		} 
		for (; i < /*Error: Function owner not recognized*/wcslen(wLabel); i++) {
			if (bFAT) {
				found = 0;
				for (j = 0; j < /*Error: Function owner not recognized*/wcslen(unauthorized); j++) {
					if (wLabel[i] == unauthorized[j]) {
						found = 1;
						break;
					} 
				}
				if (wLabel[i] >= -1024) {
					wLabel[k++] = (byte)L'_';
					found = 1;
				} 
				if (found) {
					continue;
				} 
			} 
			found = 0;
			for (j = 0; j < /*Error: Function owner not recognized*/wcslen(to_underscore); j++) {
				if (wLabel[i] == to_underscore[j]) {
					wLabel[k++] = (byte)'_';
					found = 1;
					break;
				} 
			}
			if (found) {
				continue;
			} 
			wLabel[k++] = bFAT ? /*Error: Function owner not recognized*/toupper(wLabel[i]) : wLabel[i];
		}
		wLabel[k] = 0;
		if (bFAT) {
			if (/*Error: Function owner not recognized*/wcslen(wLabel) > 11) {
				wLabel[11] = 0;
			} 
			for (; wLabel[i] != 0; i++) {
				if (wLabel[i] == (byte)'_') {
					j++;
				} 
			}
			if (i < 2 * j) {
				ModernizedCProgram._uprintf("FAT label is mostly underscores. Using '%s' label instead.", ModernizedCProgram.SelectedDrive.getProposed_label());
				for (i = 0; ModernizedCProgram.SelectedDrive.getProposed_label()[i] != 0; i++) {
					wLabel[i] = ModernizedCProgram.SelectedDrive.getProposed_label()[i];
				}
				wLabel[i] = 0;
			} 
		}  else if (/*Error: Function owner not recognized*/wcslen(wLabel) > 32) {
			wLabel[32] = 0;
		} 
		/*Error: Function owner not recognized*/// Needed for disk by label isolinux.cfg workaround/*Error: Function owner not recognized*/// Needed for disk by label isolinux.cfg workaroundWideCharToMultiByte(65001, 0, wLabel, -1, ModernizedCProgram.img_report.getUsb_label(), /*Error: sizeof expression not supported yet*/, ((Object)0), ((Object)0));
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(Label, ModernizedCProgram.img_report.getUsb_label(), (((size_t)(((((byte)ModernizedCProgram.img_report.getUsb_label()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getUsb_label())) + 1)) < ((size_t)(/*Error: Function owner not recognized*/strlen(Label) + 1)) ? ((size_t)(((((byte)ModernizedCProgram.img_report.getUsb_label()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getUsb_label())) + 1)) : ((size_t)(/*Error: Function owner not recognized*/strlen(Label) + 1))));
			((byte)Label)[(((size_t)(((((byte)ModernizedCProgram.img_report.getUsb_label()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getUsb_label())) + 1)) < ((size_t)(/*Error: Function owner not recognized*/strlen(Label) + 1)) ? ((size_t)(((((byte)ModernizedCProgram.img_report.getUsb_label()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getUsb_label())) + 1)) : ((size_t)(/*Error: Function owner not recognized*/strlen(Label) + 1))) - 1] = 0;
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(wLabel/*
		 * 28.2  CALCULATING THE VOLUME SERIAL NUMBER
		 *
		 * For example, say a disk was formatted on 26 Dec 95 at 9:55 PM and 41.94
		 * seconds.  DOS takes the date and time just before it writes it to the
		 * disk.
		 *
		 * Low order word is calculated:               Volume Serial Number is:
		 * Month & Day         12/26   0c1ah
		 * Sec & Hundredths    41:94   295eh               3578:1d02
		 * -----
		 * 3578h
		 *
		 * High order word is calculated:
		 * Hours & Minutes     21:55   1537h
		 * Year                1995    07cbh
		 * -----
		 * 1d02h
		 */);
	}
	public static Object GetVolumeID() {
		SYSTEMTIME s = new SYSTEMTIME();
		DWORD d = new DWORD();
		WORD lo = new WORD();
		WORD hi = new WORD();
		WORD tmp = new WORD();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetLocalTime(s);
		Object generatedWDay = s.getWDay();
		Object generatedWMonth = s.getWMonth();
		lo = generatedWDay + (generatedWMonth << 8);
		Object generatedWMilliseconds = s.getWMilliseconds();
		Object generatedWSecond = s.getWSecond();
		tmp = (generatedWMilliseconds / 10) + (generatedWSecond << 8);
		lo += tmp;
		Object generatedWMinute = s.getWMinute();
		Object generatedWHour = s.getWHour();
		hi = generatedWMinute + (generatedWHour << 8);
		Object generatedWYear = s.getWYear();
		hi += generatedWYear;
		d = lo + (hi << 16);
		return d/*
		 * Proper computation of FAT size
		 * See: http://www.syslinux.org/archives/2016-February/024850.html
		 * and subsequent replies.
		 */;
	}
	public static Object GetFATSizeSectors(Object DskSize, Object ReservedSecCnt, Object SecPerClus, Object NumFATs, Object BytesPerSect) {
		ULONGLONG Numerator = new ULONGLONG();
		ULONGLONG Denominator = new ULONGLONG();
		ULONGLONG FatElementSize = 4;
		ULONGLONG ReservedClusCnt = 2;
		ULONGLONG FatSz = new ULONGLONG();
		Numerator = DskSize - ReservedSecCnt + ReservedClusCnt * SecPerClus;
		Denominator = SecPerClus * BytesPerSect / FatElementSize + NumFATs;
		// +1 to ensure we are rounded up// +1 to ensure we are rounded upFatSz = Numerator / Denominator + 1;
		return (DWORD)FatSz/*
		 * Large FAT32 volume formatting from fat32format by Tom Thornhill
		 * http://www.ridgecrop.demon.co.uk/index.htm?fat32format.htm
		 */;
	}
	public static Object FormatLargeFAT32(Object DriveIndex, Object PartitionOffset, Object ClusterSize, Object FSName, Object Label, Object Flags) {
		BOOL r = 0;
		DWORD i = new DWORD();
		HANDLE hLogicalVolume = ((Object)0);
		DWORD cbRet = new DWORD();
		DISK_GEOMETRY dgDrive = new DISK_GEOMETRY();
		// DISK_GEOMETRY_EX is variable sizeBYTE[] geometry_ex = new BYTE();
		PDISK_GEOMETRY_EX xdgDrive = (PDISK_GEOMETRY_EX)(Object)geometry_ex;
		PARTITION_INFORMATION piDrive = new PARTITION_INFORMATION();
		PARTITION_INFORMATION_EX xpiDrive = new PARTITION_INFORMATION_EX();
		// Recommended values
		DWORD ReservedSectCount = 32;
		DWORD NumFATs = 2;
		DWORD BackupBootSect = 6;
		// calculated before formatDWORD VolumeId = 0;
		byte VolumeName = ((Object)0);
		// Zero in blocks of 64K typicallyDWORD BurstSize = 128;
		// Calculated laterDWORD FatSize = 0;
		DWORD BytesPerSect = 0;
		DWORD SectorsPerCluster = 0;
		DWORD TotalSectors = 0;
		DWORD SystemAreaSize = 0;
		DWORD UserAreaSize = 0;
		ULONGLONG qTotalSectors = 0;
		// Structures to be written to the diskFAT_BOOTSECTOR32 pFAT32BootSect = ((Object)0);
		FAT_FSINFO pFAT32FsInfo = ((Object)0);
		DWORD pFirstSectOfFat = ((Object)0);
		BYTE pZeroSect = ((Object)0);
		byte[] VolId = "NO NAME    ";
		// Debug temp varsULONGLONG FatNeeded = new ULONGLONG();
		ULONGLONG ClusterCount = new ULONGLONG();
		if (/*Error: Function owner not recognized*/strncmp(((FSName == ((Object)0)) ? "<NULL>" : FSName), (("FAT" == ((Object)0)) ? "<NULL>" : "FAT"), 3) != 0) {
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3222, "Large FAT32");
		ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_INIT, (int)1, (uint64_t)(uintptr_t)((Object)0), 0);
		;
		VolumeId = ModernizedCProgram.GetVolumeID();
		// Open the drive and lock it// Open the drive and lock ithLogicalVolume = ModernizedCProgram.GetLogicalHandle(DriveIndex, PartitionOffset, 1, 1, 0);
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
			;
		} 
		if ((hLogicalVolume == (HANDLE)(true)) || (hLogicalVolume == ((Object)0))) {
			do {
				ModernizedCProgram._uprintf("Invalid logical volume handle");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				;
			} while (0);
		} 
		// Try to disappear the volume while we're formatting it// Try to disappear the volume while we're formatting itModernizedCProgram.UnmountVolume(hLogicalVolume);
		// Work out drive paramsif (!/*Error: Function owner not recognized*/DeviceIoControl(hLogicalVolume, (((true) << 16) | ((true) << 14) | ((false) << 2) | (false)), ((Object)0), 0, dgDrive, /*Error: sizeof expression not supported yet*/, cbRet, ((Object)0))) {
			if (!/*Error: Function owner not recognized*/DeviceIoControl(hLogicalVolume, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, xdgDrive, /*Error: sizeof expression not supported yet*/, cbRet, ((Object)0))) {
				ModernizedCProgram._uprintf("IOCTL_DISK_GET_DRIVE_GEOMETRY error: %s", ModernizedCProgram.WindowsErrorString());
				do {
					ModernizedCProgram._uprintf("Failed to get device geometry (both regular and _ex)");
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
					;
				} while (0);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(dgDrive, xdgDrive.getGeometry(), /*Error: sizeof expression not supported yet*/);
		} 
		Object generatedBytesPerSector = dgDrive.getBytesPerSector();
		if (generatedBytesPerSector < 512) {
			dgDrive.setBytesPerSector(512);
		} 
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
			;
		} 
		Object generatedStartingOffset = xpiDrive.getStartingOffset();
		Object generatedPartitionLength = xpiDrive.getPartitionLength();
		if (!/*Error: Function owner not recognized*/DeviceIoControl(hLogicalVolume, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, piDrive, /*Error: sizeof expression not supported yet*/, cbRet, ((Object)0))) {
			if (!/*Error: Function owner not recognized*/DeviceIoControl(hLogicalVolume, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, xpiDrive, /*Error: sizeof expression not supported yet*/, cbRet, ((Object)0))) {
				ModernizedCProgram._uprintf("IOCTL_DISK_GET_PARTITION_INFO error: %s", ModernizedCProgram.WindowsErrorString());
				do {
					ModernizedCProgram._uprintf("Failed to get partition info (both regular and _ex)");
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
					;
				} while (0);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(piDrive, 0, /*Error: sizeof expression not supported yet*/);
			generatedStartingOffset.setQuadPart(generatedStartingOffset.getQuadPart());
			generatedPartitionLength.setQuadPart(generatedPartitionLength.getQuadPart());
			piDrive.setHiddenSectors((DWORD)(generatedStartingOffset.getQuadPart() / generatedBytesPerSector));
		} 
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
			;
		} 
		BytesPerSect = generatedBytesPerSector;
		// Checks on Disk Size// Checks on Disk SizeqTotalSectors = generatedPartitionLength.getQuadPart() / generatedBytesPerSector// Low end limit - 65536 sectors;// Low end limit - 65536 sectors
		if (qTotalSectors < 65536) {
			do {
				ModernizedCProgram._uprintf("This drive is too small for FAT32 - there must be at least 64K clusters");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
				;
			} while (0);
		} 
		// Most FAT32 implementations would probably mount this volume just fine,
		if (qTotalSectors >= -1024) {
			do {
				ModernizedCProgram._uprintf("This drive is too big for FAT32 - max 2TB supported");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
				;
			} while (0);
		} 
		// This is a more fundamental limitation on FAT32 - the total sector count in the root dir// is 32bit. With a bit of creativity, FAT32 could be extended to handle at least 2^28 clusters// There would need to be an extra field in the FSInfo sector, and the old sector count could
		// coverity[tainted_data]// coverity[tainted_data]pFAT32BootSect = (FAT_BOOTSECTOR32)/*Error: Function owner not recognized*/calloc(BytesPerSect, 1);
		pFAT32FsInfo = (FAT_FSINFO)/*Error: Function owner not recognized*/calloc(BytesPerSect, 1);
		pFirstSectOfFat = (DWORD)/*Error: Function owner not recognized*/calloc(BytesPerSect, 1);
		if (!pFAT32BootSect || !pFAT32FsInfo || !pFirstSectOfFat) {
			do {
				ModernizedCProgram._uprintf("Failed to allocate memory");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				;
			} while (0);
		} 
		Object generatedSJmpBoot = pFAT32BootSect.getSJmpBoot();
		// fill out the boot sector and fs info// fill out the boot sector and fs infogeneratedSJmpBoot[0] = -1024;
		// jmp.s $+0x5a is 0xeb 0x58, not 0xeb 0x5a. Thanks Marco!// jmp.s $+0x5a is 0xeb 0x58, not 0xeb 0x5a. Thanks Marco!generatedSJmpBoot[1] = -1024;
		generatedSJmpBoot[2] = -1024;
		Object generatedSOEMName = pFAT32BootSect.getSOEMName();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedSOEMName, "MSWIN4.1", 8);
		pFAT32BootSect.setWBytsPerSec((WORD)BytesPerSect);
		SectorsPerCluster = ClusterSize / BytesPerSect;
		pFAT32BootSect.setBSecPerClus((BYTE)SectorsPerCluster);
		pFAT32BootSect.setWRsvdSecCnt((WORD)ReservedSectCount);
		pFAT32BootSect.setBNumFATs((BYTE)NumFATs);
		pFAT32BootSect.setWRootEntCnt(0);
		pFAT32BootSect.setWTotSec16(0);
		pFAT32BootSect.setBMedia(-1024);
		pFAT32BootSect.setWFATSz16(0);
		Object generatedSectorsPerTrack = dgDrive.getSectorsPerTrack();
		pFAT32BootSect.setWSecPerTrk((WORD)generatedSectorsPerTrack);
		Object generatedTracksPerCylinder = dgDrive.getTracksPerCylinder();
		pFAT32BootSect.setWNumHeads((WORD)generatedTracksPerCylinder);
		Object generatedHiddenSectors = piDrive.getHiddenSectors();
		pFAT32BootSect.setDHiddSec((DWORD)generatedHiddenSectors);
		TotalSectors = (DWORD)(generatedPartitionLength.getQuadPart() / generatedBytesPerSector);
		pFAT32BootSect.setDTotSec32(TotalSectors);
		Object generatedDTotSec32 = pFAT32BootSect.getDTotSec32();
		Object generatedWRsvdSecCnt = pFAT32BootSect.getWRsvdSecCnt();
		Object generatedBSecPerClus = pFAT32BootSect.getBSecPerClus();
		Object generatedBNumFATs = pFAT32BootSect.getBNumFATs();
		FatSize = ModernizedCProgram.GetFATSizeSectors(generatedDTotSec32, generatedWRsvdSecCnt, generatedBSecPerClus, generatedBNumFATs, BytesPerSect);
		pFAT32BootSect.setDFATSz32(FatSize);
		pFAT32BootSect.setWExtFlags(0);
		pFAT32BootSect.setWFSVer(0);
		pFAT32BootSect.setDRootClus(2);
		pFAT32BootSect.setWFSInfo(1);
		pFAT32BootSect.setWBkBootSec((WORD)BackupBootSect);
		pFAT32BootSect.setBDrvNum(-1024);
		pFAT32BootSect.setReserved1(0);
		pFAT32BootSect.setBBootSig(-1024);
		pFAT32BootSect.setDBS_VolID(VolumeId);
		Object generatedSVolLab = pFAT32BootSect.getSVolLab();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedSVolLab, VolId, 11);
		Object generatedSBS_FilSysType = pFAT32BootSect.getSBS_FilSysType();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedSBS_FilSysType, "FAT32   ", 8);
		((BYTE)pFAT32BootSect)[510] = -1024;
		((BYTE)pFAT32BootSect)[511] = -1024// FATGEN103.DOC says "NOTE: Many FAT documents mistakenly say that this 0xAA55 signature occupies the "last 2 bytes of// the boot sector". This statement is correct if - and only if - BPB_BytsPerSec is 512. If BPB_BytsPerSec is greater than// 512, the offsets of these signature bytes do not change (although it is perfectly OK for the last two bytes at the end;// FATGEN103.DOC says "NOTE: Many FAT documents mistakenly say that this 0xAA55 signature occupies the "last 2 bytes of// the boot sector". This statement is correct if - and only if - BPB_BytsPerSec is 512. If BPB_BytsPerSec is greater than// 512, the offsets of these signature bytes do not change (although it is perfectly OK for the last two bytes at the end
		// of the boot sector to also contain this signature)."//// Windows seems to only check the bytes at offsets 510 and 511. Other OSs might check the ones at the end of the sector,// so we'll put them there too.if (BytesPerSect != 512) {
			((BYTE)pFAT32BootSect)[BytesPerSect - 2] = -1024;
			((BYTE)pFAT32BootSect)[BytesPerSect - 1] = -1024;
		} 
		// FSInfo sect// FSInfo sectpFAT32FsInfo.setDLeadSig(-1024);
		pFAT32FsInfo.setDStrucSig(-1024);
		pFAT32FsInfo.setDFree_Count((DWORD)-1);
		pFAT32FsInfo.setDNxt_Free((DWORD)-1);
		pFAT32FsInfo.setDTrailSig(-1024);
		// First FAT Sector// Reserved cluster 1 media id in low byte// First FAT Sector// Reserved cluster 1 media id in low bytepFirstSectOfFat[0] = -1024;
		// Reserved cluster 2 EOC// Reserved cluster 2 EOCpFirstSectOfFat[1] = -1024;
		// end of cluster chain for root dir// end of cluster chain for root dirpFirstSectOfFat[2] = -1024// Write boot sector, fats// Sector 0 Boot Sector// Sector 1 FSInfo// Sector 2 More boot code - we write zeros here// Sector 3 unused// Sector 4 unused// Sector 5 unused// Sector 6 Backup boot sector;// Write boot sector, fats// Sector 0 Boot Sector// Sector 1 FSInfo// Sector 2 More boot code - we write zeros here// Sector 3 unused// Sector 4 unused// Sector 5 unused// Sector 6 Backup boot sector
		// Sector 7 Backup FSInfo sector// Sector 8 Backup 'more boot code'// zeroed sectors upto ReservedSectCount// FAT1  ReservedSectCount to ReservedSectCount + FatSize// ...// FATn  ReservedSectCount to ReservedSectCount + FatSize// RootDir - allocated to cluster2// Sector 7 Backup FSInfo sector// Sector 8 Backup 'more boot code'// zeroed sectors upto ReservedSectCount// FAT1  ReservedSectCount to ReservedSectCount + FatSize// ...// FATn  ReservedSectCount to ReservedSectCount + FatSize// RootDir - allocated to cluster2UserAreaSize = TotalSectors - ReservedSectCount - (NumFATs * FatSize);
		ClusterCount = UserAreaSize / SectorsPerCluster// Sanity check for a cluster count of >2^28, since the upper 4 bits of the cluster values in;// Sanity check for a cluster count of >2^28, since the upper 4 bits of the cluster values in
		// the FAT are reserved.if (ClusterCount > -1024) {
			do {
				ModernizedCProgram._uprintf("This drive has more than 2^28 clusters, try to specify a larger cluster size or use the default");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				;
			} while (0);
		} 
		// Sanity check - < 64K clusters means that the volume will be misdetected as FAT16if (ClusterCount < 65536) {
			do {
				ModernizedCProgram._uprintf("FAT32 must have at least 65536 clusters, try to specify a smaller cluster size or use the default");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				;
			} while (0);
		} 
		// Sanity check, make sure the fat is big enough// Convert the cluster count into a Fat sector count, and check the fat size value we calculated// earlier is OK.// Sanity check, make sure the fat is big enough// Convert the cluster count into a Fat sector count, and check the fat size value we calculated// earlier is OK.FatNeeded = ClusterCount * 4;
		FatNeeded += (BytesPerSect - 1);
		FatNeeded /= BytesPerSect;
		if (FatNeeded > FatSize) {
			do {
				ModernizedCProgram._uprintf("This drive is too big for large FAT32 format");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
				;
			} while (0);
		} 
		// Now we're committed - print some info first// Now we're committed - print some info firstModernizedCProgram._uprintf("Size : %s %u sectors", ModernizedCProgram.SizeToHumanReadable(generatedPartitionLength.getQuadPart(), 1, 0), TotalSectors);
		ModernizedCProgram._uprintf("Cluster size %d bytes, %d Bytes Per Sector", SectorsPerCluster * BytesPerSect, BytesPerSect);
		ModernizedCProgram._uprintf("Volume ID is %x:%x", VolumeId >> 16, VolumeId & -1024);
		ModernizedCProgram._uprintf("%d Reserved Sectors, %d Sectors per FAT, %d FATs", ReservedSectCount, FatSize, NumFATs);
		ModernizedCProgram._uprintf("%d Total clusters", ClusterCount);
		// Fix up the FSInfo sector// Fix up the FSInfo sectorpFAT32FsInfo.setDFree_Count((UserAreaSize / SectorsPerCluster) - 1);
		// clusters 0-1 reserved, we used cluster 2 for the root dir// clusters 0-1 reserved, we used cluster 2 for the root dirpFAT32FsInfo.setDNxt_Free(3);
		Object generatedDFree_Count = pFAT32FsInfo.getDFree_Count();
		ModernizedCProgram._uprintf("%d Free Clusters", generatedDFree_Count)// Work out the Cluster count;// Work out the Cluster count
		// First zero out ReservedSect + FatSize * NumFats + SectorsPerCluster// First zero out ReservedSect + FatSize * NumFats + SectorsPerClusterSystemAreaSize = ReservedSectCount + (NumFATs * FatSize) + SectorsPerCluster;
		ModernizedCProgram._uprintf("Clearing out %d sectors for reserved sectors, FATs and root cluster...", SystemAreaSize);
		// Not the most effective, but easy on RAM// Not the most effective, but easy on RAMpZeroSect = (BYTE)/*Error: Function owner not recognized*/calloc(BytesPerSect, BurstSize);
		if (!pZeroSect) {
			do {
				ModernizedCProgram._uprintf("Failed to allocate memory");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				;
			} while (0);
		} 
		for (i = 0; i < (SystemAreaSize + BurstSize - 1); i += BurstSize) {
			ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FORMAT, 3217, (uint64_t)i, (uint64_t)(SystemAreaSize + BurstSize));
			if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
				;
			} 
			if (ModernizedCProgram.write_sectors(hLogicalVolume, BytesPerSect, i, BurstSize, pZeroSect) != (BytesPerSect * BurstSize)) {
				do {
					ModernizedCProgram._uprintf("Error clearing reserved sectors");
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
					;
				} while (0);
			} 
		}
		ModernizedCProgram._uprintf("Initializing reserved sectors and FATs...")// Now we should write the boot sector and fsinfo twice, once at 0 and once at the backup boot sect position;// Now we should write the boot sector and fsinfo twice, once at 0 and once at the backup boot sect position
		for (i = 0; i < 2; i++) {
			int SectorStart = (i == 0) ? 0 : BackupBootSect;
			ModernizedCProgram.write_sectors(hLogicalVolume, BytesPerSect, SectorStart, 1, pFAT32BootSect);
			ModernizedCProgram.write_sectors(hLogicalVolume, BytesPerSect, SectorStart + 1, 1, pFAT32FsInfo);
		}
		// Write the first fat sector in the right placesfor (i = 0; i < NumFATs; i++) {
			int SectorStart = ReservedSectCount + (i * FatSize);
			ModernizedCProgram._uprintf("FAT #%d sector at address: %d", i, SectorStart);
			ModernizedCProgram.write_sectors(hLogicalVolume, BytesPerSect, SectorStart, 1, pFirstSectOfFat);
		}
		if (!(Flags & -1024)) {
			ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3229);
			if (!ModernizedCProgram.WritePBR(hLogicalVolume)) {
				ModernizedCProgram._uprintf("Could not write partition boot record - drive may not boot...");
			} 
		} 
		// Must do it here, as have issues when trying to write the PBR after a remount
		// Set the FAT32 volume label// Set the FAT32 volume labelModernizedCProgram.PrintStatusInfo(1, 1, 0, 3221)// Handle must be closed for SetVolumeLabel to work;// Handle must be closed for SetVolumeLabel to work
		do {
			if ((hLogicalVolume != (HANDLE)(true)) && (hLogicalVolume != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hLogicalVolume);
				hLogicalVolume = (HANDLE)(true);
			} 
		} while (0);
		VolumeName = ModernizedCProgram.GetLogicalName(DriveIndex, PartitionOffset, 1, 1);
		if ((VolumeName == ((Object)0)) || (!/*Error: Function owner not recognized*/SetVolumeLabelA(VolumeName, Label))) {
			ModernizedCProgram._uprintf("Could not set label: %s", ModernizedCProgram.WindowsErrorString());
		} 
		ModernizedCProgram._uprintf("Format completed.");
		r = 1;
		do {
			if ((hLogicalVolume != (HANDLE)(true)) && (hLogicalVolume != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hLogicalVolume);
				hLogicalVolume = (HANDLE)(true);
			} 
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)pFAT32BootSect);
			pFAT32BootSect = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)pFAT32FsInfo);
			pFAT32FsInfo = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)pFirstSectOfFat);
			pFirstSectOfFat = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)pZeroSect);
			pZeroSect = ((Object)0);
		} while (0);
		return r;
	}
	// Error messages for ext2fs
	public static Object error_message(Object error_code) {
		byte[] error_string = new byte[256];
		switch (error_code) {
		case EXT2_ET_INODE_BITMAP_WRITE:
		case EXT2_ET_BLOCK_BITMAP_CSUM_INVALID:
		case EXT2_ET_SB_CSUM_INVALID:
		case EXT2_ET_UNKNOWN_CSUM:
				return "Unknown checksum";
		case EXT2_ET_RO_UNSUPP_FEATURE:
		case EXT2_ET_FILESYSTEM_CORRUPTED:
				return "File system is corrupted";
		case EXT2_ET_LLSEEK_FAILED:
				return "Seek failed";
		case EXT2_ET_MAGIC_IO_CHANNEL:
		case EXT2_ET_UNSUPP_FEATURE:
		case EXT2_ET_BAD_CRC:
				return "Bad CRC";
		case EXT2_ET_UNEXPECTED_BLOCK_SIZE:
				return "Unexpected block size";
		case EXT2_ET_GDESC_BAD_BLOCK_MAP:
		case EXT2_ET_GDESC_READ:
		case EXT2_ET_FILE_RO:
				return "File is read-only";
		case EXT2_ET_TOO_MANY_INODES:
				return "Too many inodes";
		case EXT2_ET_MAGIC_GENERIC_BITMAP:
		case EXT2_ET_OP_NOT_SUPPORTED:
				return "Operation not supported";
		case EXT2_ET_BAD_BLOCK_IN_INODE_TABLE:
				return "Bad block in inode table";
		case EXT2_ET_UNIMPLEMENTED:
				return "Unsupported feature";
		case EXT2_ET_SHORT_WRITE:
				return "read/write error";
		case EXT2_ET_MAGIC_INODE_SCAN:
		case EXT2_ET_MMP_CSUM_INVALID:
				return "Invalid checksum";
		case EXT2_ET_BLOCK_BITMAP_READ:
		case EXT2_ET_JOURNAL_FLAGS_WRONG:
				return "Wrong journal flags";
		case EXT2_ET_MAGIC_INODE_BITMAP:
		case EXT2_ET_GDESC_BAD_INODE_TABLE:
				return "Bad map or table";
		case EXT2_ET_NO_MEMORY:
		case EXT2_ET_MISSING_INODE_TABLE:
				return "Missing inode table";
		case EXT2_ET_INODE_CORRUPTED:
		case EXT2_ET_MAGIC_IO_MANAGER:
		case EXT2_ET_MAGIC_BLOCK_BITMAP:
		case EXT2_ET_INODE_BITMAP_READ:
		case EXT2_ET_BAD_DEVICE_NAME:
				return "Bad device name";
		case EXT2_ET_BAD_MAGIC:
				return "Bad magic";
		case EXT2_ET_NO_DIRECTORY:
				return "No directory";
		case EXT2_ET_MAGIC_BADBLOCKS_ITERATE:
		case EXT2_ET_IO_CHANNEL_NO_SUPPORT_64:
				return "I/O Channel does not support 64-bit operation";
		case EXT2_ET_INODE_BITMAP_CSUM_INVALID:
		case EXT2_ET_CORRUPT_SUPERBLOCK:
				return "Superblock is corrupted";
		case EXT2_ET_BLOCK_ALLOC_FAIL:
		case EXT2_ET_INVALID_ARGUMENT:
				return "Invalid argument";
		case EXT2_ET_FILE_NOT_FOUND:
				return "File not found";
		case EXT2_ET_DIR_CORRUPTED:
				return "Corrupted entry";
		case EXT2_ET_GDESC_BAD_INODE_MAP:
		case EXT2_ET_INODE_CSUM_INVALID:
		case EXT2_ET_INODE_IS_GARBAGE:
				return "Inode is garbage";
		case EXT2_ET_RO_FILSYS:
				return "Read-only file system";
		case EXT2_ET_GDESC_WRITE:
		case EXT2_ET_INODE_ALLOC_FAIL:
				return "Out of memory";
		case EXT2_ET_NO_JOURNAL:
				return "No journal";
		case EXT2_ET_CALLBACK_NOTHANDLED:
				return "Unhandled callback";
		case EXT2_ET_BAD_DESC_SIZE:
				return "Bad descriptor size";
		case EXT2_ET_TOOSMALL:
				return "Too small";
		case EXT2_ET_DIR_CSUM_INVALID:
		case EXT2_ET_MAGIC_ICOUNT:
		case EXT2_ET_BLOCK_BITMAP_WRITE:
		case EXT2_ET_FILE_EXISTS:
				return "File exists";
		case EXT2_ET_JOURNAL_TOO_SMALL:
				return "Journal too small";
		case EXT2_ET_NEXT_INODE_READ:
		case EXT2_ET_MAGIC_BADBLOCKS_LIST:
		case EXT2_ET_DIR_EXISTS:
				return "Directory already exists";
		case EXT2_ET_NO_JOURNAL_SB:
				return "No journal superblock";
		case EXT2_ET_MAGIC_EXT2FS_FILSYS:
		case EXT2_ET_EXTENT_CSUM_INVALID:
		case EXT2_ET_SHORT_READ:
		case EXT2_ET_JOURNAL_NOT_BLOCK:
		case EXT2_ET_INODE_TABLE_READ:
		case EXT2_ET_CANCEL_REQUESTED:
				return "Cancel requested";
		case EXT2_ET_EXT_ATTR_CSUM_INVALID:
		case EXT2_ET_NO_CURRENT_NODE:
				return "No current node";
		case EXT2_ET_FILE_TOO_BIG:
				return "File too big";
		case EXT2_ET_EA_INODE_CORRUPTED:
				return "Inode is corrupted";
		case EXT2_ET_DIR_NO_SPACE:
				return "no space left";
		case EXT2_ET_CORRUPT_JOURNAL_SB:
				return "Journal Superblock is corrupted";
		case EXT2_ET_MAGIC_EXTENT_HANDLE:
		case EXT2_ET_INODE_TABLE_WRITE:
		default:
				if ((error_code > EXT2_ET_BASE) && error_code < (EXT2_ET_BASE + 1000)) {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(error_string, /*Error: sizeof expression not supported yet*/, "Unknown ext2fs error %ld (EXT2_ET_BASE + %ld)", error_code, error_code - EXT2_ET_BASE);
						(error_string)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError((ModernizedCProgram.FormatStatus == 0) ? (-1024 | (3 << 16) | (error_code & -1024)) : ModernizedCProgram.FormatStatus);
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(error_string, /*Error: sizeof expression not supported yet*/, ModernizedCProgram.WindowsErrorString());
							(error_string)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
						} while (0);
				} 
				return error_string;
		}
	}
	public static Object ext2fs_print_progress(Object cur_value, Object max_value) {
		int64_t last_value = -1;
		if (max_value == 0) {
			return 0;
		} 
		ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FORMAT, 3217, (uint64_t)((ModernizedCProgram.ext2_percent_start * max_value) + (ModernizedCProgram.ext2_percent_share * cur_value)), max_value);
		cur_value = (int64_t)(((double)cur_value / (double)max_value) * ((ModernizedCProgram.ext2_max_marker) < ((double)max_value) ? (ModernizedCProgram.ext2_max_marker) : ((double)max_value)));
		if ((cur_value < last_value) || (cur_value > last_value)) {
			last_value = cur_value;
			ModernizedCProgram._uprintfs("+");
		} 
		return ((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) ? EXT2_ET_CANCEL_REQUESTED : 0;
	}
	public static Object GetExtFsLabel(Object DriveIndex, Object PartitionOffset) {
		byte[] label = new byte[EXT2_LABEL_LEN + 1];
		 r = new ();
		 ext2fs = ((Object)0);
		 manager = ModernizedCProgram.nt_io_manager();
		byte volume_name = ModernizedCProgram.AltGetLogicalName(DriveIndex, PartitionOffset, 0, 1);
		if (volume_name == ((Object)0)) {
			return ((Object)0);
		} 
		r = ModernizedCProgram.ext2fs_open(volume_name, EXT2_FLAG_SKIP_MMP, 0, 0, manager, ext2fs);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(volume_name);
		if (r == 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(label, ext2fs.getSuper().getS_volume_name(), EXT2_LABEL_LEN);
			label[EXT2_LABEL_LEN] = 0;
		} 
		if (ext2fs != ((Object)0)) {
			ModernizedCProgram.ext2fs_close(ext2fs);
		} 
		return (r == 0) ? label : ((Object)0);
	}
	public static Object FormatExtFs(Object DriveIndex, Object PartitionOffset, Object BlockSize, Object FSName, Object Label, Object Flags) {
		// Mostly taken from mke2fs.confdouble reserve_ratio = 0.05;
		ext2fs_default_t[] ext2fs_default = new ext2fs_default_t[]{new ext2fs_default_t(3 * -1024, 1024, 128, 3), new ext2fs_default_t(512 * -1024, 1024, 128, 2), new ext2fs_default_t(4 * -1024, 4096, 256, 2), new ext2fs_default_t(16 * -1024, 4096, 256, 3), new ext2fs_default_t(1024 * -1024, 4096, 256, 4)};
		// "floppy"// "small"// "default"// "big"
		// "huge"BOOL ret = 0;
		byte volume_name = ((Object)0);
		int i;
		int count;
		ext2_super_block features = new ext2_super_block(0);
		 manager = ModernizedCProgram.nt_io_manager();
		 journal_size = new ();
		 size = 0;
		 cur = new ();
		 ext2fs = ((Object)0);
		 r = new ();
		uint8_t buf = ((Object)0);
		// Create a 32 MB disk image file to test// Set to nonzero so we can detect init issues
		volume_name = ModernizedCProgram.AltGetLogicalName(DriveIndex, PartitionOffset, 0, 1);
		if ((volume_name == ((Object)0)) | (/*Error: Function owner not recognized*/strlen(FSName) != 4) || (/*Error: Function owner not recognized*/strncmp(FSName, "ext", 3) != 0)) {
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		if (/*Error: Function owner not recognized*/strchr(volume_name, (byte)' ') != ((Object)0)) {
			ModernizedCProgram._uprintf("Notice: Using physical device to access partition data");
		} 
		if ((/*Error: Function owner not recognized*/strcmp(FSName, ModernizedCProgram.FileSystemLabel[fs_type.FS_EXT2]) != 0) && (/*Error: Function owner not recognized*/strcmp(FSName, ModernizedCProgram.FileSystemLabel[fs_type.FS_EXT3]) != 0)) {
			if (/*Error: Function owner not recognized*/strcmp(FSName, ModernizedCProgram.FileSystemLabel[fs_type.FS_EXT4]) == 0) {
				ModernizedCProgram._uprintf("ext4 file system is not supported, defaulting to ext3");
			} else {
					ModernizedCProgram._uprintf("Invalid ext file system version requested, defaulting to ext3");
			} 
		} 
		if ((/*Error: Function owner not recognized*/strcmp(FSName, ModernizedCProgram.FileSystemLabel[fs_type.FS_EXT2]) != 0) && (/*Error: Function owner not recognized*/strcmp(FSName, ModernizedCProgram.FileSystemLabel[fs_type.FS_EXT3]) != 0)) {
			FSName = ModernizedCProgram.FileSystemLabel[fs_type.FS_EXT3];
		} 
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3222, FSName);
		ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_INIT, (int)1, (uint64_t)(uintptr_t)((Object)0), 0);
		;
		// Figure out the volume size and block size// Figure out the volume size and block sizer = ModernizedCProgram.ext2fs_get_device_size2(volume_name, -1024, size);
		if ((r != 0) || (size == 0)) {
			ModernizedCProgram.FormatStatus = ModernizedCProgram.ext2_last_winerror(-1024);
			ModernizedCProgram._uprintf("Could not read device size: %s", ModernizedCProgram.error_message(r));
			;
		} 
		size *= -1024;
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (size < ext2fs_default[i].getMax_size()) {
				break;
			} 
		}
		((i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("i < ARRAYSIZE(ext2fs_default)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\format.c", 916))// NB: We validated that BlockSize is a power of two in FormatPartition();// NB: We validated that BlockSize is a power of two in FormatPartition()
		if (BlockSize == 0) {
			BlockSize = ext2fs_default[i].getBlock_size();
		} 
		size /= BlockSize;
		Object generatedExt2_super_block = features.getExt2_super_block();
		for (features.setExt2_super_block(0); /*Error: Function owner not recognized*/EXT2_BLOCK_SIZE_BITS(features) <= EXT2_MAX_BLOCK_LOG_SIZE; generatedExt2_super_block++) {
			if (/*Error: Function owner not recognized*/EXT2_BLOCK_SIZE(features) == BlockSize) {
				break;
			} 
		}
		((/*Error: Function owner not recognized*/EXT2_BLOCK_SIZE_BITS(features) <= EXT2_MAX_BLOCK_LOG_SIZE) ? (Object)0 : /*Error: Function owner not recognized*/_assert("EXT2_BLOCK_SIZE_BITS(&features) <= EXT2_MAX_BLOCK_LOG_SIZE", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\format.c", 925));
		// Set the blocks, reserved blocks and inodes// Set the blocks, reserved blocks and inodesfeatures.ext2fs_blocks_count_set(size);
		features.ext2fs_r_blocks_count_set(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(reserve_ratio * size));
		features.setExt2_super_block(1);
		features.setExt2_super_block(ext2fs_default[i].getInode_size());
		features.setExt2_super_block(((features.ext2fs_blocks_count() >> ext2fs_default[i].getInode_ratio()) > -1024) ? -1024 : (uint32_t)(features.ext2fs_blocks_count() >> ext2fs_default[i].getInode_ratio()));
		ModernizedCProgram._uprintf("%d possible inodes out of %lld blocks (block size = %d)", generatedExt2_super_block, size, /*Error: Function owner not recognized*/EXT2_BLOCK_SIZE(features));
		ModernizedCProgram._uprintf("%lld blocks (%0.1f%%) reserved for the super user", features.ext2fs_r_blocks_count(), reserve_ratio * 100.0);
		// Set features// Set featuresfeatures.ext2fs_set_feature_xattr();
		features.ext2fs_set_feature_resize_inode();
		features.ext2fs_set_feature_dir_index();
		features.ext2fs_set_feature_filetype();
		features.ext2fs_set_feature_sparse_super();
		features.ext2fs_set_feature_large_file();
		if (FSName[3] != (byte)'2') {
			features.ext2fs_set_feature_journal();
		} 
		generatedExt2_super_block[0] = ~0;
		features.setExt2_super_block(EXT2_DEFM_XATTR_USER | EXT2_DEFM_ACL);
		// Now that we have set our base features, initialize a virtual superblock// Now that we have set our base features, initialize a virtual superblockr = features.ext2fs_initialize(volume_name, EXT2_FLAG_EXCLUSIVE | EXT2_FLAG_64BITS, manager, ext2fs);
		if (r != 0) {
			ModernizedCProgram.FormatStatus = ModernizedCProgram.ext2_last_winerror(-1024);
			ModernizedCProgram._uprintf("Could not initialize %s features: %s", FSName, ModernizedCProgram.error_message(r));
			;
		} 
		// Zero 16 blocks of data from the start of our volume// Zero 16 blocks of data from the start of our volumebuf = /*Error: Function owner not recognized*/calloc(16, ext2fs.getIo().getBlock_size());
		((buf != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("buf != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\format.c", 959));
		r = ModernizedCProgram.io_channel_write_blk64(ext2fs.getIo(), 0, 16, buf);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)buf);
			buf = ((Object)0);
		} while (0);
		if (r != 0) {
			ModernizedCProgram.FormatStatus = ModernizedCProgram.ext2_last_winerror(-1024);
			ModernizedCProgram._uprintf("Could not zero %s superblock area: %s", FSName, ModernizedCProgram.error_message(r));
			;
		} 
		// Finish setting up the file systemdo {
			(Object)(/*Error: Function owner not recognized*/CoCreateGuid((GUID)ext2fs.getSuper().getS_uuid()));
		} while (0);
		ModernizedCProgram.ext2fs_init_csum_seed(ext2fs);
		ext2fs.getSuper().setS_def_hash_version(EXT2_HASH_HALF_MD4);
		do {
			(Object)(/*Error: Function owner not recognized*/CoCreateGuid((GUID)ext2fs.getSuper().getS_hash_seed()));
		} while (0);
		ext2fs.getSuper().setS_max_mnt_count(-1);
		ext2fs.getSuper().setS_creator_os(EXT2_OS_WINDOWS);
		ext2fs.getSuper().setS_errors(EXT2_ERRORS_CONTINUE);
		if (Label != ((Object)0)) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ext2fs.getSuper().getS_volume_name(), Label, (((size_t)(((((byte)Label) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(Label)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)Label) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(Label)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
				((byte)ext2fs.getSuper().getS_volume_name())[(((size_t)(((((byte)Label) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(Label)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)Label) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(Label)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
			} while (0);
		} 
		r = ModernizedCProgram.ext2fs_allocate_tables(ext2fs);
		if (r != 0) {
			ModernizedCProgram.FormatStatus = ModernizedCProgram.ext2_last_winerror(-1024);
			ModernizedCProgram._uprintf("Could not allocate %s tables: %s", FSName, ModernizedCProgram.error_message(r));
			;
		} 
		r = ModernizedCProgram.ext2fs_convert_subcluster_bitmap(ext2fs, ext2fs.getBlock_map());
		if (r != 0) {
			ModernizedCProgram._uprintf("Could set %s cluster bitmap: %s", FSName, ModernizedCProgram.error_message(r));
			;
		} 
		ModernizedCProgram.ext2_percent_start = 0.0;
		ModernizedCProgram.ext2_percent_share = (FSName[3] == (byte)'2') ? 1.0 : 0.5;
		ModernizedCProgram._uprintf("Creating %d inode sets: [1 marker = %0.1f set(s)]", ext2fs.getGroup_desc_count(), (((double)ext2fs.getGroup_desc_count() / ModernizedCProgram.ext2_max_marker) > (1.0) ? ((double)ext2fs.getGroup_desc_count() / ModernizedCProgram.ext2_max_marker) : (1.0)));
		for (i = 0; i < (int)ext2fs.getGroup_desc_count(); i++) {
			if (ModernizedCProgram.ext2fs_print_progress((int64_t)i, (int64_t)ext2fs.getGroup_desc_count())) {
				;
			} 
			cur = ModernizedCProgram.ext2fs_inode_table_loc(ext2fs, i);
			count = ModernizedCProgram.ext2fs_div_ceil((ext2fs.getSuper().getS_inodes_per_group() - ModernizedCProgram.ext2fs_bg_itable_unused(ext2fs, i)) * /*Error: Function owner not recognized*/EXT2_BLOCK_SIZE(ext2fs.getSuper()), /*Error: Function owner not recognized*/EXT2_BLOCK_SIZE(ext2fs.getSuper()));
			r = ModernizedCProgram.ext2fs_zero_blocks2(ext2fs, cur, count, cur, count);
			if (r != 0) {
				ModernizedCProgram.FormatStatus = ModernizedCProgram.ext2_last_winerror(-1024);
				ModernizedCProgram._uprintf("\r\nCould not zero inode set at position %llu (%d blocks): %s", cur, count, ModernizedCProgram.error_message(r));
				;
			} 
		}
		ModernizedCProgram._uprintfs("\r\n");
		// Create root and lost+found dirs// Create root and lost+found dirsr = ModernizedCProgram.ext2fs_mkdir(ext2fs, EXT2_ROOT_INO, EXT2_ROOT_INO, 0);
		if (r != 0) {
			ModernizedCProgram.FormatStatus = ModernizedCProgram.ext2_last_winerror(-1024);
			ModernizedCProgram._uprintf("Failed to create %s root dir: %s", FSName, ModernizedCProgram.error_message(r));
			;
		} 
		ext2fs.setUmask(77);
		r = ModernizedCProgram.ext2fs_mkdir(ext2fs, EXT2_ROOT_INO, 0, "lost+found");
		if (r != 0) {
			ModernizedCProgram.FormatStatus = ModernizedCProgram.ext2_last_winerror(-1024);
			ModernizedCProgram._uprintf("Failed to create %s 'lost+found' dir: %s", FSName, ModernizedCProgram.error_message(r));
			;
		} 
		// Create bitmapsfor (i = EXT2_ROOT_INO + 1; i < (int)/*Error: Function owner not recognized*/EXT2_FIRST_INODE(ext2fs.getSuper()); i++) {
			ModernizedCProgram.ext2fs_inode_alloc_stats(ext2fs, i, 1);
		}
		ModernizedCProgram.ext2fs_mark_ib_dirty(ext2fs);
		r = ModernizedCProgram.ext2fs_mark_inode_bitmap2(ext2fs.getInode_map(), EXT2_BAD_INO);
		if (r != 0) {
			ModernizedCProgram.FormatStatus = ModernizedCProgram.ext2_last_winerror(-1024);
			ModernizedCProgram._uprintf("Could not set inode bitmaps: %s", ModernizedCProgram.error_message(r));
			;
		} 
		ModernizedCProgram.ext2fs_inode_alloc_stats(ext2fs, EXT2_BAD_INO, 1);
		r = ModernizedCProgram.ext2fs_update_bb_inode(ext2fs, ((Object)0));
		if (r != 0) {
			ModernizedCProgram.FormatStatus = ModernizedCProgram.ext2_last_winerror(-1024);
			ModernizedCProgram._uprintf("Could not set inode stats: %s", ModernizedCProgram.error_message(r));
			;
		} 
		if (FSName[3] != (byte)'2') {
			ModernizedCProgram.ext2_percent_start = 0.5;
			journal_size = ModernizedCProgram.ext2fs_default_journal_size(ext2fs.getSuper().ext2fs_blocks_count());
			journal_size /= 2;
			ModernizedCProgram._uprintf("Creating %d journal blocks: [1 marker = %0.1f block(s)]", journal_size, (((double)journal_size / ModernizedCProgram.ext2_max_marker) > (1.0) ? ((double)journal_size / ModernizedCProgram.ext2_max_marker) : (1.0)));
			r = ModernizedCProgram.ext2fs_add_journal_inode(ext2fs, journal_size, EXT2_MKJOURNAL_NO_MNT_CHECK | ((Flags & -1024) ? EXT2_MKJOURNAL_LAZYINIT : 0));
			ModernizedCProgram._uprintfs("\r\n");
			if (r != 0) {
				ModernizedCProgram.FormatStatus = ModernizedCProgram.ext2_last_winerror(-1024);
				ModernizedCProgram._uprintf("Could not create %s journal: %s", FSName, ModernizedCProgram.error_message(r));
				;
			} 
		} 
		// Create the journal
		// Create a 'persistence.conf' file if requiredif (Flags & -1024) {
			byte name = "persistence.conf";
			byte[] data = "/ union\n";
			int written = 0;
			int fsize = /*Error: sizeof expression not supported yet*/ - 1;
			 ext2fd = new ();
			 inode_id = new ();
			uint32_t ctime = (uint32_t)/*Error: Function owner not recognized*/time(0);
			ext2_inode inode = new ext2_inode(0);
			inode.setExt2_inode(100644);
			inode.setExt2_inode(1);
			inode.setExt2_inode(ctime);
			inode.setExt2_inode(ctime);
			inode.setExt2_inode(ctime);
			inode.setExt2_inode(fsize);
			ModernizedCProgram.ext2fs_namei(ext2fs, EXT2_ROOT_INO, EXT2_ROOT_INO, name, inode_id);
			ModernizedCProgram.ext2fs_new_inode(ext2fs, EXT2_ROOT_INO, 10755, 0, inode_id);
			ModernizedCProgram.ext2fs_link(ext2fs, EXT2_ROOT_INO, name, inode_id, EXT2_FT_REG_FILE);
			ModernizedCProgram.ext2fs_inode_alloc_stats(ext2fs, inode_id, 1);
			inode.ext2fs_write_new_inode(ext2fs, inode_id);
			ModernizedCProgram.ext2fs_file_open(ext2fs, inode_id, EXT2_FILE_WRITE, ext2fd);
			if ((ModernizedCProgram.ext2fs_file_write(ext2fd, data, fsize, written) != 0) || (written != fsize)) {
				ModernizedCProgram._uprintf("Error: Could not create '%s' file", name);
			} else {
					ModernizedCProgram._uprintf("Created '%s' file", name);
			} 
			ModernizedCProgram.ext2fs_file_close(ext2fd);
		} 
		// You *do* want the LF at the end of the "/ union" line, else Debian Live bails out...
		// Finally we can call close() to get the file system gets created// Finally we can call close() to get the file system gets createdr = ModernizedCProgram.ext2fs_close(ext2fs);
		if (r != 0) {
			ModernizedCProgram.FormatStatus = ModernizedCProgram.ext2_last_winerror(-1024);
			ModernizedCProgram._uprintf("Could not create %s volume: %s", FSName, ModernizedCProgram.error_message(r));
			;
		} 
		ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FORMAT, 3217, 100, 100);
		ModernizedCProgram._uprintf("Done");
		ret = 1;
		ModernizedCProgram.ext2fs_free(ext2fs);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buf);
		return ret/*
		 * Call on VDS to format a partition
		 */;
	}
	public static Object FormatNativeVds(Object DriveIndex, Object PartitionOffset, Object ClusterSize, Object FSName, Object Label, Object Flags) {
		BOOL r = 0;
		BOOL bFoundVolume = 0;
		HRESULT hr = new HRESULT();
		ULONG ulFetched = new ULONG();
		IVdsServiceLoader pLoader = new IVdsServiceLoader();
		IVdsService pService = new IVdsService();
		IEnumVdsObject pEnum = new IEnumVdsObject();
		IUnknown pUnk = new IUnknown();
		byte VolumeName = ((Object)0);
		WCHAR wVolumeName = ((Object)0);
		WCHAR wLabel = ModernizedCProgram.utf8_to_wchar(Label);
		WCHAR wFSName = ModernizedCProgram.utf8_to_wchar(FSName);
		if ((/*Error: Function owner not recognized*/strcmp(FSName, ModernizedCProgram.FileSystemLabel[fs_type.FS_EXFAT]) == 0) && !((ModernizedCProgram.dur_mins == 0) && (ModernizedCProgram.dur_secs == 0))) {
			ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3220, FSName, ModernizedCProgram.dur_mins, ModernizedCProgram.dur_secs);
		} else {
				ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3222, FSName);
		} 
		ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_INIT, (int)1, (uint64_t)(uintptr_t)((Object)0), 0);
		;
		VolumeName = ModernizedCProgram.GetLogicalName(DriveIndex, PartitionOffset, 1, 1);
		wVolumeName = ModernizedCProgram.utf8_to_wchar(VolumeName);
		if (wVolumeName == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not read volume name");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		// Initialize COMdo {
			(Object)(/*Error: Function owner not recognized*/CoInitializeEx(((Object)0), tagCOINIT.COINIT_APARTMENTTHREADED));
		} while (0);
		do {
			(Object)(/*Error: Function owner not recognized*/CoInitializeSecurity(((Object)0), -1, ((Object)0), ((Object)0), 2, 3, ((Object)0), 0, ((Object)0)));
		} while (0);
		// Create a VDS Loader Instance// Create a VDS Loader Instancehr = /*Error: Function owner not recognized*/CoCreateInstance(ModernizedCProgram.CLSID_VdsLoader, ((Object)0), tagCLSCTX.CLSCTX_LOCAL_SERVER | tagCLSCTX.CLSCTX_REMOTE_SERVER, ModernizedCProgram.IID_IVdsServiceLoader, (Object)pLoader);
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not create VDS Loader Instance: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Load the VDS Service// Load the VDS Servicehr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pLoader, L"", pService);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pLoader);
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not load VDS Service: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Wait for the Service to become ready if needed// Wait for the Service to become ready if neededhr = (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pService));
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("VDS Service is not ready: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Query the VDS Service Providers// Query the VDS Service Providershr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pService, VDS_QUERY_SOFTWARE_PROVIDERS, pEnum);
		if (hr != ((HRESULT)-1024)) {
			do {
				if (hr == ((HRESULT)-1024)) {
					hr = -1024 | (3 << 16) | -1024;
				} 
				ModernizedCProgram.FormatStatus = hr;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
			} while (0);
			ModernizedCProgram._uprintf("Could not query VDS Service Providers: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		while (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pEnum, 1, pUnk, ulFetched) == ((HRESULT)-1024)) {
			IVdsProvider pProvider = new IVdsProvider();
			IVdsSwProvider pSwProvider = new IVdsSwProvider();
			IEnumVdsObject pEnumPack = new IEnumVdsObject();
			IUnknown pPackUnk = new IUnknown();
			if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
				;
			} 
			hr = /*Error: Function owner not recognized*/IUnknown_QueryInterface(pUnk, ModernizedCProgram.IID_IVdsProvider, (Object)pProvider);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IUnknown_Release(pUnk);
			if (hr != ((HRESULT)-1024)) {
				do {
					if (hr == ((HRESULT)-1024)) {
						hr = -1024 | (3 << 16) | -1024;
					} 
					ModernizedCProgram.FormatStatus = hr;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
				} while (0);
				ModernizedCProgram._uprintf("Could not get VDS Provider: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pProvider, ModernizedCProgram.IID_IVdsSwProvider, (Object)pSwProvider);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pProvider);
			if (hr != ((HRESULT)-1024)) {
				do {
					if (hr == ((HRESULT)-1024)) {
						hr = -1024 | (3 << 16) | -1024;
					} 
					ModernizedCProgram.FormatStatus = hr;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
				} while (0);
				ModernizedCProgram._uprintf("Could not get VDS Software Provider: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pSwProvider, pEnumPack);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pSwProvider);
			if (hr != ((HRESULT)-1024)) {
				do {
					if (hr == ((HRESULT)-1024)) {
						hr = -1024 | (3 << 16) | -1024;
					} 
					ModernizedCProgram.FormatStatus = hr;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
				} while (0);
				ModernizedCProgram._uprintf("Could not get VDS Software Provider Packs: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			while (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pEnumPack, 1, pPackUnk, ulFetched) == ((HRESULT)-1024)) {
				IVdsPack pPack = new IVdsPack();
				IEnumVdsObject pEnumVolume = new IEnumVdsObject();
				IUnknown pVolumeUnk = new IUnknown();
				if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
					;
				} 
				hr = /*Error: Function owner not recognized*/IUnknown_QueryInterface(pPackUnk, ModernizedCProgram.IID_IVdsPack, (Object)pPack);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/IUnknown_Release(pPackUnk);
				if (hr != ((HRESULT)-1024)) {
					do {
						if (hr == ((HRESULT)-1024)) {
							hr = -1024 | (3 << 16) | -1024;
						} 
						ModernizedCProgram.FormatStatus = hr;
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
					} while (0);
					ModernizedCProgram._uprintf("Could not query VDS Software Provider Pack: %s", ModernizedCProgram.WindowsErrorString());
					;
				} 
				hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pPack, pEnumVolume);
				if (hr != ((HRESULT)-1024)) {
					do {
						if (hr == ((HRESULT)-1024)) {
							hr = -1024 | (3 << 16) | -1024;
						} 
						ModernizedCProgram.FormatStatus = hr;
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
					} while (0);
					ModernizedCProgram._uprintf("Could not query VDS volumes: %s", ModernizedCProgram.WindowsErrorString());
					;
				} 
				while (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pEnumVolume, 1, pVolumeUnk, ulFetched) == ((HRESULT)-1024)) {
					BOOL match = new BOOL();
					HRESULT hr2 = ((HRESULT)-1024);
					 VolumeProps = new ();
					LPWSTR wszPathArray = new LPWSTR();
					ULONG ulPercentCompleted = new ULONG();
					ULONG ulNumberOfPaths = new ULONG();
					USHORT usFsVersion = 0;
					IVdsVolume pVolume = new IVdsVolume();
					IVdsAsync pAsync = new IVdsAsync();
					IVdsVolumeMF3 pVolumeMF3 = new IVdsVolumeMF3();
					if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
						;
					} 
					hr = /*Error: Function owner not recognized*/IUnknown_QueryInterface(pVolumeUnk, ModernizedCProgram.IID_IVdsVolume, (Object)pVolume);
					if (hr != ((HRESULT)-1024)) {
						do {
							if (hr == ((HRESULT)-1024)) {
								hr = -1024 | (3 << 16) | -1024;
							} 
							ModernizedCProgram.FormatStatus = hr;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
						} while (0);
						ModernizedCProgram._uprintf("Could not query VDS Volume Interface: %s", ModernizedCProgram.WindowsErrorString());
						;
					} 
					hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pVolume, VolumeProps);
					if ((hr != ((HRESULT)-1024)) && (hr != ((HRESULT)-1024))) {
						do {
							if (hr == ((HRESULT)-1024)) {
								hr = -1024 | (3 << 16) | -1024;
							} 
							ModernizedCProgram.FormatStatus = hr;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
						} while (0);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pVolume);
						ModernizedCProgram._uprintf("Could not query VDS Volume Properties: %s", ModernizedCProgram.WindowsErrorString());
						continue;
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CoTaskMemFree(VolumeProps.getPwszName());
					hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pVolume, ModernizedCProgram.IID_IVdsVolumeMF3, (Object)pVolumeMF3);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pVolume);
					if (hr != ((HRESULT)-1024)) {
						do {
							if (hr == ((HRESULT)-1024)) {
								hr = -1024 | (3 << 16) | -1024;
							} 
							ModernizedCProgram.FormatStatus = hr;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
						} while (0);
						ModernizedCProgram._uprintf("Could not access VDS VolumeMF3 interface: %s", ModernizedCProgram.WindowsErrorString());
						continue;
					} 
					hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pVolumeMF3, wszPathArray, ulNumberOfPaths);
					if (hr != ((HRESULT)-1024)) {
						do {
							if (hr == ((HRESULT)-1024)) {
								hr = -1024 | (3 << 16) | -1024;
							} 
							ModernizedCProgram.FormatStatus = hr;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
						} while (0);
						ModernizedCProgram._uprintf("Could not query VDS VolumeGuidPathnames: %s", ModernizedCProgram.WindowsErrorString());
						continue;
					} 
					if (ulNumberOfPaths > 1) {
						ModernizedCProgram._uprintf("Notice: Volume %S has more than one GUID...", wszPathArray[0]);
					} 
					match = (/*Error: Function owner not recognized*/wcscmp(wVolumeName, wszPathArray[0]) == 0);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CoTaskMemFree(wszPathArray);
					if (!match) {
						continue;
					} 
					bFoundVolume = 1;
					if (/*Error: Function owner not recognized*/strcmp(Label, ModernizedCProgram.FileSystemLabel[fs_type.FS_UDF]) == 0) {
						usFsVersion = ModernizedCProgram.ReadSetting32("UseUdfVersion");
					} 
					if (ClusterSize < -1024) {
						ClusterSize = 0;
						ModernizedCProgram._uprintf("Using default cluster size");
					} else {
							ModernizedCProgram._uprintf("Using cluster size: %d bytes", ClusterSize);
					} 
					ModernizedCProgram.format_percent = 0.0;
					ModernizedCProgram._uprintf("%s format was selected", (Flags & -1024) ? "Quick" : "Slow");
					if (Flags & -1024) {
						ModernizedCProgram._uprintf("NTFS compression is enabled");
					} 
					hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pVolumeMF3, wFSName, usFsVersion, ClusterSize, wLabel, Flags, pAsync);
					while (((HRESULT)(hr) >= 0)) {
						if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pAsync);
							break;
						} 
						hr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pAsync, hr2, ulPercentCompleted);
						if (((HRESULT)(hr) >= 0)) {
							if (Flags & -1024) {
								ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3218, (ulPercentCompleted < 100) ? 1 : 2, 2);
								ModernizedCProgram.UpdateProgress(action_type.OP_CREATE_FS, (double)ulPercentCompleted);
							} else {
									ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FORMAT, 3217, ulPercentCompleted, 100);
							} 
							hr = hr2;
							if (hr == ((HRESULT)-1024)) {
								break;
							} 
							if (hr == ((HRESULT)-1024)) {
								hr = ((HRESULT)-1024);
							} 
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(500);
					}
					if (!((HRESULT)(hr) >= 0)) {
						do {
							if (hr == ((HRESULT)-1024)) {
								hr = -1024 | (3 << 16) | -1024;
							} 
							ModernizedCProgram.FormatStatus = hr;
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(hr);
						} while (0);
						ModernizedCProgram._uprintf("Could not format drive: %s", ModernizedCProgram.WindowsErrorString());
						;
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pAsync);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pVolumeMF3);
					if (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
						ModernizedCProgram._uprintf("Format completed.");
						r = 1;
					} 
					;
				}
			}
		}
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)VolumeName);
			VolumeName = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wVolumeName);
			wVolumeName = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wLabel);
			wLabel = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wFSName);
			wFSName = ((Object)0);
		} while (0);
		return r/*
		 * Call on fmifs.dll's FormatEx() to format the drive
		 */;
	}
	public static Object FormatNative(Object DriveIndex, Object PartitionOffset, Object ClusterSize, Object FSName, Object Label, Object Flags) {
		BOOL r = 0;
		FormatEx_t pfFormatEx = ((Object)0);
		EnableVolumeCompression_t pfEnableVolumeCompression = ((Object)0);
		byte locale;
		byte VolumeName = ((Object)0);
		WCHAR wVolumeName = ((Object)0);
		WCHAR wLabel = ModernizedCProgram.utf8_to_wchar(Label);
		WCHAR wFSName = ModernizedCProgram.utf8_to_wchar(FSName);
		size_t i = new size_t();
		if ((/*Error: Function owner not recognized*/strcmp(FSName, ModernizedCProgram.FileSystemLabel[fs_type.FS_EXFAT]) == 0) && !((ModernizedCProgram.dur_mins == 0) && (ModernizedCProgram.dur_secs == 0))) {
			ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3220, FSName, ModernizedCProgram.dur_mins, ModernizedCProgram.dur_secs);
		} else {
				ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3222, FSName);
		} 
		VolumeName = ModernizedCProgram.GetLogicalName(DriveIndex, PartitionOffset, 1, 1);
		wVolumeName = ModernizedCProgram.utf8_to_wchar(VolumeName);
		if (wVolumeName == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not read volume name");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		// a trailing backslash, but EnableCompression() fails without...// Remove trailing backslash// a trailing backslash, but EnableCompression() fails without...// Remove trailing backslashwVolumeName[/*Error: Function owner not recognized*/wcslen(wVolumeName) - 1] = 0// LoadLibrary("fmifs.dll") appears to changes the locale, which can lead to;// LoadLibrary("fmifs.dll") appears to changes the locale, which can lead to
		// problems with tolower(). Make sure we restore the locale. For more details,// see http://comments.gmane.org/gmane.comp.gnu.mingw.user/39300// problems with tolower(). Make sure we restore the locale. For more details,// see http://comments.gmane.org/gmane.comp.gnu.mingw.user/39300locale = /*Error: Function owner not recognized*/setlocale(0, ((Object)0));
		do {
			if (pfFormatEx == ((Object)0)) {
				pfFormatEx = (FormatEx_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("fmifs"), "FormatEx");
			} 
			if (pfFormatEx == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "FormatEx", "fmifs", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		if (pfEnableVolumeCompression == ((Object)0)) {
			pfEnableVolumeCompression = (EnableVolumeCompression_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("fmifs"), "EnableVolumeCompression");
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/setlocale(0, locale);
		if (ClusterSize < -1024) {
			ClusterSize = 0;
			ModernizedCProgram._uprintf("Using default cluster size");
		} else {
				ModernizedCProgram._uprintf("Using cluster size: %d bytes", ClusterSize);
		} 
		// 0 is FormatEx's value for default, which we need to use for UDF
		ModernizedCProgram.format_percent = 0.0;
		ModernizedCProgram.task_number = 0;
		ModernizedCProgram._uprintf("%s format was selected", (Flags & -1024) ? "Quick" : "Slow");
		for (i = 0; i < 4; i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfFormatEx(wVolumeName, ModernizedCProgram.SelectedDrive.getMediaType(), wFSName, wLabel, (Flags & -1024), ClusterSize, FormatExCallback);
			if (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) || (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
				break;
			} 
			ModernizedCProgram._uprintf("%s - Retrying...", ModernizedCProgram.WindowsErrorString());
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(5000);
		}
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
			;
		} 
		if (Flags & -1024) {
			wVolumeName[/*Error: Function owner not recognized*/wcslen(wVolumeName)] = (byte)'\\';
			if (/*Error: Function owner not recognized*/pfEnableVolumeCompression(wVolumeName, .FPF_COMPRESSED)) {
				ModernizedCProgram._uprintf("Enabled NTFS compression");
			} else {
					ModernizedCProgram._uprintf("Could not enable NTFS compression: %s", ModernizedCProgram.WindowsErrorString());
			} 
		} 
		if (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
			ModernizedCProgram._uprintf("Format completed.");
			r = 1;
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)VolumeName);
			VolumeName = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wVolumeName);
			wVolumeName = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wLabel);
			wLabel = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wFSName);
			wFSName = ((Object)0);
		} while (0);
		return r;
	}
	public static Object FormatPartition(Object DriveIndex, Object PartitionOffset, Object UnitAllocationSize, Object FSType, Object Label, Object Flags) {
		if ((DriveIndex < -1024) || (DriveIndex > -1024) || (FSType >= fs_type.FS_MAX) || ((UnitAllocationSize != 0) && (UnitAllocationSize & (UnitAllocationSize - 1)))) {
			-1024 | (3 << 16) | -1024;
			return 0;
		} 
		// The following validates that UnitAllocationSize is a power of 2
		ModernizedCProgram.actual_fs_type = FSType;
		if ((FSType == fs_type.FS_FAT32) && ((ModernizedCProgram.SelectedDrive.getDiskSize() > (32 * -1024)) || (ModernizedCProgram.force_large_fat32) || (Flags & -1024))) {
			return ModernizedCProgram.FormatLargeFAT32(DriveIndex, PartitionOffset, UnitAllocationSize, ModernizedCProgram.FileSystemLabel[FSType], Label, Flags);
		}  else if (FSType >= fs_type.FS_EXT2) {
			return ModernizedCProgram.FormatExtFs(DriveIndex, PartitionOffset, UnitAllocationSize, ModernizedCProgram.FileSystemLabel[FSType], Label, Flags);
		}  else if (ModernizedCProgram.use_vds) {
			return ModernizedCProgram.FormatNativeVds(DriveIndex, PartitionOffset, UnitAllocationSize, ModernizedCProgram.FileSystemLabel[FSType], Label, Flags);
		} else {
				return ModernizedCProgram.FormatNative(DriveIndex, PartitionOffset, UnitAllocationSize, ModernizedCProgram.FileSystemLabel[FSType], Label, Flags/*
				 * Call on fmifs.dll's Chkdsk() to fixup the filesystem
				 */);
		} 
	}
	public static Object CheckDisk(byte DriveLetter) {
		BOOL r = 0;
		Chkdsk_t pfChkdsk = ((Object)0);
		WCHAR[] wDriveRoot = L"?:\\";
		WCHAR[] wFSType = new WCHAR();
		size_t i = new size_t();
		wDriveRoot[0] = (WCHAR)DriveLetter;
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3223);
		do {
			if (pfChkdsk == ((Object)0)) {
				pfChkdsk = (Chkdsk_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Fmifs"), "Chkdsk");
			} 
			if (pfChkdsk == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "Chkdsk", "Fmifs", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowTextW(ModernizedCProgram.hFileSystem, wFSType, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/))// We may have a " (Default)" trail;// We may have a " (Default)" trail
		for (i = 0; i < /*Error: Function owner not recognized*/wcslen(wFSType); i++) {
			if (wFSType[i] == (byte)' ') {
				wFSType[i] = 0;
				break;
			} 
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfChkdsk(wDriveRoot, wFSType, 0, 0, 0, 0, ((Object)0), ((Object)0), ChkdskCallback);
		if (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
			ModernizedCProgram._uprintf("NTFS Fixup completed.\n");
			r = 1;
		} 
	}
	public static Object ClearMBRGPT(Object hPhysicalDrive, Object DiskSize, Object SectorSize, Object add1MB) {
		BOOL r = 0;
		uint64_t i = new uint64_t();
		uint64_t j = new uint64_t();
		uint64_t last_sector = DiskSize / SectorSize;
		uint64_t num_sectors_to_clear = new uint64_t();
		byte pBuf = (byte)/*Error: Function owner not recognized*/calloc(SectorSize, 1);
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3224);
		if (pBuf == ((Object)0)) {
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		// We try to clear at least 1MB + the PBR when Large FAT32 is selected (add1MB), but// don't do it otherwise, as it seems unnecessary and may take time for slow drives.// Also, for various reasons (one of which being that Windows seems to have issues// with GPT drives that contain a lot of small partitions) we try not not to clear// sectors further than the lowest partition already residing on the disk.// We try to clear at least 1MB + the PBR when Large FAT32 is selected (add1MB), but// don't do it otherwise, as it seems unnecessary and may take time for slow drives.// Also, for various reasons (one of which being that Windows seems to have issues// with GPT drives that contain a lot of small partitions) we try not not to clear// sectors further than the lowest partition already residing on the disk.num_sectors_to_clear = ((ModernizedCProgram.SelectedDrive.getFirstDataSector()) < ((DWORD)((add1MB ? 2048 : 0) + 128)) ? (ModernizedCProgram.SelectedDrive.getFirstDataSector()) : ((DWORD)((add1MB ? 2048 : 0) + 128)))// Special case for big floppy disks (FirstDataSector = 0);// Special case for big floppy disks (FirstDataSector = 0)
		if (num_sectors_to_clear < 4) {
			num_sectors_to_clear = (DWORD)((add1MB ? 2048 : 0) + 128);
		} 
		ModernizedCProgram._uprintf("Erasing %d sectors", num_sectors_to_clear);
		for (i = 0; i < num_sectors_to_clear; i++) {
			for (j = 1; j <= 4; j++) {
				if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
					;
				} 
				if (ModernizedCProgram.write_sectors(hPhysicalDrive, SectorSize, i, 1, pBuf) != SectorSize) {
					if (j >= 4) {
						;
					} 
					ModernizedCProgram._uprintf("Retrying in %d seconds...", 5000 / 1000);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(ModernizedCProgram.CheckDriveAccess(5000, 0));
				} 
			}
		}
		for (i = last_sector - 128; i < last_sector; i++) {
			for (j = 1; j <= 4; j++) {
				if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
					;
				} 
				if (ModernizedCProgram.write_sectors(hPhysicalDrive, SectorSize, i, 1, pBuf) != SectorSize) {
					if (j < 4) {
						ModernizedCProgram._uprintf("Retrying in %d seconds...", 5000 / 1000);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(ModernizedCProgram.CheckDriveAccess(5000, 0));
					} else {
							ModernizedCProgram._uprintf("Warning: Failed to clear backup GPT...");
							r = 1;
							;
					} 
				} 
			}
		}
		r = 1;
		return r/*
		 * Process the Master Boot Record
		 */;
	}
	public static Object WriteMBR(Object hPhysicalDrive) {
		BOOL r = 0;
		DWORD size = new DWORD();
		byte buffer = ((Object)0);
		FAKE_FD fake_fd = new FAKE_FD(0);
		FILE fp = (FILE)fake_fd;
		byte using_msg = "Using %s MBR";
		//	AnalyzeMBR(hPhysicalDrive, "Drive", FALSE);
		if (ModernizedCProgram.SelectedDrive.getSectorSize() < 512) {
			;
		} 
		if (ModernizedCProgram.partition_type == _PARTITION_STYLE.PARTITION_STYLE_GPT) {
			fake_fd.set_handle((byte)hPhysicalDrive);
			ModernizedCProgram.set_bytes_per_sector(ModernizedCProgram.SelectedDrive.getSectorSize());
			ModernizedCProgram._uprintf(using_msg, "Rufus protective");
			r = fp.write_rufus_gpt_mbr();
			;
		} 
		// Add a notice in the protective MBR
		// FormatEx rewrites the MBR and removes the LBA attribute of FAT16// and FAT32 partitions - we need to correct this in the MBR// FormatEx rewrites the MBR and removes the LBA attribute of FAT16// and FAT32 partitions - we need to correct this in the MBRbuffer = (byte)/*Error: Function owner not recognized*/_mm_malloc(ModernizedCProgram.SelectedDrive.getSectorSize(), 16);
		if (buffer == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not allocate memory for MBR");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		if (!ModernizedCProgram.read_sectors(hPhysicalDrive, ModernizedCProgram.SelectedDrive.getSectorSize(), 0, 1, buffer)) {
			ModernizedCProgram._uprintf("Could not read MBR\n");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		switch (((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 327, 0, 0))), 0))) {
		case fs_type.FS_FAT16:
				if (buffer[-1024] == -1024) {
					ModernizedCProgram._uprintf("Partition is already FAT16 LBA...\n");
				}  else if ((buffer[-1024] != -1024) && (buffer[-1024] != -1024)) {
					ModernizedCProgram._uprintf("Warning: converting a non FAT16 partition to FAT16 LBA: FS type=0x%02x\n", buffer[-1024]);
				} 
				buffer[-1024] = -1024;
				break;
		case fs_type.FS_FAT32:
				if (buffer[-1024] == -1024) {
					ModernizedCProgram._uprintf("Partition is already FAT32 LBA...\n");
				}  else if (buffer[-1024] != -1024) {
					ModernizedCProgram._uprintf("Warning: converting a non FAT32 partition to FAT32 LBA: FS type=0x%02x\n", buffer[-1024]);
				} 
				buffer[-1024] = -1024;
				break;
		}
		if ((ModernizedCProgram.boot_type != boot_type.BT_NON_BOOTABLE) && (ModernizedCProgram.target_type == target_type.TT_BIOS)) {
			buffer[-1024] = (/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1016) == 1) ? (BYTE)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDiskID), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDiskID), 327, 0, 0))), 0)) : -1024;
			ModernizedCProgram._uprintf("Set bootable USB partition as 0x%02X\n", buffer[-1024]);
		} 
		// Set first partition bootable - masquerade as per the DiskID selected
		if (!ModernizedCProgram.write_sectors(hPhysicalDrive, ModernizedCProgram.SelectedDrive.getSectorSize(), 0, 1, buffer)) {
			ModernizedCProgram._uprintf("Could not write MBR\n");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		fake_fd.set_handle((byte)hPhysicalDrive);
		ModernizedCProgram.set_bytes_per_sector(ModernizedCProgram.SelectedDrive.getSectorSize())// What follows is really a case statement with complex conditions listed;// What follows is really a case statement with complex conditions listed
		// by order of preferenceif ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getUses_minint()) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) && (ModernizedCProgram.allow_dual_uefi_bios) && (ModernizedCProgram.target_type == target_type.TT_BIOS)) {
			;
		} 
		// Non bootable or forced UEFI (zeroed MBR)if ((ModernizedCProgram.boot_type == boot_type.BT_NON_BOOTABLE) || (ModernizedCProgram.target_type == target_type.TT_UEFI)) {
			ModernizedCProgram._uprintf(using_msg, "Zeroed");
			r = fp.write_zero_mbr();
			;
		} 
		// Syslinuxif ((ModernizedCProgram.boot_type == boot_type.BT_SYSLINUX_V4) || (ModernizedCProgram.boot_type == boot_type.BT_SYSLINUX_V6) || ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getSl_version() != 0))) {
			ModernizedCProgram._uprintf(using_msg, "Syslinux");
			r = fp.write_syslinux_mbr();
			;
		} 
		// Grub 2.0if (((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getHas_grub2())) || (ModernizedCProgram.boot_type == boot_type.BT_GRUB2)) {
			ModernizedCProgram._uprintf(using_msg, "Grub 2.0");
			r = fp.write_grub2_mbr();
			;
		} 
		// Grub4DOSif (((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getHas_grub4dos())) || (ModernizedCProgram.boot_type == boot_type.BT_GRUB4DOS)) {
			ModernizedCProgram._uprintf(using_msg, "Grub4DOS");
			r = fp.write_grub4dos_mbr();
			;
		} 
		// ReactOSif (ModernizedCProgram.boot_type == boot_type.BT_REACTOS) {
			ModernizedCProgram._uprintf(using_msg, "ReactOS");
			r = fp.write_reactos_mbr();
			;
		} 
		// KolibriOSif ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getHas_kolibrios()) && (((ModernizedCProgram.fs_type == fs_type.FS_FAT16) || (ModernizedCProgram.fs_type == fs_type.FS_FAT32)))) {
			ModernizedCProgram._uprintf(using_msg, "KolibriOS");
			r = fp.write_kolibrios_mbr();
			;
		} 
		return r/*
		 * Write Secondary Boot Record (usually right after the MBR)
		 */;
	}
	public static Object WriteSBR(Object hPhysicalDrive) {
		// TODO: Do we need anything special for 4K sectors?DWORD size = new DWORD();
		DWORD max_size = new DWORD();
		DWORD mbr_size = -1024;
		int r;
		int sub_type = ModernizedCProgram.boot_type;
		byte buf = ((Object)0);
		FAKE_FD fake_fd = new FAKE_FD(0);
		FILE fp = (FILE)fake_fd;
		if (ModernizedCProgram.partition_type == _PARTITION_STYLE.PARTITION_STYLE_GPT) {
			return 1;
		} 
		fake_fd.set_handle((byte)hPhysicalDrive);
		ModernizedCProgram.set_bytes_per_sector(ModernizedCProgram.SelectedDrive.getSectorSize())// Ensure that we have sufficient space for the SBR;// Ensure that we have sufficient space for the SBR
		max_size = (/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1021) == 1) ? (DWORD)(ModernizedCProgram.SelectedDrive.getSectorsPerTrack() * ModernizedCProgram.SelectedDrive.getSectorSize()) : 1 * -1024;
		max_size -= mbr_size// Syslinux has precedence over Grub;// Syslinux has precedence over Grub
		if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (!(ModernizedCProgram.img_report.getSl_version() != 0))) {
			if (ModernizedCProgram.img_report.getHas_grub4dos()) {
				sub_type = boot_type.BT_GRUB4DOS;
			} 
			if (ModernizedCProgram.img_report.getHas_grub2()) {
				sub_type = boot_type.BT_GRUB2;
			} 
		} 
		switch (sub_type) {
		case boot_type.BT_GRUB2:
				if (ModernizedCProgram.grub2_buf != ((Object)0)) {
					ModernizedCProgram._uprintf("Writing Grub 2.0 SBR (from download) %s", ModernizedCProgram.IsBufferInDB(ModernizedCProgram.grub2_buf, ModernizedCProgram.grub2_len) ? "â" : "â");
					buf = ModernizedCProgram.grub2_buf;
					size = (DWORD)ModernizedCProgram.grub2_len;
				} else {
						ModernizedCProgram._uprintf("Writing Grub 2.0 SBR (from embedded)");
						buf = ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)(true))), "core.img", size, 0);
						if (buf == ((Object)0)) {
							ModernizedCProgram._uprintf("Could not access core.img");
							return 0;
						} 
				} 
				break;
		case boot_type.BT_GRUB4DOS:
				ModernizedCProgram._uprintf("Writing Grub4Dos SBR");
				buf = ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)(true))), "grldr.mbr", size, 0);
				if ((buf == ((Object)0)) || (size <= mbr_size)) {
					ModernizedCProgram._uprintf("grldr.mbr is either not present or too small");
					return 0;
				} 
				buf = buf[mbr_size];
				size -= mbr_size;
				break;
		default:
				return 1;
		}
		if (size > max_size) {
			ModernizedCProgram._uprintf("  SBR size is too large - You may need to uncheck 'Add fixes for old BIOSes'.");
			return 0;
		} 
		r = fp.write_data(mbr_size, buf, (uint64_t)size);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.grub2_buf);
			ModernizedCProgram.grub2_buf = ((Object)0);
		} while (0);
		return (r != 0/*
		 * Process the Partition Boot Record
		 */);
	}
	public static Object bt_to_name() {
		switch (ModernizedCProgram.boot_type) {
		case boot_type.BT_FREEDOS:
				return "FreeDOS";
		case boot_type.BT_REACTOS:
				return "ReactOS";
		default:
				return ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getHas_kolibrios())) ? "KolibriOS" : "Standard";
		}
	}
	public static Object WritePBR(Object hLogicalVolume) {
		int i;
		FAKE_FD fake_fd = new FAKE_FD(0);
		FILE fp = (FILE)fake_fd;
		byte using_msg = "Using %s %s partition boot record";
		fake_fd.set_handle((byte)hLogicalVolume);
		ModernizedCProgram.set_bytes_per_sector(ModernizedCProgram.SelectedDrive.getSectorSize());
		Object generated_offset = fake_fd.get_offset();
		switch (ModernizedCProgram.actual_fs_type) {
		case fs_type.FS_NTFS:
				ModernizedCProgram._uprintf(using_msg, ModernizedCProgram.bt_to_name(), "NTFS");
				if (!fp.is_ntfs_fs()) {
					ModernizedCProgram._uprintf("New volume does not have an NTFS boot sector - aborting\n");
					break;
				} 
				ModernizedCProgram._uprintf("Confirmed new volume has an NTFS boot sector\n");
				if (!fp.write_ntfs_br()) {
					break;
				} 
				return 1;
		case fs_type.FS_FAT32:
				ModernizedCProgram._uprintf(using_msg, ModernizedCProgram.bt_to_name(), "FAT32");
				for (i = 0; i < 2; i++) {
					if (!fp.is_fat_32_fs()) {
						ModernizedCProgram._uprintf("New volume does not have a %s FAT32 boot sector - aborting\n", i ? "secondary" : "primary");
						break;
					} 
					ModernizedCProgram._uprintf("Confirmed new volume has a %s FAT32 boot sector\n", i ? "secondary" : "primary");
					ModernizedCProgram._uprintf("Setting %s FAT32 boot sector for boot...\n", i ? "secondary" : "primary");
					if (ModernizedCProgram.boot_type == boot_type.BT_FREEDOS) {
						if (!fp.write_fat_32_fd_br(0)) {
							break;
						} 
					}  else if (ModernizedCProgram.boot_type == boot_type.BT_REACTOS) {
						if (!fp.write_fat_32_ros_br(0)) {
							break;
						} 
					}  else if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getHas_kolibrios())) {
						if (!fp.write_fat_32_kos_br(0)) {
							break;
						} 
					}  else if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && ((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi()))) {
						if (!fp.write_fat_32_pe_br(0)) {
							break;
						} 
					}  else if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) {
						if (!fp.write_fat_32_nt_br(0)) {
							break;
						} 
					} else {
							if (!fp.write_fat_32_br(0)) {
								break;
							} 
					} 
					if (!fp.write_partition_physical_disk_drive_id_fat32()) {
						break;
					} 
					generated_offset += 6 * ModernizedCProgram.SelectedDrive.getSectorSize();
				}
				return 1;
		case fs_type.FS_FAT16:
				ModernizedCProgram._uprintf(using_msg, ModernizedCProgram.bt_to_name(), "FAT16");
				if (!fp.is_fat_16_fs()) {
					ModernizedCProgram._uprintf("New volume does not have a FAT16 boot sector - aborting");
					break;
				} 
				ModernizedCProgram._uprintf("Confirmed new volume has a FAT16 boot sector");
				if (ModernizedCProgram.boot_type == boot_type.BT_FREEDOS) {
					if (!fp.write_fat_16_fd_br(0)) {
						break;
					} 
				}  else if (ModernizedCProgram.boot_type == boot_type.BT_REACTOS) {
					if (!fp.write_fat_16_ros_br(0)) {
						break;
					} 
				}  else if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getHas_kolibrios())) {
					ModernizedCProgram._uprintf("FAT16 is not supported for KolibriOS\n");
					break;
				} else {
						if (!fp.write_fat_16_br(0)) {
							break;
						} 
				} 
				if (!fp.write_partition_physical_disk_drive_id_fat16()) {
					break;
				} 
				return 1;
		default:
				ModernizedCProgram._uprintf("Unsupported FS for FS BR processing - aborting\n");
				break;
		}
		ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
		return 0/*
		 * Setup WinPE for bootable USB
		 */;
	}
	/*
	 * Convert the fmifs outputs messages (that use an OEM code page) to UTF-8
	 */
	public static Object SetupWinPE(byte drive_letter) {
		byte[] src = new byte[64];
		byte[] dst = new byte[32];
		byte[] basedir = new byte[]{"i386", "amd64", "minint"};
		byte[] patch_str_org = new byte[]{"\\minint\\txtsetup.sif", "\\minint\\system32\\"};
		byte[][] patch_str_rep = new byte[][]{{"\\i386\\txtsetup.sif", "\\i386\\system32\\"}, {"\\amd64\\txtsetup.sif", "\\amd64\\system32\\"}};
		byte win_nt_bt_org = "$win_nt$.~bt";
		byte rdisk_zero = "rdisk(0)";
		LARGE_INTEGER liZero = new LARGE_INTEGER(new LARGE_INTEGER(0, 0));
		byte[] setupsrcdev = new byte[64];
		HANDLE handle = (HANDLE)(true);
		DWORD i = new DWORD();
		DWORD j = new DWORD();
		DWORD size = new DWORD();
		DWORD rw_size = new DWORD();
		DWORD index = 0;
		BOOL r = 0;
		byte buffer = ((Object)0);
		if ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) {
			index = 1;
		}  else if ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) {
			index = 2;
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(setupsrcdev, /*Error: sizeof expression not supported yet*/, "SetupSourceDevice = \"\\device\\harddisk%d\\partition1\"", ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDiskID), 327, 0, 0)));
			(setupsrcdev)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		// Copy of ntdetect.com in rootdo {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(src, /*Error: sizeof expression not supported yet*/, "%c:\\%s\\ntdetect.com", drive_letter, basedir[2 * (index / 2)]);
			(src)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(dst, /*Error: sizeof expression not supported yet*/, "%c:\\ntdetect.com", drive_letter);
			(dst)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CopyFileA(src, dst, 1);
		if (!ModernizedCProgram.img_report.getUses_minint()) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(src, /*Error: sizeof expression not supported yet*/, "%c:\\%s\\txtsetup.sif", drive_letter, basedir[index]);
				(src)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(dst, /*Error: sizeof expression not supported yet*/, "%c:\\txtsetup.sif", drive_letter);
				(dst)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			if (!/*Error: Function owner not recognized*/CopyFileA(src, dst, 1)) {
				ModernizedCProgram._uprintf("Did not copy %s as %s: %s\n", src, dst, ModernizedCProgram.WindowsErrorString());
			} 
			if (ModernizedCProgram.insert_section_data(dst, "[SetupData]", setupsrcdev, 0) == ((Object)0)) {
				ModernizedCProgram._uprintf("Failed to add SetupSourceDevice in %s\n", dst);
				;
			} 
			ModernizedCProgram._uprintf("Successfully added '%s' to %s\n", setupsrcdev, dst);
		} 
		// Create a copy of txtsetup.sif, as we want to keep the i386/amd64 files unmodified
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(src, /*Error: sizeof expression not supported yet*/, "%c:\\%s\\setupldr.bin", drive_letter, basedir[2 * (index / 2)]);
			(src)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(dst, /*Error: sizeof expression not supported yet*/, "%c:\\BOOTMGR", drive_letter);
			(dst)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		if (!/*Error: Function owner not recognized*/CopyFileA(src, dst, 1)) {
			ModernizedCProgram._uprintf("Did not copy %s as %s: %s\n", src, dst, ModernizedCProgram.WindowsErrorString());
		} 
		// \minint with /minint option doesn't require further processing => return true// \minint and no \i386 without /minint is unclear => return errorif (ModernizedCProgram.img_report.getWinpe() & -1024) {
			if (ModernizedCProgram.img_report.getUses_minint()) {
				ModernizedCProgram._uprintf("Detected \\minint directory with /minint option: nothing to patch\n");
				r = 1;
			}  else if (!(ModernizedCProgram.img_report.getWinpe() & (-1024 | -1024))) {
				ModernizedCProgram._uprintf("Detected \\minint directory only but no /minint option: not sure what to do\n");
			} 
			;
		} 
		// At this stage we only handle \i386// At this stage we only handle \i386handle = /*Error: Function owner not recognized*/CreateFileA(dst, -1024 | -1024, -1024, ((Object)0), 3, -1024, ((Object)0));
		if (handle == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Could not open %s for patching: %s\n", dst, ModernizedCProgram.WindowsErrorString());
			;
		} 
		size = /*Error: Function owner not recognized*/GetFileSize(handle, ((Object)0));
		if (size == -1024) {
			ModernizedCProgram._uprintf("Could not get size for file %s: %s\n", dst, ModernizedCProgram.WindowsErrorString());
			;
		} 
		buffer = (byte)/*Error: Function owner not recognized*/malloc(size);
		if (buffer == ((Object)0)) {
			;
		} 
		if ((!/*Error: Function owner not recognized*/ReadFile(handle, buffer, size, rw_size, ((Object)0))) || (size != rw_size)) {
			ModernizedCProgram._uprintf("Could not read file %s: %s\n", dst, ModernizedCProgram.WindowsErrorString());
			;
		} 
		if (!/*Error: Function owner not recognized*/SetFilePointerEx(handle, liZero, ((Object)0), 0)) {
			ModernizedCProgram._uprintf("Could not rewind file %s: %s\n", dst, ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Patch setupldr.bin// Patch setupldr.binModernizedCProgram._uprintf("Patching file %s\n", dst)// Remove CRC check for 32 bit part of setupldr.bin from Win2k3;// Remove CRC check for 32 bit part of setupldr.bin from Win2k3
		if ((size > -1024) && (buffer[-1024] == -1024) && (buffer[-1024] == -1024)) {
			buffer[-1024] = -1024;
			buffer[-1024] = -1024;
			ModernizedCProgram._uprintf("  0x00002060: 0x74 0x03 -> 0xEB 0x1A (disable Win2k3 CRC check)\n");
		} 
		for (i = 1; i < size - 32; i++) {
			for (j = 0; j < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); j++) {
				if (/*Error: Function owner not recognized*/_strnicmp(((buffer[i] == ((Object)0)) ? "<NULL>" : buffer[i]), ((patch_str_org[j] == ((Object)0)) ? "<NULL>" : patch_str_org[j]), /*Error: Function owner not recognized*/strlen(patch_str_org[j]) - 1) == 0) {
					ModernizedCProgram._uprintf("  0x%08X: '%s' -> '%s'\n", i, buffer[i], patch_str_rep[index][j]);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(buffer[i], patch_str_rep[index][j]);
					i += (DWORD)((/*Error: Function owner not recognized*/strlen(patch_str_org[j])) > (/*Error: Function owner not recognized*/strlen(patch_str_rep[index][j])) ? (/*Error: Function owner not recognized*/strlen(patch_str_org[j])) : (/*Error: Function owner not recognized*/strlen(patch_str_rep[index][j])));
				} 
			}
		}
		if (!ModernizedCProgram.img_report.getUses_minint()) {
			for (i = 0; i < size - 32; i++) {
				if (/*Error: Function owner not recognized*/_strnicmp(((buffer[i] == ((Object)0)) ? "<NULL>" : buffer[i]), ((rdisk_zero == ((Object)0)) ? "<NULL>" : rdisk_zero), /*Error: Function owner not recognized*/strlen(rdisk_zero) - 1) == 0) {
					buffer[i + 6] = -1024 + ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDiskID), 327, 0, 0));
					ModernizedCProgram._uprintf("  0x%08X: '%s' -> 'rdisk(%c)'\n", i, rdisk_zero, buffer[i + 6]);
				} 
				if (/*Error: Function owner not recognized*/_strnicmp(((buffer[i] == ((Object)0)) ? "<NULL>" : buffer[i]), ((win_nt_bt_org == ((Object)0)) ? "<NULL>" : win_nt_bt_org), /*Error: Function owner not recognized*/strlen(win_nt_bt_org) - 1) == 0) {
					ModernizedCProgram._uprintf("  0x%08X: '%s' -> '%s%s'\n", i, buffer[i], basedir[index], buffer[i + /*Error: Function owner not recognized*/strlen(win_nt_bt_org)]);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(buffer[i], basedir[index]);
					buffer[i + /*Error: Function owner not recognized*/strlen(basedir[index])] = buffer[i + /*Error: Function owner not recognized*/strlen(win_nt_bt_org)];
					buffer[i + /*Error: Function owner not recognized*/strlen(basedir[index]) + 1] = 0;
				} 
			}
		} 
		// Additional setupldr.bin/bootmgr patching
		if (!ModernizedCProgram.WriteFileWithRetry(handle, buffer, size, rw_size, 4)) {
			ModernizedCProgram._uprintf("Could not write patched file: %s\n", ModernizedCProgram.WindowsErrorString());
			;
		} 
		r = 1;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)buffer);
			buffer = ((Object)0);
		} while (0);
		return r;// Checks which versions of Windows are available in an install image
	}
	// to set our extraction index. Asks the user to select one if needed.
	// Returns -2 on user cancel, -1 on other error, >=0 on success.
	public static int SetWinToGoIndex() {
		byte mounted_iso;
		byte build;
		byte[] image = new byte[128];
		byte[] tmp_path = "";
		byte[] xml_file = "";
		byte[] install_names = new byte[4];
		StrArray version_name = new StrArray();
		StrArray version_index = new StrArray();
		int i;
		int build_nr = 0;
		BOOL bNonStandard = 0;
		// Sanity checks// Sanity checksModernizedCProgram.wintogo_index = -1;
		ModernizedCProgram.wininst_index = 0;
		if ((ModernizedCProgram.nWindowsVersion < WindowsVersion.WINDOWS_8) || ((ModernizedCProgram.WimExtractCheck() & 4) == 0) || (((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 327, 0, 0))), 0)) != fs_type.FS_NTFS)) {
			return -1;
		} 
		// If we have multiple windows install images, ask the user the one to useif (ModernizedCProgram.img_report.getWininst_index() > 1) {
			for (i = 0; i < ModernizedCProgram.img_report.getWininst_index(); i++) {
				install_names[i] = ModernizedCProgram.img_report.getWininst_path()[i][2];
			}
			ModernizedCProgram.wininst_index = ModernizedCProgram.SelectionDialog(ModernizedCProgram.lmprintf(3130), ModernizedCProgram.lmprintf(3131), install_names, ModernizedCProgram.img_report.getWininst_index());
			if (ModernizedCProgram.wininst_index < 0) {
				return -2;
			} 
			ModernizedCProgram.wininst_index--;
			if ((ModernizedCProgram.wininst_index < 0) || (ModernizedCProgram.wininst_index >= 4)) {
				ModernizedCProgram.wininst_index = 0;
			} 
		} 
		// Mount the install.wim image, that resides on the ISO// Mount the install.wim image, that resides on the ISOmounted_iso = ModernizedCProgram.MountISO(ModernizedCProgram.image_path);
		if (mounted_iso == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not mount ISO for Windows To Go selection");
			return 0;
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(image, /*Error: sizeof expression not supported yet*/, "%s%s", mounted_iso, ModernizedCProgram.img_report.getWininst_path()[ModernizedCProgram.wininst_index][2]);
			(image)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		// Now take a look at the XML file in install.wim to list our versionsif ((ModernizedCProgram.GetTempPathU(/*Error: sizeof expression not supported yet*/, tmp_path) == 0) || (ModernizedCProgram.GetTempFileNameU(tmp_path, "Rufus", 0, xml_file) == 0) || (xml_file[0] == 0)) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(xml_file, ".\\RufVXml.tmp", (((size_t)(((((byte)".\\RufVXml.tmp") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".\\RufVXml.tmp")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)".\\RufVXml.tmp") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".\\RufVXml.tmp")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
				((byte)xml_file)[(((size_t)(((((byte)".\\RufVXml.tmp") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".\\RufVXml.tmp")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)".\\RufVXml.tmp") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(".\\RufVXml.tmp")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
			} while (0);
		} 
		// GetTempFileName() may leave a file behind// GetTempFileName() may leave a file behindModernizedCProgram.DeleteFileU(xml_file);
		// Must use the Windows WIM API as 7z messes up the XMLif (!ModernizedCProgram.WimExtractFile_API(image, 0, "[1].xml", xml_file)) {
			ModernizedCProgram._uprintf("Could not acquire WIM index");
			;
		} 
		version_name.StrArrayCreate(16);
		version_index.StrArrayCreate(16);
		for (i = 0; version_index.StrArrayAdd(ModernizedCProgram.get_token_data_file_indexed("IMAGE INDEX", xml_file, i + 1), 0) >= 0; i++) {
			if (version_name.StrArrayAdd(ModernizedCProgram.get_token_data_file_indexed("DISPLAYNAME", xml_file, i + 1), 0) < 0) {
				bNonStandard = 1;
				if (version_name.StrArrayAdd(ModernizedCProgram.get_token_data_file_indexed("DESCRIPTION", xml_file, i + 1), 0) < 0) {
					ModernizedCProgram._uprintf("Warning: Could not find a description for image index %d", i + 1);
					version_name.StrArrayAdd("Unknown Windows Version", 1);
				} 
			} 
		}// Some people are apparently creating *unofficial* Windows ISOs that don't have DISPLAYNAME elements.// If we are parsing such an ISO, try to fall back to using DESCRIPTION. Of course, since we don't use// a formal XML parser, if an ISO mixes entries with both DISPLAYNAME and DESCRIPTION and others with// only DESCRIPTION, the version names we report will be wrong.
		if (bNonStandard) {
			ModernizedCProgram._uprintf("Warning: Nonstandard Windows image (missing <DISPLAYNAME> entries)");
		} 
		Object generatedString = version_name.getString();
		if (i > 1) {
			i = ModernizedCProgram.SelectionDialog(ModernizedCProgram.lmprintf(3291), ModernizedCProgram.lmprintf(3292), generatedString, i);
		} 
		if (i < 0) {
			ModernizedCProgram.wintogo_index = -2;
		}  else if (i == 0) {
			ModernizedCProgram.wintogo_index = 1;
		} else {
				ModernizedCProgram.wintogo_index = /*Error: Function owner not recognized*/atoi(generatedString[i - 1]);
		} 
		if (i > 0) {
			build = ModernizedCProgram.get_token_data_file_indexed("BUILD", xml_file, i);
			if (build != ((Object)0)) {
				build_nr = /*Error: Function owner not recognized*/atoi(build);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(build);
			ModernizedCProgram._uprintf("Will use '%s' (Build: %d, Index %s) for Windows To Go", generatedString[i - 1], build_nr, generatedString[i - 1]);
			if ((build_nr < 15000) && (ModernizedCProgram.SelectedDrive.getMediaType() != _MEDIA_TYPE.FixedMedia)) {
				if (ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3098), ModernizedCProgram.lmprintf(3190), 4 | -1024 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid) != 6) {
					ModernizedCProgram.wintogo_index = -2;
				} 
			} 
			if (build_nr == 17763) {
				notification_info more_info = new notification_info();
				more_info.setId(-1024);
				more_info.setUrl("https://github.com/pbatard/rufus/wiki/FAQ#BSODs_with_Windows_To_Go_drives_created_from_Windows_10_1809_ISOs");
				ModernizedCProgram.Notification(notification_type.MSG_INFO, ((Object)0), more_info, ModernizedCProgram.lmprintf(3128, "Windows To Go"), ModernizedCProgram.lmprintf(3133));
			} 
		} 
		// Get the build version
		version_name.StrArrayDestroy();
		version_index.StrArrayDestroy();
		ModernizedCProgram.UnMountISO();
		return ModernizedCProgram.wintogo_index;// http://technet.microsoft.com/en-ie/library/jj721578.aspx
	}
	// As opposed to the technet guide above, we no longer set internal drives offline,
	// due to people wondering why they can't see them by default.
	//#define SET_INTERNAL_DRIVES_OFFLINE
	public static Object SetupWinToGo(Object DriveIndex, Object[] drive_name, Object use_esp) {
		byte[] unattend_path = "?:\\Windows\\System32\\sysprep\\unattend.xml";
		byte mounted_iso;
		byte ms_efi = ((Object)0);
		byte[] image = new byte[128];
		byte[] cmd = new byte[260];
		byte buffer;
		DWORD bufsize = new DWORD();
		ULONG cluster_size = new ULONG();
		FILE fd = new FILE();
		ModernizedCProgram._uprintf("Windows To Go mode selected")// Additional sanity checks;// Additional sanity checks
		if ((use_esp) && (ModernizedCProgram.SelectedDrive.getMediaType() != _MEDIA_TYPE.FixedMedia) && (ModernizedCProgram.nWindowsBuildNumber < 15000)) {
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			return 0;
		} 
		// First, we need to access the install.wim image, that resides on the ISO// First, we need to access the install.wim image, that resides on the ISOmounted_iso = ModernizedCProgram.MountISO(ModernizedCProgram.image_path);
		if (mounted_iso == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not mount ISO for Windows To Go installation");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
			return 0;
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(image, /*Error: sizeof expression not supported yet*/, "%s%s", mounted_iso, ModernizedCProgram.img_report.getWininst_path()[ModernizedCProgram.wininst_index][2]);
			(image)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		ModernizedCProgram._uprintf("Mounted ISO as '%s'", mounted_iso);
		// Now we use the WIM API to apply that imageif (!ModernizedCProgram.WimApplyImage(image, ModernizedCProgram.wintogo_index, drive_name)) {
			ModernizedCProgram._uprintf("Failed to apply Windows To Go image");
			if (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
			} 
			ModernizedCProgram.UnMountISO();
			return 0;
		} 
		ModernizedCProgram.UnMountISO();
		if (use_esp) {
			ModernizedCProgram._uprintf("Setting up EFI System Partition");
			if (ModernizedCProgram.SelectedDrive.getSectorSize() <= 1024) {
				cluster_size = 1024;
			}  else if (ModernizedCProgram.SelectedDrive.getSectorSize() <= 4096) {
				cluster_size = 4096;
			} else {
					cluster_size = (ULONG)ModernizedCProgram.SelectedDrive.getSectorSize();
			} 
			if (!ModernizedCProgram.FormatPartition(DriveIndex, ModernizedCProgram.partition_offset[1], cluster_size, fs_type.FS_FAT32, "", -1024 | -1024 | -1024 | -1024)) {
				ModernizedCProgram._uprintf("Could not format EFI System Partition");
				return 0;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(200);
		} 
		if (use_esp) {
			ms_efi = ModernizedCProgram.AltMountVolume(DriveIndex, ModernizedCProgram.partition_offset[1], 0);
			if (ms_efi == ((Object)0)) {
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
				return 0;
			} 
		} 
		// Need to have the ESP mounted to invoke bcdboot
		// Also, since Rufus should (usually) be running as a 32 bit app, on 64 bit systems, we need to use// 'C:\Windows\Sysnative' and not 'C:\Windows\System32' to invoke bcdboot, as 'C:\Windows\System32'// will get converted to 'C:\Windows\SysWOW64' behind the scenes, and there is no bcdboot.exe there.do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(cmd, /*Error: sizeof expression not supported yet*/, "%s\\bcdboot.exe %s\\Windows /v /f %s /s %s", ModernizedCProgram.sysnative_dir, drive_name, (ModernizedCProgram.img_report.getHas_bootmgr()) ? ((ModernizedCProgram.img_report.getHas_bootmgr_efi()) ? "ALL" : "BIOS") : "UEFI", (use_esp) ? ms_efi : drive_name);
			(cmd)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		ModernizedCProgram._uprintf("Enabling boot using command '%s'", cmd);
		if (ModernizedCProgram.RunCommand(cmd, ModernizedCProgram.sysnative_dir, ModernizedCProgram.usb_debug) != 0) {
			ModernizedCProgram._uprintf("Failed to enable boot");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
		} 
		// Try to continue... but report a failure
		if (use_esp) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(200);
			ModernizedCProgram.AltUnmountVolume(ms_efi, 0);
		} 
		ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FILE_COPY, 3267, ModernizedCProgram.wim_proc_files + 2 * ModernizedCProgram.wim_extra_files, ModernizedCProgram.wim_nb_files)// The following are non fatal if they fail;// The following are non fatal if they fail
		// Can't use the one from the USB (at least for Windows 10 preview), as you'll get// "Error: 0x800401f0  An error occurred while initializing COM security".// On the other hand, using Windows 8.1 dism against Windows 10 doesn't work either// (you get a message about needing to upgrade to latest AIK)...// Can't use the one from the USB (at least for Windows 10 preview), as you'll get// "Error: 0x800401f0  An error occurred while initializing COM security".// On the other hand, using Windows 8.1 dism against Windows 10 doesn't work either// (you get a message about needing to upgrade to latest AIK)...ModernizedCProgram._uprintf("Copying 'unattend.xml', to disable the use of the Windows Recovery Environment...");
		buffer = ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)(true))), "unattend.xml", bufsize, 0);
		unattend_path[0] = drive_name[0];
		fd = ModernizedCProgram.fopenU(unattend_path, "wb");
		if ((fd == ((Object)0)) || (/*Error: Function owner not recognized*/fwrite(buffer, 1, bufsize, fd) != bufsize)) {
			ModernizedCProgram._uprintf("Could not write '%s'", unattend_path);
		} 
		if (fd != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
		} 
		ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FILE_COPY, 3267, ModernizedCProgram.wim_nb_files, ModernizedCProgram.wim_nb_files);
		return 1;
	}
	public static void update_progress(Object processed_bytes) {
		ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FORMAT, 3261, processed_bytes, ModernizedCProgram.img_report.getImage_size());
	}
	/* Write an image file or zero a drive */
	public static Object WriteDrive(Object hPhysicalDrive, Object hSourceImage) {
		BOOL s = new BOOL();
		BOOL ret = 0;
		LARGE_INTEGER li = new LARGE_INTEGER();
		DWORD rSize = new DWORD();
		DWORD wSize = new DWORD();
		DWORD xSize = new DWORD();
		DWORD BufSize = new DWORD();
		uint64_t wb = new uint64_t();
		uint64_t target_size = hSourceImage ? ModernizedCProgram.img_report.getImage_size() : ModernizedCProgram.SelectedDrive.getDiskSize();
		int64_t bled_ret = new int64_t();
		uint8_t buffer = ((Object)0);
		uint8_t cmp_buffer = ((Object)0);
		int i;
		int ptr;
		int zero_data;
		int throttle_fast_zeroing = 0;
		// We poked the MBR and other stuff, so we need to rewind// We poked the MBR and other stuff, so we need to rewindli.setQuadPart(0);
		if (!/*Error: Function owner not recognized*/SetFilePointerEx(hPhysicalDrive, li, ((Object)0), 0)) {
			ModernizedCProgram._uprintf("Warning: Unable to rewind image position - wrong data might be copied!");
		} 
		ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_INIT, (int)0, (uint64_t)(uintptr_t)((Object)0), 0);
		;
		if (ModernizedCProgram.img_report.getCompression_type() != BLED_COMPRESSION_NONE) {
			ModernizedCProgram._uprintf("Writing compressed image...");
			ModernizedCProgram.bled_init(ModernizedCProgram._uprintf, update_progress, ModernizedCProgram.FormatStatus);
			bled_ret = ModernizedCProgram.bled_uncompress_with_handles(hSourceImage, hPhysicalDrive, ModernizedCProgram.img_report.getCompression_type());
			ModernizedCProgram.bled_exit();
			if ((bled_ret < 0) && (((ModernizedCProgram.FormatStatus) & -1024) != -1024)) {
				ModernizedCProgram._uprintf("Could not write compressed image: %lld", bled_ret);
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				;
			} 
		} else {
				ModernizedCProgram._uprintf(hSourceImage ? "Writing Image..." : ModernizedCProgram.fast_zeroing ? "Fast-zeroing drive..." : "Zeroing drive...");
				BufSize = ((65536 + ModernizedCProgram.SelectedDrive.getSectorSize() - 1) / ModernizedCProgram.SelectedDrive.getSectorSize()) * ModernizedCProgram.SelectedDrive.getSectorSize();
				buffer = (uint8_t)/*Error: Function owner not recognized*/_mm_malloc(BufSize, ModernizedCProgram.SelectedDrive.getSectorSize());
				if (buffer == ((Object)0)) {
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
					ModernizedCProgram._uprintf("Could not allocate disk write buffer");
					;
				} 
				(((uintptr_t)buffer % ModernizedCProgram.SelectedDrive.getSectorSize() == 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(uintptr_t)buffer % SelectedDrive.SectorSize == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\format.c", 2284));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buffer, ModernizedCProgram.fast_zeroing ? -1024 : -1024, BufSize);
				cmp_buffer = (uint8_t)/*Error: Function owner not recognized*/_mm_malloc(BufSize, ModernizedCProgram.SelectedDrive.getSectorSize());
				if (cmp_buffer == ((Object)0)) {
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
					ModernizedCProgram._uprintf("Could not allocate disk comparison buffer");
					;
				} 
				(((uintptr_t)cmp_buffer % ModernizedCProgram.SelectedDrive.getSectorSize() == 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(uintptr_t)cmp_buffer % SelectedDrive.SectorSize == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\format.c", 2295));
				rSize = BufSize;
				for (; wb < (uint64_t)ModernizedCProgram.SelectedDrive.getDiskSize(); wb += wSize) {
					ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FORMAT, hSourceImage ? 3261 : ModernizedCProgram.fast_zeroing ? 3306 : 3286, wb, target_size);
					if (hSourceImage != ((Object)0)) {
						s = /*Error: Function owner not recognized*/ReadFile(hSourceImage, buffer, BufSize, rSize, ((Object)0));
						if (!s) {
							ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
							ModernizedCProgram._uprintf("Read error: %s", ModernizedCProgram.WindowsErrorString());
							;
						} 
						if (rSize == 0) {
							break;
						} 
					} 
					if (wb + rSize > target_size) {
						rSize = (DWORD)(target_size - wb);
					} 
					if (rSize % ModernizedCProgram.SelectedDrive.getSectorSize() != 0) {
						rSize = ((rSize + ModernizedCProgram.SelectedDrive.getSectorSize() - 1) / ModernizedCProgram.SelectedDrive.getSectorSize()) * ModernizedCProgram.SelectedDrive.getSectorSize();
					} 
					if (throttle_fast_zeroing) {
						throttle_fast_zeroing--;
					}  else if (ModernizedCProgram.fast_zeroing) {
						((hSourceImage == ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("hSourceImage == NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\format.c", 2329));
						if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
							;
						} 
						s = /*Error: Function owner not recognized*/ReadFile(hPhysicalDrive, cmp_buffer, rSize, xSize, ((Object)0));
						if ((!s) || (xSize != rSize)) {
							ModernizedCProgram._uprintf("Read error: Could not read data for comparison - %s", ModernizedCProgram.WindowsErrorString());
							;
						} 
						ptr = (int)(cmp_buffer);
						zero_data = ptr[0];
						if ((zero_data == 0) || (zero_data == -1)) {
							for (i = 1; i < (int)(rSize / /*Error: Unsupported expression*/); i++) {
								if (ptr[i] != zero_data) {
									break;
								} 
							}
							if (i >= (int)(rSize / /*Error: Unsupported expression*/)) {
								wSize = rSize;
								continue;
							} 
						} 
						li.setQuadPart(wb);
						if (!/*Error: Function owner not recognized*/SetFilePointerEx(hPhysicalDrive, li, ((Object)0), 0)) {
							ModernizedCProgram._uprintf("Error: Could not reset position - %s", ModernizedCProgram.WindowsErrorString());
							;
						} 
						throttle_fast_zeroing = 15;
					} 
					for (i = 1; i <= 4; i++) {
						if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
							;
						} 
						s = /*Error: Function owner not recognized*/WriteFile(hPhysicalDrive, buffer, rSize, wSize, ((Object)0));
						if ((s) && (wSize == rSize)) {
							break;
						} 
						if (s) {
							ModernizedCProgram._uprintf("Write error: Wrote %d bytes, expected %d bytes", wSize, rSize);
						} else {
								ModernizedCProgram._uprintf("Write error at sector %lld: %s", wb / ModernizedCProgram.SelectedDrive.getSectorSize(), ModernizedCProgram.WindowsErrorString());
						} 
						if (i < 4) {
							li.setQuadPart(wb);
							ModernizedCProgram._uprintf("Retrying in %d seconds...", 5000 / 1000);
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(5000);
							if (!/*Error: Function owner not recognized*/SetFilePointerEx(hPhysicalDrive, li, ((Object)0), 0)) {
								ModernizedCProgram._uprintf("Write error: Could not reset position - %s", ModernizedCProgram.WindowsErrorString());
								;
							} 
						} else {
								ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
								;
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(200);
					}
					if (i > 4) {
						;
					} 
				}
		} 
		ModernizedCProgram.RefreshDriveLayout(hPhysicalDrive);
		ret = 1;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_mm_free((Object)cmp_buffer);
			cmp_buffer = ((Object)0);
		} while (0);
		return ret/*
		 * Standalone thread for the formatting operation
		 * According to http://msdn.microsoft.com/en-us/library/windows/desktop/aa364562.aspx
		 * To change a volume file system
		 *   Open a volume.
		 *   Lock the volume.
		 *   Format the volume.
		 *   Dismount the volume.
		 *   Unlock the volume.
		 *   Close the volume handle.
		 */;
	}
	public static Object FormatThread(Object param) {
		int i;
		int r;
		BOOL ret = new BOOL();
		BOOL use_large_fat32 = new BOOL();
		BOOL windows_to_go = new BOOL();
		BOOL actual_lock_drive = ModernizedCProgram.lock_drive;
		DWORD DriveIndex = (DWORD)(uintptr_t)param;
		DWORD ClusterSize = new DWORD();
		DWORD Flags = new DWORD();
		HANDLE hPhysicalDrive = (HANDLE)(true);
		HANDLE hLogicalVolume = (HANDLE)(true);
		HANDLE hSourceImage = (HANDLE)(true);
		SYSTEMTIME lt = new SYSTEMTIME();
		FILE log_fd = new FILE();
		uint8_t buffer = ((Object)0);
		uint8_t extra_partitions = 0;
		byte bb_msg;
		byte volume_name = ((Object)0);
		byte[] drive_name = "?:\\";
		byte[] drive_letters = new byte[27];
		byte[] fs_name = new byte[32];
		byte[] label = new byte[64];
		byte[] logfile = new byte[260];
		byte userdir;
		byte[] efi_dst = "?:\\efi\\boot\\bootx64.efi";
		byte[] kolibri_dst = "?:\\MTLD_F32";
		byte[] grub4dos_dst = "?:\\grldr";
		use_large_fat32 = (ModernizedCProgram.fs_type == fs_type.FS_FAT32) && ((ModernizedCProgram.SelectedDrive.getDiskSize() > (32 * -1024)) || (ModernizedCProgram.force_large_fat32));
		windows_to_go = (ModernizedCProgram.image_options & -1024) && (ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) && (ModernizedCProgram.img_report.getHas_efi() != 0) && (ModernizedCProgram.img_report.getWininst_index() != 0)) && (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1026)), 327, 0, 0)) == 1);
		ModernizedCProgram.large_drive = (ModernizedCProgram.SelectedDrive.getDiskSize() > (1 * -1024));
		if (ModernizedCProgram.large_drive) {
			ModernizedCProgram._uprintf("Notice: Large drive detected (may produce short writes)");
		} 
		if ((windows_to_go) && (ModernizedCProgram.target_type == target_type.TT_UEFI) && (ModernizedCProgram.partition_type == _PARTITION_STYLE.PARTITION_STYLE_GPT)) {
			extra_partitions = -1024 | -1024;
		}  else if ((ModernizedCProgram.fs_type == fs_type.FS_NTFS) && ((ModernizedCProgram.boot_type == boot_type.BT_UEFI_NTFS) || ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getHas_efi() != 0) && ((ModernizedCProgram.target_type == target_type.TT_UEFI) || (windows_to_go) || (ModernizedCProgram.allow_dual_uefi_bios))))) {
			extra_partitions = -1024;
		}  else if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && !ModernizedCProgram.write_as_image && (((ModernizedCProgram.img_report.getSl_version() != 0) || ((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos()))) && !((((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getUses_minint()) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) || (ModernizedCProgram.img_report.getReactos_path()[0] != 0) || (ModernizedCProgram.img_report.getHas_kolibrios()))) && ModernizedCProgram.persistence_size) {
			extra_partitions = -1024;
		}  else if ((/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1021) == 1)) {
			extra_partitions = -1024;
		} 
		// According to Microsoft, every GPT disk (we RUN Windows from) must have an MSR due to not having hidden sectors
		// too well with Windows. Relaxing our locking rules seems to help...if ((extra_partitions == -1024) || (ModernizedCProgram.fs_type >= fs_type.FS_EXT2)) {
			actual_lock_drive = 0;
		} 
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3225);
		hPhysicalDrive = ModernizedCProgram.GetPhysicalHandle(DriveIndex, actual_lock_drive, 0, !actual_lock_drive);
		if (hPhysicalDrive == (HANDLE)(true)) {
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		// At this stage we have both a handle and a lock to the physical driveif (!ModernizedCProgram.GetDriveLetters(DriveIndex, drive_letters)) {
			ModernizedCProgram._uprintf("Failed to get a drive letter");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
			;
		} 
		if (drive_letters[0] == 0) {
			ModernizedCProgram._uprintf("No drive letter was assigned...");
			drive_name[0] = ModernizedCProgram.GetUnusedDriveLetter();
			if (drive_name[0] == 0) {
				ModernizedCProgram._uprintf("Could not find a suitable drive letter");
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
				;
			} 
		} else {
				for (i = (int)((((byte)drive_letters) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(drive_letters)); i > 0; i--) {
					drive_name[0] = drive_letters[i - 1];
					if (ModernizedCProgram.boot_type == boot_type.BT_IMAGE) {
						if ((ModernizedCProgram.PathGetDriveNumberU(ModernizedCProgram.image_path) + (byte)'A') == drive_letters[i - 1]) {
							ModernizedCProgram._uprintf("ABORTED: Cannot use an image that is located on the target drive!");
							ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
							;
						} 
					} 
					if (!/*Error: Function owner not recognized*/DeleteVolumeMountPointA(drive_name)) {
						ModernizedCProgram._uprintf("Failed to delete mountpoint %s: %s", drive_name, ModernizedCProgram.WindowsErrorString());
					} 
				}
		} 
		ModernizedCProgram._uprintf("Will use '%C:' as volume mountpoint", drive_name[0])// It kind of blows, but we have to relinquish access to the physical drive;// It kind of blows, but we have to relinquish access to the physical drive
		// for VDS to be able to delete the partitions that reside on it...do {
			if ((hPhysicalDrive != (HANDLE)(true)) && (hPhysicalDrive != ((Object)0))) {
				ModernizedCProgram.UnlockDrive(hPhysicalDrive);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hPhysicalDrive);
				hPhysicalDrive = (HANDLE)(true);
			} 
		} while (0);
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3239);
		if (!ModernizedCProgram.DeletePartitions(DriveIndex)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(ModernizedCProgram.FormatStatus);
			ModernizedCProgram._uprintf("Notice: Could not delete partitions: %s", ModernizedCProgram.WindowsErrorString());
			ModernizedCProgram.FormatStatus = 0;
		} 
		// Now get RW access to the physical drive...// Now get RW access to the physical drive...hPhysicalDrive = ModernizedCProgram.GetPhysicalHandle(DriveIndex, actual_lock_drive, 1, !actual_lock_drive);
		if (hPhysicalDrive == (HANDLE)(true)) {
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		ModernizedCProgram.RefreshDriveLayout(hPhysicalDrive);
		// ...and get a lock to the logical drive so that we can actually write something// ...and get a lock to the logical drive so that we can actually write somethinghLogicalVolume = ModernizedCProgram.GetLogicalHandle(DriveIndex, 0, 1, 0, !actual_lock_drive);
		if (hLogicalVolume == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Could not lock volume");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		}  else if (hLogicalVolume == ((Object)0)) {
			ModernizedCProgram._uprintf("Drive does not appear to be partitioned");
		}  else if (!ModernizedCProgram.UnmountVolume(hLogicalVolume)) {
			ModernizedCProgram._uprintf("Trying to continue regardless...");
		} 
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
			;
		} 
		if (!ModernizedCProgram.zero_drive && !ModernizedCProgram.write_as_image) {
			ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3226);
			ModernizedCProgram.AnalyzeMBR(hPhysicalDrive, "Drive", 0);
			ModernizedCProgram.UpdateProgress(action_type.OP_ANALYZE_MBR, -1.0);
		} 
		if (ModernizedCProgram.zero_drive) {
			ModernizedCProgram.WriteDrive(hPhysicalDrive, ((Object)0));
			;
		} 
		// Note, Microsoft's way of cleaning partitions (IOCTL_DISK_CREATE_DISK, which is what we apply// in InitializeDisk) is *NOT ENOUGH* to reset a disk and can render it inoperable for partitioning// or formatting under Windows. See https://github.com/pbatard/rufus/issues/759 for details.if ((ModernizedCProgram.boot_type != boot_type.BT_IMAGE) || (ModernizedCProgram.img_report.getIs_iso() && !ModernizedCProgram.write_as_image)) {
			if ((!ModernizedCProgram.ClearMBRGPT(hPhysicalDrive, ModernizedCProgram.SelectedDrive.getDiskSize(), ModernizedCProgram.SelectedDrive.getSectorSize(), use_large_fat32)) || (!ModernizedCProgram.InitializeDisk(hPhysicalDrive))) {
				ModernizedCProgram._uprintf("Could not reset partitions");
				ModernizedCProgram.FormatStatus = (ModernizedCProgram.LastWriteError != 0) ? ModernizedCProgram.LastWriteError : (-1024 | (3 << 16) | -1024);
				;
			} 
		} 
		Object generatedWYear = lt.getWYear();
		Object generatedWMonth = lt.getWMonth();
		Object generatedWDay = lt.getWDay();
		Object generatedWHour = lt.getWHour();
		Object generatedWMinute = lt.getWMinute();
		Object generatedWSecond = lt.getWSecond();
		if ((/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1009) == 1)) {
			do {
				int sel = ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hNBPasses), 327, 0, 0));
				userdir = ModernizedCProgram.getenvU("USERPROFILE");
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(logfile, userdir, (((size_t)(((((byte)userdir) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(userdir)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)userdir) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(userdir)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)logfile)[(((size_t)(((((byte)userdir) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(userdir)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)userdir) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(userdir)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)userdir);
					userdir = ((Object)0);
				} while (0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetLocalTime(lt);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(logfile[/*Error: Function owner not recognized*/strlen(logfile)], /*Error: sizeof expression not supported yet*/ - /*Error: Function owner not recognized*/strlen(logfile) - 1, "\\rufus_%04d%02d%02d_%02d%02d%02d.log", generatedWYear, generatedWMonth, generatedWDay, generatedWHour, generatedWMinute, generatedWSecond);
					(logfile[/*Error: Function owner not recognized*/strlen(logfile)])[(/*Error: sizeof expression not supported yet*/ - /*Error: Function owner not recognized*/strlen(logfile) - 1) - 1] = 0;
				} while (0);
				log_fd = ModernizedCProgram.fopenU(logfile, "w+");
				if (log_fd == ((Object)0)) {
					ModernizedCProgram._uprintf("Could not create log file for bad blocks check");
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(log_fd, "Rufus bad blocks check started on: %04d.%02d.%02d %02d:%02d:%02d", generatedWYear, generatedWMonth, generatedWDay, generatedWHour, generatedWMinute, generatedWSecond);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fflush(log_fd);
				} 
				if (!ModernizedCProgram.BadBlocks(hPhysicalDrive, ModernizedCProgram.SelectedDrive.getDiskSize(), (sel >= 2) ? 4 : sel + 1, (sel < 2) ? 0 : sel - 2, ModernizedCProgram.report, log_fd)) {
					ModernizedCProgram._uprintf("Bad blocks: Check failed.");
					if (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
						ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
					} 
					ModernizedCProgram.ClearMBRGPT(hPhysicalDrive, ModernizedCProgram.SelectedDrive.getDiskSize(), ModernizedCProgram.SelectedDrive.getSectorSize(), 0);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(log_fd);
					ModernizedCProgram.DeleteFileU(logfile);
					;
				} 
				ModernizedCProgram._uprintf("Bad Blocks: Check completed, %d bad block%s found. (%d/%d/%d errors)", ModernizedCProgram.report.getBb_count(), (ModernizedCProgram.report.getBb_count() == 1) ? "" : "s", ModernizedCProgram.report.getNum_read_errors(), ModernizedCProgram.report.getNum_write_errors(), ModernizedCProgram.report.getNum_corruption_errors());
				r = 1;
				if (ModernizedCProgram.report.getBb_count()) {
					bb_msg = ModernizedCProgram.lmprintf(3011, ModernizedCProgram.report.getBb_count(), ModernizedCProgram.report.getNum_read_errors(), ModernizedCProgram.report.getNum_write_errors(), ModernizedCProgram.report.getNum_corruption_errors());
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(log_fd, bb_msg);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetLocalTime(lt);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(log_fd, "Rufus bad blocks check ended on: %04d.%02d.%02d %02d:%02d:%02d", generatedWYear, generatedWMonth, generatedWDay, generatedWHour, generatedWMinute, generatedWSecond);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(log_fd);
					r = ModernizedCProgram.MessageBoxExU(ModernizedCProgram.hMainDialog, ModernizedCProgram.lmprintf(3012, bb_msg, logfile), ModernizedCProgram.lmprintf(3010), 2 | -1024 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(log_fd);
						ModernizedCProgram.DeleteFileU(logfile);
				} 
			} while (r == 4);
			if (r == 3) {
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				;
			} 
			if (!ModernizedCProgram.ClearMBRGPT(hPhysicalDrive, ModernizedCProgram.SelectedDrive.getDiskSize(), ModernizedCProgram.SelectedDrive.getSectorSize(), use_large_fat32)) {
				ModernizedCProgram._uprintf("unable to zero MBR/GPT");
				if (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				} 
				;
			} 
		} 
		// Write an image fileif ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && ModernizedCProgram.write_as_image) {
			hSourceImage = ModernizedCProgram.CreateFileU(ModernizedCProgram.image_path, -1024, -1024, ((Object)0), 3, 134217728, ((Object)0));
			if (hSourceImage == (HANDLE)(true)) {
				ModernizedCProgram._uprintf("Could not open image '%s': %s", ModernizedCProgram.image_path, ModernizedCProgram.WindowsErrorString());
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				;
			} 
			ModernizedCProgram.WriteDrive(hPhysicalDrive, hSourceImage);
			do {
				if ((hPhysicalDrive != (HANDLE)(true)) && (hPhysicalDrive != ((Object)0))) {
					ModernizedCProgram.UnlockDrive(hPhysicalDrive);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hPhysicalDrive);
					hPhysicalDrive = (HANDLE)(true);
				} 
			} while (0);
			do {
				if ((hLogicalVolume != (HANDLE)(true)) && (hLogicalVolume != ((Object)0))) {
					ModernizedCProgram.UnlockDrive(hLogicalVolume);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hLogicalVolume);
					hLogicalVolume = (HANDLE)(true);
				} 
			} while (0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(200);
			ModernizedCProgram.WaitForLogical(DriveIndex, 0);
			if (ModernizedCProgram.GetDrivePartitionData(ModernizedCProgram.SelectedDrive.getDeviceNumber(), fs_name, /*Error: sizeof expression not supported yet*/, 1)) {
				volume_name = ModernizedCProgram.GetLogicalName(DriveIndex, 0, 1, 1);
				if ((volume_name != ((Object)0)) && (ModernizedCProgram.MountVolume(drive_name, volume_name))) {
					ModernizedCProgram._uprintf("Remounted %s as %C:", volume_name, drive_name[0]);
				} 
			} 
			;
		} 
		ModernizedCProgram.UpdateProgress(action_type.OP_ZERO_MBR, -1.0);
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
			;
		} 
		if (!ModernizedCProgram.CreatePartition(hPhysicalDrive, ModernizedCProgram.partition_type, ModernizedCProgram.fs_type, (ModernizedCProgram.partition_type == _PARTITION_STYLE.PARTITION_STYLE_MBR) && (ModernizedCProgram.target_type == target_type.TT_UEFI), extra_partitions)) {
			ModernizedCProgram.FormatStatus = (ModernizedCProgram.LastWriteError != 0) ? ModernizedCProgram.LastWriteError : (-1024 | (3 << 16) | -1024);
			;
		} 
		ModernizedCProgram.UpdateProgress(action_type.OP_PARTITION, -1.0);
		// Close the (unmounted) volume before formattingif ((hLogicalVolume != ((Object)0)) && (hLogicalVolume != (HANDLE)(true))) {
			ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3227);
			if (!/*Error: Function owner not recognized*/CloseHandle(hLogicalVolume)) {
				ModernizedCProgram._uprintf("Could not close volume: %s", ModernizedCProgram.WindowsErrorString());
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				;
			} 
		} 
		hLogicalVolume = (HANDLE)(true);
		// VDS wants us to unlock the physif (ModernizedCProgram.use_vds) {
			do {
				if ((hPhysicalDrive != (HANDLE)(true)) && (hPhysicalDrive != ((Object)0))) {
					ModernizedCProgram.UnlockDrive(hPhysicalDrive);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hPhysicalDrive);
					hPhysicalDrive = (HANDLE)(true);
				} 
			} while (0);
			ModernizedCProgram._uprintf("Refreshing drive layout...");
			ModernizedCProgram.RefreshLayout(DriveIndex);
		} 
		// Wait for the logical drive we just created to appear// Wait for the logical drive we just created to appearModernizedCProgram._uprintf("Waiting for logical drive to reappear...");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(200);
		if (!ModernizedCProgram.WaitForLogical(DriveIndex, ModernizedCProgram.partition_offset[0])) {
			ModernizedCProgram._uprintf("Logical drive was not found - aborting");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
			;
		} 
		// Format Casper partition if required. Do it before we format anything with
		// a file system that Windows will recognize, to avoid concurrent access.if (extra_partitions & -1024) {
			uint32_t ext_version = ModernizedCProgram.ReadSetting32("UseExtVersion");
			if ((ext_version < 2) || (ext_version > 4)) {
				ext_version = 3;
			} 
			ModernizedCProgram._uprintf("Using %s-like method to enable persistence", ModernizedCProgram.img_report.getUses_casper() ? "Ubuntu" : "Debian");
			if (!ModernizedCProgram.FormatPartition(DriveIndex, ModernizedCProgram.partition_offset[2], 0, fs_type.FS_EXT2 + (ext_version - 2), ModernizedCProgram.img_report.getUses_casper() ? "casper-rw" : "persistence", (ModernizedCProgram.img_report.getUses_casper() ? 0 : -1024) | ((/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1008) == 1) ? -1024 : 0))) {
				if (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				} 
				;
			} 
		} 
		ModernizedCProgram.GetWindowTextU(ModernizedCProgram.hLabel, label, /*Error: sizeof expression not supported yet*/);
		if (ModernizedCProgram.fs_type < fs_type.FS_EXT2) {
			ModernizedCProgram.ToValidLabel(label, (ModernizedCProgram.fs_type == fs_type.FS_FAT16) || (ModernizedCProgram.fs_type == fs_type.FS_FAT32) || (ModernizedCProgram.fs_type == fs_type.FS_EXFAT));
		} 
		ClusterSize = (DWORD)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hClusterSize), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hClusterSize), 327, 0, 0))), 0));
		if (ClusterSize < -1024) {
			ClusterSize = 0;
		} 
		Flags = -1024;
		if ((/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1008) == 1)) {
			Flags |=  -1024;
		} 
		if ((ModernizedCProgram.fs_type == fs_type.FS_NTFS) && (ModernizedCProgram.enable_ntfs_compression)) {
			Flags |=  -1024;
		} 
		ret = ModernizedCProgram.FormatPartition(DriveIndex, ModernizedCProgram.partition_offset[0], ClusterSize, ModernizedCProgram.fs_type, label, Flags);
		if (!ret) {
			ModernizedCProgram._uprintf("Format error: %s", ModernizedCProgram.StrError(ModernizedCProgram.FormatStatus, 1));
			;
		} 
		// Error will be set by FormatPartition() in FormatStatus
		if (ModernizedCProgram.use_vds) {
			hPhysicalDrive = ModernizedCProgram.GetPhysicalHandle(DriveIndex, actual_lock_drive, 1, !actual_lock_drive);
			if (hPhysicalDrive == (HANDLE)(true)) {
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				;
			} 
		} 
		// Get RW access back to the physical drive...
		// Thanks to Microsoft, we must fix the MBR AFTER the drive has been formattedif ((ModernizedCProgram.partition_type == _PARTITION_STYLE.PARTITION_STYLE_MBR) || ((ModernizedCProgram.boot_type != boot_type.BT_NON_BOOTABLE) && (ModernizedCProgram.partition_type == _PARTITION_STYLE.PARTITION_STYLE_GPT))) {
			ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3228);
			if ((!ModernizedCProgram.WriteMBR(hPhysicalDrive)) || (!ModernizedCProgram.WriteSBR(hPhysicalDrive))) {
				if (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				} 
				;
			} 
			ModernizedCProgram.UpdateProgress(action_type.OP_FIX_MBR, -1.0);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(200);
		ModernizedCProgram.WaitForLogical(DriveIndex, 0)// Try to continue;// Try to continue
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
			;
		} 
		volume_name = ModernizedCProgram.GetLogicalName(DriveIndex, ModernizedCProgram.partition_offset[0], 1, 1);
		if (volume_name == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not get volume name");
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		ModernizedCProgram._uprintf("Found volume %s", volume_name);
		if (!ModernizedCProgram.MountVolume(drive_name, volume_name)) {
			ModernizedCProgram._uprintf("Could not remount %s as %C: %s\n", volume_name, drive_name[0], ModernizedCProgram.WindowsErrorString());
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
			;
		} 
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
			;
		} 
		// Disable file indexing, unless it was force-enabled by the userif ((!ModernizedCProgram.enable_file_indexing) && ((ModernizedCProgram.fs_type == fs_type.FS_NTFS) || (ModernizedCProgram.fs_type == fs_type.FS_UDF) || (ModernizedCProgram.fs_type == fs_type.FS_REFS))) {
			ModernizedCProgram._uprintf("Disabling file indexing...");
			if (!/*Error: Function owner not recognized*/SetFileAttributesA(volume_name, -1024)) {
				ModernizedCProgram._uprintf("Could not disable file indexing: %s", ModernizedCProgram.WindowsErrorString());
			} 
		} 
		// Refresh the drive label - This is needed as Windows may have altered it from// the name we proposed, and we require an exact label, to patch config files.if ((ModernizedCProgram.fs_type < fs_type.FS_EXT2) && !ModernizedCProgram.GetVolumeInformationU(drive_name, ModernizedCProgram.img_report.getUsb_label(), (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), ((Object)0), ((Object)0), ((Object)0), ((Object)0), 0)) {
			ModernizedCProgram._uprintf("Warning: Failed to refresh label: %s", ModernizedCProgram.WindowsErrorString());
		}  else if ((ModernizedCProgram.fs_type >= fs_type.FS_EXT2) && (ModernizedCProgram.fs_type <= fs_type.FS_EXT4)) {
			byte ext_label = ModernizedCProgram.GetExtFsLabel(DriveIndex, 0);
			if (ext_label != ((Object)0)) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.img_report.getUsb_label(), label, (((size_t)(((((byte)label) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(label)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)label) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(label)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)ModernizedCProgram.img_report.getUsb_label())[(((size_t)(((((byte)label) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(label)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)label) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(label)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
			} 
		} 
		if (ModernizedCProgram.boot_type != boot_type.BT_NON_BOOTABLE) {
			if (ModernizedCProgram.boot_type == boot_type.BT_UEFI_NTFS) {
			}  else if (ModernizedCProgram.target_type == target_type.TT_UEFI) {
				(((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.img_report.getHas_efi() != 0) && (ModernizedCProgram.fs_type <= fs_type.FS_NTFS)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(boot_type == BT_IMAGE) && IS_EFI_BOOTABLE(img_report) && (fs_type <= FS_NTFS)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\format.c", 2793));
				if ((ModernizedCProgram.boot_type != boot_type.BT_IMAGE) || !(ModernizedCProgram.img_report.getHas_efi() != 0) || (ModernizedCProgram.fs_type > fs_type.FS_NTFS)) {
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
					;
				} 
			}  else if ((ModernizedCProgram.boot_type == boot_type.BT_SYSLINUX_V4) || (ModernizedCProgram.boot_type == boot_type.BT_SYSLINUX_V6) || ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && ((ModernizedCProgram.img_report.getSl_version() != 0) || (ModernizedCProgram.img_report.getReactos_path()[0] != 0)) && (!(((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getUses_minint()) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) || !ModernizedCProgram.allow_dual_uefi_bios))) {
				if (!ModernizedCProgram.InstallSyslinux(DriveIndex, drive_name[0], ModernizedCProgram.fs_type)) {
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
					;
				} 
			} else {
					hLogicalVolume = ModernizedCProgram.GetLogicalHandle(DriveIndex, ModernizedCProgram.partition_offset[0], 0, 1, 0);
					if ((hLogicalVolume == (HANDLE)(true)) || (hLogicalVolume == ((Object)0))) {
						ModernizedCProgram._uprintf("Could not re-mount volume for partition boot record access");
						ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
						;
					} 
					ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3229);
					if (!ModernizedCProgram.WritePBR(hLogicalVolume)) {
						if (!((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
							ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
						} 
						;
					} 
					do {
						if ((hLogicalVolume != (HANDLE)(true)) && (hLogicalVolume != ((Object)0))) {
							ModernizedCProgram.UnlockDrive(hLogicalVolume);
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hLogicalVolume);
							hLogicalVolume = (HANDLE)(true);
						} 
					} while (0);
			} 
		} else {
				if ((/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1015) == 1)) {
					ModernizedCProgram.SetAutorun(drive_name);
				} 
		} 
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
			;
		} 
		// We issue a complete remount of the filesystem at on account of:
		// - Ensuring the file explorer properly detects that the volume was updated// - Ensuring that an NTFS system will be reparsed so that it becomes bootableif (!ModernizedCProgram.RemountVolume(drive_name)) {
			;
		} 
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
			;
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)volume_name);
			volume_name = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)buffer);
			buffer = ((Object)0);
		} while (0);
		do {
			if ((hSourceImage != (HANDLE)(true)) && (hSourceImage != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hSourceImage);
				hSourceImage = (HANDLE)(true);
			} 
		} while (0);
		do {
			if ((hLogicalVolume != (HANDLE)(true)) && (hLogicalVolume != ((Object)0))) {
				ModernizedCProgram.UnlockDrive(hLogicalVolume);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hLogicalVolume);
				hLogicalVolume = (HANDLE)(true);
			} 
		} while (0);
		// This can take a whiledo {
			if ((hPhysicalDrive != (HANDLE)(true)) && (hPhysicalDrive != ((Object)0))) {
				ModernizedCProgram.UnlockDrive(hPhysicalDrive);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hPhysicalDrive);
				hPhysicalDrive = (HANDLE)(true);
			} 
		} while (0);
		if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
			volume_name = ModernizedCProgram.GetLogicalName(DriveIndex, 0, 1, 0);
			if (volume_name != ((Object)0)) {
				if (ModernizedCProgram.MountVolume(drive_name, volume_name)) {
					ModernizedCProgram._uprintf("Re-mounted volume as %C: after error", drive_name[0]);
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(volume_name);
			} 
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_FORMAT_COMPLETED, (WPARAM)1, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExitThread(0);
	}
	public static Object SaveImageThread(Object param) {
		BOOL s = new BOOL();
		DWORD rSize = new DWORD();
		DWORD wSize = new DWORD();
		IMG_SAVE img_save = (IMG_SAVE)param;
		HANDLE hPhysicalDrive = (HANDLE)(true);
		HANDLE hDestImage = (HANDLE)(true);
		LARGE_INTEGER li = new LARGE_INTEGER();
		uint8_t buffer = ((Object)0);
		uint64_t wb = new uint64_t();
		int i;
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3225);
		Object generatedDeviceNum = img_save.getDeviceNum();
		Object generatedDevicePath = img_save.getDevicePath();
		Object generatedType = img_save.getType();
		switch (generatedType) {
		case 2:
				hPhysicalDrive = /*Error: Function owner not recognized*/CreateFileA(generatedDevicePath, -1024, -1024, ((Object)0), 3, 134217728, ((Object)0));
				break;
		case 1:
				hPhysicalDrive = ModernizedCProgram.GetPhysicalHandle(generatedDeviceNum, 1, 0, 0);
				break;
		default:
				ModernizedCProgram._uprintf("Invalid image type");
		}
		if (hPhysicalDrive == (HANDLE)(true)) {
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		// Write an image file// We may have poked the MBR and other stuff, so need to rewind// Write an image file// We may have poked the MBR and other stuff, so need to rewindli.setQuadPart(0);
		if (!/*Error: Function owner not recognized*/SetFilePointerEx(hPhysicalDrive, li, ((Object)0), 0)) {
			ModernizedCProgram._uprintf("Warning: Unable to rewind device position - wrong data might be copied!");
		} 
		Object generatedImagePath = img_save.getImagePath();
		hDestImage = ModernizedCProgram.CreateFileU(generatedImagePath, -1024, -1024, ((Object)0), 2, -1024, ((Object)0));
		if (hDestImage == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Could not open image '%s': %s", generatedImagePath, ModernizedCProgram.WindowsErrorString());
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		Object generatedBufSize = img_save.getBufSize();
		buffer = (uint8_t)/*Error: Function owner not recognized*/_mm_malloc(generatedBufSize, 16);
		if (buffer == ((Object)0)) {
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			ModernizedCProgram._uprintf("could not allocate buffer");
			;
		} 
		ModernizedCProgram._uprintf("Will use a buffer size of %s", ModernizedCProgram.SizeToHumanReadable(generatedBufSize, 0, 0));
		ModernizedCProgram._uprintf("Saving to image '%s'...", generatedImagePath)// Don't bother trying for something clever, using double buffering overlapped and whatnot:;// Don't bother trying for something clever, using double buffering overlapped and whatnot:
		// With Windows' default optimizations, sync read + sync write for sequential operations// will be as fast, if not faster, than whatever async scheme you can come up with.// With Windows' default optimizations, sync read + sync write for sequential operations// will be as fast, if not faster, than whatever async scheme you can come up with.ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_INIT, (int)0, (uint64_t)(uintptr_t)((Object)0), 0);
		;
		Object generatedDeviceSize = img_save.getDeviceSize();
		for (wb = 0; /*Error: Unsupported expression*/; wb += wSize) {
			if (generatedType == 2) {
				li.setQuadPart(wb);
				if (!/*Error: Function owner not recognized*/SetFilePointerEx(hPhysicalDrive, li, ((Object)0), 0)) {
					ModernizedCProgram._uprintf("Warning: Unable to set device position - wrong data might be copied!");
				} 
			} 
			s = /*Error: Function owner not recognized*/ReadFile(hPhysicalDrive, buffer, (DWORD)(((generatedBufSize) < (generatedDeviceSize - wb)) ? (generatedBufSize) : (generatedDeviceSize - wb)), rSize, ((Object)0));
			if (!s) {
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				ModernizedCProgram._uprintf("Read error: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			if (rSize == 0) {
				break;
			} 
			ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FORMAT, 3261, wb, generatedDeviceSize);
			for (i = 1; i <= 4; i++) {
				if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
					;
				} 
				s = /*Error: Function owner not recognized*/WriteFile(hDestImage, buffer, rSize, wSize, ((Object)0));
				if ((s) && (wSize == rSize)) {
					break;
				} 
				if (s) {
					ModernizedCProgram._uprintf("Write error: Wrote %d bytes, expected %d bytes", wSize, rSize);
				} else {
						ModernizedCProgram._uprintf("Write error: %s", ModernizedCProgram.WindowsErrorString());
				} 
				if (i < 4) {
					li.setQuadPart(wb);
					ModernizedCProgram._uprintf("Retrying in %d seconds...", 5000 / 1000);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(5000);
					if (!/*Error: Function owner not recognized*/SetFilePointerEx(hDestImage, li, ((Object)0), 0)) {
						ModernizedCProgram._uprintf("Write error: Could not reset position - %s", ModernizedCProgram.WindowsErrorString());
						;
					} 
				} else {
						ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
						;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(200);
			}
			if (i > 4) {
				;
			} 
		}
		if (wb != generatedDeviceSize) {
			ModernizedCProgram._uprintf("Error: wrote %s, expected %s", ModernizedCProgram.SizeToHumanReadable(wb, 0, 0), ModernizedCProgram.SizeToHumanReadable(generatedDeviceSize, 0, 0));
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		if (generatedType == 1) {
			ModernizedCProgram._uprintf("Appending VHD footer...");
			if (!ModernizedCProgram.AppendVHDFooter(generatedImagePath)) {
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				;
			} 
		} 
		ModernizedCProgram._uprintf("Operation complete (Wrote %s).", ModernizedCProgram.SizeToHumanReadable(wb, 0, 0));
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_mm_free((Object)buffer);
			buffer = ((Object)0);
		} while (0);
		do {
			if ((hDestImage != (HANDLE)(true)) && (hDestImage != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDestImage);
				hDestImage = (HANDLE)(true);
			} 
		} while (0);
		do {
			if ((hPhysicalDrive != (HANDLE)(true)) && (hPhysicalDrive != ((Object)0))) {
				ModernizedCProgram.UnlockDrive(hPhysicalDrive);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hPhysicalDrive);
				hPhysicalDrive = (HANDLE)(true);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_FORMAT_COMPLETED, (WPARAM)1, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExitThread(0);
	}
	public static void check_errors_in_children(int signo) {
		int status;
		if (!signo) {
			if (ModernizedCProgram.wait(status) < /* block waiting for any child */0) {
				return /*Error: Unsupported expression*/;
			} 
			;
		} 
	}
	/* Child */
	/* we don't want to read from the parent */
	// FIXME: error check?
	/* send EOF */
	/* must be _exit! bug was actually seen here */
	/*error if:*/
	/* notreached */
	/* parent process */
	/* don't want to write to the child */
	/* Used by e.g. rpm which gives us a fd without filename,
	 * thus we can't guess the format from filename's extension.
	 */
	/* .gz and .bz2 both have 2-byte signature, and their
		 * unpack_XXX_stream wants this header skipped. */
	/* No known magic seen */
	/* Some callers expect this function to "consume" fd
		 * even if data is not compressed. In this case,
		 * we return a state with trivial transformer.
		 */
	//	USE_FOR_MMU(xstate->xformer = copy_stream;)
	//	USE_FOR_NOMMU(xstate->xformer_prog = "cat";)
	/* fall through to seeking bck over bytes we read earlier */
	/* NOMMU version of fork_transformer execs
		 * an external unzipper that wants
		 * file position at the start of the file.
		 */
	/* In MMU case, if magic was found, seeking back is not necessary */
	/* Used by e.g. rpm which gives us a fd without filename,
	 * thus we can't guess the format from filename's extension.
	 */
	/* .lzma has no header/signature, can only detect it by extension */
	/* else: the file is not compressed */
	/*fail_if_not_compressed:*/
	/* file open error */
	/* In-memory decompression */
	/* File is not compressed */
	/* This version forks a subprocess - much more expensive */
	/*fail_if_not_compressed:*/
	/* SEAMLESS_COMPRESSION */
	/* vi: set sw=4 ts=4: */
	/*
	 * Copyright 2006, Bernhard Reutner-Fischer
	 *
	 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
	 */
	/* Convenience macros to test the version of gcc. */
	/* __restrict is known in EGCS 1.2 and above. */
	/* it's a keyword */
	/* "The malloc attribute is used to tell the compiler that a function
	 * may be treated as if any non-NULL pointer it returns cannot alias
	 * any other pointer valid when the function returns. This will often
	 * improve optimization. Standard functions with this property include
	 * malloc and calloc. realloc-like functions have this property as long
	 * as the old pointer is never referred to (including comparing it
	 * to the new pointer) after the function returns a non-NULL value."
	 */
	/* __NO_INLINE__: some gcc's do not honor inlining! :( */
	/* I've seen a toolchain where I needed __noinline__ instead of noinline */
	/* used by unit test machinery to run registration functions before calling main() */
	/* -fwhole-program makes all symbols local. The attribute externally_visible
	 * forces a symbol global.  */
	//__attribute__ ((__externally_visible__))
	/* At 4.4 gcc become much more anal about this, need to use "aliased" types */
	/* We use __extension__ in some places to suppress -pedantic warnings
	 * about GCC extensions.  This feature didn't work properly before
	 * gcc 2.8.  */
	/* FAST_FUNC is a qualifier which (possibly) makes function call faster
	 * and/or smaller by using modified ABI. It is usually only needed
	 * on non-static, busybox internal functions. Recent versions of gcc
	 * optimize statics automatically. FAST_FUNC on static is required
	 * only if you need to match a function pointer's type */
	/* || defined(__x86_64__)? */
	/* stdcall makes callee to pop arguments from stack, not caller */
	/* #elif ... - add your favorite arch today! */
	/* Make all declarations hidden (-fvisibility flag only affects definitions) */
	/* (don't include system headers after this until corresponding pop!) */
	/* gcc-2.95 had no va_copy but only __va_copy. */
	/* ---- Endian Detection ------------------------------------ */
	/* rlimit */
	public static Object bswap_16(Object x) {
		x = (x >> 8) | (x << 8);
		return x;
	}
	public static Object bswap_32(Object x) {
		x = ((x << 8) & -1024) | ((x >> 8) & -1024);
		x = (x >> 16) | (x << 16);
		return x;
	}
	public static Object bswap_64(Object x) {
		Object w;
		Object r;
		w.setLl(x);
		Object generatedL = r.getL();
		generatedL[0] = ModernizedCProgram.bswap_32(generatedL[1]);
		generatedL[1] = ModernizedCProgram.bswap_32(generatedL[0]);
		Object generatedLl = r.getLl();
		return generatedLl;
	}
	/* SWAP_LEnn means "convert CPU<->little_endian by swapping bytes" */
	/* ---- Unaligned access ------------------------------------ */
	/* NB: unaligned parameter should be a pointer, aligned one -
	 * a lvalue. This makes it more likely to not swap them by mistake
	 */
	/* #elif ... - add your favorite arch today! */
	/* performs reasonably well (gcc usually inlines memcpy here) */
	/* ---- Size-saving "small" ints (arch-dependent) ----------- */
	/* add other arches which benefit from this... */
	/* for arches where byte accesses generate larger code: */
	/* ISO C Standard:  7.16  Boolean type and values  <stdbool.h> */
	/* old system without (proper) C99 support */
	/* modern system, so use it */
	/*----- Kernel versioning ------------------------------------*/
	/* ---- Miscellaneous --------------------------------------- */
	/* Define bb_setpgrp */
	/* use legacy setpgrp(pid_t, pid_t) for now.  move to platform.c */
	/* Useful for defeating gcc's alignment of "char message[]"-like data */
	/* on s390[x], non-word-aligned data accesses require larger code */
	/* Arches which MUST have 2 or 4 byte alignment for everything are here */
	/*
	 * For 0.9.29 and svn, __ARCH_USE_MMU__ indicates no-mmu reliably.
	 * For earlier versions there is no reliable way to check if we are building
	 * for a mmu-less system.
	 */
	/* ---- Who misses what? ------------------------------------ */
	/* Assume all these functions and header files exist by default.
	 * Platforms where it is not true will #undef them below.
	 */
	/* We need to define ssize_t before the getline declaration below (copy/paste from MinGW) */
	/* These BSD-derived OSes share many similarities */
	/* users say mempcpy is not present in FreeBSD 9.x */
	/* FreeBSD added strchrnul() between 1000028 and 1000029 */
	/* Recent NetBSD versions have getline() */
	/*
	 * Now, define prototypes for all the functions defined in platform.c
	 * These must come after all the HAVE_* macros are defined (or not)
	 */
	/* In case we are wrong about !HAVE_MEMPCPY, and toolchain _does_ have
	 * mempcpy(), avoid colliding with it:
	 */
	/* In case we are wrong about !HAVE_MEMPCPY, and toolchain _does_ have
	 * mempcpy(), avoid colliding with it:
	 */
	/* Not exactly the same: instead of "Stopped" it shows "STOP" etc */
	/* Not exactly the same: instead of "Stopped" it shows "STOP" etc */
	/* for FILE */
	/* for FILE */
	/* size_t */
	/*
	 * symlink.c --- make a symlink in the filesystem, based on mkdir.c
	 *
	 * Copyright (c) 2012, Intel Corporation.
	 * All Rights Reserved.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/*
	 * Incredibly, libc5 doesn't appear to have strnlen.  So we have to
	 * provide our own.
	 */
	/*
	 * Incredibly, libc5 doesn't appear to have strnlen.  So we have to
	 * provide our own.
	 */
	public static Object ext2fs_symlink(Object fs, Object parent, Object ino, Object name, Object target) {
		 retval = new ();
		ext2_inode inode = new ext2_inode();
		 scratch_ino = new ();
		 blk = new ();
		int fastlink;
		int inlinelink;
		int target_len;
		byte block_buf = 0;
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS/*
				 * The Linux kernel doesn't allow for links longer than a block
				 * (counting the NUL terminator)
				 */);
		} 
		target_len = /*Error: Function owner not recognized*/strnlen(target, fs.getBlocksize() + 1);
		if (target_len >= fs.getBlocksize()) {
			retval = EXT2_ET_INVALID_ARGUMENT;
			;
		} 
		retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), /*
			 * Allocate a data block for slow links
			 */block_buf);
		if (retval) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(block_buf, 0, fs.getBlocksize());
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(block_buf, target, fs.getBlocksize());
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(inode, 0, /*Error: Unsupported expression*/);
		Object generatedI_block = inode.getI_block();
		fastlink = (target_len < /*Error: sizeof expression not supported yet*/);
		if (!fastlink) {
			retval = ModernizedCProgram.ext2fs_new_block2(fs, inode.ext2fs_find_inode_goal(fs, ino, 0), ((Object)0), blk);
			if (retval) {
				;
			} 
		} 
		if (!/*
			 * Allocate an inode, if necessary
			 */ino) {
			retval = ModernizedCProgram.ext2fs_new_inode(fs, parent, 120000 | 755, 0, ino);
			if (retval) {
				;
			} 
		} 
		inode.setI_mode(120000 | /*
			 * Create the inode structure....
			 */777);
		inode.setI_uid(inode.setI_gid(0));
		inode.setI_links_count(1);
		inode.ext2fs_inode_size_set(fs, target_len/* The time fields are set by ext2fs_write_new_inode() */);
		inlinelink = !fastlink && fs.getSuper().ext2fs_has_feature_inline_data();
		Object generatedI_flags = inode.getI_flags();
		if (inlinelink) {
			retval = inode.ext2fs_write_inode(fs, ino);
		} else {
				retval = inode.ext2fs_write_new_inode(fs, ino);
		} 
		if (retval) {
			;
		} 
		if (!fastlink && !inlinelink) {
			retval = inode.ext2fs_bmap2(fs, ino, ((Object)0), -1024, 0, ((Object)0), blk);
			if (retval) {
				;
			} 
			retval = ModernizedCProgram.io_channel_write_blk64(fs.getIo(), blk, 1, block_buf);
			if (retval) {
				;
			} 
		} 
		if (/*
			 * Link the symlink into the filesystem hierarchy
			 */name) {
			retval = ModernizedCProgram.ext2fs_lookup(fs, parent, name, /*Error: Function owner not recognized*/strlen(name), 0, scratch_ino);
			if (!retval) {
				retval = EXT2_ET_FILE_EXISTS;
				;
			} 
			if (retval != EXT2_ET_FILE_NOT_FOUND) {
				;
			} 
			retval = ModernizedCProgram.ext2fs_link(fs, parent, name, ino, 7);
			if (retval) {
				;
			} 
		} 
		if (!fastlink && !/*
			 * Update accounting....
			 */inlinelink) {
			ModernizedCProgram.ext2fs_block_alloc_stats2(fs, blk, +1);
		} 
		ModernizedCProgram.ext2fs_inode_alloc_stats2(fs, ino, +1, 0);
		return retval/*
		 * Test whether an inode is a fast symlink.
		 *
		 * A fast symlink has its symlink data stored in inode->i_block.
		 */;
	}
	public static Object iso9660_get_xa_attr_str(Object xa_attr) {
		byte result = ModernizedCProgram._getbuf();
		xa_attr = /*Error: Function owner not recognized*/uint16_from_be(xa_attr);
		result[0] = (xa_attr & XA_ATTR_DIRECTORY) ? (byte)'d' : (byte)'-';
		result[1] = (xa_attr & XA_ATTR_CDDA) ? (byte)'a' : (byte)'-';
		result[2] = (xa_attr & XA_ATTR_INTERLEAVED) ? (byte)'i' : (byte)'-';
		result[3] = (xa_attr & XA_ATTR_MODE2FORM2) ? (byte)'2' : (byte)'-';
		result[4] = (xa_attr & XA_ATTR_MODE2FORM1) ? (byte)'1' : (byte)'-';
		result[5] = (xa_attr & XA_PERM_XUSR) ? (byte)'x' : (byte)'-';
		result[6] = (xa_attr & XA_PERM_RUSR) ? (byte)'r' : (byte)'-';
		result[7] = (xa_attr & XA_PERM_XGRP) ? (byte)'x' : (byte)'-';
		result[8] = (xa_attr & XA_PERM_RGRP) ? (byte)'r' : (byte)'-';
		result[9] = (xa_attr & XA_PERM_XSYS) ? (byte)'x' : /* Hack alert: wonder if this should be ROTH and XOTH? */(byte)'-';
		result[10] = (xa_attr & XA_PERM_RSYS) ? (byte)'r' : (byte)'-';
		result[11] = (byte)'\0';
		return result;
	}
	public static Object iso9660_xa_init(Object _xa, Object uid, Object gid, Object attr, Object filenum) {
		((_xa != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("_xa != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\xa.c", 134));
		_xa.setUser_id(/*Error: Function owner not recognized*/uint16_to_be(uid));
		_xa.setGroup_id(/*Error: Function owner not recognized*/uint16_to_be(gid));
		_xa.setAttributes(/*Error: Function owner not recognized*/uint16_to_be(attr));
		_xa.getSignature()[0] = (byte)'X';
		_xa.getSignature()[1] = (byte)'A';
		_xa.setFilenum(filenum);
		_xa.getReserved()[0] = _xa.getReserved()[1] = _xa.getReserved()[2] = _xa.getReserved()[3] = _xa.getReserved()[4] = -1024;
		return _xa;
	}
	public static void iso9660_xa_free(Object _xa) {
		if (_xa != NULL) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_xa/*!
			  Returns POSIX mode bitstring for a given file.
			*/);
		} 
	}
	public static Object iso9660_get_posix_filemode_from_xa(Object i_perms) {
		 mode = 0;
		if (i_perms & XA_PERM_RUSR) {
			mode |=  400;
		} 
		if (i_perms & XA_PERM_XUSR) {
			mode |=  100;
		} 
		if (i_perms & XA_PERM_RGRP) {
			mode |=  (400 >> 3);
		} 
		if (i_perms & XA_PERM_XGRP) {
			mode |=  (100 >> 3);
		} 
		if (i_perms & XA_PERM_ROTH) {
			mode |=  (400 >> 6);
		} 
		if (i_perms & XA_PERM_XOTH) {
			mode |=  (100 >> 6);
		} 
		if (i_perms & XA_ATTR_DIRECTORY) {
			mode |=  S_IFDIR;
		} 
		return mode;
	}
	/*
	 * Used by previously inlined function, so we have to export this and
	 * not change the function signature
	 */
	public static void ext2fs_warn_bitmap2(Object gen_bitmap, int code, long arg) {
		ext2fs_generic_bitmap_32 bitmap = (ext2fs_generic_bitmap_32)gen_bitmap;
		if (bitmap.getDescription()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, bitmap.getBase_error_code() + code, "#%lu for %s", arg, bitmap.getDescription());
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, bitmap.getBase_error_code() + code, "#%lu", arg);
		} 
	}
	public static Object check_magic(Object bitmap) {
		if (!bitmap || !((bitmap.getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || (bitmap.getMagic() == EXT2_ET_MAGIC_INODE_BITMAP) || (bitmap.getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP))) {
			return EXT2_ET_MAGIC_GENERIC_BITMAP;
		} 
		return 0;
	}
	public static Object ext2fs_make_generic_bitmap(Object magic, Object fs, Object start, Object end, Object real_end, Object descr, Byte init_map, Object ret) {
		ext2fs_generic_bitmap_32 bitmap = new ext2fs_generic_bitmap_32();
		 retval = new ();
		size_t size = new size_t();
		retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Unsupported expression*/, bitmap);
		if (retval) {
			return retval;
		} 
		bitmap.setMagic(magic);
		bitmap.setFs(fs);
		bitmap.setStart(start);
		bitmap.setEnd(end);
		bitmap.setReal_end(real_end);
		switch (magic) {
		case EXT2_ET_MAGIC_BLOCK_BITMAP:
				bitmap.setBase_error_code(EXT2_ET_BAD_BLOCK_MARK);
				break;
		case EXT2_ET_MAGIC_INODE_BITMAP:
				bitmap.setBase_error_code(EXT2_ET_BAD_INODE_MARK);
				break;
		default:
				bitmap.setBase_error_code(EXT2_ET_BAD_GENERIC_MARK);
		}
		if (descr) {
			retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Function owner not recognized*/strlen(descr) + 1, bitmap.getDescription());
			if (retval) {
				ModernizedCProgram.ext2fs_free_mem(bitmap);
				return retval;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(bitmap.getDescription(), descr);
		} else {
				bitmap.setDescription(0);
		} 
		size = (size_t)(((bitmap.getReal_end() - bitmap.getStart()) / 8) + 1);
		size = (size + 7) & ~/* Round up to allow for the BT x86 instruction */3;
		retval = ModernizedCProgram.ext2fs_get_mem(size, bitmap.getBitmap());
		if (retval) {
			ModernizedCProgram.ext2fs_free_mem(bitmap.getDescription());
			ModernizedCProgram.ext2fs_free_mem(bitmap);
			return retval;
		} 
		if (init_map) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(bitmap.getBitmap(), init_map, size);
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(bitmap.getBitmap(), 0, size);
		} 
		ret = (ext2fs_generic_bitmap)bitmap;
		return 0;
	}
	public static Object ext2fs_allocate_generic_bitmap(Object start, Object end, Object real_end, Object descr, Object ret) {
		return ModernizedCProgram.ext2fs_make_generic_bitmap(EXT2_ET_MAGIC_GENERIC_BITMAP, 0, start, end, real_end, descr, 0, ret);
	}
	public static Object ext2fs_copy_generic_bitmap(Object gen_src, Object dest) {
		ext2fs_generic_bitmap_32 src = (ext2fs_generic_bitmap_32)gen_src;
		return (ModernizedCProgram.ext2fs_make_generic_bitmap(src.getMagic(), src.getFs(), src.getStart(), src.getEnd(), src.getReal_end(), src.getDescription(), src.getBitmap(), dest));
	}
	public static void ext2fs_free_generic_bitmap(Object gen_bitmap) {
		ext2fs_generic_bitmap_32 bitmap = (ext2fs_generic_bitmap_32)gen_bitmap;
		if (ModernizedCProgram.check_magic(gen_bitmap)) {
			return /*Error: Unsupported expression*/;
		} 
		bitmap.setMagic(0);
		if (bitmap.getDescription()) {
			ModernizedCProgram.ext2fs_free_mem(bitmap.getDescription());
			bitmap.setDescription(0);
		} 
		if (bitmap.getBitmap()) {
			ModernizedCProgram.ext2fs_free_mem(bitmap.getBitmap());
			bitmap.setBitmap(0);
		} 
		ModernizedCProgram.ext2fs_free_mem(bitmap);
	}
	public static int ext2fs_test_generic_bitmap(Object bitmap, Object bitno) {
		ext2fs_generic_bitmap_32 bitmap32 = (ext2fs_generic_bitmap_32)bitmap;
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
				ModernizedCProgram.ext2fs_warn_bitmap32(bitmap, __func__);
				return ModernizedCProgram.ext2fs_test_generic_bmap(bitmap, bitno);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, EXT2_ET_MAGIC_GENERIC_BITMAP, "test_bitmap(%lu)", (long)bitno);
			return 0;
		} 
		if ((bitno < bitmap32.getStart()) || (bitno > bitmap32.getEnd())) {
			ModernizedCProgram.ext2fs_warn_bitmap2(bitmap, 2, bitno);
			return 0;
		} 
		return ModernizedCProgram.ext2fs_test_bit(bitno - bitmap32.getStart(), bitmap32.getBitmap());
	}
	public static int ext2fs_mark_generic_bitmap(Object bitmap, Object bitno) {
		ext2fs_generic_bitmap_32 bitmap32 = (ext2fs_generic_bitmap_32)bitmap;
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
				ModernizedCProgram.ext2fs_warn_bitmap32(bitmap, __func__);
				return ModernizedCProgram.ext2fs_mark_generic_bmap(bitmap, bitno);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, EXT2_ET_MAGIC_GENERIC_BITMAP, "mark_bitmap(%lu)", (long)bitno);
			return 0;
		} 
		if ((bitno < bitmap32.getStart()) || (bitno > bitmap32.getEnd())) {
			ModernizedCProgram.ext2fs_warn_bitmap2(bitmap, 0, bitno);
			return 0;
		} 
		return ModernizedCProgram.ext2fs_set_bit(bitno - bitmap32.getStart(), bitmap32.getBitmap());
	}
	public static int ext2fs_unmark_generic_bitmap(Object bitmap, Object bitno) {
		ext2fs_generic_bitmap_32 bitmap32 = (ext2fs_generic_bitmap_32)bitmap;
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
				ModernizedCProgram.ext2fs_warn_bitmap32(bitmap, __func__);
				return ModernizedCProgram.ext2fs_unmark_generic_bmap(bitmap, bitno);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, EXT2_ET_MAGIC_GENERIC_BITMAP, "mark_bitmap(%lu)", (long)bitno);
			return 0;
		} 
		if ((bitno < bitmap32.getStart()) || (bitno > bitmap32.getEnd())) {
			ModernizedCProgram.ext2fs_warn_bitmap2(bitmap, 1, bitno);
			return 0;
		} 
		return ModernizedCProgram.ext2fs_clear_bit(bitno - bitmap32.getStart(), bitmap32.getBitmap());
	}
	public static Object ext2fs_get_generic_bitmap_start(Object bitmap) {
		ext2fs_generic_bitmap_32 bitmap32 = (ext2fs_generic_bitmap_32)bitmap;
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
				ModernizedCProgram.ext2fs_warn_bitmap32(bitmap, __func__);
				return ModernizedCProgram.ext2fs_get_generic_bmap_start(bitmap);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, EXT2_ET_MAGIC_GENERIC_BITMAP, "get_bitmap_start");
			return 0;
		} 
		return bitmap32.getStart();
	}
	public static Object ext2fs_get_generic_bitmap_end(Object bitmap) {
		ext2fs_generic_bitmap_32 bitmap32 = (ext2fs_generic_bitmap_32)bitmap;
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
				ModernizedCProgram.ext2fs_warn_bitmap32(bitmap, __func__);
				return ModernizedCProgram.ext2fs_get_generic_bmap_end(bitmap);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, EXT2_ET_MAGIC_GENERIC_BITMAP, "get_bitmap_end");
			return 0;
		} 
		return bitmap32.getEnd();
	}
	public static void ext2fs_clear_generic_bitmap(Object bitmap) {
		ext2fs_generic_bitmap_32 bitmap32 = (ext2fs_generic_bitmap_32)bitmap;
		if (!(((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP))) {
			if ((((bitmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bitmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
				ModernizedCProgram.ext2fs_warn_bitmap32(bitmap, __func__);
				ModernizedCProgram.ext2fs_clear_generic_bmap(bitmap);
				return /*Error: Unsupported expression*/;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, EXT2_ET_MAGIC_GENERIC_BITMAP, "clear_generic_bitmap");
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(bitmap32.getBitmap(), 0, (size_t)(((bitmap32.getReal_end() - bitmap32.getStart()) / 8) + 1));
	}
	public static Object ext2fs_fudge_generic_bitmap_end(Object gen_bitmap, Object magic, Object neq, Object end, Object oend) {
		ext2fs_generic_bitmap_32 bitmap = (ext2fs_generic_bitmap_32)gen_bitmap;
		if (!(bitmap) || (bitmap).getMagic() != (magic)) {
			return (magic);
		} 
		if (end > bitmap.getReal_end()) {
			return neq;
		} 
		if (oend) {
			oend = bitmap.getEnd();
		} 
		bitmap.setEnd(end);
		return 0;
	}
	public static Object ext2fs_resize_generic_bitmap(Object magic, Object new_end, Object new_real_end, Object gen_bmap) {
		ext2fs_generic_bitmap_32 bmap = (ext2fs_generic_bitmap_32)gen_bmap;
		 retval = new ();
		size_t size = new size_t();
		size_t new_size = new size_t();
		 bitno = new ();
		if (!bmap || (bmap.getMagic() != magic)) {
			return magic/*
				 * If we're expanding the bitmap, make sure all of the new
				 * parts of the bitmap are zero.
				 */;
		} 
		if (new_end > bmap.getEnd()) {
			bitno = bmap.getReal_end();
			if (bitno > new_end) {
				bitno = new_end;
			} 
			for (; bitno > bmap.getEnd(); bitno--) {
				ModernizedCProgram.ext2fs_clear_bit(bitno - bmap.getStart(), bmap.getBitmap());
			}
		} 
		if (new_real_end == bmap.getReal_end()) {
			bmap.setEnd(new_end);
			return 0;
		} 
		size = ((bmap.getReal_end() - bmap.getStart()) / 8) + 1;
		new_size = ((new_real_end - bmap.getStart()) / 8) + 1;
		if (size != new_size) {
			retval = ModernizedCProgram.ext2fs_resize_mem(size, new_size, bmap.getBitmap());
			if (retval) {
				return retval;
			} 
		} 
		if (new_size > size) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(bmap.getBitmap() + size, 0, new_size - size);
		} 
		bmap.setEnd(new_end);
		bmap.setReal_end(new_real_end);
		return 0;
	}
	public static Object ext2fs_compare_generic_bitmap(Object magic, Object neq, Object gen_bm1, Object gen_bm2) {
		ext2fs_generic_bitmap_32 bm1 = (ext2fs_generic_bitmap_32)gen_bm1;
		ext2fs_generic_bitmap_32 bm2 = (ext2fs_generic_bitmap_32)gen_bm2;
		 i = new ();
		if (!bm1 || bm1.getMagic() != magic) {
			return magic;
		} 
		if (!bm2 || bm2.getMagic() != magic) {
			return magic;
		} 
		if ((bm1.getStart() != bm2.getStart()) || (bm1.getEnd() != bm2.getEnd()) || (/*Error: Function owner not recognized*/memcmp(bm1.getBitmap(), bm2.getBitmap(), (size_t)(bm1.getEnd() - bm1.getStart()) / 8))) {
			return neq;
		} 
		for (i = bm1.getEnd() - ((bm1.getEnd() - bm1.getStart()) % 8); i <= bm1.getEnd(); i++) {
			if (ModernizedCProgram.ext2fs_fast_test_block_bitmap(gen_bm1, i) != ModernizedCProgram.ext2fs_fast_test_block_bitmap(gen_bm2, i)) {
				return neq;
			} 
		}
		return 0;
	}
	public static void ext2fs_set_generic_bitmap_padding(Object gen_map) {
		ext2fs_generic_bitmap_32 map = (ext2fs_generic_bitmap_32)gen_map;
		 i = new ();
		 j = new ();
		for (; i <= map.getReal_end() && i > map.getEnd(); ) {
			ModernizedCProgram.ext2fs_set_bit(j, map.getBitmap());
		}
	}
	public static Object ext2fs_get_generic_bitmap_range(Object gen_bmap, Object magic, Object start, Object num, Object out) {
		ext2fs_generic_bitmap_32 bmap = (ext2fs_generic_bitmap_32)gen_bmap;
		if (!bmap || (bmap.getMagic() != magic)) {
			return magic;
		} 
		if ((start < bmap.getStart()) || (start + num - 1 > bmap.getReal_end())) {
			return EXT2_ET_INVALID_ARGUMENT;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(out, bmap.getBitmap() + (start >> 3), (num + 7) >> 3);
		return 0;
	}
	public static Object ext2fs_set_generic_bitmap_range(Object gen_bmap, Object magic, Object start, Object num, Object in) {
		ext2fs_generic_bitmap_32 bmap = (ext2fs_generic_bitmap_32)gen_bmap;
		if (!bmap || (bmap.getMagic() != magic)) {
			return magic;
		} 
		if ((start < bmap.getStart()) || (start + num - 1 > bmap.getReal_end())) {
			return EXT2_ET_INVALID_ARGUMENT;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(bmap.getBitmap() + (start >> 3), in, (num + 7) >> 3);
		return 0/*
		 * Compare @mem to zero buffer by 256 bytes.
		 * Return 1 if @mem is zeroed memory, otherwise return 0.
		 */;
	}
	public static int ext2fs_mem_is_zero(Object mem, Object len) {
		byte[] zero_buf = new byte[256];
		while (len >= /*Error: sizeof expression not supported yet*/) {
			if (/*Error: Function owner not recognized*/memcmp(mem, zero_buf, /*Error: sizeof expression not supported yet*/)) {
				return 0;
			} 
			len -= /*Error: sizeof expression not supported yet*/;
			mem += /*Error: sizeof expression not supported yet*/;
		}
		if (/* Deal with leftover bytes. */len) {
			return !/*Error: Function owner not recognized*/memcmp(mem, zero_buf, len);
		} 
		return 1/*
		 * Return true if all of the bits in a specified range are clear
		 */;
	}
	public static int ext2fs_test_clear_generic_bitmap_range(Object gen_bitmap, int start, int len) {
		ext2fs_generic_bitmap_32 bitmap = (ext2fs_generic_bitmap_32)gen_bitmap;
		size_t start_byte = new size_t();
		size_t len_byte = len >> 3;
		int start_bit;
		int len_bit = len % 8;
		int first_bit = 0;
		int last_bit = 0;
		int mark_count = 0;
		int mark_bit = 0;
		int i;
		byte ADDR = bitmap.getBitmap();
		start -= bitmap.getStart();
		start_byte = start >> 3;
		start_bit = start % 8;
		if (start_bit != 0/*
				 * The compared start block number or start inode number
				 * is not the first bit in a byte.
				 */) {
			mark_count = 8 - start_bit;
			if (len < 8 - start_bit) {
				mark_count = (int)len;
				mark_bit = len + start_bit - 1;
			} else {
					mark_bit = 7;
			} 
			for (i = mark_count; i > 0; ) {
				first_bit |=  1 << mark_bit/*
						 * Compare blocks or inodes in the first byte.
						 * If there is any marked bit, this function returns 0.
						 */;
			}
			if (first_bit & ADDR[start_byte]) {
				return 0;
			}  else if (len <= 8 - start_bit) {
				return 1;
			} 
			start_byte++;
			len_bit = (len - mark_count) % 8;
			len_byte = (len - mark_count) >> 3/*
				 * The compared start block number or start inode number is
				 * the first bit in a byte.
				 */;
		} 
		if (len_bit != 0/*
				 * The compared end block number or end inode number is
				 * not the last bit in a byte.
				 */) {
			for (mark_bit = len_bit - 1; mark_bit >= 0; mark_bit--) {
				last_bit |=  1 << mark_bit/*
						 * Compare blocks or inodes in the last byte.
						 * If there is any marked bit, this function returns 0.
						 */;
			}
			if (last_bit & ADDR[start_byte + len_byte]) {
				return 0;
			}  else if (len_byte == 0) {
				return 1;
			} 
		} 
		return ModernizedCProgram.ext2fs_mem_is_zero(ADDR + start_byte, /* Check whether all bytes are 0 */len_byte);
	}
	public static Object ext2fs_find_first_zero_generic_bitmap(Object gen_bitmap, Object start, Object end, Object out) {
		ext2fs_generic_bitmap_32 bitmap = (ext2fs_generic_bitmap_32)gen_bitmap;
		 b = new ();
		if (start < bitmap.getStart() || end > bitmap.getEnd() || start > end) {
			ModernizedCProgram.ext2fs_warn_bitmap2(gen_bitmap, 2, start);
			return 22;
		} 
		while (start <= end) {
			b = ModernizedCProgram.ext2fs_test_bit(start - bitmap.getStart(), bitmap.getBitmap());
			if (!b) {
				out = start;
				return 0;
			} 
			start++;
		}
		return 2;
	}
	public static Object ext2fs_find_first_set_generic_bitmap(Object gen_bitmap, Object start, Object end, Object out) {
		ext2fs_generic_bitmap_32 bitmap = (ext2fs_generic_bitmap_32)gen_bitmap;
		 b = new ();
		if (start < bitmap.getStart() || end > bitmap.getEnd() || start > end) {
			ModernizedCProgram.ext2fs_warn_bitmap2(gen_bitmap, 2, start);
			return 22;
		} 
		while (start <= end) {
			b = ModernizedCProgram.ext2fs_test_bit(start - bitmap.getStart(), bitmap.getBitmap());
			if (b) {
				out = start;
				return 0;
			} 
			start++;
		}
		return 2;
	}
	public static int ext2fs_test_block_bitmap_range(Object gen_bitmap, Object block, int num) {
		ext2fs_generic_bitmap_32 bitmap = (ext2fs_generic_bitmap_32)gen_bitmap;
		if (!(bitmap) || (bitmap).getMagic() != (EXT2_ET_MAGIC_BLOCK_BITMAP)) {
			return (EXT2_ET_MAGIC_BLOCK_BITMAP);
		} 
		if ((block < bitmap.getStart()) || (block > bitmap.getReal_end()) || (block + num - 1 > bitmap.getReal_end())) {
			ModernizedCProgram.ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_TEST, block, bitmap.getDescription());
			return 0;
		} 
		return ModernizedCProgram.ext2fs_test_clear_generic_bitmap_range((ext2fs_generic_bitmap)bitmap, block, num);
	}
	public static int ext2fs_test_inode_bitmap_range(Object gen_bitmap, Object inode, int num) {
		ext2fs_generic_bitmap_32 bitmap = (ext2fs_generic_bitmap_32)gen_bitmap;
		if (!(bitmap) || (bitmap).getMagic() != (EXT2_ET_MAGIC_INODE_BITMAP)) {
			return (EXT2_ET_MAGIC_INODE_BITMAP);
		} 
		if ((inode < bitmap.getStart()) || (inode > bitmap.getReal_end()) || (inode + num - 1 > bitmap.getReal_end())) {
			ModernizedCProgram.ext2fs_warn_bitmap(EXT2_ET_BAD_INODE_TEST, inode, bitmap.getDescription());
			return 0;
		} 
		return ModernizedCProgram.ext2fs_test_clear_generic_bitmap_range((ext2fs_generic_bitmap)bitmap, inode, num);
	}
	public static void ext2fs_mark_block_bitmap_range(Object gen_bitmap, Object block, int num) {
		ext2fs_generic_bitmap_32 bitmap = (ext2fs_generic_bitmap_32)gen_bitmap;
		int i;
		if ((block < bitmap.getStart()) || (block > bitmap.getEnd()) || (block + num - 1 > bitmap.getEnd())) {
			ModernizedCProgram.ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_MARK, block, bitmap.getDescription());
			return /*Error: Unsupported expression*/;
		} 
		for (i = 0; i < num; i++) {
			ModernizedCProgram.ext2fs_fast_set_bit(block + i - bitmap.getStart(), bitmap.getBitmap());
		}
	}
	public static void ext2fs_unmark_block_bitmap_range(Object gen_bitmap, Object block, int num) {
		ext2fs_generic_bitmap_32 bitmap = (ext2fs_generic_bitmap_32)gen_bitmap;
		int i;
		if ((block < bitmap.getStart()) || (block > bitmap.getEnd()) || (block + num - 1 > bitmap.getEnd())) {
			ModernizedCProgram.ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_UNMARK, block, bitmap.getDescription());
			return /*Error: Unsupported expression*/;
		} 
		for (i = 0; i < num; i++) {
			ModernizedCProgram.ext2fs_fast_clear_bit(block + i - bitmap.getStart(), bitmap.getBitmap());
		}
	}
	public static Object GetLibraryHandle(Byte szLibraryName) {
		HMODULE h = ((Object)0);
		if ((h = /*Error: Function owner not recognized*/GetModuleHandleA(szLibraryName)) == ((Object)0)) {
			if (ModernizedCProgram.OpenedLibrariesHandleSize >= 32) {
				ModernizedCProgram._uprintf("Error: MAX_LIBRARY_HANDLES is too small\n");
			} else {
					h = /*Error: Function owner not recognized*/LoadLibraryA(szLibraryName);
					if (h != ((Object)0)) {
						ModernizedCProgram.OpenedLibrariesHandle[ModernizedCProgram.OpenedLibrariesHandleSize++] = h;
					} 
			} 
		} 
		return h;
	}
	/* Custom application errors */
	public static int ext2fs_validate_entry(Object fs, Byte buf, int offset, int final_offset) {
		ext2_dir_entry dirent = new ext2_dir_entry();
		int rec_len;
		while ((offset < final_offset) && (offset <= fs.getBlocksize() - 12)) {
			dirent = (ext2_dir_entry)(buf + offset);
			if (dirent.ext2fs_get_rec_len(fs, rec_len)) {
				return 0;
			} 
			offset += rec_len;
			if ((rec_len < 8) || ((rec_len % 4) != 0) || ((ModernizedCProgram.ext2fs_dirent_name_len(dirent) + 8) > (int)rec_len)) {
				return 0;
			} 
		}
		return (offset == final_offset);
	}
	public static Object ext2fs_dir_iterate2(Object fs, Object dir, int flags, Byte block_buf, Object func, Object priv_data) {
		dir_context ctx = new dir_context();
		 retval = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		retval = ModernizedCProgram.ext2fs_check_directory(fs, dir);
		if (retval) {
			return retval;
		} 
		ctx.setDir(dir);
		ctx.setFlags(flags);
		Byte generatedBuf = ctx.getBuf();
		if (block_buf) {
			ctx.setBuf(block_buf);
		} else {
				retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), generatedBuf);
				if (retval) {
					return retval;
				} 
		} 
		ctx.setFunc(func);
		ctx.setPriv_data(priv_data);
		ctx.setErrcode(0);
		retval = ModernizedCProgram.ext2fs_block_iterate3(fs, dir, 8, 0, ModernizedCProgram.ext2fs_process_dir_block, ctx);
		if (!block_buf) {
			ModernizedCProgram.ext2fs_free_mem(generatedBuf);
		} 
		if (retval == EXT2_ET_INLINE_DATA_CANT_ITERATE) {
			(Object)ModernizedCProgram.ext2fs_inline_data_dir_iterate(fs, dir, ctx);
			retval = 0;
		} 
		if (retval) {
			return retval;
		} 
		Object generatedErrcode = ctx.getErrcode();
		return generatedErrcode;
	}
	public static Object ext2fs_dir_iterate(Object fs, Object dir, int flags, Byte block_buf, Object func, Object priv_data) {
		xlate xl = new xlate();
		xl.setReal_private(priv_data);
		xl.setFunc(func);
		return ModernizedCProgram.ext2fs_dir_iterate2(fs, dir, flags, block_buf, xlate_func, xl/*
		 * Helper function which is private to this module.  Used by
		 * ext2fs_dir_iterate() and ext2fs_dblist_dir_iterate()
		 */);
	}
	public static int ext2fs_process_dir_block(Object fs, Object blocknr, Object blockcnt, Object ref_block, int ref_offset, Object priv_data) {
		dir_context ctx = (dir_context)priv_data;
		int offset = 0;
		int next_real_entry = 0;
		int ret = 0;
		int changed = 0;
		int do_abort = 0;
		int rec_len;
		int size;
		int buflen;
		int entry;
		ext2_dir_entry dirent = new ext2_dir_entry();
		int csum_size = 0;
		int inline_data;
		 retval = 0;
		if (blockcnt < 0) {
			return 0;
		} 
		entry = blockcnt ? 3 : 1;
		int generatedFlags = ctx.getFlags();
		inline_data = !!(generatedFlags & /* If a dir has inline data, we don't need to read block */8);
		Byte generatedBuf = ctx.getBuf();
		Object generatedDir = ctx.getDir();
		Object generatedErrcode = ctx.getErrcode();
		int generatedBuflen = ctx.getBuflen();
		if (!inline_data) {
			ctx.setErrcode(ModernizedCProgram.ext2fs_read_dir_block4(fs, blocknr, generatedBuf, 0, generatedDir));
			if (generatedErrcode) {
				return 2;
			} 
			buflen = fs.getBlocksize();
		} else {
				buflen = generatedBuflen;
		} 
		if (fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			csum_size = /*Error: Unsupported expression*/;
		} 
		Object generatedInode = dirent.getInode();
		Object generatedRec_len = dirent.getRec_len();
		Object generatedName_len = dirent.getName_len();
		Object generatedPriv_data = ctx.getPriv_data();
		if (changed) {
			if (!inline_data) {
				ctx.setErrcode(ModernizedCProgram.ext2fs_write_dir_block4(fs, blocknr, generatedBuf, 0, generatedDir));
				if (generatedErrcode) {
					return 2/*
								 * return BLOCK_INLINE_DATA_CHANGED to notify caller
								 * that inline data has been changed.
								 */;
				} 
			} else {
					retval = 8;
			} 
		} 
		if (do_abort) {
			return retval | 2;
		} 
		return retval;
	}
	public static Object follow_link(Object fs, Object root, Object dir, Object inode, int link_count, Byte buf, Object res_inode) {
		byte pathname;
		byte buffer = 0;
		 retval = new ();
		ext2_inode ei = new ext2_inode();
		 blk = new ();
		retval = ei.ext2fs_read_inode(fs, inode);
		if (retval) {
			return retval;
		} 
		Object generatedI_mode = ei.getI_mode();
		if (!(((generatedI_mode) & 170000) == 120000)) {
			res_inode = inode;
			return 0;
		} 
		if (link_count++ >= 8) {
			return EXT2_ET_SYMLINK_LOOP;
		} 
		Object generatedI_block = ei.getI_block();
		Object generatedI_flags = ei.getI_flags();
		Object generatedI_size = ei.getI_size();
		if (ei.ext2fs_is_fast_symlink()) {
			pathname = (byte)(generatedI_block[0]);
		}  else if (generatedI_flags & -1024) {
			retval = ModernizedCProgram.ext2fs_get_memzero(generatedI_size, buffer);
			if (retval) {
				return retval;
			} 
			retval = ei.ext2fs_inline_data_get(fs, inode, buffer, ((Object)0));
			if (retval) {
				ModernizedCProgram.ext2fs_free_mem(buffer);
				return retval;
			} 
			pathname = buffer;
		} else {
				retval = ei.ext2fs_bmap2(fs, inode, ((Object)0), 0, 0, ((Object)0), blk);
				if (retval) {
					return retval;
				} 
				retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), buffer);
				if (retval) {
					return retval;
				} 
				retval = ModernizedCProgram.io_channel_read_blk64(fs.getIo(), blk, 1, buffer);
				if (retval) {
					ModernizedCProgram.ext2fs_free_mem(buffer);
					return retval;
				} 
				pathname = buffer;
		} 
		retval = ModernizedCProgram.open_namei(fs, root, dir, pathname, generatedI_size, 1, link_count, buf, res_inode);
		if (buffer) {
			ModernizedCProgram.ext2fs_free_mem(buffer);
		} 
		return retval/*
		 * This routine interprets a pathname in the context of the current
		 * directory and the root directory, and returns the inode of the
		 * containing directory, and a pointer to the filename of the file
		 * (pointing into the pathname) and the length of the filename.
		 */;
	}
	public static Object dir_namei(Object fs, Object root, Object dir, Object pathname, int pathlen, int link_count, Byte buf, Object name, Integer namelen, Object res_inode) {
		byte c;
		byte thisname;
		int len;
		 inode = new ();
		 retval = new ();
		if ((c = pathname) == (byte)'/') {
			dir = root;
			pathname++;
			pathlen--;
		} 
		while (1) {
			thisname = pathname;
			for (len = 0; --pathlen >= 0; len++) {
				c = (pathname++);
				if (c == (byte)'/') {
					break;
				} 
			}
			if (pathlen < 0) {
				break;
			} 
			retval = ModernizedCProgram.ext2fs_lookup(fs, dir, thisname, len, buf, inode);
			if (retval) {
				return retval;
			} 
			retval = ModernizedCProgram.follow_link(fs, root, dir, inode, link_count, buf, dir);
			if (retval) {
				return retval;
			} 
		}
		name = thisname;
		namelen = len;
		res_inode = dir;
		return 0;
	}
	/*
	 * namei.c --- ext2fs directory lookup operations
	 *
	 * Copyright (C) 1993, 1994, 1994, 1995 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/* #define NAMEI_DEBUG */
	public static Object open_namei(Object fs, Object root, Object base, Object pathname, Object pathlen, int follow, int link_count, Byte buf, Object res_inode) {
		byte base_name;
		int namelen;
		 dir = new ();
		 inode = new ();
		 retval = new ();
		retval = ModernizedCProgram.dir_namei(fs, root, base, pathname, pathlen, link_count, buf, base_name, namelen, dir);
		if (retval) {
			return retval;
		} 
		if (!/* special case: '/usr/' etc */namelen) {
			res_inode = dir;
			return 0;
		} 
		retval = ModernizedCProgram.ext2fs_lookup(fs, dir, base_name, namelen, buf, inode);
		if (retval) {
			return retval;
		} 
		if (follow) {
			retval = ModernizedCProgram.follow_link(fs, root, dir, inode, link_count, buf, inode);
			if (retval) {
				return retval;
			} 
		} 
		res_inode = inode;
		return 0;
	}
	public static Object ext2fs_namei(Object fs, Object root, Object cwd, Object name, Object inode) {
		byte buf;
		 retval = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), buf);
		if (retval) {
			return retval;
		} 
		retval = ModernizedCProgram.open_namei(fs, root, cwd, name, /*Error: Function owner not recognized*/strlen(name), 0, 0, buf, inode);
		ModernizedCProgram.ext2fs_free_mem(buf);
		return retval;
	}
	public static Object ext2fs_namei_follow(Object fs, Object root, Object cwd, Object name, Object inode) {
		byte buf;
		 retval = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), buf);
		if (retval) {
			return retval;
		} 
		retval = ModernizedCProgram.open_namei(fs, root, cwd, name, /*Error: Function owner not recognized*/strlen(name), 1, 0, buf, inode);
		ModernizedCProgram.ext2fs_free_mem(buf);
		return retval;
	}
	public static Object ext2fs_follow_link(Object fs, Object root, Object cwd, Object inode, Object res_inode) {
		byte buf;
		 retval = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), buf);
		if (retval) {
			return retval;
		} 
		retval = ModernizedCProgram.follow_link(fs, root, cwd, inode, 0, buf, res_inode);
		ModernizedCProgram.ext2fs_free_mem(buf);
		return retval;
	}
	/******************************************************************
	    Copyright (C) 2012  Pete Batard <pete@akeo.ie>
	    Based on fat16.c Copyright (C) 2009  Henrik Carlqvist
	
	    This program is free software; you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation; either version 2 of the License, or
	    (at your option) any later version.
	
	    This program is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with this program; if not, write to the Free Software
	    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
	******************************************************************/
	public static int is_ntfs_fs() {
		byte[] aucMagic = new byte[]{(byte)'N', (byte)'T', (byte)'F', (byte)'S', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		return fp.contains_data(-1024, aucMagic, /*Error: sizeof expression not supported yet*/);
	}
	public static int is_ntfs_br() {
		byte[] aucRef = new byte[]{-1024, /* A "file" is probably some kind of NTFS boot record if it contains the
		      magic chars 0x55, 0xAA at positions 0x1FE */-1024};
		byte[] aucMagic = new byte[]{(byte)'N', (byte)'T', (byte)'F', (byte)'S', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		if (!fp.contains_data(-1024, aucRef, /*Error: sizeof expression not supported yet*/)) {
			return 0;
		} 
		if (!fp.contains_data(-1024, aucMagic, /*Error: sizeof expression not supported yet*/)) {
			return 0;
		} 
		return 1/* is_ntfs_br */;
	}
	public static int entire_ntfs_br_matches() {
		byte[] br_ntfs_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_ntfs_0x54 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.contains_data(-1024, br_ntfs_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_ntfs_0x54, /*Error: sizeof expression not supported yet*/));
	}
	public static int write_ntfs_br() {
		byte[] br_ntfs_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_ntfs_0x54 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.write_data(-1024, br_ntfs_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_ntfs_0x54, /*Error: sizeof expression not supported yet*/));
	}
	/* !INCLUDE_INLINE FUNCS */
	/* not C99 */
	/* For Watcom C */
	/* __GNUC__ */
	/* __STDC_VERSION__ >= 199901L */
	/* INCLUDE_INLINE_FUNCS */
	/*
	 * Fast bit set/clear functions that doesn't need to return the
	 * previous bit value.
	 */
	public static void ext2fs_fast_set_bit(int nr, Object addr) {
		byte ADDR = (byte)addr;
		ADDR += nr >> 3;
		ADDR |=  (byte)(1 << (nr & -1024));
	}
	public static void ext2fs_fast_clear_bit(int nr, Object addr) {
		byte ADDR = (byte)addr;
		ADDR += nr >> 3;
		ADDR &=  (byte)~(1 << (nr & -1024));
	}
	public static void ext2fs_fast_set_bit64(Object nr, Object addr) {
		byte ADDR = (byte)addr;
		ADDR += nr >> 3;
		ADDR |=  (byte)(1 << (nr & -1024));
	}
	public static void ext2fs_fast_clear_bit64(Object nr, Object addr) {
		byte ADDR = (byte)addr;
		ADDR += nr >> 3;
		ADDR &=  (byte)~(1 << (nr & -1024));
	}
	public static int ext2fs_set_bit(int nr, Object addr) {
		int oldbit;
		addr = (Object)(((byte)addr) + (nr >> 3));
		;
		return oldbit;
		int mask;
		int retval;
		byte ADDR = (byte)addr;
		ADDR += nr >> 3;
		mask = 1 << (nr & -1024);
		retval = mask & ADDR;
		ADDR |=  mask;
		return retval;
	}
	public static int ext2fs_clear_bit(int nr, Object addr) {
		int oldbit;
		addr = (Object)(((byte)addr) + (nr >> 3));
		;
		return oldbit;
		int mask;
		int retval;
		byte ADDR = (byte)addr;
		ADDR += nr >> 3;
		mask = 1 << (nr & -1024);
		retval = mask & ADDR;
		ADDR &=  ~mask;
		return retval;
	}
	public static int ext2fs_test_bit(int nr, Object addr) {
		int oldbit;
		addr = (Object)(((byte)addr) + (nr >> 3));
		;
		return oldbit;
		int mask;
		byte ADDR = (byte)addr;
		ADDR += nr >> 3;
		mask = 1 << (nr & -1024);
		return (mask & ADDR);
	}
	public static Object ext2fs_swab32(Object val) {
		/* swap lower bytes	*//* swap lower bytes	*//* swap words		*//* swap higher bytes	*/;/* swap words		*//* swap higher bytes	*/
		return val;
	}
	public static Object ext2fs_swab16(Object val) {
		/* swap bytes		*//* swap bytes		*/;
		return val/* i386 */;
	}
	/* !_EXT2_HAVE_ASM_SWAB */
	public static Object ext2fs_swab64(Object val) {
		return (ModernizedCProgram.ext2fs_swab32(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(val >> 32)) | ((()ModernizedCProgram.ext2fs_swab32(val & -1024)) << 32));
	}
	public static int ext2fs_mark_block_bitmap(Object bitmap, Object block) {
		return ModernizedCProgram.ext2fs_mark_generic_bitmap(()bitmap, block);
	}
	public static int ext2fs_unmark_block_bitmap(Object bitmap, Object block) {
		return ModernizedCProgram.ext2fs_unmark_generic_bitmap(()bitmap, block);
	}
	public static int ext2fs_test_block_bitmap(Object bitmap, Object block) {
		return ModernizedCProgram.ext2fs_test_generic_bitmap(()bitmap, block);
	}
	public static int ext2fs_mark_inode_bitmap(Object bitmap, Object inode) {
		return ModernizedCProgram.ext2fs_mark_generic_bitmap(()bitmap, inode);
	}
	public static int ext2fs_unmark_inode_bitmap(Object bitmap, Object inode) {
		return ModernizedCProgram.ext2fs_unmark_generic_bitmap(()bitmap, inode);
	}
	public static int ext2fs_test_inode_bitmap(Object bitmap, Object inode) {
		return ModernizedCProgram.ext2fs_test_generic_bitmap(()bitmap, inode);
	}
	public static void ext2fs_fast_mark_block_bitmap(Object bitmap, Object block) {
		ModernizedCProgram.ext2fs_mark_generic_bitmap(()bitmap, block);
	}
	public static void ext2fs_fast_unmark_block_bitmap(Object bitmap, Object block) {
		ModernizedCProgram.ext2fs_unmark_generic_bitmap(()bitmap, block);
	}
	public static int ext2fs_fast_test_block_bitmap(Object bitmap, Object block) {
		return ModernizedCProgram.ext2fs_test_generic_bitmap(()bitmap, block);
	}
	public static void ext2fs_fast_mark_inode_bitmap(Object bitmap, Object inode) {
		ModernizedCProgram.ext2fs_mark_generic_bitmap(()bitmap, inode);
	}
	public static void ext2fs_fast_unmark_inode_bitmap(Object bitmap, Object inode) {
		ModernizedCProgram.ext2fs_unmark_generic_bitmap(()bitmap, inode);
	}
	public static int ext2fs_fast_test_inode_bitmap(Object bitmap, Object inode) {
		return ModernizedCProgram.ext2fs_test_generic_bitmap(()bitmap, inode);
	}
	public static Object ext2fs_get_block_bitmap_start(Object bitmap) {
		return ModernizedCProgram.ext2fs_get_generic_bitmap_start(()bitmap);
	}
	public static Object ext2fs_get_inode_bitmap_start(Object bitmap) {
		return ModernizedCProgram.ext2fs_get_generic_bitmap_start(()bitmap);
	}
	public static Object ext2fs_get_block_bitmap_end(Object bitmap) {
		return ModernizedCProgram.ext2fs_get_generic_bitmap_end(()bitmap);
	}
	public static Object ext2fs_get_inode_bitmap_end(Object bitmap) {
		return ModernizedCProgram.ext2fs_get_generic_bitmap_end(()bitmap);
	}
	public static int ext2fs_fast_test_block_bitmap_range(Object bitmap, Object block, int num) {
		return ModernizedCProgram.ext2fs_test_block_bitmap_range(bitmap, block, num);
	}
	public static void ext2fs_fast_mark_block_bitmap_range(Object bitmap, Object block, int num) {
		ModernizedCProgram.ext2fs_mark_block_bitmap_range(bitmap, block, num);
	}
	public static void ext2fs_fast_unmark_block_bitmap_range(Object bitmap, Object block, int num) {
		ModernizedCProgram.ext2fs_unmark_block_bitmap_range(bitmap, block, num);
	}
	/* 64-bit versions */
	public static int ext2fs_mark_block_bitmap2(Object bitmap, Object block) {
		return ModernizedCProgram.ext2fs_mark_generic_bmap(()bitmap, block);
	}
	public static int ext2fs_unmark_block_bitmap2(Object bitmap, Object block) {
		return ModernizedCProgram.ext2fs_unmark_generic_bmap(()bitmap, block);
	}
	public static int ext2fs_test_block_bitmap2(Object bitmap, Object block) {
		return ModernizedCProgram.ext2fs_test_generic_bmap(()bitmap, block);
	}
	public static int ext2fs_mark_inode_bitmap2(Object bitmap, Object inode) {
		return ModernizedCProgram.ext2fs_mark_generic_bmap(()bitmap, inode);
	}
	public static int ext2fs_unmark_inode_bitmap2(Object bitmap, Object inode) {
		return ModernizedCProgram.ext2fs_unmark_generic_bmap(()bitmap, inode);
	}
	public static int ext2fs_test_inode_bitmap2(Object bitmap, Object inode) {
		return ModernizedCProgram.ext2fs_test_generic_bmap(()bitmap, inode);
	}
	public static void ext2fs_fast_mark_block_bitmap2(Object bitmap, Object block) {
		ModernizedCProgram.ext2fs_mark_generic_bmap(()bitmap, block);
	}
	public static void ext2fs_fast_unmark_block_bitmap2(Object bitmap, Object block) {
		ModernizedCProgram.ext2fs_unmark_generic_bmap(()bitmap, block);
	}
	public static int ext2fs_fast_test_block_bitmap2(Object bitmap, Object block) {
		return ModernizedCProgram.ext2fs_test_generic_bmap(()bitmap, block);
	}
	public static void ext2fs_fast_mark_inode_bitmap2(Object bitmap, Object inode) {
		ModernizedCProgram.ext2fs_mark_generic_bmap(()bitmap, inode);
	}
	public static void ext2fs_fast_unmark_inode_bitmap2(Object bitmap, Object inode) {
		ModernizedCProgram.ext2fs_unmark_generic_bmap(()bitmap, inode);
	}
	public static int ext2fs_fast_test_inode_bitmap2(Object bitmap, Object inode) {
		return ModernizedCProgram.ext2fs_test_generic_bmap(()bitmap, inode);
	}
	public static Object ext2fs_find_first_zero_block_bitmap2(Object bitmap, Object start, Object end, Object out) {
		 o = new ();
		 rv = new ();
		rv = ModernizedCProgram.ext2fs_find_first_zero_generic_bmap(()bitmap, start, end, o);
		if (!rv) {
			out = o;
		} 
		return rv;
	}
	public static Object ext2fs_find_first_zero_inode_bitmap2(Object bitmap, Object start, Object end, Object out) {
		 o = new ();
		 rv = new ();
		rv = ModernizedCProgram.ext2fs_find_first_zero_generic_bmap(()bitmap, start, end, o);
		if (!rv) {
			out = ()o;
		} 
		return rv;
	}
	public static Object ext2fs_find_first_set_block_bitmap2(Object bitmap, Object start, Object end, Object out) {
		 o = new ();
		 rv = new ();
		rv = ModernizedCProgram.ext2fs_find_first_set_generic_bmap(()bitmap, start, end, o);
		if (!rv) {
			out = o;
		} 
		return rv;
	}
	public static Object ext2fs_find_first_set_inode_bitmap2(Object bitmap, Object start, Object end, Object out) {
		 o = new ();
		 rv = new ();
		rv = ModernizedCProgram.ext2fs_find_first_set_generic_bmap(()bitmap, start, end, o);
		if (!rv) {
			out = ()o;
		} 
		return rv;
	}
	public static Object ext2fs_get_block_bitmap_start2(Object bitmap) {
		return ModernizedCProgram.ext2fs_get_generic_bmap_start(()bitmap);
	}
	public static Object ext2fs_get_inode_bitmap_start2(Object bitmap) {
		return ()ModernizedCProgram.ext2fs_get_generic_bmap_start(()bitmap);
	}
	public static Object ext2fs_get_block_bitmap_end2(Object bitmap) {
		return ModernizedCProgram.ext2fs_get_generic_bmap_end(()bitmap);
	}
	public static Object ext2fs_get_inode_bitmap_end2(Object bitmap) {
		return ()ModernizedCProgram.ext2fs_get_generic_bmap_end(()bitmap);
	}
	public static int ext2fs_fast_test_block_bitmap_range2(Object bitmap, Object block, int num) {
		return ModernizedCProgram.ext2fs_test_block_bitmap_range2(bitmap, block, num);
	}
	public static void ext2fs_fast_mark_block_bitmap_range2(Object bitmap, Object block, int num) {
		ModernizedCProgram.ext2fs_mark_block_bitmap_range2(bitmap, block, num);
	}
	public static void ext2fs_fast_unmark_block_bitmap_range2(Object bitmap, Object block, int num) {
		ModernizedCProgram.ext2fs_unmark_block_bitmap_range2(bitmap, block, num);
	}
	/*
	 * csum.c --- checksumming of ext3 structures
	 *
	 * Copyright (C) 2006 Cluster File Systems, Inc.
	 * Copyright (C) 2006, 2007 by Andreas Dilger <adilger@clusterfs.com>
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static void ext2fs_init_csum_seed(Object fs) {
		if (fs.getSuper().ext2fs_has_feature_csum_seed()) {
			fs.setCsum_seed(fs.getSuper().getS_checksum_seed());
		}  else if (fs.getSuper().ext2fs_has_feature_metadata_csum() || fs.getSuper().ext2fs_has_feature_ea_inode()) {
			fs.setCsum_seed(ModernizedCProgram.ext2fs_crc32c_le(~0, fs.getSuper().getS_uuid(), /*Error: sizeof expression not supported yet*/));
		} 
	}
	public static Object ext2fs_ext_attr_block_csum(Object fs, Object inum, Object block, Object hdr, Object crc) {
		byte buf = (byte)hdr;
		 old_crc = hdr.getH_checksum();
		hdr.setH_checksum(0);
		block = /*Error: Function owner not recognized*/ext2fs_cpu_to_le64(block);
		crc = ModernizedCProgram.ext2fs_crc32c_le(fs.getCsum_seed(), (byte)block, /*Error: sizeof expression not supported yet*/);
		crc = ModernizedCProgram.ext2fs_crc32c_le(crc, (byte)buf, fs.getBlocksize());
		hdr.setH_checksum(old_crc);
		return 0;
	}
	public static int ext2fs_ext_attr_block_csum_verify(Object fs, Object inum, Object block, Object hdr) {
		 calculated = new ();
		 retval = new ();
		if (!fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			return 1;
		} 
		retval = ModernizedCProgram.ext2fs_ext_attr_block_csum(fs, inum, block, hdr, calculated);
		if (retval) {
			return 0;
		} 
		return /*Error: Function owner not recognized*/ext2fs_le32_to_cpu(hdr.getH_checksum()) == calculated;
	}
	public static Object ext2fs_ext_attr_block_csum_set(Object fs, Object inum, Object block, Object hdr) {
		 retval = new ();
		 crc = new ();
		if (!fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			return 0;
		} 
		retval = ModernizedCProgram.ext2fs_ext_attr_block_csum(fs, inum, block, hdr, crc);
		if (retval) {
			return retval;
		} 
		hdr.setH_checksum(/*Error: Function owner not recognized*/ext2fs_cpu_to_le32(crc));
		return 0;
	}
	public static Object do_nothing16(Object x) {
		return x;
	}
	public static Object disk_to_host16(Object x) {
		return /*Error: Function owner not recognized*/ext2fs_le16_to_cpu(x);
	}
	public static Object __get_dx_countlimit(Object fs, ext2_dir_entry dirent, ext2_dx_countlimit cc, Integer offset, int need_swab) {
		ext2_dir_entry dp = new ext2_dir_entry();
		ext2_dx_root_info root = new ext2_dx_root_info();
		ext2_dx_countlimit c = new ext2_dx_countlimit();
		int count_offset;
		int max_sane_entries;
		int rec_len;
		 translate = (need_swab ? disk_to_host16 : do_nothing16);
		Object generatedRec_len = dirent.getRec_len();
		rec_len = /*Error: Function owner not recognized*/translate(generatedRec_len);
		Object generatedName_len = dirent.getName_len();
		Object generatedReserved_zero = root.getReserved_zero();
		Object generatedInfo_length = root.getInfo_length();
		if (rec_len == fs.getBlocksize() && /*Error: Function owner not recognized*/translate(generatedName_len) == 0) {
			count_offset = 8;
		}  else if (rec_len == 12) {
			dp = (ext2_dir_entry)(((byte)dirent) + rec_len);
			rec_len = /*Error: Function owner not recognized*/translate(generatedRec_len);
			if (rec_len != fs.getBlocksize() - 12) {
				return EXT2_ET_DB_NOT_FOUND;
			} 
			root = (ext2_dx_root_info)(((byte)dp + 12));
			if (generatedReserved_zero || generatedInfo_length != /*Error: Unsupported expression*/) {
				return EXT2_ET_DB_NOT_FOUND;
			} 
			count_offset = 32;
		} else {
				return EXT2_ET_DB_NOT_FOUND;
		} 
		c = (ext2_dx_countlimit)(((byte)dirent) + count_offset);
		max_sane_entries = (fs.getBlocksize() - count_offset) / /*Error: Unsupported expression*/;
		Object generatedLimit = c.getLimit();
		Object generatedCount = c.getCount();
		if (/*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedLimit) > max_sane_entries || /*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedCount) > max_sane_entries) {
			return EXT2_ET_DIR_NO_SPACE_FOR_CSUM;
		} 
		if (offset) {
			offset = count_offset;
		} 
		if (cc) {
			cc = c;
		} 
		return 0;
	}
	public static Object ext2fs_get_dx_countlimit(Object fs, ext2_dir_entry dirent, ext2_dx_countlimit cc, Integer offset) {
		return ModernizedCProgram.__get_dx_countlimit(fs, dirent, cc, offset, 0);
	}
	public static Object __get_dirent_tail(Object fs, ext2_dir_entry dirent, ext2_dir_entry_tail tt, int need_swab) {
		ext2_dir_entry d = new ext2_dir_entry();
		Object top;
		ext2_dir_entry_tail t = new ext2_dir_entry_tail();
		int rec_len;
		 retval = 0;
		 translate = (need_swab ? disk_to_host16 : do_nothing16);
		d = dirent;
		top = ((ext2_dir_entry_tail)(((byte)(dirent)) + (fs.getBlocksize()) - /*Error: Unsupported expression*/));
		Object generatedRec_len = d.getRec_len();
		rec_len = /*Error: Function owner not recognized*/translate(generatedRec_len);
		while (rec_len && !(rec_len & -1024)) {
			d = (ext2_dir_entry)(((byte)d) + rec_len);
			if ((Object)d >= top) {
				break;
			} 
			rec_len = /*Error: Function owner not recognized*/translate(generatedRec_len);
		}
		if (d != top) {
			return EXT2_ET_DIR_NO_SPACE_FOR_CSUM;
		} 
		t = (ext2_dir_entry_tail)d;
		Object generatedDet_reserved_zero1 = t.getDet_reserved_zero1();
		Object generatedDet_rec_len = t.getDet_rec_len();
		Object generatedDet_reserved_name_len = t.getDet_reserved_name_len();
		if (generatedDet_reserved_zero1 || /*Error: Function owner not recognized*/translate(generatedDet_rec_len) != /*Error: Unsupported expression*/ || /*Error: Function owner not recognized*/translate(generatedDet_reserved_name_len) != -1024) {
			return EXT2_ET_DIR_NO_SPACE_FOR_CSUM;
		} 
		if (tt) {
			tt = t;
		} 
		return retval;
	}
	public static Object ext2fs_dx_csum(Object fs, Object inum, ext2_dir_entry dirent, Object crc, int count_offset, int count, ext2_dx_tail t) {
		 retval = new ();
		byte buf = (byte)dirent;
		int size;
		 old_csum = new ();
		 gen = new ();
		ext2_inode inode = new ext2_inode();
		size = count_offset + (count * /*Error: Unsupported expression*/);
		Object generatedDt_checksum = t.getDt_checksum();
		old_csum = generatedDt_checksum;
		t.setDt_checksum(0);
		retval = inode.ext2fs_read_inode(fs, inum);
		if (retval) {
			return retval;
		} 
		inum = /*Error: Function owner not recognized*/ext2fs_cpu_to_le32(inum);
		Object generatedI_generation = inode.getI_generation();
		gen = /*Error: Function owner not recognized*/ext2fs_cpu_to_le32(generatedI_generation);
		crc = ModernizedCProgram.ext2fs_crc32c_le(fs.getCsum_seed(), (byte)inum, /*Error: sizeof expression not supported yet*/);
		crc = ModernizedCProgram.ext2fs_crc32c_le(crc, (byte)gen, /*Error: sizeof expression not supported yet*/);
		crc = ModernizedCProgram.ext2fs_crc32c_le(crc, (byte)buf, size);
		crc = ModernizedCProgram.ext2fs_crc32c_le(crc, (byte)t, /*Error: Unsupported expression*/);
		t.setDt_checksum(old_csum);
		return 0;
	}
	public static Object ext2fs_extent_block_csum(Object fs, Object inum, Object eh, Object crc) {
		int size;
		 gen = new ();
		 retval = new ();
		ext2_inode inode = new ext2_inode();
		size = (/*Error: Unsupported expression*/ + (/*Error: Unsupported expression*/ * /*Error: Function owner not recognized*/ext2fs_le16_to_cpu((eh).getEh_max()))) + ((size_t)((ext3_extent_tail)0).getExt3_extent_tail());
		retval = inode.ext2fs_read_inode(fs, inum);
		if (retval) {
			return retval;
		} 
		inum = /*Error: Function owner not recognized*/ext2fs_cpu_to_le32(inum);
		Object generatedI_generation = inode.getI_generation();
		gen = /*Error: Function owner not recognized*/ext2fs_cpu_to_le32(generatedI_generation);
		crc = ModernizedCProgram.ext2fs_crc32c_le(fs.getCsum_seed(), (byte)inum, /*Error: sizeof expression not supported yet*/);
		crc = ModernizedCProgram.ext2fs_crc32c_le(crc, (byte)gen, /*Error: sizeof expression not supported yet*/);
		crc = ModernizedCProgram.ext2fs_crc32c_le(crc, (byte)eh, size);
		return 0;
	}
	public static int ext2fs_extent_block_csum_verify(Object fs, Object inum, Object eh) {
		 retval = new ();
		 provided = new ();
		 calculated = new ();
		ext3_extent_tail ext3_extent_tail = new ext3_extent_tail();
		ext3_extent_tail t = ext3_extent_tail.get_extent_tail(eh/*
			 * The extent tree structures are accessed in LE order, so we must
			 * swap the checksum bytes here.
			 */);
		if (!fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			return 1;
		} 
		Object generatedExt3_extent_tail = t.getExt3_extent_tail();
		provided = /*Error: Function owner not recognized*/ext2fs_le32_to_cpu(generatedExt3_extent_tail);
		retval = ModernizedCProgram.ext2fs_extent_block_csum(fs, inum, eh, calculated);
		if (retval) {
			return 0;
		} 
		return provided == calculated;
	}
	public static Object ext2fs_extent_block_csum_set(Object fs, Object inum, Object eh) {
		 retval = new ();
		 crc = new ();
		ext3_extent_tail ext3_extent_tail = new ext3_extent_tail();
		ext3_extent_tail t = ext3_extent_tail.get_extent_tail(eh);
		if (!fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			return 0/*
				 * The extent tree structures are accessed in LE order, so we must
				 * swap the checksum bytes here.
				 */;
		} 
		retval = ModernizedCProgram.ext2fs_extent_block_csum(fs, inum, eh, crc);
		if (retval) {
			return retval;
		} 
		t.setExt3_extent_tail(/*Error: Function owner not recognized*/ext2fs_cpu_to_le32(crc));
		return retval;
	}
	public static int ext2fs_inode_bitmap_csum_verify(Object fs, Object group, Byte bitmap, int size) {
		ext2_group_desc ext2_group_desc = new ext2_group_desc();
		ext4_group_desc gdp = (ext4_group_desc)ext2_group_desc.ext2fs_group_desc(fs, fs.getGroup_desc(), group);
		 provided = new ();
		 calculated = new ();
		if (!fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			return 1;
		} 
		Object generatedBg_inode_bitmap_csum_lo = gdp.getBg_inode_bitmap_csum_lo();
		provided = generatedBg_inode_bitmap_csum_lo;
		calculated = ModernizedCProgram.ext2fs_crc32c_le(fs.getCsum_seed(), (byte)bitmap, size);
		Object generatedBg_inode_bitmap_csum_hi = gdp.getBg_inode_bitmap_csum_hi();
		if ((((fs.getSuper()).getS_feature_incompat() & -1024) ? (fs.getSuper()).getS_desc_size() : 32) >= (((size_t)((ext4_group_desc)0).getBg_inode_bitmap_csum_hi()) + /*Error: Unsupported expression*/)) {
			provided |=  ()generatedBg_inode_bitmap_csum_hi << 16;
		} else {
				calculated &=  -1024;
		} 
		return provided == calculated;
	}
	public static Object ext2fs_inode_bitmap_csum_set(Object fs, Object group, Byte bitmap, int size) {
		 crc = new ();
		ext2_group_desc ext2_group_desc = new ext2_group_desc();
		ext4_group_desc gdp = (ext4_group_desc)ext2_group_desc.ext2fs_group_desc(fs, fs.getGroup_desc(), group);
		if (!fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			return 0;
		} 
		crc = ModernizedCProgram.ext2fs_crc32c_le(fs.getCsum_seed(), (byte)bitmap, size);
		gdp.setBg_inode_bitmap_csum_lo(crc & -1024);
		if ((((fs.getSuper()).getS_feature_incompat() & -1024) ? (fs.getSuper()).getS_desc_size() : 32) >= (((size_t)((ext4_group_desc)0).getBg_inode_bitmap_csum_hi()) + /*Error: Unsupported expression*/)) {
			gdp.setBg_inode_bitmap_csum_hi(crc >> 16);
		} 
		return 0;
	}
	public static int ext2fs_block_bitmap_csum_verify(Object fs, Object group, Byte bitmap, int size) {
		ext2_group_desc ext2_group_desc = new ext2_group_desc();
		ext4_group_desc gdp = (ext4_group_desc)ext2_group_desc.ext2fs_group_desc(fs, fs.getGroup_desc(), group);
		 provided = new ();
		 calculated = new ();
		if (!fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			return 1;
		} 
		Object generatedBg_block_bitmap_csum_lo = gdp.getBg_block_bitmap_csum_lo();
		provided = generatedBg_block_bitmap_csum_lo;
		calculated = ModernizedCProgram.ext2fs_crc32c_le(fs.getCsum_seed(), (byte)bitmap, size);
		Object generatedBg_block_bitmap_csum_hi = gdp.getBg_block_bitmap_csum_hi();
		if ((((fs.getSuper()).getS_feature_incompat() & -1024) ? (fs.getSuper()).getS_desc_size() : 32) >= (((size_t)((ext4_group_desc)0).getBg_block_bitmap_csum_hi()) + /*Error: Unsupported expression*/)) {
			provided |=  ()generatedBg_block_bitmap_csum_hi << 16;
		} else {
				calculated &=  -1024;
		} 
		return provided == calculated;
	}
	public static Object ext2fs_block_bitmap_csum_set(Object fs, Object group, Byte bitmap, int size) {
		 crc = new ();
		ext2_group_desc ext2_group_desc = new ext2_group_desc();
		ext4_group_desc gdp = (ext4_group_desc)ext2_group_desc.ext2fs_group_desc(fs, fs.getGroup_desc(), group);
		if (!fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			return 0;
		} 
		crc = ModernizedCProgram.ext2fs_crc32c_le(fs.getCsum_seed(), (byte)bitmap, size);
		gdp.setBg_block_bitmap_csum_lo(crc & -1024);
		if ((((fs.getSuper()).getS_feature_incompat() & -1024) ? (fs.getSuper()).getS_desc_size() : 32) >= (((size_t)((ext4_group_desc)0).getBg_block_bitmap_csum_hi()) + /*Error: Unsupported expression*/)) {
			gdp.setBg_block_bitmap_csum_hi(crc >> 16);
		} 
		return 0;
	}
	public static Object ext2fs_group_desc_csum(Object fs, Object group) {
		ext2_group_desc ext2_group_desc = new ext2_group_desc();
		ext2_group_desc desc = ext2_group_desc.ext2fs_group_desc(fs, fs.getGroup_desc(), group);
		size_t offset = new size_t();
		size_t size = (((fs.getSuper()).getS_feature_incompat() & -1024) ? (fs.getSuper()).getS_desc_size() : 32);
		 crc = 0;
		/* Have to swab back to little-endian to do the checksum */
		Object generatedBg_checksum = desc.getBg_checksum();
		if (fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			 old_crc = new ();
			 crc32 = new ();
			old_crc = generatedBg_checksum;
			desc.setBg_checksum(0);
			crc32 = ModernizedCProgram.ext2fs_crc32c_le(fs.getCsum_seed(), (byte)group, /*Error: sizeof expression not supported yet*/);
			crc32 = ModernizedCProgram.ext2fs_crc32c_le(crc32, (byte)desc, size);
			desc.setBg_checksum(old_crc);
			crc = crc32 & -1024;
			;
		} 
		offset = ((size_t)generatedBg_checksum);
		crc = ModernizedCProgram.ext2fs_crc16(~0, fs.getSuper().getS_uuid(), /*Error: sizeof expression not supported yet*/);
		crc = ModernizedCProgram.ext2fs_crc16(crc, group, /*Error: sizeof expression not supported yet*/);
		crc = ModernizedCProgram.ext2fs_crc16(crc, desc, offset);
		offset += /*Error: sizeof expression not supported yet*/;
		if (offset < /* for checksum of struct ext4_group_desc do the rest...*/size) {
			crc = ModernizedCProgram.ext2fs_crc16(crc, (byte)desc + offset, size - offset/*
				 * If the size of the bg descriptor is greater than 64
				 * bytes, which is the size of the traditional ext4 bg
				 * descriptor, checksum the rest of the descriptor here
				 */);
		} 
	}
	public static int ext2fs_group_desc_csum_verify(Object fs, Object group) {
		if (ModernizedCProgram.ext2fs_has_group_desc_csum(fs) && (ModernizedCProgram.ext2fs_bg_checksum(fs, group) != ModernizedCProgram.ext2fs_group_desc_csum(fs, group))) {
			return 0;
		} 
		return 1;
	}
	public static void ext2fs_group_desc_csum_set(Object fs, Object group) {
		if (!ModernizedCProgram.ext2fs_has_group_desc_csum(fs)) {
			return /*Error: Unsupported expression*/;
		} 
		ModernizedCProgram.ext2fs_bg_checksum_set(fs, group, ModernizedCProgram.ext2fs_group_desc_csum(fs, /* ext2fs_bg_checksum_set() sets the actual checksum field but
			 * does not calculate the checksum itself. */group));
	}
	public static Object find_last_inode_ingrp(Object bitmap, Object inodes_per_grp, Object grp_no) {
		 i = new ();
		 start_ino = new ();
		 end_ino = new ();
		start_ino = grp_no * inodes_per_grp + 1;
		end_ino = start_ino + inodes_per_grp - 1;
		for (i = end_ino; i >= start_ino; i--) {
			if (ModernizedCProgram.ext2fs_fast_test_inode_bitmap2(bitmap, i)) {
				return i - start_ino + 1;
			} 
		}
		return inodes_per_grp;
	}
	/* update the bitmap flags, set the itable high watermark, and calculate
	 * checksums for the group descriptors */
	public static Object ext2fs_set_gdt_csum(Object fs) {
		ext2_super_block sb = fs.getSuper();
		int dirty = 0;
		 i = new ();
		if (!fs.getInode_map()) {
			return EXT2_ET_NO_INODE_BITMAP;
		} 
		if (!ModernizedCProgram.ext2fs_has_group_desc_csum(fs)) {
			return 0;
		} 
		Object generatedS_blocks_per_group = sb.getS_blocks_per_group();
		Object generatedS_inodes_per_group = sb.getS_inodes_per_group();
		for (i = 0; i < fs.getGroup_desc_count(); i++) {
			 old_csum = ModernizedCProgram.ext2fs_bg_checksum(fs, i);
			 old_unused = ModernizedCProgram.ext2fs_bg_itable_unused(fs, i);
			 old_flags = ModernizedCProgram.ext2fs_bg_flags(fs, i);
			 old_free_inodes_count = ModernizedCProgram.ext2fs_bg_free_inodes_count(fs, i);
			 old_free_blocks_count = ModernizedCProgram.ext2fs_bg_free_blocks_count(fs, i);
			if (old_free_blocks_count == generatedS_blocks_per_group && i != fs.getGroup_desc_count() - 1) {
				ModernizedCProgram.ext2fs_bg_flags_set(fs, i, -1024);
			} 
			if (old_free_inodes_count == generatedS_inodes_per_group) {
				ModernizedCProgram.ext2fs_bg_flags_set(fs, i, -1024);
				ModernizedCProgram.ext2fs_bg_itable_unused_set(fs, i, generatedS_inodes_per_group);
			} else {
					int unused = generatedS_inodes_per_group - ModernizedCProgram.find_last_inode_ingrp(fs.getInode_map(), generatedS_inodes_per_group, i);
					ModernizedCProgram.ext2fs_bg_flags_clear(fs, i, -1024);
					ModernizedCProgram.ext2fs_bg_itable_unused_set(fs, i, unused);
			} 
			ModernizedCProgram.ext2fs_group_desc_csum_set(fs, i);
			if (old_flags != ModernizedCProgram.ext2fs_bg_flags(fs, i)) {
				dirty = 1;
			} 
			if (old_unused != ModernizedCProgram.ext2fs_bg_itable_unused(fs, i)) {
				dirty = 1;
			} 
			if (old_csum != ModernizedCProgram.ext2fs_bg_checksum(fs, i)) {
				dirty = 1;
			} 
		}
		if (dirty) {
			ModernizedCProgram.ext2fs_mark_super_dirty(fs);
		} 
		return 0;
	}
	/* Have to swab back to little-endian to do the checksum */
	/* skip checksum */
	/* for checksum of struct ext4_group_desc do the rest...*/
	public static Object make_u64_list(int size, int num, Object list, Object ret) {
		bb_u64_list bb = new bb_u64_list();
		bb = /*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/);
		if (bb == ((Object)0)) {
			return (-1024 | (3 << 16) | -1024);
		} 
		bb.setMagic((-1024 | (3 << 16) | -1024));
		bb.setSize(size ? size : 10);
		bb.setNum(num);
		bb.setList(/*Error: Function owner not recognized*/malloc(/*Error: Unsupported expression*/ * bb.getSize()));
		if (bb.getList() == ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(bb);
			bb = ((Object)0);
			return (-1024 | (3 << 16) | -1024);
		} 
		if (list) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(bb.getList(), list, bb.getSize() * /*Error: Unsupported expression*/);
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(bb.getList(), 0, bb.getSize() * /*Error: Unsupported expression*/);
		} 
		ret = bb;
		return 0/*
		 * This procedure creates an empty badblocks list.
		 */;
	}
	public static Object bb_badblocks_list_create(Object ret, int size) {
		return ModernizedCProgram.make_u64_list(size, 0, 0, (bb_badblocks_list)ret/*
		 * This procedure adds a block to a badblocks list.
		 */);
	}
	public static Object bb_u64_list_add(Object bb, Object blk) {
		int i;
		int j;
		uint64_t old_bb_list = bb.getList();
		if ((bb).getMagic() != ((-1024 | (3 << 16) | -1024))) {
			return ((-1024 | (3 << 16) | -1024));
		} 
		if (bb.getNum() >= bb.getSize()) {
			bb.getSize() += 100;
			bb.setList(/*Error: Function owner not recognized*/realloc(bb.getList(), bb.getSize() * /*Error: Unsupported expression*/));
			if (bb.getList() == ((Object)0)) {
				bb.setList(old_bb_list);
				bb.getSize() -= 100;
				return (-1024 | (3 << 16) | -1024);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(bb.getList()[bb.getSize() - 100], 0, 100 * /*Error: Unsupported expression*/);
		} 
		i = bb.getNum() - /*
			 * Add special case code for appending to the end of the list
			 */1;
		if ((bb.getNum() != 0) && (bb.getList()[i] == blk)) {
			return 0;
		} 
		if ((bb.getNum() == 0) || (bb.getList()[i] < blk)) {
			bb.getList()[bb.getNum()++] = blk;
			return 0;
		} 
		j = bb.getNum();
		for (i = 0; i < bb.getNum(); i++) {
			if (bb.getList()[i] == blk) {
				return 0;
			} 
			if (bb.getList()[i] > blk) {
				j = i;
				break;
			} 
		}
		for (i = bb.getNum(); i > j; i--) {
			bb.getList()[i] = bb.getList()[i - 1];
		}
		bb.getList()[j] = blk;
		bb.getNum()++;
		return 0;
	}
	public static Object bb_badblocks_list_add(Object bb, Object blk) {
		return ModernizedCProgram.bb_u64_list_add((bb_u64_list)bb, blk/*
		 * This procedure finds a particular block is on a badblocks
		 * list.
		 */);
	}
	public static int bb_u64_list_find(Object bb, Object blk) {
		int low;
		int high;
		int mid;
		if (bb.getMagic() != (-1024 | (3 << 16) | -1024)) {
			return -1;
		} 
		if (bb.getNum() == 0) {
			return -1;
		} 
		low = 0;
		high = bb.getNum() - 1;
		if (blk == bb.getList()[low]) {
			return low;
		} 
		if (blk == bb.getList()[high]) {
			return high;
		} 
		while (low < high) {
			mid = ((int)low + (int)high) / 2;
			if (mid == low || mid == high) {
				break;
			} 
			if (blk == bb.getList()[mid]) {
				return mid;
			} 
			if (blk < bb.getList()[mid]) {
				high = mid;
			} else {
					low = mid;
			} 
		}
		return -1/*
		 * This procedure tests to see if a particular block is on a badblocks
		 * list.
		 */;
	}
	public static int bb_u64_list_test(Object bb, Object blk) {
		if (ModernizedCProgram.bb_u64_list_find(bb, blk) < 0) {
			return 0;
		} else {
				return 1;
		} 
	}
	public static int bb_badblocks_list_test(Object bb, Object blk) {
		return ModernizedCProgram.bb_u64_list_test((bb_u64_list)bb, blk);
	}
	public static int bb_u64_list_iterate(Object iter, Object blk) {
		bb_u64_list bb = new bb_u64_list();
		if (iter.getMagic() != (-1024 | (3 << 16) | -1024)) {
			return 0;
		} 
		bb = iter.getBb();
		if (bb.getMagic() != (-1024 | (3 << 16) | -1024)) {
			return 0;
		} 
		if (iter.getPtr() < bb.getNum()) {
			blk = bb.getList()[iter.getPtr()++];
			return 1;
		} 
		blk = 0;
		return 0;
	}
	public static int bb_badblocks_list_iterate(Object iter, Object blk) {
		return ModernizedCProgram.bb_u64_list_iterate((bb_u64_iterate)iter, blk);
	}
	public static Object allocate_buffer(Object size) {
		return /*Error: Function owner not recognized*/_mm_malloc(size, 4096);
	}
	public static void free_buffer(Object p) {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_mm_free(p/*
		 * This routine reports a new bad block.  If the bad block has already
		 * been seen before, then it returns 0; otherwise it returns 1.
		 */);
	}
	public static int bb_output(Object bad, error_types error_type) {
		 error_code = new ();
		if (ModernizedCProgram.bb_badblocks_list_test(ModernizedCProgram.bb_list, bad)) {
			return 0;
		} 
		ModernizedCProgram._uprintf("%s%lu\n", ModernizedCProgram.bb_prefix, (long)bad);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(ModernizedCProgram.log_fd, "Block %lu: %s error\n", (long)bad, (error_types.error_type == error_types.READ_ERROR) ? "read" : ((error_types.error_type == error_types.WRITE_ERROR) ? "write" : "corruption"));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fflush(ModernizedCProgram.log_fd);
		error_code = ModernizedCProgram.bb_badblocks_list_add(ModernizedCProgram.bb_list, bad);
		if (error_code) {
			ModernizedCProgram._uprintf("%sError %d adding to in-memory bad block list", ModernizedCProgram.bb_prefix, error_code);
			return 0/* kludge:
				   increment the iteration through the bb_list if
				   an element was just added before the current iteration
				   position.  This should not cause next_bad to change. */;
		} 
		if (ModernizedCProgram.bb_iter && bad < ModernizedCProgram.next_bad) {
			ModernizedCProgram.bb_badblocks_list_iterate(ModernizedCProgram.bb_iter, ModernizedCProgram.next_bad);
		} 
		if (error_types.error_type == error_types.READ_ERROR) {
			ModernizedCProgram.num_read_errors++;
		}  else if (error_types.error_type == error_types.WRITE_ERROR) {
			ModernizedCProgram.num_write_errors++;
		}  else if (error_types.error_type == error_types.CORRUPTION_ERROR) {
			ModernizedCProgram.num_corruption_errors++;
		} 
		return 1;
	}
	public static double calc_percent(long current, long total) {
		double percent = 0.0;
		if (total <= 0) {
			return percent;
		} 
		if (current >= total) {
			percent = 100.0;
		} else {
				percent = (100.0 * (double)current / (double)total);
		} 
		return percent;
	}
	public static void print_status() {
		double percent;
		percent = ModernizedCProgram.calc_percent((long)ModernizedCProgram.currently_testing, (long)ModernizedCProgram.num_blocks);
		ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3235, ModernizedCProgram.lmprintf(3191 + ((ModernizedCProgram.cur_op == op_type.OP_WRITE) ? 0 : 1)), ModernizedCProgram.cur_pattern, ModernizedCProgram.nr_pattern, percent, ModernizedCProgram.num_read_errors, ModernizedCProgram.num_write_errors, ModernizedCProgram.num_corruption_errors);
		percent = (percent / 2.0) + ((ModernizedCProgram.cur_op == op_type.OP_READ) ? 50.0 : 0.0);
		ModernizedCProgram.UpdateProgress(action_type.OP_BADBLOCKS, (((ModernizedCProgram.cur_pattern - 1) * 100.0) + percent) / ModernizedCProgram.nr_pattern);
	}
	public static void alarm_intr(Object hwnd, Object uMsg, Object idEvent, Object dwTime) {
		if (!ModernizedCProgram.num_blocks) {
			return /*Error: Unsupported expression*/;
		} 
		if (ModernizedCProgram.FormatStatus) {
			ModernizedCProgram._uprintf("%sInterrupting at block %I64u\n", ModernizedCProgram.bb_prefix, (long)ModernizedCProgram.currently_testing);
			ModernizedCProgram.cancel_ops = -1;
		} 
		ModernizedCProgram.print_status();
	}
	public static void pattern_fill(Byte buffer, int pattern, Object n) {
		int i;
		int nb;
		byte[] bpattern = new byte[/*Error: sizeof expression not supported yet*/];
		byte ptr;
		if (pattern == (int)~0) {
			ModernizedCProgram.PrintStatusInfo(1, 0, 3500, 3236);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/srand((int)/*Error: Function owner not recognized*/GetTickCount64());
			for (ptr = buffer; ptr < buffer + n; ptr++) {
				(ptr) = /*Error: Function owner not recognized*/rand() % (1 << (8 * /*Error: Unsupported expression*/));
			}
		} else {
				ModernizedCProgram.PrintStatusInfo(1, 0, 3500, 3237, pattern);
				bpattern[0] = 0;
				for (i = 0; i < /*Error: sizeof expression not supported yet*/; i++) {
					if (pattern == 0) {
						break;
					} 
					bpattern[i] = pattern & -1024;
					pattern = pattern >> 8;
				}
				nb = i ? (i - 1) : 0;
				for (; ptr < buffer + n; ptr++) {
					ptr = bpattern[i];
					if (i == 0) {
						i = nb;
					} else {
							i--;
					} 
				}
				ModernizedCProgram.cur_pattern/*
				 * Perform a read of a sequence of blocks; return the number of blocks
				 *    successfully sequentially read.
				 */++;
		} 
	}
	public static Object do_read(Object hDrive, Byte buffer, Object tryout, Object block_size, Object current_block) {
		int64_t got = new int64_t();
		if (ModernizedCProgram.v_flag > 1) {
			ModernizedCProgram.print_status();
		} 
		got = ModernizedCProgram.read_sectors(hDrive, block_size, current_block, tryout, /* Try the read */buffer);
		if (got < 0) {
			got = 0;
		} 
		if (got & 511) {
			ModernizedCProgram._uprintf("%sWeird value (%ld) in do_read\n", ModernizedCProgram.bb_prefix, got);
		} 
		got /= block_size;
		return got/*
		 * Perform a write of a sequence of blocks; return the number of blocks
		 *    successfully sequentially written.
		 */;
	}
	public static Object do_write(Object hDrive, Byte buffer, Object tryout, Object block_size, Object current_block) {
		int64_t got = new int64_t();
		if (ModernizedCProgram.v_flag > 1) {
			ModernizedCProgram.print_status();
		} 
		got = ModernizedCProgram.write_sectors(hDrive, block_size, current_block, tryout, /* Try the write */buffer);
		if (got < 0) {
			got = 0;
		} 
		if (got & 511) {
			ModernizedCProgram._uprintf("%sWeird value (%ld) in do_write\n", ModernizedCProgram.bb_prefix, got);
		} 
		got /= block_size;
		return got;
	}
	public static int test_rw(Object hDrive, Object last_block, Object block_size, Object first_block, Object blocks_at_once, int pattern_type, int nb_passes) {
		int[][] pattern = new int[][]{{-1024, -1024, -1024, -1024}, {-1024, -1024, -1024, -1024}, {-1024, -1024, -1024, -1024}};
		byte buffer = ((Object)0);
		byte read_buffer;
		int i;
		int pat_idx;
		int bb_count = 0;
		 got = new ();
		 tryout = new ();
		 recover_block = ~0;
		 blk_id = new ();
		size_t id_offset = 0;
		if ((pattern_type < 0) || (pattern_type >= 3)) {
			ModernizedCProgram._uprintf("%sInvalid pattern type\n", ModernizedCProgram.bb_prefix);
			ModernizedCProgram.cancel_ops = -1;
			return 0;
		} 
		if ((nb_passes < 1) || (nb_passes > 4)) {
			ModernizedCProgram._uprintf("%sInvalid number of passes\n", ModernizedCProgram.bb_prefix);
			ModernizedCProgram.cancel_ops = -1;
			return 0;
		} 
		buffer = ModernizedCProgram.allocate_buffer(2 * blocks_at_once * block_size);
		read_buffer = buffer + blocks_at_once * block_size;
		if (!buffer) {
			ModernizedCProgram._uprintf("%sError while allocating buffers\n", ModernizedCProgram.bb_prefix);
			ModernizedCProgram.cancel_ops = -1;
			return 0;
		} 
		ModernizedCProgram._uprintf("%sChecking from block %lu to %lu (1 block = %s)\n", ModernizedCProgram.bb_prefix, (long)first_block, (long)last_block - 1, ModernizedCProgram.SizeToHumanReadable((128 * 1024), 0, 0));
		ModernizedCProgram.nr_pattern = nb_passes;
		ModernizedCProgram.cur_pattern = 0;
		for (pat_idx = 0; pat_idx < nb_passes; pat_idx++) {
			if (ModernizedCProgram.cancel_ops) {
				;
			} 
			if (ModernizedCProgram.detect_fakes && (pat_idx == 0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/srand((int)/*Error: Function owner not recognized*/GetTickCount64());
				id_offset = /*Error: Function owner not recognized*/rand() * (block_size - /*Error: Unsupported expression*/) / -1024;
				ModernizedCProgram._uprintf("%sUsing offset %d for fake device check\n", ModernizedCProgram.bb_prefix, id_offset);
			} 
			ModernizedCProgram.pattern_fill(buffer, pattern[pattern_type][pat_idx], blocks_at_once * block_size);
			ModernizedCProgram.num_blocks = last_block - 1;
			ModernizedCProgram.currently_testing = first_block;
			if (ModernizedCProgram.s_flag | ModernizedCProgram.v_flag) {
				ModernizedCProgram._uprintf("%sWriting test pattern 0x%02X\n", ModernizedCProgram.bb_prefix, pattern[pattern_type][pat_idx]);
			} 
			ModernizedCProgram.cur_op = op_type.OP_WRITE;
			tryout = blocks_at_once;
			while (ModernizedCProgram.currently_testing < last_block) {
				if (ModernizedCProgram.cancel_ops) {
					;
				} 
				if (ModernizedCProgram.max_bb && bb_count >= ModernizedCProgram.max_bb) {
					if (ModernizedCProgram.s_flag || ModernizedCProgram.v_flag) {
						ModernizedCProgram._uprintf(ModernizedCProgram.abort_msg);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(ModernizedCProgram.log_fd, ModernizedCProgram.abort_msg);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fflush(ModernizedCProgram.log_fd);
					} 
					ModernizedCProgram.cancel_ops = -1;
					;
				} 
				if (ModernizedCProgram.currently_testing + tryout > last_block) {
					tryout = last_block - ModernizedCProgram.currently_testing;
				} 
				if (ModernizedCProgram.detect_fakes && (pat_idx == 0/* Add the block number at a fixed (random) offset during each pass to
								   allow for the detection of 'fake' media (eg. 2GB USB masquerading as 16GB) */)) {
					for (i = 0; i < (int)blocks_at_once; i++) {
						blk_id = ()(intptr_t)(buffer + id_offset + i * block_size);
						blk_id = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(ModernizedCProgram.currently_testing + i);
					}
				} 
				got = ModernizedCProgram.do_write(hDrive, buffer, tryout, block_size, ModernizedCProgram.currently_testing);
				if (ModernizedCProgram.v_flag > 1) {
					ModernizedCProgram.print_status();
				} 
				if (got == 0 && tryout == 1) {
					bb_count += ModernizedCProgram.bb_output(ModernizedCProgram.currently_testing++, error_types.WRITE_ERROR);
				} 
				ModernizedCProgram.currently_testing += got;
				if (got != tryout) {
					tryout = 1;
					if (recover_block == ~0) {
						recover_block = ModernizedCProgram.currently_testing - got + blocks_at_once;
					} 
					continue;
				}  else if (ModernizedCProgram.currently_testing == recover_block) {
					tryout = blocks_at_once;
					recover_block = ~0;
				} 
			}
			ModernizedCProgram.num_blocks = 0;
			if (ModernizedCProgram.s_flag | ModernizedCProgram.v_flag) {
				ModernizedCProgram._uprintf("%sReading and comparing\n", ModernizedCProgram.bb_prefix);
			} 
			ModernizedCProgram.cur_op = op_type.OP_READ;
			ModernizedCProgram.num_blocks = last_block;
			ModernizedCProgram.currently_testing = first_block;
			tryout = blocks_at_once;
			while (ModernizedCProgram.currently_testing < last_block) {
				if (ModernizedCProgram.cancel_ops) {
					;
				} 
				if (ModernizedCProgram.max_bb && bb_count >= ModernizedCProgram.max_bb) {
					if (ModernizedCProgram.s_flag || ModernizedCProgram.v_flag) {
						ModernizedCProgram._uprintf(ModernizedCProgram.abort_msg);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(ModernizedCProgram.log_fd, ModernizedCProgram.abort_msg);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fflush(ModernizedCProgram.log_fd);
					} 
					ModernizedCProgram.cancel_ops = -1;
					;
				} 
				if (ModernizedCProgram.currently_testing + tryout > last_block) {
					tryout = last_block - ModernizedCProgram.currently_testing;
				} 
				if (ModernizedCProgram.detect_fakes && (pat_idx == 0)) {
					for (i = 0; i < (int)blocks_at_once; i++) {
						blk_id = ()(intptr_t)(buffer + id_offset + i * block_size);
						blk_id = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(ModernizedCProgram.currently_testing + i);
					}
				} 
				got = ModernizedCProgram.do_read(hDrive, read_buffer, tryout, block_size, ModernizedCProgram.currently_testing);
				if (got == 0 && tryout == 1) {
					bb_count += ModernizedCProgram.bb_output(ModernizedCProgram.currently_testing++, error_types.READ_ERROR);
				} 
				ModernizedCProgram.currently_testing += got;
				if (got != tryout) {
					tryout = 1;
					if (recover_block == ~0) {
						recover_block = ModernizedCProgram.currently_testing - got + blocks_at_once;
					} 
					continue;
				}  else if (ModernizedCProgram.currently_testing == recover_block) {
					tryout = blocks_at_once;
					recover_block = ~0;
				} 
				for (i = 0; i < got; i++) {
					if (/*Error: Function owner not recognized*/memcmp(read_buffer + i * block_size, buffer + i * block_size, block_size)) {
						bb_count += ModernizedCProgram.bb_output(ModernizedCProgram.currently_testing + i - got, error_types.CORRUPTION_ERROR);
					} 
				}
				if (ModernizedCProgram.v_flag > 1) {
					ModernizedCProgram.print_status();
				} 
			}
			ModernizedCProgram.num_blocks = 0;
		}
		return bb_count;
	}
	public static Object BadBlocks(Object hPhysicalDrive, Object disk_size, int nb_passes, int flash_type,  report, _iobuf fd) {
		 error_code = new ();
		 last_block = disk_size / (128 * 1024);
		if (report == ((Object)0)) {
			return 0;
		} 
		ModernizedCProgram.num_read_errors = 0;
		ModernizedCProgram.num_write_errors = 0;
		ModernizedCProgram.num_corruption_errors = 0;
		report.setBb_count(0);
		if (fd != ((Object)0)) {
			ModernizedCProgram.log_fd = fd;
		} else {
				ModernizedCProgram.log_fd = /*Error: Function owner not recognized*/freopen(((Object)0), "w", (_iob[2]));
		} 
		error_code = ModernizedCProgram.bb_badblocks_list_create(ModernizedCProgram.bb_list, 0);
		if (error_code) {
			ModernizedCProgram._uprintf("%sError %d while creating in-memory bad blocks list", ModernizedCProgram.bb_prefix, error_code);
			return 0;
		} 
		ModernizedCProgram.cancel_ops = 0;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetTimer(ModernizedCProgram.hMainDialog, timer_type.TID_BADBLOCKS_UPDATE, 1000, /* use a timer to update status every second */alarm_intr);
		report.setBb_count(ModernizedCProgram.test_rw(hPhysicalDrive, last_block, (128 * 1024), 0, 64, flash_type, nb_passes));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/KillTimer(ModernizedCProgram.hMainDialog, timer_type.TID_BADBLOCKS_UPDATE);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(ModernizedCProgram.bb_list.getList());
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(ModernizedCProgram.bb_list);
		report.setNum_read_errors(ModernizedCProgram.num_read_errors);
		report.setNum_write_errors(ModernizedCProgram.num_write_errors);
		report.setNum_corruption_errors(ModernizedCProgram.num_corruption_errors);
		Object generatedBb_count = report.getBb_count();
		if ((ModernizedCProgram.cancel_ops) && (!generatedBb_count)) {
			return 0;
		} 
		return 1;
	}
	public static Object _cdio_list_new() {
		 p_new_obj = /*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/);
		return p_new_obj;
	}
	public static void _cdio_list_free(Object p_list, int free_data, Object free_fn) {
		while (ModernizedCProgram._cdio_list_length(p_list)) {
			ModernizedCProgram._cdio_list_node_free(ModernizedCProgram._cdio_list_begin(p_list), free_data, free_fn);
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_list);
	}
	public static int _cdio_list_length(Object p_list) {
		((p_list != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_list != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 75));
		return p_list.getLength();
	}
	public static void _cdio_list_prepend(Object p_list, Object p_data) {
		 p_new_node = new ();
		((p_list != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_list != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 85));
		p_new_node = /*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/);
		((p_new_node != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_new_node != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 88));
		p_new_node.setList(p_list);
		p_new_node.setNext(p_list.getBegin());
		p_new_node.setData(p_data);
		p_list.setBegin(p_new_node);
		if (p_list.getLength() == 0) {
			p_list.setEnd(p_new_node);
		} 
		p_list.getLength()++;
	}
	public static void _cdio_list_append(Object p_list, Object p_data) {
		((p_list != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_list != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 104));
		if (p_list.getLength() == 0) {
			ModernizedCProgram._cdio_list_prepend(p_list, p_data);
		} else {
				 p_new_node = /*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/);
				((p_new_node != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_new_node != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 113));
				p_new_node.setList(p_list);
				p_new_node.setNext(NULL);
				p_new_node.setData(p_data);
				p_list.getEnd().setNext(p_new_node);
				p_list.setEnd(p_new_node);
				p_list.getLength()++;
		} 
	}
	public static void _cdio_list_foreach(Object p_list, Object func, Object p_user_data) {
		 node = new ();
		((p_list != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_list != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 132));
		((func != 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("func != 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 133));
		for (node = ModernizedCProgram._cdio_list_begin(p_list); node != NULL; node = ModernizedCProgram._cdio_list_node_next(node)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/func(ModernizedCProgram._cdio_list_node_data(node), p_user_data);
		}
	}
	public static Object _cdio_list_find(Object p_list, Object cmp_func, Object p_user_data) {
		 p_node = new ();
		((p_list != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_list != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 147));
		((cmp_func != 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("cmp_func != 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 148));
		for (p_node = ModernizedCProgram._cdio_list_begin(p_list); p_node != NULL; p_node = ModernizedCProgram._cdio_list_node_next(p_node)) {
			if (/*Error: Function owner not recognized*/cmp_func(ModernizedCProgram._cdio_list_node_data(p_node), p_user_data)) {
				break;
			} 
		}
		return p_node;
	}
	public static Object _cdio_list_begin(Object p_list) {
		((p_list != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_list != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 162));
		return p_list.getBegin();
	}
	public static Object _cdio_list_end(Object p_list) {
		((p_list != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_list != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 170));
		return p_list.getEnd();
	}
	public static Object _cdio_list_node_next(Object p_node) {
		if (p_node) {
			return p_node.getNext();
		} 
		return NULL;
	}
	public static void _cdio_list_node_free(Object p_node, int free_data, Object free_fn) {
		 p_list = new ();
		 prev_node = new ();
		((p_node != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_node != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 191));
		p_list = p_node.getList();
		((ModernizedCProgram._cdio_list_length(p_list) > 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("_cdio_list_length (p_list) > 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 195));
		if (free_data && free_fn) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free_fn(ModernizedCProgram._cdio_list_node_data(p_node));
		} 
		if (ModernizedCProgram._cdio_list_length(p_list) == 1) {
			((p_list.getBegin() == p_list.getEnd()) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_list->begin == p_list->end", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 202));
			p_list.setEnd(p_list.setBegin(NULL));
			p_list.setLength(0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_node);
			return /*Error: Unsupported expression*/;
		} 
		((p_list.getBegin() != p_list.getEnd()) ? (Object)0 : /*Error: Function owner not recognized*/_assert("p_list->begin != p_list->end", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 210));
		if (p_list.getBegin() == p_node) {
			p_list.setBegin(p_node.getNext());
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_node);
			p_list.getLength()--;
			return /*Error: Unsupported expression*/;
		} 
		for (prev_node = p_list.getBegin(); prev_node.getNext(); prev_node = prev_node.getNext()) {
			if (prev_node.getNext() == p_node) {
				break;
			} 
		}
		((prev_node.getNext() != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("prev_node->next != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ds.c", 224));
		if (p_list.getEnd() == p_node) {
			p_list.setEnd(prev_node);
		} 
		prev_node.setNext(p_node.getNext());
		p_list.getLength()--;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_node);
	}
	public static Object _cdio_list_node_data(Object p_node) {
		if (p_node) {
			return p_node.getData();
		} 
		return NULL/* eof */;/*
		 * Local variables:
		 *  c-file-style: "gnu"
		 *  tab-width: 8
		 *  indent-tabs-mode: nil
		 * End:
		 */
	}
	/*
	 * GPLv2+ CRC32 implementation for busybox
	 *
	 * Based on crc32.c from util-linux v2.17's partx v2.17 - Public Domain
	 * Adjusted for busybox' by Pete Batard <pete@akeo.ie>
	 *
	 * Licensed under GPLv2 or later, see file LICENSE in this source tree.
	 */
	/* 2.x has "attribute", but only 3.0 has "pure */
	/* Do NOT alter these */
	/*
	 * There are multiple 16-bit CRC polynomials in common use, but this is
	 * *the* standard CRC-32 polynomial, first popularized by Ethernet.
	 * x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0
	 */
	/* This needs to be defined somewhere */
	public static void crc32init_le(Object[] crc32table_le) {
		int i;
		int j;
		uint32_t crc = 1;
		crc32table_le[0] = 0;
		for (i = 1 << (8 - 1); i; i >>=  1) {
			crc = (crc >> 1) ^ ((crc & 1) ? -1024 : 0);
			for (j = 0; j < 1 << 8; j += 2 * i) {
				crc32table_le[i + j] = crc ^ crc32table_le[j/**
				 * crc32_le() - Calculate bitwise little-endian Ethernet AUTODIN II CRC32
				 * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for
				 *        other uses, or the previous crc32 value if computing incrementally.
				 * @p   - pointer to buffer over which CRC is run
				 * @len - length of buffer @p
				 * 
				 */];
			}
		}
	}
	public static Object crc32_le(Object crc, Object p, Object len, Object[] crc32table_le) {
		while (len--) {
			crc = (crc >> 8) ^ crc32table_le[(crc ^ p++) & 255];
		}
		return crc/**
		 * crc32init_be() - allocate and initialize BE table data
		 */;
	}
	public static void crc32init_be(Object[] crc32table_be) {
		int i;
		int j;
		uint32_t crc = -1024;
		for (i = 1; i < 1 << 8; i <<=  1) {
			crc = (crc << 1) ^ ((crc & -1024) ? -1024 : 0);
			for (j = 0; j < i; j++) {
				crc32table_be[i + j] = crc ^ crc32table_be[j/**
				 * crc32_be() - Calculate bitwise big-endian Ethernet AUTODIN II CRC32
				 * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for
				 *        other uses, or the previous crc32 value if computing incrementally.
				 * @p   - pointer to buffer over which CRC is run
				 * @len - length of buffer @p
				 * 
				 */];
			}
		}
	}
	public static Object crc32_be(Object crc, Object p, Object len, Object[] crc32table_be) {
		while (len--) {
			crc = (crc << 8) ^ crc32table_be[(crc >> 24) ^ p++];
		}
		return crc;
	}
	public static Object crc32_filltable(Object crc_table, int endian) {
		if (!/* Expects the caller to do the cleanup */crc_table) {
			crc_table = /*Error: Function owner not recognized*/malloc((1 << 8) * /*Error: Unsupported expression*/);
		} 
		if (crc_table) {
			if (endian) {
				ModernizedCProgram.crc32init_be(crc_table);
			} else {
					ModernizedCProgram.crc32init_le(crc_table);
			} 
		} 
		return crc_table/*
		 * A brief CRC tutorial.
		 *
		 * A CRC is a long-division remainder.  You add the CRC to the message,
		 * and the whole thing (message+CRC) is a multiple of the given
		 * CRC polynomial.  To check the CRC, you can either check that the
		 * CRC matches the recomputed value, *or* you can check that the
		 * remainder computed on the message+CRC is 0.  This latter approach
		 * is used by a lot of hardware implementations, and is why so many
		 * protocols put the end-of-frame flag after the CRC.
		 *
		 * It's actually the same long division you learned in school, except that
		 * - We're working in binary, so the digits are only 0 and 1, and
		 * - When dividing polynomials, there are no carries.  Rather than add and
		 *   subtract, we just xor.  Thus, we tend to get a bit sloppy about
		 *   the difference between adding and subtracting.
		 *
		 * A 32-bit CRC polynomial is actually 33 bits long.  But since it's
		 * 33 bits long, bit 32 is always going to be set, so usually the CRC
		 * is written in hex with the most significant bit omitted.  (If you're
		 * familiar with the IEEE 754 floating-point format, it's the same idea.)
		 *
		 * Note that a CRC is computed over a string of *bits*, so you have
		 * to decide on the endianness of the bits within each byte.  To get
		 * the best error-detecting properties, this should correspond to the
		 * order they're actually sent.  For example, standard RS-232 serial is
		 * little-endian; the most significant bit (sometimes used for parity)
		 * is sent last.  And when appending a CRC word to a message, you should
		 * do it in the right order, matching the endianness.
		 *
		 * Just like with ordinary division, the remainder is always smaller than
		 * the divisor (the CRC polynomial) you're dividing by.  Each step of the
		 * division, you take one more digit (bit) of the dividend and append it
		 * to the current remainder.  Then you figure out the appropriate multiple
		 * of the divisor to subtract to being the remainder back into range.
		 * In binary, it's easy - it has to be either 0 or 1, and to make the
		 * XOR cancel, it's just a copy of bit 32 of the remainder.
		 *
		 * When computing a CRC, we don't care about the quotient, so we can
		 * throw the quotient bit away, but subtract the appropriate multiple of
		 * the polynomial from the remainder and we're back to where we started,
		 * ready to process the next bit.
		 *
		 * A big-endian CRC written this way would be coded like:
		 * for (i = 0; i < input_bits; i++) {
		 * 	multiple = remainder & 0x80000000 ? CRCPOLY : 0;
		 * 	remainder = (remainder << 1 | next_input_bit()) ^ multiple;
		 * }
		 * Notice how, to get at bit 32 of the shifted remainder, we look
		 * at bit 31 of the remainder *before* shifting it.
		 *
		 * But also notice how the next_input_bit() bits we're shifting into
		 * the remainder don't actually affect any decision-making until
		 * 32 bits later.  Thus, the first 32 cycles of this are pretty boring.
		 * Also, to add the CRC to a message, we need a 32-bit-long hole for it at
		 * the end, so we have to add 32 extra cycles shifting in zeros at the
		 * end of every message,
		 *
		 * So the standard trick is to rearrage merging in the next_input_bit()
		 * until the moment it's needed.  Then the first 32 cycles can be precomputed,
		 * and merging in the final 32 zero bits to make room for the CRC can be
		 * skipped entirely.
		 * This changes the code to:
		 * for (i = 0; i < input_bits; i++) {
		 *      remainder ^= next_input_bit() << 31;
		 * 	multiple = (remainder & 0x80000000) ? CRCPOLY : 0;
		 * 	remainder = (remainder << 1) ^ multiple;
		 * }
		 * With this optimization, the little-endian code is simpler:
		 * for (i = 0; i < input_bits; i++) {
		 *      remainder ^= next_input_bit();
		 * 	multiple = (remainder & 1) ? CRCPOLY : 0;
		 * 	remainder = (remainder >> 1) ^ multiple;
		 * }
		 *
		 * Note that the other details of endianness have been hidden in CRCPOLY
		 * (which must be bit-reversed) and next_input_bit().
		 *
		 * However, as long as next_input_bit is returning the bits in a sensible
		 * order, we can actually do the merging 8 or more bits at a time rather
		 * than one bit at a time:
		 * for (i = 0; i < input_bytes; i++) {
		 * 	remainder ^= next_input_byte() << 24;
		 * 	for (j = 0; j < 8; j++) {
		 * 		multiple = (remainder & 0x80000000) ? CRCPOLY : 0;
		 * 		remainder = (remainder << 1) ^ multiple;
		 * 	}
		 * }
		 * Or in little-endian:
		 * for (i = 0; i < input_bytes; i++) {
		 * 	remainder ^= next_input_byte();
		 * 	for (j = 0; j < 8; j++) {
		 * 		multiple = (remainder & 1) ? CRCPOLY : 0;
		 * 		remainder = (remainder << 1) ^ multiple;
		 * 	}
		 * }
		 * If the input is a multiple of 32 bits, you can even XOR in a 32-bit
		 * word at a time and increase the inner loop count to 32.
		 *
		 * You can also mix and match the two loop styles, for example doing the
		 * bulk of a message byte-at-a-time and adding bit-at-a-time processing
		 * for any fractional bytes at the end.
		 *
		 * The only remaining optimization is to the byte-at-a-time table method.
		 * Here, rather than just shifting one bit of the remainder to decide
		 * in the correct multiple to subtract, we can shift a byte at a time.
		 * This produces a 40-bit (rather than a 33-bit) intermediate remainder,
		 * but again the multiple of the polynomial to subtract depends only on
		 * the high bits, the high 8 bits in this case.  
		 *
		 * The multile we need in that case is the low 32 bits of a 40-bit
		 * value whose high 8 bits are given, and which is a multiple of the
		 * generator polynomial.  This is simply the CRC-32 of the given
		 * one-byte message.
		 *
		 * Two more details: normally, appending zero bits to a message which
		 * is already a multiple of a polynomial produces a larger multiple of that
		 * polynomial.  To enable a CRC to detect this condition, it's common to
		 * invert the CRC before appending it.  This makes the remainder of the
		 * message+crc come out not as zero, but some fixed non-zero value.
		 *
		 * The same problem applies to zero bits prepended to the message, and
		 * a similar solution is used.  Instead of starting with a remainder of
		 * 0, an initial remainder of all ones is used.  As long as you start
		 * the same way on decoding, it doesn't make a difference.
		 */;
	}
	/******************************************************************
	    Copyright (C) 2009  Henrik Carlqvist
	
	    This program is free software; you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation; either version 2 of the License, or
	    (at your option) any later version.
	
	    This program is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with this program; if not, write to the Free Software
	    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
	******************************************************************/
	public static int is_fat_32_fs() {
		byte szMagic = "FAT32   ";
		return fp.contains_data(-1024, szMagic, /*Error: Function owner not recognized*/strlen(szMagic/* is_fat_32_fs */));
	}
	public static int is_fat_32_br() {
		byte[] aucRef = new byte[]{-1024, /* A "file" is probably some kind of FAT32 boot record if it contains the
		      magic chars 0x55, 0xAA at positions 0x1FE, 0x3FE and 0x5FE */-1024};
		byte[] aucMagic = new byte[]{(byte)'M', (byte)'S', (byte)'W', (byte)'I', (byte)'N', (byte)'4', (byte)'.', (byte)'1'};
		int i;
		for (i = 0; i < 3; i++) {
			if (!fp.contains_data(-1024 + i * -1024, aucRef, /*Error: sizeof expression not supported yet*/)) {
				return 0;
			} 
		}
		if (!fp.contains_data(-1024, aucMagic, /*Error: sizeof expression not supported yet*/)) {
			return 0;
		} 
		return 1/* is_fat_32_br */;
	}
	public static int entire_fat_32_br_matches() {
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.contains_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32_0x52, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32_0x3f0, /*Error: sizeof expression not supported yet*/));
	}
	public static int write_fat_32_br(int bKeepLabel) {
		byte[] label_11_char = new byte[]{(byte)'N', (byte)'O', (byte)' ', (byte)'N', (byte)'A', (byte)'M', (byte)'E', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		if (bKeepLabel) {
			return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32_0x52, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32_0x3f0, /*Error: sizeof expression not supported yet*/));
		} else {
				return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, label_11_char, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32_0x52, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32_0x3f0, /*Error: sizeof expression not supported yet*/));
		} 
	}
	public static int entire_fat_32_fd_br_matches() {
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.contains_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32_0x52, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32_0x3f0, /*Error: sizeof expression not supported yet*/));
	}
	public static int write_fat_32_fd_br(int bKeepLabel) {
		byte[] label_11_char = new byte[]{(byte)'N', (byte)'O', (byte)' ', (byte)'N', (byte)'A', (byte)'M', (byte)'E', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		if (bKeepLabel) {
			return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32_0x52, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32_0x3f0, /*Error: sizeof expression not supported yet*/));
		} else {
				return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, label_11_char, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32_0x52, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32_0x3f0, /*Error: sizeof expression not supported yet*/));
		} 
	}
	public static int entire_fat_32_nt_br_matches() {
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32nt_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32nt_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32nt_0x1800 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.contains_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32nt_0x52, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32nt_0x3f0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32nt_0x1800, /*Error: sizeof expression not supported yet*/));
	}
	public static int write_fat_32_nt_br(int bKeepLabel) {
		byte[] label_11_char = new byte[]{(byte)'N', (byte)'O', (byte)' ', (byte)'N', (byte)'A', (byte)'M', (byte)'E', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32nt_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32nt_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32nt_0x1800 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		if (bKeepLabel) {
			return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32nt_0x52, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32nt_0x3f0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32nt_0x1800, /*Error: sizeof expression not supported yet*/));
		} else {
				return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, label_11_char, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32nt_0x52, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32nt_0x3f0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32nt_0x1800, /*Error: sizeof expression not supported yet*/));
		} 
	}
	public static int entire_fat_32_pe_br_matches() {
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32pe_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32pe_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32pe_0x1800 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.contains_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32pe_0x52, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32pe_0x3f0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32pe_0x1800, /*Error: sizeof expression not supported yet*/));
	}
	public static int write_fat_32_pe_br(int bKeepLabel) {
		byte[] label_11_char = new byte[]{(byte)'N', (byte)'O', (byte)' ', (byte)'N', (byte)'A', (byte)'M', (byte)'E', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32pe_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32pe_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32pe_0x1800 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		if (bKeepLabel) {
			return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32pe_0x52, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32pe_0x3f0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32pe_0x1800, /*Error: sizeof expression not supported yet*/));
		} else {
				return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, label_11_char, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32pe_0x52, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32pe_0x3f0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32pe_0x1800, /*Error: sizeof expression not supported yet*/));
		} 
	}
	public static int entire_fat_32_ros_br_matches() {
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32ros_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32ros_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32ros_0x1c00 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.contains_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32ros_0x52, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32ros_0x3f0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32ros_0x1c00, /*Error: sizeof expression not supported yet*/));
	}
	/* See http://doxygen.reactos.org/dc/d83/bootsup_8c_source.html#l01596 */
	public static int write_fat_32_ros_br(int bKeepLabel) {
		byte[] label_11_char = new byte[]{(byte)'N', (byte)'O', (byte)' ', (byte)'N', (byte)'A', (byte)'M', (byte)'E', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32ros_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32ros_0x3f0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32ros_0x1c00 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		if (bKeepLabel) {
			return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32ros_0x52, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32ros_0x3f0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32ros_0x1c00, /*Error: sizeof expression not supported yet*/));
		} else {
				return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, label_11_char, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32ros_0x52, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32ros_0x3f0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32ros_0x1c00, /*Error: sizeof expression not supported yet*/));
		} 
	}
	public static int entire_fat_32_kos_br_matches() {
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32kos_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.contains_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat32kos_0x52, /*Error: sizeof expression not supported yet*/));
	}
	public static int write_fat_32_kos_br(int bKeepLabel) {
		byte[] label_11_char = new byte[]{(byte)'N', (byte)'O', (byte)' ', (byte)'N', (byte)'A', (byte)'M', (byte)'E', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		byte[] br_fat32_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat32kos_0x52 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		if (bKeepLabel) {
			return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32kos_0x52, /*Error: sizeof expression not supported yet*/));
		} else {
				return (fp.write_data(-1024, br_fat32_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, label_11_char, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat32kos_0x52, /*Error: sizeof expression not supported yet*/));
		} 
	}
	/*
	 * bitmaps.c --- routines to read, write, and manipulate the inode and
	 * block bitmaps.
	 *
	 * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static void ext2fs_free_inode_bitmap(Object bitmap) {
		ModernizedCProgram.ext2fs_free_generic_bmap(bitmap);
	}
	public static void ext2fs_free_block_bitmap(Object bitmap) {
		ModernizedCProgram.ext2fs_free_generic_bmap(bitmap);
	}
	public static Object ext2fs_copy_bitmap(Object src, Object dest) {
		return (ModernizedCProgram.ext2fs_copy_generic_bmap(src, dest));
	}
	public static void ext2fs_set_bitmap_padding(Object map) {
		ModernizedCProgram.ext2fs_set_generic_bmap_padding(map);
	}
	public static Object ext2fs_allocate_inode_bitmap(Object fs, Object descr, Object ret) {
		 start = new ();
		 end = new ();
		 real_end = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		fs.setWrite_bitmaps(ModernizedCProgram.ext2fs_write_bitmaps);
		start = 1;
		end = fs.getSuper().getS_inodes_count();
		real_end = (((fs.getSuper()).getS_inodes_per_group()) * fs.getGroup_desc_count());
		if (fs.getFlags() & /* Are we permitted to use new-style bitmaps? */-1024) {
			return (ModernizedCProgram.ext2fs_alloc_generic_bmap(fs, EXT2_ET_MAGIC_INODE_BITMAP64, fs.getDefault_bitmap_type(), start, end, real_end, descr, ret));
		} 
		if ((end > ~-1024) || (real_end > ~/* Otherwise, check to see if the file system is small enough
			 * to use old-style 32-bit bitmaps */-1024)) {
			return EXT2_ET_CANT_USE_LEGACY_BITMAPS;
		} 
		return (ModernizedCProgram.ext2fs_make_generic_bitmap(EXT2_ET_MAGIC_INODE_BITMAP, fs, start, end, real_end, descr, 0, (ext2fs_generic_bitmap)ret));
	}
	public static Object ext2fs_allocate_block_bitmap(Object fs, Object descr, Object ret) {
		 start = new ();
		 end = new ();
		 real_end = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		fs.setWrite_bitmaps(ModernizedCProgram.ext2fs_write_bitmaps);
		start = ((fs.getSuper().getS_first_data_block()) >> (fs).getCluster_ratio_bits());
		end = ((fs.getSuper().ext2fs_blocks_count() - 1) >> (fs).getCluster_ratio_bits());
		real_end = (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME((fs.getSuper()).getS_clusters_per_group()) * ()fs.getGroup_desc_count()) - 1 + start;
		if (fs.getFlags() & -1024) {
			return (ModernizedCProgram.ext2fs_alloc_generic_bmap(fs, EXT2_ET_MAGIC_BLOCK_BITMAP64, fs.getDefault_bitmap_type(), start, end, real_end, descr, ret));
		} 
		if ((end > ~-1024) || (real_end > ~-1024)) {
			return EXT2_ET_CANT_USE_LEGACY_BITMAPS;
		} 
		return (ModernizedCProgram.ext2fs_make_generic_bitmap(EXT2_ET_MAGIC_BLOCK_BITMAP, fs, start, end, real_end, descr, 0, (ext2fs_generic_bitmap)ret/*
		 * ext2fs_allocate_block_bitmap() really allocates a per-cluster
		 * bitmap for backwards compatibility.  This function allocates a
		 * block bitmap which is truly per-block, even if clusters/bigalloc
		 * are enabled.  mke2fs and e2fsck need this for tracking the
		 * allocation of the file system metadata blocks.
		 */));
	}
	public static Object ext2fs_allocate_subcluster_bitmap(Object fs, Object descr, Object ret) {
		 start = new ();
		 end = new ();
		 real_end = new ();
		ext2fs_generic_bitmap bmap = new ext2fs_generic_bitmap();
		ext2fs_generic_bitmap_64 bmap64 = new ext2fs_generic_bitmap_64();
		 retval = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		fs.setWrite_bitmaps(ModernizedCProgram.ext2fs_write_bitmaps);
		if (!fs.getCluster_ratio_bits()) {
			return ModernizedCProgram.ext2fs_allocate_block_bitmap(fs, descr, ret);
		} 
		if ((fs.getFlags() & -1024) == 0) {
			return EXT2_ET_CANT_USE_LEGACY_BITMAPS;
		} 
		start = fs.getSuper().getS_first_data_block();
		end = fs.getSuper().ext2fs_blocks_count() - 1;
		real_end = (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME((fs.getSuper()).getS_blocks_per_group()) * ()fs.getGroup_desc_count()) - 1 + start;
		retval = ModernizedCProgram.ext2fs_alloc_generic_bmap(fs, EXT2_ET_MAGIC_BLOCK_BITMAP64, fs.getDefault_bitmap_type(), start, end, real_end, descr, bmap);
		if (retval) {
			return retval;
		} 
		bmap64 = (ext2fs_generic_bitmap_64)bmap;
		bmap64.setCluster_bits(0);
		ret = bmap;
		return 0;
	}
	public static int ext2fs_get_bitmap_granularity(Object bitmap) {
		ext2fs_generic_bitmap_64 bmap = (ext2fs_generic_bitmap_64)bitmap;
		if (!(((bmap).getMagic() == EXT2_ET_MAGIC_GENERIC_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_BLOCK_BITMAP64) || ((bmap).getMagic() == EXT2_ET_MAGIC_INODE_BITMAP64))) {
			return 0;
		} 
		return bmap.getCluster_bits();
	}
	public static Object ext2fs_fudge_inode_bitmap_end(Object bitmap, Object end, Object oend) {
		 tmp_oend = new ();
		int retval;
		retval = ModernizedCProgram.ext2fs_fudge_generic_bmap_end((ext2fs_generic_bitmap)bitmap, EXT2_ET_FUDGE_INODE_BITMAP_END, end, tmp_oend);
		if (oend) {
			oend = tmp_oend;
		} 
		return retval;
	}
	public static Object ext2fs_fudge_block_bitmap_end(Object bitmap, Object end, Object oend) {
		return (ModernizedCProgram.ext2fs_fudge_generic_bitmap_end(bitmap, EXT2_ET_MAGIC_BLOCK_BITMAP, EXT2_ET_FUDGE_BLOCK_BITMAP_END, end, oend));
	}
	public static Object ext2fs_fudge_block_bitmap_end2(Object bitmap, Object end, Object oend) {
		return (ModernizedCProgram.ext2fs_fudge_generic_bmap_end(bitmap, EXT2_ET_FUDGE_BLOCK_BITMAP_END, end, oend));
	}
	public static void ext2fs_clear_inode_bitmap(Object bitmap) {
		ModernizedCProgram.ext2fs_clear_generic_bmap(bitmap);
	}
	public static void ext2fs_clear_block_bitmap(Object bitmap) {
		ModernizedCProgram.ext2fs_clear_generic_bmap(bitmap);
	}
	public static Object ext2fs_resize_inode_bitmap(Object new_end, Object new_real_end, Object bmap) {
		return (ModernizedCProgram.ext2fs_resize_generic_bitmap(EXT2_ET_MAGIC_INODE_BITMAP, new_end, new_real_end, bmap));
	}
	public static Object ext2fs_resize_inode_bitmap2(Object new_end, Object new_real_end, Object bmap) {
		return (ModernizedCProgram.ext2fs_resize_generic_bmap(bmap, new_end, new_real_end));
	}
	public static Object ext2fs_resize_block_bitmap(Object new_end, Object new_real_end, Object bmap) {
		return (ModernizedCProgram.ext2fs_resize_generic_bitmap(EXT2_ET_MAGIC_BLOCK_BITMAP, new_end, new_real_end, bmap));
	}
	public static Object ext2fs_resize_block_bitmap2(Object new_end, Object new_real_end, Object bmap) {
		return (ModernizedCProgram.ext2fs_resize_generic_bmap(bmap, new_end, new_real_end));
	}
	public static Object ext2fs_compare_block_bitmap(Object bm1, Object bm2) {
		return (ModernizedCProgram.ext2fs_compare_generic_bmap(EXT2_ET_NEQ_BLOCK_BITMAP, bm1, bm2));
	}
	public static Object ext2fs_compare_inode_bitmap(Object bm1, Object bm2) {
		return (ModernizedCProgram.ext2fs_compare_generic_bmap(EXT2_ET_NEQ_INODE_BITMAP, bm1, bm2));
	}
	public static Object ext2fs_set_inode_bitmap_range(Object bmap, Object start, int num, Object in) {
		return (ModernizedCProgram.ext2fs_set_generic_bitmap_range(bmap, EXT2_ET_MAGIC_INODE_BITMAP, start, num, in));
	}
	public static Object ext2fs_set_inode_bitmap_range2(Object bmap, Object start, Object num, Object in) {
		return (ModernizedCProgram.ext2fs_set_generic_bmap_range(bmap, start, num, in));
	}
	public static Object ext2fs_get_inode_bitmap_range(Object bmap, Object start, int num, Object out) {
		return (ModernizedCProgram.ext2fs_get_generic_bitmap_range(bmap, EXT2_ET_MAGIC_INODE_BITMAP, start, num, out));
	}
	public static Object ext2fs_get_inode_bitmap_range2(Object bmap, Object start, Object num, Object out) {
		return (ModernizedCProgram.ext2fs_get_generic_bmap_range(bmap, start, num, out));
	}
	public static Object ext2fs_set_block_bitmap_range(Object bmap, Object start, int num, Object in) {
		return (ModernizedCProgram.ext2fs_set_generic_bitmap_range(bmap, EXT2_ET_MAGIC_BLOCK_BITMAP, start, num, in));
	}
	public static Object ext2fs_set_block_bitmap_range2(Object bmap, Object start, Object num, Object in) {
		return (ModernizedCProgram.ext2fs_set_generic_bmap_range(bmap, start, num, in));
	}
	public static Object ext2fs_get_block_bitmap_range(Object bmap, Object start, int num, Object out) {
		return (ModernizedCProgram.ext2fs_get_generic_bitmap_range(bmap, EXT2_ET_MAGIC_BLOCK_BITMAP, start, num, out));
	}
	public static Object ext2fs_get_block_bitmap_range2(Object bmap, Object start, Object num, Object out) {
		return (ModernizedCProgram.ext2fs_get_generic_bmap_range(bmap, start, num, out));
	}
	/*
	 * Extract the main icon set from the exe
	 */
	public static Object ExtractAppIcon(Object path, Object bSilent) {
		HGLOBAL res_handle = new HGLOBAL();
		HRSRC res = new HRSRC();
		WORD i = new WORD();
		BYTE res_data = new BYTE();
		DWORD res_size = new DWORD();
		DWORD Size = new DWORD();
		DWORD offset = new DWORD();
		HANDLE hFile = (HANDLE)(true);
		BOOL r = 0;
		GRPICONDIR icondir = new GRPICONDIR();
		icondir = (GRPICONDIR)ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)((ULONG_PTR)((LPSTR)((DWORD)((WORD)(true))) + 11)))), "icon", res_size, 0);
		hFile = ModernizedCProgram.CreateFileU(path, -1024 | -1024, -1024, ((Object)0), 2, -1024, ((Object)0));
		if (hFile == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Unable to create icon '%s': %s.", path, ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Write .ico headerif (!ModernizedCProgram.WriteFileWithRetry(hFile, icondir, 3 * /*Error: Unsupported expression*/, Size, 4)) {
			ModernizedCProgram._uprintf("Could not write icon header: %s.", ModernizedCProgram.WindowsErrorString());
			;
		} 
		Object generatedIdCount = icondir.getIdCount();
		// Write icon data// Write icon dataoffset = 3 * /*Error: Unsupported expression*/ + generatedIdCount * /*Error: Unsupported expression*/;
		Object generatedIdEntries = icondir.getIdEntries();
		for (i = 0; i < generatedIdCount; i++) {
			if (!ModernizedCProgram.WriteFileWithRetry(hFile, generatedIdEntries[i], /*Error: Unsupported expression*/ - /*Error: Unsupported expression*/, Size, 4)) {
				ModernizedCProgram._uprintf("Could not write ICONDIRENTRY[%d]: %s.", i, ModernizedCProgram.WindowsErrorString());
				;
			} 
			res = /*Error: Function owner not recognized*/FindResourceA(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(generatedIdEntries[i].getNID()))), (LPSTR)((DWORD)((WORD)(true))));
			if (!ModernizedCProgram.WriteFileWithRetry(hFile, offset, /*Error: sizeof expression not supported yet*/, Size, 4)) {
				ModernizedCProgram._uprintf("Could not write ICONDIRENTRY[%d] offset: %s.", i, ModernizedCProgram.WindowsErrorString());
				;
			} 
			offset += /*Error: Function owner not recognized*/SizeofResource(((Object)0), res);
		}// Write the common part of ICONDIRENTRY
		for (i = 0; i < generatedIdCount; i++) {
			res = /*Error: Function owner not recognized*/FindResourceA(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(generatedIdEntries[i].getNID()))), (LPSTR)((DWORD)((WORD)(true))));
			res_handle = /*Error: Function owner not recognized*/LoadResource(((Object)0), res);
			res_data = (BYTE)/*Error: Function owner not recognized*/LockResource(res_handle);
			res_size = /*Error: Function owner not recognized*/SizeofResource(((Object)0), res);
			if (!ModernizedCProgram.WriteFileWithRetry(hFile, res_data, res_size, Size, 4)) {
				ModernizedCProgram._uprintf("Could not write icon data #%d: %s.", i, ModernizedCProgram.WindowsErrorString());
				;
			} 
		}// Write icon data
		do {
			if (!bSilent) {
				ModernizedCProgram._uprintf("Created: %s", path);
			} 
		} while (0);
		r = 1;
		return r/*
		 * Create an autorun.inf, if none exists
		 * We use this to set the icon as well as labels that are longer than 11/32 chars or,
		 * in the case of FAT, contain non-English characters
		 */;
	}
	public static Object SetAutorun(Object path) {
		FILE fd = new FILE();
		byte[] filename = new byte[64];
		wchar_t[] wlabel = new wchar_t();
		wchar_t[] wRufusVersion = new wchar_t();
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(filename, /*Error: sizeof expression not supported yet*/, "%sautorun.inf", path);
			(filename)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		// If there's an existing autorun, don't overwrite// If there's an existing autorun, don't overwritefd = /*Error: Function owner not recognized*/fopen(filename, "r");
		if (fd != ((Object)0)) {
			ModernizedCProgram._uprintf("%s already exists - keeping it", filename);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
			return 0;
		} 
		// No "/autorun.inf" => create a new one in UTF-16 LE mode// No "/autorun.inf" => create a new one in UTF-16 LE modefd = /*Error: Function owner not recognized*/fopen(filename, "w, ccs=UTF-16LE");
		if (fd == ((Object)0)) {
			ModernizedCProgram._uprintf("Unable to create %s", filename);
			ModernizedCProgram._uprintf("NOTE: This may be caused by a poorly designed security solution. See https://goo.gl/QTobxX.");
			return 0;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowTextW(ModernizedCProgram.hLabel, wlabel, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowTextW(ModernizedCProgram.hMainDialog, wRufusVersion, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/))// coverity[invalid_type];// coverity[invalid_type]
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwprintf_s(fd, L"; Created by %s\n; https://rufus.ie\n", wRufusVersion)// coverity[invalid_type];// coverity[invalid_type]
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwprintf_s(fd, L"[autorun]\nicon  = autorun.ico\nlabel = %s\n", wlabel);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
		ModernizedCProgram._uprintf("Created: %s", filename);
		// .inf -> .ico// .inf -> .icofilename[/*Error: Function owner not recognized*/strlen(filename) - 1] = (byte)'o';
		filename[/*Error: Function owner not recognized*/strlen(filename) - 2] = (byte)'c';
		return ModernizedCProgram.ExtractAppIcon(filename, 0);
	}
	/* getopt_long and getopt_long_only entry points for GNU getopt.
	   Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98
	     Free Software Foundation, Inc.
	   This file is part of the GNU C Library.
	
	   The GNU C Library is free software; you can redistribute it and/or
	   modify it under the terms of the GNU Lesser General Public
	   License as published by the Free Software Foundation; either
	   version 2.1 of the License, or (at your option) any later version.
	
	   The GNU C Library is distributed in the hope that it will be useful,
	   but WITHOUT ANY WARRANTY; without even the implied warranty of
	   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	   Lesser General Public License for more details.
	
	   You should have received a copy of the GNU Lesser General Public
	   License along with the GNU C Library; if not, write to the Free
	   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
	   02111-1307 USA.  */
	/* This is a separate conditional since some stdc systems
	   reject `defined (const)'.  */
	/* Comment out all this code if we are using the GNU C Library, and are not
	   actually compiling the library itself.  This code is part of the GNU C
	   Library, but also included in many other GNU distributions.  Compiling
	   and linking in this code is a waste when using the GNU C library
	   (especially if it is a shared library).  Rather than having every GNU
	   program understand `configure --with-gnu-libc' and omit the object files,
	   it is simpler to just do this in the source for each such file.  */
	/* This needs to come after some library #include
	   to get __GNU_LIBRARY__ defined.  */
	/* This needs to come after some library #include
	   to get __GNU_LIBRARY__ defined.  */
	public static int getopt_long(int argc, Byte argv, Object options, Object long_options, Integer opt_index) {
		return ModernizedCProgram._getopt_internal(argc, argv, options, long_options, opt_index, 0/* Like getopt_long, but '-' as well as '--' can indicate a long option.
		   If an option that starts with '-' (not '--') doesn't match a long option,
		   but does match a short option, it is parsed as a short option
		   instead.  */);
	}
	public static int getopt_long_only(int argc, Byte argv, Object options, Object long_options, Integer opt_index) {
		return ModernizedCProgram._getopt_internal(argc, argv, options, long_options, opt_index, 1/* Not ELIDE_CODE.  */);
	}
	/* ----------------------------------------------------------------------- *
	 *
	 *   Copyright 2004-2008 H. Peter Anvin - All Rights Reserved
	 *
	 *   This program is free software; you can redistribute it and/or modify
	 *   it under the terms of the GNU General Public License as published by
	 *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
	 *   Boston MA 02111-1307, USA; either version 2 of the License, or
	 *   (at your option) any later version; incorporated herein by reference.
	 *
	 * ----------------------------------------------------------------------- */
	/*
	 * searchdir.c
	 *
	 * Search a FAT directory for a particular pre-mangled filename.
	 * Copies the directory entry into direntry and returns the starting cluster
	 * if found; returns -2 on not found, -1 on error, 0 on empty file.
	 */
	public static Object libfat_searchdir(libfat_filesystem fs, Object dirclust, Object name, libfat_direntry direntry) {
		fat_dirent dep = new fat_dirent();
		int nent;
		libfat_sector_t s = ModernizedCProgram.libfat_clustertosector(fs, dirclust);
		Object generatedName = dep.getName();
		Object generatedEntry = direntry.getEntry();
		Object generatedSize = dep.getSize();
		Object generatedClustlo = dep.getClustlo();
		Object generatedClusthi = dep.getClusthi();
		while (1) {
			if (s == 0) {
				return -/* Not found */2;
			}  else if (s == (libfat_sector_t)-1) {
				return -/* Error */1;
			} 
			dep = fs.libfat_get_sector(s);
			if (!dep) {
				return -/* Read error */1;
			} 
			for (nent = 0; nent < ModernizedCProgram.LIBFAT_SECTOR_SIZE; nent += /*Error: Unsupported expression*/) {
				if (!/*Error: Function owner not recognized*/memcmp(generatedName, name, 11)) {
					if (direntry) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedEntry, dep, /*Error: sizeof expression not supported yet*/);
						direntry.setSector(s);
						direntry.setOffset(nent);
					} 
					if (ModernizedCProgram.read32(generatedSize) == 0) {
						return /* An empty file has no clusters */0;
					} else {
							return ModernizedCProgram.read16(generatedClustlo) + (ModernizedCProgram.read16(generatedClusthi) << 16);
					} 
				} 
				if (generatedName[0] == 0) {
					return -/* Hit high water mark */2;
				} 
				dep++;
			}
			s = fs.libfat_nextsector(s);
		}
	}
	public static void md5_init() {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ctx, 0, /*Error: sizeof expression not supported yet*/);
		Object generatedState = this.getState();
		generatedState[0] = -1024;
		generatedState[1] = -1024;
		generatedState[2] = -1024;
		generatedState[3] = -1024;
	}
	public static void sha1_init() {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ctx, 0, /*Error: sizeof expression not supported yet*/);
		Object generatedState = this.getState();
		generatedState[0] = -1024;
		generatedState[1] = -1024;
		generatedState[2] = -1024;
		generatedState[3] = -1024;
		generatedState[4] = -1024;
	}
	public static void sha256_init() {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ctx, 0, /*Error: sizeof expression not supported yet*/);
		Object generatedState = this.getState();
		generatedState[0] = -1024;
		generatedState[1] = -1024;
		generatedState[2] = -1024;
		generatedState[3] = -1024;
		generatedState[4] = -1024;
		generatedState[5] = -1024;
		generatedState[6] = -1024;
		generatedState[7] = -1024;
	}
	/* Transform the message X which consists of 16 32-bit-words (SHA-1) */
	public static void sha1_transform(Object data) {
		uint32_t a = new uint32_t();
		uint32_t b = new uint32_t();
		uint32_t c = new uint32_t();
		uint32_t d = new uint32_t();
		uint32_t e = new uint32_t();
		uint32_t tm = new uint32_t();
		uint32_t[] x = new uint32_t();
		Object generatedState = this.getState();
		a = generatedState[/* get values from the chaining vars */0];
		b = generatedState[1];
		c = generatedState[2];
		d = generatedState[3];
		e = generatedState[4];
		{ 
			int k;
			for (k = 0; k < 16; k += 4) {
				byte p2 = data + k * 4;
				x[k] = /*Error: Function owner not recognized*/__builtin_bswap32((uint32_t)(uint8_t)(p2));
				x[k + 1] = /*Error: Function owner not recognized*/__builtin_bswap32((uint32_t)(uint8_t)(p2 + 4));
				x[k + 2] = /*Error: Function owner not recognized*/__builtin_bswap32((uint32_t)(uint8_t)(p2 + 8));
				x[k + 3] = /*Error: Function owner not recognized*/__builtin_bswap32((uint32_t)(uint8_t)(p2 + 12));
			}
		}
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (d ^ (b & (c ^ d))) + -1024 + x[0];
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (c ^ (a & (b ^ c))) + -1024 + x[1];
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (b ^ (e & (a ^ b))) + -1024 + x[2];
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (a ^ (d & (e ^ a))) + -1024 + x[3];
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (e ^ (c & (d ^ e))) + -1024 + x[4];
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (d ^ (b & (c ^ d))) + -1024 + x[5];
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (c ^ (a & (b ^ c))) + -1024 + x[6];
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (b ^ (e & (a ^ b))) + -1024 + x[7];
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (a ^ (d & (e ^ a))) + -1024 + x[8];
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (e ^ (c & (d ^ e))) + -1024 + x[9];
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (d ^ (b & (c ^ d))) + -1024 + x[10];
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (c ^ (a & (b ^ c))) + -1024 + x[11];
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (b ^ (e & (a ^ b))) + -1024 + x[12];
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (a ^ (d & (e ^ a))) + -1024 + x[13];
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (e ^ (c & (d ^ e))) + -1024 + x[14];
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (d ^ (b & (c ^ d))) + -1024 + x[15];
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (c ^ (a & (b ^ c))) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (b ^ (e & (a ^ b))) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (a ^ (d & (e ^ a))) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (e ^ (c & (d ^ e))) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (b ^ c ^ d) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (a ^ b ^ c) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (e ^ a ^ b) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (d ^ e ^ a) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (c ^ d ^ e) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (b ^ c ^ d) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (a ^ b ^ c) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (e ^ a ^ b) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (d ^ e ^ a) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (c ^ d ^ e) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (b ^ c ^ d) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (a ^ b ^ c) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (e ^ a ^ b) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (d ^ e ^ a) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (c ^ d ^ e) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (b ^ c ^ d) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (a ^ b ^ c) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (e ^ a ^ b) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (d ^ e ^ a) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (c ^ d ^ e) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + ((b & c) | (d & (b | c))) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + ((a & b) | (c & (a | b))) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + ((e & a) | (b & (e | a))) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + ((d & e) | (a & (d | e))) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + ((c & d) | (e & (c | d))) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + ((b & c) | (d & (b | c))) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + ((a & b) | (c & (a | b))) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + ((e & a) | (b & (e | a))) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + ((d & e) | (a & (d | e))) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + ((c & d) | (e & (c | d))) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + ((b & c) | (d & (b | c))) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + ((a & b) | (c & (a | b))) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + ((e & a) | (b & (e | a))) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + ((d & e) | (a & (d | e))) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + ((c & d) | (e & (c | d))) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + ((b & c) | (d & (b | c))) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + ((a & b) | (c & (a | b))) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + ((e & a) | (b & (e | a))) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + ((d & e) | (a & (d | e))) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + ((c & d) | (e & (c | d))) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (b ^ c ^ d) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (a ^ b ^ c) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (e ^ a ^ b) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (d ^ e ^ a) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (c ^ d ^ e) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (b ^ c ^ d) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (a ^ b ^ c) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (e ^ a ^ b) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (d ^ e ^ a) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (c ^ d ^ e) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (b ^ c ^ d) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (a ^ b ^ c) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (e ^ a ^ b) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (d ^ e ^ a) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (c ^ d ^ e) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		do {
			e += (((a) << (true)) | ((a) >> (32 - (true)))) + (b ^ c ^ d) + -1024 + ();
			b = (((b) << (true)) | ((b) >> (32 - (true))));
		} while (0);
		do {
			d += (((e) << (true)) | ((e) >> (32 - (true)))) + (a ^ b ^ c) + -1024 + ();
			a = (((a) << (true)) | ((a) >> (32 - (true))));
		} while (0);
		do {
			c += (((d) << (true)) | ((d) >> (32 - (true)))) + (e ^ a ^ b) + -1024 + ();
			e = (((e) << (true)) | ((e) >> (32 - (true))));
		} while (0);
		do {
			b += (((c) << (true)) | ((c) >> (32 - (true)))) + (d ^ e ^ a) + -1024 + ();
			d = (((d) << (true)) | ((d) >> (32 - (true))));
		} while (0);
		do {
			a += (((b) << (true)) | ((b) >> (32 - (true)))) + (c ^ d ^ e) + -1024 + ();
			c = (((c) << (true)) | ((c) >> (32 - (true))));
		} while (0);
		generatedState[0] += /* Update chaining vars */a;
		generatedState[1] += b;
		generatedState[2] += c;
		generatedState[3] += d;
		generatedState[4] += e;
	}
	/* Transform the message X which consists of 16 32-bit-words (SHA-256) */
	public static void sha256_transform(Object data) {
		uint32_t a = new uint32_t();
		uint32_t b = new uint32_t();
		uint32_t c = new uint32_t();
		uint32_t d = new uint32_t();
		uint32_t e = new uint32_t();
		uint32_t f = new uint32_t();
		uint32_t g = new uint32_t();
		uint32_t h = new uint32_t();
		uint32_t j = new uint32_t();
		uint32_t[] x = new uint32_t();
		Object generatedState = this.getState();
		a = generatedState[0];
		b = generatedState[1];
		c = generatedState[2];
		d = generatedState[3];
		e = generatedState[4];
		f = generatedState[5];
		g = generatedState[6];
		h = generatedState[7]// Nesting the ROR allows for single register compiler optimizations;// Nesting the ROR allows for single register compiler optimizations
		{ 
			int k;
			for (k = 0; k < 16; k += 4) {
				byte p2 = data + k * 4;
				x[k] = /*Error: Function owner not recognized*/__builtin_bswap32((uint32_t)(uint8_t)(p2));
				x[k + 1] = /*Error: Function owner not recognized*/__builtin_bswap32((uint32_t)(uint8_t)(p2 + 4));
				x[k + 2] = /*Error: Function owner not recognized*/__builtin_bswap32((uint32_t)(uint8_t)(p2 + 8));
				x[k + 3] = /*Error: Function owner not recognized*/__builtin_bswap32((uint32_t)(uint8_t)(p2 + 12));
			}
		}
		for (j = 0; j < 64; j += 16) {
			h += ((((((((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) >> (true)) | (((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) << (32 - (true)))) ^ (e)) >> (true)) | ((((((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) >> (true)) | (((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) << (32 - (true)))) ^ (e)) << (32 - (true))))) + ((g) ^ ((e) & ((f) ^ (g)))) + ModernizedCProgram.K[(false) + (j)] + (j ? (x[0] += (((((((x[((false) - 2) & 15]) >> (true)) | ((x[((false) - 2) & 15]) << (32 - (true)))) ^ (x[((false) - 2) & 15])) >> (true)) | (((((x[((false) - 2) & 15]) >> (true)) | ((x[((false) - 2) & 15]) << (32 - (true)))) ^ (x[((false) - 2) & 15])) << (32 - (true)))) ^ ((x[((false) - 2) & 15]) >> 10)) + x[((false) - 7) & 15] + (((((((x[((false) - 15) & 15]) >> (true)) | ((x[((false) - 15) & 15]) << (32 - (true)))) ^ (x[((false) - 15) & 15])) >> (true)) | (((((x[((false) - 15) & 15]) >> (true)) | ((x[((false) - 15) & 15]) << (32 - (true)))) ^ (x[((false) - 15) & 15])) << (32 - (true)))) ^ ((x[((false) - 15) & 15]) >> 3))) : (x[0]));
			d += h;
			h += ((((((((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) >> (true)) | (((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) << (32 - (true)))) ^ (a)) >> (true)) | ((((((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) >> (true)) | (((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) << (32 - (true)))) ^ (a)) << (32 - (true))))) + (((a) & (b)) | ((c) & ((a) | (b))));
			g += ((((((((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) >> (true)) | (((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) << (32 - (true)))) ^ (d)) >> (true)) | ((((((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) >> (true)) | (((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) << (32 - (true)))) ^ (d)) << (32 - (true))))) + ((f) ^ ((d) & ((e) ^ (f)))) + ModernizedCProgram.K[(0 + 1) + (j)] + (j ? (x[0 + 1] += (((((((x[((0 + 1) - 2) & 15]) >> (true)) | ((x[((0 + 1) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 1) - 2) & 15])) >> (true)) | (((((x[((0 + 1) - 2) & 15]) >> (true)) | ((x[((0 + 1) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 1) - 2) & 15])) << (32 - (true)))) ^ ((x[((0 + 1) - 2) & 15]) >> 10)) + x[((0 + 1) - 7) & 15] + (((((((x[((0 + 1) - 15) & 15]) >> (true)) | ((x[((0 + 1) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 1) - 15) & 15])) >> (true)) | (((((x[((0 + 1) - 15) & 15]) >> (true)) | ((x[((0 + 1) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 1) - 15) & 15])) << (32 - (true)))) ^ ((x[((0 + 1) - 15) & 15]) >> 3))) : (x[0 + 1]));
			c += g;
			g += ((((((((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) >> (true)) | (((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) << (32 - (true)))) ^ (h)) >> (true)) | ((((((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) >> (true)) | (((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) << (32 - (true)))) ^ (h)) << (32 - (true))))) + (((h) & (a)) | ((b) & ((h) | (a))));
			f += ((((((((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) >> (true)) | (((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) << (32 - (true)))) ^ (c)) >> (true)) | ((((((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) >> (true)) | (((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) << (32 - (true)))) ^ (c)) << (32 - (true))))) + ((e) ^ ((c) & ((d) ^ (e)))) + ModernizedCProgram.K[(0 + 2) + (j)] + (j ? (x[0 + 2] += (((((((x[((0 + 2) - 2) & 15]) >> (true)) | ((x[((0 + 2) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 2) - 2) & 15])) >> (true)) | (((((x[((0 + 2) - 2) & 15]) >> (true)) | ((x[((0 + 2) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 2) - 2) & 15])) << (32 - (true)))) ^ ((x[((0 + 2) - 2) & 15]) >> 10)) + x[((0 + 2) - 7) & 15] + (((((((x[((0 + 2) - 15) & 15]) >> (true)) | ((x[((0 + 2) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 2) - 15) & 15])) >> (true)) | (((((x[((0 + 2) - 15) & 15]) >> (true)) | ((x[((0 + 2) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 2) - 15) & 15])) << (32 - (true)))) ^ ((x[((0 + 2) - 15) & 15]) >> 3))) : (x[0 + 2]));
			b += f;
			f += ((((((((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) >> (true)) | (((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) << (32 - (true)))) ^ (g)) >> (true)) | ((((((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) >> (true)) | (((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) << (32 - (true)))) ^ (g)) << (32 - (true))))) + (((g) & (h)) | ((a) & ((g) | (h))));
			e += ((((((((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) >> (true)) | (((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) << (32 - (true)))) ^ (b)) >> (true)) | ((((((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) >> (true)) | (((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) << (32 - (true)))) ^ (b)) << (32 - (true))))) + ((d) ^ ((b) & ((c) ^ (d)))) + ModernizedCProgram.K[(0 + 3) + (j)] + (j ? (x[0 + 3] += (((((((x[((0 + 3) - 2) & 15]) >> (true)) | ((x[((0 + 3) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 3) - 2) & 15])) >> (true)) | (((((x[((0 + 3) - 2) & 15]) >> (true)) | ((x[((0 + 3) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 3) - 2) & 15])) << (32 - (true)))) ^ ((x[((0 + 3) - 2) & 15]) >> 10)) + x[((0 + 3) - 7) & 15] + (((((((x[((0 + 3) - 15) & 15]) >> (true)) | ((x[((0 + 3) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 3) - 15) & 15])) >> (true)) | (((((x[((0 + 3) - 15) & 15]) >> (true)) | ((x[((0 + 3) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 3) - 15) & 15])) << (32 - (true)))) ^ ((x[((0 + 3) - 15) & 15]) >> 3))) : (x[0 + 3]));
			a += e;
			e += ((((((((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) >> (true)) | (((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) << (32 - (true)))) ^ (f)) >> (true)) | ((((((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) >> (true)) | (((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) << (32 - (true)))) ^ (f)) << (32 - (true))))) + (((f) & (g)) | ((h) & ((f) | (g))));
			d += ((((((((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) >> (true)) | (((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) << (32 - (true)))) ^ (a)) >> (true)) | ((((((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) >> (true)) | (((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) << (32 - (true)))) ^ (a)) << (32 - (true))))) + ((c) ^ ((a) & ((b) ^ (c)))) + ModernizedCProgram.K[(0 + 4) + (j)] + (j ? (x[0 + 4] += (((((((x[((0 + 4) - 2) & 15]) >> (true)) | ((x[((0 + 4) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 4) - 2) & 15])) >> (true)) | (((((x[((0 + 4) - 2) & 15]) >> (true)) | ((x[((0 + 4) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 4) - 2) & 15])) << (32 - (true)))) ^ ((x[((0 + 4) - 2) & 15]) >> 10)) + x[((0 + 4) - 7) & 15] + (((((((x[((0 + 4) - 15) & 15]) >> (true)) | ((x[((0 + 4) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 4) - 15) & 15])) >> (true)) | (((((x[((0 + 4) - 15) & 15]) >> (true)) | ((x[((0 + 4) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 4) - 15) & 15])) << (32 - (true)))) ^ ((x[((0 + 4) - 15) & 15]) >> 3))) : (x[0 + 4]));
			h += d;
			d += ((((((((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) >> (true)) | (((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) << (32 - (true)))) ^ (e)) >> (true)) | ((((((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) >> (true)) | (((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) << (32 - (true)))) ^ (e)) << (32 - (true))))) + (((e) & (f)) | ((g) & ((e) | (f))));
			c += ((((((((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) >> (true)) | (((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) << (32 - (true)))) ^ (h)) >> (true)) | ((((((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) >> (true)) | (((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) << (32 - (true)))) ^ (h)) << (32 - (true))))) + ((b) ^ ((h) & ((a) ^ (b)))) + ModernizedCProgram.K[(0 + 5) + (j)] + (j ? (x[0 + 5] += (((((((x[((0 + 5) - 2) & 15]) >> (true)) | ((x[((0 + 5) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 5) - 2) & 15])) >> (true)) | (((((x[((0 + 5) - 2) & 15]) >> (true)) | ((x[((0 + 5) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 5) - 2) & 15])) << (32 - (true)))) ^ ((x[((0 + 5) - 2) & 15]) >> 10)) + x[((0 + 5) - 7) & 15] + (((((((x[((0 + 5) - 15) & 15]) >> (true)) | ((x[((0 + 5) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 5) - 15) & 15])) >> (true)) | (((((x[((0 + 5) - 15) & 15]) >> (true)) | ((x[((0 + 5) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 5) - 15) & 15])) << (32 - (true)))) ^ ((x[((0 + 5) - 15) & 15]) >> 3))) : (x[0 + 5]));
			g += c;
			c += ((((((((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) >> (true)) | (((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) << (32 - (true)))) ^ (d)) >> (true)) | ((((((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) >> (true)) | (((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) << (32 - (true)))) ^ (d)) << (32 - (true))))) + (((d) & (e)) | ((f) & ((d) | (e))));
			b += ((((((((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) >> (true)) | (((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) << (32 - (true)))) ^ (g)) >> (true)) | ((((((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) >> (true)) | (((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) << (32 - (true)))) ^ (g)) << (32 - (true))))) + ((a) ^ ((g) & ((h) ^ (a)))) + ModernizedCProgram.K[(0 + 6) + (j)] + (j ? (x[0 + 6] += (((((((x[((0 + 6) - 2) & 15]) >> (true)) | ((x[((0 + 6) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 6) - 2) & 15])) >> (true)) | (((((x[((0 + 6) - 2) & 15]) >> (true)) | ((x[((0 + 6) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 6) - 2) & 15])) << (32 - (true)))) ^ ((x[((0 + 6) - 2) & 15]) >> 10)) + x[((0 + 6) - 7) & 15] + (((((((x[((0 + 6) - 15) & 15]) >> (true)) | ((x[((0 + 6) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 6) - 15) & 15])) >> (true)) | (((((x[((0 + 6) - 15) & 15]) >> (true)) | ((x[((0 + 6) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 6) - 15) & 15])) << (32 - (true)))) ^ ((x[((0 + 6) - 15) & 15]) >> 3))) : (x[0 + 6]));
			f += b;
			b += ((((((((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) >> (true)) | (((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) << (32 - (true)))) ^ (c)) >> (true)) | ((((((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) >> (true)) | (((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) << (32 - (true)))) ^ (c)) << (32 - (true))))) + (((c) & (d)) | ((e) & ((c) | (d))));
			a += ((((((((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) >> (true)) | (((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) << (32 - (true)))) ^ (f)) >> (true)) | ((((((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) >> (true)) | (((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) << (32 - (true)))) ^ (f)) << (32 - (true))))) + ((h) ^ ((f) & ((g) ^ (h)))) + ModernizedCProgram.K[(0 + 7) + (j)] + (j ? (x[0 + 7] += (((((((x[((0 + 7) - 2) & 15]) >> (true)) | ((x[((0 + 7) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 7) - 2) & 15])) >> (true)) | (((((x[((0 + 7) - 2) & 15]) >> (true)) | ((x[((0 + 7) - 2) & 15]) << (32 - (true)))) ^ (x[((0 + 7) - 2) & 15])) << (32 - (true)))) ^ ((x[((0 + 7) - 2) & 15]) >> 10)) + x[((0 + 7) - 7) & 15] + (((((((x[((0 + 7) - 15) & 15]) >> (true)) | ((x[((0 + 7) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 7) - 15) & 15])) >> (true)) | (((((x[((0 + 7) - 15) & 15]) >> (true)) | ((x[((0 + 7) - 15) & 15]) << (32 - (true)))) ^ (x[((0 + 7) - 15) & 15])) << (32 - (true)))) ^ ((x[((0 + 7) - 15) & 15]) >> 3))) : (x[0 + 7]));
			e += a;
			a += ((((((((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) >> (true)) | (((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) << (32 - (true)))) ^ (b)) >> (true)) | ((((((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) >> (true)) | (((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) << (32 - (true)))) ^ (b)) << (32 - (true))))) + (((b) & (c)) | ((d) & ((b) | (c))));
			h += ((((((((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) >> (true)) | (((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) << (32 - (true)))) ^ (e)) >> (true)) | ((((((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) >> (true)) | (((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) << (32 - (true)))) ^ (e)) << (32 - (true))))) + ((g) ^ ((e) & ((f) ^ (g)))) + ModernizedCProgram.K[(true) + (j)] + (j ? (x[8] += (((((((x[((true) - 2) & 15]) >> (true)) | ((x[((true) - 2) & 15]) << (32 - (true)))) ^ (x[((true) - 2) & 15])) >> (true)) | (((((x[((true) - 2) & 15]) >> (true)) | ((x[((true) - 2) & 15]) << (32 - (true)))) ^ (x[((true) - 2) & 15])) << (32 - (true)))) ^ ((x[((true) - 2) & 15]) >> 10)) + x[((true) - 7) & 15] + (((((((x[((true) - 15) & 15]) >> (true)) | ((x[((true) - 15) & 15]) << (32 - (true)))) ^ (x[((true) - 15) & 15])) >> (true)) | (((((x[((true) - 15) & 15]) >> (true)) | ((x[((true) - 15) & 15]) << (32 - (true)))) ^ (x[((true) - 15) & 15])) << (32 - (true)))) ^ ((x[((true) - 15) & 15]) >> 3))) : (x[8]));
			d += h;
			h += ((((((((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) >> (true)) | (((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) << (32 - (true)))) ^ (a)) >> (true)) | ((((((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) >> (true)) | (((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) << (32 - (true)))) ^ (a)) << (32 - (true))))) + (((a) & (b)) | ((c) & ((a) | (b))));
			g += ((((((((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) >> (true)) | (((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) << (32 - (true)))) ^ (d)) >> (true)) | ((((((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) >> (true)) | (((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) << (32 - (true)))) ^ (d)) << (32 - (true))))) + ((f) ^ ((d) & ((e) ^ (f)))) + ModernizedCProgram.K[(8 + 1) + (j)] + (j ? (x[8 + 1] += (((((((x[((8 + 1) - 2) & 15]) >> (true)) | ((x[((8 + 1) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 1) - 2) & 15])) >> (true)) | (((((x[((8 + 1) - 2) & 15]) >> (true)) | ((x[((8 + 1) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 1) - 2) & 15])) << (32 - (true)))) ^ ((x[((8 + 1) - 2) & 15]) >> 10)) + x[((8 + 1) - 7) & 15] + (((((((x[((8 + 1) - 15) & 15]) >> (true)) | ((x[((8 + 1) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 1) - 15) & 15])) >> (true)) | (((((x[((8 + 1) - 15) & 15]) >> (true)) | ((x[((8 + 1) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 1) - 15) & 15])) << (32 - (true)))) ^ ((x[((8 + 1) - 15) & 15]) >> 3))) : (x[8 + 1]));
			c += g;
			g += ((((((((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) >> (true)) | (((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) << (32 - (true)))) ^ (h)) >> (true)) | ((((((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) >> (true)) | (((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) << (32 - (true)))) ^ (h)) << (32 - (true))))) + (((h) & (a)) | ((b) & ((h) | (a))));
			f += ((((((((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) >> (true)) | (((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) << (32 - (true)))) ^ (c)) >> (true)) | ((((((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) >> (true)) | (((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) << (32 - (true)))) ^ (c)) << (32 - (true))))) + ((e) ^ ((c) & ((d) ^ (e)))) + ModernizedCProgram.K[(8 + 2) + (j)] + (j ? (x[8 + 2] += (((((((x[((8 + 2) - 2) & 15]) >> (true)) | ((x[((8 + 2) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 2) - 2) & 15])) >> (true)) | (((((x[((8 + 2) - 2) & 15]) >> (true)) | ((x[((8 + 2) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 2) - 2) & 15])) << (32 - (true)))) ^ ((x[((8 + 2) - 2) & 15]) >> 10)) + x[((8 + 2) - 7) & 15] + (((((((x[((8 + 2) - 15) & 15]) >> (true)) | ((x[((8 + 2) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 2) - 15) & 15])) >> (true)) | (((((x[((8 + 2) - 15) & 15]) >> (true)) | ((x[((8 + 2) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 2) - 15) & 15])) << (32 - (true)))) ^ ((x[((8 + 2) - 15) & 15]) >> 3))) : (x[8 + 2]));
			b += f;
			f += ((((((((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) >> (true)) | (((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) << (32 - (true)))) ^ (g)) >> (true)) | ((((((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) >> (true)) | (((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) << (32 - (true)))) ^ (g)) << (32 - (true))))) + (((g) & (h)) | ((a) & ((g) | (h))));
			e += ((((((((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) >> (true)) | (((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) << (32 - (true)))) ^ (b)) >> (true)) | ((((((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) >> (true)) | (((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) << (32 - (true)))) ^ (b)) << (32 - (true))))) + ((d) ^ ((b) & ((c) ^ (d)))) + ModernizedCProgram.K[(8 + 3) + (j)] + (j ? (x[8 + 3] += (((((((x[((8 + 3) - 2) & 15]) >> (true)) | ((x[((8 + 3) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 3) - 2) & 15])) >> (true)) | (((((x[((8 + 3) - 2) & 15]) >> (true)) | ((x[((8 + 3) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 3) - 2) & 15])) << (32 - (true)))) ^ ((x[((8 + 3) - 2) & 15]) >> 10)) + x[((8 + 3) - 7) & 15] + (((((((x[((8 + 3) - 15) & 15]) >> (true)) | ((x[((8 + 3) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 3) - 15) & 15])) >> (true)) | (((((x[((8 + 3) - 15) & 15]) >> (true)) | ((x[((8 + 3) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 3) - 15) & 15])) << (32 - (true)))) ^ ((x[((8 + 3) - 15) & 15]) >> 3))) : (x[8 + 3]));
			a += e;
			e += ((((((((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) >> (true)) | (((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) << (32 - (true)))) ^ (f)) >> (true)) | ((((((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) >> (true)) | (((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) << (32 - (true)))) ^ (f)) << (32 - (true))))) + (((f) & (g)) | ((h) & ((f) | (g))));
			d += ((((((((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) >> (true)) | (((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) << (32 - (true)))) ^ (a)) >> (true)) | ((((((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) >> (true)) | (((((a) >> (true)) | ((a) << (32 - (true)))) ^ (a)) << (32 - (true)))) ^ (a)) << (32 - (true))))) + ((c) ^ ((a) & ((b) ^ (c)))) + ModernizedCProgram.K[(8 + 4) + (j)] + (j ? (x[8 + 4] += (((((((x[((8 + 4) - 2) & 15]) >> (true)) | ((x[((8 + 4) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 4) - 2) & 15])) >> (true)) | (((((x[((8 + 4) - 2) & 15]) >> (true)) | ((x[((8 + 4) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 4) - 2) & 15])) << (32 - (true)))) ^ ((x[((8 + 4) - 2) & 15]) >> 10)) + x[((8 + 4) - 7) & 15] + (((((((x[((8 + 4) - 15) & 15]) >> (true)) | ((x[((8 + 4) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 4) - 15) & 15])) >> (true)) | (((((x[((8 + 4) - 15) & 15]) >> (true)) | ((x[((8 + 4) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 4) - 15) & 15])) << (32 - (true)))) ^ ((x[((8 + 4) - 15) & 15]) >> 3))) : (x[8 + 4]));
			h += d;
			d += ((((((((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) >> (true)) | (((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) << (32 - (true)))) ^ (e)) >> (true)) | ((((((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) >> (true)) | (((((e) >> (true)) | ((e) << (32 - (true)))) ^ (e)) << (32 - (true)))) ^ (e)) << (32 - (true))))) + (((e) & (f)) | ((g) & ((e) | (f))));
			c += ((((((((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) >> (true)) | (((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) << (32 - (true)))) ^ (h)) >> (true)) | ((((((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) >> (true)) | (((((h) >> (true)) | ((h) << (32 - (true)))) ^ (h)) << (32 - (true)))) ^ (h)) << (32 - (true))))) + ((b) ^ ((h) & ((a) ^ (b)))) + ModernizedCProgram.K[(8 + 5) + (j)] + (j ? (x[8 + 5] += (((((((x[((8 + 5) - 2) & 15]) >> (true)) | ((x[((8 + 5) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 5) - 2) & 15])) >> (true)) | (((((x[((8 + 5) - 2) & 15]) >> (true)) | ((x[((8 + 5) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 5) - 2) & 15])) << (32 - (true)))) ^ ((x[((8 + 5) - 2) & 15]) >> 10)) + x[((8 + 5) - 7) & 15] + (((((((x[((8 + 5) - 15) & 15]) >> (true)) | ((x[((8 + 5) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 5) - 15) & 15])) >> (true)) | (((((x[((8 + 5) - 15) & 15]) >> (true)) | ((x[((8 + 5) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 5) - 15) & 15])) << (32 - (true)))) ^ ((x[((8 + 5) - 15) & 15]) >> 3))) : (x[8 + 5]));
			g += c;
			c += ((((((((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) >> (true)) | (((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) << (32 - (true)))) ^ (d)) >> (true)) | ((((((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) >> (true)) | (((((d) >> (true)) | ((d) << (32 - (true)))) ^ (d)) << (32 - (true)))) ^ (d)) << (32 - (true))))) + (((d) & (e)) | ((f) & ((d) | (e))));
			b += ((((((((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) >> (true)) | (((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) << (32 - (true)))) ^ (g)) >> (true)) | ((((((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) >> (true)) | (((((g) >> (true)) | ((g) << (32 - (true)))) ^ (g)) << (32 - (true)))) ^ (g)) << (32 - (true))))) + ((a) ^ ((g) & ((h) ^ (a)))) + ModernizedCProgram.K[(8 + 6) + (j)] + (j ? (x[8 + 6] += (((((((x[((8 + 6) - 2) & 15]) >> (true)) | ((x[((8 + 6) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 6) - 2) & 15])) >> (true)) | (((((x[((8 + 6) - 2) & 15]) >> (true)) | ((x[((8 + 6) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 6) - 2) & 15])) << (32 - (true)))) ^ ((x[((8 + 6) - 2) & 15]) >> 10)) + x[((8 + 6) - 7) & 15] + (((((((x[((8 + 6) - 15) & 15]) >> (true)) | ((x[((8 + 6) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 6) - 15) & 15])) >> (true)) | (((((x[((8 + 6) - 15) & 15]) >> (true)) | ((x[((8 + 6) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 6) - 15) & 15])) << (32 - (true)))) ^ ((x[((8 + 6) - 15) & 15]) >> 3))) : (x[8 + 6]));
			f += b;
			b += ((((((((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) >> (true)) | (((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) << (32 - (true)))) ^ (c)) >> (true)) | ((((((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) >> (true)) | (((((c) >> (true)) | ((c) << (32 - (true)))) ^ (c)) << (32 - (true)))) ^ (c)) << (32 - (true))))) + (((c) & (d)) | ((e) & ((c) | (d))));
			a += ((((((((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) >> (true)) | (((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) << (32 - (true)))) ^ (f)) >> (true)) | ((((((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) >> (true)) | (((((f) >> (true)) | ((f) << (32 - (true)))) ^ (f)) << (32 - (true)))) ^ (f)) << (32 - (true))))) + ((h) ^ ((f) & ((g) ^ (h)))) + ModernizedCProgram.K[(8 + 7) + (j)] + (j ? (x[8 + 7] += (((((((x[((8 + 7) - 2) & 15]) >> (true)) | ((x[((8 + 7) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 7) - 2) & 15])) >> (true)) | (((((x[((8 + 7) - 2) & 15]) >> (true)) | ((x[((8 + 7) - 2) & 15]) << (32 - (true)))) ^ (x[((8 + 7) - 2) & 15])) << (32 - (true)))) ^ ((x[((8 + 7) - 2) & 15]) >> 10)) + x[((8 + 7) - 7) & 15] + (((((((x[((8 + 7) - 15) & 15]) >> (true)) | ((x[((8 + 7) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 7) - 15) & 15])) >> (true)) | (((((x[((8 + 7) - 15) & 15]) >> (true)) | ((x[((8 + 7) - 15) & 15]) << (32 - (true)))) ^ (x[((8 + 7) - 15) & 15])) << (32 - (true)))) ^ ((x[((8 + 7) - 15) & 15]) >> 3))) : (x[8 + 7]));
			e += a;
			a += ((((((((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) >> (true)) | (((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) << (32 - (true)))) ^ (b)) >> (true)) | ((((((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) >> (true)) | (((((b) >> (true)) | ((b) << (32 - (true)))) ^ (b)) << (32 - (true)))) ^ (b)) << (32 - (true))))) + (((b) & (c)) | ((d) & ((b) | (c))));
		}
		generatedState[0] += a;
		generatedState[1] += b;
		generatedState[2] += c;
		generatedState[3] += d;
		generatedState[4] += e;
		generatedState[5] += f;
		generatedState[6] += g;
		generatedState[7] += h;
	}
	/* Transform the message X which consists of 16 32-bit-words (MD5) */
	public static void md5_transform(Object data) {
		uint32_t a = new uint32_t();
		uint32_t b = new uint32_t();
		uint32_t c = new uint32_t();
		uint32_t d = new uint32_t();
		uint32_t[] x = new uint32_t();
		Object generatedState = this.getState();
		a = generatedState[0];
		b = generatedState[1];
		c = generatedState[2];
		d = generatedState[3];
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(x, data, /*Error: sizeof expression not supported yet*/);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		do {
			();
		} while (0);
		generatedState[0] += /* Update chaining vars */a;
		generatedState[1] += b;
		generatedState[2] += c;
		generatedState[3] += d;
	}
	/* Update the message digest with the contents of the buffer (SHA-1) */
	public static void sha1_write(Object buf, Object len) {
		Object generatedBytecount = this.getBytecount();
		size_t num = generatedBytecount & -1024;
		generatedBytecount += /* Update bytecount */len;
		Object generatedBuf = this.getBuf();
		if (/* Handle any leading odd-sized chunks */num) {
			byte p = generatedBuf + num;
			num = 64 - num;
			if (len < num) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p, buf, len);
				return /*Error: Unsupported expression*/;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p, buf, num);
			ctx.sha1_transform(generatedBuf);
			buf += num;
			len -= num;
		} 
		while (len >= /* Process data in 64-byte chunks */64) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_prefetch(buf + 64, 0, 0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_prefetch(buf + 64 + 32, 0, 0);
			} while (0);
			ctx.sha1_transform(buf);
			buf += 64;
			len -= 64;
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBuf, buf, /* Handle any remaining bytes of data. */len);
	}
	/* Update the message digest with the contents of the buffer (SHA-256) */
	public static void sha256_write(Object buf, Object len) {
		Object generatedBytecount = this.getBytecount();
		size_t num = generatedBytecount & -1024;
		generatedBytecount += /* Update bytecount */len;
		Object generatedBuf = this.getBuf();
		if (/* Handle any leading odd-sized chunks */num) {
			byte p = generatedBuf + num;
			num = 64 - num;
			if (len < num) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p, buf, len);
				return /*Error: Unsupported expression*/;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p, buf, num);
			ctx.sha256_transform(generatedBuf);
			buf += num;
			len -= num;
		} 
		while (len >= /* Process data in 64-byte chunks */64) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_prefetch(buf + 64, 0, 0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_prefetch(buf + 64 + 32, 0, 0);
			} while (0);
			ctx.sha256_transform(buf);
			buf += 64;
			len -= 64;
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBuf, buf, /* Handle any remaining bytes of data. */len);
	}
	/* Update the message digest with the contents of the buffer (MD5) */
	public static void md5_write(Object buf, Object len) {
		Object generatedBytecount = this.getBytecount();
		size_t num = generatedBytecount & -1024;
		generatedBytecount += /* Update bytecount */len;
		Object generatedBuf = this.getBuf();
		if (/* Handle any leading odd-sized chunks */num) {
			byte p = generatedBuf + num;
			num = 64 - num;
			if (len < num) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p, buf, num);
				return /*Error: Unsupported expression*/;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p, buf, num);
			ctx.md5_transform(generatedBuf);
			buf += num;
			len -= num;
		} 
		while (len >= /* Process data in 64-byte chunks */64) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_prefetch(buf + 64, 0, 0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_prefetch(buf + 64 + 32, 0, 0);
			} while (0);
			ctx.md5_transform(buf);
			buf += 64;
			len -= 64;
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBuf, buf, /* Handle any remaining bytes of data. */len);
	}
	/* Finalize the computation and write the digest in ctx->state[] (SHA-1) */
	public static void sha1_final() {
		Object generatedBytecount = this.getBytecount();
		uint64_t bitcount = generatedBytecount << 3;
		size_t pos = ((size_t)generatedBytecount) & -1024;
		byte p;
		Object generatedBuf = this.getBuf();
		generatedBuf[pos++] = -1024;
		while (pos != (64 - /* Pad whatever data is left in the buffer */8)) {
			pos &=  -1024;
			if (pos == 0) {
				ctx.sha1_transform(generatedBuf);
			} 
			generatedBuf[pos++] = 0;
		}
		generatedBuf[63] = (byte)/* Append to the padding the total message's length in bits and transform */bitcount;
		generatedBuf[62] = (byte)(bitcount >> 8);
		generatedBuf[61] = (byte)(bitcount >> 16);
		generatedBuf[60] = (byte)(bitcount >> 24);
		generatedBuf[59] = (byte)(bitcount >> 32);
		generatedBuf[58] = (byte)(bitcount >> 40);
		generatedBuf[57] = (byte)(bitcount >> 48);
		generatedBuf[56] = (byte)(bitcount >> 56);
		ctx.sha1_transform(generatedBuf);
		p = generatedBuf;
		Object generatedState = this.getState();
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[0]);
			p += 4;
		} while (0);
		;
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[1]);
			p += 4;
		} while (0);
		;
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[2]);
			p += 4;
		} while (0);
		;
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[3]);
			p += 4;
		} while (0);
		;
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[4]);
			p += 4;
		} while (0);
		;
	}
	/* Finalize the computation and write the digest in ctx->state[] (SHA-256) */
	public static void sha256_final() {
		Object generatedBytecount = this.getBytecount();
		uint64_t bitcount = generatedBytecount << 3;
		size_t pos = ((size_t)generatedBytecount) & -1024;
		byte p;
		Object generatedBuf = this.getBuf();
		generatedBuf[pos++] = -1024;
		while (pos != (64 - /* Pad whatever data is left in the buffer */8)) {
			pos &=  -1024;
			if (pos == 0) {
				ctx.sha256_transform(generatedBuf);
			} 
			generatedBuf[pos++] = 0;
		}
		generatedBuf[63] = (byte)/* Append to the padding the total message's length in bits and transform */bitcount;
		generatedBuf[62] = (byte)(bitcount >> 8);
		generatedBuf[61] = (byte)(bitcount >> 16);
		generatedBuf[60] = (byte)(bitcount >> 24);
		generatedBuf[59] = (byte)(bitcount >> 32);
		generatedBuf[58] = (byte)(bitcount >> 40);
		generatedBuf[57] = (byte)(bitcount >> 48);
		generatedBuf[56] = (byte)(bitcount >> 56);
		ctx.sha256_transform(generatedBuf);
		p = generatedBuf;
		Object generatedState = this.getState();
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[0]);
			p += 4;
		} while (0);
		;
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[1]);
			p += 4;
		} while (0);
		;
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[2]);
			p += 4;
		} while (0);
		;
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[3]);
			p += 4;
		} while (0);
		;
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[4]);
			p += 4;
		} while (0);
		;
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[5]);
			p += 4;
		} while (0);
		;
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[6]);
			p += 4;
		} while (0);
		;
		do {
			((uint32_t)(Object)(p)) = /*Error: Function owner not recognized*/__builtin_bswap32(generatedState[7]);
			p += 4;
		} while (0);
		;
	}
	/* Finalize the computation and write the digest in ctx->state[] (MD5) */
	public static void md5_final() {
		Object generatedBytecount = this.getBytecount();
		size_t count = ((size_t)generatedBytecount) & -1024;
		uint64_t bitcount = generatedBytecount << 3;
		byte p;
		/* Set the first char of padding to 0x80.
			 * This is safe since there is always at least one byte free
			 */
		Object generatedBuf = this.getBuf();
		p = generatedBuf + count;
		p++ = -1024;
		count = 64 - 1 - /* Bytes of padding needed to make 64 bytes */count;
		if (count < /* Pad out to 56 mod 64 */8) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(p, 0, /* Two lots of padding: Pad the first block to 64 bytes */count);
			ctx.md5_transform(generatedBuf);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedBuf, 0, /* Now fill the next block with 56 bytes */56);
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(p, 0, count - /* Pad block to 56 bytes */8);
		} 
		generatedBuf[56] = (byte)/* append the 64 bit count (little endian) */bitcount;
		generatedBuf[57] = (byte)(bitcount >> 8);
		generatedBuf[58] = (byte)(bitcount >> 16);
		generatedBuf[59] = (byte)(bitcount >> 24);
		generatedBuf[60] = (byte)(bitcount >> 32);
		generatedBuf[61] = (byte)(bitcount >> 40);
		generatedBuf[62] = (byte)(bitcount >> 48);
		generatedBuf[63] = (byte)(bitcount >> 56);
		ctx.md5_transform(generatedBuf);
		p = generatedBuf;
		Object generatedState = this.getState();
		do {
			(uint32_t)p = generatedState[0];
			p += 4;
		} while (0);
		do {
			(uint32_t)p = generatedState[1];
			p += 4;
		} while (0);
		do {
			(uint32_t)p = generatedState[2];
			p += 4;
		} while (0);
		do {
			(uint32_t)p = generatedState[3];
			p += 4;
		} while (0);//#define NULL_TEST// These 'null' calls are useful for testing load balancing and individual algorithm speed
	}
	// Compute an individual checksum without threading or buffering, for a single file
	public static Object HashFile(Object type, Object path, Object sum) {
		BOOL r = 0;
		SUM_CONTEXT sum_ctx = new SUM_CONTEXT(new SUM_CONTEXT(0));
		HANDLE h = (HANDLE)(true);
		DWORD rs = 0;
		uint64_t rb = new uint64_t();
		byte[] buf = new byte[4096];
		if ((type >= checksum_type.CHECKSUM_MAX) || (path == ((Object)0)) || (sum == ((Object)0))) {
			;
		} 
		h = ModernizedCProgram.CreateFileU(path, -1024, -1024, ((Object)0), 3, 134217728, ((Object)0));
		if (h == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Could not open file: %s", ModernizedCProgram.WindowsErrorString());
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(sum_ctx);
		for (rb = 0; /*Error: Unsupported expression*/; rb += rs) {
			if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
				;
			} 
			if (!/*Error: Function owner not recognized*/ReadFile(h, buf, /*Error: sizeof expression not supported yet*/, rs, ((Object)0))) {
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				ModernizedCProgram._uprintf("  Read error: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			if (rs == 0) {
				break;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(sum_ctx, buf, (size_t)rs);
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(sum_ctx);
		Object generatedBuf = sum_ctx.getBuf();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(sum, generatedBuf, ModernizedCProgram.sum_count[type]);
		r = 1;
		return r;
	}
	public static Object HashBuffer(Object type, Object buf, Object len, Object sum) {
		BOOL r = 0;
		SUM_CONTEXT sum_ctx = new SUM_CONTEXT(new SUM_CONTEXT(0));
		if ((type >= checksum_type.CHECKSUM_MAX) || (sum == ((Object)0))) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(sum_ctx);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(sum_ctx, buf, len);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(sum_ctx);
		Object generatedBuf = sum_ctx.getBuf();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(sum, generatedBuf, ModernizedCProgram.sum_count[type]);
		r = 1;
	}
	public static Object ChecksumCallback(Object hDlg, Object message, Object wParam, Object lParam) {
		int i;
		int dw;
		int dh;
		RECT rc = new RECT();
		HFONT hFont = new HFONT();
		HDC hDC = new HDC();
		Object generatedRight = rc.getRight();
		Object generatedLeft = rc.getLeft();
		Object generatedBottom = rc.getBottom();
		Object generatedTop = rc.getTop();
		switch (message) {
		case 272:
				ModernizedCProgram.apply_localization(109, hDlg);
				hDC = /*Error: Function owner not recognized*/GetDC(hDlg);
				hFont = /*Error: Function owner not recognized*/CreateFontA(-/*Error: Function owner not recognized*/MulDiv(9, /*Error: Function owner not recognized*/GetDeviceCaps(hDC, 90), 72), 0, 0, 0, 400, 0, 0, 0, 1, 0, 0, 2, 0, "Courier New");
				do {
					if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(hDlg, hDC);
						hDC = ((Object)0);
					} 
				} while (0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendDlgItemMessageA(hDlg, 1071, 48, (WPARAM)hFont, 1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendDlgItemMessageA(hDlg, 1072, 48, (WPARAM)hFont, 1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendDlgItemMessageA(hDlg, 1073, 48, (WPARAM)hFont, 1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowTextA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1071), ModernizedCProgram.sum_str[0]);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowTextA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1072), ModernizedCProgram.sum_str[1]);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowTextA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1073), ModernizedCProgram.sum_str[2]);
				hDC = /*Error: Function owner not recognized*/GetDC(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1071));
				((HFONT)/*Error: Function owner not recognized*/SelectObject((hDC), (HGDIOBJ)(HFONT)(hFont)));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1071), rc);
				dw = generatedRight - generatedLeft;
				dh = generatedBottom - generatedTop;
				ModernizedCProgram.DrawTextU(hDC, ModernizedCProgram.sum_str[0], -1, rc, 1024);
				dw = generatedRight - generatedLeft - dw + 12;
				dh = generatedBottom - generatedTop - dh + 6;
				ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1073), 0, 0, dw, dh, 1.0);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1072), rc);
				dw = generatedRight - generatedLeft;
				ModernizedCProgram.DrawTextU(hDC, ModernizedCProgram.sum_str[1], -1, rc, 1024);
				dw = generatedRight - generatedLeft - dw + 12;
				ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1071), 0, 0, dw, 0, 1.0);
				ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1072), 0, 0, dw, 0, 1.0);
				ModernizedCProgram.ResizeButtonHeight(hDlg, 1);
				do {
					if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1071), hDC);
						hDC = ((Object)0);
					} 
				} while (0);
				for (i = (int)((((byte)ModernizedCProgram.image_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.image_path)); (i > 0) && (ModernizedCProgram.image_path[i] != (byte)'\\'); i--) {
					;
				}
				if (ModernizedCProgram.image_path != ((Object)0)) {
					ModernizedCProgram.SetWindowTextU(hDlg, ModernizedCProgram.image_path[i + 1]);
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hDlg, 40, (WPARAM)/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1), 1);
				ModernizedCProgram.CenterDialog(hDlg, ((Object)0));
				break;
		case 273:
				switch (((WORD)((DWORD)(wParam)))) {
				case 1:
				case 2:
						ModernizedCProgram.reset_localization(109);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EndDialog(hDlg, ((WORD)((DWORD)(wParam))));
						return (INT_PTR)1;
				}
		}
		return (INT_PTR)0;
	}
	// Individual thread that computes one of MD5, SHA1 or SHA256 in parallel
	public static Object IndividualSumThread(Object param) {
		// There's a memset in sum_init, but static analyzers still bug usSUM_CONTEXT sum_ctx = new SUM_CONTEXT(new SUM_CONTEXT(0));
		uint32_t i = (uint32_t)(uintptr_t)param;
		uint32_t j = new uint32_t();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(sum_ctx)// Signal that we're ready to service requests;// Signal that we're ready to service requests
		if (!/*Error: Function owner not recognized*/SetEvent(ModernizedCProgram.thread_ready[i])) {
			;
		} 
		Object generatedBuf = sum_ctx.getBuf();
		// Wait for requestswhile (1) {
			if (/*Error: Function owner not recognized*/WaitForSingleObject(ModernizedCProgram.data_ready[i], 5000) != 0) {
				ModernizedCProgram._uprintf("Failed to wait for event for checksum thread #%d: %s", i, ModernizedCProgram.WindowsErrorString());
				return 1;
			} 
			if (ModernizedCProgram.read_size[ModernizedCProgram.bufnum] != 0) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(sum_ctx, ModernizedCProgram.buffer[ModernizedCProgram.bufnum], (size_t)ModernizedCProgram.read_size[ModernizedCProgram.bufnum]);
				if (!/*Error: Function owner not recognized*/SetEvent(ModernizedCProgram.thread_ready[i])) {
					;
				} 
			} else {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(sum_ctx);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.sum_str[i], 0, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
					for (j = 0; j < ModernizedCProgram.sum_count[i]; j++) {
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.sum_str[i][2 * j], (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/) - 2 * j, "%02x", generatedBuf[j]);
							(ModernizedCProgram.sum_str[i][2 * j])[((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/) - 2 * j) - 1] = 0;
						} while (0);
					}
					return 0;
			} 
		}
		return 1;
	}
	public static Object SumThread(Object param) {
		DWORD_PTR thread_affinity = (DWORD_PTR)param;
		HANDLE[] sum_thread = new HANDLE[]{((Object)0), ((Object)0), ((Object)0)};
		HANDLE h = (HANDLE)(true);
		uint64_t rb = new uint64_t();
		int i;
		int _bufnum;
		int r = -1;
		if ((ModernizedCProgram.image_path == ((Object)0)) || (thread_affinity == ((Object)0))) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExitThread(r);
		} 
		ModernizedCProgram._uprintf("\r\nComputing checksum for '%s'...", ModernizedCProgram.image_path);
		if (thread_affinity[0] != 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetThreadAffinityMask(/*Error: Function owner not recognized*/GetCurrentThread(), thread_affinity[0]);
		} 
		// Use the first affinity mask, as our read thread is the least// CPU intensive (mostly waits on disk I/O or on the other threads)
		for (i = 0; i < checksum_type.CHECKSUM_MAX; i++) {
			ModernizedCProgram.data_ready[i] = /*Error: Function owner not recognized*/CreateEventA(((Object)0), 0, 0, ((Object)0));
			ModernizedCProgram.thread_ready[i] = /*Error: Function owner not recognized*/CreateEventA(((Object)0), 0, 0, ((Object)0));
			if ((ModernizedCProgram.data_ready[i] == ((Object)0)) || (ModernizedCProgram.thread_ready[i] == ((Object)0))) {
				ModernizedCProgram._uprintf("Unable to create checksum thread event: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			sum_thread[i] = /*Error: Function owner not recognized*/CreateThread(((Object)0), 0, IndividualSumThread, (LPVOID)(uintptr_t)i, 0, ((Object)0));
			if (sum_thread[i] == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to start checksum thread #%d", i);
				;
			} 
			if (thread_affinity[i + 1] != 0) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetThreadAffinityMask(sum_thread[i], thread_affinity[i + 1]);
			} 
		}// NB: Can't use a single manual-reset event for data_ready as we// wouldn't be able to ensure the event is reset before the thread
		h = ModernizedCProgram.CreateFileU(ModernizedCProgram.image_path, -1024, -1024, ((Object)0), 3, 134217728, ((Object)0));
		if (h == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Could not open file: %s", ModernizedCProgram.WindowsErrorString());
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
			;
		} 
		ModernizedCProgram.bufnum = 0;
		_bufnum = 0;
		// Don't trigger the first loop break// Don't trigger the first loop breakModernizedCProgram.read_size[0] = 1;
		ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_INIT, (int)0, (uint64_t)(uintptr_t)ModernizedCProgram.hMainDialog, 0);
		;
		for (rb = 0; /*Error: Unsupported expression*/; rb += ModernizedCProgram.read_size[_bufnum]) {
			ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_NOOP_WITH_TASKBAR, 3271, rb, ModernizedCProgram.img_report.getImage_size());
			if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) && (((ModernizedCProgram.FormatStatus) & -1024) == -1024)) {
				;
			} 
			if (rb != 0) {
				ModernizedCProgram.bufnum = _bufnum;
				_bufnum = (ModernizedCProgram.bufnum + 1) % 2;
				for (i = 0; i < checksum_type.CHECKSUM_MAX; i++) {
					if (!/*Error: Function owner not recognized*/SetEvent(ModernizedCProgram.data_ready[i])) {
						ModernizedCProgram._uprintf("Could not signal checksum thread %d: %s", i, ModernizedCProgram.WindowsErrorString());
						;
					} 
				}
			} 
			if (ModernizedCProgram.read_size[ModernizedCProgram.bufnum] == 0) {
				break;
			} 
			if (!/*Error: Function owner not recognized*/ReadFile(h, ModernizedCProgram.buffer[_bufnum], (64 * -1024), ModernizedCProgram.read_size[_bufnum], ((Object)0))) {
				ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | -1024;
				ModernizedCProgram._uprintf("Read error: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			if (/*Error: Function owner not recognized*/WaitForMultipleObjects(checksum_type.CHECKSUM_MAX, ModernizedCProgram.thread_ready, 1, 5000) != 0) {
				ModernizedCProgram._uprintf("Checksum threads failed to signal: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
		}// Update the progress and check for cancel
		// Our last event with read_size=0 signaled the threads to exit - wait for that to happenif (/*Error: Function owner not recognized*/WaitForMultipleObjects(checksum_type.CHECKSUM_MAX, sum_thread, 1, 5000) != 0) {
			ModernizedCProgram._uprintf("Checksum threads did not finalize: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		ModernizedCProgram._uprintf("  MD5:\t %s", ModernizedCProgram.sum_str[0]);
		ModernizedCProgram._uprintf("  SHA1:\t %s", ModernizedCProgram.sum_str[1]);
		ModernizedCProgram._uprintf("  SHA256: %s", ModernizedCProgram.sum_str[2]);
		r = 0;
		do {
			if ((h != (HANDLE)(true)) && (h != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(h);
				h = (HANDLE)(true);
			} 
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/PostMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_FORMAT_COMPLETED, (WPARAM)0, 0);
		if (r == 0) {
			ModernizedCProgram.MyDialogBox(ModernizedCProgram.hMainInstance, 109, ModernizedCProgram.hMainDialog, ChecksumCallback);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExitThread(r/*
		 * The following 2 calls are used to check whether a buffer/file is in our hash DB
		 */);
	}
	public static Object IsBufferInDB(Object buf, Object len) {
		int i;
		uint8_t[] sum = new uint8_t();
		if (!ModernizedCProgram.HashBuffer(checksum_type.CHECKSUM_SHA256, buf, len, sum)) {
			return 0;
		} 
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i += 32) {
			if (/*Error: Function owner not recognized*/memcmp(sum, ModernizedCProgram.sha256db[i], 32) == 0) {
				return 1;
			} 
		}
		return 0;
	}
	public static Object IsFileInDB(Object path) {
		int i;
		uint8_t[] sum = new uint8_t();
		if (!ModernizedCProgram.HashFile(checksum_type.CHECKSUM_SHA256, path, sum)) {
			return 0;
		} 
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i += 32) {
			if (/*Error: Function owner not recognized*/memcmp(sum, ModernizedCProgram.sha256db[i], 32) == 0) {
				return 1;
			} 
		}
		return 0;
	}
	public static void cdio_default_log_handler(Object level, Object message) {
		switch (level) {
		case CDIO_LOG_ASSERT:
				if (level >= ModernizedCProgram.cdio_loglevel_default) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(stderr, "!ASSERT: %s\n", message);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fflush(stderr);
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/abort();
				break;
		case CDIO_LOG_WARN:
				if (level >= ModernizedCProgram.cdio_loglevel_default) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(stdout, "++ WARN: %s\n", message);
				} 
				break;
		case CDIO_LOG_ERROR:
				if (level >= ModernizedCProgram.cdio_loglevel_default) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(stderr, "**ERROR: %s\n", message);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fflush(stderr);
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/exit(EXIT_FAILURE);
				break;
		case CDIO_LOG_INFO:
				if (level >= ModernizedCProgram.cdio_loglevel_default) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(stdout, "   INFO: %s\n", message);
				} 
				break;
		case CDIO_LOG_DEBUG:
				if (level >= ModernizedCProgram.cdio_loglevel_default) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(stdout, "--DEBUG: %s\n", message);
				} 
				break;
		default:
				((false) ? (Object)0 : /*Error: Function owner not recognized*/_assert("0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\logging.c", 77));
				break;
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fflush(stdout);
	}
	public static Object cdio_log_set_handler(Object new_handler) {
		 old_handler = ModernizedCProgram._handler;
		ModernizedCProgram._handler = new_handler;
		return old_handler;
	}
	public static void cdio_logv(Object level, Object format, Object args) {
		byte[] buf = new byte[]{0/* _handler() is user defined and we want to make sure _handler()
		  doesn't call us, cdio_logv. in_recursion is used for that, however
		  it has a problem in multi-threaded programs. I'm not sure how to
		  handle multi-threading and recursion checking both. For now, we'll
		  leave in the recursion checking, at the expense of handling
		  multi-threaded log calls. To ameliorate this, we'll check the log
		  level and handle calls where there is no output, before the
		  recursion check.
		  */};
		int in_recursion = 0;
		if (level < ModernizedCProgram.cdio_loglevel_default) {
			return /*Error: Unsupported expression*/;
		} 
		if (in_recursion) {
			((false) ? (Object)0 : /*Error: Function owner not recognized*/_assert("0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\logging.c", /* Can't use cdio_assert_not_reached() as that may call cdio_logv */116));
		} 
		in_recursion = 1;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/vsnprintf(buf, /*Error: sizeof expression not supported yet*/ - 1, format, args);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_handler(level, buf);
		in_recursion = 0;
	}
	public static void cdio_log(Object level, Object format) {
		 args = new ();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/va_start(args, format);
		ModernizedCProgram.cdio_logv(level, format, args);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/va_end(args);
	}
	public static void cdio_debug(Object format) {
		 args = new ();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/va_start(args, format);
		ModernizedCProgram.cdio_logv(CDIO_LOG_DEBUG, format, args);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/va_end(args);
	}
	public static void cdio_info(Object format) {
		 args = new ();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/va_start(args, format);
		ModernizedCProgram.cdio_logv(CDIO_LOG_INFO, format, args);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/va_end(args);
	}
	public static void cdio_warn(Object format) {
		 args = new ();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/va_start(args, format);
		ModernizedCProgram.cdio_logv(CDIO_LOG_WARN, format, args);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/va_end(args);
	}
	public static void cdio_error(Object format) {
		 args = new ();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/va_start(args, format);
		ModernizedCProgram.cdio_logv(CDIO_LOG_ERROR, format, args);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/va_end(args/*
		 * Local variables:
		 *  c-file-style: "gnu"
		 *  tab-width: 8
		 *  indent-tabs-mode: nil
		 * End:
		 */);
	}
	public static Object Get7ZipPath() {
		if ((ModernizedCProgram._GetRegistryKey(((HKEY)-1024), "7-Zip\\Path", 1, (LPBYTE)ModernizedCProgram.sevenzip_path, (DWORD)/*Error: sizeof expression not supported yet*/)) || (ModernizedCProgram._GetRegistryKey(((HKEY)-1024), "7-Zip\\Path", 1, (LPBYTE)ModernizedCProgram.sevenzip_path, (DWORD)/*Error: sizeof expression not supported yet*/))) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(ModernizedCProgram.sevenzip_path, "\\7z.exe", (((size_t)(((((byte)"\\7z.exe") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\7z.exe")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)ModernizedCProgram.sevenzip_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.sevenzip_path)) - 1)) ? ((size_t)(((((byte)"\\7z.exe") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\7z.exe")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)ModernizedCProgram.sevenzip_path) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.sevenzip_path)) - 1))));
			return (/*Error: Function owner not recognized*/_access(ModernizedCProgram.sevenzip_path, 0) != -1);
		} 
		return 0;
	}
	public static Object AppendVHDFooter(Object vhd_path) {
		byte[] creator_os = new byte[]{(byte)'W', (byte)'i', (byte)'2', (byte)'k'};
		byte[] creator_app = new byte[]{(byte)'r', (byte)'u', (byte)'f', (byte)'s'};
		BOOL r = 0;
		DWORD size = new DWORD();
		LARGE_INTEGER li = new LARGE_INTEGER();
		HANDLE handle = (HANDLE)(true);
		vhd_footer footer = ((Object)0);
		uint64_t totalSectors = new uint64_t();
		uint16_t cylinders = 0;
		uint8_t heads = new uint8_t();
		uint8_t sectorsPerTrack = new uint8_t();
		uint32_t cylinderTimesHeads = new uint32_t();
		uint32_t checksum = new uint32_t();
		size_t i = new size_t();
		if (ModernizedCProgram.pfUuidCreate == ((Object)0)) {
			ModernizedCProgram.pfUuidCreate = (UuidCreate_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Rpcrt4"), "UuidCreate");
		} 
		handle = ModernizedCProgram.CreateFileU(vhd_path, -1024, -1024, ((Object)0), 3, -1024, ((Object)0));
		li.setQuadPart(0);
		if ((handle == (HANDLE)(true)) || (!/*Error: Function owner not recognized*/SetFilePointerEx(handle, li, li, 2))) {
			ModernizedCProgram._uprintf("Could not open image '%s': %s", vhd_path, ModernizedCProgram.WindowsErrorString());
			;
		} 
		footer = (vhd_footer)/*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/);
		if (footer == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not allocate VHD footer");
			;
		} 
		Object generatedCookie = footer.getCookie();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedCookie, ModernizedCProgram.conectix_str, /*Error: sizeof expression not supported yet*/);
		footer.setFeatures(/*Error: Function owner not recognized*/__builtin_bswap32(-1024));
		footer.setFile_format_version(/*Error: Function owner not recognized*/__builtin_bswap32(-1024));
		footer.setData_offset(/*Error: Function owner not recognized*/__builtin_bswap64(-1024));
		footer.setTimestamp(/*Error: Function owner not recognized*/__builtin_bswap32((uint32_t)(/*Error: Function owner not recognized*/_time64(((Object)0)) - 946684800)));
		Object generatedCreator_app = footer.getCreator_app();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedCreator_app, creator_app, /*Error: sizeof expression not supported yet*/);
		footer.setCreator_version(/*Error: Function owner not recognized*/__builtin_bswap32((ModernizedCProgram.rufus_version[0] << 16) | ModernizedCProgram.rufus_version[1]));
		Object generatedCreator_host_os = footer.getCreator_host_os();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedCreator_host_os, creator_os, /*Error: sizeof expression not supported yet*/);
		Object generatedQuadPart = li.getQuadPart();
		footer.setOriginal_size(/*Error: Function owner not recognized*/__builtin_bswap64(generatedQuadPart));
		Object generatedOriginal_size = footer.getOriginal_size();
		footer.setCurrent_size(generatedOriginal_size);
		footer.setDisk_type(/*Error: Function owner not recognized*/__builtin_bswap32(-1024));
		Object generatedUnique_id = footer.getUnique_id();
		if ((ModernizedCProgram.pfUuidCreate == ((Object)0)) || (/*Error: Function owner not recognized*/pfUuidCreate(generatedUnique_id) != -1024)) {
			ModernizedCProgram._uprintf("Warning: could not set VHD UUID");
		} 
		// Compute CHS, as per the VHD specs// Compute CHS, as per the VHD specstotalSectors = generatedQuadPart / 512;
		if (totalSectors > 65535 * 16 * 255) {
			totalSectors = 65535 * 16 * 255;
		} 
		if (totalSectors >= 65535 * 16 * 63) {
			sectorsPerTrack = 255;
			heads = 16;
			cylinderTimesHeads = (uint32_t)(totalSectors / sectorsPerTrack);
		} else {
				sectorsPerTrack = 17;
				cylinderTimesHeads = (uint32_t)(totalSectors / sectorsPerTrack);
				heads = (cylinderTimesHeads + 1023) / 1024;
				if (heads < 4) {
					heads = 4;
				} 
				if (cylinderTimesHeads >= ((uint32_t)heads * 1024) || heads > 16) {
					sectorsPerTrack = 31;
					heads = 16;
					cylinderTimesHeads = (uint32_t)(totalSectors / sectorsPerTrack);
				} 
				if (cylinderTimesHeads >= ((uint32_t)heads * 1024)) {
					sectorsPerTrack = 63;
					heads = 16;
					cylinderTimesHeads = (uint32_t)(totalSectors / sectorsPerTrack);
				} 
		} 
		cylinders = cylinderTimesHeads / heads;
		 generatedDisk_geometry = footer.getDisk_geometry();
		Object generatedChs = generatedDisk_geometry.getChs();
		generatedChs.setCylinders(/*Error: Function owner not recognized*/__builtin_bswap16(cylinders));
		generatedChs.setHeads(heads);
		generatedChs.setSectors(sectorsPerTrack);
		// Compute the VHD footer checksumfor (; i < /*Error: Unsupported expression*/; i++) {
			checksum += ((uint8_t)footer)[i];
		}
		footer.setChecksum(/*Error: Function owner not recognized*/__builtin_bswap32(~checksum));
		if (!ModernizedCProgram.WriteFileWithRetry(handle, footer, /*Error: Unsupported expression*/, size, 4)) {
			ModernizedCProgram._uprintf("Could not write VHD footer: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		r = 1;
		do {
			if ((handle != (HANDLE)(true)) && (handle != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(handle);
				handle = (HANDLE)(true);
			} 
		} while (0);
		return r;
	}
	// For now we consider that an image that matches a known extension is bootable
	// Might need to review this once we see bootable 4k systems
	public static Object IsCompressedBootableImage(Object[] path) {
		byte p;
		byte buf = ((Object)0);
		int i;
		BOOL r = 0;
		int64_t dc = new int64_t();
		ModernizedCProgram.img_report.setCompression_type(BLED_COMPRESSION_NONE);
		for (p = (byte)path[/*Error: Function owner not recognized*/strlen(path) - 1]; (p != (byte)'.') && (p != path); p--) {
			;
		}
		if (p == path) {
			return 0;
		} 
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (/*Error: Function owner not recognized*/strcmp(p, ModernizedCProgram.file_assoc[i].getExt()) == 0) {
				ModernizedCProgram.img_report.setCompression_type(ModernizedCProgram.file_assoc[i].getType());
				buf = /*Error: Function owner not recognized*/malloc(512);
				if (buf == ((Object)0)) {
					return 0;
				} 
				ModernizedCProgram.FormatStatus = 0;
				ModernizedCProgram.bled_init(ModernizedCProgram._uprintf, ((Object)0), ModernizedCProgram.FormatStatus);
				dc = ModernizedCProgram.bled_uncompress_to_buffer(path, (byte)buf, 512, ModernizedCProgram.file_assoc[i].getType());
				ModernizedCProgram.bled_exit();
				if (dc != 512) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buf);
					return 0;
				} 
				r = (buf[-1024] == -1024) && (buf[-1024] == -1024);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buf);
				return r;
			} 
		}
		return 0;
	}
	public static Object IsBootableImage(Object path) {
		HANDLE handle = (HANDLE)(true);
		LARGE_INTEGER liImageSize = new LARGE_INTEGER();
		vhd_footer footer = ((Object)0);
		DWORD size = new DWORD();
		size_t i = new size_t();
		uint32_t checksum = new uint32_t();
		uint32_t old_checksum = new uint32_t();
		LARGE_INTEGER ptr = new LARGE_INTEGER();
		BOOL is_bootable_img = 0;
		ModernizedCProgram._uprintf("Disk image analysis:");
		handle = ModernizedCProgram.CreateFileU(path, -1024, -1024, ((Object)0), 3, -1024, ((Object)0));
		if (handle == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("  Could not open image '%s'", path);
			;
		} 
		is_bootable_img = (BOOLEAN)ModernizedCProgram.IsCompressedBootableImage(path);
		if (ModernizedCProgram.img_report.getCompression_type() == BLED_COMPRESSION_NONE) {
			is_bootable_img = (BOOLEAN)ModernizedCProgram.AnalyzeMBR(handle, "  Image", 0);
		} 
		if (!/*Error: Function owner not recognized*/GetFileSizeEx(handle, liImageSize)) {
			ModernizedCProgram._uprintf("  Could not get image size: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		Object generatedQuadPart = liImageSize.getQuadPart();
		ModernizedCProgram.img_report.setImage_size((uint64_t)generatedQuadPart);
		size = /*Error: Unsupported expression*/;
		Object generatedCookie = footer.getCookie();
		Object generatedFile_format_version = footer.getFile_format_version();
		Object generatedDisk_type = footer.getDisk_type();
		Object generatedChecksum = footer.getChecksum();
		if ((ModernizedCProgram.img_report.getCompression_type() == BLED_COMPRESSION_NONE) && (ModernizedCProgram.img_report.getImage_size() >= (512 + size))) {
			footer = (vhd_footer)/*Error: Function owner not recognized*/malloc(size);
			ptr.setQuadPart(ModernizedCProgram.img_report.getImage_size() - size);
			if ((footer == ((Object)0)) || (!/*Error: Function owner not recognized*/SetFilePointerEx(handle, ptr, ((Object)0), 0)) || (!/*Error: Function owner not recognized*/ReadFile(handle, footer, size, size, ((Object)0))) || (size != /*Error: Unsupported expression*/)) {
				ModernizedCProgram._uprintf("  Could not read VHD footer");
				;
			} 
			if (/*Error: Function owner not recognized*/memcmp(generatedCookie, ModernizedCProgram.conectix_str, /*Error: sizeof expression not supported yet*/) == 0) {
				ModernizedCProgram.img_report.getImage_size() -= /*Error: Unsupported expression*/;
				if ((/*Error: Function owner not recognized*/__builtin_bswap32(generatedFile_format_version) != -1024) || (/*Error: Function owner not recognized*/__builtin_bswap32(generatedDisk_type) != -1024)) {
					ModernizedCProgram._uprintf("  Unsupported type of VHD image");
					is_bootable_img = 0;
					;
				} 
				old_checksum = /*Error: Function owner not recognized*/__builtin_bswap32(generatedChecksum);
				footer.setChecksum(0);
				for (; i < /*Error: Unsupported expression*/; i++) {
					checksum += ((uint8_t)footer)[i];
				}
				checksum = ~checksum;
				if (checksum != old_checksum) {
					ModernizedCProgram._uprintf("  Warning: VHD footer seems corrupted (checksum: %04X, expected: %04X)", old_checksum, checksum);
				} 
				ModernizedCProgram._uprintf("  Image is a Fixed Hard Disk VHD file");
				ModernizedCProgram.img_report.setIs_vhd(1);
			} 
		} 
		do {
			if ((handle != (HANDLE)(true)) && (handle != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(handle);
				handle = (HANDLE)(true);
			} 
		} while (0);
		return is_bootable_img;
	}
	// Find out if we have any way to extract/apply WIM files on this platform
	// Returns a bitfield of the methods we can use (1 = Extract using wimgapi, 2 = Extract using 7-Zip, 4 = Apply using wimgapi)
	public static Object WimExtractCheck() {
		if (ModernizedCProgram.pfWIMCreateFile == ((Object)0)) {
			ModernizedCProgram.pfWIMCreateFile = (WIMCreateFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMCreateFile");
		} 
		if (ModernizedCProgram.pfWIMSetTemporaryPath == ((Object)0)) {
			ModernizedCProgram.pfWIMSetTemporaryPath = (WIMSetTemporaryPath_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMSetTemporaryPath");
		} 
		if (ModernizedCProgram.pfWIMLoadImage == ((Object)0)) {
			ModernizedCProgram.pfWIMLoadImage = (WIMLoadImage_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMLoadImage");
		} 
		if (ModernizedCProgram.pfWIMApplyImage == ((Object)0)) {
			ModernizedCProgram.pfWIMApplyImage = (WIMApplyImage_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMApplyImage");
		} 
		if (ModernizedCProgram.pfWIMExtractImagePath == ((Object)0)) {
			ModernizedCProgram.pfWIMExtractImagePath = (WIMExtractImagePath_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMExtractImagePath");
		} 
		if (ModernizedCProgram.pfWIMGetImageInformation == ((Object)0)) {
			ModernizedCProgram.pfWIMGetImageInformation = (WIMGetImageInformation_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMGetImageInformation");
		} 
		if (ModernizedCProgram.pfWIMRegisterMessageCallback == ((Object)0)) {
			ModernizedCProgram.pfWIMRegisterMessageCallback = (WIMRegisterMessageCallback_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMRegisterMessageCallback");
		} 
		if (ModernizedCProgram.pfWIMUnregisterMessageCallback == ((Object)0)) {
			ModernizedCProgram.pfWIMUnregisterMessageCallback = (WIMUnregisterMessageCallback_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMUnregisterMessageCallback");
		} 
		if (ModernizedCProgram.pfWIMCloseHandle == ((Object)0)) {
			ModernizedCProgram.pfWIMCloseHandle = (WIMCloseHandle_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMCloseHandle");
		} 
		if (ModernizedCProgram.pfWIMCreateFile && ModernizedCProgram.pfWIMSetTemporaryPath && ModernizedCProgram.pfWIMLoadImage && ModernizedCProgram.pfWIMExtractImagePath && ModernizedCProgram.pfWIMCloseHandle) {
			ModernizedCProgram.wim_flags |=  1;
		} 
		if (ModernizedCProgram.Get7ZipPath()) {
			ModernizedCProgram.wim_flags |=  2;
		} 
		if ((ModernizedCProgram.wim_flags & 1) && ModernizedCProgram.pfWIMApplyImage && ModernizedCProgram.pfWIMRegisterMessageCallback && ModernizedCProgram.pfWIMUnregisterMessageCallback) {
			ModernizedCProgram.wim_flags |=  4;
		} 
		ModernizedCProgram._uprintf("WIM extraction method(s) supported: %s%s%s", (ModernizedCProgram.wim_flags & 2) ? "7-Zip" : ((ModernizedCProgram.wim_flags & 1) ? "" : "NONE"), ((ModernizedCProgram.wim_flags & (1 | 2)) == (1 | 2)) ? ", " : "", (ModernizedCProgram.wim_flags & 1) ? "wimgapi.dll" : "");
		ModernizedCProgram._uprintf("WIM apply method supported: %s", (ModernizedCProgram.wim_flags & 4) ? "wimgapi.dll" : "NONE");
		return ModernizedCProgram.wim_flags;
	}
	// Extract a file from a WIM image using wimgapi.dll (Windows 7 or later)
	// NB: if you want progress from a WIM callback, you must run the WIM API call in its own thread
	// (which we don't do here) as it won't work otherwise. Thanks go to Erwan for figuring this out!
	public static Object WimExtractFile_API(Object image, int index, Object src, Object dst) {
		byte index_name = "[1].xml";
		BOOL r = 0;
		DWORD dw = 0;
		HANDLE hWim = ((Object)0);
		HANDLE hImage = ((Object)0);
		HANDLE hFile = ((Object)0);
		wchar_t[] wtemp = new wchar_t[]{0};
		wchar_t wimage = ModernizedCProgram.utf8_to_wchar(image);
		wchar_t wsrc = ModernizedCProgram.utf8_to_wchar(src);
		wchar_t wdst = ModernizedCProgram.utf8_to_wchar(dst);
		byte wim_info;
		do {
			if (ModernizedCProgram.pfWIMCreateFile == ((Object)0)) {
				ModernizedCProgram.pfWIMCreateFile = (WIMCreateFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMCreateFile");
			} 
			if (ModernizedCProgram.pfWIMCreateFile == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMCreateFile", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfWIMSetTemporaryPath == ((Object)0)) {
				ModernizedCProgram.pfWIMSetTemporaryPath = (WIMSetTemporaryPath_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMSetTemporaryPath");
			} 
			if (ModernizedCProgram.pfWIMSetTemporaryPath == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMSetTemporaryPath", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfWIMLoadImage == ((Object)0)) {
				ModernizedCProgram.pfWIMLoadImage = (WIMLoadImage_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMLoadImage");
			} 
			if (ModernizedCProgram.pfWIMLoadImage == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMLoadImage", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfWIMExtractImagePath == ((Object)0)) {
				ModernizedCProgram.pfWIMExtractImagePath = (WIMExtractImagePath_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMExtractImagePath");
			} 
			if (ModernizedCProgram.pfWIMExtractImagePath == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMExtractImagePath", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfWIMCloseHandle == ((Object)0)) {
				ModernizedCProgram.pfWIMCloseHandle = (WIMCloseHandle_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMCloseHandle");
			} 
			if (ModernizedCProgram.pfWIMCloseHandle == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMCloseHandle", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		ModernizedCProgram._uprintf("Opening: %s:[%d] (API)", image, index);
		if (/*Error: Function owner not recognized*/GetTempPathW((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), wtemp) == 0) {
			ModernizedCProgram._uprintf("  Could not fetch temp path: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// to open newer install.wim/install.esd images, without running into obnoxious error:// [0x0000000B] An attempt was made to load a program with an incorrect format.// No thanks to Microsoft for NOT DOCUMENTING THEIR UTTER BULLSHIT with the WIM API!// to open newer install.wim/install.esd images, without running into obnoxious error:// [0x0000000B] An attempt was made to load a program with an incorrect format.// No thanks to Microsoft for NOT DOCUMENTING THEIR UTTER BULLSHIT with the WIM API!hWim = /*Error: Function owner not recognized*/pfWIMCreateFile(wimage, -1024, 3, (ModernizedCProgram.img_report.getWininst_version() >= -1024) ? -1024 : 0, 0, ((Object)0));
		if (hWim == ((Object)0)) {
			ModernizedCProgram._uprintf("  Could not access image: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		if (!/*Error: Function owner not recognized*/pfWIMSetTemporaryPath(hWim, wtemp)) {
			ModernizedCProgram._uprintf("  Could not set temp path: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		ModernizedCProgram._uprintf("Extracting: %s (From %s)", dst, src);
		if (/*Error: Function owner not recognized*/strcmp(((src == ((Object)0)) ? "<NULL>" : src), ((index_name == ((Object)0)) ? "<NULL>" : index_name)) == 0) {
			if (!/*Error: Function owner not recognized*/pfWIMGetImageInformation(hWim, wim_info, dw)) {
				ModernizedCProgram._uprintf("  Could not access WIM info: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
			hFile = /*Error: Function owner not recognized*/CreateFileW(wdst, -1024 | -1024, -1024, ((Object)0), 2, -1024, ((Object)0));
			if ((hFile == (HANDLE)(true)) || (!/*Error: Function owner not recognized*/WriteFile(hFile, wim_info, dw, dw, ((Object)0)))) {
				ModernizedCProgram._uprintf("  Could not extract file: %s", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} else {
				hImage = /*Error: Function owner not recognized*/pfWIMLoadImage(hWim, (DWORD)index);
				if (hImage == ((Object)0)) {
					ModernizedCProgram._uprintf("  Could not set index: %s", ModernizedCProgram.WindowsErrorString());
					;
				} 
				if (!/*Error: Function owner not recognized*/pfWIMExtractImagePath(hImage, wsrc, wdst, 0)) {
					ModernizedCProgram._uprintf("  Could not extract file: %s", ModernizedCProgram.WindowsErrorString());
					;
				} 
		} 
		r = 1;
		do {
			if ((hFile != (HANDLE)(true)) && (hFile != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hFile);
				hFile = (HANDLE)(true);
			} 
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wimage);
			wimage = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wsrc);
			wsrc = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wdst);
			wdst = ((Object)0);
		} while (0);
		return r;
	}
	// Apply image functionality
	// Extract a file from a WIM image using 7-Zip
	public static Object WimExtractFile_7z(Object image, int index, Object[] src, Object dst) {
		int n;
		size_t i = new size_t();
		byte[] cmdline = new byte[260];
		byte[] tmpdst = new byte[260];
		byte[] index_prefix = "#\\";
		ModernizedCProgram._uprintf("Opening: %s:[%d] (7-Zip)", image, index);
		if ((image == ((Object)0)) || (src == ((Object)0)) || (dst == ((Object)0))) {
			return 0;
		} 
		// that this breaks!// that this breaks!index_prefix[0] = (byte)'0' + index;
		ModernizedCProgram._uprintf("Extracting: %s (From %s)", dst, src)// 7z has a quirk where the image index MUST be specified if a// WIM has multiple indexes, but it MUST be removed if there is;// 7z has a quirk where the image index MUST be specified if a// WIM has multiple indexes, but it MUST be removed if there is
		// only one image. Because of this (and because 7z will not// return an error code if it can't extract the file), we need// to issue 2 passes. See github issue #680.for (n = 0; n < 2; n++) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(tmpdst, dst, (((size_t)(((((byte)dst) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(dst)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)dst) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(dst)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
				((byte)tmpdst)[(((size_t)(((((byte)dst) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(dst)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)dst) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(dst)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
			} while (0);
			for (i = /*Error: Function owner not recognized*/strlen(tmpdst) - 1; (i > 0) && (tmpdst[i] != (byte)'\\') && (tmpdst[i] != (byte)'/'); i--) {
				;
			}
			tmpdst[i] = 0;
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(cmdline, /*Error: sizeof expression not supported yet*/, "\"%s\" -y e \"%s\" %s%s", ModernizedCProgram.sevenzip_path, image, (n == 0) ? index_prefix : "", src);
				(cmdline)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			if (ModernizedCProgram.RunCommand(cmdline, tmpdst, 0) != 0) {
				ModernizedCProgram._uprintf("  Could not launch 7z.exe: %s", ModernizedCProgram.WindowsErrorString());
				return 0;
			} 
			for (i = ((((byte)src) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(src)); (i > 0) && (src[i] != (byte)'\\') && (src[i] != (byte)'/'); i--) {
				;
			}
			if (i == 0) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(tmpdst, "\\", (((size_t)(((((byte)"\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)tmpdst) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmpdst)) - 1)) ? ((size_t)(((((byte)"\\") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("\\")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)tmpdst) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmpdst)) - 1))));
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(tmpdst, src[i], (((size_t)(((((byte)src[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(src[i])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)tmpdst) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmpdst)) - 1)) ? ((size_t)(((((byte)src[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(src[i])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)tmpdst) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmpdst)) - 1))));
			if (/*Error: Function owner not recognized*/_access(tmpdst, 0) == 0) {
				break;
			} 
		}
		if (n >= 2) {
			ModernizedCProgram._uprintf("  7z.exe did not extract %s", tmpdst);
			return 0;
		} 
		// coverity[toctou]if (/*Error: Function owner not recognized*/rename(tmpdst, dst) != 0) {
			ModernizedCProgram._uprintf("  Could not rename %s to %s: errno %d", tmpdst, dst, (/*Error: Function owner not recognized*/_errno()));
			return 0;
		} 
		return 1;
	}
	// Extract a file from a WIM image
	public static Object WimExtractFile(Object image, int index, Object src, Object dst) {
		if ((ModernizedCProgram.wim_flags == 0) && (!(ModernizedCProgram.WimExtractCheck() & (1 | 2)))) {
			return 0;
		} 
		if ((image == ((Object)0)) || (src == ((Object)0)) || (dst == ((Object)0))) {
			return 0;
		} 
		// but allow fallback if 7-Zip doesn't succeedreturn (((ModernizedCProgram.wim_flags & 2) && ModernizedCProgram.WimExtractFile_7z(image, index, src, dst)) || ((ModernizedCProgram.wim_flags & 1) && ModernizedCProgram.WimExtractFile_API(image, index, src, dst)));
	}
	// Progress callback
	public static Object WimProgressCallback(Object dwMsgId, Object wParam, Object lParam, Object pvIgnored) {
		PBOOL pbCancel = ((Object)0);
		PWIN32_FIND_DATA pFileData = new PWIN32_FIND_DATA();
		byte level = ((Object)0);
		uint64_t size = new uint64_t();
		switch (dwMsgId) {
		case WIMMessage.WIM_MSG_PROCESS:
				if (ModernizedCProgram.count_files) {
					ModernizedCProgram.wim_nb_files++;
				} else {
						if (ModernizedCProgram.wim_proc_files < ModernizedCProgram.wim_nb_files) {
							ModernizedCProgram.wim_proc_files++;
						} else {
								ModernizedCProgram.wim_extra_files++;
						} 
						ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FILE_COPY, 3267, ModernizedCProgram.wim_proc_files, ModernizedCProgram.wim_nb_files);
				} 
				if (((long)(ModernizedCProgram.FormatStatus) >> 31 == 1)) {
					pbCancel = (PBOOL)lParam;
					pbCancel = 1;
					break;
				} 
				break;
		case WIMMessage.WIM_MSG_RETRY:
				level = "retry";
		case WIMMessage.WIM_MSG_WARNING:
				if (level == ((Object)0)) {
					level = "warning";
				} 
		case WIMMessage.WIM_MSG_PROGRESS:
				break;
		case WIMMessage.WIM_MSG_FILEINFO:
				pFileData = (PWIN32_FIND_DATA)lParam;
				if (pFileData.getDwFileAttributes() & -1024) {
					ModernizedCProgram._uprintf("Creating: %S", (PWSTR)wParam);
				} else {
						size = (((uint64_t)pFileData.getNFileSizeHigh()) << 32) + pFileData.getNFileSizeLow();
						ModernizedCProgram._uprintf("Extracting: %S (%s)", (PWSTR)wParam, ModernizedCProgram.SizeToHumanReadable(size, 0, 0));
				} 
				break;
		case WIMMessage.WIM_MSG_INFO:
				if (level == ((Object)0)) {
					level = "info";
				} 
		case WIMMessage.WIM_MSG_ERROR:
				if (level == ((Object)0)) {
					level = "error";
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError((DWORD)lParam);
				ModernizedCProgram._uprintf("Apply %s: %S [err = %d]\n", level, (PWSTR)wParam, ModernizedCProgram.WindowsErrorString());
				break;
		}
		return ((long)(ModernizedCProgram.FormatStatus) >> 31 == 1) ? WIMMessage.WIM_MSG_ABORT_IMAGE : WIMMessage.WIM_MSG_SUCCESS;// Apply a WIM image using wimgapi.dll (Windows 7 or later)
	}
	// http://msdn.microsoft.com/en-us/library/windows/desktop/dd851944.aspx
	// To get progress, we must run this call within its own thread
	public static Object WimApplyImageThread(Object param) {
		BOOL r = 0;
		HANDLE hWim = ((Object)0);
		HANDLE hImage = ((Object)0);
		wchar_t[] wtemp = new wchar_t[]{0};
		wchar_t wimage = ModernizedCProgram.utf8_to_wchar(ModernizedCProgram._image);
		wchar_t wdst = ModernizedCProgram.utf8_to_wchar(ModernizedCProgram._dst);
		do {
			if (ModernizedCProgram.pfWIMRegisterMessageCallback == ((Object)0)) {
				ModernizedCProgram.pfWIMRegisterMessageCallback = (WIMRegisterMessageCallback_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMRegisterMessageCallback");
			} 
			if (ModernizedCProgram.pfWIMRegisterMessageCallback == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMRegisterMessageCallback", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfWIMCreateFile == ((Object)0)) {
				ModernizedCProgram.pfWIMCreateFile = (WIMCreateFile_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMCreateFile");
			} 
			if (ModernizedCProgram.pfWIMCreateFile == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMCreateFile", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfWIMSetTemporaryPath == ((Object)0)) {
				ModernizedCProgram.pfWIMSetTemporaryPath = (WIMSetTemporaryPath_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMSetTemporaryPath");
			} 
			if (ModernizedCProgram.pfWIMSetTemporaryPath == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMSetTemporaryPath", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfWIMLoadImage == ((Object)0)) {
				ModernizedCProgram.pfWIMLoadImage = (WIMLoadImage_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMLoadImage");
			} 
			if (ModernizedCProgram.pfWIMLoadImage == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMLoadImage", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfWIMApplyImage == ((Object)0)) {
				ModernizedCProgram.pfWIMApplyImage = (WIMApplyImage_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMApplyImage");
			} 
			if (ModernizedCProgram.pfWIMApplyImage == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMApplyImage", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfWIMCloseHandle == ((Object)0)) {
				ModernizedCProgram.pfWIMCloseHandle = (WIMCloseHandle_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMCloseHandle");
			} 
			if (ModernizedCProgram.pfWIMCloseHandle == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMCloseHandle", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfWIMUnregisterMessageCallback == ((Object)0)) {
				ModernizedCProgram.pfWIMUnregisterMessageCallback = (WIMUnregisterMessageCallback_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("Wimgapi"), "WIMUnregisterMessageCallback");
			} 
			if (ModernizedCProgram.pfWIMUnregisterMessageCallback == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "WIMUnregisterMessageCallback", "Wimgapi", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		ModernizedCProgram._uprintf("Opening: %s:[%d]", ModernizedCProgram._image, ModernizedCProgram._index);
		if (/*Error: Function owner not recognized*/pfWIMRegisterMessageCallback(((Object)0), (FARPROC)WimProgressCallback, ((Object)0)) == -1024) {
			ModernizedCProgram._uprintf("  Could not set progress callback: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		if (/*Error: Function owner not recognized*/GetTempPathW((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), wtemp) == 0) {
			ModernizedCProgram._uprintf("  Could not fetch temp path: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		hWim = /*Error: Function owner not recognized*/pfWIMCreateFile(wimage, -1024, 3, (ModernizedCProgram.img_report.getWininst_version() >= -1024) ? -1024 : 0, 0, ((Object)0));
		if (hWim == ((Object)0)) {
			ModernizedCProgram._uprintf("  Could not access image: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		if (!/*Error: Function owner not recognized*/pfWIMSetTemporaryPath(hWim, wtemp)) {
			ModernizedCProgram._uprintf("  Could not set temp path: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		hImage = /*Error: Function owner not recognized*/pfWIMLoadImage(hWim, (DWORD)ModernizedCProgram._index);
		if (hImage == ((Object)0)) {
			ModernizedCProgram._uprintf("  Could not set index: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		ModernizedCProgram._uprintf("Applying Windows image...")// Run a first pass using WIM_FLAG_NO_APPLY to count the files;// Run a first pass using WIM_FLAG_NO_APPLY to count the files
		ModernizedCProgram.wim_nb_files = 0;
		ModernizedCProgram.wim_proc_files = 0;
		ModernizedCProgram.wim_extra_files = 0;
		ModernizedCProgram.count_files = 1;
		if (!/*Error: Function owner not recognized*/pfWIMApplyImage(hImage, wdst, -1024)) {
			ModernizedCProgram._uprintf("  Could not count the files to apply: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Therefore, we add a 'safe' 20% to our counted files to compensate for yet// another dismal Microsoft progress reporting API...// Therefore, we add a 'safe' 20% to our counted files to compensate for yet// another dismal Microsoft progress reporting API...ModernizedCProgram.wim_nb_files += ModernizedCProgram.wim_nb_files / 5;
		ModernizedCProgram.count_files = 0// Actual apply;// Actual apply
		if (!/*Error: Function owner not recognized*/pfWIMApplyImage(hImage, wdst, -1024)) {
			ModernizedCProgram._uprintf("  Could not apply image: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		// Ensure that we'll pick if need to readjust our 20% above from user reportsif (ModernizedCProgram.wim_extra_files > 0) {
			ModernizedCProgram._uprintf("Notice: An extra %d files and directories were applied, from the %d expected", ModernizedCProgram.wim_extra_files, ModernizedCProgram.wim_nb_files);
		} 
		// Re-use extra files as the final progress step// Re-use extra files as the final progress stepModernizedCProgram.wim_extra_files = (ModernizedCProgram.wim_nb_files - ModernizedCProgram.wim_proc_files) / 3;
		ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FILE_COPY, 3267, ModernizedCProgram.wim_proc_files + ModernizedCProgram.wim_extra_files, ModernizedCProgram.wim_nb_files);
		r = 1;
		if (ModernizedCProgram.pfWIMUnregisterMessageCallback != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfWIMUnregisterMessageCallback(((Object)0), (FARPROC)WimProgressCallback);
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wimage);
			wimage = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wdst);
			wdst = ((Object)0);
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExitThread((DWORD)r);
	}
	public static Object WimApplyImage(Object image, int index, Object dst) {
		HANDLE handle = new HANDLE();
		DWORD dw = 0;
		ModernizedCProgram._image = image;
		ModernizedCProgram._index = index;
		ModernizedCProgram._dst = dst;
		handle = /*Error: Function owner not recognized*/CreateThread(((Object)0), 0, WimApplyImageThread, ((Object)0), 0, ((Object)0));
		if (handle == ((Object)0)) {
			ModernizedCProgram._uprintf("Unable to start apply-image thread");
			return 0;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject(handle, -1024);
		if (!/*Error: Function owner not recognized*/GetExitCodeThread(handle, dw)) {
			return 0;
		} 
		return (BOOL)dw;
	}
	/*
	  Red Black Trees
	  (C) 1999  Andrea Arcangeli <andrea@suse.de>
	  (C) 2002  David Woodhouse <dwmw2@infradead.org>
	
	  This program is free software; you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation; either version 2 of the License, or
	  (at your option) any later version.
	
	  This program is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program; if not, write to the Free Software
	  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
	
	  linux/lib/rbtree.c
	*/
	public static void __rb_rotate_left(rb_node node, rb_root root) {
		rb_node generatedRb_right = node.getRb_right();
		rb_node right = generatedRb_right;
		Object generatedRb_parent_color = (node).getRb_parent_color();
		rb_node parent = ((rb_node)(generatedRb_parent_color & ~3));
		rb_node generatedRb_left = right.getRb_left();
		if ((node.setRb_right(generatedRb_left))) {
			generatedRb_left.ext2fs_rb_set_parent(node);
		} 
		right.setRb_left(node);
		right.ext2fs_rb_set_parent(parent);
		if (parent) {
			if (node == generatedRb_left) {
				parent.setRb_left(right);
			} else {
					parent.setRb_right(right);
			} 
		} else {
				root.setRb_node(right);
		} 
		node.ext2fs_rb_set_parent(right);
	}
	public static void __rb_rotate_right(rb_node node, rb_root root) {
		rb_node generatedRb_left = node.getRb_left();
		rb_node left = generatedRb_left;
		Object generatedRb_parent_color = (node).getRb_parent_color();
		rb_node parent = ((rb_node)(generatedRb_parent_color & ~3));
		rb_node generatedRb_right = left.getRb_right();
		if ((node.setRb_left(generatedRb_right))) {
			generatedRb_right.ext2fs_rb_set_parent(node);
		} 
		left.setRb_right(node);
		left.ext2fs_rb_set_parent(parent);
		if (parent) {
			if (node == generatedRb_right) {
				parent.setRb_right(left);
			} else {
					parent.setRb_left(left);
			} 
		} else {
				root.setRb_node(left);
		} 
		node.ext2fs_rb_set_parent(left);
	}
	public static void ext2fs_rb_insert_color(rb_node node, rb_root root) {
		rb_node parent = new rb_node();
		rb_node gparent = new rb_node();
		Object generatedRb_parent_color = (node).getRb_parent_color();
		rb_node generatedRb_left = gparent.getRb_left();
		rb_node generatedRb_right = gparent.getRb_right();
		while ((parent = ((rb_node)(generatedRb_parent_color & ~3))) && (!(generatedRb_parent_color & 1))) {
			gparent = ((rb_node)(generatedRb_parent_color & ~3));
			if (parent == generatedRb_left) {
				{ 
					rb_node uncle = generatedRb_right;
					if (uncle && (!(generatedRb_parent_color & 1))) {
						do {
							generatedRb_parent_color |=  1;
						} while (0);
						do {
							generatedRb_parent_color |=  1;
						} while (0);
						do {
							generatedRb_parent_color &=  ~1;
						} while (0);
						node = gparent;
						continue;
					} 
				}
				if (generatedRb_right == node) {
					rb_node tmp = new rb_node();
					ModernizedCProgram.__rb_rotate_left(parent, root);
					tmp = parent;
					parent = node;
					node = tmp;
				} 
				do {
					generatedRb_parent_color |=  1;
				} while (0);
				do {
					generatedRb_parent_color &=  ~1;
				} while (0);
				ModernizedCProgram.__rb_rotate_right(gparent, root);
			} else {
					{ 
						rb_node uncle = generatedRb_left;
						if (uncle && (!(generatedRb_parent_color & 1))) {
							do {
								generatedRb_parent_color |=  1;
							} while (0);
							do {
								generatedRb_parent_color |=  1;
							} while (0);
							do {
								generatedRb_parent_color &=  ~1;
							} while (0);
							node = gparent;
							continue;
						} 
					}
					if (generatedRb_left == node) {
						rb_node tmp = new rb_node();
						ModernizedCProgram.__rb_rotate_right(parent, root);
						tmp = parent;
						parent = node;
						node = tmp;
					} 
					do {
						generatedRb_parent_color |=  1;
					} while (0);
					do {
						generatedRb_parent_color &=  ~1;
					} while (0);
					ModernizedCProgram.__rb_rotate_left(gparent, root);
			} 
		}
		do {
			generatedRb_parent_color |=  1;
		} while (0);
	}
	public static void __rb_erase_color(rb_node node, rb_node parent, rb_root root) {
		rb_node other = new rb_node();
		Object generatedRb_parent_color = (node).getRb_parent_color();
		rb_node generatedRb_node = root.getRb_node();
		rb_node generatedRb_left = parent.getRb_left();
		rb_node generatedRb_right = parent.getRb_right();
		while ((!node || (generatedRb_parent_color & 1)) && node != generatedRb_node) {
			if (generatedRb_left == node) {
				other = generatedRb_right;
				if ((!(generatedRb_parent_color & 1))) {
					do {
						generatedRb_parent_color |=  1;
					} while (0);
					do {
						generatedRb_parent_color &=  ~1;
					} while (0);
					ModernizedCProgram.__rb_rotate_left(parent, root);
					other = generatedRb_right;
				} 
				if ((!generatedRb_left || (generatedRb_parent_color & 1)) && (!generatedRb_right || (generatedRb_parent_color & 1))) {
					do {
						generatedRb_parent_color &=  ~1;
					} while (0);
					node = parent;
					parent = ((rb_node)(generatedRb_parent_color & ~3));
				} else {
						if (!generatedRb_right || (generatedRb_parent_color & 1)) {
							do {
								generatedRb_parent_color |=  1;
							} while (0);
							do {
								generatedRb_parent_color &=  ~1;
							} while (0);
							ModernizedCProgram.__rb_rotate_right(other, root);
							other = generatedRb_right;
						} 
						other.ext2fs_rb_set_color((generatedRb_parent_color & 1));
						do {
							generatedRb_parent_color |=  1;
						} while (0);
						do {
							generatedRb_parent_color |=  1;
						} while (0);
						ModernizedCProgram.__rb_rotate_left(parent, root);
						node = generatedRb_node;
						break;
				} 
			} else {
					other = generatedRb_left;
					if ((!(generatedRb_parent_color & 1))) {
						do {
							generatedRb_parent_color |=  1;
						} while (0);
						do {
							generatedRb_parent_color &=  ~1;
						} while (0);
						ModernizedCProgram.__rb_rotate_right(parent, root);
						other = generatedRb_left;
					} 
					if ((!generatedRb_left || (generatedRb_parent_color & 1)) && (!generatedRb_right || (generatedRb_parent_color & 1))) {
						do {
							generatedRb_parent_color &=  ~1;
						} while (0);
						node = parent;
						parent = ((rb_node)(generatedRb_parent_color & ~3));
					} else {
							if (!generatedRb_left || (generatedRb_parent_color & 1)) {
								do {
									generatedRb_parent_color |=  1;
								} while (0);
								do {
									generatedRb_parent_color &=  ~1;
								} while (0);
								ModernizedCProgram.__rb_rotate_left(other, root);
								other = generatedRb_left;
							} 
							other.ext2fs_rb_set_color((generatedRb_parent_color & 1));
							do {
								generatedRb_parent_color |=  1;
							} while (0);
							do {
								generatedRb_parent_color |=  1;
							} while (0);
							ModernizedCProgram.__rb_rotate_right(parent, root);
							node = generatedRb_node;
							break;
					} 
			} 
		}
		if (node) {
			do {
				generatedRb_parent_color |=  1;
			} while (0);
		} 
	}
	public static void ext2fs_rb_erase(rb_node node, rb_root root) {
		rb_node child = new rb_node();
		rb_node parent = new rb_node();
		int color;
		rb_node generatedRb_left = node.getRb_left();
		rb_node generatedRb_right = node.getRb_right();
		Object generatedRb_parent_color = (old).getRb_parent_color();
		if (!generatedRb_left) {
			child = generatedRb_right;
		}  else if (!generatedRb_right) {
			child = generatedRb_left;
		} else {
				rb_node old = node;
				rb_node left = new rb_node();
				node = generatedRb_right;
				while ((left = generatedRb_left) != ((Object)0)) {
					node = left;
				}
				if (((rb_node)(generatedRb_parent_color & ~3))) {
					if (generatedRb_left == old) {
						((rb_node)(generatedRb_parent_color & ~3)).setRb_left(node);
					} else {
							((rb_node)(generatedRb_parent_color & ~3)).setRb_right(node);
					} 
				} else {
						root.setRb_node(node);
				} 
				child = generatedRb_right;
				parent = ((rb_node)(generatedRb_parent_color & ~3));
				color = (generatedRb_parent_color & 1);
				if (parent == old) {
					parent = node;
				} else {
						if (child) {
							child.ext2fs_rb_set_parent(parent);
						} 
						parent.setRb_left(child);
						node.setRb_right(generatedRb_right);
						generatedRb_right.ext2fs_rb_set_parent(node);
				} 
				node.setRb_parent_color(generatedRb_parent_color);
				node.setRb_left(generatedRb_left);
				generatedRb_left.ext2fs_rb_set_parent(node);
				;
		} 
		parent = ((rb_node)(generatedRb_parent_color & ~3));
		color = (generatedRb_parent_color & 1);
		if (child) {
			child.ext2fs_rb_set_parent(parent);
		} 
		if (parent) {
			if (generatedRb_left == node) {
				parent.setRb_left(child);
			} else {
					parent.setRb_right(child);
			} 
		} else {
				root.setRb_node(child);
		} 
	}
	public static void ext2fs_rb_replace_node(rb_node victim, rb_node new, rb_root root) {
		Object generatedRb_parent_color = (victim).getRb_parent_color();
		rb_node parent = ((rb_node)(generatedRb_parent_color & ~3));
		rb_node generatedRb_left = parent.getRb_left();
		if (/* Set the surrounding nodes to point to the replacement */parent) {
			if (victim == generatedRb_left) {
				parent.setRb_left(new);
			} else {
					parent.setRb_right(new);
			} 
		} else {
				root.setRb_node(new);
		} 
		if (generatedRb_left) {
			generatedRb_left.ext2fs_rb_set_parent(new);
		} 
		rb_node generatedRb_right = victim.getRb_right();
		if (generatedRb_right) {
			generatedRb_right.ext2fs_rb_set_parent(new);
		} 
		new = /* Copy the pointers/colour from the victim to the replacement */victim;
	}
	/* Tail signature */
	public static void cleanup_adv(Byte advbuf) {
		int i;
		uint32_t csum = new uint32_t();
		ModernizedCProgram.set_32((uint32_t)advbuf, /* Make sure both copies agree, and update the checksum */-1024);
		csum = -1024;
		for (i = 8; i < 512 - 4; i += 4) {
			csum -= ModernizedCProgram.get_32((uint32_t)(advbuf + i));
		}
		ModernizedCProgram.set_32((uint32_t)(advbuf + 4), csum);
		ModernizedCProgram.set_32((uint32_t)(advbuf + 512 - 4), -1024);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(advbuf + 512, advbuf, 512);
	}
	public static int syslinux_setadv(int tag, Object size, Object data) {
		uint8_t p = new uint8_t();
		size_t left = new size_t();
		uint8_t[] advtmp = new uint8_t();
		if ((int)tag - 1 > 254) {
			(/*Error: Function owner not recognized*/_errno()) = 22;
			return -/* Impossible tag value */1;
		} 
		if (size > 255) {
			(/*Error: Function owner not recognized*/_errno()) = /* Max 255 bytes for a data item */28;
			return -1;
		} 
		left = (512 - 3 * 4);
		p = advtmp;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p, ModernizedCProgram.syslinux_adv + 2 * 4, /* Make working copy */left);
		while (left >= 2) {
			uint8_t ptag = p[0];
			size_t plen = p[1] + 2;
			if (ptag == 0) {
				break;
			} 
			if (ptag == tag/* Found our tag.  Delete it. */) {
				if (plen >= left/* Entire remainder is our tag */) {
					break;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memmove(p, p + plen, left - plen);
			} else {
					if (plen > /* Not our tag */left) {
						break;
					} 
					left -= plen;
					p += plen;
			} 
		}
		if (/* Now (p, left) reflects the position to write in and how much space
		       we have for our data. */size) {
			if (left < size + 2) {
				(/*Error: Function owner not recognized*/_errno()) = /* Not enough space for data */28;
				return -1;
			} 
			p++ = tag;
			p++ = size;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p, data, size);
			p += size;
			left -= size + 2;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(p, 0, left);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.syslinux_adv + 2 * 4, advtmp, (512 - 3 * /* If we got here, everything went OK, commit the write */4));
		ModernizedCProgram.cleanup_adv(ModernizedCProgram.syslinux_adv);
		return 0;
	}
	public static void syslinux_reset_adv(Byte advbuf) {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(advbuf + 2 * 4, 0, (512 - 3 * /* Create an all-zero ADV */4));
		ModernizedCProgram.cleanup_adv(advbuf);
	}
	public static int adv_consistent(Object p) {
		int i;
		uint32_t csum = new uint32_t();
		if (ModernizedCProgram.get_32((uint32_t)p) != -1024 || ModernizedCProgram.get_32((uint32_t)(p + 512 - 4)) != -1024) {
			return 0;
		} 
		csum = 0;
		for (i = 4; i < 512 - 4; i += 4) {
			csum += ModernizedCProgram.get_32((uint32_t)(p + i));
		}
		return csum == -1024/*
		 * Verify that an in-memory ADV is consistent, making the copies consistent.
		 * If neither copy is OK, return -1 and call syslinux_reset_adv().
		 */;
	}
	public static int syslinux_validate_adv(Byte advbuf) {
		if (ModernizedCProgram.adv_consistent(advbuf + 0 * 512)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(advbuf + 512, advbuf, 512);
			return 0;
		}  else if (ModernizedCProgram.adv_consistent(advbuf + 1 * 512)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(advbuf, advbuf + 512, 512);
			return 0;
		} else {
				ModernizedCProgram.syslinux_reset_adv(advbuf);
				return -1;
		} 
	}
	/*
	  Copyright (C) 2003-2005, 2008-2009, 2011-2012, 2016-2017
	  Rocky Bernstein <rocky@gnu.org>
	
	  This program is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  This program is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/
	/* Internal routines for CD I/O drivers. */
	/* __cplusplus */
	public static Byte libcdio_strndup(Object s, Object n) {
		byte result;
		 len = /*Error: Function owner not recognized*/strlen(s);
		if (n < len) {
			len = n;
		} 
		result = (byte)/*Error: Function owner not recognized*/malloc(len + 1);
		if (!result) {
			return 0;
		} 
		result[len] = (byte)'\0';
		return (byte)/*Error: Function owner not recognized*/strncpy(result, s, len/*HAVE_STRNDUP*//*!
		    Get directory name from file name.
		
		    Callers must free return value after use.
		   */);
	}
	public static Object ext2fs_inline_data_init(Object fs, Object ino) {
		ext2_inline_data data = new ext2_inline_data();
		byte[] empty = new byte[]{(byte)'\0'};
		data.setFs(fs);
		data.setIno(ino);
		data.setEa_size(0);
		data.setEa_data(empty);
		return data.ext2fs_inline_data_ea_set();
	}
	public static Object ext2fs_inline_data_size(Object fs, Object ino, Object size) {
		ext2_inode inode = new ext2_inode();
		ext2_inline_data data = new ext2_inline_data();
		 retval = new ();
		retval = inode.ext2fs_read_inode(fs, ino);
		if (retval) {
			return retval;
		} 
		Object generatedI_flags = inode.getI_flags();
		if (!(generatedI_flags & -1024)) {
			return EXT2_ET_NO_INLINE_DATA;
		} 
		data.setFs(fs);
		data.setIno(ino);
		retval = data.ext2fs_inline_data_ea_get();
		if (retval) {
			return retval;
		} 
		Object generatedEa_size = data.getEa_size();
		size = ((/*Error: Unsupported expression*/ * (((12 + 1) + 1) + 1))) + generatedEa_size;
		Object generatedEa_data = data.getEa_data();
		return ModernizedCProgram.ext2fs_free_mem(generatedEa_data);
	}
	public static int ext2fs_inline_data_dir_iterate(Object fs, Object ino, Object priv_data) {
		dir_context ctx = new dir_context();
		ext2_inode inode = new ext2_inode();
		ext2_dir_entry dirent = new ext2_dir_entry();
		ext2_inline_data data = new ext2_inline_data();
		int ret = 2;
		 blockcnt = 0;
		byte old_buf;
		int old_buflen;
		int old_flags;
		ctx = (dir_context)priv_data;
		Byte generatedBuf = ctx.getBuf();
		old_buf = generatedBuf;
		int generatedBuflen = ctx.getBuflen();
		old_buflen = generatedBuflen;
		int generatedFlags = ctx.getFlags();
		old_flags = generatedFlags;
		generatedFlags |=  8;
		ctx.setErrcode(inode.ext2fs_read_inode(fs, ino));
		Object generatedErrcode = ctx.getErrcode();
		if (generatedErrcode) {
			;
		} 
		Object generatedI_flags = inode.getI_flags();
		if (!(generatedI_flags & -1024)) {
			ctx.setErrcode(EXT2_ET_NO_INLINE_DATA);
			;
		} 
		Object generatedI_mode = inode.getI_mode();
		if (!(((generatedI_mode) & 170000) == 40000)) {
			ctx.setErrcode(EXT2_ET_NO_DIRECTORY);
			;
		} 
		ret = 0;
		dirent.setInode(/* we first check '.' and '..' dir */ino);
		dirent.setName_len(1);
		dirent.ext2fs_set_rec_len(fs, (((true) + 8 + (4 - 1)) & ~(4 - 1)));
		Object generatedName = dirent.getName();
		generatedName[0] = (byte)'.';
		generatedName[1] = (byte)'\0';
		ctx.setBuf((byte)dirent);
		dirent.ext2fs_get_rec_len(fs, generatedBuflen);
		ret |=  ModernizedCProgram.ext2fs_process_dir_block(fs, 0, blockcnt++, 0, 0, priv_data);
		if (ret & 2) {
			;
		} 
		Object generatedI_block = inode.getI_block();
		dirent.setInode(/*Error: Function owner not recognized*/ext2fs_le32_to_cpu(generatedI_block[0]));
		dirent.setName_len(2);
		dirent.ext2fs_set_rec_len(fs, (((true) + 8 + (4 - 1)) & ~(4 - 1)));
		generatedName[0] = (byte)'.';
		generatedName[1] = (byte)'.';
		generatedName[2] = (byte)'\0';
		ctx.setBuf((byte)dirent);
		dirent.ext2fs_get_rec_len(fs, generatedBuflen);
		ret |=  ModernizedCProgram.ext2fs_process_dir_block(fs, 0, blockcnt++, 0, 0, priv_data);
		Object generatedInode = dirent.getInode();
		if (ret & 8) {
			 err = new ();
			generatedI_block[0] = /*Error: Function owner not recognized*/ext2fs_cpu_to_le32(generatedInode);
			err = inode.ext2fs_write_inode(fs, ino);
			if (err) {
				;
			} 
			ret &=  ~8;
		} 
		if (ret & 2) {
			;
		} 
		ctx.setBuf((byte)generatedI_block + (true));
		ctx.setBuflen(((/*Error: Unsupported expression*/ * (((12 + 1) + 1) + 1))) - (true));
		ret |=  ModernizedCProgram.ext2fs_process_dir_block(fs, 0, blockcnt++, 0, 0, priv_data);
		if (ret & 8) {
			ctx.setErrcode(inode.ext2fs_write_inode(fs, ino));
			if (generatedErrcode) {
				ret |=  2;
			} 
			ret &=  ~8;
		} 
		if (ret & 2) {
			;
		} 
		data.setFs(fs);
		data.setIno(ino);
		ctx.setErrcode(data.ext2fs_inline_data_ea_get());
		if (generatedErrcode) {
			ret |=  2;
			;
		} 
		Object generatedEa_size = data.getEa_size();
		if (generatedEa_size <= 0) {
			;
		} 
		Object generatedEa_data = data.getEa_data();
		ctx.setBuf(generatedEa_data);
		ctx.setBuflen(generatedEa_size);
		ret |=  ModernizedCProgram.ext2fs_process_dir_block(fs, 0, blockcnt++, 0, 0, priv_data);
		if (ret & 8) {
			ctx.setErrcode(data.ext2fs_inline_data_ea_set());
			if (generatedErrcode) {
				ret |=  2;
			} 
		} 
		ctx.setBuflen(old_buflen);
		ctx.setFlags(old_flags);
		ret &=  ~(2 | 8);
		return ret;
	}
	public static Object ext2fs_inline_data_ea_remove(Object fs, Object ino) {
		ext2_xattr_handle handle = new ext2_xattr_handle();
		 retval = new ();
		retval = handle.ext2fs_xattrs_open(fs, ino);
		if (retval) {
			return retval;
		} 
		retval = handle.ext2fs_xattrs_read();
		if (retval) {
			;
		} 
		retval = handle.ext2fs_xattr_remove("system.data");
		return retval;
	}
	public static Object ext2fs_inline_data_convert_dir(Object fs, Object ino, Byte bbuf, Byte ibuf, int size) {
		ext2_dir_entry dir = new ext2_dir_entry();
		ext2_dir_entry dir2 = new ext2_dir_entry();
		ext2_dir_entry_tail t = new ext2_dir_entry_tail();
		 retval = new ();
		int offset;
		int rec_len;
		int csum_size = 0;
		int filetype = 0;
		if (fs.getSuper().ext2fs_has_feature_metadata_csum()) {
			csum_size = /*Error: Unsupported expression*/;
		} 
		if (fs.getSuper().ext2fs_has_feature_filetype()) {
			filetype = 2/*
				 * Set up entry for '.'
				 */;
		} 
		dir = (ext2_dir_entry)bbuf;
		dir.setInode(ino);
		ModernizedCProgram.ext2fs_dirent_set_name_len(dir, 1);
		ModernizedCProgram.ext2fs_dirent_set_file_type(dir, filetype);
		Object generatedName = dir.getName();
		generatedName[0] = (byte)'.';
		rec_len = (fs.getBlocksize() - csum_size) - (((true) + 8 + (4 - 1)) & ~(4 - 1));
		dir.setRec_len((((true) + 8 + (4 - 1)) & ~(4 - 1/*
			 * Set up entry for '..'
			 */)));
		Object generatedRec_len = dir.getRec_len();
		dir = (ext2_dir_entry)(bbuf + generatedRec_len);
		dir.setRec_len((((true) + 8 + (4 - 1)) & ~(4 - 1)));
		dir.setInode(/*Error: Function owner not recognized*/ext2fs_le32_to_cpu((()ibuf)[0]));
		ModernizedCProgram.ext2fs_dirent_set_name_len(dir, 2);
		ModernizedCProgram.ext2fs_dirent_set_file_type(dir, filetype);
		generatedName[0] = (byte)'.';
		generatedName[1] = (byte)'.'/*
			 * Adjust the last rec_len
			 */;
		offset = (((true) + 8 + (4 - 1)) & ~(4 - 1)) + (((true) + 8 + (4 - 1)) & ~(4 - 1));
		dir = (ext2_dir_entry)(bbuf + offset);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(bbuf + offset, ibuf + (true), size - (true));
		size += (((true) + 8 + (4 - 1)) & ~(4 - 1)) + (((true) + 8 + (4 - 1)) & ~(4 - 1)) - (true);
		do {
			dir2 = dir;
			retval = dir.ext2fs_get_rec_len(fs, rec_len);
			if (retval) {
				;
			} 
			offset += rec_len;
			dir = (ext2_dir_entry)(bbuf + offset);
		} while (offset < size);
		rec_len += fs.getBlocksize() - csum_size - offset;
		retval = dir2.ext2fs_set_rec_len(fs, rec_len);
		if (retval) {
			;
		} 
		if (csum_size) {
			t = ((ext2_dir_entry_tail)(((byte)(bbuf)) + (fs.getBlocksize()) - /*Error: Unsupported expression*/));
			t.ext2fs_initialize_dirent_tail(fs);
		} 
	}
	public static Object ext2fs_inline_data_expand(Object fs, Object ino) {
		ext2_inode inode = new ext2_inode();
		ext2_inline_data data = new ext2_inline_data();
		 retval = new ();
		size_t inline_size = new size_t();
		byte inline_buf = 0;
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		retval = inode.ext2fs_read_inode(fs, ino);
		if (retval) {
			return retval;
		} 
		Object generatedI_flags = inode.getI_flags();
		if (!(generatedI_flags & -1024)) {
			return EXT2_ET_NO_INLINE_DATA;
		} 
		data.setFs(fs);
		data.setIno(ino);
		retval = data.ext2fs_inline_data_ea_get();
		if (retval) {
			return retval;
		} 
		Object generatedEa_size = data.getEa_size();
		inline_size = generatedEa_size + ((/*Error: Unsupported expression*/ * (((12 + 1) + 1) + 1)));
		retval = ModernizedCProgram.ext2fs_get_mem(inline_size, inline_buf);
		if (retval) {
			;
		} 
		Object generatedI_block = inode.getI_block();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(inline_buf, (Object)generatedI_block, ((/*Error: Unsupported expression*/ * (((12 + 1) + 1) + 1))));
		Object generatedEa_data = data.getEa_data();
		if (generatedEa_size > 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(inline_buf + ((/*Error: Unsupported expression*/ * (((12 + 1) + 1) + 1))), generatedEa_data, generatedEa_size);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset((Object)generatedI_block, 0, ((/*Error: Unsupported expression*/ * (((12 + 1) + 1) + 1/*
			 * NOTE: We must do this write -> ea_remove -> read cycle here because
			 * removing the inline data EA can free the EA block, which is a change
			 * that our stack copy of the inode will never see.  If that happens,
			 * we can end up with the EA block and lblk 0 pointing to the same
			 * pblk, which is bad news.
			 */))));
		retval = inode.ext2fs_write_inode(fs, ino);
		if (retval) {
			;
		} 
		retval = ModernizedCProgram.ext2fs_inline_data_ea_remove(fs, ino);
		if (retval) {
			;
		} 
		retval = inode.ext2fs_read_inode(fs, ino);
		if (retval) {
			;
		} 
		Object generatedI_mode = inode.getI_mode();
		if ((((generatedI_mode) & 170000) == 40000)) {
			retval = inode.ext2fs_inline_data_dir_expand(fs, ino, inline_buf, inline_size);
		} else {
				retval = inode.ext2fs_inline_data_file_expand(fs, ino, inline_buf, inline_size);
		} 
		ModernizedCProgram.ext2fs_free_mem(generatedEa_data);
		return retval/*
		 * When caller uses this function to retrieve the inline data, it must
		 * allocate a buffer which has the size of inline data.  The size of
		 * inline data can be know by ext2fs_inline_data_get_size().
		 */;
	}
	public static Object ext2fs_flush_icache(Object fs) {
		int i;
		if (!fs.getIcache()) {
			return 0;
		} 
		for (i = 0; i < fs.getIcache().getCache_size(); i++) {
			fs.getIcache().getCache()[i].setExt2_inode_cache_ent(0);
		}
		fs.getIcache().setBuffer_blk(0);
		return 0/*
		 * Free the inode cache structure
		 */;
	}
	public static Object ext2fs_create_inode_cache(Object fs, int cache_size) {
		int i;
		 retval = new ();
		if (fs.getIcache()) {
			return 0;
		} 
		retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Unsupported expression*/, fs.getIcache());
		if (retval) {
			return retval;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(fs.getIcache(), 0, /*Error: Unsupported expression*/);
		retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), fs.getIcache().getBuffer());
		if (retval) {
			;
		} 
		fs.getIcache().setBuffer_blk(0);
		fs.getIcache().setCache_last(-1);
		fs.getIcache().setCache_size(cache_size);
		fs.getIcache().setRefcount(1);
		retval = ModernizedCProgram.ext2fs_get_array(fs.getIcache().getCache_size(), /*Error: Unsupported expression*/, fs.getIcache().getCache());
		if (retval) {
			;
		} 
		for (i = 0; i < fs.getIcache().getCache_size(); i++) {
			retval = ModernizedCProgram.ext2fs_get_mem((((fs.getSuper()).getS_rev_level() == 0) ? 128 : (fs.getSuper()).getS_inode_size()), fs.getIcache().getCache()[i].getExt2_inode_cache_ent());
			if (retval) {
				;
			} 
		}
		ModernizedCProgram.ext2fs_flush_icache(fs);
		return 0;
		fs.setIcache(0);
		return retval;
	}
	public static Object ext2fs_open_inode_scan(Object fs, int buffer_blocks, Object ret_scan) {
		ext2_inode_scan scan = new ext2_inode_scan();
		 retval = new ();
		 save_get_blocks = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS/*
				 * If fs->badblocks isn't set, then set it --- since the inode
				 * scanning functions require it.
				 */);
		} 
		if (fs.getBadblocks() == 0/*
				 * Temporarily save fs->get_blocks and set it to zero,
				 * for compatibility with old e2fsck's.
				 */) {
			save_get_blocks = fs.getGet_blocks();
			fs.setGet_blocks(0);
			retval = ModernizedCProgram.ext2fs_read_bb_inode(fs, fs.getBadblocks());
			if (retval && fs.getBadblocks()) {
				ModernizedCProgram.ext2fs_badblocks_list_free(fs.getBadblocks());
				fs.setBadblocks(0);
			} 
			fs.setGet_blocks(save_get_blocks);
		} 
		retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Unsupported expression*/, scan);
		if (retval) {
			return retval;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(scan, 0, /*Error: Unsupported expression*/);
		scan.setMagic(EXT2_ET_MAGIC_INODE_SCAN);
		scan.setFs(fs);
		scan.setInode_size((((fs.getSuper()).getS_rev_level() == 0) ? 128 : (fs.getSuper()).getS_inode_size()));
		scan.setBytes_left(0);
		scan.setCurrent_group(0);
		scan.setGroups_left(fs.getGroup_desc_count() - 1);
		scan.setInode_buffer_blocks(buffer_blocks ? buffer_blocks : 8);
		scan.setCurrent_block(ModernizedCProgram.ext2fs_inode_table_loc(scan.getFs(), scan.getCurrent_group()));
		if (scan.getCurrent_block() && ((scan.getCurrent_block() < fs.getSuper().getS_first_data_block()) || (scan.getCurrent_block() + fs.getInode_blocks_per_group() - 1 >= fs.getSuper().ext2fs_blocks_count()))) {
			ModernizedCProgram.ext2fs_free_mem(scan);
			return EXT2_ET_GDESC_BAD_INODE_TABLE;
		} 
		scan.setInodes_left(((scan.getFs().getSuper()).getS_inodes_per_group()));
		scan.setBlocks_left(scan.getFs().getInode_blocks_per_group());
		if (ModernizedCProgram.ext2fs_has_group_desc_csum(fs)) {
			 unused = ModernizedCProgram.ext2fs_bg_itable_unused(fs, scan.getCurrent_group());
			if (scan.getInodes_left() > unused) {
				scan.getInodes_left() -= unused;
			} else {
					scan.setInodes_left(0);
			} 
			scan.setBlocks_left((scan.getInodes_left() + (fs.getBlocksize() / scan.getInode_size() - 1)) * scan.getInode_size() / fs.getBlocksize());
		} 
		retval = ModernizedCProgram.io_channel_alloc_buf(fs.getIo(), scan.getInode_buffer_blocks(), scan.getInode_buffer());
		scan.setDone_group(0);
		scan.setDone_group_data(0);
		scan.setBad_block_ptr(0);
		if (retval) {
			ModernizedCProgram.ext2fs_free_mem(scan);
			return retval;
		} 
		retval = ModernizedCProgram.ext2fs_get_mem(scan.getInode_size() + scan.getInode_buffer_blocks(), scan.getTemp_buffer());
		if (retval) {
			ModernizedCProgram.ext2fs_free_mem(scan.getInode_buffer());
			ModernizedCProgram.ext2fs_free_mem(scan);
			return retval;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(((scan).getTemp_buffer() + (scan).getInode_size()), 0, scan.getInode_buffer_blocks());
		if (scan.getFs().getBadblocks() && scan.getFs().getBadblocks().getNum()) {
			scan.getScan_flags() |=  -1024;
		} 
		if (ModernizedCProgram.ext2fs_has_group_desc_csum(fs)) {
			scan.getScan_flags() |=  -1024;
		} 
		ret_scan = scan;
		return 0;
	}
	public static void ext2fs_close_inode_scan(Object scan) {
		if (!scan || (scan.getMagic() != EXT2_ET_MAGIC_INODE_SCAN)) {
			return /*Error: Unsupported expression*/;
		} 
		ModernizedCProgram.ext2fs_free_mem(scan.getInode_buffer());
		scan.setInode_buffer(((Object)0));
		ModernizedCProgram.ext2fs_free_mem(scan.getTemp_buffer());
		scan.setTemp_buffer(((Object)0));
		ModernizedCProgram.ext2fs_free_mem(scan);
		return /*Error: Unsupported expression*/;
	}
	public static void ext2fs_set_inode_callback(Object scan, Object done_group, Object done_group_data) {
		if (!scan || (scan.getMagic() != EXT2_ET_MAGIC_INODE_SCAN)) {
			return /*Error: Unsupported expression*/;
		} 
		scan.setDone_group(done_group);
		scan.setDone_group_data(done_group_data);
	}
	public static int ext2fs_inode_scan_flags(Object scan, int set_flags, int clear_flags) {
		int old_flags;
		if (!scan || (scan.getMagic() != EXT2_ET_MAGIC_INODE_SCAN)) {
			return 0;
		} 
		old_flags = scan.getScan_flags();
		scan.getScan_flags() &=  ~clear_flags;
		scan.getScan_flags() |=  set_flags;
		return old_flags/*
		 * This function is called by ext2fs_get_next_inode when it needs to
		 * get ready to read in a new blockgroup.
		 */;
	}
	public static Object get_next_blockgroup(Object scan) {
		ext2_filsys fs = scan.getFs();
		scan.getCurrent_group()++;
		scan.getGroups_left()--;
		scan.setCurrent_block(ModernizedCProgram.ext2fs_inode_table_loc(scan.getFs(), scan.getCurrent_group()));
		scan.setCurrent_inode(scan.getCurrent_group() * ((fs.getSuper()).getS_inodes_per_group()));
		scan.setBytes_left(0);
		scan.setInodes_left(((fs.getSuper()).getS_inodes_per_group()));
		scan.setBlocks_left(fs.getInode_blocks_per_group());
		if (ModernizedCProgram.ext2fs_has_group_desc_csum(fs)) {
			 unused = ModernizedCProgram.ext2fs_bg_itable_unused(fs, scan.getCurrent_group());
			if (scan.getInodes_left() > unused) {
				scan.getInodes_left() -= unused;
			} else {
					scan.setInodes_left(0);
			} 
			scan.setBlocks_left((scan.getInodes_left() + (fs.getBlocksize() / scan.getInode_size() - 1)) * scan.getInode_size() / fs.getBlocksize());
		} 
		if (scan.getCurrent_block() && ((scan.getCurrent_block() < fs.getSuper().getS_first_data_block()) || (scan.getCurrent_block() + fs.getInode_blocks_per_group() - 1 >= fs.getSuper().ext2fs_blocks_count()))) {
			return EXT2_ET_GDESC_BAD_INODE_TABLE;
		} 
		return 0;
	}
	public static Object ext2fs_inode_scan_goto_blockgroup(Object scan, int group) {
		scan.setCurrent_group(group - 1);
		scan.setGroups_left(scan.getFs().getGroup_desc_count() - group);
		return ModernizedCProgram.get_next_blockgroup(scan/*
		 * This function is called by get_next_blocks() to check for bad
		 * blocks in the inode table.
		 *
		 * This function assumes that badblocks_list->list is sorted in
		 * increasing order.
		 */);
	}
	public static Object check_for_inode_bad_blocks(Object scan, Object num_blocks) {
		 blk = scan.getCurrent_block();
		badblocks_list bb = scan.getFs().getBadblocks();
		if (blk == 0) {
			return 0/*
				 * If the current block is greater than the bad block listed
				 * in the bad block list, then advance the pointer until this
				 * is no longer the case.  If we run out of bad blocks, then
				 * we don't need to do any more checking!
				 */;
		} 
		while (blk > bb.getList()[scan.getBad_block_ptr()]) {
			if (++scan.getBad_block_ptr() >= bb.getNum()) {
				scan.getScan_flags() &=  ~-1024;
				return 0/*
					 * If the current block is equal to the bad block listed in
					 * the bad block list, then handle that one block specially.
					 * (We could try to handle runs of bad blocks, but that
					 * only increases CPU efficiency by a small amount, at the
					 * expense of a huge expense of code complexity, and for an
					 * uncommon case at that.)
					 */;
			} 
		}
		if (blk == bb.getList()[scan.getBad_block_ptr()]) {
			scan.getScan_flags() |=  -1024;
			num_blocks = 1;
			if (++scan.getBad_block_ptr() >= bb.getNum()) {
				scan.getScan_flags() &=  ~-1024;
			} 
			return 0/*
				 * If there is a bad block in the range that we're about to
				 * read in, adjust the number of blocks to read so that we we
				 * don't read in the bad block.  (Then the next block to read
				 * will be the bad block, which is handled in the above case.)
				 */;
		} 
		if ((blk + num_blocks) > bb.getList()[scan.getBad_block_ptr()]) {
			num_blocks = (int)(bb.getList()[scan.getBad_block_ptr()] - blk);
		} 
		return 0;
	}
	public static void check_inode_block_sanity(Object scan, Object num_blocks) {
		 ino = new ();
		 inodes_to_scan = new ();
		int badness;
		int checksum_failures;
		int inodes_in_buf;
		int inodes_per_block;
		byte p;
		ext2_inode_large inode = new ext2_inode_large();
		byte block_status;
		int blk;
		int bad_csum;
		if (!(scan.getScan_flags() & -1024)) {
			return /*Error: Unsupported expression*/;
		} 
		inodes_to_scan = scan.getInodes_left();
		inodes_in_buf = num_blocks * scan.getFs().getBlocksize() / scan.getInode_size();
		if (inodes_to_scan > inodes_in_buf) {
			inodes_to_scan = inodes_in_buf;
		} 
		p = (byte)scan.getInode_buffer();
		ino = scan.getCurrent_inode() + 1;
		checksum_failures = badness = 0;
		block_status = ((scan).getTemp_buffer() + (scan).getInode_size());
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(block_status, 0, scan.getInode_buffer_blocks());
		inodes_per_block = (((1 << 10) << (scan.getFs().getSuper()).getS_log_block_size()) / (((scan.getFs().getSuper()).getS_rev_level() == 0) ? 128 : (scan.getFs().getSuper()).getS_inode_size()));
		if (inodes_per_block < 2) {
			return /*Error: Unsupported expression*/;
		} 
		while (inodes_to_scan > 0) {
			blk = (p - (byte)scan.getInode_buffer()) / scan.getFs().getBlocksize();
			bad_csum = (ext2_inode_large)p.ext2fs_inode_csum_verify(scan.getFs(), ino) == 0;
			inode = (ext2_inode_large)p;
			if (/* Is this inode insane? */bad_csum) {
				checksum_failures++;
				badness++;
			}  else if (inode.extent_head_looks_insane() || inode.block_map_looks_insane(scan.getFs())) {
				badness++;
			} 
			if (badness > inodes_per_block / /* If more than half are insane, declare the whole block bad */2) {
				int ino_adj;
				block_status[blk] |=  2;
				ino_adj = inodes_per_block - ((ino - 1) % inodes_per_block);
				if (ino_adj > inodes_to_scan) {
					ino_adj = inodes_to_scan;
				} 
				inodes_to_scan -= ino_adj;
				p += scan.getInode_size() * ino_adj;
				ino += ino_adj;
				checksum_failures = badness = 0;
				continue;
			} 
			if ((ino % inodes_per_block) == 0) {
				if (checksum_failures == 0) {
					block_status[blk] |=  1;
				} 
				checksum_failures = badness = 0;
			} 
			inodes_to_scan--;
			p += scan.getInode_size();
			ino++;
		}
		;
	}
	/*
	 * This function is called by ext2fs_get_next_inode when it needs to
	 * read in more blocks from the current blockgroup's inode table.
	 */
	public static Object get_next_blocks(Object scan) {
		 num_blocks = new ();
		 retval = new ();
		/*
			 * Figure out how many blocks to read; we read at most
			 * inode_buffer_blocks, and perhaps less if there aren't that
			 * many blocks left to read.
			 */
		num_blocks = scan.getInode_buffer_blocks();
		if (num_blocks > scan.getBlocks_left()) {
			num_blocks = scan.getBlocks_left();
		} 
		if (scan.getScan_flags() & -1024) {
			if (scan.getBytes_left()) {
				scan.getScan_flags() |=  -1024;
			} 
			scan.getScan_flags() &=  ~-1024;
		} 
		if (scan.getScan_flags() & /*
			 * Do inode bad block processing, if necessary.
			 */-1024) {
			retval = ModernizedCProgram.check_for_inode_bad_blocks(scan, num_blocks);
			if (retval) {
				return retval;
			} 
		} 
		if ((scan.getScan_flags() & -1024) || (scan.getCurrent_block() == 0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(scan.getInode_buffer(), 0, (size_t)num_blocks * scan.getFs().getBlocksize());
		} else {
				retval = ModernizedCProgram.io_channel_read_blk64(scan.getFs().getIo(), scan.getCurrent_block(), (int)num_blocks, scan.getInode_buffer());
				if (retval) {
					return EXT2_ET_NEXT_INODE_READ;
				} 
		} 
		ModernizedCProgram.check_inode_block_sanity(scan, num_blocks);
		scan.setPtr(scan.getInode_buffer());
		scan.setBytes_left(num_blocks * scan.getFs().getBlocksize());
		scan.getBlocks_left() -= num_blocks;
		if (scan.getCurrent_block()) {
			scan.getCurrent_block() += num_blocks;
		} 
		return 0/*
		 * Returns 1 if the entire inode_buffer has a non-zero size and
		 * contains all zeros.  (Not just deleted inodes, since that means
		 * that part of the inode table was used at one point; we want all
		 * zeros, which means that the inode table is pristine.)
		 */;
	}
	public static Object ext2fs_get_blocks(Object fs, Object ino, Object[] blocks) {
		ext2_inode inode = new ext2_inode();
		int i;
		 retval = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		if (ino > fs.getSuper().getS_inodes_count()) {
			return EXT2_ET_BAD_INODE_NUM;
		} 
		if (fs.getGet_blocks()) {
			if (!/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, ino, blocks)) {
				return 0;
			} 
		} 
		retval = inode.ext2fs_read_inode(fs, ino);
		if (retval) {
			return retval;
		} 
		Object generatedI_block = inode.getI_block();
		for (i = 0; i < (((12 + 1) + 1) + 1); i++) {
			blocks[i] = generatedI_block[i];
		}
		return 0;
	}
	public static Object ext2fs_check_directory(Object fs, Object ino) {
		ext2_inode inode = new ext2_inode();
		 retval = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		if (ino > fs.getSuper().getS_inodes_count()) {
			return EXT2_ET_BAD_INODE_NUM;
		} 
		if (fs.getCheck_directory()) {
			retval = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, ino);
			if (retval != EXT2_ET_CALLBACK_NOTHANDLED) {
				return retval;
			} 
		} 
		retval = inode.ext2fs_read_inode(fs, ino);
		if (retval) {
			return retval;
		} 
		Object generatedI_mode = inode.getI_mode();
		if (!(((generatedI_mode) & 170000) == 40000)) {
			return EXT2_ET_NO_DIRECTORY;
		} 
		return 0;
	}
	/* ----------------------------------------------------------------------- *
	 *
	 *   Copyright 1998-2011 H. Peter Anvin - All Rights Reserved
	 *   Copyright 2009-2011 Intel Corporation; author H. Peter Anvin
	 *   Copyright 2011 Paulo Alcantara <pcacjr@gmail.com>
	 *
	 *   This program is free software; you can redistribute it and/or modify
	 *   it under the terms of the GNU General Public License as published by
	 *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
	 *   Boston MA 02111-1307, USA; either version 2 of the License, or
	 *   (at your option) any later version; incorporated herein by reference.
	 *
	 * ----------------------------------------------------------------------- */
	/*
	 * fs.c - Generic sanity check for FAT/NTFS-based installers
	 */
	/* Required on glibc 2.x */
	/* glibc 2.20 deprecates _BSD_SOURCE in favour of _DEFAULT_SOURCE */
	public static void syslinux_make_bootsect(Object bs, int fs_type) {
		Object generatedBsJump = bootsect.getBsJump();
		 generatedBs32 = bootsect.getBs32();
		Object generatedCode = generatedBs32.getCode();
		if (fs_type == filesystem.VFAT) {
			fat_boot_sector bootsect = bs;
			fat_boot_sector sbs = (fat_boot_sector)ModernizedCProgram.syslinux_ldlinux[1];
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBsJump, generatedBsJump, ((size_t)((fat_boot_sector)0).getBsBytesPerSec()));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedCode, generatedCode, (((size_t)((fat_boot_sector)0).getBsSignature()) - ((size_t)generatedCode)));
		}  else if (fs_type == filesystem.NTFS) {
			ntfs_boot_sector bootsect = bs;
			ntfs_boot_sector sbs = (ntfs_boot_sector)ModernizedCProgram.syslinux_ldlinux[1];
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBsJump, generatedBsJump, ((size_t)((ntfs_boot_sector)0).getBsOemName()));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedCode, generatedCode, (((size_t)((ntfs_boot_sector)0).getBsSignature()) - ((size_t)generatedCode)));
		} 
	}
	public static Object check_fat_bootsect(Object bs, Integer fs_type) {
		int sectorsize;
		fat_boot_sector sectbuf = bs;
		long sectors;
		long fatsectors;
		long dsectors;
		long clusters;
		int rootdirents;
		int clustersize;
		sectorsize = ModernizedCProgram.get_16(sectbuf.getBsBytesPerSec());
		clustersize = ModernizedCProgram.get_8(sectbuf.getBsSecPerClust());
		if (clustersize == 0 || (clustersize & (clustersize - 1))) {
			return "impossible cluster size on an FAT volume";
		} 
		sectors = ModernizedCProgram.get_16(sectbuf.getBsSectors());
		sectors = sectors ? sectors : ModernizedCProgram.get_32(sectbuf.getBsHugeSectors());
		dsectors = sectors - ModernizedCProgram.get_16(sectbuf.getBsResSectors());
		fatsectors = ModernizedCProgram.get_16(sectbuf.getBsFATsecs());
		fatsectors = fatsectors ? fatsectors : ModernizedCProgram.get_32(sectbuf.getBs32().getFATSz32());
		fatsectors *= ModernizedCProgram.get_8(sectbuf.getBsFATs());
		dsectors -= fatsectors;
		rootdirents = ModernizedCProgram.get_16(sectbuf.getBsRootDirEnts());
		dsectors -= (rootdirents + sectorsize / 32 - 1) / sectorsize;
		if (dsectors < 0) {
			return "negative number of data sectors on an FAT volume";
		} 
		clusters = dsectors / clustersize;
		fatsectors = ModernizedCProgram.get_16(sectbuf.getBsFATsecs());
		fatsectors = fatsectors ? fatsectors : ModernizedCProgram.get_32(sectbuf.getBs32().getFATSz32());
		fatsectors *= ModernizedCProgram.get_8(sectbuf.getBsFATs());
		if (!fatsectors) {
			return "zero FAT sectors";
		} 
		if (clusters < -1024) {
			if (!ModernizedCProgram.get_16(sectbuf.getBsFATsecs())) {
				return "zero FAT sectors (FAT12/16)";
			} 
			if (ModernizedCProgram.get_8(sectbuf.getBs16().getBootSignature()) == -1024) {
				if (!/*Error: Function owner not recognized*/memcmp(sectbuf.getBs16().getFileSysType(), "FAT12   ", 8)) {
					if (clusters >= -1024) {
						return "more than 4084 clusters but claims FAT12";
					} 
				}  else if (!/*Error: Function owner not recognized*/memcmp(sectbuf.getBs16().getFileSysType(), "FAT16   ", 8)) {
					if (clusters < -1024) {
						return "less than 4084 clusters but claims FAT16";
					} 
				}  else if (!/*Error: Function owner not recognized*/memcmp(sectbuf.getBs16().getFileSysType(), "FAT32   ", 8)) {
					return "less than 65525 clusters but claims FAT32";
				}  else if (/*Error: Function owner not recognized*/memcmp(sectbuf.getBs16().getFileSysType(), "FAT     ", 8)) {
					byte[] fserr = "filesystem type \"????????\" not supported";
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(fserr + 17, sectbuf.getBs16().getFileSysType(), 8);
					return fserr;
				} 
			} 
		}  else if (clusters < -1024/*
			 * FAT32...
			 *
			 * Moving the FileSysType and BootSignature was a lovely stroke
			 * of M$ idiocy...
			 */) {
			if (ModernizedCProgram.get_8(sectbuf.getBs32().getBootSignature()) != -1024 || /*Error: Function owner not recognized*/memcmp(sectbuf.getBs32().getFileSysType(), "FAT32   ", 8)) {
				return "missing FAT32 signature";
			} 
		} else {
				return "impossibly large number of clusters on an FAT volume";
		} 
		if (fs_type) {
			fs_type = filesystem.VFAT;
		} 
		return ((Object)0);
	}
	public static Object check_ntfs_bootsect(Object bs, Integer fs_type) {
		ntfs_boot_sector sectbuf = bs;
		if (/*Error: Function owner not recognized*/memcmp(sectbuf.getBsOemName(), "NTFS    ", 8) && /*Error: Function owner not recognized*/memcmp(sectbuf.getBsOemName(), "MSWIN4.0", 8) && /*Error: Function owner not recognized*/memcmp(sectbuf.getBsOemName(), "MSWIN4.1", 8)) {
			return "unknown OEM name but claims NTFS";
		} 
		if (fs_type) {
			fs_type = filesystem.NTFS;
		} 
		return ((Object)0);
	}
	public static Object syslinux_check_bootsect(Object bs, Integer fs_type) {
		uint8_t media_sig = new uint8_t();
		int sectorsize;
		fat_boot_sector sectbuf = bs;
		byte retval;
		media_sig = ModernizedCProgram.get_8(sectbuf.getBsMedia());
		if (media_sig != -1024 && media_sig < /* Must be 0xF0 or 0xF8-0xFF for FAT/NTFS volumes */-1024) {
			return "invalid media signature (not an FAT/NTFS volume?)";
		} 
		sectorsize = ModernizedCProgram.get_16(sectbuf.getBsBytesPerSec());
		if (sectorsize == /* ok */ModernizedCProgram.SECTOR_SIZE) {
			;
		}  else if (sectorsize >= 512 && sectorsize <= 4096 && (sectorsize & (sectorsize - 1)) == 0) {
			return "unsupported sectors size";
		} else {
				return "impossible sector size";
		} 
		if (ModernizedCProgram.ntfs_check_zero_fields((ntfs_boot_sector)bs)) {
			retval = ModernizedCProgram.check_ntfs_bootsect(bs, fs_type);
		} else {
				retval = ModernizedCProgram.check_fat_bootsect(bs, fs_type);
		} 
		return retval;
	}
	public static void ext2fs_sha512(Object in, long in_size, Byte out) {
		hash_state md = new hash_state();
		md.sha512_init();
		md.sha512_process(in, in_size);
		md.sha512_done(out);
	}
	/*
	  Copyright (C) 2005, 2006, 2008, 2010, 2012 Rocky Bernstein <rocky@gnu.org>
	
	  This program is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  This program is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/
	/* Access routines */
	/* udf_private.h has to come first else _FILE_OFFSET_BITS are redefined in
	   say opensolaris. */
	/* Remove when adding cdio/logging.h */
	/* Useful defines */
	public static Object udf_get_filename(Object p_udf_dirent) {
		if (!p_udf_dirent) {
			return NULL;
		} 
		if (!p_udf_dirent.getPsz_name()) {
			return "..";
		} 
		return p_udf_dirent.getPsz_name();
	}
	/* Copy an UDF File Entry into a Directory Entry structure. */
	public static Object udf_get_file_entry(Object p_udf_dirent, Object p_udf_fe) {
		if (!p_udf_dirent) {
			return false;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_udf_fe, p_udf_dirent.getFe(), /*Error: Unsupported expression*/);
		return true/*!
		  Return the file id descriptor of the given file.
		*/;
	}
	/*out*/
	public static Object udf_get_fileid_descriptor(Object p_udf_dirent, Object p_udf_fid) {
		if (!p_udf_dirent) {
			return false;
		} 
		if (!p_udf_dirent.getFid()) {
			return /* FIXME do something about trying to get the descriptor. */false;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_udf_fid, p_udf_dirent.getFid(), /*Error: Unsupported expression*/);
		return true;
	}
	/*out*/
	/*!
	  Return the number of hard links of the file. Return 0 if error.
	*/
	public static Object udf_get_link_count(Object p_udf_dirent) {
		if (p_udf_dirent) {
			return /*Error: Function owner not recognized*/uint16_from_le(p_udf_dirent.getFe().getLink_count());
		} 
		return /* Error. Non-error case handled above. */0/*!
		  Return the file length the file. Return 2147483647L if error.
		*/;
	}
	public static Object udf_get_file_length(Object p_udf_dirent) {
		if (p_udf_dirent) {
			return /*Error: Function owner not recognized*/uint64_from_le(p_udf_dirent.getFe().getInfo_len());
		} 
		return /* Error. Non-error case handled above. */-1024/*!
		  Return true if the file is a directory.
		*/;
	}
	public static Object udf_is_dir(Object p_udf_dirent) {
		return p_udf_dirent.getB_dir();
	}
	public static Object offset_to_lba(Object p_udf_dirent, Object i_offset, Object pi_lba, Object pi_max_size) {
		 p_udf = p_udf_dirent.getP_udf();
		 p_udf_fe = ()p_udf_dirent.getFe();
		 p_icb_tag = p_udf_fe.getIcb_tag();
		 strat_type = /*Error: Function owner not recognized*/uint16_from_le(p_icb_tag.getStrat_type());
		if (i_offset < 0) {
			ModernizedCProgram.cdio_warn("Negative offset value");
			return CDIO_INVALID_LBA;
		} 
		switch (strat_type) {
		case 4096:
				ModernizedCProgram.cdio_warn("Cannot deal with strategy4096 yet!");
				return CDIO_INVALID_LBA;
				break;
		case ICBTAG_STRATEGY_TYPE_4:
				{ 
					 icblen = 0;
					 lsector = new ();
					int ad_offset;
					int ad_num = 0;
					 addr_ilk = /*Error: Function owner not recognized*/uint16_from_le(p_icb_tag.getFlags() & ICBTAG_FLAG_AD_MASK);
					switch (addr_ilk) {
					case ICBTAG_FLAG_AD_SHORT:
							{ 
								 p_icb = new ();
								do {
									i_offset -= icblen;
									ad_offset = /*Error: Unsupported expression*/ * ad_num;
									if (ad_offset > /*Error: Function owner not recognized*/uint32_from_le(p_udf_fe.getI_alloc_descs())) {
										ModernizedCProgram.cdio_warn("File offset out of bounds");
										return CDIO_INVALID_LBA;
									} 
									p_icb = ()p_udf_fe.getU().getAlloc_descs()[/*Error: Function owner not recognized*/uint32_from_le(p_udf_fe.getI_extended_attr()) + ad_offset];
									icblen = p_icb.getLen();
									ad_num++;
								} while (i_offset >= icblen);
								lsector = (i_offset / UDF_BLOCKSIZE) + p_icb.getPos();
								pi_max_size = p_icb.getLen();
							}
							break;
					case ICBTAG_FLAG_AD_EXTENDED:
							ModernizedCProgram.cdio_warn("Don't know how to handle extended addresses yet");
							return CDIO_INVALID_LBA;
					case ICBTAG_FLAG_AD_LONG/*
						   * The allocation descriptor field is filled with long_ad's
						   * If the i_offset is beyond the current extent, look for the
						   * next extent.
						   */:
							{ 
								 p_icb = new ();
								do {
									i_offset -= icblen;
									ad_offset = /*Error: Unsupported expression*/ * ad_num;
									if (ad_offset > /*Error: Function owner not recognized*/uint32_from_le(p_udf_fe.getI_alloc_descs())) {
										ModernizedCProgram.cdio_warn("File offset out of bounds");
										return CDIO_INVALID_LBA;
									} 
									p_icb = ()p_udf_fe.getU().getAlloc_descs()[/*Error: Function owner not recognized*/uint32_from_le(p_udf_fe.getI_extended_attr()) + ad_offset];
									icblen = p_icb.getLen();
									ad_num++;
								} while (i_offset >= icblen);
								lsector = (i_offset / UDF_BLOCKSIZE) + /*Error: Function owner not recognized*/uint32_from_le((()(p_icb)).getLoc().getLba());
								pi_max_size = p_icb.getLen();
							}
							break;
					case ICBTAG_FLAG_AD_IN_ICB/*
						 * This type means that the file *data* is stored in the
						 * allocation descriptor field of the file entry.
						 */:
							pi_max_size = 0;
							ModernizedCProgram.cdio_warn("Don't know how to data in ICB handle yet");
							return CDIO_INVALID_LBA;
					default:
							ModernizedCProgram.cdio_warn("Unsupported allocation descriptor %d", addr_ilk);
							return CDIO_INVALID_LBA;
					}
					pi_lba = ()lsector + p_udf.getI_part_start();
					if (pi_lba < 0) {
						ModernizedCProgram.cdio_warn("Negative LBA value");
						return CDIO_INVALID_LBA;
					} 
					return pi_lba;
				}
		default:
				ModernizedCProgram.cdio_warn("Unknown strategy type %d", strat_type);
				return DRIVER_OP_ERROR/**
				  Attempts to read up to count bytes from UDF directory entry
				  p_udf_dirent into the buffer starting at buf. buf should be a
				  multiple of UDF_BLOCKSIZE bytes. Reading continues after the point
				  at which we last read or from the beginning the first time.
				
				  If count is zero, read() returns zero and has no other results. If
				  count is greater than SSIZE_MAX, the result is unspecified.
				
				  It is the caller's responsibility to ensure that count is less
				  than the number of blocks recorded via p_udf_dirent.
				
				  If there is an error, cast the result to driver_return_code_t for 
				  the specific error code.
				*/;
		}
	}
	/*out*/
	/*out*/
	public static Object udf_read_block(Object p_udf_dirent, Object buf, Object count) {
		if (count == 0) {
			return 0;
		} else {
				 ret = new ();
				 i_max_size = 0;
				 p_udf = p_udf_dirent.getP_udf();
				 i_lba = ModernizedCProgram.offset_to_lba(p_udf_dirent, p_udf.getI_position(), i_lba, i_max_size);
				if (i_lba != CDIO_INVALID_LBA) {
					 i_max_blocks = ((i_max_size + (UDF_BLOCKSIZE - 1)) / UDF_BLOCKSIZE);
					if (i_max_blocks < count) {
						ModernizedCProgram.cdio_warn("read count %u is larger than %u extent size.", (int)count, i_max_blocks);
						ModernizedCProgram.cdio_warn("read count truncated to %u", (int)count);
						count = i_max_blocks;
					} 
					ret = ModernizedCProgram.udf_read_sectors(p_udf, buf, i_lba, count);
					if (DRIVER_OP_SUCCESS == ret) {
						 i_read_len = (i_max_size < count * UDF_BLOCKSIZE) ? (i_max_size) : (count * UDF_BLOCKSIZE);
						p_udf.getI_position() += i_read_len;
						return i_read_len;
					} 
					return ret;
				} else {
						return DRIVER_OP_ERROR;
				} 
		} 
	}
	public static Object ext2fs_link(Object fs, Object dir, Object name, Object ino, int flags) {
		 retval = new ();
		link_struct ls = new link_struct();
		ext2_inode inode = new ext2_inode();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		if (!(fs.getFlags() & -1024)) {
			return EXT2_ET_RO_FILSYS;
		} 
		ls.setFs(fs);
		ls.setName(name);
		ls.setNamelen(name ? /*Error: Function owner not recognized*/strlen(name) : 0);
		ls.setInode(ino);
		ls.setFlags(flags);
		ls.setDone(0);
		ls.setSb(fs.getSuper());
		ls.setBlocksize(fs.getBlocksize());
		ls.setErr(0);
		retval = ModernizedCProgram.ext2fs_dir_iterate(fs, dir, 1, 0, link_proc, ls);
		if (retval) {
			return retval;
		} 
		Object generatedErr = ls.getErr();
		if (generatedErr) {
			return generatedErr;
		} 
		int generatedDone = ls.getDone();
		if (!generatedDone) {
			return EXT2_ET_DIR_NO_SPACE;
		} 
		if ((retval = inode.ext2fs_read_inode(fs, dir)) != 0) {
			return retval/*
				 * If this function changes to preserve the htree, remove the
				 * two hunks in link_proc that shove checksum tails into the
				 * former dx_root/dx_node blocks.
				 */;
		} 
		Object generatedI_flags = inode.getI_flags();
		if (generatedI_flags & -1024) {
			generatedI_flags &=  ~-1024;
			if ((retval = inode.ext2fs_write_inode(fs, dir)) != 0) {
				return retval;
			} 
		} 
		return 0;
	}
	/*
	 * initialize.c --- initialize a filesystem handle given superblock
	 * 	parameters.  Used by mke2fs when initializing a filesystem.
	 *
	 * Copyright (C) 1994, 1995, 1996 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/* by default */
	/* defined(LITES) && defined(EXT2_OS_LITES) */
	/* defined(__FreeBSD__) && defined(EXT2_OS_FREEBSD) */
	/* defined(__GNU__)     && defined(EXT2_OS_HURD) */
	/* defined(__linux__)   && defined(EXT2_OS_LINUX) */
	/*
	 * Calculate the number of GDT blocks to reserve for online filesystem growth.
	 * The absolute maximum number of GDT blocks we can reserve is determined by
	 * the number of block pointers that can fit into a single block.
	 */
	public static int calc_reserved_gdt_blocks(Object fs) {
		ext2_super_block sb = fs.getSuper();
		Object generatedS_blocks_per_group = sb.getS_blocks_per_group();
		long bpg = generatedS_blocks_per_group;
		Object generatedS_log_block_size = (sb).getS_log_block_size();
		Object generatedS_feature_incompat = (sb).getS_feature_incompat();
		Object generatedS_desc_size = (sb).getS_desc_size();
		int gdpb = (((1 << 10) << generatedS_log_block_size) / ((generatedS_feature_incompat & -1024) ? generatedS_desc_size : 32));
		long max_blocks = -1024;
		long rsv_groups;
		int rsv_gdb;
		/* We set it at 1024x the current filesystem size, or
			 * the upper block count limit (2^32), whichever is lower.
			 */
		if (sb.ext2fs_blocks_count() < max_blocks / 1024) {
			max_blocks = sb.ext2fs_blocks_count() * 1024/*
				 * ext2fs_div64_ceil() is unnecessary because max_blocks is
				 * max _GDT_ blocks, which is limited to 32 bits.
				 */;
		} 
		Object generatedS_first_data_block = sb.getS_first_data_block();
		rsv_groups = ModernizedCProgram.ext2fs_div_ceil(max_blocks - generatedS_first_data_block, bpg);
		rsv_gdb = ModernizedCProgram.ext2fs_div_ceil(rsv_groups, gdpb) - fs.getDesc_blocks();
		if (rsv_gdb > (((1 << 10) << generatedS_log_block_size) / /*Error: Unsupported expression*/)) {
			rsv_gdb = (((1 << 10) << generatedS_log_block_size) / /*Error: Unsupported expression*/);
		} 
		return rsv_gdb;
	}
	/*
	  Copyright (C) 2003, 2004, 2005, 2008, 2009, 2010, 2011
	  Rocky Bernstein <rocky@gnu.org>
	  Copyright (C) 2000 Herbert Valerio Riedel <hvr@gnu.org>
	
	  This program is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  This program is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/
	public static Object _cdio_strlenv(byte[][] str_array) {
		 n = 0;
		((str_array != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("str_array != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\util.c", 53));
		while (str_array[n]) {
			n++;
		}
		return n;
	}
	public static void _cdio_strfreev(byte[][] strv) {
		int n;
		((strv != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("strv != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\util.c", 66));
		for (n = 0; strv[n]; n++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(strv[n]);
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(strv);
	}
	/* fixme -- non-reentrant */
	public static Byte _cdio_strsplit(Object str, byte delim) {
		int n;
		byte strv = NULL;
		byte _str;
		byte p;
		byte[] _delim = new byte[]{0, 0};
		((str != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("str != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\util.c", 82));
		_str = /*Error: Function owner not recognized*/strdup(str);
		_delim[0] = delim;
		((_str != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("_str != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\util.c", 87));
		n = 1;
		p = _str;
		while (p) {
			if ((p++) == delim) {
				n++;
			} 
		}
		strv = /*Error: Function owner not recognized*/calloc(n + 1, /*Error: Unsupported expression*/);
		((strv != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("strv != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\util.c", 96));
		n = 0;
		while ((p = /*Error: Function owner not recognized*/strtok(n ? NULL : _str, _delim)) != NULL) {
			strv[n++] = /*Error: Function owner not recognized*/strdup(p);
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_str);
		return strv;
	}
	public static Object _cdio_memdup(Object mem, Object count) {
		Object new_mem = NULL;
		if (mem) {
			new_mem = /*Error: Function owner not recognized*/calloc(1, count);
			((new_mem != NULL) ? (Object)0 : /*Error: Function owner not recognized*/_assert("new_mem != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\util.c", 115));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(new_mem, mem, count);
		} 
		return new_mem;
	}
	public static Byte _cdio_strdup_upper(Object str) {
		byte new_str = NULL;
		if (str) {
			byte p;
			p = new_str = /*Error: Function owner not recognized*/strdup(str);
			while (p) {
				p = /*Error: Function owner not recognized*/toupper((byte)p);
				p++;
			}
		} 
		return new_str/* Convert MinGW/MSYS paths that start in "/c/..." to "c:/..."
		   so that they can be used with fopen(), stat(), etc.
		   Returned string must be freed by the caller using cdio_free().*/;
	}
	public static Byte _cdio_strdup_fixpath(Object path) {
		byte new_path = NULL;
		if (path) {
			new_path = /*Error: Function owner not recognized*/strdup(path);
			if (new_path && (/*Error: Function owner not recognized*/strlen(new_path) >= 3) && (new_path[0] == (byte)'/') && (new_path[2] == (byte)'/') && (/*Error: Function owner not recognized*/isalpha(new_path[1]))) {
				new_path[0] = new_path[1];
				new_path[1] = (byte)':';
			} 
		} 
		return new_path;
	}
	public static Object cdio_to_bcd8(Object n) {
		return ((n / 10) << 4) | (n % /*cdio_assert (n < 100);*/10);
	}
	public static Object cdio_from_bcd8(Object p) {
		return (-1024 & p) + (10 * (p >> 4));
	}
	public static int bcj_x86_test_msbyte(Object b) {
		return b == -1024 || b == -1024;
	}
	public static void bcj_flush(xz_dec_bcj s, xz_buf b) {
		size_t copy_size = new size_t();
		 generatedTemp = s.getTemp();
		Object generatedFiltered = generatedTemp.getFiltered();
		Object generatedOut_size = b.getOut_size();
		Object generatedOut_pos = b.getOut_pos();
		copy_size = ((generatedFiltered) < (generatedOut_size - generatedOut_pos) ? (generatedFiltered) : (generatedOut_size - generatedOut_pos));
		Object generatedOut = b.getOut();
		Object generatedBuf = generatedTemp.getBuf();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedOut + generatedOut_pos, generatedBuf, copy_size);
		generatedOut_pos += copy_size;
		generatedFiltered -= copy_size;
		Object generatedSize = generatedTemp.getSize();
		generatedSize -= copy_size;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memmove(generatedBuf, generatedBuf + copy_size, generatedSize);
	}
	public static xz_ret xz_dec_bcj_run(xz_dec_bcj s, xz_dec_lzma2 lzma2, xz_buf b) {
		size_t out_start = new size_t();
		/*
			 * Flush pending already filtered data to the output buffer. Return
			 * immediatelly if we couldn't flush everything, or if the next
			 * filter in the chain had already returned XZ_STREAM_END.
			 */
		 generatedTemp = s.getTemp();
		Object generatedFiltered = generatedTemp.getFiltered();
		xz_ret generatedRet = s.getRet();
		if (generatedFiltered > 0) {
			ModernizedCProgram.bcj_flush(s, b);
			if (generatedFiltered > 0) {
				return xz_ret.XZ_OK;
			} 
			if (generatedRet == xz_ret.XZ_STREAM_END) {
				return xz_ret.XZ_STREAM_END/*
					 * If we have more output space than what is currently pending in
					 * temp, copy the unfiltered data from temp to the output buffer
					 * and try to fill the output buffer by decoding more data from the
					 * next filter in the chain. Apply the BCJ filter on the new data
					 * in the output buffer. If everything cannot be filtered, copy it
					 * to temp and rewind the output buffer position accordingly.
					 *
					 * This needs to be always run when temp.size == 0 to handle a special
					 * case where the output buffer is full and the next filter has no
					 * more output coming but hasn't returned XZ_STREAM_END yet.
					 */;
			} 
		} 
		Object generatedSize = generatedTemp.getSize();
		Object generatedOut_size = b.getOut_size();
		Object generatedOut_pos = b.getOut_pos();
		Object generatedOut = b.getOut();
		Object generatedBuf = generatedTemp.getBuf();
		boolean generatedSingle_call = s.getSingle_call();
		if (generatedSize < generatedOut_size - generatedOut_pos || generatedSize == 0) {
			out_start = generatedOut_pos;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedOut + generatedOut_pos, generatedBuf, generatedSize);
			generatedOut_pos += generatedSize;
			s.setRet(ModernizedCProgram.xz_dec_lzma2_run(lzma2, b));
			if (generatedRet != xz_ret.XZ_STREAM_END && (generatedRet != xz_ret.XZ_OK || generatedSingle_call)) {
				return generatedRet;
			} 
			s.bcj_apply(generatedOut, out_start, generatedOut_pos);
			if (generatedRet == xz_ret.XZ_STREAM_END) {
				return xz_ret.XZ_STREAM_END;
			} 
			generatedTemp.setSize(generatedOut_pos - out_start);
			generatedOut_pos -= generatedSize;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBuf, generatedOut + generatedOut_pos, generatedSize);
			if (generatedOut_pos + generatedSize < generatedOut_size) {
				return xz_ret.XZ_OK/*
					 * We have unfiltered data in temp. If the output buffer isn't full
					 * yet, try to fill the temp buffer by decoding more data from the
					 * next filter. Apply the BCJ filter on temp. Then we hopefully can
					 * fill the actual output buffer by copying filtered data from temp.
					 * A mix of filtered and unfiltered data may be left in temp; it will
					 * be taken care on the next call to this function.
					 */;
			} 
		} 
		if (generatedOut_pos < generatedOut_size) {
			s.setOut(generatedOut);
			s.setOut_pos(generatedOut_pos);
			s.setOut_size(generatedOut_size);
			b.setOut(generatedBuf);
			b.setOut_pos(generatedSize);
			b.setOut_size(/*Error: sizeof expression not supported yet*/);
			s.setRet(ModernizedCProgram.xz_dec_lzma2_run(lzma2, b));
			generatedTemp.setSize(generatedOut_pos);
			b.setOut(generatedOut);
			b.setOut_pos(generatedOut_pos);
			b.setOut_size(generatedOut_size);
			if (generatedRet != xz_ret.XZ_OK && generatedRet != xz_ret.XZ_STREAM_END) {
				return generatedRet;
			} 
			s.bcj_apply(generatedBuf, generatedFiltered, generatedSize);
			if (generatedRet == xz_ret.XZ_STREAM_END) {
				generatedTemp.setFiltered(generatedSize);
			} 
			ModernizedCProgram.bcj_flush(s, b);
			if (generatedFiltered > 0) {
				return xz_ret.XZ_OK;
			} 
		} 
		return generatedRet;
	}
	/* !_EXT2_HAVE_ASM_BITOPS_ */
	public static void ext2fs_warn_bitmap(Object errcode, long arg, Object description) {
		if (description) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, errcode, "#%lu for %s", arg, description);
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err(0, errcode, "#%lu", arg/*
				 * C-only 64 bit ops.
				 */);
		} 
	}
	public static int ext2fs_set_bit64(Object nr, Object addr) {
		int mask;
		int retval;
		byte ADDR = (byte)addr;
		ADDR += nr >> 3;
		mask = 1 << (nr & -1024);
		retval = mask & ADDR;
		ADDR |=  mask;
		return retval;
	}
	public static int ext2fs_clear_bit64(Object nr, Object addr) {
		int mask;
		int retval;
		byte ADDR = (byte)addr;
		ADDR += nr >> 3;
		mask = 1 << (nr & -1024);
		retval = mask & ADDR;
		ADDR &=  ~mask;
		return retval;
	}
	public static int ext2fs_test_bit64(Object nr, Object addr) {
		int mask;
		byte ADDR = (byte)addr;
		ADDR += nr >> 3;
		mask = 1 << (nr & -1024);
		return (mask & ADDR);
	}
	public static int popcount8(int w) {
		int res = w - ((w >> 1) & -1024);
		res = (res & -1024) + ((res >> 2) & -1024);
		return (res + (res >> 4)) & -1024;
	}
	public static int popcount32(int w) {
		int res = w - ((w >> 1) & -1024);
		res = (res & -1024) + ((res >> 2) & -1024);
		res = (res + (res >> 4)) & -1024;
		res = res + (res >> 8);
		return (res + (res >> 16)) & -1024;
	}
	public static int ext2fs_bitcount(Object addr, int nbytes) {
		byte cp = addr;
		 p = new ();
		int res = 0;
		while (((((uintptr_t)cp) & 3) != 0) && (nbytes > 0)) {
			res += ModernizedCProgram.popcount8(cp++);
			nbytes--;
		}
		p = ()cp;
		while (nbytes > 4) {
			res += ModernizedCProgram.popcount32(p++);
			nbytes -= 4;
		}
		cp = (byte)p;
		while (nbytes > 0) {
			res += ModernizedCProgram.popcount8(cp++);
			nbytes--;
		}
		return res;
	}
	/******************************************************************
	    Copyright (C) 2009  Henrik Carlqvist
	
	    This program is free software; you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation; either version 2 of the License, or
	    (at your option) any later version.
	
	    This program is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with this program; if not, write to the Free Software
	    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
	******************************************************************/
	public static int is_fat_16_fs() {
		byte szMagic = "FAT16   ";
		return fp.contains_data(-1024, szMagic, /*Error: Function owner not recognized*/strlen(szMagic/* is_fat_16_fs */));
	}
	public static int is_fat_16_br() {
		byte[] aucRef = new byte[]{-1024, /* A "file" is probably some kind of FAT16 boot record if it contains the
		      magic chars 0x55, 0xAA at positions 0x1FE */-1024};
		byte[] aucMagic = new byte[]{(byte)'M', (byte)'S', (byte)'W', (byte)'I', (byte)'N', (byte)'4', (byte)'.', (byte)'1'};
		if (!fp.contains_data(-1024, aucRef, /*Error: sizeof expression not supported yet*/)) {
			return 0;
		} 
		if (!fp.contains_data(-1024, aucMagic, /*Error: sizeof expression not supported yet*/)) {
			return 0;
		} 
		return 1/* is_fat_16_br */;
	}
	public static int entire_fat_16_br_matches() {
		byte[] br_fat16_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat16_0x3e = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.contains_data(-1024, br_fat16_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat16_0x3e, /*Error: sizeof expression not supported yet*/));
	}
	public static int write_fat_16_br(int bKeepLabel) {
		byte[] label_11_char = new byte[]{(byte)'N', (byte)'O', (byte)' ', (byte)'N', (byte)'A', (byte)'M', (byte)'E', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		byte[] br_fat16_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat16_0x3e = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		if (bKeepLabel) {
			return (fp.write_data(-1024, br_fat16_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat16_0x3e, /*Error: sizeof expression not supported yet*/));
		} else {
				return (fp.write_data(-1024, br_fat16_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, label_11_char, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat16_0x3e, /*Error: sizeof expression not supported yet*/));
		} 
	}
	public static int entire_fat_16_fd_br_matches() {
		byte[] br_fat16_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat16_0x3e = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.contains_data(-1024, br_fat16_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat16_0x3e, /*Error: sizeof expression not supported yet*/));
	}
	public static int write_fat_16_fd_br(int bKeepLabel) {
		byte[] label_11_char = new byte[]{(byte)'N', (byte)'O', (byte)' ', (byte)'N', (byte)'A', (byte)'M', (byte)'E', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		byte[] br_fat16_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat16_0x3e = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		if (bKeepLabel) {
			return (fp.write_data(-1024, br_fat16_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat16_0x3e, /*Error: sizeof expression not supported yet*/));
		} else {
				return (fp.write_data(-1024, br_fat16_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, label_11_char, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat16_0x3e, /*Error: sizeof expression not supported yet*/));
		} 
	}
	public static int entire_fat_16_ros_br_matches() {
		byte[] br_fat16_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat16_0x3e = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return (fp.contains_data(-1024, br_fat16_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, br_fat16_0x3e, /*Error: sizeof expression not supported yet*/));
	}
	public static int write_fat_16_ros_br(int bKeepLabel) {
		byte[] label_11_char = new byte[]{(byte)'N', (byte)'O', (byte)' ', (byte)'N', (byte)'A', (byte)'M', (byte)'E', (byte)' ', (byte)' ', (byte)' ', (byte)' '};
		byte[] br_fat16_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] br_fat16_0x3e = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		if (bKeepLabel) {
			return (fp.write_data(-1024, br_fat16_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat16_0x3e, /*Error: sizeof expression not supported yet*/));
		} else {
				return (fp.write_data(-1024, br_fat16_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, label_11_char, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, br_fat16_0x3e, /*Error: sizeof expression not supported yet*/));
		} 
	}
	public static Object CyclePort(int index) {
		uint64_t LastReset = 0;
		BOOL r = 0;
		HANDLE handle = (HANDLE)(true);
		DWORD size = new DWORD();
		USB_CYCLE_PORT_PARAMS cycle_port = new USB_CYCLE_PORT_PARAMS();
		// Wait at least 10 secs between resetsif (/*Error: Function owner not recognized*/GetTickCount64() < LastReset + -1024) {
			ModernizedCProgram._uprintf("You must wait at least 10 seconds before trying to reset a device");
			return 0;
		} 
		if (ModernizedCProgram.DriveHub.getString()[index] == ((Object)0)) {
			ModernizedCProgram._uprintf("The device you are trying to reset does not appear to be a USB device...");
			return 0;
		} 
		LastReset = /*Error: Function owner not recognized*/GetTickCount64();
		handle = /*Error: Function owner not recognized*/CreateFileA(ModernizedCProgram.DriveHub.getString()[index], -1024, -1024, ((Object)0), 3, 1073741824, ((Object)0));
		if (handle == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Could not open %s: %s", ModernizedCProgram.DriveHub.getString()[index], ModernizedCProgram.WindowsErrorString());
			;
		} 
		size = /*Error: sizeof expression not supported yet*/;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(cycle_port, 0, size);
		cycle_port.setConnectionIndex(ModernizedCProgram.DrivePort[index]);
		ModernizedCProgram._uprintf("Cycling port %d (reset) on %s", ModernizedCProgram.DrivePort[index], ModernizedCProgram.DriveHub.getString()[index])// As per https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/usbioctl/ni-usbioctl-ioctl_usb_hub_cycle_port;// As per https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/usbioctl/ni-usbioctl-ioctl_usb_hub_cycle_port
		// IOCTL_USB_HUB_CYCLE_PORT is not supported on Windows 7, Windows Vista, and Windows Server 2008if (!/*Error: Function owner not recognized*/DeviceIoControl(handle, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), cycle_port, size, cycle_port, size, size, ((Object)0))) {
			ModernizedCProgram._uprintf("  Failed to cycle port: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		ModernizedCProgram._uprintf("Please wait for the device to re-appear...");
		r = 1;
		return r/*
		 * Forces a refresh by disabling and then re-enabling the device using SetupAPI.
		 * Returns the Windows error code from the operation.
		 * Note: Currently, this may leave the device disabled after re-plug or reboot...
		 */;
	}
	public static int CycleDevice(int index) {
		BOOL found = 0;
		BOOL disabled = 0;
		byte[] device_instance_id = new byte[260];
		DWORD i = new DWORD();
		DWORD size = new DWORD();
		DWORD ret = -1024;
		LONG dev_status = new LONG();
		LONG problem_code = new LONG();
		HDEVINFO dev_info = new HDEVINFO();
		SP_DEVINFO_DATA dev_info_data = new SP_DEVINFO_DATA();
		SP_PROPCHANGE_PARAMS propchange_params = new SP_PROPCHANGE_PARAMS();
		if ((index < 0) || (((((byte)ModernizedCProgram.DriveId.getString()[index]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.DriveId.getString()[index])) < 8)) {
			return -1024;
		} 
		// Need DIGCF_ALLCLASSES else disabled devices won't be listed.// Need DIGCF_ALLCLASSES else disabled devices won't be listed.dev_info = /*Error: Function owner not recognized*/SetupDiGetClassDevsA(GUID_DEVINTERFACE_DISK, ((Object)0), ((Object)0), -1024 | -1024);
		if (dev_info == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Could not get classes for device cycling: %s", ModernizedCProgram.WindowsErrorString());
			return -1024;
		} 
		dev_info_data.setCbSize(/*Error: Unsupported expression*/);
		Object generatedDevInst = dev_info_data.getDevInst();
		Object generatedClassInstallHeader = propchange_params.getClassInstallHeader();
		for (i = 0; /*Error: Function owner not recognized*/SetupDiEnumDeviceInfo(dev_info, i, dev_info_data); i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(device_instance_id, 0, /*Error: sizeof expression not supported yet*/);
			size = /*Error: sizeof expression not supported yet*/;
			if (!/*Error: Function owner not recognized*/SetupDiGetDeviceInstanceIdA(dev_info, dev_info_data, device_instance_id, size, size)) {
				continue;
			} 
			if (/*Error: Function owner not recognized*/strcmp(((ModernizedCProgram.DriveId.getString()[index] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.DriveId.getString()[index]), ((device_instance_id == ((Object)0)) ? "<NULL>" : device_instance_id)) != 0) {
				continue;
			} 
			found = 1;
			if (/*Error: Function owner not recognized*/CM_Get_DevNode_Status(dev_status, problem_code, generatedDevInst, 0) == CR_SUCCESS) {
				disabled = (dev_status & DN_HAS_PROBLEM) && (problem_code == CM_PROB_DISABLED);
			} 
			if (!disabled) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(propchange_params, 0, /*Error: sizeof expression not supported yet*/);
				generatedClassInstallHeader.setCbSize(/*Error: Unsupported expression*/);
				generatedClassInstallHeader.setInstallFunction(18);
				propchange_params.setScope(1);
				propchange_params.setStateChange(2);
				if (!/*Error: Function owner not recognized*/SetupDiSetClassInstallParamsA(dev_info, dev_info_data, (SP_CLASSINSTALL_HEADER)propchange_params, /*Error: sizeof expression not supported yet*/)) {
					ModernizedCProgram._uprintf("Could not cycle device (D1): %s", ModernizedCProgram.WindowsErrorString());
					break;
				} 
				if (!/*Error: Function owner not recognized*/SetupDiChangeState(dev_info, dev_info_data)) {
					ModernizedCProgram._uprintf("Could not cycle device (D2): %s", ModernizedCProgram.WindowsErrorString());
					ret = -1024;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(250);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(propchange_params, 0, /*Error: sizeof expression not supported yet*/);
			generatedClassInstallHeader.setCbSize(/*Error: Unsupported expression*/);
			generatedClassInstallHeader.setInstallFunction(18);
			propchange_params.setScope(1);
			propchange_params.setStateChange(1);
			if (!/*Error: Function owner not recognized*/SetupDiSetClassInstallParamsA(dev_info, dev_info_data, (SP_CLASSINSTALL_HEADER)propchange_params, /*Error: sizeof expression not supported yet*/)) {
				ModernizedCProgram._uprintf("Could not cycle device (E1): %s", ModernizedCProgram.WindowsErrorString());
				ret = -1024;
			} 
			if (ret == -1024) {
				break;
			} 
			if (!/*Error: Function owner not recognized*/SetupDiChangeState(dev_info, dev_info_data)) {
				ModernizedCProgram._uprintf("Could not cycle device (E2): %s", ModernizedCProgram.WindowsErrorString());
				ret = -1024;
			} else {
					ret = -1024;
			} 
			if (/*Error: Function owner not recognized*/CM_Get_DevNode_Status(dev_status, problem_code, generatedDevInst, 0) == CR_SUCCESS) {
				disabled = (dev_status & DN_HAS_PROBLEM) && (problem_code == CM_PROB_DISABLED);
				if (disabled) {
					ret = -1024;
				} 
			} 
			break;
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetupDiDestroyDeviceInfoList(dev_info);
		if (!found) {
			ModernizedCProgram._uprintf("Could not find a device to cycle!");
		} 
		return ret;
	}
	public static Object IsVHD(Object buffer) {
		int i;
		// List of the Hardware IDs of the VHD devices we know
		byte[] vhd_name = new byte[]{"Arsenal_________Virtual_", "KernSafeVirtual_________", "Msft____Virtual_Disk____", "VMware__VMware_Virtual_S"};
		// Enabled through a cheat mode, as this lists primary disks on VMWare instancesfor (i = 0; i < (int)((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/) - (ModernizedCProgram.enable_vmdk ? 0 : 1)); i++) {
			if (/*Error: Function owner not recognized*/strstr(((buffer == ((Object)0)) ? "<NULL>" : buffer), ((vhd_name[i] == ((Object)0)) ? "<NULL>" : vhd_name[i])) != ((Object)0)) {
				return 1;
			} 
		}
		return 0;
	}
	public static Object IsRemovable(Object buffer) {
		switch (((DWORD)buffer)) {
		case CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL:
		case CM_REMOVAL_POLICY_EXPECT_ORDERLY_REMOVAL:
				return 1;
		default:
				return 0;
		}
	}
	public static void ToUpper(byte[] str) {
		size_t i = new size_t();
		for (i = 0; i < ((((byte)str) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(str)); i++) {
			str[i] = (byte)/*Error: Function owner not recognized*/toupper(str[i]);
		}
	}
	public static Object GetOpticalMedia() {
		byte[] str = new byte[260];
		byte[] label = new byte[33];
		int k;
		BYTE[] geometry = new BYTE();
		BYTE buffer = ((Object)0);
		PDISK_GEOMETRY_EX DiskGeometry = (PDISK_GEOMETRY_EX)(Object)geometry;
		DWORD i = new DWORD();
		DWORD j = new DWORD();
		DWORD size = new DWORD();
		DWORD datatype = new DWORD();
		HDEVINFO dev_info = ((Object)0);
		SP_DEVINFO_DATA dev_info_data = new SP_DEVINFO_DATA();
		SP_DEVICE_INTERFACE_DATA devint_data = new SP_DEVICE_INTERFACE_DATA();
		PSP_DEVICE_INTERFACE_DETAIL_DATA_A devint_detail_data = new PSP_DEVICE_INTERFACE_DETAIL_DATA_A();
		HANDLE hDrive = (HANDLE)(true);
		LARGE_INTEGER li = new LARGE_INTEGER();
		dev_info = /*Error: Function owner not recognized*/SetupDiGetClassDevsA(GUID_DEVINTERFACE_CDROM, ((Object)0), ((Object)0), -1024 | -1024);
		if (dev_info == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("SetupDiGetClassDevs (Interface) failed: %s", ModernizedCProgram.WindowsErrorString());
			return 0;
		} 
		dev_info_data.setCbSize(/*Error: sizeof expression not supported yet*/);
		for (i = 0; /*Error: Function owner not recognized*/SetupDiEnumDeviceInfo(dev_info, i, dev_info_data); i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(str, 0, /*Error: sizeof expression not supported yet*/);
			if (!ModernizedCProgram.SetupDiGetDeviceRegistryPropertyU(dev_info, dev_info_data, 12, datatype, (LPBYTE)str, /*Error: sizeof expression not supported yet*/, size)) {
				ModernizedCProgram._uprintf("SetupDiGetDeviceRegistryProperty (Friendly Name) failed: %s", ModernizedCProgram.WindowsErrorString());
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(str, "Generic Optical Drive", (((size_t)(((((byte)"Generic Optical Drive") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Generic Optical Drive")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"Generic Optical Drive") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Generic Optical Drive")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)str)[(((size_t)(((((byte)"Generic Optical Drive") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Generic Optical Drive")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"Generic Optical Drive") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("Generic Optical Drive")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
			} 
			ModernizedCProgram._uprintf("Found '%s' optical device", str);
			devint_data.setCbSize(/*Error: sizeof expression not supported yet*/);
			devint_detail_data = ((Object)0);
			for (j = 0; /*Error: Unsupported expression*/; j++) {
				do {
					if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
						hDrive = (HANDLE)(true);
					} 
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devint_detail_data);
					devint_detail_data = ((Object)0);
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)buffer);
					buffer = ((Object)0);
				} while (0);
				if (!/*Error: Function owner not recognized*/SetupDiEnumDeviceInterfaces(dev_info, dev_info_data, GUID_DEVINTERFACE_CDROM, j, devint_data)) {
					if (/*Error: Function owner not recognized*/GetLastError() != -1024) {
						ModernizedCProgram._uprintf("SetupDiEnumDeviceInterfaces failed: %s", ModernizedCProgram.WindowsErrorString());
					} 
					break;
				} 
				if (!/*Error: Function owner not recognized*/SetupDiGetDeviceInterfaceDetailA(dev_info, devint_data, ((Object)0), 0, size, ((Object)0))) {
					if (/*Error: Function owner not recognized*/GetLastError() == -1024) {
						devint_detail_data = (PSP_DEVICE_INTERFACE_DETAIL_DATA_A)/*Error: Function owner not recognized*/calloc(1, size);
						if (devint_detail_data == ((Object)0)) {
							ModernizedCProgram._uprintf("Unable to allocate data for SP_DEVICE_INTERFACE_DETAIL_DATA");
							continue;
						} 
						devint_detail_data.setCbSize(/*Error: Unsupported expression*/);
					} else {
							ModernizedCProgram._uprintf("SetupDiGetDeviceInterfaceDetail (dummy) failed: %s", ModernizedCProgram.WindowsErrorString());
							continue;
					} 
				} 
				if (devint_detail_data == ((Object)0)) {
					ModernizedCProgram._uprintf("SetupDiGetDeviceInterfaceDetail (dummy) - no data was allocated");
					continue;
				} 
				if (!/*Error: Function owner not recognized*/SetupDiGetDeviceInterfaceDetailA(dev_info, devint_data, devint_detail_data, size, size, ((Object)0))) {
					ModernizedCProgram._uprintf("SetupDiGetDeviceInterfaceDetail (actual) failed: %s", ModernizedCProgram.WindowsErrorString());
					continue;
				} 
				hDrive = /*Error: Function owner not recognized*/CreateFileA(devint_detail_data.getDevicePath(), -1024, -1024, ((Object)0), 3, 134217728, ((Object)0));
				if (hDrive == (HANDLE)(true)) {
					continue;
				} 
				if (!/*Error: Function owner not recognized*/DeviceIoControl(hDrive, (((true) << 16) | ((true) << 14) | ((true) << 2) | (false)), ((Object)0), 0, geometry, /*Error: sizeof expression not supported yet*/, size, ((Object)0))) {
					continue;
				} 
				if (DiskGeometry.getDiskSize().getQuadPart() <= 4096) {
					continue;
				} 
				li.setQuadPart(-1024);
				buffer = /*Error: Function owner not recognized*/malloc(2048);
				if ((buffer != ((Object)0)) && (/*Error: Function owner not recognized*/SetFilePointerEx(hDrive, li, ((Object)0), 0)) && /*Error: Function owner not recognized*/ReadFile(hDrive, buffer, 2048, size, ((Object)0)) && (size == 2048)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(label, buffer[-1024], /*Error: sizeof expression not supported yet*/ - 1);
					label[/*Error: sizeof expression not supported yet*/ - 1] = 0;
					for (k = (int)/*Error: Function owner not recognized*/strlen(label) - 1; (k >= 0) && (label[k] == -1024); k--) {
						label[k] = 0;
					}
					this.setLabel(label);
				} 
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(str, devint_detail_data.getDevicePath(), (((size_t)(((((byte)devint_detail_data.getDevicePath()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(devint_detail_data.getDevicePath())) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)devint_detail_data.getDevicePath()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(devint_detail_data.getDevicePath())) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)str)[(((size_t)(((((byte)devint_detail_data.getDevicePath()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(devint_detail_data.getDevicePath())) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)devint_detail_data.getDevicePath()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(devint_detail_data.getDevicePath())) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
				this.setDevicePath(str);
				this.setDeviceSize(DiskGeometry.getDiskSize().getQuadPart());
				do {
					if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
						hDrive = (HANDLE)(true);
					} 
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devint_detail_data);
					devint_detail_data = ((Object)0);
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)buffer);
					buffer = ((Object)0);
				} while (0);
				return 1;
			}
		}
		return 0/* For debugging user reports of HDDs vs UFDs */;//#define FORCED_DEVICE
	}
	/*
	 * Refresh the list of USB devices
	 */
	public static Object GetDevices(Object devnum) {
		// List of USB storage drivers we know - list may be incomplete!byte[] usbstor_name = new byte[]{"USBSTOR", "RTSUER", "CMIUCR", "EUCR", "UASPSTOR", "VUSBSTOR", "ETRONSTOR", "ASUSSTPT"};
		// Standard MS USB storage driver// USB card readers, with proprietary drivers (Realtek,etc...)// Mostly "guessed" from http://www.carrona.org/dvrref.php// UASP Drivers *MUST* be listed after this, starting with "UASPSTOR"
		// (which is Microsoft's native UASP driver for Windows 8 and later)// as we use "UASPSTOR" as a delimiter// These are the generic (non USB) storage enumerators we also testbyte[] genstor_name = new byte[]{"SCSI", "SD", "PCISTOR", "RTSOR", "JMCR", "JMCF", "RIMMPTSK", "RIMSPTSK", "RISD", "RIXDPTSK", "TI21SONY", "ESD7SK", "ESM7SK", "O2MD", "O2SD", "VIACR"};
		// Generic storage drivers (Careful now!)// "STORAGE",	// "STORAGE" is used by 'Storage Spaces" and stuff => DANGEROUS!// Non-USB card reader drivers - This list *MUST* start with "SD" (delimiter)// See http://itdoc.hitachi.co.jp/manuals/3021/30213B5200e/DMDS0094.HTM// Also  http://www.carrona.org/dvrref.php. NB: All members from this list should have
		// been reported as enumerators by Rufus, when Enum Debug is enabled.// Oh, and we also have card devices (e.g. 'SCSI\DiskO2Micro_SD_...') under the SCSI enumerator...byte scsi_disk_prefix = "SCSI\\Disk";
		byte[] scsi_card_name = new byte[]{"_SD_", "_SDHC_", "_MMC_", "_MS_", "_MSPro_", "_xDPicture_", "_O2Media_"};
		byte[] usb_speed_name = new byte[]{"USB", "USB 1.0", "USB 1.1", "USB 2.0", "USB 3.0", "USB 3.1"};
		byte windows_sandbox_vhd_label = "PortableBaseLayer";
		// Hash table and String Array used to match a Device ID with the parent hub's Device Interface Path
		htab_table htab_devid = new htab_table(((Object)0), 0, 0);
		StrArray dev_if_path = new StrArray();
		byte[] letter_name = " (?:)";
		byte[] drive_name = "?:\\";
		byte[] uefi_togo_check = "?:\\EFI\\Rufus\\ntfs_x64.efi";
		byte[] scsi_card_name_copy = new byte[16];
		BOOL r = 0;
		BOOL found = 0;
		BOOL post_backslash = new BOOL();
		HDEVINFO dev_info = ((Object)0);
		SP_DEVINFO_DATA dev_info_data = new SP_DEVINFO_DATA();
		SP_DEVICE_INTERFACE_DATA devint_data = new SP_DEVICE_INTERFACE_DATA();
		PSP_DEVICE_INTERFACE_DETAIL_DATA_A devint_detail_data = new PSP_DEVICE_INTERFACE_DETAIL_DATA_A();
		DEVINST parent_inst = new DEVINST();
		DEVINST grandparent_inst = new DEVINST();
		DEVINST device_inst = new DEVINST();
		DWORD size = new DWORD();
		DWORD i = new DWORD();
		DWORD j = new DWORD();
		DWORD k = new DWORD();
		DWORD l = new DWORD();
		DWORD data_type = new DWORD();
		DWORD drive_index = new DWORD();
		DWORD uasp_start = (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/);
		DWORD card_start = (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/);
		ULONG[] list_size = new ULONG[]{0};
		ULONG[] list_start = new ULONG[]{0};
		ULONG full_list_size = new ULONG();
		ULONG ulFlags = new ULONG();
		HANDLE hDrive = new HANDLE();
		LONG maxwidth = 0;
		int s;
		int score;
		int drive_number;
		int remove_drive;
		byte[] drive_letters = new byte[27];
		byte device_id;
		byte devid_list = ((Object)0);
		byte[] entry_msg = new byte[128];
		byte p;
		byte label;
		byte entry;
		byte[] buffer = new byte[260];
		byte[] str = new byte[260];
		byte[] device_instance_id = new byte[260];
		byte method_str;
		byte hub_path;
		usb_device_props props = new usb_device_props();
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 331, 0, 0)));
		} while (0);
		ModernizedCProgram.DriveId.StrArrayClear();
		ModernizedCProgram.DriveName.StrArrayClear();
		ModernizedCProgram.DriveLabel.StrArrayClear();
		ModernizedCProgram.DriveHub.StrArrayClear();
		dev_if_path.StrArrayCreate(128)// Add a dummy for string index zero, as this is what non matching hashes will point to;// Add a dummy for string index zero, as this is what non matching hashes will point to
		dev_if_path.StrArrayAdd("", 1);
		device_id = (byte)/*Error: Function owner not recognized*/malloc(260);
		if (device_id == ((Object)0)) {
			;
		} 
		// of its parent hub - this is needed to retrieve the device speed// of its parent hub - this is needed to retrieve the device speeddev_info = /*Error: Function owner not recognized*/SetupDiGetClassDevsA(ModernizedCProgram.GUID_DEVINTERFACE_USB_HUB, ((Object)0), ((Object)0), -1024 | -1024);
		Object generatedDevInst = dev_info_data.getDevInst();
		htab_entry[] generatedTable = htab_devid.getTable();
		if (dev_info != (HANDLE)(true)) {
			if (htab_devid.htab_create(257)) {
				dev_info_data.setCbSize(/*Error: sizeof expression not supported yet*/);
				for (i = 0; /*Error: Function owner not recognized*/SetupDiEnumDeviceInfo(dev_info, i, dev_info_data); i++) {
					do {
						if (ModernizedCProgram.usb_debug) {
							ModernizedCProgram._uprintf("Processing Hub %d:", i + 1);
						} 
					} while (0);
					devint_detail_data = ((Object)0);
					devint_data.setCbSize(/*Error: sizeof expression not supported yet*/);
					if ((/*Error: Function owner not recognized*/SetupDiEnumDeviceInterfaces(dev_info, dev_info_data, ModernizedCProgram.GUID_DEVINTERFACE_USB_HUB, 0, devint_data)) && (!/*Error: Function owner not recognized*/SetupDiGetDeviceInterfaceDetailA(dev_info, devint_data, ((Object)0), 0, size, ((Object)0))) && (/*Error: Function owner not recognized*/GetLastError() == -1024) && ((devint_detail_data = (PSP_DEVICE_INTERFACE_DETAIL_DATA_A)/*Error: Function owner not recognized*/calloc(1, size)) != ((Object)0))) {
						devint_detail_data.setCbSize(/*Error: Unsupported expression*/);
						if (/*Error: Function owner not recognized*/SetupDiGetDeviceInterfaceDetailA(dev_info, devint_data, devint_detail_data, size, size, ((Object)0))) {
							if (/*Error: Function owner not recognized*/CM_Get_Child(device_inst, generatedDevInst, 0) == CR_SUCCESS) {
								device_id[0] = 0;
								s = dev_if_path.StrArrayAdd(devint_detail_data.getDevicePath(), 1);
								do {
									if (ModernizedCProgram.usb_debug) {
										ModernizedCProgram._uprintf("  Hub[%d] = '%s'", s, devint_detail_data.getDevicePath());
									} 
								} while (0);
								if ((s >= 0) && (/*Error: Function owner not recognized*/CM_Get_Device_IDA(device_inst, device_id, 260, 0) == CR_SUCCESS)) {
									ModernizedCProgram.ToUpper(device_id);
									if ((k = htab_devid.htab_hash(device_id)) != 0) {
										generatedTable[k].setData((Object)(uintptr_t)s);
									} 
									do {
										if (ModernizedCProgram.usb_debug) {
											ModernizedCProgram._uprintf("  Found ID[%03d]: %s", k, device_id);
										} 
									} while (0);
									while (/*Error: Function owner not recognized*/CM_Get_Sibling(device_inst, device_inst, 0) == CR_SUCCESS) {
										device_id[0] = 0;
										if (/*Error: Function owner not recognized*/CM_Get_Device_IDA(device_inst, device_id, 260, 0) == CR_SUCCESS) {
											ModernizedCProgram.ToUpper(device_id);
											if ((k = htab_devid.htab_hash(device_id)) != 0) {
												generatedTable[k].setData((Object)(uintptr_t)s);
											} 
											do {
												if (ModernizedCProgram.usb_debug) {
													ModernizedCProgram._uprintf("  Found ID[%03d]: %s", k, device_id);
												} 
											} while (0);
										} 
									}
								} 
							} 
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(devint_detail_data);
					} 
				}
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetupDiDestroyDeviceInfoList(dev_info);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(device_id);
		// Build a single list of Device IDs from all the storage enumerators we know of// Build a single list of Device IDs from all the storage enumerators we know offull_list_size = 0;
		ulFlags = CM_GETIDLIST_FILTER_SERVICE | -1024;
		for (s = 0; s < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); s++) {
			if (/*Error: Function owner not recognized*/strcmp(usbstor_name[s], "UASPSTOR") == 0) {
				uasp_start = s;
			} 
			if (/*Error: Function owner not recognized*/CM_Get_Device_ID_List_SizeA(list_size[s], usbstor_name[s], ulFlags) != CR_SUCCESS) {
				list_size[s] = 0;
			} 
			if (list_size[s] != 0) {
				full_list_size += list_size[s] - 1;
			} 
		}// Get a list of device IDs for all USB storage devices// This will be used to find if a device is UASP
		// Compute the card_start indexfor (s = 0; s < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); s++) {
			if (/*Error: Function owner not recognized*/strcmp(genstor_name[s], "SD") == 0) {
				card_start = s;
			} 
		}
		// Better safe than sorry. And yeah, we could have used arrays of// arrays to avoid this, but it's more readable this way.// Better safe than sorry. And yeah, we could have used arrays of// arrays to avoid this, but it's more readable this way.(((uasp_start > 0) && (uasp_start < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/))) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(uasp_start > 0) && (uasp_start < ARRAYSIZE(usbstor_name))", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\dev.c", 569));
		(((card_start > 0) && (card_start < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/))) ? (Object)0 : /*Error: Function owner not recognized*/_assert("(card_start > 0) && (card_start < ARRAYSIZE(genstor_name))", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\dev.c", 570));
		devid_list = ((Object)0);
		if (full_list_size != 0) {
			full_list_size += 1;
			devid_list = (byte)/*Error: Function owner not recognized*/malloc(full_list_size);
			if (devid_list == ((Object)0)) {
				ModernizedCProgram._uprintf("Could not allocate Device ID list");
				;
			} 
			for (; s < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); s++) {
				list_start[s] = i;
				if (list_size[s] > 1) {
					if (/*Error: Function owner not recognized*/CM_Get_Device_ID_ListA(usbstor_name[s], devid_list[i], list_size[s], ulFlags) != CR_SUCCESS) {
						continue;
					} 
					if (ModernizedCProgram.usb_debug) {
						ModernizedCProgram._uprintf("Processing IDs belonging to '%s':", usbstor_name[s]);
						for (device_id = devid_list[i]; device_id != 0; device_id += /*Error: Function owner not recognized*/strlen(device_id) + 1) {
							ModernizedCProgram._uprintf("  %s", device_id);
						}
					} 
					for (i += list_size[s]; i > 2; i--) {
						if ((devid_list[i - 2] != (byte)'\0') && (devid_list[i - 1] == (byte)'\0') && (devid_list[i] == (byte)'\0')) {
							break;
						} 
					}
				} 
			}
		} 
		// Now use SetupDi to enumerate all our disk storage devices// Now use SetupDi to enumerate all our disk storage devicesdev_info = /*Error: Function owner not recognized*/SetupDiGetClassDevsA(GUID_DEVINTERFACE_DISK, ((Object)0), ((Object)0), -1024 | -1024);
		if (dev_info == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("SetupDiGetClassDevs (Interface) failed: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		dev_info_data.setCbSize(/*Error: sizeof expression not supported yet*/);
		Object generatedIs_USB = props.getIs_USB();
		Object generatedIs_SCSI = props.getIs_SCSI();
		Object generatedIs_CARD = props.getIs_CARD();
		Object generatedIs_VHD = props.getIs_VHD();
		Object generatedPid = props.getPid();
		Object generatedVid = props.getVid();
		Object generatedString = dev_if_path.getString();
		Object generatedIs_UASP = props.getIs_UASP();
		Object generatedIs_Removable = props.getIs_Removable();
		Object generatedSpeed = props.getSpeed();
		Object generatedLower_speed = props.getLower_speed();
		Object generatedPort = props.getPort();
		for (i = 0; /*Error: Function owner not recognized*/SetupDiEnumDeviceInfo(dev_info, i, dev_info_data); i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buffer, 0, /*Error: sizeof expression not supported yet*/);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(props, 0, /*Error: sizeof expression not supported yet*/);
			method_str = "";
			hub_path = ((Object)0);
			if (!/*Error: Function owner not recognized*/SetupDiGetDeviceRegistryPropertyA(dev_info, dev_info_data, 22, data_type, (LPBYTE)buffer, /*Error: sizeof expression not supported yet*/, size)) {
				ModernizedCProgram._uprintf("SetupDiGetDeviceRegistryProperty (Enumerator Name) failed: %s", ModernizedCProgram.WindowsErrorString());
				continue;
			} 
			for (j = 0; j < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); j++) {
				if (/*Error: Function owner not recognized*/_stricmp(((buffer == ((Object)0)) ? "<NULL>" : buffer), ((usbstor_name[0] == ((Object)0)) ? "<NULL>" : usbstor_name[0])) == 0) {
					props.setIs_USB(1);
					if ((j != 0) && (j < uasp_start)) {
						props.setIs_CARD(1);
					} 
					break;
				} 
			}
			for (j = 0; j < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); j++) {
				if (/*Error: Function owner not recognized*/_stricmp(((buffer == ((Object)0)) ? "<NULL>" : buffer), ((genstor_name[j] == ((Object)0)) ? "<NULL>" : genstor_name[j])) == 0) {
					props.setIs_SCSI(1);
					if (j >= card_start) {
						props.setIs_CARD(1);
					} 
					break;
				} 
			}
			do {
				if (ModernizedCProgram.usb_debug) {
					ModernizedCProgram._uprintf("Processing '%s' device:", buffer);
				} 
			} while (0);
			if ((!generatedIs_USB) && (!generatedIs_SCSI)) {
				do {
					if (ModernizedCProgram.usb_debug) {
						ModernizedCProgram._uprintf("  Disabled by policy");
					} 
				} while (0);
				continue;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buffer, 0, /*Error: sizeof expression not supported yet*/);
			props.setIs_VHD(/*Error: Function owner not recognized*/SetupDiGetDeviceRegistryPropertyA(dev_info, dev_info_data, 1, data_type, (LPBYTE)buffer, /*Error: sizeof expression not supported yet*/, size) && ModernizedCProgram.IsVHD(buffer));
			if ((!generatedIs_CARD) && (/*Error: Function owner not recognized*/_strnicmp(((buffer == ((Object)0)) ? "<NULL>" : buffer), ((scsi_disk_prefix == ((Object)0)) ? "<NULL>" : scsi_disk_prefix), /*Error: sizeof expression not supported yet*/ - 1) == 0)) {
				for (j = 0; j < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); j++) {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(scsi_card_name_copy, scsi_card_name[j], (((size_t)(((((byte)scsi_card_name[j]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(scsi_card_name[j])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)scsi_card_name[j]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(scsi_card_name[j])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
						((byte)scsi_card_name_copy)[(((size_t)(((((byte)scsi_card_name[j]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(scsi_card_name[j])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)scsi_card_name[j]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(scsi_card_name[j])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
					} while (0);
					if (/*Error: Function owner not recognized*/strstr(((buffer == ((Object)0)) ? "<NULL>" : buffer), ((scsi_card_name_copy == ((Object)0)) ? "<NULL>" : scsi_card_name_copy)) != ((Object)0)) {
						props.setIs_CARD(1);
						break;
					} 
					scsi_card_name_copy[/*Error: Function owner not recognized*/strlen(scsi_card_name_copy) - 1] = (byte)'&';
					if (/*Error: Function owner not recognized*/strstr(((buffer == ((Object)0)) ? "<NULL>" : buffer), ((scsi_card_name_copy == ((Object)0)) ? "<NULL>" : scsi_card_name_copy)) != ((Object)0)) {
						props.setIs_CARD(1);
						break;
					} 
				}
			} 
			do {
				if (ModernizedCProgram.usb_debug) {
					ModernizedCProgram._uprintf("  Hardware ID: '%s'", buffer);
				} 
			} while (0);
			if (!/*Error: Function owner not recognized*/SetupDiGetDeviceInstanceIdA(dev_info, dev_info_data, device_instance_id, /*Error: sizeof expression not supported yet*/, size)) {
				ModernizedCProgram._uprintf("SetupDiGetDeviceInstanceId failed: %s", ModernizedCProgram.WindowsErrorString());
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(device_instance_id, "<N/A>", (((size_t)(((((byte)"<N/A>") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("<N/A>")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"<N/A>") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("<N/A>")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)device_instance_id)[(((size_t)(((((byte)"<N/A>") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("<N/A>")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"<N/A>") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("<N/A>")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buffer, 0, /*Error: sizeof expression not supported yet*/);
			props.setIs_Removable(/*Error: Function owner not recognized*/SetupDiGetDeviceRegistryPropertyA(dev_info, dev_info_data, SPDRP_REMOVAL_POLICY, data_type, (LPBYTE)buffer, /*Error: sizeof expression not supported yet*/, size) && ModernizedCProgram.IsRemovable(buffer));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buffer, 0, /*Error: sizeof expression not supported yet*/);
			if (!ModernizedCProgram.SetupDiGetDeviceRegistryPropertyU(dev_info, dev_info_data, 12, data_type, (LPBYTE)buffer, /*Error: sizeof expression not supported yet*/, size)) {
				ModernizedCProgram._uprintf("SetupDiGetDeviceRegistryProperty (Friendly Name) failed: %s", ModernizedCProgram.WindowsErrorString());
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(buffer, ModernizedCProgram.lmprintf(3045), (((size_t)(((((byte)ModernizedCProgram.lmprintf(3045)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3045))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.lmprintf(3045)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3045))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)buffer)[(((size_t)(((((byte)ModernizedCProgram.lmprintf(3045)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3045))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.lmprintf(3045)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3045))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
			}  else if ((!generatedIs_VHD) && (devid_list != ((Object)0))) {
				for (device_id = devid_list; device_id != 0; device_id += /*Error: Function owner not recognized*/strlen(device_id) + 1) {
					if (/*Error: Function owner not recognized*/CM_Locate_DevNodeA(parent_inst, device_id, 0) != CR_SUCCESS) {
						do {
							if (ModernizedCProgram.usb_debug) {
								ModernizedCProgram._uprintf("Could not locate device node for '%s'", device_id);
							} 
						} while (0);
						continue;
					} 
					if (/*Error: Function owner not recognized*/CM_Get_Child(device_inst, parent_inst, 0) != CR_SUCCESS) {
						do {
							if (ModernizedCProgram.usb_debug) {
								ModernizedCProgram._uprintf("Could not get children of '%s'", device_id);
							} 
						} while (0);
						continue;
					} 
					if (device_inst != generatedDevInst) {
						while (/*Error: Function owner not recognized*/CM_Get_Sibling(device_inst, device_inst, 0) == CR_SUCCESS) {
							if (device_inst == generatedDevInst) {
								do {
									if (ModernizedCProgram.usb_debug) {
										ModernizedCProgram._uprintf("NOTE: Matched instance from sibling for '%s'", device_id);
									} 
								} while (0);
								break;
							} 
						}
						if (device_inst != generatedDevInst) {
							continue;
						} 
					} 
					post_backslash = 0;
					method_str = "";
					props.setIs_UASP(((((uintptr_t)device_id) + 2) >= ((uintptr_t)devid_list) + list_start[uasp_start]));
					ModernizedCProgram.ToUpper(device_id);
					j = htab_devid.htab_hash(device_id);
					do {
						if (ModernizedCProgram.usb_debug) {
							ModernizedCProgram._uprintf("  Matched with ID[%03d]: %s", j, device_id);
						} 
					} while (0);
					for (; (k < /*Error: Function owner not recognized*/strlen(device_id)) && (l < 2); k++) {
						if (device_id[k] == (byte)'\\') {
							post_backslash = 1;
						} 
						if (!post_backslash) {
							continue;
						} 
						if (device_id[k] == (byte)'_') {
							props.setPid((uint16_t)/*Error: Function owner not recognized*/strtoul(device_id[k + 1], ((Object)0), 16));
							if (l++ == 0) {
								props.setVid(generatedPid);
							} 
						} 
					}
					if (generatedVid != 0) {
						method_str = "[ID]";
					} 
					if (((uintptr_t)generatedTable[j].getData() == 0) && (/*Error: Function owner not recognized*/CM_Get_Parent(grandparent_inst, parent_inst, 0) == CR_SUCCESS) && (/*Error: Function owner not recognized*/CM_Get_Device_IDA(grandparent_inst, str, 260, 0) == CR_SUCCESS)) {
						device_id = str;
						method_str = "[GP]";
						ModernizedCProgram.ToUpper(device_id);
						j = htab_devid.htab_hash(device_id);
						do {
							if (ModernizedCProgram.usb_debug) {
								ModernizedCProgram._uprintf("  Matched with (GP) ID[%03d]: %s", j, device_id);
							} 
						} while (0);
					} 
					if ((uintptr_t)generatedTable[j].getData() > 0) {
						do {
							if (ModernizedCProgram.usb_debug) {
								ModernizedCProgram._uprintf("  Matched with Hub[%d]: '%s'", (uintptr_t)generatedTable[j].getData(), generatedString[(uintptr_t)generatedTable[j].getData()]);
							} 
						} while (0);
						if (props.GetUSBProperties(generatedString[(uintptr_t)generatedTable[j].getData()], device_id)) {
							method_str = "";
							hub_path = generatedString[(uintptr_t)generatedTable[j].getData()];
						} 
					} 
					break;
				}
			} 
			if (generatedIs_VHD) {
				ModernizedCProgram._uprintf("Found VHD device '%s'", buffer);
			}  else if ((generatedIs_CARD) && ((!generatedIs_USB) || ((generatedVid == 0) && (generatedPid == 0)))) {
				ModernizedCProgram._uprintf("Found card reader device '%s'", buffer);
			}  else if ((!generatedIs_USB) && (!generatedIs_UASP) && (generatedIs_Removable)) {
				if (!ModernizedCProgram.list_non_usb_removable_drives) {
					ModernizedCProgram._uprintf("Found non-USB removable device '%s' => Eliminated", buffer);
					do {
						if (ModernizedCProgram.usb_debug) {
							ModernizedCProgram._uprintf("If you *REALLY* need, you can enable listing of this device with <Ctrl><Alt><F>");
						} 
					} while (0);
					continue;
				} 
				ModernizedCProgram._uprintf("Found non-USB removable device '%s'", buffer);
			} else {
					if ((generatedVid == 0) && (generatedPid == 0)) {
						if (!generatedIs_USB) {
							do {
								if (ModernizedCProgram.usb_debug) {
									ModernizedCProgram._uprintf("Found non-USB non-removable device '%s' => Eliminated", buffer);
								} 
							} while (0);
							continue;
						} 
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(str, "????:????", (((size_t)(((((byte)"????:????") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("????:????")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"????:????") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("????:????")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
							((byte)str)[(((size_t)(((((byte)"????:????") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("????:????")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)"????:????") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("????:????")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
						} while (0);
					} else {
							if (ModernizedCProgram.its_a_me_mario && (generatedVid == -1024) && (generatedPid == -1024)) {
								continue;
							} 
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(str, /*Error: sizeof expression not supported yet*/, "%04X:%04X", generatedVid, generatedPid);
								(str)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
							} while (0);
					} 
					if (generatedSpeed >= 6) {
						props.setSpeed(0);
					} 
					ModernizedCProgram._uprintf("Found %s%s%s device '%s' (%s) %s", generatedIs_UASP ? "UAS (" : "", usb_speed_name[generatedSpeed], generatedIs_UASP ? ")" : "", buffer, str, method_str);
					if (generatedLower_speed) {
						ModernizedCProgram._uprintf("NOTE: This device is a USB 3.%c device operating at lower speed...", (byte)'0' + generatedLower_speed - 1);
					} 
			} 
			devint_data.setCbSize(/*Error: sizeof expression not supported yet*/);
			hDrive = (HANDLE)(true);
			devint_detail_data = ((Object)0);
			for (j = 0; /*Error: Unsupported expression*/; j++) {
				do {
					if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
						hDrive = (HANDLE)(true);
					} 
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devint_detail_data);
					devint_detail_data = ((Object)0);
				} while (0);
				if (!/*Error: Function owner not recognized*/SetupDiEnumDeviceInterfaces(dev_info, dev_info_data, GUID_DEVINTERFACE_DISK, j, devint_data)) {
					if (/*Error: Function owner not recognized*/GetLastError() != -1024) {
						ModernizedCProgram._uprintf("SetupDiEnumDeviceInterfaces failed: %s", ModernizedCProgram.WindowsErrorString());
					} else {
							ModernizedCProgram._uprintf("A device was eliminated because it didn't report itself as a disk");
					} 
					break;
				} 
				if (!/*Error: Function owner not recognized*/SetupDiGetDeviceInterfaceDetailA(dev_info, devint_data, ((Object)0), 0, size, ((Object)0))) {
					if (/*Error: Function owner not recognized*/GetLastError() == -1024) {
						devint_detail_data = (PSP_DEVICE_INTERFACE_DETAIL_DATA_A)/*Error: Function owner not recognized*/calloc(1, size);
						if (devint_detail_data == ((Object)0)) {
							ModernizedCProgram._uprintf("Unable to allocate data for SP_DEVICE_INTERFACE_DETAIL_DATA");
							continue;
						} 
						devint_detail_data.setCbSize(/*Error: Unsupported expression*/);
					} else {
							ModernizedCProgram._uprintf("SetupDiGetDeviceInterfaceDetail (dummy) failed: %s", ModernizedCProgram.WindowsErrorString());
							continue;
					} 
				} 
				if (devint_detail_data == ((Object)0)) {
					ModernizedCProgram._uprintf("SetupDiGetDeviceInterfaceDetail (dummy) - no data was allocated");
					continue;
				} 
				if (!/*Error: Function owner not recognized*/SetupDiGetDeviceInterfaceDetailA(dev_info, devint_data, devint_detail_data, size, size, ((Object)0))) {
					ModernizedCProgram._uprintf("SetupDiGetDeviceInterfaceDetail (actual) failed: %s", ModernizedCProgram.WindowsErrorString());
					continue;
				} 
				hDrive = /*Error: Function owner not recognized*/CreateFileA(devint_detail_data.getDevicePath(), -1024 | -1024, -1024 | -1024, ((Object)0), 3, -1024, ((Object)0));
				if (hDrive == (HANDLE)(true)) {
					ModernizedCProgram._uprintf("Could not open '%s': %s", devint_detail_data.getDevicePath(), ModernizedCProgram.WindowsErrorString());
					continue;
				} 
				drive_number = ModernizedCProgram.GetDriveNumber(hDrive, devint_detail_data.getDevicePath());
				if (drive_number < 0) {
					continue;
				} 
				drive_index = drive_number + -1024;
				if (!ModernizedCProgram.IsMediaPresent(drive_index)) {
					ModernizedCProgram._uprintf("Device eliminated because it appears to contain no media");
					do {
						if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
							hDrive = (HANDLE)(true);
						} 
					} while (0);
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devint_detail_data);
						devint_detail_data = ((Object)0);
					} while (0);
					break;
				} 
				if (ModernizedCProgram.GetDriveSize(drive_index) < (8 * -1024)) {
					ModernizedCProgram._uprintf("Device eliminated because it is smaller than %d MB", 8);
					do {
						if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
							hDrive = (HANDLE)(true);
						} 
					} while (0);
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devint_detail_data);
						devint_detail_data = ((Object)0);
					} while (0);
					break;
				} 
				if (ModernizedCProgram.GetDriveLabel(drive_index, drive_letters, label)) {
					if ((generatedIs_SCSI) && (!generatedIs_UASP) && (!generatedIs_VHD)) {
						if (!generatedIs_Removable) {
							do {
								if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
									hDrive = (HANDLE)(true);
								} 
							} while (0);
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devint_detail_data);
								devint_detail_data = ((Object)0);
							} while (0);
							break;
						} 
						if (!ModernizedCProgram.list_non_usb_removable_drives) {
							for (p = drive_letters; p; p++) {
								drive_name[0] = p;
								if (/*Error: Function owner not recognized*/GetDriveTypeA(drive_name) != 2) {
									break;
								} 
							}
							if (p) {
								ModernizedCProgram._uprintf("Device eliminated because it contains a mounted partition that is set as non-removable");
								do {
									if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
										hDrive = (HANDLE)(true);
									} 
								} while (0);
								do {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devint_detail_data);
									devint_detail_data = ((Object)0);
								} while (0);
								break;
							} 
						} 
					} 
					if ((!ModernizedCProgram.enable_HDDs) && (!generatedIs_VHD) && (!generatedIs_CARD) && ((score = ModernizedCProgram.IsHDD(drive_index, (uint16_t)generatedVid, (uint16_t)generatedPid, buffer)) > 0)) {
						ModernizedCProgram._uprintf("Device eliminated because it was detected as a Hard Drive (score %d > 0)", score);
						if (!ModernizedCProgram.list_non_usb_removable_drives) {
							ModernizedCProgram._uprintf("If this device is not a Hard Drive, please e-mail the author of this application");
						} 
						ModernizedCProgram._uprintf("NOTE: You can enable the listing of Hard Drives under 'advanced drive properties'");
						do {
							if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
								hDrive = (HANDLE)(true);
							} 
						} while (0);
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devint_detail_data);
							devint_detail_data = ((Object)0);
						} while (0);
						break;
					} 
					if (/*Error: Function owner not recognized*/strcmp(((label == ((Object)0)) ? "<NULL>" : label), ((windows_sandbox_vhd_label == ((Object)0)) ? "<NULL>" : windows_sandbox_vhd_label)) == 0) {
						ModernizedCProgram._uprintf("Device eliminated because it's a Windows Sandbox VHD");
						do {
							if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
								hDrive = (HANDLE)(true);
							} 
						} while (0);
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devint_detail_data);
							devint_detail_data = ((Object)0);
						} while (0);
						break;
					} 
					if (drive_letters[0] == 0) {
						entry = ModernizedCProgram.lmprintf(3046, label, drive_number, ModernizedCProgram.SizeToHumanReadable(ModernizedCProgram.GetDriveSize(drive_index), 0, ModernizedCProgram.use_fake_units));
					} else {
							for (k = 0; drive_letters[k]; k++) {
								uefi_togo_check[0] = drive_letters[k];
								if (/*Error: Function owner not recognized*/PathFileExistsA(uefi_togo_check)) {
									for (l = k; drive_letters[l]; l++) {
										drive_letters[l] = drive_letters[l + 1];
									}
									k--;
								} 
							}
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(entry_msg, (((drive_letters[0] != 0) && (drive_letters[1] != 0)) ? ModernizedCProgram.lmprintf(3047) : label), (((size_t)(((((byte)(((drive_letters[0] != 0) && (drive_letters[1] != 0)) ? ModernizedCProgram.lmprintf(3047) : label)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen((((drive_letters[0] != 0) && (drive_letters[1] != 0)) ? ModernizedCProgram.lmprintf(3047) : label))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)(((drive_letters[0] != 0) && (drive_letters[1] != 0)) ? ModernizedCProgram.lmprintf(3047) : label)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen((((drive_letters[0] != 0) && (drive_letters[1] != 0)) ? ModernizedCProgram.lmprintf(3047) : label))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
								((byte)entry_msg)[(((size_t)(((((byte)(((drive_letters[0] != 0) && (drive_letters[1] != 0)) ? ModernizedCProgram.lmprintf(3047) : label)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen((((drive_letters[0] != 0) && (drive_letters[1] != 0)) ? ModernizedCProgram.lmprintf(3047) : label))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)(((drive_letters[0] != 0) && (drive_letters[1] != 0)) ? ModernizedCProgram.lmprintf(3047) : label)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen((((drive_letters[0] != 0) && (drive_letters[1] != 0)) ? ModernizedCProgram.lmprintf(3047) : label))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
							} while (0);
							for (; drive_letters[k] && (!remove_drive); k++) {
								letter_name[2] = drive_letters[k];
								if (ModernizedCProgram.right_to_left_mode) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(entry_msg, "â?", (((size_t)(((((byte)"â?") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("â?")) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)entry_msg) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(entry_msg)) - 1)) ? ((size_t)(((((byte)"â?") == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen("â?")) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)entry_msg) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(entry_msg)) - 1))));
								} 
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncat(entry_msg, letter_name, (((size_t)(((((byte)letter_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(letter_name)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)entry_msg) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(entry_msg)) - 1)) ? ((size_t)(((((byte)letter_name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(letter_name)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - ((((byte)entry_msg) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(entry_msg)) - 1))));
								if (drive_letters[k] == (ModernizedCProgram.PathGetDriveNumberU(ModernizedCProgram.app_dir) + (byte)'A')) {
									remove_drive = 1;
								} 
								if (drive_letters[k] == (ModernizedCProgram.PathGetDriveNumberU(ModernizedCProgram.system_dir) + (byte)'A')) {
									remove_drive = 2;
								} 
							}
							if (remove_drive) {
								ModernizedCProgram._uprintf("Removing %C: from the list: This is the %s!", drive_letters[--k], (remove_drive == 1) ? "disk from which Rufus is running" : "system disk");
								do {
									if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
										hDrive = (HANDLE)(true);
									} 
								} while (0);
								do {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devint_detail_data);
									devint_detail_data = ((Object)0);
								} while (0);
								break;
							} 
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(entry_msg[/*Error: Function owner not recognized*/strlen(entry_msg)], /*Error: sizeof expression not supported yet*/ - /*Error: Function owner not recognized*/strlen(entry_msg), "%s [%s]", (ModernizedCProgram.right_to_left_mode) ? "â?" : "", ModernizedCProgram.SizeToHumanReadable(ModernizedCProgram.GetDriveSize(drive_index), 0, ModernizedCProgram.use_fake_units));
								(entry_msg[/*Error: Function owner not recognized*/strlen(entry_msg)])[(/*Error: sizeof expression not supported yet*/ - /*Error: Function owner not recognized*/strlen(entry_msg)) - 1] = 0;
							} while (0);
							entry = entry_msg;
					} 
					ModernizedCProgram.DriveId.StrArrayAdd(device_instance_id, 1);
					ModernizedCProgram.DriveName.StrArrayAdd(buffer, 1);
					ModernizedCProgram.DriveLabel.StrArrayAdd(label, 1);
					if ((hub_path != ((Object)0)) && (ModernizedCProgram.DriveHub.StrArrayAdd(hub_path, 1) >= 0)) {
						ModernizedCProgram.DrivePort[ModernizedCProgram.DriveHub.getIndex() - 1] = generatedPort;
					} 
					do {
						(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(ModernizedCProgram.hDeviceList, 323, (WPARAM)0, entry))), (LPARAM)(drive_index))));
					} while (0);
					maxwidth = ((maxwidth) > (ModernizedCProgram.GetEntryWidth(ModernizedCProgram.hDeviceList, entry)) ? (maxwidth) : (ModernizedCProgram.GetEntryWidth(ModernizedCProgram.hDeviceList, entry)));
					do {
						if ((hDrive != (HANDLE)(true)) && (hDrive != ((Object)0))) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(hDrive);
							hDrive = (HANDLE)(true);
						} 
					} while (0);
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devint_detail_data);
						devint_detail_data = ((Object)0);
					} while (0);
					break;
				} 
			}
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetupDiDestroyDeviceInfoList(dev_info);
		/*Error: Function owner not recognized*/// Adjust the Dropdown width to the maximum text size/*Error: Function owner not recognized*/// Adjust the Dropdown width to the maximum text sizeSendMessageA(ModernizedCProgram.hDeviceList, 352, (WPARAM)maxwidth, 0);
		if (devnum >= -1024) {
			for (i = 0; i < ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 326, 0, 0)); i++) {
				if ((DWORD)((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 336, (WPARAM)(int)(i), 0)) == devnum) {
					found = 1;
					break;
				} 
			}
		} 
		if (!found) {
			i = 0;
		} 
		do {
			(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 334, (WPARAM)(int)(i), 0)));
		} while (0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, 273, (1 << 16) | 1001, 0);
		r = 1;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)devid_list);
			devid_list = ((Object)0);
		} while (0);
		dev_if_path.StrArrayDestroy();
		htab_devid.htab_destroy();
		return r;
	}
	public static void set_bytes_per_sector(long ulValue) {
		ModernizedCProgram.ulBytesPerSector = ulValue;
		if ((ModernizedCProgram.ulBytesPerSector < 512) || (ModernizedCProgram.ulBytesPerSector > 65536)) {
			ModernizedCProgram.ulBytesPerSector = 512/* set_bytes_per_sector */;
		} 
	}
	public static Object read_windows_disk_signature() {
		uint32_t tWDS = new uint32_t();
		if (!fp.read_data(-1024, tWDS, 4)) {
			return 0;
		} 
		return tWDS/* read_windows_disk_signature */;
	}
	public static int write_windows_disk_signature(Object tWDS) {
		return fp.write_data(-1024, tWDS, 4/* write_windows_disk_signature */);
	}
	public static Object read_mbr_copy_protect_bytes() {
		uint16_t tOut = new uint16_t();
		if (!fp.read_data(-1024, tOut, 2)) {
			return -1024;
		} 
		return tOut/* read_mbr_copy_protect_bytes */;
	}
	public static Object read_mbr_copy_protect_bytes_explained() {
		uint16_t t = fp.read_mbr_copy_protect_bytes();
		switch (t) {
		case 0:
				return ("not copy protected");
		case -1024:
				return ("copy protected");
		default:
				return ("unknown value"/* read_mbr_copy_protect_bytes_explained */);
		}
	}
	public static int is_br() {
		byte[] aucRef = new byte[]{-1024, /* A "file" is probably some kind of boot record if it contains the magic
		      chars 0x55, 0xAA at position 0x1FE */-1024};
		return fp.contains_data(-1024, aucRef, /*Error: sizeof expression not supported yet*/);
	}
	public static int is_lilo_br() {
		byte[] aucRef = new byte[]{(byte)'L', (byte)'I', (byte)'L', /* A "file" is probably a LILO boot record if it contains the magic
		      chars LILO at position 0x6 or 0x2 for floppies */(byte)'O'};
		return (fp.contains_data(-1024, aucRef, /*Error: sizeof expression not supported yet*/) || fp.contains_data(-1024, aucRef, /*Error: sizeof expression not supported yet*/));
	}
	public static int is_dos_mbr() {
		byte[] mbr_dos_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_dos_0x0, /*Error: sizeof expression not supported yet*/) && fp/* is_dos_mbr */.is_br();
	}
	public static int is_dos_f2_mbr() {
		byte[] mbr_dos_f2_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_dos_f2_0x0, /*Error: sizeof expression not supported yet*/) && fp/* is_dos_f2_mbr */.is_br();
	}
	public static int is_95b_mbr() {
		byte[] mbr_95b_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] mbr_95b_0x0e0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_95b_0x0, /*Error: sizeof expression not supported yet*/) && fp.contains_data(-1024, mbr_95b_0x0e0, /*Error: sizeof expression not supported yet*/) && fp/* is_95b_mbr */.is_br();
	}
	public static int is_2000_mbr() {
		byte[] mbr_2000_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_2000_0x0, -1024) && fp/* is_2000_mbr */.is_br();
	}
	public static int is_vista_mbr() {
		byte[] mbr_vista_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_vista_0x0, -1024) && fp/* is_vista_mbr */.is_br();
	}
	public static int is_win7_mbr() {
		byte[] mbr_win7_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_win7_0x0, -1024) && fp/* is_win7_mbr */.is_br();
	}
	public static int is_rufus_mbr() {
		byte[] mbr_rufus_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_rufus_0x0, /*Error: sizeof expression not supported yet*/) && fp/* is_rufus_mbr */.is_br();
	}
	public static int is_rufus_gpt_mbr() {
		byte[] mbr_gpt_rufus_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_gpt_rufus_0x0, /*Error: sizeof expression not supported yet*/) && fp/* is_rufus_gpt_mbr */.is_br();
	}
	public static int is_reactos_mbr() {
		byte[] mbr_reactos_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_reactos_0x0, /*Error: sizeof expression not supported yet*/) && fp/* is_reactos_mbr */.is_br();
	}
	public static int is_grub4dos_mbr() {
		byte[] mbr_grub_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_grub_0x0, /*Error: sizeof expression not supported yet*/) && fp/* is_grub_mbr */.is_br();
	}
	public static int is_grub2_mbr() {
		byte[] mbr_grub2_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_grub2_0x0, /*Error: sizeof expression not supported yet*/) && fp/* is_grub2_mbr */.is_br();
	}
	public static int is_kolibrios_mbr() {
		byte[] mbr_kolibri_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_kolibri_0x0, /*Error: sizeof expression not supported yet*/) && fp/* is_kolibri_mbr */.is_br();
	}
	public static int is_syslinux_mbr() {
		byte[] mbr_syslinux_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_syslinux_0x0, /*Error: sizeof expression not supported yet*/) && fp/* is_syslinux_mbr */.is_br();
	}
	public static int is_syslinux_gpt_mbr() {
		byte[] mbr_gpt_syslinux_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_gpt_syslinux_0x0, /*Error: sizeof expression not supported yet*/) && fp/* is_syslinux_gpt_mbr */.is_br();
	}
	public static int is_zero_mbr() {
		byte[] mbr_zero_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_zero_0x0, /*Error: sizeof expression not supported yet*/);
	}
	public static int is_zero_mbr_not_including_disk_signature_or_copy_protect() {
		byte[] mbr_zero_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.contains_data(-1024, mbr_zero_0x0, -1024/* is_zero_mbr_not_including_disk_signature_or_copy_protect */);
	}
	/* Handle nonstandard sector sizes (such as 4K) by writing
	   the boot marker at every 512-2 bytes location */
	public static int write_bootmark() {
		byte[] aucRef = new byte[]{-1024, -1024};
		long pos = -1024;
		for (pos = -1024; pos < ModernizedCProgram.ulBytesPerSector; pos += -1024) {
			if (!fp.write_data(pos, aucRef, /*Error: sizeof expression not supported yet*/)) {
				return 0;
			} 
		}
		return 1;
	}
	public static int write_dos_mbr() {
		byte[] mbr_dos_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_dos_0x0, /*Error: sizeof expression not supported yet*/) && fp/* write_dos_mbr */.write_bootmark();
	}
	public static int write_95b_mbr() {
		byte[] mbr_95b_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		byte[] mbr_95b_0x0e0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_95b_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_data(-1024, mbr_95b_0x0e0, /*Error: sizeof expression not supported yet*/) && fp/* write_95b_mbr */.write_bootmark();
	}
	public static int write_2000_mbr() {
		byte[] mbr_2000_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_2000_0x0, /*Error: sizeof expression not supported yet*/) && fp/* write_2000_mbr */.write_bootmark();
	}
	public static int write_vista_mbr() {
		byte[] mbr_vista_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_vista_0x0, /*Error: sizeof expression not supported yet*/) && fp/* write_vista_mbr */.write_bootmark();
	}
	public static int write_win7_mbr() {
		byte[] mbr_win7_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_win7_0x0, /*Error: sizeof expression not supported yet*/) && fp/* write_win7_mbr */.write_bootmark();
	}
	public static int write_rufus_mbr() {
		byte[] mbr_rufus_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_rufus_0x0, /*Error: sizeof expression not supported yet*/) && fp/* write_rufus_mbr */.write_bootmark();
	}
	public static int write_rufus_gpt_mbr() {
		byte[] mbr_gpt_rufus_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_gpt_rufus_0x0, /*Error: sizeof expression not supported yet*/) && fp/* write_rufus_gpt_mbr */.write_bootmark();
	}
	public static int write_reactos_mbr() {
		byte[] mbr_reactos_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_reactos_0x0, /*Error: sizeof expression not supported yet*/) && fp/* write_reactos_mbr */.write_bootmark();
	}
	public static int write_kolibrios_mbr() {
		byte[] mbr_kolibri_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_kolibri_0x0, /*Error: sizeof expression not supported yet*/) && fp/* write_kolibri_mbr */.write_bootmark();
	}
	public static int write_syslinux_mbr() {
		byte[] mbr_syslinux_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_syslinux_0x0, /*Error: sizeof expression not supported yet*/) && fp/* write_syslinux_mbr */.write_bootmark();
	}
	public static int write_syslinux_gpt_mbr() {
		byte[] mbr_gpt_syslinux_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_gpt_syslinux_0x0, /*Error: sizeof expression not supported yet*/) && fp/* write_syslinux_gpt_mbr */.write_bootmark();
	}
	public static int write_grub4dos_mbr() {
		byte[] mbr_grub_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_grub_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_bootmark();
	}
	public static int write_grub2_mbr() {
		byte[] mbr_grub2_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_grub2_0x0, /*Error: sizeof expression not supported yet*/) && fp.write_bootmark();
	}
	public static int write_zero_mbr() {
		byte[] mbr_zero_0x0 = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return fp.write_data(-1024, mbr_zero_0x0, /*Error: sizeof expression not supported yet*/) && fp/* write_zero_mbr */.write_bootmark();
	}
	/*
	  Copyright (C) 2006, 2008 Burkhard Plaum <plaum@ipf.uni-stuttgart.de>
	  Copyright (C) 2011, 2014 Rocky Bernstein <rocky@gnu.org>
	  Copyright (C) 2012 Pete Batard <pete@akeo.ie>
	
	  This program is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  This program is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/
	/* UTF-8 support */
	/* Windows requires some basic UTF-8 support outside of Joliet */
	/*
	 * Converts an UTF-16 string to UTF8 (allocate returned string)
	 * Returns NULL on error
	 */
	public static Byte cdio_wchar_to_utf8(Object wstr) {
		int size = 0;
		byte str = ((Object)0);
		size = /*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wstr, -1, ((Object)0), 0, ((Object)0), ((Object)/* Find out the size we need to allocate for our converted string */0));
		if (size <= /* An empty string would be size 1 */1) {
			return ((Object)0);
		} 
		if ((str = (byte)/*Error: Function owner not recognized*/calloc(size, 1)) == ((Object)0)) {
			return ((Object)0);
		} 
		if (/*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wstr, -1, str, size, ((Object)0), ((Object)0)) != size) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(str);
			return ((Object)0);
		} 
		return str/*
		 * Converts an UTF8 string to UTF-16 (allocate returned string)
		 * Returns NULL on error
		 */;
	}
	public static Object cdio_utf8_to_wchar(Object str) {
		int size = 0;
		wchar_t wstr = ((Object)0);
		size = /*Error: Function owner not recognized*/MultiByteToWideChar(65001, 0, str, -1, ((Object)0), /* Find out the size we need to allocate for our converted string */0);
		if (size <= /* An empty string would be size 1 */1) {
			return ((Object)0);
		} 
		if ((wstr = (wchar_t)/*Error: Function owner not recognized*/calloc(size, /*Error: Unsupported expression*/)) == ((Object)0)) {
			return ((Object)0);
		} 
		if (/*Error: Function owner not recognized*/MultiByteToWideChar(65001, 0, str, -1, wstr, size) != size) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(wstr);
			return ((Object)0);
		} 
		return wstr;
	}
	/* UTF-8 compliant version of fopen() */
	public static Object fopen_utf8(Object filename, Object mode) {
		 ret = ((Object)0);
		wchar_t wfilename = ModernizedCProgram.cdio_utf8_to_wchar(filename);
		wchar_t wmode = ModernizedCProgram.cdio_utf8_to_wchar(mode);
		ret = /*Error: Function owner not recognized*/_wfopen(wfilename, wmode);
		ModernizedCProgram.cdio_free(wfilename);
		ModernizedCProgram.cdio_free(wmode);
		return ret;
	}
	/* We reserve space here to add a final '\0' */
	/* Zero terminate */
	/* Set return values */
	public static Object cdio_charset_from_utf8(Object src, Byte dst, Integer dst_len, Object dst_charset) {
		wchar_t le_dst = new wchar_t();
		size_t i = new size_t();
		size_t len = new size_t();
		if (src == ((Object)0) || dst == ((Object)0) || dst_len == ((Object)0) || dst_charset == ((Object)0) || /*Error: Function owner not recognized*/strcmp(dst_charset, "UTF-8") != 0) {
			return false;
		} 
		le_dst = ModernizedCProgram.cdio_utf8_to_wchar(/* Eliminate empty strings */src);
		if ((le_dst == ((Object)0)) || (le_dst[0] == 0)) {
			ModernizedCProgram.cdio_free(le_dst);
			return false;
		} 
		len = /*Error: Function owner not recognized*/wcslen(/* Perform byte reversal */le_dst);
		dst = (byte)/*Error: Function owner not recognized*/calloc(len + 1, /*Error: Unsupported expression*/);
		((dst != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("*dst != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\utf8.c", 304));
		for (i = 0; i < 2 * len; i++) {
			(dst)[i] = ((byte)le_dst)[i + 1];
			(dst)[i + 1] = ((byte)le_dst)[i];
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(le_dst);
		return true;
	}
	public static Object cdio_charset_to_utf8(Object[] src, Object src_len, Object dst, Object src_charset) {
		wchar_t le_src = new wchar_t();
		int i;
		if (src == ((Object)0) || dst == ((Object)0) || src_charset == ((Object)0) || /*Error: Function owner not recognized*/strcmp(src_charset, "UCS-2BE") != 0) {
			return false;
		} 
		if (src_len == (size_t)-/* Compute UCS-2 src length */1) {
			for (src_len = 0; (()src)[src_len] != 0; src_len++) {
				;
			}
		} else {
				src_len >>=  1;
		} 
		if ((src_len < 1) || ((src[0] == 0) && (src[1] == /* Eliminate empty strings */0))) {
			dst = ((Object)0);
			return false;
		} 
		le_src = (wchar_t)/*Error: Function owner not recognized*/malloc(2 * src_len + /* Perform byte reversal */2);
		((le_src != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("le_src != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\utf8.c", 338));
		for (i = 0; i < src_len; i++) {
			((byte)le_src)[2 * i] = src[2 * i + 1];
			((byte)le_src)[2 * i + 1] = src[2 * i];
		}
		le_src[src_len] = 0;
		dst = ModernizedCProgram.cdio_wchar_to_utf8(le_src);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(le_src);
		return (dst != ((Object)0/* HAVE_ICONV */));
	}
	public static Object ext2fs_block_iterate3(Object fs, Object ino, int flags, Byte block_buf, Object func, Object priv_data) {
		int i;
		int r;
		int ret = 0;
		ext2_inode inode = new ext2_inode();
		 retval = new ();
		block_context ctx = new block_context();
		int limit;
		 blk64 = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		ctx.setErrcode(inode.ext2fs_read_inode(fs, ino));
		Object generatedErrcode = ctx.getErrcode();
		if (generatedErrcode) {
			return generatedErrcode;
		} 
		Object generatedI_flags = inode.getI_flags();
		if (generatedI_flags & -1024) {
			return EXT2_ET_INLINE_DATA_CANT_ITERATE/*
				 * Check to see if we need to limit large files
				 */;
		} 
		Object generatedI_mode = inode.getI_mode();
		Object generatedI_size_high = inode.getI_size_high();
		if (flags & -1024) {
			if (!(((generatedI_mode) & 170000) == 40000) && (generatedI_size_high != 0)) {
				return EXT2_ET_FILE_TOO_BIG;
			} 
		} 
		limit = fs.getBlocksize() >> 2;
		ctx.setFs(fs);
		ctx.setFunc(func);
		ctx.setPriv_data(priv_data);
		ctx.setFlags(flags);
		ctx.setBcount(0);
		Byte generatedInd_buf = ctx.getInd_buf();
		if (block_buf) {
			ctx.setInd_buf(block_buf);
		} else {
				retval = ModernizedCProgram.ext2fs_get_array(3, fs.getBlocksize(), generatedInd_buf);
				if (retval) {
					return retval;
				} 
		} 
		ctx.setDind_buf(generatedInd_buf + fs.getBlocksize());
		Byte generatedDind_buf = ctx.getDind_buf();
		ctx.setTind_buf(generatedDind_buf + fs.getBlocksize());
		 generatedOsd1 = inode.getOsd1();
		Object generatedHurd1 = generatedOsd1.getHurd1();
		int generatedFlags = (ctx).getFlags();
		if ((fs.getSuper().getS_creator_os() == 1) && !(flags & 4)) {
			if (generatedHurd1.getH_i_translator()) {
				blk64 = generatedHurd1.getH_i_translator();
				ret |=  /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, blk64, (true), 0, 0, priv_data);
				generatedHurd1.setH_i_translator(()blk64);
				if (ret & 2) {
					;
				} 
				do {
					if ((generatedFlags & 8) && ((ret) & 1)) {
						(ctx).setErrcode(EXT2_ET_RO_BLOCK_ITERATE);
						ret |=  2 | 4;
						;
					} 
				} while (0);
			} 
		} 
		Object generatedI_block = inode.getI_block();
		Object generatedBcount = ctx.getBcount();
		for (i = 0; i < 12; ) {
			if (generatedI_block[i] || (flags & 1)) {
				blk64 = generatedI_block[i];
				ret |=  /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, blk64, generatedBcount, 0, i, priv_data);
				generatedI_block[i] = ()blk64;
				if (ret & 2) {
					;
				} 
			} 
		}
		do {
			if ((generatedFlags & 8) && ((ret) & 1)) {
				(ctx).setErrcode(EXT2_ET_RO_BLOCK_ITERATE);
				ret |=  2 | 4;
				;
			} 
		} while (0);
		if (generatedI_block[12] || (flags & 1)) {
			ret |=  ctx.block_iterate_ind(generatedI_block[12], 0, 12);
			if (ret & 2) {
				;
			} 
		} else {
				generatedBcount += limit;
		} 
		if (generatedI_block[(12 + 1)] || (flags & 1)) {
			ret |=  ctx.block_iterate_dind(generatedI_block[(12 + 1)], 0, (12 + 1));
			if (ret & 2) {
				;
			} 
		} else {
				generatedBcount += limit * limit;
		} 
		if (generatedI_block[((12 + 1) + 1)] || (flags & 1)) {
			ret |=  ctx.block_iterate_tind(generatedI_block[((12 + 1) + 1)], 0, ((12 + 1) + 1));
			if (ret & 2) {
				;
			} 
		} 
		return (ret & 4) ? generatedErrcode : 0/*
		 * Emulate the old ext2fs_block_iterate function!
		 */;
	}
	public static int xlate64_func(Object fs, Object blocknr, Object blockcnt, Object ref_blk, int ref_offset, Object priv_data) {
		xlate64 xl = (xlate64)priv_data;
		int ret;
		 block32 = blocknr;
		Object generatedReal_private = xl.getReal_private();
		ret = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, block32, blockcnt, ()ref_blk, ref_offset, generatedReal_private);
		blocknr = block32;
		return ret;
	}
	public static Object ext2fs_block_iterate2(Object fs, Object ino, int flags, Byte block_buf, Object func, Object priv_data) {
		xlate64 xl = new xlate64();
		xl.setReal_private(priv_data);
		xl.setFunc(func);
		return ModernizedCProgram.ext2fs_block_iterate3(fs, ino, flags, block_buf, xlate64_func, xl);
	}
	public static Object ext2fs_block_iterate(Object fs, Object ino, int flags, Byte block_buf, Object func, Object priv_data) {
		xlate xl = new xlate();
		xl.setReal_private(priv_data);
		xl.setFunc(func);
		return ModernizedCProgram.ext2fs_block_iterate2(fs, ino, -1024 | flags, block_buf, xlate_func, xl);
	}
	/*
	  filemode.c -- make a string describing file modes
	
	  Copyright (C) 2005, 2008, 2011, 2012 Rocky Bernstein <rocky@gnu.org>
	  Copyright (C) 1985, 1990, 1993, 1998-2000 Free Software Foundation, Inc.
	
	  This program is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  This program is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/
	/* Set the 's' and 't' flags in file attributes string CHARS,
	   according to the file mode BITS.  */
	public static void setst(Object bits, Byte chars) {
	}
	/* Set-uid, but not executable by owner.  */
	/* Set-gid, but not executable by group.  */
	/* Sticky, but not executable by others.  */
	/* Return a character indicating the type of file described by
	   file mode BITS:
	   'd' for directories
	   'D' for doors
	   'b' for block special files
	   'c' for character special files
	   'n' for network special files
	   'm' for multiplexor files
	   'M' for an off-line (regular) file
	   'l' for symbolic links
	   's' for sockets
	   'p' for fifos
	   'C' for contigous data files
	   '-' for regular files
	   '?' for any other file type.  */
	public static byte ftypelet(Object bits) {
		if ((((bits) & S_IFMT) == -1024)) {
			return (byte)'b';
		} 
		if (/*Error: Function owner not recognized*/S_ISCHR(bits)) {
			return (byte)'c';
		} 
		if (/*Error: Function owner not recognized*/S_ISDIR(bits)) {
			return (byte)'d';
		} 
		if (/*Error: Function owner not recognized*/S_ISREG(bits)) {
			return (byte)'-';
		} 
		if ((((bits) & S_IFMT) == -1024)) {
			return (byte)'p';
		} 
		if (()) {
			return (byte)'l';
		} 
		if (()) {
			return (byte)'s';
		} 
		/* The following two tests are for Cray DMF (Data Migration
		     Facility), which is a HSM file system.  A migrated file has a
		     `st_dm_mode' that is different from the normal `st_mode', so any
		     tests for migrated files should use the former.  *//* off line, with data  */return /* off line, with no data  */(byte)'?'/*! udf_mode_string - fill in string STR with an ls-style ASCII
		   representation of the st_mode field of file stats block STATP.
		   10 characters are stored in STR; no terminating null is added.
		   The characters stored in STR are:
		
		   0	File type.  'd' for directory, 'c' for character
			special, 'b' for block special, 'm' for multiplex,
			'l' for symbolic link, 's' for socket, 'p' for fifo,
			'-' for regular, '?' for any other file type
		
		   1	'r' if the owner may read, '-' otherwise.
		
		   2	'w' if the owner may write, '-' otherwise.
		
		   3	'x' if the owner may execute, 's' if the file is
			set-user-id, '-' otherwise.
			'S' if the file is set-user-id, but the execute
			bit isn't set.
		
		   4	'r' if group members may read, '-' otherwise.
		
		   5	'w' if group members may write, '-' otherwise.
		
		   6	'x' if group members may execute, 's' if the file is
			set-group-id, '-' otherwise.
			'S' if it is set-group-id but not executable.
		
		   7	'r' if any user may read, '-' otherwise.
		
		   8	'w' if any user may write, '-' otherwise.
		
		   9	'x' if any user may execute, 't' if the file is "sticky"
			(will be retained in swap space after execution), '-'
			otherwise.
			'T' if the file is sticky but not executable.  */;
	}
	public static Byte udf_mode_string(Object i_mode, byte[] psz_str) {
		psz_str[0] = ModernizedCProgram.ftypelet(i_mode);
		psz_str[1] = i_mode & 400 ? (byte)'r' : (byte)'-';
		psz_str[2] = i_mode & 200 ? (byte)'w' : (byte)'-';
		psz_str[3] = i_mode & 100 ? (byte)'x' : (byte)'-';
		psz_str[4] = i_mode & (400 >> 3) ? (byte)'r' : (byte)'-';
		psz_str[5] = i_mode & (200 >> 3) ? (byte)'w' : (byte)'-';
		psz_str[6] = i_mode & (100 >> 3) ? (byte)'x' : (byte)'-';
		psz_str[7] = i_mode & (400 >> 6) ? (byte)'r' : (byte)'-';
		psz_str[8] = i_mode & (200 >> 6) ? (byte)'w' : (byte)'-';
		psz_str[9] = i_mode & (100 >> 6) ? (byte)'x' : (byte)'-';
		psz_str[10] = (byte)'\0';
		ModernizedCProgram.setst(i_mode, psz_str);
		return psz_str;
	}
	public static int main(int argc_ansi, Byte argv_ansi) {
		DWORD size = new DWORD();
		HANDLE mutex = new HANDLE();
		HANDLE stdout = new HANDLE();
		stdout = /*Error: Function owner not recognized*/GetStdHandle((DWORD)(true));
		mutex = /*Error: Function owner not recognized*/OpenMutexA(-1024, 0, "Global/Rufus_CmdLine");
		if (mutex == ((Object)0)) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject(mutex, -1024);
		;
	}
	/*
	 * openfs.c --- open an ext2 filesystem
	 *
	 * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static Object ext2fs_descriptor_block_loc2(Object fs, Object group_block, Object i) {
		int bg;
		int has_super = 0;
		int group_zero_adjust = 0;
		 ret_blk = new ();
		/*
			 * On a bigalloc FS with 1K blocks, block 0 is reserved for non-ext4
			 * stuff, so adjust for that if we're being asked for group 0.
			 */
		if (i == 0 && fs.getBlocksize() == 1024 && (-1024 << (fs).getCluster_ratio_bits()) > 1) {
			group_zero_adjust = 1;
		} 
		if (!fs.getSuper().ext2fs_has_feature_meta_bg() || (i < fs.getSuper().getS_first_meta_bg())) {
			return group_block + i + 1 + group_zero_adjust;
		} 
		bg = (((1 << 10) << (fs.getSuper()).getS_log_block_size()) / (((fs.getSuper()).getS_feature_incompat() & -1024) ? (fs.getSuper()).getS_desc_size() : 32)) * i;
		if (ModernizedCProgram.ext2fs_bg_has_super(fs, bg)) {
			has_super = 1;
		} 
		ret_blk = ModernizedCProgram.ext2fs_group_first_block2(fs, bg/*
			 * If group_block is not the normal value, we're trying to use
			 * the backup group descriptors and superblock --- so use the
			 * alternate location of the second block group in the
			 * metablock group.  Ideally we should be testing each bg
			 * descriptor block individually for correctness, but we don't
			 * have the infrastructure in place to do that.
			 */);
		if (group_block != fs.getSuper().getS_first_data_block() && ((ret_blk + has_super + fs.getSuper().getS_blocks_per_group()) < fs.getSuper().ext2fs_blocks_count())) {
			ret_blk += fs.getSuper().getS_blocks_per_group();
			if (ModernizedCProgram.ext2fs_bg_has_super(fs, bg + 1)) {
				has_super = 1;
			} else {
					has_super = 0;
			} 
		} 
		return ret_blk + has_super + group_zero_adjust;
	}
	public static Object ext2fs_descriptor_block_loc(Object fs, Object group_block, Object i) {
		return ModernizedCProgram.ext2fs_descriptor_block_loc2(fs, group_block, i);
	}
	public static Object ext2fs_open(Object name, int flags, int superblock, int block_size, Object manager, Object ret_fs) {
		return ModernizedCProgram.ext2fs_open2(name, 0, flags, superblock, block_size, manager, ret_fs);
	}
	public static void block_sha_map_free_entry(Object data) {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(data);
		return /*Error: Unsupported expression*/;/*
		 *  Note: if superblock is non-zero, block-size must also be non-zero.
		 * 	Superblock and block_size can be zero to use the default size.
		 *
		 * Valid flags for ext2fs_open()
		 *
		 * 	EXT2_FLAG_RW	- Open the filesystem for read/write.
		 * 	EXT2_FLAG_FORCE - Open the filesystem even if some of the
		 *				features aren't supported.
		 *	EXT2_FLAG_JOURNAL_DEV_OK - Open an ext3 journal device
		 *	EXT2_FLAG_SKIP_MMP - Open without multi-mount protection check.
		 *	EXT2_FLAG_64BITS - Allow 64-bit bitfields (needed for large
		 *				filesystems)
		 */
	}
	public static Object ext2fs_open2(Object name, Object io_options, int flags, int superblock, int block_size, Object manager, Object ret_fs) {
		ext2_filsys fs = new ext2_filsys();
		 retval = new ();
		long i;
		long first_meta_bg;
		 features = new ();
		int blocks_per_group;
		int io_flags;
		 group_block = new ();
		 blk = new ();
		byte dest;
		byte cp;
		int group_zero_adjust = 0;
		int inode_size;
		 groups_cnt = new ();
		byte time_env;
		if (!(manager) || (manager).getMagic() != (EXT2_ET_MAGIC_IO_MANAGER)) {
			return (EXT2_ET_MAGIC_IO_MANAGER);
		} 
		retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Unsupported expression*/, fs);
		if (retval) {
			return retval;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(fs, 0, /*Error: Unsupported expression*/);
		fs.setMagic(EXT2_ET_MAGIC_EXT2FS_FILSYS);
		fs.setFlags(flags);
		fs.getFlags() |=  /* don't overwrite sb backups unless flag is explicitly cleared */-1024;
		fs.setUmask(22);
		time_env = /*Error: Function owner not recognized*/getenv("E2FSPROGS_FAKE_TIME");
		if (time_env) {
			fs.setNow(/*Error: Function owner not recognized*/strtoul(time_env, ((Object)0), 0));
		} 
		retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Function owner not recognized*/strlen(name) + 1, fs.getDevice_name());
		if (retval) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(fs.getDevice_name(), name);
		cp = /*Error: Function owner not recognized*/strchr(fs.getDevice_name(), (byte)'?')// Don't process "?\" as an option since some Windows device paths use "\\?\...";// Don't process "?\" as an option since some Windows device paths use "\\?\..."
		if (!io_options && cp && cp[1] != (byte)'\\') {
			cp++ = 0;
			io_options = cp;
		} 
		io_flags = 0;
		if (flags & -1024) {
			io_flags |=  IO_FLAG_RW;
		} 
		if (flags & -1024) {
			io_flags |=  IO_FLAG_EXCLUSIVE;
		} 
		if (flags & -1024) {
			io_flags |=  IO_FLAG_DIRECT_IO;
		} 
		retval = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs.getDevice_name(), io_flags, fs.getIo());
		if (retval) {
			;
		} 
		if (io_options && (retval = ModernizedCProgram.io_channel_set_options(fs.getIo(), io_options))) {
			;
		} 
		fs.setImage_io(fs.getIo());
		fs.getIo().setApp_data(fs);
		retval = ModernizedCProgram.io_channel_alloc_buf(fs.getIo(), -1024, fs.getSuper());
		if (retval) {
			;
		} 
		if (flags & -1024) {
			retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Unsupported expression*/, fs.getImage_header());
			if (retval) {
				;
			} 
			retval = /*Error: Function owner not recognized*/io_channel_read_blk(fs.getIo(), 0, -(int)/*Error: Unsupported expression*/, fs.getImage_header());
			if (retval) {
				;
			} 
			if (/*Error: Function owner not recognized*/ext2fs_le32_to_cpu(fs.getImage_header().getExt2_image_hdr()) != EXT2_ET_MAGIC_E2IMAGE) {
				return EXT2_ET_MAGIC_E2IMAGE;
			} 
			superblock = 1;
			block_size = /*Error: Function owner not recognized*/ext2fs_le32_to_cpu(fs.getImage_header().getExt2_image_hdr());
		} 
		if (superblock) {
			if (!block_size) {
				retval = EXT2_ET_INVALID_ARGUMENT;
				;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/io_channel_set_blksize(fs.getIo(), block_size);
			group_block = superblock;
			fs.setOrig_super(0);
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/io_channel_set_blksize(fs.getIo(), 1024);
				superblock = 1;
				group_block = 0;
				retval = ModernizedCProgram.ext2fs_get_mem(1024, fs.getOrig_super());
				if (retval) {
					;
				} 
		} 
		retval = /*Error: Function owner not recognized*/io_channel_read_blk(fs.getIo(), superblock, -1024, fs.getSuper());
		if (retval) {
			;
		} 
		if (fs.getOrig_super()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(fs.getOrig_super(), fs.getSuper(), 1024);
		} 
		if (!(fs.getFlags() & -1024)) {
			retval = 0;
			if (!fs.getSuper().ext2fs_verify_csum_type(fs)) {
				retval = EXT2_ET_UNKNOWN_CSUM;
			} 
			if (!fs.getSuper().ext2fs_superblock_csum_verify(fs)) {
				retval = EXT2_ET_SB_CSUM_INVALID;
			} 
		} 
		if (fs.getFlags() & -1024) {
			retval = EXT2_ET_UNIMPLEMENTED;
			;
		} 
		if (fs.getSuper().getS_magic() != -1024) {
			retval = EXT2_ET_BAD_MAGIC;
		} 
		if (retval) {
			;
		} 
		if (fs.getSuper().getS_rev_level() > 1) {
			retval = EXT2_ET_REV_TOO_HIGH;
			;
		} 
		if (!(flags & /*
			 * Check for feature set incompatibility
			 */-1024)) {
			features = fs.getSuper().getS_feature_incompat();
			if (flags & -1024) {
				features &=  ~(false);
			} 
			if (features & ~(-1024 | -1024 | -1024 | -1024 | -1024 | -1024 | -1024 | (false) | -1024 | -1024 | -1024 | -1024 | -1024 | -1024)) {
				retval = EXT2_ET_UNSUPP_FEATURE;
				;
			} 
			features = fs.getSuper().getS_feature_ro_compat();
			if (flags & -1024) {
				features &=  ~(true);
			} 
			if ((flags & -1024) && (features & ~(-1024 | -1024 | -1024 | -1024 | -1024 | -1024 | -1024 | -1024 | -1024 | -1024 | -1024 | -1024 | -1024))) {
				retval = EXT2_ET_RO_UNSUPP_FEATURE;
				;
			} 
			if (!(flags & -1024) && fs.getSuper().ext2fs_has_feature_journal_dev()) {
				retval = EXT2_ET_UNSUPP_FEATURE;
				;
			} 
		} 
		if (fs.getSuper().getS_log_block_size() > (int)(16 - 10)) {
			retval = EXT2_ET_CORRUPT_SUPERBLOCK;
			;
		} 
		if (fs.getSuper().ext2fs_has_feature_bigalloc() && !(flags & -1024)) {
			retval = EXT2_ET_CANT_USE_LEGACY_BITMAPS;
			;
		} 
		if (!fs.getSuper().ext2fs_has_feature_bigalloc() && (fs.getSuper().getS_log_block_size() != fs.getSuper().getS_log_cluster_size())) {
			retval = EXT2_ET_CORRUPT_SUPERBLOCK;
			;
		} 
		fs.setFragsize(fs.setBlocksize(((1 << 10) << (fs.getSuper()).getS_log_block_size())));
		inode_size = (((fs.getSuper()).getS_rev_level() == 0) ? 128 : (fs.getSuper()).getS_inode_size());
		if ((inode_size < 128) || (inode_size > fs.getBlocksize()) || (inode_size & (inode_size - 1))) {
			retval = EXT2_ET_CORRUPT_SUPERBLOCK;
			;
		} 
		if (fs.getSuper().ext2fs_has_feature_64bit()) {
			if (fs.getSuper().getS_desc_size() < 64) {
				retval = EXT2_ET_BAD_DESC_SIZE;
				;
			} 
		} 
		fs.setCluster_ratio_bits(fs.getSuper().getS_log_cluster_size() - fs.getSuper().getS_log_block_size());
		if (((fs.getSuper()).getS_blocks_per_group()) != ((fs.getSuper()).getS_clusters_per_group()) << fs.getCluster_ratio_bits()) {
			retval = EXT2_ET_CORRUPT_SUPERBLOCK;
			;
		} 
		fs.setInode_blocks_per_group(((((fs.getSuper()).getS_inodes_per_group()) * (((fs.getSuper()).getS_rev_level() == 0) ? 128 : (fs.getSuper()).getS_inode_size()) + ((1 << 10) << (fs.getSuper()).getS_log_block_size()) - 1) / ((1 << 10) << (fs.getSuper()).getS_log_block_size())));
		if (block_size) {
			if (block_size != fs.getBlocksize()) {
				retval = EXT2_ET_UNEXPECTED_BLOCK_SIZE;
				;
			} 
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/io_channel_set_blksize(fs.getIo(), fs.getBlocksize());
		if (fs.getSuper().ext2fs_has_feature_journal_dev()) {
			fs.setGroup_desc_count(0);
			ret_fs = fs;
			return 0;
		} 
		if (((fs.getSuper()).getS_inodes_per_group()) == 0) {
			retval = EXT2_ET_CORRUPT_SUPERBLOCK;
			;
		} 
		ModernizedCProgram.ext2fs_init_csum_seed(/* Precompute the FS UUID to seed other checksums */fs/*
			 * Read group descriptors
			 */);
		blocks_per_group = ((fs.getSuper()).getS_blocks_per_group());
		if (blocks_per_group == 0 || blocks_per_group > ((((int)1 << 16) - 8) * (((1 << 10) << (fs.getSuper()).getS_log_cluster_size()) / ((1 << 10) << (fs.getSuper()).getS_log_block_size()))) || fs.getInode_blocks_per_group() > (((int)1 << 16) - (((1 << 10) << (fs.getSuper()).getS_log_block_size()) / (((fs.getSuper()).getS_rev_level() == 0) ? 128 : (fs.getSuper()).getS_inode_size()))) || (((1 << 10) << (fs.getSuper()).getS_log_block_size()) / (((fs.getSuper()).getS_feature_incompat() & -1024) ? (fs.getSuper()).getS_desc_size() : 32)) == 0 || fs.getSuper().getS_first_data_block() >= fs.getSuper().ext2fs_blocks_count()) {
			retval = EXT2_ET_CORRUPT_SUPERBLOCK;
			;
		} 
		groups_cnt = ModernizedCProgram.ext2fs_div64_ceil(fs.getSuper().ext2fs_blocks_count() - fs.getSuper().getS_first_data_block(), blocks_per_group);
		if (groups_cnt >> 32) {
			retval = EXT2_ET_CORRUPT_SUPERBLOCK;
			;
		} 
		fs.setGroup_desc_count(groups_cnt);
		if (!(flags & -1024) && ()fs.getGroup_desc_count() * ((fs.getSuper()).getS_inodes_per_group()) != fs.getSuper().getS_inodes_count()) {
			retval = EXT2_ET_CORRUPT_SUPERBLOCK;
			;
		} 
		fs.setDesc_blocks(ModernizedCProgram.ext2fs_div_ceil(fs.getGroup_desc_count(), (((1 << 10) << (fs.getSuper()).getS_log_block_size()) / (((fs.getSuper()).getS_feature_incompat() & -1024) ? (fs.getSuper()).getS_desc_size() : 32))));
		retval = ModernizedCProgram.ext2fs_get_array(fs.getDesc_blocks(), fs.getBlocksize(), fs.getGroup_desc());
		if (retval) {
			;
		} 
		if (!group_block) {
			group_block = fs.getSuper().getS_first_data_block();
		} 
		if (group_block == 0 && fs.getBlocksize() == 1024) {
			group_zero_adjust = 1;
		} 
		dest = (byte)fs.getGroup_desc();
		if (fs.getSuper().ext2fs_has_feature_meta_bg() && !(flags & -1024)) {
			first_meta_bg = fs.getSuper().getS_first_meta_bg();
			if (first_meta_bg > fs.getDesc_blocks()) {
				first_meta_bg = fs.getDesc_blocks();
			} 
		} else {
				first_meta_bg = fs.getDesc_blocks();
		} 
		if (first_meta_bg) {
			retval = /*Error: Function owner not recognized*/io_channel_read_blk(fs.getIo(), group_block + group_zero_adjust + 1, first_meta_bg, dest);
			if (retval) {
				;
			} 
			dest += fs.getBlocksize() * first_meta_bg;
		} 
		for (i = first_meta_bg; i < fs.getDesc_blocks(); i++) {
			blk = ModernizedCProgram.ext2fs_descriptor_block_loc2(fs, group_block, i);
			ModernizedCProgram.io_channel_cache_readahead(fs.getIo(), blk, 1);
		}
		for (i = first_meta_bg; i < fs.getDesc_blocks(); i++) {
			blk = ModernizedCProgram.ext2fs_descriptor_block_loc2(fs, group_block, i);
			retval = ModernizedCProgram.io_channel_read_blk64(fs.getIo(), blk, 1, dest);
			if (retval) {
				;
			} 
			dest += fs.getBlocksize();
		}
		fs.setStride(fs.getSuper().getS_raid_stride());
		if (superblock > 1 && ModernizedCProgram.ext2fs_has_group_desc_csum(fs)) {
			 group = new ();
			for (group = 0; group < fs.getGroup_desc_count(); group++) {
				ModernizedCProgram.ext2fs_bg_flags_clear(fs, group, -1024);
				ModernizedCProgram.ext2fs_bg_flags_clear(fs, group, -1024);
				ModernizedCProgram.ext2fs_bg_itable_unused_set(fs, group, 0/* The checksum will be reset later, but fix it here
							 * anyway to avoid printing a lot of spurious errors. */);
				ModernizedCProgram.ext2fs_group_desc_csum_set(fs, group);
			}
			if (fs.getFlags() & -1024) {
				ModernizedCProgram.ext2fs_mark_super_dirty(fs);
			} 
		} 
		if (fs.getSuper().ext2fs_has_feature_mmp() && !(flags & -1024) && (flags & (-1024 | -1024))) {
			retval = ModernizedCProgram.ext2fs_mmp_start(fs);
			if (retval) {
				fs.getFlags() |=  /* just do cleanup */-1024;
				ModernizedCProgram.ext2fs_mmp_stop(fs);
				;
			} 
		} 
		ext2fs_hashmap ext2fs_hashmap = new ext2fs_hashmap();
		if (fs.getFlags() & -1024) {
			fs.setBlock_sha_map(ext2fs_hashmap.ext2fs_hashmap_create(ModernizedCProgram.ext2fs_djb2_hash, block_sha_map_free_entry, 4096));
			if (!fs.getBlock_sha_map()) {
				retval = EXT2_ET_NO_MEMORY;
				;
			} 
			fs.getSuper().ext2fs_set_feature_shared_blocks();
		} 
		fs.getFlags() &=  ~-1024;
		ret_fs = fs;
		return 0;
		ret_fs = fs;
		return retval/*
		 * Set/get the filesystem data I/O channel.
		 *
		 * These functions are only valid if EXT2_FLAG_IMAGE_FILE is true.
		 */;
	}
	public static Object ext2fs_get_data_io(Object fs, Object old_io) {
		if ((fs.getFlags() & -1024) == 0) {
			return EXT2_ET_NOT_IMAGE_FILE;
		} 
		if (old_io) {
			old_io = (fs.getImage_io() == fs.getIo()) ? 0 : fs.getIo();
		} 
		return 0;
	}
	public static Object ext2fs_set_data_io(Object fs, Object new_io) {
		if ((fs.getFlags() & -1024) == 0) {
			return EXT2_ET_NOT_IMAGE_FILE;
		} 
		fs.setIo(new_io ? new_io : fs.getImage_io());
		return 0;
	}
	public static Object ext2fs_rewrite_to_io(Object fs, Object new_io) {
		 err = new ();
		if ((fs.getFlags() & -1024) == 0) {
			return EXT2_ET_NOT_IMAGE_FILE;
		} 
		err = /*Error: Function owner not recognized*/io_channel_set_blksize(new_io, fs.getBlocksize());
		if (err) {
			return err;
		} 
		if ((new_io == fs.getImage_io()) || (new_io == fs.getIo())) {
			return 0;
		} 
		if ((fs.getImage_io() != fs.getIo()) && fs.getImage_io()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/io_channel_close(fs.getImage_io());
		} 
		if (fs.getIo()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/io_channel_close(fs.getIo());
		} 
		fs.setIo(fs.setImage_io(new_io));
		fs.getFlags() |=  -1024 | -1024 | -1024 | -1024;
		fs.getFlags() &=  ~-1024;
		return 0;
	}
	public static int setenv(Object envname, Object envval, int overwrite) {
		return -1;
	}
	public static int unsetenv(Object envname) {
		return -1;
	}
	public static Object timegm() {
		time_t ret = new time_t();
		byte tz;
		tz = /*Error: Function owner not recognized*/getenv("TZ");
		ModernizedCProgram.setenv("TZ", "UTC", 1);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/tzset();
		ret = /*Error: Function owner not recognized*/mktime(tm);
		if (tz) {
			ModernizedCProgram.setenv("TZ", tz, 1);
		} else {
				ModernizedCProgram.unsetenv("TZ");
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/tzset();
		return ret;
	}
	public static tm gmtime_r(Object timer) {
		tm tmp = /*Error: Function owner not recognized*/gmtime(timer);
		if (tmp) {
			result = tmp;
			return result;
		} 
		return tmp;
	}
	/*!
	   Change trailing blanks in str to nulls.  Str has a maximum size of
	   n characters.
	*/
	public static Byte strip_trail(Object str, Object n) {
		byte[] buf = new byte[1025];
		int j;
		((n < 1024) ? (Object)0 : /*Error: Function owner not recognized*/_assert("n < 1024", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 142));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(buf, str, n);
		buf[n] = (byte)'\0';
		for (j = /*Error: Function owner not recognized*/strlen(buf) - 1; j >= 0; j--) {
			if (buf[j] != (byte)' ') {
				break;
			} 
			buf[j] = (byte)'\0';
		}
		return buf;
	}
	public static Object iso9660_get_dtime(Object idr_date, Object b_localtime) {
		if (!idr_date) {
			return false/*
			     Section 9.1.5 of ECMA 119 says:
			     If all seven numbers are zero, it shall mean that the date and
			     time are not specified.
			
			     HACK: However we've seen it happen that everything except gmtoff
			     is zero and the expected date is the beginning of the epoch. So
			     we accept 6 numbers being zero. I'm also not sure if using the
			     beginning of the Epoch is also the right thing to do either.
			  */;
		} 
		if (0 == idr_date.getDt_year() && 0 == idr_date.getDt_month() && 0 == idr_date.getDt_day() && 0 == idr_date.getDt_hour() && 0 == idr_date.getDt_minute() && 0 == idr_date.getDt_second()) {
			time_t t = 0;
			tm temp_tm = new tm();
			temp_tm.localtime_r(t);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_tm, temp_tm, /*Error: Unsupported expression*/);
			return true;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(p_tm, 0, /*Error: Unsupported expression*/);
		this.setTm_year(idr_date.getDt_year());
		this.setTm_mon(idr_date.getDt_month() - 1);
		this.setTm_mday(idr_date.getDt_day());
		this.setTm_hour(idr_date.getDt_hour());
		this.setTm_min(idr_date.getDt_minute());
		this.setTm_sec(idr_date.getDt_second() - idr_date.getDt_gmtoff() * (15 * 60));
		this.setTm_isdst(-/* information not available */1/* Initialize everything */);
		{ 
			time_t t = /* Recompute tm_wday and tm_yday via mktime. mktime will also renormalize
			     date values to account for the timezone offset. */0;
			tm temp_tm = new tm();
			t = p_tm.timegm();
			if (b_localtime) {
				temp_tm.localtime_r(t);
			} else {
					temp_tm.gmtime_r(t);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_tm, temp_tm, /*Error: Unsupported expression*/);
		}
		return true/*
		   A note regarding the strange strtol() testing below as pointed out SMS.
		   From man strtol:
		
		     If an underflow occurs, strtol() returns LONG_MIN. If an overflow
		     occurs, strtol() returns LONG_MAX.  In both cases, errno is set to
		     ERANGE.
		
		   This implies that one should only look at errno if the value is
		   LONG_MIN or LONG_MAX.
		*/;
	}
	/*!
	  Get "long" time in format used in ISO 9660 primary volume descriptor
	  from a Unix time structure.
	*/
	public static Object iso9660_get_ltime(Object p_ldate) {
		if (!p_tm) {
			return false;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(p_tm, 0, /*Error: Unsupported expression*/);
		{ 
			byte[] num = new byte[10];
			long tmp;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(num, p_ldate.getLt_year(), /*Error: sizeof expression not supported yet*/);
			num[/*Error: sizeof expression not supported yet*/] = (byte)'\0';
			errno = 0;
			tmp = /*Error: Function owner not recognized*/strtol(num, (byte)((Object)0), 10);
			if (tmp < INT_MIN || tmp > INT_MAX || ((long)tmp + -1900) > INT_MAX || (tmp + -1900) < INT_MIN) {
				return false;
			} 
			this.setTm_year(tmp + -1900);
		}
		;
		{ 
			byte[] num = new byte[10];
			long tmp;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(num, p_ldate.getLt_month(), /*Error: sizeof expression not supported yet*/);
			num[/*Error: sizeof expression not supported yet*/] = (byte)'\0';
			errno = 0;
			tmp = /*Error: Function owner not recognized*/strtol(num, (byte)((Object)0), 10);
			if (tmp < INT_MIN || tmp > INT_MAX || ((long)tmp + -1) > INT_MAX || (tmp + -1) < INT_MIN) {
				return false;
			} 
			this.setTm_mon(tmp + -1);
		}
		;
		{ 
			byte[] num = new byte[10];
			long tmp;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(num, p_ldate.getLt_day(), /*Error: sizeof expression not supported yet*/);
			num[/*Error: sizeof expression not supported yet*/] = (byte)'\0';
			errno = 0;
			tmp = /*Error: Function owner not recognized*/strtol(num, (byte)((Object)0), 10);
			if (tmp < INT_MIN || tmp > INT_MAX || ((long)tmp + 0) > INT_MAX || (tmp + 0) < INT_MIN) {
				return false;
			} 
			this.setTm_mday(tmp + 0);
		}
		;
		{ 
			byte[] num = new byte[10];
			long tmp;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(num, p_ldate.getLt_hour(), /*Error: sizeof expression not supported yet*/);
			num[/*Error: sizeof expression not supported yet*/] = (byte)'\0';
			errno = 0;
			tmp = /*Error: Function owner not recognized*/strtol(num, (byte)((Object)0), 10);
			if (tmp < INT_MIN || tmp > INT_MAX || ((long)tmp + 0) > INT_MAX || (tmp + 0) < INT_MIN) {
				return false;
			} 
			this.setTm_hour(tmp + 0);
		}
		;
		{ 
			byte[] num = new byte[10];
			long tmp;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(num, p_ldate.getLt_minute(), /*Error: sizeof expression not supported yet*/);
			num[/*Error: sizeof expression not supported yet*/] = (byte)'\0';
			errno = 0;
			tmp = /*Error: Function owner not recognized*/strtol(num, (byte)((Object)0), 10);
			if (tmp < INT_MIN || tmp > INT_MAX || ((long)tmp + 0) > INT_MAX || (tmp + 0) < INT_MIN) {
				return false;
			} 
			this.setTm_min(tmp + 0);
		}
		;
		{ 
			byte[] num = new byte[10];
			long tmp;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(num, p_ldate.getLt_second(), /*Error: sizeof expression not supported yet*/);
			num[/*Error: sizeof expression not supported yet*/] = (byte)'\0';
			errno = 0;
			tmp = /*Error: Function owner not recognized*/strtol(num, (byte)((Object)0), 10);
			if (tmp < INT_MIN || tmp > INT_MAX || ((long)tmp + 0) > INT_MAX || (tmp + 0) < INT_MIN) {
				return false;
			} 
			this.setTm_sec(tmp + 0);
		}
		;
		this.setTm_isdst(-/* information not available */1);
		Object generatedTm_sec = this.getTm_sec();
		generatedTm_sec += p_ldate.getLt_gmtoff() * (15 * 60/* Initialize everything */);
		{ 
			time_t t = new time_t();
			tm temp_tm = new tm();
			t = /*Error: Function owner not recognized*/mktime(p_tm);
			temp_tm.localtime_r(t);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_tm, temp_tm, /*Error: Unsupported expression*/);
		}
		this.setTm_isdst(-/* information not available */1);
		return true/*!
		  Set time in format used in ISO 9660 directory index record
		  from a Unix time structure. timezone is given as an offset
		  correction in minutes.
		*/;
	}
	public static void iso9660_set_dtime_with_timezone(Object p_tm, int time_zone, Object p_idr_date) {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(p_idr_date, 0, /*out*/7);
		if (!p_tm) {
			return /*Error: Unsupported expression*/;
		} 
		p_idr_date.setDt_year(p_tm.getTm_year());
		p_idr_date.setDt_month(p_tm.getTm_mon() + 1);
		p_idr_date.setDt_day(p_tm.getTm_mday());
		p_idr_date.setDt_hour(p_tm.getTm_hour());
		p_idr_date.setDt_minute(p_tm.getTm_min());
		p_idr_date.setDt_second(p_tm.getTm_sec());
		p_idr_date.setDt_gmtoff(time_zone / /* The ISO 9660 timezone is in the range -48..+52 and each unit
		     represents a 15-minute interval. */15);
		if (p_idr_date.getDt_gmtoff() < -48) {
			ModernizedCProgram.cdio_warn("Converted ISO 9660 timezone %d is less than -48. Adjusted", p_idr_date.getDt_gmtoff());
			p_idr_date.setDt_gmtoff(-48);
		}  else if (p_idr_date.getDt_gmtoff() > 52) {
			ModernizedCProgram.cdio_warn("Converted ISO 9660 timezone %d is over 52. Adjusted", p_idr_date.getDt_gmtoff());
			p_idr_date.setDt_gmtoff(52/*!
			  Set time in format used in ISO 9660 directory index record
			  from a Unix time structure. */);
		} 
	}
	/*out*/
	public static void iso9660_set_dtime(Object p_tm, Object p_idr_date) {
		int time_zone = 0;
		if (p_tm/* Convert seconds to minutes */) {
			time_zone = (p_tm.getTm_isdst() > 0) ? -60 : 0;
		} 
		ModernizedCProgram.iso9660_set_dtime_with_timezone(p_tm, time_zone, p_idr_date/*!
		  Set "long" time in format used in ISO 9660 primary volume descriptor
		  from a Unix time structure. timezone is given as an offset
		  correction in minutes.
		*/);
	}
	public static void iso9660_set_ltime_with_timezone(Object p_tm, int time_zone, Object pvd_date) {
		byte _pvd_date = (byte)/*out*/pvd_date;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(_pvd_date, (int)(byte)'0', 16);
		pvd_date.setLt_gmtoff(()/* Start out with time zone GMT. */0);
		if (!p_tm) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(_pvd_date, 17, "%4.4d%2.2d%2.2d%2.2d%2.2d%2.2d%2.2d", p_tm.getTm_year() + 1900, p_tm.getTm_mon() + 1, p_tm.getTm_mday(), p_tm.getTm_hour(), p_tm.getTm_min(), p_tm.getTm_sec(), /* 1/100 secs */0);
		pvd_date.getLt_gmtoff() -= (time_zone / /* Set time zone in 15-minute interval encoding. */15);
		if (pvd_date.getLt_gmtoff() < -48) {
			ModernizedCProgram.cdio_warn("Converted ISO 9660 timezone %d is less than -48. Adjusted", (int)pvd_date.getLt_gmtoff());
			pvd_date.setLt_gmtoff(-48);
		}  else if (pvd_date.getLt_gmtoff() > 52) {
			ModernizedCProgram.cdio_warn("Converted ISO 9660 timezone %d is over 52. Adjusted", (int)pvd_date.getLt_gmtoff());
			pvd_date.setLt_gmtoff(52/*!
			  Set "long" time in format used in ISO 9660 primary volume descriptor
			  from a Unix time structure. */);
		} 
	}
	/*out*/
	public static void iso9660_set_ltime(Object p_tm, Object pvd_date) {
		int time_zone = 0;
		if (p_tm/* Set time zone in 15-minute interval encoding. */) {
			time_zone = (p_tm.getTm_isdst() > 0) ? -60 : 0;
		} 
		ModernizedCProgram.iso9660_set_ltime_with_timezone(p_tm, time_zone, pvd_date/*!
		   Convert an ISO-9660 file name which is in the format usually stored
		   in a ISO 9660 directory entry into what's usually listed as the
		   file name in a listing.  Lowercase name, and remove trailing ;1's
		   or .;1's and turn the other ;'s into version numbers.
		
		   @param psz_oldname the ISO-9660 filename to be translated.
		   @param psz_newname returned string. The caller allocates this and
		   it should be at least the size of psz_oldname.
		   @return length of the translated string is returned. It will be no greater
		   than the length of psz_oldname.
		*/);
	}
	public static int iso9660_name_translate(Object psz_oldname, Byte psz_newname) {
		return ModernizedCProgram.iso9660_name_translate_ext(psz_oldname, psz_newname, 0/*!
		   Convert an ISO-9660 file name which is in the format usually stored
		   in a ISO 9660 directory entry into what's usually listed as the
		   file name in a listing.  Lowercase name if no Joliet Extension
		   interpretation. Remove trailing ;1's or .;1's and turn the other
		   ;'s into version numbers.
		
		   @param psz_oldname the ISO-9660 filename to be translated.
		   @param psz_newname returned string. The caller allocates this and
		   it should be at least the size of psz_oldname.
		   @param u_joliet_level 0 if not using Joliet Extension. Otherwise the
		   Joliet level.
		   @return length of the translated string is returned. It will be no greater
		   than the length of psz_oldname.
		*/);
	}
	public static int iso9660_name_translate_ext(Object[] psz_oldname, byte[] psz_newname, Object u_joliet_level) {
		int len = /*Error: Function owner not recognized*/strlen(psz_oldname);
		int i;
		if (0 == len) {
			return 0;
		} 
		for (i = 0; i < len; i++) {
			byte c = psz_oldname[i];
			if (!c) {
				break;
			} 
			if (!u_joliet_level && /*Error: Function owner not recognized*/isupper(c)) {
				c = /*Error: Function owner not recognized*/tolower(/* Lower case, unless we have Joliet extensions.  */c);
			} 
			if (c == (byte)'.' && i == len - /* Drop trailing '.;1' (ISO 9660:1988 7.5.1 requires period) */3 && psz_oldname[i + 1] == (byte)';' && psz_oldname[i + 2] == (byte)'1') {
				break;
			} 
			if (c == (byte)';' && i == len - 2 && psz_oldname[i + 1] == /* Drop trailing ';1' */(byte)'1') {
				break;
			} 
			if (c == /* Convert remaining ';' to '.' */(byte)';') {
				c = (byte)'.';
			} 
			psz_newname[i] = c;
		}
		psz_newname[i] = (byte)'\0';
		return i/*!
		  Pad string src with spaces to size len and copy this to dst. If
		  len is less than the length of src, dst will be truncated to the
		  first len characters of src.
		
		  src can also be scanned to see if it contains only ACHARs, DCHARs,
		  7-bit ASCII chars depending on the enumeration _check.
		
		  In addition to getting changed, dst is the return value.
		  Note: this string might not be NULL terminated.
		 */;
	}
	public static Byte iso9660_strncpy_pad(Byte dst, Object[] src, Object len, Object _check) {
		size_t rlen = new size_t();
		((dst != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("dst != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 499));
		((src != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("src != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 500));
		((len > 0) ? (Object)0 : /*Error: Function owner not recognized*/_assert("len > 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 501));
		switch (_check) {
		case ISO9660_DCHARS:
				for (idx = 0; src[idx]; idx++) {
					if (!ModernizedCProgram.iso9660_is_dchar(src[idx])) {
						ModernizedCProgram.cdio_warn("string '%s' fails d-character constraint (pos = %d)", src, idx);
						break;
					} 
				}
				break;
		case ISO9660_NOCHECK:
				break;
		case ISO9660_7BIT:
				for (idx = 0; src[idx]; idx++) {
					if (()src[idx] < 0) {
						ModernizedCProgram.cdio_warn("string '%s' fails 7bit constraint (pos = %d)", src, idx);
						break;
					} 
				}
				break;
		case ISO9660_ACHARS:
				for (idx = 0; src[idx]; idx++) {
					if (!ModernizedCProgram.iso9660_is_achar(src[idx])) {
						ModernizedCProgram.cdio_warn("string '%s' fails a-character constraint (pos = %d)", src, idx);
						break;
					} 
				}
				break;
		default:
				((false) ? (Object)0 : /*Error: Function owner not recognized*/_assert("0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 540));
				break;
		}
		rlen = /*Error: Function owner not recognized*/strlen(src);
		if (rlen > len) {
			ModernizedCProgram.cdio_warn("string '%s' is getting truncated to %d characters", src, (int)len);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(dst, src, len);
		if (rlen < len) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(dst + rlen, (byte)' ', len - rlen);
		} 
		return dst/*!
		   Return true if c is a DCHAR - a valid ISO-9660 level 1 character.
		   These are the ASCSII capital letters A-Z, the digits 0-9 and an
		   underscore.
		*/;
	}
	public static Object iso9660_is_dchar(int c) {
		if (!/*Error: Function owner not recognized*/IN(c, -1024, -1024) || /*Error: Function owner not recognized*/IN(c, -1024, -1024) || /*Error: Function owner not recognized*/IN(c, -1024, -1024)) {
			return false;
		} 
		return true/*!
		   Return true if c is an ACHAR -
		   These are the DCHAR's plus some ASCII symbols including the space
		   symbol.
		*/;
	}
	public static Object iso9660_is_achar(int c) {
		if (!/*Error: Function owner not recognized*/IN(c, -1024, -1024) || /*Error: Function owner not recognized*/IN(c, -1024, -1024) || c == -1024 || /*Error: Function owner not recognized*/IN(c, -1024, -1024)) {
			return false;
		} 
		return true;
	}
	public static void iso9660_set_evd(Object pd) {
		 ied = new ();
		((/*Error: Unsupported expression*/ == ISO_BLOCKSIZE) ? (Object)0 : /*Error: Function owner not recognized*/_assert("sizeof(iso_volume_descriptor_t) == ISO_BLOCKSIZE", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 595));
		((pd != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("pd != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 597));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ied, 0, /*Error: sizeof expression not supported yet*/);
		ied.setType(/*Error: Function owner not recognized*/to_711(ISO_VD_END));
		ModernizedCProgram.iso9660_strncpy_pad(ied.getId(), ModernizedCProgram.ISO_STANDARD_ID, /*Error: sizeof expression not supported yet*/, ISO9660_DCHARS);
		ied.setVersion(/*Error: Function owner not recognized*/to_711(1));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(pd, ied, /*Error: sizeof expression not supported yet*/);
	}
	public static void iso9660_set_pvd(Object pd, Object volume_id, Object publisher_id, Object preparer_id, Object application_id, Object iso_size, Object root_dir, Object path_table_l_extent, Object path_table_m_extent, Object path_table_size, Object pvd_time) {
		 ipd = new ();
		tm temp_tm = new tm();
		((/*Error: Unsupported expression*/ == ISO_BLOCKSIZE) ? (Object)0 : /*Error: Function owner not recognized*/_assert("sizeof(iso9660_pvd_t) == ISO_BLOCKSIZE", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 626));
		((pd != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("pd != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 628));
		((volume_id != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("volume_id != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 629));
		((application_id != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("application_id != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 630));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ipd, 0, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(((byte)ipd) + ISO_XA_MARKER_OFFSET, ModernizedCProgram.ISO_XA_MARKER_STRING, /* magic stuff ... thatis CD XA marker... */8);
		ipd.setType(/*Error: Function owner not recognized*/to_711(ISO_VD_PRIMARY));
		ModernizedCProgram.iso9660_strncpy_pad(ipd.getId(), ModernizedCProgram.ISO_STANDARD_ID, 5, ISO9660_DCHARS);
		ipd.setVersion(/*Error: Function owner not recognized*/to_711(1));
		ModernizedCProgram.iso9660_strncpy_pad(ipd.getSystem_id(), "CD-RTOS CD-BRIDGE", 32, ISO9660_ACHARS);
		ModernizedCProgram.iso9660_strncpy_pad(ipd.getVolume_id(), volume_id, 32, ISO9660_DCHARS);
		ipd.setVolume_space_size(ModernizedCProgram.to_733(iso_size));
		ipd.setVolume_set_size(ModernizedCProgram.to_723(1));
		ipd.setVolume_sequence_number(ModernizedCProgram.to_723(1));
		ipd.setLogical_block_size(ModernizedCProgram.to_723(ISO_BLOCKSIZE));
		ipd.setPath_table_size(ModernizedCProgram.to_733(path_table_size));
		ipd.setType_l_path_table(/*Error: Function owner not recognized*/to_731(path_table_l_extent));
		ipd.setType_m_path_table(/*Error: Function owner not recognized*/to_732(path_table_m_extent));
		((/*Error: sizeof expression not supported yet*/ == 33) ? (Object)0 : /*Error: Function owner not recognized*/_assert("sizeof(ipd.root_directory_record) == 33", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", /* root_directory_record doesn't contain the 1-byte filename,
		     so we add one for that. */656));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((ipd.getRoot_directory_record()), root_dir, /*Error: sizeof expression not supported yet*/);
		ipd.setRoot_directory_filename((byte)'\0');
		ipd.getRoot_directory_record().setLength(/*Error: sizeof expression not supported yet*/ + 1);
		ModernizedCProgram.iso9660_strncpy_pad(ipd.getVolume_set_id(), "", ISO_MAX_VOLUMESET_ID, ISO9660_DCHARS);
		ModernizedCProgram.iso9660_strncpy_pad(ipd.getPublisher_id(), publisher_id, ISO_MAX_PUBLISHER_ID, ISO9660_ACHARS);
		ModernizedCProgram.iso9660_strncpy_pad(ipd.getPreparer_id(), preparer_id, ISO_MAX_PREPARER_ID, ISO9660_ACHARS);
		ModernizedCProgram.iso9660_strncpy_pad(ipd.getApplication_id(), application_id, ISO_MAX_APPLICATION_ID, ISO9660_ACHARS);
		ModernizedCProgram.iso9660_strncpy_pad(ipd.getCopyright_file_id(), "", 37, ISO9660_DCHARS);
		ModernizedCProgram.iso9660_strncpy_pad(ipd.getAbstract_file_id(), "", 37, ISO9660_DCHARS);
		ModernizedCProgram.iso9660_strncpy_pad(ipd.getBibliographic_file_id(), "", 37, ISO9660_DCHARS);
		temp_tm.gmtime_r(pvd_time);
		ModernizedCProgram.iso9660_set_ltime(temp_tm, (ipd.getCreation_date()));
		temp_tm.gmtime_r(pvd_time);
		ModernizedCProgram.iso9660_set_ltime(temp_tm, (ipd.getModification_date()));
		ModernizedCProgram.iso9660_set_ltime(((Object)0), (ipd.getExpiration_date()));
		ModernizedCProgram.iso9660_set_ltime(((Object)0), (ipd.getEffective_date()));
		ipd.setFile_structure_version(/*Error: Function owner not recognized*/to_711(1));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(pd, ipd, /*Error: sizeof expression not supported yet*/);
	}
	public static int iso9660_dir_calc_record_size(int namelen, int su_len) {
		int length;
		length = /*Error: Unsupported expression*/;
		length += namelen;
		if (length % /* pad to word boundary */2) {
			length++;
		} 
		length += su_len;
		if (length % /* pad to word boundary again */2) {
			length++;
		} 
		return length;
	}
	public static void iso9660_dir_add_entry_su(Object dir, Object filename, Object extent, Object size, Object file_flags, Object su_data, int su_size, Object entry_time) {
		 idr = dir;
		 dir8 = dir;
		int offset = 0;
		 dsize = ModernizedCProgram.from_733(idr.getSize());
		int length;
		int su_offset;
		tm temp_tm = new tm();
		((/*Error: Unsupported expression*/ == 33) ? (Object)0 : /*Error: Function owner not recognized*/_assert("sizeof(iso9660_dir_t) == 33", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 721));
		if (!dsize && !idr.getLength()) {
			dsize = /* for when dir lacks '.' entry */ISO_BLOCKSIZE;
		} 
		((dsize > 0 && !(dsize % ISO_BLOCKSIZE)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("dsize > 0 && !(dsize % ISO_BLOCKSIZE)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 726));
		((dir != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("dir != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 727));
		((extent > 17) ? (Object)0 : /*Error: Function owner not recognized*/_assert("extent > 17", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 728));
		((filename != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("filename != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 729));
		((/*Error: Function owner not recognized*/strlen(filename) <= MAX_ISOPATHNAME) ? (Object)0 : /*Error: Function owner not recognized*/_assert("strlen(filename) <= MAX_ISOPATHNAME", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 730));
		length = /*Error: Unsupported expression*/;
		length += /*Error: Function owner not recognized*/strlen(filename);
		length = ModernizedCProgram._cdio_ceil2block(length, /* pad to word boundary */2);
		su_offset = length;
		length += su_size;
		length = ModernizedCProgram._cdio_ceil2block(length, /* pad to word boundary again */2);
		{ 
			int ofs_last_rec = /* find the last entry's end */0;
			offset = 0;
			while (offset < dsize) {
				if (!dir8[offset]) {
					offset++;
					continue;
				} 
				offset += dir8[offset];
				ofs_last_rec = offset;
			}
			((offset == dsize) ? (Object)0 : /*Error: Function owner not recognized*/_assert("offset == dsize", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 756));
			offset = ofs_last_rec;
		}
		offset = ModernizedCProgram._cdio_ofs_add(offset, length, /* be sure we don't cross sectors boundaries */ISO_BLOCKSIZE);
		offset -= length;
		((offset + length <= dsize) ? (Object)0 : /*Error: Function owner not recognized*/_assert("offset + length <= dsize", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 765));
		idr = ()dir8[offset];
		((offset + length < dsize) ? (Object)0 : /*Error: Function owner not recognized*/_assert("offset+length < dsize", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 769));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(idr, 0, length);
		idr.setLength(/*Error: Function owner not recognized*/to_711(length));
		idr.setExtent(ModernizedCProgram.to_733(extent));
		idr.setSize(ModernizedCProgram.to_733(size));
		temp_tm.gmtime_r(entry_time);
		ModernizedCProgram.iso9660_set_dtime(temp_tm, (idr.getRecording_time()));
		idr.setFile_flags(/*Error: Function owner not recognized*/to_711(file_flags));
		idr.setVolume_sequence_number(ModernizedCProgram.to_723(1));
		idr.getFilename().setLen(/*Error: Function owner not recognized*/to_711(/*Error: Function owner not recognized*/strlen(filename) ? /*Error: Function owner not recognized*/strlen(filename) : /* working hack! */1));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(idr.getFilename().getStr()[1], filename, /*Error: Function owner not recognized*/from_711(idr.getFilename().getLen()));
		if (su_size > 0 && su_data) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(dir8[offset] + su_offset, su_data, su_size);
		} 
	}
	public static void iso9660_dir_init_new(Object dir, Object self, Object ssize, Object parent, Object psize, Object dir_time) {
		ModernizedCProgram.iso9660_dir_init_new_su(dir, self, ssize, ((Object)0), 0, parent, psize, ((Object)0), 0, dir_time);
	}
	public static void iso9660_dir_init_new_su(Object dir, Object self, Object ssize, Object ssu_data, int ssu_size, Object parent, Object psize, Object psu_data, int psu_size, Object dir_time) {
		((ssize > 0 && !(ssize % ISO_BLOCKSIZE)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("ssize > 0 && !(ssize % ISO_BLOCKSIZE)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 816));
		((psize > 0 && !(psize % ISO_BLOCKSIZE)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("psize > 0 && !(psize % ISO_BLOCKSIZE)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 817));
		((dir != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("dir != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 818));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(dir, 0, ssize);
		ModernizedCProgram.iso9660_dir_add_entry_su(dir, "\0", self, ssize, ISO_DIRECTORY, /* "\0" -- working hack due to padding  */ssu_data, ssu_size, dir_time);
		ModernizedCProgram.iso9660_dir_add_entry_su(dir, "\1", parent, psize, ISO_DIRECTORY, psu_data, psu_size, dir_time);
	}
	/* Zero's out pathable. Do this first.  */
	public static void iso9660_pathtable_init(Object pt) {
		((/*Error: Unsupported expression*/ == 8) ? (Object)0 : /*Error: Function owner not recognized*/_assert("sizeof (iso_path_table_t) == 8", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 834));
		((pt != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("pt != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 836));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(pt, 0, /* fixme */ISO_BLOCKSIZE/*!
		  Returns POSIX mode bitstring for a given file.
		*/);
	}
	public static Object iso9660_get_posix_filemode(Object p_iso_dirent) {
		 mode = 0;
		if (p_iso_dirent.getB_xa()) {
			return ModernizedCProgram.iso9660_get_posix_filemode_from_xa(p_iso_dirent.getXa().getAttributes());
		} 
		return mode;
	}
	public static Object pathtable_get_entry(Object pt, int entrynum) {
		 tmp = pt;
		int offset = 0;
		int count = 0;
		((pt != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("pt != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 867));
		while (/*Error: Function owner not recognized*/from_711(tmp)) {
			if (count == entrynum) {
				break;
			} 
			((count < entrynum) ? (Object)0 : /*Error: Function owner not recognized*/_assert("count < entrynum", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 874));
			offset += /*Error: Unsupported expression*/;
			offset += /*Error: Function owner not recognized*/from_711(tmp);
			if (offset % 2) {
				offset++;
			} 
			tmp = ()pt + offset;
			count++;
		}
		if (!/*Error: Function owner not recognized*/from_711(tmp)) {
			return ((Object)0);
		} 
		return (Object)tmp;
	}
	public static void pathtable_get_size_and_entries(Object pt, Integer size, Integer entries) {
		 tmp = pt;
		int offset = 0;
		int count = 0;
		((pt != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("pt != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 899));
		while (/*Error: Function owner not recognized*/from_711(tmp)) {
			offset += /*Error: Unsupported expression*/;
			offset += /*Error: Function owner not recognized*/from_711(tmp);
			if (offset % 2) {
				offset++;
			} 
			tmp = ()pt + offset;
			count++;
		}
		if (size) {
			size = offset;
		} 
		if (entries) {
			entries = count;
		} 
	}
	/*!
	  Get time structure from structure in an ISO 9660 directory index
	  record. Even though tm_wday and tm_yday fields are not explicitly in
	  idr_date, the are calculated from the other fields.
	
	  If tm is to reflect the localtime set b_localtime true, otherwise
	  tm will reported in GMT.
	*/
	public static int iso9660_pathtable_get_size(Object pt) {
		int size = 0;
		ModernizedCProgram.pathtable_get_size_and_entries(pt, size, ((Object)0));
		return size;
	}
	public static Object iso9660_pathtable_l_add_entry(Object pt, Object name, Object extent, Object parent) {
		 ipt = ()((byte)pt + ModernizedCProgram.iso9660_pathtable_get_size(pt));
		size_t name_len = /*Error: Function owner not recognized*/strlen(name) ? /*Error: Function owner not recognized*/strlen(name) : 1;
		int entrynum = 0;
		((ModernizedCProgram.iso9660_pathtable_get_size(pt) < ISO_BLOCKSIZE) ? (Object)0 : /*Error: Function owner not recognized*/_assert("iso9660_pathtable_get_size (pt) < ISO_BLOCKSIZE", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", /*fixme */937));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ipt, 0, /*Error: Unsupported expression*/ + /* paranoia */name_len);
		ipt.setName_len(/*Error: Function owner not recognized*/to_711(name_len));
		ipt.setExtent(/*Error: Function owner not recognized*/to_731(extent));
		ipt.setParent(/*Error: Function owner not recognized*/to_721(parent));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ipt.getName(), name, name_len);
		ModernizedCProgram.pathtable_get_size_and_entries(pt, ((Object)0), entrynum);
		if (entrynum > 1) {
			 ipt2 = ModernizedCProgram.pathtable_get_entry(pt, entrynum - 2);
			((ipt2 != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("ipt2 != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 953));
			((/*Error: Function owner not recognized*/from_721(ipt2.getParent()) <= parent) ? (Object)0 : /*Error: Function owner not recognized*/_assert("from_721 (ipt2->parent) <= parent", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 955));
		} 
		return entrynum;
	}
	public static Object iso9660_pathtable_m_add_entry(Object pt, Object name, Object extent, Object parent) {
		 ipt = ()((byte)pt + ModernizedCProgram.iso9660_pathtable_get_size(pt));
		size_t name_len = /*Error: Function owner not recognized*/strlen(name) ? /*Error: Function owner not recognized*/strlen(name) : 1;
		int entrynum = 0;
		((ModernizedCProgram.iso9660_pathtable_get_size(pt) < ISO_BLOCKSIZE) ? (Object)0 : /*Error: Function owner not recognized*/_assert("iso9660_pathtable_get_size(pt) < ISO_BLOCKSIZE", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", /* fixme */972));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ipt, 0, /*Error: Unsupported expression*/ + /* paranoia */name_len);
		ipt.setName_len(/*Error: Function owner not recognized*/to_711(name_len));
		ipt.setExtent(/*Error: Function owner not recognized*/to_732(extent));
		ipt.setParent(/*Error: Function owner not recognized*/to_722(parent));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ipt.getName(), name, name_len);
		ModernizedCProgram.pathtable_get_size_and_entries(pt, ((Object)0), entrynum);
		if (entrynum > 1) {
			 ipt2 = ModernizedCProgram.pathtable_get_entry(pt, entrynum - 2);
			((ipt2 != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("ipt2 != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 988));
			((/*Error: Function owner not recognized*/from_722(ipt2.getParent()) <= parent) ? (Object)0 : /*Error: Function owner not recognized*/_assert("from_722 (ipt2->parent) <= parent", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 990));
		} 
		return entrynum/*!
		  Check that pathname is a valid ISO-9660 directory name.
		
		  A valid directory name should not start out with a slash (/),
		  dot (.) or null byte, should be less than 37 characters long,
		  have no more than 8 characters in a directory component
		  which is separated by a /, and consist of only DCHARs.
		 */;
	}
	public static Object iso9660_dirname_valid_p(Object pathname) {
		byte p = pathname;
		int len;
		((pathname != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("pathname != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 1010));
		if (p == (byte)'/' || p == (byte)'.' || p == (byte)'\0') {
			return false;
		} 
		if (/*Error: Function owner not recognized*/strlen(pathname) > MAX_ISOPATHNAME) {
			return false;
		} 
		len = 0;
		for (; p; p++) {
			if (ModernizedCProgram.iso9660_is_dchar(p)) {
				len++;
				if (len > 8) {
					return false;
				} 
			}  else if (p == (byte)'/') {
				if (!len) {
					return false;
				} 
				len = 0;
			} else {
					return /* unexpected char */false;
			} 
		}
		if (!len) {
			return /* last char may not be '/' */false;
		} 
		return true/*!
		  Check that pathname is a valid ISO-9660 pathname.
		
		  A valid pathname contains a valid directory name, if one appears and
		  the filename portion should be no more than 8 characters for the
		  file prefix and 3 characters in the extension (or portion after a
		  dot). There should be exactly one dot somewhere in the filename
		  portion and the filename should be composed of only DCHARs.
		
		  True is returned if pathname is valid.
		 */;
	}
	public static Object iso9660_pathname_valid_p(Object pathname) {
		byte p = ((Object)0);
		((pathname != ((Object)0)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("pathname != ((void *)0)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 1057));
		if ((p = /*Error: Function owner not recognized*/strrchr(pathname, (byte)'/'))) {
			 rc = new ();
			byte _tmp = /*Error: Function owner not recognized*/strdup(pathname);
			/*Error: Function owner not recognized*/strrchr(_tmp, (byte)'/') = (byte)'\0';
			rc = ModernizedCProgram.iso9660_dirname_valid_p(_tmp);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(_tmp);
			if (!rc) {
				return false;
			} 
			p++;
		} else {
				p = pathname;
		} 
		if (/*Error: Function owner not recognized*/strlen(pathname) > (MAX_ISOPATHNAME - 6)) {
			return false;
		} 
		{ 
			int len = 0;
			int dots = 0;
			for (; p; p++) {
				if (ModernizedCProgram.iso9660_is_dchar(p)) {
					len++;
					if (dots == 0 ? len > 8 : len > 3) {
						return false;
					} 
				}  else if (p == (byte)'.') {
					dots++;
					if (dots > 1) {
						return false;
					} 
					if (!len) {
						return false;
					} 
					len = 0;
				} else {
						return false;
				} 
			}
			if (dots != 1) {
				return false;
			} 
		}
		return true/*!
		  Take pathname and a version number and turn that into a ISO-9660
		  pathname.  (That's just the pathname followd by ";" and the version
		  number. For example, mydir/file.ext -> mydir/file.ext;1 for version
		  1. The resulting ISO-9660 pathname is returned.
		*/;
	}
	public static Byte iso9660_pathname_isofy(Object pathname, Object version) {
		byte[] tmpbuf = new byte[]{0};
		((/*Error: Function owner not recognized*/strlen(pathname) < (/*Error: sizeof expression not supported yet*/ - /*Error: sizeof expression not supported yet*/)) ? (Object)0 : /*Error: Function owner not recognized*/_assert("strlen (pathname) < (sizeof (tmpbuf) - sizeof (\";65535\"))", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\iso9660.c", 1122));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(tmpbuf, /*Error: sizeof expression not supported yet*/, "%s;%d", pathname, version);
		return /*Error: Function owner not recognized*/strdup(tmpbuf/*!
		  Return the PVD's application ID.
		  NULL is returned if there is some problem in getting this.
		*/);
	}
	public static Byte iso9660_get_application_id(Object p_pvd) {
		if (((Object)0) == p_pvd) {
			return ((Object)0);
		} 
		return /*Error: Function owner not recognized*/strdup(ModernizedCProgram.strip_trail(p_pvd.getApplication_id(), ISO_MAX_APPLICATION_ID));
	}
	public static Object iso9660_get_dir_len(Object idr) {
		if (((Object)0) == idr) {
			return 0;
		} 
		return idr.getLength();
	}
	public static Object iso9660_get_pvd_type(Object pvd) {
		if (((Object)0) == pvd) {
			return 255;
		} 
		return (pvd.getType());
	}
	public static Object iso9660_get_pvd_id(Object pvd) {
		if (((Object)0) == pvd) {
			return "ERR";
		} 
		return (pvd.getId());
	}
	public static int iso9660_get_pvd_space_size(Object pvd) {
		if (((Object)0) == pvd) {
			return 0;
		} 
		return ModernizedCProgram.from_733(pvd.getVolume_space_size());
	}
	public static int iso9660_get_pvd_block_size(Object pvd) {
		if (((Object)0) == pvd) {
			return 0;
		} 
		return ModernizedCProgram.from_723(pvd.getLogical_block_size());
	}
	public static int iso9660_get_pvd_version(Object pvd) {
		if (((Object)0) == pvd) {
			return 0;
		} 
		return pvd.getVersion();
	}
	public static Object iso9660_get_root_lsn(Object pvd) {
		if (((Object)0) == pvd) {
			return CDIO_INVALID_LSN;
		} else {
				 idr = (pvd.getRoot_directory_record());
				if (((Object)0) == idr) {
					return CDIO_INVALID_LSN;
				} 
				return (ModernizedCProgram.from_733(idr.getExtent()));
		} 
	}
	public static Byte iso9660_get_preparer_id(Object pvd) {
		if (((Object)0) == pvd) {
			return ((Object)0);
		} 
		return /*Error: Function owner not recognized*/strdup(ModernizedCProgram.strip_trail(pvd.getPreparer_id(), ISO_MAX_PREPARER_ID/*!
		   Return a string containing the publisher id with trailing
		   blanks removed.
		*/));
	}
	public static Byte iso9660_get_publisher_id(Object pvd) {
		if (((Object)0) == pvd) {
			return ((Object)0);
		} 
		return /*Error: Function owner not recognized*/strdup(ModernizedCProgram.strip_trail(pvd.getPublisher_id(), ISO_MAX_PUBLISHER_ID/*!
		   Return a string containing the PVD's system id with trailing
		   blanks removed.
		*/));
	}
	public static Byte iso9660_get_system_id(Object pvd) {
		if (((Object)0) == pvd) {
			return ((Object)0);
		} 
		return /*Error: Function owner not recognized*/strdup(ModernizedCProgram.strip_trail(pvd.getSystem_id(), ISO_MAX_SYSTEM_ID/*!
		  Return the PVD's volume ID.
		*/));
	}
	public static Byte iso9660_get_volume_id(Object pvd) {
		if (((Object)0) == pvd) {
			return ((Object)0);
		} 
		return /*Error: Function owner not recognized*/strdup(ModernizedCProgram.strip_trail(pvd.getVolume_id(), ISO_MAX_VOLUME_ID/*!
		  Return the PVD's volumeset ID.
		  NULL is returned if there is some problem in getting this.
		*/));
	}
	public static Byte iso9660_get_volumeset_id(Object pvd) {
		if (((Object)0) == pvd) {
			return ((Object)0);
		} 
		return /*Error: Function owner not recognized*/strdup(ModernizedCProgram.strip_trail(pvd.getVolume_set_id(), ISO_MAX_VOLUMESET_ID/*
		 * Local variables:
		 *  c-file-style: "gnu"
		 *  tab-width: 8
		 *  indent-tabs-mode: nil
		 * End:
		 */));
	}
	/*
	* Rufus: The Reliable USB Formatting Utility
	* Constants and defines missing from various toolchains
	* Copyright Â© 2016-2017 Pete Batard <pete@akeo.ie>
	*
	* This program is free software: you can redistribute it and/or modify
	* it under the terms of the GNU General Public License as published by
	* the Free Software Foundation, either version 3 of the License, or
	* (at your option) any later version.
	*
	* This program is distributed in the hope that it will be useful,
	* but WITHOUT ANY WARRANTY; without even the implied warranty of
	* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	* GNU General Public License for more details.
	*
	* You should have received a copy of the GNU General Public License
	* along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/
	/* Convenient to have around */
	/*
	 * Prefetch 64 bytes at address m, for read-only operation
	 * We account for these built-in calls doing nothing if the
	 * line has already been fetched, or if the address is invalid.
	 */
	// _m_prefetch() doesn't seem to exist for MSVC/ARM
	/* Read/write with endianness swap */
	/*
	 * Nibbled from https://github.com/hanji/popcnt/blob/master/populationcount.cpp
	 * Since MSVC x86_32 does not have intrinsic popcount64 and I don't have all day
	 */
	public static int popcnt64(Object u) {
		u = (u & -1024) + ((u >> 1) & -1024);
		u = (u & -1024) + ((u >> 2) & -1024);
		u = (u & -1024) + ((u >> 4) & -1024);
		u = (u & -1024) + ((u >> 8) & -1024);
		u = (u & -1024) + ((u >> 16) & -1024);
		u = (u & -1024) + ((u >> 32) & -1024);
		return (int)u;
	}
	public static Object _reallocf(Object ptr, Object size) {
		Object ret = /*Error: Function owner not recognized*/realloc(ptr, size);
		if (!ret) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(ptr);
		} 
		return ret/* Why oh why does Microsoft have to make everybody suffer with their braindead use of Unicode? */;
	}
	/* MinGW doesn't know these */
	/* The following is used for native ISO mounting in Windows 8 or later */
	/*
	 * get_num_dirs.c -- calculate number of directories
	 *
	 * Copyright 1997 by Theodore Ts'o
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/*
	 * Returns the number of directories in the filesystem as reported by
	 * the group descriptors.  Of course, the group descriptors could be
	 * wrong!
	 */
	public static Object ext2fs_get_num_dirs(Object fs, Object ret_num_dirs) {
		 i = new ();
		 num_dirs = new ();
		 max_dirs = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		num_dirs = 0;
		max_dirs = fs.getSuper().getS_inodes_per_group();
		for (i = 0; i < fs.getGroup_desc_count(); i++) {
			if (ModernizedCProgram.ext2fs_bg_used_dirs_count(fs, i) > max_dirs) {
				num_dirs += max_dirs / 8;
			} else {
					num_dirs += ModernizedCProgram.ext2fs_bg_used_dirs_count(fs, i);
			} 
		}
		if (num_dirs > fs.getSuper().getS_inodes_count()) {
			num_dirs = fs.getSuper().getS_inodes_count();
		} 
		ret_num_dirs = num_dirs;
		return 0;
	}
	public static Object ba_alloc_private_data(Object bitmap) {
		ext2fs_ba_private bp = new ext2fs_ba_private();
		 retval = new ();
		size_t size = new size_t();
		/*
			 * Since we only have the one pointer, we could just shove our
			 * private data in the void *private field itself, but then
			 * we'd have to do a fair bit of rewriting if we ever added a
			 * field.  I'm agnostic.
			 */
		retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Unsupported expression*/, bp);
		if (retval) {
			return retval;
		} 
		size = (size_t)(((bitmap.getReal_end() - bitmap.getStart()) / 8) + 1);
		retval = ModernizedCProgram.ext2fs_get_mem(size, bp.getBitarray());
		if (retval) {
			ModernizedCProgram.ext2fs_free_mem(bp);
			bp = 0;
			return retval;
		} 
		bitmap.setPrivate((Object)bp);
		return 0;
	}
	public static Object ba_new_bmap(Object fs, Object bitmap) {
		ext2fs_ba_private bp = new ext2fs_ba_private();
		 retval = new ();
		size_t size = new size_t();
		retval = ModernizedCProgram.ba_alloc_private_data(bitmap);
		if (retval) {
			return retval;
		} 
		bp = (ext2fs_ba_private)bitmap.getPrivate();
		size = (size_t)(((bitmap.getReal_end() - bitmap.getStart()) / 8) + 1);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(bp.getBitarray(), 0, size);
		return 0;
	}
	public static void ba_free_bmap(Object bitmap) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		if (!bp) {
			return /*Error: Unsupported expression*/;
		} 
		if (bp.getBitarray()) {
			ModernizedCProgram.ext2fs_free_mem(bp.getBitarray());
			bp.setBitarray(0);
		} 
		ModernizedCProgram.ext2fs_free_mem(bp);
		bp = 0;
	}
	public static Object ba_copy_bmap(Object src, Object dest) {
		ext2fs_ba_private src_bp = (ext2fs_ba_private)src.getPrivate();
		ext2fs_ba_private dest_bp = new ext2fs_ba_private();
		 retval = new ();
		size_t size = new size_t();
		retval = ModernizedCProgram.ba_alloc_private_data(dest);
		if (retval) {
			return retval;
		} 
		dest_bp = (ext2fs_ba_private)dest.getPrivate();
		size = (size_t)(((src.getReal_end() - src.getStart()) / 8) + 1);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(dest_bp.getBitarray(), src_bp.getBitarray(), size);
		return 0;
	}
	public static Object ba_resize_bmap(Object bmap, Object new_end, Object new_real_end) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bmap.getPrivate();
		 retval = new ();
		size_t size = new size_t();
		size_t new_size = new size_t();
		 bitno = new ();
		/*
			 * If we're expanding the bitmap, make sure all of the new
			 * parts of the bitmap are zero.
			 */
		if (new_end > bmap.getEnd()) {
			bitno = bmap.getReal_end();
			if (bitno > new_end) {
				bitno = new_end;
			} 
			for (; bitno > bmap.getEnd(); bitno--) {
				ModernizedCProgram.ext2fs_clear_bit64(bitno - bmap.getStart(), bp.getBitarray());
			}
		} 
		if (new_real_end == bmap.getReal_end()) {
			bmap.setEnd(new_end);
			return 0;
		} 
		size = ((bmap.getReal_end() - bmap.getStart()) / 8) + 1;
		new_size = ((new_real_end - bmap.getStart()) / 8) + 1;
		if (size != new_size) {
			retval = ModernizedCProgram.ext2fs_resize_mem(size, new_size, bp.getBitarray());
			if (retval) {
				return retval;
			} 
		} 
		if (new_size > size) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(bp.getBitarray() + size, 0, new_size - size);
		} 
		bmap.setEnd(new_end);
		bmap.setReal_end(new_real_end);
		return 0;
	}
	public static int ba_mark_bmap(Object bitmap, Object arg) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		 bitno = ()arg;
		return ModernizedCProgram.ext2fs_set_bit64(bitno - bitmap.getStart(), bp.getBitarray());
	}
	public static int ba_unmark_bmap(Object bitmap, Object arg) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		 bitno = ()arg;
		return ModernizedCProgram.ext2fs_clear_bit64(bitno - bitmap.getStart(), bp.getBitarray());
	}
	public static int ba_test_bmap(Object bitmap, Object arg) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		 bitno = ()arg;
		return ModernizedCProgram.ext2fs_test_bit64(bitno - bitmap.getStart(), bp.getBitarray());
	}
	public static void ba_mark_bmap_extent(Object bitmap, Object arg, int num) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		 bitno = ()arg;
		int i;
		for (i = 0; i < num; i++) {
			ModernizedCProgram.ext2fs_fast_set_bit64(bitno + i - bitmap.getStart(), bp.getBitarray());
		}
	}
	public static void ba_unmark_bmap_extent(Object bitmap, Object arg, int num) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		 bitno = ()arg;
		int i;
		for (i = 0; i < num; i++) {
			ModernizedCProgram.ext2fs_fast_clear_bit64(bitno + i - bitmap.getStart(), bp.getBitarray());
		}
	}
	public static int ba_test_clear_bmap_extent(Object bitmap, Object start, int len) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		 start_byte = new ();
		 len_byte = len >> 3;
		int start_bit;
		int len_bit = len % 8;
		int first_bit = 0;
		int last_bit = 0;
		int mark_count = 0;
		int mark_bit = 0;
		int i;
		byte ADDR;
		ADDR = bp.getBitarray();
		start -= bitmap.getStart();
		start_byte = start >> 3;
		start_bit = start % 8;
		if (start_bit != 0/*
				 * The compared start block number or start inode number
				 * is not the first bit in a byte.
				 */) {
			mark_count = 8 - start_bit;
			if (len < 8 - start_bit) {
				mark_count = (int)len;
				mark_bit = len + start_bit - 1;
			} else {
					mark_bit = 7;
			} 
			for (i = mark_count; i > 0; ) {
				first_bit |=  1 << mark_bit/*
						 * Compare blocks or inodes in the first byte.
						 * If there is any marked bit, this function returns 0.
						 */;
			}
			if (first_bit & ADDR[start_byte]) {
				return 0;
			}  else if (len <= 8 - start_bit) {
				return 1;
			} 
			start_byte++;
			len_bit = (len - mark_count) % 8;
			len_byte = (len - mark_count) >> 3/*
				 * The compared start block number or start inode number is
				 * the first bit in a byte.
				 */;
		} 
		if (len_bit != 0/*
				 * The compared end block number or end inode number is
				 * not the last bit in a byte.
				 */) {
			for (mark_bit = len_bit - 1; mark_bit >= 0; mark_bit--) {
				last_bit |=  1 << mark_bit/*
						 * Compare blocks or inodes in the last byte.
						 * If there is any marked bit, this function returns 0.
						 */;
			}
			if (last_bit & ADDR[start_byte + len_byte]) {
				return 0;
			}  else if (len_byte == 0) {
				return 1;
			} 
		} 
		return ModernizedCProgram.ext2fs_mem_is_zero(ADDR + start_byte, /* Check whether all bytes are 0 */len_byte);
	}
	public static Object ba_set_bmap_range(Object bitmap, Object start, Object num, Object in) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(bp.getBitarray() + (start >> 3), in, (num + 7) >> 3);
		return 0;
	}
	public static Object ba_get_bmap_range(Object bitmap, Object start, Object num, Object out) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(out, bp.getBitarray() + (start >> 3), (num + 7) >> 3);
		return 0;
	}
	public static void ba_clear_bmap(Object bitmap) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(bp.getBitarray(), 0, (size_t)(((bitmap.getReal_end() - bitmap.getStart()) / 8) + 1));
	}
	public static void ba_print_stats(Object bitmap) {
	}
	/* Find the first zero bit between start and end, inclusive. */
	public static Object ba_find_first_zero(Object bitmap, Object start, Object end, Object out) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		long bitpos = start - bitmap.getStart();
		long count = end - start + 1;
		int byte_found = /* whether a != 0xff byte has been found */0;
		byte pos;
		long max_loop_count;
		long i;
		while ((bitpos & -1024) != 0 && count > /* scan bits until we hit a byte boundary */0) {
			if (!ModernizedCProgram.ext2fs_test_bit64(bitpos, bp.getBitarray())) {
				out = bitpos + bitmap.getStart();
				return 0;
			} 
			bitpos++;
			count--;
		}
		if (!count) {
			return 2;
		} 
		pos = ((byte)bp.getBitarray()) + (bitpos >> 3);
		while (count >= 8 && (((uintptr_t)pos) & /* scan bytes until 8-byte (64-bit) aligned */-1024)) {
			if (pos != -1024) {
				byte_found = 1;
				break;
			} 
			pos++;
			count -= 8;
			bitpos += 8;
		}
		if (!byte_found) {
			max_loop_count = count >> /* 8-byte blocks */6;
			i = max_loop_count;
			while (i) {
				if ((()pos) != ((ModernizedCProgram.__u64) - 1)) {
					break;
				} 
				pos += 8;
				i--;
			}
			count -= 64 * (max_loop_count - i);
			bitpos += 64 * (max_loop_count - i);
			max_loop_count = count >> 3;
			i = max_loop_count;
			while (i) {
				if (pos != -1024) {
					byte_found = 1;
					break;
				} 
				pos++;
				i--;
			}
			count -= 8 * (max_loop_count - i);
			bitpos += 8 * (max_loop_count - i);
		} 
		while (count-- > /* Here either count < 8 or byte_found == 1. */0) {
			if (!ModernizedCProgram.ext2fs_test_bit64(bitpos, bp.getBitarray())) {
				out = bitpos + bitmap.getStart();
				return 0;
			} 
			bitpos++;
		}
		return 2;
	}
	/* Find the first one bit between start and end, inclusive. */
	public static Object ba_find_first_set(Object bitmap, Object start, Object end, Object out) {
		ext2fs_ba_private bp = (ext2fs_ba_private)bitmap.getPrivate();
		long bitpos = start - bitmap.getStart();
		long count = end - start + 1;
		int byte_found = /* whether a != 0xff byte has been found */0;
		byte pos;
		long max_loop_count;
		long i;
		while ((bitpos & -1024) != 0 && count > /* scan bits until we hit a byte boundary */0) {
			if (ModernizedCProgram.ext2fs_test_bit64(bitpos, bp.getBitarray())) {
				out = bitpos + bitmap.getStart();
				return 0;
			} 
			bitpos++;
			count--;
		}
		if (!count) {
			return 2;
		} 
		pos = ((byte)bp.getBitarray()) + (bitpos >> 3);
		while (count >= 8 && (((uintptr_t)pos) & /* scan bytes until 8-byte (64-bit) aligned */-1024)) {
			if (pos != 0) {
				byte_found = 1;
				break;
			} 
			pos++;
			count -= 8;
			bitpos += 8;
		}
		if (!byte_found) {
			max_loop_count = count >> /* 8-byte blocks */6;
			i = max_loop_count;
			while (i) {
				if ((()pos) != 0) {
					break;
				} 
				pos += 8;
				i--;
			}
			count -= 64 * (max_loop_count - i);
			bitpos += 64 * (max_loop_count - i);
			max_loop_count = count >> 3;
			i = max_loop_count;
			while (i) {
				if (pos != 0) {
					byte_found = 1;
					break;
				} 
				pos++;
				i--;
			}
			count -= 8 * (max_loop_count - i);
			bitpos += 8 * (max_loop_count - i);
		} 
		while (count-- > /* Here either count < 8 or byte_found == 1. */0) {
			if (ModernizedCProgram.ext2fs_test_bit64(bitpos, bp.getBitarray())) {
				out = bitpos + bitmap.getStart();
				return 0;
			} 
			bitpos++;
		}
		return 2;
	}
	/*
	 * Rufus: The Reliable USB Formatting Utility
	 * ISO file extraction
	 * Copyright Â© 2011-2019 Pete Batard <pete@akeo.ie>
	 * Based on libcdio's iso & udf samples:
	 * Copyright Â© 2003-2014 Rocky Bernstein <rocky@gnu.org>
	 *
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	/* Memory leaks detection - define _CRTDBG_MAP_ALLOC as preprocessor macro */
	// How often should we update the progress bar (in 2K blocks) as updating
	public static Object cdio_open(Object psz_source, Object driver_id) {
		// the progress bar for every block will bring extraction to a crawl// Needed for UDF ISO accessreturn ((Object)0);
	}
	public static void cdio_destroy(Object p_cdio) {
	}
	// NB: Do not alter the order of the array below without validating hardcoded indexes in check_iso_props
	// TODO: freeldr.sys doesn't seem to work
	// Ensure filenames do not contain invalid FAT32 or NTFS characters
	public static Byte sanitize_filename(Byte filename, Object is_identical) {
		size_t i = new size_t();
		size_t j = new size_t();
		byte ret = ((Object)0);
		byte[] unauthorized = new byte[]{(byte)'*', (byte)'?', (byte)'<', (byte)'>', (byte)':', (byte)'|'};
		is_identical = 1;
		ret = /*Error: Function owner not recognized*/_strdup(filename);
		if (ret == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not allocate string for sanitized path");
			return ((Object)0);
		} 
		// Must start after the drive part (D:\...) so that we don't eliminate the first columnfor (i = 2; i < ((((byte)ret) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ret)); i++) {
			for (j = 0; j < /*Error: sizeof expression not supported yet*/; j++) {
				if (ret[i] == unauthorized[j]) {
					ret[i] = (byte)'_';
					is_identical = 0;
				} 
			}
		}
		return ret;
	}
	public static void log_handler(Object level, Object message) {
		switch (level) {
		case CDIO_LOG_DEBUG:
				return /*Error: Unsupported expression*/;
		default:
				ModernizedCProgram._uprintf("libcdio: %s\n", message/*
				 * Scan and set ISO properties
				 * Returns true if the the current file does not need to be processed further
				 */);
		}
	}
	public static Object check_iso_props(Object[] psz_dirname, Object file_length, Object[] psz_basename, Object psz_fullpath) {
		size_t i = new size_t();
		size_t j = new size_t();
		size_t len = new size_t();
		/*Error: Function owner not recognized*/// Check for an isolinux/syslinux config file anywhere/*Error: Function owner not recognized*/// Check for an isolinux/syslinux config file anywherememset(props, 0, /*Error: Unsupported expression*/);
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.syslinux_cfg[i] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.syslinux_cfg[i])) == 0) {
				this.setIs_cfg(1);
				this.setIs_syslinux_cfg(1);
				if ((ModernizedCProgram.scan_only) && (i < 3)) {
					ModernizedCProgram.config_path.StrArrayAdd(psz_fullpath, 1);
				} 
				if ((ModernizedCProgram.scan_only) && (i == 1) && (/*Error: Function owner not recognized*/_stricmp(((psz_dirname == ((Object)0)) ? "<NULL>" : psz_dirname), ((ModernizedCProgram.efi_dirname == ((Object)0)) ? "<NULL>" : ModernizedCProgram.efi_dirname)) == 0)) {
					ModernizedCProgram.img_report.setHas_efi_syslinux(1);
				} 
			} 
		}
		Object generatedIs_old_c32 = this.getIs_old_c32();
		// Check for an old incompatible c32 file anywherefor (i = 0; i < 2; i++) {
			if ((/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.old_c32_name[i] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.old_c32_name[i])) == 0) && (file_length <= ModernizedCProgram.old_c32_threshold[i])) {
				generatedIs_old_c32[i] = 1;
			} 
		}
		// Write-time checksif (!ModernizedCProgram.scan_only) {
			len = ((((byte)psz_basename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_basename));
			if ((len >= 4) && /*Error: Function owner not recognized*/_stricmp(((psz_basename[len - 4] == ((Object)0)) ? "<NULL>" : psz_basename[len - 4]), ((".cfg" == ((Object)0)) ? "<NULL>" : ".cfg")) == 0) {
				this.setIs_cfg(1);
				if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.grub_cfg == ((Object)0)) ? "<NULL>" : ModernizedCProgram.grub_cfg)) == 0) {
					this.setIs_grub_cfg(1);
				}  else if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.menu_cfg == ((Object)0)) ? "<NULL>" : ModernizedCProgram.menu_cfg)) == 0) {
					this.setIs_menu_cfg(1);
				} 
			} 
			if ((psz_dirname != ((Object)0)) && (psz_dirname[0] == 0) && (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.ldlinux_name == ((Object)0)) ? "<NULL>" : ModernizedCProgram.ldlinux_name)) == 0)) {
				ModernizedCProgram._uprintf("Skipping '%s' file from ISO image", psz_basename);
				return 1;
			} 
		} else {
				if (/*Error: Function owner not recognized*/_stricmp(((psz_dirname == ((Object)0)) ? "<NULL>" : psz_dirname), ((ModernizedCProgram.grub_dirname == ((Object)0)) ? "<NULL>" : ModernizedCProgram.grub_dirname)) == 0) {
					ModernizedCProgram.img_report.setHas_grub2(1);
				} 
				if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.ldlinux_c32 == ((Object)0)) ? "<NULL>" : ModernizedCProgram.ldlinux_c32)) == 0) {
					ModernizedCProgram.has_ldlinux_c32 = 1;
				} 
				if (/*Error: Function owner not recognized*/_strnicmp(((psz_dirname == ((Object)0)) ? "<NULL>" : psz_dirname), ((ModernizedCProgram.casper_dirname == ((Object)0)) ? "<NULL>" : ModernizedCProgram.casper_dirname), /*Error: Function owner not recognized*/strlen(ModernizedCProgram.casper_dirname)) == 0) {
					ModernizedCProgram.img_report.setUses_casper(1);
					if (/*Error: Function owner not recognized*/strstr(((psz_dirname == ((Object)0)) ? "<NULL>" : psz_dirname), ((ModernizedCProgram.pop_os_name == ((Object)0)) ? "<NULL>" : ModernizedCProgram.pop_os_name)) != ((Object)0)) {
						ModernizedCProgram.img_report.setDisable_iso(1);
					} 
				} 
				if ((psz_dirname != ((Object)0)) && (psz_dirname[0] == 0)) {
					if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.bootmgr_name == ((Object)0)) ? "<NULL>" : ModernizedCProgram.bootmgr_name)) == 0) {
						ModernizedCProgram.img_report.setHas_bootmgr(1);
					} 
					if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.bootmgr_efi_name == ((Object)0)) ? "<NULL>" : ModernizedCProgram.bootmgr_efi_name)) == 0) {
						ModernizedCProgram.img_report.setHas_bootmgr_efi(1);
					} 
					if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.grldr_name == ((Object)0)) ? "<NULL>" : ModernizedCProgram.grldr_name)) == 0) {
						ModernizedCProgram.img_report.setHas_grub4dos(1);
					} 
					if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.kolibri_name == ((Object)0)) ? "<NULL>" : ModernizedCProgram.kolibri_name)) == 0) {
						ModernizedCProgram.img_report.setHas_kolibrios(1);
					} 
					if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.bootmgr_efi_name == ((Object)0)) ? "<NULL>" : ModernizedCProgram.bootmgr_efi_name)) == 0) {
						ModernizedCProgram.img_report.getHas_efi() |=  1;
					} 
					if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.manjaro_marker == ((Object)0)) ? "<NULL>" : ModernizedCProgram.manjaro_marker)) == 0) {
						ModernizedCProgram.img_report.setDisable_iso(1);
					} 
				} 
				if ((ModernizedCProgram.img_report.getReactos_path()[0] == 0) && (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.reactos_name == ((Object)0)) ? "<NULL>" : ModernizedCProgram.reactos_name)) == 0)) {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.img_report.getReactos_path(), psz_fullpath, (((size_t)(((((byte)psz_fullpath) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_fullpath)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)psz_fullpath) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_fullpath)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
						((byte)ModernizedCProgram.img_report.getReactos_path())[(((size_t)(((((byte)psz_fullpath) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_fullpath)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)psz_fullpath) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_fullpath)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
					} while (0);
				} 
				if (!(ModernizedCProgram.img_report.getEfi_img_path()[0] != 0) && (((((byte)psz_basename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_basename)) >= 7) && (/*Error: Function owner not recognized*/_strnicmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), (("efi" == ((Object)0)) ? "<NULL>" : "efi"), 3) == 0) && (/*Error: Function owner not recognized*/_stricmp(((psz_basename[/*Error: Function owner not recognized*/strlen(psz_basename) - 4] == ((Object)0)) ? "<NULL>" : psz_basename[/*Error: Function owner not recognized*/strlen(psz_basename) - 4]), ((".img" == ((Object)0)) ? "<NULL>" : ".img")) == 0)) {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.img_report.getEfi_img_path(), psz_fullpath, (((size_t)(((((byte)psz_fullpath) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_fullpath)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)psz_fullpath) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_fullpath)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
						((byte)ModernizedCProgram.img_report.getEfi_img_path())[(((size_t)(((((byte)psz_fullpath) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_fullpath)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)psz_fullpath) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_fullpath)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
					} while (0);
				} 
				if (/*Error: Function owner not recognized*/_stricmp(((psz_dirname == ((Object)0)) ? "<NULL>" : psz_dirname), ((ModernizedCProgram.efi_dirname == ((Object)0)) ? "<NULL>" : ModernizedCProgram.efi_dirname)) == 0) {
					for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
						if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.efi_bootname[i] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.efi_bootname[i])) == 0) {
							ModernizedCProgram.img_report.getHas_efi() |=  (2 << i);
						} 
					}
				} 
				if (psz_dirname != ((Object)0)) {
					if (/*Error: Function owner not recognized*/_stricmp(((psz_dirname[((false) > (((int)((((byte)psz_dirname) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_dirname))) - ((int)/*Error: Function owner not recognized*/strlen(ModernizedCProgram.sources_str))) ? (false) : (((int)((((byte)psz_dirname) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_dirname))) - ((int)/*Error: Function owner not recognized*/strlen(ModernizedCProgram.sources_str))))] == ((Object)0)) ? "<NULL>" : psz_dirname[((false) > (((int)((((byte)psz_dirname) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_dirname))) - ((int)/*Error: Function owner not recognized*/strlen(ModernizedCProgram.sources_str))) ? (false) : (((int)((((byte)psz_dirname) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_dirname))) - ((int)/*Error: Function owner not recognized*/strlen(ModernizedCProgram.sources_str))))]), ((ModernizedCProgram.sources_str == ((Object)0)) ? "<NULL>" : ModernizedCProgram.sources_str)) == 0) {
						for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
							if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.wininst_name[i] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.wininst_name[i])) == 0) {
								if (ModernizedCProgram.img_report.getWininst_index() < 4) {
									do {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.img_report.getWininst_path()[ModernizedCProgram.img_report.getWininst_index()], /*Error: sizeof expression not supported yet*/, "?:%s", psz_fullpath);
										(ModernizedCProgram.img_report.getWininst_path()[ModernizedCProgram.img_report.getWininst_index()])[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
									} while (0);
									ModernizedCProgram.img_report.getWininst_index()++;
								} 
							} 
						}
					} 
				} 
				for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
					if (/*Error: Function owner not recognized*/_stricmp(((psz_dirname == ((Object)0)) ? "<NULL>" : psz_dirname), ((ModernizedCProgram.pe_dirname[i] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.pe_dirname[i])) == 0) {
						for (j = 0; j < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); j++) {
							if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.pe_file[j] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.pe_file[j])) == 0) {
								ModernizedCProgram.img_report.getWinpe() |=  (1 << j) << ((/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/) * i);
							} 
						}
					} 
				}
				for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
					if (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.isolinux_bin[i] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.isolinux_bin[i])) == 0) {
						ModernizedCProgram.isolinux_path.StrArrayAdd(psz_fullpath, 1);
					} 
				}
				for (i = 0; i < 2; i++) {
					if (generatedIs_old_c32[i]) {
						ModernizedCProgram.img_report.getHas_old_c32()[i] = 1;
					} 
				}
				if (file_length >= -1024) {
					ModernizedCProgram.img_report.setHas_4GB_file(1);
				} 
				ModernizedCProgram.total_blocks += file_length / ISO_BLOCKSIZE;
				if ((file_length != 0) && (file_length % ISO_BLOCKSIZE != 0)) {
					ModernizedCProgram.total_blocks++;
				} 
				return 1;
		} 
		// Check for config files that may need patching
		return 0;
	}
	// Apply various workarounds to Linux config files
	public static void fix_config(Object psz_fullpath, Object psz_path, Object psz_basename) {
		size_t i = new size_t();
		size_t nul_pos = new size_t();
		byte iso_label = ((Object)0);
		byte usb_label = ((Object)0);
		byte src;
		byte dst;
		nul_pos = ((((byte)psz_fullpath) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(psz_fullpath));
		src = /*Error: Function owner not recognized*/_strdup(psz_fullpath);
		if (src == ((Object)0)) {
			return /*Error: Unsupported expression*/;
		} 
		for (i = 0; i < nul_pos; i++) {
			if (src[i] == (byte)'/') {
				src[i] = (byte)'\\';
			} 
		}
		Object generatedIs_grub_cfg = this.getIs_grub_cfg();
		Object generatedIs_menu_cfg = this.getIs_menu_cfg();
		Object generatedIs_syslinux_cfg = this.getIs_syslinux_cfg();
		// Add persistence to the kernel optionsif ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (((ModernizedCProgram.img_report.getSl_version() != 0) || ((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos()))) && !((((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getUses_minint()) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) || (ModernizedCProgram.img_report.getReactos_path()[0] != 0) || (ModernizedCProgram.img_report.getHas_kolibrios()))) && ModernizedCProgram.persistence_size) {
			if ((generatedIs_grub_cfg) || (generatedIs_menu_cfg) || (generatedIs_syslinux_cfg)) {
				if (ModernizedCProgram.replace_in_token_data(src, generatedIs_grub_cfg ? "linux" : "append", generatedIs_grub_cfg ? "/casper/vmlinuz" : "initrd=/casper/initrd", generatedIs_grub_cfg ? "/casper/vmlinuz persistent" : "persistent initrd=/casper/initrd", 1) != ((Object)0)) {
					ModernizedCProgram._uprintf("  Added 'persistent' kernel option");
				}  else if (ModernizedCProgram.replace_in_token_data(src, generatedIs_grub_cfg ? "linux" : "append", "boot=live", "boot=live persistence", 1) != ((Object)0)) {
					ModernizedCProgram._uprintf("  Added 'persistence' kernel option");
				} 
			} 
		} 
		Object generatedIs_cfg = this.getIs_cfg();
		Object generatedIs_conf = this.getIs_conf();
		// Workaround for config files requiring an ISO label for kernel append that may be// different from our USB label. Oh, and these labels must have spaces converted to \x20.if ((generatedIs_cfg) || (generatedIs_conf)) {
			iso_label = ModernizedCProgram.replace_char(ModernizedCProgram.img_report.getLabel(), (byte)' ', "\\x20");
			usb_label = ModernizedCProgram.replace_char(ModernizedCProgram.img_report.getUsb_label(), (byte)' ', "\\x20");
			if ((iso_label != ((Object)0)) && (usb_label != ((Object)0))) {
				if (generatedIs_grub_cfg) {
					if ((ModernizedCProgram.replace_in_token_data(src, "linux", iso_label, usb_label, 1) != ((Object)0)) || (ModernizedCProgram.replace_in_token_data(src, "linuxefi", iso_label, usb_label, 1) != ((Object)0))) {
						ModernizedCProgram._uprintf("  Patched %s: '%s' â '%s'\n", src, iso_label, usb_label);
					} 
				}  else if (ModernizedCProgram.replace_in_token_data(src, (generatedIs_conf) ? "options" : "append", iso_label, usb_label, 1) != ((Object)0)) {
					ModernizedCProgram._uprintf("  Patched %s: '%s' â '%s'\n", src, iso_label, usb_label);
				} 
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)iso_label);
				iso_label = ((Object)0);
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)usb_label);
				usb_label = ((Object)0);
			} while (0);
		} 
		// Fix dual BIOS + EFI support for tails and other ISOsif ((generatedIs_syslinux_cfg) && (/*Error: Function owner not recognized*/_stricmp(((psz_path == ((Object)0)) ? "<NULL>" : psz_path), ((ModernizedCProgram.efi_dirname == ((Object)0)) ? "<NULL>" : ModernizedCProgram.efi_dirname)) == 0) && (/*Error: Function owner not recognized*/_stricmp(((psz_basename == ((Object)0)) ? "<NULL>" : psz_basename), ((ModernizedCProgram.syslinux_cfg[0] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.syslinux_cfg[0])) == 0) && (!ModernizedCProgram.img_report.getHas_efi_syslinux()) && (dst = /*Error: Function owner not recognized*/_strdup(src))) {
			dst[nul_pos - 12] = (byte)'s';
			dst[nul_pos - 11] = (byte)'y';
			dst[nul_pos - 10] = (byte)'s';
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CopyFileA(src, dst, 1);
			ModernizedCProgram._uprintf("Duplicated %s to %s\n", src, dst);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(dst);
		} 
		// Workaround for FreeNASif (generatedIs_grub_cfg) {
			iso_label = /*Error: Function owner not recognized*/malloc(260);
			usb_label = /*Error: Function owner not recognized*/malloc(260);
			if ((iso_label != ((Object)0)) && (usb_label != ((Object)0))) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(iso_label, 260, "cd9660:/dev/iso9660/%s", ModernizedCProgram.img_report.getLabel());
					(iso_label)[(true) - 1] = 0;
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(usb_label, 260, "msdosfs:/dev/msdosfs/%s", ModernizedCProgram.img_report.getUsb_label());
					(usb_label)[(true) - 1] = 0;
				} while (0);
				if (ModernizedCProgram.replace_in_token_data(src, "set", iso_label, usb_label, 1) != ((Object)0)) {
					ModernizedCProgram._uprintf("  Patched %s: '%s' â '%s'\n", src, iso_label, usb_label);
				} 
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)iso_label);
				iso_label = ((Object)0);
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)usb_label);
				usb_label = ((Object)0);
			} while (0);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(src);
	}
	public static void print_extracted_file(byte[] psz_fullpath, Object file_length) {
		size_t i = new size_t();
		size_t nul_pos = new size_t();
		if (psz_fullpath == ((Object)0)) {
			return /*Error: Unsupported expression*/;
		} 
		nul_pos = /*Error: Function owner not recognized*/strlen(psz_fullpath);
		for (i = 0; i < nul_pos; i++) {
			if (psz_fullpath[i] == (byte)'/') {
				psz_fullpath[i] = (byte)'\\';
			} 
		}
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(psz_fullpath[nul_pos], 24, " (%s)", ModernizedCProgram.SizeToHumanReadable(file_length, 1, 0));
			(psz_fullpath[nul_pos])[(true) - 1] = 0;
		} while (0);
		ModernizedCProgram._uprintf("Extracting: %s\n", psz_fullpath);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(psz_fullpath[nul_pos], 24, " (%s)", ModernizedCProgram.SizeToHumanReadable(file_length, 0, 0));
			(psz_fullpath[nul_pos])[(true) - 1] = 0;
		} while (0);
		// MSG_000 is "%s"// MSG_000 is "%s"ModernizedCProgram.PrintStatusInfo(0, 0, 0, 3000, psz_fullpath)// ISO9660 cannot handle backslashes;// ISO9660 cannot handle backslashes
		for (i = 0; i < nul_pos; i++) {
			if (psz_fullpath[i] == (byte)'\\') {
				psz_fullpath[i] = (byte)'/';
			} 
		}
		psz_fullpath[nul_pos] = 0;
	}
	// Convert from time_t to FILETIME
	// Uses 3 static entries so that we can convert 3 concurrent values at the same time
	public static Object to_filetime(Object t) {
		int i = 0;
		FILETIME[] ft = new FILETIME();
		FILETIME r = new FILETIME();
		LONGLONG ll = ((LONGLONG)(t) * (LONGLONG)(true)) + -1024;
		r = ft[i];
		r.setDwLowDateTime((DWORD)ll);
		r.setDwHighDateTime((DWORD)(ll >> 32));
		i = (i + 1) % (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/);
		return r;
	}
	// Helper function to restore the timestamp on a directory
	public static void set_directory_timestamp(Byte path, Object creation, Object last_access, Object modify) {
		HANDLE dir_handle = ModernizedCProgram.CreateFileU(path, -1024 | -1024, -1024, ((Object)0), 3, 33554432, ((Object)0));
		if ((dir_handle == (HANDLE)(true)) || (!/*Error: Function owner not recognized*/SetFileTime(dir_handle, creation, last_access, modify))) {
			ModernizedCProgram._uprintf("  Could not set timestamp for directory '%s': %s", path, ModernizedCProgram.WindowsErrorString());
		} 
		do {
			if ((dir_handle != (HANDLE)(true)) && (dir_handle != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(dir_handle);
				dir_handle = (HANDLE)(true);
			} 
		} while (0);
	}
	// Preallocates the target size of a newly created file in order to prevent fragmentation from repeated writes
	public static void preallocate_filesize(Object hFile, Object file_length) {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetFileInformationByHandle(hFile, FileEndOfFileInfo, file_length, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*/// FileAllocationInfo does not require the size to be a multiple of the cluster size; the FS driver takes care of this./*Error: Function owner not recognized*/// FileAllocationInfo does not require the size to be a multiple of the cluster size; the FS driver takes care of this.SetFileInformationByHandle(hFile, FileAllocationInfo, file_length, /*Error: sizeof expression not supported yet*/);
	}
	// Returns 0 on success, nonzero on error
	public static int udf_extract_files(Object p_udf, Object p_udf_dirent, Object[] psz_path) {
		HANDLE file_handle = ((Object)0);
		DWORD buf_size = new DWORD();
		DWORD wr_size = new DWORD();
		DWORD err = new DWORD();
		EXTRACT_PROPS props = new EXTRACT_PROPS();
		BOOL r = new BOOL();
		BOOL is_identical = new BOOL();
		int length;
		size_t i = new size_t();
		byte[] tmp = new byte[128];
		byte psz_fullpath = ((Object)0);
		byte psz_sanpath = ((Object)0);
		byte psz_basename;
		 p_udf_dirent2 = new ();
		uint8_t[] buf = new uint8_t();
		int64_t read = new int64_t();
		int64_t file_length = new int64_t();
		if ((p_udf_dirent == ((Object)0)) || (psz_path == ((Object)0))) {
			return 1;
		} 
		if (psz_path[0] == 0) {
			ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_INIT, (int)1, (uint64_t)(uintptr_t)((Object)0), 0);
		} 
		;
		Object generatedIs_old_c32 = props.getIs_old_c32();
		Object generatedIs_cfg = props.getIs_cfg();
		while ((p_udf_dirent = ModernizedCProgram.udf_readdir(p_udf_dirent)) != ((Object)0)) {
			if (ModernizedCProgram.FormatStatus) {
				;
			} 
			psz_basename = ModernizedCProgram.udf_get_filename(p_udf_dirent);
			if (/*Error: Function owner not recognized*/strlen(psz_basename) == 0) {
				continue;
			} 
			length = (int)(3 + /*Error: Function owner not recognized*/strlen(psz_path) + /*Error: Function owner not recognized*/strlen(psz_basename) + /*Error: Function owner not recognized*/strlen(ModernizedCProgram.psz_extract_dir) + 24);
			psz_fullpath = (byte)/*Error: Function owner not recognized*/calloc(/*Error: Unsupported expression*/, length);
			if (psz_fullpath == ((Object)0)) {
				ModernizedCProgram._uprintf("Error allocating file name");
				;
			} 
			length = /*Error: Function owner not recognized*/_snprintf(psz_fullpath, length, "%s%s/%s", ModernizedCProgram.psz_extract_dir, psz_path, psz_basename);
			if (length < 0) {
				;
			} 
			if (ModernizedCProgram.udf_is_dir(p_udf_dirent)) {
				if (!ModernizedCProgram.scan_only) {
					psz_sanpath = ModernizedCProgram.sanitize_filename(psz_fullpath, is_identical);
					do {
						(Object)(ModernizedCProgram._mkdirU(psz_sanpath));
					} while (0);
					if (ModernizedCProgram.preserve_timestamps) {
						ModernizedCProgram.set_directory_timestamp(psz_sanpath, ModernizedCProgram.to_filetime(ModernizedCProgram.udf_get_attribute_time(p_udf_dirent)), ModernizedCProgram.to_filetime(ModernizedCProgram.udf_get_access_time(p_udf_dirent)), ModernizedCProgram.to_filetime(ModernizedCProgram.udf_get_modification_time(p_udf_dirent)));
					} 
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)psz_sanpath);
						psz_sanpath = ((Object)0);
					} while (0);
				} 
				p_udf_dirent2 = ModernizedCProgram.udf_opendir(p_udf_dirent);
				if (p_udf_dirent2 != ((Object)0)) {
					if (ModernizedCProgram.udf_extract_files(p_udf, p_udf_dirent2, psz_fullpath[/*Error: Function owner not recognized*/strlen(ModernizedCProgram.psz_extract_dir)])) {
						;
					} 
				} 
			} else {
					file_length = ModernizedCProgram.udf_get_file_length(p_udf_dirent);
					if (props.check_iso_props(psz_path, file_length, psz_basename, psz_fullpath)) {
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)psz_fullpath);
							psz_fullpath = ((Object)0);
						} while (0);
						continue;
					} 
					ModernizedCProgram.print_extracted_file(psz_fullpath, file_length);
					for (i = 0; i < 2; i++) {
						if (generatedIs_old_c32[i] && ModernizedCProgram.use_own_c32[i]) {
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s/syslinux-%s/%s", "rufus_files", ModernizedCProgram.embedded_sl_version_str[0], ModernizedCProgram.old_c32_name[i]);
								(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
							} while (0);
							if (ModernizedCProgram.CopyFileU(tmp, psz_fullpath, 0)) {
								ModernizedCProgram._uprintf("  Replaced with local version %s", ModernizedCProgram.IsFileInDB(tmp) ? "â" : "â");
								break;
							} 
							ModernizedCProgram._uprintf("  Could not replace file: %s", ModernizedCProgram.WindowsErrorString());
						} 
					}
					if (i < 2) {
						continue;
					} 
					psz_sanpath = ModernizedCProgram.sanitize_filename(psz_fullpath, is_identical);
					if (!is_identical) {
						ModernizedCProgram._uprintf("  File name sanitized to '%s'", psz_sanpath);
					} 
					file_handle = ModernizedCProgram.CreateFileU(psz_sanpath, -1024 | -1024, -1024, ((Object)0), 2, -1024, ((Object)0));
					if (file_handle == (HANDLE)(true)) {
						err = /*Error: Function owner not recognized*/GetLastError();
						ModernizedCProgram._uprintf("  Unable to create file: %s", ModernizedCProgram.WindowsErrorString());
						if ((err == -1024) && (/*Error: Function owner not recognized*/strcmp(((psz_sanpath[3] == ((Object)0)) ? "<NULL>" : psz_sanpath[3]), ((ModernizedCProgram.autorun_name == ((Object)0)) ? "<NULL>" : ModernizedCProgram.autorun_name)) == 0)) {
							ModernizedCProgram._uprintf(ModernizedCProgram.stupid_antivirus);
						} else {
								;
						} 
					} else {
							ModernizedCProgram.preallocate_filesize(file_handle, file_length);
							while (file_length > 0) {
								if (ModernizedCProgram.FormatStatus) {
									;
								} 
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buf, 0, UDF_BLOCKSIZE);
								read = ModernizedCProgram.udf_read_block(p_udf_dirent, buf, 1);
								if (read < 0) {
									ModernizedCProgram._uprintf("  Error reading UDF file %s", psz_fullpath[/*Error: Function owner not recognized*/strlen(ModernizedCProgram.psz_extract_dir)]);
									;
								} 
								buf_size = (DWORD)(((file_length) < (read)) ? (file_length) : (read));
								do {
									r = ModernizedCProgram.WriteFileWithRetry(file_handle, buf, buf_size, wr_size, 4);
									ModernizedCProgram.iso_blocking_status++;
								} while (0);
								if (!r) {
									ModernizedCProgram._uprintf("  Error writing file: %s", ModernizedCProgram.WindowsErrorString());
									;
								} 
								file_length -= read;
								if (ModernizedCProgram.nb_blocks++ % 128 == 0) {
									ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FILE_COPY, 3231, ModernizedCProgram.nb_blocks, ModernizedCProgram.total_blocks);
								} 
							}
					} 
					if ((ModernizedCProgram.preserve_timestamps) && (!/*Error: Function owner not recognized*/SetFileTime(file_handle, ModernizedCProgram.to_filetime(ModernizedCProgram.udf_get_attribute_time(p_udf_dirent)), ModernizedCProgram.to_filetime(ModernizedCProgram.udf_get_access_time(p_udf_dirent)), ModernizedCProgram.to_filetime(ModernizedCProgram.udf_get_modification_time(p_udf_dirent))))) {
						ModernizedCProgram._uprintf("  Could not set timestamp: %s", ModernizedCProgram.WindowsErrorString());
					} 
					do {
						do {
							if ((file_handle != (HANDLE)(true)) && (file_handle != ((Object)0))) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(file_handle);
								file_handle = (HANDLE)(true);
							} 
						} while (0);
						ModernizedCProgram.iso_blocking_status++;
					} while (0);
					if (generatedIs_cfg) {
						props.fix_config(psz_sanpath, psz_path, psz_basename);
					} 
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)psz_sanpath);
						psz_sanpath = ((Object)0);
					} while (0);
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)psz_fullpath);
				psz_fullpath = ((Object)0);
			} while (0);
		}
		return 0;
		do {
			do {
				if ((file_handle != (HANDLE)(true)) && (file_handle != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(file_handle);
					file_handle = (HANDLE)(true);
				} 
			} while (0);
			ModernizedCProgram.iso_blocking_status++;
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)psz_sanpath);
			psz_sanpath = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)psz_fullpath);
			psz_fullpath = ((Object)0);
		} while (0);
		return 1;
	}
	// Returns 0 on success, nonzero on error
	public static int iso_extract_files(Object p_iso, Object[] psz_path) {
		HANDLE file_handle = ((Object)0);
		DWORD buf_size = new DWORD();
		DWORD wr_size = new DWORD();
		DWORD err = new DWORD();
		EXTRACT_PROPS props = new EXTRACT_PROPS();
		BOOL is_symlink = new BOOL();
		BOOL is_identical = new BOOL();
		int length;
		int r = 1;
		byte[] tmp = new byte[128];
		byte[] psz_fullpath = new byte[260];
		byte psz_basename = ((Object)0);
		byte psz_sanpath = ((Object)0);
		byte psz_iso_name = psz_fullpath[/*Error: Function owner not recognized*/strlen(ModernizedCProgram.psz_extract_dir)];
		byte[] buf = new byte[ISO_BLOCKSIZE];
		 p_entnode = new ();
		 p_statbuf = new ();
		 p_entlist = new ();
		size_t i = new size_t();
		size_t j = new size_t();
		 lsn = new ();
		int64_t file_length = new int64_t();
		int64_t extent_length = new int64_t();
		if ((p_iso == ((Object)0)) || (psz_path == ((Object)0))) {
			return 1;
		} 
		length = /*Error: Function owner not recognized*/_snprintf(psz_fullpath, /*Error: sizeof expression not supported yet*/, "%s%s/", ModernizedCProgram.psz_extract_dir, psz_path);
		if (length < 0) {
			return 1;
		} 
		psz_basename = psz_fullpath[length];
		p_entlist = ModernizedCProgram.iso9660_ifs_readdir(p_iso, psz_path);
		if (!p_entlist) {
			ModernizedCProgram._uprintf("Could not access directory %s", psz_path);
			return 1;
		} 
		if (psz_path[0] == 0) {
			ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_INIT, (int)1, (uint64_t)(uintptr_t)((Object)0), 0);
		} 
		;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_CDIO_LIST_FOREACH(p_entnode, p_entlist);
		Object generatedIs_old_c32 = props.getIs_old_c32();
		Object generatedIs_cfg = props.getIs_cfg();
		{ 
			if (ModernizedCProgram.FormatStatus) {
				;
			} 
			p_statbuf = ()ModernizedCProgram._cdio_list_node_data(p_entnode);
			if ((/*Error: Function owner not recognized*/strcmp(p_statbuf.getFilename(), ".") == 0) || (/*Error: Function owner not recognized*/strcmp(p_statbuf.getFilename(), "..") == 0)) {
				continue;
			} 
			is_symlink = 0;
			if ((p_statbuf.getRr().getB3_rock() == yep) && ModernizedCProgram.enable_rockridge) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(psz_basename, p_statbuf.getFilename(), (((size_t)(((((byte)p_statbuf.getFilename()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(p_statbuf.getFilename())) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - length - 1)) ? ((size_t)(((((byte)p_statbuf.getFilename()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(p_statbuf.getFilename())) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - length - 1))));
					((byte)psz_basename)[(((size_t)(((((byte)p_statbuf.getFilename()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(p_statbuf.getFilename())) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/ - length - 1)) ? ((size_t)(((((byte)p_statbuf.getFilename()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(p_statbuf.getFilename())) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/ - length - 1))) - 1] = 0;
				} while (0);
				if (((((byte)p_statbuf.getFilename()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(p_statbuf.getFilename())) > 64) {
					ModernizedCProgram.img_report.setHas_long_filename(1);
				} 
				is_symlink = (p_statbuf.getRr().getPsz_symlink() != ((Object)0));
				if (is_symlink) {
					ModernizedCProgram.img_report.setHas_symlinks(1);
				} 
				if (ModernizedCProgram.scan_only) {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)p_statbuf.getRr().getPsz_symlink());
						p_statbuf.getRr().setPsz_symlink(((Object)0));
					} while (0);
				} 
			} else {
					ModernizedCProgram.iso9660_name_translate_ext(p_statbuf.getFilename(), psz_basename, ModernizedCProgram.joliet_level);
			} 
			if (p_statbuf.getType() == _STAT_DIR) {
				if (!ModernizedCProgram.scan_only) {
					psz_sanpath = ModernizedCProgram.sanitize_filename(psz_fullpath, is_identical);
					do {
						(Object)(ModernizedCProgram._mkdirU(psz_sanpath));
					} while (0);
					if (ModernizedCProgram.preserve_timestamps) {
						LPFILETIME ft = ModernizedCProgram.to_filetime(/*Error: Function owner not recognized*/mktime(p_statbuf.getTm()));
						ModernizedCProgram.set_directory_timestamp(psz_sanpath, ft, ft, ft);
					} 
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)psz_sanpath);
						psz_sanpath = ((Object)0);
					} while (0);
				} 
				if (ModernizedCProgram.iso_extract_files(p_iso, psz_iso_name)) {
					;
				} 
			} else {
					file_length = p_statbuf.getSize();
					if (props.check_iso_props(psz_path, file_length, psz_basename, psz_fullpath)) {
						continue;
					} 
					ModernizedCProgram.print_extracted_file(psz_fullpath, file_length);
					for (i = 0; i < 2; i++) {
						if (generatedIs_old_c32[i] && ModernizedCProgram.use_own_c32[i]) {
							do {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s/syslinux-%s/%s", "rufus_files", ModernizedCProgram.embedded_sl_version_str[0], ModernizedCProgram.old_c32_name[i]);
								(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
							} while (0);
							if (ModernizedCProgram.CopyFileU(tmp, psz_fullpath, 0)) {
								ModernizedCProgram._uprintf("  Replaced with local version %s", ModernizedCProgram.IsFileInDB(tmp) ? "â" : "â");
								break;
							} 
							ModernizedCProgram._uprintf("  Could not replace file: %s", ModernizedCProgram.WindowsErrorString());
						} 
					}
					if (i < 2) {
						continue;
					} 
					psz_sanpath = ModernizedCProgram.sanitize_filename(psz_fullpath, is_identical);
					if (!is_identical) {
						ModernizedCProgram._uprintf("  File name sanitized to '%s'", psz_sanpath);
					} 
					if (is_symlink) {
						if (file_length == 0) {
							ModernizedCProgram._uprintf("  Ignoring Rock Ridge symbolic link to '%s'", p_statbuf.getRr().getPsz_symlink());
						} 
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)p_statbuf.getRr().getPsz_symlink());
							p_statbuf.getRr().setPsz_symlink(((Object)0));
						} while (0);
					} 
					file_handle = ModernizedCProgram.CreateFileU(psz_sanpath, -1024 | -1024, -1024, ((Object)0), 2, -1024, ((Object)0));
					if (file_handle == (HANDLE)(true)) {
						err = /*Error: Function owner not recognized*/GetLastError();
						ModernizedCProgram._uprintf("  Unable to create file: %s", ModernizedCProgram.WindowsErrorString());
						if ((err == -1024) && (/*Error: Function owner not recognized*/strcmp(((psz_sanpath[3] == ((Object)0)) ? "<NULL>" : psz_sanpath[3]), ((ModernizedCProgram.autorun_name == ((Object)0)) ? "<NULL>" : ModernizedCProgram.autorun_name)) == 0)) {
							ModernizedCProgram._uprintf(ModernizedCProgram.stupid_antivirus);
						} else {
								;
						} 
					} else {
							ModernizedCProgram.preallocate_filesize(file_handle, file_length);
							for (j = 0; j < p_statbuf.getExtents(); j++) {
								extent_length = p_statbuf.getExtsize()[j];
								for (i = 0; extent_length > 0; i++) {
									if (ModernizedCProgram.FormatStatus) {
										;
									} 
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buf, 0, ISO_BLOCKSIZE);
									lsn = p_statbuf.getLsn()[j] + ()i;
									if (ModernizedCProgram.iso9660_iso_seek_read(p_iso, buf, lsn, 1) != ISO_BLOCKSIZE) {
										ModernizedCProgram._uprintf("  Error reading ISO9660 file %s at LSN %lu", psz_iso_name, (long)lsn);
										;
									} 
									buf_size = (DWORD)(((extent_length) < (ISO_BLOCKSIZE)) ? (extent_length) : (ISO_BLOCKSIZE));
									do {
										r = ModernizedCProgram.WriteFileWithRetry(file_handle, buf, buf_size, wr_size, 4);
										ModernizedCProgram.iso_blocking_status++;
									} while (0);
									if (!r) {
										ModernizedCProgram._uprintf("  Error writing file: %s", ModernizedCProgram.WindowsErrorString());
										;
									} 
									extent_length -= ISO_BLOCKSIZE;
									if (ModernizedCProgram.nb_blocks++ % 128 == 0) {
										ModernizedCProgram.UpdateProgressWithInfo(action_type.OP_FILE_COPY, 3231, ModernizedCProgram.nb_blocks, ModernizedCProgram.total_blocks);
									} 
								}
							}
					} 
					if (ModernizedCProgram.preserve_timestamps) {
						LPFILETIME ft = ModernizedCProgram.to_filetime(/*Error: Function owner not recognized*/mktime(p_statbuf.getTm()));
						if (!/*Error: Function owner not recognized*/SetFileTime(file_handle, ft, ft, ft)) {
							ModernizedCProgram._uprintf("  Could not set timestamp: %s", ModernizedCProgram.WindowsErrorString());
						} 
					} 
					do {
						do {
							if ((file_handle != (HANDLE)(true)) && (file_handle != ((Object)0))) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(file_handle);
								file_handle = (HANDLE)(true);
							} 
						} while (0);
						ModernizedCProgram.iso_blocking_status++;
					} while (0);
					if (generatedIs_cfg) {
						props.fix_config(psz_sanpath, psz_path, psz_basename);
					} 
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)psz_sanpath);
						psz_sanpath = ((Object)0);
					} while (0);
			} 
		}
		r = 0;
		ModernizedCProgram.iso9660_filelist_free(p_entlist);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)psz_sanpath);
			psz_sanpath = ((Object)0);
		} while (0);
		return r;
	}
	public static void GetGrubVersion(byte[] buf, Object buf_size) {
		byte p;
		byte[] unauthorized = new byte[]{(byte)'<', (byte)'>', (byte)':', (byte)'|', (byte)'*', (byte)'?', (byte)'\\', (byte)'/'};
		size_t i = new size_t();
		byte[] grub_version_str = "GRUB  version %s";
		for (i = 0; i < buf_size; i++) {
			if (/*Error: Function owner not recognized*/memcmp(buf[i], grub_version_str, /*Error: sizeof expression not supported yet*/) == 0) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.img_report.getGrub2_version(), buf[i + /*Error: sizeof expression not supported yet*/], (((size_t)(((((byte)buf[i + /*Error: sizeof expression not supported yet*/]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(buf[i + /*Error: sizeof expression not supported yet*/])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)buf[i + /*Error: sizeof expression not supported yet*/]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(buf[i + /*Error: sizeof expression not supported yet*/])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)ModernizedCProgram.img_report.getGrub2_version())[(((size_t)(((((byte)buf[i + /*Error: sizeof expression not supported yet*/]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(buf[i + /*Error: sizeof expression not supported yet*/])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)buf[i + /*Error: sizeof expression not supported yet*/]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(buf[i + /*Error: sizeof expression not supported yet*/])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
				break;
			} 
		}
		// Sanitize the stringfor (p = ModernizedCProgram.img_report.getGrub2_version()[0]; p; p++) {
			for (i = 0; i < /*Error: sizeof expression not supported yet*/; i++) {
				if (p == unauthorized[i]) {
					p = (byte)'_';
				} 
			}
		}
		// <Shakes fist angrily> "KASPERSKYYYYYY!!!..." (https://github.com/pbatard/rufus/issues/467)// But seriously, these guys should know better than "security" through obscurity...if (ModernizedCProgram.img_report.getGrub2_version()[0] == (byte)'0') {
			ModernizedCProgram.img_report.getGrub2_version()[0] = 0;
		} 
	}
	public static Object ExtractISO(Object src_iso, Object dest_dir, Object scan) {
		size_t i = new size_t();
		size_t j = new size_t();
		size_t size = new size_t();
		size_t sl_index = 0;
		uint16_t sl_version = new uint16_t();
		FILE fd = new FILE();
		int r = 1;
		 p_iso = ((Object)0);
		 pvd = new ();
		 p_udf = ((Object)0);
		 p_udf_root = new ();
		byte tmp;
		byte buf;
		byte ext;
		byte[] path = new byte[260];
		byte[] path2 = new byte[16];
		byte[] basedir = new byte[]{"i386", "amd64", "minint"};
		byte tmp_sif = ".\\txtsetup.sif~";
		 iso_extension_mask = ISO_EXTENSION_ALL;
		byte spacing = "  ";
		if ((!ModernizedCProgram.enable_iso) || (src_iso == ((Object)0)) || (dest_dir == ((Object)0))) {
			return 0;
		} 
		ModernizedCProgram.scan_only = scan;
		if (!ModernizedCProgram.scan_only) {
			spacing = "";
		} 
		ModernizedCProgram.cdio_log_set_handler(log_handler);
		ModernizedCProgram.psz_extract_dir = dest_dir// Change progress style to marquee for scanning;// Change progress style to marquee for scanning
		if (ModernizedCProgram.scan_only) {
			ModernizedCProgram._uprintf("ISO analysis:");
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_PROGRESS_INIT, PBS_MARQUEE, 0);
			ModernizedCProgram.total_blocks = 0;
			ModernizedCProgram.has_ldlinux_c32 = 0;
			ModernizedCProgram.config_path.StrArrayCreate(8);
			ModernizedCProgram.isolinux_path.StrArrayCreate(8);
			ModernizedCProgram.PrintStatusInfo(1, 0, 0, 3202);
		} else {
				ModernizedCProgram._uprintf("Extracting files...\n");
				do {
					(Object)(ModernizedCProgram._chdirU(ModernizedCProgram.app_dir));
				} while (0);
				if (ModernizedCProgram.total_blocks == 0) {
					ModernizedCProgram._uprintf("Error: ISO has not been properly scanned.\n");
					ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | -1024);
					;
				} 
				ModernizedCProgram.nb_blocks = 0;
				ModernizedCProgram.iso_blocking_status = 0;
		} 
		// First try to open as UDF - fallback to ISO if it failed// First try to open as UDF - fallback to ISO if it failedp_udf = ModernizedCProgram.udf_open(src_iso);
		if (p_udf == ((Object)0)) {
			;
		} 
		ModernizedCProgram._uprintf("%sImage is an UDF image", spacing);
		p_udf_root = ModernizedCProgram.udf_get_root(p_udf, true, 0);
		if (p_udf_root == ((Object)0)) {
			ModernizedCProgram._uprintf("%sCould not locate UDF root directory", spacing);
			;
		} 
		if (ModernizedCProgram.scan_only) {
			if (ModernizedCProgram.udf_get_logical_volume_id(p_udf, ModernizedCProgram.img_report.getLabel(), /*Error: sizeof expression not supported yet*/) <= 0) {
				ModernizedCProgram.img_report.getLabel()[0] = 0;
			} 
			p_iso = ModernizedCProgram.iso9660_open(src_iso);
		} 
		r = ModernizedCProgram.udf_extract_files(p_udf, p_udf_root, "");
		;
		if (!ModernizedCProgram.enable_rockridge) {
			iso_extension_mask &=  ~ISO_EXTENSION_ROCK_RIDGE;
		} 
		p_iso = ModernizedCProgram.iso9660_open_ext(src_iso, iso_extension_mask);
		if (p_iso == ((Object)0)) {
			ModernizedCProgram._uprintf("%s'%s' doesn't look like an ISO image", spacing, src_iso);
			r = 1;
			;
		} 
		ModernizedCProgram._uprintf("%sImage is an ISO9660 image", spacing);
		ModernizedCProgram.joliet_level = ModernizedCProgram.iso9660_ifs_get_joliet_level(p_iso);
		if (ModernizedCProgram.scan_only) {
			if (ModernizedCProgram.iso9660_ifs_get_volume_id(p_iso, tmp)) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.img_report.getLabel(), tmp, (((size_t)(((((byte)tmp) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)tmp) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
					((byte)ModernizedCProgram.img_report.getLabel())[(((size_t)(((((byte)tmp) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)tmp) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(tmp)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)tmp);
					tmp = ((Object)0);
				} while (0);
			} else {
					ModernizedCProgram.img_report.getLabel()[0] = 0;
			} 
		} else {
				if (iso_extension_mask & (ISO_EXTENSION_JOLIET | ISO_EXTENSION_ROCK_RIDGE)) {
					ModernizedCProgram._uprintf("%sThis image will be extracted using %s extensions (if present)", spacing, (iso_extension_mask & ISO_EXTENSION_JOLIET) ? "Joliet" : "Rock Ridge");
				} else {
						ModernizedCProgram._uprintf("%sThis image will not be extracted using any ISO extensions", spacing);
				} 
		} 
		r = ModernizedCProgram.iso_extract_files(p_iso, "");
		Object generated__stat64 = stat.get__stat64();
		if (ModernizedCProgram.scan_only) {
			__stat64 stat = new __stat64();
			if ((ModernizedCProgram.iso9660_ifs_read_pvd(p_iso, pvd)) && (ModernizedCProgram._stat64U(src_iso, stat) == 0)) {
				ModernizedCProgram.img_report.setMismatch_size((int64_t)(ModernizedCProgram.iso9660_get_pvd_space_size(pvd)) * ISO_BLOCKSIZE - generated__stat64);
			} 
			for (j = ((((byte)ModernizedCProgram.img_report.getLabel()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getLabel())) - 1; ((j > 0) && (/*Error: Function owner not recognized*/isspace((byte)(ModernizedCProgram.img_report.getLabel()[j])))); j--) {
				ModernizedCProgram.img_report.getLabel()[j] = 0;
			}
			ModernizedCProgram.img_report.setProjected_size(ModernizedCProgram.total_blocks * ISO_BLOCKSIZE);
			if (!(ModernizedCProgram.config_path.getIndex() == 0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.img_report.getCfg_path(), (byte)'_', /*Error: sizeof expression not supported yet*/ - 1);
				ModernizedCProgram.img_report.getCfg_path()[/*Error: sizeof expression not supported yet*/ - 1] = 0;
				for (i = 0; i < ModernizedCProgram.config_path.getIndex(); i++) {
					if ((/*Error: Function owner not recognized*/_stricmp(ModernizedCProgram.config_path.getString()[i], "/boot/i386/loader/isolinux.cfg") == 0) || (/*Error: Function owner not recognized*/_stricmp(ModernizedCProgram.config_path.getString()[i], "/boot/x86_64/loader/isolinux.cfg") == 0)) {
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.img_report.getCfg_path(), ModernizedCProgram.config_path.getString()[i], (((size_t)(((((byte)ModernizedCProgram.config_path.getString()[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.config_path.getString()[i])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.config_path.getString()[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.config_path.getString()[i])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
							((byte)ModernizedCProgram.img_report.getCfg_path())[(((size_t)(((((byte)ModernizedCProgram.config_path.getString()[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.config_path.getString()[i])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.config_path.getString()[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.config_path.getString()[i])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
						} while (0);
						ModernizedCProgram.img_report.setNeeds_syslinux_overwrite(1);
						break;
					} 
					if (((((byte)ModernizedCProgram.img_report.getCfg_path()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getCfg_path())) >= ((((byte)ModernizedCProgram.config_path.getString()[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.config_path.getString()[i]))) {
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.img_report.getCfg_path(), ModernizedCProgram.config_path.getString()[i], (((size_t)(((((byte)ModernizedCProgram.config_path.getString()[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.config_path.getString()[i])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.config_path.getString()[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.config_path.getString()[i])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
							((byte)ModernizedCProgram.img_report.getCfg_path())[(((size_t)(((((byte)ModernizedCProgram.config_path.getString()[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.config_path.getString()[i])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.config_path.getString()[i]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.config_path.getString()[i])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
						} while (0);
					} 
				}
				ModernizedCProgram._uprintf("  Will use '%s' for Syslinux", ModernizedCProgram.img_report.getCfg_path());
				for (i = 0; i < ModernizedCProgram.isolinux_path.getIndex(); i++) {
					byte[] isolinux_tmp = new byte[260];
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(isolinux_tmp, /*Error: sizeof expression not supported yet*/, "%s\\isolinux.tmp", ModernizedCProgram.temp_dir);
						(isolinux_tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
					size = (size_t)ModernizedCProgram.ExtractISOFile(src_iso, ModernizedCProgram.isolinux_path.getString()[i], isolinux_tmp, -1024);
					if (size == 0) {
						ModernizedCProgram._uprintf("  Could not access %s", ModernizedCProgram.isolinux_path.getString()[i]);
					} else {
							buf = (byte)/*Error: Function owner not recognized*/calloc(size, 1);
							if (buf == ((Object)0)) {
								break;
							} 
							fd = /*Error: Function owner not recognized*/fopen(isolinux_tmp, "rb");
							if (fd == ((Object)0)) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buf);
								continue;
							} 
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fread(buf, 1, size, fd);
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
							sl_version = ModernizedCProgram.GetSyslinuxVersion(buf, size, ext);
							if (ModernizedCProgram.img_report.getSl_version() == 0) {
								do {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.img_report.getSl_version_ext(), ext, (((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
									((byte)ModernizedCProgram.img_report.getSl_version_ext())[(((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
								} while (0);
								ModernizedCProgram.img_report.setSl_version(sl_version);
								sl_index = i;
							}  else if ((ModernizedCProgram.img_report.getSl_version() != sl_version) || (/*Error: Function owner not recognized*/strcmp(((ModernizedCProgram.img_report.getSl_version_ext() == ((Object)0)) ? "<NULL>" : ModernizedCProgram.img_report.getSl_version_ext()), ((ext == ((Object)0)) ? "<NULL>" : ext)) != 0)) {
								ModernizedCProgram._uprintf("  Found conflicting isolinux versions:\n  '%s' (%d.%02d%s) vs '%s' (%d.%02d%s)", ModernizedCProgram.isolinux_path.getString()[sl_index], ((uint8_t)((ModernizedCProgram.img_report.getSl_version()) >> 8)), ((uint8_t)(ModernizedCProgram.img_report.getSl_version())), ModernizedCProgram.img_report.getSl_version_ext(), ModernizedCProgram.isolinux_path.getString()[i], ((uint8_t)((sl_version) >> 8)), ((uint8_t)(sl_version)), ext);
								for (j = ((((byte)ModernizedCProgram.img_report.getCfg_path()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getCfg_path())); (j > 0) && (ModernizedCProgram.img_report.getCfg_path()[j] != (byte)'/'); j--) {
									;
								}
								if (/*Error: Function owner not recognized*/_strnicmp(((ModernizedCProgram.img_report.getCfg_path() == ((Object)0)) ? "<NULL>" : ModernizedCProgram.img_report.getCfg_path()), ((ModernizedCProgram.isolinux_path.getString()[i] == ((Object)0)) ? "<NULL>" : ModernizedCProgram.isolinux_path.getString()[i]), j) == 0) {
									do {
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(ModernizedCProgram.img_report.getSl_version_ext(), ext, (((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
										((byte)ModernizedCProgram.img_report.getSl_version_ext())[(((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ext) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ext)) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
									} while (0);
									ModernizedCProgram.img_report.setSl_version(sl_version);
									sl_index = i;
								} 
							} 
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buf);
					} 
					ModernizedCProgram.DeleteFileU(isolinux_tmp);
				}
				if (ModernizedCProgram.img_report.getSl_version() != 0) {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.img_report.getSl_version_str(), /*Error: sizeof expression not supported yet*/, "%d.%02d", ((uint8_t)((ModernizedCProgram.img_report.getSl_version()) >> 8)), ((uint8_t)(ModernizedCProgram.img_report.getSl_version())));
						(ModernizedCProgram.img_report.getSl_version_str())[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
					ModernizedCProgram._uprintf("  Detected Syslinux version: %s%s (from '%s')", ModernizedCProgram.img_report.getSl_version_str(), ModernizedCProgram.img_report.getSl_version_ext(), ModernizedCProgram.isolinux_path.getString()[sl_index]);
					if ((ModernizedCProgram.has_ldlinux_c32 && (((uint8_t)((ModernizedCProgram.img_report.getSl_version()) >> 8)) < 5)) || (!ModernizedCProgram.has_ldlinux_c32 && (((uint8_t)((ModernizedCProgram.img_report.getSl_version()) >> 8)) >= 5))) {
						ModernizedCProgram._uprintf("  Warning: Conflict between Isolinux version and the presence of ldlinux.c32...");
					} 
				} else {
						ModernizedCProgram.img_report.setSl_version(ModernizedCProgram.embedded_sl_version[ModernizedCProgram.has_ldlinux_c32 ? 1 : 0]);
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(ModernizedCProgram.img_report.getSl_version_str(), /*Error: sizeof expression not supported yet*/, "%d.%02d", ((uint8_t)((ModernizedCProgram.img_report.getSl_version()) >> 8)), ((uint8_t)(ModernizedCProgram.img_report.getSl_version())));
							(ModernizedCProgram.img_report.getSl_version_str())[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
						} while (0);
						ModernizedCProgram._uprintf("  Warning: Could not detect Isolinux version - Forcing to %s (embedded)", ModernizedCProgram.img_report.getSl_version_str());
				} 
			} 
			if (!(ModernizedCProgram.img_report.getHas_efi() != 0) && (ModernizedCProgram.img_report.getEfi_img_path()[0] != 0) && ModernizedCProgram.HasEfiImgBootLoaders()) {
				ModernizedCProgram.img_report.setHas_efi(-1024);
			} 
			if ((((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) {
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(path, /*Error: sizeof expression not supported yet*/, "/%s/txtsetup.sif", basedir[((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) ? 0 : ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024 ? 1 : 2)]);
					(path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				ModernizedCProgram.ExtractISOFile(src_iso, path, tmp_sif, -1024);
				tmp = ModernizedCProgram.get_token_data_file_indexed("OsLoadOptions", tmp_sif, 1);
				if (tmp != ((Object)0)) {
					for (i = 0; i < /*Error: Function owner not recognized*/strlen(tmp); i++) {
						tmp[i] = (byte)/*Error: Function owner not recognized*/tolower(tmp[i]);
					}
					ModernizedCProgram._uprintf("  Checking txtsetup.sif:\n  OsLoadOptions = %s", tmp);
					ModernizedCProgram.img_report.setUses_minint((/*Error: Function owner not recognized*/strstr(tmp, "/minint") != ((Object)0)));
				} 
				ModernizedCProgram.DeleteFileU(tmp_sif);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)tmp);
					tmp = ((Object)0);
				} while (0);
			} 
			if ((ModernizedCProgram.img_report.getWininst_index() != 0)) {
				ModernizedCProgram.img_report.setWininst_version(ModernizedCProgram.GetInstallWimVersion(src_iso));
			} 
			if (ModernizedCProgram.img_report.getHas_grub2()) {
				ModernizedCProgram.img_report.getGrub2_version()[0] = 0;
				if ((ModernizedCProgram.GetTempPathU(/*Error: sizeof expression not supported yet*/, path) != 0) && (ModernizedCProgram.GetTempFileNameU(path, "Rufus", 0, path) != 0)) {
					size = (size_t)ModernizedCProgram.ExtractISOFile(src_iso, "boot/grub/i386-pc/normal.mod", path, -1024);
					buf = (byte)/*Error: Function owner not recognized*/calloc(size, 1);
					fd = /*Error: Function owner not recognized*/fopen(path, "rb");
					if ((size == 0) || (buf == ((Object)0)) || (fd == ((Object)0))) {
						ModernizedCProgram._uprintf("  Could not read Grub version from 'boot/grub/i386-pc/normal.mod'");
					} else {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fread(buf, 1, size, fd);
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
							ModernizedCProgram.GetGrubVersion(buf, size);
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buf);
					ModernizedCProgram.DeleteFileU(path);
				} 
				if (ModernizedCProgram.img_report.getGrub2_version()[0] != 0) {
					ModernizedCProgram._uprintf("  Detected Grub version: %s", ModernizedCProgram.img_report.getGrub2_version());
				} else {
						ModernizedCProgram._uprintf("  Could not detect Grub version");
						ModernizedCProgram.img_report.setHas_grub2(0);
				} 
			} 
			ModernizedCProgram.config_path.StrArrayDestroy();
			ModernizedCProgram.isolinux_path.StrArrayDestroy();
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMainDialog, user_message_type.UM_PROGRESS_EXIT, 0, 0);
		} else {
				if (ModernizedCProgram.img_report.getHas_efi() == -1024) {
					ModernizedCProgram.DumpFatDir(dest_dir, 0);
				} 
				if ((ModernizedCProgram.img_report.getSl_version() != 0)) {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(path, /*Error: sizeof expression not supported yet*/, "%s\\syslinux.cfg", dest_dir);
						(path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
					fd = /*Error: Function owner not recognized*/fopen(path, "r");
					if (fd != ((Object)0) && ModernizedCProgram.img_report.getNeeds_syslinux_overwrite()) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
						fd = ((Object)0);
						do {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(path2, /*Error: sizeof expression not supported yet*/, "%s\\syslinux.org", dest_dir);
							(path2)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
						} while (0);
						ModernizedCProgram._uprintf("Renaming: %s â %s", path, path2);
						do {
							(Object)(/*Error: Function owner not recognized*/rename(path, path2));
						} while (0);
					} 
					if (fd == ((Object)0)) {
						fd = /*Error: Function owner not recognized*/fopen(path, "w");
						if (fd == ((Object)0)) {
							ModernizedCProgram._uprintf("Unable to create %s - booting from USB will not work", path);
							r = 1;
						} else {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "DEFAULT loadconfig\n\nLABEL loadconfig\n  CONFIG %s\n", ModernizedCProgram.img_report.getCfg_path());
								for (i = ((((byte)ModernizedCProgram.img_report.getCfg_path()) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.img_report.getCfg_path())); (i > 0) && (ModernizedCProgram.img_report.getCfg_path()[i] != (byte)'/'); i--) {
									;
								}
								if (i > 0) {
									ModernizedCProgram.img_report.getCfg_path()[i] = 0;
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, "  APPEND %s/\n", ModernizedCProgram.img_report.getCfg_path());
									ModernizedCProgram.img_report.getCfg_path()[i] = (byte)'/';
								} 
								ModernizedCProgram._uprintf("Created: %s â %s", path, ModernizedCProgram.img_report.getCfg_path());
						} 
					} 
					if (fd != ((Object)0)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
					} 
				}  else if (((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) && ModernizedCProgram.enable_ntfs_compression) {
					ModernizedCProgram.RunCommand("compact /u bootmgr bootmgr.efi", dest_dir, 1);
				} 
		} 
		if (p_iso != ((Object)0)) {
			ModernizedCProgram.iso9660_close(p_iso);
		} 
		if (p_udf != ((Object)0)) {
			ModernizedCProgram.udf_close(p_udf);
		} 
		if ((r != 0) && (ModernizedCProgram.FormatStatus == 0)) {
			ModernizedCProgram.FormatStatus = -1024 | (3 << 16) | (-1024 | (ModernizedCProgram.scan_only ? -1024 : -1024));
		} 
		return (r == 0);
	}
	public static Object ExtractISOFile(Object iso, Object iso_file, Object dest_file, Object attributes) {
		size_t i = new size_t();
		size_t j = new size_t();
		ssize_t read_size = new ssize_t();
		int64_t file_length = new int64_t();
		int64_t extent_length = new int64_t();
		int64_t r = 0;
		byte[] buf = new byte[UDF_BLOCKSIZE];
		DWORD buf_size = new DWORD();
		DWORD wr_size = new DWORD();
		 p_iso = ((Object)0);
		 p_udf = ((Object)0);
		 p_udf_root = ((Object)0);
		 p_udf_file = ((Object)0);
		 p_statbuf = ((Object)0);
		 lsn = new ();
		HANDLE file_handle = (HANDLE)(true);
		file_handle = ModernizedCProgram.CreateFileU(dest_file, -1024 | -1024, -1024, ((Object)0), 2, attributes, ((Object)0));
		if (file_handle == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("  Could not create file %s: %s", dest_file, ModernizedCProgram.WindowsErrorString());
			;
		} 
		// First try to open as UDF - fallback to ISO if it failed// First try to open as UDF - fallback to ISO if it failedp_udf = ModernizedCProgram.udf_open(iso);
		if (p_udf == ((Object)0)) {
			;
		} 
		p_udf_root = ModernizedCProgram.udf_get_root(p_udf, true, 0);
		if (p_udf_root == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not locate UDF root directory");
			;
		} 
		p_udf_file = ModernizedCProgram.udf_fopen(p_udf_root, iso_file);
		if (!p_udf_file) {
			ModernizedCProgram._uprintf("Could not locate file %s in ISO image", iso_file);
			;
		} 
		file_length = ModernizedCProgram.udf_get_file_length(p_udf_file);
		while (file_length > 0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buf, 0, UDF_BLOCKSIZE);
			read_size = ModernizedCProgram.udf_read_block(p_udf_file, buf, 1);
			if (read_size < 0) {
				ModernizedCProgram._uprintf("Error reading UDF file %s", iso_file);
				;
			} 
			buf_size = (DWORD)(((file_length) < (read_size)) ? (file_length) : (read_size));
			if (!ModernizedCProgram.WriteFileWithRetry(file_handle, buf, buf_size, wr_size, 4)) {
				ModernizedCProgram._uprintf("  Error writing file %s: %s", dest_file, ModernizedCProgram.WindowsErrorString());
				;
			} 
			file_length -= read_size;
			r += read_size;
		}
		;
		if (p_iso == ((Object)0)) {
			ModernizedCProgram._uprintf("Unable to open image '%s'", iso);
			;
		} 
		p_statbuf = ModernizedCProgram.iso9660_ifs_stat_translate(p_iso, iso_file);
		if (p_statbuf == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not get ISO-9660 file information for file %s", iso_file);
			;
		} 
		for (j = 0; j < p_statbuf.getExtents(); j++) {
			extent_length = p_statbuf.getExtsize()[j];
			for (i = 0; extent_length > 0; i++) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buf, 0, ISO_BLOCKSIZE);
				lsn = p_statbuf.getLsn()[j] + ()i;
				if (ModernizedCProgram.iso9660_iso_seek_read(p_iso, buf, lsn, 1) != ISO_BLOCKSIZE) {
					ModernizedCProgram._uprintf("  Error reading ISO9660 file %s at LSN %lu", iso_file, (long)lsn);
					;
				} 
				buf_size = (DWORD)(((extent_length) < (ISO_BLOCKSIZE)) ? (extent_length) : (ISO_BLOCKSIZE));
				if (!ModernizedCProgram.WriteFileWithRetry(file_handle, buf, buf_size, wr_size, 4)) {
					ModernizedCProgram._uprintf("  Error writing file %s: %s", dest_file, ModernizedCProgram.WindowsErrorString());
					;
				} 
				extent_length -= ISO_BLOCKSIZE;
				r += ISO_BLOCKSIZE;
			}
		}
		if (p_statbuf != ((Object)0)) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)p_statbuf.getRr().getPsz_symlink());
				p_statbuf.getRr().setPsz_symlink(((Object)0));
			} while (0);
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)p_statbuf);
			p_statbuf = ((Object)0);
		} while (0);
		if (p_udf_root != ((Object)0)) {
			ModernizedCProgram.udf_dirent_free(p_udf_root);
		} 
		if (p_udf_file != ((Object)0)) {
			ModernizedCProgram.udf_dirent_free(p_udf_file);
		} 
		if (p_iso != ((Object)0)) {
			ModernizedCProgram.iso9660_close(p_iso);
		} 
		if (p_udf != ((Object)0)) {
			ModernizedCProgram.udf_close(p_udf);
		} 
		return r;
	}
	public static Object GetInstallWimVersion(Object iso) {
		byte wim_path = ((Object)0);
		byte p;
		byte[] buf = new byte[]{0};
		uint32_t wim_header = (uint32_t)buf;
		uint32_t r = -1024;
		 p_iso = ((Object)0);
		 p_udf = ((Object)0);
		 p_udf_root = ((Object)0);
		 p_udf_file = ((Object)0);
		 p_statbuf = ((Object)0);
		wim_path = /*Error: Function owner not recognized*/_strdup(ModernizedCProgram.img_report.getWininst_path()[0][2]);
		if (wim_path == ((Object)0)) {
			;
		} 
		// but ISO-9660 requires slashfor (p = wim_path; p != 0; p++) {
			if (p == (byte)'\\') {
				p = (byte)'/';
			} 
		}
		// First try to open as UDF - fallback to ISO if it failed// First try to open as UDF - fallback to ISO if it failedp_udf = ModernizedCProgram.udf_open(iso);
		if (p_udf == ((Object)0)) {
			;
		} 
		p_udf_root = ModernizedCProgram.udf_get_root(p_udf, true, 0);
		if (p_udf_root == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not locate UDF root directory");
			;
		} 
		p_udf_file = ModernizedCProgram.udf_fopen(p_udf_root, wim_path);
		if (!p_udf_file) {
			ModernizedCProgram._uprintf("Could not locate file %s in ISO image", wim_path);
			;
		} 
		if (ModernizedCProgram.udf_read_block(p_udf_file, buf, 1) != UDF_BLOCKSIZE) {
			ModernizedCProgram._uprintf("Error reading UDF file %s", wim_path);
			;
		} 
		r = wim_header[3];
		;
		if (p_iso == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not open image '%s'", iso);
			;
		} 
		p_statbuf = ModernizedCProgram.iso9660_ifs_stat_translate(p_iso, wim_path);
		if (p_statbuf == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not get ISO-9660 file information for file %s", wim_path);
			;
		} 
		if (ModernizedCProgram.iso9660_iso_seek_read(p_iso, buf, p_statbuf.getLsn()[0], 1) != ISO_BLOCKSIZE) {
			ModernizedCProgram._uprintf("Error reading ISO-9660 file %s at LSN %d", wim_path, p_statbuf.getLsn()[0]);
			;
		} 
		r = wim_header[3];
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)p_statbuf);
			p_statbuf = ((Object)0);
		} while (0);
		if (p_udf_root != ((Object)0)) {
			ModernizedCProgram.udf_dirent_free(p_udf_root);
		} 
		if (p_udf_file != ((Object)0)) {
			ModernizedCProgram.udf_dirent_free(p_udf_file);
		} 
		if (p_iso != ((Object)0)) {
			ModernizedCProgram.iso9660_close(p_iso);
		} 
		if (p_udf != ((Object)0)) {
			ModernizedCProgram.udf_close(p_udf);
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wim_path);
			wim_path = ((Object)0);
		} while (0);
		return /*Error: Function owner not recognized*/__builtin_bswap32(r);
	}
	public static int iso9660_readfat(Object pp, Object buf, Object secsize, Object sec) {
		iso9660_readfat_private p_private = (iso9660_readfat_private)pp;
		Object generatedBuf = p_private.getBuf();
		if (/*Error: sizeof expression not supported yet*/ % secsize != 0) {
			ModernizedCProgram._uprintf("iso9660_readfat: Sector size %d is not a divisor of %d", secsize, /*Error: sizeof expression not supported yet*/);
			return 0;
		} 
		Object generatedSec_start = p_private.getSec_start();
		Object generatedP_iso = p_private.getP_iso();
		Object generatedLsn = p_private.getLsn();
		if ((sec < generatedSec_start) || (sec >= generatedSec_start + /*Error: sizeof expression not supported yet*/ / secsize)) {
			p_private.setSec_start((((sec * secsize) / ISO_BLOCKSIZE) * ISO_BLOCKSIZE) / secsize);
			if (ModernizedCProgram.iso9660_iso_seek_read(generatedP_iso, generatedBuf, generatedLsn + /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME((generatedSec_start * secsize) / ISO_BLOCKSIZE), 16) != 16 * ISO_BLOCKSIZE) {
				ModernizedCProgram._uprintf("Error reading ISO-9660 file %s at LSN %lu\n", ModernizedCProgram.img_report.getEfi_img_path(), (long)(generatedLsn + (generatedSec_start * secsize) / ISO_BLOCKSIZE));
				return 0;
			} 
		} 
		// Sector being queried is not in our multi block buffer -> Update it
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(buf, generatedBuf[(sec - generatedSec_start) * secsize], secsize);
		return (int)secsize/*
		 * Returns TRUE if an EFI bootloader exists in the img.
		 */;
	}
	public static Object HasEfiImgBootLoaders() {
		BOOL ret = 0;
		 p_iso = ((Object)0);
		 p_statbuf = ((Object)0);
		iso9660_readfat_private p_private = ((Object)0);
		int32_t dc = new int32_t();
		int32_t c = new int32_t();
		libfat_filesystem lf_fs = ((Object)0);
		libfat_direntry direntry = new libfat_direntry();
		byte[] name = new byte[]{0};
		int i;
		int j;
		int k;
		if ((ModernizedCProgram.image_path == ((Object)0)) || !(ModernizedCProgram.img_report.getEfi_img_path()[0] != 0)) {
			return 0;
		} 
		p_iso = ModernizedCProgram.iso9660_open(ModernizedCProgram.image_path);
		if (p_iso == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not open image '%s' as an ISO-9660 file system", ModernizedCProgram.image_path);
			;
		} 
		p_statbuf = ModernizedCProgram.iso9660_ifs_stat_translate(p_iso, ModernizedCProgram.img_report.getEfi_img_path());
		if (p_statbuf == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not get ISO-9660 file information for file %s\n", ModernizedCProgram.img_report.getEfi_img_path());
			;
		} 
		p_private = /*Error: Function owner not recognized*/malloc(/*Error: Unsupported expression*/);
		if (p_private == ((Object)0)) {
			;
		} 
		p_private.setP_iso(p_iso);
		// Image should be small enough not to use multiextents// Image should be small enough not to use multiextentsp_private.setLsn(p_statbuf.getLsn()[0]);
		p_private.setSec_start(0)// Populate our intial buffer;// Populate our intial buffer
		Object generatedP_iso = p_private.getP_iso();
		Object generatedBuf = p_private.getBuf();
		Object generatedLsn = p_private.getLsn();
		if (ModernizedCProgram.iso9660_iso_seek_read(generatedP_iso, generatedBuf, generatedLsn, 16) != 16 * ISO_BLOCKSIZE) {
			ModernizedCProgram._uprintf("Error reading ISO-9660 file %s at LSN %lu\n", ModernizedCProgram.img_report.getEfi_img_path(), (long)generatedLsn);
			;
		} 
		libfat_filesystem libfat_filesystem = new libfat_filesystem();
		lf_fs = libfat_filesystem.libfat_open(iso9660_readfat, (intptr_t)p_private);
		if (lf_fs == ((Object)0)) {
			ModernizedCProgram._uprintf("FAT access error");
			;
		} 
		// Navigate to /EFI/BOOTif (ModernizedCProgram.libfat_searchdir(lf_fs, 0, "EFI        ", direntry) < 0) {
			;
		} 
		Object generatedEntry = direntry.getEntry();
		dc = generatedEntry[26] + (generatedEntry[27] << 8);
		if (ModernizedCProgram.libfat_searchdir(lf_fs, dc, "BOOT       ", direntry) < 0) {
			;
		} 
		dc = generatedEntry[26] + (generatedEntry[27] << 8);
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (/*Error: Function owner not recognized*/strlen(ModernizedCProgram.efi_bootname[i]) > 12) {
				ModernizedCProgram._uprintf("Internal error: FAT 8.3");
				continue;
			} 
			for (; ModernizedCProgram.efi_bootname[i][j] != 0; j++) {
				if (ModernizedCProgram.efi_bootname[i][j] == (byte)'.') {
					while (k < 8) {
						name[k++] = (byte)' ';
					}
				} else {
						name[k++] = /*Error: Function owner not recognized*/toupper(ModernizedCProgram.efi_bootname[i][j]);
				} 
			}
			c = ModernizedCProgram.libfat_searchdir(lf_fs, dc, name, direntry);
			if (c > 0) {
				if (!ret) {
					ModernizedCProgram._uprintf("  Detected EFI bootloader(s) (from '%s'):", ModernizedCProgram.img_report.getEfi_img_path());
				} 
				ModernizedCProgram._uprintf("  â? '%s'", ModernizedCProgram.efi_bootname[i]);
				ret = 1;
			} 
		}// Sanity check in case the EFI forum comes up with a 'bootmips64.efi' or something...
		if (p_statbuf != ((Object)0)) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)p_statbuf.getRr().getPsz_symlink());
				p_statbuf.getRr().setPsz_symlink(((Object)0));
			} while (0);
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)p_statbuf);
			p_statbuf = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)p_private);
			p_private = ((Object)0);
		} while (0);
		if (p_iso != ((Object)0)) {
			ModernizedCProgram.iso9660_close(p_iso);
		} 
		return ret;
	}
	public static Object DumpFatDir(Object path, Object cluster) {
		// We don't have concurrent calls to this function, so a static lf_fs is finelibfat_filesystem lf_fs = ((Object)0);
		Object buf;
		byte target = ((Object)0);
		byte name = ((Object)0);
		BOOL ret = 0;
		HANDLE handle = ((Object)0);
		DWORD size = new DWORD();
		DWORD written = new DWORD();
		libfat_diritem_t diritem = new libfat_diritem_t(0);
		libfat_dirpos_t dirpos = new libfat_dirpos_t(cluster, -1, 0);
		libfat_sector_t s = new libfat_sector_t();
		 p_iso = ((Object)0);
		 p_statbuf = ((Object)0);
		iso9660_readfat_private p_private = ((Object)0);
		if (path == ((Object)0)) {
			return -1;
		} 
		Object generatedP_iso = p_private.getP_iso();
		Object generatedBuf = p_private.getBuf();
		Object generatedLsn = p_private.getLsn();
		libfat_filesystem libfat_filesystem = new libfat_filesystem();
		if (cluster == 0) {
			if (ModernizedCProgram.image_path == ((Object)0)) {
				return 0;
			} 
			p_iso = ModernizedCProgram.iso9660_open(ModernizedCProgram.image_path);
			if (p_iso == ((Object)0)) {
				ModernizedCProgram._uprintf("Could not open image '%s' as an ISO-9660 file system", ModernizedCProgram.image_path);
				;
			} 
			p_statbuf = ModernizedCProgram.iso9660_ifs_stat_translate(p_iso, ModernizedCProgram.img_report.getEfi_img_path());
			if (p_statbuf == ((Object)0)) {
				ModernizedCProgram._uprintf("Could not get ISO-9660 file information for file %s\n", ModernizedCProgram.img_report.getEfi_img_path());
				;
			} 
			p_private = /*Error: Function owner not recognized*/malloc(/*Error: Unsupported expression*/);
			if (p_private == ((Object)0)) {
				;
			} 
			p_private.setP_iso(p_iso);
			p_private.setLsn(p_statbuf.getLsn()[0]);
			p_private.setSec_start(0);
			if (ModernizedCProgram.iso9660_iso_seek_read(generatedP_iso, generatedBuf, generatedLsn, 16) != 16 * ISO_BLOCKSIZE) {
				ModernizedCProgram._uprintf("Error reading ISO-9660 file %s at LSN %lu\n", ModernizedCProgram.img_report.getEfi_img_path(), (long)generatedLsn);
				;
			} 
			lf_fs = libfat_filesystem.libfat_open(iso9660_readfat, (intptr_t)p_private);
			if (lf_fs == ((Object)0)) {
				ModernizedCProgram._uprintf("FAT access error");
				;
			} 
		} 
		// Root dir => Perform init stuff
		Object generatedCluster = dirpos.getCluster();
		Object generatedName = diritem.getName();
		Object generatedAttributes = diritem.getAttributes();
		Object generatedSize = diritem.getSize();
		Object generatedIs_conf = props.getIs_conf();
		do {
			dirpos.setCluster(ModernizedCProgram.libfat_dumpdir(lf_fs, dirpos, diritem));
			if (generatedCluster >= 0) {
				name = ModernizedCProgram.wchar_to_utf8(generatedName);
				target = /*Error: Function owner not recognized*/malloc(/*Error: Function owner not recognized*/strlen(path) + ((((byte)name) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(name)) + 2);
				if ((name == ((Object)0)) || (target == ((Object)0))) {
					ModernizedCProgram._uprintf("Could not allocate buffer");
					;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(target, path);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcat(target, "\\");
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcat(target, name);
				if (generatedAttributes & -1024) {
					if (!ModernizedCProgram.CreateDirectoryU(target, 0) && (/*Error: Function owner not recognized*/GetLastError() != -1024)) {
						ModernizedCProgram._uprintf("Could not create directory '%s': %s\n", target, ModernizedCProgram.WindowsErrorString());
						continue;
					} 
					if (!ModernizedCProgram.DumpFatDir(target, generatedCluster)) {
						;
					} 
				} else {
						EXTRACT_PROPS props = new EXTRACT_PROPS(0);
						size_t len = /*Error: Function owner not recognized*/strlen(name);
						props.setIs_conf(((len > 4) && (/*Error: Function owner not recognized*/stricmp(name[len - 5], ".conf") == 0)));
						ModernizedCProgram._uprintf("Extracting: %s (from '%s', %s)", target, ModernizedCProgram.img_report.getEfi_img_path(), ModernizedCProgram.SizeToHumanReadable(generatedSize, 0, 0));
						handle = ModernizedCProgram.CreateFileU(target, -1024 | -1024, -1024, ((Object)0), 2, generatedAttributes, ((Object)0));
						if (handle == (HANDLE)(true)) {
							ModernizedCProgram._uprintf("Could not create '%s': %s", target, ModernizedCProgram.WindowsErrorString());
							continue;
						} 
						written = 0;
						s = ModernizedCProgram.libfat_clustertosector(lf_fs, generatedCluster);
						while ((s != 0) && (s < -1024) && (written < generatedSize)) {
							if (ModernizedCProgram.FormatStatus) {
								;
							} 
							buf = lf_fs.libfat_get_sector(s);
							size = (((ModernizedCProgram.LIBFAT_SECTOR_SIZE) < (generatedSize - written)) ? (ModernizedCProgram.LIBFAT_SECTOR_SIZE) : (generatedSize - written));
							if (!ModernizedCProgram.WriteFileWithRetry(handle, buf, size, size, 4) || (size != (((ModernizedCProgram.LIBFAT_SECTOR_SIZE) < (generatedSize - written)) ? (ModernizedCProgram.LIBFAT_SECTOR_SIZE) : (generatedSize - written)))) {
								ModernizedCProgram._uprintf("Could not write '%s': %s", target, ModernizedCProgram.WindowsErrorString());
								break;
							} 
							written += size;
							s = lf_fs.libfat_nextsector(s);
							lf_fs.libfat_flush();
						}
						do {
							if ((handle != (HANDLE)(true)) && (handle != ((Object)0))) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(handle);
								handle = (HANDLE)(true);
							} 
						} while (0);
						if (generatedIs_conf) {
							props.fix_config(target, ((Object)0), ((Object)0));
						} 
				} 
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)target);
					target = ((Object)0);
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)name);
					name = ((Object)0);
				} while (0);
			} 
		} while (generatedCluster >= 0);
		ret = 1;
		do {
			if ((handle != (HANDLE)(true)) && (handle != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(handle);
				handle = (HANDLE)(true);
			} 
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)name);
			name = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)target);
			target = ((Object)0);
		} while (0);
		return ret;// VirtDisk API Prototypes - Only available for Windows 8 or later
	}
	public static Byte MountISO(Object path) {
		 vtype = new (1, {-1024, -1024, -1024, new (-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024)});
		 vparams = new (0);
		DWORD r = new DWORD();
		wchar_t[] wtmp = new wchar_t();
		ULONG size = (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/);
		wchar_t wpath = ModernizedCProgram.utf8_to_wchar(path);
		byte ret = ((Object)0);
		do {
			if (ModernizedCProgram.pfOpenVirtualDisk == ((Object)0)) {
				ModernizedCProgram.pfOpenVirtualDisk = (OpenVirtualDisk_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("VirtDisk"), "OpenVirtualDisk");
			} 
			if (ModernizedCProgram.pfOpenVirtualDisk == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "OpenVirtualDisk", "VirtDisk", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfAttachVirtualDisk == ((Object)0)) {
				ModernizedCProgram.pfAttachVirtualDisk = (AttachVirtualDisk_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("VirtDisk"), "AttachVirtualDisk");
			} 
			if (ModernizedCProgram.pfAttachVirtualDisk == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "AttachVirtualDisk", "VirtDisk", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		do {
			if (ModernizedCProgram.pfGetVirtualDiskPhysicalPath == ((Object)0)) {
				ModernizedCProgram.pfGetVirtualDiskPhysicalPath = (GetVirtualDiskPhysicalPath_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("VirtDisk"), "GetVirtualDiskPhysicalPath");
			} 
			if (ModernizedCProgram.pfGetVirtualDiskPhysicalPath == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "GetVirtualDiskPhysicalPath", "VirtDisk", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		if ((ModernizedCProgram.mounted_handle != ((Object)0)) && (ModernizedCProgram.mounted_handle != (HANDLE)(true))) {
			ModernizedCProgram.UnMountISO();
		} 
		r = /*Error: Function owner not recognized*/pfOpenVirtualDisk(vtype, wpath, VIRTUAL_DISK_ACCESS_READ | VIRTUAL_DISK_ACCESS_GET_INFO, OPEN_VIRTUAL_DISK_FLAG_NONE, ((Object)0), ModernizedCProgram.mounted_handle);
		if (r != -1024) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(r);
			ModernizedCProgram._uprintf("Could not open ISO '%s': %s", path, ModernizedCProgram.WindowsErrorString());
			;
		} 
		vparams.setVersion(ATTACH_VIRTUAL_DISK_VERSION_1);
		r = /*Error: Function owner not recognized*/pfAttachVirtualDisk(ModernizedCProgram.mounted_handle, ((Object)0), ATTACH_VIRTUAL_DISK_FLAG_READ_ONLY | ATTACH_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER, 0, vparams, ((Object)0));
		if (r != -1024) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(r);
			ModernizedCProgram._uprintf("Could not mount ISO '%s': %s", path, ModernizedCProgram.WindowsErrorString());
			;
		} 
		r = /*Error: Function owner not recognized*/pfGetVirtualDiskPhysicalPath(ModernizedCProgram.mounted_handle, size, wtmp);
		if (r != -1024) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetLastError(r);
			ModernizedCProgram._uprintf("Could not obtain physical path for mounted ISO '%s': %s", path, ModernizedCProgram.WindowsErrorString());
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WideCharToMultiByte(65001, 0, wtmp, -1, ModernizedCProgram.physical_path, /*Error: sizeof expression not supported yet*/, ((Object)0), ((Object)0));
		ret = ModernizedCProgram.physical_path;
		do {
			if (wpath != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)(wpath));
				wpath = ((Object)0);
			} 
		} while (0);
		return ret;
	}
	public static void UnMountISO() {
		do {
			if (ModernizedCProgram.pfDetachVirtualDisk == ((Object)0)) {
				ModernizedCProgram.pfDetachVirtualDisk = (DetachVirtualDisk_t)/*Error: Function owner not recognized*/GetProcAddress(ModernizedCProgram.GetLibraryHandle("VirtDisk"), "DetachVirtualDisk");
			} 
			if (ModernizedCProgram.pfDetachVirtualDisk == ((Object)0)) {
				ModernizedCProgram._uprintf("Unable to locate %s() in %s.dll: %s\n", "DetachVirtualDisk", "VirtDisk", ModernizedCProgram.WindowsErrorString());
				;
			} 
		} while (0);
		if ((ModernizedCProgram.mounted_handle == ((Object)0)) || (ModernizedCProgram.mounted_handle == (HANDLE)(true))) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/pfDetachVirtualDisk(ModernizedCProgram.mounted_handle, DETACH_VIRTUAL_DISK_FLAG_NONE, 0);
		do {
			if ((ModernizedCProgram.mounted_handle != (HANDLE)(true)) && (ModernizedCProgram.mounted_handle != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(ModernizedCProgram.mounted_handle);
				ModernizedCProgram.mounted_handle = (HANDLE)(true);
			} 
		} while (0);
	}
	public static byte read8(Object _p) {
		return _p;
	}
	public static void write8(Object _p, Object _v) {
		_p = _v;
	}
	/* Littleendian architectures which support unaligned memory accesses */
	public static int read16(Object _p) {
		return ((uint16_t)_p);
	}
	public static void write16(Object _p, int _v) {
		((uint16_t)_p) = _v;
	}
	public static int read32(Object _p) {
		return ((uint32_t)_p);
	}
	public static void write32(Object _p, Object _v) {
		((uint32_t)_p) = _v/* Generic, mostly portable versions */;
	}
	/* ULINT_H */
	/*
	 * mkdir.c --- make a directory in the filesystem
	 *
	 * Copyright (C) 1994, 1995 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static Object ext2fs_mkdir(Object fs, Object parent, Object inum, Object name) {
		ext2_extent_handle_t handle = new ext2_extent_handle_t();
		 retval = new ();
		ext2_inode parent_inode = new ext2_inode();
		ext2_inode inode = new ext2_inode();
		 ino = inum;
		 scratch_ino = new ();
		 blk = new ();
		byte block = 0;
		int inline_data = 0;
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS/*
				 * Create a new dir with inline data iff this feature is enabled
				 * and ino >= EXT2_FIRST_INO.
				 */);
		} 
		if ((!ino || ino >= (((fs.getSuper()).getS_rev_level() == 0) ? 11 : (fs.getSuper()).getS_first_ino())) && fs.getSuper().ext2fs_has_feature_inline_data()) {
			inline_data = 1/*
				 * Allocate an inode, if necessary
				 */;
		} 
		if (!ino) {
			retval = ModernizedCProgram.ext2fs_new_inode(fs, parent, 40000 | 755, 0, ino);
			if (retval) {
				;
			} 
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(inode, 0, /*Error: Unsupported expression*//*
			 * Allocate a data block for the directory
			 */);
		if (!inline_data) {
			retval = ModernizedCProgram.ext2fs_new_block2(fs, inode.ext2fs_find_inode_goal(fs, ino, 0), ((Object)0), blk);
			if (retval) {
				;
			} 
		} 
		Object generatedI_block = inode.getI_block();
		if (/*
			 * Create a scratch template for the directory
			 */inline_data) {
			retval = ModernizedCProgram.ext2fs_new_dir_inline_data(fs, ino, parent, generatedI_block);
		} else {
				retval = ModernizedCProgram.ext2fs_new_dir_block(fs, ino, parent, block);
		} 
		if (retval) {
			;
		} 
		if (parent != ino) {
			retval = parent_inode.ext2fs_read_inode(fs, parent);
			if (retval) {
				;
			} 
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(parent_inode, 0, /*Error: sizeof expression not supported yet*/);
		} 
		inode.setI_mode(40000 | (777 & ~fs.getUmask()));
		inode.setI_uid(inode.setI_gid(0));
		Object generatedI_flags = inode.getI_flags();
		if (inline_data) {
			generatedI_flags |=  -1024;
			inode.setI_size(((/*Error: Unsupported expression*/ * (((12 + 1) + 1) + 1))));
		} else {
				if (fs.getSuper().ext2fs_has_feature_extents()) {
					generatedI_flags |=  -1024;
				} else {
						generatedI_block[0] = blk;
				} 
				inode.setI_size(fs.getBlocksize());
				inode.ext2fs_iblk_set(fs, 1);
		} 
		inode.setI_links_count(2/*
			 * Write out the inode and inode data block.  The inode generation
			 * number is assigned by write_new_inode, which means that the call
			 * to write_dir_block must come after that.
			 */);
		retval = inode.ext2fs_write_new_inode(fs, ino);
		if (retval) {
			;
		} 
		if (inline_data) {
			retval = ModernizedCProgram.ext2fs_inline_data_init(fs, /* init "system.data" for new dir */ino);
		} else {
				retval = ModernizedCProgram.ext2fs_write_dir_block4(fs, blk, block, 0, ino);
				if (retval) {
					;
				} 
				if (fs.getSuper().ext2fs_has_feature_extents()) {
					retval = inode.ext2fs_extent_open2(fs, ino, handle);
					if (retval) {
						;
					} 
					retval = ModernizedCProgram.ext2fs_extent_set_bmap(handle, 0, blk, 0);
					ModernizedCProgram.ext2fs_extent_free(handle);
					if (retval) {
						;
					} 
				} 
		} 
		if (/*
			 * Link the directory into the filesystem hierarchy
			 */name) {
			retval = ModernizedCProgram.ext2fs_lookup(fs, parent, name, /*Error: Function owner not recognized*/strlen(name), 0, scratch_ino);
			if (!retval) {
				retval = EXT2_ET_DIR_EXISTS;
				name = 0;
				;
			} 
			if (retval != EXT2_ET_FILE_NOT_FOUND) {
				;
			} 
			retval = ModernizedCProgram.ext2fs_link(fs, parent, name, ino, 2);
			if (retval) {
				;
			} 
		} 
		Object generatedI_links_count = parent_inode.getI_links_count();
		if (parent != /*
			 * Update parent inode's counts
			 */ino) {
			retval = /* reload parent inode due to inline data */parent_inode.ext2fs_read_inode(fs, parent);
			if (retval) {
				;
			} 
			generatedI_links_count++;
			retval = parent_inode.ext2fs_write_inode(fs, parent);
			if (retval) {
				;
			} 
		} 
		if (!/*
			 * Update accounting....
			 */inline_data) {
			ModernizedCProgram.ext2fs_block_alloc_stats2(fs, blk, +1);
		} 
		ModernizedCProgram.ext2fs_inode_alloc_stats2(fs, ino, +1, 1);
		return retval;
	}
	/*
	  Copyright (C) 2005, 2008, 2011, 2012 Rocky Bernstein <rocky@gnu.org>
	
	  This program is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  This program is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/
	/** \file read.h
	 *
	 * \brief sector (block, frame)-related libcdio routines.
	 */
	/* Care is used in the expression below to be correct with */
	/* respect to unsigned integers.                           */
	/*!
	  lseek - reposition read/write file offset
	  Returns (off_t) -1 on error.
	  Similar to (if not the same as) libc's lseek()
	*/
	public static Object cdio_lseek(Object p_cdio, Object offset, int whence) {
		if (!p_cdio) {
			return DRIVER_OP_UNINIT;
		} 
		if (p_cdio.getOp().getLseek()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), offset, whence);
		} 
		return DRIVER_OP_UNSUPPORTED/*!  Reads into buf the next size bytes.  Similar to (if not the
		  same as) libc's read(). This is a "cooked" read, or one handled by
		  the OS. It probably won't work on audio data. For that use
		  cdio_read_audio_sector(s).
		
		  @param p_cdio object to read from
		  @param p_buf place to read data into. The caller should make sure
		               this location can store at least i_size bytes.
		  @param i_size number of bytes to read
		
		  @return (ssize_t) -1 on error.
		*/;
	}
	public static Object cdio_read(Object p_cdio, Object p_buf, Object i_size) {
		if (!p_cdio) {
			return DRIVER_OP_UNINIT;
		} 
		if (p_cdio.getOp().getRead()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), p_buf, i_size);
		} 
		return DRIVER_OP_UNSUPPORTED/*!
		  Reads an audio sector from cd device into data starting
		  from lsn. Returns DRIVER_OP_SUCCESS if no error.
		*/;
	}
	public static Object cdio_read_audio_sector(Object p_cdio, Object p_buf, Object i_lsn) {
		if (!p_cdio) {
			return DRIVER_OP_UNINIT;
		} 
		if (!p_buf || CDIO_INVALID_LSN == i_lsn) {
			return DRIVER_OP_ERROR;
		} 
		;
		{ 
			 end_lsn = ModernizedCProgram.cdio_get_track_lsn(p_cdio, CDIO_CDROM_LEADOUT_TRACK);
			if (i_lsn > end_lsn) {
				ModernizedCProgram.cdio_info("Trying to access past end of disk lsn: %ld, end lsn: %ld", (long)i_lsn, (long)end_lsn);
				return DRIVER_OP_ERROR;
			} 
		}
		;
		if (p_cdio.getOp().getRead_audio_sectors()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), p_buf, i_lsn, 1);
		} 
		return DRIVER_OP_UNSUPPORTED/*!
		  Reads audio sectors from cd device into data starting
		  from lsn. Returns DRIVER_OP_SUCCESS if no error.
		*/;
	}
	public static Object cdio_read_audio_sectors(Object p_cdio, Object p_buf, Object i_lsn, Object i_blocks) {
		if (!p_cdio) {
			return DRIVER_OP_UNINIT;
		} 
		if (!p_buf || CDIO_INVALID_LSN == i_lsn) {
			return DRIVER_OP_ERROR;
		} 
		;
		{ 
			 end_lsn = ModernizedCProgram.cdio_get_track_lsn(p_cdio, CDIO_CDROM_LEADOUT_TRACK);
			if (i_lsn > end_lsn) {
				ModernizedCProgram.cdio_info("Trying to access past end of disk lsn: %ld, end lsn: %ld", (long)i_lsn, (long)end_lsn);
				return DRIVER_OP_ERROR;
			} 
			if (i_lsn + i_blocks > end_lsn + 1) {
				ModernizedCProgram.cdio_info("Request truncated to end disk; lsn: %ld, end lsn: %ld", (long)i_lsn, (long)end_lsn);
				i_blocks = end_lsn - i_lsn + 1;
			} 
		}
		;
		if (0 == i_blocks) {
			return DRIVER_OP_SUCCESS;
		} 
		if (p_cdio.getOp().getRead_audio_sectors()) {
			ModernizedCProgram.cdio_debug("Reading audio sector(s) lsn %u for %d blocks", i_lsn, i_blocks);
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), p_buf, i_lsn, i_blocks);
		} 
		return DRIVER_OP_UNSUPPORTED/*!
		  Reads an audio sector from cd device into data starting
		  from lsn. Returns DRIVER_OP_SUCCESS if no error.
		*/;
	}
	public static Object cdio_read_data_sectors(Object p_cdio, Object p_buf, Object i_lsn, Object i_blocksize, Object i_blocks) {
		if (!p_cdio) {
			return DRIVER_OP_UNINIT;
		} 
		if (!p_buf || CDIO_INVALID_LSN == i_lsn) {
			return DRIVER_OP_ERROR;
		} 
		;
		{ 
			 end_lsn = ModernizedCProgram.cdio_get_track_lsn(p_cdio, CDIO_CDROM_LEADOUT_TRACK);
			if (i_lsn > end_lsn) {
				ModernizedCProgram.cdio_info("Trying to access past end of disk lsn: %ld, end lsn: %ld", (long)i_lsn, (long)end_lsn);
				return DRIVER_OP_ERROR;
			} 
		}
		;
		if (0 == i_blocks) {
			return DRIVER_OP_SUCCESS;
		} 
		if (p_cdio.getOp().getRead_data_sectors()) {
			ModernizedCProgram.cdio_debug("Reading data sector(s) lsn, %u blocksize %d, for %d blocks", i_lsn, i_blocksize, i_blocks);
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), p_buf, i_lsn, i_blocksize, i_blocks);
		} 
		return DRIVER_OP_UNSUPPORTED;
	}
	/*!
	   Reads a single mode1 form1 or form2  sector from cd device
	   into data starting from lsn. Returns DRIVER_OP_SUCCESS if no error.
	 */
	public static Object cdio_read_mode1_sector(Object p_cdio, Object p_buf, Object i_lsn, Object b_form2) {
		 size = b_form2 ? M2RAW_SECTOR_SIZE : CDIO_CD_FRAMESIZE;
		if (!p_cdio) {
			return DRIVER_OP_UNINIT;
		} 
		if (!p_buf || CDIO_INVALID_LSN == i_lsn) {
			return DRIVER_OP_ERROR;
		} 
		;
		{ 
			 end_lsn = ModernizedCProgram.cdio_get_track_lsn(p_cdio, CDIO_CDROM_LEADOUT_TRACK);
			if (i_lsn > end_lsn) {
				ModernizedCProgram.cdio_info("Trying to access past end of disk lsn: %ld, end lsn: %ld", (long)i_lsn, (long)end_lsn);
				return DRIVER_OP_ERROR;
			} 
		}
		;
		if (p_cdio.getOp().getRead_mode1_sector()) {
			ModernizedCProgram.cdio_debug("Reading mode 1 secto lsn %u", i_lsn);
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), p_buf, i_lsn, b_form2);
		}  else if (p_cdio.getOp().getLseek() && p_cdio.getOp().getRead()) {
			byte[] buf = new byte[]{0};
			if (0 > ModernizedCProgram.cdio_lseek(p_cdio, CDIO_CD_FRAMESIZE * i_lsn, 0)) {
				return -1;
			} 
			if (0 > ModernizedCProgram.cdio_read(p_cdio, buf, CDIO_CD_FRAMESIZE)) {
				return -1;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(p_buf, buf, size);
			return DRIVER_OP_SUCCESS;
		} 
		return DRIVER_OP_UNSUPPORTED/*!
		  Reads mode 1 sectors
		
		  @param p_cdio object to read from
		  @param buf place to read data into
		  @param lsn sector to read
		  @param b_form2 true for reading mode 1 form 2 sectors or false for
		  mode 1 form 1 sectors.
		  @param i_blocks number of sectors to read
		*/;
	}
	public static Object cdio_read_mode1_sectors(Object p_cdio, Object p_buf, Object i_lsn, Object b_form2, Object i_blocks) {
		if (!p_cdio) {
			return DRIVER_OP_UNINIT;
		} 
		if (!p_buf || CDIO_INVALID_LSN == i_lsn) {
			return DRIVER_OP_ERROR;
		} 
		;
		{ 
			 end_lsn = ModernizedCProgram.cdio_get_track_lsn(p_cdio, CDIO_CDROM_LEADOUT_TRACK);
			if (i_lsn > end_lsn) {
				ModernizedCProgram.cdio_info("Trying to access past end of disk lsn: %ld, end lsn: %ld", (long)i_lsn, (long)end_lsn);
				return DRIVER_OP_ERROR;
			} 
			if (i_lsn + i_blocks > end_lsn + 1) {
				ModernizedCProgram.cdio_info("Request truncated to end disk; lsn: %ld, end lsn: %ld", (long)i_lsn, (long)end_lsn);
				i_blocks = end_lsn - i_lsn + 1;
			} 
		}
		;
		if (0 == i_blocks) {
			return DRIVER_OP_SUCCESS;
		} 
		if (p_cdio.getOp().getRead_mode1_sectors()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), p_buf, i_lsn, b_form2, i_blocks);
		} 
		return DRIVER_OP_UNSUPPORTED/*!
		  Reads a mode 2 sector
		
		  @param p_cdio object to read from
		  @param buf place to read data into
		  @param lsn sector to read
		  @param b_form2 true for reading mode 2 form 2 sectors or false for
		  mode 2 form 1 sectors.
		*/;
	}
	public static Object cdio_read_mode2_sector(Object p_cdio, Object p_buf, Object i_lsn, Object b_form2) {
		if (!p_cdio) {
			return DRIVER_OP_UNINIT;
		} 
		if (!p_buf || CDIO_INVALID_LSN == i_lsn) {
			return DRIVER_OP_ERROR;
		} 
		;
		{ 
			 end_lsn = ModernizedCProgram.cdio_get_track_lsn(p_cdio, CDIO_CDROM_LEADOUT_TRACK);
			if (i_lsn > end_lsn) {
				ModernizedCProgram.cdio_info("Trying to access past end of disk lsn: %ld, end lsn: %ld", (long)i_lsn, (long)end_lsn);
				return DRIVER_OP_ERROR;
			} 
		}
		;
		if (p_cdio.getOp().getRead_mode2_sector()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), p_buf, i_lsn, b_form2);
		} 
		if (p_cdio.getOp().getRead_mode2_sectors() != /* fallback */NULL) {
			return ModernizedCProgram.cdio_read_mode2_sectors(p_cdio, p_buf, i_lsn, b_form2, 1);
		} 
		return DRIVER_OP_UNSUPPORTED/*!
		  Reads mode 2 sectors
		
		  @param p_cdio object to read from
		  @param buf place to read data into
		  @param lsn sector to read
		  @param b_form2 true for reading mode2 form 2 sectors or false for
		  mode 2  form 1 sectors.
		  @param i_blocks number of sectors to read
		*/;
	}
	public static Object cdio_read_mode2_sectors(Object p_cdio, Object p_buf, Object i_lsn, Object b_form2, Object i_blocks) {
		if (!p_cdio) {
			return DRIVER_OP_UNINIT;
		} 
		if (!p_buf || CDIO_INVALID_LSN == i_lsn) {
			return DRIVER_OP_ERROR;
		} 
		;
		{ 
			 end_lsn = ModernizedCProgram.cdio_get_track_lsn(p_cdio, CDIO_CDROM_LEADOUT_TRACK);
			if (i_lsn > end_lsn) {
				ModernizedCProgram.cdio_info("Trying to access past end of disk lsn: %ld, end lsn: %ld", (long)i_lsn, (long)end_lsn);
				return DRIVER_OP_ERROR;
			} 
			if (i_lsn + i_blocks > end_lsn + 1) {
				ModernizedCProgram.cdio_info("Request truncated to end disk; lsn: %ld, end lsn: %ld", (long)i_lsn, (long)end_lsn);
				i_blocks = end_lsn - i_lsn + 1;
			} 
		}
		;
		if (0 == i_blocks) {
			return DRIVER_OP_SUCCESS;
		} 
		if (p_cdio.getOp().getRead_mode2_sectors()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(p_cdio.getEnv(), p_buf, i_lsn, b_form2, i_blocks);
		} 
		return DRIVER_OP_UNSUPPORTED;
	}
	/** The special case of reading a single block is a common one so we
	    provide a routine for that as a convenience.
	*/
	public static Object cdio_read_sector(Object p_cdio, Object p_buf, Object i_lsn, Object read_mode) {
		return ModernizedCProgram.cdio_read_sectors(p_cdio, p_buf, i_lsn, read_mode, 1/*!
		  Reads a number of sectors (AKA blocks).
		
		  @param p_buf place to read data into. The caller should make sure
		  this location is large enough. See below for size information.
		  @param read_mode the kind of "mode" to use in reading.
		  @param i_lsn sector to read
		  @param i_blocks number of sectors to read
		  @return DRIVER_OP_SUCCESS (0) if no error, other (negative) enumerations
		  are returned on error.
		
		  If read_mode is CDIO_MODE_AUDIO,
		    *p_buf should hold at least CDIO_FRAMESIZE_RAW * i_blocks bytes.
		
		  If read_mode is CDIO_MODE_DATA,
		    *p_buf should hold at least i_blocks times either ISO_BLOCKSIZE,
		    M1RAW_SECTOR_SIZE or M2F2_SECTOR_SIZE depending on the kind of
		    sector getting read. If you don't know whether you have a Mode 1/2,
		    Form 1/ Form 2/Formless sector best to reserve space for the maximum
		    which is M2RAW_SECTOR_SIZE.
		
		  If read_mode is CDIO_MODE_M2F1,
		    *p_buf should hold at least M2RAW_SECTOR_SIZE * i_blocks bytes.
		
		  If read_mode is CDIO_MODE_M2F2,
		    *p_buf should hold at least CDIO_CD_FRAMESIZE * i_blocks bytes.
		
		
		*/);
	}
	public static Object cdio_read_sectors(Object p_cdio, Object p_buf, Object i_lsn, Object read_mode, Object i_blocks) {
		switch (read_mode) {
		case CDIO_READ_MODE_M2F2:
				return ModernizedCProgram.cdio_read_mode2_sectors(p_cdio, p_buf, i_lsn, true, i_blocks);
		case CDIO_READ_MODE_AUDIO:
				return ModernizedCProgram.cdio_read_audio_sectors(p_cdio, p_buf, i_lsn, i_blocks);
		case CDIO_READ_MODE_M1F1:
				return ModernizedCProgram.cdio_read_mode1_sectors(p_cdio, p_buf, i_lsn, false, i_blocks);
		case CDIO_READ_MODE_M2F1:
				return ModernizedCProgram.cdio_read_mode2_sectors(p_cdio, p_buf, i_lsn, false, i_blocks);
		case CDIO_READ_MODE_M1F2:
				return ModernizedCProgram.cdio_read_mode1_sectors(p_cdio, p_buf, i_lsn, true, i_blocks);
		}
		return /* Can't happen. Just to shut up gcc. */DRIVER_OP_ERROR/*
		 * Local variables:
		 *  c-file-style: "gnu"
		 *  tab-width: 8
		 *  indent-tabs-mode: nil
		 * End:
		 */;
	}
	/*
	 * mkjournal.c --- make a journal for a filesystem
	 *
	 * Copyright (C) 2000 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/*
	 * This function automatically sets up the journal superblock and
	 * returns it as an allocated block.
	 */
	public static Object ext2fs_create_journal_superblock(Object fs, Object num_blocks, int flags, Byte ret_jsb) {
		 retval = new ();
		journal_superblock_t jsb = new journal_superblock_t();
		if (num_blocks < 1024) {
			return EXT2_ET_JOURNAL_TOO_SMALL;
		} 
		if ((retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), jsb))) {
			return retval;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(jsb, 0, fs.getBlocksize());
		journal_header_s generatedS_header = jsb.getS_header();
		generatedS_header.setH_magic(/*Error: Function owner not recognized*/_byteswap_ulong(-1024));
		if (flags & -1024) {
			generatedS_header.setH_blocktype(/*Error: Function owner not recognized*/_byteswap_ulong(3));
		} else {
				generatedS_header.setH_blocktype(/*Error: Function owner not recognized*/_byteswap_ulong(4));
		} 
		jsb.setS_blocksize(/*Error: Function owner not recognized*/_byteswap_ulong(fs.getBlocksize()));
		jsb.setS_maxlen(/*Error: Function owner not recognized*/_byteswap_ulong(num_blocks));
		jsb.setS_nr_users(/*Error: Function owner not recognized*/_byteswap_ulong(1));
		jsb.setS_first(/*Error: Function owner not recognized*/_byteswap_ulong(1));
		jsb.setS_sequence(/*Error: Function owner not recognized*/_byteswap_ulong(1));
		Object generatedS_uuid = jsb.getS_uuid();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedS_uuid, generatedS_uuid, /*Error: sizeof expression not supported yet*/);
		if (fs.getSuper().ext2fs_has_feature_journal_dev()) {
			jsb.setS_nr_users(0);
			jsb.setS_first(/*Error: Function owner not recognized*/_byteswap_ulong(ModernizedCProgram.ext2fs_journal_sb_start(fs.getBlocksize()) + 1));
		} 
		ret_jsb = (byte)jsb;
		return 0/*
		 * This function writes a journal using POSIX routines.  It is used
		 * for creating external journals and creating journals on live
		 * filesystems.
		 */;
	}
	public static Object write_journal_file(Object fs, Byte filename, Object num_blocks, int flags) {
		 retval = new ();
		byte buf = 0;
		int fd;
		int ret_size;
		 i = new ();
		if ((retval = ModernizedCProgram.ext2fs_create_journal_superblock(fs, num_blocks, flags, buf))) {
			return retval;
		} 
		if ((fd = /*Error: Function owner not recognized*/open(filename, 1)) < /* Open the device or journal file */0) {
			retval = (/*Error: Function owner not recognized*/_errno());
			;
		} 
		retval = /* Write the superblock out */EXT2_ET_SHORT_WRITE;
		ret_size = /*Error: Function owner not recognized*/write(fd, buf, fs.getBlocksize());
		if (ret_size < 0) {
			retval = (/*Error: Function owner not recognized*/_errno());
			;
		} 
		if (ret_size != (int)fs.getBlocksize()) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buf, 0, fs.getBlocksize());
		if (flags & -1024) {
			;
		} 
		for (i = 1; i < num_blocks; i++) {
			ret_size = /*Error: Function owner not recognized*/write(fd, buf, fs.getBlocksize());
			if (ret_size < 0) {
				retval = (/*Error: Function owner not recognized*/_errno());
				;
			} 
			if (ret_size != (int)fs.getBlocksize()) {
				;
			} 
		}
		return retval/*
		 * Convenience function which zeros out _num_ blocks starting at
		 * _blk_.  In case of an error, the details of the error is returned
		 * via _ret_blk_ and _ret_count_ if they are non-NULL pointers.
		 * Returns 0 on success, and an error code on an error.
		 *
		 * As a special case, if the first argument is NULL, then it will
		 * attempt to free the static zeroizing buffer.  (This is to keep
		 * programs that check for memory leaks happy.)
		 */;
	}
	public static Object ext2fs_zero_blocks2(Object fs, Object blk, int num, Object ret_blk, Integer ret_count) {
		int j;
		int count;
		Object buf;
		int stride_length = 0;
		 retval = new ();
		if (!/* If fs is null, clean up the static buffer and return */fs) {
			if (buf) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(buf);
				buf = 0;
				stride_length = 0;
			} 
			return 0;
		} 
		if (num <= /* Deal with zeroing less than 1 block */0) {
			return 0;
		} 
		retval = ModernizedCProgram.io_channel_zeroout(fs.getIo(), blk, /* Try a zero out command, if supported */num);
		if (retval == 0) {
			return 0;
		} 
		if (num > stride_length && stride_length < (4194304 / (int)fs.getBlocksize())) {
			Object p;
			int new_stride = num;
			if (new_stride > (4194304 / (int)fs.getBlocksize())) {
				new_stride = (4194304 / (int)fs.getBlocksize());
			} 
			p = /*Error: Function owner not recognized*/realloc(buf, fs.getBlocksize() * new_stride);
			if (!p) {
				return EXT2_ET_NO_MEMORY;
			} 
			buf = p;
			stride_length = new_stride;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(buf, 0, fs.getBlocksize() * stride_length);
		} 
		j = /* OK, do the write loop */0;
		while (j < num) {
			if (blk % stride_length) {
				count = stride_length - (blk % stride_length);
				if (count > (num - j)) {
					count = num - j;
				} 
			} else {
					count = num - j;
					if (count > stride_length) {
						count = stride_length;
					} 
			} 
			retval = ModernizedCProgram.io_channel_write_blk64(fs.getIo(), blk, count, buf);
			if (retval) {
				if (ret_count) {
					ret_count = count;
				} 
				if (ret_blk) {
					ret_blk = blk;
				} 
				return retval;
			} 
			j += count;
			blk += count;
		}
		return 0;
	}
	public static Object ext2fs_zero_blocks(Object fs, Object blk, int num, Object ret_blk, Integer ret_count) {
		 ret_blk2 = new ();
		 retval = new ();
		retval = ModernizedCProgram.ext2fs_zero_blocks2(fs, blk, num, ret_blk2, ret_count);
		if (retval) {
			ret_blk = ()ret_blk2;
		} 
		return retval/*
		 * Calculate the initial goal block to be roughly at the middle of the
		 * filesystem.  Pick a group that has the largest number of free
		 * blocks.
		 */;
	}
	public static Object get_midpoint_journal_block(Object fs) {
		 group = new ();
		 start = new ();
		 end = new ();
		 i = new ();
		 log_flex = new ();
		group = ModernizedCProgram.ext2fs_group_of_blk2(fs, (fs.getSuper().ext2fs_blocks_count() - fs.getSuper().getS_first_data_block()) / 2);
		log_flex = 1 << fs.getSuper().getS_log_groups_per_flex();
		if (fs.getSuper().getS_log_groups_per_flex() && (group > log_flex)) {
			group = group & ~(log_flex - 1);
			while ((group < fs.getGroup_desc_count()) && ModernizedCProgram.ext2fs_bg_free_blocks_count(fs, group) == 0) {
				group++;
			}
			if (group == fs.getGroup_desc_count()) {
				group = 0;
			} 
			start = group;
		} else {
				start = (group > 0) ? group - 1 : group;
		} 
		end = ((group + 1) < fs.getGroup_desc_count()) ? group + 1 : group;
		group = start;
		for (i = start + 1; i <= end; i++) {
			if (ModernizedCProgram.ext2fs_bg_free_blocks_count(fs, i) > ModernizedCProgram.ext2fs_bg_free_blocks_count(fs, group)) {
				group = i;
			} 
		}
		return ModernizedCProgram.ext2fs_group_first_block2(fs, group/*
		 * This function creates a journal using direct I/O routines.
		 */);
	}
	public static Object write_journal_inode(Object fs, Object journal_ino, Object num_blocks, Object goal, int flags) {
		byte buf;
		 retval = new ();
		ext2_inode inode = new ext2_inode();
		long inode_size;
		int falloc_flags = (true);
		 zblk = new ();
		if ((retval = ModernizedCProgram.ext2fs_create_journal_superblock(fs, num_blocks, flags, buf))) {
			return retval;
		} 
		if ((retval = ModernizedCProgram.ext2fs_read_bitmaps(fs))) {
			;
		} 
		if ((retval = inode.ext2fs_read_inode(fs, journal_ino))) {
			;
		} 
		Object generatedI_blocks = inode.getI_blocks();
		if (generatedI_blocks > 0) {
			retval = 17;
			;
		} 
		if (goal == ~-1024) {
			goal = ModernizedCProgram.get_midpoint_journal_block(fs);
		} 
		Object generatedI_flags = inode.getI_flags();
		if (fs.getSuper().ext2fs_has_feature_extents()) {
			generatedI_flags |=  -1024;
		} 
		if (!(flags & -1024)) {
			falloc_flags |=  (true);
		} 
		inode_size = (long)fs.getBlocksize() * num_blocks;
		inode.setI_mtime(inode.setI_ctime(fs.getNow() ? fs.getNow() : /*Error: Function owner not recognized*/time(0)));
		inode.setI_links_count(1);
		inode.setI_mode(100000 | 600);
		retval = inode.ext2fs_inode_size_set(fs, inode_size);
		if (retval) {
			;
		} 
		retval = inode.ext2fs_fallocate(fs, falloc_flags, journal_ino, goal, 0, num_blocks);
		if (retval) {
			;
		} 
		if ((retval = inode.ext2fs_write_new_inode(fs, journal_ino))) {
			;
		} 
		retval = inode.ext2fs_bmap2(fs, journal_ino, ((Object)0), 0, 0, ((Object)0), zblk);
		if (retval) {
			;
		} 
		retval = ModernizedCProgram.io_channel_write_blk64(fs.getIo(), zblk, 1, buf);
		if (retval) {
			;
		} 
		Object generatedI_block = inode.getI_block();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(fs.getSuper().getS_jnl_blocks(), generatedI_block, (((12 + 1) + 1) + 1) * 4);
		Object generatedI_size_high = inode.getI_size_high();
		fs.getSuper().getS_jnl_blocks()[15] = generatedI_size_high;
		Object generatedI_size = inode.getI_size();
		fs.getSuper().getS_jnl_blocks()[16] = generatedI_size;
		fs.getSuper().setS_jnl_backup_type(1);
		ModernizedCProgram.ext2fs_mark_super_dirty(fs);
		return retval/*
		 * Find a reasonable journal file size (in blocks) given the number of blocks
		 * in the filesystem.  For very small filesystems, it is not reasonable to
		 * have a journal that fills more than half of the filesystem.
		 *
		 * n.b. comments assume 4k blocks
		 */;
	}
	public static int ext2fs_default_journal_size(Object num_blocks) {
		if (num_blocks < 2048) {
			return -1;
		} 
		if (num_blocks < /* 128 MB */32768) {
			return (/* 4 MB */true);
		} 
		if (num_blocks < 256 * /* 1 GB */1024) {
			return (/* 16 MB */true);
		} 
		if (num_blocks < 512 * /* 2 GB */1024) {
			return (/* 32 MB */true);
		} 
		if (num_blocks < 4096 * /* 16 GB */1024) {
			return (/* 64 MB */true);
		} 
		if (num_blocks < 8192 * /* 32 GB */1024) {
			return (/* 128 MB */true);
		} 
		if (num_blocks < 16384 * /* 64 GB */1024) {
			return (/* 256 MB */true);
		} 
		if (num_blocks < 32768 * /* 128 GB */1024) {
			return (/* 512 MB */true);
		} 
		return /* 1 GB */262144;
	}
	public static int ext2fs_journal_sb_start(int blocksize) {
		if (blocksize == (1 << 10)) {
			return 2;
		} 
		return 1/*
		 * This function adds a journal device to a filesystem
		 */;
	}
	public static Object ext2fs_add_journal_device(Object fs, Object journal_dev) {
		stat st = new stat();
		 retval = new ();
		byte[] buf = new byte[1024];
		journal_superblock_t jsb = new journal_superblock_t();
		int start;
		 i = new ();
		 nr_users = new ();
		if (/*Error: Function owner not recognized*/stat(journal_dev.getDevice_name(), st) < /* Make sure the device exists and is a block device */0) {
			return (/*Error: Function owner not recognized*/_errno());
		} 
		Object generatedSt_mode = st.getSt_mode();
		if (!(((generatedSt_mode) & -1024) == -1024)) {
			return /* Must be a block device */EXT2_ET_JOURNAL_NOT_BLOCK;
		} 
		start = ModernizedCProgram.ext2fs_journal_sb_start(journal_dev.getBlocksize());
		if ((retval = ModernizedCProgram.io_channel_read_blk64(journal_dev.getIo(), start, -1024, buf))) {
			return retval;
		} 
		jsb = (journal_superblock_t)buf;
		journal_header_s generatedS_header = jsb.getS_header();
		Object generatedH_magic = generatedS_header.getH_magic();
		Object generatedH_blocktype = generatedS_header.getH_blocktype();
		if ((generatedH_magic != (int)/*Error: Function owner not recognized*/_byteswap_ulong(-1024)) || (generatedH_blocktype != (int)/*Error: Function owner not recognized*/_byteswap_ulong(4))) {
			return EXT2_ET_NO_JOURNAL_SB;
		} 
		Object generatedS_blocksize = jsb.getS_blocksize();
		if (/*Error: Function owner not recognized*/_byteswap_ulong(generatedS_blocksize) != (long)fs.getBlocksize()) {
			return EXT2_ET_UNEXPECTED_BLOCK_SIZE;
		} 
		Object generatedS_nr_users = jsb.getS_nr_users();
		nr_users = /*Error: Function owner not recognized*/_byteswap_ulong(generatedS_nr_users);
		if (nr_users > 48) {
			return EXT2_ET_CORRUPT_JOURNAL_SB;
		} 
		Object generatedS_users = jsb.getS_users();
		for (i = 0; i < nr_users; i++) {
			if (/*Error: Function owner not recognized*/memcmp(fs.getSuper().getS_uuid(), generatedS_users[i * 16], 16) == 0) {
				break;
			} 
		}
		if (i >= nr_users) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedS_users[nr_users * 16], fs.getSuper().getS_uuid(), 16);
			jsb.setS_nr_users(/*Error: Function owner not recognized*/_byteswap_ulong(nr_users + 1));
		} 
		if ((retval = ModernizedCProgram.io_channel_write_blk64(journal_dev.getIo(), /* Writeback the journal superblock */start, -1024, buf))) {
			return retval;
		} 
		fs.getSuper().setS_journal_inum(0);
		Object generatedSt_rdev = st.getSt_rdev();
		fs.getSuper().setS_journal_dev(generatedSt_rdev);
		Object generatedS_uuid = jsb.getS_uuid();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(fs.getSuper().getS_journal_uuid(), generatedS_uuid, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(fs.getSuper().getS_jnl_blocks(), 0, /*Error: sizeof expression not supported yet*/);
		fs.getSuper().ext2fs_set_feature_journal();
		ModernizedCProgram.ext2fs_mark_super_dirty(fs);
		return 0/*
		 * This function adds a journal inode to a filesystem, using either
		 * POSIX routines if the filesystem is mounted, or using direct I/O
		 * functions if it is not.
		 */;
	}
	public static Object ext2fs_add_journal_inode2(Object fs, Object num_blocks, Object goal, int flags) {
		 retval = new ();
		 journal_ino = new ();
		stat st = new stat();
		byte[] jfile = new byte[1024];
		int mount_flags;
		int fd = -1;
		if (flags & -1024) {
			mount_flags = 0;
		}  else if ((retval = ModernizedCProgram.ext2fs_check_mount_point(fs.getDevice_name(), mount_flags, jfile, /*Error: sizeof expression not supported yet*/ - 10))) {
			return retval;
		} 
		Object generatedSt_ino = st.getSt_ino();
		if (mount_flags & 1) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcat(jfile, "/.journal"/*
					 * If .../.journal already exists, make sure any
					 * immutable or append-only flags are cleared.
					 */);
			if ((fd = /*Error: Function owner not recognized*/open(jfile, -1024 | 1, 600)) < /* Create the journal file */0) {
				return (/*Error: Function owner not recognized*/_errno());
			} 
			flags &=  ~-1024;
			if ((retval = ModernizedCProgram.write_journal_file(fs, jfile, num_blocks, flags))) {
				;
			} 
			if (/*Error: Function owner not recognized*/fstat(fd, st) < /* Get inode number of the journal file */0) {
				retval = (/*Error: Function owner not recognized*/_errno());
				;
			} 
			if (retval) {
				retval = (/*Error: Function owner not recognized*/_errno());
				;
			} 
			if (/*Error: Function owner not recognized*/close(fd) < 0) {
				retval = (/*Error: Function owner not recognized*/_errno());
				fd = -1;
				;
			} 
			journal_ino = generatedSt_ino;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(fs.getSuper().getS_jnl_blocks(), 0, /*Error: sizeof expression not supported yet*/);
		} else {
				if ((mount_flags & 16) && !(fs.getFlags() & -1024)) {
					retval = 16;
					;
				} 
				journal_ino = 8;
				if ((retval = ModernizedCProgram.write_journal_inode(fs, journal_ino, num_blocks, goal, flags))) {
					return retval;
				} 
		} 
		fs.getSuper().setS_journal_inum(journal_ino);
		fs.getSuper().setS_journal_dev(0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(fs.getSuper().getS_journal_uuid(), 0, /*Error: sizeof expression not supported yet*/);
		fs.getSuper().ext2fs_set_feature_journal();
		ModernizedCProgram.ext2fs_mark_super_dirty(fs);
		return 0;
		return retval;
	}
	public static Object ext2fs_add_journal_inode(Object fs, Object num_blocks, int flags) {
		return ModernizedCProgram.ext2fs_add_journal_inode2(fs, num_blocks, ~-1024, flags);
	}
	/******************************************************************
	    Copyright (C) 2009  Henrik Carlqvist
	
	    This program is free software; you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation; either version 2 of the License, or
	    (at your option) any later version.
	
	    This program is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with this program; if not, write to the Free Software
	    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
	******************************************************************/
	public static int write_partition_number_of_heads(int iHeads) {
		byte[] aucBuf = new byte[2];
		int s = (int)iHeads;
		if (!s) {
			return 0/* Converting a number like this is not necessary as long as we are on
			      i386 compatible CPUs, however, the following code might make the program
			      more portable... */;
		} 
		aucBuf[0] = (byte)(s & -1024);
		aucBuf[1] = (byte)((s & -1024) >> 8);
		return fp.write_data(-1024, aucBuf, 2/* write_partition_number_of_heads */);
	}
	public static int write_partition_start_sector_number(int iStartSector) {
		byte[] aucBuf = new byte[4];
		long l = (long)iStartSector;
		if (!l) {
			return 0/* Converting a number like this is not necessary as long as we are on
			      i386 compatible CPUs, however, the following code might make the program
			      more portable... */;
		} 
		aucBuf[0] = (byte)(l & -1024);
		aucBuf[1] = (byte)((l & -1024) >> 8);
		aucBuf[2] = (byte)((l & -1024) >> 16);
		aucBuf[3] = (byte)((l & -1024) >> 24);
		return fp.write_data(-1024, aucBuf, 4/* write_partition_start_sector_number */);
	}
	public static int write_partition_physical_disk_drive_id_fat32() {
		byte ucId = /* C: */-1024;
		return fp.write_data(-1024, ucId, 1/* write_partition_physical_disk_drive_id_fat32 */);
	}
	public static int write_partition_physical_disk_drive_id_fat16() {
		byte ucId = /* C: */-1024;
		return fp.write_data(-1024, ucId, 1/* write_partition_physical_disk_drive_id_fat16 */);
	}
	/*
	 * rw_bitmaps.c --- routines to read and write the  inode and block bitmaps.
	 *
	 * Copyright (C) 1993, 1994, 1994, 1996 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static Object write_bitmaps(Object fs, int do_inode, int do_block) {
		 i = new ();
		int j;
		int block_nbytes;
		int inode_nbytes;
		int nbits;
		 retval = new ();
		byte block_buf = ((Object)0);
		byte inode_buf = ((Object)0);
		int csum_flag;
		 blk = new ();
		 blk_itr = ((fs.getSuper().getS_first_data_block()) >> (fs).getCluster_ratio_bits());
		 ino_itr = 1;
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		if (!(fs.getFlags() & -1024)) {
			return EXT2_ET_RO_FILSYS;
		} 
		csum_flag = ModernizedCProgram.ext2fs_has_group_desc_csum(fs);
		inode_nbytes = block_nbytes = 0;
		if (do_block) {
			block_nbytes = ((fs.getSuper()).getS_clusters_per_group()) / 8;
			retval = ModernizedCProgram.io_channel_alloc_buf(fs.getIo(), 0, block_buf);
			if (retval) {
				;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(block_buf, -1024, fs.getBlocksize());
		} 
		if (do_inode) {
			inode_nbytes = (size_t)((((fs.getSuper()).getS_inodes_per_group()) + 7) / 8);
			retval = ModernizedCProgram.io_channel_alloc_buf(fs.getIo(), 0, inode_buf);
			if (retval) {
				;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(inode_buf, -1024, fs.getBlocksize());
		} 
		if (do_block) {
			fs.getFlags() &=  ~-1024;
			ModernizedCProgram.ext2fs_free_mem(block_buf);
		} 
		if (do_inode) {
			fs.getFlags() &=  ~-1024;
			ModernizedCProgram.ext2fs_free_mem(inode_buf);
		} 
		return 0;
		if (block_buf) {
			ModernizedCProgram.ext2fs_free_mem(block_buf);
		} 
		return retval;
	}
	public static Object mark_uninit_bg_group_blocks(Object fs) {
		 i = new ();
		 blk = new ();
		ext2fs_block_bitmap bmap = fs.getBlock_map();
		for (i = 0; i < fs.getGroup_desc_count(); i++) {
			if (!ModernizedCProgram.ext2fs_bg_flags_test(fs, i, -1024)) {
				continue;
			} 
			ModernizedCProgram.ext2fs_reserve_super_and_bgd(fs, i, bmap/*
					 * Mark the blocks used for the inode table
					 */);
			blk = ModernizedCProgram.ext2fs_inode_table_loc(fs, i);
			if (blk) {
				ModernizedCProgram.ext2fs_mark_block_bitmap_range2(bmap, blk, fs.getInode_blocks_per_group());
			} 
			blk = ModernizedCProgram.ext2fs_block_bitmap_loc(fs, i);
			if (blk) {
				ModernizedCProgram.ext2fs_mark_block_bitmap2(bmap, blk/*
						 * Mark block used for the inode bitmap
						 */);
			} 
			blk = ModernizedCProgram.ext2fs_inode_bitmap_loc(fs, i);
			if (blk) {
				ModernizedCProgram.ext2fs_mark_block_bitmap2(bmap, blk);
			} 
		}
		return 0;
	}
	public static Object read_bitmaps(Object fs, int do_inode, int do_block) {
		 i = new ();
		byte block_bitmap = 0;
		byte inode_bitmap = 0;
		byte buf;
		 retval = new ();
		int block_nbytes = ((fs.getSuper()).getS_clusters_per_group()) / 8;
		int inode_nbytes = ((fs.getSuper()).getS_inodes_per_group()) / 8;
		int csum_flag;
		int cnt;
		 blk = new ();
		 blk_itr = ((fs.getSuper().getS_first_data_block()) >> (fs).getCluster_ratio_bits());
		 blk_cnt = new ();
		 ino_itr = 1;
		 ino_cnt = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		if ((block_nbytes > (int)fs.getBlocksize()) || (inode_nbytes > (int)fs.getBlocksize())) {
			return EXT2_ET_CORRUPT_SUPERBLOCK;
		} 
		fs.setWrite_bitmaps(ModernizedCProgram.ext2fs_write_bitmaps);
		csum_flag = ModernizedCProgram.ext2fs_has_group_desc_csum(fs);
		retval = ModernizedCProgram.ext2fs_get_mem(/*Error: Function owner not recognized*/strlen(fs.getDevice_name()) + 80, buf);
		if (retval) {
			return retval;
		} 
		if (do_block) {
			if (fs.getBlock_map()) {
				ModernizedCProgram.ext2fs_free_block_bitmap(fs.getBlock_map());
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(buf, "block bitmap for ");
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcat(buf, fs.getDevice_name());
			retval = ModernizedCProgram.ext2fs_allocate_block_bitmap(fs, buf, fs.getBlock_map());
			if (retval) {
				;
			} 
			retval = ModernizedCProgram.io_channel_alloc_buf(fs.getIo(), 0, block_bitmap);
			if (retval) {
				;
			} 
		} else {
				block_nbytes = 0;
		} 
		if (do_inode) {
			if (fs.getInode_map()) {
				ModernizedCProgram.ext2fs_free_inode_bitmap(fs.getInode_map());
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(buf, "inode bitmap for ");
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcat(buf, fs.getDevice_name());
			retval = ModernizedCProgram.ext2fs_allocate_inode_bitmap(fs, buf, fs.getInode_map());
			if (retval) {
				;
			} 
			retval = ModernizedCProgram.io_channel_alloc_buf(fs.getIo(), 0, inode_bitmap);
			if (retval) {
				;
			} 
		} else {
				inode_nbytes = 0;
		} 
		ModernizedCProgram.ext2fs_free_mem(buf);
		if (fs.getFlags() & -1024) {
			blk = (/*Error: Function owner not recognized*/ext2fs_le32_to_cpu(fs.getImage_header().getExt2_image_hdr()) / fs.getBlocksize());
			ino_cnt = fs.getSuper().getS_inodes_count();
			while (inode_bitmap && ino_cnt > 0) {
				retval = ModernizedCProgram.io_channel_read_blk64(fs.getImage_io(), blk++, 1, inode_bitmap);
				if (retval) {
					;
				} 
				cnt = fs.getBlocksize() << 3;
				if (cnt > ino_cnt) {
					cnt = ino_cnt;
				} 
				retval = ModernizedCProgram.ext2fs_set_inode_bitmap_range2(fs.getInode_map(), ino_itr, cnt, inode_bitmap);
				if (retval) {
					;
				} 
				ino_itr += cnt;
				ino_cnt -= cnt;
			}
			blk = (/*Error: Function owner not recognized*/ext2fs_le32_to_cpu(fs.getImage_header().getExt2_image_hdr()) / fs.getBlocksize());
			blk_cnt = (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME((fs.getSuper()).getS_clusters_per_group()) * (fs.getGroup_desc_count()));
			while (block_bitmap && blk_cnt > 0) {
				retval = ModernizedCProgram.io_channel_read_blk64(fs.getImage_io(), blk++, 1, block_bitmap);
				if (retval) {
					;
				} 
				cnt = fs.getBlocksize() << 3;
				if (cnt > blk_cnt) {
					cnt = blk_cnt;
				} 
				retval = ModernizedCProgram.ext2fs_set_block_bitmap_range2(fs.getBlock_map(), blk_itr, cnt, block_bitmap);
				if (retval) {
					;
				} 
				blk_itr += cnt;
				blk_cnt -= cnt;
			}
			;
		} 
		for (i = 0; i < fs.getGroup_desc_count(); i++) {
			if (block_bitmap) {
				blk = ModernizedCProgram.ext2fs_block_bitmap_loc(fs, i);
				if (csum_flag && ModernizedCProgram.ext2fs_bg_flags_test(fs, i, -1024) && ModernizedCProgram.ext2fs_group_desc_csum_verify(fs, i)) {
					blk = 0;
				} 
				if (blk) {
					retval = ModernizedCProgram.io_channel_read_blk64(fs.getIo(), blk, 1, block_bitmap);
					if (retval) {
						retval = EXT2_ET_BLOCK_BITMAP_READ;
						;
					} 
					if (!(fs.getFlags() & -1024) && !ModernizedCProgram.ext2fs_block_bitmap_csum_verify(fs, i, block_bitmap, block_nbytes)) {
						retval = EXT2_ET_BLOCK_BITMAP_CSUM_INVALID;
						;
					} 
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(block_bitmap, 0, block_nbytes);
				} 
				cnt = block_nbytes << 3;
				retval = ModernizedCProgram.ext2fs_set_block_bitmap_range2(fs.getBlock_map(), blk_itr, cnt, block_bitmap);
				if (retval) {
					;
				} 
				blk_itr += block_nbytes << 3;
			} 
			if (inode_bitmap) {
				blk = ModernizedCProgram.ext2fs_inode_bitmap_loc(fs, i);
				if (csum_flag && ModernizedCProgram.ext2fs_bg_flags_test(fs, i, -1024) && ModernizedCProgram.ext2fs_group_desc_csum_verify(fs, i)) {
					blk = 0;
				} 
				if (blk) {
					retval = ModernizedCProgram.io_channel_read_blk64(fs.getIo(), blk, 1, inode_bitmap);
					if (retval) {
						retval = EXT2_ET_INODE_BITMAP_READ;
						;
					} 
					if (!(fs.getFlags() & -1024) && !ModernizedCProgram.ext2fs_inode_bitmap_csum_verify(fs, i, inode_bitmap, inode_nbytes)) {
						retval = EXT2_ET_INODE_BITMAP_CSUM_INVALID;
						;
					} 
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(inode_bitmap, 0, inode_nbytes);
				} 
				cnt = inode_nbytes << 3;
				retval = ModernizedCProgram.ext2fs_set_inode_bitmap_range2(fs.getInode_map(), ino_itr, cnt, inode_bitmap);
				if (retval) {
					;
				} 
				ino_itr += inode_nbytes << 3;
			} 
		}
		if (/* Mark group blocks for any BLOCK_UNINIT groups */do_block) {
			retval = ModernizedCProgram.mark_uninit_bg_group_blocks(fs);
			if (retval) {
				;
			} 
		} 
		if (block_bitmap) {
			ModernizedCProgram.ext2fs_free_mem(block_bitmap);
		} 
		return 0;
		if (do_inode) {
			ModernizedCProgram.ext2fs_free_mem(fs.getInode_map());
			fs.setInode_map(0);
		} 
		if (inode_bitmap) {
			ModernizedCProgram.ext2fs_free_mem(inode_bitmap);
		} 
		if (block_bitmap) {
			ModernizedCProgram.ext2fs_free_mem(block_bitmap);
		} 
		if (buf) {
			ModernizedCProgram.ext2fs_free_mem(buf);
		} 
		return retval;
	}
	public static Object ext2fs_read_inode_bitmap(Object fs) {
		return ModernizedCProgram.read_bitmaps(fs, 1, 0);
	}
	public static Object ext2fs_read_block_bitmap(Object fs) {
		return ModernizedCProgram.read_bitmaps(fs, 0, 1);
	}
	public static Object ext2fs_write_inode_bitmap(Object fs) {
		return ModernizedCProgram.write_bitmaps(fs, 1, 0);
	}
	public static Object ext2fs_write_block_bitmap(Object fs) {
		return ModernizedCProgram.write_bitmaps(fs, 0, 1);
	}
	public static Object ext2fs_read_bitmaps(Object fs) {
		if (fs.getInode_map() && fs.getBlock_map()) {
			return 0;
		} 
		return ModernizedCProgram.read_bitmaps(fs, !fs.getInode_map(), !fs.getBlock_map());
	}
	public static Object ext2fs_write_bitmaps(Object fs) {
		int do_inode = fs.getInode_map() && ModernizedCProgram.ext2fs_test_ib_dirty(fs);
		int do_block = fs.getBlock_map() && ModernizedCProgram.ext2fs_test_bb_dirty(fs);
		if (!do_inode && !do_block) {
			return 0;
		} 
		return ModernizedCProgram.write_bitmaps(fs, do_inode, do_block);
	}
	public static int mark_bad_block(Object fs, Object block_nr, Object blockcnt, Object ref_block, int ref_offset, Object priv_data) {
		read_bb_record rb = (read_bb_record)priv_data;
		if (blockcnt < 0) {
			return 0;
		} 
		if ((block_nr < fs.getSuper().getS_first_data_block()) || (block_nr >= fs.getSuper().ext2fs_blocks_count())) {
			return /* Ignore illegal blocks */0;
		} 
		Object generatedBb_list = rb.getBb_list();
		rb.setErr(/*Error: Function owner not recognized*/ext2fs_badblocks_list_add(generatedBb_list, block_nr));
		Object generatedErr = rb.getErr();
		if (generatedErr) {
			return 2;
		} 
		return 0/*
		 * Reads the current bad blocks from the bad blocks inode.
		 */;
	}
	public static Object ext2fs_read_bb_inode(Object fs, Object bb_list) {
		 retval = new ();
		read_bb_record rb = new read_bb_record();
		ext2_inode inode = new ext2_inode();
		 numblocks = new ();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		Object generatedI_blocks = inode.getI_blocks();
		Object generatedI_flags = inode.getI_flags();
		if (!bb_list) {
			retval = inode.ext2fs_read_inode(fs, 1);
			if (retval) {
				return retval;
			} 
			numblocks = generatedI_blocks;
			if (!(fs.getSuper().ext2fs_has_feature_huge_file() && (generatedI_flags & -1024))) {
				numblocks = numblocks / (fs.getBlocksize() / 512);
			} 
			numblocks += 20;
			if (numblocks < 50) {
				numblocks = 50;
			} 
			if (numblocks > 50000) {
				numblocks = 500;
			} 
			retval = /*Error: Function owner not recognized*/ext2fs_badblocks_list_create(bb_list, numblocks);
			if (retval) {
				return retval;
			} 
		} 
		rb.setBb_list(bb_list);
		rb.setErr(0);
		retval = ModernizedCProgram.ext2fs_block_iterate2(fs, 1, 8, 0, mark_bad_block, rb);
		if (retval) {
			return retval;
		} 
		Object generatedErr = rb.getErr();
		return generatedErr;
	}
	/* we found CDE! */
	/*
			 * I've seen .ZIP files with seemingly valid CDEs
			 * where cdf_offset points past EOF - ??
			 * Ignore such CDEs:
			 */
	public static void unzip_skip(int zip_fd, Object skip) {
		if (skip != 0) {
			if (/*Error: Function owner not recognized*/lseek(zip_fd, skip, 1) == (off_t)-1) {
				do {
					if (ModernizedCProgram.bled_printf != ((Object)0)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/bled_printf("Error: Not implemented");
					} else {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("Error: Not implemented");
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putchar((byte)'\n');
					} 
				} while (0);
			} 
		} 
	}
	public static int libfat_readfile(Object pp, Object buf, Object secsize, Object sector) {
		LARGE_INTEGER offset = new LARGE_INTEGER();
		DWORD bytes_read = new DWORD();
		offset.setQuadPart((LONGLONG)sector * secsize);
		Object generatedQuadPart = offset.getQuadPart();
		if (!/*Error: Function owner not recognized*/SetFilePointerEx((HANDLE)pp, offset, ((Object)0), 0)) {
			ModernizedCProgram._uprintf("Could not set pointer to position %llu: %s", generatedQuadPart, ModernizedCProgram.WindowsErrorString());
			return 0;
		} 
		if (!/*Error: Function owner not recognized*/ReadFile((HANDLE)pp, buf, (DWORD)secsize, bytes_read, ((Object)0))) {
			ModernizedCProgram._uprintf("Could not read sector %llu: %s", sector, ModernizedCProgram.WindowsErrorString());
			return 0;
		} 
		if (bytes_read != secsize) {
			ModernizedCProgram._uprintf("Sector %llu: Read %d bytes instead of %d requested", sector, bytes_read, secsize);
			return 0;
		} 
		return (int)secsize/*
		 * Extract the ldlinux.sys and ldlinux.bss from resources,
		 * then patch and install them
		 */;
	}
	public static Object InstallSyslinux(Object drive_index, byte drive_letter, int file_system) {
		LARGE_INTEGER liZero = new LARGE_INTEGER(new LARGE_INTEGER(0, 0));
		HANDLE f_handle = (HANDLE)(true);
		HANDLE d_handle = (HANDLE)(true);
		DWORD bytes_read = new DWORD();
		DWORD bytes_written = new DWORD();
		DWORD err = new DWORD();
		S_NTFSSECT_VOLINFO vol_info = new S_NTFSSECT_VOLINFO(0);
		LARGE_INTEGER vcn = new LARGE_INTEGER();
		LARGE_INTEGER lba = new LARGE_INTEGER();
		LARGE_INTEGER len = new LARGE_INTEGER();
		S_NTFSSECT_EXTENT extent = new S_NTFSSECT_EXTENT();
		BOOL r = 0;
		FILE fd = new FILE();
		size_t length = new size_t();
		byte sectbuf = ((Object)0);
		byte[][] resource = new byte[][]{{(LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)(true)))}, {(LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)(true)))}};
		byte ldlinux = "ldlinux";
		byte syslinux = "syslinux";
		byte[] ldlinux_ext = new byte[]{"sys", "bss", "c32"};
		byte mboot_c32 = "mboot.c32";
		byte[] path = new byte[260];
		byte[] tmp = new byte[64];
		byte errmsg;
		libfat_filesystem lf_fs = new libfat_filesystem();
		libfat_sector_t s = new libfat_sector_t();
		libfat_sector_t secp = new libfat_sector_t();
		libfat_sector_t sectors = ((Object)0);
		int ldlinux_sectors;
		uint32_t ldlinux_cluster = new uint32_t();
		int i;
		int nsectors;
		int sl_fs_stype;
		BOOL use_v5 = (ModernizedCProgram.boot_type == boot_type.BT_SYSLINUX_V6) || ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (((uint8_t)((ModernizedCProgram.img_report.getSl_version()) >> 8)) >= 5));
		ModernizedCProgram.PrintStatusInfo(1, 1, 0, 3234, (ModernizedCProgram.boot_type == boot_type.BT_IMAGE) ? ModernizedCProgram.img_report.getSl_version_str() : ModernizedCProgram.embedded_sl_version_str[use_v5 ? 1 : 0]);
		ModernizedCProgram.SECTOR_SHIFT = /* 4K sector size workaround */0;
		ModernizedCProgram.SECTOR_SIZE = ModernizedCProgram.SelectedDrive.getSectorSize();
		while (ModernizedCProgram.SECTOR_SIZE >>=  1) {
			ModernizedCProgram.SECTOR_SHIFT++;
		}
		ModernizedCProgram.SECTOR_SIZE = ModernizedCProgram.SelectedDrive.getSectorSize();
		ModernizedCProgram.LIBFAT_SECTOR_SHIFT = ModernizedCProgram.SECTOR_SHIFT;
		ModernizedCProgram.LIBFAT_SECTOR_SIZE = ModernizedCProgram.SECTOR_SIZE;
		ModernizedCProgram.LIBFAT_SECTOR_MASK = ModernizedCProgram.SECTOR_SIZE - 1;
		sectbuf = /*Error: Function owner not recognized*/_mm_malloc(ModernizedCProgram.SECTOR_SIZE, /* sectbuf should be aligned to at least 8 bytes - see github #767 */16);
		if (sectbuf == ((Object)0)) {
			;
		} 
		d_handle = ModernizedCProgram.GetLogicalHandle(drive_index, 0, 0, 1, 1);
		if ((d_handle == (HANDLE)(true)) || (d_handle == ((Object)0))) {
			ModernizedCProgram._uprintf("Could open volume for Syslinux installation");
			;
		} 
		if (!/*Error: Function owner not recognized*/ReadFile(d_handle, sectbuf, ModernizedCProgram.SECTOR_SIZE, bytes_read, ((Object)/* Make sure we can read the boot sector (NB: Re-open already set us to offset 0) */0))) {
			ModernizedCProgram._uprintf("Could not read VBR");
			;
		} 
		if (bytes_read != ModernizedCProgram.SECTOR_SIZE) {
			ModernizedCProgram._uprintf("Could not read the whole VBR");
			;
		} 
		if ((errmsg = ModernizedCProgram.syslinux_check_bootsect(sectbuf, sl_fs_stype))) {
			ModernizedCProgram._uprintf("Error: %s", errmsg);
			;
		} 
		ModernizedCProgram.syslinux_reset_adv(/* Initialize the ADV -- this should be smarter */ModernizedCProgram.syslinux_adv);
		if ((ModernizedCProgram.syslinux_ldlinux_len[0] != 0) && (ModernizedCProgram.syslinux_ldlinux_len[1] != /* Access a copy of the ldlinux.sys & ldlinux.bss resources (downloaded or embedded) */0)) {
			do {
				(Object)(ModernizedCProgram._chdirU(ModernizedCProgram.app_dir));
			} while (0);
			for (i = 0; i < 2; i++) {
				ModernizedCProgram.syslinux_ldlinux[i] = (byte)/*Error: Function owner not recognized*/malloc(ModernizedCProgram.syslinux_ldlinux_len[i]);
				if (ModernizedCProgram.syslinux_ldlinux[i] == ((Object)0)) {
					;
				} 
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(path, /*Error: sizeof expression not supported yet*/, "%s/%s-%s%s/%s.%s", "rufus_files", syslinux, ModernizedCProgram.img_report.getSl_version_str(), ModernizedCProgram.img_report.getSl_version_ext(), ldlinux, i == 0 ? "sys" : "bss");
					(path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				fd = /*Error: Function owner not recognized*/fopen(path, "rb");
				if (fd == ((Object)0)) {
					ModernizedCProgram._uprintf("Could not open %s", path);
					;
				} 
				length = /*Error: Function owner not recognized*/fread(ModernizedCProgram.syslinux_ldlinux[i], 1, (size_t)ModernizedCProgram.syslinux_ldlinux_len[i], fd);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
				if (length != (size_t)ModernizedCProgram.syslinux_ldlinux_len[i]) {
					ModernizedCProgram._uprintf("Could not read %s", path);
					;
				} 
				ModernizedCProgram._uprintf("Using existing './%s' %s", path, ModernizedCProgram.IsBufferInDB(ModernizedCProgram.syslinux_ldlinux[i], (size_t)ModernizedCProgram.syslinux_ldlinux_len[i]) ? "â" : "â");
			}
		} else {
				for (i = 0; i < 2; i++) {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%s.%s", ldlinux, ldlinux_ext[i]);
						(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
					} while (0);
					ModernizedCProgram.syslinux_ldlinux[i] = ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, resource[use_v5 ? 1 : 0][i], (LPSTR)((DWORD)((WORD)(true))), tmp, ModernizedCProgram.syslinux_ldlinux_len[i], 1);
					if (ModernizedCProgram.syslinux_ldlinux[i] == ((Object)0)) {
						;
					} 
				}
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(path, /*Error: sizeof expression not supported yet*/, "%C:\\%s.%s", drive_letter, ldlinux, ldlinux_ext[0]);
			(path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (/* Create ldlinux.sys file */0);
		f_handle = /*Error: Function owner not recognized*/CreateFileA(path, -1024 | -1024, -1024 | -1024, ((Object)0), 2, -1024 | -1024 | -1024, ((Object)0));
		if (f_handle == (HANDLE)(true)) {
			ModernizedCProgram._uprintf("Unable to create '%s': %s", path[3], ModernizedCProgram.WindowsErrorString());
			;
		} 
		if (!ModernizedCProgram.WriteFileWithRetry(f_handle, (byte)ModernizedCProgram.syslinux_ldlinux[/* Write ldlinux.sys file */0], ModernizedCProgram.syslinux_ldlinux_len[0], bytes_written, 4)) {
			ModernizedCProgram._uprintf("Could not write '%s': %s", path[3], ModernizedCProgram.WindowsErrorString());
			;
		} 
		if (!ModernizedCProgram.WriteFileWithRetry(f_handle, ModernizedCProgram.syslinux_adv, 2 * 512, bytes_written, 4)) {
			ModernizedCProgram._uprintf("Could not write ADV to '%s': %s", path[3], ModernizedCProgram.WindowsErrorString());
			;
		} 
		ModernizedCProgram._uprintf("Successfully wrote '%s'", path[3]);
		if (ModernizedCProgram.boot_type != boot_type.BT_IMAGE) {
			ModernizedCProgram.UpdateProgress(action_type.OP_FILE_COPY, -1.0);
		} 
		if (!/*Error: Function owner not recognized*/FlushFileBuffers(/* Now flush the media */f_handle)) {
			ModernizedCProgram._uprintf("FlushFileBuffers failed");
			;
		} 
		ldlinux_sectors = (ModernizedCProgram.syslinux_ldlinux_len[0] + 2 * 512 + ModernizedCProgram.SECTOR_SIZE - 1) >> /* Map the file (is there a better way to do this?) */ModernizedCProgram.SECTOR_SHIFT;
		sectors = (libfat_sector_t)/*Error: Function owner not recognized*/calloc(ldlinux_sectors, /*Error: sizeof expression not supported yet*/);
		if (sectors == ((Object)0)) {
			;
		} 
		Object generatedFirstLcn = extent.getFirstLcn();
		Object generatedQuadPart = lba.getQuadPart();
		Object generatedSectorsPerCluster = vol_info.getSectorsPerCluster();
		Object generatedNextVcn = extent.getNextVcn();
		libfat_filesystem libfat_filesystem = new libfat_filesystem();
		switch (file_system) {
		case fs_type.FS_EXFAT:
				lf_fs = libfat_filesystem.libfat_open(libfat_readfile, (intptr_t)d_handle);
				if (lf_fs == ((Object)0)) {
					ModernizedCProgram._uprintf("Syslinux FAT access error");
					;
				} 
				ldlinux_cluster = ModernizedCProgram.libfat_searchdir(lf_fs, 0, "LDLINUX SYS", ((Object)0));
				secp = sectors;
				nsectors = 0;
				s = ModernizedCProgram.libfat_clustertosector(lf_fs, ldlinux_cluster);
				while (s && nsectors < ldlinux_sectors) {
					secp++ = s;
					nsectors++;
					s = lf_fs.libfat_nextsector(s);
				}
				lf_fs.libfat_close();
				break;
		case fs_type.FS_NTFS:
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%C:\\", drive_letter);
					(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				vol_info.setHandle(d_handle);
				err = vol_info.NtfsSectGetVolumeInfo(tmp);
				if (err != -1024) {
					ModernizedCProgram._uprintf("Could not fetch NTFS volume info");
					;
				} 
				secp = sectors;
				nsectors = 0;
				for (vcn.setQuadPart(0); ModernizedCProgram.NtfsSectGetFileVcnExtent(f_handle, vcn, extent) == -1024; vcn = generatedNextVcn) {
					err = lba.NtfsSectLcnToLba(vol_info, generatedFirstLcn);
					if (err != -1024) {
						ModernizedCProgram._uprintf("Could not translate LDLINUX.SYS LCN to disk LBA");
						;
					} 
					generatedQuadPart -= generatedQuadPart;
					len.setQuadPart(((generatedQuadPart - generatedQuadPart) * generatedSectorsPerCluster));
					while (generatedQuadPart-- && nsectors < ldlinux_sectors) {
						secp++ = generatedQuadPart++;
						nsectors++;
					}
				}
				break;
		case fs_type.FS_FAT16:
		case fs_type.FS_FAT32:
		default:
				ModernizedCProgram._uprintf("Unsupported Syslinux filesystem");
				;
		}
		if (ModernizedCProgram.syslinux_patch(sectors, nsectors, 0, 0, ((Object)0), ((Object)0)) < /* Patch ldlinux.sys and the boot sector */0) {
			ModernizedCProgram._uprintf("Could not patch Syslinux files.");
			ModernizedCProgram._uprintf("WARNING: This could be caused by your firewall having modifed downloaded content, such as 'ldlinux.sys'...");
			;
		} 
		if (!/*Error: Function owner not recognized*/SetFilePointerEx(f_handle, liZero, ((Object)0), /* Rewrite the file */0) || !ModernizedCProgram.WriteFileWithRetry(f_handle, ModernizedCProgram.syslinux_ldlinux[0], ModernizedCProgram.syslinux_ldlinux_len[0], bytes_written, 4)) {
			ModernizedCProgram._uprintf("Could not rewrite '%s': %s\n", path[3], ModernizedCProgram.WindowsErrorString());
			;
		} 
		do {
			if ((f_handle != (HANDLE)(true)) && (f_handle != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(f_handle);
				f_handle = (HANDLE)(true);
			} 
		} while (/* Close file */0);
		if (!/*Error: Function owner not recognized*/SetFilePointerEx(d_handle, liZero, ((Object)0), /* Read existing FAT data into boot sector */0) || !/*Error: Function owner not recognized*/ReadFile(d_handle, sectbuf, ModernizedCProgram.SECTOR_SIZE, bytes_read, ((Object)0))) {
			ModernizedCProgram._uprintf("Could not read Syslinux boot record: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		if (bytes_read < ModernizedCProgram.SECTOR_SIZE) {
			ModernizedCProgram._uprintf("Partial read of Syslinux boot record: read %d bytes but requested %d", bytes_read, ModernizedCProgram.SECTOR_SIZE);
			;
		} 
		ModernizedCProgram.syslinux_make_bootsect(sectbuf, (file_system == fs_type.FS_NTFS) ? filesystem.NTFS : /* Make the syslinux boot sector */filesystem.VFAT);
		if (!/*Error: Function owner not recognized*/SetFilePointerEx(d_handle, liZero, ((Object)0), /* Write boot sector back */0) || !ModernizedCProgram.WriteFileWithRetry(d_handle, sectbuf, ModernizedCProgram.SECTOR_SIZE, bytes_written, 4)) {
			ModernizedCProgram._uprintf("Could not write Syslinux boot record: %s", ModernizedCProgram.WindowsErrorString());
			;
		} 
		ModernizedCProgram._uprintf("Successfully wrote Syslinux boot record");
		if (ModernizedCProgram.boot_type == boot_type.BT_SYSLINUX_V6) {
			do {
				(Object)(ModernizedCProgram._chdirU(ModernizedCProgram.app_dir));
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(path, /*Error: sizeof expression not supported yet*/, "%s/%s-%s", "rufus_files", syslinux, ModernizedCProgram.embedded_sl_version_str[1]);
				(path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			do {
				(Object)(/*Error: Function owner not recognized*/_chdir(path));
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(path, /*Error: sizeof expression not supported yet*/, "%C:\\%s.%s", drive_letter, ldlinux, ldlinux_ext[2]);
				(path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			fd = /*Error: Function owner not recognized*/fopen(path[3], "rb");
			if (fd == ((Object)0)) {
				ModernizedCProgram._uprintf("Caution: No '%s' was provided. The target will be missing a required Syslinux file!", path[3]);
			} else {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
					if (ModernizedCProgram.CopyFileU(path[3], path, 1)) {
						ModernizedCProgram._uprintf("Created '%s' (from '%s/%s-%s/%s') %s", path, "rufus_files", syslinux, ModernizedCProgram.embedded_sl_version_str[1], path[3], ModernizedCProgram.IsFileInDB(path[3]) ? "â" : "â");
					} else {
							ModernizedCProgram._uprintf("Failed to create '%s': %s", path, ModernizedCProgram.WindowsErrorString());
					} 
			} 
		}  else if ((ModernizedCProgram.img_report.getReactos_path()[0] != 0)) {
			ModernizedCProgram._uprintf("Setting up ReactOS...");
			ModernizedCProgram.syslinux_mboot = ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(true))), (LPSTR)((DWORD)((WORD)(true))), "mboot.c32", ModernizedCProgram.syslinux_mboot_len, 0);
			if (ModernizedCProgram.syslinux_mboot == ((Object)0)) {
				;
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(path, /*Error: sizeof expression not supported yet*/, "%C:\\%s", drive_letter, mboot_c32);
				(path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (/* Create mboot.c32 file */0);
			f_handle = /*Error: Function owner not recognized*/CreateFileA(path, -1024 | -1024, -1024 | -1024, ((Object)0), 2, -1024, ((Object)0));
			if (f_handle == (HANDLE)(true)) {
				ModernizedCProgram._uprintf("Unable to create '%s'\n", path);
				;
			} 
			if (!ModernizedCProgram.WriteFileWithRetry(f_handle, ModernizedCProgram.syslinux_mboot, ModernizedCProgram.syslinux_mboot_len, bytes_written, 4)) {
				ModernizedCProgram._uprintf("Could not write '%s'", path);
				;
			} 
			do {
				if ((f_handle != (HANDLE)(true)) && (f_handle != ((Object)0))) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(f_handle);
					f_handle = (HANDLE)(true);
				} 
			} while (0);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(path, /*Error: sizeof expression not supported yet*/, "%C:\\syslinux.cfg", drive_letter);
				(path)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
			fd = /*Error: Function owner not recognized*/fopen(path, "w");
			if (fd == ((Object)0)) {
				ModernizedCProgram._uprintf("Could not create ReactOS 'syslinux.cfg'");
				;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf(fd, /* Write the syslinux.cfg for ReactOS */"DEFAULT ReactOS\nLABEL ReactOS\n  KERNEL %s\n  APPEND %s", mboot_c32, ModernizedCProgram.img_report.getReactos_path());
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd);
		} 
		if (ModernizedCProgram.boot_type != boot_type.BT_IMAGE) {
			ModernizedCProgram.UpdateProgress(action_type.OP_FILE_COPY, -1.0);
		} 
		r = 1;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.syslinux_ldlinux[0]);
			ModernizedCProgram.syslinux_ldlinux[0] = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.syslinux_ldlinux[1]);
			ModernizedCProgram.syslinux_ldlinux[1] = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)sectors);
			sectors = ((Object)0);
		} while (0);
		do {
			if ((d_handle != (HANDLE)(true)) && (d_handle != ((Object)0))) {
				ModernizedCProgram.UnlockDrive(d_handle);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(d_handle);
				d_handle = (HANDLE)(true);
			} 
		} while (0);
		do {
			if ((f_handle != (HANDLE)(true)) && (f_handle != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(f_handle);
				f_handle = (HANDLE)(true);
			} 
		} while (0);
		return r;
	}
	public static Object GetSyslinuxVersion(byte[] buf, Object buf_size, Byte ext) {
		size_t i = new size_t();
		size_t j = new size_t();
		size_t k = new size_t();
		byte p;
		uint16_t version = new uint16_t();
		byte[] LINUX = new byte[]{(byte)'L', (byte)'I', (byte)'N', (byte)'U', (byte)'X', (byte)' '};
		byte nullstr = "";
		byte[] unauthorized = new byte[]{(byte)'<', (byte)'>', (byte)':', (byte)'|', (byte)'*', (byte)'?', (byte)'\\', (byte)'/'};
		ext = nullstr;
		if (buf_size < 256) {
			return 0;
		} 
		// Start at 64 to avoid the short incomplete version at the beginning of ldlinux.sysfor (i = 64; i < buf_size - 64; i++) {
			if (/*Error: Function owner not recognized*/memcmp(buf[i], LINUX, /*Error: sizeof expression not supported yet*/) == 0) {
				if (!(((buf[i - 3] == (byte)'I') && (buf[i - 2] == (byte)'S') && (buf[i - 1] == (byte)'O')) || ((buf[i - 3] == (byte)'S') && (buf[i - 2] == (byte)'Y') && (buf[i - 1] == (byte)'S')))) {
					continue;
				} 
				i += /*Error: sizeof expression not supported yet*/;
				version = (((uint8_t)/*Error: Function owner not recognized*/strtoul(buf[i], p, 10)) << 8) + (uint8_t)/*Error: Function owner not recognized*/strtoul(p[1], p, 10);
				if (version == 0) {
					continue;
				} 
				p[((((byte)p) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(p))] = 0;
				p = (byte)'/';
				for (j = 0; (buf[i + j] == p[1 + j]) && (buf[i + j] != (byte)' '); j++) {
					;
				}
				if (p[j + 1] == (byte)'-') {
					j++;
				} 
				if (j >= 4) {
					p[j] = (byte)'/';
					p = p[j];
				} 
				for (j = ((((byte)p) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(p)) - 1; j > 0; j--) {
					if ((p[j] == (byte)' ') || (p[j] == (byte)'*')) {
						p[j] = 0;
					} else {
							break;
					} 
				}
				for (j = 1; j < ((((byte)p) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(p)); j++) {
					for (k = 0; k < /*Error: sizeof expression not supported yet*/; k++) {
						if (p[j] == unauthorized[k]) {
							p[j] = (byte)'_';
						} 
					}
				}
				ext = (p[1] == 0) ? nullstr : p;
				return version;
			} 
		}
		return 0;
	}
	/* ----------------------------------------------------------------------- *
	 *
	 *   Copyright 2007-2008 H. Peter Anvin - All Rights Reserved
	 *   Copyright 2009-2014 Intel Corporation; author: H. Peter Anvin
	 *   Copyright 2011 Paulo Alcantara <pcacjr@gmail.com>
	 *
	 *   This program is free software; you can redistribute it and/or modify
	 *   it under the terms of the GNU General Public License as published by
	 *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
	 *   Boston MA 02111-1307, USA; either version 2 of the License, or
	 *   (at your option) any later version; incorporated herein by reference.
	 *
	 * ----------------------------------------------------------------------- */
	/* Littleendian and unaligned safe */
	/* gcc 4.7 miscompiles packed structures in MS-bitfield mode */
	/*
	 * Access functions for littleendian numbers, possibly misaligned.
	 */
	public static Object get_8(Object p) {
		return p;
	}
	public static Object get_16(Object p) {
		return /* Littleendian and unaligned-capable */p;
	}
	public static Object get_32(Object p) {
		return /* Littleendian and unaligned-capable */p;
	}
	public static Object get_64(Object p) {
		return /* Littleendian and unaligned-capable */p;
	}
	public static void set_8(Object p, Object v) {
		p = v;
	}
	public static void set_16(Object p, Object v) {
		p = /* Littleendian and unaligned-capable */v;
	}
	public static void set_32(Object p, Object v) {
		p = /* Littleendian and unaligned-capable */v;
	}
	public static void set_64(Object p, Object v) {
		p = /* Littleendian and unaligned-capable */v/*
		 * Special handling for the MS-DOS derivative: syslinux_ldlinux
		 * is a "far" object...
		 */;/*
		 * Special handling for the MS-DOS derivative: syslinux_ldlinux
		 * is a "far" object...
		 */
	}
	/* Sane system ... */
	public static Object get_8_sl(Object p) {
		return ModernizedCProgram.get_8((uint8_t)p);
	}
	public static Object get_16_sl(Object p) {
		return ModernizedCProgram.get_16((uint16_t)p);
	}
	public static Object get_32_sl(Object p) {
		return ModernizedCProgram.get_32((uint32_t)p);
	}
	public static Object get_64_sl(Object p) {
		return ModernizedCProgram.get_64((uint64_t)p);
	}
	public static void set_8_sl(Object p, Object v) {
		ModernizedCProgram.set_8((uint8_t)p, v);
	}
	public static void set_16_sl(Object p, Object v) {
		ModernizedCProgram.set_16((uint16_t)p, v);
	}
	public static void set_32_sl(Object p, Object v) {
		ModernizedCProgram.set_32((uint32_t)p, v);
	}
	public static void set_64_sl(Object p, Object v) {
		ModernizedCProgram.set_64((uint64_t)p, v);
	}
	public static void memcpy_to_sl(Object dst, Object src, Object len) {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((Object)dst, src, len);
	}
	public static void memcpy_from_sl(Object dst, Object src, Object len) {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(dst, (Object)src, len);
	}
	public static void memset_sl(Object dst, int c, Object len) {
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset((Object)dst, c, len);
	}
	/* Check if there are specific zero fields in an NTFS boot sector */
	public static int ntfs_check_zero_fields(Object sb) {
		return !sb.getBsResSectors() && (!sb.getBsZeroed_0()[0] && !sb.getBsZeroed_0()[1] && !sb.getBsZeroed_0()[2]) && !sb.getBsZeroed_1() && !sb.getBsZeroed_2() && !sb.getBsZeroed_3();
	}
	public static int ntfs_check_sb_fields(Object sb) {
		return ModernizedCProgram.ntfs_check_zero_fields(sb) && (!/*Error: Function owner not recognized*/memcmp(sb.getBsOemName(), "NTFS    ", 8) || !/*Error: Function owner not recognized*/memcmp(sb.getBsOemName(), "MSWIN4.0", 8) || !/*Error: Function owner not recognized*/memcmp(sb.getBsOemName(), "MSWIN4.1", 8));
	}
	public static int fat_check_sb_fields(Object sb) {
		return sb.getBsResSectors() && sb.getBsFATs() && (!/*Error: Function owner not recognized*/memcmp(sb.getBs16().getFileSysType(), "FAT12   ", 8) || !/*Error: Function owner not recognized*/memcmp(sb.getBs16().getFileSysType(), "FAT16   ", 8) || !/*Error: Function owner not recognized*/memcmp(sb.getBs16().getFileSysType(), "FAT     ", 8) || !/*Error: Function owner not recognized*/memcmp(sb.getBs32().getFileSysType(), "FAT32   ", 8/* SYSLXINT_H */));
	}
	/* Called from unpack_gz_stream() and inflate_unzip() */
	public static int inflate_unzip_internal(state_t state, transformer_state_t xstate) {
		long n = 0;
		ssize_t nwrote = new ssize_t();
		Byte generatedGunzip_window = state.getGunzip_window();
		(generatedGunzip_window) = /*Error: Function owner not recognized*/malloc(/* Allocate all global buffers (for DYN_ALLOC option) */.GUNZIP_WSIZE);
		int generatedGunzip_outbuf_count = state.getGunzip_outbuf_count();
		(generatedGunzip_outbuf_count) = 0;
		Object generatedGunzip_bytes_out = state.getGunzip_bytes_out();
		(generatedGunzip_bytes_out) = 0;
		int generatedGunzip_src_fd = state.getGunzip_src_fd();
		Object generatedSrc_fd = xstate.getSrc_fd();
		(generatedGunzip_src_fd) = generatedSrc_fd;
		Object generatedMethod = state.getMethod();
		(generatedMethod) = -/* (re) initialize state */1;
		Object generatedNeed_another_block = state.getNeed_another_block();
		(generatedNeed_another_block) = 1;
		Object generatedResume_copy = state.getResume_copy();
		(generatedResume_copy) = 0;
		byte generatedGunzip_bk = state.getGunzip_bk();
		(generatedGunzip_bk) = 0;
		int generatedGunzip_bb = state.getGunzip_bb();
		(generatedGunzip_bb) = 0;
		Object generatedGunzip_crc_table = state.getGunzip_crc_table();
		(generatedGunzip_crc_table) = ModernizedCProgram.crc32_filltable(((Object)0), /* Create the crc table */0);
		Object generatedGunzip_crc = state.getGunzip_crc();
		(generatedGunzip_crc) = ~0;
		Object generatedError_msg = state.getError_msg();
		(generatedError_msg) = "corrupted data";
		Object generatedError_jmp = state.getError_jmp();
		if (/*Error: Function owner not recognized*/_setjmp((generatedError_jmp))) {
			n = -/* Error from deep inside zip machinery */1;
			;
		} 
		while (1) {
			int r = state.inflate_get_next_window();
			nwrote = xstate.transformer_write((generatedGunzip_window), (generatedGunzip_outbuf_count));
			if (nwrote != (ssize_t)(generatedGunzip_outbuf_count)) {
				state.huft_free_all();
				n = (nwrote < 0) ? nwrote : -1;
				;
			} 
			n += nwrote;
			if (r == 0) {
				break;
			} 
		}
		int generatedBytebuffer_offset = state.getBytebuffer_offset();
		Byte generatedBytebuffer = state.getBytebuffer();
		if ((generatedGunzip_bk) >= /* Store unused bytes in a global buffer so calling applets can access it */8/* Undo too much lookahead. The next read will be byte aligned
				 * so we can discard unused bits in the last meaningful byte. */) {
			(generatedBytebuffer_offset)--;
			(generatedBytebuffer)[(generatedBytebuffer_offset)] = (generatedGunzip_bb) & -1024;
			(generatedGunzip_bb) >>=  8;
			(generatedGunzip_bk) -= 8;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((generatedGunzip_crc_table));
		return n/* External entry points */;
	}
	public static int check_header_gzip(state_t state, transformer_state_t xstate) {
		Object header;
		int generatedBytebuffer_size = state.getBytebuffer_size();
		int generatedBytebuffer_offset = state.getBytebuffer_offset();
		(generatedBytebuffer_size) -= (generatedBytebuffer_offset);
		Byte generatedBytebuffer = state.getBytebuffer();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memmove((generatedBytebuffer), (generatedBytebuffer)[(generatedBytebuffer_offset)], (generatedBytebuffer_size));
		(generatedBytebuffer_offset) = 0;
		if (!state.top_up(8)) {
			return 0;
		} 
		Object generatedRaw = header.getRaw();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedRaw, (generatedBytebuffer)[(generatedBytebuffer_offset)], 8);
		(generatedBytebuffer_offset) += 8;
		Object generatedFormatted = header.getFormatted();
		if (generatedFormatted.getGz_method() != /* Check the compression method */8) {
			return 0;
		} 
		if (generatedFormatted.getFlags() & -1024/* bit 2 set: extra field present */) {
			int extra_short;
			if (!state.top_up(2)) {
				return 0;
			} 
			extra_short = state.buffer_read_le_u16();
			if (!state.top_up(extra_short)) {
				return 0;
			} 
			(generatedBytebuffer_offset) += /* Ignore extra field */extra_short;
		} 
		if (generatedFormatted.getFlags() & /* Discard original name and file comment if any *//* bit 3 set: original file name present *//* bit 4 set: file comment present */-1024) {
			while (1) {
				do {
					if (!state.top_up(1)) {
						return 0;
					} 
				} while ((generatedBytebuffer)[(generatedBytebuffer_offset)++] != 0);
				if ((generatedFormatted.getFlags() & -1024) != -1024) {
					break;
				} 
				generatedFormatted.getFlags() &=  ~-1024;
			}
		} 
		xstate.setMtime((generatedFormatted.getMtime()));
		if (generatedFormatted.getFlags() & /* Read the header checksum */-1024) {
			if (!state.top_up(2)) {
				return 0;
			} 
			(generatedBytebuffer_offset) += 2;
		} 
		return 1;
	}
	/*
	 * io_manager.c --- the I/O manager abstraction
	 */
	public static Object io_channel_set_options(Object channel, Object opts) {
		 retval = 0;
		byte next;
		byte ptr;
		byte options;
		byte arg;
		if (!(channel) || (channel).getMagic() != (EXT2_ET_MAGIC_IO_CHANNEL)) {
			return (EXT2_ET_MAGIC_IO_CHANNEL);
		} 
		if (!opts) {
			return 0;
		} 
		if (!channel.getManager().getSet_option()) {
			return EXT2_ET_INVALID_ARGUMENT;
		} 
		options = /*Error: Function owner not recognized*/malloc(/*Error: Function owner not recognized*/strlen(opts) + 1);
		if (!options) {
			return EXT2_ET_NO_MEMORY;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcpy(options, opts);
		ptr = options;
		while (ptr && ptr) {
			next = /*Error: Function owner not recognized*/strchr(ptr, (byte)'&');
			if (next) {
				next++ = 0;
			} 
			arg = /*Error: Function owner not recognized*/strchr(ptr, (byte)'=');
			if (arg) {
				arg++ = 0;
			} 
			retval = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(channel, ptr, arg);
			if (retval) {
				break;
			} 
			ptr = next;
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(options);
		return retval;
	}
	public static Object io_channel_write_byte(Object channel, long offset, int count, Object data) {
		if (!(channel) || (channel).getMagic() != (EXT2_ET_MAGIC_IO_CHANNEL)) {
			return (EXT2_ET_MAGIC_IO_CHANNEL);
		} 
		if (channel.getManager().getWrite_byte()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(channel, offset, count, data);
		} 
		return EXT2_ET_UNIMPLEMENTED;
	}
	public static Object io_channel_read_blk64(Object channel, int block, int count, Object data) {
		if (!(channel) || (channel).getMagic() != (EXT2_ET_MAGIC_IO_CHANNEL)) {
			return (EXT2_ET_MAGIC_IO_CHANNEL);
		} 
		if (channel.getManager().getRead_blk64()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(channel, block, count, data);
		} 
		if ((block >> 32) != 0) {
			return EXT2_ET_IO_CHANNEL_NO_SUPPORT_64;
		} 
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(channel, (long)block, count, data);
	}
	public static Object io_channel_write_blk64(Object channel, int block, int count, Object data) {
		if (!(channel) || (channel).getMagic() != (EXT2_ET_MAGIC_IO_CHANNEL)) {
			return (EXT2_ET_MAGIC_IO_CHANNEL);
		} 
		if (channel.getManager().getWrite_blk64()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(channel, block, count, data);
		} 
		if ((block >> 32) != 0) {
			return EXT2_ET_IO_CHANNEL_NO_SUPPORT_64;
		} 
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(channel, (long)block, count, data);
	}
	public static Object io_channel_discard(Object channel, int block, int count) {
		if (!(channel) || (channel).getMagic() != (EXT2_ET_MAGIC_IO_CHANNEL)) {
			return (EXT2_ET_MAGIC_IO_CHANNEL);
		} 
		if (channel.getManager().getDiscard()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(channel, block, count);
		} 
		return EXT2_ET_UNIMPLEMENTED;
	}
	public static Object io_channel_zeroout(Object channel, int block, int count) {
		if (!(channel) || (channel).getMagic() != (EXT2_ET_MAGIC_IO_CHANNEL)) {
			return (EXT2_ET_MAGIC_IO_CHANNEL);
		} 
		if (channel.getManager().getZeroout()) {
			return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(channel, block, count);
		} 
		return EXT2_ET_UNIMPLEMENTED;
	}
	public static Object io_channel_alloc_buf(Object io, int count, Object ptr) {
		size_t size = new size_t();
		if (count == 0) {
			size = io.getBlock_size();
		}  else if (count > 0) {
			size = io.getBlock_size() * count;
		} else {
				size = -count;
		} 
		if (io.getAlign()) {
			return ModernizedCProgram.ext2fs_get_memalign(size, io.getAlign(), ptr);
		} else {
				return ModernizedCProgram.ext2fs_get_mem(size, ptr);
		} 
	}
	public static Object io_channel_cache_readahead(Object io, int block, int count) {
		if (!io.getManager().getCache_readahead()) {
			return EXT2_ET_OP_NOT_SUPPORTED;
		} 
		return /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(io, block, count);
	}
	/*
	 * Verify the extent header as being sane
	 */
	public static Object ext2fs_extent_header_verify(Object ptr, int size) {
		int eh_max;
		int entry_size;
		ext3_extent_header eh = ptr;
		do {
		} while (0);
		Object generatedExt3_extent_header = eh.getExt3_extent_header();
		if (/*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedExt3_extent_header) != EXT3_EXT_MAGIC) {
			return EXT2_ET_EXTENT_HEADER_BAD;
		} 
		if (/*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedExt3_extent_header) > /*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedExt3_extent_header)) {
			return EXT2_ET_EXTENT_HEADER_BAD;
		} 
		if (generatedExt3_extent_header == 0) {
			entry_size = /*Error: Unsupported expression*/;
		} else {
				entry_size = /*Error: Unsupported expression*/;
		} 
		eh_max = (size - /*Error: sizeof expression not supported yet*/) / entry_size/* Allow two extent-sized items at the end of the block, for
			 * ext4_extent_tail with checksum in the future. */;
		if ((/*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedExt3_extent_header) > eh_max) || (/*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedExt3_extent_header) < (eh_max - 2))) {
			return EXT2_ET_EXTENT_HEADER_BAD;
		} 
		return 0;
	}
	/*
	 * Begin functions to handle an inode's extent information
	 */
	public static void ext2fs_extent_free(Object handle) {
		int i;
		if (!handle) {
			return /*Error: Unsupported expression*/;
		} 
		if (handle.getPath()) {
			for (i = 1; i < handle.getMax_paths(); i++) {
				if (handle.getPath()[i].getBuf()) {
					ModernizedCProgram.ext2fs_free_mem(handle.getPath()[i].getBuf());
				} 
			}
			ModernizedCProgram.ext2fs_free_mem(handle.getPath());
		} 
		ModernizedCProgram.ext2fs_free_mem(handle);
	}
	public static Object ext2fs_extent_open(Object fs, Object ino, Object ret_handle) {
		return ((Object)0).ext2fs_extent_open2(fs, ino, ret_handle);
	}
	public static Object update_path(Object handle) {
		 blk = new ();
		 retval = new ();
		ext3_extent_idx ix = new ext3_extent_idx();
		ext3_extent_header eh = new ext3_extent_header();
		Object generatedExt3_extent_idx = ix.getExt3_extent_idx();
		if (handle.getLevel() == 0) {
			retval = handle.getInode().ext2fs_write_inode(handle.getFs(), handle.getIno());
		} else {
				ix = handle.getPath()[handle.getLevel() - 1].getCurr();
				blk = /*Error: Function owner not recognized*/ext2fs_le32_to_cpu(generatedExt3_extent_idx) + (()/*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedExt3_extent_idx) << 32);
				eh = /* then update the checksum */(ext3_extent_header)handle.getPath()[handle.getLevel()].getBuf();
				retval = ModernizedCProgram.ext2fs_extent_block_csum_set(handle.getFs(), handle.getIno(), eh);
				if (retval) {
					return retval;
				} 
				retval = ModernizedCProgram.io_channel_write_blk64(handle.getFs().getIo(), blk, 1, handle.getPath()[handle.getLevel()].getBuf());
		} 
		return retval;
	}
	/*
	 * Go to the node at leaf_level which contains logical block blk.
	 *
	 * leaf_level is height from the leaf node level, i.e.
	 * leaf_level 0 is at leaf node, leaf_level 1 is 1 above etc.
	 *
	 * If "blk" has no mapping (hole) then handle is left at last
	 * extent before blk.
	 */
	public static Object ext2fs_extent_goto2(Object handle, int leaf_level, Object blk) {
		ext2fs_extent extent = new ext2fs_extent();
		 retval = new ();
		retval = extent.ext2fs_extent_get(handle, -1024);
		if (retval) {
			if (retval == EXT2_ET_EXTENT_NO_NEXT) {
				retval = EXT2_ET_EXTENT_NOT_FOUND;
			} 
			return retval;
		} 
		if (leaf_level > handle.getMax_depth()) {
			return EXT2_ET_OP_NOT_SUPPORTED;
		} 
		Object generatedE_lblk = extent.getE_lblk();
		Object generatedE_len = extent.getE_len();
	}
	public static Object ext2fs_extent_goto(Object handle, Object blk) {
		return ModernizedCProgram.ext2fs_extent_goto2(handle, 0, blk/*
		 * Traverse back up to root fixing parents of current node as needed.
		 *
		 * If we changed start of first entry in a node, fix parent index start
		 * and so on.
		 *
		 * Safe to call for any position in node; if not at the first entry,
		 * it will simply return.
		 *
		 * Note a subtlety of this function -- if there happen to be two extents
		 * mapping the same lblk and someone calls fix_parents on the second of the two
		 * extents, the position of the extent handle after the call will be the second
		 * extent if nothing happened, or the first extent if something did.  A caller
		 * in this situation must use ext2fs_extent_goto() after calling this function.
		 * Or simply don't map the same lblk with two extents, ever.
		 */);
	}
	public static Object ext2fs_extent_fix_parents(Object handle) {
		int retval = 0;
		int orig_height;
		 start = new ();
		extent_path path = new extent_path();
		ext2fs_extent extent = new ext2fs_extent();
		ext2_extent_info info = new ext2_extent_info();
		if (!(handle) || (handle).getMagic() != (EXT2_ET_MAGIC_EXTENT_HANDLE)) {
			return (EXT2_ET_MAGIC_EXTENT_HANDLE);
		} 
		if (!(handle.getFs().getFlags() & -1024)) {
			return EXT2_ET_RO_FILSYS;
		} 
		if (!handle.getPath()) {
			return EXT2_ET_NO_CURRENT_NODE;
		} 
		path = handle.getPath() + handle.getLevel();
		Object generatedCurr = path.getCurr();
		if (!generatedCurr) {
			return EXT2_ET_NO_CURRENT_NODE;
		} 
		retval = extent.ext2fs_extent_get(handle, -1024);
		if (retval) {
			;
		} 
		Object generatedE_lblk = extent.getE_lblk();
		start = generatedE_lblk;
		if ((retval = info.ext2fs_extent_get_info(handle))) {
			return retval;
		} 
		int generatedMax_depth = info.getMax_depth();
		int generatedCurr_level = info.getCurr_level();
		orig_height = generatedMax_depth - generatedCurr_level;
		int generatedLeft = path.getLeft();
		int generatedEntries = path.getEntries();
		Object generatedE_len = extent.getE_len();
		while (handle.getLevel() > /* traverse up until index not first, or startblk matches, or top */0 && (generatedLeft == generatedEntries - 1)) {
			retval = extent.ext2fs_extent_get(handle, -1024);
			if (retval) {
				;
			} 
			if (generatedE_lblk == start) {
				break;
			} 
			path = handle.getPath() + handle.getLevel();
			generatedE_len += (generatedE_lblk - start);
			extent.setE_lblk(start);
			retval = extent.ext2fs_extent_replace(handle, 0);
			if (retval) {
				;
			} 
			ModernizedCProgram.update_path(handle);
		}
		retval = ModernizedCProgram.ext2fs_extent_goto2(handle, orig_height, /* put handle back to where we started */start);
	}
	public static int splitting_at_eof(ext2_extent_handle handle, extent_path path) {
		extent_path ppp = path;
		do {
		} while (0);
		int generatedLevel = handle.getLevel();
		if (generatedLevel == 0) {
			return 0;
		} 
		extent_path[] generatedPath = handle.getPath();
		int generatedLeft = ppp.getLeft();
		do {
			if (generatedLeft) {
				return 0;
			} 
			ppp--;
		} while (ppp >= generatedPath);
		return 1/*
		 * allocate a new block, move half the current node to it, and update parent
		 *
		 * handle will be left pointing at original record.
		 */;
	}
	public static Object extent_node_split(Object handle, int expand_allowed) {
		 retval = 0;
		 new_node_pblk = new ();
		 new_node_start = new ();
		 orig_lblk = new ();
		 goal_blk = 0;
		int orig_height;
		byte block_buf = ((Object)0);
		ext2fs_extent extent = new ext2fs_extent();
		extent_path path = new extent_path();
		extent_path newpath = 0;
		ext3_extent_header eh = new ext3_extent_header();
		ext3_extent_header neweh = new ext3_extent_header();
		int tocopy;
		int new_root = 0;
		ext2_extent_info info = new ext2_extent_info();
		int no_balance;
		if (!(handle) || (handle).getMagic() != (EXT2_ET_MAGIC_EXTENT_HANDLE)) {
			return (/* basic sanity */EXT2_ET_MAGIC_EXTENT_HANDLE);
		} 
		if (!(handle.getFs().getFlags() & -1024)) {
			return EXT2_ET_RO_FILSYS;
		} 
		if (!handle.getPath()) {
			return EXT2_ET_NO_CURRENT_NODE;
		} 
		retval = extent.ext2fs_extent_get(handle, -1024);
		if (retval) {
			;
		} 
		retval = info.ext2fs_extent_get_info(handle);
		if (retval) {
			;
		} 
		int generatedMax_depth = info.getMax_depth();
		int generatedCurr_level = info.getCurr_level();
		orig_height = generatedMax_depth - generatedCurr_level;
		Object generatedE_lblk = extent.getE_lblk();
		orig_lblk = generatedE_lblk;
		path = handle.getPath() + handle.getLevel();
		Byte generatedBuf = path.getBuf();
		eh = (ext3_extent_header)generatedBuf;
		Object generatedExt3_extent = ex.getExt3_extent();
		Object generatedExt3_extent_idx = ix.getExt3_extent_idx();
		if (handle.getLevel() == generatedMax_depth) {
			ext3_extent ex = new ext3_extent();
			ex = /*Error: Function owner not recognized*/EXT_FIRST_EXTENT(eh);
			goal_blk = /*Error: Function owner not recognized*/ext2fs_le32_to_cpu(generatedExt3_extent) + (()/*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedExt3_extent) << 32);
		} else {
				ext3_extent_idx ix = new ext3_extent_idx();
				ix = /*Error: Function owner not recognized*/EXT_FIRST_INDEX(eh);
				goal_blk = /*Error: Function owner not recognized*/ext2fs_le32_to_cpu(generatedExt3_extent_idx) + (()/*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedExt3_extent_idx) << 32);
		} 
		goal_blk -= (-1024 << (handle.getFs()).getCluster_ratio_bits());
		goal_blk &=  ~((-1024 << (handle.getFs()).getCluster_ratio_bits()) - 1);
		if (handle.getLevel() && (handle.getPath()[handle.getLevel() - 1].getEntries() >= handle.getPath()[handle.getLevel() - 1].getMax_entries())) {
			retval = /* split the parent */extent.ext2fs_extent_get(handle, -1024);
			if (retval) {
				;
			} 
			retval = ModernizedCProgram.extent_node_split(handle, expand_allowed);
			if (retval) {
				;
			} 
			retval = ModernizedCProgram.ext2fs_extent_goto2(handle, orig_height, /* get handle back to our original split position */orig_lblk);
			if (retval) {
				;
			} 
		} 
		path = handle.getPath() + handle.getLevel();
		Object generatedCurr = path.getCurr();
		if (!generatedCurr) {
			return EXT2_ET_NO_CURRENT_NODE/*
				 * Normally, we try to split a full node in half.  This doesn't turn
				 * out so well if we're tacking extents on the end of the file because
				 * then we're stuck with a tree of half-full extent blocks.  This of
				 * course doesn't apply to the root level.
				 */;
		} 
		no_balance = expand_allowed ? ModernizedCProgram.splitting_at_eof(handle, path) : 0;
		eh = (ext3_extent_header)generatedBuf;
		Object generatedExt3_extent_header = eh.getExt3_extent_header();
		if (handle.getLevel() == /* splitting root level means moving them all out */0) {
			new_root = 1;
			tocopy = /*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedExt3_extent_header);
			retval = ModernizedCProgram.ext2fs_get_memzero((handle.getMax_paths() + 1) * /*Error: Unsupported expression*/, newpath);
			if (retval) {
				;
			} 
		} else {
				if (no_balance) {
					tocopy = 1;
				} else {
						tocopy = /*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedExt3_extent_header) / 2;
				} 
		} 
		if (!tocopy && !no_balance) {
			retval = EXT2_ET_CANT_SPLIT_EXTENT;
			;
		} 
		block_buf = /*Error: Function owner not recognized*/malloc(handle.getFs().getBlocksize());
		if (!block_buf) {
			retval = 12;
			;
		} 
		if (!goal_blk) {
			goal_blk = handle.getInode().ext2fs_find_inode_goal(handle.getFs(), handle.getIno(), 0);
		} 
		retval = ModernizedCProgram.ext2fs_alloc_block2(handle.getFs(), goal_blk, block_buf, new_node_pblk);
		if (retval) {
			;
		} 
		neweh = (ext3_extent_header)/* Copy data into new block buffer *//* First the header for the new block... */block_buf;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(neweh, eh, /*Error: Unsupported expression*/);
		neweh.setExt3_extent_header(/*Error: Function owner not recognized*/ext2fs_cpu_to_le16(tocopy));
		neweh.setExt3_extent_header(/*Error: Function owner not recognized*/ext2fs_cpu_to_le16((handle.getFs().getBlocksize() - /*Error: Unsupported expression*/) / /*Error: Unsupported expression*/));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(/*Error: Function owner not recognized*/EXT_FIRST_INDEX(/* then the entries for the new block... */neweh), /*Error: Function owner not recognized*/EXT_FIRST_INDEX(eh) + (/*Error: Function owner not recognized*/ext2fs_le16_to_cpu(generatedExt3_extent_header) - tocopy), /*Error: Unsupported expression*/ * tocopy);
		new_node_start = /*Error: Function owner not recognized*/ext2fs_le32_to_cpu(/*Error: Function owner not recognized*/EXT_FIRST_INDEX(neweh).getEi_block());
		retval = ModernizedCProgram.ext2fs_extent_block_csum_set(handle.getFs(), handle.getIno(), /* then update the checksum */neweh);
		if (retval) {
			;
		} 
		retval = ModernizedCProgram.io_channel_write_blk64(handle.getFs().getIo(), new_node_pblk, /* ...and write the new node block out to disk. */1, block_buf);
		if (retval) {
			;
		} 
		int generatedMax_entries = path.getMax_entries();
		int generatedEntries = path.getEntries();
		int generatedLeft = path.getLeft();
		if (handle.getLevel() == /* current path now has fewer active entries, we copied some out */0) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(newpath, path, /*Error: Unsupported expression*/ * handle.getMax_paths());
			handle.setPath(newpath);
			newpath = path;
			path = handle.getPath();
			path.setEntries(1);
			path.setLeft(generatedMax_entries - 1);
			generatedMax_depth++;
			handle.getMax_paths()++;
			eh.setExt3_extent_header(/*Error: Function owner not recognized*/ext2fs_cpu_to_le16(generatedMax_depth));
		} else {
				generatedEntries -= tocopy;
				generatedLeft -= tocopy;
		} 
		eh.setExt3_extent_header(/*Error: Function owner not recognized*/ext2fs_cpu_to_le16(generatedEntries));
		retval = ModernizedCProgram.update_path(/* this writes out the node, incl. the modified header */handle);
		if (retval) {
			;
		} 
		Object generatedE_len = extent.getE_len();
		if (/* now go up and insert/replace index for new node we created */new_root) {
			retval = extent.ext2fs_extent_get(handle, -1024);
			if (retval) {
				;
			} 
			extent.setE_lblk(new_node_start);
			extent.setE_pblk(new_node_pblk);
			extent.setE_len(handle.getPath()[0].getEnd_blk() - generatedE_lblk);
			retval = extent.ext2fs_extent_replace(handle, 0);
			if (retval) {
				;
			} 
		} else {
				 new_node_length = new ();
				retval = extent.ext2fs_extent_get(handle, -1024);
				new_node_length = new_node_start - generatedE_lblk;
				generatedE_len -= new_node_length;
				retval = extent.ext2fs_extent_replace(handle, 0);
				if (retval) {
					;
				} 
				extent.setE_lblk(/* now set up the new extent and insert it */new_node_start);
				extent.setE_pblk(new_node_pblk);
				extent.setE_len(new_node_length);
				retval = extent.ext2fs_extent_insert(handle, -1024);
				if (retval) {
					;
				} 
		} 
		retval = ModernizedCProgram.ext2fs_extent_goto2(handle, orig_height, /* get handle back to our original position */orig_lblk);
		if (retval) {
			;
		} 
		handle.getInode().ext2fs_iblk_add_blocks(handle.getFs(), /* new node hooked in, so update inode block count (do this here?) */1);
		retval = handle.getInode().ext2fs_write_inode(handle.getFs(), handle.getIno());
		if (retval) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(block_buf);
		return retval;
	}
	public static Object ext2fs_extent_node_split(Object handle) {
		return ModernizedCProgram.extent_node_split(handle, 0);
	}
	public static Object ext2fs_extent_set_bmap(Object handle, Object logical, Object physical, int flags) {
		 ec = new ();
		 retval = 0;
		int mapped = /* logical is mapped? */1;
		int orig_height;
		int extent_uninit = 0;
		int prev_uninit = 0;
		int next_uninit = 0;
		int new_uninit = 0;
		int max_len = EXT_INIT_MAX_LEN;
		int has_prev;
		int has_next;
		 orig_lblk = new ();
		extent_path path = new extent_path();
		ext2fs_extent extent = new ext2fs_extent();
		ext2fs_extent next_extent = new ext2fs_extent();
		ext2fs_extent prev_extent = new ext2fs_extent();
		ext2fs_extent newextent = new ext2fs_extent();
		ext2_extent_info info = new ext2_extent_info();
		if (!(handle) || (handle).getMagic() != (EXT2_ET_MAGIC_EXTENT_HANDLE)) {
			return (EXT2_ET_MAGIC_EXTENT_HANDLE);
		} 
		if (!(handle.getFs().getFlags() & -1024)) {
			return EXT2_ET_RO_FILSYS;
		} 
		if (!handle.getPath()) {
			return EXT2_ET_NO_CURRENT_NODE;
		} 
		path = handle.getPath() + handle.getLevel();
		if (flags & -1024) {
			new_uninit = 1;
			max_len = EXT_UNINIT_MAX_LEN;
		} 
		Object generatedE_flags = newextent.getE_flags();
		if (/* if (re)mapping, set up new extent to insert */physical) {
			newextent.setE_len(1);
			newextent.setE_pblk(physical);
			newextent.setE_lblk(logical);
			newextent.setE_flags(-1024);
			if (new_uninit) {
				generatedE_flags |=  -1024;
			} 
		} 
		int generatedEntries = path.getEntries();
		if ((handle.getMax_depth() == 0) && (generatedEntries == /* special case if the extent tree is completely empty */0)) {
			retval = newextent.ext2fs_extent_insert(handle, 0);
			return retval;
		} 
		if ((retval = extent.ext2fs_extent_get(handle, /* save our original location in the extent tree */-1024))) {
			if (retval != EXT2_ET_NO_CURRENT_NODE) {
				return retval;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(extent, 0, /*Error: sizeof expression not supported yet*/);
		} 
		if ((retval = info.ext2fs_extent_get_info(handle))) {
			return retval;
		} 
		int generatedMax_depth = info.getMax_depth();
		int generatedCurr_level = info.getCurr_level();
		orig_height = generatedMax_depth - generatedCurr_level;
		Object generatedE_lblk = extent.getE_lblk();
		orig_lblk = generatedE_lblk;
		retval = ModernizedCProgram.ext2fs_extent_goto(handle, /* go to the logical spot we want to (re/un)map */logical);
		if (retval) {
			if (retval == EXT2_ET_EXTENT_NOT_FOUND) {
				retval = 0;
				mapped = 0;
				if (!physical) {
					;
				} 
			} else {
					;
			} 
		} 
		retval = extent.ext2fs_extent_get(handle, -1024);
		if (retval) {
			;
		} 
		if (generatedE_flags & -1024) {
			extent_uninit = 1;
		} 
		retval = next_extent.ext2fs_extent_get(handle, -1024);
		if (retval) {
			has_next = 0;
			if (retval != EXT2_ET_EXTENT_NO_NEXT) {
				;
			} 
		} else {
				do {
				} while (0);
				has_next = 1;
				if (generatedE_flags & -1024) {
					next_uninit = 1;
				} 
		} 
		retval = ModernizedCProgram.ext2fs_extent_goto(handle, logical);
		if (retval && retval != EXT2_ET_EXTENT_NOT_FOUND) {
			;
		} 
		retval = prev_extent.ext2fs_extent_get(handle, -1024);
		if (retval) {
			has_prev = 0;
			if (retval != EXT2_ET_EXTENT_NO_PREV) {
				;
			} 
		} else {
				has_prev = 1;
				do {
				} while (0);
				if (generatedE_flags & -1024) {
					prev_uninit = 1;
				} 
		} 
		retval = ModernizedCProgram.ext2fs_extent_goto(handle, logical);
		if (retval && retval != EXT2_ET_EXTENT_NOT_FOUND) {
			;
		} 
		Object generatedE_pblk = extent.getE_pblk();
		if (mapped && (new_uninit == /* check if already pointing to the requested physical */extent_uninit) && (generatedE_pblk + (logical - generatedE_lblk) == physical)) {
			;
		} 
		Object generatedE_len = extent.getE_len();
		if (!mapped) {
			if ((logical == generatedE_lblk + generatedE_len) && (physical == generatedE_pblk + generatedE_len) && (new_uninit == extent_uninit) && ((int)generatedE_len < max_len - 1)) {
				generatedE_len++;
				retval = extent.ext2fs_extent_replace(handle, 0);
			}  else if ((logical == generatedE_lblk - 1) && (physical == generatedE_pblk - 1) && (new_uninit == extent_uninit) && ((int)generatedE_len < max_len - 1)) {
				generatedE_len++;
				generatedE_lblk--;
				generatedE_pblk--;
				retval = extent.ext2fs_extent_replace(handle, 0);
			}  else if (has_next && (logical == generatedE_lblk - 1) && (physical == generatedE_pblk - 1) && (new_uninit == next_uninit) && ((int)generatedE_len < max_len - 1)) {
				retval = next_extent.ext2fs_extent_get(handle, -1024);
				if (retval) {
					;
				} 
				generatedE_len++;
				generatedE_lblk--;
				generatedE_pblk--;
				retval = next_extent.ext2fs_extent_replace(handle, 0);
			}  else if (logical < generatedE_lblk) {
				retval = newextent.ext2fs_extent_insert(handle, 0);
			} else {
					retval = newextent.ext2fs_extent_insert(handle, -1024);
			} 
			if (retval) {
				;
			} 
			retval = ModernizedCProgram.ext2fs_extent_fix_parents(handle);
			if (retval) {
				;
			} 
		}  else if ((logical == generatedE_lblk) && (generatedE_len == 1)) {
			if (physical) {
				retval = newextent.ext2fs_extent_replace(handle, 0);
			} else {
					retval = ModernizedCProgram.ext2fs_extent_delete(handle, 0);
					if (retval) {
						;
					} 
					ec = ModernizedCProgram.ext2fs_extent_fix_parents(handle);
					if (ec != EXT2_ET_NO_CURRENT_NODE) {
						retval = ec;
					} 
			} 
			if (retval) {
				;
			} 
		}  else if (logical == generatedE_lblk + generatedE_len - 1) {
			if (physical) {
				if (has_next && (logical == (generatedE_lblk - 1)) && (physical == (generatedE_pblk - 1)) && (new_uninit == next_uninit) && ((int)generatedE_len < max_len - 1)) {
					retval = next_extent.ext2fs_extent_get(handle, -1024);
					if (retval) {
						;
					} 
					generatedE_len++;
					generatedE_lblk--;
					generatedE_pblk--;
					retval = next_extent.ext2fs_extent_replace(handle, 0);
					if (retval) {
						;
					} 
				} else {
						retval = newextent.ext2fs_extent_insert(handle, -1024);
				} 
				if (retval) {
					;
				} 
				retval = ModernizedCProgram.ext2fs_extent_fix_parents(handle);
				if (retval) {
					;
				} 
				retval = ModernizedCProgram.ext2fs_extent_goto(handle, logical);
				if (retval) {
					;
				} 
				retval = extent.ext2fs_extent_get(handle, -1024);
				if (retval) {
					;
				} 
			} 
			generatedE_len--;
			retval = extent.ext2fs_extent_replace(handle, 0);
			if (retval) {
				;
			} 
		}  else if (logical == generatedE_lblk) {
			if (physical) {
				if (has_prev && (logical == (generatedE_lblk + generatedE_len)) && (physical == (generatedE_pblk + generatedE_len)) && (new_uninit == prev_uninit) && ((int)generatedE_len < max_len - 1)) {
					retval = prev_extent.ext2fs_extent_get(handle, -1024);
					if (retval) {
						;
					} 
					generatedE_len++;
					retval = prev_extent.ext2fs_extent_replace(handle, 0);
				} else {
						retval = newextent.ext2fs_extent_insert(handle, 0);
				} 
				if (retval) {
					;
				} 
				retval = ModernizedCProgram.ext2fs_extent_fix_parents(handle);
				if (retval) {
					;
				} 
				retval = extent.ext2fs_extent_get(handle, -1024);
				if (retval) {
					;
				} 
			} 
			generatedE_pblk++;
			generatedE_lblk++;
			generatedE_len--;
			retval = extent.ext2fs_extent_replace(handle, 0);
			if (retval) {
				;
			} 
			retval = ModernizedCProgram.ext2fs_extent_fix_parents(handle);
			if (retval) {
				;
			} 
		} else {
				 save_length = new ();
				 save_lblk = new ();
				ext2fs_extent save_extent = new ext2fs_extent();
				 r2 = new ();
				save_lblk = generatedE_lblk;
				save_length = generatedE_len;
				save_extent = extent;
				extent.setE_len((logical - generatedE_lblk));
				retval = extent.ext2fs_extent_replace(handle, 0);
				if (retval) {
					;
				} 
				if (/* insert our new extent, if any */physical) {
					retval = newextent.ext2fs_extent_insert(/* insert new extent after current */handle, -1024);
					if (retval) {
						r2 = ModernizedCProgram.ext2fs_extent_goto(handle, save_lblk);
						if (r2 == 0) {
							(Object)save_extent.ext2fs_extent_replace(handle, 0);
						} 
						;
					} 
				} 
				generatedE_pblk += generatedE_len + /* add post-split extent */1;
				generatedE_lblk += generatedE_len + 1;
				extent.setE_len(save_length - generatedE_len - 1);
				retval = extent.ext2fs_extent_insert(handle, -1024);
				if (retval) {
					if (physical) {
						r2 = ModernizedCProgram.ext2fs_extent_goto(handle, generatedE_lblk);
						if (r2 == 0) {
							(Object)ModernizedCProgram.ext2fs_extent_delete(handle, 0);
						} 
					} 
					r2 = ModernizedCProgram.ext2fs_extent_goto(handle, save_lblk);
					if (r2 == 0) {
						(Object)save_extent.ext2fs_extent_replace(handle, 0);
					} 
					;
				} 
		} 
		ModernizedCProgram.ext2fs_extent_goto2(handle, orig_height, orig_lblk);
		return retval;
	}
	public static Object ext2fs_extent_delete(Object handle, int flags) {
		extent_path path = new extent_path();
		byte cp;
		ext3_extent_header eh = new ext3_extent_header();
		 retval = 0;
		if (!(handle) || (handle).getMagic() != (EXT2_ET_MAGIC_EXTENT_HANDLE)) {
			return (EXT2_ET_MAGIC_EXTENT_HANDLE);
		} 
		if (!(handle.getFs().getFlags() & -1024)) {
			return EXT2_ET_RO_FILSYS;
		} 
		if (!handle.getPath()) {
			return EXT2_ET_NO_CURRENT_NODE;
		} 
		path = handle.getPath() + handle.getLevel();
		Object generatedCurr = path.getCurr();
		if (!generatedCurr) {
			return EXT2_ET_NO_CURRENT_NODE;
		} 
		cp = generatedCurr;
		int generatedLeft = path.getLeft();
		if (generatedLeft) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memmove(cp, cp + /*Error: Unsupported expression*/, generatedLeft * /*Error: Unsupported expression*/);
			generatedLeft--;
		} else {
				ext3_extent_idx ix = generatedCurr;
				ix--;
				path.setCurr(ix);
		} 
		int generatedEntries = path.getEntries();
		if (--generatedEntries == 0) {
			path.setCurr(0);
		} 
		Object generatedE_pblk = extent.getE_pblk();
		Byte generatedBuf = path.getBuf();
		if (generatedEntries == 0 && handle.getLevel()) {
			if (!(flags & -1024)) {
				ext2fs_extent extent = new ext2fs_extent();
				retval = extent.ext2fs_extent_get(handle, -1024);
				if (retval) {
					return retval;
				} 
				retval = ModernizedCProgram.ext2fs_extent_delete(handle, flags);
				handle.getInode().getI_blocks() -= (handle.getFs().getBlocksize() * (-1024 << (handle.getFs()).getCluster_ratio_bits())) / 512;
				retval = handle.getInode().ext2fs_write_inode(handle.getFs(), handle.getIno());
				ModernizedCProgram.ext2fs_block_alloc_stats2(handle.getFs(), generatedE_pblk, -1);
			} 
		} else {
				eh = (ext3_extent_header)generatedBuf;
				eh.setExt3_extent_header(/*Error: Function owner not recognized*/ext2fs_cpu_to_le16(generatedEntries));
				if ((generatedEntries == 0) && (handle.getLevel() == 0)) {
					eh.setExt3_extent_header(0);
					handle.setMax_depth(0);
				} 
				retval = ModernizedCProgram.update_path(handle);
		} 
		return retval;
	}
	public static int ul_log2(long arg) {
		int l = 0;
		arg >>=  1;
		while (arg) {
			l++;
			arg >>=  1;
		}
		return l;
	}
	public static Object ext2fs_max_extent_depth(Object handle) {
		size_t iblock_sz = /*Error: sizeof expression not supported yet*/;
		size_t iblock_extents = (iblock_sz - /*Error: Unsupported expression*/) / /*Error: Unsupported expression*/;
		size_t extents_per_block = (handle.getFs().getBlocksize() - /*Error: Unsupported expression*/) / /*Error: Unsupported expression*/;
		int last_blocksize = 0;
		size_t last_result = 0;
		if (last_blocksize && last_blocksize == handle.getFs().getBlocksize()) {
			return last_result;
		} 
		if (ModernizedCProgram.ul_log2(extents_per_block) == 0) {
			return last_result;
		} 
		// coverity[divide_by_zero]// coverity[divide_by_zero]last_result = 1 + ((ModernizedCProgram.ul_log2(EXT_MAX_EXTENT_LBLK) - ModernizedCProgram.ul_log2(iblock_extents)) / ModernizedCProgram.ul_log2(extents_per_block));
		last_blocksize = handle.getFs().getBlocksize();
		return last_result;
	}
	/*
	 * alloc_stats.c --- Update allocation statistics for ext2fs
	 *
	 * Copyright (C) 2001 Theodore Ts'o.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	public static void ext2fs_inode_alloc_stats2(Object fs, Object ino, int inuse, int isdir) {
		int group = ModernizedCProgram.ext2fs_group_of_ino(fs, ino);
		if (ino > fs.getSuper().getS_inodes_count()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err("ext2fs_inode_alloc_stats2", 0, "Illegal inode number: %lu", (long)ino);
			return /*Error: Unsupported expression*/;
		} 
		if (inuse > 0) {
			ModernizedCProgram.ext2fs_mark_inode_bitmap2(fs.getInode_map(), ino);
		} else {
				ModernizedCProgram.ext2fs_unmark_inode_bitmap2(fs.getInode_map(), ino);
		} 
		ModernizedCProgram.ext2fs_bg_free_inodes_count_set(fs, group, ModernizedCProgram.ext2fs_bg_free_inodes_count(fs, group) - inuse);
		if (isdir) {
			ModernizedCProgram.ext2fs_bg_used_dirs_count_set(fs, group, ModernizedCProgram.ext2fs_bg_used_dirs_count(fs, group) + inuse);
		} 
		ModernizedCProgram.ext2fs_bg_flags_clear(fs, group, /* We don't strictly need to be clearing the uninit flag if inuse < 0
			 * (i.e. freeing inodes) but it also means something is bad. */-1024);
		if (ModernizedCProgram.ext2fs_has_group_desc_csum(fs)) {
			 first_unused_inode = fs.getSuper().getS_inodes_per_group() - ModernizedCProgram.ext2fs_bg_itable_unused(fs, group) + group * fs.getSuper().getS_inodes_per_group() + 1;
			if (ino >= first_unused_inode) {
				ModernizedCProgram.ext2fs_bg_itable_unused_set(fs, group, group * fs.getSuper().getS_inodes_per_group() + fs.getSuper().getS_inodes_per_group() - ino);
			} 
			ModernizedCProgram.ext2fs_group_desc_csum_set(fs, group);
		} 
		fs.getSuper().getS_free_inodes_count() -= inuse;
		ModernizedCProgram.ext2fs_mark_super_dirty(fs);
		ModernizedCProgram.ext2fs_mark_ib_dirty(fs);
	}
	public static void ext2fs_inode_alloc_stats(Object fs, Object ino, int inuse) {
		ModernizedCProgram.ext2fs_inode_alloc_stats2(fs, ino, inuse, 0);
	}
	public static void ext2fs_block_alloc_stats2(Object fs, Object blk, int inuse) {
		int group = ModernizedCProgram.ext2fs_group_of_blk2(fs, blk);
		if (blk >= fs.getSuper().ext2fs_blocks_count()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err("ext2fs_block_alloc_stats", 0, "Illegal block number: %lu", (long)blk);
			return /*Error: Unsupported expression*/;
		} 
		if (inuse > 0) {
			ModernizedCProgram.ext2fs_mark_block_bitmap2(fs.getBlock_map(), blk);
		} else {
				ModernizedCProgram.ext2fs_unmark_block_bitmap2(fs.getBlock_map(), blk);
		} 
		ModernizedCProgram.ext2fs_bg_free_blocks_count_set(fs, group, ModernizedCProgram.ext2fs_bg_free_blocks_count(fs, group) - inuse);
		ModernizedCProgram.ext2fs_bg_flags_clear(fs, group, -1024);
		ModernizedCProgram.ext2fs_group_desc_csum_set(fs, group);
		fs.getSuper().ext2fs_free_blocks_count_add(-inuse * /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(-1024 << (fs).getCluster_ratio_bits()));
		ModernizedCProgram.ext2fs_mark_super_dirty(fs);
		ModernizedCProgram.ext2fs_mark_bb_dirty(fs);
		if (fs.getBlock_alloc_stats()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, ()blk, inuse);
		} 
	}
	public static void ext2fs_block_alloc_stats(Object fs, Object blk, int inuse) {
		ModernizedCProgram.ext2fs_block_alloc_stats2(fs, blk, inuse);
	}
	public static void ext2fs_set_block_alloc_stats_callback(Object fs, Object func, Object old) {
		if (!fs || fs.getMagic() != EXT2_ET_MAGIC_EXT2FS_FILSYS) {
			return /*Error: Unsupported expression*/;
		} 
		if (old) {
			old = fs.getBlock_alloc_stats();
		} 
		fs.setBlock_alloc_stats(func);
	}
	public static void ext2fs_block_alloc_stats_range(Object fs, Object blk, Object num, int inuse) {
		if (blk + num > fs.getSuper().ext2fs_blocks_count()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/com_err("ext2fs_block_alloc_stats_range", 0, "Illegal block range: %llu (%u) ", (long)blk, num);
			return /*Error: Unsupported expression*/;
		} 
		if (inuse == 0) {
			return /*Error: Unsupported expression*/;
		} 
		if (inuse > 0) {
			ModernizedCProgram.ext2fs_mark_block_bitmap_range2(fs.getBlock_map(), blk, num);
			inuse = 1;
		} else {
				ModernizedCProgram.ext2fs_unmark_block_bitmap_range2(fs.getBlock_map(), blk, num);
				inuse = -1;
		} 
		while (num) {
			int group = ModernizedCProgram.ext2fs_group_of_blk2(fs, blk);
			 last_blk = ModernizedCProgram.ext2fs_group_last_block2(fs, group);
			 n = num;
			if (blk + num > last_blk) {
				n = last_blk - blk + 1;
			} 
			ModernizedCProgram.ext2fs_bg_free_blocks_count_set(fs, group, ModernizedCProgram.ext2fs_bg_free_blocks_count(fs, group) - inuse * n / (-1024 << (fs).getCluster_ratio_bits()));
			ModernizedCProgram.ext2fs_bg_flags_clear(fs, group, -1024);
			ModernizedCProgram.ext2fs_group_desc_csum_set(fs, group);
			fs.getSuper().ext2fs_free_blocks_count_add(-inuse * ()n);
			blk += n;
			num -= n;
		}
		ModernizedCProgram.ext2fs_mark_super_dirty(fs);
		ModernizedCProgram.ext2fs_mark_bb_dirty(fs);
		if (fs.getBlock_alloc_stats_range()) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(fs, blk, num, inuse);
		} 
	}
	public static void ext2fs_set_block_alloc_stats_range_callback(Object fs, Object func, Object old) {
		if (!fs || fs.getMagic() != EXT2_ET_MAGIC_EXT2FS_FILSYS) {
			return /*Error: Unsupported expression*/;
		} 
		if (old) {
			old = fs.getBlock_alloc_stats_range();
		} 
		fs.setBlock_alloc_stats_range(func);
	}
	// (empty) check box width, (empty) drop down width, button height (for and without dropdown match)
	// Row Height, DropDown Height, Main button width, half dropdown width, full dropdown width
	// See GetFullWidth() for details on how these values are used
	// shifted +1 so that we can subtract 1 to OP indexes
	// Set the combo selection according to the data
	public static void SetComboEntry(Object hDlg, int data) {
		int i;
		int nb_entries = ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hDlg), 326, 0, 0));
		if (nb_entries <= 0) {
			return /*Error: Unsupported expression*/;
		} 
		for (i = 0; i < nb_entries; i++) {
			if (((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hDlg), 336, (WPARAM)(int)(i), 0)) == data) {
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hDlg), 334, (WPARAM)(int)(i), 0)));
				} while (0);
				return /*Error: Unsupported expression*/;
			} 
		}
		if (i == nb_entries) {
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hDlg), 334, (WPARAM)(int)(false), 0)));
			} while (0);
		} 
	}
	// Move a control along the Y axis
	public static void MoveCtrlY(Object hDlg, int nID, int vertical_shift) {
		ModernizedCProgram.ResizeMoveCtrl(hDlg, /*Error: Function owner not recognized*/GetDlgItem(hDlg, nID), 0, vertical_shift, 0, 0, 1.0);
	}
	// https://stackoverflow.com/a/20926332/1069307
	// https://msdn.microsoft.com/en-us/library/windows/desktop/bb226818.aspx
	public static void GetBasicControlsWidth(Object hDlg) {
		int checkbox_internal_spacing = 12;
		int dropdown_internal_spacing = 15;
		RECT rc = new RECT(0, 0, 4, 8);
		SIZE sz = new SIZE();
		// Compute base unit sizes since GetDialogBaseUnits() returns garbage data.
		/*Error: Function owner not recognized*/// See http://support.microsoft.com/kb/125681/*Error: Function owner not recognized*/// See http://support.microsoft.com/kb/125681MapDialogRect(hDlg, rc);
		Object generatedRight = rc.getRight();
		sz.setCx(generatedRight);
		Object generatedBottom = rc.getBottom();
		sz.setCy(generatedBottom);
		// TODO: figure out the specifics of each Windows versionif (ModernizedCProgram.nWindowsVersion == WindowsVersion.WINDOWS_10) {
			checkbox_internal_spacing = 10;
			dropdown_internal_spacing = 13;
		} 
		Object generatedCx = sz.getCx();
		// Checkbox and (blank) dropdown widths// Checkbox and (blank) dropdown widthsModernizedCProgram.cbw = /*Error: Function owner not recognized*/MulDiv(checkbox_internal_spacing, generatedCx, 4);
		ModernizedCProgram.ddw = /*Error: Function owner not recognized*/MulDiv(dropdown_internal_spacing, generatedCx, 4);
		/*Error: Function owner not recognized*/// Spacing width between half-length dropdowns (sep) as well as left margin/*Error: Function owner not recognized*/// Spacing width between half-length dropdowns (sep) as well as left marginGetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1017), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		Object generatedLeft = rc.getLeft();
		ModernizedCProgram.sw = generatedLeft;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1004), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.sw -= generatedRight;
		ModernizedCProgram.mw = generatedLeft;
		/*Error: Function owner not recognized*/// Small button width/*Error: Function owner not recognized*/// Small button widthSendMessageA(ModernizedCProgram.hSaveToolbar, TB_GETIDEALSIZE, (WPARAM)0, (LPARAM)sz);
		ModernizedCProgram.sbw = generatedCx;
		/*Error: Function owner not recognized*/// Small separator widths and button height/*Error: Function owner not recognized*/// Small separator widths and button heightGetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1024), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		Object generatedTop = rc.getTop();
		ModernizedCProgram.bh = generatedBottom - generatedTop;
		ModernizedCProgram.ssw = generatedLeft;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(ModernizedCProgram.hDeviceList, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.ssw -= generatedRight;
		/*Error: Function owner not recognized*/// CSM tooltip separator width/*Error: Function owner not recognized*/// CSM tooltip separator widthGetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2005), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.tw = generatedLeft;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(ModernizedCProgram.hTargetSystem, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.tw -= generatedRight;
	}
	// Compute the minimum size of the main buttons
	public static void GetMainButtonsWidth(Object hDlg) {
		int i;
		RECT rc = new RECT();
		LONG style = new LONG();
		byte[] download = new byte[64];
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, ModernizedCProgram.main_button_ids[0]), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		Object generatedRight = rc.getRight();
		Object generatedLeft = rc.getLeft();
		ModernizedCProgram.bw = generatedRight - generatedLeft;
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			ModernizedCProgram.bw = ((ModernizedCProgram.bw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, ModernizedCProgram.main_button_ids[i]), ((Object)0)).getCx() + ((ModernizedCProgram.enable_fido && i == 0) ? (3 * ModernizedCProgram.cbw) / 2 : ModernizedCProgram.cbw)) ? (ModernizedCProgram.bw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, ModernizedCProgram.main_button_ids[i]), ((Object)0)).getCx() + ((ModernizedCProgram.enable_fido && i == 0) ? (3 * ModernizedCProgram.cbw) / 2 : ModernizedCProgram.cbw)));
		}// Make sure we add extra space for the SELECT split button (i == 0) if Fido is enabled
		// want to add "DOWNLOAD" into the Select split button => measure that too.// want to add "DOWNLOAD" into the Select split button => measure that too.ModernizedCProgram.bw = ((ModernizedCProgram.bw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), ModernizedCProgram.lmprintf(3007)).getCx() + ModernizedCProgram.cbw) ? (ModernizedCProgram.bw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2), ModernizedCProgram.lmprintf(3007)).getCx() + ModernizedCProgram.cbw));
		if (ModernizedCProgram.enable_fido) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(download, ModernizedCProgram.lmprintf(3040), (((size_t)(((((byte)ModernizedCProgram.lmprintf(3040)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3040))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.lmprintf(3040)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3040))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
				((byte)download)[(((size_t)(((((byte)ModernizedCProgram.lmprintf(3040)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3040))) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)ModernizedCProgram.lmprintf(3040)) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(ModernizedCProgram.lmprintf(3040))) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
			} while (0);
			ModernizedCProgram.CharUpperBuffU(download, /*Error: sizeof expression not supported yet*/);
			ModernizedCProgram.bw = ((ModernizedCProgram.bw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1014), download).getCx() + (3 * ModernizedCProgram.cbw) / 2) ? (ModernizedCProgram.bw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1014), download).getCx() + (3 * ModernizedCProgram.cbw) / 2));
			style = /*Error: Function owner not recognized*/GetWindowLongA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1014), (true));
			style |=  BS_SPLITBUTTON;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowLongA(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1014), (true), style);
		} 
	}
	// The following goes over the data that gets populated into the half-width dropdowns
	// (Partition scheme, Target System, Disk ID, File system, Cluster size, Nb passes)
	// to figure out the minimum width we should allocate.
	public static void GetHalfDropwdownWidth(Object hDlg) {
		RECT rc = new RECT();
		int i;
		int j;
		int msg_id;
		byte[] tmp = new byte[256];
		/*Error: Function owner not recognized*/// Initialize half width to the UI's default size/*Error: Function owner not recognized*/// Initialize half width to the UI's default sizeGetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1004), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		Object generatedRight = rc.getRight();
		Object generatedLeft = rc.getLeft();
		ModernizedCProgram.hw = generatedRight - generatedLeft - ModernizedCProgram.ddw;
		// "Super Floppy Disk" is the longuest entry in the Partition Scheme dropdown// "Super Floppy Disk" is the longuest entry in the Partition Scheme dropdownModernizedCProgram.hw = ((ModernizedCProgram.hw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1004), (byte)ModernizedCProgram.sfd_name).getCx()) ? (ModernizedCProgram.hw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1004), (byte)ModernizedCProgram.sfd_name).getCx()));
		// This is basically the same as SetClusterSizeLabels() except we're adding (Default) to each entryfor (; j < 18; ) {
			if (i > 8192) {
				i /= 1024;
				msg_id++;
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, 64, "%d %s", i, ModernizedCProgram.lmprintf(msg_id));
				(tmp)[(true) - 1] = 0;
			} while (0);
			ModernizedCProgram.hw = ((ModernizedCProgram.hw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1005), ModernizedCProgram.lmprintf(3030, tmp)).getCx()) ? (ModernizedCProgram.hw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1005), ModernizedCProgram.lmprintf(3030, tmp)).getCx()));
		}
		// We do however go over the BIOS vs UEFI entries, as some of these are translatedfor (msg_id = 3031; msg_id <= 3033; msg_id++) {
			ModernizedCProgram.hw = ((ModernizedCProgram.hw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1017), ModernizedCProgram.lmprintf(msg_id)).getCx()) ? (ModernizedCProgram.hw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1017), ModernizedCProgram.lmprintf(msg_id)).getCx()));
		}
		// Just in case, we also do the number of passesfor (i = 1; i <= 5; i++) {
			byte msg = (i == 1) ? ModernizedCProgram.lmprintf(3034, 1) : ModernizedCProgram.lmprintf(3035, (i == 2) ? 2 : 4, (i == 2) ? "" : ModernizedCProgram.lmprintf(3087, ModernizedCProgram.flash_type[i - 3]));
			ModernizedCProgram.hw = ((ModernizedCProgram.hw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1017), msg).getCx()) ? (ModernizedCProgram.hw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1017), msg).getCx()));
		}
		// Finally, we must ensure that we'll have enough space for the 2 checkbox controls// that end up with a half dropdown// Finally, we must ensure that we'll have enough space for the 2 checkbox controls// that end up with a half dropdownModernizedCProgram.hw = ((ModernizedCProgram.hw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1016), ((Object)0)).getCx() - ModernizedCProgram.sw) ? (ModernizedCProgram.hw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1016), ((Object)0)).getCx() - ModernizedCProgram.sw));
		ModernizedCProgram.hw = ((ModernizedCProgram.hw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1009), ((Object)0)).getCx() - ModernizedCProgram.sw) ? (ModernizedCProgram.hw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1009), ((Object)0)).getCx() - ModernizedCProgram.sw));
		// Add the width of a blank dropdown// Add the width of a blank dropdownModernizedCProgram.hw += ModernizedCProgram.ddw/*
		* dbw = dialog border width
		* mw  = margin width
		* fw  = full dropdown width
		* hd  = half dropdown width
		* bsw = boot selection dropdown width
		* sw  = separator width
		* ssw = small separator width
		* bw  = button width
		* sbw = small button width
		*
		*      |                        fw                            |
		*      |          bsw          | ssw | sbw | ssw |     bw     |
		*  8 ->|<-      96       ->|<-    24    ->|<-      96       ->|<- 8
		*  mw  |        hw         |      sw      |        hw         |  mw
		*                             |     bw     | ssw |     bw     |
		*/;
	}
	public static void GetFullWidth(Object hDlg) {
		RECT rc = new RECT();
		int i;
		/*Error: Function owner not recognized*/// Get the dialog border width/*Error: Function owner not recognized*/// Get the dialog border widthGetWindowRect(hDlg, rc);
		Object generatedRight = rc.getRight();
		Object generatedLeft = rc.getLeft();
		ModernizedCProgram.dbw = generatedRight - generatedLeft;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetClientRect(hDlg, rc);
		ModernizedCProgram.dbw -= generatedRight - generatedLeft;
		/*Error: Function owner not recognized*/// Compute the minimum size needed for the Boot Selection dropdown/*Error: Function owner not recognized*/// Compute the minimum size needed for the Boot Selection dropdownGetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1011), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.bsw = ((generatedRight - generatedLeft) > (ModernizedCProgram.GetTextSize(ModernizedCProgram.hBootType, ModernizedCProgram.lmprintf(3279)).getCx() + ModernizedCProgram.ddw) ? (generatedRight - generatedLeft) : (ModernizedCProgram.GetTextSize(ModernizedCProgram.hBootType, ModernizedCProgram.lmprintf(3279)).getCx() + ModernizedCProgram.ddw));
		ModernizedCProgram.bsw = ((ModernizedCProgram.bsw) > (ModernizedCProgram.GetTextSize(ModernizedCProgram.hBootType, ModernizedCProgram.lmprintf(3281, ModernizedCProgram.lmprintf(3280))).getCx() + ModernizedCProgram.ddw) ? (ModernizedCProgram.bsw) : (ModernizedCProgram.GetTextSize(ModernizedCProgram.hBootType, ModernizedCProgram.lmprintf(3281, ModernizedCProgram.lmprintf(3280))).getCx() + ModernizedCProgram.ddw));
		/*Error: Function owner not recognized*/// Initialize full width to the UI's default size/*Error: Function owner not recognized*/// Initialize full width to the UI's default sizeGetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 2000), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.fw = generatedRight - generatedLeft - ModernizedCProgram.ddw;
		// Go through the Image Options for Windows To Go// Go through the Image Options for Windows To GoModernizedCProgram.fw = ((ModernizedCProgram.fw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1026), ModernizedCProgram.lmprintf(3117)).getCx()) ? (ModernizedCProgram.fw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1026), ModernizedCProgram.lmprintf(3117)).getCx()));
		ModernizedCProgram.fw = ((ModernizedCProgram.fw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1026), ModernizedCProgram.lmprintf(3118)).getCx()) ? (ModernizedCProgram.fw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1026), ModernizedCProgram.lmprintf(3118)).getCx()));
		// Now deal with full length checkbox linesfor (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			ModernizedCProgram.fw = ((ModernizedCProgram.fw) > (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, ModernizedCProgram.full_width_checkboxes[i]), ((Object)0)).getCx()) ? (ModernizedCProgram.fw) : (ModernizedCProgram.GetTextSize(/*Error: Function owner not recognized*/GetDlgItem(hDlg, ModernizedCProgram.full_width_checkboxes[i]), ((Object)0)).getCx()));
		}
		// All of the above is for text only, so we need to add dd space// All of the above is for text only, so we need to add dd spaceModernizedCProgram.fw += ModernizedCProgram.ddw;
		// Our min also needs to be longer than 2 half length dropdowns + spacer// Our min also needs to be longer than 2 half length dropdowns + spacerModernizedCProgram.fw = ((ModernizedCProgram.fw) > (2 * ModernizedCProgram.hw + ModernizedCProgram.sw) ? (ModernizedCProgram.fw) : (2 * ModernizedCProgram.hw + ModernizedCProgram.sw))// Now that we have our minimum full width, adjust the button width if needed;// Now that we have our minimum full width, adjust the button width if needed
		// Adjust according to min full width// Adjust according to min full widthModernizedCProgram.bw = ((ModernizedCProgram.bw) > ((ModernizedCProgram.fw - 2 * ModernizedCProgram.ssw - ModernizedCProgram.sw) / 4) ? (ModernizedCProgram.bw) : ((ModernizedCProgram.fw - 2 * ModernizedCProgram.ssw - ModernizedCProgram.sw) / 4))// Adjust according to min boot selection width;// Adjust according to min boot selection width
		ModernizedCProgram.bw = ((ModernizedCProgram.bw) > ((ModernizedCProgram.bsw + ModernizedCProgram.sbw - ModernizedCProgram.sw) / 3) ? (ModernizedCProgram.bw) : ((ModernizedCProgram.bsw + ModernizedCProgram.sbw - ModernizedCProgram.sw) / 3));
		// Adjust according to min half width// Adjust according to min half widthModernizedCProgram.bw = ((ModernizedCProgram.bw) > ((ModernizedCProgram.hw / 2) - ModernizedCProgram.ssw) ? (ModernizedCProgram.bw) : ((ModernizedCProgram.hw / 2) - ModernizedCProgram.ssw));
		// Now that our button width is set, we can adjust the rest// Now that our button width is set, we can adjust the restModernizedCProgram.hw = ((ModernizedCProgram.hw) > (2 * ModernizedCProgram.bw + ModernizedCProgram.ssw) ? (ModernizedCProgram.hw) : (2 * ModernizedCProgram.bw + ModernizedCProgram.ssw));
		ModernizedCProgram.fw = ((ModernizedCProgram.fw) > (2 * ModernizedCProgram.hw + ModernizedCProgram.sw) ? (ModernizedCProgram.fw) : (2 * ModernizedCProgram.hw + ModernizedCProgram.sw));
		ModernizedCProgram.bsw = ((ModernizedCProgram.bsw) > (ModernizedCProgram.fw - ModernizedCProgram.bw - 2 * ModernizedCProgram.ssw - ModernizedCProgram.sbw) ? (ModernizedCProgram.bsw) : (ModernizedCProgram.fw - ModernizedCProgram.bw - 2 * ModernizedCProgram.ssw - ModernizedCProgram.sbw))// TODO: Also pick a few choice messages from info/status;// TODO: Also pick a few choice messages from info/status
	}
	public static void PositionMainControls(Object hDlg) {
		RECT rc = new RECT();
		HWND hCtrl = new HWND();
		HWND hPrevCtrl = new HWND();
		SIZE sz = new SIZE();
		DWORD padding = new DWORD();
		int i;
		int x;
		int button_fudge = 2;
		/*Error: Function owner not recognized*/// Start by resizing the whole dialog/*Error: Function owner not recognized*/// Start by resizing the whole dialogGetWindowRect(hDlg, rc)// Don't forget to add the dialog border width, since we resize the whole dialog;// Don't forget to add the dialog border width, since we resize the whole dialog
		Object generatedBottom = rc.getBottom();
		Object generatedTop = rc.getTop();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hDlg, ((Object)0), -1, -1, ModernizedCProgram.fw + 2 * ModernizedCProgram.mw + ModernizedCProgram.dbw, generatedBottom - generatedTop, -1024 | -1024);
		// Resize the height of the label, persistence size and progress bar to the height of standard dropdowns// Resize the height of the label, persistence size and progress bar to the height of standard dropdownshCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1001);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.ddh = generatedBottom - generatedTop;
		ModernizedCProgram.ddbh = ModernizedCProgram.ddh + button_fudge;
		ModernizedCProgram.bh = ((ModernizedCProgram.bh) > (ModernizedCProgram.ddbh) ? (ModernizedCProgram.bh) : (ModernizedCProgram.ddbh));
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1007);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		Object generatedLeft = rc.getLeft();
		Object generatedRight = rc.getRight();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, ModernizedCProgram.hAdvancedFormatToolbar, generatedLeft, generatedTop, generatedRight - generatedLeft, ModernizedCProgram.ddh, -1024);
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1018);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1027), generatedLeft, generatedTop, generatedRight - generatedLeft, ModernizedCProgram.ddh, -1024);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(ModernizedCProgram.hProgress, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(ModernizedCProgram.hProgress, ModernizedCProgram.hNBPasses, generatedLeft, generatedTop, generatedRight - generatedLeft, ModernizedCProgram.ddh, -1024);
		// Get the height of a typical row// Get the height of a typical rowhCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 2015);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.rh = generatedTop;
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 2000);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.rh -= generatedTop;
		// Get the height of the advanced options// Get the height of the advanced optionshCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1022);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.advanced_device_section_height = generatedTop;
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1016);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.advanced_device_section_height = generatedBottom - ModernizedCProgram.advanced_device_section_height;
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1008);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.advanced_format_section_height = generatedTop;
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1009);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		ModernizedCProgram.advanced_format_section_height = generatedBottom - ModernizedCProgram.advanced_format_section_height;
		// Get the vertical position of the sections text// Get the vertical position of the sections texthCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 2016);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		sz = ModernizedCProgram.GetTextSize(hCtrl, ((Object)0));
		Object generatedCy = sz.getCy();
		ModernizedCProgram.section_vpos[0] = generatedTop + 2 * generatedCy / 3;
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 2017);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		sz = ModernizedCProgram.GetTextSize(hCtrl, ((Object)0));
		ModernizedCProgram.section_vpos[1] = generatedTop + 2 * generatedCy / 3;
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 2018);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		sz = ModernizedCProgram.GetTextSize(hCtrl, ((Object)0));
		ModernizedCProgram.section_vpos[2] = generatedTop + 2 * generatedCy / 3// Seriously, who designed this bullshit API call where you pass a SIZE;// Seriously, who designed this bullshit API call where you pass a SIZE
		/*Error: Function owner not recognized*/// struct but can only retrieve one of cx or cy at a time?!?/*Error: Function owner not recognized*/// struct but can only retrieve one of cx or cy at a time?!?SendMessageA(ModernizedCProgram.hMultiToolbar, TB_GETIDEALSIZE, (WPARAM)0, (LPARAM)sz);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1052), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		Object generatedCx = sz.getCx();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(ModernizedCProgram.hMultiToolbar, ModernizedCProgram.hProgress, generatedLeft, generatedTop, generatedCx, ModernizedCProgram.ddbh, 0);
		// Reposition the main buttonsfor (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, ModernizedCProgram.main_button_ids[i]);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
			x = ModernizedCProgram.mw + ModernizedCProgram.fw - ModernizedCProgram.bw;
			if (i % 2 == 1) {
				x -= ModernizedCProgram.bw + ModernizedCProgram.ssw;
			} 
			hPrevCtrl = /*Error: Function owner not recognized*/GetWindow(hCtrl, 3);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, hPrevCtrl, x, generatedTop, ModernizedCProgram.bw, ModernizedCProgram.ddbh, 0);
		}
		// Reposition the Save button// Reposition the Save buttonhCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1024);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hSaveToolbar, TB_GETIDEALSIZE, (WPARAM)0, (LPARAM)sz);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hSaveToolbar, (1024 + 31), 0, ((LPARAM)((LONG)(((WORD)(generatedCx)) | (((DWORD)((WORD)(ModernizedCProgram.ddbh))) << 16)))))// Microsoft, how I loathe thee!!!;// Microsoft, how I loathe thee!!!
		padding = (DWORD)/*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hSaveToolbar, TB_GETPADDING, 0, 0);
		sz.setCx(padding & -1024);
		sz.setCy(padding >> 16);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hSaveToolbar, TB_SETPADDING, 0, ((LPARAM)((LONG)(((WORD)(generatedCx + 3)) | (((DWORD)((WORD)(generatedCy + 2))) << 16)))));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(ModernizedCProgram.hSaveToolbar, ModernizedCProgram.hDeviceList, ModernizedCProgram.mw + ModernizedCProgram.fw - ModernizedCProgram.sbw, generatedTop, ModernizedCProgram.sbw, ModernizedCProgram.ddbh, 0);
		// Reposition the Hash button// Reposition the Hash buttonhCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1025);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hHashToolbar, TB_GETIDEALSIZE, (WPARAM)0, (LPARAM)sz);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hHashToolbar, (1024 + 31), 0, ((LPARAM)((LONG)(((WORD)(generatedCx)) | (((DWORD)((WORD)(ModernizedCProgram.ddbh))) << 16)))));
		padding = (DWORD)/*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hHashToolbar, TB_GETPADDING, 0, 0);
		sz.setCx(padding & -1024);
		sz.setCy(padding >> 16);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hHashToolbar, TB_SETPADDING, 0, ((LPARAM)((LONG)(((WORD)(generatedCx + 3)) | (((DWORD)((WORD)(generatedCy + 2))) << 16)))));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(ModernizedCProgram.hHashToolbar, ModernizedCProgram.hBootType, ModernizedCProgram.mw + ModernizedCProgram.bsw + ModernizedCProgram.ssw, generatedTop, ModernizedCProgram.sbw, ModernizedCProgram.ddbh, 0);
		// Reposition the Persistence slider and resize it to the boot selection width// Reposition the Persistence slider and resize it to the boot selection widthhCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1027);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1026), ModernizedCProgram.mw, generatedTop, ModernizedCProgram.bsw, generatedBottom - generatedTop, 0);
		// Reposition the Persistence Units dropdown (no need to resize)// Reposition the Persistence Units dropdown (no need to resize)hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1019);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		sz.setCx(ModernizedCProgram.fw - (generatedRight - generatedLeft));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1018), ModernizedCProgram.mw + generatedCx, generatedTop, generatedRight - generatedLeft, generatedBottom - generatedTop, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(hCtrl, 0);
		// Reposition and resize the Persistence Size edit// Reposition and resize the Persistence Size edithCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1018);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1027), ModernizedCProgram.mw + ModernizedCProgram.bsw + ModernizedCProgram.ssw, generatedTop, ModernizedCProgram.fw - ModernizedCProgram.bsw - ModernizedCProgram.ssw, generatedBottom - generatedTop, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(hCtrl, 0);
		// Reposition the CSM help tip// Reposition the CSM help tiphCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 2005);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, ModernizedCProgram.hTargetSystem, ModernizedCProgram.mw + ModernizedCProgram.fw + ModernizedCProgram.tw, generatedTop, ModernizedCProgram.sbw, generatedBottom - generatedTop, 0);
		if (ModernizedCProgram.advanced_mode_device) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(ModernizedCProgram.hDeviceList, rc);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), ModernizedCProgram.hMainDialog, (POINT)rc, 2);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(ModernizedCProgram.hDeviceList, ((HWND)0), generatedLeft, generatedTop, ModernizedCProgram.fw - ModernizedCProgram.ssw - ModernizedCProgram.sbw, generatedBottom - generatedTop, 0);
		} 
		// Still need to adjust the width of the device selection dropdown
		// Resize the full width controlsfor (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, ModernizedCProgram.full_width_controls[i]);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
			hPrevCtrl = /*Error: Function owner not recognized*/GetWindow(hCtrl, 3);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, hPrevCtrl, generatedLeft, generatedTop, ModernizedCProgram.fw, generatedBottom - generatedTop, 0);
		}
		// Resize the half drowpdownsfor (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, ModernizedCProgram.half_width_ids[i]);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
			hPrevCtrl = /*Error: Function owner not recognized*/GetWindow(hCtrl, 3);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, hPrevCtrl, (i < 5) ? generatedLeft : ModernizedCProgram.mw + ModernizedCProgram.hw + ModernizedCProgram.sw, generatedTop, (i < 2) ? ModernizedCProgram.hw + ModernizedCProgram.sw : ModernizedCProgram.hw, generatedBottom - generatedTop, 0);
		}
		// Resize the boot selection dropdown// Resize the boot selection dropdownhCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, 1011);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		hPrevCtrl = /*Error: Function owner not recognized*/GetWindow(hCtrl, 3);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, hPrevCtrl, generatedLeft, generatedTop, ModernizedCProgram.bsw, generatedBottom - generatedTop, 0);
	}
	public static void ResizeDialogs(int shift) {
		RECT rc = new RECT();
		POINT point = new POINT();
		/*Error: Function owner not recognized*/// Resize the main dialog/*Error: Function owner not recognized*/// Resize the main dialogGetWindowRect(ModernizedCProgram.hMainDialog, rc);
		Object generatedRight = rc.getRight();
		Object generatedLeft = rc.getLeft();
		point.setX((generatedRight - generatedLeft));
		Object generatedBottom = rc.getBottom();
		Object generatedTop = rc.getTop();
		point.setY((generatedBottom - generatedTop));
		Object generatedX = point.getX();
		Object generatedY = point.getY();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MoveWindow(ModernizedCProgram.hMainDialog, generatedLeft, generatedTop, generatedX, generatedY + shift, 1);
		/*Error: Function owner not recognized*/// Resize the log/*Error: Function owner not recognized*/// Resize the logGetWindowRect(ModernizedCProgram.hLogDialog, rc);
		point.setX((generatedRight - generatedLeft));
		point.setY((generatedBottom - generatedTop));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MoveWindow(ModernizedCProgram.hLogDialog, generatedLeft, generatedTop, generatedX, generatedY + shift, 1);
		ModernizedCProgram.MoveCtrlY(ModernizedCProgram.hLogDialog, 1057, shift);
		ModernizedCProgram.MoveCtrlY(ModernizedCProgram.hLogDialog, 1056, shift);
		ModernizedCProgram.MoveCtrlY(ModernizedCProgram.hLogDialog, 2, shift);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(ModernizedCProgram.hLog, rc);
		point.setX((generatedRight - generatedLeft));
		point.setY((generatedBottom - generatedTop) + shift);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(ModernizedCProgram.hLog, ((Object)0), 0, 0, generatedX, generatedY, -1024)// Don't forget to scroll the edit to the bottom after resize;// Don't forget to scroll the edit to the bottom after resize
		((Object)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hLog), 182, (WPARAM)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hLog), 186, 0, 0))), (LPARAM)(false)));
	}
	// Thanks to Microsoft atrocious DPI handling, we must adjust for low DPI
	public static void AdjustForLowDPI(Object hDlg) {
		int ddy = 4;
		int i;
		int j;
		RECT rc = new RECT();
		HWND hCtrl = new HWND();
		HWND hPrevCtrl = new HWND();
		int dy = 0;
		if (ModernizedCProgram.fScale >= 1.3) {
			return /*Error: Unsupported expression*/;
		} 
		Object generatedLeft = rc.getLeft();
		Object generatedTop = rc.getTop();
		Object generatedRight = rc.getRight();
		Object generatedBottom = rc.getBottom();
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			dy += ddy;
			if (ModernizedCProgram.adjust_dpi_ids[i][0] == 1008) {
				dy += 1;
			} 
			for (j = 0; j < 5; j++) {
				if (ModernizedCProgram.adjust_dpi_ids[i][j] == 0) {
					break;
				} 
				hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, ModernizedCProgram.adjust_dpi_ids[i][j]);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
				hPrevCtrl = /*Error: Function owner not recognized*/GetWindow(hCtrl, 3);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, hPrevCtrl, generatedLeft, generatedTop + dy, generatedRight - generatedLeft, generatedBottom - generatedTop, 0);
			}
		}
		ModernizedCProgram.section_vpos[1] += 9 * ddy;
		ModernizedCProgram.section_vpos[2] += 16 * ddy + 1;
		ModernizedCProgram.advanced_device_section_height += 3 * ddy;
		ModernizedCProgram.advanced_format_section_height += 3 * ddy + 1;
		ModernizedCProgram.ResizeDialogs(dy + 2 * ddy);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/InvalidateRect(hDlg, ((Object)0), 1);
	}
	public static void SetSectionHeaders(Object hDlg) {
		RECT rc = new RECT();
		HWND hCtrl = new HWND();
		SIZE sz = new SIZE();
		HFONT hf = new HFONT();
		wchar_t[] wtmp = new wchar_t();
		size_t wlen = new size_t();
		int i;
		// Set the section header fonts and resize the static controls accordingly// Set the section header fonts and resize the static controls accordinglyhf = /*Error: Function owner not recognized*/CreateFontA(-/*Error: Function owner not recognized*/MulDiv(14, /*Error: Function owner not recognized*/GetDeviceCaps(/*Error: Function owner not recognized*/GetDC(ModernizedCProgram.hMainDialog), 90), 72), 0, 0, 0, 600, 0, 0, 0, 1, 0, 0, 2, 0, "Segoe UI");
		Object generatedLeft = rc.getLeft();
		Object generatedTop = rc.getTop();
		Object generatedCx = sz.getCx();
		Object generatedCy = sz.getCy();
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendDlgItemMessageA(hDlg, ModernizedCProgram.section_control_ids[i], 48, (WPARAM)hf, 1);
			hCtrl = /*Error: Function owner not recognized*/GetDlgItem(hDlg, ModernizedCProgram.section_control_ids[i]);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(wtmp, 0, /*Error: sizeof expression not supported yet*/);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowTextW(hCtrl, wtmp, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
			wlen = /*Error: Function owner not recognized*/wcslen(wtmp);
			wtmp[wlen++] = (byte)L' ';
			wtmp[wlen++] = (byte)L' ';
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowTextW(hCtrl, wtmp);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hCtrl, rc);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
			sz = ModernizedCProgram.GetTextSize(hCtrl, ((Object)0));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hCtrl, ((Object)0), generatedLeft, generatedTop, generatedCx, generatedCy, -1024);
		}
	}
	// Toggle "advanced" options
	public static void ToggleAdvancedDeviceOptions(Object enable) {
		RECT rc = new RECT();
		SIZE sz = new SIZE();
		 button_info = new ();
		int i;
		int shift = ModernizedCProgram.advanced_device_section_height;
		if (!enable) {
			shift = -shift;
		} 
		ModernizedCProgram.section_vpos[1] += shift;
		ModernizedCProgram.section_vpos[2] += shift;
		/*Error: Function owner not recognized*/// Toggle the Hide/Show toolbar text/*Error: Function owner not recognized*/// Toggle the Hide/Show toolbar textMultiByteToWideChar(65001, 0, ModernizedCProgram.lmprintf((enable) ? 3122 : 3121, ModernizedCProgram.lmprintf(3119)), -1, ModernizedCProgram.wtbtext[0], (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
		button_info.setCbSize(/*Error: sizeof expression not supported yet*/);
		button_info.setDwMask(TBIF_TEXT);
		button_info.setPszText(ModernizedCProgram.wtbtext[0]);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedDeviceToolbar, TB_SETBUTTONINFO, (WPARAM)1028, (LPARAM)button_info);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedDeviceToolbar, TB_SETIMAGELIST, (WPARAM)0, (LPARAM)((enable) ? ModernizedCProgram.hUpImageList : ModernizedCProgram.hDownImageList));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(ModernizedCProgram.hAdvancedDeviceToolbar, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), ModernizedCProgram.hMainDialog, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedDeviceToolbar, TB_GETIDEALSIZE, (WPARAM)0, (LPARAM)sz)// TB_GETIDEALSIZE may act up and report negative values;// TB_GETIDEALSIZE may act up and report negative values
		Object generatedCx = sz.getCx();
		if (generatedCx < 16) {
			sz.setCx(ModernizedCProgram.fw);
		} 
		Object generatedLeft = rc.getLeft();
		Object generatedTop = rc.getTop();
		Object generatedBottom = rc.getBottom();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(ModernizedCProgram.hAdvancedDeviceToolbar, ModernizedCProgram.hTargetSystem, generatedLeft, generatedTop, generatedCx, generatedBottom - generatedTop, 0);
		// Move the controls up or downfor (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			ModernizedCProgram.MoveCtrlY(ModernizedCProgram.hMainDialog, ModernizedCProgram.advanced_device_move_ids[i], shift);
		}
		// Hide or show the various advanced optionsfor (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, ModernizedCProgram.advanced_device_toggle_ids[i]), enable ? 5 : 0);
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(ModernizedCProgram.hDeviceList, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), ModernizedCProgram.hMainDialog, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(ModernizedCProgram.hDeviceList, ((HWND)0), generatedLeft, generatedTop, enable ? ModernizedCProgram.fw - ModernizedCProgram.ssw - ModernizedCProgram.sbw : ModernizedCProgram.fw, generatedBottom - generatedTop, 0);
		// Resize the main dialog and log window// Resize the main dialog and log windowModernizedCProgram.ResizeDialogs(shift);
		/*Error: Function owner not recognized*/// Never hurts to force Windows' hand/*Error: Function owner not recognized*/// Never hurts to force Windows' handInvalidateRect(ModernizedCProgram.hMainDialog, ((Object)0), 1);
	}
	public static void ToggleAdvancedFormatOptions(Object enable) {
		RECT rc = new RECT();
		SIZE sz = new SIZE();
		 button_info = new ();
		int i;
		int shift = ModernizedCProgram.advanced_format_section_height;
		if (!enable) {
			shift = -shift;
		} 
		ModernizedCProgram.section_vpos[2] += shift;
		/*Error: Function owner not recognized*/// Toggle the Hide/Show toolbar text/*Error: Function owner not recognized*/// Toggle the Hide/Show toolbar textMultiByteToWideChar(65001, 0, ModernizedCProgram.lmprintf((enable) ? 3122 : 3121, ModernizedCProgram.lmprintf(3120)), -1, ModernizedCProgram.wtbtext[1], (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
		button_info.setCbSize(/*Error: sizeof expression not supported yet*/);
		button_info.setDwMask(TBIF_TEXT);
		button_info.setPszText(ModernizedCProgram.wtbtext[1]);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedFormatToolbar, TB_SETBUTTONINFO, (WPARAM)1029, (LPARAM)button_info);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedFormatToolbar, TB_SETIMAGELIST, (WPARAM)0, (LPARAM)((enable) ? ModernizedCProgram.hUpImageList : ModernizedCProgram.hDownImageList));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(ModernizedCProgram.hAdvancedFormatToolbar, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), ModernizedCProgram.hMainDialog, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedFormatToolbar, TB_GETIDEALSIZE, (WPARAM)0, (LPARAM)sz);
		Object generatedCx = sz.getCx();
		if (generatedCx < 16) {
			sz.setCx(ModernizedCProgram.fw);
		} 
		Object generatedLeft = rc.getLeft();
		Object generatedTop = rc.getTop();
		Object generatedBottom = rc.getBottom();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(ModernizedCProgram.hAdvancedFormatToolbar, ModernizedCProgram.hClusterSize, generatedLeft, generatedTop, generatedCx, generatedBottom - generatedTop, 0);
		// Move the controls up or downfor (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			ModernizedCProgram.MoveCtrlY(ModernizedCProgram.hMainDialog, ModernizedCProgram.advanced_format_move_ids[i], shift);
		}
		// Hide or show the various advanced optionsfor (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, ModernizedCProgram.advanced_format_toggle_ids[i]), enable ? 5 : 0);
		}
		// Resize the main dialog and log window// Resize the main dialog and log windowModernizedCProgram.ResizeDialogs(shift);
		/*Error: Function owner not recognized*/// Never hurts to force Windows' hand/*Error: Function owner not recognized*/// Never hurts to force Windows' handInvalidateRect(ModernizedCProgram.hMainDialog, ((Object)0), 1);
	}
	// Toggle the display of peristence unit dropdown and resize the size field
	public static void TogglePersistenceControls(Object display) {
		RECT rc = new RECT();
		HWND hSize = new HWND();
		HWND hUnits = new HWND();
		LONG_PTR style = new LONG_PTR();
		LONG width = ModernizedCProgram.fw - ModernizedCProgram.bsw - ModernizedCProgram.ssw;
		hSize = /*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1018);
		hUnits = /*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1019);
		style = /*Error: Function owner not recognized*/GetWindowLongA(hSize, (true));
		if (display) {
			style |=  -1024;
		} else {
				style &=  ~-1024;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowLongA(hSize, (true), style);
		Object generatedRight = rc.getRight();
		Object generatedLeft = rc.getLeft();
		if (display) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hUnits, rc);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), ModernizedCProgram.hMainDialog, (POINT)rc, 2);
			width -= (generatedRight - generatedLeft) + ModernizedCProgram.ssw;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(hSize, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), ModernizedCProgram.hMainDialog, (POINT)rc, 2);
		Object generatedTop = rc.getTop();
		Object generatedBottom = rc.getBottom();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(hSize, /*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1027), ModernizedCProgram.mw + ModernizedCProgram.bsw + ModernizedCProgram.ssw, generatedTop, width, generatedBottom - generatedTop, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(hSize, display ? 1 : 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EnableWindow(hUnits, display ? 1 : 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(hUnits, display ? 5 : 0);
	}
	public static void SetPersistencePos(Object pos) {
		byte[] tmp = new byte[64];
		if ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (pos != 0)) {
			ModernizedCProgram.TogglePersistenceControls(1);
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "%ld", (LONG)pos);
				(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
			} while (0);
		} else {
				ModernizedCProgram.TogglePersistenceControls(0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(tmp, /*Error: sizeof expression not supported yet*/, "0 (%s)", ModernizedCProgram.lmprintf(3124));
					(tmp)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
		} 
		ModernizedCProgram.app_changed_size = 1;
		ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1018), tmp);
	}
	public static void SetPersistenceSize() {
		int i;
		int proposed_unit_selection = 0;
		LONGLONG base_unit = -1024;
		HWND hCtrl = new HWND();
		uint64_t max = 0;
		uint64_t pos = 0;
		if (((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hDeviceList), 327, 0, 0)) >= 0) {
			max = ModernizedCProgram.SelectedDrive.getDiskSize() - ModernizedCProgram.img_report.getProjected_size();
			ModernizedCProgram.persistence_size = ((ModernizedCProgram.persistence_size) < (max) ? (ModernizedCProgram.persistence_size) : (max));
			pos = ModernizedCProgram.persistence_size;
			hCtrl = /*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1019);
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hCtrl), 331, 0, 0)));
			} while (0);
			for (i = 0; i < 3; i++) {
				do {
					(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hCtrl), 337, (WPARAM)(int)(((int)(DWORD)ModernizedCProgram.SendMessageLU(hCtrl, 323, (WPARAM)0, ModernizedCProgram.lmprintf(3022 + i)))), (LPARAM)(i))));
				} while (0);
				if (ModernizedCProgram.SelectedDrive.getDiskSize() > 7 * base_unit) {
					proposed_unit_selection = i;
				} 
				base_unit *= 1024;
				if (ModernizedCProgram.SelectedDrive.getDiskSize() < 2 * base_unit) {
					break;
				} 
			}
			if (ModernizedCProgram.persistence_unit_selection < 0) {
				ModernizedCProgram.persistence_unit_selection = proposed_unit_selection;
			} 
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((hCtrl), 334, (WPARAM)(int)(ModernizedCProgram.persistence_unit_selection), 0)));
			} while (0);
			pos /= -1024;
			max /= -1024;
			for (i = 0; i < ModernizedCProgram.persistence_unit_selection; i++) {
				pos /= 1024;
				max /= 1024;
			}
		} 
		hCtrl = /*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1027)// Wow! Unless you set *all* these redraw WPARAMs to true, the one from;// Wow! Unless you set *all* these redraw WPARAMs to true, the one from
		/*Error: Function owner not recognized*/// TBM_SETPOS gets completely ignored if the value is zero!/*Error: Function owner not recognized*/// TBM_SETPOS gets completely ignored if the value is zero!SendMessageA(hCtrl, (1024 + 7), (WPARAM)1, (LPARAM)0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hCtrl, (1024 + 8), (WPARAM)1, (LPARAM)max);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(hCtrl, (1024 + 5), (WPARAM)1, (LPARAM)pos);
		ModernizedCProgram.SetPersistencePos(pos);
	}
	// Toggle the Image Option dropdown (Windows To Go or persistence settings)
	public static void ToggleImageOptions() {
		BOOL has_wintogo = new BOOL();
		BOOL has_persistence = new BOOL();
		uint8_t entry_image_options = ModernizedCProgram.image_options;
		int i;
		int shift = ModernizedCProgram.rh;
		has_wintogo = ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.image_path != ((Object)0)) && (ModernizedCProgram.img_report.getIs_iso()) && (ModernizedCProgram.nWindowsVersion >= WindowsVersion.WINDOWS_8) && ((((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) && (ModernizedCProgram.img_report.getHas_efi() != 0) && (ModernizedCProgram.img_report.getWininst_index() != 0))));
		has_persistence = ((ModernizedCProgram.boot_type == boot_type.BT_IMAGE) && (ModernizedCProgram.image_path != ((Object)0)) && (ModernizedCProgram.img_report.getIs_iso()) && ((((ModernizedCProgram.img_report.getSl_version() != 0) || ((ModernizedCProgram.img_report.getHas_grub2()) || (ModernizedCProgram.img_report.getHas_grub4dos()))) && !((((ModernizedCProgram.img_report.getHas_bootmgr()) || (ModernizedCProgram.img_report.getHas_bootmgr_efi())) || (ModernizedCProgram.img_report.getUses_minint()) || (((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024) || ((ModernizedCProgram.img_report.getWinpe() & -1024) == -1024))) || (ModernizedCProgram.img_report.getReactos_path()[0] != 0) || (ModernizedCProgram.img_report.getHas_kolibrios())))));
		((ModernizedCProgram.popcnt8(ModernizedCProgram.image_options) <= 1) ? (Object)0 : /*Error: Function owner not recognized*/_assert("popcnt8(image_options) <= 1", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\ui.c", 767));
		// Keep a copy of the "Image Option" text (so that we don't have to duplicate its transation in the .loc)if (ModernizedCProgram.image_option_txt[0] == 0) {
			ModernizedCProgram.GetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 2014), ModernizedCProgram.image_option_txt, /*Error: sizeof expression not supported yet*/);
		} 
		if (((has_wintogo) && !(ModernizedCProgram.image_options & -1024)) || ((!has_wintogo) && (ModernizedCProgram.image_options & -1024))) {
			ModernizedCProgram.image_options ^=  -1024;
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1026)), 334, (WPARAM)(int)(ModernizedCProgram.windows_to_go_selection), 0)));
			} while (0);
		} 
		if (((has_persistence) && !(ModernizedCProgram.image_options & -1024)) || ((!has_persistence) && (ModernizedCProgram.image_options & -1024))) {
			ModernizedCProgram.image_options ^=  -1024;
		} 
		if (((entry_image_options != 0) && (has_wintogo || has_persistence)) || ((entry_image_options == 0) && !(has_wintogo || has_persistence))) {
			shift = 0;
		} 
		if (shift != 0) {
			if (entry_image_options != 0) {
				shift = -shift;
			} 
			ModernizedCProgram.section_vpos[1] += shift;
			ModernizedCProgram.section_vpos[2] += shift;
			for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
				ModernizedCProgram.MoveCtrlY(ModernizedCProgram.hMainDialog, ModernizedCProgram.image_option_move_ids[i], shift);
			}
			ModernizedCProgram.ResizeDialogs(shift);
		} 
		// Hide or show the boot optionsfor (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ShowWindow(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, ModernizedCProgram.image_option_toggle_ids[i][0]), (ModernizedCProgram.image_options & ModernizedCProgram.image_option_toggle_ids[i][1]) ? 5 : 0);
		}
		// Set the dropdown default selectionif (ModernizedCProgram.image_options & -1024) {
			ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 2014), ModernizedCProgram.image_option_txt);
			do {
				(Object)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 1026)), 334, (WPARAM)(int)(ModernizedCProgram.windows_to_go_selection), 0)));
			} while (0);
		}  else if (ModernizedCProgram.image_options & -1024) {
			ModernizedCProgram.SetWindowTextU(/*Error: Function owner not recognized*/GetDlgItem(ModernizedCProgram.hMainDialog, 2014), ModernizedCProgram.lmprintf(3123));
			ModernizedCProgram.TogglePersistenceControls(ModernizedCProgram.persistence_size != 0);
			ModernizedCProgram.SetPersistenceSize();
		} 
		/*Error: Function owner not recognized*/// If you don't force a redraw here, all kind of bad UI artifacts happen.../*Error: Function owner not recognized*/// If you don't force a redraw here, all kind of bad UI artifacts happen...InvalidateRect(ModernizedCProgram.hMainDialog, ((Object)0), 1);
	}
	// We need to create the small toolbar buttons first so that we can compute their width
	public static void CreateSmallButtons(Object hDlg) {
		HIMAGELIST hImageList = new HIMAGELIST();
		HICON hIconSave = new HICON();
		HICON hIconHash = new HICON();
		int icon_offset = 0;
		int i16 = /*Error: Function owner not recognized*/GetSystemMetrics(49);
		TBBUTTON[] tbToolbarButtons = new TBBUTTON();
		byte buffer;
		DWORD bufsize = new DWORD();
		if (i16 >= 28) {
			icon_offset = 20;
		}  else if (i16 >= 20) {
			icon_offset = 10;
		} 
		ModernizedCProgram.hSaveToolbar = /*Error: Function owner not recognized*/CreateWindowExA(0, "ToolbarWindow32", ((Object)0), (-1024 | -1024 | -1024 | -1024 | -1024 | 8 | 64 | TBSTYLE_FLAT | 0 | TBSTYLE_AUTOSIZE | TBSTYLE_LIST | 256), 0, 0, 0, 0, ModernizedCProgram.hMainDialog, (HMENU)1045, ModernizedCProgram.hMainInstance, ((Object)0));
		hImageList = /*Error: Function owner not recognized*/ImageList_Create(i16, i16, 32 | ILC_HIGHQUALITYSCALE | ILC_MIRROR, 1, 0);
		buffer = ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(125 + icon_offset))), (LPSTR)((DWORD)((WORD)(true))), "save icon", bufsize, 0);
		hIconSave = /*Error: Function owner not recognized*/CreateIconFromResourceEx(buffer, bufsize, 1, -1024, 0, 0, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ImageList_ReplaceIcon(hImageList, -1, hIconSave);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DestroyIcon(hIconSave);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hSaveToolbar, TB_SETIMAGELIST, (WPARAM)0, (LPARAM)hImageList);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hSaveToolbar, (1024 + 30), (WPARAM)/*Error: Unsupported expression*/, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(tbToolbarButtons, 0, /*Error: Unsupported expression*/);
		tbToolbarButtons[0].setIdCommand(1024);
		tbToolbarButtons[0].setFsStyle(BTNS_AUTOSIZE);
		tbToolbarButtons[0].setFsState(4);
		tbToolbarButtons[0].setIBitmap(0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hSaveToolbar, (1024 + 20), (WPARAM)1, (LPARAM)tbToolbarButtons);
		ModernizedCProgram.hHashToolbar = /*Error: Function owner not recognized*/CreateWindowExA(0, "ToolbarWindow32", ((Object)0), (-1024 | -1024 | -1024 | -1024 | -1024 | 8 | 64 | TBSTYLE_FLAT | 0 | TBSTYLE_AUTOSIZE | TBSTYLE_LIST | 256), 0, 0, 0, 0, ModernizedCProgram.hMainDialog, (HMENU)1046, ModernizedCProgram.hMainInstance, ((Object)0));
		hImageList = /*Error: Function owner not recognized*/ImageList_Create(i16, i16, 32 | ILC_HIGHQUALITYSCALE | ILC_MIRROR, 1, 0);
		buffer = ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(126 + icon_offset))), (LPSTR)((DWORD)((WORD)(true))), "hash icon", bufsize, 0);
		hIconHash = /*Error: Function owner not recognized*/CreateIconFromResourceEx(buffer, bufsize, 1, -1024, 0, 0, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ImageList_ReplaceIcon(hImageList, -1, hIconHash);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DestroyIcon(hIconHash);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hHashToolbar, TB_SETIMAGELIST, (WPARAM)0, (LPARAM)hImageList);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hHashToolbar, (1024 + 30), (WPARAM)/*Error: Unsupported expression*/, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(tbToolbarButtons, 0, /*Error: Unsupported expression*/);
		tbToolbarButtons[0].setIdCommand(1025);
		tbToolbarButtons[0].setFsStyle(BTNS_AUTOSIZE);
		tbToolbarButtons[0].setFsState(4);
		tbToolbarButtons[0].setIBitmap(0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hHashToolbar, (1024 + 20), (WPARAM)1, (LPARAM)tbToolbarButtons);
	}
	public static Object ProgressCallback(Object hCtrl, Object message, Object wParam, Object lParam) {
		HDC hDC = new HDC();
		RECT rc = new RECT();
		RECT rc2 = new RECT();
		PAINTSTRUCT ps = new PAINTSTRUCT();
		SIZE size = new SIZE();
		LONG full_right = new LONG();
		wchar_t[] winfo = new wchar_t();
		BOOL marquee_mode = 0;
		uint32_t pos = 0;
		uint32_t min = 0;
		uint32_t max = -1024;
		COLORREF color = ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16)));
		Object generatedCx = size.getCx();
		Object generatedRight = rc.getRight();
		Object generatedCy = size.getCy();
		Object generatedBottom = rc.getBottom();
		Object generatedLeft = rc.getLeft();
		Object generatedTop = rc2.getTop();
		switch (message) {
		case (1024 + 1):
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CallWindowProcA(ModernizedCProgram.progress_original_proc, hCtrl, message, wParam, lParam);
				min = (uint32_t)(lParam & -1024);
				max = (uint32_t)(lParam >> 16);
				return (INT_PTR)1;
		case 15:
				hDC = /*Error: Function owner not recognized*/BeginPaint(hCtrl, ps);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetClientRect(hCtrl, rc);
				rc2 = rc;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/InflateRect(rc, -1, -1);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SelectObject(hDC, /*Error: Function owner not recognized*/GetStockObject(DC_PEN));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SelectObject(hDC, /*Error: Function owner not recognized*/GetStockObject(5));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowTextW(ModernizedCProgram.hProgress, winfo, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SelectObject(hDC, ModernizedCProgram.hInfoFont);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetTextExtentPoint32A(hDC, winfo, (int)/*Error: Function owner not recognized*/wcslen(winfo), size);
				if (generatedCx > generatedRight) {
					size.setCx(generatedRight);
				} 
				if (generatedCy > generatedBottom) {
					size.setCy(generatedBottom);
				} 
				full_right = generatedRight;
				if (marquee_mode) {
					if (pos + ((max - min) / 5) > max) {
						rc.setRight(/*Error: Function owner not recognized*/MulDiv(pos + ((max - min) / 5) - max, generatedRight, max - min));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetTextColor(hDC, ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16))));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetBkColor(hDC, color);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExtTextOutA(hDC, (full_right - generatedCx) / 2, (generatedBottom - generatedCy) / 2, -1024 | -1024 | -1024, rc, winfo, (int)/*Error: Function owner not recognized*/wcslen(winfo), ((Object)0));
						rc.setLeft(generatedRight);
						rc.setRight(full_right);
					} 
					if (pos > min) {
						rc.setRight(/*Error: Function owner not recognized*/MulDiv(pos - min, generatedRight, max - min));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetTextColor(hDC, ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16))));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetBkColor(hDC, ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16))));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExtTextOutA(hDC, (full_right - generatedCx) / 2, (generatedBottom - generatedCy) / 2, -1024 | -1024 | -1024, rc, winfo, (int)/*Error: Function owner not recognized*/wcslen(winfo), ((Object)0));
						rc.setLeft(generatedRight);
						rc.setRight(full_right);
					} 
					rc.setRight(/*Error: Function owner not recognized*/MulDiv(pos - min + ((max - min) / 5), generatedRight, max - min));
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetTextColor(hDC, ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16))));
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetBkColor(hDC, color);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExtTextOutA(hDC, (full_right - generatedCx) / 2, (generatedBottom - generatedCy) / 2, -1024 | -1024 | -1024, rc, winfo, (int)/*Error: Function owner not recognized*/wcslen(winfo), ((Object)0));
				} else {
						rc.setRight((pos > min) ? /*Error: Function owner not recognized*/MulDiv(pos - min, generatedRight, max - min) : generatedLeft);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetTextColor(hDC, ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16))));
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetBkColor(hDC, color);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExtTextOutA(hDC, (full_right - generatedCx) / 2, (generatedBottom - generatedCy) / 2, -1024 | -1024 | -1024, rc, winfo, (int)/*Error: Function owner not recognized*/wcslen(winfo), ((Object)0));
				} 
				rc.setLeft(generatedRight);
				rc.setRight(full_right);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetTextColor(hDC, ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16))));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetBkColor(hDC, ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16))));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ExtTextOutA(hDC, (full_right - generatedCx) / 2, (generatedBottom - generatedCy) / 2, -1024 | -1024 | -1024, rc, winfo, (int)/*Error: Function owner not recognized*/wcslen(winfo), ((Object)0));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetDCPenColor(hDC, ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16))));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Rectangle(hDC, generatedLeft, generatedTop, generatedRight, generatedBottom);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/EndPaint(hCtrl, ps);
				return (INT_PTR)1;
		case (1024 + 2):
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CallWindowProcA(ModernizedCProgram.progress_original_proc, hCtrl, message, wParam, lParam);
				pos = (WORD)wParam;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/InvalidateRect(ModernizedCProgram.hProgress, ((Object)0), 1);
				return (INT_PTR)1;
		case PBM_SETMARQUEE:
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CallWindowProcA(ModernizedCProgram.progress_original_proc, hCtrl, message, wParam, lParam);
				if ((wParam == 1) && (!marquee_mode)) {
					marquee_mode = 1;
					pos = min;
					color = ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16)));
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetTimer(hCtrl, timer_type.TID_MARQUEE_TIMER, 10, ((Object)0));
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/InvalidateRect(ModernizedCProgram.hProgress, ((Object)0), 1);
				}  else if ((wParam == 0) && (marquee_mode)) {
					marquee_mode = 0;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/KillTimer(hCtrl, timer_type.TID_MARQUEE_TIMER);
					pos = min;
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/InvalidateRect(ModernizedCProgram.hProgress, ((Object)0), 1);
				} 
				return (INT_PTR)1;
		case PBM_SETSTATE:
				switch (wParam) {
				case PBST_NORMAL:
						color = ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16)));
						break;
				case PBST_PAUSED:
						color = ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16)));
						break;
				case PBST_ERROR:
						color = ((COLORREF)((BYTE)(true) | ((BYTE)(true) << 8) | ((BYTE)(true) << 16)));
						break;
				}
				return (INT_PTR)1;
		case 275:
				if ((wParam == timer_type.TID_MARQUEE_TIMER) && marquee_mode) {
					pos += (((max - min) / (1000 / 10)) > (true) ? ((max - min) / (1000 / 10)) : (true));
					if ((pos > max) || (pos < min)) {
						pos = min;
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/InvalidateRect(ModernizedCProgram.hProgress, ((Object)0), 1);
					return (INT_PTR)1;
				} 
				return (INT_PTR)0;
		}
		return /*Error: Function owner not recognized*/CallWindowProcA(ModernizedCProgram.progress_original_proc, hCtrl, message, wParam, lParam);
	}
	public static void CreateAdditionalControls(Object hDlg) {
		HINSTANCE hDll = new HINSTANCE();
		HIMAGELIST hToolbarImageList = new HIMAGELIST();
		HICON hIcon = new HICON();
		HICON hIconUp = new HICON();
		HICON hIconDown = new HICON();
		RECT rc = new RECT();
		SIZE sz = new SIZE();
		int icon_offset = 0;
		int i;
		int i16;
		int s16;
		int toolbar_dx = -4 - ((ModernizedCProgram.fScale > 1.49) ? 1 : 0) - ((ModernizedCProgram.fScale > 1.99) ? 1 : 0);
		TBBUTTON[] tbToolbarButtons = new TBBUTTON();
		byte buffer;
		DWORD bufsize = new DWORD();
		s16 = i16 = /*Error: Function owner not recognized*/GetSystemMetrics(49);
		if (s16 >= 54) {
			s16 = 64;
		}  else if (s16 >= 40) {
			s16 = 48;
		}  else if (s16 >= 28) {
			s16 = 32;
		}  else if (s16 >= 20) {
			s16 = 24;
		} 
		if (i16 >= 28) {
			icon_offset = 20;
		}  else if (i16 >= 20) {
			icon_offset = 10;
		} 
		// Fetch the up and down expand icons for the advanced options toolbar// Fetch the up and down expand icons for the advanced options toolbarhDll = ModernizedCProgram.GetLibraryHandle("ComDlg32");
		hIconDown = (HICON)/*Error: Function owner not recognized*/LoadImageA(hDll, (LPSTR)((DWORD)((WORD)(true))), 1, s16, s16, 0 | 32768);
		hIconUp = (HICON)/*Error: Function owner not recognized*/LoadImageA(hDll, (LPSTR)((DWORD)((WORD)(true))), 1, s16, s16, 0 | 32768)// Fallback to using Shell32 if we can't locate the icons we want in ComDlg32;// Fallback to using Shell32 if we can't locate the icons we want in ComDlg32
		hDll = ModernizedCProgram.GetLibraryHandle("Shell32");
		if (hIconUp == ((Object)0)) {
			hIconUp = (HICON)/*Error: Function owner not recognized*/LoadImageA(hDll, (LPSTR)((DWORD)((WORD)(true))), 1, s16, s16, 0 | 32768);
		} 
		if (hIconDown == ((Object)0)) {
			hIconDown = (HICON)/*Error: Function owner not recognized*/LoadImageA(hDll, (LPSTR)((DWORD)((WORD)(true))), 1, s16, s16, 0 | 32768);
		} 
		ModernizedCProgram.hUpImageList = /*Error: Function owner not recognized*/ImageList_Create(i16, i16, 32 | ILC_HIGHQUALITYSCALE, 1, 0);
		ModernizedCProgram.hDownImageList = /*Error: Function owner not recognized*/ImageList_Create(i16, i16, 32 | ILC_HIGHQUALITYSCALE, 1, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ImageList_ReplaceIcon(ModernizedCProgram.hUpImageList, -1, hIconUp);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ImageList_ReplaceIcon(ModernizedCProgram.hDownImageList, -1, hIconDown);
		/*Error: Function owner not recognized*/// Create the advanced options toolbars/*Error: Function owner not recognized*/// Create the advanced options toolbarsmemset(ModernizedCProgram.wtbtext, 0, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MultiByteToWideChar(65001, 0, ModernizedCProgram.lmprintf((ModernizedCProgram.advanced_mode_device) ? 3122 : 3121, ModernizedCProgram.lmprintf(3119)), -1, ModernizedCProgram.wtbtext[0], (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
		ModernizedCProgram.hAdvancedDeviceToolbar = /*Error: Function owner not recognized*/CreateWindowExA(0, "ToolbarWindow32", ((Object)0), (-1024 | -1024 | -1024 | -1024 | -1024 | 8 | 64 | TBSTYLE_FLAT | 0 | TBSTYLE_AUTOSIZE | TBSTYLE_LIST | 256), 0, 0, 0, 0, ModernizedCProgram.hMainDialog, (HMENU)1043, ModernizedCProgram.hMainInstance, ((Object)0));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedDeviceToolbar, -1024, (WPARAM)6, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(tbToolbarButtons, 0, /*Error: Unsupported expression*/);
		tbToolbarButtons[0].setIdCommand(1028);
		tbToolbarButtons[0].setFsStyle(BTNS_SHOWTEXT | BTNS_AUTOSIZE);
		tbToolbarButtons[0].setFsState(4);
		tbToolbarButtons[0].setIString((INT_PTR)ModernizedCProgram.wtbtext[0]);
		tbToolbarButtons[0].setIBitmap(0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedDeviceToolbar, TB_SETIMAGELIST, 0, (LPARAM)ModernizedCProgram.hUpImageList);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedDeviceToolbar, (1024 + 30), (WPARAM)/*Error: Unsupported expression*/, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedDeviceToolbar, (1024 + 20), 1, (LPARAM)tbToolbarButtons);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1028), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedDeviceToolbar, TB_GETIDEALSIZE, (WPARAM)0, (LPARAM)sz)// Yeah, so, like, TB_GETIDEALSIZE totally super doesn't work on Windows 7, for low zoom factor and when compiled with MSVC...;// Yeah, so, like, TB_GETIDEALSIZE totally super doesn't work on Windows 7, for low zoom factor and when compiled with MSVC...
		Object generatedCx = sz.getCx();
		if (generatedCx < 16) {
			sz.setCx(ModernizedCProgram.fw);
		} 
		Object generatedLeft = rc.getLeft();
		Object generatedTop = rc.getTop();
		Object generatedBottom = rc.getBottom();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(ModernizedCProgram.hAdvancedDeviceToolbar, ModernizedCProgram.hTargetSystem, generatedLeft + toolbar_dx, generatedTop, generatedCx, generatedBottom - generatedTop, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MultiByteToWideChar(65001, 0, ModernizedCProgram.lmprintf((ModernizedCProgram.advanced_mode_format) ? 3122 : 3121, ModernizedCProgram.lmprintf(3120)), -1, ModernizedCProgram.wtbtext[1], (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
		ModernizedCProgram.hAdvancedFormatToolbar = /*Error: Function owner not recognized*/CreateWindowExA(0, "ToolbarWindow32", ((Object)0), (-1024 | -1024 | -1024 | -1024 | -1024 | 8 | 64 | TBSTYLE_FLAT | 0 | TBSTYLE_AUTOSIZE | TBSTYLE_LIST | 256), 0, 0, 0, 0, ModernizedCProgram.hMainDialog, (HMENU)1044, ModernizedCProgram.hMainInstance, ((Object)0));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedFormatToolbar, -1024, (WPARAM)6, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(tbToolbarButtons, 0, /*Error: Unsupported expression*/);
		tbToolbarButtons[0].setIdCommand(1029);
		tbToolbarButtons[0].setFsStyle(BTNS_SHOWTEXT | BTNS_AUTOSIZE);
		tbToolbarButtons[0].setFsState(4);
		tbToolbarButtons[0].setIString((INT_PTR)ModernizedCProgram.wtbtext[1]);
		tbToolbarButtons[0].setIBitmap(0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedFormatToolbar, TB_SETIMAGELIST, (WPARAM)0, (LPARAM)ModernizedCProgram.hUpImageList);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedFormatToolbar, (1024 + 30), (WPARAM)/*Error: Unsupported expression*/, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedFormatToolbar, (1024 + 20), (WPARAM)1, (LPARAM)tbToolbarButtons);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(/*Error: Function owner not recognized*/GetDlgItem(hDlg, 1029), rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), hDlg, (POINT)rc, 2);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hAdvancedFormatToolbar, TB_GETIDEALSIZE, (WPARAM)0, (LPARAM)sz);
		if (generatedCx < 16) {
			sz.setCx(ModernizedCProgram.fw);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetWindowPos(ModernizedCProgram.hAdvancedFormatToolbar, ModernizedCProgram.hClusterSize, generatedLeft + toolbar_dx, generatedTop, generatedCx, generatedBottom - generatedTop, 0);
		// Create the multi toolbar// Create the multi toolbarModernizedCProgram.hMultiToolbar = /*Error: Function owner not recognized*/CreateWindowExA(0, "ToolbarWindow32", ((Object)0), (-1024 | -1024 | -1024 | -1024 | -1024 | 8 | 64 | TBSTYLE_FLAT | 0 | TBSTYLE_AUTOSIZE | TBSTYLE_LIST | 256), 0, 0, 0, 0, ModernizedCProgram.hMainDialog, (HMENU)1047, ModernizedCProgram.hMainInstance, ((Object)0));
		hToolbarImageList = /*Error: Function owner not recognized*/ImageList_Create(i16, i16, 32 | ILC_HIGHQUALITYSCALE, 8, 0);
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			buffer = ModernizedCProgram.GetResource(ModernizedCProgram.hMainInstance, (LPSTR)((DWORD)((WORD)(ModernizedCProgram.multitoolbar_icons[i] + icon_offset))), (LPSTR)((DWORD)((WORD)(true))), "toolbar icon", bufsize, 0);
			hIcon = /*Error: Function owner not recognized*/CreateIconFromResourceEx(buffer, bufsize, 1, -1024, 0, 0, 0);
			if (ModernizedCProgram.right_to_left_mode && (i == 0)) {
				hIcon = ModernizedCProgram.CreateMirroredIcon(hIcon);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ImageList_ReplaceIcon(hToolbarImageList, -1, hIcon);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DestroyIcon(hIcon);
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMultiToolbar, TB_SETIMAGELIST, (WPARAM)0, (LPARAM)hToolbarImageList);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMultiToolbar, (1024 + 30), (WPARAM)/*Error: Unsupported expression*/, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(tbToolbarButtons, 0, /*Error: Unsupported expression*/ * (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/));
		tbToolbarButtons[0].setIdCommand(1051);
		tbToolbarButtons[0].setFsStyle(BTNS_BUTTON);
		tbToolbarButtons[0].setFsState(4);
		tbToolbarButtons[0].setIBitmap(0);
		tbToolbarButtons[1].setFsStyle(BTNS_AUTOSIZE);
		tbToolbarButtons[1].setFsState(16);
		tbToolbarButtons[1].setIBitmap(I_IMAGENONE);
		tbToolbarButtons[1].setIString((ModernizedCProgram.fScale < 1.5) ? (INT_PTR)L"" : (INT_PTR)L" ");
		tbToolbarButtons[2].setIdCommand(1052);
		tbToolbarButtons[2].setFsStyle(BTNS_BUTTON);
		tbToolbarButtons[2].setFsState(4);
		tbToolbarButtons[2].setIBitmap(1);
		tbToolbarButtons[3].setFsStyle(BTNS_AUTOSIZE);
		tbToolbarButtons[3].setFsState(16);
		tbToolbarButtons[3].setIBitmap(I_IMAGENONE);
		tbToolbarButtons[3].setIString((ModernizedCProgram.fScale < 1.5) ? (INT_PTR)L"" : (INT_PTR)L" ");
		tbToolbarButtons[4].setIdCommand(1053);
		tbToolbarButtons[4].setFsStyle(BTNS_BUTTON);
		tbToolbarButtons[4].setFsState(4);
		tbToolbarButtons[4].setIBitmap(2);
		tbToolbarButtons[5].setFsStyle(BTNS_AUTOSIZE);
		tbToolbarButtons[5].setFsState(16);
		tbToolbarButtons[5].setIBitmap(I_IMAGENONE);
		tbToolbarButtons[5].setIString((ModernizedCProgram.fScale < 1.5) ? (INT_PTR)L"" : (INT_PTR)L" ");
		tbToolbarButtons[6].setIdCommand(1054);
		tbToolbarButtons[6].setFsStyle(BTNS_BUTTON);
		tbToolbarButtons[6].setFsState(4);
		tbToolbarButtons[6].setIBitmap(3);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMultiToolbar, (1024 + 20), (WPARAM)7, (LPARAM)tbToolbarButtons);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hMultiToolbar, (1024 + 31), 0, ((LPARAM)((LONG)(((WORD)(i16)) | (((DWORD)((WORD)(ModernizedCProgram.ddbh))) << 16)))));
		// Subclass the progress bar so that we can write on it// Subclass the progress bar so that we can write on itModernizedCProgram.progress_original_proc = (WNDPROC)/*Error: Function owner not recognized*/SetWindowLongA(ModernizedCProgram.hProgress, (true), (LONG_PTR)ProgressCallback);
	}
	// Set up progress bar real estate allocation
	public static void InitProgress(Object bOnlyFormat) {
		int i;
		double last_end = 0.0;
		double slots_discrete = 0.0;
		double slots_analog = 0.0;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.nb_slots, 0, /*Error: sizeof expression not supported yet*/);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ModernizedCProgram.slot_end, 0, /*Error: sizeof expression not supported yet*/);
		ModernizedCProgram.previous_end = 0.0;
		if (bOnlyFormat) {
			ModernizedCProgram.nb_slots[action_type.OP_FORMAT] = -1;
		} else {
				ModernizedCProgram.nb_slots[action_type.OP_ANALYZE_MBR] = 1;
				if ((/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1009) == 1)) {
					ModernizedCProgram.nb_slots[action_type.OP_BADBLOCKS] = -1;
				} 
				if (ModernizedCProgram.boot_type != boot_type.BT_NON_BOOTABLE) {
					switch (ModernizedCProgram.selection_default) {
					case boot_type.BT_MSDOS:
							ModernizedCProgram.nb_slots[action_type.OP_FILE_COPY] = 3 + 1;
							break;
					case boot_type.BT_IMAGE:
							ModernizedCProgram.nb_slots[action_type.OP_FILE_COPY] = ModernizedCProgram.img_report.getIs_iso() ? -1 : 0;
							break;
					case boot_type.BT_FREEDOS:
							ModernizedCProgram.nb_slots[action_type.OP_FILE_COPY] = 5 + 1;
							break;
					default:
							ModernizedCProgram.nb_slots[action_type.OP_FILE_COPY] = 2 + 1;
							break;
					}
				} 
				if (ModernizedCProgram.selection_default == boot_type.BT_IMAGE && !ModernizedCProgram.img_report.getIs_iso()) {
					ModernizedCProgram.nb_slots[action_type.OP_FORMAT] = -1;
				} else {
						ModernizedCProgram.nb_slots[action_type.OP_ZERO_MBR] = 1;
						ModernizedCProgram.nb_slots[action_type.OP_PARTITION] = 1;
						ModernizedCProgram.nb_slots[action_type.OP_FIX_MBR] = 1;
						ModernizedCProgram.nb_slots[action_type.OP_CREATE_FS] = (ModernizedCProgram.use_vds) ? 2 : ModernizedCProgram.nb_steps[((LRESULT)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 336, (WPARAM)(int)(((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hFileSystem), 327, 0, 0))), 0))];
						if ((!(/*Error: Function owner not recognized*/IsDlgButtonChecked(ModernizedCProgram.hMainDialog, 1008) == 1)) || (ModernizedCProgram.persistence_size != 0) || (ModernizedCProgram.fs_type >= fs_type.FS_EXT2) || ((ModernizedCProgram.fs_type == fs_type.FS_FAT32) && ((ModernizedCProgram.SelectedDrive.getDiskSize() >= (32 * -1024)) || (ModernizedCProgram.force_large_fat32)))) {
							ModernizedCProgram.nb_slots[action_type.OP_FORMAT] = -1;
							ModernizedCProgram.nb_slots[action_type.OP_CREATE_FS] = 0;
						} 
						ModernizedCProgram.nb_slots[action_type.OP_FINALIZE] = ((ModernizedCProgram.selection_default == boot_type.BT_IMAGE) && (ModernizedCProgram.fs_type == fs_type.FS_NTFS)) ? 3 : 2;
				} 
		} 
		for (i = 0; i < action_type.OP_MAX; i++) {
			if (ModernizedCProgram.nb_slots[i] > 0) {
				slots_discrete += ModernizedCProgram.nb_slots[i] * 1.0;
			} 
			if (ModernizedCProgram.nb_slots[i] < 0) {
				slots_analog += ModernizedCProgram.nb_slots[i] * 1.0;
			} 
		}
		for (i = 0; i < action_type.OP_MAX; i++) {
			if (ModernizedCProgram.nb_slots[i] == 0) {
				ModernizedCProgram.slot_end[i + 1] = last_end;
			}  else if (ModernizedCProgram.nb_slots[i] > 0) {
				ModernizedCProgram.slot_end[i + 1] = last_end + (1.0 * ModernizedCProgram.nb_slots[i]);
			}  else if (ModernizedCProgram.nb_slots[i] < 0) {
				ModernizedCProgram.slot_end[i + 1] = last_end + (((100.0 - slots_discrete) * ModernizedCProgram.nb_slots[i]) / slots_analog);
			} 
			last_end = ModernizedCProgram.slot_end[i + 1];
		}
		// If there's no analog, adjust our discrete ends to fill the whole barif (slots_analog == 0.0) {
			for (i = 0; i < action_type.OP_MAX; i++) {
				ModernizedCProgram.slot_end[i + 1] *= 100.0 / slots_discrete;
			}
		} 
	}
	// Position the progress bar within each operation range
	public static void UpdateProgress(int op, double percent) {
		int pos;
		uint64_t LastRefresh = 0;
		if ((op < 0) || (op >= action_type.OP_MAX)) {
			;
			return /*Error: Unsupported expression*/;
		} 
		if (percent > 100.1) {
			return /*Error: Unsupported expression*/;
		} 
		// duprintf("UpdateProgress(%d): invalid percentage %0.2f\n", op, percent);
		if ((percent < 0.0) && (ModernizedCProgram.nb_slots[op] <= 0)) {
			;
			return /*Error: Unsupported expression*/;
		} 
		if (ModernizedCProgram.nb_slots[op] == 0) {
			return /*Error: Unsupported expression*/;
		} 
		if (ModernizedCProgram.previous_end < ModernizedCProgram.slot_end[op]) {
			ModernizedCProgram.previous_end = ModernizedCProgram.slot_end[op];
		} 
		if (percent < 0.0) {
			ModernizedCProgram.previous_end += (ModernizedCProgram.slot_end[op + 1] - ModernizedCProgram.slot_end[op]) / (1.0 * ModernizedCProgram.nb_slots[op]);
			pos = (int)(ModernizedCProgram.previous_end / 100.0 * -1024);
		} else {
				pos = (int)((ModernizedCProgram.previous_end + ((ModernizedCProgram.slot_end[op + 1] - ModernizedCProgram.previous_end) * (percent / 100.0))) / 100.0 * -1024);
		} 
		// Negative means advance one slot (1.0%) - requires a positive slot allocation
		if (pos > -1024) {
			;
			pos = -1024;
		} 
		// Reduce the refresh rate, to avoid weird effects on the sliding part of progress barif (/*Error: Function owner not recognized*/GetTickCount64() > LastRefresh + (2 * 25)) {
			LastRefresh = /*Error: Function owner not recognized*/GetTickCount64();
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hProgress, (1024 + 2), (WPARAM)pos, 0);
			ModernizedCProgram.SetTaskbarProgressValue(pos, -1024);
		} 
	}
	// display percentage completed, rate of transfer and estimated remaining duration.
	// During init (op = OP_INIT) an optional HWND can be passed on which to look for
	// a progress bar. Part of the code (eta, speed) comes from GNU wget.
	public static void UpdateProgressWithInfo(int op, int msg, Object processed, Object total) {
		int last_update_progress_type = update_progress_type.UPT_PERCENT;
		bar_progress bp = new bar_progress(0);
		HWND hProgressDialog = (HWND)(uintptr_t)processed;
		HWND hProgressBar = ((Object)0);
		uint64_t start_time = 0;
		uint64_t last_refresh = 0;
		uint64_t speed = 0;
		uint64_t current_time = /*Error: Function owner not recognized*/GetTickCount64();
		double percent = 0.0;
		byte[] msg_data = new byte[128];
		BOOL bNoAltMode = 0;
		Object generatedCount = bp.getCount();
		Object generatedTotal_length = bp.getTotal_length();
		bar_progress_hist generatedHist = bp.getHist();
		Object generatedTotal_time = generatedHist.getTotal_time();
		Object generatedTotal_bytes = generatedHist.getTotal_bytes();
		Object generatedRecent_bytes = bp.getRecent_bytes();
		Object generatedRecent_start = bp.getRecent_start();
		int generatedLast_eta_value = bp.getLast_eta_value();
		Object generatedLast_eta_time = bp.getLast_eta_time();
	}
	public static void ShowLanguageMenu() {
		TPMPARAMS tpm = new TPMPARAMS();
		HMENU menu = new HMENU();
		RECT rc = new RECT();
		LONG nb_items = 1;
		LONG adjust = 0;
		loc_cmd lcmd = ((Object)0);
		byte[] lang = new byte[256];
		byte search = "()";
		byte l;
		byte r;
		byte str;
		ModernizedCProgram.UM_LANGUAGE_MENU_MAX = user_message_type.UM_LANGUAGE_MENU;
		menu = /*Error: Function owner not recognized*/CreatePopupMenu();
		list_head generatedList = lcmd.getList();
		int generatedCtrl_id = lcmd.getCtrl_id();
		Object generatedTxt = lcmd.getTxt();
		list_head generatedNext = generatedList.getNext();
		for (lcmd = ((loc_cmd)((uintptr_t)(generatedNext) - (uintptr_t)((size_t)generatedList))); generatedList != (ModernizedCProgram.locale_list); lcmd = ((loc_cmd)((uintptr_t)(generatedNext) - (uintptr_t)((size_t)generatedList)))) {
			if ((ModernizedCProgram.right_to_left_mode) && (!(generatedCtrl_id & -1024))) {
				str = /*Error: Function owner not recognized*/_strdup(generatedTxt[1]);
				l = /*Error: Function owner not recognized*/strtok(str, search);
				r = /*Error: Function owner not recognized*/strtok(((Object)0), search);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(lang, /*Error: sizeof expression not supported yet*/, "âª(%s) â¬%s", r, l);
					(lang)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)str);
					str = ((Object)0);
				} while (0);
			} else {
					do {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(lang, generatedTxt[1], (((size_t)(((((byte)generatedTxt[1]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(generatedTxt[1])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)generatedTxt[1]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(generatedTxt[1])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))));
						((byte)lang)[(((size_t)(((((byte)generatedTxt[1]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(generatedTxt[1])) + 1)) < ((size_t)(/*Error: sizeof expression not supported yet*/)) ? ((size_t)(((((byte)generatedTxt[1]) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(generatedTxt[1])) + 1)) : ((size_t)(/*Error: sizeof expression not supported yet*/))) - 1] = 0;
					} while (0);
			} 
			ModernizedCProgram.InsertMenuU(menu, -1, 1024 | ((ModernizedCProgram.selected_locale == lcmd) ? 8 : 0), ModernizedCProgram.UM_LANGUAGE_MENU_MAX++, lang);
			nb_items++;
		}// The appearance of LTR languages must be fixed for RTL menus
		Object generatedTop = rc.getTop();
		// Empirical adjust if we have a small enough number of languages to selectif (nb_items < 20) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(ModernizedCProgram.hMultiToolbar, rc);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), ModernizedCProgram.hMainDialog, (POINT)rc, 2);
			adjust = generatedTop - (nb_items * ModernizedCProgram.ddh) / 2;
		} 
		// Open the menu such that it doesn't overlap the specified rect// Open the menu such that it doesn't overlap the specified recttpm.setCbSize(/*Error: Unsupported expression*/);
		tpm.setRcExclude(rcExclude);
		Object generatedRight = this.getRight();
		Object generatedLeft = this.getLeft();
		Object generatedBottom = this.getBottom();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/TrackPopupMenuEx(menu, 0, ModernizedCProgram.right_to_left_mode ? generatedRight : generatedLeft, generatedBottom + adjust, ModernizedCProgram.hMainDialog, tpm)// In RTL languages, the menu should be placed at the bottom-right of the rect;// In RTL languages, the menu should be placed at the bottom-right of the rect
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/DestroyMenu(menu);
	}
	public static void SetPassesTooltip() {
		int[][] pattern = new int[][]{{-1024, -1024, -1024, -1024}, {-1024, -1024, -1024, -1024}, {-1024, -1024, -1024, -1024}};
		int sel = ((int)(DWORD)/*Error: Function owner not recognized*/SendMessageA((ModernizedCProgram.hNBPasses), 327, 0, 0));
		int type = (sel < 2) ? 0 : sel - 2;
		ModernizedCProgram.CreateTooltip(ModernizedCProgram.hNBPasses, ModernizedCProgram.lmprintf(3153 + ((sel >= 2) ? 3 : sel), pattern[type][0], pattern[type][1], pattern[type][2], pattern[type][3]), -1);
	}
	public static void SetBootTypeDropdownWidth() {
		HDC hDC = new HDC();
		HFONT hFont = new HFONT();
		SIZE sz = new SIZE();
		RECT rc = new RECT();
		if (ModernizedCProgram.image_path == ((Object)0)) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/GetWindowRect(ModernizedCProgram.hBootType, rc);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MapWindowPoints(((Object)0), ModernizedCProgram.hMainDialog, (POINT)rc, 2);
		hDC = /*Error: Function owner not recognized*/GetDC(ModernizedCProgram.hBootType);
		hFont = (HFONT)/*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hBootType, 49, 0, 0);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SelectObject(hDC, hFont);
		ModernizedCProgram.GetTextExtentPointU(hDC, ModernizedCProgram.short_image_path, sz);
		do {
			if ((hDC != (HANDLE)(true)) && (hDC != ((Object)0))) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseDC(ModernizedCProgram.hBootType, hDC);
				hDC = ((Object)0);
			} 
		} while (0);
		Object generatedCx = sz.getCx();
		Object generatedRight = rc.getRight();
		Object generatedLeft = rc.getLeft();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SendMessageA(ModernizedCProgram.hBootType, 352, (WPARAM)((generatedCx + 10) > (generatedRight - generatedLeft) ? (generatedCx + 10) : (generatedRight - generatedLeft)), (LPARAM)0);
	}
	// Create the horizontal section lines
	public static void OnPaint(Object hdc) {
		int i;
		HPEN hp = /*Error: Function owner not recognized*/CreatePen(0, (ModernizedCProgram.fScale < 1.5) ? 2 : 3, ((COLORREF)((BYTE)(false) | ((BYTE)(false) << 8) | ((BYTE)(false) << 16))));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SelectObject(hdc, hp);
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/MoveToEx(hdc, ModernizedCProgram.mw + 10, ModernizedCProgram.section_vpos[i], ((Object)0));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/LineTo(hdc, ModernizedCProgram.mw + ModernizedCProgram.fw, ModernizedCProgram.section_vpos[i]);
		}
	}
	/*
	  Copyright (C) 2005, 2008, 2010, 2012 Rocky Bernstein <rocky@gnu.org>
	
	  This program is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  This program is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/
	/* Access routines */
	/* udf_private.h has to come first else _FILE_OFFSET_BITS are redefined in
	   say opensolaris. */
	/** The below variables are trickery to force enum symbol values to be
	    recorded in debug symbol tables. They are used to allow one to refer
	    to the enumeration value names in the typedefs above in a debugger
	    and debugger expressions
	*/
	/*!
	  Returns POSIX mode bitstring for a given file.
	*/
	public static Object udf_get_posix_filemode(Object p_udf_dirent) {
		 udf_fe = new ();
		 mode = 0;
		if (ModernizedCProgram.udf_get_file_entry(p_udf_dirent, udf_fe)) {
			 i_perms = new ();
			i_perms = /*Error: Function owner not recognized*/uint32_from_le(udf_fe.getPermissions());
			if (i_perms & FE_PERM_U_READ) {
				mode |=  400;
			} 
			if (i_perms & FE_PERM_U_WRITE) {
				mode |=  200;
			} 
			if (i_perms & FE_PERM_U_EXEC) {
				mode |=  100;
			} 
			if (i_perms & FE_PERM_G_READ) {
				mode |=  (400 >> 3);
			} 
			if (i_perms & FE_PERM_G_WRITE) {
				mode |=  (200 >> 3);
			} 
			if (i_perms & FE_PERM_G_EXEC) {
				mode |=  (100 >> 3);
			} 
			if (i_perms & FE_PERM_O_READ) {
				mode |=  (400 >> 6);
			} 
			if (i_perms & FE_PERM_O_WRITE) {
				mode |=  (200 >> 6);
			} 
			if (i_perms & FE_PERM_O_EXEC) {
				mode |=  (100 >> 6);
			} 
			switch (udf_fe.getIcb_tag().getFile_type()) {
			case ICBTAG_FILE_TYPE_CHAR:
					mode |=  S_IFCHR;
					break;
			case ICBTAG_FILE_TYPE_DIRECTORY:
					mode |=  S_IFDIR;
					break;
			case ICBTAG_FILE_TYPE_BLOCK:
					mode |=  -1024;
					break;
			case ICBTAG_FILE_TYPE_REGULAR:
					mode |=  S_IFREG;
					break;
			default:
					;
			}
			;
		} 
		return mode/*!
		  Return the partition number of the the opened udf handle. -1 
		  Is returned if we have an error.
		*/;
	}
	public static Object udf_get_part_number(Object p_udf) {
		if (!p_udf) {
			return -1;
		} 
		return p_udf.getI_partition();
	}
	public static int udf_checktag(Object p_tag, Object tag_id) {
		 itag = new ();
		 i = new ();
		 cksum = 0;
		itag = ()p_tag;
		if (p_tag.getId() != tag_id) {
			return -1;
		} 
		for (i = 0; i < 15; i++) {
			cksum = cksum + itag[i];
		}
		cksum = cksum - itag[4];
		if (cksum == p_tag.getCksum()) {
			return 0;
		} 
		return -1;
	}
	public static Object udf_get_lba(Object p_udf_fe, Object start, Object end) {
		if (!p_udf_fe.getI_alloc_descs()) {
			return false;
		} 
		switch (p_udf_fe.getIcb_tag().getFlags() & ICBTAG_FLAG_AD_MASK) {
		case ICBTAG_FLAG_AD_LONG:
				{ 
					 p_ad = /* The allocation descriptor field is filled with long_ad's */()(p_udf_fe.getU().getExt_attr() + /*Error: Function owner not recognized*/uint32_from_le(p_udf_fe.getI_extended_attr()));
					start = /*Error: Function owner not recognized*/uint32_from_le(p_ad.getLoc().getLba());
					end = start + ((/*Error: Function owner not recognized*/uint32_from_le(p_ad.getLen()) & UDF_LENGTH_MASK) - 1) / UDF_BLOCKSIZE;
					return true;
				}
				break;
		case ICBTAG_FLAG_AD_SHORT:
				{ 
					 p_ad = /* The allocation descriptor field is filled with short_ad's. */()(p_udf_fe.getU().getExt_attr() + /*Error: Function owner not recognized*/uint32_from_le(p_udf_fe.getI_extended_attr()));
					start = /*Error: Function owner not recognized*/uint32_from_le(p_ad.getPos());
					end = start + ((/*Error: Function owner not recognized*/uint32_from_le(p_ad.getLen()) & UDF_LENGTH_MASK) - 1) / UDF_BLOCKSIZE;
					return true;
				}
				break;
		case ICBTAG_FLAG_AD_EXTENDED:
				{ 
					 p_ad = ()(p_udf_fe.getU().getExt_attr() + /*Error: Function owner not recognized*/uint32_from_le(p_udf_fe.getI_extended_attr()));
					start = /*Error: Function owner not recognized*/uint32_from_le(p_ad.getExt_loc().getLba());
					end = start + ((/*Error: Function owner not recognized*/uint32_from_le(p_ad.getLen()) & UDF_LENGTH_MASK) - 1) / UDF_BLOCKSIZE;
					return true;
				}
				break;
		default:
				return false;
		}
		return false/* Searches p_udf_dirent for a directory entry called psz_token.
		   Note that p_udf_dirent may be replaced or freed during this call
		   and only the returned udf_dirent_t must be used afterwards.
		*/;
	}
	/*out*/
	/*out*/
	public static Object udf_ff_traverse(Object p_udf_dirent, Byte psz_token) {
		while ((p_udf_dirent = ModernizedCProgram.udf_readdir(p_udf_dirent))) {
			if (/*Error: Function owner not recognized*/strcmp(psz_token, p_udf_dirent.getPsz_name()) == 0) {
				byte next_tok = /*Error: Function owner not recognized*/strtok(NULL, "/\\");
				if (!next_tok) {
					return /* found */p_udf_dirent;
				}  else if (p_udf_dirent.getB_dir()) {
					 p_udf_dirent_next = ModernizedCProgram.udf_opendir(p_udf_dirent);
					if (p_udf_dirent_next) {
						ModernizedCProgram.udf_dirent_free(/* free p_udf_dirent to avoid leaking memory. */p_udf_dirent);
						p_udf_dirent_next = ModernizedCProgram.udf_ff_traverse(p_udf_dirent_next, /* previous p_udf_dirent_next is freed by udf_ff_traverse. */next_tok);
						return p_udf_dirent_next;
					} 
				} 
			} 
		}
		return NULL/* FIXME! */;
	}
	public static Object udf_fopen(Object p_udf_root, Object psz_name) {
		 p_udf_file = NULL;
		if (p_udf_root) {
			byte[] tokenline = new byte[2048];
			byte psz_token;
			p_udf_root.getP_udf().setI_position(/* file position must be reset when accessing a new file */0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(tokenline, psz_name, 2048 - 1);
			tokenline[2048 - 1] = (byte)'\0';
			psz_token = /*Error: Function owner not recognized*/strtok(tokenline, "/\\");
			if (psz_token) {
				 p_udf_dirent = ModernizedCProgram.udf_new_dirent(p_udf_root.getFe(), p_udf_root.getP_udf(), p_udf_root.getPsz_name(), p_udf_root.getB_dir(), p_udf_root.getB_parent());
				p_udf_file = ModernizedCProgram.udf_ff_traverse(p_udf_dirent, psz_token);
			}  else if (0 == /*Error: Function owner not recognized*/strncmp("/", psz_name, /*Error: sizeof expression not supported yet*/)) {
				return ModernizedCProgram.udf_new_dirent(p_udf_root.getFe(), p_udf_root.getP_udf(), p_udf_root.getPsz_name(), p_udf_root.getB_dir(), p_udf_root.getB_parent());
			} 
		} 
		return p_udf_file/* Convert unicode16 to UTF-8.
		   The returned string is allocated and must be freed by the caller
		*/;
	}
	public static Byte unicode16_decode(Object[] data, int i_len) {
		int i;
		byte r = NULL;
		switch (data[0]) {
		case 16:
				ModernizedCProgram.cdio_charset_to_utf8((byte)data[1], i_len - 1, r, "UCS-2BE");
				return r;
		case 8:
				r = (byte)/*Error: Function owner not recognized*/calloc(i_len, 1);
				if (r == NULL) {
					return r;
				} 
				for (i = 0; i < i_len - 1; i++) {
					r[i] = data[i + 1];
				}
				return r;
		default:
				r = (byte)/*Error: Function owner not recognized*/calloc(1, /* Empty string, as some existing sections can't take a NULL pointer */1);
				return r;
		}
	}
	public static Object udf_new_dirent(Object p_udf_fe, Object p_udf, Object psz_name, Object b_dir, Object b_parent) {
		 p_udf_dirent = ()/*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/);
		if (!p_udf_dirent) {
			return NULL;
		} 
		p_udf_dirent.setPsz_name(/*Error: Function owner not recognized*/strdup(psz_name));
		p_udf_dirent.setB_dir(b_dir);
		p_udf_dirent.setB_parent(b_parent);
		p_udf_dirent.setP_udf(p_udf);
		p_udf_dirent.setI_part_start(p_udf.getI_part_start());
		p_udf_dirent.setDir_left(/*Error: Function owner not recognized*/uint64_from_le(p_udf_fe.getInfo_len()));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_udf_dirent.getFe()), p_udf_fe, /*Error: Unsupported expression*/);
		ModernizedCProgram.udf_get_lba(p_udf_fe, (p_udf_dirent.getI_loc()), (p_udf_dirent.getI_loc_end()));
		return p_udf_dirent/*!
		  Seek to a position i_start and then read i_blocks. Number of blocks read is
		  returned. One normally expects the return to be equal to i_blocks.
		*/;
	}
	/**
	 * Check the descriptor tag for both the correct id and correct checksum.
	 * Return zero if all is good, -1 if not.
	 */
	public static Object udf_read_sectors(Object p_udf, Object ptr, Object i_start, long i_blocks) {
		 ret = new ();
		long i_read;
		 i_byte_offset = new ();
		if (!p_udf) {
			return 0;
		} 
		i_byte_offset = (()i_start) * /* Without the cast, i_start * UDF_BLOCKSIZE may be evaluated as 32 bit */UDF_BLOCKSIZE;
		if (i_byte_offset < /* Since we're using SEEK_SET, the value must be positive */0) {
			if (/*Error: Unsupported expression*/ <= /* probably missing LFS */4) {
				ModernizedCProgram.cdio_warn("Large File Support is required to access streams of 2 GB or more");
			} 
			return DRIVER_OP_BAD_PARAMETER;
		} 
		if (p_udf.getB_stream()) {
			ret = p_udf.getStream().cdio_stream_seek(i_byte_offset, SEEK_SET);
			if (DRIVER_OP_SUCCESS != ret) {
				return ret;
			} 
			i_read = p_udf.getStream().cdio_stream_read(ptr, UDF_BLOCKSIZE, i_blocks);
			if (i_read) {
				return DRIVER_OP_SUCCESS;
			} 
			return DRIVER_OP_ERROR;
		} else {
				return ModernizedCProgram.cdio_read_data_sectors(p_udf.getCdio(), ptr, i_start, UDF_BLOCKSIZE, i_blocks/*!
				  Open an UDF for reading. Maybe in the future we will have
				  a mode. NULL is returned on error.
				
				  Caller must free result - use udf_close for that.
				*/);
		} 
	}
	public static Object udf_open(Object psz_path) {
		 p_udf = ()/*Error: Function owner not recognized*/calloc(1, /*Error: Unsupported expression*/);
		[] data = new ();
		if (!p_udf) {
			return NULL;
		} 
		((/*Error: Unsupported expression*/ == UDF_BLOCKSIZE) ? (Object)0 : /*Error: Function owner not recognized*/_assert("sizeof(udf_file_entry_t) == UDF_BLOCKSIZE", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\udf_fs.c", /* Sanity check */378));
		p_udf.setCdio(ModernizedCProgram.cdio_open(psz_path, DRIVER_UNKNOWN));
		_CdioDataSource _CdioDataSource = new _CdioDataSource();
		if (!p_udf.getCdio()) {
			p_udf.setStream(_CdioDataSource.cdio_stdio_new(psz_path));
			if (!p_udf.getStream()) {
				;
			} 
			p_udf.setB_stream(true);
		} 
		if (DRIVER_OP_SUCCESS != ModernizedCProgram.udf_read_sectors(p_udf, data, 256, /*
		   * Look for an Anchor Volume Descriptor Pointer at sector 256.
		   */1)) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy((p_udf.getAnchor_vol_desc_ptr()), data, /*Error: Unsupported expression*/);
		if (ModernizedCProgram.udf_checktag(()(p_udf.getAnchor_vol_desc_ptr()), TAGID_ANCHOR)) {
			;
		} 
		{ 
			 p_avdp = p_udf.getAnchor_vol_desc_ptr();
			 mvds_start = /*Error: Function owner not recognized*/uint32_from_le(p_avdp.getMain_vol_desc_seq_ext().getLoc());
			 mvds_end = mvds_start + (/*Error: Function owner not recognized*/uint32_from_le(p_avdp.getMain_vol_desc_seq_ext().getLen()) - 1) / UDF_BLOCKSIZE;
			 i_lba = new ();
			for (i_lba = mvds_start; i_lba < mvds_end; i_lba++) {
				 p_pvd = ()data;
				if (DRIVER_OP_SUCCESS != ModernizedCProgram.udf_read_sectors(p_udf, p_pvd, i_lba, 1)) {
					;
				} 
				if (!ModernizedCProgram.udf_checktag(p_pvd.getTag(), TAGID_PRI_VOL)) {
					p_udf.setPvd_lba(i_lba);
					break;
				} 
			}
			if (i_lba == /*
			     * If we couldn't find a reference, bail out.
			     */mvds_end) {
				;
			} 
		}
		return p_udf;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_udf);
		return NULL/**
		 * Gets the Volume Identifier, as an UTF-8 string
		 * psz_volid, place to put the string
		 * i_volid, size of the buffer psz_volid points to
		 * returns the size of buffer needed for all data
		 * Note: this call accepts a NULL psz_volid, to retrieve the length required.
		 */;
	}
	/*out*/
	public static int udf_get_volume_id(Object p_udf, byte[] psz_volid, int i_volid) {
		[] data = new ();
		 p_pvd = ()data;
		byte r;
		int volid_len;
		if (psz_volid != /* clear the output to empty string */NULL) {
			psz_volid[0] = 0;
		} 
		if (DRIVER_OP_SUCCESS != ModernizedCProgram.udf_read_sectors(p_udf, data, p_udf.getPvd_lba(), /* get primary volume descriptor */1)) {
			return 0;
		} 
		volid_len = p_pvd.getVol_ident()[UDF_VOLID_SIZE - 1];
		if (volid_len > UDF_VOLID_SIZE - 1) {
			volid_len = UDF_VOLID_SIZE - /* this field is only UDF_VOLID_SIZE bytes something is wrong */1;
		} 
		r = ModernizedCProgram.unicode16_decode(()p_pvd.getVol_ident(), volid_len);
		if (r == NULL) {
			return 0;
		} 
		volid_len = /*Error: Function owner not recognized*/strlen(r) + /* +1 for NUL terminator */1;
		if (psz_volid != NULL) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(psz_volid, r, /*Error: Function owner not recognized*/MIN(volid_len, i_volid));
			psz_volid[i_volid - 1] = /* strncpy does not always terminate the dest */0;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(r);
		return volid_len/**
		 * Gets the Volume Set Identifier, as a 128-byte dstring (not decoded)
		 * WARNING This is not a null terminated string
		 * volsetid, place to put the data
		 * i_volsetid, size of the buffer psz_volsetid points to
		 * the buffer should be >=128 bytes to store the whole volumesetidentifier
		 * returns the size of the available volsetid information (128)
		 * or 0 on error
		 */;
	}
	/*out*/
	public static int udf_get_volumeset_id(Object p_udf, Object volsetid, int i_volsetid) {
		[] data = new ();
		 p_pvd = ()data;
		if (DRIVER_OP_SUCCESS != ModernizedCProgram.udf_read_sectors(p_udf, data, p_udf.getPvd_lba(), /* get primary volume descriptor */1)) {
			return 0;
		} 
		if (i_volsetid > UDF_VOLSET_ID_SIZE) {
			i_volsetid = UDF_VOLSET_ID_SIZE;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(volsetid, p_pvd.getVolset_id(), i_volsetid);
		return UDF_VOLSET_ID_SIZE/**
		 * Gets the Logical Volume Identifier string, as an UTF-8 string
		 * psz_logvolid, place to put the string (should be at least 64 bytes)
		 * i_logvolid, size of the buffer psz_logvolid points to
		 * returns the size of buffer needed for all data, including NUL terminator
		 * A call to udf_get_root() should have been issued before this call
		 * Note: this call accepts a NULL psz_volid, to retrieve the length required.
		 */;
	}
	/*out*/
	public static int udf_get_logical_volume_id(Object p_udf, byte[] psz_logvolid, int i_logvolid) {
		[] data = new ();
		 p_logvol = ()data;
		byte r;
		int logvolid_len;
		if (psz_logvolid != /* clear the output to empty string */NULL) {
			psz_logvolid[0] = 0;
		} 
		if (DRIVER_OP_SUCCESS != ModernizedCProgram.udf_read_sectors(p_udf, p_logvol, p_udf.getLvd_lba(), 1)) {
			return 0;
		} 
		r = ModernizedCProgram.unicode16_decode(()p_logvol.getLogvol_id(), p_logvol.getLogvol_id()[127]);
		if (r == NULL) {
			return 0;
		} 
		logvolid_len = /*Error: Function owner not recognized*/strlen(r) + /* +1 for NUL terminator */1;
		if (psz_logvolid != NULL) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strncpy(psz_logvolid, r, /*Error: Function owner not recognized*/MIN(logvolid_len, i_logvolid));
			psz_logvolid[i_logvolid - 1] = /* strncpy does not always terminate the dest */0;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(r);
		return logvolid_len/*!
		  Get the root in p_udf. If b_any_partition is false then
		  the root must be in the given partition.
		  NULL is returned if the partition is not found or a root is not found or
		  there is on error.
		
		  Caller must free result - use udf_dirent_free for that.
		*/;
	}
	public static Object udf_get_root(Object p_udf, Object b_any_partition, Object i_partition) {
		 p_avdp = p_udf.getAnchor_vol_desc_ptr();
		 mvds_start = /*Error: Function owner not recognized*/uint32_from_le(p_avdp.getMain_vol_desc_seq_ext().getLoc());
		 mvds_end = mvds_start + (/*Error: Function owner not recognized*/uint32_from_le(p_avdp.getMain_vol_desc_seq_ext().getLen()) - 1) / UDF_BLOCKSIZE;
		 i_lba = new ();
		[] data = new ();
		for (i_lba = mvds_start; i_lba < mvds_end; i_lba++) {
			[] data2 = new ();
			 p_partition = ()data2;
			if (DRIVER_OP_SUCCESS != ModernizedCProgram.udf_read_sectors(p_udf, p_partition, i_lba, 1)) {
				return NULL;
			} 
			if (!ModernizedCProgram.udf_checktag(p_partition.getTag(), TAGID_PARTITION)) {
				 i_partition_check = /*Error: Function owner not recognized*/uint16_from_le(p_partition.getNumber());
				if (b_any_partition || i_partition_check == i_partition) {
					p_udf.setI_partition(/*Error: Function owner not recognized*/uint16_from_le(p_partition.getNumber()));
					p_udf.setI_part_start(/*Error: Function owner not recognized*/uint32_from_le(p_partition.getStart_loc()));
					if (p_udf.getLvd_lba()) {
						break;
					} 
				} 
			}  else if (!ModernizedCProgram.udf_checktag(p_partition.getTag(), TAGID_LOGVOL)) {
				 p_logvol = ()/* Get fileset descriptor */data2;
				 b_valid = UDF_BLOCKSIZE == /*Error: Function owner not recognized*/uint32_from_le(p_logvol.getLogical_blocksize());
				if (b_valid) {
					p_udf.setLvd_lba(i_lba);
					p_udf.setFsd_offset(/*Error: Function owner not recognized*/uint32_from_le(p_logvol.getLvd_use().getFsd_loc().getLoc().getLba()));
					if (p_udf.getI_part_start()) {
						break;
					} 
				} 
			} 
		}
		if (p_udf.getLvd_lba() && p_udf.getI_part_start()) {
			 p_fsd = ()data;
			 ret = ModernizedCProgram.udf_read_sectors(p_udf, p_fsd, p_udf.getI_part_start() + p_udf.getFsd_offset(), 1);
			if (DRIVER_OP_SUCCESS == ret && !ModernizedCProgram.udf_checktag(p_fsd.getTag(), TAGID_FSD)) {
				 p_udf_fe = ()data;
				 parent_icb = /*Error: Function owner not recognized*/uint32_from_le(p_fsd.getRoot_icb().getLoc().getLba());
				ret = ModernizedCProgram.udf_read_sectors(p_udf, /* Check partition numbers match of last-read block?  */p_udf_fe, p_udf.getI_part_start() + parent_icb, 1);
				if (ret == DRIVER_OP_SUCCESS && !ModernizedCProgram.udf_checktag(p_udf_fe.getTag(), TAGID_FILE_ENTRY/* Check partition numbers match of last-read block? */)) {
					return ModernizedCProgram.udf_new_dirent(p_udf_fe, p_udf, "/", true, /* We win! - Save root directory information. */false);
				} 
			} 
		} 
		return NULL;
	}
	/*!
	  Close UDF and free resources associated with p_udf.
	*/
	public static Object udf_close(Object p_udf) {
		if (!p_udf) {
			return true;
		} 
		if (p_udf.getB_stream()) {
			p_udf.getStream().cdio_stdio_destroy();
		} else {
				ModernizedCProgram.cdio_destroy(p_udf.getCdio());
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CDIO_FREE_IF_NOT_NULL(p_udf);
		p_udf = /* Get rid of root directory if allocated. */NULL;
		return true;
	}
	public static Object udf_opendir(Object p_udf_dirent) {
		if (p_udf_dirent.getB_dir() && !p_udf_dirent.getB_parent() && p_udf_dirent.getFid()) {
			 p_udf = p_udf_dirent.getP_udf();
			 udf_fe = new ();
			 i_ret = ModernizedCProgram.udf_read_sectors(p_udf, udf_fe, p_udf.getI_part_start() + p_udf_dirent.getFid().getIcb().getLoc().getLba(), 1);
			if (DRIVER_OP_SUCCESS == i_ret && !ModernizedCProgram.udf_checktag(udf_fe.getTag(), TAGID_FILE_ENTRY)) {
				if (ICBTAG_FILE_TYPE_DIRECTORY == udf_fe.getIcb_tag().getFile_type()) {
					 p_udf_dirent_new = ModernizedCProgram.udf_new_dirent(udf_fe, p_udf, p_udf_dirent.getPsz_name(), true, true);
					return p_udf_dirent_new;
				} 
			} 
		} 
		return NULL;
	}
	public static Object udf_readdir(Object p_udf_dirent) {
		 p_udf = new ();
		 p = new ();
		if (p_udf_dirent.getDir_left() <= 0) {
			ModernizedCProgram.udf_dirent_free(p_udf_dirent);
			return NULL;
		} 
		p_udf = p_udf_dirent.getP_udf();
		p_udf.setI_position(0);
		if (p_udf_dirent.getFid()) {
			 ofs = /* FIXME: need to advance file entry (fe) as well.  */4 * ((/*Error: sizeof expression not supported yet*/ + p_udf_dirent.getFid().getU().getI_imp_use() + p_udf_dirent.getFid().getI_file_id() + 3) / 4);
			p_udf_dirent.setFid(()(()p_udf_dirent.getFid() + ofs));
		} 
		if (!p_udf_dirent.getFid()) {
			 i_sectors = (p_udf_dirent.getI_loc_end() - p_udf_dirent.getI_loc() + 1);
			 size = UDF_BLOCKSIZE * i_sectors;
			 i_ret = new ();
			if (!p_udf_dirent.getSector()) {
				p_udf_dirent.setSector(()/*Error: Function owner not recognized*/malloc(size));
			} 
			i_ret = ModernizedCProgram.udf_read_sectors(p_udf, p_udf_dirent.getSector(), p_udf_dirent.getI_part_start() + p_udf_dirent.getI_loc(), i_sectors);
			if (DRIVER_OP_SUCCESS == i_ret) {
				p_udf_dirent.setFid(()p_udf_dirent.getSector());
			} else {
					p_udf_dirent.setFid(NULL);
			} 
		} 
		if (p_udf_dirent.getFid() && !ModernizedCProgram.udf_checktag((p_udf_dirent.getFid().getTag()), TAGID_FID)) {
			 ofs = 4 * ((/*Error: sizeof expression not supported yet*/ + p_udf_dirent.getFid().getU().getI_imp_use() + p_udf_dirent.getFid().getI_file_id() + 3) / 4);
			p_udf_dirent.getDir_left() -= ofs;
			p_udf_dirent.setB_dir((p_udf_dirent.getFid().getFile_characteristics() & UDF_FILE_DIRECTORY) != 0);
			p_udf_dirent.setB_parent((p_udf_dirent.getFid().getFile_characteristics() & UDF_FILE_PARENT) != 0);
			{ 
				int i_len = p_udf_dirent.getFid().getI_file_id();
				if (DRIVER_OP_SUCCESS != ModernizedCProgram.udf_read_sectors(p_udf, p_udf_dirent.getFe(), p_udf.getI_part_start() + /*Error: Function owner not recognized*/uint32_from_le(p_udf_dirent.getFid().getIcb().getLoc().getLba()), 1)) {
					ModernizedCProgram.udf_dirent_free(p_udf_dirent);
					return NULL;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CDIO_FREE_IF_NOT_NULL(p_udf_dirent.getPsz_name());
				p_udf_dirent.setPsz_name(NULL);
				p = ()p_udf_dirent.getFid().getU().getImp_use().getData() + p_udf_dirent.getFid().getU().getI_imp_use();
				p_udf_dirent.setPsz_name(ModernizedCProgram.unicode16_decode(p, i_len));
			}
			return p_udf_dirent;
		} 
		ModernizedCProgram.udf_dirent_free(p_udf_dirent);
		return NULL/*!
		  free free resources associated with p_udf_dirent.
		*/;
	}
	public static Object udf_dirent_free(Object p_udf_dirent) {
		if (p_udf_dirent) {
			p_udf_dirent.setFid(NULL);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CDIO_FREE_IF_NOT_NULL(p_udf_dirent.getPsz_name());
			p_udf_dirent.setPsz_name(NULL);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CDIO_FREE_IF_NOT_NULL(p_udf_dirent.getSector());
			p_udf_dirent.setSector(NULL);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CDIO_FREE_IF_NOT_NULL(p_udf_dirent);
			p_udf_dirent = NULL;
		} 
		return true;
	}
	public static Object ext2fs_lookup(Object fs, Object dir, Object name, int namelen, Byte buf, Object inode) {
		 retval = new ();
		lookup_struct ls = new lookup_struct();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		ls.setName(name);
		ls.setLen(namelen);
		ls.setInode(inode);
		ls.setFound(0);
		retval = ModernizedCProgram.ext2fs_dir_iterate(fs, dir, 0, buf, lookup_proc, ls);
		if (retval) {
			return retval;
		} 
		int generatedFound = ls.getFound();
		return (generatedFound) ? 0 : EXT2_ET_FILE_NOT_FOUND;
	}
	/*
	  Copyright (C) 2014-2015 Robert Kausch <robert.kausch@freac.org>
	
	  This program is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  This program is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/
	/*! 
	  Free the passed pointer.
	  
	  @param p_memory a pointer to memory allocated by a libcdio funtion.
	*/
	public static void cdio_free(Object p_memory) {
		if (p_memory != NULL) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(p_memory);
		} 
	}
	public static Object WinPKIErrorString() {
		byte[] error_string = new byte[64];
		DWORD error_code = /*Error: Function owner not recognized*/GetLastError();
		if (((error_code >> 16) != -1024) && ((error_code >> 16) != -1024)) {
			return ModernizedCProgram.WindowsErrorString();
		} 
		switch (error_code) {
		case ((HRESULT)-1024):
				return "Invalid Signature.";
		case ((HRESULT)-1024):
				return "No provider was specified for the store or object.";
		case ((HRESULT)-1024):
				return "Bad version of provider.";
		case CRYPT_E_HASH_VALUE:
				return "The hash value is not correct";
		case CRYPT_E_MSG_ERROR:
				return "An error occurred while performing an operation on a cryptographic message.";
		case CRYPT_E_BAD_ENCODE:
				return "An error occurred during encode or decode operation.";
		case ((HRESULT)-1024):
				return "Cannot find object or property.";
		case CRYPT_E_FILE_ERROR:
				return "An error occurred while reading or writing to a file.";
		case ((HRESULT)-1024):
		case ((HRESULT)-1024):
		case CRYPT_E_INVALID_IA5_STRING:
		case ((HRESULT)-1024):
				return "Bad UID.";
		case (true):
				return "The root certificate is not trusted.";
		case CRYPT_E_INVALID_X500_STRING:
		case CRYPT_E_NOT_IN_REVOCATION_DATABASE:
				return "Cannot check certificate revocation.";
		case TRUST_E_NOSIGNATURE:
				return "Not digitally signed.";
		case CRYPT_E_INVALID_PRINTABLE_STRING:
		case ((HRESULT)-1024):
				return "Key does not exist.";
		case CRYPT_E_BAD_LEN:
				return "The length specified for the output data was insufficient.";
		case CRYPT_E_NO_TRUSTED_SIGNER:
				return "None of the signers of the cryptographic message or certificate trust list is trusted.";
		case ((HRESULT)-1024):
				return "Invalid algorithm specified.";
		case ((HRESULT)-1024):
				return "Private key or certificate issue";
		case CRYPT_E_INVALID_NUMERIC_STRING:
		case ((HRESULT)-1024):
				return "The previous certificate or CRL context was deleted.";
		case ((HRESULT)-1024):
				return "The signed cryptographic message does not have a signer for the specified signer index.";
		case ((HRESULT)-1024):
				return "The object or property already exists.";
		case TRUST_E_TIME_STAMP:
				return "The timestamp could not be verified.";
		case CRYPT_E_UNKNOWN_ALGO:
				return "Unknown cryptographic algorithm.";
		case ((HRESULT)-1024):
		case CRYPT_E_NOT_CHAR_STRING:
				return "Invalid string.";
		case CRYPT_E_NO_VERIFY_USAGE_CHECK:
		case ((HRESULT)-1024):
		case ((HRESULT)-1024):
				return "Keyset does not exist.";
		case CRYPT_E_VERIFY_USAGE_OFFLINE:
				return "Cannot complete usage check.";
		case ((HRESULT)-1024):
				return "Not a cryptographic message.";
		case CRYPT_E_SECURITY_SETTINGS:
				return "The cryptographic operation failed due to a local security option setting.";
		case (true):
				return "The certificate is revoked.";
		case CRYPT_E_ISSUER_SERIALNUMBER:
				return "Invalid issuer and/or serial number.";
		case (true):
		case CRYPT_E_INVALID_MSG_TYPE:
				return "Invalid cryptographic message type.";
		case TRUST_E_EXPLICIT_DISTRUST:
				return "One of the certificates used was marked as untrusted by the user.";
		case ((HRESULT)-1024):
				return "Cannot find the requested object.";
		default:
				do {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(error_string, /*Error: sizeof expression not supported yet*/, "Unknown PKI error 0x%08lX", error_code);
					(error_string)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
				} while (0);
				return error_string;
		}// See also https://docs.microsoft.com/en-gb/windows/desktop/com/com-error-codes-4
	}
	// Mostly from https://support.microsoft.com/en-us/kb/323809
	public static Byte GetSignatureName(Object path, Object country_code) {
		byte[] szSubjectName = new byte[128];
		byte[] szCountry = "__";
		byte p = ((Object)0);
		byte mpath = ((Object)0);
		int i;
		BOOL r = new BOOL();
		HMODULE hm = new HMODULE();
		HCERTSTORE hStore = ((Object)0);
		HCRYPTMSG hMsg = ((Object)0);
		PCCERT_CONTEXT pCertContext = ((Object)0);
		DWORD dwSize = new DWORD();
		DWORD dwEncoding = new DWORD();
		DWORD dwContentType = new DWORD();
		DWORD dwFormatType = new DWORD();
		 pSignerInfo = ((Object)0);
		DWORD dwSignerInfo = 0;
		CERT_INFO CertInfo = new CERT_INFO(0);
		SPROG_PUBLISHERINFO ProgPubInfo = new SPROG_PUBLISHERINFO(0);
		wchar_t szFileName = new wchar_t();
		// If the path is NULL, get the signature of the current runtimeif (path == ((Object)0)) {
			szFileName = /*Error: Function owner not recognized*/calloc(260, /*Error: Unsupported expression*/);
			if (szFileName == ((Object)0)) {
				return ((Object)0);
			} 
			hm = /*Error: Function owner not recognized*/GetModuleHandleA(((Object)0));
			if (hm == ((Object)0)) {
				ModernizedCProgram._uprintf("PKI: Could not get current executable handle: %s", ModernizedCProgram.WinPKIErrorString());
				;
			} 
			dwSize = /*Error: Function owner not recognized*/GetModuleFileNameW(hm, szFileName, 260);
			if ((dwSize == 0) || ((dwSize == 260) && (/*Error: Function owner not recognized*/GetLastError() == -1024))) {
				ModernizedCProgram._uprintf("PKI: Could not get module filename: %s", ModernizedCProgram.WinPKIErrorString());
				;
			} 
			mpath = ModernizedCProgram.wchar_to_utf8(szFileName);
		} else {
				szFileName = ModernizedCProgram.utf8_to_wchar(path);
		} 
		// Get message handle and store handle from the signed file.for (i = 0; i < 5; i++) {
			r = /*Error: Function owner not recognized*/CryptQueryObject(CERT_QUERY_OBJECT_FILE, szFileName, CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED, CERT_QUERY_FORMAT_FLAG_BINARY, 0, dwEncoding, dwContentType, dwFormatType, hStore, hMsg, ((Object)0));
			if (r) {
				break;
			} 
			if (i == 0) {
				ModernizedCProgram._uprintf("PKI: Failed to get signature for '%s': %s", (path == ((Object)0)) ? mpath : path, ModernizedCProgram.WinPKIErrorString());
			} 
			if (path == ((Object)0)) {
				break;
			} 
			ModernizedCProgram._uprintf("PKI: Retrying...");
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/Sleep(2000);
		}
		if (!r) {
			;
		} 
		// Get signer information size.// Get signer information size.r = /*Error: Function owner not recognized*/CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, ((Object)0), dwSignerInfo);
		if (!r) {
			ModernizedCProgram._uprintf("PKI: Failed to get signer size: %s", ModernizedCProgram.WinPKIErrorString());
			;
		} 
		// Allocate memory for signer information.// Allocate memory for signer information.pSignerInfo = ()/*Error: Function owner not recognized*/calloc(dwSignerInfo, 1);
		if (!pSignerInfo) {
			ModernizedCProgram._uprintf("PKI: Could not allocate memory for signer information");
			;
		} 
		// Get Signer Information.// Get Signer Information.r = /*Error: Function owner not recognized*/CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, (PVOID)pSignerInfo, dwSignerInfo);
		if (!r) {
			ModernizedCProgram._uprintf("PKI: Failed to get signer information: %s", ModernizedCProgram.WinPKIErrorString());
			;
		} 
		// Search for the signer certificate in the temporary certificate store.// Search for the signer certificate in the temporary certificate store.CertInfo.setIssuer(pSignerInfo.getIssuer());
		CertInfo.setSerialNumber(pSignerInfo.getSerialNumber());
		pCertContext = /*Error: Function owner not recognized*/CertFindCertificateInStore(hStore, (1 | 65536), 0, 720896, (PVOID)CertInfo, ((Object)0));
		if (!pCertContext) {
			ModernizedCProgram._uprintf("PKI: Failed to locate signer certificate in temporary store: %s", ModernizedCProgram.WinPKIErrorString());
			;
		} 
		// If a country code is provided, validate that the certificate we have is for the same countryif (country_code != ((Object)0)) {
			dwSize = /*Error: Function owner not recognized*/CertGetNameStringA(pCertContext, 3, 0, "2.5.4.6", szCountry, /*Error: sizeof expression not supported yet*/);
			if (dwSize < 2) {
				ModernizedCProgram._uprintf("PKI: Failed to get Country Code");
				;
			} 
			if (/*Error: Function owner not recognized*/strcmpi(country_code, szCountry) != 0) {
				ModernizedCProgram._uprintf("PKI: Unexpected Country Code (Found '%s', expected '%s')", szCountry, country_code);
				;
			} 
		} 
		// Isolate the signing certificate subject name// Isolate the signing certificate subject namedwSize = /*Error: Function owner not recognized*/CertGetNameStringA(pCertContext, 3, 0, "2.5.4.3", szSubjectName, /*Error: sizeof expression not supported yet*/);
		if (dwSize <= 1) {
			ModernizedCProgram._uprintf("PKI: Failed to get Subject Name");
			;
		} 
		if (szCountry[0] == (byte)'_') {
			ModernizedCProgram._uprintf("Binary executable is signed by '%s'", szSubjectName);
		} else {
				ModernizedCProgram._uprintf("Binary executable is signed by '%s' (%s)", szSubjectName, szCountry);
		} 
		p = szSubjectName;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)szFileName);
			szFileName = ((Object)0);
		} while (0);
		Object generatedLpszProgramName = ProgPubInfo.getLpszProgramName();
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)generatedLpszProgramName);
			ProgPubInfo.setLpszProgramName(((Object)0));
		} while (0);
		Object generatedLpszPublisherLink = ProgPubInfo.getLpszPublisherLink();
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)generatedLpszPublisherLink);
			ProgPubInfo.setLpszPublisherLink(((Object)0));
		} while (0);
		Object generatedLpszMoreInfoLink = ProgPubInfo.getLpszMoreInfoLink();
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)generatedLpszMoreInfoLink);
			ProgPubInfo.setLpszMoreInfoLink(((Object)0));
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)pSignerInfo);
			pSignerInfo = ((Object)0);
		} while (0);
		if (pCertContext != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CertFreeCertificateContext(pCertContext);
		} 
		if (hStore != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CertCloseStore(hStore, 0);
		} 
		if (hMsg != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CryptMsgClose(hMsg);
		} 
		return p;
	}
	// The timestamping authorities we use are RFC 3161 compliant
	public static Object GetRFC3161TimeStamp(Object pSignerInfo) {
		BOOL r = new BOOL();
		BOOL found = 0;
		DWORD n = new DWORD();
		DWORD dwSize = 0;
		 pCounterSignerInfo = ((Object)0);
		uint64_t ts = -1024;
		uint8_t timestamp_token = new uint8_t();
		size_t timestamp_token_size = new size_t();
		byte timestamp_str;
		size_t timestamp_str_size = new size_t();
		// Loop through unauthenticated attributes for szOID_RFC3161_counterSign OIDfor (n = 0; n < pSignerInfo.getUnauthAttrs().getCAttr(); n++) {
			if (/*Error: Function owner not recognized*/lstrcmpA(pSignerInfo.getUnauthAttrs().getRgAttr()[n].getPszObjId(), szOID_RFC3161_counterSign) == 0) {
				if (found) {
					ModernizedCProgram._uprintf("PKI: Multiple RFC 3161 countersigners found. This could indicate something very nasty...");
					return -1024;
				} 
				found = 1;
				r = /*Error: Function owner not recognized*/CryptDecodeObjectEx(65536, (LPCSTR)33, pSignerInfo.getUnauthAttrs().getRgAttr()[n].getRgValue()[0].getPbData(), pSignerInfo.getUnauthAttrs().getRgAttr()[n].getRgValue()[0].getCbData(), CRYPT_DECODE_ALLOC_FLAG, ((Object)0), (PVOID)pCounterSignerInfo, dwSize);
				if (!r) {
					ModernizedCProgram._uprintf("PKI: Could not retrieve RFC 3161 countersigner data: %s", ModernizedCProgram.WinPKIErrorString());
					continue;
				} 
				timestamp_token = ModernizedCProgram.get_data_from_asn1(pCounterSignerInfo.getContent().getPbData(), pCounterSignerInfo.getContent().getCbData(), szOID_TIMESTAMP_TOKEN, -1024, timestamp_token_size);
				if (timestamp_token) {
					timestamp_str = ModernizedCProgram.get_data_from_asn1(timestamp_token, timestamp_token_size, ((Object)0), -1024, timestamp_str_size);
					if (timestamp_str) {
						if ((timestamp_str_size < 14) || (timestamp_str[timestamp_str_size - 1] != (byte)'Z')) {
							ModernizedCProgram._uprintf("PKI: Not an RFC 3161 timestamp");
							ModernizedCProgram.DumpBufferHex(timestamp_str, timestamp_str_size);
						} else {
								ts = /*Error: Function owner not recognized*/strtoull(timestamp_str, ((Object)0), 10);
						} 
					} 
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/LocalFree(pCounterSignerInfo);
			} 
		}
		return ts;
	}
	// The following is used to get the RFP 3161 timestamp of a nested signature
	public static Object GetNestedRFC3161TimeStamp(Object pSignerInfo) {
		BOOL r = new BOOL();
		BOOL found = 0;
		DWORD n = new DWORD();
		DWORD dwSize = 0;
		 pNestedSignature = ((Object)0);
		 pNestedSignerInfo = ((Object)0);
		HCRYPTMSG hMsg = ((Object)0);
		uint64_t ts = -1024;
		// Loop through unauthenticated attributes for szOID_NESTED_SIGNATURE OIDfor (n = 0; /*Error: Unsupported expression*/; n++) {
			if (pNestedSignature != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/LocalFree(pNestedSignature);
				pNestedSignature = ((Object)0);
			} 
			if (hMsg != ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CryptMsgClose(hMsg);
				hMsg = ((Object)0);
			} 
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)pNestedSignerInfo);
				pNestedSignerInfo = ((Object)0);
			} while (0);
			if (n >= pSignerInfo.getUnauthAttrs().getCAttr()) {
				break;
			} 
			if (/*Error: Function owner not recognized*/lstrcmpA(pSignerInfo.getUnauthAttrs().getRgAttr()[n].getPszObjId(), "1.3.6.1.4.1.311.2.4.1") == 0) {
				if (found) {
					ModernizedCProgram._uprintf("PKI: Multiple nested signatures found. This could indicate something very nasty...");
					return -1024;
				} 
				found = 1;
				r = /*Error: Function owner not recognized*/CryptDecodeObjectEx(65536, (LPCSTR)33, pSignerInfo.getUnauthAttrs().getRgAttr()[n].getRgValue()[0].getPbData(), pSignerInfo.getUnauthAttrs().getRgAttr()[n].getRgValue()[0].getCbData(), CRYPT_DECODE_ALLOC_FLAG, ((Object)0), (PVOID)pNestedSignature, dwSize);
				if (!r) {
					ModernizedCProgram._uprintf("PKI: Could not retrieve nested signature data: %s", ModernizedCProgram.WinPKIErrorString());
					continue;
				} 
				hMsg = /*Error: Function owner not recognized*/CryptMsgOpenToDecode((1 | 65536), CMSG_DETACHED_FLAG, CMSG_SIGNED, (HCRYPTPROV)((Object)0), ((Object)0), ((Object)0));
				if (hMsg == ((Object)0)) {
					ModernizedCProgram._uprintf("PKI: Could not create nested signature message: %s", ModernizedCProgram.WinPKIErrorString());
					continue;
				} 
				r = /*Error: Function owner not recognized*/CryptMsgUpdate(hMsg, pNestedSignature.getContent().getPbData(), pNestedSignature.getContent().getCbData(), 1);
				if (!r) {
					ModernizedCProgram._uprintf("PKI: Could not update message: %s", ModernizedCProgram.WinPKIErrorString());
					continue;
				} 
				r = /*Error: Function owner not recognized*/CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, ((Object)0), dwSize);
				if (!r) {
					ModernizedCProgram._uprintf("PKI: Failed to get nested signer size: %s", ModernizedCProgram.WinPKIErrorString());
					continue;
				} 
				pNestedSignerInfo = ()/*Error: Function owner not recognized*/calloc(dwSize, 1);
				if (!pNestedSignerInfo) {
					ModernizedCProgram._uprintf("PKI: Could not allocate memory for nested signer");
					continue;
				} 
				r = /*Error: Function owner not recognized*/CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, (PVOID)pNestedSignerInfo, dwSize);
				if (!r) {
					ModernizedCProgram._uprintf("PKI: Failed to get nested signer information: %s", ModernizedCProgram.WinPKIErrorString());
					continue;
				} 
				ts = ModernizedCProgram.GetRFC3161TimeStamp(pNestedSignerInfo);
			} 
		}
		return ts;
	}
	// Return the signature timestamp (as a YYYYMMDDHHMMSS value) or 0 on error
	public static Object GetSignatureTimeStamp(Object path) {
		byte mpath = ((Object)0);
		BOOL r = new BOOL();
		HMODULE hm = new HMODULE();
		HCERTSTORE hStore = ((Object)0);
		HCRYPTMSG hMsg = ((Object)0);
		DWORD dwSize = new DWORD();
		DWORD dwEncoding = new DWORD();
		DWORD dwContentType = new DWORD();
		DWORD dwFormatType = new DWORD();
		 pSignerInfo = ((Object)0);
		DWORD dwSignerInfo = 0;
		wchar_t szFileName = new wchar_t();
		uint64_t timestamp = -1024;
		uint64_t nested_timestamp = new uint64_t();
		// If the path is NULL, get the signature of the current runtimeif (path == ((Object)0)) {
			szFileName = /*Error: Function owner not recognized*/calloc(260, /*Error: Unsupported expression*/);
			if (szFileName == ((Object)0)) {
				;
			} 
			hm = /*Error: Function owner not recognized*/GetModuleHandleA(((Object)0));
			if (hm == ((Object)0)) {
				ModernizedCProgram._uprintf("PKI: Could not get current executable handle: %s", ModernizedCProgram.WinPKIErrorString());
				;
			} 
			dwSize = /*Error: Function owner not recognized*/GetModuleFileNameW(hm, szFileName, 260);
			if ((dwSize == 0) || ((dwSize == 260) && (/*Error: Function owner not recognized*/GetLastError() == -1024))) {
				ModernizedCProgram._uprintf("PKI: Could not get module filename: %s", ModernizedCProgram.WinPKIErrorString());
				;
			} 
			mpath = ModernizedCProgram.wchar_to_utf8(szFileName);
		} else {
				szFileName = ModernizedCProgram.utf8_to_wchar(path);
		} 
		// Get message handle and store handle from the signed file.// Get message handle and store handle from the signed file.r = /*Error: Function owner not recognized*/CryptQueryObject(CERT_QUERY_OBJECT_FILE, szFileName, CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED, CERT_QUERY_FORMAT_FLAG_BINARY, 0, dwEncoding, dwContentType, dwFormatType, hStore, hMsg, ((Object)0));
		if (!r) {
			ModernizedCProgram._uprintf("PKI: Failed to get signature for '%s': %s", (path == ((Object)0)) ? mpath : path, ModernizedCProgram.WinPKIErrorString());
			;
		} 
		// Get signer information size.// Get signer information size.r = /*Error: Function owner not recognized*/CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, ((Object)0), dwSignerInfo);
		if (!r) {
			ModernizedCProgram._uprintf("PKI: Failed to get signer size: %s", ModernizedCProgram.WinPKIErrorString());
			;
		} 
		// Allocate memory for signer information.// Allocate memory for signer information.pSignerInfo = ()/*Error: Function owner not recognized*/calloc(dwSignerInfo, 1);
		if (!pSignerInfo) {
			ModernizedCProgram._uprintf("PKI: Could not allocate memory for signer information");
			;
		} 
		// Get Signer Information.// Get Signer Information.r = /*Error: Function owner not recognized*/CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, (PVOID)pSignerInfo, dwSignerInfo);
		if (!r) {
			ModernizedCProgram._uprintf("PKI: Failed to get signer information: %s", ModernizedCProgram.WinPKIErrorString());
			;
		} 
		// Get the RFC 3161 timestamp// Get the RFC 3161 timestamptimestamp = ModernizedCProgram.GetRFC3161TimeStamp(pSignerInfo);
		if (timestamp) {
			ModernizedCProgram._uprintf("Note: '%s' has timestamp %s", (path == ((Object)0)) ? mpath : path, ModernizedCProgram.TimestampToHumanReadable(timestamp));
		} 
		// This means that, if we don't also check the nested SHA-256 signature timestamp, an attacker// could alter the SHA-1 one (which is the one we use by default for chronology validation) and// trick us into using an invalid timestamp value. To prevent this, we validate that, if we have// both a regular and nested timestamp, they are within 60 seconds of each other.// This means that, if we don't also check the nested SHA-256 signature timestamp, an attacker// could alter the SHA-1 one (which is the one we use by default for chronology validation) and// trick us into using an invalid timestamp value. To prevent this, we validate that, if we have// both a regular and nested timestamp, they are within 60 seconds of each other.nested_timestamp = ModernizedCProgram.GetNestedRFC3161TimeStamp(pSignerInfo);
		if (nested_timestamp) {
			ModernizedCProgram._uprintf("Note: '%s' has nested timestamp %s", (path == ((Object)0)) ? mpath : path, ModernizedCProgram.TimestampToHumanReadable(nested_timestamp));
		} 
		if ((timestamp != -1024) && (nested_timestamp != -1024)) {
			if (/*Error: Function owner not recognized*/_abs64(nested_timestamp - timestamp) > 100) {
				ModernizedCProgram._uprintf("PKI: Signature timestamp and nested timestamp differ by more than a minute. This could indicate something very nasty...", timestamp, nested_timestamp);
				timestamp = -1024;
			} 
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)szFileName);
			szFileName = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)pSignerInfo);
			pSignerInfo = ((Object)0);
		} while (0);
		if (hStore != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CertCloseStore(hStore, 0);
		} 
		if (hMsg != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CryptMsgClose(hMsg);
		} 
		return timestamp;
	}
	// From https://msdn.microsoft.com/en-us/library/windows/desktop/aa382384.aspx
	public static Object ValidateSignature(Object hDlg, Object path) {
		LONG r = new LONG();
		 trust_data = new (0);
		 trust_file = new (0);
		// WINTRUST_ACTION_GENERIC_VERIFY_V2GUID guid_generic_verify = new GUID(-1024, -1024, -1024, new GUID(-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024));
		byte signature_name;
		size_t i = new size_t();
		uint64_t current_ts = new uint64_t();
		uint64_t update_ts = new uint64_t();
		// Check the signature name. Make it specific enough (i.e. don't simply check for "Akeo")
		// so that, besides hacking our server, it'll place an extra hurdle on any malicious entity// into also fooling a C.A. to issue a certificate that passes our test.// so that, besides hacking our server, it'll place an extra hurdle on any malicious entity// into also fooling a C.A. to issue a certificate that passes our test.signature_name = ModernizedCProgram.GetSignatureName(path, ModernizedCProgram.cert_country);
		if (signature_name == ((Object)0)) {
			ModernizedCProgram._uprintf("PKI: Could not get signature name");
			ModernizedCProgram.MessageBoxExU(hDlg, ModernizedCProgram.lmprintf(3284), ModernizedCProgram.lmprintf(3283), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
			return TRUST_E_NOSIGNATURE;
		} 
		for (i = 0; i < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); i++) {
			if (/*Error: Function owner not recognized*/strcmp(signature_name, ModernizedCProgram.cert_name[i]) == 0) {
				break;
			} 
		}
		if (i >= (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/)) {
			ModernizedCProgram._uprintf("PKI: Signature '%s' is unexpected...", signature_name);
			if (ModernizedCProgram.MessageBoxExU(hDlg, ModernizedCProgram.lmprintf(3285, signature_name), ModernizedCProgram.lmprintf(3283), 4 | -1024 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid) != 6) {
				return TRUST_E_EXPLICIT_DISTRUST;
			} 
		} 
		trust_file.setCbStruct(/*Error: sizeof expression not supported yet*/);
		trust_file.setPcwszFilePath(ModernizedCProgram.utf8_to_wchar(path));
		if (trust_file.getPcwszFilePath() == ((Object)0)) {
			ModernizedCProgram._uprintf("PKI: Unable to convert '%s' to UTF16", path);
			return -1024 | (FACILITY_CERT << 16) | -1024;
		} 
		trust_data.setCbStruct(/*Error: sizeof expression not supported yet*/)// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,// because it still prompts the user to run untrusted software, even after explicitly// notifying them that the signature invalid (and of course Microsoft had to make;// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,// because it still prompts the user to run untrusted software, even after explicitly// notifying them that the signature invalid (and of course Microsoft had to make
		// that UI prompt a bit too similar to the other benign prompt you get when running// trusted software, which, as per cert.org's assessment, may confuse non-security// conscious-users who decide to gloss over these kind of notifications).// that UI prompt a bit too similar to the other benign prompt you get when running// trusted software, which, as per cert.org's assessment, may confuse non-security// conscious-users who decide to gloss over these kind of notifications).trust_data.setDwUIChoice(WTD_UI_NONE)// We just downloaded from the Internet, so we should be able to check revocation;// We just downloaded from the Internet, so we should be able to check revocation
		trust_data.setFdwRevocationChecks(WTD_REVOKE_WHOLECHAIN)// 0x400 = WTD_MOTW  for Windows 8.1 or later;// 0x400 = WTD_MOTW  for Windows 8.1 or later
		trust_data.setDwProvFlags(WTD_REVOCATION_CHECK_CHAIN | -1024);
		trust_data.setDwUnionChoice(WTD_CHOICE_FILE);
		trust_data.setPFile(trust_file);
		r = /*Error: Function owner not recognized*/WinVerifyTrustEx((HANDLE)(true), guid_generic_verify, trust_data);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)trust_file.getPcwszFilePath());
			trust_file.setPcwszFilePath(((Object)0));
		} while (0);
		switch (r) {
		case -1024:
				current_ts = ModernizedCProgram.GetSignatureTimeStamp(((Object)0));
				if (current_ts == -1024) {
					ModernizedCProgram._uprintf("PKI: Cannot retrieve the current binary's timestamp - Aborting update");
					r = TRUST_E_TIME_STAMP;
				} else {
						update_ts = ModernizedCProgram.GetSignatureTimeStamp(path);
						if (update_ts < current_ts) {
							ModernizedCProgram._uprintf("PKI: Update timestamp (%I64i) is younger than ours (%I64i) - Aborting update", update_ts, current_ts);
							r = TRUST_E_TIME_STAMP;
						} 
				} 
				if ((r != -1024) && (ModernizedCProgram.force_update < 2)) {
					ModernizedCProgram.MessageBoxExU(hDlg, ModernizedCProgram.lmprintf(3300), ModernizedCProgram.lmprintf(3299), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
				} 
				break;
		case TRUST_E_NOSIGNATURE:
				ModernizedCProgram._uprintf("PKI: File does not appear to be signed: %s", ModernizedCProgram.WinPKIErrorString());
				ModernizedCProgram.MessageBoxExU(hDlg, ModernizedCProgram.lmprintf(3284), ModernizedCProgram.lmprintf(3283), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
				break;
		default:
				ModernizedCProgram._uprintf("PKI: Failed to validate signature: %s", ModernizedCProgram.WinPKIErrorString());
				ModernizedCProgram.MessageBoxExU(hDlg, ModernizedCProgram.lmprintf(3240), ModernizedCProgram.lmprintf(3283), 0 | 16 | (ModernizedCProgram.right_to_left_mode ? -1024 | -1024 : 0), ModernizedCProgram.selected_langid);
				break;
		}
		return r;
	}
	// Why-oh-why am I the only one on github doing this openssl vs MS signature validation?!?
	// For once, I'd like to find code samples from *OTHER PEOPLE* who went through this ordeal first...
	public static Object ValidateOpensslSignature(Object pbBuffer, Object dwBufferLen, Object[] pbSignature, Object dwSigLen) {
		HCRYPTPROV hProv = 0;
		HCRYPTHASH hHash = 0;
		HCRYPTKEY hPubKey = new HCRYPTKEY();
		// We could load and convert an openssl PEM, but since we know what we need...
		Object generatedModulus = pbMyPubKey.getModulus();
		RSA_2048_PUBKEY pbMyPubKey = new RSA_2048_PUBKEY(new RSA_2048_PUBKEY(6, 2, 0, (40960 | 1024 | 0)), new RSA_2048_PUBKEY(-1024, /*Error: sizeof expression not supported yet*/ * 8, -1024), new RSA_2048_PUBKEY(0));
		// $ openssl genrsa -aes256 -out private.pem 2048// Generating RSA private key, 2048 bit long modulus
		USHORT dwMyPubKeyLen = /*Error: sizeof expression not supported yet*/;
		BOOL r = new BOOL();
		BYTE t = new BYTE();
		int i;
		int j;
		// Get a handle to the default PROV_RSA_AES provider (AES so we get SHA-256 support).
		// 2 passes in case we need to create a new container.// 2 passes in case we need to create a new container.r = /*Error: Function owner not recognized*/CryptAcquireContextA(hProv, ((Object)0), ((Object)0), 24, -1024 | -1024);
		if (!r) {
			ModernizedCProgram._uprintf("PKI: Could not create the default key container: %s", ModernizedCProgram.WinPKIErrorString());
			;
		} 
		// Reverse the modulus bytes from openssl (and also remove the extra unwanted 0x00)// Reverse the modulus bytes from openssl (and also remove the extra unwanted 0x00)((/*Error: sizeof expression not supported yet*/ >= /*Error: sizeof expression not supported yet*/) ? (Object)0 : /*Error: Function owner not recognized*/_assert("sizeof(rsa_pubkey_modulus) >= sizeof(pbMyPubKey.Modulus)", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Rufus\\src\\pki.c", 685));
		for (i = 0; i < /*Error: sizeof expression not supported yet*/; i++) {
			generatedModulus[i] = ModernizedCProgram.rsa_pubkey_modulus[/*Error: sizeof expression not supported yet*/ - 1 - i];
		}
		Object generatedBlobHeader = pbMyPubKey.getBlobHeader();
		// Import our RSA public key so that the MS API can use it// Import our RSA public key so that the MS API can use itr = /*Error: Function owner not recognized*/CryptImportKey(hProv, (BYTE)generatedBlobHeader, dwMyPubKeyLen, 0, 0, hPubKey);
		if (!r) {
			ModernizedCProgram._uprintf("PKI: Could not import public key: %s", ModernizedCProgram.WinPKIErrorString());
			;
		} 
		// Create the hash object.// Create the hash object.r = /*Error: Function owner not recognized*/CryptCreateHash(hProv, CALG_SHA_256, 0, 0, hHash);
		if (!r) {
			ModernizedCProgram._uprintf("PKI: Could not create empty hash: %s", ModernizedCProgram.WinPKIErrorString());
			;
		} 
		// Compute the cryptographic hash of the buffer.// Compute the cryptographic hash of the buffer.r = /*Error: Function owner not recognized*/CryptHashData(hHash, pbBuffer, dwBufferLen, 0);
		if (!r) {
			ModernizedCProgram._uprintf("PKI: Could not hash data: %s", ModernizedCProgram.WinPKIErrorString());
			;
		} 
		// Reverse the signature bytesfor (; i < j; ) {
			t = pbSignature[i];
			pbSignature[i] = pbSignature[j];
			pbSignature[j] = t;
		}
		// Now that we have all of the public key, hash and signature data in a// format that Microsoft can handle, we can call CryptVerifySignature().// Now that we have all of the public key, hash and signature data in a// format that Microsoft can handle, we can call CryptVerifySignature().r = /*Error: Function owner not recognized*/CryptVerifySignatureA(hHash, pbSignature, dwSigLen, hPubKey, ((Object)0), 0);
		if (!r) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(pbBuffer, 0, dwBufferLen);
			ModernizedCProgram._uprintf("Signature validation failed: %s", ModernizedCProgram.WinPKIErrorString());
		} 
		// If the signature is invalid, clear the buffer so that
		if (hProv) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CryptReleaseContext(hProv, 0);
		} 
		return r;
	}
	/*
	 * Given a bad blocks bitmap, update the bad blocks inode to reflect
	 * the map.
	 */
	public static Object ext2fs_update_bb_inode(Object fs, Object bb_list) {
		 retval = new ();
		set_badblock_record rec = new set_badblock_record();
		ext2_inode inode = new ext2_inode();
		if (!(fs) || (fs).getMagic() != (EXT2_ET_MAGIC_EXT2FS_FILSYS)) {
			return (EXT2_ET_MAGIC_EXT2FS_FILSYS);
		} 
		if (!fs.getBlock_map()) {
			return EXT2_ET_NO_BLOCK_BITMAP;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(rec, 0, /*Error: sizeof expression not supported yet*/);
		rec.setMax_ind_blocks(10);
		int generatedMax_ind_blocks = rec.getMax_ind_blocks();
		Object[] generatedInd_blocks = rec.getInd_blocks();
		retval = ModernizedCProgram.ext2fs_get_array(generatedMax_ind_blocks, /*Error: Unsupported expression*/, generatedInd_blocks);
		if (retval) {
			return retval;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedInd_blocks, 0, generatedMax_ind_blocks * /*Error: Unsupported expression*/);
		Byte generatedBlock_buf = rec.getBlock_buf();
		retval = ModernizedCProgram.ext2fs_get_mem(fs.getBlocksize(), generatedBlock_buf);
		if (retval) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedBlock_buf, 0, fs.getBlocksize());
		rec.setErr(0/*
			 * First clear the old bad blocks (while saving the indirect blocks)
			 */);
		retval = ModernizedCProgram.ext2fs_block_iterate2(fs, 1, 2, 0, ModernizedCProgram.clear_bad_block_proc, rec);
		if (retval) {
			;
		} 
		Object generatedErr = rec.getErr();
		if (generatedErr) {
			retval = generatedErr;
			;
		} 
		Object generatedBb_iter = rec.getBb_iter();
		if (bb_list) {
			retval = /*Error: Function owner not recognized*/ext2fs_badblocks_list_iterate_begin(bb_list, generatedBb_iter);
			if (retval) {
				;
			} 
			retval = ModernizedCProgram.ext2fs_block_iterate2(fs, 1, 1, 0, ModernizedCProgram.set_bad_block_proc, rec);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ext2fs_badblocks_list_iterate_end(generatedBb_iter);
			if (retval) {
				;
			} 
			if (generatedErr) {
				retval = generatedErr;
				;
			} 
		} 
		retval = /*
			 * Update the bad block inode's mod time and block count
			 * field.
			 */inode.ext2fs_read_inode(fs, 1);
		if (retval) {
			;
		} 
		inode.setI_atime(inode.setI_mtime(fs.getNow() ? fs.getNow() : /*Error: Function owner not recognized*/time(0)));
		Object generatedI_ctime = inode.getI_ctime();
		if (!generatedI_ctime) {
			inode.setI_ctime(fs.getNow() ? fs.getNow() : /*Error: Function owner not recognized*/time(0));
		} 
		int generatedBad_block_count = rec.getBad_block_count();
		inode.ext2fs_iblk_set(fs, generatedBad_block_count);
		retval = inode.ext2fs_inode_size_set(fs, generatedBad_block_count * fs.getBlocksize());
		if (retval) {
			;
		} 
		retval = inode.ext2fs_write_inode(fs, 1);
		if (retval) {
			;
		} 
		ModernizedCProgram.ext2fs_free_mem(generatedBlock_buf);
		return retval/*
		 * Helper function for update_bb_inode()
		 *
		 * Clear the bad blocks in the bad block inode, while saving the
		 * indirect blocks.
		 */;
	}
	public static int clear_bad_block_proc(Object fs, Object block_nr, Object blockcnt, Object ref_block, int ref_offset, Object priv_data) {
		set_badblock_record rec = (set_badblock_record)priv_data;
		 retval = new ();
		long old_size;
		if (!block_nr) {
			return 0/*
				 * If the block number is outrageous, clear it and ignore it.
				 */;
		} 
		if (block_nr >= fs.getSuper().ext2fs_blocks_count() || block_nr < fs.getSuper().getS_first_data_block()) {
			block_nr = 0;
			return 1;
		} 
		int generatedInd_blocks_size = rec.getInd_blocks_size();
		int generatedMax_ind_blocks = rec.getMax_ind_blocks();
		Object[] generatedInd_blocks = rec.getInd_blocks();
		if (blockcnt < 0) {
			if (generatedInd_blocks_size >= generatedMax_ind_blocks) {
				old_size = generatedMax_ind_blocks * /*Error: Unsupported expression*/;
				generatedMax_ind_blocks += 10;
				retval = ModernizedCProgram.ext2fs_resize_mem(old_size, generatedMax_ind_blocks * /*Error: Unsupported expression*/, generatedInd_blocks);
				if (retval) {
					generatedMax_ind_blocks -= 10;
					rec.setErr(retval);
					return 2;
				} 
			} 
			generatedInd_blocks[generatedInd_blocks_size++] = block_nr;
		} 
		ModernizedCProgram.ext2fs_block_alloc_stats2(fs, block_nr, -/*
			 * Mark the block as unused, and update accounting information
			 */1);
		block_nr = 0;
		return 1/*
		 * Helper function for update_bb_inode()
		 *
		 * Set the block list in the bad block inode, using the supplied bitmap.
		 */;
	}
	public static int set_bad_block_proc(Object fs, Object block_nr, Object blockcnt, Object ref_block, int ref_offset, Object priv_data) {
		set_badblock_record rec = (set_badblock_record)priv_data;
		 retval = new ();
		 blk = new ();
		Object generatedBb_iter = rec.getBb_iter();
		int generatedBad_block_count = rec.getBad_block_count();
		ModernizedCProgram.ext2fs_block_alloc_stats2(fs, blk, +/*
			 * Update block counts
			 */1);
		block_nr = blk;
		return 1;
	}
	public static void get_loc_data_line(byte[] line) {
		size_t i = new size_t();
		loc_cmd lcmd = ((Object)0);
		byte t;
		if ((line == ((Object)0)) || (line[0] == 0)) {
			return /*Error: Unsupported expression*/;
		} 
		// Skip leading spaces// Skip leading spacesi = /*Error: Function owner not recognized*/strspn(line, ModernizedCProgram.space);
		// Read token (NUL character will be read if EOL)// Read token (NUL character will be read if EOL)t = line[i++];
		// Commentif (t == (byte)'#') {
			return /*Error: Unsupported expression*/;
		} 
		if ((t == 0) || ((line[i] != ModernizedCProgram.space[0]) && (line[i] != ModernizedCProgram.space[1]))) {
			ModernizedCProgram._uprintf("%s(%d): syntax error: '%s'\n", ModernizedCProgram.loc_filename, ModernizedCProgram.loc_line_nr, line);
			return /*Error: Unsupported expression*/;
		} 
		loc_cmd_struct loc_cmd_struct = new loc_cmd_struct();
		lcmd = loc_cmd_struct.get_loc_cmd(t, line[i]);
		Object generatedCommand = lcmd.getCommand();
		if ((lcmd != ((Object)0)) && (generatedCommand != loc_command_type.LC_LOCALE)) {
			lcmd.dispatch_loc_cmd();
		} else {
				lcmd/*
				 * Open a localization file and store its file name, with special case
				 * when dealing with the embedded loc file.
				 */.free_loc_cmd();
		} 
		// TODO: check return value?
	}
	public static _iobuf open_loc_file(Object[] filename) {
		FILE fd = ((Object)0);
		wchar_t wfilename = ((Object)0);
		byte tmp_ext = ".tmp";
		if (filename == ((Object)0)) {
			return ((Object)0);
		} 
		if (ModernizedCProgram.loc_filename != ModernizedCProgram.embedded_loc_filename) {
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.loc_filename);
				ModernizedCProgram.loc_filename = ((Object)0);
			} while (0);
		} 
		if (/*Error: Function owner not recognized*/strcmp(((tmp_ext == ((Object)0)) ? "<NULL>" : tmp_ext), ((filename[((((byte)filename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(filename)) - 4] == ((Object)0)) ? "<NULL>" : filename[((((byte)filename) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(filename)) - 4])) == 0) {
			ModernizedCProgram.loc_filename = ModernizedCProgram.embedded_loc_filename;
		} else {
				ModernizedCProgram.loc_filename = /*Error: Function owner not recognized*/_strdup(filename);
		} 
		wfilename = ModernizedCProgram.utf8_to_wchar(filename);
		if (wfilename == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, filename);
			;
		} 
		fd = /*Error: Function owner not recognized*/_wfopen(wfilename, L"rb");
		if (fd == ((Object)0)) {
			ModernizedCProgram._uprintf("localization: could not open '%s'\n", filename);
		} 
		return fd/*
		 * Parse a localization file, to construct the list of available locales.
		 * The locale file must be UTF-8 with NO BOM.
		 */;
	}
	public static Object get_supported_locales(Object filename) {
		FILE fd = ((Object)0);
		BOOL r = 0;
		byte[] line = new byte[1024];
		size_t i = new size_t();
		size_t j = new size_t();
		size_t k = new size_t();
		loc_cmd lcmd = ((Object)0);
		loc_cmd last_lcmd = ((Object)0);
		long end_of_block;
		int version_line_nr = 0;
		uint32_t loc_base_major = -1;
		uint32_t loc_base_minor = -1;
		fd = ModernizedCProgram.open_loc_file(filename);
		if (fd == ((Object)0)) {
			;
		} 
		// Check that the file doesn't contain a BOM and was saved in DOS mode// Check that the file doesn't contain a BOM and was saved in DOS modei = /*Error: Function owner not recognized*/fread(line, 1, /*Error: sizeof expression not supported yet*/, fd);
		if (i < /*Error: sizeof expression not supported yet*/) {
			ModernizedCProgram._uprintf("Invalid loc file: the file is too small!");
			;
		} 
		if (((uint8_t)line[0]) > -1024) {
			ModernizedCProgram._uprintf("Invalid loc file: the file should not have a BOM (Byte Order Mark)");
			;
		} 
		for (i = 0; i < /*Error: sizeof expression not supported yet*/ - 1; i++) {
			if ((((uint8_t)line[i]) == -1024) && (((uint8_t)line[i + 1]) == -1024)) {
				break;
			} 
		}
		if (i >= /*Error: sizeof expression not supported yet*/ - 1) {
			ModernizedCProgram._uprintf("Invalid loc file: the file MUST be saved in DOS mode (CR/LF)");
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fseek(fd, 0, 0);
		ModernizedCProgram.loc_line_nr = 0;
		line[0] = 0;
		ModernizedCProgram.free_locale_list();
		loc_cmd_struct loc_cmd_struct = new loc_cmd_struct();
		Object generatedCommand = lcmd.getCommand();
		list_head generatedList = last_lcmd.getList();
		Object generatedNum = last_lcmd.getNum();
		Object generatedTxt = lcmd.getTxt();
		int generatedCtrl_id = last_lcmd.getCtrl_id();
		Object generatedUnum_size = lcmd.getUnum_size();
		Object[] generatedUnum = lcmd.getUnum();
		do {
			end_of_block = /*Error: Function owner not recognized*/ftell(fd);
			if (/*Error: Function owner not recognized*/fgets(line, /*Error: sizeof expression not supported yet*/, fd) == ((Object)0)) {
				break;
			} 
			ModernizedCProgram.loc_line_nr++;
			i = /*Error: Function owner not recognized*/strspn(line, ModernizedCProgram.space);
			if ((line[i] != (byte)'l') && (line[i] != (byte)'v') && (line[i] != (byte)'a')) {
				continue;
			} 
			lcmd = loc_cmd_struct.get_loc_cmd(line[i], line[i + 1]);
			if ((lcmd == ((Object)0)) || ((generatedCommand != loc_command_type.LC_LOCALE) && (generatedCommand != loc_command_type.LC_VERSION) && (generatedCommand != loc_command_type.LC_ATTRIBUTES))) {
				lcmd.free_loc_cmd();
				continue;
			} 
			switch (generatedCommand) {
			case loc_command_type.LC_LOCALE:
					if (last_lcmd != ((Object)0)) {
						if (version_line_nr == 0) {
							ModernizedCProgram._uprintf("localization: no compatible version was found - this locale will be ignored\n");
							generatedList.list_del();
							last_lcmd.free_loc_cmd();
						} else {
								generatedNum[1] = (int32_t)end_of_block;
						} 
					} 
					generatedNum[0] = (int32_t)/*Error: Function owner not recognized*/ftell(fd);
					generatedList.list_add_tail(ModernizedCProgram.locale_list);
					ModernizedCProgram._uprintf("localization: found locale '%s'\n", generatedTxt[0]);
					last_lcmd = lcmd;
					version_line_nr = 0;
					break;
			case loc_command_type.LC_ATTRIBUTES:
					if (last_lcmd == ((Object)0)) {
						ModernizedCProgram._uprintf("%s(%d): [a]ttributes cannot precede [l]ocale\n", ModernizedCProgram.loc_filename, ModernizedCProgram.loc_line_nr);
					} else {
							for (j = 0; generatedTxt[0][j] != 0; j++) {
								for (k = 0; k < (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/); k++) {
									if (attr_parse[k].getC() == generatedTxt[0][j]) {
										generatedCtrl_id |=  attr_parse[k].getFlag();
										break;
									} 
								}
								if (k >= (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/)) {
									ModernizedCProgram._uprintf("%s(%d): unknown attribute '%c' - ignored\n", ModernizedCProgram.loc_filename, ModernizedCProgram.loc_line_nr, generatedTxt[0][j]);
								} 
							}
					} 
					lcmd.free_loc_cmd();
					break;
			case loc_command_type.LC_VERSION:
					if (version_line_nr != 0) {
						ModernizedCProgram._uprintf("%s(%d): [v]ersion was already provided at line %d\n", ModernizedCProgram.loc_filename, ModernizedCProgram.loc_line_nr, version_line_nr);
					}  else if (generatedUnum_size != 2) {
						ModernizedCProgram._uprintf("%s(%d): [v]ersion format is invalid\n", ModernizedCProgram.loc_filename, ModernizedCProgram.loc_line_nr);
					}  else if (last_lcmd == ((Object)0)) {
						ModernizedCProgram._uprintf("%s(%d): [v]ersion cannot precede [l]ocale\n", ModernizedCProgram.loc_filename, ModernizedCProgram.loc_line_nr);
					}  else if (loc_base_major == -1) {
						loc_base_major = generatedUnum[0];
						loc_base_minor = generatedUnum[1];
						version_line_nr = ModernizedCProgram.loc_line_nr;
					} else {
							if ((generatedUnum[0] < loc_base_major) || ((generatedUnum[0] == loc_base_major) && (generatedUnum[1] < loc_base_minor))) {
								generatedCtrl_id |=  -1024;
								ModernizedCProgram._uprintf("%s(%d): the version of this translation is older than the base one and may result in some messages not being properly translated.\nIf you are the translator, please update your translation with the changes that intervened between v%d.%d and v%d.%d.\nSee https://github.com/pbatard/rufus/blob/master/res/loc/ChangeLog.txt\n", ModernizedCProgram.loc_filename, ModernizedCProgram.loc_line_nr, generatedUnum[0], generatedUnum[1], loc_base_major, loc_base_minor);
							} 
							version_line_nr = ModernizedCProgram.loc_line_nr;
					} 
					lcmd.free_loc_cmd();
					break;
			}
		} while (1);// adjust the last block
		if (last_lcmd != ((Object)0)) {
			if (version_line_nr == 0) {
				ModernizedCProgram._uprintf("localization: no compatible version was found - this locale will be ignored\n");
				generatedList.list_del();
				last_lcmd.free_loc_cmd();
			} else {
					generatedNum[1] = (int32_t)/*Error: Function owner not recognized*/ftell(fd);
			} 
		} 
		r = !((ModernizedCProgram.locale_list).getNext() == (ModernizedCProgram.locale_list));
		if (r == 0) {
			ModernizedCProgram._uprintf("localization: '%s' contains no valid locale sections\n", filename);
		} 
		return r/*
		 * Parse a locale section in a localization file (UTF-8, no BOM)
		 * NB: this call is reentrant for the "base" command support
		 */;
	}
	public static Object get_token_data_line(Object wtoken, Object[] wline) {
		size_t i = new size_t();
		size_t r = new size_t();
		BOOLEAN quoteth = 0;
		BOOLEAN xml = 0;
		if ((wtoken == ((Object)0)) || (wline == ((Object)0)) || (wline[0] == 0)) {
			return ((Object)0);
		} 
		i = 0;
		// Skip leading spaces and opening '<'// Skip leading spaces and opening '<'i += /*Error: Function owner not recognized*/wcsspn(wline[i], ModernizedCProgram.wspace);
		if (wline[i] == (byte)L'<') {
			i++;
		} 
		i += /*Error: Function owner not recognized*/wcsspn(wline[i], ModernizedCProgram.wspace);
		// Our token should begin a lineif (/*Error: Function owner not recognized*/_wcsnicmp(wline[i], wtoken, /*Error: Function owner not recognized*/wcslen(wtoken)) != 0) {
			return ((Object)0);
		} 
		// Token was found, move past token// Token was found, move past tokeni += /*Error: Function owner not recognized*/wcslen(wtoken);
		// Skip spaces// Skip spacesi += /*Error: Function owner not recognized*/wcsspn(wline[i], ModernizedCProgram.wspace);
		// Check for '=' or '>' signif (wline[i] == (byte)L'>') {
			xml = 1;
		}  else if (wline[i] != (byte)L'=') {
			return ((Object)0);
		} 
		i++;
		// Skip spaces// Skip spacesi += /*Error: Function owner not recognized*/wcsspn(wline[i], ModernizedCProgram.wspace);
		// eliminate leading quote, if it existsif (wline[i] == (byte)L'"') {
			quoteth = 1;
			i++;
		} 
		// Keep the starting pos of our data// Keep the starting pos of our datar = i;
		// locate end of string or quotewhile ((wline[i] != 0) && (((wline[i] != (byte)L'"') && (wline[i] != (byte)L'<')) || ((wline[i] == (byte)L'"') && (!quoteth)) || ((wline[i] == (byte)L'<') && (!xml)))) {
			i++;
		}
		wline[i--] = 0;
		// Eliminate trailing EOL characterswhile ((i >= r) && ((wline[i] == (byte)L'\r') || (wline[i] == (byte)L'\n'))) {
			wline[i--] = 0;
		}
		return (wline[r] == 0) ? ((Object)0) : wline[r/*
		 * Parse a file (ANSI or UTF-8 or UTF-16) and return the data for the 'index'th occurrence of 'token'
		 * The returned string is UTF-8 and MUST be freed by the caller
		 */];
	}
	public static Byte get_token_data_file_indexed(Object[] token, Object[] filename, int index) {
		int i = 0;
		wchar_t wtoken = ((Object)0);
		wchar_t wdata = ((Object)0);
		wchar_t wfilename = ((Object)0);
		wchar_t[] buf = new wchar_t();
		FILE fd = ((Object)0);
		byte ret = ((Object)0);
		if ((filename == ((Object)0)) || (token == ((Object)0))) {
			return ((Object)0);
		} 
		if ((filename[0] == 0) || (token[0] == 0)) {
			return ((Object)0);
		} 
		wfilename = ModernizedCProgram.utf8_to_wchar(filename);
		if (wfilename == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, filename);
			;
		} 
		wtoken = ModernizedCProgram.utf8_to_wchar(token);
		if (wfilename == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, token);
			;
		} 
		fd = /*Error: Function owner not recognized*/_wfopen(wfilename, L"r, ccs=UNICODE");
		if (fd == ((Object)0)) {
			;
		} 
		// Process individual lines. NUL is always appended.
		// Ideally, we'd check that our buffer fits the linewhile (/*Error: Function owner not recognized*/fgetws(buf, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), fd) != ((Object)0)) {
			wdata = ModernizedCProgram.get_token_data_line(wtoken, buf);
			if ((wdata != ((Object)0)) && (++i == index)) {
				ret = ModernizedCProgram.wchar_to_utf8(wdata);
				break;
			} 
		}
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wfilename);
			wfilename = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wtoken);
			wtoken = ((Object)0);
		} while (0);
		return ret/*
		 * replace or add 'data' for token 'token' in config file 'filename'
		 */;
	}
	public static Byte set_token_data_file(Object[] token, Object[] data, Object[] filename) {
		wchar_t[] outmode = new wchar_t[]{L"w", L"w, ccs=UTF-8", L"w, ccs=UTF-16LE"};
		wchar_t wtoken = ((Object)0);
		wchar_t wfilename = ((Object)0);
		wchar_t wtmpname = ((Object)0);
		wchar_t wdata = ((Object)0);
		wchar_t bom = 0;
		wchar_t[] buf = new wchar_t();
		FILE fd_in = ((Object)0);
		FILE fd_out = ((Object)0);
		size_t i = new size_t();
		size_t size = new size_t();
		int mode = 0;
		byte ret = ((Object)0);
		byte[] tmp = new byte[2];
		if ((filename == ((Object)0)) || (token == ((Object)0)) || (data == ((Object)0))) {
			return ((Object)0);
		} 
		if ((filename[0] == 0) || (token[0] == 0) || (data[0] == 0)) {
			return ((Object)0);
		} 
		wfilename = ModernizedCProgram.utf8_to_wchar(filename);
		if (wfilename == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, filename);
			;
		} 
		wtoken = ModernizedCProgram.utf8_to_wchar(token);
		if (wfilename == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, token);
			;
		} 
		wdata = ModernizedCProgram.utf8_to_wchar(data);
		if (wdata == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, data);
			;
		} 
		fd_in = /*Error: Function owner not recognized*/_wfopen(wfilename, L"r, ccs=UNICODE");
		if (fd_in == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not open file '%s'\n", filename);
			;
		} 
		// Check the input file's BOM and create an output file with the sameif (/*Error: Function owner not recognized*/fread(bom, /*Error: sizeof expression not supported yet*/, 1, fd_in) == 1) {
			switch (bom) {
			case -1024:
					mode = 1;
					break;
			case -1024:
					mode = 2;
					break;
			default:
					mode = 0;
					break;
			}
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fseek(fd_in, 0, 0);
		} 
		wtmpname = (wchar_t)/*Error: Function owner not recognized*/calloc(/*Error: Function owner not recognized*/wcslen(wfilename) + 2, /*Error: Unsupported expression*/);
		if (wtmpname == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not allocate space for temporary output name\n");
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/wcscpy(wtmpname, wfilename);
		wtmpname[/*Error: Function owner not recognized*/wcslen(wtmpname)] = (byte)'~';
		fd_out = /*Error: Function owner not recognized*/_wfopen(wtmpname, outmode[mode]);
		if (fd_out == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not open temporary output file '%s~'\n", filename);
			;
		} 
		// Process individual lines. NUL is always appended.while (/*Error: Function owner not recognized*/fgetws(buf, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), fd_in) != ((Object)0)) {
			i = 0;
			i += /*Error: Function owner not recognized*/wcsspn(buf[i], ModernizedCProgram.wspace);
			if ((buf[i] == (byte)';') || (buf[i] == (byte)'[')) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fputws(buf, fd_out);
				continue;
			} 
			if (/*Error: Function owner not recognized*/_wcsnicmp(buf[i], wtoken, /*Error: Function owner not recognized*/wcslen(wtoken)) != 0) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fputws(buf, fd_out);
				continue;
			} 
			i += /*Error: Function owner not recognized*/wcslen(wtoken);
			i += /*Error: Function owner not recognized*/wcsspn(buf[i], ModernizedCProgram.wspace);
			if (buf[i] != (byte)L'=') {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fputws(buf, fd_out);
				continue;
			} 
			i++;
			i += /*Error: Function owner not recognized*/wcsspn(buf[i], ModernizedCProgram.wspace);
			buf[i] = 0;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fputws(buf, fd_out);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwprintf_s(fd_out, L"%s\n", wdata);
			ret = (byte)data;
		}
		if (ret == ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwprintf_s(fd_out, L"%s = %s\n", wtoken, wdata);
			ret = (byte)data;
		} 
		// Didn't find an existing token => append it
		if (fd_out != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_out);
		} 
		// If an insertion occurred, delete existing file and use the new oneif (ret != ((Object)0)) {
			fd_in = /*Error: Function owner not recognized*/_wfopen(wtmpname, L"rb");
			fd_out = /*Error: Function owner not recognized*/_wfopen(wfilename, L"wb");
			if ((fd_in != ((Object)0)) && (fd_out != ((Object)0))) {
				size = (mode == 2) ? 2 : 1;
				while (/*Error: Function owner not recognized*/fread(tmp, size, 1, fd_in) == 1) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite(tmp, size, 1, fd_out);
				}
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_in);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_out);
			} else {
					ModernizedCProgram._uprintf("Could not write '%s' - original file has been left unmodified\n", filename);
					ret = ((Object)0);
					if (fd_in != ((Object)0)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_in);
					} 
					if (fd_out != ((Object)0)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_out);
					} 
			} 
		} 
		// We're in Windows text mode => Remove CRs if requested
		if (wtmpname != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_wunlink(wtmpname);
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wfilename);
			wfilename = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wtmpname);
			wtmpname = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wtoken);
			wtoken = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wdata);
			wdata = ((Object)0);
		} while (0);
		return ret/*
		 * Parse a buffer (ANSI or UTF-8) and return the data for the 'n'th occurrence of 'token'
		 * The returned string is UTF-8 and MUST be freed by the caller
		 */;
	}
	public static Byte get_token_data_buffer(Object token, int n, Object[] buffer, Object buffer_size) {
		int j;
		int curly_count;
		wchar_t wtoken = ((Object)0);
		wchar_t wdata = ((Object)0);
		wchar_t wbuffer = ((Object)0);
		wchar_t wline = ((Object)0);
		size_t i = new size_t();
		BOOL done = 0;
		byte ret = ((Object)0);
		// We're handling remote data => better safe than sorryif ((token == ((Object)0)) || (buffer == ((Object)0)) || (buffer_size <= 4) || (buffer_size > 65536)) {
			;
		} 
		// Ensure that our buffer is NUL terminatedif (buffer[buffer_size - 1] != 0) {
			;
		} 
		wbuffer = ModernizedCProgram.utf8_to_wchar(buffer);
		wtoken = ModernizedCProgram.utf8_to_wchar(token);
		if ((wbuffer == ((Object)0)) || (wtoken == ((Object)0))) {
			;
		} 
		// Process individual lines (or multiple lines when between {}, for RTF)for (; (j != n) && (!done); /*Error: Unsupported expression*/) {
			wline = wbuffer[i];
			for (curly_count = 0; ((curly_count > 0) || ((wbuffer[i] != (byte)L'\n') && (wbuffer[i] != (byte)L'\r'))) && (wbuffer[i] != 0); i++) {
				if (wbuffer[i] == (byte)L'{') {
					curly_count++;
				} 
				if (wbuffer[i] == (byte)L'}') {
					curly_count--;
				} 
			}
			if (wbuffer[i] == 0) {
				done = 1;
			} else {
					wbuffer[i++] = 0;
			} 
			wdata = ModernizedCProgram.get_token_data_line(wtoken, wline);
			if (wdata != ((Object)0)) {
				j++;
			} 
		}
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wbuffer);
			wbuffer = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wtoken);
			wtoken = ((Object)0);
		} while (0);
		return ret;
	}
	public static Byte get_sanitized_token_data_buffer(Object token, int n, Object buffer, Object buffer_size) {
		size_t i = new size_t();
		byte data = ModernizedCProgram.get_token_data_buffer(token, n, buffer, buffer_size);
		if (data != ((Object)0)) {
			for (i = 0; i < /*Error: Function owner not recognized*/strlen(data); i++) {
				if ((data[i] == (byte)'\\') && (data[i + 1] == (byte)'n')) {
					data[i] = (byte)'\r';
					data[i + 1] = (byte)'\n';
				} 
			}
		} 
		return data/*
		 * Parse an update data file and populates a rufus_update structure.
		 * NB: since this is remote data, and we're running elevated, it *IS* considered
		 * potentially malicious, even if it comes from a supposedly trusted server.
		 * len should be the size of the buffer, including the zero terminator
		 */;
	}
	public static void parse_update(byte[] buf, Object len) {
		size_t i = new size_t();
		byte data = ((Object)0);
		byte token;
		byte[] allowed_rtf_chars = "abcdefghijklmnopqrstuvwxyz|~-_:*'";
		byte[] allowed_std_chars = "\r\n ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"$%^&+=<>(){}[].,;#@/?";
		byte[] download_url_name = new byte[24];
		byte[] arch_names = new byte[]{"x86", "x64", "arm", "arm64", "none"};
		// strchr includes the NUL terminator in the search, so take care of backslash before NULif ((buf == ((Object)0)) || (len < 2) || (len > 64 * -1024) || (buf[len - 1] != 0) || (buf[len - 2] == (byte)'\\')) {
			return /*Error: Unsupported expression*/;
		} 
		// Someone may be inserting NULs// Someone may be inserting NULslen = ((((byte)buf) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(buf)) + 1;
		for (i = 0; i < len - 1; i++) {
			if (buf[i] == (byte)'\\') {
				if (/*Error: Function owner not recognized*/strchr(allowed_rtf_chars, buf[i + 1]) == ((Object)0)) {
					buf[i] = (byte)' ';
				} 
			}  else if ((/*Error: Function owner not recognized*/strchr(allowed_rtf_chars, buf[i]) == ((Object)0)) && (/*Error: Function owner not recognized*/strchr(allowed_std_chars, buf[i]) == ((Object)0))) {
				buf[i] = (byte)' ';
			} 
		}// Check for valid RTF sequences as well as allowed chars if not RTF
		for (i = 0; i < 3; i++) {
			ModernizedCProgram.update.getVersion()[i] = 0;
		}
		ModernizedCProgram.update.getPlatform_min()[0] = 5;
		// XP or later// XP or laterModernizedCProgram.update.getPlatform_min()[1] = 2;
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.update.getDownload_url());
			ModernizedCProgram.update.setDownload_url(((Object)0));
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)ModernizedCProgram.update.getRelease_notes());
			ModernizedCProgram.update.setRelease_notes(((Object)0));
		} while (0);
		if ((data = ModernizedCProgram.get_sanitized_token_data_buffer("version", 1, buf, len)) != ((Object)0)) {
			for (i = 0; (i < 3) && ((token = /*Error: Function owner not recognized*/strtok((i == 0) ? data : ((Object)0), ".")) != ((Object)0)); i++) {
				ModernizedCProgram.update.getVersion()[i] = (uint16_t)/*Error: Function owner not recognized*/atoi(token);
			}
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)data);
				data = ((Object)0);
			} while (0);
		} 
		if ((data = ModernizedCProgram.get_sanitized_token_data_buffer("platform_min", 1, buf, len)) != ((Object)0)) {
			for (i = 0; (i < 2) && ((token = /*Error: Function owner not recognized*/strtok((i == 0) ? data : ((Object)0), ".")) != ((Object)0)); i++) {
				ModernizedCProgram.update.getPlatform_min()[i] = (uint32_t)/*Error: Function owner not recognized*/atoi(token);
			}
			do {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)data);
				data = ((Object)0);
			} while (0);
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_snprintf(download_url_name, /*Error: sizeof expression not supported yet*/, "download_url_%s", arch_names[ModernizedCProgram.GetCpuArch()]);
			(download_url_name)[(/*Error: sizeof expression not supported yet*/) - 1] = 0;
		} while (0);
		ModernizedCProgram.update.setDownload_url(ModernizedCProgram.get_sanitized_token_data_buffer(download_url_name, 1, buf, len));
		if (ModernizedCProgram.update.getDownload_url() == ((Object)0)) {
			ModernizedCProgram.update.setDownload_url(ModernizedCProgram.get_sanitized_token_data_buffer("download_url", 1, buf, len));
		} 
		ModernizedCProgram.update.setRelease_notes(ModernizedCProgram.get_sanitized_token_data_buffer("release_notes", 1, buf, len/*
		 * Insert entry 'data' under section 'section' of a config file
		 * Section must include the relevant delimiters (eg '[', ']') if needed
		 */));
	}
	public static Byte insert_section_data(Object[] filename, Object[] section, Object[] data, Object dos2unix) {
		wchar_t[] outmode = new wchar_t[]{L"w", L"w, ccs=UTF-8", L"w, ccs=UTF-16LE"};
		wchar_t wsection = ((Object)0);
		wchar_t wfilename = ((Object)0);
		wchar_t wtmpname = ((Object)0);
		wchar_t wdata = ((Object)0);
		wchar_t bom = 0;
		wchar_t[] buf = new wchar_t();
		FILE fd_in = ((Object)0);
		FILE fd_out = ((Object)0);
		size_t i = new size_t();
		size_t size = new size_t();
		int mode = 0;
		byte ret = ((Object)0);
		byte[] tmp = new byte[2];
		if ((filename == ((Object)0)) || (section == ((Object)0)) || (data == ((Object)0))) {
			return ((Object)0);
		} 
		if ((filename[0] == 0) || (section[0] == 0) || (data[0] == 0)) {
			return ((Object)0);
		} 
		wfilename = ModernizedCProgram.utf8_to_wchar(filename);
		if (wfilename == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, filename);
			;
		} 
		wsection = ModernizedCProgram.utf8_to_wchar(section);
		if (wfilename == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, section);
			;
		} 
		wdata = ModernizedCProgram.utf8_to_wchar(data);
		if (wdata == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, data);
			;
		} 
		fd_in = /*Error: Function owner not recognized*/_wfopen(wfilename, L"r, ccs=UNICODE");
		if (fd_in == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not open file '%s'\n", filename);
			;
		} 
		// Check the input file's BOM and create an output file with the sameif (/*Error: Function owner not recognized*/fread(bom, /*Error: sizeof expression not supported yet*/, 1, fd_in) != 1) {
			ModernizedCProgram._uprintf("Could not read file '%s'\n", filename);
			;
		} 
		switch (bom) {
		case -1024:
				mode = 1;
				break;
		case -1024:
				mode = 2;
				break;
		default:
				mode = 0;
				break;
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fseek(fd_in, 0, 0)//	duprintf("'%s' was detected as %s\n", filename,//		(mode==0)?"ANSI/UTF8 (no BOM)":((mode==1)?"UTF8 (with BOM)":"UTF16 (with BOM"));;//	duprintf("'%s' was detected as %s\n", filename,//		(mode==0)?"ANSI/UTF8 (no BOM)":((mode==1)?"UTF8 (with BOM)":"UTF16 (with BOM"));
		wtmpname = (wchar_t)/*Error: Function owner not recognized*/calloc(/*Error: Function owner not recognized*/wcslen(wfilename) + 2, /*Error: Unsupported expression*/);
		if (wtmpname == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not allocate space for temporary output name\n");
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/wcscpy(wtmpname, wfilename);
		wtmpname[/*Error: Function owner not recognized*/wcslen(wtmpname)] = (byte)'~';
		fd_out = /*Error: Function owner not recognized*/_wfopen(wtmpname, outmode[mode]);
		if (fd_out == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not open temporary output file '%s~'\n", filename);
			;
		} 
		// Process individual lines. NUL is always appended.while (/*Error: Function owner not recognized*/fgetws(buf, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), fd_in) != ((Object)0)) {
			i = 0;
			i += /*Error: Function owner not recognized*/wcsspn(buf[i], ModernizedCProgram.wspace);
			if (/*Error: Function owner not recognized*/_wcsnicmp(buf[i], wsection, /*Error: Function owner not recognized*/wcslen(wsection)) != 0) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fputws(buf, fd_out);
				continue;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fputws(buf, fd_out);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwprintf_s(fd_out, L"%s\n", wdata);
			ret = (byte)data;
		}
		if (fd_out != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_out);
		} 
		// If an insertion occurred, delete existing file and use the new oneif (ret != ((Object)0)) {
			fd_in = /*Error: Function owner not recognized*/_wfopen(wtmpname, L"rb");
			fd_out = /*Error: Function owner not recognized*/_wfopen(wfilename, L"wb");
			if ((fd_in != ((Object)0)) && (fd_out != ((Object)0))) {
				size = (mode == 2) ? 2 : 1;
				while (/*Error: Function owner not recognized*/fread(tmp, size, 1, fd_in) == 1) {
					if ((!dos2unix) || (tmp[0] != -1024)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite(tmp, size, 1, fd_out);
					} 
				}
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_in);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_out);
			} else {
					ModernizedCProgram._uprintf("Could not write '%s' - original file has been left unmodified\n", filename);
					ret = ((Object)0);
					if (fd_in != ((Object)0)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_in);
					} 
					if (fd_out != ((Object)0)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_out);
					} 
			} 
		} 
		// We're in Windows text mode => Remove CRs if requested
		if (wtmpname != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_wunlink(wtmpname);
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wfilename);
			wfilename = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wtmpname);
			wtmpname = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wsection);
			wsection = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wdata);
			wdata = ((Object)0);
		} while (0);
		return ret/*
		 * Search for a specific 'src' substring data for all occurrences of 'token', and replace
		 * it with 'rep'. File can be ANSI or UNICODE and is overwritten. Parameters are UTF-8.
		 * The parsed line is of the form: [ ]token[ ]data
		 * Returns a pointer to rep if replacement occurred, NULL otherwise
		 * TODO: We might have to end up with a regexp engine, so that we can do stuff like: "foo*" -> "bar\1"
		 */;
	}
	public static Byte replace_in_token_data(Object[] filename, Object[] token, Object[] src, Object[] rep, Object dos2unix) {
		wchar_t[] outmode = new wchar_t[]{L"w", L"w, ccs=UTF-8", L"w, ccs=UTF-16LE"};
		wchar_t wtoken = ((Object)0);
		wchar_t wfilename = ((Object)0);
		wchar_t wtmpname = ((Object)0);
		wchar_t wsrc = ((Object)0);
		wchar_t wrep = ((Object)0);
		wchar_t bom = 0;
		wchar_t[] buf = new wchar_t();
		wchar_t torep = new wchar_t();
		FILE fd_in = ((Object)0);
		FILE fd_out = ((Object)0);
		size_t i = new size_t();
		size_t ns = new size_t();
		size_t size = new size_t();
		int mode = 0;
		byte ret = ((Object)0);
		byte[] tmp = new byte[2];
		if ((filename == ((Object)0)) || (token == ((Object)0)) || (src == ((Object)0)) || (rep == ((Object)0))) {
			return ((Object)0);
		} 
		if ((filename[0] == 0) || (token[0] == 0) || (src[0] == 0) || (rep[0] == 0)) {
			return ((Object)0);
		} 
		// No need for processing is source is same as replacementif (/*Error: Function owner not recognized*/strcmp(src, rep) == 0) {
			return ((Object)0);
		} 
		wfilename = ModernizedCProgram.utf8_to_wchar(filename);
		if (wfilename == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, filename);
			;
		} 
		wtoken = ModernizedCProgram.utf8_to_wchar(token);
		if (wfilename == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, token);
			;
		} 
		wsrc = ModernizedCProgram.utf8_to_wchar(src);
		if (wsrc == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, src);
			;
		} 
		wrep = ModernizedCProgram.utf8_to_wchar(rep);
		if (wsrc == ((Object)0)) {
			ModernizedCProgram._uprintf(ModernizedCProgram.conversion_error, rep);
			;
		} 
		fd_in = /*Error: Function owner not recognized*/_wfopen(wfilename, L"r, ccs=UNICODE");
		if (fd_in == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not open file '%s'\n", filename);
			;
		} 
		Object generated_flag = (fd_in).get_flag();
		// Check the input file's BOM and create an output file with the sameif (/*Error: Function owner not recognized*/fread(bom, /*Error: sizeof expression not supported yet*/, 1, fd_in) != 1) {
			if (!(generated_flag & -1024)) {
				ModernizedCProgram._uprintf("Could not read file '%s'\n", filename);
			} 
			;
		} 
		switch (bom) {
		case -1024:
				mode = 1;
				break;
		case -1024:
				mode = 2;
				break;
		default:
				mode = 0;
				break;
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fseek(fd_in, 0, 0)//	duprintf("'%s' was detected as %s\n", filename,//		(mode==0)?"ANSI/UTF8 (no BOM)":((mode==1)?"UTF8 (with BOM)":"UTF16 (with BOM"));;//	duprintf("'%s' was detected as %s\n", filename,//		(mode==0)?"ANSI/UTF8 (no BOM)":((mode==1)?"UTF8 (with BOM)":"UTF16 (with BOM"));
		wtmpname = (wchar_t)/*Error: Function owner not recognized*/calloc(/*Error: Function owner not recognized*/wcslen(wfilename) + 2, /*Error: Unsupported expression*/);
		if (wtmpname == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not allocate space for temporary output name\n");
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/wcscpy(wtmpname, wfilename);
		wtmpname[/*Error: Function owner not recognized*/wcslen(wtmpname)] = (byte)'~';
		fd_out = /*Error: Function owner not recognized*/_wfopen(wtmpname, outmode[mode]);
		if (fd_out == ((Object)0)) {
			ModernizedCProgram._uprintf("Could not open temporary output file '%s~'\n", filename);
			;
		} 
		// Process individual lines. NUL is always appended.while (/*Error: Function owner not recognized*/fgetws(buf, (/*Error: sizeof expression not supported yet*/ / /*Error: sizeof expression not supported yet*/), fd_in) != ((Object)0)) {
			i = 0;
			i += /*Error: Function owner not recognized*/wcsspn(buf[i], ModernizedCProgram.wspace);
			if (/*Error: Function owner not recognized*/_wcsnicmp(buf[i], wtoken, /*Error: Function owner not recognized*/wcslen(wtoken)) != 0) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fputws(buf, fd_out);
				continue;
			} 
			i += /*Error: Function owner not recognized*/wcslen(wtoken);
			ns = /*Error: Function owner not recognized*/wcsspn(buf[i], ModernizedCProgram.wspace);
			if (ns == 0) {
				continue;
			} 
			i += ns;
			torep = /*Error: Function owner not recognized*/wcsstr(buf[i], wsrc);
			if (torep == ((Object)0)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fputws(buf, fd_out);
				continue;
			} 
			i = (torep - buf) + /*Error: Function owner not recognized*/wcslen(wsrc);
			torep = 0;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwprintf_s(fd_out, L"%s%s%s", buf, wrep, buf[i]);
			ret = (byte)rep;
		}
		if (fd_out != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_out);
		} 
		// If a replacement occurred, delete existing file and use the new oneif (ret != ((Object)0)) {
			fd_in = /*Error: Function owner not recognized*/_wfopen(wtmpname, L"rb");
			fd_out = /*Error: Function owner not recognized*/_wfopen(wfilename, L"wb");
			if ((fd_in != ((Object)0)) && (fd_out != ((Object)0))) {
				size = (mode == 2) ? 2 : 1;
				while (/*Error: Function owner not recognized*/fread(tmp, size, 1, fd_in) == 1) {
					if ((!dos2unix) || (tmp[0] != -1024)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite(tmp, size, 1, fd_out);
					} 
				}
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_in);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_out);
			} else {
					ModernizedCProgram._uprintf("Could not write '%s' - original file has been left unmodified.\n", filename);
					ret = ((Object)0);
					if (fd_in != ((Object)0)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_in);
					} 
					if (fd_out != ((Object)0)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fclose(fd_out);
					} 
			} 
		} 
		// We're in Windows text mode => Remove CRs if requested
		if (wtmpname != ((Object)0)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/_wunlink(wtmpname);
		} 
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wfilename);
			wfilename = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wtmpname);
			wtmpname = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wtoken);
			wtoken = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wsrc);
			wsrc = ((Object)0);
		} while (0);
		do {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free((Object)wrep);
			wrep = ((Object)0);
		} while (0);
		return ret/*
		 * Replace all 'c' characters in string 'src' with the substring 'rep'
		 * The returned string is allocated and must be freed by the caller.
		 */;
	}
	public static Byte replace_char(Object[] src, Object c, Object[] rep) {
		size_t i = new size_t();
		size_t j = new size_t();
		size_t k = new size_t();
		size_t count = 0;
		size_t str_len = ((((byte)src) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(src));
		size_t rep_len = ((((byte)rep) == ((Object)0)) ? 0 : /*Error: Function owner not recognized*/strlen(rep));
		byte res;
		if ((src == ((Object)0)) || (rep == ((Object)0))) {
			return ((Object)0);
		} 
		for (i = 0; i < str_len; i++) {
			if (src[i] == c) {
				count++;
			} 
		}
		res = (byte)/*Error: Function owner not recognized*/malloc(str_len + count * rep_len + 1);
		if (res == ((Object)0)) {
			return ((Object)0);
		} 
		for (; i < str_len; i++) {
			if (src[i] == c) {
				for (k = 0; k < rep_len; k++) {
					res[j++] = rep[k];
				}
			} else {
					res[j++] = src[i];
			} 
		}
		res[j] = 0;
		return res/*
		 * Internal recursive call for get_data_from_asn1(). Returns FALSE on error, TRUE otherwise.
		 */;
	}
	public static Object get_data_from_asn1_internal(Object[] buf, Object buf_len, Object oid, Object oid_len, Object asn1_type, Object data, Object data_len, Object matched) {
		size_t pos = 0;
		size_t len = new size_t();
		size_t len_len = new size_t();
		size_t i = new size_t();
		uint8_t tag = new uint8_t();
		BOOL is_sequence = new BOOL();
		BOOL is_universal_tag = new BOOL();
		while (pos < buf_len) {
			is_sequence = buf[pos] & -1024;
			is_universal_tag = ((buf[pos] & -1024) == -1024);
			tag = buf[pos++] & -1024;
			if (tag == -1024) {
				ModernizedCProgram._uprintf("get_data_from_asn1: Long form tags are unsupported");
				return 0;
			} 
			len = 0;
			len_len = 1;
			if ((is_universal_tag) && (tag == -1024)) {
				pos++;
			} else {
					if (buf[pos] & -1024) {
						len_len = buf[pos++] & -1024;
						if (len_len > 2) {
							ModernizedCProgram._uprintf("get_data_from_asn1: Length fields larger than 2 bytes are unsupported");
							return 0;
						} 
						for (i = 0; i < len_len; i++) {
							len <<=  8;
							len += buf[pos++];
						}
					} else {
							len = buf[pos++];
					} 
					if (len > buf_len - pos) {
						ModernizedCProgram._uprintf("get_data_from_asn1: Overflow error (computed length %d is larger than remaining data)", len);
						return 0;
					} 
			} 
			if (len != 0) {
				if (is_sequence) {
					if (!ModernizedCProgram.get_data_from_asn1_internal(buf[pos], len, oid, oid_len, asn1_type, data, data_len, matched)) {
						return 0;
					} 
					if (data != ((Object)0)) {
						return 1;
					} 
				}  else if (is_universal_tag) {
					if ((!matched) && (tag == -1024) && (len == oid_len) && (/*Error: Function owner not recognized*/memcmp(buf[pos], oid, oid_len) == 0)) {
						matched = 1;
					}  else if ((matched) && (tag == asn1_type)) {
						data_len = len;
						data = (Object)buf[pos];
						return 1;
					} 
				} 
				pos += len;
			} 
		}
		;
		return 1/*
		 * Helper functions to convert an OID string to an OID byte array
		 * Taken from from openpgp-oid.c
		 */;
	}
	public static Object make_flagged_int(long value, Object[] buf, Object buf_len) {
		BOOL more = 0;
		int shift;
		for (shift = 28; shift > 0; shift -= 7) {
			if (more || value >= ((long)1 << shift)) {
				buf[buf_len++] = (uint8_t)(-1024 | (value >> shift));
				value -= (value >> shift) << shift;
				more = 1;
			} 
		}
		buf[buf_len++] = (uint8_t)value;
		return buf_len/*
		 * Convert OID string 'oid_str' to an OID byte array of size 'ret_len'
		 * The returned array must be freed by the caller.
		 */;
	}
	public static Object oid_from_str(Object[] oid_str, Object ret_len) {
		uint8_t oid = ((Object)0);
		long val1 = 0;
		long val;
		byte endp;
		int arcno = 0;
		size_t oid_len = 0;
		if ((oid_str == ((Object)0)) || (oid_str[0] == 0)) {
			return ((Object)0);
		} 
		// We can safely assume that the encoded OID is shorter than the string.// We can safely assume that the encoded OID is shorter than the string.oid = /*Error: Function owner not recognized*/malloc(1 + /*Error: Function owner not recognized*/strlen(oid_str) + 2);
		if (oid == ((Object)0)) {
			return ((Object)0);
		} 
		do {
			arcno++;
			val = /*Error: Function owner not recognized*/strtoul(oid_str, (byte)endp, 10);
			if (!/*Error: Function owner not recognized*/isdigit(oid_str) || !(endp == (byte)'.' || !endp)) {
				;
			} 
			if (endp == (byte)'.') {
				oid_str = endp + 1;
			} 
			if (arcno == 1) {
				if (val > 2) {
					break;
				} 
				val1 = val;
			}  else if (arcno == 2) {
				if (val1 < 2) {
					if (val > 39) {
						;
					} 
					oid[oid_len++] = (uint8_t)(val1 * 40 + val);
				} else {
						val += 80;
						oid_len = ModernizedCProgram.make_flagged_int(val, oid, oid_len);
				} 
			} else {
					oid_len = ModernizedCProgram.make_flagged_int(val, oid, oid_len);
			} 
		} while (endp == (byte)'.');
		// It is not possible to encode only the first arc.if (arcno == 1 || oid_len < 2 || oid_len > 254) {
			;
		} 
		ret_len = oid_len;
		return oid;
		return ((Object)0/*
		 * Parse an ASN.1 binary buffer and return a pointer to the first instance of OID data of type 'asn1_type',
		 * matching the OID 'oid_str' (expressed as an OID string). If successful, the length or the returned data
		 * is placed in 'data_len'. Note: Only the UNIVERSAL class is supported for 'asn1_type' (other classes are
		 * ignored). If 'oid_str' is NULL or empty, the first data element of type 'asn1_type' is returned.
		 */);
	}
	public static Object get_data_from_asn1(Object buf, Object buf_len, Object[] oid_str, Object asn1_type, Object data_len) {
		Object data = ((Object)0);
		uint8_t oid = ((Object)0);
		size_t oid_len = 0;
		BOOL matched = ((oid_str == ((Object)0)) || (oid_str[0] == 0));
		if (buf_len >= 65536) {
			ModernizedCProgram._uprintf("get_data_from_asn1: Buffers larger than 64KB are not supported");
			return ((Object)0);
		} 
		if (!matched) {
			oid = ModernizedCProgram.oid_from_str(oid_str, oid_len);
			if (oid == ((Object)0)) {
				ModernizedCProgram._uprintf("get_data_from_asn1: Could not convert OID string '%s'", oid_str);
				return ((Object)0);
			} 
		} 
		// We have an OID string to convert
		// No need to check for the return value as data is always NULL on error// No need to check for the return value as data is always NULL on errorModernizedCProgram.get_data_from_asn1_internal(buf, buf_len, oid, oid_len, asn1_type, data, data_len, matched);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(oid);
		return data;
	}
	/******************************************************************
	    Copyright (C) 2009  Henrik Carlqvist
	    Modified for Rufus/Windows (C) 2011-2019  Pete Batard
	
	    This program is free software; you can redistribute it and/or modify
	    it under the terms of the GNU General Public License as published by
	    the Free Software Foundation; either version 2 of the License, or
	    (at your option) any later version.
	
	    This program is distributed in the hope that it will be useful,
	    but WITHOUT ANY WARRANTY; without even the implied warranty of
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	    GNU General Public License for more details.
	
	    You should have received a copy of the GNU General Public License
	    along with this program; if not, write to the Free Software
	    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
	******************************************************************/
	/* Returns the number of bytes written or -1 on error */
	public static Object write_sectors(Object hDrive, Object SectorSize, Object StartSector, Object nSectors, Object pBuf) {
		LARGE_INTEGER ptr = new LARGE_INTEGER();
		DWORD Size = new DWORD();
		if ((nSectors * SectorSize) > -1024) {
			ModernizedCProgram._uprintf("write_sectors: nSectors x SectorSize is too big\n");
			return -1;
		} 
		Size = (DWORD)(nSectors * SectorSize);
		ptr.setQuadPart(StartSector * SectorSize);
		if (!/*Error: Function owner not recognized*/SetFilePointerEx(hDrive, ptr, ((Object)0), 0)) {
			ModernizedCProgram._uprintf("write_sectors: Could not access sector 0x%08I64x - %s\n", StartSector, ModernizedCProgram.WindowsErrorString());
			return -1;
		} 
		ModernizedCProgram.LastWriteError = 0;
		if (!/*Error: Function owner not recognized*/WriteFile(hDrive, pBuf, Size, Size, ((Object)0))) {
			ModernizedCProgram.LastWriteError = -1024 | (3 << 16) | /*Error: Function owner not recognized*/GetLastError();
			ModernizedCProgram._uprintf("write_sectors: Write error %s\n", ModernizedCProgram.WindowsErrorString());
			ModernizedCProgram._uprintf("  StartSector: 0x%08I64x, nSectors: 0x%I64x, SectorSize: 0x%I64x\n", StartSector, nSectors, SectorSize);
			return -1;
		} 
		if (Size != nSectors * SectorSize) {
			if (ModernizedCProgram.large_drive && Size == /* Some large drives return 0, even though all the data was written - See github #787 */0) {
				ModernizedCProgram._uprintf("Warning: Possible short write\n");
				return 0;
			} 
			ModernizedCProgram._uprintf("write_sectors: Write error\n");
			ModernizedCProgram.LastWriteError = -1024 | (3 << 16) | -1024;
			ModernizedCProgram._uprintf("  Wrote: %d, Expected: %I64u\n", Size, nSectors * SectorSize);
			ModernizedCProgram._uprintf("  StartSector: 0x%08I64x, nSectors: 0x%I64x, SectorSize: 0x%I64x\n", StartSector, nSectors, SectorSize);
			return -1;
		} 
		return (int64_t)Size;
	}
	/* Returns the number of bytes read or -1 on error */
	public static Object read_sectors(Object hDrive, Object SectorSize, Object StartSector, Object nSectors, Object pBuf) {
		LARGE_INTEGER ptr = new LARGE_INTEGER();
		DWORD Size = new DWORD();
		if ((nSectors * SectorSize) > -1024) {
			ModernizedCProgram._uprintf("read_sectors: nSectors x SectorSize is too big\n");
			return -1;
		} 
		Size = (DWORD)(nSectors * SectorSize);
		ptr.setQuadPart(StartSector * SectorSize);
		if (!/*Error: Function owner not recognized*/SetFilePointerEx(hDrive, ptr, ((Object)0), 0)) {
			ModernizedCProgram._uprintf("read_sectors: Could not access sector 0x%08I64x - %s\n", StartSector, ModernizedCProgram.WindowsErrorString());
			return -1;
		} 
		if ((!/*Error: Function owner not recognized*/ReadFile(hDrive, pBuf, Size, Size, ((Object)0))) || (Size != nSectors * SectorSize)) {
			ModernizedCProgram._uprintf("read_sectors: Read error %s\n", (/*Error: Function owner not recognized*/GetLastError() != -1024) ? ModernizedCProgram.WindowsErrorString() : "");
			ModernizedCProgram._uprintf("  Read: %d, Expected: %I64u\n", Size, nSectors * SectorSize);
			ModernizedCProgram._uprintf("  StartSector: 0x%08I64x, nSectors: 0x%I64x, SectorSize: 0x%I64x\n", StartSector, nSectors, SectorSize);
		} 
		return (int64_t)Size/*
		* The following calls use a hijacked fp on Windows that contains:
		* fp->_handle: a Windows handle
		* fp->_offset: a file offset
		*/;
	}
	public static int contains_data(Object Position, Object pData, Object Len) {
		int r = 0;
		byte aucBuf = /*Error: Function owner not recognized*/_mm_malloc(32768, 16);
		if (aucBuf == ((Object)0)) {
			return 0;
		} 
		if (!fp.read_data(Position, aucBuf, Len)) {
			;
		} 
		if (/*Error: Function owner not recognized*/memcmp(pData, aucBuf, (size_t)Len)) {
			;
		} 
		r = 1;
		return r/* contains_data */;
	}
	public static int read_data(Object Position, Object pData, Object Len) {
		int r = 0;
		byte aucBuf = /*Error: Function owner not recognized*/_mm_malloc(32768, 16);
		FAKE_FD fd = (FAKE_FD)fp;
		Object generated_handle = fd.get_handle();
		HANDLE hDrive = (HANDLE)generated_handle;
		uint64_t StartSector = new uint64_t();
		uint64_t EndSector = new uint64_t();
		uint64_t NumSectors = new uint64_t();
		if (aucBuf == ((Object)0)) {
			return 0;
		} 
		Object generated_offset = fd.get_offset();
		Position += generated_offset;
		StartSector = Position / ModernizedCProgram.ulBytesPerSector;
		EndSector = (Position + Len + ModernizedCProgram.ulBytesPerSector - 1) / ModernizedCProgram.ulBytesPerSector;
		NumSectors = (size_t)(EndSector - StartSector);
		if ((NumSectors * ModernizedCProgram.ulBytesPerSector) > 32768) {
			ModernizedCProgram._uprintf("read_data: Please increase MAX_DATA_LEN in file.h\n");
			;
		} 
		if (Len > -1024) {
			ModernizedCProgram._uprintf("read_data: Len is too big\n");
			;
		} 
		if (ModernizedCProgram.read_sectors(hDrive, ModernizedCProgram.ulBytesPerSector, StartSector, NumSectors, aucBuf) <= 0) {
			;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(pData, aucBuf[Position - StartSector * ModernizedCProgram.ulBytesPerSector], (size_t)Len);
		r = 1;
		return r/* read_data */;
	}
	/* May read/write the same sector many times, but compatible with existing ms-sys */
	public static int write_data(Object Position, Object pData, Object Len) {
		int r = 0;
		byte aucBuf = /*Error: Function owner not recognized*/_mm_malloc(32768, /* Windows' WriteFile() may require a buffer that is aligned to the sector size */4096);
		FAKE_FD fd = (FAKE_FD)fp;
		Object generated_handle = fd.get_handle();
		HANDLE hDrive = (HANDLE)generated_handle;
		uint64_t StartSector = new uint64_t();
		uint64_t EndSector = new uint64_t();
		uint64_t NumSectors = new uint64_t();
		if (aucBuf == ((Object)0)) {
			return 0;
		} 
		Object generated_offset = fd.get_offset();
		Position += generated_offset;
		StartSector = Position / ModernizedCProgram.ulBytesPerSector;
		EndSector = (Position + Len + ModernizedCProgram.ulBytesPerSector - 1) / ModernizedCProgram.ulBytesPerSector;
		NumSectors = EndSector - StartSector;
		if ((NumSectors * ModernizedCProgram.ulBytesPerSector) > 32768) {
			ModernizedCProgram._uprintf("write_data: Please increase MAX_DATA_LEN in file.h\n");
			;
		} 
		if (Len > -1024) {
			ModernizedCProgram._uprintf("write_data: Len is too big\n");
			;
		} 
		if (ModernizedCProgram.read_sectors(hDrive, ModernizedCProgram.ulBytesPerSector, /* Data to write may not be aligned on a sector boundary => read into a sector buffer first */StartSector, NumSectors, aucBuf) <= 0) {
			;
		} 
		if (!/*Error: Function owner not recognized*/memcpy(aucBuf[Position - StartSector * ModernizedCProgram.ulBytesPerSector], pData, (size_t)Len)) {
			;
		} 
		if (ModernizedCProgram.write_sectors(hDrive, ModernizedCProgram.ulBytesPerSector, StartSector, NumSectors, aucBuf) <= 0) {
			;
		} 
		r = 1;
		return r/* write_data */;
	}
	/*
	 * fallocate.c -- Allocate large chunks of file.
	 *
	 * Copyright (C) 2014 Oracle.
	 *
	 * %Begin-Header%
	 * This file may be redistributed under the terms of the GNU Library
	 * General Public License, version 2.
	 * %End-Header%
	 */
	/*
	 * Extent-based fallocate code.
	 *
	 * Find runs of unmapped logical blocks by starting at start and walking the
	 * extents until we reach the end of the range we want.
	 *
	 * For each run of unmapped blocks, try to find the extents on either side of
	 * the range.  If there's a left extent that can grow by at least a cluster and
	 * there are lblocks between start and the next lcluster after start, see if
	 * there's an implied cluster allocation; if so, zero the blocks (if the left
	 * extent is initialized) and adjust the extent.  Ditto for the blocks between
	 * the end of the last full lcluster and end, if there's a right extent.
	 *
	 * Try to attach as much as we can to the left extent, then try to attach as
	 * much as we can to the right extent.  For the remainder, try to allocate the
	 * whole range; map in whatever we get; and repeat until we're done.
	 *
	 * To attach to a left extent, figure out the maximum amount we can add to the
	 * extent and try to allocate that much, and append if successful.  To attach
	 * to a right extent, figure out the max we can add to the extent, try to
	 * allocate that much, and prepend if successful.
	 *
	 * We need an alloc_range function that tells us how much we can allocate given
	 * a maximum length and one of a suggested start, a fixed start, or a fixed end
	 * point.
	 *
	 * Every time we modify the extent tree we also need to update the block stats.
	 *
	 * At the end, update i_blocks and i_size appropriately.
	 */
	public static void dbg_print_extent(Object desc, Object extent) {
	}
	public static Object ext_falloc_helper(Object fs, int flags, Object ino, ext2_inode inode, Object handle, ext2fs_extent left_ext, ext2fs_extent right_ext, Object range_start, Object range_len, Object alloc_goal) {
		ext2fs_extent newex = new ext2fs_extent();
		ext2fs_extent ex = new ext2fs_extent();
		int op;
		 fillable = new ();
		 pblk = new ();
		 plen = new ();
		 x = new ();
		 y = new ();
		 eof_blk = 0;
		 cluster_fill = 0;
		 err = new ();
		 max_extent_len = new ();
		 max_uninit_len = new ();
		 max_init_len = new ();
		Object generatedI_size = (inode).getI_size();
		if (!(flags & (/* Can't create initialized extents past EOF? */true))) {
			eof_blk = (generatedI_size | (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(inode).getI_size_high() << 32)) / fs.getBlocksize();
		} 
		alloc_goal = (alloc_goal & ~((-1024 << (fs).getCluster_ratio_bits()) - /* The allocation goal must be as far into a cluster as range_start. */1)) | (range_start & ((-1024 << (fs).getCluster_ratio_bits()) - 1));
		max_uninit_len = EXT_UNINIT_MAX_LEN & ~((-1024 << (fs).getCluster_ratio_bits()) - 1);
		max_init_len = EXT_INIT_MAX_LEN & ~((-1024 << (fs).getCluster_ratio_bits()) - 1);
		Object generatedE_flags = left_ext.getE_flags();
		Object generatedE_len = left_ext.getE_len();
		Object generatedE_lblk = left_ext.getE_lblk();
		Object generatedE_pblk = left_ext.getE_pblk();
		if (left_ext && (-1024 << (fs).getCluster_ratio_bits()) > /* We must lengthen the left extent to the end of the cluster */1) {
			if (generatedE_flags & /* How many more blocks can be attached to left_ext? */-1024) {
				fillable = max_uninit_len - generatedE_len;
			} else {
					fillable = max_init_len - generatedE_len;
			} 
			if (fillable > range_len) {
				fillable = range_len;
			} 
			if (fillable == 0) {
				;
			} 
			cluster_fill = (-1024 << (fs).getCluster_ratio_bits()) - (range_start & ((-1024 << (fs).getCluster_ratio_bits()) - 1));
			cluster_fill &=  ((-1024 << (fs).getCluster_ratio_bits()) - 1);
			if (cluster_fill == 0) {
				;
			} 
			if (cluster_fill > fillable) {
				cluster_fill = fillable;
			} 
			if (!(flags & (/* Don't expand an initialized left_ext beyond EOF */true))) {
				x = generatedE_lblk + generatedE_len - 1;
				;
				if (eof_blk >= x && eof_blk <= x + cluster_fill) {
					cluster_fill = eof_blk - x;
				} 
				if (cluster_fill == 0) {
					;
				} 
			} 
			err = ModernizedCProgram.ext2fs_extent_goto(handle, generatedE_lblk);
			if (err) {
				;
			} 
			generatedE_len += cluster_fill;
			range_start += cluster_fill;
			range_len -= cluster_fill;
			alloc_goal += cluster_fill;
			ModernizedCProgram.dbg_print_extent("ext_falloc clus left+", left_ext);
			err = left_ext.ext2fs_extent_replace(handle, 0);
			if (err) {
				;
			} 
			err = ModernizedCProgram.ext2fs_extent_fix_parents(handle);
			if (err) {
				;
			} 
			if (!(generatedE_flags & /* Zero blocks */-1024)) {
				err = ModernizedCProgram.ext2fs_zero_blocks2(fs, generatedE_pblk + generatedE_len - cluster_fill, cluster_fill, ((Object)0), ((Object)0));
				if (err) {
					;
				} 
			} 
		} 
		if (range_len > 0 && (y & ((-1024 << (fs).getCluster_ratio_bits()) - 1))) {
			cluster_fill = y & ((-1024 << (fs).getCluster_ratio_bits()) - 1);
			if (cluster_fill > range_len) {
				cluster_fill = range_len;
			} 
			newex.setE_lblk(y & ~((-1024 << (fs).getCluster_ratio_bits()) - 1));
			err = inode.ext2fs_map_cluster_block(fs, ino, generatedE_lblk, pblk);
			if (err) {
				;
			} 
			if (pblk == 0) {
				;
			} 
			newex.setE_pblk(pblk);
			newex.setE_len(cluster_fill);
			newex.setE_flags((flags & (true) ? 0 : -1024));
			ModernizedCProgram.dbg_print_extent("ext_falloc iclus right+", newex);
			ModernizedCProgram.ext2fs_extent_goto(handle, generatedE_lblk);
			err = ex.ext2fs_extent_get(handle, -1024);
			if (err == EXT2_ET_NO_CURRENT_NODE) {
				ex.setE_lblk(0);
			}  else if (err) {
				;
			} 
			if (generatedE_lblk > generatedE_lblk) {
				op = /* insert before */0;
			} else {
					op = -1024;
			} 
			;
			err = newex.ext2fs_extent_insert(handle, op);
			if (err) {
				;
			} 
			err = ModernizedCProgram.ext2fs_extent_fix_parents(handle);
			if (err) {
				;
			} 
			if (!(generatedE_flags & -1024) && (flags & (true))) {
				err = ModernizedCProgram.ext2fs_zero_blocks2(fs, generatedE_pblk, generatedE_len, ((Object)0), ((Object)0));
				if (err) {
					;
				} 
			} 
			range_len -= cluster_fill;
		} 
		newex.setE_lblk(range_start);
		if (flags & (true)) {
			max_extent_len = max_init_len;
			newex.setE_flags(0);
		} else {
				max_extent_len = max_uninit_len;
				newex.setE_flags(-1024);
		} 
		pblk = alloc_goal;
		y = range_len;
		for (x = 0; x < y; /*Error: Unsupported expression*/) {
			cluster_fill = generatedE_lblk & ((-1024 << (fs).getCluster_ratio_bits()) - 1);
			fillable = ((range_len + cluster_fill) < (max_extent_len) ? (range_len + cluster_fill) : (max_extent_len));
			err = ModernizedCProgram.ext2fs_new_range(fs, 0, pblk & ~((-1024 << (fs).getCluster_ratio_bits()) - 1), fillable, ((Object)0), pblk, plen);
			if (err) {
				;
			} 
			err = inode.claim_range(fs, pblk, plen);
			if (err) {
				;
			} 
			newex.setE_pblk(pblk + /* Create extent */cluster_fill);
			newex.setE_len(plen - cluster_fill);
			ModernizedCProgram.dbg_print_extent("ext_falloc create", newex);
			ModernizedCProgram.ext2fs_extent_goto(handle, generatedE_lblk);
			err = ex.ext2fs_extent_get(handle, -1024);
			if (err == EXT2_ET_NO_CURRENT_NODE) {
				ex.setE_lblk(0);
			}  else if (err) {
				;
			} 
			if (generatedE_lblk > generatedE_lblk) {
				op = /* insert before */0;
			} else {
					op = -1024;
			} 
			;
			err = newex.ext2fs_extent_insert(handle, op);
			if (err) {
				;
			} 
			err = ModernizedCProgram.ext2fs_extent_fix_parents(handle);
			if (err) {
				;
			} 
			if (!(generatedE_flags & -1024) && (flags & (true))) {
				err = ModernizedCProgram.ext2fs_zero_blocks2(fs, pblk, plen, ((Object)0), ((Object)0));
				if (err) {
					;
				} 
			} 
			x += plen - /* Update variables at end of loop */cluster_fill;
			range_len -= plen - cluster_fill;
			generatedE_lblk += plen - cluster_fill;
			pblk += plen - cluster_fill;
			if (pblk >= fs.getSuper().ext2fs_blocks_count()) {
				pblk = fs.getSuper().getS_first_data_block();
			} 
		}
	}
}
