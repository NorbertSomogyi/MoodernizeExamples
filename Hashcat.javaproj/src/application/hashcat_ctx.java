package application;

public class hashcat_ctx {
	private bitmap_ctx bitmap_ctx;
	private combinator_ctx combinator_ctx;
	private cpt_ctx cpt_ctx;
	private debugfile_ctx debugfile_ctx;
	private dictstat_ctx dictstat_ctx;
	private event_ctx event_ctx;
	private folder_config folder_config;
	private hashcat_user hashcat_user;
	private hashconfig hashconfig;
	private hashes hashes;
	private hwmon_ctx hwmon_ctx;
	private induct_ctx induct_ctx;
	private logfile_ctx logfile_ctx;
	private loopback_ctx loopback_ctx;
	private mask_ctx mask_ctx;
	private module_ctx module_ctx;
	private backend_ctx backend_ctx;
	private outcheck_ctx outcheck_ctx;
	private outfile_ctx outfile_ctx;
	private pidfile_ctx pidfile_ctx;
	private potfile_ctx potfile_ctx;
	private restore_ctx restore_ctx;
	private status_ctx status_ctx;
	private straight_ctx straight_ctx;
	private tuning_db tuning_db;
	private user_options_extra user_options_extra;
	private user_options user_options;
	private wl_data wl_data;
	private Object event;
	
	public hashcat_ctx(bitmap_ctx bitmap_ctx, combinator_ctx combinator_ctx, cpt_ctx cpt_ctx, debugfile_ctx debugfile_ctx, dictstat_ctx dictstat_ctx, event_ctx event_ctx, folder_config folder_config, hashcat_user hashcat_user, hashconfig hashconfig, hashes hashes, hwmon_ctx hwmon_ctx, induct_ctx induct_ctx, logfile_ctx logfile_ctx, loopback_ctx loopback_ctx, mask_ctx mask_ctx, module_ctx module_ctx, backend_ctx backend_ctx, outcheck_ctx outcheck_ctx, outfile_ctx outfile_ctx, pidfile_ctx pidfile_ctx, potfile_ctx potfile_ctx, restore_ctx restore_ctx, status_ctx status_ctx, straight_ctx straight_ctx, tuning_db tuning_db, user_options_extra user_options_extra, user_options user_options, wl_data wl_data, Object event) {
		setBitmap_ctx(bitmap_ctx);
		setCombinator_ctx(combinator_ctx);
		setCpt_ctx(cpt_ctx);
		setDebugfile_ctx(debugfile_ctx);
		setDictstat_ctx(dictstat_ctx);
		setEvent_ctx(event_ctx);
		setFolder_config(folder_config);
		setHashcat_user(hashcat_user);
		setHashconfig(hashconfig);
		setHashes(hashes);
		setHwmon_ctx(hwmon_ctx);
		setInduct_ctx(induct_ctx);
		setLogfile_ctx(logfile_ctx);
		setLoopback_ctx(loopback_ctx);
		setMask_ctx(mask_ctx);
		setModule_ctx(module_ctx);
		setBackend_ctx(backend_ctx);
		setOutcheck_ctx(outcheck_ctx);
		setOutfile_ctx(outfile_ctx);
		setPidfile_ctx(pidfile_ctx);
		setPotfile_ctx(potfile_ctx);
		setRestore_ctx(restore_ctx);
		setStatus_ctx(status_ctx);
		setStraight_ctx(straight_ctx);
		setTuning_db(tuning_db);
		setUser_options_extra(user_options_extra);
		setUser_options(user_options);
		setWl_data(wl_data);
		setEvent(event);
	}
	public hashcat_ctx() {
	}
	
	public int dictstat_init() {
		dictstat_ctx generatedDictstat_ctx = this.getDictstat_ctx();
		dictstat_ctx_t dictstat_ctx = generatedDictstat_ctx;
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		dictstat_ctx.setEnabled(0);
		boolean generatedBenchmark = user_options.getBenchmark();
		if (generatedBenchmark == true) {
			return 0;
		} 
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		Object generatedAttack_mode = user_options.getAttack_mode();
		if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
			return 0;
		} 
		dictstat_ctx.setEnabled(1);
		dictstat_ctx.setBase((dictstat_t)ModernizedCProgram.hccalloc(100000, /*Error: Unsupported expression*/));
		dictstat_ctx.setCnt(0);
		Byte generatedFilename = dictstat_ctx.getFilename();
		Byte generatedProfile_dir = folder_config.getProfile_dir();
		ModernizedCProgram.hc_asprintf(generatedFilename, "%s/%s", generatedProfile_dir, "hashcat.dictstat2");
		return 0;
	}
	public void dictstat_destroy() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		dictstat_ctx generatedDictstat_ctx = this.getDictstat_ctx();
		dictstat_ctx_t dictstat_ctx = generatedDictstat_ctx;
		boolean generatedEnabled = dictstat_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		boolean generatedDictstat_disable = hashconfig.getDictstat_disable();
		if (generatedDictstat_disable == true) {
			return /*Error: Unsupported expression*/;
		} 
		Byte generatedFilename = dictstat_ctx.getFilename();
		ModernizedCProgram.hcfree(generatedFilename);
		dictstat generatedBase = dictstat_ctx.getBase();
		ModernizedCProgram.hcfree(generatedBase);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(dictstat_ctx, 0, /*Error: Unsupported expression*/);
	}
	public void dictstat_read() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		dictstat_ctx generatedDictstat_ctx = this.getDictstat_ctx();
		dictstat_ctx_t dictstat_ctx = generatedDictstat_ctx;
		boolean generatedEnabled = dictstat_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		boolean generatedDictstat_disable = hashconfig.getDictstat_disable();
		if (generatedDictstat_disable == true) {
			return /*Error: Unsupported expression*/;
		} 
		HCFILE fp = new HCFILE();
		Byte generatedFilename = dictstat_ctx.getFilename();
		if (fp.hc_fopen(generatedFilename, "rb") == 0) {
			return /*Error: Unsupported expression*/;
		} 
		// first run, file does not exist, do not error out
		// parse headeru64 v = new u64();
		u64 z = new u64();
		size_t nread1 = fp.hc_fread(v, /*Error: Unsupported expression*/, 1);
		size_t nread2 = fp.hc_fread(z, /*Error: Unsupported expression*/, 1);
		if ((nread1 != 1) || (nread2 != 1)) {
			hashcat_ctx.event_log_error("%s: Invalid header", generatedFilename);
			fp.hc_fclose();
			return /*Error: Unsupported expression*/;
		} 
		v = ModernizedCProgram.byte_swap_64(v);
		z = ModernizedCProgram.byte_swap_64(z);
		if ((v & -1024) != ((-1024 | -1024) & -1024)) {
			hashcat_ctx.event_log_error("%s: Invalid header, ignoring content", generatedFilename);
			fp.hc_fclose();
			return /*Error: Unsupported expression*/;
		} 
		if (z != 0) {
			hashcat_ctx.event_log_error("%s: Invalid header, ignoring content", generatedFilename);
			fp.hc_fclose();
			return /*Error: Unsupported expression*/;
		} 
		if ((v & -1024) < ((-1024 | -1024) & -1024)) {
			hashcat_ctx.event_log_warning("%s: Outdated header version, ignoring content", generatedFilename);
			fp.hc_fclose();
			return /*Error: Unsupported expression*/;
		} 
		dictstat generatedBase = dictstat_ctx.getBase();
		Object generatedCnt = dictstat_ctx.getCnt();
		// parse datawhile (!fp.hc_feof()) {
			dictstat_t d = new dictstat_t();
			size_t nread = fp.hc_fread(d, /*Error: Unsupported expression*/, 1);
			if (nread == 0) {
				continue;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/lsearch(d, generatedBase, generatedCnt, /*Error: Unsupported expression*/, ModernizedCProgram.sort_by_dictstat);
			if (generatedCnt == 100000) {
				hashcat_ctx.event_log_error("There are too many entries in the %s database. You have to remove/rename it.", generatedFilename);
				break;
			} 
		}
		fp.hc_fclose();
	}
	public int dictstat_write() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		dictstat_ctx generatedDictstat_ctx = this.getDictstat_ctx();
		dictstat_ctx_t dictstat_ctx = generatedDictstat_ctx;
		boolean generatedEnabled = dictstat_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		boolean generatedDictstat_disable = hashconfig.getDictstat_disable();
		if (generatedDictstat_disable == true) {
			return 0;
		} 
		HCFILE fp = new HCFILE();
		Byte generatedFilename = dictstat_ctx.getFilename();
		if (fp.hc_fopen(generatedFilename, "wb") == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		if (fp.hc_lockfile() == -1) {
			fp.hc_fclose();
			hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		// headeru64 v = (-1024 | -1024);
		u64 z = 0;
		v = ModernizedCProgram.byte_swap_64(v);
		z = ModernizedCProgram.byte_swap_64(z);
		fp.hc_fwrite(v, /*Error: Unsupported expression*/, 1);
		fp.hc_fwrite(z, /*Error: Unsupported expression*/, 1)// data;// data
		dictstat generatedBase = dictstat_ctx.getBase();
		Object generatedCnt = dictstat_ctx.getCnt();
		fp.hc_fwrite(generatedBase, /*Error: Unsupported expression*/, generatedCnt);
		fp.hc_fclose();
		return 0;
	}
	public int backend_ctx_find_alias_devices() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param_src.getSkipped();
		boolean generatedSkipped_warning = device_param_src.getSkipped_warning();
		Object[] generatedDevice_id_alias_buf = device_param_src.getDevice_id_alias_buf();
		int generatedDevice_id_alias_cnt = device_param_src.getDevice_id_alias_cnt();
		int generatedDevice_id = device_param_dst.getDevice_id();
		boolean generatedIs_opencl = device_param_dst.getIs_opencl();
		int generatedOpencl_devices_active = backend_ctx.getOpencl_devices_active();
		int generatedBackend_devices_active = backend_ctx.getBackend_devices_active();
		for (int backend_devices_cnt_src = 0;
		 backend_devices_cnt_src < generatedBackend_devices_cnt; backend_devices_cnt_src++) {
			hc_device_param_t device_param_src = generatedDevices_param[backend_devices_cnt_src];
			if (generatedSkipped == true) {
				continue;
			} 
			if (generatedSkipped_warning == true) {
				continue;
			} 
			for (int backend_devices_cnt_dst = backend_devices_cnt_src + 1;
			 backend_devices_cnt_dst < generatedBackend_devices_cnt; backend_devices_cnt_dst++) {
				hc_device_param_t device_param_dst = generatedDevices_param[backend_devices_cnt_dst];
				if (generatedSkipped == true) {
					continue;
				} 
				if (generatedSkipped_warning == true) {
					continue;
				} 
				if (ModernizedCProgram.is_same_device(device_param_src, device_param_dst) == 0) {
					continue;
				} 
				generatedDevice_id_alias_buf[generatedDevice_id_alias_cnt] = generatedDevice_id;
				generatedDevice_id_alias_cnt++;
				generatedDevice_id_alias_buf[generatedDevice_id_alias_cnt] = generatedDevice_id;
				generatedDevice_id_alias_cnt++;
				if (generatedIs_opencl == true) {
					if (generatedSkipped == false) {
						device_param_dst.setSkipped(1);
						generatedOpencl_devices_active--;
						generatedBackend_devices_active--;
					} 
				} 
			}
		}
		return -1;
	}
	public int ocl_check_dri() {
		// Now the problem is only with AMDGPU-PRO, not with oldschool AMD driver// Now do the real check// __linux__return 0;
	}
	// This check makes sense only if we're not root
	// No GPU available! That's fine, so we don't need to check if we have access to it.
	// Now we need to check if this an AMD vendor, because this is when the problems start
	public boolean setup_backend_devices_filter(Object backend_devices, Object out) {
		u64 backend_devices_filter = 0;
		if (backend_devices) {
			Byte devices = ModernizedCProgram.hcstrdup(backend_devices);
			if (devices == (null)) {
				return 0;
			} 
			Byte saveptr = (null);
			Byte next = /*Error: Function owner not recognized*/strtok_r(devices, ",", saveptr);
			do {
				int backend_device_id = (int)/*Error: Function owner not recognized*/strtol(next, (null), 10);
				if ((backend_device_id <= 0) || (backend_device_id >= 64)) {
					hashcat_ctx.event_log_error("Invalid device_id %d specified.", backend_device_id);
					ModernizedCProgram.hcfree(devices);
					return 0;
				} 
				backend_devices_filter |=  -1024 << (backend_device_id - 1);
			} while ((next = /*Error: Function owner not recognized*/strtok_r((byte)(null), ",", saveptr)) != (null));
			ModernizedCProgram.hcfree(devices);
		} else {
				backend_devices_filter = --1024;
		} 
		out = backend_devices_filter;
		return 1;
	}
	public boolean setup_opencl_device_types_filter(Object opencl_device_types, Object out) {
		 opencl_device_types_filter = 0;
		if (opencl_device_types) {
			Byte device_types = ModernizedCProgram.hcstrdup(opencl_device_types);
			if (device_types == (null)) {
				return 0;
			} 
			Byte saveptr = (null);
			Byte next = /*Error: Function owner not recognized*/strtok_r(device_types, ",", saveptr);
			do {
				int device_type = (int)/*Error: Function owner not recognized*/strtol(next, (null), 10);
				if (device_type < 1 || device_type > 3) {
					hashcat_ctx.event_log_error("Invalid OpenCL device-type %d specified.", device_type);
					ModernizedCProgram.hcfree(device_types);
					return 0;
				} 
				opencl_device_types_filter |=  -1024 << device_type;
			} while ((next = /*Error: Function owner not recognized*/strtok_r((null), ",", saveptr)) != (null));
			ModernizedCProgram.hcfree(device_types);
		} else {
				opencl_device_types_filter = CL_DEVICE_TYPE_ALL & ~CL_DEVICE_TYPE_CPU;
		} 
		out = opencl_device_types_filter;
		return 1;
	}
	public boolean cuda_test_instruction(Object sm_major, Object sm_minor, Object kernel_buf) {
		nvrtcProgram program = new nvrtcProgram();
		if (hashcat_ctx.hc_nvrtcCreateProgram(program, kernel_buf, "test_instruction", 0, (null), (null)) == -1) {
			return 0;
		} 
		byte[][] nvrtc_options = new byte[4];
		nvrtc_options[0] = "--restrict";
		nvrtc_options[1] = "--gpu-architecture";
		ModernizedCProgram.hc_asprintf(nvrtc_options[2], "compute_%d%d", sm_major, sm_minor);
		nvrtc_options[3] = (null);
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedNvrtc = backend_ctx.getNvrtc();
		NVRTC_PTR nvrtc = generatedNvrtc;
		nvrtcResult NVRTC_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(program, 3, (byte)nvrtc_options);
		ModernizedCProgram.hcfree(nvrtc_options[2]);
		size_t build_log_size = 0;
		hashcat_ctx.hc_nvrtcGetProgramLogSize(program, build_log_size);
		if (NVRTC_err != .NVRTC_SUCCESS) {
			Byte build_log = (byte)ModernizedCProgram.hcmalloc(build_log_size + 1);
			if (hashcat_ctx.hc_nvrtcGetProgramLog(program, build_log) == -1) {
				return 0;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/puts(build_log);
			ModernizedCProgram.hcfree(build_log);
			hashcat_ctx.hc_nvrtcDestroyProgram(program);
			return 0;
		} 
		size_t binary_size = new size_t();
		if (hashcat_ctx.hc_nvrtcGetPTXSize(program, binary_size) == -1) {
			return 0;
		} 
		Byte binary = (byte)ModernizedCProgram.hcmalloc(binary_size);
		if (hashcat_ctx.hc_nvrtcGetPTX(program, binary) == -1) {
			ModernizedCProgram.hcfree(binary);
			return 0;
		} 
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUmodule cuda_module = new CUmodule();
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(cuda_module, binary, 0, (null), (null));
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			ModernizedCProgram.hcfree(binary);
			return 0;
		} 
		ModernizedCProgram.hcfree(binary);
		if (hashcat_ctx.hc_cuModuleUnload(cuda_module) == -1) {
			return 0;
		} 
		if (hashcat_ctx.hc_nvrtcDestroyProgram(program) == -1) {
			return 0;
		} 
		return 1;
	}
	public boolean opencl_test_instruction(Object context, Object device, Object kernel_buf) {
		cl_program program = new cl_program();
		if (hashcat_ctx.hc_clCreateProgramWithSource(context, 1, kernel_buf, (null), program) == -1) {
			return 0;
		} 
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		// LLVM seems to write an error message (if there's an error) directly to stderr// and not (as supposted to) into buffer for later request using clGetProgramBuildInfo()
		// do not use the wrapper to avoid the error messageint CL_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(program, 1, device, "-Werror", (null), (null));
		if (CL_rc != CL_SUCCESS) {
			hashcat_ctx.hc_clReleaseProgram(program);
			return 0;
		} 
		if (hashcat_ctx.hc_clReleaseProgram(program) == -1) {
			return 0;
		} 
		return 1;
	}
	public boolean read_kernel_binary(Object kernel_file, Object[] kernel_lengths, byte[][] kernel_sources, Object force_recompile) {
		HCFILE fp = new HCFILE();
		Object generatedSt_size = st.getSt_size();
		if (fp.hc_fopen(kernel_file, "rb") == 1) {
			stat st = new stat();
			if (/*Error: Function owner not recognized*/stat(kernel_file, st)) {
				fp.hc_fclose();
				return 0;
			} 
			size_t klen = generatedSt_size;
			Byte buf = (byte)ModernizedCProgram.hcmalloc(klen + 1 + 100);
			size_t num_read = fp.hc_fread(buf, /*Error: Unsupported expression*/, klen);
			fp.hc_fclose();
			if (num_read != klen) {
				hashcat_ctx.event_log_error("%s: %s", kernel_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
				ModernizedCProgram.hcfree(buf);
				return 0;
			} 
			buf[klen] = 0;
			if (force_recompile == 1) {
				time_t tlog = /*Error: Function owner not recognized*/time((null));
				int extra_len = /*Error: Function owner not recognized*/snprintf(buf + klen, 100, "\n//%u\n", (u32)tlog);
				klen += extra_len;
			} 
			kernel_lengths[0] = klen;
			kernel_sources[0] = buf;
		} else {
				hashcat_ctx.event_log_error("%s: %s", kernel_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
				return 0;
		} 
		return 1;
	}
	public boolean write_kernel_binary(Byte kernel_file, Byte binary, Object binary_size) {
		if (binary_size > 0) {
			HCFILE fp = new HCFILE();
			if (fp.hc_fopen(kernel_file, "wb") == 0) {
				hashcat_ctx.event_log_error("%s: %s", kernel_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
				return 0;
			} 
			if (fp.hc_lockfile() == -1) {
				fp.hc_fclose();
				hashcat_ctx.event_log_error("%s: %s", kernel_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
				return 0;
			} 
			fp.hc_fwrite(binary, /*Error: Unsupported expression*/, binary_size);
			fp.hc_fflush();
			fp.hc_fclose();
		} 
		return 1;
	}
	// NVRTC
	public int nvrtc_init() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedNvrtc = backend_ctx.getNvrtc();
		NVRTC_PTR nvrtc = generatedNvrtc;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(nvrtc, 0, /*Error: Unsupported expression*/);
		nvrtc.setLib(ModernizedCProgram.hc_dlopen("nvrtc.dll"));
		if (nvrtc.getLib() == (null)) {
			byte[] dllname = new byte[100];
			for (int major = 20;
			 major >= 10; major--) {
				for (int minor = 20;
				 minor >= 0; minor--) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(dllname, /*Error: sizeof expression not supported yet*/, "nvrtc64_%d%d.dll", major, minor);
					nvrtc.setLib(ModernizedCProgram.hc_dlopen(dllname));
					if (nvrtc.getLib()) {
						break;
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(dllname, /*Error: sizeof expression not supported yet*/, "nvrtc64_%d%d_0.dll", major, minor);
					nvrtc.setLib(ModernizedCProgram.hc_dlopen(dllname));
					if (nvrtc.getLib()) {
						break;
					} 
				}
				if (nvrtc.getLib()) {
					break;
				} 
			}
		} 
		// super annoying: nvidia is using the CUDA version in nvrtc???.dll filename!// however, the cuda version string comes from nvcuda.dll which is from nvidia driver, but
		if (nvrtc.getLib() == (null)) {
			return -1;
		} 
		nvrtc.setNvrtcAddNameExpression((NVRTC_NVRTCADDNAMEEXPRESSION)ModernizedCProgram.hc_dlsym(nvrtc.getLib(), "nvrtcAddNameExpression"));
		if (1 != -1) {
			if (!nvrtc.getNvrtcAddNameExpression()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvrtcAddNameExpression", "NVRTC");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvrtcAddNameExpression", "NVRTC");
					return 0;
				} 
			} 
		} 
		;
		nvrtc.setNvrtcCompileProgram((NVRTC_NVRTCCOMPILEPROGRAM)ModernizedCProgram.hc_dlsym(nvrtc.getLib(), "nvrtcCompileProgram"));
		if (1 != -1) {
			if (!nvrtc.getNvrtcCompileProgram()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvrtcCompileProgram", "NVRTC");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvrtcCompileProgram", "NVRTC");
					return 0;
				} 
			} 
		} 
		;
		nvrtc.setNvrtcCreateProgram((NVRTC_NVRTCCREATEPROGRAM)ModernizedCProgram.hc_dlsym(nvrtc.getLib(), "nvrtcCreateProgram"));
		if (1 != -1) {
			if (!nvrtc.getNvrtcCreateProgram()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvrtcCreateProgram", "NVRTC");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvrtcCreateProgram", "NVRTC");
					return 0;
				} 
			} 
		} 
		;
		nvrtc.setNvrtcDestroyProgram((NVRTC_NVRTCDESTROYPROGRAM)ModernizedCProgram.hc_dlsym(nvrtc.getLib(), "nvrtcDestroyProgram"));
		if (1 != -1) {
			if (!nvrtc.getNvrtcDestroyProgram()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvrtcDestroyProgram", "NVRTC");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvrtcDestroyProgram", "NVRTC");
					return 0;
				} 
			} 
		} 
		;
		nvrtc.setNvrtcGetLoweredName((NVRTC_NVRTCGETLOWEREDNAME)ModernizedCProgram.hc_dlsym(nvrtc.getLib(), "nvrtcGetLoweredName"));
		if (1 != -1) {
			if (!nvrtc.getNvrtcGetLoweredName()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvrtcGetLoweredName", "NVRTC");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvrtcGetLoweredName", "NVRTC");
					return 0;
				} 
			} 
		} 
		;
		nvrtc.setNvrtcGetPTX((NVRTC_NVRTCGETPTX)ModernizedCProgram.hc_dlsym(nvrtc.getLib(), "nvrtcGetPTX"));
		if (1 != -1) {
			if (!nvrtc.getNvrtcGetPTX()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvrtcGetPTX", "NVRTC");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvrtcGetPTX", "NVRTC");
					return 0;
				} 
			} 
		} 
		;
		nvrtc.setNvrtcGetPTXSize((NVRTC_NVRTCGETPTXSIZE)ModernizedCProgram.hc_dlsym(nvrtc.getLib(), "nvrtcGetPTXSize"));
		if (1 != -1) {
			if (!nvrtc.getNvrtcGetPTXSize()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvrtcGetPTXSize", "NVRTC");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvrtcGetPTXSize", "NVRTC");
					return 0;
				} 
			} 
		} 
		;
		nvrtc.setNvrtcGetProgramLog((NVRTC_NVRTCGETPROGRAMLOG)ModernizedCProgram.hc_dlsym(nvrtc.getLib(), "nvrtcGetProgramLog"));
		if (1 != -1) {
			if (!nvrtc.getNvrtcGetProgramLog()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvrtcGetProgramLog", "NVRTC");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvrtcGetProgramLog", "NVRTC");
					return 0;
				} 
			} 
		} 
		;
		nvrtc.setNvrtcGetProgramLogSize((NVRTC_NVRTCGETPROGRAMLOGSIZE)ModernizedCProgram.hc_dlsym(nvrtc.getLib(), "nvrtcGetProgramLogSize"));
		if (1 != -1) {
			if (!nvrtc.getNvrtcGetProgramLogSize()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvrtcGetProgramLogSize", "NVRTC");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvrtcGetProgramLogSize", "NVRTC");
					return 0;
				} 
			} 
		} 
		;
		nvrtc.setNvrtcGetErrorString((NVRTC_NVRTCGETERRORSTRING)ModernizedCProgram.hc_dlsym(nvrtc.getLib(), "nvrtcGetErrorString"));
		if (1 != -1) {
			if (!nvrtc.getNvrtcGetErrorString()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvrtcGetErrorString", "NVRTC");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvrtcGetErrorString", "NVRTC");
					return 0;
				} 
			} 
		} 
		;
		nvrtc.setNvrtcVersion((NVRTC_NVRTCVERSION)ModernizedCProgram.hc_dlsym(nvrtc.getLib(), "nvrtcVersion"));
		if (1 != -1) {
			if (!nvrtc.getNvrtcVersion()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvrtcVersion", "NVRTC");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvrtcVersion", "NVRTC");
					return 0;
				} 
			} 
		} 
		;
		return 0;
	}
	public void nvrtc_close() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedNvrtc = backend_ctx.getNvrtc();
		NVRTC_PTR nvrtc = generatedNvrtc;
		if (nvrtc) {
			if (nvrtc.getLib()) {
				ModernizedCProgram.hc_dlclose(nvrtc.getLib());
			} 
			ModernizedCProgram.hcfree(generatedNvrtc);
			backend_ctx.setNvrtc((null));
		} 
	}
	public int hc_nvrtcCreateProgram(Object prog, Object src, Object name, int numHeaders, Object headers, Object includeNames) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedNvrtc = backend_ctx.getNvrtc();
		NVRTC_PTR nvrtc = generatedNvrtc;
		nvrtcResult NVRTC_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(prog, src, name, numHeaders, headers, includeNames);
		if (NVRTC_err != .NVRTC_SUCCESS) {
			hashcat_ctx.event_log_error("nvrtcCreateProgram(): %s", /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(NVRTC_err));
			return -1;
		} 
		return 0;
	}
	public int hc_nvrtcDestroyProgram(Object prog) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedNvrtc = backend_ctx.getNvrtc();
		NVRTC_PTR nvrtc = generatedNvrtc;
		nvrtcResult NVRTC_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(prog);
		if (NVRTC_err != .NVRTC_SUCCESS) {
			hashcat_ctx.event_log_error("nvrtcDestroyProgram(): %s", /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(NVRTC_err));
			return -1;
		} 
		return 0;
	}
	public int hc_nvrtcCompileProgram(Object prog, int numOptions, Object options) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedNvrtc = backend_ctx.getNvrtc();
		NVRTC_PTR nvrtc = generatedNvrtc;
		nvrtcResult NVRTC_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(prog, numOptions, options);
		if (NVRTC_err != .NVRTC_SUCCESS) {
			hashcat_ctx.event_log_error("nvrtcCompileProgram(): %s", /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(NVRTC_err));
			return -1;
		} 
		return 0;
	}
	public int hc_nvrtcGetProgramLogSize(Object prog, Object logSizeRet) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedNvrtc = backend_ctx.getNvrtc();
		NVRTC_PTR nvrtc = generatedNvrtc;
		nvrtcResult NVRTC_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(prog, logSizeRet);
		if (NVRTC_err != .NVRTC_SUCCESS) {
			hashcat_ctx.event_log_error("nvrtcGetProgramLogSize(): %s", /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(NVRTC_err));
			return -1;
		} 
		return 0;
	}
	public int hc_nvrtcGetProgramLog(Object prog, Byte log) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedNvrtc = backend_ctx.getNvrtc();
		NVRTC_PTR nvrtc = generatedNvrtc;
		nvrtcResult NVRTC_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(prog, log);
		if (NVRTC_err != .NVRTC_SUCCESS) {
			hashcat_ctx.event_log_error("nvrtcGetProgramLog(): %s", /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(NVRTC_err));
			return -1;
		} 
		return 0;
	}
	public int hc_nvrtcGetPTXSize(Object prog, Object ptxSizeRet) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedNvrtc = backend_ctx.getNvrtc();
		NVRTC_PTR nvrtc = generatedNvrtc;
		nvrtcResult NVRTC_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(prog, ptxSizeRet);
		if (NVRTC_err != .NVRTC_SUCCESS) {
			hashcat_ctx.event_log_error("nvrtcGetPTXSize(): %s", /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(NVRTC_err));
			return -1;
		} 
		return 0;
	}
	public int hc_nvrtcGetPTX(Object prog, Byte ptx) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedNvrtc = backend_ctx.getNvrtc();
		NVRTC_PTR nvrtc = generatedNvrtc;
		nvrtcResult NVRTC_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(prog, ptx);
		if (NVRTC_err != .NVRTC_SUCCESS) {
			hashcat_ctx.event_log_error("nvrtcGetPTX(): %s", /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(NVRTC_err));
			return -1;
		} 
		return 0;
	}
	public int hc_nvrtcVersion(Integer major, Integer minor) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedNvrtc = backend_ctx.getNvrtc();
		NVRTC_PTR nvrtc = generatedNvrtc;
		nvrtcResult NVRTC_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(major, minor);
		if (NVRTC_err != .NVRTC_SUCCESS) {
			hashcat_ctx.event_log_error("nvrtcVersion(): %s", /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(NVRTC_err));
			return -1;
		} 
		return 0;
	}
	// CUDA
	public int cuda_init() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(cuda, 0, /*Error: Unsupported expression*/);
		cuda.setLib(ModernizedCProgram.hc_dlopen("nvcuda.dll"));
		if (cuda.getLib() == (null)) {
			return -1;
		} 
		// finding the right symbol is a PITA, because of the _v2 suffix// a good reference is cuda.h itself// this needs to be verified for each new cuda release// finding the right symbol is a PITA, because of the _v2 suffix// a good reference is cuda.h itself// this needs to be verified for each new cuda releasecuda.setCuCtxCreate((CUDA_CUCTXCREATE)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuCtxCreate_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuCtxCreate()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuCtxCreate", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuCtxCreate", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuCtxDestroy((CUDA_CUCTXDESTROY)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuCtxDestroy_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuCtxDestroy()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuCtxDestroy", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuCtxDestroy", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuCtxGetCacheConfig((CUDA_CUCTXGETCACHECONFIG)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuCtxGetCacheConfig"));
		if ((true) != -1) {
			if (!(cuda).getCuCtxGetCacheConfig()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuCtxGetCacheConfig", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuCtxGetCacheConfig", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuCtxGetCurrent((CUDA_CUCTXGETCURRENT)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuCtxGetCurrent"));
		if ((true) != -1) {
			if (!(cuda).getCuCtxGetCurrent()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuCtxGetCurrent", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuCtxGetCurrent", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuCtxGetSharedMemConfig((CUDA_CUCTXGETSHAREDMEMCONFIG)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuCtxGetSharedMemConfig"));
		if ((true) != -1) {
			if (!(cuda).getCuCtxGetSharedMemConfig()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuCtxGetSharedMemConfig", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuCtxGetSharedMemConfig", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuCtxPopCurrent((CUDA_CUCTXPOPCURRENT)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuCtxPopCurrent_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuCtxPopCurrent()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuCtxPopCurrent", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuCtxPopCurrent", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuCtxPushCurrent((CUDA_CUCTXPUSHCURRENT)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuCtxPushCurrent_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuCtxPushCurrent()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuCtxPushCurrent", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuCtxPushCurrent", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuCtxSetCacheConfig((CUDA_CUCTXSETCACHECONFIG)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuCtxSetCacheConfig"));
		if ((true) != -1) {
			if (!(cuda).getCuCtxSetCacheConfig()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuCtxSetCacheConfig", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuCtxSetCacheConfig", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuCtxSetCurrent((CUDA_CUCTXSETCURRENT)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuCtxSetCurrent"));
		if ((true) != -1) {
			if (!(cuda).getCuCtxSetCurrent()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuCtxSetCurrent", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuCtxSetCurrent", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuCtxSetSharedMemConfig((CUDA_CUCTXSETSHAREDMEMCONFIG)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuCtxSetSharedMemConfig"));
		if ((true) != -1) {
			if (!(cuda).getCuCtxSetSharedMemConfig()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuCtxSetSharedMemConfig", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuCtxSetSharedMemConfig", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuCtxSynchronize((CUDA_CUCTXSYNCHRONIZE)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuCtxSynchronize"));
		if ((true) != -1) {
			if (!(cuda).getCuCtxSynchronize()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuCtxSynchronize", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuCtxSynchronize", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuDeviceGetAttribute((CUDA_CUDEVICEGETATTRIBUTE)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuDeviceGetAttribute"));
		if ((true) != -1) {
			if (!(cuda).getCuDeviceGetAttribute()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuDeviceGetAttribute", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuDeviceGetAttribute", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuDeviceGetCount((CUDA_CUDEVICEGETCOUNT)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuDeviceGetCount"));
		if ((true) != -1) {
			if (!(cuda).getCuDeviceGetCount()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuDeviceGetCount", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuDeviceGetCount", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuDeviceGet((CUDA_CUDEVICEGET)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuDeviceGet"));
		if ((true) != -1) {
			if (!(cuda).getCuDeviceGet()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuDeviceGet", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuDeviceGet", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuDeviceGetName((CUDA_CUDEVICEGETNAME)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuDeviceGetName"));
		if ((true) != -1) {
			if (!(cuda).getCuDeviceGetName()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuDeviceGetName", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuDeviceGetName", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuDeviceTotalMem((CUDA_CUDEVICETOTALMEM)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuDeviceTotalMem_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuDeviceTotalMem()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuDeviceTotalMem", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuDeviceTotalMem", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuDriverGetVersion((CUDA_CUDRIVERGETVERSION)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuDriverGetVersion"));
		if ((true) != -1) {
			if (!(cuda).getCuDriverGetVersion()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuDriverGetVersion", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuDriverGetVersion", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuEventCreate((CUDA_CUEVENTCREATE)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuEventCreate"));
		if ((true) != -1) {
			if (!(cuda).getCuEventCreate()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuEventCreate", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuEventCreate", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuEventDestroy((CUDA_CUEVENTDESTROY)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuEventDestroy_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuEventDestroy()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuEventDestroy", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuEventDestroy", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuEventElapsedTime((CUDA_CUEVENTELAPSEDTIME)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuEventElapsedTime"));
		if ((true) != -1) {
			if (!(cuda).getCuEventElapsedTime()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuEventElapsedTime", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuEventElapsedTime", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuEventQuery((CUDA_CUEVENTQUERY)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuEventQuery"));
		if ((true) != -1) {
			if (!(cuda).getCuEventQuery()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuEventQuery", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuEventQuery", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuEventRecord((CUDA_CUEVENTRECORD)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuEventRecord"));
		if ((true) != -1) {
			if (!(cuda).getCuEventRecord()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuEventRecord", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuEventRecord", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuEventSynchronize((CUDA_CUEVENTSYNCHRONIZE)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuEventSynchronize"));
		if ((true) != -1) {
			if (!(cuda).getCuEventSynchronize()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuEventSynchronize", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuEventSynchronize", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuFuncGetAttribute((CUDA_CUFUNCGETATTRIBUTE)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuFuncGetAttribute"));
		if ((true) != -1) {
			if (!(cuda).getCuFuncGetAttribute()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuFuncGetAttribute", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuFuncGetAttribute", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuFuncSetAttribute((CUDA_CUFUNCSETATTRIBUTE)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuFuncSetAttribute"));
		if ((true) != -1) {
			if (!(cuda).getCuFuncSetAttribute()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuFuncSetAttribute", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuFuncSetAttribute", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuFuncSetCacheConfig((CUDA_CUFUNCSETCACHECONFIG)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuFuncSetCacheConfig"));
		if ((true) != -1) {
			if (!(cuda).getCuFuncSetCacheConfig()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuFuncSetCacheConfig", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuFuncSetCacheConfig", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuFuncSetSharedMemConfig((CUDA_CUFUNCSETSHAREDMEMCONFIG)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuFuncSetSharedMemConfig"));
		if ((true) != -1) {
			if (!(cuda).getCuFuncSetSharedMemConfig()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuFuncSetSharedMemConfig", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuFuncSetSharedMemConfig", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuGetErrorName((CUDA_CUGETERRORNAME)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuGetErrorName"));
		if ((true) != -1) {
			if (!(cuda).getCuGetErrorName()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuGetErrorName", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuGetErrorName", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuGetErrorString((CUDA_CUGETERRORSTRING)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuGetErrorString"));
		if ((true) != -1) {
			if (!(cuda).getCuGetErrorString()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuGetErrorString", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuGetErrorString", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuInit((CUDA_CUINIT)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuInit"));
		if ((true) != -1) {
			if (!(cuda).getCuInit()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuInit", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuInit", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuLaunchKernel((CUDA_CULAUNCHKERNEL)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuLaunchKernel"));
		if ((true) != -1) {
			if (!(cuda).getCuLaunchKernel()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuLaunchKernel", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuLaunchKernel", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuMemAlloc((CUDA_CUMEMALLOC)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuMemAlloc_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuMemAlloc()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuMemAlloc", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuMemAlloc", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuMemAllocHost((CUDA_CUMEMALLOCHOST)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuMemAllocHost_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuMemAllocHost()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuMemAllocHost", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuMemAllocHost", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuMemcpyDtoD((CUDA_CUMEMCPYDTOD)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuMemcpyDtoD_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuMemcpyDtoD()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuMemcpyDtoD", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuMemcpyDtoD", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuMemcpyDtoH((CUDA_CUMEMCPYDTOH)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuMemcpyDtoH_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuMemcpyDtoH()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuMemcpyDtoH", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuMemcpyDtoH", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuMemcpyHtoD((CUDA_CUMEMCPYHTOD)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuMemcpyHtoD_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuMemcpyHtoD()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuMemcpyHtoD", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuMemcpyHtoD", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuMemFree((CUDA_CUMEMFREE)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuMemFree_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuMemFree()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuMemFree", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuMemFree", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuMemFreeHost((CUDA_CUMEMFREEHOST)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuMemFreeHost"));
		if ((true) != -1) {
			if (!(cuda).getCuMemFreeHost()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuMemFreeHost", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuMemFreeHost", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuMemGetInfo((CUDA_CUMEMGETINFO)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuMemGetInfo_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuMemGetInfo()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuMemGetInfo", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuMemGetInfo", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuMemsetD32((CUDA_CUMEMSETD32)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuMemsetD32_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuMemsetD32()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuMemsetD32", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuMemsetD32", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuMemsetD8((CUDA_CUMEMSETD8)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuMemsetD8_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuMemsetD8()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuMemsetD8", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuMemsetD8", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuModuleGetFunction((CUDA_CUMODULEGETFUNCTION)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuModuleGetFunction"));
		if ((true) != -1) {
			if (!(cuda).getCuModuleGetFunction()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuModuleGetFunction", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuModuleGetFunction", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuModuleGetGlobal((CUDA_CUMODULEGETGLOBAL)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuModuleGetGlobal_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuModuleGetGlobal()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuModuleGetGlobal", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuModuleGetGlobal", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuModuleLoad((CUDA_CUMODULELOAD)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuModuleLoad"));
		if ((true) != -1) {
			if (!(cuda).getCuModuleLoad()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuModuleLoad", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuModuleLoad", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuModuleLoadData((CUDA_CUMODULELOADDATA)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuModuleLoadData"));
		if ((true) != -1) {
			if (!(cuda).getCuModuleLoadData()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuModuleLoadData", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuModuleLoadData", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuModuleLoadDataEx((CUDA_CUMODULELOADDATAEX)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuModuleLoadDataEx"));
		if ((true) != -1) {
			if (!(cuda).getCuModuleLoadDataEx()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuModuleLoadDataEx", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuModuleLoadDataEx", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuModuleUnload((CUDA_CUMODULEUNLOAD)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuModuleUnload"));
		if ((true) != -1) {
			if (!(cuda).getCuModuleUnload()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuModuleUnload", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuModuleUnload", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuProfilerStart((CUDA_CUPROFILERSTART)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuProfilerStart"));
		if ((true) != -1) {
			if (!(cuda).getCuProfilerStart()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuProfilerStart", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuProfilerStart", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuProfilerStop((CUDA_CUPROFILERSTOP)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuProfilerStop"));
		if ((true) != -1) {
			if (!(cuda).getCuProfilerStop()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuProfilerStop", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuProfilerStop", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuStreamCreate((CUDA_CUSTREAMCREATE)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuStreamCreate"));
		if ((true) != -1) {
			if (!(cuda).getCuStreamCreate()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuStreamCreate", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuStreamCreate", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuStreamDestroy((CUDA_CUSTREAMDESTROY)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuStreamDestroy_v2"));
		if ((true) != -1) {
			if (!(cuda).getCuStreamDestroy()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuStreamDestroy", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuStreamDestroy", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuStreamSynchronize((CUDA_CUSTREAMSYNCHRONIZE)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuStreamSynchronize"));
		if ((true) != -1) {
			if (!(cuda).getCuStreamSynchronize()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuStreamSynchronize", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuStreamSynchronize", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		cuda.setCuStreamWaitEvent((CUDA_CUSTREAMWAITEVENT)ModernizedCProgram.hc_dlsym((cuda).getLib(), "cuStreamWaitEvent"));
		if ((true) != -1) {
			if (!(cuda).getCuStreamWaitEvent()) {
				if ((true) == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "cuStreamWaitEvent", "CUDA");
					return -1;
				} 
				if ((true) != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "cuStreamWaitEvent", "CUDA");
					return 0;
				} 
			} 
		} 
		;
		return 0;
	}
	public void cuda_close() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		if (cuda) {
			if (cuda.getLib()) {
				ModernizedCProgram.hc_dlclose(cuda.getLib());
			} 
			ModernizedCProgram.hcfree(generatedCuda);
			backend_ctx.setCuda((null));
		} 
	}
	public int hc_cuInit(int Flags) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(Flags);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuInit(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuInit(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuDeviceGetAttribute(Integer pi, CUdevice_attribute_enum attrib, Object dev) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pi, attrib, dev);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuDeviceGetAttribute(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuDeviceGetAttribute(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuDeviceGetCount(Integer count) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(count);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuDeviceGetCount(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuDeviceGetCount(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuDeviceGet(Object device, int ordinal) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(device, ordinal);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuDeviceGet(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuDeviceGet(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuDeviceGetName(Byte name, int len, Object dev) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(name, len, dev);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuDeviceGetName(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuDeviceGetName(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuDeviceTotalMem(Object bytes, Object dev) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(bytes, dev);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuDeviceTotalMem(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuDeviceTotalMem(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuDriverGetVersion(Integer driverVersion) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(driverVersion);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuDriverGetVersion(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuDriverGetVersion(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuCtxCreate(Object pctx, int flags, Object dev) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pctx, flags, dev);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuCtxCreate(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuCtxCreate(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuCtxDestroy(Object ctx) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(ctx);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuCtxDestroy(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuCtxDestroy(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuModuleLoadDataEx(Object module, Object image, int numOptions, CUjit_option_enum options, Object optionValues) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(module, image, numOptions, options, optionValues);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuModuleLoadDataEx(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuModuleLoadDataEx(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuModuleLoadDataExLog(Object module, Object image) {
		Byte info_log = ModernizedCProgram.hcmalloc(8192);
		Byte error_log = ModernizedCProgram.hcmalloc(8192);
		CUjit_option[] opts = new CUjit_option();
		Object[][] vals = new Object[6];
		opts[0] = CUjit_option_enum.CU_JIT_TARGET_FROM_CUCONTEXT;
		vals[0] = null;
		opts[1] = CUjit_option_enum.CU_JIT_LOG_VERBOSE;
		vals[1] = (Object)1;
		opts[2] = CUjit_option_enum.CU_JIT_INFO_LOG_BUFFER;
		vals[2] = (Object)info_log;
		opts[3] = CUjit_option_enum.CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;
		vals[3] = (Object)8192;
		opts[4] = CUjit_option_enum.CU_JIT_ERROR_LOG_BUFFER;
		vals[4] = (Object)error_log;
		opts[5] = CUjit_option_enum.CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES;
		vals[5] = (Object)8192;
		int rc_cuModuleLoadDataEx = hashcat_ctx.hc_cuModuleLoadDataEx(module, image, 6, opts, vals);
		if (rc_cuModuleLoadDataEx == -1) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("cuModuleLoadDataEx() Info Log (%d):\n%s\n\n", (int)/*Error: Function owner not recognized*/strlen(info_log), info_log);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("cuModuleLoadDataEx() Error Log (%d):\n%s\n\n", (int)/*Error: Function owner not recognized*/strlen(error_log), error_log);
		} 
		ModernizedCProgram.hcfree(info_log);
		ModernizedCProgram.hcfree(error_log);
		return rc_cuModuleLoadDataEx;
	}
	public int hc_cuModuleUnload(Object hmod) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hmod);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuModuleUnload(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuModuleUnload(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuCtxSetCurrent(Object ctx) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(ctx);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuCtxSetCurrent(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuCtxSetCurrent(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuMemAlloc(Object dptr, Object bytesize) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(dptr, bytesize);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuMemAlloc(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuMemAlloc(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuMemFree(Object dptr) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(dptr);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuMemFree(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuMemFree(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuMemcpyDtoH(Object dstHost, Object srcDevice, Object ByteCount) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(dstHost, srcDevice, ByteCount);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuMemcpyDtoH(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuMemcpyDtoH(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuMemcpyDtoD(Object dstDevice, Object srcDevice, Object ByteCount) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(dstDevice, srcDevice, ByteCount);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuMemcpyDtoD(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuMemcpyDtoD(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuMemcpyHtoD(Object dstDevice, Object srcHost, Object ByteCount) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(dstDevice, srcHost, ByteCount);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuMemcpyHtoD(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuMemcpyHtoD(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuModuleGetFunction(Object hfunc, Object hmod, Object name) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hfunc, hmod, name);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuModuleGetFunction(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuModuleGetFunction(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuModuleGetGlobal(Object dptr, Object bytes, Object hmod, Object name) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(dptr, bytes, hmod, name);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuModuleGetGlobal(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuModuleGetGlobal(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuMemGetInfo(Object free, Object total) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(free, total);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuMemGetInfo(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuMemGetInfo(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuFuncGetAttribute(Integer pi, CUfunction_attribute_enum attrib, Object hfunc) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pi, attrib, hfunc);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuFuncGetAttribute(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuFuncGetAttribute(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuFuncSetAttribute(Object hfunc, CUfunction_attribute_enum attrib, int value) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hfunc, attrib, value);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuFuncSetAttribute(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuFuncSetAttribute(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuStreamCreate(Object phStream, int Flags) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(phStream, Flags);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuStreamCreate(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuStreamCreate(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuStreamDestroy(Object hStream) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hStream);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuStreamDestroy(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuStreamDestroy(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuStreamSynchronize(Object hStream) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hStream);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuStreamSynchronize(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuStreamSynchronize(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuLaunchKernel(Object f, int gridDimX, int gridDimY, int gridDimZ, int blockDimX, int blockDimY, int blockDimZ, int sharedMemBytes, Object hStream, Object kernelParams, Object extra) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, hStream, kernelParams, extra);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuLaunchKernel(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuLaunchKernel(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuCtxSynchronize() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME();
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuCtxSynchronize(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuCtxSynchronize(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuEventCreate(Object phEvent, int Flags) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(phEvent, Flags);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuEventCreate(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuEventCreate(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuEventDestroy(Object hEvent) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hEvent);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuEventDestroy(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuEventDestroy(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuEventElapsedTime(Double pMilliseconds, Object hStart, Object hEnd) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pMilliseconds, hStart, hEnd);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuEventElapsedTime(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuEventElapsedTime(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuEventQuery(Object hEvent) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hEvent);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuEventQuery(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuEventQuery(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuEventRecord(Object hEvent, Object hStream) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hEvent, hStream);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuEventRecord(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuEventRecord(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuEventSynchronize(Object hEvent) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hEvent);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuEventSynchronize(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuEventSynchronize(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuCtxSetCacheConfig(CUfunc_cache_enum config) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(config);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuCtxSetCacheConfig(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuCtxSetCacheConfig(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuCtxPushCurrent(Object ctx) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(ctx);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuCtxPushCurrent(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuCtxPushCurrent(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	public int hc_cuCtxPopCurrent(Object pctx) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedCuda = backend_ctx.getCuda();
		CUDA_PTR cuda = generatedCuda;
		CUresult CU_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(pctx);
		if (CU_err != cudaError_enum.CUDA_SUCCESS) {
			Byte pStr = (null);
			if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(CU_err, pStr) == cudaError_enum.CUDA_SUCCESS) {
				hashcat_ctx.event_log_error("cuCtxPopCurrent(): %s", pStr);
			} else {
					hashcat_ctx.event_log_error("cuCtxPopCurrent(): %d", CU_err);
			} 
			return -1;
		} 
		return 0;
	}
	// OpenCL
	public int ocl_init() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(ocl, 0, /*Error: Unsupported expression*/);
		ocl.setLib(ModernizedCProgram.hc_dlopen("OpenCL"));
		if (ocl.getLib() == (null)) {
			return -1;
		} 
		ocl.setClBuildProgram(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clBuildProgram"));
		if (1 != -1) {
			if (!ocl.getClBuildProgram()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clBuildProgram", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clBuildProgram", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClCreateBuffer(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clCreateBuffer"));
		if (1 != -1) {
			if (!ocl.getClCreateBuffer()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clCreateBuffer", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clCreateBuffer", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClCreateCommandQueue(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clCreateCommandQueue"));
		if (1 != -1) {
			if (!ocl.getClCreateCommandQueue()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clCreateCommandQueue", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clCreateCommandQueue", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClCreateContext(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clCreateContext"));
		if (1 != -1) {
			if (!ocl.getClCreateContext()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clCreateContext", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clCreateContext", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClCreateKernel(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clCreateKernel"));
		if (1 != -1) {
			if (!ocl.getClCreateKernel()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clCreateKernel", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clCreateKernel", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClCreateProgramWithBinary(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clCreateProgramWithBinary"));
		if (1 != -1) {
			if (!ocl.getClCreateProgramWithBinary()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clCreateProgramWithBinary", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clCreateProgramWithBinary", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClCreateProgramWithSource(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clCreateProgramWithSource"));
		if (1 != -1) {
			if (!ocl.getClCreateProgramWithSource()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clCreateProgramWithSource", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clCreateProgramWithSource", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClEnqueueCopyBuffer(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clEnqueueCopyBuffer"));
		if (1 != -1) {
			if (!ocl.getClEnqueueCopyBuffer()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clEnqueueCopyBuffer", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clEnqueueCopyBuffer", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClEnqueueMapBuffer(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clEnqueueMapBuffer"));
		if (1 != -1) {
			if (!ocl.getClEnqueueMapBuffer()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clEnqueueMapBuffer", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clEnqueueMapBuffer", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClEnqueueNDRangeKernel(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clEnqueueNDRangeKernel"));
		if (1 != -1) {
			if (!ocl.getClEnqueueNDRangeKernel()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clEnqueueNDRangeKernel", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clEnqueueNDRangeKernel", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClEnqueueReadBuffer(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clEnqueueReadBuffer"));
		if (1 != -1) {
			if (!ocl.getClEnqueueReadBuffer()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clEnqueueReadBuffer", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clEnqueueReadBuffer", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClEnqueueUnmapMemObject(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clEnqueueUnmapMemObject"));
		if (1 != -1) {
			if (!ocl.getClEnqueueUnmapMemObject()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clEnqueueUnmapMemObject", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clEnqueueUnmapMemObject", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClEnqueueWriteBuffer(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clEnqueueWriteBuffer"));
		if (1 != -1) {
			if (!ocl.getClEnqueueWriteBuffer()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clEnqueueWriteBuffer", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clEnqueueWriteBuffer", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClFinish(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clFinish"));
		if (1 != -1) {
			if (!ocl.getClFinish()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clFinish", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clFinish", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClFlush(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clFlush"));
		if (1 != -1) {
			if (!ocl.getClFlush()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clFlush", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clFlush", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClGetDeviceIDs(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clGetDeviceIDs"));
		if (1 != -1) {
			if (!ocl.getClGetDeviceIDs()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clGetDeviceIDs", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clGetDeviceIDs", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClGetDeviceInfo(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clGetDeviceInfo"));
		if (1 != -1) {
			if (!ocl.getClGetDeviceInfo()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clGetDeviceInfo", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clGetDeviceInfo", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClGetEventInfo(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clGetEventInfo"));
		if (1 != -1) {
			if (!ocl.getClGetEventInfo()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clGetEventInfo", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clGetEventInfo", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClGetKernelWorkGroupInfo(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clGetKernelWorkGroupInfo"));
		if (1 != -1) {
			if (!ocl.getClGetKernelWorkGroupInfo()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clGetKernelWorkGroupInfo", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clGetKernelWorkGroupInfo", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClGetPlatformIDs(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clGetPlatformIDs"));
		if (1 != -1) {
			if (!ocl.getClGetPlatformIDs()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clGetPlatformIDs", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clGetPlatformIDs", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClGetPlatformInfo(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clGetPlatformInfo"));
		if (1 != -1) {
			if (!ocl.getClGetPlatformInfo()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clGetPlatformInfo", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clGetPlatformInfo", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClGetProgramBuildInfo(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clGetProgramBuildInfo"));
		if (1 != -1) {
			if (!ocl.getClGetProgramBuildInfo()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clGetProgramBuildInfo", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clGetProgramBuildInfo", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClGetProgramInfo(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clGetProgramInfo"));
		if (1 != -1) {
			if (!ocl.getClGetProgramInfo()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clGetProgramInfo", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clGetProgramInfo", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClReleaseCommandQueue(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clReleaseCommandQueue"));
		if (1 != -1) {
			if (!ocl.getClReleaseCommandQueue()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clReleaseCommandQueue", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clReleaseCommandQueue", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClReleaseContext(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clReleaseContext"));
		if (1 != -1) {
			if (!ocl.getClReleaseContext()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clReleaseContext", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clReleaseContext", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClReleaseKernel(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clReleaseKernel"));
		if (1 != -1) {
			if (!ocl.getClReleaseKernel()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clReleaseKernel", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clReleaseKernel", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClReleaseMemObject(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clReleaseMemObject"));
		if (1 != -1) {
			if (!ocl.getClReleaseMemObject()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clReleaseMemObject", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clReleaseMemObject", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClReleaseProgram(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clReleaseProgram"));
		if (1 != -1) {
			if (!ocl.getClReleaseProgram()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clReleaseProgram", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clReleaseProgram", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClSetKernelArg(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clSetKernelArg"));
		if (1 != -1) {
			if (!ocl.getClSetKernelArg()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clSetKernelArg", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clSetKernelArg", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClWaitForEvents(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clWaitForEvents"));
		if (1 != -1) {
			if (!ocl.getClWaitForEvents()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clWaitForEvents", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clWaitForEvents", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClGetEventProfilingInfo(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clGetEventProfilingInfo"));
		if (1 != -1) {
			if (!ocl.getClGetEventProfilingInfo()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clGetEventProfilingInfo", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clGetEventProfilingInfo", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		ocl.setClReleaseEvent(()ModernizedCProgram.hc_dlsym(ocl.getLib(), "clReleaseEvent"));
		if (1 != -1) {
			if (!ocl.getClReleaseEvent()) {
				if (1 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "clReleaseEvent", "OpenCL");
					return -1;
				} 
				if (1 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "clReleaseEvent", "OpenCL");
					return 0;
				} 
			} 
		} 
		;
		return 0;
	}
	public void ocl_close() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		if (ocl) {
			if (ocl.getLib()) {
				ModernizedCProgram.hc_dlclose(ocl.getLib());
			} 
			ModernizedCProgram.hcfree(generatedOcl);
			backend_ctx.setOcl((null));
		} 
	}
	public int hc_clEnqueueNDRangeKernel(Object command_queue, Object kernel, Object work_dim, Object global_work_offset, Object global_work_size, Object local_work_size, Object num_events_in_wait_list, Object event_wait_list, Object event) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clEnqueueNDRangeKernel(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clGetEventInfo(Object event, Object param_name, Object param_value_size, Object param_value, Object param_value_size_ret) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(event, param_name, param_value_size, param_value, param_value_size_ret);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clGetEventInfo(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clFlush(Object command_queue) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clFlush(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clFinish(Object command_queue) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clFinish(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clSetKernelArg(Object kernel, Object arg_index, Object arg_size, Object arg_value) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(kernel, arg_index, arg_size, arg_value);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clSetKernelArg(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clEnqueueWriteBuffer(Object command_queue, Object buffer, Object blocking_write, Object offset, Object size, Object ptr, Object num_events_in_wait_list, Object event_wait_list, Object event) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clEnqueueWriteBuffer(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clEnqueueCopyBuffer(Object command_queue, Object src_buffer, Object dst_buffer, Object src_offset, Object dst_offset, Object size, Object num_events_in_wait_list, Object event_wait_list, Object event) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, event);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clEnqueueCopyBuffer(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clEnqueueReadBuffer(Object command_queue, Object buffer, Object blocking_read, Object offset, Object size, Object ptr, Object num_events_in_wait_list, Object event_wait_list, Object event) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clEnqueueReadBuffer(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clGetPlatformIDs(Object num_entries, Object platforms, Object num_platforms) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(num_entries, platforms, num_platforms);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clGetPlatformIDs(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clGetPlatformInfo(Object platform, Object param_name, Object param_value_size, Object param_value, Object param_value_size_ret) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(platform, param_name, param_value_size, param_value, param_value_size_ret);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clGetPlatformInfo(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clGetDeviceIDs(Object platform, Object device_type, Object num_entries, Object devices, Object num_devices) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(platform, device_type, num_entries, devices, num_devices);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clGetDeviceIDs(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clGetDeviceInfo(Object device, Object param_name, Object param_value_size, Object param_value, Object param_value_size_ret) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(device, param_name, param_value_size, param_value, param_value_size_ret);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clGetDeviceInfo(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clCreateCommandQueue(Object context, Object device, Object properties, Object command_queue) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = new cl_int();
		command_queue = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(context, device, properties, CL_err);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clCreateCommandQueue(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clCreateBuffer(Object context, Object flags, Object size, Object host_ptr, Object mem) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = new cl_int();
		mem = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(context, flags, size, host_ptr, CL_err);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clCreateBuffer(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clCreateProgramWithSource(Object context, Object count, Object strings, Object lengths, Object program) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = new cl_int();
		program = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(context, count, strings, lengths, CL_err);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clCreateProgramWithSource(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clCreateProgramWithBinary(Object context, Object num_devices, Object device_list, Object lengths, Object binaries, Object binary_status, Object program) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = new cl_int();
		program = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(context, num_devices, device_list, lengths, binaries, binary_status, CL_err);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clCreateProgramWithBinary(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clCreateKernel(Object program, Object kernel_name, Object kernel) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = new cl_int();
		kernel = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(program, kernel_name, CL_err);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clCreateKernel(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clReleaseMemObject(Object mem) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(mem);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clReleaseMemObject(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clReleaseKernel(Object kernel) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(kernel);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clReleaseKernel(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clReleaseProgram(Object program) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(program);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clReleaseProgram(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clReleaseCommandQueue(Object command_queue) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clReleaseCommandQueue(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clReleaseContext(Object context) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(context);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clReleaseContext(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clEnqueueMapBuffer(Object command_queue, Object buffer, Object blocking_map, Object map_flags, Object offset, Object size, Object num_events_in_wait_list, Object event_wait_list, Object event, Object buf) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = new cl_int();
		buf = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list, event, CL_err);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clEnqueueMapBuffer(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clEnqueueUnmapMemObject(Object command_queue, Object memobj, Object mapped_ptr, Object num_events_in_wait_list, Object event_wait_list, Object event) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, event);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clEnqueueUnmapMemObject(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clGetKernelWorkGroupInfo(Object kernel, Object device, Object param_name, Object param_value_size, Object param_value, Object param_value_size_ret) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(kernel, device, param_name, param_value_size, param_value, param_value_size_ret);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clGetKernelWorkGroupInfo(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clGetProgramBuildInfo(Object program, Object device, Object param_name, Object param_value_size, Object param_value, Object param_value_size_ret) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(program, device, param_name, param_value_size, param_value, param_value_size_ret);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clGetProgramBuildInfo(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clGetProgramInfo(Object program, Object param_name, Object param_value_size, Object param_value, Object param_value_size_ret) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(program, param_name, param_value_size, param_value, param_value_size_ret);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clGetProgramInfo(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clWaitForEvents(Object num_events, Object event_list) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(num_events, event_list);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clWaitForEvents(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clGetEventProfilingInfo(Object event, Object param_name, Object param_value_size, Object param_value, Object param_value_size_ret) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(event, param_name, param_value_size, param_value, param_value_size_ret);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clGetEventProfilingInfo(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int hc_clReleaseEvent(Object event) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		Object generatedOcl = backend_ctx.getOcl();
		OCL_PTR ocl = generatedOcl;
		cl_int CL_err = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(event);
		if (CL_err != CL_SUCCESS) {
			hashcat_ctx.event_log_error("clReleaseEvent(): %s", ModernizedCProgram.val2cstr_cl(CL_err));
			return -1;
		} 
		return 0;
	}
	public int backend_ctx_init() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		backend_ctx.setEnabled(0);
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		hc_device_param_t devices_param = (hc_device_param_t)ModernizedCProgram.hccalloc(64, /*Error: Unsupported expression*/);
		backend_ctx.setDevices_param(devices_param/**
		   * Load and map CUDA library calls, then init CUDA
		   */);
		CUDA_PTR cuda = (CUDA_PTR)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		backend_ctx.setCuda(cuda);
		int rc_cuda_init = hashcat_ctx.cuda_init();
		if (rc_cuda_init == -1) {
			hashcat_ctx/**
			   * Load and map NVRTC library calls
			   */.cuda_close();
		} 
		NVRTC_PTR nvrtc = (NVRTC_PTR)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		backend_ctx.setNvrtc(nvrtc);
		int rc_nvrtc_init = hashcat_ctx.nvrtc_init();
		if (rc_nvrtc_init == -1) {
			hashcat_ctx/**
			   * Check if both CUDA and NVRTC were load successful
			   */.nvrtc_close();
		} 
		if ((rc_cuda_init == 0) && (rc_nvrtc_init == 0)) {
			int nvrtc_major = 0;
			int nvrtc_minor = 0;
			if (hashcat_ctx.hc_nvrtcVersion(nvrtc_major, nvrtc_minor) == -1) {
				return -1;
			} 
			int nvrtc_driver_version = (nvrtc_major * 1000) + (nvrtc_minor * 10);
			backend_ctx.setNvrtc_driver_version(nvrtc_driver_version);
			int cuda_driver_version = 0;
			if (hashcat_ctx.hc_cuDriverGetVersion(cuda_driver_version) == -1) {
				return -1;
			} 
			backend_ctx.setCuda_driver_version(cuda_driver_version);
			if ((nvrtc_driver_version < 10010) || (cuda_driver_version < 10010)) {
				hashcat_ctx.event_log_error("Outdated NVIDIA CUDA Toolkit version '%d' detected!", cuda_driver_version);
				hashcat_ctx.event_log_warning("See hashcat.net for officially supported NVIDIA CUDA Toolkit versions.");
				hashcat_ctx.event_log_warning((null));
				return -1;
			} 
		} else {
				rc_cuda_init = -1;
				rc_nvrtc_init = -1;
				hashcat_ctx.cuda_close();
				hashcat_ctx/**
				   * Load and map OpenCL library calls
				   */.nvrtc_close();
		} 
		// nvrtc version
		OCL_PTR ocl = (OCL_PTR)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		backend_ctx.setOcl(ocl);
		int rc_ocl_init = hashcat_ctx.ocl_init();
		if (rc_ocl_init == -1) {
			hashcat_ctx/**
			   * return if both CUDA and OpenCL initialization failed
			   */.ocl_close();
		} 
		if ((rc_cuda_init == -1) && (rc_ocl_init == -1)) {
			hashcat_ctx.event_log_error("ATTENTION! No OpenCL or CUDA installation found.");
			hashcat_ctx.event_log_warning("You are probably missing the CUDA or OpenCL runtime installation.");
			hashcat_ctx.event_log_warning((null));
			hashcat_ctx.event_log_warning("* AMD GPUs on Windows require this driver:");
			hashcat_ctx.event_log_warning("  \"AMD Radeon Software Crimson Edition\" (15.12 or later)");
			hashcat_ctx.event_log_warning("* Intel CPUs require this runtime:");
			hashcat_ctx.event_log_warning("  \"OpenCL Runtime for Intel Core and Intel Xeon Processors\" (16.1.1 or later)");
			hashcat_ctx.event_log_warning("* Intel GPUs on Windows require this driver:");
			hashcat_ctx.event_log_warning("  \"OpenCL Driver for Intel Iris and Intel HD Graphics\"");
			hashcat_ctx.event_log_warning("* NVIDIA GPUs require this runtime and/or driver (both):");
			hashcat_ctx.event_log_warning("  \"NVIDIA Driver\" (418.56 or later)");
			hashcat_ctx.event_log_warning("  \"CUDA Toolkit\" (10.1 or later)");
			hashcat_ctx.event_log_warning((null));
			return -1/**
			   * Some permission pre-check, because AMDGPU-PRO Driver crashes if the user has no permission to do this
			   */;
		} 
		if (hashcat_ctx.ocl_check_dri() == -1) {
			return -1/**
			   * Backend device selection
			   */;
		} 
		u64 backend_devices_filter = new u64();
		Byte generatedBackend_devices = user_options.getBackend_devices();
		if (hashcat_ctx.setup_backend_devices_filter(generatedBackend_devices, backend_devices_filter) == 0) {
			return -1;
		} 
		backend_ctx.setBackend_devices_filter(backend_devices_filter/**
		   * OpenCL device type selection
		   */);
		 opencl_device_types_filter = new ();
		Byte generatedOpencl_device_types = user_options.getOpencl_device_types();
		if (hashcat_ctx.setup_opencl_device_types_filter(generatedOpencl_device_types, opencl_device_types_filter) == 0) {
			return -1;
		} 
		backend_ctx.setOpencl_device_types_filter(opencl_device_types_filter/**
		   * CUDA API: init
		   */);
		Object generatedCuda = backend_ctx.getCuda();
		if (generatedCuda) {
			if (hashcat_ctx.hc_cuInit(0) == -1) {
				hashcat_ctx.cuda_close();
			} 
		} 
		Object generatedOcl = backend_ctx.getOcl();
		boolean generatedStdout_flag = user_options.getStdout_flag();
		if (generatedOcl) {
			 opencl_platforms = ()ModernizedCProgram.hccalloc(16, /*Error: Unsupported expression*/);
			 opencl_platforms_cnt = 0;
			 opencl_platforms_devices = ()ModernizedCProgram.hccalloc(16, /*Error: Unsupported expression*/);
			 opencl_platforms_devices_cnt = ()ModernizedCProgram.hccalloc(16, /*Error: Unsupported expression*/);
			Byte opencl_platforms_name = (byte)ModernizedCProgram.hccalloc(16, /*Error: Unsupported expression*/);
			Byte opencl_platforms_vendor = (byte)ModernizedCProgram.hccalloc(16, /*Error: Unsupported expression*/);
			 opencl_platforms_vendor_id = ()ModernizedCProgram.hccalloc(16, /*Error: Unsupported expression*/);
			Byte opencl_platforms_version = (byte)ModernizedCProgram.hccalloc(16, /*Error: Unsupported expression*/);
			if (hashcat_ctx.hc_clGetPlatformIDs(16, opencl_platforms, opencl_platforms_cnt) == -1) {
				opencl_platforms_cnt = 0;
				{ 
					ModernizedCProgram.hcfree(opencl_platforms);
					ModernizedCProgram.hcfree(opencl_platforms_devices);
					ModernizedCProgram.hcfree(opencl_platforms_devices_cnt);
					ModernizedCProgram.hcfree(opencl_platforms_name);
					ModernizedCProgram.hcfree(opencl_platforms_vendor);
					ModernizedCProgram.hcfree(opencl_platforms_vendor_id);
					ModernizedCProgram.hcfree(opencl_platforms_version);
				}
				;
				hashcat_ctx.ocl_close();
			} 
			if (opencl_platforms_cnt) {
				for (u32 opencl_platforms_idx = 0;
				 opencl_platforms_idx < opencl_platforms_cnt; opencl_platforms_idx++) {
					 opencl_platform = opencl_platforms[opencl_platforms_idx];
					size_t param_value_size = 0;
					if (hashcat_ctx.hc_clGetPlatformInfo(opencl_platform, CL_PLATFORM_VENDOR, 0, (null), param_value_size) == -1) {
						return -1;
					} 
					Byte opencl_platform_vendor = (byte)ModernizedCProgram.hcmalloc(param_value_size);
					if (hashcat_ctx.hc_clGetPlatformInfo(opencl_platform, CL_PLATFORM_VENDOR, param_value_size, opencl_platform_vendor, (null)) == -1) {
						return -1;
					} 
					opencl_platforms_vendor[opencl_platforms_idx] = opencl_platform_vendor;
					if (hashcat_ctx.hc_clGetPlatformInfo(opencl_platform, CL_PLATFORM_NAME, 0, (null), param_value_size) == -1) {
						return -1;
					} 
					Byte opencl_platform_name = (byte)ModernizedCProgram.hcmalloc(param_value_size);
					if (hashcat_ctx.hc_clGetPlatformInfo(opencl_platform, CL_PLATFORM_NAME, param_value_size, opencl_platform_name, (null)) == -1) {
						return -1;
					} 
					opencl_platforms_name[opencl_platforms_idx] = opencl_platform_name;
					if (hashcat_ctx.hc_clGetPlatformInfo(opencl_platform, CL_PLATFORM_VERSION, 0, (null), param_value_size) == -1) {
						return -1;
					} 
					Byte opencl_platform_version = (byte)ModernizedCProgram.hcmalloc(param_value_size);
					if (hashcat_ctx.hc_clGetPlatformInfo(opencl_platform, CL_PLATFORM_VERSION, param_value_size, opencl_platform_version, (null)) == -1) {
						return -1;
					} 
					opencl_platforms_version[opencl_platforms_idx] = opencl_platform_version;
					 opencl_platform_vendor_id = 0;
					if (/*Error: Function owner not recognized*/strcmp(opencl_platform_vendor, ModernizedCProgram.CL_VENDOR_AMD1) == 0) {
						opencl_platform_vendor_id = vendor_id.VENDOR_ID_AMD;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_platform_vendor, ModernizedCProgram.CL_VENDOR_AMD2) == 0) {
						opencl_platform_vendor_id = vendor_id.VENDOR_ID_AMD;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_platform_vendor, ModernizedCProgram.CL_VENDOR_AMD_USE_INTEL) == 0) {
						opencl_platform_vendor_id = vendor_id.VENDOR_ID_AMD_USE_INTEL;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_platform_vendor, ModernizedCProgram.CL_VENDOR_APPLE) == 0) {
						opencl_platform_vendor_id = vendor_id.VENDOR_ID_APPLE;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_platform_vendor, ModernizedCProgram.CL_VENDOR_INTEL_BEIGNET) == 0) {
						opencl_platform_vendor_id = vendor_id.VENDOR_ID_INTEL_BEIGNET;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_platform_vendor, ModernizedCProgram.CL_VENDOR_INTEL_SDK) == 0) {
						opencl_platform_vendor_id = vendor_id.VENDOR_ID_INTEL_SDK;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_platform_vendor, ModernizedCProgram.CL_VENDOR_MESA) == 0) {
						opencl_platform_vendor_id = vendor_id.VENDOR_ID_MESA;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_platform_vendor, ModernizedCProgram.CL_VENDOR_NV) == 0) {
						opencl_platform_vendor_id = vendor_id.VENDOR_ID_NV;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_platform_vendor, ModernizedCProgram.CL_VENDOR_POCL) == 0) {
						opencl_platform_vendor_id = vendor_id.VENDOR_ID_POCL;
					} else {
							opencl_platform_vendor_id = vendor_id.VENDOR_ID_GENERIC;
					} 
					opencl_platforms_vendor_id[opencl_platforms_idx] = opencl_platform_vendor_id;
					 opencl_platform_devices = ()ModernizedCProgram.hccalloc(64, /*Error: Unsupported expression*/);
					 opencl_platform_devices_cnt = 0;
					int CL_rc = hashcat_ctx.hc_clGetDeviceIDs(opencl_platform, CL_DEVICE_TYPE_ALL, 64, opencl_platform_devices, opencl_platform_devices_cnt);
					if (CL_rc == -1) {
						hashcat_ctx.event_log_error("clGetDeviceIDs(): %s", ModernizedCProgram.val2cstr_cl(CL_rc));
						return -1;
					} 
					opencl_platforms_devices[opencl_platforms_idx] = opencl_platform_devices;
					opencl_platforms_devices_cnt[opencl_platforms_idx] = opencl_platform_devices_cnt;
				}
				if (generatedOpencl_device_types == (null)) {
					 opencl_device_types_all = 0;
					for (u32 opencl_platforms_idx = 0;
					 opencl_platforms_idx < opencl_platforms_cnt; opencl_platforms_idx++) {
						 opencl_platform_devices = opencl_platforms_devices[opencl_platforms_idx];
						 opencl_platform_devices_cnt = opencl_platforms_devices_cnt[opencl_platforms_idx];
						for (u32 opencl_platform_devices_idx = 0;
						 opencl_platform_devices_idx < opencl_platform_devices_cnt; opencl_platform_devices_idx++) {
							 opencl_device = opencl_platform_devices[opencl_platform_devices_idx];
							 opencl_device_type = new ();
							if (hashcat_ctx.hc_clGetDeviceInfo(opencl_device, CL_DEVICE_TYPE, /*Error: sizeof expression not supported yet*/, opencl_device_type, (null)) == -1) {
								{ 
									ModernizedCProgram.hcfree(opencl_platforms);
									ModernizedCProgram.hcfree(opencl_platforms_devices);
									ModernizedCProgram.hcfree(opencl_platforms_devices_cnt);
									ModernizedCProgram.hcfree(opencl_platforms_name);
									ModernizedCProgram.hcfree(opencl_platforms_vendor);
									ModernizedCProgram.hcfree(opencl_platforms_vendor_id);
									ModernizedCProgram.hcfree(opencl_platforms_version);
								}
								;
								return -1;
							} 
							opencl_device_types_all |=  opencl_device_type;
						}
					}
					if ((opencl_device_types_all & (CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR)) == 0) {
						opencl_device_types_filter |=  CL_DEVICE_TYPE_CPU;
					} 
					if (generatedStdout_flag == true) {
						if (opencl_device_types_all & CL_DEVICE_TYPE_CPU) {
							opencl_device_types_filter = CL_DEVICE_TYPE_CPU;
						} 
					} 
					backend_ctx.setOpencl_device_types_filter(opencl_device_types_filter);
				} 
			} 
			backend_ctx.setOpencl_platforms(opencl_platforms);
			backend_ctx.setOpencl_platforms_cnt(opencl_platforms_cnt);
			backend_ctx.setOpencl_platforms_devices(opencl_platforms_devices);
			backend_ctx.setOpencl_platforms_devices_cnt(opencl_platforms_devices_cnt);
			backend_ctx.setOpencl_platforms_name(opencl_platforms_name);
			backend_ctx.setOpencl_platforms_vendor(opencl_platforms_vendor);
			backend_ctx.setOpencl_platforms_vendor_id(opencl_platforms_vendor_id);
			backend_ctx.setOpencl_platforms_version(opencl_platforms_version);
		} 
		if ((generatedCuda == (null)) && (generatedOcl == (null))) {
			hashcat_ctx.event_log_error("ATTENTION! No OpenCL-compatible or CUDA-compatible platform found.");
			hashcat_ctx.event_log_warning("You are probably missing the OpenCL or CUDA runtime installation.");
			hashcat_ctx.event_log_warning((null));
			hashcat_ctx.event_log_warning("* AMD GPUs on Windows require this driver:");
			hashcat_ctx.event_log_warning("  \"AMD Radeon Software Crimson Edition\" (15.12 or later)");
			hashcat_ctx.event_log_warning("* Intel CPUs require this runtime:");
			hashcat_ctx.event_log_warning("  \"OpenCL Runtime for Intel Core and Intel Xeon Processors\" (16.1.1 or later)");
			hashcat_ctx.event_log_warning("* Intel GPUs on Windows require this driver:");
			hashcat_ctx.event_log_warning("  \"OpenCL Driver for Intel Iris and Intel HD Graphics\"");
			hashcat_ctx.event_log_warning("* NVIDIA GPUs require this runtime and/or driver (both):");
			hashcat_ctx.event_log_warning("  \"NVIDIA Driver\" (418.56 or later)");
			hashcat_ctx.event_log_warning("  \"CUDA Toolkit\" (10.1 or later)");
			hashcat_ctx.event_log_warning((null));
			return -1;
		} 
		backend_ctx.setEnabled(1);
		return 0;
	}
	public void backend_ctx_destroy() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		ModernizedCProgram.hcfree(generatedDevices_param);
		Object generatedOcl = backend_ctx.getOcl();
		Object generatedOpencl_platforms = backend_ctx.getOpencl_platforms();
		Object[][] generatedOpencl_platforms_devices = backend_ctx.getOpencl_platforms_devices();
		Object generatedOpencl_platforms_devices_cnt = backend_ctx.getOpencl_platforms_devices_cnt();
		byte[][] generatedOpencl_platforms_name = backend_ctx.getOpencl_platforms_name();
		byte[][] generatedOpencl_platforms_vendor = backend_ctx.getOpencl_platforms_vendor();
		Object generatedOpencl_platforms_vendor_id = backend_ctx.getOpencl_platforms_vendor_id();
		byte[][] generatedOpencl_platforms_version = backend_ctx.getOpencl_platforms_version();
		if (generatedOcl) {
			ModernizedCProgram.hcfree(generatedOpencl_platforms);
			ModernizedCProgram.hcfree(generatedOpencl_platforms_devices);
			ModernizedCProgram.hcfree(generatedOpencl_platforms_devices_cnt);
			ModernizedCProgram.hcfree(generatedOpencl_platforms_name);
			ModernizedCProgram.hcfree(generatedOpencl_platforms_vendor);
			ModernizedCProgram.hcfree(generatedOpencl_platforms_vendor_id);
			ModernizedCProgram.hcfree(generatedOpencl_platforms_version);
		} 
		hashcat_ctx.nvrtc_close();
		hashcat_ctx.cuda_close();
		hashcat_ctx.ocl_close();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(backend_ctx, 0, /*Error: Unsupported expression*/);
	}
	public int backend_ctx_devices_init(Object comptime) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		hc_device_param_t[] devices_param = generatedDevices_param;
		boolean need_adl = false;
		boolean need_nvml = false;
		boolean need_nvapi = false;
		boolean need_sysfs = false;
		int backend_devices_idx = 0;
		int cuda_devices_cnt = 0;
		int cuda_devices_active = 0;
		Object generatedCuda = backend_ctx.getCuda();
		Object[] generatedBackend_device_from_cuda = backend_ctx.getBackend_device_from_cuda();
		Object generatedBackend_devices_filter = backend_ctx.getBackend_devices_filter();
		Object generatedOpencl_device_types_filter = backend_ctx.getOpencl_device_types_filter();
		Object generatedOpencl_platform_vendor_id = device_param.getOpencl_platform_vendor_id();
		Object generatedOpencl_device_vendor_id = device_param.getOpencl_device_vendor_id();
		Object generatedSpin_damp = user_options.getSpin_damp();
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedForce = user_options.getForce();
		boolean generatedBackend_info = user_options.getBackend_info();
		int generatedSm_major = device_param.getSm_major();
		boolean generatedQuiet = user_options.getQuiet();
		int generatedSm_minor = device_param.getSm_minor();
		Object generatedKernel_exec_timeout = device_param.getKernel_exec_timeout();
		Object generatedCuda_device = device_param.getCuda_device();
		if (generatedCuda) {
			if (hashcat_ctx.hc_cuDeviceGetCount(cuda_devices_cnt) == -1) {
				hashcat_ctx.cuda_close();
			} 
			backend_ctx.setCuda_devices_cnt(cuda_devices_cnt);
			for (int cuda_devices_idx = 0;
			 cuda_devices_idx < cuda_devices_cnt; ) {
				u32 device_id = backend_devices_idx;
				hc_device_param_t device_param = devices_param[backend_devices_idx];
				device_param.setDevice_id(device_id);
				generatedBackend_device_from_cuda[cuda_devices_idx] = backend_devices_idx;
				CUdevice cuda_device = new CUdevice();
				if (hashcat_ctx.hc_cuDeviceGet(cuda_device, cuda_devices_idx) == -1) {
					return -1;
				} 
				device_param.setCuda_device(cuda_device);
				device_param.setIs_cuda(1);
				Byte device_name = (byte)ModernizedCProgram.hcmalloc(-1024);
				if (hashcat_ctx.hc_cuDeviceGetName(device_name, -1024, cuda_device) == -1) {
					return -1;
				} 
				device_param.setDevice_name(device_name);
				ModernizedCProgram.hc_string_trim_leading(device_name);
				ModernizedCProgram.hc_string_trim_trailing(device_name);
				int device_processors = 0;
				if (hashcat_ctx.hc_cuDeviceGetAttribute(device_processors, CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, cuda_device) == -1) {
					return -1;
				} 
				device_param.setDevice_processors(device_processors);
				size_t bytes = 0;
				if (hashcat_ctx.hc_cuDeviceTotalMem(bytes, cuda_device) == -1) {
					return -1;
				} 
				device_param.setDevice_global_mem((u64)bytes);
				device_param.setDevice_maxmem_alloc((u64)bytes);
				device_param.setDevice_available_mem(0);
				int cuda_warp_size = 0;
				if (hashcat_ctx.hc_cuDeviceGetAttribute(cuda_warp_size, CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_WARP_SIZE, cuda_device) == -1) {
					return -1;
				} 
				device_param.setCuda_warp_size(cuda_warp_size);
				int sm_major = 0;
				int sm_minor = 0;
				if (hashcat_ctx.hc_cuDeviceGetAttribute(sm_major, CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, cuda_device) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuDeviceGetAttribute(sm_minor, CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, cuda_device) == -1) {
					return -1;
				} 
				device_param.setSm_major(sm_major);
				device_param.setSm_minor(sm_minor);
				int device_maxworkgroup_size = 0;
				if (hashcat_ctx.hc_cuDeviceGetAttribute(device_maxworkgroup_size, CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK, cuda_device) == -1) {
					return -1;
				} 
				device_param.setDevice_maxworkgroup_size(device_maxworkgroup_size);
				int device_maxclock_frequency = 0;
				if (hashcat_ctx.hc_cuDeviceGetAttribute(device_maxclock_frequency, CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CLOCK_RATE, cuda_device) == -1) {
					return -1;
				} 
				device_param.setDevice_maxclock_frequency(device_maxclock_frequency / 1000);
				int pci_bus_id_nv = 0;
				int pci_slot_id_nv = 0;
				if (hashcat_ctx.hc_cuDeviceGetAttribute(pci_bus_id_nv, CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PCI_BUS_ID, cuda_device) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuDeviceGetAttribute(pci_slot_id_nv, CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID, cuda_device) == -1) {
					return -1;
				} 
				device_param.setPcie_bus((u8)(pci_bus_id_nv));
				device_param.setPcie_device((u8)(pci_slot_id_nv >> 3));
				device_param.setPcie_function((u8)(pci_slot_id_nv & 7));
				int kernel_exec_timeout = 0;
				if (hashcat_ctx.hc_cuDeviceGetAttribute(kernel_exec_timeout, CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT, cuda_device) == -1) {
					return -1;
				} 
				device_param.setKernel_exec_timeout(kernel_exec_timeout);
				int max_shared_memory_per_block = 0;
				if (hashcat_ctx.hc_cuDeviceGetAttribute(max_shared_memory_per_block, CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK, cuda_device) == -1) {
					return -1;
				} 
				if (max_shared_memory_per_block < 32768) {
					hashcat_ctx.event_log_error("* Device #%u: This device's shared buffer size is too small.", device_id + 1);
					device_param.setSkipped(1);
				} 
				device_param.setDevice_local_mem_size(max_shared_memory_per_block);
				int device_max_constant_buffer_size = 0;
				if (hashcat_ctx.hc_cuDeviceGetAttribute(device_max_constant_buffer_size, CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY, cuda_device) == -1) {
					return -1;
				} 
				if (device_max_constant_buffer_size < 65536) {
					hashcat_ctx.event_log_error("* Device #%u: This device's local mem size is too small.", device_id + 1);
					device_param.setSkipped(1);
				} 
				device_param.setDevice_local_mem_type(CL_LOCAL);
				device_param.setOpencl_device_type(CL_DEVICE_TYPE_GPU);
				device_param.setOpencl_device_vendor_id(vendor_id.VENDOR_ID_NV);
				device_param.setOpencl_platform_vendor_id(vendor_id.VENDOR_ID_NV);
				device_param.setOpencl_device_version("");
				device_param.setOpencl_driver_version("");
				device_param.setOpencl_device_vendor("");
				device_param.setOpencl_device_c_version("");
				if ((generatedBackend_devices_filter & (-1024 << device_id)) == 0) {
					device_param.setSkipped(1);
				} 
				if ((generatedOpencl_device_types_filter & CL_DEVICE_TYPE_GPU) == 0) {
					device_param.setSkipped(1);
				} 
				if ((generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_NV) && (generatedOpencl_device_vendor_id == vendor_id.VENDOR_ID_NV)) {
					need_nvml = true;
					need_nvapi = true;
				} 
				device_param.setSpin_damp((double)generatedSpin_damp / 100);
				if (generatedSkipped == false) {
					if ((generatedForce == false) && (generatedBackend_info == false)) {
						if (generatedSm_major < 5) {
							if (generatedQuiet == false) {
								hashcat_ctx.event_log_warning("* Device #%u: This hardware has outdated CUDA compute capability (%u.%u).", device_id + 1, generatedSm_major, generatedSm_minor);
							} 
							if (generatedQuiet == false) {
								hashcat_ctx.event_log_warning("             For modern OpenCL performance, upgrade to hardware that supports");
							} 
							if (generatedQuiet == false) {
								hashcat_ctx.event_log_warning("             CUDA compute capability version 5.0 (Maxwell) or higher.");
							} 
						} 
						if (generatedKernel_exec_timeout != 0) {
							if (generatedQuiet == false) {
								hashcat_ctx.event_log_warning("* Device #%u: WARNING! Kernel exec timeout is not disabled.", device_id + 1);
							} 
							if (generatedQuiet == false) {
								hashcat_ctx.event_log_warning("             This may cause \"CL_OUT_OF_RESOURCES\" or related errors.");
							} 
							if (generatedQuiet == false) {
								hashcat_ctx.event_log_warning("             To disable the timeout, see: https://hashcat.net/q/timeoutpatch");
							} 
						} 
					} 
					/**
					         * activate device
					         */cuda_devices_active++;
				} 
				CUcontext cuda_context = new CUcontext();
				if (hashcat_ctx.hc_cuCtxCreate(cuda_context, CUctx_flags_enum.CU_CTX_SCHED_BLOCKING_SYNC, generatedCuda_device) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuCtxSetCurrent(cuda_context) == -1) {
					return -1;
				} 
				device_param.setHas_bfe(hashcat_ctx.cuda_test_instruction(sm_major, sm_minor, "__global__ void test () { unsigned int r; asm volatile (\"bfe.u32 %0, 0, 0, 0;\" : \"=r\"(r)); }"));
				device_param.setHas_lop3(hashcat_ctx.cuda_test_instruction(sm_major, sm_minor, "__global__ void test () { unsigned int r; asm volatile (\"lop3.b32 %0, 0, 0, 0, 0;\" : \"=r\"(r)); }"));
				device_param.setHas_mov64(hashcat_ctx.cuda_test_instruction(sm_major, sm_minor, "__global__ void test () { unsigned long long r; unsigned int a; unsigned int b; asm volatile (\"mov.b64 %0, {%1, %2};\" : \"=l\"(r) : \"r\"(a), \"r\"(b)); }"));
				device_param.setHas_prmt(hashcat_ctx.cuda_test_instruction(sm_major, sm_minor, "__global__ void test () { unsigned int r; asm volatile (\"prmt.b32 %0, 0, 0, 0;\" : \"=r\"(r)); }"));
				size_t free = 0;
				size_t total = 0;
				if (hashcat_ctx.hc_cuMemGetInfo(free, total) == -1) {
					return -1;
				} 
				device_param.setDevice_available_mem((u64)free);
				if (hashcat_ctx.hc_cuCtxDestroy(cuda_context) == -1) {
					return -1;
				} 
			}
		} 
		// device count
		backend_ctx.setCuda_devices_cnt(cuda_devices_cnt);
		backend_ctx.setCuda_devices_active(cuda_devices_active);
		int opencl_devices_cnt = 0;
		int opencl_devices_active = 0;
		Object generatedOcl = backend_ctx.getOcl();
		Object generatedOpencl_platforms_cnt = backend_ctx.getOpencl_platforms_cnt();
		Object[][] generatedOpencl_platforms_devices = backend_ctx.getOpencl_platforms_devices();
		Object generatedOpencl_platforms_devices_cnt = backend_ctx.getOpencl_platforms_devices_cnt();
		Object generatedOpencl_platforms_vendor_id = backend_ctx.getOpencl_platforms_vendor_id();
		Object[] generatedBackend_device_from_opencl = backend_ctx.getBackend_device_from_opencl();
		Object[][] generatedBackend_device_from_opencl_platform = backend_ctx.getBackend_device_from_opencl_platform();
		Object generatedOpencl_device = device_param.getOpencl_device();
		Byte generatedDevice_name = device_param.getDevice_name();
		Object generatedOpencl_device_type = device_param.getOpencl_device_type();
		Object generatedPcie = amdtopo.getPcie();
		Object generatedNvrtc = backend_ctx.getNvrtc();
		Byte generatedOpencl_driver_version = device_param.getOpencl_driver_version();
		Byte generatedOpencl_device_version = device_param.getOpencl_device_version();
		Byte generatedOpencl_device_c_version = device_param.getOpencl_device_c_version();
		Object generatedDevice_global_mem = device_param.getDevice_global_mem();
		Object generatedDevice_available_mem = device_param.getDevice_available_mem();
		if (generatedOcl) {
			 opencl_platforms_cnt = generatedOpencl_platforms_cnt;
			 opencl_platforms_devices = generatedOpencl_platforms_devices;
			 opencl_platforms_devices_cnt = generatedOpencl_platforms_devices_cnt;
			 opencl_platforms_vendor_id = generatedOpencl_platforms_vendor_id;
			for (u32 opencl_platforms_idx = 0;
			 opencl_platforms_idx < opencl_platforms_cnt; opencl_platforms_idx++) {
				 opencl_platform_devices = opencl_platforms_devices[opencl_platforms_idx];
				 opencl_platform_devices_cnt = opencl_platforms_devices_cnt[opencl_platforms_idx];
				 opencl_platform_vendor_id = opencl_platforms_vendor_id[opencl_platforms_idx];
				for (u32 opencl_platform_devices_idx = 0;
				 opencl_platform_devices_idx < opencl_platform_devices_cnt; ) {
					u32 device_id = backend_devices_idx;
					hc_device_param_t device_param = devices_param[device_id];
					device_param.setDevice_id(device_id);
					generatedBackend_device_from_opencl[opencl_devices_cnt] = backend_devices_idx;
					generatedBackend_device_from_opencl_platform[opencl_platforms_idx][opencl_platform_devices_idx] = backend_devices_idx;
					device_param.setOpencl_platform_vendor_id(opencl_platform_vendor_id);
					device_param.setOpencl_device(opencl_platform_devices[opencl_platform_devices_idx]);
					device_param.setIs_opencl(1);
					size_t param_value_size = 0;
					 opencl_device_type = new ();
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_TYPE, /*Error: sizeof expression not supported yet*/, opencl_device_type, (null)) == -1) {
						return -1;
					} 
					opencl_device_type &=  ~CL_DEVICE_TYPE_DEFAULT;
					device_param.setOpencl_device_type(opencl_device_type);
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_NAME, 0, (null), param_value_size) == -1) {
						return -1;
					} 
					Byte device_name = (byte)ModernizedCProgram.hcmalloc(param_value_size);
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_NAME, param_value_size, device_name, (null)) == -1) {
						return -1;
					} 
					device_param.setDevice_name(device_name);
					ModernizedCProgram.hc_string_trim_leading(generatedDevice_name);
					ModernizedCProgram.hc_string_trim_trailing(generatedDevice_name);
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_VENDOR, 0, (null), param_value_size) == -1) {
						return -1;
					} 
					Byte opencl_device_vendor = (byte)ModernizedCProgram.hcmalloc(param_value_size);
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_VENDOR, param_value_size, opencl_device_vendor, (null)) == -1) {
						return -1;
					} 
					device_param.setOpencl_device_vendor(opencl_device_vendor);
					 opencl_device_vendor_id = 0;
					if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_AMD1) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_AMD;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_AMD2) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_AMD;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_AMD_USE_INTEL) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_AMD_USE_INTEL;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_APPLE) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_APPLE;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_APPLE_USE_AMD) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_AMD;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_APPLE_USE_NV) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_NV;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_APPLE_USE_INTEL) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_INTEL_SDK;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_INTEL_BEIGNET) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_INTEL_BEIGNET;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_INTEL_SDK) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_INTEL_SDK;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_MESA) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_MESA;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_NV) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_NV;
					}  else if (/*Error: Function owner not recognized*/strcmp(opencl_device_vendor, ModernizedCProgram.CL_VENDOR_POCL) == 0) {
						opencl_device_vendor_id = vendor_id.VENDOR_ID_POCL;
					} else {
							opencl_device_vendor_id = vendor_id.VENDOR_ID_GENERIC;
					} 
					device_param.setOpencl_device_vendor_id(opencl_device_vendor_id);
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_VERSION, 0, (null), param_value_size) == -1) {
						return -1;
					} 
					Byte opencl_device_version = (byte)ModernizedCProgram.hcmalloc(param_value_size);
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_VERSION, param_value_size, opencl_device_version, (null)) == -1) {
						return -1;
					} 
					device_param.setOpencl_device_version(opencl_device_version);
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_OPENCL_C_VERSION, 0, (null), param_value_size) == -1) {
						return -1;
					} 
					Byte opencl_device_c_version = (byte)ModernizedCProgram.hcmalloc(param_value_size);
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_OPENCL_C_VERSION, param_value_size, opencl_device_c_version, (null)) == -1) {
						return -1;
					} 
					device_param.setOpencl_device_c_version(opencl_device_c_version);
					 device_processors = 0;
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_MAX_COMPUTE_UNITS, /*Error: sizeof expression not supported yet*/, device_processors, (null)) == -1) {
						return -1;
					} 
					device_param.setDevice_processors(device_processors);
					 device_global_mem = 0;
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_GLOBAL_MEM_SIZE, /*Error: sizeof expression not supported yet*/, device_global_mem, (null)) == -1) {
						return -1;
					} 
					device_param.setDevice_global_mem(device_global_mem);
					device_param.setDevice_available_mem(0);
					 device_maxmem_alloc = 0;
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_MAX_MEM_ALLOC_SIZE, /*Error: sizeof expression not supported yet*/, device_maxmem_alloc, (null)) == -1) {
						return -1;
					} 
					device_param.setDevice_maxmem_alloc(device_maxmem_alloc);
					size_t device_maxworkgroup_size = 0;
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_MAX_WORK_GROUP_SIZE, /*Error: sizeof expression not supported yet*/, device_maxworkgroup_size, (null)) == -1) {
						return -1;
					} 
					device_param.setDevice_maxworkgroup_size(device_maxworkgroup_size);
					 device_maxclock_frequency = 0;
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_MAX_CLOCK_FREQUENCY, /*Error: sizeof expression not supported yet*/, device_maxclock_frequency, (null)) == -1) {
						return -1;
					} 
					device_param.setDevice_maxclock_frequency(device_maxclock_frequency);
					 device_endian_little = CL_FALSE;
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_ENDIAN_LITTLE, /*Error: sizeof expression not supported yet*/, device_endian_little, (null)) == -1) {
						return -1;
					} 
					if (device_endian_little == CL_FALSE) {
						hashcat_ctx.event_log_error("* Device #%u: This device is not little-endian.", device_id + 1);
						device_param.setSkipped(1);
					} 
					 device_available = CL_FALSE;
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_AVAILABLE, /*Error: sizeof expression not supported yet*/, device_available, (null)) == -1) {
						return -1;
					} 
					if (device_available == CL_FALSE) {
						hashcat_ctx.event_log_error("* Device #%u: This device is not available.", device_id + 1);
						device_param.setSkipped(1);
					} 
					 device_compiler_available = CL_FALSE;
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_COMPILER_AVAILABLE, /*Error: sizeof expression not supported yet*/, device_compiler_available, (null)) == -1) {
						return -1;
					} 
					if (device_compiler_available == CL_FALSE) {
						hashcat_ctx.event_log_error("* Device #%u: No compiler is available for this device.", device_id + 1);
						device_param.setSkipped(1);
					} 
					 device_execution_capabilities = new ();
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_EXECUTION_CAPABILITIES, /*Error: sizeof expression not supported yet*/, device_execution_capabilities, (null)) == -1) {
						return -1;
					} 
					if ((device_execution_capabilities & CL_EXEC_KERNEL) == 0) {
						hashcat_ctx.event_log_error("* Device #%u: This device does not support executing kernels.", device_id + 1);
						device_param.setSkipped(1);
					} 
					size_t device_extensions_size = new size_t();
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_EXTENSIONS, 0, (null), device_extensions_size) == -1) {
						return -1;
					} 
					Byte device_extensions = ModernizedCProgram.hcmalloc(device_extensions_size + 1);
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_EXTENSIONS, device_extensions_size, device_extensions, (null)) == -1) {
						return -1;
					} 
					if (/*Error: Function owner not recognized*/strstr(device_extensions, "base_atomics") == 0) {
						hashcat_ctx.event_log_error("* Device #%u: This device does not support base atomics.", device_id + 1);
						device_param.setSkipped(1);
					} 
					if (/*Error: Function owner not recognized*/strstr(device_extensions, "byte_addressable_store") == 0) {
						hashcat_ctx.event_log_error("* Device #%u: This device does not support byte-addressable store.", device_id + 1);
						device_param.setSkipped(1);
					} 
					ModernizedCProgram.hcfree(device_extensions);
					 device_local_mem_type = new ();
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_LOCAL_MEM_TYPE, /*Error: sizeof expression not supported yet*/, device_local_mem_type, (null)) == -1) {
						return -1;
					} 
					device_param.setDevice_local_mem_type(device_local_mem_type);
					 device_max_constant_buffer_size = new ();
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, /*Error: sizeof expression not supported yet*/, device_max_constant_buffer_size, (null)) == -1) {
						return -1;
					} 
					if (device_local_mem_type == CL_LOCAL) {
						if (device_max_constant_buffer_size < 65536) {
							hashcat_ctx.event_log_error("* Device #%u: This device's constant buffer size is too small.", device_id + 1);
							device_param.setSkipped(1);
						} 
					} 
					 device_local_mem_size = 0;
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_LOCAL_MEM_SIZE, /*Error: sizeof expression not supported yet*/, device_local_mem_size, (null)) == -1) {
						return -1;
					} 
					if (device_local_mem_type == CL_LOCAL) {
						if (device_local_mem_size < 32768) {
							hashcat_ctx.event_log_error("* Device #%u: This device's local mem size is too small.", device_id + 1);
							device_param.setSkipped(1);
						} 
					} 
					device_param.setDevice_local_mem_size(device_local_mem_size);
					if (opencl_device_type & CL_DEVICE_TYPE_CPU) {
						if (generatedOpencl_device_vendor_id == vendor_id.VENDOR_ID_AMD_USE_INTEL) {
							if (generatedForce == false) {
								if (generatedQuiet == false) {
									hashcat_ctx.event_log_warning("* Device #%u: Not a native Intel OpenCL runtime. Expect massive speed loss.", device_id + 1);
								} 
								if (generatedQuiet == false) {
									hashcat_ctx.event_log_warning("             You can use --force to override, but do not report related errors.");
								} 
								device_param.setSkipped(1);
							} 
						} 
					} 
					if (opencl_device_type & CL_DEVICE_TYPE_GPU) {
						if ((generatedOpencl_device_vendor_id == vendor_id.VENDOR_ID_INTEL_SDK) || (generatedOpencl_device_vendor_id == vendor_id.VENDOR_ID_INTEL_BEIGNET)) {
							if (generatedForce == false) {
								if (generatedQuiet == false) {
									hashcat_ctx.event_log_warning("* Device #%u: Intel's OpenCL runtime (GPU only) is currently broken.", device_id + 1);
								} 
								if (generatedQuiet == false) {
									hashcat_ctx.event_log_warning("             We are waiting for updated OpenCL drivers from Intel.");
								} 
								if (generatedQuiet == false) {
									hashcat_ctx.event_log_warning("             You can use --force to override, but do not report related errors.");
								} 
								device_param.setSkipped(1);
							} 
						} 
					} 
					if ((generatedBackend_devices_filter & (-1024 << device_id)) == 0) {
						device_param.setSkipped(1);
					} 
					if ((generatedOpencl_device_types_filter & (opencl_device_type)) == 0) {
						device_param.setSkipped(1);
					} 
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DRIVER_VERSION, 0, (null), param_value_size) == -1) {
						return -1;
					} 
					Byte opencl_driver_version = (byte)ModernizedCProgram.hcmalloc(param_value_size);
					if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DRIVER_VERSION, param_value_size, opencl_driver_version, (null)) == -1) {
						return -1;
					} 
					device_param.setOpencl_driver_version(opencl_driver_version);
					if (generatedOpencl_device_type & CL_DEVICE_TYPE_GPU) {
						if ((generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_AMD) && (generatedOpencl_device_vendor_id == vendor_id.VENDOR_ID_AMD)) {
							need_adl = true;
						} 
						if ((generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_NV) && (generatedOpencl_device_vendor_id == vendor_id.VENDOR_ID_NV)) {
							need_nvml = true;
							need_nvapi = true;
						} 
					} 
					if (generatedOpencl_device_type & CL_DEVICE_TYPE_GPU) {
						if ((generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_AMD) && (generatedOpencl_device_vendor_id == vendor_id.VENDOR_ID_AMD)) {
							cl_device_topology_amd amdtopo = new cl_device_topology_amd();
							if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, -1024, /*Error: sizeof expression not supported yet*/, amdtopo, (null)) == -1) {
								return -1;
							} 
							device_param.setPcie_bus(generatedPcie.getBus());
							device_param.setPcie_device(generatedPcie.getDevice());
							device_param.setPcie_function(generatedPcie.getFunction());
						} 
						if ((generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_NV) && (generatedOpencl_device_vendor_id == vendor_id.VENDOR_ID_NV)) {
							 pci_bus_id_nv = new ();
							 pci_slot_id_nv = new ();
							if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, -1024, /*Error: sizeof expression not supported yet*/, pci_bus_id_nv, (null)) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, -1024, /*Error: sizeof expression not supported yet*/, pci_slot_id_nv, (null)) == -1) {
								return -1;
							} 
							device_param.setPcie_bus((u8)(pci_bus_id_nv));
							device_param.setPcie_device((u8)(pci_slot_id_nv >> 3));
							device_param.setPcie_function((u8)(pci_slot_id_nv & 7));
							int sm_minor = 0;
							int sm_major = 0;
							if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, -1024, /*Error: sizeof expression not supported yet*/, sm_minor, (null)) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, -1024, /*Error: sizeof expression not supported yet*/, sm_major, (null)) == -1) {
								return -1;
							} 
							device_param.setSm_minor(sm_minor);
							device_param.setSm_major(sm_major);
							 kernel_exec_timeout = 0;
							if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, -1024, /*Error: sizeof expression not supported yet*/, kernel_exec_timeout, (null)) == -1) {
								return -1;
							} 
							device_param.setKernel_exec_timeout(kernel_exec_timeout);
							device_param.setSpin_damp((double)generatedSpin_damp / 100);
							if ((generatedCuda == (null)) || (generatedNvrtc == (null))) {
								hashcat_ctx.event_log_warning("* Device #%u: CUDA SDK Toolkit installation NOT detected.", device_id + 1);
								hashcat_ctx.event_log_warning("             CUDA SDK Toolkit installation required for proper device support and utilization");
								hashcat_ctx.event_log_warning("             Falling back to OpenCL Runtime");
								hashcat_ctx.event_log_warning((null));
							} 
						} 
					} 
					if (generatedSkipped == false) {
						if ((generatedForce == false) && (generatedBackend_info == false)) {
							if (opencl_device_type & CL_DEVICE_TYPE_CPU) {
								if (generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_INTEL_SDK) {
									boolean intel_warn = false;
									int opencl_driver1 = 0;
									int opencl_driver2 = 0;
									int opencl_driver3 = 0;
									int opencl_driver4 = 0;
									int res18 = /*Error: Function owner not recognized*/sscanf(generatedOpencl_driver_version, "%d.%d.%d.%d", opencl_driver1, opencl_driver2, opencl_driver3, opencl_driver4);
									if (res18 == 4) {
									} else {
											double opencl_version = 0;
											int opencl_build = 0;
											int res16 = /*Error: Function owner not recognized*/sscanf(generatedOpencl_device_version, "OpenCL %f (Build %d)", opencl_version, opencl_build);
											if (res16 == 2) {
												if (opencl_build < 25) {
													intel_warn = true;
												} 
											} 
									} 
									if (intel_warn == true) {
										hashcat_ctx.event_log_error("* Device #%u: Outdated or broken Intel OpenCL runtime '%s' detected!", device_id + 1, generatedOpencl_driver_version);
										hashcat_ctx.event_log_warning("You are STRONGLY encouraged to use the officially supported Intel OpenCL runtime.");
										hashcat_ctx.event_log_warning("See hashcat.net for officially supported Intel OpenCL runtime.");
										hashcat_ctx.event_log_warning("See also: https://hashcat.net/faq/wrongdriver");
										hashcat_ctx.event_log_warning("You can use --force to override this, but do not report related errors.");
										hashcat_ctx.event_log_warning((null));
										return -1;
									} 
								} 
							}  else if (opencl_device_type & CL_DEVICE_TYPE_GPU) {
								if (generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_AMD) {
									boolean amd_warn = true;
									if (/*Error: Function owner not recognized*/strtoul(generatedOpencl_driver_version, (null), 10) >= 1573) {
										amd_warn = false;
									} 
									if (amd_warn == true) {
										hashcat_ctx.event_log_error("* Device #%u: Outdated or broken AMD driver '%s' detected!", device_id + 1, generatedOpencl_driver_version);
										hashcat_ctx.event_log_warning("You are STRONGLY encouraged to use the officially supported AMD driver.");
										hashcat_ctx.event_log_warning("See hashcat.net for officially supported AMD drivers.");
										hashcat_ctx.event_log_warning("See also: https://hashcat.net/faq/wrongdriver");
										hashcat_ctx.event_log_warning("You can use --force to override this, but do not report related errors.");
										hashcat_ctx.event_log_warning((null));
										return -1;
									} 
								} 
								if (generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_NV) {
									int nv_warn = 1;
									int version_maj = 0;
									int version_min = 0;
									int r = /*Error: Function owner not recognized*/sscanf(generatedOpencl_driver_version, "%d.%d", version_maj, version_min);
									if (r == 2) {
										if (version_maj >= 367) {
											if (version_maj == 418) {
												if (version_min >= 56) {
													nv_warn = 0;
												} 
											} else {
													nv_warn = 0;
											} 
										} 
									} else {
											nv_warn = 0;
									} 
									if (nv_warn == 1) {
										hashcat_ctx.event_log_warning("* Device #%u: Outdated or broken NVIDIA driver '%s' detected!", device_id + 1, generatedOpencl_driver_version);
										hashcat_ctx.event_log_warning((null));
										hashcat_ctx.event_log_warning("You are STRONGLY encouraged to use the officially supported NVIDIA driver.");
										hashcat_ctx.event_log_warning("See hashcat's homepage for officially supported NVIDIA drivers.");
										hashcat_ctx.event_log_warning("See also: https://hashcat.net/faq/wrongdriver");
										hashcat_ctx.event_log_warning("You can use --force to override this, but do not report related errors.");
										hashcat_ctx.event_log_warning((null));
										return -1;
									} 
									if (generatedSm_major < 5) {
										if (generatedQuiet == false) {
											hashcat_ctx.event_log_warning("* Device #%u: This hardware has outdated CUDA compute capability (%u.%u).", device_id + 1, generatedSm_major, generatedSm_minor);
										} 
										if (generatedQuiet == false) {
											hashcat_ctx.event_log_warning("             For modern OpenCL performance, upgrade to hardware that supports");
										} 
										if (generatedQuiet == false) {
											hashcat_ctx.event_log_warning("             CUDA compute capability version 5.0 (Maxwell) or higher.");
										} 
									} 
									if (generatedKernel_exec_timeout != 0) {
										if (generatedQuiet == false) {
											hashcat_ctx.event_log_warning("* Device #%u: WARNING! Kernel exec timeout is not disabled.", device_id + 1);
										} 
										if (generatedQuiet == false) {
											hashcat_ctx.event_log_warning("             This may cause \"CL_OUT_OF_RESOURCES\" or related errors.");
										} 
										if (generatedQuiet == false) {
											hashcat_ctx.event_log_warning("             To disable the timeout, see: https://hashcat.net/q/timeoutpatch");
										} 
									} 
								} 
								if ((/*Error: Function owner not recognized*/strstr(generatedOpencl_device_c_version, "beignet")) || (/*Error: Function owner not recognized*/strstr(generatedOpencl_device_version, "beignet"))) {
									hashcat_ctx.event_log_error("* Device #%u: Intel beignet driver detected!", device_id + 1);
									hashcat_ctx.event_log_warning("The beignet driver has been marked as likely to fail kernel compilation.");
									hashcat_ctx.event_log_warning("You can use --force to override this, but do not report related errors.");
									hashcat_ctx.event_log_warning((null));
									return -1;
								} 
							} 
						} 
						/**
						           * activate device
						           */opencl_devices_active/**
						         * create context for each device
						         */++;
					} 
					cl_context context = new cl_context();
					if (/*Error: Function owner not recognized*/hc_clCreateContext(hashcat_ctx, (null), 1, generatedOpencl_device, (null), (null), context) == -1) {
						return -1/**
						         * create command-queue
						         */;
					} 
					cl_command_queue command_queue = new cl_command_queue();
					if (hashcat_ctx.hc_clCreateCommandQueue(context, generatedOpencl_device, 0, command_queue) == -1) {
						return -1;
					} 
					if ((generatedOpencl_device_type & CL_DEVICE_TYPE_GPU) && (generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_AMD)) {
						device_param.setHas_vadd3(hashcat_ctx.opencl_test_instruction(context, generatedOpencl_device, "__kernel void test () { uint r; __asm__ __volatile__ (\"V_ADD3_U32 %0, 0, 0, 0;\" : \"=v\"(r)); }"));
						device_param.setHas_vbfe(hashcat_ctx.opencl_test_instruction(context, generatedOpencl_device, "__kernel void test () { uint r; __asm__ __volatile__ (\"V_BFE_U32 %0, 0, 0, 0;\" : \"=v\"(r)); }"));
						device_param.setHas_vperm(hashcat_ctx.opencl_test_instruction(context, generatedOpencl_device, "__kernel void test () { uint r; __asm__ __volatile__ (\"V_PERM_B32 %0, 0, 0, 0;\" : \"=v\"(r)); }"));
					} 
					if ((generatedOpencl_device_type & CL_DEVICE_TYPE_GPU) && (generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_NV)) {
						device_param.setHas_bfe(hashcat_ctx.opencl_test_instruction(context, generatedOpencl_device, "__kernel void test () { uint r; asm volatile (\"bfe.u32 %0, 0, 0, 0;\" : \"=r\"(r)); }"));
						device_param.setHas_lop3(hashcat_ctx.opencl_test_instruction(context, generatedOpencl_device, "__kernel void test () { uint r; asm volatile (\"lop3.b32 %0, 0, 0, 0, 0;\" : \"=r\"(r)); }"));
						device_param.setHas_mov64(hashcat_ctx.opencl_test_instruction(context, generatedOpencl_device, "__kernel void test () { ulong r; uint a; uint b; asm volatile (\"mov.b64 %0, {%1, %2};\" : \"=l\"(r) : \"r\"(a), \"r\"(b)); }"));
						device_param.setHas_prmt(hashcat_ctx.opencl_test_instruction(context, generatedOpencl_device, "__kernel void test () { uint r; asm volatile (\"prmt.b32 %0, 0, 0, 0;\" : \"=r\"(r)); }"));
					} 
					device_param.setDevice_available_mem(generatedDevice_global_mem - (64 * 1024 * 1024));
					if ((generatedOpencl_device_type & CL_DEVICE_TYPE_GPU) && (generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_NV)) {
						cl_mem tmp_device = (cl_mem)ModernizedCProgram.hccalloc(8192, /*Error: Unsupported expression*/);
						u64 c = new u64();
						for (c = 0; c < 8192; c++) {
							if (((c + 1 + 1) * (64 * 1024 * 1024)) >= generatedDevice_global_mem) {
								break;
							} 
							cl_int CL_err = new cl_int();
							OCL_PTR ocl = generatedOcl;
							tmp_device[c] = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(context, CL_MEM_READ_WRITE, (64 * 1024 * 1024), (null), CL_err);
							if (CL_err != CL_SUCCESS) {
								c--;
								break;
							} 
							u8[] tmp_host = new u8();
							if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue, tmp_device[c], CL_TRUE, 0, /*Error: sizeof expression not supported yet*/, tmp_host, 0, (null), (null)) != CL_SUCCESS) {
								break;
							} 
							if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue, tmp_device[c], CL_TRUE, 0, /*Error: sizeof expression not supported yet*/, tmp_host, 0, (null), (null)) != CL_SUCCESS) {
								break;
							} 
							if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue, tmp_device[c], CL_TRUE, (64 * 1024 * 1024) - /*Error: sizeof expression not supported yet*/, /*Error: sizeof expression not supported yet*/, tmp_host, 0, (null), (null)) != CL_SUCCESS) {
								break;
							} 
							if (/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(command_queue, tmp_device[c], CL_TRUE, (64 * 1024 * 1024) - /*Error: sizeof expression not supported yet*/, /*Error: sizeof expression not supported yet*/, tmp_host, 0, (null), (null)) != CL_SUCCESS) {
								break;
							} 
						}
						device_param.setDevice_available_mem((64 * 1024 * 1024));
						if (c > 0) {
							generatedDevice_available_mem *= c;
						} 
						for (c = 0; c < 8192; c++) {
							if (((c + 1 + 1) * (64 * 1024 * 1024)) >= generatedDevice_global_mem) {
								break;
							} 
							if (tmp_device[c] != (null)) {
								if (hashcat_ctx.hc_clReleaseMemObject(tmp_device[c]) == -1) {
									return -1;
								} 
							} 
						}
						ModernizedCProgram.hcfree(tmp_device);
					} 
					hashcat_ctx.hc_clReleaseCommandQueue(command_queue);
					hashcat_ctx.hc_clReleaseContext(context);
				}
			}
		} 
		backend_ctx.setOpencl_devices_cnt(opencl_devices_cnt);
		backend_ctx.setOpencl_devices_active(opencl_devices_active)// all devices combined go into backend_* variables;// all devices combined go into backend_* variables
		backend_ctx.setBackend_devices_cnt(cuda_devices_cnt + opencl_devices_cnt);
		backend_ctx.setBackend_devices_active(cuda_devices_active + opencl_devices_active)// find duplicate devices (typically CUDA and OpenCL);// find duplicate devices (typically CUDA and OpenCL)
		if ((cuda_devices_cnt > 0) && (opencl_devices_cnt > 0)) {
			hashcat_ctx.backend_ctx_find_alias_devices();
		} 
		// using force here enables both devices, which is the worst possible outcome// many users force by default, so this is not a good idea
		int generatedBackend_devices_active = backend_ctx.getBackend_devices_active();
		if (generatedBackend_devices_active == 0) {
			hashcat_ctx.event_log_error("No devices found/left.");
			return -1;
		} 
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		// additional check to see if the user has chosen a device that is not within the range of available devices (i.e. larger than devices_cnt)if (generatedBackend_devices_filter != (u64)-1) {
			u64 backend_devices_cnt_mask = ~(((u64)-1 >> generatedBackend_devices_cnt) << generatedBackend_devices_cnt);
			if (generatedBackend_devices_filter > backend_devices_cnt_mask) {
				hashcat_ctx.event_log_error("An invalid device was specified using the --backend-devices parameter.");
				hashcat_ctx.event_log_error("The specified device was higher than the number of available devices (%u).", generatedBackend_devices_cnt);
				return -1;
			} 
		} 
		Object generatedWorkload_profile = user_options.getWorkload_profile();
		backend_ctx.setTarget_msec(ModernizedCProgram.TARGET_MSEC_PROFILE[generatedWorkload_profile - 1]);
		backend_ctx.setNeed_adl(need_adl);
		backend_ctx.setNeed_nvml(need_nvml);
		backend_ctx.setNeed_nvapi(need_nvapi);
		backend_ctx.setNeed_sysfs(need_sysfs);
		backend_ctx.setComptime(comptime);
		return 0;
	}
	public void backend_ctx_devices_destroy() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		Object generatedOpencl_platforms_cnt = backend_ctx.getOpencl_platforms_cnt();
		Object[][] generatedOpencl_platforms_devices = backend_ctx.getOpencl_platforms_devices();
		byte[][] generatedOpencl_platforms_name = backend_ctx.getOpencl_platforms_name();
		byte[][] generatedOpencl_platforms_vendor = backend_ctx.getOpencl_platforms_vendor();
		byte[][] generatedOpencl_platforms_version = backend_ctx.getOpencl_platforms_version();
		for (u32 opencl_platforms_idx = 0;
		 opencl_platforms_idx < generatedOpencl_platforms_cnt; opencl_platforms_idx++) {
			ModernizedCProgram.hcfree(generatedOpencl_platforms_devices[opencl_platforms_idx]);
			ModernizedCProgram.hcfree(generatedOpencl_platforms_name[opencl_platforms_idx]);
			ModernizedCProgram.hcfree(generatedOpencl_platforms_vendor[opencl_platforms_idx]);
			ModernizedCProgram.hcfree(generatedOpencl_platforms_version[opencl_platforms_idx]);
		}
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		Byte generatedDevice_name = device_param.getDevice_name();
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Byte generatedOpencl_driver_version = device_param.getOpencl_driver_version();
		Byte generatedOpencl_device_version = device_param.getOpencl_device_version();
		Byte generatedOpencl_device_c_version = device_param.getOpencl_device_c_version();
		Byte generatedOpencl_device_vendor = device_param.getOpencl_device_vendor();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
			hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			ModernizedCProgram.hcfree(generatedDevice_name);
			if (generatedIs_opencl == true) {
				ModernizedCProgram.hcfree(generatedOpencl_driver_version);
				ModernizedCProgram.hcfree(generatedOpencl_device_version);
				ModernizedCProgram.hcfree(generatedOpencl_device_c_version);
				ModernizedCProgram.hcfree(generatedOpencl_device_vendor);
			} 
		}
		backend_ctx.setBackend_devices_cnt(0);
		backend_ctx.setBackend_devices_active(0);
		backend_ctx.setCuda_devices_cnt(0);
		backend_ctx.setCuda_devices_active(0);
		backend_ctx.setOpencl_devices_cnt(0);
		backend_ctx.setOpencl_devices_active(0);
		backend_ctx.setNeed_adl(0);
		backend_ctx.setNeed_nvml(0);
		backend_ctx.setNeed_nvapi(0);
		backend_ctx.setNeed_sysfs(0);
	}
	public void backend_ctx_devices_sync_tuning() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param_src.getSkipped();
		boolean generatedSkipped_warning = device_param_src.getSkipped_warning();
		Object generatedKernel_accel = device_param_src.getKernel_accel();
		Object generatedKernel_loops = device_param_src.getKernel_loops();
		Object generatedKernel_threads = device_param_src.getKernel_threads();
		Object generatedDevice_processors = device_param_dst.getDevice_processors();
		Object generatedHardware_power = device_param_dst.getHardware_power();
		for (int backend_devices_cnt_src = 0;
		 backend_devices_cnt_src < generatedBackend_devices_cnt; backend_devices_cnt_src++) {
			hc_device_param_t device_param_src = generatedDevices_param[backend_devices_cnt_src];
			if (generatedSkipped == true) {
				continue;
			} 
			if (generatedSkipped_warning == true) {
				continue;
			} 
			for (int backend_devices_cnt_dst = backend_devices_cnt_src + 1;
			 backend_devices_cnt_dst < generatedBackend_devices_cnt; backend_devices_cnt_dst++) {
				hc_device_param_t device_param_dst = generatedDevices_param[backend_devices_cnt_dst];
				if (generatedSkipped == true) {
					continue;
				} 
				if (generatedSkipped_warning == true) {
					continue;
				} 
				if (ModernizedCProgram.is_same_device_type(device_param_src, device_param_dst) == 0) {
					continue;
				} 
				device_param_dst.setKernel_accel(generatedKernel_accel);
				device_param_dst.setKernel_loops(generatedKernel_loops);
				device_param_dst.setKernel_threads(generatedKernel_threads);
				u32 hardware_power = generatedDevice_processors * generatedKernel_threads;
				device_param_dst.setHardware_power(hardware_power);
				u32 kernel_power = generatedHardware_power * generatedKernel_accel;
				device_param_dst.setKernel_power(kernel_power);
			}
		}
	}
	public void backend_ctx_devices_update_power() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		u32 kernel_power_all = 0;
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedKernel_power = device_param.getKernel_power();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
			hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			if (generatedSkipped_warning == true) {
				continue;
			} 
			kernel_power_all += generatedKernel_power;
		}
		backend_ctx.setKernel_power_all(kernel_power_all/*
		   * Inform user about possible slow speeds
		   */);
		Object generatedWordlist_mode = user_options_extra.getWordlist_mode();
		Object generatedWords_base = status_ctx.getWords_base();
		boolean generatedQuiet = user_options.getQuiet();
		if ((generatedWordlist_mode == wl_mode.WL_MODE_FILE) || (generatedWordlist_mode == wl_mode.WL_MODE_MASK)) {
			if (generatedWords_base < kernel_power_all) {
				if (generatedQuiet == false) {
					hashcat_ctx.event_log_advice("The wordlist or mask that you are using is too small.");
					hashcat_ctx.event_log_advice("This means that hashcat cannot use the full parallel power of your device(s).");
					hashcat_ctx.event_log_advice("Unless you supply more work, your cracking speed will drop.");
					hashcat_ctx.event_log_advice("For tips on supplying more work, see: https://hashcat.net/faq/morework");
					hashcat_ctx.event_log_advice((null));
				} 
			} 
		} 
	}
	public void backend_ctx_devices_kernel_loops() {
		combinator_ctx generatedCombinator_ctx = this.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedKernel_loops_min_sav = device_param.getKernel_loops_min_sav();
		Object generatedKernel_loops_max_sav = device_param.getKernel_loops_max_sav();
		Object generatedKernel_loops_min = device_param.getKernel_loops_min();
		Object generatedKernel_loops_max = device_param.getKernel_loops_max();
		Object generatedAttack_exec = hashconfig.getAttack_exec();
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		Object generatedAttack_kern = user_options_extra.getAttack_kern();
		Object generatedKernel_rules_cnt = straight_ctx.getKernel_rules_cnt();
		Object generatedCombs_cnt = combinator_ctx.getCombs_cnt();
		Object generatedBfs_cnt = mask_ctx.getBfs_cnt();
		salt[] generatedSalts_buf = hashes.getSalts_buf();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
			hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			if (generatedSkipped_warning == true) {
				continue;
			} 
			device_param.setKernel_loops_min(generatedKernel_loops_min_sav);
			device_param.setKernel_loops_max(generatedKernel_loops_max_sav);
			if (generatedKernel_loops_min < generatedKernel_loops_max) {
				u32 innerloop_cnt = 0;
				if (generatedAttack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
					if (generatedSlow_candidates == true) {
						innerloop_cnt = 1;
					} else {
							if (generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
								innerloop_cnt = (((amplifier_count.KERNEL_RULES) < ((u32)generatedKernel_rules_cnt)) ? (amplifier_count.KERNEL_RULES) : ((u32)generatedKernel_rules_cnt));
							}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
								innerloop_cnt = (((amplifier_count.KERNEL_COMBS) < ((u32)generatedCombs_cnt)) ? (amplifier_count.KERNEL_COMBS) : ((u32)generatedCombs_cnt));
							}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_BF) {
								innerloop_cnt = (((amplifier_count.KERNEL_BFS) < ((u32)generatedBfs_cnt)) ? (amplifier_count.KERNEL_BFS) : ((u32)generatedBfs_cnt));
							} 
					} 
				} else {
						innerloop_cnt = generatedSalts_buf[0].getSalt_iter();
				} 
				if ((innerloop_cnt >= generatedKernel_loops_min) && (innerloop_cnt <= generatedKernel_loops_max)) {
					device_param.setKernel_loops_max(innerloop_cnt);
				} 
			} 
		}
	}
	public int get_cuda_kernel_wgs(Object function, Object result) {
		int max_threads_per_block;
		if (hashcat_ctx.hc_cuFuncGetAttribute(max_threads_per_block, CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, function) == -1) {
			return -1;
		} 
		result = (u32)max_threads_per_block;
		return 0;
	}
	public int get_cuda_kernel_local_mem_size(Object function, Object result) {
		int shared_size_bytes;
		if (hashcat_ctx.hc_cuFuncGetAttribute(shared_size_bytes, CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES, function) == -1) {
			return -1;
		} 
		result = (u64)shared_size_bytes;
		return 0;
	}
	public int backend_session_begin() {
		bitmap_ctx generatedBitmap_ctx = this.getBitmap_ctx();
		bitmap_ctx_t bitmap_ctx = generatedBitmap_ctx;
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		module_ctx generatedModule_ctx = this.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		u64 size_total_host_all = 0;
		u32 hardware_power_all = 0;
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		int generatedDevice_id = device_param.getDevice_id();
		Byte generatedDevice_name = device_param.getDevice_name();
		Object generatedOpencl_device_type = device_param.getOpencl_device_type();
		tuning_db_entry tuning_db_entry = new tuning_db_entry();
		int generatedVector_width = tuningdb_entry.getVector_width();
		boolean generatedIs_cuda = device_param.getIs_cuda();
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_device = device_param.getOpencl_device();
		Object generatedKernel_accel_min = device_param.getKernel_accel_min();
		Object generatedKernel_accel_max = device_param.getKernel_accel_max();
		int generatedKernel_accel = tuningdb_entry.getKernel_accel();
		Object generatedKernel_loops_min = device_param.getKernel_loops_min();
		Object generatedKernel_loops_max = device_param.getKernel_loops_max();
		int generatedKernel_loops = tuningdb_entry.getKernel_loops();
		Object generatedKernel_threads_min = device_param.getKernel_threads_min();
		Object generatedKernel_threads_max = device_param.getKernel_threads_max();
		Object generatedDevice_processors = device_param.getDevice_processors();
		Object generatedCuda_context = device_param.getCuda_context();
		Object generatedCuda_device = device_param.getCuda_device();
		Object generatedOpencl_context = device_param.getOpencl_context();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedCuda_stream = device_param.getCuda_stream();
		Object generatedCuda_event1 = device_param.getCuda_event1();
		Object generatedCuda_event2 = device_param.getCuda_event2();
		int generatedDevice_local_mem_type = device_param.getDevice_local_mem_type();
		Object generatedOpencl_platform_vendor_id = device_param.getOpencl_platform_vendor_id();
		int generatedSm_major = device_param.getSm_major();
		int generatedSm_minor = device_param.getSm_minor();
		boolean generatedHas_vperm = device_param.getHas_vperm();
		boolean generatedHas_vadd3 = device_param.getHas_vadd3();
		boolean generatedHas_vbfe = device_param.getHas_vbfe();
		boolean generatedHas_bfe = device_param.getHas_bfe();
		boolean generatedHas_lop3 = device_param.getHas_lop3();
		boolean generatedHas_mov64 = device_param.getHas_mov64();
		boolean generatedHas_prmt = device_param.getHas_prmt();
		int generatedComptime = backend_ctx.getComptime();
		int generatedCuda_driver_version = backend_ctx.getCuda_driver_version();
		Byte generatedOpencl_device_version = device_param.getOpencl_device_version();
		Byte generatedOpencl_driver_version = device_param.getOpencl_driver_version();
		Object[] generatedH = md5_ctx.getH();
		Object generatedCuda_module = device_param.getCuda_module();
		Object generatedOpencl_program = device_param.getOpencl_program();
		Object generatedCuda_module_mp = device_param.getCuda_module_mp();
		Object generatedOpencl_program_mp = device_param.getOpencl_program_mp();
		Object generatedCuda_module_amp = device_param.getCuda_module_amp();
		Object generatedOpencl_program_amp = device_param.getOpencl_program_amp();
		Object generatedCuda_d_bitmap_s1_a = device_param.getCuda_d_bitmap_s1_a();
		Object generatedCuda_d_bitmap_s1_b = device_param.getCuda_d_bitmap_s1_b();
		Object generatedCuda_d_bitmap_s1_c = device_param.getCuda_d_bitmap_s1_c();
		Object generatedCuda_d_bitmap_s1_d = device_param.getCuda_d_bitmap_s1_d();
		Object generatedCuda_d_bitmap_s2_a = device_param.getCuda_d_bitmap_s2_a();
		Object generatedCuda_d_bitmap_s2_b = device_param.getCuda_d_bitmap_s2_b();
		Object generatedCuda_d_bitmap_s2_c = device_param.getCuda_d_bitmap_s2_c();
		Object generatedCuda_d_bitmap_s2_d = device_param.getCuda_d_bitmap_s2_d();
		Object generatedCuda_d_plain_bufs = device_param.getCuda_d_plain_bufs();
		Object generatedCuda_d_digests_buf = device_param.getCuda_d_digests_buf();
		Object generatedCuda_d_digests_shown = device_param.getCuda_d_digests_shown();
		Object generatedCuda_d_salt_bufs = device_param.getCuda_d_salt_bufs();
		Object generatedCuda_d_result = device_param.getCuda_d_result();
		Object generatedCuda_d_extra0_buf = device_param.getCuda_d_extra0_buf();
		Object generatedCuda_d_extra1_buf = device_param.getCuda_d_extra1_buf();
		Object generatedCuda_d_extra2_buf = device_param.getCuda_d_extra2_buf();
		Object generatedCuda_d_extra3_buf = device_param.getCuda_d_extra3_buf();
		Object generatedCuda_d_st_digests_buf = device_param.getCuda_d_st_digests_buf();
		Object generatedCuda_d_st_salts_buf = device_param.getCuda_d_st_salts_buf();
		Object generatedCuda_d_rules_c = device_param.getCuda_d_rules_c();
		Object generatedCuda_d_rules = device_param.getCuda_d_rules();
		Object generatedCuda_d_combs = device_param.getCuda_d_combs();
		Object generatedCuda_d_combs_c = device_param.getCuda_d_combs_c();
		Object generatedCuda_d_root_css_buf = device_param.getCuda_d_root_css_buf();
		Object generatedCuda_d_markov_css_buf = device_param.getCuda_d_markov_css_buf();
		Object generatedCuda_d_bfs = device_param.getCuda_d_bfs();
		Object generatedCuda_d_bfs_c = device_param.getCuda_d_bfs_c();
		Object generatedCuda_d_tm_c = device_param.getCuda_d_tm_c();
		Object generatedCuda_d_esalt_bufs = device_param.getCuda_d_esalt_bufs();
		Object generatedCuda_d_st_esalts_buf = device_param.getCuda_d_st_esalts_buf();
		Object generatedOpencl_d_bitmap_s1_a = device_param.getOpencl_d_bitmap_s1_a();
		Object generatedOpencl_d_bitmap_s1_b = device_param.getOpencl_d_bitmap_s1_b();
		Object generatedOpencl_d_bitmap_s1_c = device_param.getOpencl_d_bitmap_s1_c();
		Object generatedOpencl_d_bitmap_s1_d = device_param.getOpencl_d_bitmap_s1_d();
		Object generatedOpencl_d_bitmap_s2_a = device_param.getOpencl_d_bitmap_s2_a();
		Object generatedOpencl_d_bitmap_s2_b = device_param.getOpencl_d_bitmap_s2_b();
		Object generatedOpencl_d_bitmap_s2_c = device_param.getOpencl_d_bitmap_s2_c();
		Object generatedOpencl_d_bitmap_s2_d = device_param.getOpencl_d_bitmap_s2_d();
		Object generatedOpencl_d_plain_bufs = device_param.getOpencl_d_plain_bufs();
		Object generatedOpencl_d_digests_buf = device_param.getOpencl_d_digests_buf();
		Object generatedOpencl_d_digests_shown = device_param.getOpencl_d_digests_shown();
		Object generatedOpencl_d_salt_bufs = device_param.getOpencl_d_salt_bufs();
		Object generatedOpencl_d_result = device_param.getOpencl_d_result();
		Object generatedOpencl_d_extra0_buf = device_param.getOpencl_d_extra0_buf();
		Object generatedOpencl_d_extra1_buf = device_param.getOpencl_d_extra1_buf();
		Object generatedOpencl_d_extra2_buf = device_param.getOpencl_d_extra2_buf();
		Object generatedOpencl_d_extra3_buf = device_param.getOpencl_d_extra3_buf();
		Object generatedOpencl_d_st_digests_buf = device_param.getOpencl_d_st_digests_buf();
		Object generatedOpencl_d_st_salts_buf = device_param.getOpencl_d_st_salts_buf();
		Object generatedOpencl_d_rules_c = device_param.getOpencl_d_rules_c();
		Object generatedOpencl_d_rules = device_param.getOpencl_d_rules();
		Object generatedOpencl_d_combs = device_param.getOpencl_d_combs();
		Object generatedOpencl_d_combs_c = device_param.getOpencl_d_combs_c();
		Object generatedOpencl_d_root_css_buf = device_param.getOpencl_d_root_css_buf();
		Object generatedOpencl_d_markov_css_buf = device_param.getOpencl_d_markov_css_buf();
		Object generatedOpencl_d_bfs = device_param.getOpencl_d_bfs();
		Object generatedOpencl_d_bfs_c = device_param.getOpencl_d_bfs_c();
		Object generatedOpencl_d_tm_c = device_param.getOpencl_d_tm_c();
		Object generatedOpencl_d_esalt_bufs = device_param.getOpencl_d_esalt_bufs();
		Object generatedOpencl_d_st_esalts_buf = device_param.getOpencl_d_st_esalts_buf();
		Object[] generatedKernel_params_buf32 = device_param.getKernel_params_buf32();
		Object[] generatedKernel_params_buf64 = device_param.getKernel_params_buf64();
		Object[] generatedKernel_params = device_param.getKernel_params();
		Object[] generatedKernel_params_mp_buf64 = device_param.getKernel_params_mp_buf64();
		Object[] generatedKernel_params_mp_buf32 = device_param.getKernel_params_mp_buf32();
		Object[] generatedKernel_params_mp = device_param.getKernel_params_mp();
		Object[] generatedKernel_params_mp_l_buf64 = device_param.getKernel_params_mp_l_buf64();
		Object[] generatedKernel_params_mp_l_buf32 = device_param.getKernel_params_mp_l_buf32();
		Object[] generatedKernel_params_mp_l = device_param.getKernel_params_mp_l();
		Object[] generatedKernel_params_mp_r_buf64 = device_param.getKernel_params_mp_r_buf64();
		Object[] generatedKernel_params_mp_r_buf32 = device_param.getKernel_params_mp_r_buf32();
		Object[] generatedKernel_params_mp_r = device_param.getKernel_params_mp_r();
		Object[] generatedKernel_params_amp_buf32 = device_param.getKernel_params_amp_buf32();
		Object[] generatedKernel_params_amp_buf64 = device_param.getKernel_params_amp_buf64();
		Object[] generatedKernel_params_amp = device_param.getKernel_params_amp();
		Object[] generatedKernel_params_tm = device_param.getKernel_params_tm();
		Object[] generatedKernel_params_memset_buf32 = device_param.getKernel_params_memset_buf32();
		Object[] generatedKernel_params_memset_buf64 = device_param.getKernel_params_memset_buf64();
		Object[] generatedKernel_params_memset = device_param.getKernel_params_memset();
		Object[] generatedKernel_params_atinit_buf64 = device_param.getKernel_params_atinit_buf64();
		Object[] generatedKernel_params_atinit = device_param.getKernel_params_atinit();
		Object[] generatedKernel_params_decompress_buf64 = device_param.getKernel_params_decompress_buf64();
		Object[] generatedKernel_params_decompress = device_param.getKernel_params_decompress();
		Object generatedCuda_function1 = device_param.getCuda_function1();
		Object generatedKernel_wgs1 = device_param.getKernel_wgs1();
		Object generatedKernel_local_mem_size1 = device_param.getKernel_local_mem_size1();
		int generatedCuda_warp_size = device_param.getCuda_warp_size();
		Object generatedCuda_function2 = device_param.getCuda_function2();
		Object generatedKernel_wgs2 = device_param.getKernel_wgs2();
		Object generatedKernel_local_mem_size2 = device_param.getKernel_local_mem_size2();
		Object generatedCuda_function3 = device_param.getCuda_function3();
		Object generatedKernel_wgs3 = device_param.getKernel_wgs3();
		Object generatedKernel_local_mem_size3 = device_param.getKernel_local_mem_size3();
		Object generatedCuda_function4 = device_param.getCuda_function4();
		Object generatedKernel_wgs4 = device_param.getKernel_wgs4();
		Object generatedKernel_local_mem_size4 = device_param.getKernel_local_mem_size4();
		Object generatedCuda_function_tm = device_param.getCuda_function_tm();
		Object generatedKernel_wgs_tm = device_param.getKernel_wgs_tm();
		Object generatedKernel_local_mem_size_tm = device_param.getKernel_local_mem_size_tm();
		Object generatedCuda_function12 = device_param.getCuda_function12();
		Object generatedKernel_wgs12 = device_param.getKernel_wgs12();
		Object generatedKernel_local_mem_size12 = device_param.getKernel_local_mem_size12();
		Object generatedCuda_function23 = device_param.getCuda_function23();
		Object generatedKernel_wgs23 = device_param.getKernel_wgs23();
		Object generatedKernel_local_mem_size23 = device_param.getKernel_local_mem_size23();
		Object generatedCuda_function_init2 = device_param.getCuda_function_init2();
		Object generatedKernel_wgs_init2 = device_param.getKernel_wgs_init2();
		Object generatedKernel_local_mem_size_init2 = device_param.getKernel_local_mem_size_init2();
		Object generatedCuda_function_loop2 = device_param.getCuda_function_loop2();
		Object generatedKernel_wgs_loop2 = device_param.getKernel_wgs_loop2();
		Object generatedKernel_local_mem_size_loop2 = device_param.getKernel_local_mem_size_loop2();
		Object generatedCuda_function_aux1 = device_param.getCuda_function_aux1();
		Object generatedKernel_wgs_aux1 = device_param.getKernel_wgs_aux1();
		Object generatedKernel_local_mem_size_aux1 = device_param.getKernel_local_mem_size_aux1();
		Object generatedCuda_function_aux2 = device_param.getCuda_function_aux2();
		Object generatedKernel_wgs_aux2 = device_param.getKernel_wgs_aux2();
		Object generatedKernel_local_mem_size_aux2 = device_param.getKernel_local_mem_size_aux2();
		Object generatedCuda_function_aux3 = device_param.getCuda_function_aux3();
		Object generatedKernel_wgs_aux3 = device_param.getKernel_wgs_aux3();
		Object generatedKernel_local_mem_size_aux3 = device_param.getKernel_local_mem_size_aux3();
		Object generatedCuda_function_aux4 = device_param.getCuda_function_aux4();
		Object generatedKernel_wgs_aux4 = device_param.getKernel_wgs_aux4();
		Object generatedKernel_local_mem_size_aux4 = device_param.getKernel_local_mem_size_aux4();
		Object generatedCuda_function_memset = device_param.getCuda_function_memset();
		Object generatedKernel_wgs_memset = device_param.getKernel_wgs_memset();
		Object generatedKernel_local_mem_size_memset = device_param.getKernel_local_mem_size_memset();
		Object generatedCuda_function_atinit = device_param.getCuda_function_atinit();
		Object generatedKernel_wgs_atinit = device_param.getKernel_wgs_atinit();
		Object generatedKernel_local_mem_size_atinit = device_param.getKernel_local_mem_size_atinit();
		Object generatedCuda_function_decompress = device_param.getCuda_function_decompress();
		Object generatedKernel_wgs_decompress = device_param.getKernel_wgs_decompress();
		Object generatedKernel_local_mem_size_decompress = device_param.getKernel_local_mem_size_decompress();
		Object generatedCuda_function_mp_l = device_param.getCuda_function_mp_l();
		Object generatedKernel_wgs_mp_l = device_param.getKernel_wgs_mp_l();
		Object generatedKernel_local_mem_size_mp_l = device_param.getKernel_local_mem_size_mp_l();
		Object generatedCuda_function_mp_r = device_param.getCuda_function_mp_r();
		Object generatedKernel_wgs_mp_r = device_param.getKernel_wgs_mp_r();
		Object generatedKernel_local_mem_size_mp_r = device_param.getKernel_local_mem_size_mp_r();
		Object generatedCuda_function_mp = device_param.getCuda_function_mp();
		Object generatedKernel_wgs_mp = device_param.getKernel_wgs_mp();
		Object generatedKernel_local_mem_size_mp = device_param.getKernel_local_mem_size_mp();
		Object generatedCuda_function_amp = device_param.getCuda_function_amp();
		Object generatedKernel_wgs_amp = device_param.getKernel_wgs_amp();
		Object generatedKernel_local_mem_size_amp = device_param.getKernel_local_mem_size_amp();
		Object generatedSize_plains = device_param.getSize_plains();
		Object generatedSize_shown = device_param.getSize_shown();
		Object generatedSize_results = device_param.getSize_results();
		Object generatedOpencl_kernel1 = device_param.getOpencl_kernel1();
		Object generatedKernel_preferred_wgs_multiple1 = device_param.getKernel_preferred_wgs_multiple1();
		Object generatedOpencl_kernel2 = device_param.getOpencl_kernel2();
		Object generatedKernel_preferred_wgs_multiple2 = device_param.getKernel_preferred_wgs_multiple2();
		Object generatedOpencl_kernel3 = device_param.getOpencl_kernel3();
		Object generatedKernel_preferred_wgs_multiple3 = device_param.getKernel_preferred_wgs_multiple3();
		Object generatedOpencl_kernel4 = device_param.getOpencl_kernel4();
		Object generatedKernel_preferred_wgs_multiple4 = device_param.getKernel_preferred_wgs_multiple4();
		Object generatedOpencl_kernel_tm = device_param.getOpencl_kernel_tm();
		Object generatedKernel_preferred_wgs_multiple_tm = device_param.getKernel_preferred_wgs_multiple_tm();
		Object generatedOpencl_kernel12 = device_param.getOpencl_kernel12();
		Object generatedKernel_preferred_wgs_multiple12 = device_param.getKernel_preferred_wgs_multiple12();
		Object generatedOpencl_kernel23 = device_param.getOpencl_kernel23();
		Object generatedKernel_preferred_wgs_multiple23 = device_param.getKernel_preferred_wgs_multiple23();
		Object generatedOpencl_kernel_init2 = device_param.getOpencl_kernel_init2();
		Object generatedKernel_preferred_wgs_multiple_init2 = device_param.getKernel_preferred_wgs_multiple_init2();
		Object generatedOpencl_kernel_loop2 = device_param.getOpencl_kernel_loop2();
		Object generatedKernel_preferred_wgs_multiple_loop2 = device_param.getKernel_preferred_wgs_multiple_loop2();
		Object generatedOpencl_kernel_aux1 = device_param.getOpencl_kernel_aux1();
		Object generatedKernel_preferred_wgs_multiple_aux1 = device_param.getKernel_preferred_wgs_multiple_aux1();
		Object generatedOpencl_kernel_aux2 = device_param.getOpencl_kernel_aux2();
		Object generatedKernel_preferred_wgs_multiple_aux2 = device_param.getKernel_preferred_wgs_multiple_aux2();
		Object generatedOpencl_kernel_aux3 = device_param.getOpencl_kernel_aux3();
		Object generatedKernel_preferred_wgs_multiple_aux3 = device_param.getKernel_preferred_wgs_multiple_aux3();
		Object generatedOpencl_kernel_aux4 = device_param.getOpencl_kernel_aux4();
		Object generatedKernel_preferred_wgs_multiple_aux4 = device_param.getKernel_preferred_wgs_multiple_aux4();
		Object generatedOpencl_kernel_memset = device_param.getOpencl_kernel_memset();
		Object generatedKernel_preferred_wgs_multiple_memset = device_param.getKernel_preferred_wgs_multiple_memset();
		Object generatedOpencl_kernel_atinit = device_param.getOpencl_kernel_atinit();
		Object generatedKernel_preferred_wgs_multiple_atinit = device_param.getKernel_preferred_wgs_multiple_atinit();
		Object generatedOpencl_kernel_decompress = device_param.getOpencl_kernel_decompress();
		Object generatedKernel_preferred_wgs_multiple_decompress = device_param.getKernel_preferred_wgs_multiple_decompress();
		Object generatedOpencl_kernel_mp_l = device_param.getOpencl_kernel_mp_l();
		Object generatedKernel_preferred_wgs_multiple_mp_l = device_param.getKernel_preferred_wgs_multiple_mp_l();
		Object generatedOpencl_kernel_mp_r = device_param.getOpencl_kernel_mp_r();
		Object generatedKernel_preferred_wgs_multiple_mp_r = device_param.getKernel_preferred_wgs_multiple_mp_r();
		Object generatedOpencl_kernel_mp = device_param.getOpencl_kernel_mp();
		Object generatedKernel_preferred_wgs_multiple_mp = device_param.getKernel_preferred_wgs_multiple_mp();
		Object generatedOpencl_kernel_amp = device_param.getOpencl_kernel_amp();
		Object generatedKernel_preferred_wgs_multiple_amp = device_param.getKernel_preferred_wgs_multiple_amp();
		Object generatedHardware_power = device_param.getHardware_power();
		Object generatedDevice_maxmem_alloc = device_param.getDevice_maxmem_alloc();
		Object generatedDevice_available_mem = device_param.getDevice_available_mem();
		Object generatedCuda_d_pws_buf = device_param.getCuda_d_pws_buf();
		Object generatedCuda_d_pws_amp_buf = device_param.getCuda_d_pws_amp_buf();
		Object generatedCuda_d_pws_comp_buf = device_param.getCuda_d_pws_comp_buf();
		Object generatedCuda_d_pws_idx = device_param.getCuda_d_pws_idx();
		Object generatedCuda_d_tmps = device_param.getCuda_d_tmps();
		Object generatedCuda_d_hooks = device_param.getCuda_d_hooks();
		Object generatedSize_pws = device_param.getSize_pws();
		Object generatedSize_pws_amp = device_param.getSize_pws_amp();
		Object generatedSize_pws_comp = device_param.getSize_pws_comp();
		Object generatedSize_pws_idx = device_param.getSize_pws_idx();
		Object generatedSize_tmps = device_param.getSize_tmps();
		Object generatedSize_hooks = device_param.getSize_hooks();
		Object generatedOpencl_d_pws_buf = device_param.getOpencl_d_pws_buf();
		Object generatedOpencl_d_pws_amp_buf = device_param.getOpencl_d_pws_amp_buf();
		Object generatedOpencl_d_pws_comp_buf = device_param.getOpencl_d_pws_comp_buf();
		Object generatedOpencl_d_pws_idx = device_param.getOpencl_d_pws_idx();
		Object generatedOpencl_d_tmps = device_param.getOpencl_d_tmps();
		Object generatedOpencl_d_hooks = device_param.getOpencl_d_hooks();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx/**
		     * host buffer
		     */++) {
			hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			hashcat_ctx.event_call((event_identifier.EVENT_BACKEND_DEVICE_INIT_PRE), (backend_devices_idx), (/*Error: Unsupported expression*/));
			int device_id = generatedDevice_id;
			device_param.setSkipped_warning(0);
			if (module_ctx.getModule_unstable_warning() != (Object)-1) {
				boolean unstable_warning = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra, device_param);
				if ((unstable_warning == 1) && (user_options.getForce() == 0)) {
					hashcat_ctx.event_log_warning("* Device #%u: Skipping hash-mode %u - known CUDA/OpenCL Runtime/Driver issue (not a hashcat issue)", device_id + 1, hashconfig.getHash_mode());
					hashcat_ctx.event_log_warning("             You can use --force to override, but do not report related errors.");
					device_param.setSkipped_warning(1);
					continue;
				} 
			} 
			int vector_width = 0;
			if (user_options.getBackend_vector_width_chgd() == 0) {
				tuning_db_entry_t tuningdb_entry = new tuning_db_entry_t();
				if (user_options.getSlow_candidates() == 1) {
					tuningdb_entry = tuning_db_entry.tuning_db_search(hashcat_ctx, generatedDevice_name, generatedOpencl_device_type, 0, hashconfig.getHash_mode());
				} else {
						tuningdb_entry = tuning_db_entry.tuning_db_search(hashcat_ctx, generatedDevice_name, generatedOpencl_device_type, user_options.getAttack_mode(), hashconfig.getHash_mode());
				} 
				if (tuningdb_entry == (null) || generatedVector_width == -1) {
					if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_USES_BITS_64) {
						if (generatedIs_cuda == true) {
							vector_width = 1;
						} 
						if (generatedIs_opencl == true) {
							if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG, /*Error: sizeof expression not supported yet*/, vector_width, (null)) == -1) {
								return -1;
							} 
						} 
					} else {
							if (generatedIs_cuda == true) {
								vector_width = 1;
							} 
							if (generatedIs_opencl == true) {
								if (hashcat_ctx.hc_clGetDeviceInfo(generatedOpencl_device, CL_DEVICE_NATIVE_VECTOR_WIDTH_INT, /*Error: sizeof expression not supported yet*/, vector_width, (null)) == -1) {
									return -1;
								} 
							} 
					} 
				} else {
						vector_width = ()generatedVector_width;
				} 
			} else {
					vector_width = user_options.getBackend_vector_width();
			} 
			if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) {
				if (generatedOpencl_device_type & CL_DEVICE_TYPE_GPU) {
					vector_width = 1;
				} 
			} 
			if (vector_width > 16) {
				vector_width = 16;
			} 
			device_param.setVector_width(vector_width/**
			     * kernel accel and loops tuning db adjustment
			     */);
			device_param.setKernel_accel_min(hashconfig.getKernel_accel_min());
			device_param.setKernel_accel_max(hashconfig.getKernel_accel_max());
			device_param.setKernel_loops_min(hashconfig.getKernel_loops_min());
			device_param.setKernel_loops_max(hashconfig.getKernel_loops_max());
			device_param.setKernel_threads_min(hashconfig.getKernel_threads_min());
			device_param.setKernel_threads_max(hashconfig.getKernel_threads_max());
			tuning_db_entry_t tuningdb_entry = (null);
			if (user_options.getSlow_candidates() == 1) {
				tuningdb_entry = tuning_db_entry.tuning_db_search(hashcat_ctx, generatedDevice_name, generatedOpencl_device_type, 0, hashconfig.getHash_mode());
			} else {
					tuningdb_entry = tuning_db_entry.tuning_db_search(hashcat_ctx, generatedDevice_name, generatedOpencl_device_type, user_options.getAttack_mode(), hashconfig.getHash_mode());
			} 
			if (user_options.getKernel_accel_chgd() == 1) {
				u32 _kernel_accel = user_options.getKernel_accel();
				if ((_kernel_accel >= generatedKernel_accel_min) && (_kernel_accel <= generatedKernel_accel_max)) {
					device_param.setKernel_accel_min(_kernel_accel);
					device_param.setKernel_accel_max(_kernel_accel);
				} 
			} else {
					if (tuningdb_entry != (null)) {
						u32 _kernel_accel = generatedKernel_accel;
						if (_kernel_accel) {
							if ((_kernel_accel >= generatedKernel_accel_min) && (_kernel_accel <= generatedKernel_accel_max)) {
								device_param.setKernel_accel_min(_kernel_accel);
								device_param.setKernel_accel_max(_kernel_accel);
							} 
						} 
					} 
			} 
			if (user_options.getKernel_loops_chgd() == 1) {
				u32 _kernel_loops = user_options.getKernel_loops();
				if ((_kernel_loops >= generatedKernel_loops_min) && (_kernel_loops <= generatedKernel_loops_max)) {
					device_param.setKernel_loops_min(_kernel_loops);
					device_param.setKernel_loops_max(_kernel_loops);
				} 
			} else {
					if (tuningdb_entry != (null)) {
						u32 _kernel_loops = generatedKernel_loops;
						if (_kernel_loops) {
							if (user_options.getWorkload_profile() == 1) {
								_kernel_loops = (_kernel_loops > 8) ? _kernel_loops / 8 : 1;
							}  else if (user_options.getWorkload_profile() == 2) {
								_kernel_loops = (_kernel_loops > 4) ? _kernel_loops / 4 : 1;
							} 
							if ((_kernel_loops >= generatedKernel_loops_min) && (_kernel_loops <= generatedKernel_loops_max)) {
								device_param.setKernel_loops_min(_kernel_loops);
								device_param.setKernel_loops_max(_kernel_loops);
							} 
						} 
					} 
			} 
			if (user_options.getKernel_threads_chgd() == 1) {
				u32 _kernel_threads = user_options.getKernel_threads();
				if ((_kernel_threads >= generatedKernel_threads_min) && (_kernel_threads <= generatedKernel_threads_max)) {
					device_param.setKernel_threads_min(_kernel_threads);
					device_param.setKernel_threads_max(_kernel_threads);
				} 
			} 
			if (user_options.getSlow_candidates() == 1) {
			} else {
					if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
						if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_STRAIGHT) {
							device_param.setKernel_loops_min((((generatedKernel_loops_min) < (amplifier_count.KERNEL_RULES)) ? (generatedKernel_loops_min) : (amplifier_count.KERNEL_RULES)));
							device_param.setKernel_loops_max((((generatedKernel_loops_max) < (amplifier_count.KERNEL_RULES)) ? (generatedKernel_loops_max) : (amplifier_count.KERNEL_RULES)));
						}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_COMBI) {
							device_param.setKernel_loops_min((((generatedKernel_loops_min) < (amplifier_count.KERNEL_COMBS)) ? (generatedKernel_loops_min) : (amplifier_count.KERNEL_COMBS)));
							device_param.setKernel_loops_max((((generatedKernel_loops_max) < (amplifier_count.KERNEL_COMBS)) ? (generatedKernel_loops_max) : (amplifier_count.KERNEL_COMBS)));
						}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_BF) {
							device_param.setKernel_loops_min((((generatedKernel_loops_min) < (amplifier_count.KERNEL_BFS)) ? (generatedKernel_loops_min) : (amplifier_count.KERNEL_BFS)));
							device_param.setKernel_loops_max((((generatedKernel_loops_max) < (amplifier_count.KERNEL_BFS)) ? (generatedKernel_loops_max) : (amplifier_count.KERNEL_BFS)));
						} 
					} 
			} 
			device_param.setKernel_loops_min_sav(generatedKernel_loops_min);
			device_param.setKernel_loops_max_sav(generatedKernel_loops_max);
			u32 device_processors = generatedDevice_processors;
			if (generatedIs_cuda == true) {
				if (hashcat_ctx.hc_cuCtxCreate(generatedCuda_context, CUctx_flags_enum.CU_CTX_SCHED_BLOCKING_SYNC, generatedCuda_device) == -1) {
					return -1;
				} 
			} 
			if (generatedIs_opencl == true/*
			      cl_context_properties properties[3];
			
			      properties[0] = CL_CONTEXT_PLATFORM;
			      properties[1] = (cl_context_properties) device_param->opencl_platform;
			      properties[2] = 0;
			
			      CL_rc = hc_clCreateContext (hashcat_ctx, properties, 1, &device_param->opencl_device, NULL, NULL, &device_param->opencl_context);
			      */) {
				if (/*Error: Function owner not recognized*/hc_clCreateContext(hashcat_ctx, (null), 1, generatedOpencl_device, (null), (null), generatedOpencl_context) == -1) {
					return -1/**
					       * create command-queue
					       */;
				} 
				if (hashcat_ctx.hc_clCreateCommandQueue(generatedOpencl_context, generatedOpencl_device, CL_QUEUE_PROFILING_ENABLE, generatedOpencl_command_queue) == -1) {
					return -1/**
					     * create stream for CUDA devices
					     */;
				} 
			} 
			if (generatedIs_cuda == true) {
				if (hashcat_ctx.hc_cuStreamCreate(generatedCuda_stream, CUstream_flags_enum.CU_STREAM_DEFAULT) == -1) {
					return -1/**
					     * create events for CUDA devices
					     */;
				} 
			} 
			if (generatedIs_cuda == true) {
				if (hashcat_ctx.hc_cuEventCreate(generatedCuda_event1, CUevent_flags_enum.CU_EVENT_DEFAULT) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuEventCreate(generatedCuda_event2, CUevent_flags_enum.CU_EVENT_DEFAULT) == -1) {
					return -1/**
					     * create input buffers on device : calculate size of fixed memory buffers
					     */;
				} 
			} 
			u64 size_root_css = 256 * /*Error: Unsupported expression*/;
			u64 size_markov_css = 256 * -1024 * /*Error: Unsupported expression*/;
			device_param.setSize_root_css(size_root_css);
			device_param.setSize_markov_css(size_markov_css);
			u64 size_results = /*Error: Unsupported expression*/;
			device_param.setSize_results(size_results);
			u64 size_rules = (u64)straight_ctx.getKernel_rules_cnt() * /*Error: Unsupported expression*/;
			u64 size_rules_c = (u64)amplifier_count.KERNEL_RULES * /*Error: Unsupported expression*/;
			device_param.setSize_rules(size_rules);
			device_param.setSize_rules_c(size_rules_c);
			u64 size_plains = (u64)hashes.getDigests_cnt() * /*Error: Unsupported expression*/;
			u64 size_salts = (u64)hashes.getSalts_cnt() * /*Error: Unsupported expression*/;
			u64 size_esalts = (u64)hashes.getDigests_cnt() * hashconfig.getEsalt_size();
			u64 size_shown = (u64)hashes.getDigests_cnt() * /*Error: Unsupported expression*/;
			u64 size_digests = (u64)hashes.getDigests_cnt() * (u64)hashconfig.getDgst_size();
			device_param.setSize_plains(size_plains);
			device_param.setSize_digests(size_digests);
			device_param.setSize_shown(size_shown);
			device_param.setSize_salts(size_salts);
			device_param.setSize_esalts(size_esalts);
			u64 size_combs = amplifier_count.KERNEL_COMBS * /*Error: Unsupported expression*/;
			u64 size_bfs = amplifier_count.KERNEL_BFS * /*Error: Unsupported expression*/;
			u64 size_tm = 32 * /*Error: Unsupported expression*/;
			device_param.setSize_bfs(size_bfs);
			device_param.setSize_combs(size_combs);
			device_param.setSize_tm(size_tm);
			u64 size_st_digests = 1 * hashconfig.getDgst_size();
			u64 size_st_salts = 1 * /*Error: Unsupported expression*/;
			u64 size_st_esalts = 1 * hashconfig.getEsalt_size();
			device_param.setSize_st_digests(size_st_digests);
			device_param.setSize_st_salts(size_st_salts);
			device_param.setSize_st_esalts(size_st_esalts);
			u64 size_extra_buffer = 4;
			if (module_ctx.getModule_extra_buffer_size() != (Object)-1) {
				u64 extra_buffer_size = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra, hashes, device_param);
				if (extra_buffer_size == (u64)-1) {
					hashcat_ctx.event_log_error("Invalid extra buffer size.");
					return -1;
				} 
				device_param.setExtra_buffer_size(extra_buffer_size);
				size_extra_buffer = extra_buffer_size;
			} 
			u32 kern_type = hashconfig.getKern_type();
			if (module_ctx.getModule_kern_type_dynamic() != (Object)-1) {
				if (user_options.getBenchmark() == 1) {
				} else {
						Object digests_buf = hashes.getDigests_buf();
						salt_t salts_buf = hashes.getSalts_buf();
						Object esalts_buf = hashes.getEsalts_buf();
						Object hook_salts_buf = hashes.getHook_salts_buf();
						hashinfo_t hash_info = hashes.getHash_info();
						hashinfo_t hash_info_ptr = (null);
						if (hash_info) {
							hash_info_ptr = hash_info[0];
						} 
						kern_type = (u32)/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, digests_buf, salts_buf, esalts_buf, hook_salts_buf, hash_info_ptr);
				} 
			} 
			size_t build_options_sz = 4096;
			Byte build_options_buf = (byte)ModernizedCProgram.hcmalloc(build_options_sz);
			int build_options_len = 0;
			build_options_len += /*Error: Function owner not recognized*/snprintf(build_options_buf + build_options_len, build_options_sz - build_options_len, "-D KERNEL_STATIC -I OpenCL -I \"%s\" ", folder_config.getCpath_real());
			build_options_len += /*Error: Function owner not recognized*/snprintf(build_options_buf + build_options_len, build_options_sz - build_options_len, "-D LOCAL_MEM_TYPE=%d -D VENDOR_ID=%u -D CUDA_ARCH=%u -D HAS_VPERM=%u -D HAS_VADD3=%u -D HAS_VBFE=%u -D HAS_BFE=%u -D HAS_LOP3=%u -D HAS_MOV64=%u -D HAS_PRMT=%u -D VECT_SIZE=%d -D DEVICE_TYPE=%u -D DGST_R0=%u -D DGST_R1=%u -D DGST_R2=%u -D DGST_R3=%u -D DGST_ELEM=%u -D KERN_TYPE=%u -D ATTACK_EXEC=%u -D ATTACK_KERN=%u -D _unroll -w ", generatedDevice_local_mem_type, generatedOpencl_platform_vendor_id, (generatedSm_major * 100) + (generatedSm_minor * 10), generatedHas_vperm, generatedHas_vadd3, generatedHas_vbfe, generatedHas_bfe, generatedHas_lop3, generatedHas_mov64, generatedHas_prmt, generatedVector_width, (u32)generatedOpencl_device_type, hashconfig.getDgst_pos0(), hashconfig.getDgst_pos1(), hashconfig.getDgst_pos2(), hashconfig.getDgst_pos3(), hashconfig.getDgst_size() / 4, kern_type, hashconfig.getAttack_exec(), user_options_extra.getAttack_kern());
			build_options_buf[build_options_len] = 0/*
			    if (device_param->opencl_device_type & CL_DEVICE_TYPE_CPU)
			    {
			      if (device_param->opencl_platform_vendor_id == VENDOR_ID_INTEL_SDK)
			      {
			        strncat (build_options_buf, " -cl-opt-disable", 16);
			      }
			    }
			    */;
			Byte build_options_module_buf = (byte)ModernizedCProgram.hcmalloc(build_options_sz);
			int build_options_module_len = 0;
			build_options_module_len += /*Error: Function owner not recognized*/snprintf(build_options_module_buf + build_options_module_len, build_options_sz - build_options_module_len, "%s ", build_options_buf);
			if (module_ctx.getModule_jit_build_options() != (Object)-1) {
				Byte jit_build_options = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra, hashes, device_param);
				if (jit_build_options != (null)) {
					build_options_module_len += /*Error: Function owner not recognized*/snprintf(build_options_module_buf + build_options_module_len, build_options_sz - build_options_module_len, "%s", jit_build_options);
					u32 fixed_local_size = 0;
					if (/*Error: Function owner not recognized*/sscanf(jit_build_options, "-D FIXED_LOCAL_SIZE=%u", fixed_local_size) == 1) {
						device_param.setKernel_threads_min(fixed_local_size);
						device_param.setKernel_threads_max(fixed_local_size);
					} 
				} 
			} 
			build_options_module_buf[build_options_module_len] = 0;
			Byte device_name_chksum = (byte)ModernizedCProgram.hcmalloc(/**
			     * device_name_chksum
			     */-1024);
			Byte device_name_chksum_amp_mp = (byte)ModernizedCProgram.hcmalloc(-1024);
			size_t dnclen = /*Error: Function owner not recognized*/snprintf(device_name_chksum, -1024, "%d-%d-%d-%u-%s-%s-%s-%d-%u", generatedComptime, generatedCuda_driver_version, generatedIs_opencl, generatedOpencl_platform_vendor_id, generatedDevice_name, generatedOpencl_device_version, generatedOpencl_driver_version, generatedVector_width, hashconfig.getKern_type());
			size_t dnclen_amp_mp = /*Error: Function owner not recognized*/snprintf(device_name_chksum_amp_mp, -1024, "%d-%d-%d-%u-%s-%s-%s", generatedComptime, generatedCuda_driver_version, generatedIs_opencl, generatedOpencl_platform_vendor_id, generatedDevice_name, generatedOpencl_device_version, generatedOpencl_driver_version);
			md5_ctx_t md5_ctx = new md5_ctx_t();
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/md5_init(md5_ctx);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/md5_update(md5_ctx, (u32)device_name_chksum, dnclen);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/md5_final(md5_ctx);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(device_name_chksum, -1024, "%08x", generatedH[0]);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/md5_init(md5_ctx);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/md5_update(md5_ctx, (u32)device_name_chksum_amp_mp, dnclen_amp_mp);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/md5_final(md5_ctx);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(device_name_chksum_amp_mp, -1024, "%08x", generatedH[0/**
			     * kernel cache
			     */]);
			boolean cache_disable = false;
			if (generatedOpencl_platform_vendor_id == vendor_id.VENDOR_ID_APPLE) {
				if (generatedOpencl_device_type & CL_DEVICE_TYPE_CPU) {
					cache_disable = true;
				} 
			} 
			if (module_ctx.getModule_jit_cache_disable() != (Object)-1) {
				cache_disable = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra, hashes, device_param/**
				     * main kernel
				     */);
			} 
			{ 
				byte[] source_file = new byte[]{/**
				       * kernel source filename
				       */0};
				ModernizedCProgram.generate_source_kernel_filename(user_options.getSlow_candidates(), hashconfig.getAttack_exec(), user_options_extra.getAttack_kern(), kern_type, hashconfig.getOpti_type(), folder_config.getShared_dir(), source_file);
				if (ModernizedCProgram.hc_path_read(source_file) == 0) {
					hashcat_ctx.event_log_error("%s: %s", source_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1/**
					       * kernel cached filename
					       */;
				} 
				byte[] cached_file = new byte[]{0};
				ModernizedCProgram.generate_cached_kernel_filename(user_options.getSlow_candidates(), hashconfig.getAttack_exec(), user_options_extra.getAttack_kern(), kern_type, hashconfig.getOpti_type(), folder_config.getProfile_dir(), device_name_chksum, cached_file);
				boolean cached = true;
				if (cache_disable == true) {
					cached = false;
				} 
				if (ModernizedCProgram.hc_path_read(cached_file) == 0) {
					cached = false;
				} 
				if (ModernizedCProgram.hc_path_is_empty(cached_file) == 1) {
					cached = false/**
					       * kernel compile or load
					       */;
				} 
				size_t kernel_lengths_buf = 0;
				size_t kernel_lengths = kernel_lengths_buf;
				Byte kernel_sources_buf = (null);
				Byte kernel_sources = kernel_sources_buf;
				if (cached == false) {
					if (hashcat_ctx.read_kernel_binary(source_file, kernel_lengths, kernel_sources, 1) == 0) {
						return -1;
					} 
					if (generatedIs_cuda == true) {
						nvrtcProgram program = new nvrtcProgram();
						if (hashcat_ctx.hc_nvrtcCreateProgram(program, kernel_sources[0], "main_kernel", 0, (null), (null)) == -1) {
							return -1;
						} 
						Byte nvrtc_options = (byte)ModernizedCProgram.hccalloc(4 + /*Error: Function owner not recognized*/strlen(build_options_module_buf) + 1, /*Error: Unsupported expression*/);
						nvrtc_options[0] = "--restrict";
						nvrtc_options[1] = "--device-as-default-execution-space";
						nvrtc_options[2] = "--gpu-architecture";
						ModernizedCProgram.hc_asprintf(nvrtc_options[3], "compute_%d%d", generatedSm_major, generatedSm_minor);
						Byte nvrtc_options_string = ModernizedCProgram.hcstrdup(build_options_module_buf);
						int num_options = 4 + ModernizedCProgram.nvrtc_make_options_array_from_string(nvrtc_options_string, nvrtc_options + 4);
						int rc_nvrtcCompileProgram = hashcat_ctx.hc_nvrtcCompileProgram(program, num_options, (byte)nvrtc_options);
						size_t build_log_size = 0;
						hashcat_ctx.hc_nvrtcGetProgramLogSize(program, build_log_size);
						if (rc_nvrtcCompileProgram == -1) {
							Byte build_log = (byte)ModernizedCProgram.hcmalloc(build_log_size + 1);
							if (hashcat_ctx.hc_nvrtcGetProgramLog(program, build_log) == -1) {
								return -1;
							} 
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/puts(build_log);
							ModernizedCProgram.hcfree(build_log);
						} 
						if (rc_nvrtcCompileProgram == -1) {
							device_param.setSkipped_warning(1);
							hashcat_ctx.event_log_error("* Device #%u: Kernel %s build failed - proceeding without this device.", device_id + 1, source_file);
							continue;
						} 
						ModernizedCProgram.hcfree(nvrtc_options);
						ModernizedCProgram.hcfree(nvrtc_options_string);
						size_t binary_size = new size_t();
						if (hashcat_ctx.hc_nvrtcGetPTXSize(program, binary_size) == -1) {
							return -1;
						} 
						Byte binary = (byte)ModernizedCProgram.hcmalloc(binary_size);
						if (hashcat_ctx.hc_nvrtcGetPTX(program, binary) == -1) {
							return -1;
						} 
						if (hashcat_ctx.hc_nvrtcDestroyProgram(program) == -1) {
							return -1;
						} 
						int rc_cuModuleLoadDataEx = hashcat_ctx.hc_cuModuleLoadDataExLog(generatedCuda_module, binary);
						if (rc_cuModuleLoadDataEx == -1) {
							return -1;
						} 
						if (cache_disable == false) {
							boolean rc_write = hashcat_ctx.write_kernel_binary(cached_file, binary, binary_size);
							if (rc_write == 0) {
								return -1;
							} 
						} 
						ModernizedCProgram.hcfree(binary);
					} 
					if (generatedIs_opencl == true) {
						if (hashcat_ctx.hc_clCreateProgramWithSource(generatedOpencl_context, 1, (byte)kernel_sources, (null), generatedOpencl_program) == -1) {
							return -1;
						} 
						int CL_rc = /*Error: Function owner not recognized*/hc_clBuildProgram(hashcat_ctx, generatedOpencl_program, 1, generatedOpencl_device, build_options_module_buf, (null), (null));
						size_t build_log_size = 0;
						hashcat_ctx.hc_clGetProgramBuildInfo(generatedOpencl_program, generatedOpencl_device, CL_PROGRAM_BUILD_LOG, 0, (null), build_log_size);
						if (CL_rc == -1) {
							Byte build_log = (byte)ModernizedCProgram.hcmalloc(build_log_size + 1);
							int rc_clGetProgramBuildInfo = hashcat_ctx.hc_clGetProgramBuildInfo(generatedOpencl_program, generatedOpencl_device, CL_PROGRAM_BUILD_LOG, build_log_size, build_log, (null));
							if (rc_clGetProgramBuildInfo == -1) {
								return -1;
							} 
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/puts(build_log);
							ModernizedCProgram.hcfree(build_log);
						} 
						if (CL_rc == -1) {
							device_param.setSkipped_warning(1);
							hashcat_ctx.event_log_error("* Device #%u: Kernel %s build failed - proceeding without this device.", device_id + 1, source_file);
							continue;
						} 
						if (cache_disable == false) {
							size_t binary_size = new size_t();
							if (hashcat_ctx.hc_clGetProgramInfo(generatedOpencl_program, CL_PROGRAM_BINARY_SIZES, /*Error: Unsupported expression*/, binary_size, (null)) == -1) {
								return -1;
							} 
							Byte binary = (byte)ModernizedCProgram.hcmalloc(binary_size);
							if (hashcat_ctx.hc_clGetProgramInfo(generatedOpencl_program, CL_PROGRAM_BINARIES, /*Error: Unsupported expression*/, binary, (null)) == -1) {
								return -1;
							} 
							if (hashcat_ctx.write_kernel_binary(cached_file, binary, binary_size) == 0) {
								return -1;
							} 
							ModernizedCProgram.hcfree(binary);
						} 
					} 
				} else {
						if (hashcat_ctx.read_kernel_binary(cached_file, kernel_lengths, kernel_sources, 0) == 0) {
							return -1;
						} 
						if (generatedIs_cuda == true) {
							if (hashcat_ctx.hc_cuModuleLoadDataExLog(generatedCuda_module, kernel_sources[0]) == -1) {
								return -1;
							} 
						} 
						if (generatedIs_opencl == true) {
							if (hashcat_ctx.hc_clCreateProgramWithBinary(generatedOpencl_context, 1, generatedOpencl_device, kernel_lengths, (byte)kernel_sources, (null), generatedOpencl_program) == -1) {
								return -1;
							} 
							if (/*Error: Function owner not recognized*/hc_clBuildProgram(hashcat_ctx, generatedOpencl_program, 1, generatedOpencl_device, build_options_module_buf, (null), (null)) == -1) {
								return -1;
							} 
						} 
				} 
				ModernizedCProgram.hcfree(kernel_sources[0]);
			}
			ModernizedCProgram.hcfree(build_options_module_buf/**
			     * word generator kernel
			     */);
			if (user_options.getSlow_candidates() == 1) {
			} else {
					if (user_options.getAttack_mode() != attack_mode.ATTACK_MODE_STRAIGHT/**
					         * kernel mp source filename
					         */) {
						byte[] source_file = new byte[]{0};
						ModernizedCProgram.generate_source_kernel_mp_filename(hashconfig.getOpti_type(), hashconfig.getOpts_type(), folder_config.getShared_dir(), source_file);
						if (ModernizedCProgram.hc_path_read(source_file) == 0) {
							hashcat_ctx.event_log_error("%s: %s", source_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
							return -1/**
							         * kernel mp cached filename
							         */;
						} 
						byte[] cached_file = new byte[]{0};
						ModernizedCProgram.generate_cached_kernel_mp_filename(hashconfig.getOpti_type(), hashconfig.getOpts_type(), folder_config.getProfile_dir(), device_name_chksum_amp_mp, cached_file);
						boolean cached = true;
						if (cache_disable == true) {
							cached = false;
						} 
						if (ModernizedCProgram.hc_path_read(cached_file) == 0) {
							cached = false;
						} 
						if (ModernizedCProgram.hc_path_is_empty(cached_file) == 1) {
							cached = false/**
							         * kernel compile or load
							         */;
						} 
						size_t kernel_lengths_buf = 0;
						size_t kernel_lengths = kernel_lengths_buf;
						Byte kernel_sources_buf = (null);
						Byte kernel_sources = kernel_sources_buf;
						if (cached == false) {
							if (hashcat_ctx.read_kernel_binary(source_file, kernel_lengths, kernel_sources, 1) == 0) {
								return -1;
							} 
							if (generatedIs_cuda == true) {
								nvrtcProgram program = new nvrtcProgram();
								if (hashcat_ctx.hc_nvrtcCreateProgram(program, kernel_sources[0], "mp_kernel", 0, (null), (null)) == -1) {
									return -1;
								} 
								Byte nvrtc_options = (byte)ModernizedCProgram.hccalloc(4 + /*Error: Function owner not recognized*/strlen(build_options_buf) + 1, /*Error: Unsupported expression*/);
								nvrtc_options[0] = "--restrict";
								nvrtc_options[1] = "--device-as-default-execution-space";
								nvrtc_options[2] = "--gpu-architecture";
								ModernizedCProgram.hc_asprintf(nvrtc_options[3], "compute_%d%d", generatedSm_major, generatedSm_minor);
								Byte nvrtc_options_string = ModernizedCProgram.hcstrdup(build_options_buf);
								int num_options = 4 + ModernizedCProgram.nvrtc_make_options_array_from_string(nvrtc_options_string, nvrtc_options + 4);
								int rc_nvrtcCompileProgram = hashcat_ctx.hc_nvrtcCompileProgram(program, num_options, (byte)nvrtc_options);
								size_t build_log_size = 0;
								hashcat_ctx.hc_nvrtcGetProgramLogSize(program, build_log_size);
								if (rc_nvrtcCompileProgram == -1) {
									Byte build_log = (byte)ModernizedCProgram.hcmalloc(build_log_size + 1);
									if (hashcat_ctx.hc_nvrtcGetProgramLog(program, build_log) == -1) {
										return -1;
									} 
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/puts(build_log);
									ModernizedCProgram.hcfree(build_log);
								} 
								if (rc_nvrtcCompileProgram == -1) {
									device_param.setSkipped_warning(1);
									hashcat_ctx.event_log_error("* Device #%u: Kernel %s build failed - proceeding without this device.", device_id + 1, source_file);
									continue;
								} 
								ModernizedCProgram.hcfree(nvrtc_options);
								ModernizedCProgram.hcfree(nvrtc_options_string);
								size_t binary_size = 0;
								if (hashcat_ctx.hc_nvrtcGetPTXSize(program, binary_size) == -1) {
									return -1;
								} 
								Byte binary = (byte)ModernizedCProgram.hcmalloc(binary_size);
								if (hashcat_ctx.hc_nvrtcGetPTX(program, binary) == -1) {
									return -1;
								} 
								if (hashcat_ctx.hc_nvrtcDestroyProgram(program) == -1) {
									return -1;
								} 
								int rc_cuModuleLoadDataEx = hashcat_ctx.hc_cuModuleLoadDataExLog(generatedCuda_module_mp, binary);
								if (rc_cuModuleLoadDataEx == -1) {
									return -1;
								} 
								if (cache_disable == false) {
									boolean rc_write = hashcat_ctx.write_kernel_binary(cached_file, binary, binary_size);
									if (rc_write == 0) {
										return -1;
									} 
								} 
								ModernizedCProgram.hcfree(binary);
							} 
							if (generatedIs_opencl == true) {
								if (hashcat_ctx.hc_clCreateProgramWithSource(generatedOpencl_context, 1, (byte)kernel_sources, (null), generatedOpencl_program_mp) == -1) {
									return -1;
								} 
								int CL_rc = /*Error: Function owner not recognized*/hc_clBuildProgram(hashcat_ctx, generatedOpencl_program_mp, 1, generatedOpencl_device, build_options_buf, (null), (null));
								size_t build_log_size = 0;
								hashcat_ctx.hc_clGetProgramBuildInfo(generatedOpencl_program_mp, generatedOpencl_device, CL_PROGRAM_BUILD_LOG, 0, (null), build_log_size);
								if (CL_rc == -1) {
									Byte build_log = (byte)ModernizedCProgram.hcmalloc(build_log_size + 1);
									int rc_clGetProgramBuildInfo = hashcat_ctx.hc_clGetProgramBuildInfo(generatedOpencl_program_mp, generatedOpencl_device, CL_PROGRAM_BUILD_LOG, build_log_size, build_log, (null));
									if (rc_clGetProgramBuildInfo == -1) {
										return -1;
									} 
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/puts(build_log);
									ModernizedCProgram.hcfree(build_log);
								} 
								if (CL_rc == -1) {
									device_param.setSkipped_warning(1);
									hashcat_ctx.event_log_error("* Device #%u: Kernel %s build failed - proceeding without this device.", device_id + 1, source_file);
									continue;
								} 
								if (cache_disable == false) {
									size_t binary_size = 0;
									if (hashcat_ctx.hc_clGetProgramInfo(generatedOpencl_program_mp, CL_PROGRAM_BINARY_SIZES, /*Error: Unsupported expression*/, binary_size, (null)) == -1) {
										return -1;
									} 
									Byte binary = (byte)ModernizedCProgram.hcmalloc(binary_size);
									if (hashcat_ctx.hc_clGetProgramInfo(generatedOpencl_program_mp, CL_PROGRAM_BINARIES, /*Error: Unsupported expression*/, binary, (null)) == -1) {
										return -1;
									} 
									hashcat_ctx.write_kernel_binary(cached_file, binary, binary_size);
									ModernizedCProgram.hcfree(binary);
								} 
							} 
						} else {
								if (hashcat_ctx.read_kernel_binary(cached_file, kernel_lengths, kernel_sources, 0) == 0) {
									return -1;
								} 
								if (generatedIs_cuda == true) {
									if (hashcat_ctx.hc_cuModuleLoadDataExLog(generatedCuda_module_mp, kernel_sources[0]) == -1) {
										return -1;
									} 
								} 
								if (generatedIs_opencl == true) {
									if (hashcat_ctx.hc_clCreateProgramWithBinary(generatedOpencl_context, 1, generatedOpencl_device, kernel_lengths, (byte)kernel_sources, (null), generatedOpencl_program_mp) == -1) {
										return -1;
									} 
									if (/*Error: Function owner not recognized*/hc_clBuildProgram(hashcat_ctx, generatedOpencl_program_mp, 1, generatedOpencl_device, build_options_buf, (null), (null)) == -1) {
										return -1;
									} 
								} 
						} 
						ModernizedCProgram.hcfree(kernel_sources[0]);
					} 
			} 
			if (user_options.getSlow_candidates() == /**
			     * amplifier kernel
			     */1) {
			} else {
					if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
					} else {
							byte[] source_file = new byte[]{/**
							         * kernel amp source filename
							         */0};
							ModernizedCProgram.generate_source_kernel_amp_filename(user_options_extra.getAttack_kern(), folder_config.getShared_dir(), source_file);
							if (ModernizedCProgram.hc_path_read(source_file) == 0) {
								hashcat_ctx.event_log_error("%s: %s", source_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
								return -1/**
								         * kernel amp cached filename
								         */;
							} 
							byte[] cached_file = new byte[]{0};
							ModernizedCProgram.generate_cached_kernel_amp_filename(user_options_extra.getAttack_kern(), folder_config.getProfile_dir(), device_name_chksum_amp_mp, cached_file);
							boolean cached = true;
							if (cache_disable == true) {
								cached = false;
							} 
							if (ModernizedCProgram.hc_path_read(cached_file) == 0) {
								cached = false;
							} 
							if (ModernizedCProgram.hc_path_is_empty(cached_file) == 1) {
								cached = false/**
								         * kernel compile or load
								         */;
							} 
							size_t kernel_lengths_buf = 0;
							size_t kernel_lengths = kernel_lengths_buf;
							Byte kernel_sources_buf = (null);
							Byte kernel_sources = kernel_sources_buf;
							if (cached == false) {
								boolean rc_read_kernel = hashcat_ctx.read_kernel_binary(source_file, kernel_lengths, kernel_sources, 1);
								if (rc_read_kernel == 0) {
									return -1;
								} 
								if (generatedIs_cuda == true) {
									nvrtcProgram program = new nvrtcProgram();
									if (hashcat_ctx.hc_nvrtcCreateProgram(program, kernel_sources[0], "mp_kernel", 0, (null), (null)) == -1) {
										return -1;
									} 
									Byte nvrtc_options = (byte)ModernizedCProgram.hccalloc(4 + /*Error: Function owner not recognized*/strlen(build_options_buf) + 1, /*Error: Unsupported expression*/);
									nvrtc_options[0] = "--restrict";
									nvrtc_options[1] = "--device-as-default-execution-space";
									nvrtc_options[2] = "--gpu-architecture";
									ModernizedCProgram.hc_asprintf(nvrtc_options[3], "compute_%d%d", generatedSm_major, generatedSm_minor);
									Byte nvrtc_options_string = ModernizedCProgram.hcstrdup(build_options_buf);
									int num_options = 4 + ModernizedCProgram.nvrtc_make_options_array_from_string(nvrtc_options_string, nvrtc_options + 4);
									int rc_nvrtcCompileProgram = hashcat_ctx.hc_nvrtcCompileProgram(program, num_options, (byte)nvrtc_options);
									size_t build_log_size = 0;
									hashcat_ctx.hc_nvrtcGetProgramLogSize(program, build_log_size);
									if (rc_nvrtcCompileProgram == -1) {
										Byte build_log = (byte)ModernizedCProgram.hcmalloc(build_log_size + 1);
										if (hashcat_ctx.hc_nvrtcGetProgramLog(program, build_log) == -1) {
											return -1;
										} 
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/puts(build_log);
										ModernizedCProgram.hcfree(build_log);
									} 
									if (rc_nvrtcCompileProgram == -1) {
										device_param.setSkipped_warning(1);
										hashcat_ctx.event_log_error("* Device #%u: Kernel %s build failed - proceeding without this device.", device_id + 1, source_file);
										continue;
									} 
									ModernizedCProgram.hcfree(nvrtc_options);
									ModernizedCProgram.hcfree(nvrtc_options_string);
									size_t binary_size = 0;
									if (hashcat_ctx.hc_nvrtcGetPTXSize(program, binary_size) == -1) {
										return -1;
									} 
									Byte binary = (byte)ModernizedCProgram.hcmalloc(binary_size);
									if (hashcat_ctx.hc_nvrtcGetPTX(program, binary) == -1) {
										return -1;
									} 
									if (hashcat_ctx.hc_nvrtcDestroyProgram(program) == -1) {
										return -1;
									} 
									if (hashcat_ctx.hc_cuModuleLoadDataExLog(generatedCuda_module_amp, binary) == -1) {
										return -1;
									} 
									if (cache_disable == false) {
										if (hashcat_ctx.write_kernel_binary(cached_file, binary, binary_size) == 0) {
											return -1;
										} 
									} 
									ModernizedCProgram.hcfree(binary);
								} 
								if (generatedIs_opencl == true) {
									if (hashcat_ctx.hc_clCreateProgramWithSource(generatedOpencl_context, 1, (byte)kernel_sources, (null), generatedOpencl_program_amp) == -1) {
										return -1;
									} 
									int CL_rc = /*Error: Function owner not recognized*/hc_clBuildProgram(hashcat_ctx, generatedOpencl_program_amp, 1, generatedOpencl_device, build_options_buf, (null), (null));
									size_t build_log_size = 0;
									hashcat_ctx.hc_clGetProgramBuildInfo(generatedOpencl_program_amp, generatedOpencl_device, CL_PROGRAM_BUILD_LOG, 0, (null), build_log_size);
									if (CL_rc == -1) {
										Byte build_log = (byte)ModernizedCProgram.hcmalloc(build_log_size + 1);
										int rc_clGetProgramBuildInfo = hashcat_ctx.hc_clGetProgramBuildInfo(generatedOpencl_program_amp, generatedOpencl_device, CL_PROGRAM_BUILD_LOG, build_log_size, build_log, (null));
										if (rc_clGetProgramBuildInfo == -1) {
											return -1;
										} 
										/*Error: Function owner not recognized*//*Error: Function owner not recognized*/puts(build_log);
										ModernizedCProgram.hcfree(build_log);
									} 
									if (CL_rc == -1) {
										device_param.setSkipped_warning(1);
										hashcat_ctx.event_log_error("* Device #%u: Kernel %s build failed - proceeding without this device.", device_id + 1, source_file);
										continue;
									} 
									if (cache_disable == false) {
										size_t binary_size = new size_t();
										if (hashcat_ctx.hc_clGetProgramInfo(generatedOpencl_program_amp, CL_PROGRAM_BINARY_SIZES, /*Error: Unsupported expression*/, binary_size, (null)) == -1) {
											return -1;
										} 
										Byte binary = (byte)ModernizedCProgram.hcmalloc(binary_size);
										if (hashcat_ctx.hc_clGetProgramInfo(generatedOpencl_program_amp, CL_PROGRAM_BINARIES, /*Error: Unsupported expression*/, binary, (null)) == -1) {
											return -1;
										} 
										hashcat_ctx.write_kernel_binary(cached_file, binary, binary_size);
										ModernizedCProgram.hcfree(binary);
									} 
								} 
							} else {
									if (hashcat_ctx.read_kernel_binary(cached_file, kernel_lengths, kernel_sources, 0) == 0) {
										return -1;
									} 
									if (generatedIs_cuda == true) {
										if (hashcat_ctx.hc_cuModuleLoadDataExLog(generatedCuda_module_amp, kernel_sources[0]) == -1) {
											return -1;
										} 
									} 
									if (generatedIs_opencl == true) {
										if (hashcat_ctx.hc_clCreateProgramWithBinary(generatedOpencl_context, 1, generatedOpencl_device, kernel_lengths, (byte)kernel_sources, (null), generatedOpencl_program_amp) == -1) {
											return -1;
										} 
										if (/*Error: Function owner not recognized*/hc_clBuildProgram(hashcat_ctx, generatedOpencl_program_amp, 1, generatedOpencl_device, build_options_buf, (null), (null)) == -1) {
											return -1;
										} 
									} 
							} 
							ModernizedCProgram.hcfree(kernel_sources[0]);
							ModernizedCProgram.hcfree(build_options_buf);
					} 
			} 
			ModernizedCProgram.hcfree(device_name_chksum);
			ModernizedCProgram.hcfree(device_name_chksum_amp_mp);
			if (user_options.getBenchmark() == 1) {
				((u32)hashes.getDigests_buf())[0] = --1024;
				((u32)hashes.getDigests_buf())[1] = --1024;
				((u32)hashes.getDigests_buf())[2] = --1024;
				((u32)hashes.getDigests_buf())[3] = --1024/**
				     * global buffers
				     */;
			} 
			if (generatedIs_cuda == true) {
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_bitmap_s1_a, bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_bitmap_s1_b, bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_bitmap_s1_c, bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_bitmap_s1_d, bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_bitmap_s2_a, bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_bitmap_s2_b, bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_bitmap_s2_c, bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_bitmap_s2_d, bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_plain_bufs, size_plains) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_digests_buf, size_digests) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_digests_shown, size_shown) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_salt_bufs, size_salts) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_result, size_results) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_extra0_buf, size_extra_buffer / 4) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_extra1_buf, size_extra_buffer / 4) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_extra2_buf, size_extra_buffer / 4) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_extra3_buf, size_extra_buffer / 4) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_st_digests_buf, size_st_digests) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_st_salts_buf, size_st_salts) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_bitmap_s1_a, bitmap_ctx.getBitmap_s1_a(), bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_bitmap_s1_b, bitmap_ctx.getBitmap_s1_b(), bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_bitmap_s1_c, bitmap_ctx.getBitmap_s1_c(), bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_bitmap_s1_d, bitmap_ctx.getBitmap_s1_d(), bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_bitmap_s2_a, bitmap_ctx.getBitmap_s2_a(), bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_bitmap_s2_b, bitmap_ctx.getBitmap_s2_b(), bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_bitmap_s2_c, bitmap_ctx.getBitmap_s2_c(), bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_bitmap_s2_d, bitmap_ctx.getBitmap_s2_d(), bitmap_ctx.getBitmap_size()) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_digests_buf, hashes.getDigests_buf(), size_digests) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_salt_bufs, hashes.getSalts_buf(), size_salts) == -1) {
					return -1/**
					       * special buffers
					       */;
				} 
				if (user_options.getSlow_candidates() == 1) {
					if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_rules_c, size_rules_c) == -1) {
						return -1;
					} 
				} else {
						if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_STRAIGHT) {
							if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_rules, size_rules) == -1) {
								return -1;
							} 
							if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
								size_t dummy = 0;
								if (hashcat_ctx.hc_cuModuleGetGlobal(generatedCuda_d_rules_c, dummy, generatedCuda_module, "generic_constant") == -1) {
									return -1;
								} 
							} else {
									if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_rules_c, size_rules_c) == -1) {
										return -1;
									} 
							} 
							if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_rules, straight_ctx.getKernel_rules_buf(), size_rules) == -1) {
								return -1;
							} 
						}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_COMBI) {
							if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_combs, size_combs) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_combs_c, size_combs) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_root_css_buf, size_root_css) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_markov_css_buf, size_markov_css) == -1) {
								return -1;
							} 
						}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_BF) {
							if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_bfs, size_bfs) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_root_css_buf, size_root_css) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_markov_css_buf, size_markov_css) == -1) {
								return -1;
							} 
							if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
								size_t dummy = 0;
								if (hashcat_ctx.hc_cuModuleGetGlobal(generatedCuda_d_bfs_c, dummy, generatedCuda_module, "generic_constant") == -1) {
									return -1;
								} 
								if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_tm_c, size_tm) == -1) {
									return -1;
								} 
							} else {
									if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_bfs_c, size_bfs) == -1) {
										return -1;
									} 
									if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_tm_c, size_tm) == -1) {
										return -1;
									} 
							} 
						} 
				} 
				if (size_esalts) {
					if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_esalt_bufs, size_esalts) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_esalt_bufs, hashes.getEsalts_buf(), size_esalts) == -1) {
						return -1;
					} 
				} 
				if (hashconfig.getSt_hash() != (null)) {
					if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_st_digests_buf, hashes.getSt_digests_buf(), size_st_digests) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_st_salts_buf, hashes.getSt_salts_buf(), size_st_salts) == -1) {
						return -1;
					} 
					if (size_esalts) {
						if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_st_esalts_buf, size_st_esalts) == -1) {
							return -1;
						} 
						if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_st_esalts_buf, hashes.getSt_esalts_buf(), size_st_esalts) == -1) {
							return -1;
						} 
					} 
				} 
			} 
			if (generatedIs_opencl == true) {
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, bitmap_ctx.getBitmap_size(), (null), generatedOpencl_d_bitmap_s1_a) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, bitmap_ctx.getBitmap_size(), (null), generatedOpencl_d_bitmap_s1_b) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, bitmap_ctx.getBitmap_size(), (null), generatedOpencl_d_bitmap_s1_c) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, bitmap_ctx.getBitmap_size(), (null), generatedOpencl_d_bitmap_s1_d) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, bitmap_ctx.getBitmap_size(), (null), generatedOpencl_d_bitmap_s2_a) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, bitmap_ctx.getBitmap_size(), (null), generatedOpencl_d_bitmap_s2_b) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, bitmap_ctx.getBitmap_size(), (null), generatedOpencl_d_bitmap_s2_c) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, bitmap_ctx.getBitmap_size(), (null), generatedOpencl_d_bitmap_s2_d) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_WRITE, size_plains, (null), generatedOpencl_d_plain_bufs) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_digests, (null), generatedOpencl_d_digests_buf) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_WRITE, size_shown, (null), generatedOpencl_d_digests_shown) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_salts, (null), generatedOpencl_d_salt_bufs) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_WRITE, size_results, (null), generatedOpencl_d_result) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_WRITE, size_extra_buffer / 4, (null), generatedOpencl_d_extra0_buf) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_WRITE, size_extra_buffer / 4, (null), generatedOpencl_d_extra1_buf) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_WRITE, size_extra_buffer / 4, (null), generatedOpencl_d_extra2_buf) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_WRITE, size_extra_buffer / 4, (null), generatedOpencl_d_extra3_buf) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_st_digests, (null), generatedOpencl_d_st_digests_buf) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_st_salts, (null), generatedOpencl_d_st_salts_buf) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_bitmap_s1_a, CL_TRUE, 0, bitmap_ctx.getBitmap_size(), bitmap_ctx.getBitmap_s1_a(), 0, (null), (null)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_bitmap_s1_b, CL_TRUE, 0, bitmap_ctx.getBitmap_size(), bitmap_ctx.getBitmap_s1_b(), 0, (null), (null)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_bitmap_s1_c, CL_TRUE, 0, bitmap_ctx.getBitmap_size(), bitmap_ctx.getBitmap_s1_c(), 0, (null), (null)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_bitmap_s1_d, CL_TRUE, 0, bitmap_ctx.getBitmap_size(), bitmap_ctx.getBitmap_s1_d(), 0, (null), (null)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_bitmap_s2_a, CL_TRUE, 0, bitmap_ctx.getBitmap_size(), bitmap_ctx.getBitmap_s2_a(), 0, (null), (null)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_bitmap_s2_b, CL_TRUE, 0, bitmap_ctx.getBitmap_size(), bitmap_ctx.getBitmap_s2_b(), 0, (null), (null)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_bitmap_s2_c, CL_TRUE, 0, bitmap_ctx.getBitmap_size(), bitmap_ctx.getBitmap_s2_c(), 0, (null), (null)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_bitmap_s2_d, CL_TRUE, 0, bitmap_ctx.getBitmap_size(), bitmap_ctx.getBitmap_s2_d(), 0, (null), (null)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_digests_buf, CL_TRUE, 0, size_digests, hashes.getDigests_buf(), 0, (null), (null)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_salt_bufs, CL_TRUE, 0, size_salts, hashes.getSalts_buf(), 0, (null), (null)) == -1) {
					return -1/**
					       * special buffers
					       */;
				} 
				if (user_options.getSlow_candidates() == 1) {
					if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_rules_c, (null), generatedOpencl_d_rules_c) == -1) {
						return -1;
					} 
				} else {
						if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_STRAIGHT) {
							if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_rules, (null), generatedOpencl_d_rules) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_rules_c, (null), generatedOpencl_d_rules_c) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_rules, CL_TRUE, 0, size_rules, straight_ctx.getKernel_rules_buf(), 0, (null), (null)) == -1) {
								return -1;
							} 
						}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_COMBI) {
							if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_combs, (null), generatedOpencl_d_combs) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_combs, (null), generatedOpencl_d_combs_c) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_root_css, (null), generatedOpencl_d_root_css_buf) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_markov_css, (null), generatedOpencl_d_markov_css_buf) == -1) {
								return -1;
							} 
						}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_BF) {
							if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_bfs, (null), generatedOpencl_d_bfs) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_bfs, (null), generatedOpencl_d_bfs_c) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_tm, (null), generatedOpencl_d_tm_c) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_root_css, (null), generatedOpencl_d_root_css_buf) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_markov_css, (null), generatedOpencl_d_markov_css_buf) == -1) {
								return -1;
							} 
						} 
				} 
				if (size_esalts) {
					if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_esalts, (null), generatedOpencl_d_esalt_bufs) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_esalt_bufs, CL_TRUE, 0, size_esalts, hashes.getEsalts_buf(), 0, (null), (null)) == -1) {
						return -1;
					} 
				} 
				if (hashconfig.getSt_hash() != (null)) {
					if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_st_digests_buf, CL_TRUE, 0, size_st_digests, hashes.getSt_digests_buf(), 0, (null), (null)) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_st_salts_buf, CL_TRUE, 0, size_st_salts, hashes.getSt_salts_buf(), 0, (null), (null)) == -1) {
						return -1;
					} 
					if (size_esalts) {
						if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_st_esalts, (null), generatedOpencl_d_st_esalts_buf) == -1) {
							return -1;
						} 
						if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_st_esalts_buf, CL_TRUE, 0, size_st_esalts, hashes.getSt_esalts_buf(), 0, (null), (null)) == -1) {
							return -1;
						} 
					} 
				} 
			} 
			generatedKernel_params_buf32[24] = bitmap_ctx.getBitmap_mask();
			generatedKernel_params_buf32[25] = bitmap_ctx.getBitmap_shift1();
			generatedKernel_params_buf32[26] = bitmap_ctx.getBitmap_shift2();
			generatedKernel_params_buf32[27] = 0;
			generatedKernel_params_buf32[28] = 0;
			generatedKernel_params_buf32[29] = 0;
			generatedKernel_params_buf32[30] = 0;
			generatedKernel_params_buf32[31] = 0;
			generatedKernel_params_buf32[32] = 0;
			generatedKernel_params_buf32[33] = 0;
			generatedKernel_params_buf64[34] = 0;
			if (generatedIs_cuda == true) {
				generatedKernel_params[0] = (null);
				generatedKernel_params[1] = generatedCuda_d_rules_c;
				generatedKernel_params[2] = generatedCuda_d_combs_c;
				generatedKernel_params[3] = generatedCuda_d_bfs_c;
				generatedKernel_params[4] = (null);
				generatedKernel_params[5] = (null);
				generatedKernel_params[6] = generatedCuda_d_bitmap_s1_a;
				generatedKernel_params[7] = generatedCuda_d_bitmap_s1_b;
				generatedKernel_params[8] = generatedCuda_d_bitmap_s1_c;
				generatedKernel_params[9] = generatedCuda_d_bitmap_s1_d;
				generatedKernel_params[10] = generatedCuda_d_bitmap_s2_a;
				generatedKernel_params[11] = generatedCuda_d_bitmap_s2_b;
				generatedKernel_params[12] = generatedCuda_d_bitmap_s2_c;
				generatedKernel_params[13] = generatedCuda_d_bitmap_s2_d;
				generatedKernel_params[14] = generatedCuda_d_plain_bufs;
				generatedKernel_params[15] = generatedCuda_d_digests_buf;
				generatedKernel_params[16] = generatedCuda_d_digests_shown;
				generatedKernel_params[17] = generatedCuda_d_salt_bufs;
				generatedKernel_params[18] = generatedCuda_d_esalt_bufs;
				generatedKernel_params[19] = generatedCuda_d_result;
				generatedKernel_params[20] = generatedCuda_d_extra0_buf;
				generatedKernel_params[21] = generatedCuda_d_extra1_buf;
				generatedKernel_params[22] = generatedCuda_d_extra2_buf;
				generatedKernel_params[23] = generatedCuda_d_extra3_buf;
			} 
			if (generatedIs_opencl == true) {
				generatedKernel_params[0] = (null);
				generatedKernel_params[1] = generatedOpencl_d_rules_c;
				generatedKernel_params[2] = generatedOpencl_d_combs_c;
				generatedKernel_params[3] = generatedOpencl_d_bfs_c;
				generatedKernel_params[4] = (null);
				generatedKernel_params[5] = (null);
				generatedKernel_params[6] = generatedOpencl_d_bitmap_s1_a;
				generatedKernel_params[7] = generatedOpencl_d_bitmap_s1_b;
				generatedKernel_params[8] = generatedOpencl_d_bitmap_s1_c;
				generatedKernel_params[9] = generatedOpencl_d_bitmap_s1_d;
				generatedKernel_params[10] = generatedOpencl_d_bitmap_s2_a;
				generatedKernel_params[11] = generatedOpencl_d_bitmap_s2_b;
				generatedKernel_params[12] = generatedOpencl_d_bitmap_s2_c;
				generatedKernel_params[13] = generatedOpencl_d_bitmap_s2_d;
				generatedKernel_params[14] = generatedOpencl_d_plain_bufs;
				generatedKernel_params[15] = generatedOpencl_d_digests_buf;
				generatedKernel_params[16] = generatedOpencl_d_digests_shown;
				generatedKernel_params[17] = generatedOpencl_d_salt_bufs;
				generatedKernel_params[18] = generatedOpencl_d_esalt_bufs;
				generatedKernel_params[19] = generatedOpencl_d_result;
				generatedKernel_params[20] = generatedOpencl_d_extra0_buf;
				generatedKernel_params[21] = generatedOpencl_d_extra1_buf;
				generatedKernel_params[22] = generatedOpencl_d_extra2_buf;
				generatedKernel_params[23] = generatedOpencl_d_extra3_buf;
			} 
			generatedKernel_params[24] = generatedKernel_params_buf32[24];
			generatedKernel_params[25] = generatedKernel_params_buf32[25];
			generatedKernel_params[26] = generatedKernel_params_buf32[26];
			generatedKernel_params[27] = generatedKernel_params_buf32[27];
			generatedKernel_params[28] = generatedKernel_params_buf32[28];
			generatedKernel_params[29] = generatedKernel_params_buf32[29];
			generatedKernel_params[30] = generatedKernel_params_buf32[30];
			generatedKernel_params[31] = generatedKernel_params_buf32[31];
			generatedKernel_params[32] = generatedKernel_params_buf32[32];
			generatedKernel_params[33] = generatedKernel_params_buf32[33];
			generatedKernel_params[34] = generatedKernel_params_buf64[34];
			if (user_options.getSlow_candidates() == 1) {
			} else {
					generatedKernel_params_mp_buf64[3] = 0;
					generatedKernel_params_mp_buf32[4] = 0;
					generatedKernel_params_mp_buf32[5] = 0;
					generatedKernel_params_mp_buf32[6] = 0;
					generatedKernel_params_mp_buf32[7] = 0;
					generatedKernel_params_mp_buf64[8] = 0;
					if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
						if (generatedIs_cuda == true) {
							generatedKernel_params_mp[0] = generatedCuda_d_combs;
						} 
						if (generatedIs_opencl == true) {
							generatedKernel_params_mp[0] = generatedOpencl_d_combs;
						} 
					} else {
							if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
								if (generatedIs_cuda == true) {
									generatedKernel_params_mp[0] = generatedCuda_d_combs;
								} 
								if (generatedIs_opencl == true) {
									generatedKernel_params_mp[0] = generatedOpencl_d_combs;
								} 
							} else {
									generatedKernel_params_mp[0] = (null);
							} 
					} 
					if (generatedIs_cuda == true) {
						generatedKernel_params_mp[1] = generatedCuda_d_root_css_buf;
						generatedKernel_params_mp[2] = generatedCuda_d_markov_css_buf;
					} 
					if (generatedIs_opencl == true) {
						generatedKernel_params_mp[1] = generatedOpencl_d_root_css_buf;
						generatedKernel_params_mp[2] = generatedOpencl_d_markov_css_buf;
					} 
					generatedKernel_params_mp[3] = generatedKernel_params_mp_buf64[3];
					generatedKernel_params_mp[4] = generatedKernel_params_mp_buf32[4];
					generatedKernel_params_mp[5] = generatedKernel_params_mp_buf32[5];
					generatedKernel_params_mp[6] = generatedKernel_params_mp_buf32[6];
					generatedKernel_params_mp[7] = generatedKernel_params_mp_buf32[7];
					generatedKernel_params_mp[8] = generatedKernel_params_mp_buf64[8];
					generatedKernel_params_mp_l_buf64[3] = 0;
					generatedKernel_params_mp_l_buf32[4] = 0;
					generatedKernel_params_mp_l_buf32[5] = 0;
					generatedKernel_params_mp_l_buf32[6] = 0;
					generatedKernel_params_mp_l_buf32[7] = 0;
					generatedKernel_params_mp_l_buf32[8] = 0;
					generatedKernel_params_mp_l_buf64[9] = 0;
					generatedKernel_params_mp_l[0] = (null);
					if (generatedIs_cuda == true) {
						generatedKernel_params_mp_l[1] = generatedCuda_d_root_css_buf;
						generatedKernel_params_mp_l[2] = generatedCuda_d_markov_css_buf;
					} 
					if (generatedIs_opencl == true) {
						generatedKernel_params_mp_l[1] = generatedOpencl_d_root_css_buf;
						generatedKernel_params_mp_l[2] = generatedOpencl_d_markov_css_buf;
					} 
					generatedKernel_params_mp_l[3] = generatedKernel_params_mp_l_buf64[3];
					generatedKernel_params_mp_l[4] = generatedKernel_params_mp_l_buf32[4];
					generatedKernel_params_mp_l[5] = generatedKernel_params_mp_l_buf32[5];
					generatedKernel_params_mp_l[6] = generatedKernel_params_mp_l_buf32[6];
					generatedKernel_params_mp_l[7] = generatedKernel_params_mp_l_buf32[7];
					generatedKernel_params_mp_l[8] = generatedKernel_params_mp_l_buf32[8];
					generatedKernel_params_mp_l[9] = generatedKernel_params_mp_l_buf64[9];
					generatedKernel_params_mp_r_buf64[3] = 0;
					generatedKernel_params_mp_r_buf32[4] = 0;
					generatedKernel_params_mp_r_buf32[5] = 0;
					generatedKernel_params_mp_r_buf32[6] = 0;
					generatedKernel_params_mp_r_buf32[7] = 0;
					generatedKernel_params_mp_r_buf64[8] = 0;
					if (generatedIs_cuda == true) {
						generatedKernel_params_mp_r[0] = generatedCuda_d_bfs;
						generatedKernel_params_mp_r[1] = generatedCuda_d_root_css_buf;
						generatedKernel_params_mp_r[2] = generatedCuda_d_markov_css_buf;
					} 
					if (generatedIs_opencl == true) {
						generatedKernel_params_mp_r[0] = generatedOpencl_d_bfs;
						generatedKernel_params_mp_r[1] = generatedOpencl_d_root_css_buf;
						generatedKernel_params_mp_r[2] = generatedOpencl_d_markov_css_buf;
					} 
					generatedKernel_params_mp_r[3] = generatedKernel_params_mp_r_buf64[3];
					generatedKernel_params_mp_r[4] = generatedKernel_params_mp_r_buf32[4];
					generatedKernel_params_mp_r[5] = generatedKernel_params_mp_r_buf32[5];
					generatedKernel_params_mp_r[6] = generatedKernel_params_mp_r_buf32[6];
					generatedKernel_params_mp_r[7] = generatedKernel_params_mp_r_buf32[7];
					generatedKernel_params_mp_r[8] = generatedKernel_params_mp_r_buf64[8];
					generatedKernel_params_amp_buf32[5] = 0;
					generatedKernel_params_amp_buf64[6] = 0;
					if (generatedIs_cuda == true) {
						generatedKernel_params_amp[0] = (null);
						generatedKernel_params_amp[1] = (null);
						generatedKernel_params_amp[2] = generatedCuda_d_rules_c;
						generatedKernel_params_amp[3] = generatedCuda_d_combs_c;
						generatedKernel_params_amp[4] = generatedCuda_d_bfs_c;
					} 
					if (generatedIs_opencl == true) {
						generatedKernel_params_amp[0] = (null);
						generatedKernel_params_amp[1] = (null);
						generatedKernel_params_amp[2] = generatedOpencl_d_rules_c;
						generatedKernel_params_amp[3] = generatedOpencl_d_combs_c;
						generatedKernel_params_amp[4] = generatedOpencl_d_bfs_c;
					} 
					generatedKernel_params_amp[5] = generatedKernel_params_amp_buf32[5];
					generatedKernel_params_amp[6] = generatedKernel_params_amp_buf64[6];
					if (generatedIs_cuda == true) {
						generatedKernel_params_tm[0] = generatedCuda_d_bfs_c;
						generatedKernel_params_tm[1] = generatedCuda_d_tm_c;
					} 
					if (generatedIs_opencl == true) {
						generatedKernel_params_tm[0] = generatedOpencl_d_bfs_c;
						generatedKernel_params_tm[1] = generatedOpencl_d_tm_c;
					} 
			} 
			generatedKernel_params_memset_buf32[1] = 0;
			generatedKernel_params_memset_buf64[2] = 0;
			generatedKernel_params_memset[0] = (null);
			generatedKernel_params_memset[1] = generatedKernel_params_memset_buf32[1];
			generatedKernel_params_memset[2] = generatedKernel_params_memset_buf64[2];
			generatedKernel_params_atinit_buf64[1] = 0;
			generatedKernel_params_atinit[0] = (null);
			generatedKernel_params_atinit[1] = generatedKernel_params_atinit_buf64[1];
			generatedKernel_params_decompress_buf64[3] = 0;
			if (generatedIs_cuda == true) {
				generatedKernel_params_decompress[0] = (null);
				generatedKernel_params_decompress[1] = (null);
				generatedKernel_params_decompress[2] = (null);
			} 
			if (generatedIs_opencl == true) {
				generatedKernel_params_decompress[0] = (null);
				generatedKernel_params_decompress[1] = (null);
				generatedKernel_params_decompress[2] = (null);
			} 
			generatedKernel_params_decompress[3] = generatedKernel_params_decompress_buf64[3/**
			     * kernel name
			     */];
			if (generatedIs_cuda == true) {
				byte[] kernel_name = new byte[]{0};
				if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
					if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_SINGLE_HASH) {
						if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_s%02d", kern_type, 4);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function1, generatedCuda_module, kernel_name) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function1, generatedKernel_wgs1) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function1, generatedKernel_local_mem_size1) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple1(generatedCuda_warp_size);
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_s%02d", kern_type, 8);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function2, generatedCuda_module, kernel_name) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function2, generatedKernel_wgs2) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function2, generatedKernel_local_mem_size2) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple2(generatedCuda_warp_size);
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_s%02d", kern_type, 16);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function3, generatedCuda_module, kernel_name) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function3, generatedKernel_wgs3) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function3, generatedKernel_local_mem_size3) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple3(generatedCuda_warp_size);
						} else {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_sxx", kern_type);
								if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function4, generatedCuda_module, kernel_name) == -1) {
									return -1;
								} 
								if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function4, generatedKernel_wgs4) == -1) {
									return -1;
								} 
								if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function4, generatedKernel_local_mem_size4) == -1) {
									return -1;
								} 
								device_param.setKernel_preferred_wgs_multiple4(generatedCuda_warp_size);
						} 
					} else {
							if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_m%02d", kern_type, 4);
								if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function1, generatedCuda_module, kernel_name) == -1) {
									return -1;
								} 
								if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function1, generatedKernel_wgs1) == -1) {
									return -1;
								} 
								if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function1, generatedKernel_local_mem_size1) == -1) {
									return -1;
								} 
								device_param.setKernel_preferred_wgs_multiple1(generatedCuda_warp_size);
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_m%02d", kern_type, 8);
								if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function2, generatedCuda_module, kernel_name) == -1) {
									return -1;
								} 
								if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function2, generatedKernel_wgs2) == -1) {
									return -1;
								} 
								if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function2, generatedKernel_local_mem_size2) == -1) {
									return -1;
								} 
								device_param.setKernel_preferred_wgs_multiple2(generatedCuda_warp_size);
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_m%02d", kern_type, 16);
								if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function3, generatedCuda_module, kernel_name) == -1) {
									return -1;
								} 
								if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function3, generatedKernel_wgs3) == -1) {
									return -1;
								} 
								if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function3, generatedKernel_local_mem_size3) == -1) {
									return -1;
								} 
								device_param.setKernel_preferred_wgs_multiple3(generatedCuda_warp_size);
							} else {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_mxx", kern_type);
									if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function4, generatedCuda_module, kernel_name) == -1) {
										return -1;
									} 
									if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function4, generatedKernel_wgs4) == -1) {
										return -1;
									} 
									if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function4, generatedKernel_local_mem_size4) == -1) {
										return -1;
									} 
									device_param.setKernel_preferred_wgs_multiple4(generatedCuda_warp_size);
							} 
					} 
					if (user_options.getSlow_candidates() == 1) {
					} else {
							if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_BITSLICE) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_tm", kern_type);
									if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_tm, generatedCuda_module, kernel_name) == -1) {
										return -1;
									} 
									if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_tm, generatedKernel_wgs_tm) == -1) {
										return -1;
									} 
									if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_tm, generatedKernel_local_mem_size_tm) == -1) {
										return -1;
									} 
									device_param.setKernel_preferred_wgs_multiple_tm(generatedCuda_warp_size);
								} 
							} 
					} 
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_init", kern_type);
						if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function1, generatedCuda_module, kernel_name) == -1) {
							return -1;
						} 
						if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function1, generatedKernel_wgs1) == -1) {
							return -1;
						} 
						if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function1, generatedKernel_local_mem_size1) == -1) {
							return -1;
						} 
						device_param.setKernel_preferred_wgs_multiple1(generatedCuda_warp_size);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_loop", kern_type);
						if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function2, generatedCuda_module, kernel_name) == -1) {
							return -1;
						} 
						if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function2, generatedKernel_wgs2) == -1) {
							return -1;
						} 
						if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function2, generatedKernel_local_mem_size2) == -1) {
							return -1;
						} 
						device_param.setKernel_preferred_wgs_multiple2(generatedCuda_warp_size);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_comp", kern_type);
						if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function3, generatedCuda_module, kernel_name) == -1) {
							return -1;
						} 
						if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function3, generatedKernel_wgs3) == -1) {
							return -1;
						} 
						if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function3, generatedKernel_local_mem_size3) == -1) {
							return -1;
						} 
						device_param.setKernel_preferred_wgs_multiple3(generatedCuda_warp_size);
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_HOOK12) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_hook12", kern_type);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function12, generatedCuda_module, kernel_name) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function12, generatedKernel_wgs12) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function12, generatedKernel_local_mem_size12) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple12(generatedCuda_warp_size);
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_HOOK23) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_hook23", kern_type);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function23, generatedCuda_module, kernel_name) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function23, generatedKernel_wgs23) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function23, generatedKernel_local_mem_size23) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple23(generatedCuda_warp_size);
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_INIT2) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_init2", kern_type);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_init2, generatedCuda_module, kernel_name) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_init2, generatedKernel_wgs_init2) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_init2, generatedKernel_local_mem_size_init2) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple_init2(generatedCuda_warp_size);
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_LOOP2) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_loop2", kern_type);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_loop2, generatedCuda_module, kernel_name) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_loop2, generatedKernel_wgs_loop2) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_loop2, generatedKernel_local_mem_size_loop2) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple_loop2(generatedCuda_warp_size);
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_AUX1) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_aux1", kern_type);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_aux1, generatedCuda_module, kernel_name) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_aux1, generatedKernel_wgs_aux1) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_aux1, generatedKernel_local_mem_size_aux1) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple_aux1(generatedCuda_warp_size);
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_AUX2) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_aux2", kern_type);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_aux2, generatedCuda_module, kernel_name) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_aux2, generatedKernel_wgs_aux2) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_aux2, generatedKernel_local_mem_size_aux2) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple_aux2(generatedCuda_warp_size);
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_AUX3) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_aux3", kern_type);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_aux3, generatedCuda_module, kernel_name) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_aux3, generatedKernel_wgs_aux3) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_aux3, generatedKernel_local_mem_size_aux3) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple_aux3(generatedCuda_warp_size);
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_AUX4) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_aux4", kern_type);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_aux4, generatedCuda_module, kernel_name) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_aux4, generatedKernel_wgs_aux4) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_aux4, generatedKernel_local_mem_size_aux4) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple_aux4(generatedCuda_warp_size);
						} 
				} 
				if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_memset, generatedCuda_module, "gpu_memset") == -1) {
					return -1;
				} 
				if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_memset, generatedKernel_wgs_memset) == -1) {
					return -1;
				} 
				if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_memset, generatedKernel_local_mem_size_memset) == -1) {
					return -1;
				} 
				device_param.setKernel_preferred_wgs_multiple_memset(generatedCuda_warp_size);
				if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_atinit, generatedCuda_module, "gpu_atinit") == -1) {
					return -1;
				} 
				if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_atinit, generatedKernel_wgs_atinit) == -1) {
					return -1;
				} 
				if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_atinit, generatedKernel_local_mem_size_atinit) == -1) {
					return -1;
				} 
				device_param.setKernel_preferred_wgs_multiple_atinit(generatedCuda_warp_size);
				if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_decompress, generatedCuda_module, "gpu_decompress") == -1) {
					return -1;
				} 
				if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_decompress, generatedKernel_wgs_decompress) == -1) {
					return -1;
				} 
				if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_decompress, generatedKernel_local_mem_size_decompress) == -1) {
					return -1;
				} 
				device_param.setKernel_preferred_wgs_multiple_decompress(generatedCuda_warp_size);
				if (user_options.getSlow_candidates() == 1) {
				} else {
						if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_mp_l, generatedCuda_module_mp, "l_markov") == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_mp_l, generatedKernel_wgs_mp_l) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_mp_l, generatedKernel_local_mem_size_mp_l) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple_mp_l(generatedCuda_warp_size);
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_mp_r, generatedCuda_module_mp, "r_markov") == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_mp_r, generatedKernel_wgs_mp_r) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_mp_r, generatedKernel_local_mem_size_mp_r) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple_mp_r(generatedCuda_warp_size);
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_BITSLICE) {
							} 
						}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_mp, generatedCuda_module_mp, "C_markov") == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_mp, generatedKernel_wgs_mp) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_mp, generatedKernel_local_mem_size_mp) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple_mp(generatedCuda_warp_size);
						}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
							if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_mp, generatedCuda_module_mp, "C_markov") == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_mp, generatedKernel_wgs_mp) == -1) {
								return -1;
							} 
							if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_mp, generatedKernel_local_mem_size_mp) == -1) {
								return -1;
							} 
							device_param.setKernel_preferred_wgs_multiple_mp(generatedCuda_warp_size);
						} 
				} 
				if (user_options.getSlow_candidates() == 1) {
				} else {
						if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
						} else {
								if (hashcat_ctx.hc_cuModuleGetFunction(generatedCuda_function_amp, generatedCuda_module_amp, "amp") == -1) {
									return -1;
								} 
								if (hashcat_ctx.get_cuda_kernel_wgs(generatedCuda_function_amp, generatedKernel_wgs_amp) == -1) {
									return -1;
								} 
								if (hashcat_ctx.get_cuda_kernel_local_mem_size(generatedCuda_function_amp, generatedKernel_local_mem_size_amp) == -1) {
									return -1;
								} 
								device_param.setKernel_preferred_wgs_multiple_amp(generatedCuda_warp_size);
						} 
				} 
				if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_plain_bufs, generatedSize_plains) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_digests_shown, generatedSize_shown) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_result, generatedSize_results) == -1) {
					return -1/**
					       * special buffers
					       */;
				} 
				if (user_options.getSlow_candidates() == 1) {
					if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_rules_c, size_rules_c) == -1) {
						return -1;
					} 
				} else {
						if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_STRAIGHT) {
							if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_rules_c, size_rules_c) == -1) {
								return -1;
							} 
						}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_COMBI) {
							if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_combs, size_combs) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_combs_c, size_combs) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_root_css_buf, size_root_css) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_markov_css_buf, size_markov_css) == -1) {
								return -1;
							} 
						}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_BF) {
							if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_bfs, size_bfs) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_bfs_c, size_bfs) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_tm_c, size_tm) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_root_css_buf, size_root_css) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_markov_css_buf, size_markov_css) == -1) {
								return -1;
							} 
						} 
				} 
				if (user_options.getSlow_candidates() == 1) {
				} else {
						if ((user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) || (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2/**
						           * prepare mp
						           */)) {
							if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
								generatedKernel_params_mp_buf32[5] = 0;
								generatedKernel_params_mp_buf32[6] = 0;
								generatedKernel_params_mp_buf32[7] = 0;
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD01) {
									generatedKernel_params_mp_buf32[5] = ModernizedCProgram.full01;
								} 
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD06) {
									generatedKernel_params_mp_buf32[5] = ModernizedCProgram.full06;
								} 
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD80) {
									generatedKernel_params_mp_buf32[5] = ModernizedCProgram.full80;
								} 
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADDBITS14) {
									generatedKernel_params_mp_buf32[6] = 1;
								} 
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADDBITS15) {
									generatedKernel_params_mp_buf32[7] = 1;
								} 
							}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
								generatedKernel_params_mp_buf32[5] = 0;
								generatedKernel_params_mp_buf32[6] = 0;
								generatedKernel_params_mp_buf32[7] = 0;
							} 
						}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF/**
						           * prepare mp_r and mp_l
						           */) {
							generatedKernel_params_mp_l_buf32[6] = 0;
							generatedKernel_params_mp_l_buf32[7] = 0;
							generatedKernel_params_mp_l_buf32[8] = 0;
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD01) {
								generatedKernel_params_mp_l_buf32[6] = ModernizedCProgram.full01;
							} 
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD06) {
								generatedKernel_params_mp_l_buf32[6] = ModernizedCProgram.full06;
							} 
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD80) {
								generatedKernel_params_mp_l_buf32[6] = ModernizedCProgram.full80;
							} 
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADDBITS14) {
								generatedKernel_params_mp_l_buf32[7] = 1;
							} 
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADDBITS15) {
								generatedKernel_params_mp_l_buf32[8] = 1;
							} 
						} 
				} 
			} 
			if (generatedIs_opencl == true) {
				byte[] kernel_name = new byte[]{0};
				if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
					if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_SINGLE_HASH) {
						if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_s%02d", kern_type, 4);
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel1) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel1, generatedKernel_wgs1) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel1, generatedKernel_local_mem_size1) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel1, generatedKernel_preferred_wgs_multiple1) == -1) {
								return -1;
							} 
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_s%02d", kern_type, 8);
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel2, generatedKernel_wgs2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel2, generatedKernel_local_mem_size2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel2, generatedKernel_preferred_wgs_multiple2) == -1) {
								return -1;
							} 
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_s%02d", kern_type, 16);
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel3) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel3, generatedKernel_wgs3) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel3, generatedKernel_local_mem_size3) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel3, generatedKernel_preferred_wgs_multiple3) == -1) {
								return -1;
							} 
						} else {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_sxx", kern_type);
								if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel4) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel4, generatedKernel_wgs4) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel4, generatedKernel_local_mem_size4) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel4, generatedKernel_preferred_wgs_multiple4) == -1) {
									return -1;
								} 
						} 
					} else {
							if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_m%02d", kern_type, 4);
								if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel1) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel1, generatedKernel_wgs1) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel1, generatedKernel_local_mem_size1) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel1, generatedKernel_preferred_wgs_multiple1) == -1) {
									return -1;
								} 
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_m%02d", kern_type, 8);
								if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel2) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel2, generatedKernel_wgs2) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel2, generatedKernel_local_mem_size2) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel2, generatedKernel_preferred_wgs_multiple2) == -1) {
									return -1;
								} 
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_m%02d", kern_type, 16);
								if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel3) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel3, generatedKernel_wgs3) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel3, generatedKernel_local_mem_size3) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel3, generatedKernel_preferred_wgs_multiple3) == -1) {
									return -1;
								} 
							} else {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_mxx", kern_type);
									if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel4) == -1) {
										return -1;
									} 
									if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel4, generatedKernel_wgs4) == -1) {
										return -1;
									} 
									if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel4, generatedKernel_local_mem_size4) == -1) {
										return -1;
									} 
									if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel4, generatedKernel_preferred_wgs_multiple4) == -1) {
										return -1;
									} 
							} 
					} 
					if (user_options.getSlow_candidates() == 1) {
					} else {
							if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_BITSLICE) {
									/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_tm", kern_type);
									if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel_tm) == -1) {
										return -1;
									} 
									if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_tm, generatedKernel_wgs_tm) == -1) {
										return -1;
									} 
									if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_tm, generatedKernel_local_mem_size_tm) == -1) {
										return -1;
									} 
									if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_tm, generatedKernel_preferred_wgs_multiple_tm) == -1) {
										return -1;
									} 
								} 
							} 
					} 
				} else {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_init", kern_type);
						if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel1) == -1) {
							return -1;
						} 
						if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel1, generatedKernel_wgs1) == -1) {
							return -1;
						} 
						if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel1, generatedKernel_local_mem_size1) == -1) {
							return -1;
						} 
						if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel1, generatedKernel_preferred_wgs_multiple1) == -1) {
							return -1;
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_loop", kern_type);
						if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel2) == -1) {
							return -1;
						} 
						if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel2, generatedKernel_wgs2) == -1) {
							return -1;
						} 
						if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel2, generatedKernel_local_mem_size2) == -1) {
							return -1;
						} 
						if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel2, generatedKernel_preferred_wgs_multiple2) == -1) {
							return -1;
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_comp", kern_type);
						if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel3) == -1) {
							return -1;
						} 
						if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel3, generatedKernel_wgs3) == -1) {
							return -1;
						} 
						if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel3, generatedKernel_local_mem_size3) == -1) {
							return -1;
						} 
						if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel3, generatedKernel_preferred_wgs_multiple3) == -1) {
							return -1;
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_HOOK12) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_hook12", kern_type);
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel12) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel12, generatedKernel_wgs12) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel12, generatedKernel_local_mem_size12) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel12, generatedKernel_preferred_wgs_multiple12) == -1) {
								return -1;
							} 
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_HOOK23) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_hook23", kern_type);
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel23) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel23, generatedKernel_wgs23) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel23, generatedKernel_local_mem_size23) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel23, generatedKernel_preferred_wgs_multiple23) == -1) {
								return -1;
							} 
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_INIT2) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_init2", kern_type);
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel_init2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_init2, generatedKernel_wgs_init2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_init2, generatedKernel_local_mem_size_init2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_init2, generatedKernel_preferred_wgs_multiple_init2) == -1) {
								return -1;
							} 
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_LOOP2) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_loop2", kern_type);
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel_loop2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_loop2, generatedKernel_wgs_loop2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_loop2, generatedKernel_local_mem_size_loop2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_loop2, generatedKernel_preferred_wgs_multiple_loop2) == -1) {
								return -1;
							} 
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_AUX1) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_aux1", kern_type);
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel_aux1) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_aux1, generatedKernel_wgs_aux1) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_aux1, generatedKernel_local_mem_size_aux1) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_aux1, generatedKernel_preferred_wgs_multiple_aux1) == -1) {
								return -1;
							} 
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_AUX2) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_aux2", kern_type);
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel_aux2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_aux2, generatedKernel_wgs_aux2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_aux2, generatedKernel_local_mem_size_aux2) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_aux2, generatedKernel_preferred_wgs_multiple_aux2) == -1) {
								return -1;
							} 
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_AUX3) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_aux3", kern_type);
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel_aux3) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_aux3, generatedKernel_wgs_aux3) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_aux3, generatedKernel_local_mem_size_aux3) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_aux3, generatedKernel_preferred_wgs_multiple_aux3) == -1) {
								return -1;
							} 
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_AUX4) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(kernel_name, /*Error: sizeof expression not supported yet*/, "m%05u_aux4", kern_type);
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, kernel_name, generatedOpencl_kernel_aux4) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_aux4, generatedKernel_wgs_aux4) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_aux4, generatedKernel_local_mem_size_aux4) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_aux4, generatedKernel_preferred_wgs_multiple_aux4) == -1) {
								return -1;
							} 
						} 
				} 
				if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, "gpu_memset", generatedOpencl_kernel_memset) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_memset, generatedKernel_wgs_memset) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_memset, generatedKernel_local_mem_size_memset) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_memset, generatedKernel_preferred_wgs_multiple_memset) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_memset, 0, /*Error: Unsupported expression*/, generatedKernel_params_memset[0]) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_memset, 1, /*Error: Unsupported expression*/, generatedKernel_params_memset[1]) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_memset, 2, /*Error: Unsupported expression*/, generatedKernel_params_memset[2]) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, "gpu_atinit", generatedOpencl_kernel_atinit) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_atinit, generatedKernel_wgs_atinit) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_atinit, generatedKernel_local_mem_size_atinit) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_atinit, generatedKernel_preferred_wgs_multiple_atinit) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_atinit, 0, /*Error: Unsupported expression*/, generatedKernel_params_atinit[0]) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_atinit, 1, /*Error: Unsupported expression*/, generatedKernel_params_atinit[1]) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program, "gpu_decompress", generatedOpencl_kernel_decompress) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_decompress, generatedKernel_wgs_decompress) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_decompress, generatedKernel_local_mem_size_decompress) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_decompress, generatedKernel_preferred_wgs_multiple_decompress) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_decompress, 0, /*Error: Unsupported expression*/, generatedKernel_params_decompress[0]) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_decompress, 1, /*Error: Unsupported expression*/, generatedKernel_params_decompress[1]) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_decompress, 2, /*Error: Unsupported expression*/, generatedKernel_params_decompress[2]) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_decompress, 3, /*Error: Unsupported expression*/, generatedKernel_params_decompress[3]) == -1) {
					return -1;
				} 
				if (user_options.getSlow_candidates() == 1) {
				} else {
						if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program_mp, "l_markov", generatedOpencl_kernel_mp_l) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_mp_l, generatedKernel_wgs_mp_l) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_mp_l, generatedKernel_local_mem_size_mp_l) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_mp_l, generatedKernel_preferred_wgs_multiple_mp_l) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program_mp, "r_markov", generatedOpencl_kernel_mp_r) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_mp_r, generatedKernel_wgs_mp_r) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_mp_r, generatedKernel_local_mem_size_mp_r) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_mp_r, generatedKernel_preferred_wgs_multiple_mp_r) == -1) {
								return -1;
							} 
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_BITSLICE) {
								if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_tm, 0, /*Error: Unsupported expression*/, generatedKernel_params_tm[0]) == -1) {
									return -1;
								} 
								if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_tm, 1, /*Error: Unsupported expression*/, generatedKernel_params_tm[1]) == -1) {
									return -1;
								} 
							} 
						}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program_mp, "C_markov", generatedOpencl_kernel_mp) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_mp, generatedKernel_wgs_mp) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_mp, generatedKernel_local_mem_size_mp) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_mp, generatedKernel_preferred_wgs_multiple_mp) == -1) {
								return -1;
							} 
						}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
							if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program_mp, "C_markov", generatedOpencl_kernel_mp) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_mp, generatedKernel_wgs_mp) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_mp, generatedKernel_local_mem_size_mp) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_mp, generatedKernel_preferred_wgs_multiple_mp) == -1) {
								return -1;
							} 
						} 
				} 
				if (user_options.getSlow_candidates() == 1) {
				} else {
						if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
						} else {
								if (hashcat_ctx.hc_clCreateKernel(generatedOpencl_program_amp, "amp", generatedOpencl_kernel_amp) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_wgs(hashcat_ctx, device_param, generatedOpencl_kernel_amp, generatedKernel_wgs_amp) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_local_mem_size(hashcat_ctx, device_param, generatedOpencl_kernel_amp, generatedKernel_local_mem_size_amp) == -1) {
									return -1;
								} 
								if (ModernizedCProgram.get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx, device_param, generatedOpencl_kernel_amp, generatedKernel_preferred_wgs_multiple_amp) == -1) {
									return -1;
								} 
						} 
						if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
						} else {
								for (u32 i = 0;
								 i < 5; i++) {
									if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_amp, i, /*Error: Unsupported expression*/, generatedKernel_params_amp[i]) == -1) {
										return -1;
									} 
								}
								for (u32 i = 5;
								 i < 6; i++) {
									if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_amp, i, /*Error: Unsupported expression*/, generatedKernel_params_amp[i]) == -1) {
										return -1;
									} 
								}
								for (u32 i = 6;
								 i < 7; i++) {
									if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_amp, i, /*Error: Unsupported expression*/, generatedKernel_params_amp[i]) == -1) {
										return -1;
									} 
								}
						} 
				} 
				if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_plain_bufs, generatedSize_plains) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_digests_shown, generatedSize_shown) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_result, generatedSize_results) == -1) {
					return -1/**
					       * special buffers
					       */;
				} 
				if (user_options.getSlow_candidates() == 1) {
					if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_rules_c, size_rules_c) == -1) {
						return -1;
					} 
				} else {
						if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_STRAIGHT) {
							if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_rules_c, size_rules_c) == -1) {
								return -1;
							} 
						}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_COMBI) {
							if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_combs, size_combs) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_combs_c, size_combs) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_root_css_buf, size_root_css) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_markov_css_buf, size_markov_css) == -1) {
								return -1;
							} 
						}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_BF) {
							if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_bfs, size_bfs) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_bfs_c, size_bfs) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_tm_c, size_tm) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_root_css_buf, size_root_css) == -1) {
								return -1;
							} 
							if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_markov_css_buf, size_markov_css) == -1) {
								return -1;
							} 
						} 
				} 
				if (user_options.getSlow_candidates() == 1) {
				} else {
						if ((user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) || (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2/**
						           * prepare mp
						           */)) {
							if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
								generatedKernel_params_mp_buf32[5] = 0;
								generatedKernel_params_mp_buf32[6] = 0;
								generatedKernel_params_mp_buf32[7] = 0;
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD01) {
									generatedKernel_params_mp_buf32[5] = ModernizedCProgram.full01;
								} 
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD06) {
									generatedKernel_params_mp_buf32[5] = ModernizedCProgram.full06;
								} 
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD80) {
									generatedKernel_params_mp_buf32[5] = ModernizedCProgram.full80;
								} 
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADDBITS14) {
									generatedKernel_params_mp_buf32[6] = 1;
								} 
								if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADDBITS15) {
									generatedKernel_params_mp_buf32[7] = 1;
								} 
							}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
								generatedKernel_params_mp_buf32[5] = 0;
								generatedKernel_params_mp_buf32[6] = 0;
								generatedKernel_params_mp_buf32[7] = 0;
							} 
							for (u32 i = 0;
							 i < 3; i++) {
								if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp, i, /*Error: Unsupported expression*/, generatedKernel_params_mp[i]) == -1) {
									return -1;
								} 
							}
						}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF/**
						           * prepare mp_r and mp_l
						           */) {
							generatedKernel_params_mp_l_buf32[6] = 0;
							generatedKernel_params_mp_l_buf32[7] = 0;
							generatedKernel_params_mp_l_buf32[8] = 0;
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD01) {
								generatedKernel_params_mp_l_buf32[6] = ModernizedCProgram.full01;
							} 
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD06) {
								generatedKernel_params_mp_l_buf32[6] = ModernizedCProgram.full06;
							} 
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADD80) {
								generatedKernel_params_mp_l_buf32[6] = ModernizedCProgram.full80;
							} 
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADDBITS14) {
								generatedKernel_params_mp_l_buf32[7] = 1;
							} 
							if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ADDBITS15) {
								generatedKernel_params_mp_l_buf32[8] = 1;
							} 
							for (u32 i = 0;
							 i < 3; i++) {
								if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp_l, i, /*Error: Unsupported expression*/, generatedKernel_params_mp_l[i]) == -1) {
									return -1;
								} 
							}
							for (u32 i = 0;
							 i < 3; i++) {
								if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp_r, i, /*Error: Unsupported expression*/, generatedKernel_params_mp_r[i]) == -1) {
									return -1;
								} 
							}
						} 
				} 
			} 
			if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
				if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
				} else {
						device_param.setKernel_threads_max((((generatedKernel_threads_max) < (true)) ? (generatedKernel_threads_max) : (true)));
				} 
			} 
			u32 kernel_threads = ModernizedCProgram.get_kernel_threads(/**
			     * now everything that depends on threads and accel, basically dynamic workload
			     */device_param);
			device_param.setKernel_threads(kernel_threads);
			device_param.setHardware_power(device_processors * kernel_threads);
			u32 kernel_accel_min = generatedKernel_accel_min;
			u32 kernel_accel_max = generatedKernel_accel_max;
			u64 size_pws = 4;
			u64 size_pws_amp = 4;
			u64 size_pws_comp = 4;
			u64 size_pws_idx = 4;
			u64 size_pws_pre = 4;
			u64 size_pws_base = 4;
			u64 size_tmps = 4;
			u64 size_hooks = 4;
			u64 PWS_SPACE = -1024 * -1024 * -1024;
			u64 EXTRA_SPACE = -1024 * -1024 * -1024;
			while (kernel_accel_max >= kernel_accel_min) {
				u64 kernel_power_max = generatedHardware_power * kernel_accel_max;
				size_pws = kernel_power_max * /*Error: Unsupported expression*/;
				size_pws_amp = (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) ? 1 : size_pws;
				size_pws_comp = kernel_power_max * (/*Error: Unsupported expression*/ * 64);
				size_pws_idx = (u64)(kernel_power_max + 1) * /*Error: Unsupported expression*/;
				size_tmps = kernel_power_max * (hashconfig.getTmp_size() + hashconfig.getExtra_tmp_size());
				size_hooks = kernel_power_max * hashconfig.getHook_size();
				if (user_options.getSlow_candidates() == 1) {
					size_pws_pre = kernel_power_max * /*Error: Unsupported expression*/;
					size_pws_base = kernel_power_max * /*Error: Unsupported expression*/;
				} 
				int memory_limit_hit = 0;
				if (size_pws > PWS_SPACE) {
					memory_limit_hit = 1;
				} 
				if ((size_pws + EXTRA_SPACE) > generatedDevice_maxmem_alloc) {
					memory_limit_hit = 1;
				} 
				if ((size_tmps + EXTRA_SPACE) > generatedDevice_maxmem_alloc) {
					memory_limit_hit = 1;
				} 
				if ((size_hooks + EXTRA_SPACE) > generatedDevice_maxmem_alloc) {
					memory_limit_hit = 1;
				} 
				u64 size_total = bitmap_ctx.getBitmap_size() + bitmap_ctx.getBitmap_size() + bitmap_ctx.getBitmap_size() + bitmap_ctx.getBitmap_size() + bitmap_ctx.getBitmap_size() + bitmap_ctx.getBitmap_size() + bitmap_ctx.getBitmap_size() + bitmap_ctx.getBitmap_size() + size_bfs + size_combs + size_digests + size_esalts + size_hooks + size_markov_css + size_plains + size_pws + size_pws_amp + size_pws_comp + size_pws_idx + size_results + size_root_css + size_rules + size_rules_c + size_salts + size_extra_buffer + size_shown + size_tm + size_tmps + size_st_digests + size_st_salts + size_st_esalts;
				if ((size_total + EXTRA_SPACE) > generatedDevice_available_mem) {
					memory_limit_hit = 1;
				} 
				if (memory_limit_hit == 1) {
					kernel_accel_max--;
					continue;
				} 
				u64 size_total_host = size_pws_comp + size_pws_idx + size_hooks + size_pws_pre + size_pws_base;
				size_total_host_all += size_total_host + EXTRA_SPACE;
				break;
			}
			if (kernel_accel_max < kernel_accel_min) {
				hashcat_ctx.event_log_error("* Device #%u: Not enough allocatable device memory for this attack.", device_id + 1);
				return -1;
			} 
			device_param.setKernel_accel_min(kernel_accel_min);
			device_param.setKernel_accel_max(kernel_accel_max);
			device_param.setSize_pws(size_pws);
			device_param.setSize_pws_amp(size_pws_amp);
			device_param.setSize_pws_comp(size_pws_comp);
			device_param.setSize_pws_idx(size_pws_idx);
			device_param.setSize_pws_pre(size_pws_pre);
			device_param.setSize_pws_base(size_pws_base);
			device_param.setSize_tmps(size_tmps);
			device_param.setSize_hooks(size_hooks);
			if (generatedIs_cuda == true) {
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_pws_buf, size_pws) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_pws_amp_buf, size_pws_amp) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_pws_comp_buf, size_pws_comp) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_pws_idx, size_pws_idx) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_tmps, size_tmps) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemAlloc(generatedCuda_d_hooks, size_hooks) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_pws_buf, generatedSize_pws) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_pws_amp_buf, generatedSize_pws_amp) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_pws_comp_buf, generatedSize_pws_comp) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_pws_idx, generatedSize_pws_idx) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_tmps, generatedSize_tmps) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_hooks, generatedSize_hooks) == -1) {
					return -1;
				} 
			} 
			if (generatedIs_opencl == true) {
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_WRITE, size_pws, (null), generatedOpencl_d_pws_buf) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_WRITE, size_pws_amp, (null), generatedOpencl_d_pws_amp_buf) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_pws_comp, (null), generatedOpencl_d_pws_comp_buf) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_ONLY, size_pws_idx, (null), generatedOpencl_d_pws_idx) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_WRITE, size_tmps, (null), generatedOpencl_d_tmps) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clCreateBuffer(generatedOpencl_context, CL_MEM_READ_WRITE, size_hooks, (null), generatedOpencl_d_hooks) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_pws_buf, generatedSize_pws) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_pws_amp_buf, generatedSize_pws_amp) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_pws_comp_buf, generatedSize_pws_comp) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_pws_idx, generatedSize_pws_idx) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_tmps, generatedSize_tmps) == -1) {
					return -1;
				} 
				if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_hooks, generatedSize_hooks) == -1) {
					return -1/**
					     * main host data
					     */;
				} 
			} 
			u32 pws_comp = (u32)ModernizedCProgram.hcmalloc(size_pws_comp);
			device_param.setPws_comp(pws_comp);
			pw_idx_t pws_idx = (pw_idx_t)ModernizedCProgram.hcmalloc(size_pws_idx);
			device_param.setPws_idx(pws_idx);
			pw_t combs_buf = (pw_t)ModernizedCProgram.hccalloc(amplifier_count.KERNEL_COMBS, /*Error: Unsupported expression*/);
			device_param.setCombs_buf(combs_buf);
			Object hooks_buf = ModernizedCProgram.hcmalloc(size_hooks);
			device_param.setHooks_buf(hooks_buf);
			Byte scratch_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
			device_param.setScratch_buf(scratch_buf);
			pw_pre_t pws_pre_buf = (pw_pre_t)ModernizedCProgram.hcmalloc(size_pws_pre);
			device_param.setPws_pre_buf(pws_pre_buf);
			pw_pre_t pws_base_buf = (pw_pre_t)ModernizedCProgram.hcmalloc(size_pws_base);
			device_param.setPws_base_buf(pws_base_buf/**
			     * kernel args
			     */);
			if (generatedIs_cuda == true) {
				generatedKernel_params[0] = generatedCuda_d_pws_buf;
				generatedKernel_params[4] = generatedCuda_d_tmps;
				generatedKernel_params[5] = generatedCuda_d_hooks;
			} 
			if (generatedIs_opencl == true) {
				generatedKernel_params[0] = generatedOpencl_d_pws_buf;
				generatedKernel_params[4] = generatedOpencl_d_tmps;
				generatedKernel_params[5] = generatedOpencl_d_hooks;
			} 
			if (user_options.getSlow_candidates() == 1) {
			} else {
					if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
					} else {
							if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
								if (generatedIs_cuda == true) {
									generatedKernel_params_mp[0] = (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) ? generatedCuda_d_pws_buf : generatedCuda_d_pws_amp_buf;
								} 
								if (generatedIs_opencl == true) {
									generatedKernel_params_mp[0] = (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) ? generatedOpencl_d_pws_buf : generatedOpencl_d_pws_amp_buf;
									if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp, 0, /*Error: Unsupported expression*/, generatedKernel_params_mp[0]) == -1) {
										return -1;
									} 
								} 
							} 
					} 
					if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
						if (generatedIs_cuda == true) {
							generatedKernel_params_mp_l[0] = (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) ? generatedCuda_d_pws_buf : generatedCuda_d_pws_amp_buf;
						} 
						if (generatedIs_opencl == true) {
							generatedKernel_params_mp_l[0] = (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) ? generatedOpencl_d_pws_buf : generatedOpencl_d_pws_amp_buf;
							if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp_l, 0, /*Error: Unsupported expression*/, generatedKernel_params_mp_l[0]) == -1) {
								return -1;
							} 
						} 
					} 
					if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
					} else {
							if (generatedIs_cuda == true) {
								generatedKernel_params_amp[0] = generatedCuda_d_pws_buf;
								generatedKernel_params_amp[1] = generatedCuda_d_pws_amp_buf;
							} 
							if (generatedIs_opencl == true) {
								generatedKernel_params_amp[0] = generatedOpencl_d_pws_buf;
								generatedKernel_params_amp[1] = generatedOpencl_d_pws_amp_buf;
								if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_amp, 0, /*Error: Unsupported expression*/, generatedKernel_params_amp[0]) == -1) {
									return -1;
								} 
								if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_amp, 1, /*Error: Unsupported expression*/, generatedKernel_params_amp[1]) == -1) {
									return -1;
								} 
							} 
					} 
			} 
			if (generatedIs_cuda == true) {
				generatedKernel_params_decompress[0] = generatedCuda_d_pws_idx;
				generatedKernel_params_decompress[1] = generatedCuda_d_pws_comp_buf;
				generatedKernel_params_decompress[2] = (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) ? generatedCuda_d_pws_buf : generatedCuda_d_pws_amp_buf;
			} 
			if (generatedIs_opencl == true) {
				generatedKernel_params_decompress[0] = generatedOpencl_d_pws_idx;
				generatedKernel_params_decompress[1] = generatedOpencl_d_pws_comp_buf;
				generatedKernel_params_decompress[2] = (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) ? generatedOpencl_d_pws_buf : generatedOpencl_d_pws_amp_buf;
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_decompress, 0, /*Error: Unsupported expression*/, generatedKernel_params_decompress[0]) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_decompress, 1, /*Error: Unsupported expression*/, generatedKernel_params_decompress[1]) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_decompress, 2, /*Error: Unsupported expression*/, generatedKernel_params_decompress[2]) == -1) {
					return -1;
				} 
			} 
			hardware_power_all += generatedHardware_power;
			hashcat_ctx.event_call((event_identifier.EVENT_BACKEND_DEVICE_INIT_POST), (backend_devices_idx), (/*Error: Unsupported expression*/));
		}
		if (user_options.getBenchmark() == 0) {
			if (hardware_power_all == 0) {
				return -1;
			} 
		} 
		backend_ctx.setHardware_power_all(hardware_power_all);
		hashcat_ctx.event_call((event_identifier.EVENT_BACKEND_SESSION_HOSTMEM), (size_total_host_all), (/*Error: Unsupported expression*/));
		return 0;
	}
	public void backend_session_destroy() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		Object generatedPws_comp = device_param.getPws_comp();
		pw_idx generatedPws_idx = device_param.getPws_idx();
		pw_pre generatedPws_pre_buf = device_param.getPws_pre_buf();
		pw_pre generatedPws_base_buf = device_param.getPws_base_buf();
		pw[] generatedCombs_buf = device_param.getCombs_buf();
		Object generatedHooks_buf = device_param.getHooks_buf();
		Byte generatedScratch_buf = device_param.getScratch_buf();
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_d_pws_buf = device_param.getCuda_d_pws_buf();
		Object generatedCuda_d_pws_amp_buf = device_param.getCuda_d_pws_amp_buf();
		Object generatedCuda_d_pws_comp_buf = device_param.getCuda_d_pws_comp_buf();
		Object generatedCuda_d_pws_idx = device_param.getCuda_d_pws_idx();
		Object generatedCuda_d_rules = device_param.getCuda_d_rules();
		Object generatedCuda_d_combs = device_param.getCuda_d_combs();
		Object generatedCuda_d_combs_c = device_param.getCuda_d_combs_c();
		Object generatedCuda_d_bfs = device_param.getCuda_d_bfs();
		Object generatedCuda_d_bitmap_s1_a = device_param.getCuda_d_bitmap_s1_a();
		Object generatedCuda_d_bitmap_s1_b = device_param.getCuda_d_bitmap_s1_b();
		Object generatedCuda_d_bitmap_s1_c = device_param.getCuda_d_bitmap_s1_c();
		Object generatedCuda_d_bitmap_s1_d = device_param.getCuda_d_bitmap_s1_d();
		Object generatedCuda_d_bitmap_s2_a = device_param.getCuda_d_bitmap_s2_a();
		Object generatedCuda_d_bitmap_s2_b = device_param.getCuda_d_bitmap_s2_b();
		Object generatedCuda_d_bitmap_s2_c = device_param.getCuda_d_bitmap_s2_c();
		Object generatedCuda_d_bitmap_s2_d = device_param.getCuda_d_bitmap_s2_d();
		Object generatedCuda_d_plain_bufs = device_param.getCuda_d_plain_bufs();
		Object generatedCuda_d_digests_buf = device_param.getCuda_d_digests_buf();
		Object generatedCuda_d_digests_shown = device_param.getCuda_d_digests_shown();
		Object generatedCuda_d_salt_bufs = device_param.getCuda_d_salt_bufs();
		Object generatedCuda_d_esalt_bufs = device_param.getCuda_d_esalt_bufs();
		Object generatedCuda_d_tmps = device_param.getCuda_d_tmps();
		Object generatedCuda_d_hooks = device_param.getCuda_d_hooks();
		Object generatedCuda_d_result = device_param.getCuda_d_result();
		Object generatedCuda_d_extra0_buf = device_param.getCuda_d_extra0_buf();
		Object generatedCuda_d_extra1_buf = device_param.getCuda_d_extra1_buf();
		Object generatedCuda_d_extra2_buf = device_param.getCuda_d_extra2_buf();
		Object generatedCuda_d_extra3_buf = device_param.getCuda_d_extra3_buf();
		Object generatedCuda_d_root_css_buf = device_param.getCuda_d_root_css_buf();
		Object generatedCuda_d_markov_css_buf = device_param.getCuda_d_markov_css_buf();
		Object generatedCuda_d_tm_c = device_param.getCuda_d_tm_c();
		Object generatedCuda_d_st_digests_buf = device_param.getCuda_d_st_digests_buf();
		Object generatedCuda_d_st_salts_buf = device_param.getCuda_d_st_salts_buf();
		Object generatedCuda_d_st_esalts_buf = device_param.getCuda_d_st_esalts_buf();
		Object generatedCuda_event1 = device_param.getCuda_event1();
		Object generatedCuda_event2 = device_param.getCuda_event2();
		Object generatedCuda_stream = device_param.getCuda_stream();
		Object generatedCuda_module = device_param.getCuda_module();
		Object generatedCuda_module_mp = device_param.getCuda_module_mp();
		Object generatedCuda_module_amp = device_param.getCuda_module_amp();
		Object generatedCuda_context = device_param.getCuda_context();
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_d_pws_buf = device_param.getOpencl_d_pws_buf();
		Object generatedOpencl_d_pws_amp_buf = device_param.getOpencl_d_pws_amp_buf();
		Object generatedOpencl_d_pws_comp_buf = device_param.getOpencl_d_pws_comp_buf();
		Object generatedOpencl_d_pws_idx = device_param.getOpencl_d_pws_idx();
		Object generatedOpencl_d_rules = device_param.getOpencl_d_rules();
		Object generatedOpencl_d_rules_c = device_param.getOpencl_d_rules_c();
		Object generatedOpencl_d_combs = device_param.getOpencl_d_combs();
		Object generatedOpencl_d_combs_c = device_param.getOpencl_d_combs_c();
		Object generatedOpencl_d_bfs = device_param.getOpencl_d_bfs();
		Object generatedOpencl_d_bfs_c = device_param.getOpencl_d_bfs_c();
		Object generatedOpencl_d_bitmap_s1_a = device_param.getOpencl_d_bitmap_s1_a();
		Object generatedOpencl_d_bitmap_s1_b = device_param.getOpencl_d_bitmap_s1_b();
		Object generatedOpencl_d_bitmap_s1_c = device_param.getOpencl_d_bitmap_s1_c();
		Object generatedOpencl_d_bitmap_s1_d = device_param.getOpencl_d_bitmap_s1_d();
		Object generatedOpencl_d_bitmap_s2_a = device_param.getOpencl_d_bitmap_s2_a();
		Object generatedOpencl_d_bitmap_s2_b = device_param.getOpencl_d_bitmap_s2_b();
		Object generatedOpencl_d_bitmap_s2_c = device_param.getOpencl_d_bitmap_s2_c();
		Object generatedOpencl_d_bitmap_s2_d = device_param.getOpencl_d_bitmap_s2_d();
		Object generatedOpencl_d_plain_bufs = device_param.getOpencl_d_plain_bufs();
		Object generatedOpencl_d_digests_buf = device_param.getOpencl_d_digests_buf();
		Object generatedOpencl_d_digests_shown = device_param.getOpencl_d_digests_shown();
		Object generatedOpencl_d_salt_bufs = device_param.getOpencl_d_salt_bufs();
		Object generatedOpencl_d_esalt_bufs = device_param.getOpencl_d_esalt_bufs();
		Object generatedOpencl_d_tmps = device_param.getOpencl_d_tmps();
		Object generatedOpencl_d_hooks = device_param.getOpencl_d_hooks();
		Object generatedOpencl_d_result = device_param.getOpencl_d_result();
		Object generatedOpencl_d_extra0_buf = device_param.getOpencl_d_extra0_buf();
		Object generatedOpencl_d_extra1_buf = device_param.getOpencl_d_extra1_buf();
		Object generatedOpencl_d_extra2_buf = device_param.getOpencl_d_extra2_buf();
		Object generatedOpencl_d_extra3_buf = device_param.getOpencl_d_extra3_buf();
		Object generatedOpencl_d_root_css_buf = device_param.getOpencl_d_root_css_buf();
		Object generatedOpencl_d_markov_css_buf = device_param.getOpencl_d_markov_css_buf();
		Object generatedOpencl_d_tm_c = device_param.getOpencl_d_tm_c();
		Object generatedOpencl_d_st_digests_buf = device_param.getOpencl_d_st_digests_buf();
		Object generatedOpencl_d_st_salts_buf = device_param.getOpencl_d_st_salts_buf();
		Object generatedOpencl_d_st_esalts_buf = device_param.getOpencl_d_st_esalts_buf();
		Object generatedOpencl_kernel1 = device_param.getOpencl_kernel1();
		Object generatedOpencl_kernel12 = device_param.getOpencl_kernel12();
		Object generatedOpencl_kernel2 = device_param.getOpencl_kernel2();
		Object generatedOpencl_kernel23 = device_param.getOpencl_kernel23();
		Object generatedOpencl_kernel3 = device_param.getOpencl_kernel3();
		Object generatedOpencl_kernel4 = device_param.getOpencl_kernel4();
		Object generatedOpencl_kernel_init2 = device_param.getOpencl_kernel_init2();
		Object generatedOpencl_kernel_loop2 = device_param.getOpencl_kernel_loop2();
		Object generatedOpencl_kernel_mp = device_param.getOpencl_kernel_mp();
		Object generatedOpencl_kernel_mp_l = device_param.getOpencl_kernel_mp_l();
		Object generatedOpencl_kernel_mp_r = device_param.getOpencl_kernel_mp_r();
		Object generatedOpencl_kernel_tm = device_param.getOpencl_kernel_tm();
		Object generatedOpencl_kernel_amp = device_param.getOpencl_kernel_amp();
		Object generatedOpencl_kernel_memset = device_param.getOpencl_kernel_memset();
		Object generatedOpencl_kernel_atinit = device_param.getOpencl_kernel_atinit();
		Object generatedOpencl_kernel_decompress = device_param.getOpencl_kernel_decompress();
		Object generatedOpencl_kernel_aux1 = device_param.getOpencl_kernel_aux1();
		Object generatedOpencl_kernel_aux2 = device_param.getOpencl_kernel_aux2();
		Object generatedOpencl_kernel_aux3 = device_param.getOpencl_kernel_aux3();
		Object generatedOpencl_kernel_aux4 = device_param.getOpencl_kernel_aux4();
		Object generatedOpencl_program = device_param.getOpencl_program();
		Object generatedOpencl_program_mp = device_param.getOpencl_program_mp();
		Object generatedOpencl_program_amp = device_param.getOpencl_program_amp();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedOpencl_context = device_param.getOpencl_context();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
			hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			ModernizedCProgram.hcfree(generatedPws_comp);
			ModernizedCProgram.hcfree(generatedPws_idx);
			ModernizedCProgram.hcfree(generatedPws_pre_buf);
			ModernizedCProgram.hcfree(generatedPws_base_buf);
			ModernizedCProgram.hcfree(generatedCombs_buf);
			ModernizedCProgram.hcfree(generatedHooks_buf);
			ModernizedCProgram.hcfree(generatedScratch_buf);
			if (generatedIs_cuda == true) {
				if (generatedCuda_d_pws_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_pws_buf);
				} 
				if (generatedCuda_d_pws_amp_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_pws_amp_buf);
				} 
				if (generatedCuda_d_pws_comp_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_pws_comp_buf);
				} 
				if (generatedCuda_d_pws_idx) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_pws_idx);
				} 
				if (generatedCuda_d_rules) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_rules);
				} 
				if (generatedCuda_d_combs) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_combs);
				} 
				if (generatedCuda_d_combs_c) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_combs_c);
				} 
				if (generatedCuda_d_bfs) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_bfs);
				} 
				if (generatedCuda_d_bitmap_s1_a) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_bitmap_s1_a);
				} 
				if (generatedCuda_d_bitmap_s1_b) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_bitmap_s1_b);
				} 
				if (generatedCuda_d_bitmap_s1_c) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_bitmap_s1_c);
				} 
				if (generatedCuda_d_bitmap_s1_d) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_bitmap_s1_d);
				} 
				if (generatedCuda_d_bitmap_s2_a) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_bitmap_s2_a);
				} 
				if (generatedCuda_d_bitmap_s2_b) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_bitmap_s2_b);
				} 
				if (generatedCuda_d_bitmap_s2_c) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_bitmap_s2_c);
				} 
				if (generatedCuda_d_bitmap_s2_d) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_bitmap_s2_d);
				} 
				if (generatedCuda_d_plain_bufs) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_plain_bufs);
				} 
				if (generatedCuda_d_digests_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_digests_buf);
				} 
				if (generatedCuda_d_digests_shown) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_digests_shown);
				} 
				if (generatedCuda_d_salt_bufs) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_salt_bufs);
				} 
				if (generatedCuda_d_esalt_bufs) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_esalt_bufs);
				} 
				if (generatedCuda_d_tmps) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_tmps);
				} 
				if (generatedCuda_d_hooks) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_hooks);
				} 
				if (generatedCuda_d_result) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_result);
				} 
				if (generatedCuda_d_extra0_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_extra0_buf);
				} 
				if (generatedCuda_d_extra1_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_extra1_buf);
				} 
				if (generatedCuda_d_extra2_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_extra2_buf);
				} 
				if (generatedCuda_d_extra3_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_extra3_buf);
				} 
				if (generatedCuda_d_root_css_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_root_css_buf);
				} 
				if (generatedCuda_d_markov_css_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_markov_css_buf);
				} 
				if (generatedCuda_d_tm_c) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_tm_c);
				} 
				if (generatedCuda_d_st_digests_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_st_digests_buf);
				} 
				if (generatedCuda_d_st_salts_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_st_salts_buf);
				} 
				if (generatedCuda_d_st_esalts_buf) {
					hashcat_ctx.hc_cuMemFree(generatedCuda_d_st_esalts_buf);
				} 
				if (generatedCuda_event1) {
					hashcat_ctx.hc_cuEventDestroy(generatedCuda_event1);
				} 
				if (generatedCuda_event2) {
					hashcat_ctx.hc_cuEventDestroy(generatedCuda_event2);
				} 
				if (generatedCuda_stream) {
					hashcat_ctx.hc_cuStreamDestroy(generatedCuda_stream);
				} 
				if (generatedCuda_module) {
					hashcat_ctx.hc_cuModuleUnload(generatedCuda_module);
				} 
				if (generatedCuda_module_mp) {
					hashcat_ctx.hc_cuModuleUnload(generatedCuda_module_mp);
				} 
				if (generatedCuda_module_amp) {
					hashcat_ctx.hc_cuModuleUnload(generatedCuda_module_amp);
				} 
				if (generatedCuda_context) {
					hashcat_ctx.hc_cuCtxDestroy(generatedCuda_context);
				} 
				device_param.setCuda_d_pws_buf(0);
				device_param.setCuda_d_pws_amp_buf(0);
				device_param.setCuda_d_pws_comp_buf(0);
				device_param.setCuda_d_pws_idx(0);
				device_param.setCuda_d_rules(0);
				device_param.setCuda_d_rules_c(0);
				device_param.setCuda_d_combs(0);
				device_param.setCuda_d_combs_c(0);
				device_param.setCuda_d_bfs(0);
				device_param.setCuda_d_bfs_c(0);
				device_param.setCuda_d_bitmap_s1_a(0);
				device_param.setCuda_d_bitmap_s1_b(0);
				device_param.setCuda_d_bitmap_s1_c(0);
				device_param.setCuda_d_bitmap_s1_d(0);
				device_param.setCuda_d_bitmap_s2_a(0);
				device_param.setCuda_d_bitmap_s2_b(0);
				device_param.setCuda_d_bitmap_s2_c(0);
				device_param.setCuda_d_bitmap_s2_d(0);
				device_param.setCuda_d_plain_bufs(0);
				device_param.setCuda_d_digests_buf(0);
				device_param.setCuda_d_digests_shown(0);
				device_param.setCuda_d_salt_bufs(0);
				device_param.setCuda_d_esalt_bufs(0);
				device_param.setCuda_d_tmps(0);
				device_param.setCuda_d_hooks(0);
				device_param.setCuda_d_result(0);
				device_param.setCuda_d_extra0_buf(0);
				device_param.setCuda_d_extra1_buf(0);
				device_param.setCuda_d_extra2_buf(0);
				device_param.setCuda_d_extra3_buf(0);
				device_param.setCuda_d_root_css_buf(0);
				device_param.setCuda_d_markov_css_buf(0);
				device_param.setCuda_d_tm_c(0);
				device_param.setCuda_d_st_digests_buf(0);
				device_param.setCuda_d_st_salts_buf(0);
				device_param.setCuda_d_st_esalts_buf(0);
				device_param.setCuda_function1((null));
				device_param.setCuda_function12((null));
				device_param.setCuda_function2((null));
				device_param.setCuda_function23((null));
				device_param.setCuda_function3((null));
				device_param.setCuda_function4((null));
				device_param.setCuda_function_init2((null));
				device_param.setCuda_function_loop2((null));
				device_param.setCuda_function_mp((null));
				device_param.setCuda_function_mp_l((null));
				device_param.setCuda_function_mp_r((null));
				device_param.setCuda_function_tm((null));
				device_param.setCuda_function_amp((null));
				device_param.setCuda_function_memset((null));
				device_param.setCuda_function_atinit((null));
				device_param.setCuda_function_decompress((null));
				device_param.setCuda_function_aux1((null));
				device_param.setCuda_function_aux2((null));
				device_param.setCuda_function_aux3((null));
				device_param.setCuda_function_aux4((null));
				device_param.setCuda_module((null));
				device_param.setCuda_module_mp((null));
				device_param.setCuda_module_amp((null));
				device_param.setCuda_context((null));
			} 
			if (generatedIs_opencl == true) {
				if (generatedOpencl_d_pws_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_pws_buf);
				} 
				if (generatedOpencl_d_pws_amp_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_pws_amp_buf);
				} 
				if (generatedOpencl_d_pws_comp_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_pws_comp_buf);
				} 
				if (generatedOpencl_d_pws_idx) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_pws_idx);
				} 
				if (generatedOpencl_d_rules) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_rules);
				} 
				if (generatedOpencl_d_rules_c) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_rules_c);
				} 
				if (generatedOpencl_d_combs) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_combs);
				} 
				if (generatedOpencl_d_combs_c) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_combs_c);
				} 
				if (generatedOpencl_d_bfs) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_bfs);
				} 
				if (generatedOpencl_d_bfs_c) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_bfs_c);
				} 
				if (generatedOpencl_d_bitmap_s1_a) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_bitmap_s1_a);
				} 
				if (generatedOpencl_d_bitmap_s1_b) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_bitmap_s1_b);
				} 
				if (generatedOpencl_d_bitmap_s1_c) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_bitmap_s1_c);
				} 
				if (generatedOpencl_d_bitmap_s1_d) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_bitmap_s1_d);
				} 
				if (generatedOpencl_d_bitmap_s2_a) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_bitmap_s2_a);
				} 
				if (generatedOpencl_d_bitmap_s2_b) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_bitmap_s2_b);
				} 
				if (generatedOpencl_d_bitmap_s2_c) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_bitmap_s2_c);
				} 
				if (generatedOpencl_d_bitmap_s2_d) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_bitmap_s2_d);
				} 
				if (generatedOpencl_d_plain_bufs) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_plain_bufs);
				} 
				if (generatedOpencl_d_digests_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_digests_buf);
				} 
				if (generatedOpencl_d_digests_shown) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_digests_shown);
				} 
				if (generatedOpencl_d_salt_bufs) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_salt_bufs);
				} 
				if (generatedOpencl_d_esalt_bufs) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_esalt_bufs);
				} 
				if (generatedOpencl_d_tmps) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_tmps);
				} 
				if (generatedOpencl_d_hooks) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_hooks);
				} 
				if (generatedOpencl_d_result) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_result);
				} 
				if (generatedOpencl_d_extra0_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_extra0_buf);
				} 
				if (generatedOpencl_d_extra1_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_extra1_buf);
				} 
				if (generatedOpencl_d_extra2_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_extra2_buf);
				} 
				if (generatedOpencl_d_extra3_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_extra3_buf);
				} 
				if (generatedOpencl_d_root_css_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_root_css_buf);
				} 
				if (generatedOpencl_d_markov_css_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_markov_css_buf);
				} 
				if (generatedOpencl_d_tm_c) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_tm_c);
				} 
				if (generatedOpencl_d_st_digests_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_st_digests_buf);
				} 
				if (generatedOpencl_d_st_salts_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_st_salts_buf);
				} 
				if (generatedOpencl_d_st_esalts_buf) {
					hashcat_ctx.hc_clReleaseMemObject(generatedOpencl_d_st_esalts_buf);
				} 
				if (generatedOpencl_kernel1) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel1);
				} 
				if (generatedOpencl_kernel12) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel12);
				} 
				if (generatedOpencl_kernel2) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel2);
				} 
				if (generatedOpencl_kernel23) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel23);
				} 
				if (generatedOpencl_kernel3) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel3);
				} 
				if (generatedOpencl_kernel4) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel4);
				} 
				if (generatedOpencl_kernel_init2) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_init2);
				} 
				if (generatedOpencl_kernel_loop2) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_loop2);
				} 
				if (generatedOpencl_kernel_mp) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_mp);
				} 
				if (generatedOpencl_kernel_mp_l) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_mp_l);
				} 
				if (generatedOpencl_kernel_mp_r) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_mp_r);
				} 
				if (generatedOpencl_kernel_tm) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_tm);
				} 
				if (generatedOpencl_kernel_amp) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_amp);
				} 
				if (generatedOpencl_kernel_memset) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_memset);
				} 
				if (generatedOpencl_kernel_atinit) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_atinit);
				} 
				if (generatedOpencl_kernel_decompress) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_decompress);
				} 
				if (generatedOpencl_kernel_aux1) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_aux1);
				} 
				if (generatedOpencl_kernel_aux2) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_aux2);
				} 
				if (generatedOpencl_kernel_aux3) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_aux3);
				} 
				if (generatedOpencl_kernel_aux4) {
					hashcat_ctx.hc_clReleaseKernel(generatedOpencl_kernel_aux4);
				} 
				if (generatedOpencl_program) {
					hashcat_ctx.hc_clReleaseProgram(generatedOpencl_program);
				} 
				if (generatedOpencl_program_mp) {
					hashcat_ctx.hc_clReleaseProgram(generatedOpencl_program_mp);
				} 
				if (generatedOpencl_program_amp) {
					hashcat_ctx.hc_clReleaseProgram(generatedOpencl_program_amp);
				} 
				if (generatedOpencl_command_queue) {
					hashcat_ctx.hc_clReleaseCommandQueue(generatedOpencl_command_queue);
				} 
				if (generatedOpencl_context) {
					hashcat_ctx.hc_clReleaseContext(generatedOpencl_context);
				} 
				device_param.setOpencl_d_pws_buf((null));
				device_param.setOpencl_d_pws_amp_buf((null));
				device_param.setOpencl_d_pws_comp_buf((null));
				device_param.setOpencl_d_pws_idx((null));
				device_param.setOpencl_d_rules((null));
				device_param.setOpencl_d_rules_c((null));
				device_param.setOpencl_d_combs((null));
				device_param.setOpencl_d_combs_c((null));
				device_param.setOpencl_d_bfs((null));
				device_param.setOpencl_d_bfs_c((null));
				device_param.setOpencl_d_bitmap_s1_a((null));
				device_param.setOpencl_d_bitmap_s1_b((null));
				device_param.setOpencl_d_bitmap_s1_c((null));
				device_param.setOpencl_d_bitmap_s1_d((null));
				device_param.setOpencl_d_bitmap_s2_a((null));
				device_param.setOpencl_d_bitmap_s2_b((null));
				device_param.setOpencl_d_bitmap_s2_c((null));
				device_param.setOpencl_d_bitmap_s2_d((null));
				device_param.setOpencl_d_plain_bufs((null));
				device_param.setOpencl_d_digests_buf((null));
				device_param.setOpencl_d_digests_shown((null));
				device_param.setOpencl_d_salt_bufs((null));
				device_param.setOpencl_d_esalt_bufs((null));
				device_param.setOpencl_d_tmps((null));
				device_param.setOpencl_d_hooks((null));
				device_param.setOpencl_d_result((null));
				device_param.setOpencl_d_extra0_buf((null));
				device_param.setOpencl_d_extra1_buf((null));
				device_param.setOpencl_d_extra2_buf((null));
				device_param.setOpencl_d_extra3_buf((null));
				device_param.setOpencl_d_root_css_buf((null));
				device_param.setOpencl_d_markov_css_buf((null));
				device_param.setOpencl_d_tm_c((null));
				device_param.setOpencl_d_st_digests_buf((null));
				device_param.setOpencl_d_st_salts_buf((null));
				device_param.setOpencl_d_st_esalts_buf((null));
				device_param.setOpencl_kernel1((null));
				device_param.setOpencl_kernel12((null));
				device_param.setOpencl_kernel2((null));
				device_param.setOpencl_kernel23((null));
				device_param.setOpencl_kernel3((null));
				device_param.setOpencl_kernel4((null));
				device_param.setOpencl_kernel_init2((null));
				device_param.setOpencl_kernel_loop2((null));
				device_param.setOpencl_kernel_mp((null));
				device_param.setOpencl_kernel_mp_l((null));
				device_param.setOpencl_kernel_mp_r((null));
				device_param.setOpencl_kernel_tm((null));
				device_param.setOpencl_kernel_amp((null));
				device_param.setOpencl_kernel_memset((null));
				device_param.setOpencl_kernel_atinit((null));
				device_param.setOpencl_kernel_decompress((null));
				device_param.setOpencl_kernel_aux1((null));
				device_param.setOpencl_kernel_aux2((null));
				device_param.setOpencl_kernel_aux3((null));
				device_param.setOpencl_kernel_aux4((null));
				device_param.setOpencl_program((null));
				device_param.setOpencl_program_mp((null));
				device_param.setOpencl_program_amp((null));
				device_param.setOpencl_command_queue((null));
				device_param.setOpencl_context((null));
			} 
			device_param.setPws_comp((null));
			device_param.setPws_idx((null));
			device_param.setPws_pre_buf((null));
			device_param.setPws_base_buf((null));
			device_param.setCombs_buf((null));
			device_param.setHooks_buf((null));
			device_param.setScratch_buf((null));
		}
	}
	public void backend_session_reset() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		Object[] generatedSpeed_cnt = device_param.getSpeed_cnt();
		Object[] generatedSpeed_msec = device_param.getSpeed_msec();
		Object[] generatedExec_msec = device_param.getExec_msec();
		Object generatedPws_comp = device_param.getPws_comp();
		Object generatedSize_pws_comp = device_param.getSize_pws_comp();
		pw_idx generatedPws_idx = device_param.getPws_idx();
		Object generatedSize_pws_idx = device_param.getSize_pws_idx();
		Object generatedTimer_speed = device_param.getTimer_speed();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
			hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			device_param.setSpeed_pos(0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedSpeed_cnt, 0, 4096 * /*Error: Unsupported expression*/);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedSpeed_msec, 0, 4096 * /*Error: Unsupported expression*/);
			device_param.setSpeed_only_finish(0);
			device_param.setExec_pos(0);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedExec_msec, 0, 128 * /*Error: Unsupported expression*/);
			device_param.setOuterloop_msec(0);
			device_param.setOuterloop_pos(0);
			device_param.setOuterloop_left(0);
			device_param.setInnerloop_pos(0);
			device_param.setInnerloop_left(0);
			if (generatedPws_comp) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedPws_comp, 0, generatedSize_pws_comp);
			} 
			if (generatedPws_idx) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedPws_idx, 0, generatedSize_pws_idx);
			} 
			device_param.setPws_cnt(0);
			device_param.setWords_off(0);
			device_param.setWords_done(0);
			generatedTimer_speed.setQuadPart(0);
		}
		backend_ctx.setKernel_power_all(0);
		backend_ctx.setKernel_power_final(0);
	}
	public int backend_session_update_combinator() {
		combinator_ctx generatedCombinator_ctx = this.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object[] generatedKernel_params_buf32 = device_param.getKernel_params_buf32();
		Object generatedCombs_mode = combinator_ctx.getCombs_mode();
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		Object[] generatedKernel_params_amp_buf32 = device_param.getKernel_params_amp_buf32();
		Object generatedAttack_exec = hashconfig.getAttack_exec();
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_kernel_amp = device_param.getOpencl_kernel_amp();
		Object[] generatedKernel_params_amp = device_param.getKernel_params_amp();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
			hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			if (generatedSkipped_warning == true) {
				continue;
			} 
			generatedKernel_params_buf32[33] = generatedCombs_mode;
			if (generatedSlow_candidates == true) {
			} else {
					generatedKernel_params_amp_buf32[5] = generatedCombs_mode;
					if (generatedAttack_exec == attack_exec.ATTACK_EXEC_OUTSIDE_KERNEL) {
						if (generatedIs_opencl == true) {
							int rc_clSetKernelArg = hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_amp, 5, /*Error: Unsupported expression*/, generatedKernel_params_amp[5]);
							if (rc_clSetKernelArg == -1) {
								return -1;
							} 
						} 
					} 
			} 
		}
		return 0;
	}
	public int backend_session_update_mp() {
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		if (generatedSlow_candidates == true) {
			return 0;
		} 
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object[] generatedKernel_params_mp_buf64 = device_param.getKernel_params_mp_buf64();
		Object[] generatedKernel_params_mp_buf32 = device_param.getKernel_params_mp_buf32();
		Object generatedCss_cnt = mask_ctx.getCss_cnt();
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_d_root_css_buf = device_param.getCuda_d_root_css_buf();
		 generatedRoot_css_buf = mask_ctx.getRoot_css_buf();
		Object generatedSize_root_css = device_param.getSize_root_css();
		Object generatedCuda_d_markov_css_buf = device_param.getCuda_d_markov_css_buf();
		 generatedMarkov_css_buf = mask_ctx.getMarkov_css_buf();
		Object generatedSize_markov_css = device_param.getSize_markov_css();
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_kernel_mp = device_param.getOpencl_kernel_mp();
		Object[] generatedKernel_params_mp = device_param.getKernel_params_mp();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedOpencl_d_root_css_buf = device_param.getOpencl_d_root_css_buf();
		Object generatedOpencl_d_markov_css_buf = device_param.getOpencl_d_markov_css_buf();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
			hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			if (generatedSkipped_warning == true) {
				continue;
			} 
			generatedKernel_params_mp_buf64[3] = 0;
			generatedKernel_params_mp_buf32[4] = generatedCss_cnt;
			if (generatedIs_cuda == true) {
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_root_css_buf, generatedRoot_css_buf, generatedSize_root_css) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_markov_css_buf, generatedMarkov_css_buf, generatedSize_markov_css) == -1) {
					return -1;
				} 
			} 
			if (generatedIs_opencl == true) {
				for (u32 i = 3;
				 i < 4; i++) {
					if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp, i, /*Error: Unsupported expression*/, generatedKernel_params_mp[i]) == -1) {
						return -1;
					} 
				}
				for (u32 i = 4;
				 i < 8; i++) {
					if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp, i, /*Error: Unsupported expression*/, generatedKernel_params_mp[i]) == -1) {
						return -1;
					} 
				}
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_root_css_buf, CL_TRUE, 0, generatedSize_root_css, generatedRoot_css_buf, 0, (null), (null)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_markov_css_buf, CL_TRUE, 0, generatedSize_markov_css, generatedMarkov_css_buf, 0, (null), (null)) == -1) {
					return -1;
				} 
			} 
		}
		return 0;
	}
	public int backend_session_update_mp_rl(Object css_cnt_l, Object css_cnt_r) {
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		if (generatedSlow_candidates == true) {
			return 0;
		} 
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object[] generatedKernel_params_mp_l_buf64 = device_param.getKernel_params_mp_l_buf64();
		Object[] generatedKernel_params_mp_l_buf32 = device_param.getKernel_params_mp_l_buf32();
		Object[] generatedKernel_params_mp_r_buf64 = device_param.getKernel_params_mp_r_buf64();
		Object[] generatedKernel_params_mp_r_buf32 = device_param.getKernel_params_mp_r_buf32();
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_d_root_css_buf = device_param.getCuda_d_root_css_buf();
		 generatedRoot_css_buf = mask_ctx.getRoot_css_buf();
		Object generatedSize_root_css = device_param.getSize_root_css();
		Object generatedCuda_d_markov_css_buf = device_param.getCuda_d_markov_css_buf();
		 generatedMarkov_css_buf = mask_ctx.getMarkov_css_buf();
		Object generatedSize_markov_css = device_param.getSize_markov_css();
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_kernel_mp_l = device_param.getOpencl_kernel_mp_l();
		Object[] generatedKernel_params_mp_l = device_param.getKernel_params_mp_l();
		Object generatedOpencl_kernel_mp_r = device_param.getOpencl_kernel_mp_r();
		Object[] generatedKernel_params_mp_r = device_param.getKernel_params_mp_r();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedOpencl_d_root_css_buf = device_param.getOpencl_d_root_css_buf();
		Object generatedOpencl_d_markov_css_buf = device_param.getOpencl_d_markov_css_buf();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
			hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			if (generatedSkipped_warning == true) {
				continue;
			} 
			generatedKernel_params_mp_l_buf64[3] = 0;
			generatedKernel_params_mp_l_buf32[4] = css_cnt_l;
			generatedKernel_params_mp_l_buf32[5] = css_cnt_r;
			generatedKernel_params_mp_r_buf64[3] = 0;
			generatedKernel_params_mp_r_buf32[4] = css_cnt_r;
			if (generatedIs_cuda == true) {
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_root_css_buf, generatedRoot_css_buf, generatedSize_root_css) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_markov_css_buf, generatedMarkov_css_buf, generatedSize_markov_css) == -1) {
					return -1;
				} 
			} 
			if (generatedIs_opencl == true) {
				for (u32 i = 3;
				 i < 4; i++) {
					if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp_l, i, /*Error: Unsupported expression*/, generatedKernel_params_mp_l[i]) == -1) {
						return -1;
					} 
				}
				for (u32 i = 4;
				 i < 8; i++) {
					if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp_l, i, /*Error: Unsupported expression*/, generatedKernel_params_mp_l[i]) == -1) {
						return -1;
					} 
				}
				for (u32 i = 9;
				 i < 9; i++) {
					if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp_l, i, /*Error: Unsupported expression*/, generatedKernel_params_mp_l[i]) == -1) {
						return -1;
					} 
				}
				for (u32 i = 3;
				 i < 4; i++) {
					if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp_r, i, /*Error: Unsupported expression*/, generatedKernel_params_mp_r[i]) == -1) {
						return -1;
					} 
				}
				for (u32 i = 4;
				 i < 7; i++) {
					if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp_r, i, /*Error: Unsupported expression*/, generatedKernel_params_mp_r[i]) == -1) {
						return -1;
					} 
				}
				for (u32 i = 8;
				 i < 8; i++) {
					if (hashcat_ctx.hc_clSetKernelArg(generatedOpencl_kernel_mp_r, i, /*Error: Unsupported expression*/, generatedKernel_params_mp_r[i]) == -1) {
						return -1;
					} 
				}
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_root_css_buf, CL_TRUE, 0, generatedSize_root_css, generatedRoot_css_buf, 0, (null), (null)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_markov_css_buf, CL_TRUE, 0, generatedSize_markov_css, generatedMarkov_css_buf, 0, (null), (null)) == -1) {
					return -1;
				} 
			} 
		}
		return 0;
	}
	public int induct_ctx_init() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		induct_ctx generatedInduct_ctx = this.getInduct_ctx();
		induct_ctx_t induct_ctx = generatedInduct_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		induct_ctx.setEnabled(0);
		boolean generatedBenchmark = user_options.getBenchmark();
		if (generatedBenchmark == true) {
			return 0;
		} 
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedStdout_flag = user_options.getStdout_flag();
		if (generatedStdout_flag == true) {
			return 0;
		} 
		boolean generatedSpeed_only = user_options.getSpeed_only();
		if (generatedSpeed_only == true) {
			return 0;
		} 
		boolean generatedProgress_only = user_options.getProgress_only();
		if (generatedProgress_only == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		Object generatedAttack_mode = user_options.getAttack_mode();
		if (generatedAttack_mode != attack_mode.ATTACK_MODE_STRAIGHT) {
			return 0;
		} 
		induct_ctx.setEnabled(1);
		Byte generatedInduction_dir = user_options.getInduction_dir();
		Byte generatedSession_dir = folder_config.getSession_dir();
		Object generatedSession = user_options.getSession();
		if (generatedInduction_dir == (null)) {
			Byte root_directory;
			ModernizedCProgram.hc_asprintf(root_directory, "%s/%s.%s", generatedSession_dir, generatedSession, ModernizedCProgram.INDUCT_DIR);
			if (/*Error: Function owner not recognized*/rmdir(root_directory) == -1) {
				if ((/*Error: Function owner not recognized*/_errno()) == 2) {
				}  else if ((/*Error: Function owner not recognized*/_errno()) == 41) {
					Byte root_directory_mv;
					ModernizedCProgram.hc_asprintf(root_directory_mv, "%s/%s.induct.%d", generatedSession_dir, generatedSession, (int)/*Error: Function owner not recognized*/time((null)));
					if (/*Error: Function owner not recognized*/rename(root_directory, root_directory_mv) != 0) {
						hashcat_ctx.event_log_error("Rename directory %s to %s: %s", root_directory, root_directory_mv, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						return -1;
					} 
					ModernizedCProgram.hcfree(root_directory_mv);
				} else {
						hashcat_ctx.event_log_error("%s: %s", root_directory, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						return -1;
				} 
			} 
			if (ModernizedCProgram.hc_mkdir(root_directory, 700) == -1) {
				hashcat_ctx.event_log_error("%s: %s", root_directory, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
				return -1;
			} 
			induct_ctx.setRoot_directory(root_directory);
		} else {
				induct_ctx.setRoot_directory(ModernizedCProgram.hcstrdup(generatedInduction_dir));
		} 
		return 0;
	}
	public void induct_ctx_scan() {
		induct_ctx generatedInduct_ctx = this.getInduct_ctx();
		induct_ctx_t induct_ctx = generatedInduct_ctx;
		boolean generatedEnabled = induct_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		Byte generatedRoot_directory = induct_ctx.getRoot_directory();
		induct_ctx.setInduction_dictionaries(ModernizedCProgram.scan_directory(generatedRoot_directory));
		byte[][] generatedInduction_dictionaries = induct_ctx.getInduction_dictionaries();
		induct_ctx.setInduction_dictionaries_cnt(ModernizedCProgram.count_dictionaries(generatedInduction_dictionaries));
		int generatedInduction_dictionaries_cnt = induct_ctx.getInduction_dictionaries_cnt();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/qsort(generatedInduction_dictionaries, (size_t)generatedInduction_dictionaries_cnt, /*Error: Unsupported expression*/, sort_by_mtime);
	}
	public void induct_ctx_destroy() {
		induct_ctx generatedInduct_ctx = this.getInduct_ctx();
		induct_ctx_t induct_ctx = generatedInduct_ctx;
		boolean generatedEnabled = induct_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		Byte generatedRoot_directory = induct_ctx.getRoot_directory();
		if (/*Error: Function owner not recognized*/rmdir(generatedRoot_directory) == -1) {
			if ((/*Error: Function owner not recognized*/_errno()) == 2) {
			}  else if ((/*Error: Function owner not recognized*/_errno()) == 41) {
			} else {
					hashcat_ctx.event_log_error("%s: %s", generatedRoot_directory, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			} 
		} 
		ModernizedCProgram.hcfree(generatedRoot_directory);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(induct_ctx, 0, /*Error: Unsupported expression*/);
	}
	public int tuning_db_init() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		tuning_db generatedTuning_db = this.getTuning_db();
		tuning_db_t tuning_db = generatedTuning_db;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		tuning_db.setEnabled(0);
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		tuning_db.setEnabled(1);
		Byte tuning_db_file;
		Byte generatedShared_dir = folder_config.getShared_dir();
		ModernizedCProgram.hc_asprintf(tuning_db_file, "%s/%s", generatedShared_dir, "hashcat.hctune");
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(tuning_db_file, "rb") == 0) {
			hashcat_ctx.event_log_error("%s: %s", tuning_db_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		ModernizedCProgram.hcfree(tuning_db_file);
		size_t num_lines = fp.count_lines();
		// a bit over-allocated
		tuning_db.setAlias_buf((tuning_db_alias_t)ModernizedCProgram.hccalloc(num_lines + 1, /*Error: Unsupported expression*/));
		tuning_db.setAlias_cnt(0);
		tuning_db.setEntry_buf((tuning_db_entry_t)ModernizedCProgram.hccalloc(num_lines + 1, /*Error: Unsupported expression*/));
		tuning_db.setEntry_cnt(0);
		fp.hc_rewind();
		int line_num = 0;
		Byte buf = (byte)ModernizedCProgram.hcmalloc(-1024);
		tuning_db_alias[] generatedAlias_buf = tuning_db.getAlias_buf();
		int generatedAlias_cnt = tuning_db.getAlias_cnt();
		Object generatedAttack_kern = user_options_extra.getAttack_kern();
		tuning_db_entry[] generatedEntry_buf = tuning_db.getEntry_buf();
		int generatedEntry_cnt = tuning_db.getEntry_cnt();
		while (!fp.hc_feof()) {
			Byte line_buf = fp.hc_fgets(buf, -1024 - 1);
			if (line_buf == (null)) {
				break;
			} 
			line_num++;
			size_t line_len = ModernizedCProgram.in_superchop(line_buf);
			if (line_len == 0) {
				continue;
			} 
			if (line_buf[0] == (byte)'#') {
				continue;
			} 
			byte[] token_ptr = new byte[]{(null)};
			int token_cnt = 0;
			Byte saveptr = (null);
			Byte next = /*Error: Function owner not recognized*/strtok_r(line_buf, "\t ", saveptr);
			token_ptr[token_cnt] = next;
			token_cnt++;
			while ((next = /*Error: Function owner not recognized*/strtok_r((byte)(null), "\t ", saveptr)) != (null)) {
				token_ptr[token_cnt] = next;
				token_cnt++;
			}
			if (token_cnt == 2) {
				Byte device_name = token_ptr[0];
				Byte alias_name = token_ptr[1];
				tuning_db_alias_t alias = generatedAlias_buf[generatedAlias_cnt];
				alias.setDevice_name(ModernizedCProgram.hcstrdup(device_name));
				alias.setAlias_name(ModernizedCProgram.hcstrdup(alias_name));
				generatedAlias_cnt++;
			}  else if (token_cnt == 6) {
				if ((token_ptr[1][0] != (byte)'0') && (token_ptr[1][0] != (byte)'1') && (token_ptr[1][0] != (byte)'3') && (token_ptr[1][0] != (byte)'*')) {
					hashcat_ctx.event_log_warning("Tuning-db: Invalid attack_mode '%c' in Line '%d'", token_ptr[1][0], line_num);
					continue;
				} 
				if ((token_ptr[3][0] != (byte)'1') && (token_ptr[3][0] != (byte)'2') && (token_ptr[3][0] != (byte)'4') && (token_ptr[3][0] != (byte)'8') && (token_ptr[3][0] != (byte)'N')) {
					hashcat_ctx.event_log_warning("Tuning-db: Invalid vector_width '%c' in Line '%d'", token_ptr[3][0], line_num);
					continue;
				} 
				Byte device_name = token_ptr[0];
				int attack_mode = -1;
				int hash_mode = -1;
				int vector_width = -1;
				int kernel_accel = -1;
				int kernel_loops = -1;
				if (token_ptr[1][0] != (byte)'*') {
					attack_mode = (int)/*Error: Function owner not recognized*/strtol(token_ptr[1], (null), 10);
				} 
				if (token_ptr[2][0] != (byte)'*') {
					hash_mode = (int)/*Error: Function owner not recognized*/strtol(token_ptr[2], (null), 10);
				} 
				if (token_ptr[3][0] != (byte)'N') {
					vector_width = (int)/*Error: Function owner not recognized*/strtol(token_ptr[3], (null), 10);
				} 
				if (token_ptr[4][0] == (byte)'A') {
					kernel_accel = 0;
				}  else if (token_ptr[4][0] == (byte)'M') {
					kernel_accel = 1024;
				} else {
						kernel_accel = (int)/*Error: Function owner not recognized*/strtol(token_ptr[4], (null), 10);
						if ((kernel_accel < 1) || (kernel_accel > 1024)) {
							hashcat_ctx.event_log_warning("Tuning-db: Invalid kernel_accel '%d' in Line '%d'", kernel_accel, line_num);
							continue;
						} 
				} 
				if (token_ptr[5][0] == (byte)'A') {
					kernel_loops = 0;
				}  else if (token_ptr[5][0] == (byte)'M') {
					if (generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
						kernel_loops = amplifier_count.KERNEL_RULES;
					}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
						kernel_loops = amplifier_count.KERNEL_COMBS;
					}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_BF) {
						kernel_loops = amplifier_count.KERNEL_BFS;
					} 
				} else {
						kernel_loops = (int)/*Error: Function owner not recognized*/strtol(token_ptr[5], (null), 10);
						if (kernel_loops < 1) {
							hashcat_ctx.event_log_warning("Tuning-db: Invalid kernel_loops '%d' in Line '%d'", kernel_loops, line_num);
							continue;
						} 
						if ((generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) && (kernel_loops > amplifier_count.KERNEL_RULES)) {
							hashcat_ctx.event_log_warning("Tuning-db: Invalid kernel_loops '%d' in Line '%d'", kernel_loops, line_num);
							continue;
						} 
						if ((generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) && (kernel_loops > amplifier_count.KERNEL_COMBS)) {
							hashcat_ctx.event_log_warning("Tuning-db: Invalid kernel_loops '%d' in Line '%d'", kernel_loops, line_num);
							continue;
						} 
						if ((generatedAttack_kern == attack_kern.ATTACK_KERN_BF) && (kernel_loops > amplifier_count.KERNEL_BFS)) {
							hashcat_ctx.event_log_warning("Tuning-db: Invalid kernel_loops '%d' in Line '%d'", kernel_loops, line_num);
							continue;
						} 
				} 
				tuning_db_entry_t entry = generatedEntry_buf[generatedEntry_cnt];
				entry.setDevice_name(ModernizedCProgram.hcstrdup(device_name));
				entry.setAttack_mode(attack_mode);
				entry.setHash_mode(hash_mode);
				entry.setVector_width(vector_width);
				entry.setKernel_accel(kernel_accel);
				entry.setKernel_loops(kernel_loops);
				generatedEntry_cnt++;
			} else {
					hashcat_ctx.event_log_warning("Tuning-db: Invalid number of token in Line '%d'", line_num);
					continue;
			} 
		}
		ModernizedCProgram.hcfree(buf);
		fp.hc_fclose()// todo: print loaded 'cnt' message;// todo: print loaded 'cnt' message
		/*Error: Function owner not recognized*/// sort the database/*Error: Function owner not recognized*/// sort the databaseqsort(generatedAlias_buf, generatedAlias_cnt, /*Error: Unsupported expression*/, sort_by_tuning_db_alias);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/qsort(generatedEntry_buf, generatedEntry_cnt, /*Error: Unsupported expression*/, sort_by_tuning_db_entry);
		return 0;
	}
	public void tuning_db_destroy() {
		tuning_db generatedTuning_db = this.getTuning_db();
		tuning_db_t tuning_db = generatedTuning_db;
		boolean generatedEnabled = tuning_db.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		int i;
		int generatedAlias_cnt = tuning_db.getAlias_cnt();
		tuning_db_alias[] generatedAlias_buf = tuning_db.getAlias_buf();
		Byte generatedDevice_name = alias.getDevice_name();
		Byte generatedAlias_name = alias.getAlias_name();
		for (i = 0; i < generatedAlias_cnt; i++) {
			tuning_db_alias_t alias = generatedAlias_buf[i];
			ModernizedCProgram.hcfree(generatedDevice_name);
			ModernizedCProgram.hcfree(generatedAlias_name);
		}
		int generatedEntry_cnt = tuning_db.getEntry_cnt();
		tuning_db_entry[] generatedEntry_buf = tuning_db.getEntry_buf();
		for (i = 0; i < generatedEntry_cnt; i++) {
			tuning_db_entry_t entry = generatedEntry_buf[i];
			ModernizedCProgram.hcfree((Object)generatedDevice_name);
		}
		ModernizedCProgram.hcfree(generatedAlias_buf);
		ModernizedCProgram.hcfree(generatedEntry_buf);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(tuning_db, 0, /*Error: Unsupported expression*/);
	}
	public int init_restore() {
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		restore_data_t rd = (restore_data_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		restore_ctx.setRd(rd);
		rd.setVersion(510);
		int generatedArgc = restore_ctx.getArgc();
		rd.setArgc(generatedArgc);
		Byte generatedArgv = restore_ctx.getArgv();
		rd.setArgv(generatedArgv);
		Object[] generatedCwd = rd.getCwd();
		if (/*Error: Function owner not recognized*/getcwd(generatedCwd, 255) == (null)) {
			hashcat_ctx.event_log_error("getcwd(): %s", /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		return 0;
	}
	public int read_restore() {
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		boolean generatedEnabled = restore_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		Byte generatedEff_restore_file = restore_ctx.getEff_restore_file();
		Byte eff_restore_file = generatedEff_restore_file;
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(eff_restore_file, "rb") == 0) {
			hashcat_ctx.event_log_error("Restore file '%s': %s", eff_restore_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		restore_data generatedRd = restore_ctx.getRd();
		restore_data_t rd = generatedRd;
		if (fp.hc_fread(rd, /*Error: Unsupported expression*/, 1) != 1) {
			hashcat_ctx.event_log_error("Cannot read %s", eff_restore_file);
			fp.hc_fclose();
			return -1;
		} 
		Object generatedArgc = rd.getArgc();
		// we only use these 2 checks to avoid "tainted string" warningsif (generatedArgc < 1) {
			hashcat_ctx.event_log_error("Unusually low number of arguments (argc) within restore file %s", eff_restore_file);
			fp.hc_fclose();
			return -1;
		} 
		// some upper bound check is always good (with some dirs/dicts it could be a large string)if (generatedArgc > 250) {
			hashcat_ctx.event_log_error("Unusually high number of arguments (argc) within restore file %s", eff_restore_file);
			fp.hc_fclose();
			return -1;
		} 
		rd.setArgv((byte)ModernizedCProgram.hccalloc(generatedArgc, /*Error: Unsupported expression*/));
		byte[] buf = (byte)ModernizedCProgram.hcmalloc(-1024);
		byte[][] generatedArgv = rd.getArgv();
		for (u32 i = 0;
		 i < generatedArgc; i++) {
			if (fp.hc_fgets(buf, -1024 - 1) == (null)) {
				hashcat_ctx.event_log_error("Cannot read %s", eff_restore_file);
				fp.hc_fclose();
				ModernizedCProgram.hcfree(buf);
				return -1;
			} 
			size_t len = /*Error: Function owner not recognized*/strlen(buf);
			if (len) {
				buf[len - 1] = 0;
			} 
			generatedArgv[i] = ModernizedCProgram.hcstrdup(buf);
		}
		ModernizedCProgram.hcfree(buf);
		fp.hc_fclose();
		Object[] generatedCwd = rd.getCwd();
		if (ModernizedCProgram.hc_path_exist(generatedCwd) == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedCwd, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		if (ModernizedCProgram.hc_path_is_directory(generatedCwd) == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedCwd, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		Byte generatedInstall_dir = folder_config.getInstall_dir();
		Byte generatedShared_dir = folder_config.getShared_dir();
		// check if we need to change the current working directoryif (/*Error: Function owner not recognized*/strncmp(generatedCwd, generatedCwd, /*Error: sizeof expression not supported yet*/) != 0) {
			hashcat_ctx.event_log_warning("Changing current working directory to '%s'", generatedCwd);
			hashcat_ctx.event_log_warning((null));
			if (/*Error: Function owner not recognized*/chdir(generatedCwd)) {
				hashcat_ctx.event_log_error("Directory '%s' needed to restore the session was not found.", generatedCwd);
				hashcat_ctx.event_log_warning("Either create the directory, or update the directory within the .restore file.");
				hashcat_ctx.event_log_warning("Restore files can be analyzed and modified with analyze_hc_restore.pl:");
				hashcat_ctx.event_log_warning("    https://github.com/philsmd/analyze_hc_restore");
				hashcat_ctx.event_log_warning("Directory must contain all files and folders from the original command line.");
				hashcat_ctx.event_log_warning((null));
				return -1/**
				     * updated folders
				     */;
			} 
			Byte install_folder = ModernizedCProgram.hcstrdup(generatedInstall_dir);
			Byte shared_folder = ModernizedCProgram.hcstrdup(generatedShared_dir);
			hashcat_ctx.folder_config_destroy();
			int rc_folder_config_init = hashcat_ctx.folder_config_init(install_folder, shared_folder);
			ModernizedCProgram.hcfree(install_folder);
			ModernizedCProgram.hcfree(shared_folder);
			if (rc_folder_config_init == -1) {
				return -1/**
				     * updated pidfile
				     */;
			} 
			hashcat_ctx.pidfile_ctx_destroy();
			if (hashcat_ctx.pidfile_ctx_init() == -1) {
				return -1;
			} 
		} 
		return 0;
	}
	public int write_restore() {
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		if (restore_ctx.getEnabled() == 0) {
			return 0;
		} 
		restore_data_t rd = restore_ctx.getRd();
		rd.setMasks_pos(mask_ctx.getMasks_pos());
		rd.setDicts_pos(straight_ctx.getDicts_pos());
		rd.setWords_cur(status_ctx.getWords_cur());
		Byte new_restore_file = restore_ctx.getNew_restore_file();
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(new_restore_file, "wb") == 0) {
			hashcat_ctx.event_log_error("%s: %s", new_restore_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		_iobuf generatedPfp = fp.getPfp();
		if (/*Error: Function owner not recognized*/setvbuf(generatedPfp, (null), -1024, 0)) {
			hashcat_ctx.event_log_error("setvbuf file '%s': %s", new_restore_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			fp.hc_fclose();
			return -1;
		} 
		fp.hc_fwrite(rd, /*Error: Unsupported expression*/, 1);
		Object generatedArgc = rd.getArgc();
		byte[][] generatedArgv = rd.getArgv();
		for (u32 i = 0;
		 i < generatedArgc; i++) {
			fp.hc_fprintf("%s", generatedArgv[i]);
			fp.hc_fputc((byte)'\n');
		}
		fp.hc_fflush();
		ModernizedCProgram.fsync(fp.hc_fileno());
		fp.hc_fclose();
		rd.setMasks_pos(0);
		rd.setDicts_pos(0);
		rd.setWords_cur(0);
		return 0;
	}
	public int cycle_restore() {
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		boolean generatedEnabled = restore_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		Byte generatedEff_restore_file = restore_ctx.getEff_restore_file();
		Byte eff_restore_file = generatedEff_restore_file;
		Byte generatedNew_restore_file = restore_ctx.getNew_restore_file();
		Byte new_restore_file = generatedNew_restore_file;
		if (hashcat_ctx.write_restore() == -1) {
			return -1;
		} 
		if (ModernizedCProgram.hc_path_exist(eff_restore_file) == 1) {
			if (/*Error: Function owner not recognized*/unlink(eff_restore_file) == -1) {
				hashcat_ctx.event_log_warning("Unlink file '%s': %s", eff_restore_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			} 
		} 
		if (/*Error: Function owner not recognized*/rename(new_restore_file, eff_restore_file) == -1) {
			hashcat_ctx.event_log_warning("Rename file '%s' to '%s': %s", new_restore_file, eff_restore_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
		} 
		return 0;
	}
	public void unlink_restore() {
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		boolean generatedEnabled = restore_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		Object generatedDevices_status = status_ctx.getDevices_status();
		boolean generatedRun_thread_level1 = status_ctx.getRun_thread_level1();
		Byte generatedEff_restore_file = restore_ctx.getEff_restore_file();
		Byte generatedNew_restore_file = restore_ctx.getNew_restore_file();
		// this is to check for [c]heckpointif ((generatedDevices_status == status_rc.STATUS_EXHAUSTED) && (generatedRun_thread_level1 == true)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(generatedEff_restore_file);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(generatedNew_restore_file);
		} 
		if (generatedDevices_status == status_rc.STATUS_CRACKED) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(generatedEff_restore_file);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(generatedNew_restore_file);
		} 
	}
	public int restore_ctx_init(int argc, Byte argv) {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		restore_ctx.setEnabled(0);
		boolean generatedBenchmark = user_options.getBenchmark();
		if (generatedBenchmark == true) {
			return 0;
		} 
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedStdout_flag = user_options.getStdout_flag();
		if (generatedStdout_flag == true) {
			return 0;
		} 
		boolean generatedSpeed_only = user_options.getSpeed_only();
		if (generatedSpeed_only == true) {
			return 0;
		} 
		boolean generatedProgress_only = user_options.getProgress_only();
		if (generatedProgress_only == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		boolean generatedRestore_disable = user_options.getRestore_disable();
		if (generatedRestore_disable == true) {
			return 0;
		} 
		if (argc == 0) {
			return 0;
		} 
		if (argv == (null)) {
			return 0;
		} 
		Byte generatedRestore_file_path = user_options.getRestore_file_path();
		Byte generatedEff_restore_file = restore_ctx.getEff_restore_file();
		Byte generatedSession_dir = folder_config.getSession_dir();
		Object generatedSession = user_options.getSession();
		Byte generatedNew_restore_file = restore_ctx.getNew_restore_file();
		if (generatedRestore_file_path == (null)) {
			ModernizedCProgram.hc_asprintf(generatedEff_restore_file, "%s/%s.restore", generatedSession_dir, generatedSession);
			ModernizedCProgram.hc_asprintf(generatedNew_restore_file, "%s/%s.restore.new", generatedSession_dir, generatedSession);
		} else {
				restore_ctx.setEff_restore_file(ModernizedCProgram.hcstrdup(generatedRestore_file_path));
				ModernizedCProgram.hc_asprintf(generatedNew_restore_file, "%s.new", generatedRestore_file_path);
		} 
		restore_ctx.setArgc(argc);
		restore_ctx.setArgv(argv);
		if (hashcat_ctx.init_restore() == -1) {
			return -1;
		} 
		restore_ctx.setEnabled(1);
		restore_ctx.setRestore_execute(0);
		boolean generatedRestore = user_options.getRestore();
		restore_data generatedRd = restore_ctx.getRd();
		Object generatedArgc = rd.getArgc();
		byte[][] generatedArgv = rd.getArgv();
		if (generatedRestore == true) {
			if (hashcat_ctx.read_restore() == -1) {
				return -1;
			} 
			restore_data_t rd = generatedRd;
			if (generatedVersion < 340) {
				hashcat_ctx.event_log_error("Incompatible restore-file version.");
				return -1;
			} 
			hashcat_ctx.user_options_init();
			if (hashcat_ctx.user_options_getopt(generatedArgc, generatedArgv) == -1) {
				return -1;
			} 
			restore_ctx.setRestore_execute(1);
		} 
		return 0;
	}
	public void restore_ctx_destroy() {
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		boolean generatedEnabled = restore_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		Byte generatedEff_restore_file = restore_ctx.getEff_restore_file();
		ModernizedCProgram.hcfree(generatedEff_restore_file);
		Byte generatedNew_restore_file = restore_ctx.getNew_restore_file();
		ModernizedCProgram.hcfree(generatedNew_restore_file);
		restore_data generatedRd = restore_ctx.getRd();
		ModernizedCProgram.hcfree(generatedRd);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(restore_ctx, 0, /*Error: Unsupported expression*/);
	}
	public void welcome_screen(Object version_tag) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getKeyspace() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getStdout_flag() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getShow() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getLeft() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getBenchmark() == 1) {
			if (user_options.getMachine_readable() == 0) {
				hashcat_ctx.event_log_info("%s (%s) starting in benchmark mode...", "hashcat", version_tag);
				hashcat_ctx.event_log_info((null));
				if (user_options.getWorkload_profile_chgd() == 0) {
					hashcat_ctx.event_log_advice("Benchmarking uses hand-optimized kernel code by default.");
					hashcat_ctx.event_log_advice("You can use it in your cracking session by setting the -O option.");
					hashcat_ctx.event_log_advice("Note: Using optimized kernel code limits the maximum supported password length.");
					hashcat_ctx.event_log_advice("To disable the optimized kernel code in benchmark mode, use the -w option.");
					hashcat_ctx.event_log_advice((null));
				} 
			} else {
					hashcat_ctx.event_log_info("# version: %s", version_tag);
			} 
		}  else if (user_options.getRestore() == 1) {
			hashcat_ctx.event_log_info("%s (%s) starting in restore mode...", "hashcat", version_tag);
			hashcat_ctx.event_log_info((null));
		}  else if (user_options.getSpeed_only() == 1) {
			hashcat_ctx.event_log_info("%s (%s) starting in speed-only mode...", "hashcat", version_tag);
			hashcat_ctx.event_log_info((null));
		}  else if (user_options.getProgress_only() == 1) {
			hashcat_ctx.event_log_info("%s (%s) starting in progress-only mode...", "hashcat", version_tag);
			hashcat_ctx.event_log_info((null));
		} else {
				hashcat_ctx.event_log_info("%s (%s) starting...", "hashcat", version_tag);
				hashcat_ctx.event_log_info((null));
		} 
		if (user_options.getForce() == 1) {
			hashcat_ctx.event_log_warning("You have enabled --force to bypass dangerous warnings and errors!");
			hashcat_ctx.event_log_warning("This can hide serious problems and should only be done when debugging.");
			hashcat_ctx.event_log_warning("Do not report hashcat issues encountered when using --force.");
		} 
	}
	public void goodbye_screen(Object proc_start, Object proc_stop) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getKeyspace() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getStdout_flag() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getShow() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getLeft() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		byte[] start_buf = new byte[32];
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(start_buf, 0, /*Error: sizeof expression not supported yet*/);
		byte[] stop_buf = new byte[32];
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(start_buf, 0, /*Error: sizeof expression not supported yet*/);
		hashcat_ctx.event_log_info_nn("Started: %s", /*Error: Function owner not recognized*/ctime_r(proc_start, start_buf));
		hashcat_ctx.event_log_info_nn("Stopped: %s", /*Error: Function owner not recognized*/ctime_r(proc_stop, stop_buf));
	}
	public void send_prompt() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		if (status_ctx.getDevices_status() == status_rc.STATUS_PAUSED) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[1]), "%s", ModernizedCProgram.PROMPT_PAUSED);
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[1]), "%s", ModernizedCProgram.PROMPT_ACTIVE);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fflush((_iob[1]));
	}
	public void clear_prompt() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		size_t prompt_sz = 0;
		if (status_ctx.getDevices_status() == status_rc.STATUS_PAUSED) {
			prompt_sz = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.PROMPT_PAUSED);
		} else {
				prompt_sz = /*Error: Function owner not recognized*/strlen(ModernizedCProgram.PROMPT_ACTIVE);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fputc((byte)'\r', (_iob[1]));
		for (size_t i = 0;
		 i < prompt_sz; i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fputc((byte)' ', (_iob[1]));
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fputc((byte)'\r', (_iob[1]));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fflush((_iob[1]));
	}
	public void keypress() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Object generatedDevices_status = status_ctx.getDevices_status();
		// this is required, because some of the variables down there are not initialized at that pointwhile (generatedDevices_status == status_rc.STATUS_INIT) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/usleep(100000);
		}
		boolean generatedQuiet = user_options.getQuiet();
		boolean quiet = generatedQuiet;
		ModernizedCProgram.tty_break();
		boolean generatedShutdown_outer = status_ctx.getShutdown_outer();
		Object generatedMux_display = status_ctx.getMux_display();
		boolean generatedCheckpoint_shutdown = status_ctx.getCheckpoint_shutdown();
		while (generatedShutdown_outer == false) {
			int ch = ModernizedCProgram.tty_getchar();
			if (ch == -1) {
				break;
			} 
			if (ch == 0) {
				continue;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject(generatedMux_display, -1024);
			hashcat_ctx.event_log_info((null));
			switch (ch) {
			case (byte)'\r':
			case (byte)'r':
					if (generatedDevices_status == status_rc.STATUS_PAUSED) {
						hashcat_ctx.event_log_info((null));
						hashcat_ctx.ResumeThreads();
						if (generatedDevices_status != status_rc.STATUS_PAUSED) {
							hashcat_ctx.event_log_info("Resumed");
						} 
						hashcat_ctx.event_log_info((null));
					} 
					if (quiet == 0) {
						hashcat_ctx.send_prompt();
					} 
					break;
			case (byte)'s':
			case (byte)'\n':
					hashcat_ctx.event_log_info((null));
					hashcat_ctx.status_display();
					hashcat_ctx.event_log_info((null));
					if (quiet == 0) {
						hashcat_ctx.send_prompt();
					} 
					break;
			case (byte)'b':
					hashcat_ctx.event_log_info((null));
					hashcat_ctx.bypass();
					hashcat_ctx.event_log_info("Next dictionary / mask in queue selected. Bypassing current one.");
					hashcat_ctx.event_log_info((null));
					if (quiet == 0) {
						hashcat_ctx.send_prompt();
					} 
					break;
			case (byte)'q':
					hashcat_ctx.event_log_info((null));
					hashcat_ctx.myquit();
					break;
			case (byte)'p':
					if (generatedDevices_status != status_rc.STATUS_PAUSED) {
						hashcat_ctx.event_log_info((null));
						hashcat_ctx.SuspendThreads();
						if (generatedDevices_status == status_rc.STATUS_PAUSED) {
							hashcat_ctx.event_log_info("Paused");
						} 
						hashcat_ctx.event_log_info((null));
					} 
					if (quiet == 0) {
						hashcat_ctx.send_prompt();
					} 
					break;
			case (byte)'c':
					hashcat_ctx.event_log_info((null));
					hashcat_ctx.stop_at_checkpoint();
					if (generatedCheckpoint_shutdown == true) {
						hashcat_ctx.event_log_info("Checkpoint enabled. Will quit at next restore-point update.");
					} else {
							hashcat_ctx.event_log_info("Checkpoint disabled. Restore-point updates will no longer be monitored.");
					} 
					hashcat_ctx.event_log_info((null));
					if (quiet == 0) {
						hashcat_ctx.send_prompt();
					} 
					break;
			default:
					if (quiet == 0) {
						hashcat_ctx.send_prompt();
					} 
					break;
			}
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseMutex(generatedMux_display);
		}
		ModernizedCProgram.tty_fix();
	}
	public void example_hashes() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedHash_mode_chgd = user_options.getHash_mode_chgd();
		hashconfig generatedHashconfig = this.getHashconfig();
		int generatedHash_mode = hashconfig.getHash_mode();
		Object generatedHash_name = hashconfig.getHash_name();
		Object generatedSt_hash = hashconfig.getSt_hash();
		Object generatedSt_pass = hashconfig.getSt_pass();
		byte generatedSeparator = user_options.getSeparator();
		if (generatedHash_mode_chgd == true) {
			if (hashcat_ctx.hashconfig_init() == 0) {
				hashconfig_t hashconfig = generatedHashconfig;
				hashcat_ctx.event_log_info("MODE: %u", generatedHash_mode);
				hashcat_ctx.event_log_info("TYPE: %s", generatedHash_name);
				if ((generatedSt_hash != (null)) && (generatedSt_pass != (null))) {
					hashcat_ctx.event_log_info("HASH: %s", generatedSt_hash);
					if (ModernizedCProgram.need_hexify((u8)generatedSt_pass, /*Error: Function owner not recognized*/strlen(generatedSt_pass), generatedSeparator, 0)) {
						byte[] tmp_buf = new byte[]{0};
						int tmp_len = 0;
						tmp_buf[tmp_len++] = (byte)'$';
						tmp_buf[tmp_len++] = (byte)'H';
						tmp_buf[tmp_len++] = (byte)'E';
						tmp_buf[tmp_len++] = (byte)'X';
						tmp_buf[tmp_len++] = (byte)'[';
						ModernizedCProgram.exec_hexify((u8)generatedSt_pass, /*Error: Function owner not recognized*/strlen(generatedSt_pass), (u8)tmp_buf + tmp_len);
						tmp_len += /*Error: Function owner not recognized*/strlen(generatedSt_pass) * 2;
						tmp_buf[tmp_len++] = (byte)']';
						tmp_buf[tmp_len++] = 0;
						hashcat_ctx.event_log_info("PASS: %s", tmp_buf);
					} else {
							hashcat_ctx.event_log_info("PASS: %s", generatedSt_pass);
					} 
				} else {
						hashcat_ctx.event_log_info("HASH: not stored");
						hashcat_ctx.event_log_info("PASS: not stored");
				} 
				hashcat_ctx.event_log_info((null));
			} 
			hashcat_ctx.hashconfig_destroy();
		} else {
				Byte modulefile = (byte)ModernizedCProgram.hcmalloc(-1024);
				for (int i = 0;
				 i < ModernizedCProgram.MODULE_HASH_MODES_MAXIMUM; i++) {
					user_options.setHash_mode(i);
					ModernizedCProgram.module_filename(folder_config, i, modulefile, -1024);
					if (ModernizedCProgram.hc_path_exist(modulefile) == 0) {
						continue;
					} 
					if (hashcat_ctx.hashconfig_init() == 0) {
						hashconfig_t hashconfig = generatedHashconfig;
						hashcat_ctx.event_log_info("MODE: %u", generatedHash_mode);
						hashcat_ctx.event_log_info("TYPE: %s", generatedHash_name);
						if ((generatedSt_hash != (null)) && (generatedSt_pass != (null))) {
							hashcat_ctx.event_log_info("HASH: %s", generatedSt_hash);
							if (ModernizedCProgram.need_hexify((u8)generatedSt_pass, /*Error: Function owner not recognized*/strlen(generatedSt_pass), generatedSeparator, 0)) {
								byte[] tmp_buf = new byte[]{0};
								int tmp_len = 0;
								tmp_buf[tmp_len++] = (byte)'$';
								tmp_buf[tmp_len++] = (byte)'H';
								tmp_buf[tmp_len++] = (byte)'E';
								tmp_buf[tmp_len++] = (byte)'X';
								tmp_buf[tmp_len++] = (byte)'[';
								ModernizedCProgram.exec_hexify((u8)generatedSt_pass, /*Error: Function owner not recognized*/strlen(generatedSt_pass), (u8)tmp_buf + tmp_len);
								tmp_len += /*Error: Function owner not recognized*/strlen(generatedSt_pass) * 2;
								tmp_buf[tmp_len++] = (byte)']';
								tmp_buf[tmp_len++] = 0;
								hashcat_ctx.event_log_info("PASS: %s", tmp_buf);
							} else {
									hashcat_ctx.event_log_info("PASS: %s", generatedSt_pass);
							} 
						} else {
								hashcat_ctx.event_log_info("HASH: not stored");
								hashcat_ctx.event_log_info("PASS: not stored");
						} 
						hashcat_ctx.event_log_info((null));
					} 
					hashcat_ctx.hashconfig_destroy();
				}
				ModernizedCProgram.hcfree(modulefile);
		} 
	}
	public void backend_info() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		if (backend_ctx.getCuda()) {
			hashcat_ctx.event_log_info("CUDA Info:");
			hashcat_ctx.event_log_info("==========");
			hashcat_ctx.event_log_info((null));
			int cuda_devices_cnt = backend_ctx.getCuda_devices_cnt();
			int cuda_driver_version = backend_ctx.getCuda_driver_version();
			hashcat_ctx.event_log_info("CUDA.Version.: %d.%d", cuda_driver_version / 1000, (cuda_driver_version % 100) / 10);
			hashcat_ctx.event_log_info((null));
			for (int cuda_devices_idx = 0;
			 cuda_devices_idx < cuda_devices_cnt; cuda_devices_idx++) {
				int backend_devices_idx = backend_ctx.getBackend_device_from_cuda()[cuda_devices_idx];
				hc_device_param_t device_param = backend_ctx.getDevices_param() + backend_devices_idx;
				int device_id = device_param.getDevice_id();
				Byte device_name = device_param.getDevice_name();
				u32 device_processors = device_param.getDevice_processors();
				u32 device_maxclock_frequency = device_param.getDevice_maxclock_frequency();
				u64 device_global_mem = device_param.getDevice_global_mem();
				if (device_param.getDevice_id_alias_cnt()) {
					hashcat_ctx.event_log_info("Backend Device ID #%d (Alias: #%d)", device_id + 1, device_param.getDevice_id_alias_buf()[0] + 1);
				} else {
						hashcat_ctx.event_log_info("Backend Device ID #%d", device_id + 1);
				} 
				hashcat_ctx.event_log_info("  Name...........: %s", device_name);
				hashcat_ctx.event_log_info("  Processor(s)...: %u", device_processors);
				hashcat_ctx.event_log_info("  Clock..........: %u", device_maxclock_frequency);
				hashcat_ctx.event_log_info("  Memory.........: %I64u MB", device_global_mem / 1024 / 1024);
				hashcat_ctx.event_log_info((null));
			}
		} 
		if (backend_ctx.getOcl()) {
			hashcat_ctx.event_log_info("OpenCL Info:");
			hashcat_ctx.event_log_info("============");
			hashcat_ctx.event_log_info((null));
			 opencl_platforms_cnt = backend_ctx.getOpencl_platforms_cnt();
			 opencl_platforms_devices_cnt = backend_ctx.getOpencl_platforms_devices_cnt();
			Byte opencl_platforms_name = backend_ctx.getOpencl_platforms_name();
			Byte opencl_platforms_vendor = backend_ctx.getOpencl_platforms_vendor();
			Byte opencl_platforms_version = backend_ctx.getOpencl_platforms_version();
			for ( opencl_platforms_idx = 0;
			 opencl_platforms_idx < opencl_platforms_cnt; opencl_platforms_idx++) {
				Byte opencl_platform_vendor = opencl_platforms_vendor[opencl_platforms_idx];
				Byte opencl_platform_name = opencl_platforms_name[opencl_platforms_idx];
				Byte opencl_platform_version = opencl_platforms_version[opencl_platforms_idx];
				 opencl_platform_devices_cnt = opencl_platforms_devices_cnt[opencl_platforms_idx];
				hashcat_ctx.event_log_info("OpenCL Platform ID #%u", opencl_platforms_idx + 1);
				hashcat_ctx.event_log_info("  Vendor..: %s", opencl_platform_vendor);
				hashcat_ctx.event_log_info("  Name....: %s", opencl_platform_name);
				hashcat_ctx.event_log_info("  Version.: %s", opencl_platform_version);
				hashcat_ctx.event_log_info((null));
				for ( opencl_platform_devices_idx = 0;
				 opencl_platform_devices_idx < opencl_platform_devices_cnt; opencl_platform_devices_idx++) {
					int backend_devices_idx = backend_ctx.getBackend_device_from_opencl_platform()[opencl_platforms_idx][opencl_platform_devices_idx];
					hc_device_param_t device_param = backend_ctx.getDevices_param() + backend_devices_idx;
					int device_id = device_param.getDevice_id();
					Byte device_name = device_param.getDevice_name();
					u32 device_processors = device_param.getDevice_processors();
					u32 device_maxclock_frequency = device_param.getDevice_maxclock_frequency();
					u64 device_maxmem_alloc = device_param.getDevice_maxmem_alloc();
					u64 device_global_mem = device_param.getDevice_global_mem();
					 opencl_device_type = device_param.getOpencl_device_type();
					 opencl_device_vendor_id = device_param.getOpencl_device_vendor_id();
					Byte opencl_device_vendor = device_param.getOpencl_device_vendor();
					Byte opencl_device_c_version = device_param.getOpencl_device_c_version();
					Byte opencl_device_version = device_param.getOpencl_device_version();
					Byte opencl_driver_version = device_param.getOpencl_driver_version();
					if (device_param.getDevice_id_alias_cnt()) {
						hashcat_ctx.event_log_info("  Backend Device ID #%d (Alias: #%d)", device_id + 1, device_param.getDevice_id_alias_buf()[0] + 1);
					} else {
							hashcat_ctx.event_log_info("  Backend Device ID #%d", device_id + 1);
					} 
					hashcat_ctx.event_log_info("    Type...........: %s", ((opencl_device_type & CL_DEVICE_TYPE_CPU) ? "CPU" : ((opencl_device_type & CL_DEVICE_TYPE_GPU) ? "GPU" : "Accelerator")));
					hashcat_ctx.event_log_info("    Vendor.ID......: %u", opencl_device_vendor_id);
					hashcat_ctx.event_log_info("    Vendor.........: %s", opencl_device_vendor);
					hashcat_ctx.event_log_info("    Name...........: %s", device_name);
					hashcat_ctx.event_log_info("    Version........: %s", opencl_device_version);
					hashcat_ctx.event_log_info("    Processor(s)...: %u", device_processors);
					hashcat_ctx.event_log_info("    Clock..........: %u", device_maxclock_frequency);
					hashcat_ctx.event_log_info("    Memory.........: %I64u/%I64u MB allocatable", device_maxmem_alloc / 1024 / 1024, device_global_mem / 1024 / 1024);
					hashcat_ctx.event_log_info("    OpenCL.Version.: %s", opencl_device_c_version);
					hashcat_ctx.event_log_info("    Driver.Version.: %s", opencl_driver_version);
					hashcat_ctx.event_log_info((null));
				}
			}
		} 
	}
	public void backend_info_compact() {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getMachine_readable() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getStatus_json() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (backend_ctx.getCuda()) {
			int cuda_devices_cnt = backend_ctx.getCuda_devices_cnt();
			int cuda_driver_version = backend_ctx.getCuda_driver_version();
			size_t len = hashcat_ctx.event_log_info("CUDA API (CUDA %d.%d)", cuda_driver_version / 1000, (cuda_driver_version % 100) / 10);
			byte[] line = new byte[]{0};
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(line, (byte)'=', len);
			line[len] = 0;
			hashcat_ctx.event_log_info("%s", line);
			for (int cuda_devices_idx = 0;
			 cuda_devices_idx < cuda_devices_cnt; cuda_devices_idx++) {
				int backend_devices_idx = backend_ctx.getBackend_device_from_cuda()[cuda_devices_idx];
				hc_device_param_t device_param = backend_ctx.getDevices_param() + backend_devices_idx;
				int device_id = device_param.getDevice_id();
				Byte device_name = device_param.getDevice_name();
				u32 device_processors = device_param.getDevice_processors();
				u64 device_global_mem = device_param.getDevice_global_mem();
				if ((device_param.getSkipped() == 0) && (device_param.getSkipped_warning() == 0)) {
					hashcat_ctx.event_log_info("* Device #%u: %s, %I64u MB, %uMCU", device_id + 1, device_name, device_global_mem / 1024 / 1024, device_processors);
				} else {
						hashcat_ctx.event_log_info("* Device #%u: %s, skipped", device_id + 1, device_name);
				} 
			}
			hashcat_ctx.event_log_info((null));
		} 
		if (backend_ctx.getOcl()) {
			 opencl_platforms_cnt = backend_ctx.getOpencl_platforms_cnt();
			 opencl_platforms_devices_cnt = backend_ctx.getOpencl_platforms_devices_cnt();
			Byte opencl_platforms_vendor = backend_ctx.getOpencl_platforms_vendor();
			Byte opencl_platforms_version = backend_ctx.getOpencl_platforms_version();
			for ( opencl_platforms_idx = 0;
			 opencl_platforms_idx < opencl_platforms_cnt; opencl_platforms_idx++) {
				Byte opencl_platform_vendor = opencl_platforms_vendor[opencl_platforms_idx];
				Byte opencl_platform_version = opencl_platforms_version[opencl_platforms_idx];
				 opencl_platform_devices_cnt = opencl_platforms_devices_cnt[opencl_platforms_idx];
				size_t len = hashcat_ctx.event_log_info("OpenCL API (%s) - Platform #%u [%s]", opencl_platform_version, opencl_platforms_idx + 1, opencl_platform_vendor);
				byte[] line = new byte[]{0};
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(line, (byte)'=', len);
				line[len] = 0;
				hashcat_ctx.event_log_info("%s", line);
				for ( opencl_platform_devices_idx = 0;
				 opencl_platform_devices_idx < opencl_platform_devices_cnt; opencl_platform_devices_idx++) {
					int backend_devices_idx = backend_ctx.getBackend_device_from_opencl_platform()[opencl_platforms_idx][opencl_platform_devices_idx];
					hc_device_param_t device_param = backend_ctx.getDevices_param() + backend_devices_idx;
					int device_id = device_param.getDevice_id();
					Byte device_name = device_param.getDevice_name();
					u32 device_processors = device_param.getDevice_processors();
					u64 device_maxmem_alloc = device_param.getDevice_maxmem_alloc();
					u64 device_global_mem = device_param.getDevice_global_mem();
					if ((device_param.getSkipped() == 0) && (device_param.getSkipped_warning() == 0)) {
						hashcat_ctx.event_log_info("* Device #%u: %s, %I64u/%I64u MB allocatable, %uMCU", device_id + 1, device_name, device_maxmem_alloc / 1024 / 1024, device_global_mem / 1024 / 1024, device_processors);
					} else {
							hashcat_ctx.event_log_info("* Device #%u: %s, skipped", device_id + 1, device_name);
					} 
				}
				hashcat_ctx.event_log_info((null));
			}
		} 
	}
	public void status_display_machine_readable() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		hashcat_status_t hashcat_status = (hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, hashcat_status) == -1) {
			ModernizedCProgram.hcfree(hashcat_status);
			return /*Error: Unsupported expression*/;
		} 
		int generatedStatus_number = hashcat_status.getStatus_number();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("STATUS\t%d\t", generatedStatus_number);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("SPEED\t");
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object[] generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("%I64u\t", (u64)(device_info.getHashes_msec_dev() * 1000));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("1000\t");
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("EXEC_RUNTIME\t");
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("%f\t", device_info.getExec_msec_dev());
		}
		Object generatedRestore_point = hashcat_status.getRestore_point();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("CURKU\t%I64u\t", generatedRestore_point);
		Object generatedProgress_cur_relative_skip = hashcat_status.getProgress_cur_relative_skip();
		Object generatedProgress_end_relative_skip = hashcat_status.getProgress_end_relative_skip();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("PROGRESS\t%I64u\t%I64u\t", generatedProgress_cur_relative_skip, generatedProgress_end_relative_skip);
		int generatedDigests_done = hashcat_status.getDigests_done();
		int generatedDigests_cnt = hashcat_status.getDigests_cnt();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("RECHASH\t%d\t%d\t", generatedDigests_done, generatedDigests_cnt);
		int generatedSalts_done = hashcat_status.getSalts_done();
		int generatedSalts_cnt = hashcat_status.getSalts_cnt();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("RECSALT\t%d\t%d\t", generatedSalts_done, generatedSalts_cnt);
		if (hwmon_ctx.getEnabled() == 1) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("TEMP\t");
			for (int device_id = 0;
			 device_id < generatedDevice_info_cnt; device_id++) {
				device_info_t device_info = generatedDevice_info_buf + device_id;
				if (device_info.getSkipped_dev() == 1) {
					continue;
				} 
				if (device_info.getSkipped_warning_dev() == 1) {
					continue;
				} 
				int temp = hashcat_ctx.hm_get_temperature_with_devices_idx(device_id);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("%d\t", temp);
			}
		} 
		Object generatedProgress_rejected = hashcat_status.getProgress_rejected();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("REJECTED\t%I64u\t", generatedProgress_rejected);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("UTIL\t");
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			int util = hashcat_ctx.hm_get_utilization_with_devices_idx(device_id);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("%d\t", util);
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1, (_iob[1]));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fflush((_iob[1]));
		ModernizedCProgram.status_status_destroy(hashcat_ctx, hashcat_status);
		ModernizedCProgram.hcfree(hashcat_status);
	}
	public void status_display_status_json() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		hashcat_status_t hashcat_status = (hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, hashcat_status) == -1) {
			ModernizedCProgram.hcfree(hashcat_status);
			return /*Error: Unsupported expression*/;
		} 
		time_t time_now = new time_t();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/time(time_now);
		time_t end = new time_t();
		time_t sec_etc = ModernizedCProgram.status_get_sec_etc(hashcat_ctx);
		if (ModernizedCProgram.overflow_check_u64_add(time_now, sec_etc) == 0) {
			end = 1;
		} else {
				end = time_now + sec_etc;
		} 
		Byte generatedSession = hashcat_status.getSession();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("{ \"session\": \"%s\",", generatedSession);
		int generatedStatus_number = hashcat_status.getStatus_number();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"status\": %d,", generatedStatus_number);
		Byte generatedHash_target = hashcat_status.getHash_target();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"target\": \"%s\",", generatedHash_target);
		Object generatedProgress_cur_relative_skip = hashcat_status.getProgress_cur_relative_skip();
		Object generatedProgress_end_relative_skip = hashcat_status.getProgress_end_relative_skip();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"progress\": [%I64u, %I64u],", generatedProgress_cur_relative_skip, generatedProgress_end_relative_skip);
		Object generatedRestore_point = hashcat_status.getRestore_point();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"restore_point\": %I64u,", generatedRestore_point);
		int generatedDigests_done = hashcat_status.getDigests_done();
		int generatedDigests_cnt = hashcat_status.getDigests_cnt();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"recovered_hashes\": [%d, %d],", generatedDigests_done, generatedDigests_cnt);
		int generatedSalts_done = hashcat_status.getSalts_done();
		int generatedSalts_cnt = hashcat_status.getSalts_cnt();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"recovered_salts\": [%d, %d],", generatedSalts_done, generatedSalts_cnt);
		Object generatedProgress_rejected = hashcat_status.getProgress_rejected();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"rejected\": %I64u,", generatedProgress_rejected);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"devices\": [");
		int device_num = 0;
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object[] generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			if (device_num != 0) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(",");
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" { \"device_id\": %d,", device_id + 1);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"speed\": %I64u,", (u64)(device_info.getHashes_msec_dev() * 1000));
			if (hwmon_ctx.getEnabled() == 1) {
				int temp = hashcat_ctx.hm_get_temperature_with_devices_idx(device_id);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"temp\": %d,", temp);
			} 
			int util = hashcat_ctx.hm_get_utilization_with_devices_idx(device_id);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"util\": %d }", util);
			device_num++;
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" ],");
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"time_start\": %I64u,", (u64)status_ctx.getRuntime_start());
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"estimated_stop\": %I64u }", (u64)end);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1, (_iob[1]));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fflush((_iob[1]));
		ModernizedCProgram.status_status_destroy(hashcat_ctx, hashcat_status);
		ModernizedCProgram.hcfree(hashcat_status);
	}
	public void status_display() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getMachine_readable() == 1) {
			hashcat_ctx.status_display_machine_readable();
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getStatus_json() == 1) {
			hashcat_ctx.status_display_status_json();
			return /*Error: Unsupported expression*/;
		} 
		hashcat_status_t hashcat_status = (hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, hashcat_status) == -1) {
			ModernizedCProgram.hcfree(hashcat_status);
			return /*Error: Unsupported expression*/;
		} 
		Byte generatedSession = hashcat_status.getSession();
		hashcat_ctx.event_log_info("Session..........: %s", generatedSession);
		Object generatedStatus_string = hashcat_status.getStatus_string();
		hashcat_ctx.event_log_info("Status...........: %s", generatedStatus_string);
		Byte generatedHash_name = hashcat_status.getHash_name();
		hashcat_ctx.event_log_info("Hash.Name........: %s", generatedHash_name);
		Byte generatedHash_target = hashcat_status.getHash_target();
		hashcat_ctx.event_log_info("Hash.Target......: %s", generatedHash_target);
		Byte generatedTime_started_absolute = hashcat_status.getTime_started_absolute();
		Byte generatedTime_started_relative = hashcat_status.getTime_started_relative();
		hashcat_ctx.event_log_info("Time.Started.....: %s (%s)", generatedTime_started_absolute, generatedTime_started_relative);
		Byte generatedTime_estimated_absolute = hashcat_status.getTime_estimated_absolute();
		Byte generatedTime_estimated_relative = hashcat_status.getTime_estimated_relative();
		hashcat_ctx.event_log_info("Time.Estimated...: %s (%s)", generatedTime_estimated_absolute, generatedTime_estimated_relative);
		Byte generatedGuess_base = hashcat_status.getGuess_base();
		Byte generatedGuess_mod = hashcat_status.getGuess_mod();
		int generatedGuess_mask_length = hashcat_status.getGuess_mask_length();
		Byte generatedGuess_charset = hashcat_status.getGuess_charset();
		int generatedGuess_mode = hashcat_status.getGuess_mode();
		switch (generatedGuess_mode) {
		case guess_mode.GUESS_MODE_STRAIGHT_STDIN_RULES_FILE:
				hashcat_ctx.event_log_info("Guess.Base.......: Pipe");
				hashcat_ctx.event_log_info("Guess.Mod........: Rules (%s)", generatedGuess_mod);
				break;
		case guess_mode.GUESS_MODE_COMBINATOR_BASE_RIGHT:
				hashcat_ctx.event_log_info("Guess.Base.......: File (%s), Right Side", generatedGuess_base);
				hashcat_ctx.event_log_info("Guess.Mod........: File (%s), Left Side", generatedGuess_mod);
				break;
		case guess_mode.GUESS_MODE_MASK_CS:
				hashcat_ctx.event_log_info("Guess.Mask.......: %s [%d]", generatedGuess_base, generatedGuess_mask_length);
				hashcat_ctx.event_log_info("Guess.Charset....: %s ", generatedGuess_charset);
				break;
		case guess_mode.GUESS_MODE_HYBRID1:
				hashcat_ctx.event_log_info("Guess.Base.......: File (%s), Left Side", generatedGuess_base);
				hashcat_ctx.event_log_info("Guess.Mod........: Mask (%s) [%d], Right Side", generatedGuess_mod, generatedGuess_mask_length);
				break;
		case guess_mode.GUESS_MODE_STRAIGHT_STDIN:
				hashcat_ctx.event_log_info("Guess.Base.......: Pipe");
				break;
		case guess_mode.GUESS_MODE_STRAIGHT_FILE_RULES_GEN:
				hashcat_ctx.event_log_info("Guess.Base.......: File (%s)", generatedGuess_base);
				hashcat_ctx.event_log_info("Guess.Mod........: Rules (Generated)");
				break;
		case guess_mode.GUESS_MODE_MASK:
				hashcat_ctx.event_log_info("Guess.Mask.......: %s [%d]", generatedGuess_base, generatedGuess_mask_length);
				break;
		case guess_mode.GUESS_MODE_STRAIGHT_STDIN_RULES_GEN:
				hashcat_ctx.event_log_info("Guess.Base.......: Pipe");
				hashcat_ctx.event_log_info("Guess.Mod........: Rules (Generated)");
				break;
		case guess_mode.GUESS_MODE_STRAIGHT_FILE_RULES_FILE:
				hashcat_ctx.event_log_info("Guess.Base.......: File (%s)", generatedGuess_base);
				hashcat_ctx.event_log_info("Guess.Mod........: Rules (%s)", generatedGuess_mod);
				break;
		case guess_mode.GUESS_MODE_COMBINATOR_BASE_LEFT:
				hashcat_ctx.event_log_info("Guess.Base.......: File (%s), Left Side", generatedGuess_base);
				hashcat_ctx.event_log_info("Guess.Mod........: File (%s), Right Side", generatedGuess_mod);
				break;
		case guess_mode.GUESS_MODE_HYBRID2:
				if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
					hashcat_ctx.event_log_info("Guess.Base.......: Mask (%s) [%d], Left Side", generatedGuess_base, generatedGuess_mask_length);
					hashcat_ctx.event_log_info("Guess.Mod........: File (%s), Right Side", generatedGuess_mod);
				} else {
						hashcat_ctx.event_log_info("Guess.Base.......: File (%s), Right Side", generatedGuess_base);
						hashcat_ctx.event_log_info("Guess.Mod........: Mask (%s) [%d], Left Side", generatedGuess_mod, generatedGuess_mask_length);
				} 
				break;
		case guess_mode.GUESS_MODE_HYBRID2_CS:
				if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
					hashcat_ctx.event_log_info("Guess.Base.......: Mask (%s) [%d], Left Side", generatedGuess_base, generatedGuess_mask_length);
					hashcat_ctx.event_log_info("Guess.Mod........: File (%s), Right Side", generatedGuess_mod);
					hashcat_ctx.event_log_info("Guess.Charset....: %s", generatedGuess_charset);
				} else {
						hashcat_ctx.event_log_info("Guess.Base.......: File (%s), Right Side", generatedGuess_base);
						hashcat_ctx.event_log_info("Guess.Mod........: Mask (%s) [%d], Left Side", generatedGuess_mod, generatedGuess_mask_length);
						hashcat_ctx.event_log_info("Guess.Charset....: %s", generatedGuess_charset);
				} 
				break;
		case guess_mode.GUESS_MODE_STRAIGHT_FILE:
				hashcat_ctx.event_log_info("Guess.Base.......: File (%s)", generatedGuess_base);
				break;
		case guess_mode.GUESS_MODE_HYBRID1_CS:
				hashcat_ctx.event_log_info("Guess.Base.......: File (%s), Left Side", generatedGuess_base);
				hashcat_ctx.event_log_info("Guess.Mod........: Mask (%s) [%d], Right Side", generatedGuess_mod, generatedGuess_mask_length);
				hashcat_ctx.event_log_info("Guess.Charset....: %s", generatedGuess_charset);
				break;
		}
		int generatedGuess_base_offset = hashcat_status.getGuess_base_offset();
		int generatedGuess_base_count = hashcat_status.getGuess_base_count();
		double generatedGuess_base_percent = hashcat_status.getGuess_base_percent();
		int generatedGuess_mod_offset = hashcat_status.getGuess_mod_offset();
		int generatedGuess_mod_count = hashcat_status.getGuess_mod_count();
		double generatedGuess_mod_percent = hashcat_status.getGuess_mod_percent();
		switch (generatedGuess_mode) {
		case guess_mode.GUESS_MODE_HYBRID2:
				hashcat_ctx.event_log_info("Guess.Queue.Base.: %d/%d (%.02f%%)", generatedGuess_base_offset, generatedGuess_base_count, generatedGuess_base_percent);
				hashcat_ctx.event_log_info("Guess.Queue.Mod..: %d/%d (%.02f%%)", generatedGuess_mod_offset, generatedGuess_mod_count, generatedGuess_mod_percent);
				break;
		case guess_mode.GUESS_MODE_STRAIGHT_FILE:
				hashcat_ctx.event_log_info("Guess.Queue......: %d/%d (%.02f%%)", generatedGuess_base_offset, generatedGuess_base_count, generatedGuess_base_percent);
				break;
		case guess_mode.GUESS_MODE_STRAIGHT_FILE_RULES_GEN:
				hashcat_ctx.event_log_info("Guess.Queue......: %d/%d (%.02f%%)", generatedGuess_base_offset, generatedGuess_base_count, generatedGuess_base_percent);
				break;
		case guess_mode.GUESS_MODE_STRAIGHT_FILE_RULES_FILE:
				hashcat_ctx.event_log_info("Guess.Queue......: %d/%d (%.02f%%)", generatedGuess_base_offset, generatedGuess_base_count, generatedGuess_base_percent);
				break;
		case guess_mode.GUESS_MODE_MASK:
				hashcat_ctx.event_log_info("Guess.Queue......: %d/%d (%.02f%%)", generatedGuess_base_offset, generatedGuess_base_count, generatedGuess_base_percent);
				break;
		case guess_mode.GUESS_MODE_MASK_CS:
				hashcat_ctx.event_log_info("Guess.Queue......: %d/%d (%.02f%%)", generatedGuess_base_offset, generatedGuess_base_count, generatedGuess_base_percent);
				break;
		case guess_mode.GUESS_MODE_HYBRID1:
				hashcat_ctx.event_log_info("Guess.Queue.Base.: %d/%d (%.02f%%)", generatedGuess_base_offset, generatedGuess_base_count, generatedGuess_base_percent);
				hashcat_ctx.event_log_info("Guess.Queue.Mod..: %d/%d (%.02f%%)", generatedGuess_mod_offset, generatedGuess_mod_count, generatedGuess_mod_percent);
				break;
		}
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object[] generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			hashcat_ctx.event_log_info("Speed.#%d.........: %9sH/s (%0.2fms) @ Accel:%d Loops:%d Thr:%d Vec:%d", device_id + 1, device_info.getSpeed_sec_dev(), device_info.getExec_msec_dev(), device_info.getKernel_accel_dev(), device_info.getKernel_loops_dev(), device_info.getKernel_threads_dev(), device_info.getVector_width_dev());
		}
		int generatedDevice_info_active = hashcat_status.getDevice_info_active();
		Byte generatedSpeed_sec_all = hashcat_status.getSpeed_sec_all();
		if (generatedDevice_info_active > 1) {
			hashcat_ctx.event_log_info("Speed.#*.........: %9sH/s", generatedSpeed_sec_all);
		} 
		int generatedSalts_cnt = hashcat_status.getSalts_cnt();
		int generatedDigests_done = hashcat_status.getDigests_done();
		int generatedDigests_cnt = hashcat_status.getDigests_cnt();
		double generatedDigests_percent = hashcat_status.getDigests_percent();
		int generatedSalts_done = hashcat_status.getSalts_done();
		double generatedSalts_percent = hashcat_status.getSalts_percent();
		if (generatedSalts_cnt > 1) {
			hashcat_ctx.event_log_info("Recovered........: %d/%d (%.2f%%) Digests, %d/%d (%.2f%%) Salts", generatedDigests_done, generatedDigests_cnt, generatedDigests_percent, generatedSalts_done, generatedSalts_cnt, generatedSalts_percent);
		} else {
				hashcat_ctx.event_log_info("Recovered........: %d/%d (%.2f%%) Digests", generatedDigests_done, generatedDigests_cnt, generatedDigests_percent);
		} 
		if (generatedDigests_cnt > 1000) {
			int digests_remain = generatedDigests_cnt - generatedDigests_done;
			double digests_remain_percent = (double)digests_remain / (double)generatedDigests_cnt * 100;
			int salts_remain = generatedSalts_cnt - generatedSalts_done;
			double salts_remain_percent = (double)salts_remain / (double)generatedSalts_cnt * 100;
			if (generatedSalts_cnt > 1) {
				hashcat_ctx.event_log_info("Remaining........: %d (%.2f%%) Digests, %d (%.2f%%) Salts", digests_remain, digests_remain_percent, salts_remain, salts_remain_percent);
			} else {
					hashcat_ctx.event_log_info("Remaining........: %d (%.2f%%) Digests", digests_remain, digests_remain_percent);
			} 
		} 
		Byte generatedCpt = hashcat_status.getCpt();
		if (generatedDigests_cnt > 1000) {
			hashcat_ctx.event_log_info("Recovered/Time...: %s", generatedCpt);
		} 
		Object generatedProgress_cur_relative_skip = hashcat_status.getProgress_cur_relative_skip();
		Object generatedProgress_end_relative_skip = hashcat_status.getProgress_end_relative_skip();
		double generatedProgress_finished_percent = hashcat_status.getProgress_finished_percent();
		Object generatedProgress_rejected = hashcat_status.getProgress_rejected();
		double generatedProgress_rejected_percent = hashcat_status.getProgress_rejected_percent();
		int generatedProgress_mode = hashcat_status.getProgress_mode();
		switch (generatedProgress_mode) {
		case progress_mode.PROGRESS_MODE_KEYSPACE_KNOWN:
				hashcat_ctx.event_log_info("Progress.........: %I64u/%I64u (%.02f%%)", generatedProgress_cur_relative_skip, generatedProgress_end_relative_skip, generatedProgress_finished_percent);
				hashcat_ctx.event_log_info("Rejected.........: %I64u/%I64u (%.02f%%)", generatedProgress_rejected, generatedProgress_cur_relative_skip, generatedProgress_rejected_percent);
				break;
		case progress_mode.PROGRESS_MODE_KEYSPACE_UNKNOWN:
				hashcat_ctx.event_log_info("Progress.........: %I64u", generatedProgress_cur_relative_skip);
				hashcat_ctx.event_log_info("Rejected.........: %I64u", generatedProgress_rejected);
				break;
		}
		Object generatedRestore_point = hashcat_status.getRestore_point();
		Object generatedRestore_total = hashcat_status.getRestore_total();
		double generatedRestore_percent = hashcat_status.getRestore_percent();
		switch (generatedProgress_mode) {
		case progress_mode.PROGRESS_MODE_KEYSPACE_UNKNOWN:
				hashcat_ctx.event_log_info("Restore.Point....: %I64u", generatedRestore_point);
				break;
		case progress_mode.PROGRESS_MODE_KEYSPACE_KNOWN:
				hashcat_ctx.event_log_info("Restore.Point....: %I64u/%I64u (%.02f%%)", generatedRestore_point, generatedRestore_total, generatedRestore_percent);
				break;
		}
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			hashcat_ctx.event_log_info("Restore.Sub.#%d...: Salt:%d Amplifier:%d-%d Iteration:%d-%d", device_id + 1, device_info.getSalt_pos_dev(), device_info.getInnerloop_pos_dev(), device_info.getInnerloop_pos_dev() + device_info.getInnerloop_left_dev(), device_info.getIteration_pos_dev(), device_info.getIteration_pos_dev() + device_info.getIteration_left_dev());
		}
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			if (device_info.getGuess_candidates_dev() == (null)) {
				continue;
			} 
			hashcat_ctx.event_log_info("Candidates.#%d....: %s", device_id + 1, device_info.getGuess_candidates_dev());
		}
		if (hwmon_ctx.getEnabled() == 1) {
			for (int device_id = 0;
			 device_id < generatedDevice_info_cnt; device_id++) {
				device_info_t device_info = generatedDevice_info_buf + device_id;
				if (device_info.getSkipped_dev() == 1) {
					continue;
				} 
				if (device_info.getSkipped_warning_dev() == 1) {
					continue;
				} 
				if (device_info.getHwmon_dev() == (null)) {
					continue;
				} 
				hashcat_ctx.event_log_info("Hardware.Mon.#%d..: %s", device_id + 1, device_info.getHwmon_dev());
			}
		} 
		ModernizedCProgram.status_status_destroy(hashcat_ctx, hashcat_status);
		ModernizedCProgram.hcfree(hashcat_status);
	}
	public void status_benchmark_machine_readable() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		int generatedHash_mode = hashconfig.getHash_mode();
		u32 hash_mode = generatedHash_mode;
		hashcat_status_t hashcat_status = (hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, hashcat_status) == -1) {
			ModernizedCProgram.hcfree(hashcat_status);
			return /*Error: Unsupported expression*/;
		} 
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object[] generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			hashcat_ctx.event_log_info("%d:%u:%d:%d:%.2f:%I64u", device_id + 1, hash_mode, device_info.getCorespeed_dev(), device_info.getMemoryspeed_dev(), device_info.getExec_msec_dev(), (u64)(device_info.getHashes_msec_dev_benchmark() * 1000));
		}
		ModernizedCProgram.status_status_destroy(hashcat_ctx, hashcat_status);
		ModernizedCProgram.hcfree(hashcat_status);
	}
	public void status_benchmark() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getMachine_readable() == 1) {
			hashcat_ctx.status_benchmark_machine_readable();
			return /*Error: Unsupported expression*/;
		} 
		hashcat_status_t hashcat_status = (hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, hashcat_status) == -1) {
			ModernizedCProgram.hcfree(hashcat_status);
			return /*Error: Unsupported expression*/;
		} 
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object[] generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			hashcat_ctx.event_log_info("Speed.#%d.........: %9sH/s (%0.2fms) @ Accel:%d Loops:%d Thr:%d Vec:%d", device_id + 1, device_info.getSpeed_sec_dev(), device_info.getExec_msec_dev(), device_info.getKernel_accel_dev(), device_info.getKernel_loops_dev(), device_info.getKernel_threads_dev(), device_info.getVector_width_dev());
		}
		int generatedDevice_info_active = hashcat_status.getDevice_info_active();
		Byte generatedSpeed_sec_all = hashcat_status.getSpeed_sec_all();
		if (generatedDevice_info_active > 1) {
			hashcat_ctx.event_log_info("Speed.#*.........: %9sH/s", generatedSpeed_sec_all);
		} 
		ModernizedCProgram.status_status_destroy(hashcat_ctx, hashcat_status);
		ModernizedCProgram.hcfree(hashcat_status);
	}
	public void status_speed_machine_readable() {
		hashcat_status_t hashcat_status = (hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, hashcat_status) == -1) {
			ModernizedCProgram.hcfree(hashcat_status);
			return /*Error: Unsupported expression*/;
		} 
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object[] generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			hashcat_ctx.event_log_info("%d:%I64u", device_id + 1, (u64)(device_info.getHashes_msec_dev_benchmark() * 1000));
		}
		ModernizedCProgram.status_status_destroy(hashcat_ctx, hashcat_status);
		ModernizedCProgram.hcfree(hashcat_status);
	}
	public void status_speed_json() {
		hashcat_status_t hashcat_status = (hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, hashcat_status) == -1) {
			ModernizedCProgram.hcfree(hashcat_status);
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("{ \"devices\": [");
		int device_num = 0;
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object[] generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			if (device_num != 0) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(",");
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" { \"device_id\": %d,", device_id + 1);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"speed\": %I64u }", (u64)(device_info.getHashes_msec_dev_benchmark() * 1000));
			device_num++;
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" ] }");
		ModernizedCProgram.status_status_destroy(hashcat_ctx, hashcat_status);
		ModernizedCProgram.hcfree(hashcat_status);
	}
	public void status_speed() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getMachine_readable() == 1) {
			hashcat_ctx.status_speed_machine_readable();
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getStatus_json() == 1) {
			hashcat_ctx.status_speed_json();
			return /*Error: Unsupported expression*/;
		} 
		hashcat_status_t hashcat_status = (hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, hashcat_status) == -1) {
			ModernizedCProgram.hcfree(hashcat_status);
			return /*Error: Unsupported expression*/;
		} 
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object[] generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			hashcat_ctx.event_log_info("Speed.#%d.........: %9sH/s (%0.2fms)", device_id + 1, device_info.getSpeed_sec_dev(), device_info.getExec_msec_dev());
		}
		int generatedDevice_info_active = hashcat_status.getDevice_info_active();
		Byte generatedSpeed_sec_all = hashcat_status.getSpeed_sec_all();
		if (generatedDevice_info_active > 1) {
			hashcat_ctx.event_log_info("Speed.#*.........: %9sH/s", generatedSpeed_sec_all);
		} 
		ModernizedCProgram.status_status_destroy(hashcat_ctx, hashcat_status);
		ModernizedCProgram.hcfree(hashcat_status);
	}
	public void status_progress_machine_readable() {
		hashcat_status_t hashcat_status = (hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, hashcat_status) == -1) {
			ModernizedCProgram.hcfree(hashcat_status);
			return /*Error: Unsupported expression*/;
		} 
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object[] generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			hashcat_ctx.event_log_info("%d:%I64u:%0.2f", device_id + 1, device_info.getProgress_dev(), device_info.getRuntime_msec_dev());
		}
		ModernizedCProgram.status_status_destroy(hashcat_ctx, hashcat_status);
		ModernizedCProgram.hcfree(hashcat_status);
	}
	public void status_progress_json() {
		hashcat_status_t hashcat_status = (hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, hashcat_status) == -1) {
			ModernizedCProgram.hcfree(hashcat_status);
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("{ \"devices\": [");
		int device_num = 0;
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object[] generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			if (device_num != 0) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(",");
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" { \"device_id\": %d,", device_id + 1);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"progress\": %I64u,", device_info.getProgress_dev());
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" \"runtime\": %0.2f }", device_info.getRuntime_msec_dev());
			device_num++;
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf(" ] }");
		ModernizedCProgram.status_status_destroy(hashcat_ctx, hashcat_status);
		ModernizedCProgram.hcfree(hashcat_status);
	}
	public void status_progress() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getMachine_readable() == 1) {
			hashcat_ctx.status_progress_machine_readable();
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getStatus_json() == 1) {
			hashcat_ctx.status_progress_json();
			return /*Error: Unsupported expression*/;
		} 
		hashcat_status_t hashcat_status = (hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, hashcat_status) == -1) {
			ModernizedCProgram.hcfree(hashcat_status);
			return /*Error: Unsupported expression*/;
		} 
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object[] generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			hashcat_ctx.event_log_info("Progress.#%d......: %I64u", device_id + 1, device_info.getProgress_dev());
		}
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			if (device_info.getSkipped_dev() == 1) {
				continue;
			} 
			if (device_info.getSkipped_warning_dev() == 1) {
				continue;
			} 
			hashcat_ctx.event_log_info("Runtime.#%d.......: %0.2fms", device_id + 1, device_info.getRuntime_msec_dev());
		}
		ModernizedCProgram.status_status_destroy(hashcat_ctx, hashcat_status);
		ModernizedCProgram.hcfree(hashcat_status);
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public int combinator_ctx_init() {
		combinator_ctx generatedCombinator_ctx = this.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		combinator_ctx.setEnabled(0);
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		Object generatedAttack_mode = user_options.getAttack_mode();
		if ((generatedAttack_mode != attack_mode.ATTACK_MODE_COMBI) && (generatedAttack_mode != attack_mode.ATTACK_MODE_HYBRID1) && (generatedAttack_mode != attack_mode.ATTACK_MODE_HYBRID2)) {
			return 0;
		} 
		combinator_ctx.setEnabled(1);
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		byte[][] generatedHc_workv = user_options_extra.getHc_workv();
		Object generatedOpti_type = hashconfig.getOpti_type();
		Object generatedRule_buf_l = user_options.getRule_buf_l();
		Object generatedRule_buf_r = user_options.getRule_buf_r();
		Object generatedRule_len_l = user_options_extra.getRule_len_l();
		Object generatedRule_len_r = user_options_extra.getRule_len_r();
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		if (generatedSlow_candidates == true) {
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
				Byte dictfile1 = generatedHc_workv[0];
				Byte dictfile2 = generatedHc_workv[1];
				if (ModernizedCProgram.hc_path_is_file(dictfile1) == 0) {
					hashcat_ctx.event_log_error("%s: Not a regular file.", dictfile1);
					return -1;
				} 
				if (ModernizedCProgram.hc_path_is_file(dictfile2) == 0) {
					hashcat_ctx.event_log_error("%s: Not a regular file.", dictfile2);
					return -1;
				} 
				HCFILE fp1 = new HCFILE();
				HCFILE fp2 = new HCFILE();
				if (fp1.hc_fopen(dictfile1, "rb") == 0) {
					hashcat_ctx.event_log_error("%s: %s", dictfile1, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				if (fp2.hc_fopen(dictfile2, "rb") == 0) {
					hashcat_ctx.event_log_error("%s: %s", dictfile2, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					fp1.hc_fclose();
					return -1;
				} 
				combinator_ctx.setCombs_cnt(1);
				u64 words1_cnt = 0;
				int rc1 = ModernizedCProgram.count_words(hashcat_ctx, fp1, dictfile1, words1_cnt);
				if (rc1 == -1) {
					hashcat_ctx.event_log_error("Integer overflow detected in keyspace of wordlist: %s", dictfile1);
					fp1.hc_fclose();
					fp2.hc_fclose();
					return -1;
				} 
				if (words1_cnt == 0) {
					hashcat_ctx.event_log_error("%s: empty file.", dictfile1);
					fp1.hc_fclose();
					fp2.hc_fclose();
					return -1;
				} 
				combinator_ctx.setCombs_cnt(1);
				u64 words2_cnt = 0;
				int rc2 = ModernizedCProgram.count_words(hashcat_ctx, fp2, dictfile2, words2_cnt);
				fp1.hc_fclose();
				fp2.hc_fclose();
				if (rc2 == -1) {
					hashcat_ctx.event_log_error("Integer overflow detected in keyspace of wordlist: %s", dictfile2);
					return -1;
				} 
				if (words2_cnt == 0) {
					hashcat_ctx.event_log_error("%s: empty file.", dictfile2);
					return -1;
				} 
				combinator_ctx.setDict1(dictfile1);
				combinator_ctx.setDict2(dictfile2);
				combinator_ctx.setCombs_mode(combinator_mode.COMBINATOR_MODE_BASE_LEFT);
				combinator_ctx.setCombs_cnt(words2_cnt);
			} 
		} else {
				if (generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
					if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
						Byte dictfile1 = generatedHc_workv[0];
						Byte dictfile2 = generatedHc_workv[1];
						if (ModernizedCProgram.hc_path_is_file(dictfile1) == 0) {
							hashcat_ctx.event_log_error("%s: Not a regular file.", dictfile1);
							return -1;
						} 
						if (ModernizedCProgram.hc_path_is_file(dictfile2) == 0) {
							hashcat_ctx.event_log_error("%s: Not a regular file.", dictfile2);
							return -1;
						} 
						HCFILE fp1 = new HCFILE();
						HCFILE fp2 = new HCFILE();
						if (fp1.hc_fopen(dictfile1, "rb") == 0) {
							hashcat_ctx.event_log_error("%s: %s", dictfile1, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
							return -1;
						} 
						if (fp2.hc_fopen(dictfile2, "rb") == 0) {
							hashcat_ctx.event_log_error("%s: %s", dictfile2, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
							fp1.hc_fclose();
							return -1;
						} 
						combinator_ctx.setCombs_cnt(1);
						u64 words1_cnt = 0;
						int rc1 = ModernizedCProgram.count_words(hashcat_ctx, fp1, dictfile1, words1_cnt);
						if (rc1 == -1) {
							hashcat_ctx.event_log_error("Integer overflow detected in keyspace of wordlist: %s", dictfile1);
							fp1.hc_fclose();
							fp2.hc_fclose();
							return -1;
						} 
						if (words1_cnt == 0) {
							hashcat_ctx.event_log_error("%s: empty file.", dictfile1);
							fp1.hc_fclose();
							fp2.hc_fclose();
							return -1;
						} 
						combinator_ctx.setCombs_cnt(1);
						u64 words2_cnt = 0;
						int rc2 = ModernizedCProgram.count_words(hashcat_ctx, fp2, dictfile2, words2_cnt);
						fp1.hc_fclose();
						fp2.hc_fclose();
						if (rc2 == -1) {
							hashcat_ctx.event_log_error("Integer overflow detected in keyspace of wordlist: %s", dictfile2);
							return -1;
						} 
						if (words2_cnt == 0) {
							hashcat_ctx.event_log_error("%s: empty file.", dictfile2);
							return -1;
						} 
						combinator_ctx.setDict1(dictfile1);
						combinator_ctx.setDict2(dictfile2);
						if (words1_cnt >= words2_cnt) {
							combinator_ctx.setCombs_mode(combinator_mode.COMBINATOR_MODE_BASE_LEFT);
							combinator_ctx.setCombs_cnt(words2_cnt);
						} else {
								combinator_ctx.setCombs_mode(combinator_mode.COMBINATOR_MODE_BASE_RIGHT);
								combinator_ctx.setCombs_cnt(words1_cnt);
								Byte tmpc = generatedRule_buf_l;
								user_options.setRule_buf_l(generatedRule_buf_r);
								user_options.setRule_buf_r(tmpc);
								u32 tmpi = generatedRule_len_l;
								user_options_extra.setRule_len_l(generatedRule_len_r);
								user_options_extra.setRule_len_r(tmpi);
						} 
					}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
						combinator_ctx.setCombs_mode(combinator_mode.COMBINATOR_MODE_BASE_LEFT);
					}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
						combinator_ctx.setCombs_mode(combinator_mode.COMBINATOR_MODE_BASE_RIGHT);
					} 
				} else {
						if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
							Byte dictfile1 = generatedHc_workv[0];
							Byte dictfile2 = generatedHc_workv[1];
							if (ModernizedCProgram.hc_path_is_file(dictfile1) == 0) {
								hashcat_ctx.event_log_error("%s: Not a regular file.", dictfile1);
								return -1;
							} 
							if (ModernizedCProgram.hc_path_is_file(dictfile2) == 0) {
								hashcat_ctx.event_log_error("%s: Not a regular file.", dictfile2);
								return -1;
							} 
							HCFILE fp1 = new HCFILE();
							HCFILE fp2 = new HCFILE();
							if (fp1.hc_fopen(dictfile1, "rb") == 0) {
								hashcat_ctx.event_log_error("%s: %s", dictfile1, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
								return -1;
							} 
							if (fp2.hc_fopen(dictfile2, "rb") == 0) {
								hashcat_ctx.event_log_error("%s: %s", dictfile2, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
								fp1.hc_fclose();
								return -1;
							} 
							combinator_ctx.setCombs_cnt(1);
							u64 words1_cnt = 0;
							int rc1 = ModernizedCProgram.count_words(hashcat_ctx, fp1, dictfile1, words1_cnt);
							if (rc1 == -1) {
								hashcat_ctx.event_log_error("Integer overflow detected in keyspace of wordlist: %s", dictfile1);
								fp1.hc_fclose();
								fp2.hc_fclose();
								return -1;
							} 
							if (words1_cnt == 0) {
								hashcat_ctx.event_log_error("%s: empty file.", dictfile1);
								fp1.hc_fclose();
								fp2.hc_fclose();
								return -1;
							} 
							combinator_ctx.setCombs_cnt(1);
							u64 words2_cnt = 0;
							int rc2 = ModernizedCProgram.count_words(hashcat_ctx, fp2, dictfile2, words2_cnt);
							fp1.hc_fclose();
							fp2.hc_fclose();
							if (rc2 == -1) {
								hashcat_ctx.event_log_error("Integer overflow detected in keyspace of wordlist: %s", dictfile2);
								return -1;
							} 
							if (words2_cnt == 0) {
								hashcat_ctx.event_log_error("%s: empty file.", dictfile2);
								return -1;
							} 
							combinator_ctx.setDict1(dictfile1);
							combinator_ctx.setDict2(dictfile2);
							combinator_ctx.setCombs_mode(combinator_mode.COMBINATOR_MODE_BASE_LEFT);
							combinator_ctx.setCombs_cnt(words2_cnt);
						}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
							combinator_ctx.setCombs_mode(combinator_mode.COMBINATOR_MODE_BASE_LEFT);
						}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
							mask_ctx_t mask_ctx = generatedMask_ctx;
							Byte dictfile = generatedHc_workv[1];
							if (ModernizedCProgram.hc_path_is_file(dictfile) == 0) {
								hashcat_ctx.event_log_error("%s: Not a regular file.", dictfile);
								return -1;
							} 
							HCFILE fp = new HCFILE();
							if (fp.hc_fopen(dictfile, "rb") == 0) {
								hashcat_ctx.event_log_error("%s: %s", dictfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
								return -1;
							} 
							mask_ctx.setBfs_cnt(1);
							u64 words_cnt = 0;
							int rc = ModernizedCProgram.count_words(hashcat_ctx, fp, dictfile, words_cnt);
							fp.hc_fclose();
							if (rc == -1) {
								hashcat_ctx.event_log_error("Integer overflow detected in keyspace of wordlist: %s", dictfile);
								return -1;
							} 
							combinator_ctx.setCombs_cnt(words_cnt);
							combinator_ctx.setCombs_mode(combinator_mode.COMBINATOR_MODE_BASE_LEFT);
						} 
				} 
		} 
		// this is always need to be COMBINATOR_MODE_BASE_LEFT
		return 0;
	}
	public void combinator_ctx_destroy() {
		combinator_ctx generatedCombinator_ctx = this.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		boolean generatedEnabled = combinator_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(combinator_ctx, 0, /*Error: Unsupported expression*/);
	}
	public int potfile_init() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		potfile_ctx_t potfile_ctx = generatedPotfile_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		potfile_ctx.setEnabled(0);
		if (user_options.getBenchmark() == 1) {
			return 0;
		} 
		if (user_options.getExample_hashes() == 1) {
			return 0;
		} 
		if (user_options.getKeyspace() == 1) {
			return 0;
		} 
		if (user_options.getBackend_info() == 1) {
			return 0;
		} 
		if (user_options.getStdout_flag() == 1) {
			return 0;
		} 
		if (user_options.getSpeed_only() == 1) {
			return 0;
		} 
		if (user_options.getProgress_only() == 1) {
			return 0;
		} 
		if (user_options.getUsage() == 1) {
			return 0;
		} 
		if (user_options.getVersion() == 1) {
			return 0;
		} 
		if (user_options.getPotfile_disable() == 1) {
			return 0;
		} 
		if (hashconfig.getPotfile_disable() == 1) {
			return 0;
		} 
		potfile_ctx.setEnabled(1);
		hc_fp generatedFp = potfile_ctx.getFp();
		Byte generatedFilename = potfile_ctx.getFilename();
		if (user_options.getPotfile_path() == (null)) {
			generatedFp.setPfp((null));
			ModernizedCProgram.hc_asprintf(generatedFilename, "%s/hashcat.potfile", folder_config.getProfile_dir());
		} else {
				potfile_ctx.setFilename(ModernizedCProgram.hcstrdup(user_options.getPotfile_path()));
				generatedFp.setPfp((null));
		} 
		// starting from here, we should allocate some scratch buffer for later useu8 out_buf = (u8)ModernizedCProgram.hcmalloc(-1024);
		potfile_ctx.setOut_buf(out_buf)// we need two buffers in parallel;// we need two buffers in parallel
		u8 tmp_buf = (u8)ModernizedCProgram.hcmalloc(-1024);
		potfile_ctx.setTmp_buf(tmp_buf)// old potfile detection;// old potfile detection
		if (user_options.getPotfile_path() == (null)) {
			Byte potfile_old;
			ModernizedCProgram.hc_asprintf(potfile_old, "%s/hashcat.pot", folder_config.getProfile_dir());
			if (ModernizedCProgram.hc_path_exist(potfile_old) == 1) {
				hashcat_ctx.event_log_warning("Old potfile detected: %s", potfile_old);
				hashcat_ctx.event_log_warning("New potfile is: %s ", generatedFilename);
				hashcat_ctx.event_log_warning((null));
			} 
			ModernizedCProgram.hcfree(potfile_old);
		} 
		return 0;
	}
	public void potfile_destroy() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		potfile_ctx_t potfile_ctx = generatedPotfile_ctx;
		boolean generatedEnabled = potfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		boolean generatedPotfile_disable = hashconfig.getPotfile_disable();
		if (generatedPotfile_disable == true) {
			return /*Error: Unsupported expression*/;
		} 
		Object generatedOut_buf = potfile_ctx.getOut_buf();
		ModernizedCProgram.hcfree(generatedOut_buf);
		Object generatedTmp_buf = potfile_ctx.getTmp_buf();
		ModernizedCProgram.hcfree(generatedTmp_buf);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(potfile_ctx, 0, /*Error: Unsupported expression*/);
	}
	public int potfile_read_open() {
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		potfile_ctx_t potfile_ctx = generatedPotfile_ctx;
		boolean generatedEnabled = potfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		hc_fp generatedFp = potfile_ctx.getFp();
		Byte generatedFilename = potfile_ctx.getFilename();
		if (generatedFp.hc_fopen(generatedFilename, "rb") == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		return 0;
	}
	public void potfile_read_close() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		potfile_ctx_t potfile_ctx = generatedPotfile_ctx;
		boolean generatedEnabled = potfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		boolean generatedPotfile_disable = hashconfig.getPotfile_disable();
		if (generatedPotfile_disable == true) {
			return /*Error: Unsupported expression*/;
		} 
		hc_fp generatedFp = potfile_ctx.getFp();
		_iobuf generatedPfp = generatedFp.getPfp();
		if (generatedPfp == (null)) {
			return /*Error: Unsupported expression*/;
		} 
		generatedFp.hc_fclose();
	}
	public int potfile_write_open() {
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		potfile_ctx_t potfile_ctx = generatedPotfile_ctx;
		boolean generatedEnabled = potfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		hc_fp generatedFp = potfile_ctx.getFp();
		Byte generatedFilename = potfile_ctx.getFilename();
		if (generatedFp.hc_fopen(generatedFilename, "ab") == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		return 0;
	}
	public void potfile_write_close() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		potfile_ctx_t potfile_ctx = generatedPotfile_ctx;
		boolean generatedEnabled = potfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		boolean generatedPotfile_disable = hashconfig.getPotfile_disable();
		if (generatedPotfile_disable == true) {
			return /*Error: Unsupported expression*/;
		} 
		hc_fp generatedFp = potfile_ctx.getFp();
		generatedFp.hc_fclose();
	}
	public void potfile_write_append(Object out_buf, Object out_len, Object plain_ptr, int plain_len) {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		potfile_ctx_t potfile_ctx = generatedPotfile_ctx;
		boolean generatedEnabled = potfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		if (hashconfig.getPotfile_disable() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		Object generatedTmp_buf = potfile_ctx.getTmp_buf();
		u8[] tmp_buf = generatedTmp_buf;
		int tmp_len = 0;
		if (1) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(tmp_buf + tmp_len, out_buf, out_len);
			tmp_len += out_len;
			tmp_buf[tmp_len] = hashconfig.getSeparator();
			tmp_len += 1;
		} 
		if ((hashconfig.getOpts_type() & opts_type.OPTS_TYPE_POTFILE_NOPASS) == 0) {
			boolean always_ascii = (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ALWAYS_ASCII) ? 1 : 0;
			if ((user_options.getOutfile_autohex() == 1) && (ModernizedCProgram.need_hexify(plain_ptr, plain_len, hashconfig.getSeparator(), always_ascii) == 1)) {
				tmp_buf[tmp_len++] = (byte)'$';
				tmp_buf[tmp_len++] = (byte)'H';
				tmp_buf[tmp_len++] = (byte)'E';
				tmp_buf[tmp_len++] = (byte)'X';
				tmp_buf[tmp_len++] = (byte)'[';
				ModernizedCProgram.exec_hexify((u8)plain_ptr, plain_len, tmp_buf + tmp_len);
				tmp_len += plain_len * 2;
				tmp_buf[tmp_len++] = (byte)']';
			} else {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(tmp_buf + tmp_len, plain_ptr, plain_len);
					tmp_len += plain_len;
			} 
		} 
		tmp_buf[tmp_len] = 0;
		hc_fp generatedFp = potfile_ctx.getFp();
		generatedFp.hc_lockfile();
		generatedFp.hc_fprintf("%s\r\n", tmp_buf);
		generatedFp.hc_fflush();
		Byte generatedFilename = potfile_ctx.getFilename();
		if (generatedFp.hc_unlockfile()) {
			hashcat_ctx.event_log_error("%s: Failed to unlock file.", generatedFilename);
		} 
	}
	public int potfile_remove_parse() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		module_ctx generatedModule_ctx = this.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		potfile_ctx_t potfile_ctx = generatedPotfile_ctx;
		boolean generatedEnabled = potfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		if (hashconfig.getPotfile_disable() == 1) {
			return 0;
		} 
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_NEVERCRACK) {
			return 0;
		} 
		// if no potfile exists yet we don't need to do anything here
		Byte generatedFilename = potfile_ctx.getFilename();
		if (ModernizedCProgram.hc_path_exist(generatedFilename) == 0) {
			return 0;
		} 
		hash_t[] hashes_buf = hashes.getHashes_buf();
		u32 hashes_cnt = hashes.getHashes_cnt();
		// no solution for these special hash types (for instane because they use hashfile in output etc)
		hash_t hash_buf = new hash_t();
		hash_buf.setDigest(ModernizedCProgram.hcmalloc(hashconfig.getDgst_size()));
		hash_buf.setSalt((null));
		hash_buf.setEsalt((null));
		hash_buf.setHook_salt((null));
		hash_buf.setCracked(0);
		hash_buf.setHash_info((null));
		hash_buf.setPw_buf((null));
		hash_buf.setPw_len(0);
		if (hashconfig.getIs_salted() == 1) {
			hash_buf.setSalt((salt_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		} 
		if (hashconfig.getEsalt_size() > 0) {
			hash_buf.setEsalt(ModernizedCProgram.hcmalloc(hashconfig.getEsalt_size()));
		} 
		if (hashconfig.getHook_salt_size() > 0) {
			hash_buf.setHook_salt(ModernizedCProgram.hcmalloc(hashconfig.getHook_salt_size()));
		} 
		// whenever we use --username and --show together we want to keep all hashes sorted within a nice structurepot_tree_entry_t all_hashes_tree = (null);
		pot_tree_entry_t[] tree_entry_cache = (null);
		pot_hash_node_t[] tree_nodes_cache = (null);
		pot_hash_node generatedNodes = found_entry.getNodes();
		if (hashconfig.getPotfile_keep_all_hashes() == 1) {
			tree_entry_cache = (pot_tree_entry_t)ModernizedCProgram.hccalloc(hashes_cnt, /*Error: Unsupported expression*/);
			tree_nodes_cache = (pot_hash_node_t)ModernizedCProgram.hccalloc(hashes_cnt, /*Error: Unsupported expression*/);
			for (u32 hash_pos = 0;
			 hash_pos < hashes_cnt; hash_pos++) {
				pot_hash_node_t new_node = tree_nodes_cache[hash_pos];
				new_node.setHash_buf(hashes_buf[hash_pos]);
				new_node.setNext((null));
				pot_tree_entry_t new_entry = tree_entry_cache[hash_pos];
				new_entry.setNodes(new_node);
				new_entry.setHashconfig((hashconfig_t)hashconfig);
				Object found = /*Error: Function owner not recognized*/tsearch(new_entry, (Object)all_hashes_tree, ModernizedCProgram.sort_pot_tree_by_hash);
				pot_tree_entry_t found_entry = (pot_tree_entry_t)found;
				if (found_entry == (null)) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), "Error while allocating memory for the potfile search: %s\n", "Insufficient memory available");
					return -1;
				} 
				if (found_entry == new_entry) {
				} else {
						new_node.setNext(generatedNodes);
				} 
				found_entry.setNodes(new_node);
			}
		} 
		// we need *at most* one entry for every hash
		Object generatedDigest = hash_buf.getDigest();
		salt generatedSalt = hash_buf.getSalt();
		Object generatedEsalt = hash_buf.getEsalt();
		Object generatedHook_salt = hash_buf.getHook_salt();
		hashinfo generatedHash_info = hash_buf.getHash_info();
		// do not use this unless really needed, for example as in LMif (module_ctx.getModule_hash_decode_zero_hash() != (Object)-1) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info);
			if (hashconfig.getPotfile_keep_all_hashes() == 1) {
				ModernizedCProgram.potfile_update_hashes(hashcat_ctx, hash_buf, (null), 0, all_hashes_tree);
			} else {
					hash_t found = (hash_t)ModernizedCProgram.hc_bsearch_r(hash_buf, hashes_buf, hashes_cnt, /*Error: Unsupported expression*/, ModernizedCProgram.sort_by_hash_no_salt, (Object)hashconfig);
					ModernizedCProgram.potfile_update_hash(hashcat_ctx, found, (null), 0);
			} 
		} 
		int rc = hashcat_ctx.potfile_read_open();
		if (rc == -1) {
			return -1;
		} 
		Object tmps = (null);
		if (hashconfig.getTmp_size() > 0) {
			tmps = ModernizedCProgram.hcmalloc(hashconfig.getTmp_size());
		} 
		Byte line_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
		hc_fp generatedFp = potfile_ctx.getFp();
		while (!generatedFp.hc_feof()) {
			size_t line_len = generatedFp.fgetl(line_buf, -1024);
			if (line_len == 0) {
				continue;
			} 
			Byte last_separator = /*Error: Function owner not recognized*/strrchr(line_buf, hashconfig.getSeparator());
			if (last_separator == (null)) {
				continue;
			} 
			Byte line_pw_buf = last_separator + 1;
			size_t line_pw_len = line_buf + line_len - line_pw_buf;
			Byte line_hash_buf = line_buf;
			int line_hash_len = last_separator - line_buf;
			line_hash_buf[line_hash_len] = 0;
			if (line_hash_len == 0) {
				continue;
			} 
			if (generatedSalt) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedSalt, 0, /*Error: Unsupported expression*/);
			} 
			if (generatedEsalt) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedEsalt, 0, hashconfig.getEsalt_size());
			} 
			if (generatedHook_salt) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedHook_salt, 0, hashconfig.getHook_salt_size());
			} 
			if (module_ctx.getModule_hash_decode_potfile() != (Object)-1) {
				if (module_ctx.getModule_potfile_custom_check() != (Object)-1) {
					int parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, line_hash_buf, line_hash_len, tmps);
					if (parser_status != parser_rc.PARSER_OK) {
						continue;
					} 
					for (u32 hashes_pos = 0;
					 hashes_pos < hashes_cnt; hashes_pos++) {
						boolean cracked = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, hashes_buf[hashes_pos], hash_buf, tmps);
						if (cracked == 1) {
							ModernizedCProgram.potfile_update_hash(hashcat_ctx, hashes_buf[hashes_pos], line_pw_buf, (u32)line_pw_len);
						} 
					}
					continue;
				} 
			} else {
					int parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, line_hash_buf, line_hash_len);
					if (parser_status != parser_rc.PARSER_OK) {
						continue;
					} 
					if (hashconfig.getPotfile_keep_all_hashes() == 1) {
						ModernizedCProgram.potfile_update_hashes(hashcat_ctx, hash_buf, line_pw_buf, (u32)line_pw_len, all_hashes_tree);
						continue;
					} 
					hash_t found = (hash_t)ModernizedCProgram.hc_bsearch_r(hash_buf, hashes_buf, hashes_cnt, /*Error: Unsupported expression*/, ModernizedCProgram.sort_by_hash, (Object)hashconfig);
					ModernizedCProgram.potfile_update_hash(hashcat_ctx, found, line_pw_buf, (u32)line_pw_len);
			} 
		}
		ModernizedCProgram.hcfree(line_buf);
		if (hashconfig.getTmp_size() > 0) {
			ModernizedCProgram.hcfree(tmps);
		} 
		hashcat_ctx.potfile_read_close();
		if (hashconfig.getPotfile_keep_all_hashes() == 1) {
			all_hashes_tree.pot_tree_destroy();
			ModernizedCProgram.hcfree(tree_nodes_cache);
			ModernizedCProgram.hcfree(tree_entry_cache);
		} 
		if (hashconfig.getEsalt_size() > 0) {
			ModernizedCProgram.hcfree(generatedEsalt);
		} 
		if (hashconfig.getHook_salt_size() > 0) {
			ModernizedCProgram.hcfree(generatedHook_salt);
		} 
		if (hashconfig.getIs_salted() == 1) {
			ModernizedCProgram.hcfree(generatedSalt);
		} 
		ModernizedCProgram.hcfree(generatedDigest);
		return 0;
	}
	public int potfile_handle_show() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		potfile_ctx_t potfile_ctx = generatedPotfile_ctx;
		hash generatedHashes_buf = hashes.getHashes_buf();
		hash_t[] hashes_buf = generatedHashes_buf;
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		u32 salts_cnt = generatedSalts_cnt;
		salt[] generatedSalts_buf = hashes.getSalts_buf();
		salt_t salts_buf = generatedSalts_buf;
		Object generatedOpts_type = hashconfig.getOpts_type();
		Object generatedDigests_cnt = salt_buf.getDigests_cnt();
		Object generatedDigests_offset = salt_buf.getDigests_offset();
		Object[] generatedDigests_shown = hashes.getDigests_shown();
		hashinfo generatedHash_info = hash1.getHash_info();
		split generatedSplit = generatedHash_info.getSplit();
		int generatedSplit_origin = generatedSplit.getSplit_origin();
		int generatedSplit_neighbor = generatedSplit.getSplit_neighbor();
		Object generatedOut_buf = potfile_ctx.getOut_buf();
		module_ctx generatedModule_ctx = this.getModule_ctx();
		user generatedUser = generatedHash_info.getUser();
		byte[] generatedUser_name = user.getUser_name();
		Object generatedUser_len = user.getUser_len();
		Object generatedTmp_buf = potfile_ctx.getTmp_buf();
		byte[] generatedPw_buf = hash1.getPw_buf();
		int generatedPw_len = hash1.getPw_len();
		if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_SPLIT) {
			for (u32 salt_idx = 0;
			 salt_idx < salts_cnt; salt_idx++) {
				salt_t salt_buf = salts_buf + salt_idx;
				u32 digests_cnt = generatedDigests_cnt;
				for (u32 digest_idx = 0;
				 digest_idx < digests_cnt; digest_idx++) {
					u32 hashes_idx = generatedDigests_offset + digest_idx;
					u32 digests_shown = generatedDigests_shown;
					hash_t hash1 = hashes_buf[hashes_idx];
					hash_t hash2 = (null);
					int split_neighbor = -1;
					if (generatedSplit_origin == split_origin.SPLIT_ORIGIN_LEFT) {
						split_neighbor = generatedSplit_neighbor;
						hash2 = hashes_buf[split_neighbor];
						if ((digests_shown[hashes_idx] == 0) && (digests_shown[split_neighbor] == 0)) {
							continue;
						} 
					}  else if (generatedSplit_origin == split_origin.SPLIT_ORIGIN_NONE) {
						if (digests_shown[hashes_idx] == 0) {
							continue;
						} 
					} else {
							continue;
					} 
					u8 out_buf = generatedOut_buf;
					int out_len = ModernizedCProgram.hash_encode(generatedHashconfig, generatedHashes, generatedModule_ctx, (byte)out_buf + 0, -1024 - 0, salt_idx, digest_idx);
					if (hash2) {
						out_len += ModernizedCProgram.hash_encode(generatedHashconfig, generatedHashes, generatedModule_ctx, (byte)out_buf + 16, -1024 - 16, salt_idx, split_neighbor);
					} 
					out_buf[out_len] = 0;
					Byte username = (null);
					u32 user_len = 0;
					user_t user = generatedUser;
					if (user) {
						username = (byte)(generatedUser_name);
						user_len = generatedUser_len;
						username[user_len] = 0;
					} 
					u8 tmp_buf = generatedTmp_buf;
					tmp_buf[0] = 0;
					u8[] mixed_buf = new u8[]{0};
					u8 mixed_len = 0;
					if (digests_shown[hashes_idx] == 1) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(mixed_buf + mixed_len, generatedPw_buf, generatedPw_len);
						mixed_len += generatedPw_len;
					} else {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(mixed_buf + mixed_len, ModernizedCProgram.MASKED_PLAIN, /*Error: Function owner not recognized*/strlen(ModernizedCProgram.MASKED_PLAIN));
							mixed_len += /*Error: Function owner not recognized*/strlen(ModernizedCProgram.MASKED_PLAIN);
					} 
					if (hash2) {
						if (digests_shown[split_neighbor] == 1) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(mixed_buf + mixed_len, generatedPw_buf, generatedPw_len);
							mixed_len += generatedPw_len;
						} else {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(mixed_buf + mixed_len, ModernizedCProgram.MASKED_PLAIN, /*Error: Function owner not recognized*/strlen(ModernizedCProgram.MASKED_PLAIN));
								mixed_len += /*Error: Function owner not recognized*/strlen(ModernizedCProgram.MASKED_PLAIN);
						} 
					} 
					int tmp_len = hashcat_ctx.outfile_write((byte)out_buf, out_len, (u8)mixed_buf, mixed_len, 0, username, user_len, (byte)tmp_buf);
					hashcat_ctx.event_call((event_identifier.EVENT_POTFILE_HASH_SHOW), (tmp_buf), (tmp_len));
				}
			}
		} else {
				for (u32 salt_idx = 0;
				 salt_idx < salts_cnt; salt_idx++) {
					salt_t salt_buf = salts_buf + salt_idx;
					u32 digests_cnt = generatedDigests_cnt;
					for (u32 digest_idx = 0;
					 digest_idx < digests_cnt; digest_idx++) {
						u32 hashes_idx = generatedDigests_offset + digest_idx;
						u32 digests_shown = generatedDigests_shown;
						if (digests_shown[hashes_idx] == 0) {
							continue;
						} 
						hash_t hash = hashes_buf[hashes_idx];
						u8 out_buf = generatedOut_buf;
						int out_len = ModernizedCProgram.hash_encode(generatedHashconfig, generatedHashes, generatedModule_ctx, (byte)out_buf, -1024, salt_idx, digest_idx);
						out_buf[out_len] = 0;
						Byte username = (null);
						u32 user_len = 0;
						if (generatedHash_info != (null)) {
							user_t user = generatedUser;
							if (user) {
								username = (byte)(generatedUser_name);
								user_len = generatedUser_len;
								username[user_len] = 0;
							} 
						} 
						u8 tmp_buf = generatedTmp_buf;
						tmp_buf[0] = 0;
						boolean is_collider_hex_password = false;
						if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ALWAYS_HEXIFY) {
							if (ModernizedCProgram.is_hexify((u8)generatedPw_buf, generatedPw_len) == 1) {
								is_collider_hex_password = true;
							} 
						} 
						int tmp_len = 0;
						if (is_collider_hex_password == true) {
							u8[] pass_unhexified = new u8[]{0};
							size_t pass_unhexified_len = ModernizedCProgram.exec_unhexify((u8)generatedPw_buf, generatedPw_len, pass_unhexified, /*Error: sizeof expression not supported yet*/);
							tmp_len = hashcat_ctx.outfile_write((byte)out_buf, out_len, pass_unhexified, (u32)pass_unhexified_len, 0, username, user_len, (byte)tmp_buf);
						} else {
								tmp_len = hashcat_ctx.outfile_write((byte)out_buf, out_len, (u8)generatedPw_buf, generatedPw_len, 0, username, user_len, (byte)tmp_buf);
						} 
						hashcat_ctx.event_call((event_identifier.EVENT_POTFILE_HASH_SHOW), (tmp_buf), (tmp_len));
					}
				}
		} 
		// this implementation will work for LM only
		return 0;
	}
	public int potfile_handle_left() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		module_ctx generatedModule_ctx = this.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		potfile_ctx_t potfile_ctx = generatedPotfile_ctx;
		hash generatedHashes_buf = hashes.getHashes_buf();
		hash_t[] hashes_buf = generatedHashes_buf;
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		u32 salts_cnt = generatedSalts_cnt;
		salt[] generatedSalts_buf = hashes.getSalts_buf();
		salt_t salts_buf = generatedSalts_buf;
		Object generatedOpts_type = hashconfig.getOpts_type();
		Object generatedDigests_cnt = salt_buf.getDigests_cnt();
		Object generatedDigests_offset = salt_buf.getDigests_offset();
		Object[] generatedDigests_shown = hashes.getDigests_shown();
		hashinfo generatedHash_info = hash1.getHash_info();
		split generatedSplit = generatedHash_info.getSplit();
		int generatedSplit_origin = generatedSplit.getSplit_origin();
		int generatedSplit_neighbor = generatedSplit.getSplit_neighbor();
		Object generatedOut_buf = potfile_ctx.getOut_buf();
		user generatedUser = generatedHash_info.getUser();
		byte[] generatedUser_name = user.getUser_name();
		Object generatedUser_len = user.getUser_len();
		Object generatedTmp_buf = potfile_ctx.getTmp_buf();
		Object generatedModule_hash_binary_save = module_ctx.getModule_hash_binary_save();
		if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_SPLIT) {
			for (u32 salt_idx = 0;
			 salt_idx < salts_cnt; salt_idx++) {
				salt_t salt_buf = salts_buf + salt_idx;
				u32 digests_cnt = generatedDigests_cnt;
				for (u32 digest_idx = 0;
				 digest_idx < digests_cnt; digest_idx++) {
					u32 hashes_idx = generatedDigests_offset + digest_idx;
					u32 digests_shown = generatedDigests_shown;
					hash_t hash1 = hashes_buf[hashes_idx];
					hash_t hash2 = (null);
					int split_neighbor = -1;
					if (generatedSplit_origin == split_origin.SPLIT_ORIGIN_LEFT) {
						split_neighbor = generatedSplit_neighbor;
						hash2 = hashes_buf[split_neighbor];
						if ((digests_shown[hashes_idx] == 1) && (digests_shown[split_neighbor] == 1)) {
							continue;
						} 
					}  else if (generatedSplit_origin == split_origin.SPLIT_ORIGIN_NONE) {
						if (digests_shown[hashes_idx] == 1) {
							continue;
						} 
					} else {
							continue;
					} 
					u8 out_buf = generatedOut_buf;
					int out_len = ModernizedCProgram.hash_encode(generatedHashconfig, generatedHashes, generatedModule_ctx, (byte)out_buf + 0, -1024 - 0, salt_idx, digest_idx);
					if (hash2) {
						out_len += ModernizedCProgram.hash_encode(generatedHashconfig, generatedHashes, generatedModule_ctx, (byte)out_buf + 16, -1024 - 16, salt_idx, split_neighbor);
					} 
					out_buf[out_len] = 0;
					Byte username = (null);
					u32 user_len = 0;
					user_t user = generatedUser;
					if (user) {
						username = (byte)(generatedUser_name);
						user_len = generatedUser_len;
						username[user_len] = 0;
					} 
					u8 tmp_buf = generatedTmp_buf;
					tmp_buf[0] = 0;
					int tmp_len = hashcat_ctx.outfile_write((byte)out_buf, out_len, (null), 0, 0, username, user_len, (byte)tmp_buf);
					hashcat_ctx.event_call((event_identifier.EVENT_POTFILE_HASH_LEFT), (tmp_buf), (tmp_len));
				}
			}
		} else {
				for (u32 salt_idx = 0;
				 salt_idx < salts_cnt; salt_idx++) {
					salt_t salt_buf = salts_buf + salt_idx;
					u32 digests_cnt = generatedDigests_cnt;
					for (u32 digest_idx = 0;
					 digest_idx < digests_cnt; digest_idx++) {
						u32 hashes_idx = generatedDigests_offset + digest_idx;
						u32 digests_shown = generatedDigests_shown;
						if (digests_shown[hashes_idx] == 1) {
							continue;
						} 
						u8 out_buf = generatedOut_buf;
						int out_len;
						if (generatedModule_hash_binary_save != (Object)-1) {
							Byte binary_buf = (null);
							int binary_len = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashes, salt_idx, digest_idx, binary_buf);
							if ((generatedOpts_type & opts_type.OPTS_TYPE_BINARY_HASHFILE) == 0) {
								binary_len--;
							} 
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(out_buf, binary_buf, binary_len);
							out_len = binary_len;
							ModernizedCProgram.hcfree(binary_buf);
						} else {
								out_len = ModernizedCProgram.hash_encode(generatedHashconfig, generatedHashes, generatedModule_ctx, (byte)out_buf, -1024, salt_idx, digest_idx);
						} 
						out_buf[out_len] = 0;
						hash_t hash = hashes_buf[hashes_idx];
						Byte username = (null);
						u32 user_len = 0;
						if (generatedHash_info != (null)) {
							user_t user = generatedUser;
							if (user) {
								username = (byte)(generatedUser_name);
								user_len = generatedUser_len;
								username[user_len] = 0;
							} 
						} 
						u8 tmp_buf = generatedTmp_buf;
						tmp_buf[0] = 0;
						int tmp_len = hashcat_ctx.outfile_write((byte)out_buf, out_len, (null), 0, 0, username, user_len, (byte)tmp_buf);
						hashcat_ctx.event_call((event_identifier.EVENT_POTFILE_HASH_LEFT), (tmp_buf), (tmp_len));
					}
				}
		} 
		// this implementation will work for LM only
		return 0;
	}
	// hlfmt hashcat
	public void hlfmt_hash_hashcat(byte[] line_buf, Object line_len, Byte hashbuf_pos, Integer hashbuf_len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		if (user_options.getUsername() == 0) {
			hashbuf_pos = line_buf;
			hashbuf_len = line_len;
		} else {
				Byte pos = line_buf;
				size_t len = line_len;
				for (int i = 0;
				 i < line_len; ) {
					if (line_buf[i] == hashconfig.getSeparator()) {
						pos++;
						len--;
						break;
					} 
				}
				hashbuf_pos = pos;
				hashbuf_len = len;
		} 
	}
	public void hlfmt_user_hashcat(byte[] line_buf, Object line_len, Byte userbuf_pos, Integer userbuf_len) {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		Byte pos = (null);
		size_t len = 0;
		int sep_cnt = 0;
		for (int i = 0;
		 i < line_len; i++) {
			if (line_buf[i] == hashconfig.getSeparator()) {
				sep_cnt++;
				continue;
			} 
			if (sep_cnt == 0) {
				if (pos == (null)) {
					pos = line_buf + i;
				} 
				len++;
			} 
		}
		userbuf_pos = pos;
		userbuf_len = len;
	}
	// hlfmt pwdump
	public int hlfmt_detect_pwdump(Object[] line_buf, Object line_len) {
		int sep_cnt = 0;
		int sep2_len = 0;
		int sep3_len = 0;
		for (int i = 0;
		 i < line_len; i++) {
			if (line_buf[i] == (byte)':') {
				sep_cnt++;
				continue;
			} 
			if (sep_cnt == 2) {
				sep2_len++;
			} 
			if (sep_cnt == 3) {
				sep3_len++;
			} 
		}
		if ((sep_cnt == 6) && ((sep2_len == 32) || (sep3_len == 32))) {
			return 1;
		} 
		return 0;
	}
	public void hlfmt_hash_pwdump(byte[] line_buf, Object line_len, Byte hashbuf_pos, Integer hashbuf_len) {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		Byte pos = (null);
		size_t len = 0;
		int sep_cnt = 0;
		for (int i = 0;
		 i < line_len; i++) {
			if (line_buf[i] == (byte)':') {
				sep_cnt++;
				continue;
			} 
			if (hashconfig.getPwdump_column() == pwdump_column.PWDUMP_COLUMN_LM_HASH) {
				if (sep_cnt == 2) {
					if (pos == (null)) {
						pos = line_buf + i;
					} 
					len++;
				} 
			}  else if (hashconfig.getPwdump_column() == pwdump_column.PWDUMP_COLUMN_NTLM_HASH) {
				if (sep_cnt == 3) {
					if (pos == (null)) {
						pos = line_buf + i;
					} 
					len++;
				} 
			} 
		}
		hashbuf_pos = pos;
		hashbuf_len = len;
	}
	public void hlfmt_user_pwdump(byte[] line_buf, Object line_len, Byte userbuf_pos, Integer userbuf_len) {
		Byte pos = (null);
		size_t len = 0;
		int sep_cnt = 0;
		for (int i = 0;
		 i < line_len; i++) {
			if (line_buf[i] == (byte)':') {
				sep_cnt++;
				continue;
			} 
			if (sep_cnt == 0) {
				if (pos == (null)) {
					pos = line_buf + i;
				} 
				len++;
			} 
		}
		userbuf_pos = pos;
		userbuf_len = len;
	}
	// hlfmt passwd
	public int hlfmt_detect_passwd(Object[] line_buf, Object line_len) {
		int sep_cnt = 0;
		byte sep5_first = 0;
		byte sep6_first = 0;
		for (int i = 0;
		 i < line_len; i++) {
			if (line_buf[i] == (byte)':') {
				sep_cnt++;
				continue;
			} 
			if (sep_cnt == 5) {
				if (sep5_first == 0) {
					sep5_first = line_buf[i];
				} 
			} 
			if (sep_cnt == 6) {
				if (sep6_first == 0) {
					sep6_first = line_buf[i];
				} 
			} 
		}
		if ((sep_cnt == 6) && ((sep5_first == (byte)'/') || (sep6_first == (byte)'/'))) {
			return 1;
		} 
		return 0;
	}
	public void hlfmt_hash_passwd(byte[] line_buf, Object line_len, Byte hashbuf_pos, Integer hashbuf_len) {
		Byte pos = (null);
		size_t len = 0;
		int sep_cnt = 0;
		for (int i = 0;
		 i < line_len; i++) {
			if (line_buf[i] == (byte)':') {
				sep_cnt++;
				continue;
			} 
			if (sep_cnt == 1) {
				if (pos == (null)) {
					pos = line_buf + i;
				} 
				len++;
			} 
		}
		hashbuf_pos = pos;
		hashbuf_len = len;
	}
	public void hlfmt_user_passwd(byte[] line_buf, Object line_len, Byte userbuf_pos, Integer userbuf_len) {
		Byte pos = (null);
		size_t len = 0;
		int sep_cnt = 0;
		for (int i = 0;
		 i < line_len; i++) {
			if (line_buf[i] == (byte)':') {
				sep_cnt++;
				continue;
			} 
			if (sep_cnt == 0) {
				if (pos == (null)) {
					pos = line_buf + i;
				} 
				len++;
			} 
		}
		userbuf_pos = pos;
		userbuf_len = len;
	}
	// hlfmt shadow
	public int hlfmt_detect_shadow(Object[] line_buf, Object line_len) {
		int sep_cnt = 0;
		for (int i = 0;
		 i < line_len; i++) {
			if (line_buf[i] == (byte)':') {
				sep_cnt++;
			} 
		}
		if (sep_cnt == 8) {
			return 1;
		} 
		return 0;
	}
	public void hlfmt_hash_shadow(Byte line_buf, Object line_len, Byte hashbuf_pos, Integer hashbuf_len) {
		hashcat_ctx.hlfmt_hash_passwd(line_buf, line_len, hashbuf_pos, hashbuf_len);
	}
	public void hlfmt_user_shadow(Byte line_buf, Object line_len, Byte userbuf_pos, Integer userbuf_len) {
		hashcat_ctx.hlfmt_user_passwd(line_buf, line_len, userbuf_pos, userbuf_len);
	}
	public void hlfmt_hash(Object hashfile_format, Byte line_buf, Object line_len, Byte hashbuf_pos, Integer hashbuf_len) {
		switch (hashfile_format) {
		case hlfmt_name.HLFMT_PWDUMP:
				hashcat_ctx.hlfmt_hash_pwdump(line_buf, line_len, hashbuf_pos, hashbuf_len);
				break;
		case hlfmt_name.HLFMT_PASSWD:
				hashcat_ctx.hlfmt_hash_passwd(line_buf, line_len, hashbuf_pos, hashbuf_len);
				break;
		case hlfmt_name.HLFMT_HASHCAT:
				hashcat_ctx.hlfmt_hash_hashcat(line_buf, line_len, hashbuf_pos, hashbuf_len);
				break;
		case hlfmt_name.HLFMT_SHADOW:
				hashcat_ctx.hlfmt_hash_shadow(line_buf, line_len, hashbuf_pos, hashbuf_len);
				break;
		}
	}
	public void hlfmt_user(Object hashfile_format, Byte line_buf, Object line_len, Byte userbuf_pos, Integer userbuf_len) {
		switch (hashfile_format) {
		case hlfmt_name.HLFMT_HASHCAT:
				hashcat_ctx.hlfmt_user_hashcat(line_buf, line_len, userbuf_pos, userbuf_len);
				break;
		case hlfmt_name.HLFMT_PWDUMP:
				hashcat_ctx.hlfmt_user_pwdump(line_buf, line_len, userbuf_pos, userbuf_len);
				break;
		case hlfmt_name.HLFMT_PASSWD:
				hashcat_ctx.hlfmt_user_passwd(line_buf, line_len, userbuf_pos, userbuf_len);
				break;
		case hlfmt_name.HLFMT_SHADOW:
				hashcat_ctx.hlfmt_user_shadow(line_buf, line_len, userbuf_pos, userbuf_len);
				break;
		}
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public Object convert_from_hex(byte[] line_buf, Object line_len) {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		// not in hexif (line_len & 1) {
			return (line_len);
		} 
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_HEX) {
			size_t i = new size_t();
			size_t j = new size_t();
			for (; j < line_len; ) {
				line_buf[i] = ModernizedCProgram.hex_to_u8((u8)line_buf[j]);
			}
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(line_buf + i, 0, line_len - i);
			return (i);
		} 
		if (user_options.getWordlist_autohex_disable() == 0) {
			if (ModernizedCProgram.is_hexify((u8)line_buf, line_len) == 1) {
				size_t new_len = ModernizedCProgram.exec_unhexify((u8)line_buf, line_len, (u8)line_buf, line_len);
				return new_len;
			} 
		} 
		return (line_len);
	}
	public int wl_data_init() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		wl_data generatedWl_data = this.getWl_data();
		wl_data_t wl_data = generatedWl_data;
		wl_data.setEnabled(0);
		boolean generatedBenchmark = user_options.getBenchmark();
		if (generatedBenchmark == true) {
			return 0;
		} 
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		wl_data.setEnabled(1);
		Object generatedSegment_size = user_options.getSegment_size();
		wl_data.setBuf((byte)ModernizedCProgram.hcmalloc(generatedSegment_size));
		wl_data.setAvail(generatedSegment_size);
		wl_data.setIncr(generatedSegment_size);
		wl_data.setCnt(0);
		wl_data.setPos(0/**
		   * choose dictionary parser
		   */);
		wl_data.setFunc(ModernizedCProgram.get_next_word_std);
		Object generatedOpts_type = hashconfig.getOpts_type();
		if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UPPER) {
			wl_data.setFunc(ModernizedCProgram.get_next_word_uc);
		} 
		if (generatedOpts_type & opts_type.OPTS_TYPE_PT_LM) {
			wl_data.setFunc(ModernizedCProgram.get_next_word_lm/**
			   * iconv
			   */);
		} 
		Object generatedEncoding_from = user_options.getEncoding_from();
		Object generatedEncoding_to = user_options.getEncoding_to();
		Object generatedIconv_ctx = wl_data.getIconv_ctx();
		if (/*Error: Function owner not recognized*/strcmp(generatedEncoding_from, generatedEncoding_to) != 0) {
			wl_data.setIconv_enabled(1);
			wl_data.setIconv_ctx(/*Error: Function owner not recognized*/iconv_open(generatedEncoding_to, generatedEncoding_from));
			if (generatedIconv_ctx == (iconv_t) - 1) {
				return -1;
			} 
			wl_data.setIconv_tmp((byte)ModernizedCProgram.hcmalloc(-1024));
		} 
		return 0;
	}
	public void wl_data_destroy() {
		wl_data generatedWl_data = this.getWl_data();
		wl_data_t wl_data = generatedWl_data;
		boolean generatedEnabled = wl_data.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		byte[] generatedBuf = wl_data.getBuf();
		ModernizedCProgram.hcfree(generatedBuf);
		boolean generatedIconv_enabled = wl_data.getIconv_enabled();
		Object generatedIconv_ctx = wl_data.getIconv_ctx();
		Byte generatedIconv_tmp = wl_data.getIconv_tmp();
		if (generatedIconv_enabled == true) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/iconv_close(generatedIconv_ctx);
			wl_data.setIconv_enabled(0);
			ModernizedCProgram.hcfree(generatedIconv_tmp);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(wl_data, 0, /*Error: Unsupported expression*/);
	}
	public int set_kernel_power_final(Object kernel_power_final) {
		hashcat_ctx.event_call((event_identifier.EVENT_SET_KERNEL_POWER_FINAL), (null), 0);
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		backend_ctx.setKernel_power_final(kernel_power_final);
		return 0;
	}
	public int user_options_init() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options.setAdvice_disable(user_options_defaults.ADVICE_DISABLE);
		user_options.setAttack_mode(user_options_defaults.ATTACK_MODE);
		user_options.setBackend_devices((null));
		user_options.setBackend_info(user_options_defaults.BACKEND_INFO);
		user_options.setBackend_vector_width(user_options_defaults.BACKEND_VECTOR_WIDTH);
		user_options.setBenchmark_all(user_options_defaults.BENCHMARK_ALL);
		user_options.setBenchmark(user_options_defaults.BENCHMARK);
		user_options.setBitmap_max(user_options_defaults.BITMAP_MAX);
		user_options.setBitmap_min(user_options_defaults.BITMAP_MIN);
		user_options.setCpu_affinity((null));
		user_options.setCustom_charset_1((null));
		user_options.setCustom_charset_2((null));
		user_options.setCustom_charset_3((null));
		user_options.setCustom_charset_4((null));
		user_options.setDebug_file((null));
		user_options.setDebug_mode(user_options_defaults.DEBUG_MODE);
		user_options.setEncoding_from(ModernizedCProgram.ENCODING_FROM);
		user_options.setEncoding_to(ModernizedCProgram.ENCODING_TO);
		user_options.setExample_hashes(user_options_defaults.EXAMPLE_HASHES);
		user_options.setForce(user_options_defaults.FORCE);
		user_options.setHwmon_disable(user_options_defaults.HWMON_DISABLE);
		user_options.setHwmon_temp_abort(user_options_defaults.HWMON_TEMP_ABORT);
		user_options.setHash_mode(user_options_defaults.HASH_MODE);
		user_options.setHccapx_message_pair(user_options_defaults.HCCAPX_MESSAGE_PAIR);
		user_options.setHex_charset(user_options_defaults.HEX_CHARSET);
		user_options.setHex_salt(user_options_defaults.HEX_SALT);
		user_options.setHex_wordlist(user_options_defaults.HEX_WORDLIST);
		user_options.setIncrement(user_options_defaults.INCREMENT);
		user_options.setIncrement_max(user_options_defaults.INCREMENT_MAX);
		user_options.setIncrement_min(user_options_defaults.INCREMENT_MIN);
		user_options.setInduction_dir((null));
		user_options.setKeep_guessing(user_options_defaults.KEEP_GUESSING);
		user_options.setKernel_accel(user_options_defaults.KERNEL_ACCEL);
		user_options.setKernel_loops(user_options_defaults.KERNEL_LOOPS);
		user_options.setKernel_threads(user_options_defaults.KERNEL_THREADS);
		user_options.setKeyboard_layout_mapping((null));
		user_options.setKeyspace(user_options_defaults.KEYSPACE);
		user_options.setLeft(user_options_defaults.LEFT);
		user_options.setLimit(user_options_defaults.LIMIT);
		user_options.setLogfile_disable(user_options_defaults.LOGFILE_DISABLE);
		user_options.setLoopback(user_options_defaults.LOOPBACK);
		user_options.setMachine_readable(user_options_defaults.MACHINE_READABLE);
		user_options.setMarkov_classic(user_options_defaults.MARKOV_CLASSIC);
		user_options.setMarkov_disable(user_options_defaults.MARKOV_DISABLE);
		user_options.setMarkov_hcstat2((null));
		user_options.setMarkov_threshold(user_options_defaults.MARKOV_THRESHOLD);
		user_options.setNonce_error_corrections(user_options_defaults.NONCE_ERROR_CORRECTIONS);
		user_options.setOpencl_device_types((null));
		user_options.setOptimized_kernel_enable(user_options_defaults.OPTIMIZED_KERNEL_ENABLE);
		user_options.setOutfile_autohex(user_options_defaults.OUTFILE_AUTOHEX);
		user_options.setOutfile_check_dir((null));
		user_options.setOutfile_check_timer(user_options_defaults.OUTFILE_CHECK_TIMER);
		user_options.setOutfile_format(user_options_defaults.OUTFILE_FORMAT);
		user_options.setOutfile((null));
		user_options.setPotfile_disable(user_options_defaults.POTFILE_DISABLE);
		user_options.setPotfile_path((null));
		user_options.setProgress_only(user_options_defaults.PROGRESS_ONLY);
		user_options.setQuiet(user_options_defaults.QUIET);
		user_options.setRemove(user_options_defaults.REMOVE);
		user_options.setRemove_timer(user_options_defaults.REMOVE_TIMER);
		user_options.setRestore_disable(user_options_defaults.RESTORE_DISABLE);
		user_options.setRestore_file_path((null));
		user_options.setRestore(user_options_defaults.RESTORE);
		user_options.setRestore_timer(user_options_defaults.RESTORE_TIMER);
		user_options.setRp_gen_func_max(user_options_defaults.RP_GEN_FUNC_MAX);
		user_options.setRp_gen_func_min(user_options_defaults.RP_GEN_FUNC_MIN);
		user_options.setRp_gen(user_options_defaults.RP_GEN);
		user_options.setRp_gen_seed(user_options_defaults.RP_GEN_SEED);
		user_options.setRule_buf_l(ModernizedCProgram.RULE_BUF_L);
		user_options.setRule_buf_r(ModernizedCProgram.RULE_BUF_R);
		user_options.setRuntime(user_options_defaults.RUNTIME);
		user_options.setScrypt_tmto(user_options_defaults.SCRYPT_TMTO);
		user_options.setSegment_size(user_options_defaults.SEGMENT_SIZE);
		user_options.setSelf_test_disable(user_options_defaults.SELF_TEST_DISABLE);
		user_options.setSeparator(user_options_defaults.SEPARATOR);
		user_options.setSession("hashcat");
		user_options.setShow(user_options_defaults.SHOW);
		user_options.setSkip(user_options_defaults.SKIP);
		user_options.setSlow_candidates(user_options_defaults.SLOW_CANDIDATES);
		user_options.setSpeed_only(user_options_defaults.SPEED_ONLY);
		user_options.setSpin_damp(user_options_defaults.SPIN_DAMP);
		user_options.setStatus(user_options_defaults.STATUS);
		user_options.setStatus_json(user_options_defaults.STATUS_JSON);
		user_options.setStatus_timer(user_options_defaults.STATUS_TIMER);
		user_options.setStdin_timeout_abort(user_options_defaults.STDIN_TIMEOUT_ABORT);
		user_options.setStdout_flag(user_options_defaults.STDOUT_FLAG);
		user_options.setTruecrypt_keyfiles((null));
		user_options.setUsage(user_options_defaults.USAGE);
		user_options.setUsername(user_options_defaults.USERNAME);
		user_options.setVeracrypt_keyfiles((null));
		user_options.setVeracrypt_pim_start(0);
		user_options.setVeracrypt_pim_stop(0);
		user_options.setVersion(user_options_defaults.VERSION);
		user_options.setWordlist_autohex_disable(user_options_defaults.WORDLIST_AUTOHEX_DISABLE);
		user_options.setWorkload_profile(user_options_defaults.WORKLOAD_PROFILE);
		user_options.setRp_files_cnt(0);
		user_options.setRp_files((byte)ModernizedCProgram.hccalloc(256, /*Error: Unsupported expression*/));
		user_options.setHc_bin("hashcat");
		user_options.setHc_argc(0);
		user_options.setHc_argv((null));
		return 0;
	}
	public void user_options_destroy() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		byte[][] generatedRp_files = user_options.getRp_files();
		ModernizedCProgram.hcfree(generatedRp_files)//do not reset this, it might be used from main.c//memset (user_options, 0, sizeof (user_options_t));;//do not reset this, it might be used from main.c//memset (user_options, 0, sizeof (user_options_t));
	}
	public int user_options_getopt(int argc, byte[][] argv) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		int c = -1;
		int option_index;
		optind = 1;
		optopt = 0;
		option_index = 0;
		while ((c = /*Error: Function owner not recognized*/getopt_long(argc, argv, ModernizedCProgram.short_options, ModernizedCProgram.long_options, option_index)) != -1) {
			switch (c) {
			case (byte)'?':
					{ 
						hashcat_ctx.event_log_error("Invalid argument specified.");
						return -1;
					}
			case user_options_map.IDX_SPIN_DAMP:
			case user_options_map.IDX_BACKEND_VECTOR_WIDTH:
			case user_options_map.IDX_KERNEL_ACCEL:
			case user_options_map.IDX_STATUS_TIMER:
			case user_options_map.IDX_SCRYPT_TMTO:
			case user_options_map.IDX_ATTACK_MODE:
			case user_options_map.IDX_RP_GEN_FUNC_MIN:
			case user_options_map.IDX_REMOVE_TIMER:
			case user_options_map.IDX_RP_GEN:
			case user_options_map.IDX_NONCE_ERROR_CORRECTIONS:
			case user_options_map.IDX_KERNEL_LOOPS:
			case user_options_map.IDX_INCREMENT_MAX:
					if (ModernizedCProgram.hc_string_is_digit(optarg) == 0) {
						hashcat_ctx.event_log_error("The specified parameter cannot use '%s' as a value - must be a number.", optarg);
						return -1;
					} 
					break;
			case user_options_map.IDX_RP_GEN_SEED:
			case user_options_map.IDX_SKIP:
			case user_options_map.IDX_HWMON_TEMP_ABORT:
			case user_options_map.IDX_MARKOV_THRESHOLD:
			case user_options_map.IDX_VERACRYPT_PIM_START:
			case user_options_map.IDX_INCREMENT_MIN:
			case user_options_map.IDX_HCCAPX_MESSAGE_PAIR:
			case user_options_map.IDX_RUNTIME:
			case user_options_map.IDX_DEBUG_MODE:
			case user_options_map.IDX_RP_GEN_FUNC_MAX:
			case user_options_map.IDX_BITMAP_MIN:
			case user_options_map.IDX_BITMAP_MAX:
			case user_options_map.IDX_LIMIT:
			case user_options_map.IDX_VERACRYPT_PIM_STOP:
			case user_options_map.IDX_HASH_MODE:
			case user_options_map.IDX_KERNEL_THREADS:
			case user_options_map.IDX_OUTFILE_CHECK_TIMER:
			case user_options_map.IDX_WORKLOAD_PROFILE:
			case user_options_map.IDX_SEGMENT_SIZE:
			case user_options_map.IDX_OUTFILE_FORMAT:
			}
		}
		optind = 1;
		optopt = 0;
		option_index = 0;
		byte[][] generatedRp_files = user_options.getRp_files();
		Object generatedRp_files_cnt = user_options.getRp_files_cnt();
		while ((c = /*Error: Function owner not recognized*/getopt_long(argc, argv, ModernizedCProgram.short_options, ModernizedCProgram.long_options, option_index)) != -1) {
			switch (c) {
			case user_options_map.IDX_CUSTOM_CHARSET_4:
					user_options.setCustom_charset_4(optarg);
					break;
			case user_options_map.IDX_LOOPBACK:
					user_options.setLoopback(1);
					break;
			case user_options_map.IDX_BENCHMARK:
					user_options.setBenchmark(1);
					break;
			case user_options_map.IDX_KERNEL_THREADS:
					user_options.setKernel_threads(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setKernel_threads_chgd(1);
					break;
			case user_options_map.IDX_HELP:
					user_options.setUsage(1);
					break;
			case user_options_map.IDX_RUNTIME:
					user_options.setRuntime(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setRuntime_chgd(1);
					break;
			case user_options_map.IDX_MACHINE_READABLE:
					user_options.setMachine_readable(1);
					break;
			case user_options_map.IDX_INDUCTION_DIR:
					user_options.setInduction_dir(optarg);
					break;
			case user_options_map.IDX_KERNEL_ACCEL:
					user_options.setKernel_accel(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setKernel_accel_chgd(1);
					break;
			case user_options_map.IDX_RESTORE:
					user_options.setRestore(1);
					break;
			case user_options_map.IDX_SLOW_CANDIDATES:
					user_options.setSlow_candidates(1);
					break;
			case user_options_map.IDX_RP_GEN:
					user_options.setRp_gen(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_ENCODING_FROM:
					user_options.setEncoding_from(optarg);
					break;
			case user_options_map.IDX_RESTORE_FILE_PATH:
					user_options.setRestore_file_path(optarg);
					break;
			case user_options_map.IDX_VERACRYPT_PIM_START:
					user_options.setVeracrypt_pim_start(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_POTFILE_PATH:
					user_options.setPotfile_path(optarg);
					break;
			case user_options_map.IDX_STATUS_TIMER:
					user_options.setStatus_timer(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_RP_FILE:
					generatedRp_files[generatedRp_files_cnt++] = optarg;
					break;
			case user_options_map.IDX_RULE_BUF_L:
					user_options.setRule_buf_l(optarg);
					break;
			case user_options_map.IDX_BACKEND_VECTOR_WIDTH:
					user_options.setBackend_vector_width(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setBackend_vector_width_chgd(1);
					break;
			case user_options_map.IDX_MARKOV_CLASSIC:
					user_options.setMarkov_classic(1);
					break;
			case user_options_map.IDX_SKIP:
					user_options.setSkip(ModernizedCProgram.hc_strtoull(optarg, (null), 10));
					user_options.setSkip_chgd(1);
					break;
			case user_options_map.IDX_LIMIT:
					user_options.setLimit(ModernizedCProgram.hc_strtoull(optarg, (null), 10));
					user_options.setLimit_chgd(1);
					break;
			case user_options_map.IDX_TRUECRYPT_KEYFILES:
					user_options.setTruecrypt_keyfiles(optarg);
					break;
			case user_options_map.IDX_KEYSPACE:
					user_options.setKeyspace(1);
					break;
			case user_options_map.IDX_STDOUT_FLAG:
					user_options.setStdout_flag(1);
					break;
			case user_options_map.IDX_KEEP_GUESSING:
					user_options.setKeep_guessing(1);
					break;
			case user_options_map.IDX_LEFT:
					user_options.setLeft(1);
					break;
			case user_options_map.IDX_HCCAPX_MESSAGE_PAIR:
					user_options.setHccapx_message_pair(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setHccapx_message_pair_chgd(1);
					break;
			case user_options_map.IDX_OPTIMIZED_KERNEL_ENABLE:
					user_options.setOptimized_kernel_enable(1);
					break;
			case user_options_map.IDX_ADVICE_DISABLE:
					user_options.setAdvice_disable(1);
					break;
			case user_options_map.IDX_WORKLOAD_PROFILE:
					user_options.setWorkload_profile(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setWorkload_profile_chgd(1);
					break;
			case user_options_map.IDX_BITMAP_MAX:
					user_options.setBitmap_max(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_OUTFILE:
					user_options.setOutfile(optarg);
					break;
			case user_options_map.IDX_QUIET:
					user_options.setQuiet(1);
					break;
			case user_options_map.IDX_HASH_MODE:
					user_options.setHash_mode(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setHash_mode_chgd(1);
					break;
			case user_options_map.IDX_STDIN_TIMEOUT_ABORT:
					user_options.setStdin_timeout_abort(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setStdin_timeout_abort_chgd(1);
					break;
			case user_options_map.IDX_MARKOV_DISABLE:
					user_options.setMarkov_disable(1);
					break;
			case user_options_map.IDX_BITMAP_MIN:
					user_options.setBitmap_min(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_OUTFILE_FORMAT:
					user_options.setOutfile_format(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setOutfile_format_chgd(1);
					break;
			case user_options_map.IDX_OPENCL_DEVICE_TYPES:
					user_options.setOpencl_device_types(optarg);
					break;
			case user_options_map.IDX_REMOVE:
					user_options.setRemove(1);
					break;
			case user_options_map.IDX_DEBUG_MODE:
					user_options.setDebug_mode(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_SEPARATOR:
					user_options.setSeparator(optarg[0]);
					break;
			case user_options_map.IDX_INCREMENT_MAX:
					user_options.setIncrement_max(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setIncrement_max_chgd(1);
					break;
			case user_options_map.IDX_PROGRESS_ONLY:
					user_options.setProgress_only(1);
					break;
			case user_options_map.IDX_RP_GEN_FUNC_MAX:
					user_options.setRp_gen_func_max(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_NONCE_ERROR_CORRECTIONS:
					user_options.setNonce_error_corrections(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setNonce_error_corrections_chgd(1);
					break;
			case user_options_map.IDX_OUTFILE_CHECK_TIMER:
					user_options.setOutfile_check_timer(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_HWMON_TEMP_ABORT:
					user_options.setHwmon_temp_abort(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_SEGMENT_SIZE:
					user_options.setSegment_size(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setSegment_size_chgd(1);
					break;
			case user_options_map.IDX_SPEED_ONLY:
					user_options.setSpeed_only(1);
					break;
			case user_options_map.IDX_RESTORE_DISABLE:
					user_options.setRestore_disable(1);
					break;
			case user_options_map.IDX_LOGFILE_DISABLE:
					user_options.setLogfile_disable(1);
					break;
			case user_options_map.IDX_RP_GEN_SEED:
					user_options.setRp_gen_seed(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setRp_gen_seed_chgd(1);
					break;
			case user_options_map.IDX_POTFILE_DISABLE:
					user_options.setPotfile_disable(1);
					break;
			case user_options_map.IDX_ENCODING_TO:
					user_options.setEncoding_to(optarg);
					break;
			case user_options_map.IDX_VERSION:
					user_options.setVersion(1);
					break;
			case user_options_map.IDX_SELF_TEST_DISABLE:
					user_options.setSelf_test_disable(1);
					break;
			case user_options_map.IDX_WORDLIST_AUTOHEX_DISABLE:
					user_options.setWordlist_autohex_disable(1);
					break;
			case user_options_map.IDX_OUTFILE_CHECK_DIR:
					user_options.setOutfile_check_dir(optarg);
					break;
			case user_options_map.IDX_EXAMPLE_HASHES:
					user_options.setExample_hashes(1);
					break;
			case user_options_map.IDX_STATUS:
					user_options.setStatus(1);
					break;
			case user_options_map.IDX_HEX_CHARSET:
					user_options.setHex_charset(1);
					break;
			case user_options_map.IDX_CPU_AFFINITY:
					user_options.setCpu_affinity(optarg);
					break;
			case user_options_map.IDX_CUSTOM_CHARSET_2:
					user_options.setCustom_charset_2(optarg);
					break;
			case user_options_map.IDX_VERACRYPT_PIM_STOP:
					user_options.setVeracrypt_pim_stop(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_INCREMENT:
					user_options.setIncrement(1);
					break;
			case user_options_map.IDX_STATUS_JSON:
					user_options.setStatus_json(1);
					break;
			case user_options_map.IDX_SPIN_DAMP:
					user_options.setSpin_damp(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setSpin_damp_chgd(1);
					break;
			case user_options_map.IDX_CUSTOM_CHARSET_1:
					user_options.setCustom_charset_1(optarg);
					break;
			case user_options_map.IDX_SESSION:
					user_options.setSession(optarg);
					break;
			case user_options_map.IDX_OUTFILE_AUTOHEX_DISABLE:
					user_options.setOutfile_autohex(0);
					break;
			case user_options_map.IDX_KEYBOARD_LAYOUT_MAPPING:
					user_options.setKeyboard_layout_mapping(optarg);
					break;
			case user_options_map.IDX_HEX_WORDLIST:
					user_options.setHex_wordlist(1);
					break;
			case user_options_map.IDX_BACKEND_DEVICES:
					user_options.setBackend_devices(optarg);
					break;
			case user_options_map.IDX_INCREMENT_MIN:
					user_options.setIncrement_min(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setIncrement_min_chgd(1);
					break;
			case user_options_map.IDX_RP_GEN_FUNC_MIN:
					user_options.setRp_gen_func_min(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_VERACRYPT_KEYFILES:
					user_options.setVeracrypt_keyfiles(optarg);
					break;
			case user_options_map.IDX_SHOW:
					user_options.setShow(1);
					break;
			case user_options_map.IDX_FORCE:
					user_options.setForce(1);
					break;
			case user_options_map.IDX_KERNEL_LOOPS:
					user_options.setKernel_loops(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setKernel_loops_chgd(1);
					break;
			case user_options_map.IDX_REMOVE_TIMER:
					user_options.setRemove_timer(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setRemove_timer_chgd(1);
					break;
			case user_options_map.IDX_SCRYPT_TMTO:
					user_options.setScrypt_tmto(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_CUSTOM_CHARSET_3:
					user_options.setCustom_charset_3(optarg);
					break;
			case user_options_map.IDX_MARKOV_HCSTAT2:
					user_options.setMarkov_hcstat2(optarg);
					break;
			case user_options_map.IDX_DEBUG_FILE:
					user_options.setDebug_file(optarg);
					break;
			case user_options_map.IDX_RULE_BUF_R:
					user_options.setRule_buf_r(optarg);
					break;
			case user_options_map.IDX_HWMON_DISABLE:
					user_options.setHwmon_disable(1);
					break;
			case user_options_map.IDX_BACKEND_INFO:
					user_options.setBackend_info(1);
					break;
			case user_options_map.IDX_MARKOV_THRESHOLD:
					user_options.setMarkov_threshold(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					break;
			case user_options_map.IDX_BENCHMARK_ALL:
					user_options.setBenchmark_all(1);
					break;
			case user_options_map.IDX_HEX_SALT:
					user_options.setHex_salt(1);
					break;
			case user_options_map.IDX_USERNAME:
					user_options.setUsername(1);
					break;
			case user_options_map.IDX_ATTACK_MODE:
					user_options.setAttack_mode(ModernizedCProgram.hc_strtoul(optarg, (null), 10));
					user_options.setAttack_mode_chgd(1);
					break;
			}
		}
		user_options.setHc_bin(argv[0]);
		user_options.setHc_argc(argc - optind);
		user_options.setHc_argv(argv + optind);
		return 0;
	}
	public int user_options_sanity() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		int generatedHc_argc = user_options.getHc_argc();
		if (generatedHc_argc < 0) {
			hashcat_ctx.event_log_error("hc_argc %d is invalid.", generatedHc_argc);
			return -1;
		} 
		byte[][] generatedHc_argv = user_options.getHc_argv();
		if (generatedHc_argv == (null)) {
			hashcat_ctx.event_log_error("hc_argv is NULL.");
			return -1;
		} 
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		Object generatedAttack_mode = user_options.getAttack_mode();
		if (generatedSlow_candidates == true) {
			if ((generatedAttack_mode != attack_mode.ATTACK_MODE_STRAIGHT) && (generatedAttack_mode != attack_mode.ATTACK_MODE_COMBI) && (generatedAttack_mode != attack_mode.ATTACK_MODE_BF)) {
				hashcat_ctx.event_log_error("Invalid attack mode (-a) value specified in slow-candidates mode.");
				return -1;
			} 
		} else {
				if ((generatedAttack_mode != attack_mode.ATTACK_MODE_STRAIGHT) && (generatedAttack_mode != attack_mode.ATTACK_MODE_COMBI) && (generatedAttack_mode != attack_mode.ATTACK_MODE_BF) && (generatedAttack_mode != attack_mode.ATTACK_MODE_HYBRID1) && (generatedAttack_mode != attack_mode.ATTACK_MODE_HYBRID2) && (generatedAttack_mode != attack_mode.ATTACK_MODE_NONE)) {
					hashcat_ctx.event_log_error("Invalid attack mode (-a) value specified.");
					return -1;
				} 
		} 
		boolean generatedHccapx_message_pair_chgd = user_options.getHccapx_message_pair_chgd();
		boolean generatedRemove = user_options.getRemove();
		Object generatedHccapx_message_pair = user_options.getHccapx_message_pair();
		if (generatedHccapx_message_pair_chgd == true) {
			if (generatedRemove == true) {
				hashcat_ctx.event_log_error("Combining --remove with --hccapx-message-pair is not allowed.");
				return -1;
			} 
			if (generatedHccapx_message_pair >= 6) {
				hashcat_ctx.event_log_error("Invalid --hccapx-message-pair value specified.");
				return -1/*
				  if (user_options->skip_chgd == true && user_options->skip == 0)
				  {
				    event_log_error (hashcat_ctx, "Invalid --skip value specified.");
				
				    return -1;
				  }
				  */;
			} 
		} 
		boolean generatedLimit_chgd = user_options.getLimit_chgd();
		Object generatedLimit = user_options.getLimit();
		if (generatedLimit_chgd == true && generatedLimit == 0) {
			hashcat_ctx.event_log_error("Invalid --limit value specified.");
			return -1;
		} 
		boolean generatedRuntime_chgd = user_options.getRuntime_chgd();
		Object generatedRuntime = user_options.getRuntime();
		if (generatedRuntime_chgd == true && generatedRuntime == 0) {
			hashcat_ctx.event_log_error("Invalid --runtime value specified.");
			return -1;
		} 
		boolean generatedLoopback = user_options.getLoopback();
		if (generatedRuntime_chgd == true && generatedLoopback == true) {
			hashcat_ctx.event_log_error("Combining --limit with --loopback is not allowed.");
			return -1;
		} 
		int generatedHash_mode = user_options.getHash_mode();
		if (generatedHash_mode >= ModernizedCProgram.MODULE_HASH_MODES_MAXIMUM) {
			hashcat_ctx.event_log_error("Invalid -m (hash type) value specified.");
			return -1;
		} 
		Object generatedOutfile_format = user_options.getOutfile_format();
		if (generatedOutfile_format > 16) {
			hashcat_ctx.event_log_error("Invalid --outfile-format value specified.");
			return -1;
		} 
		boolean generatedLeft = user_options.getLeft();
		boolean generatedOutfile_format_chgd = user_options.getOutfile_format_chgd();
		if (generatedLeft == true) {
			if (generatedOutfile_format_chgd == true) {
				if (generatedOutfile_format > 1) {
					hashcat_ctx.event_log_error("Combining --outfile-format > 1 with --left is not allowed.");
					return -1;
				} 
			} 
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			if (generatedOutfile_format_chgd == true) {
				if (generatedOutfile_format > 7) {
					hashcat_ctx.event_log_error("Combining --outfile-format > 7 with --show is not allowed.");
					return -1;
				} 
			} 
		} 
		Object generatedIncrement_min = user_options.getIncrement_min();
		if (generatedIncrement_min < user_options_defaults.INCREMENT_MIN) {
			hashcat_ctx.event_log_error("Invalid --increment-min value specified.");
			return -1;
		} 
		Object generatedIncrement_max = user_options.getIncrement_max();
		if (generatedIncrement_max > user_options_defaults.INCREMENT_MAX) {
			hashcat_ctx.event_log_error("Invalid --increment-max value specified.");
			return -1;
		} 
		Object generatedVeracrypt_pim_start = user_options.getVeracrypt_pim_start();
		Object generatedVeracrypt_pim_stop = user_options.getVeracrypt_pim_stop();
		if ((generatedVeracrypt_pim_start != 0) && (generatedVeracrypt_pim_stop == 0)) {
			hashcat_ctx.event_log_error("If --veracrypt-pim-start is specified then --veracrypt-pim-stop needs to be specified, too.");
			return -1;
		} 
		if ((generatedVeracrypt_pim_start == 0) && (generatedVeracrypt_pim_stop != 0)) {
			hashcat_ctx.event_log_error("If --veracrypt-pim-stop is specified then --veracrypt-pim-start needs to be specified, too.");
			return -1;
		} 
		if (generatedVeracrypt_pim_start > generatedVeracrypt_pim_stop) {
			hashcat_ctx.event_log_error("Invalid --veracrypt-pim-start value specified.");
			return -1;
		} 
		if (generatedIncrement_min > generatedIncrement_max) {
			hashcat_ctx.event_log_error("Invalid --increment-min value specified - must be >= --increment-max.");
			return -1;
		} 
		boolean generatedIncrement = user_options.getIncrement();
		boolean generatedProgress_only = user_options.getProgress_only();
		if ((generatedIncrement == true) && (generatedProgress_only == true)) {
			hashcat_ctx.event_log_error("Increment is not allowed in combination with --progress-only.");
			return -1;
		} 
		boolean generatedSpeed_only = user_options.getSpeed_only();
		if ((generatedIncrement == true) && (generatedSpeed_only == true)) {
			hashcat_ctx.event_log_error("Increment is not allowed in combination with --speed-only.");
			return -1;
		} 
		if ((generatedIncrement == true) && (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT)) {
			hashcat_ctx.event_log_error("Increment is not allowed in attack mode 0 (straight).");
			return -1;
		} 
		boolean generatedIncrement_min_chgd = user_options.getIncrement_min_chgd();
		if ((generatedIncrement == false) && (generatedIncrement_min_chgd == true)) {
			hashcat_ctx.event_log_error("Increment-min is only supported when combined with -i/--increment.");
			return -1;
		} 
		boolean generatedIncrement_max_chgd = user_options.getIncrement_max_chgd();
		if ((generatedIncrement == false) && (generatedIncrement_max_chgd == true)) {
			hashcat_ctx.event_log_error("Increment-max is only supported combined with -i/--increment.");
			return -1;
		} 
		Object generatedRp_files_cnt = user_options.getRp_files_cnt();
		Object generatedRp_gen = user_options.getRp_gen();
		if ((generatedRp_files_cnt > 0) && (generatedRp_gen > 0)) {
			hashcat_ctx.event_log_error("Combining -r/--rules-file and -g/--rules-generate is not supported.");
			return -1;
		} 
		if ((generatedRp_files_cnt > 0) || (generatedRp_gen > 0)) {
			if (generatedAttack_mode != attack_mode.ATTACK_MODE_STRAIGHT) {
				hashcat_ctx.event_log_error("Use of -r/--rules-file and -g/--rules-generate only allowed in attack mode 0.");
				return -1;
			} 
		} 
		Object generatedBitmap_min = user_options.getBitmap_min();
		Object generatedBitmap_max = user_options.getBitmap_max();
		if (generatedBitmap_min > generatedBitmap_max) {
			hashcat_ctx.event_log_error("Invalid --bitmap-min value specified.");
			return -1;
		} 
		Object generatedRp_gen_func_min = user_options.getRp_gen_func_min();
		Object generatedRp_gen_func_max = user_options.getRp_gen_func_max();
		if (generatedRp_gen_func_min > generatedRp_gen_func_max) {
			hashcat_ctx.event_log_error("Invalid --rp-gen-func-min value specified.");
			return -1;
		} 
		boolean generatedKernel_accel_chgd = user_options.getKernel_accel_chgd();
		boolean generatedForce = user_options.getForce();
		Object generatedKernel_accel = user_options.getKernel_accel();
		if (generatedKernel_accel_chgd == true) {
			if (generatedForce == false) {
				hashcat_ctx.event_log_error("The manual use of the -n option (or --kernel-accel) is outdated.");
				hashcat_ctx.event_log_warning("Please consider using the -w option instead.");
				hashcat_ctx.event_log_warning("You can use --force to override this, but do not report related errors.");
				hashcat_ctx.event_log_warning((null));
				return -1;
			} 
			if (generatedKernel_accel < 1) {
				hashcat_ctx.event_log_error("Invalid --kernel-accel value specified - must be greater than 0.");
				return -1;
			} 
			if (generatedKernel_accel > 1024) {
				hashcat_ctx.event_log_error("Invalid --kernel-accel value specified - must be <= 1024.");
				return -1;
			} 
		} 
		boolean generatedKernel_loops_chgd = user_options.getKernel_loops_chgd();
		Object generatedKernel_loops = user_options.getKernel_loops();
		if (generatedKernel_loops_chgd == true) {
			if (generatedForce == false) {
				hashcat_ctx.event_log_error("The manual use of the -u option (or --kernel-loops) is outdated.");
				hashcat_ctx.event_log_warning("Please consider using the -w option instead.");
				hashcat_ctx.event_log_warning("You can use --force to override this, but do not report related errors.");
				hashcat_ctx.event_log_warning((null));
				return -1;
			} 
			if (generatedKernel_loops < 1) {
				hashcat_ctx.event_log_error("Invalid kernel-loops specified.");
				return -1;
			} 
			if (generatedKernel_loops > 1024) {
				hashcat_ctx.event_log_error("Invalid kernel-loops specified.");
				return -1;
			} 
		} 
		boolean generatedKernel_threads_chgd = user_options.getKernel_threads_chgd();
		Object generatedKernel_threads = user_options.getKernel_threads();
		if (generatedKernel_threads_chgd == true) {
			if (generatedForce == false) {
				hashcat_ctx.event_log_error("The manual use of the -T option (or --kernel-threads) is outdated.");
				hashcat_ctx.event_log_warning("You can use --force to override this, but do not report related errors.");
				hashcat_ctx.event_log_warning((null));
				return -1;
			} 
			if (generatedKernel_threads < 1) {
				hashcat_ctx.event_log_error("Invalid kernel-threads specified.");
				return -1;
			} 
			if (generatedKernel_threads > 1024) {
				hashcat_ctx.event_log_error("Invalid kernel-threads specified.");
				return -1;
			} 
		} 
		Object generatedWorkload_profile = user_options.getWorkload_profile();
		if ((generatedWorkload_profile < 1) || (generatedWorkload_profile > 4)) {
			hashcat_ctx.event_log_error("workload-profile %u is not available.", generatedWorkload_profile);
			return -1;
		} 
		boolean generatedBackend_vector_width_chgd = user_options.getBackend_vector_width_chgd();
		Object generatedBackend_vector_width = user_options.getBackend_vector_width();
		if (generatedBackend_vector_width_chgd == true) {
			if (ModernizedCProgram.is_power_of_2(generatedBackend_vector_width) == 0 || generatedBackend_vector_width > 16) {
				hashcat_ctx.event_log_error("backend-vector-width %u is not allowed.", generatedBackend_vector_width);
				return -1;
			} 
		} 
		boolean generatedPotfile_disable = user_options.getPotfile_disable();
		if (generatedShow == true || generatedLeft == true) {
			if (generatedRemove == true) {
				hashcat_ctx.event_log_error("Mixing --remove not allowed with --show or --left.");
				return -1;
			} 
			if (generatedPotfile_disable == true) {
				hashcat_ctx.event_log_error("Mixing --potfile-disable is not allowed with --show or --left.");
				return -1;
			} 
		} 
		boolean generatedOutfile_autohex = user_options.getOutfile_autohex();
		if (generatedShow == true) {
			if (generatedOutfile_autohex == false) {
				hashcat_ctx.event_log_error("Mixing --outfile-autohex-disable is not allowed with --show.");
				return -1;
			} 
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			if (generatedShow == true) {
				hashcat_ctx.event_log_error("Combining --show with --keyspace is not allowed.");
				return -1;
			} 
			if (generatedLeft == true) {
				hashcat_ctx.event_log_error("Combining --left with --keyspace is not allowed.");
				return -1;
			} 
		} 
		boolean generatedMachine_readable = user_options.getMachine_readable();
		boolean generatedStatus_json = user_options.getStatus_json();
		if (generatedMachine_readable == true) {
			if (generatedStatus_json == true) {
				hashcat_ctx.event_log_error("The --status-json flag can not be used with --machine-readable.");
				return -1;
			} 
		} 
		boolean generatedRemove_timer_chgd = user_options.getRemove_timer_chgd();
		Object generatedRemove_timer = user_options.getRemove_timer();
		if (generatedRemove_timer_chgd == true) {
			if (generatedRemove == false) {
				hashcat_ctx.event_log_error("The --remove-timer flag requires --remove.");
				return -1;
			} 
			if (generatedRemove_timer < 1) {
				hashcat_ctx.event_log_error("The --remove-timer parameter must have a value greater than or equal to 1.");
				return -1;
			} 
		} 
		if (generatedLoopback == true) {
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
				if ((generatedRp_files_cnt == 0) && (generatedRp_gen == 0)) {
					hashcat_ctx.event_log_error("Parameter --loopback not allowed without -r/--rules-file or -g/--rules-generate.");
					return -1;
				} 
			} else {
					hashcat_ctx.event_log_error("Parameter --loopback is only allowed in attack mode 0 (straight).");
					return -1;
			} 
		} 
		Object generatedDebug_mode = user_options.getDebug_mode();
		if (generatedDebug_mode > 0) {
			if (generatedAttack_mode != attack_mode.ATTACK_MODE_STRAIGHT) {
				hashcat_ctx.event_log_error("Parameter --debug-mode option is only allowed in attack mode 0 (straight).");
				return -1;
			} 
			if ((generatedRp_files_cnt == 0) && (generatedRp_gen == 0)) {
				hashcat_ctx.event_log_error("Use of --debug-mode requires -r/--rules-file or -g/--rules-generate.");
				return -1;
			} 
		} 
		if (generatedDebug_mode > 4) {
			hashcat_ctx.event_log_error("Invalid --debug-mode value specified.");
			return -1;
		} 
		Byte generatedDebug_file = user_options.getDebug_file();
		if (generatedDebug_file != (null)) {
			if (generatedDebug_mode < 1) {
				hashcat_ctx.event_log_error("Parameter --debug-file requires --debug-mode.");
				return -1;
			} 
		} 
		Byte generatedInduction_dir = user_options.getInduction_dir();
		if (generatedInduction_dir != (null)) {
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
				hashcat_ctx.event_log_error("Use of --induction-dir is not allowed in attack mode 3 (brute-force).");
				return -1;
			} 
		} 
		Object generatedSpin_damp = user_options.getSpin_damp();
		if (generatedSpin_damp > 100) {
			hashcat_ctx.event_log_error("Values of --spin-damp must be between 0 and 100 (inclusive).");
			return -1;
		} 
		boolean generatedBenchmark = user_options.getBenchmark();
		boolean generatedAttack_mode_chgd = user_options.getAttack_mode_chgd();
		Object generatedHwmon_temp_abort = user_options.getHwmon_temp_abort();
		boolean generatedRestore = user_options.getRestore();
		boolean generatedStatus = user_options.getStatus();
		boolean generatedSpin_damp_chgd = user_options.getSpin_damp_chgd();
		Object generatedCustom_charset_1 = user_options.getCustom_charset_1();
		Object generatedCustom_charset_2 = user_options.getCustom_charset_2();
		Object generatedCustom_charset_3 = user_options.getCustom_charset_3();
		Byte generatedCustom_charset_4 = user_options.getCustom_charset_4();
		if (generatedBenchmark == true) {
			if (generatedAttack_mode_chgd == true) {
				hashcat_ctx.event_log_error("Can't change --attack-mode (-a) in benchmark mode.");
				return -1;
			} 
			if (generatedBitmap_min != user_options_defaults.BITMAP_MIN) {
				hashcat_ctx.event_log_error("Can't change --bitmap-min in benchmark mode.");
				return -1;
			} 
			if (generatedBitmap_max != user_options_defaults.BITMAP_MAX) {
				hashcat_ctx.event_log_error("Can't change --bitmap-max in benchmark mode.");
				return -1;
			} 
			if (generatedHwmon_temp_abort != user_options_defaults.HWMON_TEMP_ABORT) {
				hashcat_ctx.event_log_error("Can't change --hwmon-temp-abort in benchmark mode.");
				return -1;
			} 
			if (generatedLeft == true) {
				hashcat_ctx.event_log_error("Can't change --left in benchmark mode.");
				return -1;
			} 
			if (generatedShow == true) {
				hashcat_ctx.event_log_error("Can't change --show in benchmark mode.");
				return -1;
			} 
			if (generatedSpeed_only == true) {
				hashcat_ctx.event_log_error("Can't change --speed-only in benchmark mode.");
				return -1;
			} 
			if (generatedProgress_only == true) {
				hashcat_ctx.event_log_error("Can't change --progress-only in benchmark mode.");
				return -1;
			} 
			if (generatedIncrement == true) {
				hashcat_ctx.event_log_error("Can't change --increment (-i) in benchmark mode.");
				return -1;
			} 
			if (generatedRestore == true) {
				hashcat_ctx.event_log_error("Can't change --restore in benchmark mode.");
				return -1;
			} 
			if (generatedStatus == true) {
				hashcat_ctx.event_log_error("Can't change --status in benchmark mode.");
				return -1;
			} 
			if (generatedSpin_damp_chgd == true) {
				hashcat_ctx.event_log_error("Can't change --spin-damp in benchmark mode.");
				return -1;
			} 
			if ((generatedCustom_charset_1 != (null)) || (generatedCustom_charset_2 != (null)) || (generatedCustom_charset_3 != (null)) || (generatedCustom_charset_4 != (null))) {
				if (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
					hashcat_ctx.event_log_error("Custom charsets are not supported in benchmark mode.");
					return -1;
				} 
			} 
		} 
		// sanity checks based on automatically overwritten configuration variables by// benchmark mode section in user_options_preprocess()
		Byte generatedMarkov_hcstat2 = user_options.getMarkov_hcstat2();
		if (generatedMarkov_hcstat2 != (null)) {
			if (/*Error: Function owner not recognized*/strlen(generatedMarkov_hcstat2) == 0) {
				hashcat_ctx.event_log_error("Invalid --markov-hcstat2 value - must not be empty.");
				return -1;
			} 
		} 
		Byte generatedRestore_file_path = user_options.getRestore_file_path();
		if (generatedRestore_file_path != (null)) {
			if (/*Error: Function owner not recognized*/strlen(generatedRestore_file_path) == 0) {
				hashcat_ctx.event_log_error("Invalid --restore-file-path value - must not be empty.");
				return -1;
			} 
		} 
		Byte generatedOutfile = user_options.getOutfile();
		if (generatedOutfile != (null)) {
			if (/*Error: Function owner not recognized*/strlen(generatedOutfile) == 0) {
				hashcat_ctx.event_log_error("Invalid --outfile value - must not be empty.");
				return -1;
			} 
		} 
		if (generatedDebug_file != (null)) {
			if (/*Error: Function owner not recognized*/strlen(generatedDebug_file) == 0) {
				hashcat_ctx.event_log_error("Invalid --debug-file value - must not be empty.");
				return -1;
			} 
		} 
		Object generatedSession = user_options.getSession();
		if (generatedSession != (null)) {
			if (/*Error: Function owner not recognized*/strlen(generatedSession) == 0) {
				hashcat_ctx.event_log_error("Invalid --session value - must not be empty.");
				return -1;
			} 
		} 
		Byte generatedCpu_affinity = user_options.getCpu_affinity();
		if (generatedCpu_affinity != (null)) {
			if (/*Error: Function owner not recognized*/strlen(generatedCpu_affinity) == 0) {
				hashcat_ctx.event_log_error("Invalid --cpu-affinity value - must not be empty.");
				return -1;
			} 
		} 
		Byte generatedBackend_devices = user_options.getBackend_devices();
		if (generatedBackend_devices != (null)) {
			if (/*Error: Function owner not recognized*/strlen(generatedBackend_devices) == 0) {
				hashcat_ctx.event_log_error("Invalid --backend-devices value - must not be empty.");
				return -1;
			} 
		} 
		Byte generatedOpencl_device_types = user_options.getOpencl_device_types();
		if (generatedOpencl_device_types != (null)) {
			if (/*Error: Function owner not recognized*/strlen(generatedOpencl_device_types) == 0) {
				hashcat_ctx.event_log_error("Invalid --opencl-device-types value - must not be empty.");
				return -1;
			} 
		} 
		boolean generatedStdin_timeout_abort_chgd = user_options.getStdin_timeout_abort_chgd();
		if (generatedStdin_timeout_abort_chgd == true) {
			if (generatedAttack_mode != attack_mode.ATTACK_MODE_STRAIGHT) {
				hashcat_ctx.event_log_error("Use of --stdin-timeout-abort is only allowed in attack mode 0 (straight).");
				return -1;
			} 
			if (generatedHc_argc != 1) {
				hashcat_ctx.event_log_error("Use of --stdin-timeout-abort is only allowed in stdin mode (pipe).");
				return -1;
			} 
		} 
		boolean generatedStdout_flag = user_options.getStdout_flag();
		// custom charset checksif ((generatedCustom_charset_1 != (null)) || (generatedCustom_charset_2 != (null)) || (generatedCustom_charset_3 != (null)) || (generatedCustom_charset_4 != (null))) {
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
				hashcat_ctx.event_log_error("Custom charsets are not supported in attack mode 0 (straight).");
				return -1;
			} 
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
				hashcat_ctx.event_log_error("Custom charsets are not supported in attack mode 1 (combination).");
				return -1;
			} 
			boolean mask_is_missing = true;
			if (generatedKeyspace == true) {
				if (generatedHc_argc > 0) {
					mask_is_missing = false;
				} 
			}  else if (generatedStdout_flag == true) {
				if (generatedHc_argc > 0) {
					mask_is_missing = false;
				} 
			} else {
					if (generatedHc_argc > 1) {
						mask_is_missing = false;
					} 
			} 
			if (mask_is_missing == true) {
				hashcat_ctx.event_log_error("If you specify a custom charset, you must also specify a mask.");
				return -1;
			} 
		} 
		// argc / argv checksboolean show_error = true;
		boolean generatedVersion = user_options.getVersion();
		boolean generatedUsage = user_options.getUsage();
		boolean generatedExample_hashes = user_options.getExample_hashes();
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedVersion == true) {
			show_error = false;
		}  else if (generatedUsage == true) {
			show_error = false;
		}  else if (generatedBenchmark == true) {
			if (generatedHc_argc == 0) {
				show_error = false;
			} 
		}  else if (generatedExample_hashes == true) {
			if (generatedHc_argc == 0) {
				show_error = false;
			} 
		}  else if (generatedBackend_info == true) {
			if (generatedHc_argc == 0) {
				show_error = false;
			} 
		}  else if (generatedRestore == true) {
			if (generatedHc_argc == 0) {
				show_error = false;
			} 
		}  else if (generatedKeyspace == true) {
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
				if (generatedHc_argc == 1) {
					show_error = false;
				} 
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
				if (generatedHc_argc == 2) {
					show_error = false;
				} 
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
				if (generatedHc_argc == 1) {
					show_error = false;
				} 
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
				if (generatedHc_argc == 2) {
					show_error = false;
				} 
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
				if (generatedHc_argc == 2) {
					show_error = false;
				} 
			} 
		}  else if (generatedStdout_flag == true) {
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
				show_error = false;
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
				if (generatedHc_argc == 2) {
					show_error = false;
				} 
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
				if (generatedHc_argc >= 1) {
					show_error = false;
				} 
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
				if (generatedHc_argc >= 1) {
					show_error = false;
				} 
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
				if (generatedHc_argc >= 1) {
					show_error = false;
				} 
			} 
		} else {
				if (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
					if (generatedHc_argc >= 1) {
						show_error = false;
					} 
					if (generatedHc_argc == 1) {
						if (generatedSlow_candidates == true) {
							hashcat_ctx.event_log_error("Use of --slow-candidates is not possible in stdin mode.");
							return -1;
						} 
					} 
				}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
					if (generatedHc_argc == 3) {
						show_error = false;
					} 
				}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
					if (generatedHc_argc >= 1) {
						show_error = false;
					} 
				}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
					if (generatedHc_argc >= 2) {
						show_error = false;
					} 
				}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
					if (generatedHc_argc >= 2) {
						show_error = false;
					} 
				} 
		} 
		Object generatedHc_bin = user_options.getHc_bin();
		if (show_error == true) {
			ModernizedCProgram.usage_mini_print(generatedHc_bin);
			return -1;
		} 
		return 0;
	}
	public void user_options_session_auto() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Object generatedSession = user_options.getSession();
		boolean generatedBenchmark = user_options.getBenchmark();
		boolean generatedExample_hashes = user_options.getExample_hashes();
		boolean generatedUsage = user_options.getUsage();
		boolean generatedSpeed_only = user_options.getSpeed_only();
		boolean generatedProgress_only = user_options.getProgress_only();
		boolean generatedKeyspace = user_options.getKeyspace();
		boolean generatedStdout_flag = user_options.getStdout_flag();
		boolean generatedBackend_info = user_options.getBackend_info();
		boolean generatedShow = user_options.getShow();
		boolean generatedLeft = user_options.getLeft();
		if (/*Error: Function owner not recognized*/strcmp(generatedSession, "hashcat") == 0) {
			if (generatedBenchmark == true) {
				user_options.setSession("benchmark");
			} 
			if (generatedExample_hashes == true) {
				user_options.setSession("example_hashes");
			} 
			if (generatedUsage == true) {
				user_options.setSession("usage");
			} 
			if (generatedSpeed_only == true) {
				user_options.setSession("speed_only");
			} 
			if (generatedProgress_only == true) {
				user_options.setSession("progress_only");
			} 
			if (generatedKeyspace == true) {
				user_options.setSession("keyspace");
			} 
			if (generatedStdout_flag == true) {
				user_options.setSession("stdout");
			} 
			if (generatedBackend_info == true) {
				user_options.setSession("backend_info");
			} 
			if (generatedShow == true) {
				user_options.setSession("show");
			} 
			if (generatedLeft == true) {
				user_options.setSession("left");
			} 
		} 
	}
	public void user_options_preprocess() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		// some options can influence or overwrite other options
		boolean generatedStdout_flag = user_options.getStdout_flag();
		if (generatedStdout_flag) {
			user_options.setHwmon_disable(1);
			user_options.setLeft(0);
			user_options.setLogfile_disable(1);
			user_options.setSpin_damp(0);
			user_options.setOutfile_check_timer(0);
			user_options.setPotfile_disable(1);
			user_options.setRestore_disable(1);
			user_options.setRestore(0);
			user_options.setRestore_timer(0);
			user_options.setShow(0);
			user_options.setStatus(0);
			user_options.setStatus_timer(0);
			user_options.setBitmap_min(1);
			user_options.setBitmap_max(1);
		} 
		boolean generatedExample_hashes = user_options.getExample_hashes();
		boolean generatedBackend_info = user_options.getBackend_info();
		boolean generatedKeyspace = user_options.getKeyspace();
		boolean generatedSpeed_only = user_options.getSpeed_only();
		boolean generatedProgress_only = user_options.getProgress_only();
		boolean generatedUsage = user_options.getUsage();
		if (generatedExample_hashes == true || generatedBackend_info == true || generatedKeyspace == true || generatedSpeed_only == true || generatedProgress_only == true || generatedUsage == true) {
			user_options.setHwmon_disable(1);
			user_options.setLeft(0);
			user_options.setLogfile_disable(1);
			user_options.setSpin_damp(0);
			user_options.setOutfile_check_timer(0);
			user_options.setPotfile_disable(1);
			user_options.setRestore_disable(1);
			user_options.setRestore(0);
			user_options.setRestore_timer(0);
			user_options.setShow(0);
			user_options.setStatus(0);
			user_options.setStatus_timer(0);
			user_options.setBitmap_min(1);
			user_options.setBitmap_max(1);
		} 
		boolean generatedBenchmark = user_options.getBenchmark();
		boolean generatedWorkload_profile_chgd = user_options.getWorkload_profile_chgd();
		if (generatedBenchmark == true) {
			user_options.setAttack_mode(attack_mode.ATTACK_MODE_BF);
			user_options.setHwmon_temp_abort(0);
			user_options.setIncrement(0);
			user_options.setLeft(0);
			user_options.setLogfile_disable(1);
			user_options.setSpin_damp(0);
			user_options.setPotfile_disable(1);
			user_options.setProgress_only(0);
			user_options.setRestore_disable(1);
			user_options.setRestore(0);
			user_options.setRestore_timer(0);
			user_options.setShow(0);
			user_options.setSpeed_only(1);
			user_options.setStatus(0);
			user_options.setStatus_timer(0);
			user_options.setBitmap_min(1);
			user_options.setBitmap_max(1);
			if (generatedWorkload_profile_chgd == false) {
				user_options.setOptimized_kernel_enable(1);
				user_options.setWorkload_profile(3);
			} 
		} 
		if (generatedExample_hashes == true) {
			user_options.setQuiet(1);
		} 
		if (generatedUsage == true) {
			user_options.setQuiet(1);
		} 
		if (generatedProgress_only == true) {
			user_options.setSpeed_only(1);
		} 
		if (generatedKeyspace == true) {
			user_options.setQuiet(1);
		} 
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		if (generatedSlow_candidates == true) {
			user_options.setBackend_vector_width(1);
		} 
		Object generatedAttack_mode = user_options.getAttack_mode();
		if (generatedStdout_flag == true) {
			user_options.setForce(1);
			user_options.setHash_mode(2000);
			user_options.setKernel_accel(1024);
			user_options.setBackend_vector_width(1);
			user_options.setOutfile_format(outfile_fmt.OUTFILE_FMT_PLAIN);
			user_options.setQuiet(1);
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
				user_options.setKernel_loops(amplifier_count.KERNEL_RULES);
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
				user_options.setKernel_loops(amplifier_count.KERNEL_COMBS);
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
				user_options.setKernel_loops(amplifier_count.KERNEL_BFS);
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
				user_options.setKernel_loops(amplifier_count.KERNEL_COMBS);
			}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
				user_options.setKernel_loops(amplifier_count.KERNEL_COMBS);
			} 
		} 
		if (generatedBackend_info == true) {
			user_options.setBackend_devices((null));
			user_options.setOpencl_device_types(ModernizedCProgram.hcstrdup("1,2,3"));
			user_options.setQuiet(1);
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			user_options.setOutfile_format(outfile_fmt.OUTFILE_FMT_HASH);
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true || generatedLeft == true) {
			user_options.setAttack_mode(attack_mode.ATTACK_MODE_NONE);
			user_options.setQuiet(1);
		} 
		// this allows the user to use --show and --left while cracking (i.e. while another instance of hashcat is running)if (generatedShow == true || generatedLeft == true) {
			user_options.setRestore_disable(1);
			user_options.setRestore(0);
		} 
		Object generatedSkip = user_options.getSkip();
		Object generatedLimit = user_options.getLimit();
		if (generatedSkip != 0 && generatedLimit != 0) {
			generatedLimit += generatedSkip;
		} 
		Object generatedMarkov_threshold = user_options.getMarkov_threshold();
		if (generatedMarkov_threshold == 0) {
			user_options.setMarkov_threshold(-1024);
		} 
		boolean generatedSegment_size_chgd = user_options.getSegment_size_chgd();
		Object generatedSegment_size = user_options.getSegment_size();
		if (generatedSegment_size_chgd == true) {
			generatedSegment_size *= (1024 * 1024);
		} 
		user_options.setHwmon_disable(1)// WITH_HWMON;// WITH_HWMON
		boolean generatedHwmon_disable = user_options.getHwmon_disable();
		if (generatedHwmon_disable == true) {
			user_options.setHwmon_temp_abort(0);
		} 
		int generatedHc_argc = user_options.getHc_argc();
		// default maskif (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
			if (generatedExample_hashes == true) {
			}  else if (generatedBackend_info == true) {
			}  else if (generatedSpeed_only == true) {
			}  else if (generatedKeyspace == true) {
				if (generatedHc_argc == 0) {
					user_options.setCustom_charset_1(ModernizedCProgram.DEF_MASK_CS_1);
					user_options.setCustom_charset_2(ModernizedCProgram.DEF_MASK_CS_2);
					user_options.setCustom_charset_3(ModernizedCProgram.DEF_MASK_CS_3);
					user_options.setIncrement(1);
				} 
			}  else if (generatedStdout_flag == true) {
				if (generatedHc_argc == 0) {
					user_options.setCustom_charset_1(ModernizedCProgram.DEF_MASK_CS_1);
					user_options.setCustom_charset_2(ModernizedCProgram.DEF_MASK_CS_2);
					user_options.setCustom_charset_3(ModernizedCProgram.DEF_MASK_CS_3);
					user_options.setIncrement(1);
				} 
			} else {
					if (generatedHc_argc == 1) {
						user_options.setCustom_charset_1(ModernizedCProgram.DEF_MASK_CS_1);
						user_options.setCustom_charset_2(ModernizedCProgram.DEF_MASK_CS_2);
						user_options.setCustom_charset_3(ModernizedCProgram.DEF_MASK_CS_3);
						user_options.setIncrement(1);
					} 
			} 
		} 
	}
	public void user_options_postprocess() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		// automatic status
		Object generatedWordlist_mode = user_options_extra.getWordlist_mode();
		if (generatedWordlist_mode == wl_mode.WL_MODE_STDIN) {
			user_options.setStatus(1);
		} 
	}
	public void user_options_info() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getBenchmark() == 0) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getMachine_readable() == 0) {
			hashcat_ctx.event_log_info("Benchmark relevant options:");
			hashcat_ctx.event_log_info("===========================");
			if (user_options.getBenchmark_all() == 1) {
				hashcat_ctx.event_log_info("* --benchmark-all");
			} 
			if (user_options.getForce() == 1) {
				hashcat_ctx.event_log_info("* --force");
			} 
			if (user_options.getBackend_devices()) {
				hashcat_ctx.event_log_info("* --backend-devices=%s", user_options.getBackend_devices());
			} 
			if (user_options.getOpencl_device_types()) {
				hashcat_ctx.event_log_info("* --opencl-device-types=%s", user_options.getOpencl_device_types());
			} 
			if (user_options.getOptimized_kernel_enable() == 1) {
				hashcat_ctx.event_log_info("* --optimized-kernel-enable");
			} 
			if (user_options.getBackend_vector_width_chgd() == 1) {
				hashcat_ctx.event_log_info("* --backend-vector-width=%u", user_options.getBackend_vector_width());
			} 
			if (user_options.getKernel_accel_chgd() == 1) {
				hashcat_ctx.event_log_info("* --kernel-accel=%u", user_options.getKernel_accel());
			}  else if (user_options.getKernel_loops_chgd() == 1) {
				hashcat_ctx.event_log_info("* --kernel-loops=%u", user_options.getKernel_loops());
			}  else if (user_options.getKernel_threads_chgd() == 1) {
				hashcat_ctx.event_log_info("* --kernel-threads=%u", user_options.getKernel_threads());
			} else {
					if (user_options.getWorkload_profile_chgd() == 1) {
						hashcat_ctx.event_log_info("* --workload-profile=%u", user_options.getWorkload_profile());
					} 
			} 
			hashcat_ctx.event_log_info((null));
		} else {
				if (user_options.getBenchmark_all() == 1) {
					hashcat_ctx.event_log_info("# option: --benchmark-all");
				} 
				if (user_options.getForce() == 1) {
					hashcat_ctx.event_log_info("# option: --force");
				} 
				if (user_options.getBackend_devices()) {
					hashcat_ctx.event_log_info("# option: --backend-devices=%s", user_options.getBackend_devices());
				} 
				if (user_options.getOpencl_device_types()) {
					hashcat_ctx.event_log_info("# option: --opencl-device-types=%s", user_options.getOpencl_device_types());
				} 
				if (user_options.getOptimized_kernel_enable() == 1) {
					hashcat_ctx.event_log_info("# option: --optimized-kernel-enable");
				} 
				if (user_options.getBackend_vector_width_chgd() == 1) {
					hashcat_ctx.event_log_info("# option: --backend-vector-width=%u", user_options.getBackend_vector_width());
				} 
				if (user_options.getKernel_accel_chgd() == 1) {
					hashcat_ctx.event_log_info("# option: --kernel-accel=%u", user_options.getKernel_accel());
				}  else if (user_options.getKernel_loops_chgd() == 1) {
					hashcat_ctx.event_log_info("# option: --kernel-loops=%u", user_options.getKernel_loops());
				}  else if (user_options.getKernel_threads_chgd() == 1) {
					hashcat_ctx.event_log_info("# option: --kernel-threads=%u", user_options.getKernel_threads());
				} else {
						if (user_options.getWorkload_profile_chgd() == 1) {
							hashcat_ctx.event_log_info("# option: --workload-profile=%u", user_options.getWorkload_profile());
						} 
				} 
		} 
	}
	public void user_options_extra_init() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		// attack-kern
		user_options_extra.setAttack_kern(attack_kern.ATTACK_KERN_NONE);
		Object generatedAttack_mode = user_options.getAttack_mode();
		switch (generatedAttack_mode) {
		case attack_mode.ATTACK_MODE_COMBI:
				user_options_extra.setAttack_kern(attack_kern.ATTACK_KERN_COMBI);
				break;
		case attack_mode.ATTACK_MODE_HYBRID2:
				user_options_extra.setAttack_kern(attack_kern.ATTACK_KERN_COMBI);
				break;
		case attack_mode.ATTACK_MODE_HYBRID1:
				user_options_extra.setAttack_kern(attack_kern.ATTACK_KERN_COMBI);
				break;
		case attack_mode.ATTACK_MODE_STRAIGHT:
				user_options_extra.setAttack_kern(attack_kern.ATTACK_KERN_STRAIGHT);
				break;
		case attack_mode.ATTACK_MODE_BF:
				user_options_extra.setAttack_kern(attack_kern.ATTACK_KERN_BF);
				break;
		}
		Object generatedRule_buf_l = user_options.getRule_buf_l();
		// rules// rulesuser_options_extra.setRule_len_l((int)/*Error: Function owner not recognized*/strlen(generatedRule_buf_l));
		Object generatedRule_buf_r = user_options.getRule_buf_r();
		user_options_extra.setRule_len_r((int)/*Error: Function owner not recognized*/strlen(generatedRule_buf_r))// hc_hash and hc_work*;// hc_hash and hc_work*
		user_options_extra.setHc_hash((null));
		user_options_extra.setHc_workv((null));
		user_options_extra.setHc_workc(0);
		boolean generatedBenchmark = user_options.getBenchmark();
		boolean generatedExample_hashes = user_options.getExample_hashes();
		boolean generatedBackend_info = user_options.getBackend_info();
		boolean generatedKeyspace = user_options.getKeyspace();
		int generatedHc_argc = user_options.getHc_argc();
		byte[][] generatedHc_argv = user_options.getHc_argv();
		boolean generatedStdout_flag = user_options.getStdout_flag();
		if (generatedBenchmark == true) {
		}  else if (generatedExample_hashes == true) {
		}  else if (generatedBackend_info == true) {
		}  else if (generatedKeyspace == true) {
			user_options_extra.setHc_workc(generatedHc_argc);
			user_options_extra.setHc_workv(generatedHc_argv);
		}  else if (generatedStdout_flag == true) {
			user_options_extra.setHc_workc(generatedHc_argc);
			user_options_extra.setHc_workv(generatedHc_argv);
		} else {
				user_options_extra.setHc_hash(generatedHc_argv[0]);
				user_options_extra.setHc_workc(generatedHc_argc - 1);
				user_options_extra.setHc_workv(generatedHc_argv + 1);
		} 
		// wordlist_mode// wordlist_modeuser_options_extra.setWordlist_mode(wl_mode.WL_MODE_NONE);
		Object generatedAttack_kern = user_options_extra.getAttack_kern();
		int generatedHc_workc = user_options_extra.getHc_workc();
		if (generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
			user_options_extra.setWordlist_mode((generatedHc_workc >= 1) ? wl_mode.WL_MODE_FILE : wl_mode.WL_MODE_STDIN);
		}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
			user_options_extra.setWordlist_mode(wl_mode.WL_MODE_FILE);
		}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_BF) {
			user_options_extra.setWordlist_mode(wl_mode.WL_MODE_MASK);
		} 
	}
	public void user_options_extra_destroy() {
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(user_options_extra, 0, /*Error: Unsupported expression*/);
	}
	public Object user_options_extra_amplifier() {
		combinator_ctx generatedCombinator_ctx = this.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		if (user_options.getSlow_candidates() == 1) {
			return 1;
		} 
		if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_STRAIGHT) {
			if (straight_ctx.getKernel_rules_cnt()) {
				return straight_ctx.getKernel_rules_cnt();
			} 
		}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_COMBI) {
			if (combinator_ctx.getCombs_cnt()) {
				return combinator_ctx.getCombs_cnt();
			} 
		}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_BF) {
			if (mask_ctx.getBfs_cnt()) {
				return mask_ctx.getBfs_cnt();
			} 
		} 
		return 1;
	}
	public int user_options_check_files() {
		dictstat_ctx generatedDictstat_ctx = this.getDictstat_ctx();
		dictstat_ctx_t dictstat_ctx = generatedDictstat_ctx;
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		outcheck_ctx generatedOutcheck_ctx = this.getOutcheck_ctx();
		outcheck_ctx_t outcheck_ctx = generatedOutcheck_ctx;
		outfile_ctx generatedOutfile_ctx = this.getOutfile_ctx();
		outfile_ctx_t outfile_ctx = generatedOutfile_ctx;
		pidfile_ctx generatedPidfile_ctx = this.getPidfile_ctx();
		pidfile_ctx_t pidfile_ctx = generatedPidfile_ctx;
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		potfile_ctx_t potfile_ctx = generatedPotfile_ctx;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		// brain
		// common foldersif (ModernizedCProgram.hc_path_read(".") == 0) {
			hashcat_ctx.event_log_error("%s: %s", ".", /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		Byte generatedInstall_dir = folder_config.getInstall_dir();
		if (ModernizedCProgram.hc_path_read(generatedInstall_dir) == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedInstall_dir, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		Byte generatedProfile_dir = folder_config.getProfile_dir();
		if (ModernizedCProgram.hc_path_read(generatedProfile_dir) == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedProfile_dir, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		Byte generatedSession_dir = folder_config.getSession_dir();
		if (ModernizedCProgram.hc_path_write(generatedSession_dir) == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedSession_dir, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		Byte generatedShared_dir = folder_config.getShared_dir();
		if (ModernizedCProgram.hc_path_read(generatedShared_dir) == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedShared_dir, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		Byte generatedCpath_real = folder_config.getCpath_real();
		if (ModernizedCProgram.hc_path_read(generatedCpath_real) == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedCpath_real, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		Byte generatedHc_hash = user_options_extra.getHc_hash();
		// hashfile - can be NULLif (generatedHc_hash != (null)) {
			if (ModernizedCProgram.hc_path_exist(generatedHc_hash) == 1) {
				if (ModernizedCProgram.hc_path_is_directory(generatedHc_hash) == 1) {
					hashcat_ctx.event_log_error("%s: A directory cannot be used as a hashfile argument.", generatedHc_hash);
					return -1;
				} 
				if (ModernizedCProgram.hc_path_read(generatedHc_hash) == 0) {
					hashcat_ctx.event_log_error("%s: %s", generatedHc_hash, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				if (ModernizedCProgram.hc_path_has_bom(generatedHc_hash) == 1) {
					hashcat_ctx.event_log_error("%s: Byte Order Mark (BOM) was detected", generatedHc_hash);
					return -1;
				} 
			} 
		} 
		Object generatedAttack_mode = user_options.getAttack_mode();
		int generatedHc_workc = user_options_extra.getHc_workc();
		byte[][] generatedHc_workv = user_options_extra.getHc_workv();
		Object generatedRp_files_cnt = user_options.getRp_files_cnt();
		byte[][] generatedRp_files = user_options.getRp_files();
		// arguments - checks must depend on attack_modeif (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
			for (int i = 0;
			 i < generatedHc_workc; i++) {
				Byte wlfile = generatedHc_workv[i];
				if (ModernizedCProgram.hc_path_exist(wlfile) == 0) {
					hashcat_ctx.event_log_error("%s: %s", wlfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
			}
			for (int i = 0;
			 i < (int)generatedRp_files_cnt; i++) {
				Byte rp_file = generatedRp_files[i];
				if (ModernizedCProgram.hc_path_exist(rp_file) == 0) {
					hashcat_ctx.event_log_error("%s: %s", rp_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				if (ModernizedCProgram.hc_path_is_directory(rp_file) == 1) {
					hashcat_ctx.event_log_error("%s: A directory cannot be used as a rulefile argument.", rp_file);
					return -1;
				} 
				if (ModernizedCProgram.hc_path_read(rp_file) == 0) {
					hashcat_ctx.event_log_error("%s: %s", rp_file, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				if (ModernizedCProgram.hc_path_has_bom(rp_file) == 1) {
					hashcat_ctx.event_log_error("%s: Byte Order Mark (BOM) was detected", rp_file);
					return -1;
				} 
			}
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
			if (generatedHc_workc == 2) {
				Byte dictfile1 = generatedHc_workv[0];
				Byte dictfile2 = generatedHc_workv[1];
				if (ModernizedCProgram.hc_path_exist(dictfile1) == 0) {
					hashcat_ctx.event_log_error("%s: %s", dictfile1, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				if (ModernizedCProgram.hc_path_is_directory(dictfile1) == 1) {
					hashcat_ctx.event_log_error("%s: A directory cannot be used as a wordlist argument.", dictfile1);
					return -1;
				} 
				if (ModernizedCProgram.hc_path_read(dictfile1) == 0) {
					hashcat_ctx.event_log_error("%s: %s", dictfile1, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				if (ModernizedCProgram.hc_path_has_bom(dictfile1) == 1) {
					hashcat_ctx.event_log_error("%s: Byte Order Mark (BOM) was detected", dictfile1);
					return -1;
				} 
				if (ModernizedCProgram.hc_path_exist(dictfile2) == 0) {
					hashcat_ctx.event_log_error("%s: %s", dictfile2, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				if (ModernizedCProgram.hc_path_is_directory(dictfile2) == 1) {
					hashcat_ctx.event_log_error("%s: A directory cannot be used as a wordlist argument.", dictfile2);
					return -1;
				} 
				if (ModernizedCProgram.hc_path_read(dictfile2) == 0) {
					hashcat_ctx.event_log_error("%s: %s", dictfile2, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				if (ModernizedCProgram.hc_path_has_bom(dictfile2) == 1) {
					hashcat_ctx.event_log_error("%s: Byte Order Mark (BOM) was detected", dictfile2);
					return -1;
				} 
			} 
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
			if (generatedHc_workc == 1) {
				Byte maskfile = generatedHc_workv[0];
				if (ModernizedCProgram.hc_path_exist(maskfile) == 1) {
					if (ModernizedCProgram.hc_path_is_directory(maskfile) == 1) {
						hashcat_ctx.event_log_error("%s: A directory cannot be used as a maskfile argument.", maskfile);
						return -1;
					} 
					if (ModernizedCProgram.hc_path_read(maskfile) == 0) {
						hashcat_ctx.event_log_error("%s: %s", maskfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						return -1;
					} 
					if (ModernizedCProgram.hc_path_has_bom(maskfile) == 1) {
						hashcat_ctx.event_log_error("%s: Byte Order Mark (BOM) was detected", maskfile);
						return -1;
					} 
				} 
			} 
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
			if (generatedHc_workc == 2) {
				Byte wlfile = generatedHc_workv[0];
				Byte maskfile = generatedHc_workv[1];
				if (ModernizedCProgram.hc_path_exist(wlfile) == 0) {
					hashcat_ctx.event_log_error("%s: %s", wlfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				if (ModernizedCProgram.hc_path_exist(maskfile) == 1) {
					if (ModernizedCProgram.hc_path_is_directory(maskfile) == 1) {
						hashcat_ctx.event_log_error("%s: A directory cannot be used as a maskfile argument.", maskfile);
						return -1;
					} 
					if (ModernizedCProgram.hc_path_read(maskfile) == 0) {
						hashcat_ctx.event_log_error("%s: %s", maskfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						return -1;
					} 
					if (ModernizedCProgram.hc_path_has_bom(maskfile) == 1) {
						hashcat_ctx.event_log_error("%s: Byte Order Mark (BOM) was detected", maskfile);
						return -1;
					} 
				} 
			} 
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
			if (generatedHc_workc == 2) {
				Byte wlfile = generatedHc_workv[1];
				Byte maskfile = generatedHc_workv[0];
				if (ModernizedCProgram.hc_path_exist(wlfile) == 0) {
					hashcat_ctx.event_log_error("%s: %s", wlfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				if (ModernizedCProgram.hc_path_exist(maskfile) == 1) {
					if (ModernizedCProgram.hc_path_is_directory(maskfile) == 1) {
						hashcat_ctx.event_log_error("%s: A directory cannot be used as a maskfile argument.", maskfile);
						return -1;
					} 
					if (ModernizedCProgram.hc_path_read(maskfile) == 0) {
						hashcat_ctx.event_log_error("%s: %s", maskfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						return -1;
					} 
					if (ModernizedCProgram.hc_path_has_bom(maskfile) == 1) {
						hashcat_ctx.event_log_error("%s: Byte Order Mark (BOM) was detected", maskfile);
						return -1;
					} 
				} 
			} 
		} 
		boolean generatedEnabled = logfile_ctx.getEnabled();
		Byte generatedLogfile = logfile_ctx.getLogfile();
		// logfileif (generatedEnabled == true) {
			if (ModernizedCProgram.hc_path_exist(generatedLogfile) == 1) {
				if (ModernizedCProgram.hc_path_is_directory(generatedLogfile) == 1) {
					hashcat_ctx.event_log_error("%s: A directory cannot be used as a logfile argument.", generatedLogfile);
					return -1;
				} 
				if (ModernizedCProgram.hc_path_write(generatedLogfile) == 0) {
					hashcat_ctx.event_log_error("%s: %s", generatedLogfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
			} else {
					if (ModernizedCProgram.hc_path_create(generatedLogfile) == 0) {
						hashcat_ctx.event_log_error("%s: %s", generatedLogfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						return -1;
					} 
			} 
		} 
		Byte generatedRoot_directory = outcheck_ctx.getRoot_directory();
		// outfile_checkif (generatedEnabled == true) {
			if (ModernizedCProgram.hc_path_exist(generatedRoot_directory) == 1) {
				if (ModernizedCProgram.hc_path_is_directory(generatedRoot_directory) == 0) {
					hashcat_ctx.event_log_error("Directory specified in outfile-check '%s' is not a directory.", generatedRoot_directory);
					return -1;
				} 
			} 
		} 
		Byte generatedFilename = outfile_ctx.getFilename();
		// outfile - can be NULLif (generatedFilename != (null)) {
			if (ModernizedCProgram.hc_path_exist(generatedFilename) == 1) {
				if (ModernizedCProgram.hc_path_is_directory(generatedFilename) == 1) {
					hashcat_ctx.event_log_error("%s: A directory cannot be used as an outfile.", generatedFilename);
					return -1;
				} 
				if (ModernizedCProgram.hc_path_write(generatedFilename) == 0) {
					hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
			} else {
					if (ModernizedCProgram.hc_path_create(generatedFilename) == 0) {
						hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						return -1;
					} 
			} 
		} 
		// check for outfile vs. hashfileif (ModernizedCProgram.hc_same_files(generatedFilename, generatedHc_hash) == 1) {
			hashcat_ctx.event_log_error("Outfile and hashfile cannot point to the same file.");
			return -1;
		} 
		// check for outfile vs. cached wordlistsif (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
			for (int i = 0;
			 i < generatedHc_workc; i++) {
				Byte wlfile = generatedHc_workv[i];
				if (ModernizedCProgram.hc_same_files(generatedFilename, wlfile) == 1) {
					hashcat_ctx.event_log_error("Outfile and wordlist cannot point to the same file.");
					return -1;
				} 
			}
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
			if (generatedHc_workc == 2) {
				Byte dictfile1 = generatedHc_workv[0];
				Byte dictfile2 = generatedHc_workv[1];
				if (ModernizedCProgram.hc_same_files(generatedFilename, dictfile1) == 1) {
					hashcat_ctx.event_log_error("Outfile and wordlist cannot point to the same file.");
					return -1;
				} 
				if (ModernizedCProgram.hc_same_files(generatedFilename, dictfile2) == 1) {
					hashcat_ctx.event_log_error("Outfile and wordlist cannot point to the same file.");
					return -1;
				} 
			} 
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
			if (generatedHc_workc == 2) {
				Byte wlfile = generatedHc_workv[0];
				if (ModernizedCProgram.hc_same_files(generatedFilename, wlfile) == 1) {
					hashcat_ctx.event_log_error("Outfile and wordlist cannot point to the same file.");
					return -1;
				} 
			} 
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
			if (generatedHc_workc == 2) {
				Byte wlfile = generatedHc_workv[1];
				if (ModernizedCProgram.hc_same_files(generatedFilename, wlfile) == 1) {
					hashcat_ctx.event_log_error("Outfile and wordlist cannot point to the same file.");
					return -1;
				} 
			} 
		} 
		// pidfileif (ModernizedCProgram.hc_path_exist(generatedFilename) == 1) {
			if (ModernizedCProgram.hc_path_is_directory(generatedFilename) == 1) {
				hashcat_ctx.event_log_error("%s: A directory cannot be used as a pidfile argument.", generatedFilename);
				return -1;
			} 
			if (ModernizedCProgram.hc_path_write(generatedFilename) == 0) {
				hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
				return -1;
			} 
		} else {
				if (ModernizedCProgram.hc_path_create(generatedFilename) == 0) {
					hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
		} 
		// potfileif (generatedEnabled == true) {
			if (ModernizedCProgram.hc_path_exist(generatedFilename) == 1) {
				if (ModernizedCProgram.hc_path_is_directory(generatedFilename) == 1) {
					hashcat_ctx.event_log_error("%s: A directory cannot be used as a potfile argument.", generatedFilename);
					return -1;
				} 
				if (ModernizedCProgram.hc_path_write(generatedFilename) == 0) {
					hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
			} else {
					if (ModernizedCProgram.hc_path_create(generatedFilename) == 0) {
						hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						return -1;
					} 
			} 
		} 
		// dictstatif (generatedEnabled == true) {
			if (ModernizedCProgram.hc_path_exist(generatedFilename) == 1) {
				if (ModernizedCProgram.hc_path_is_directory(generatedFilename) == 1) {
					hashcat_ctx.event_log_error("%s: A directory cannot be used as a dictstat argument.", generatedFilename);
					return -1;
				} 
				if (ModernizedCProgram.hc_path_write(generatedFilename) == 0) {
					hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
			} else {
					if (ModernizedCProgram.hc_path_create(generatedFilename) == 0) {
						hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						return -1;
					} 
			} 
		} 
		// single kernel and module existence check to detect "7z e" errorsByte modulefile = (byte)ModernizedCProgram.hcmalloc(-1024);
		ModernizedCProgram.module_filename(folder_config, 0, modulefile, -1024);
		if (ModernizedCProgram.hc_path_exist(modulefile) == 0) {
			hashcat_ctx.event_log_error("%s: %s", modulefile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			hashcat_ctx.event_log_warning("If you are using the hashcat binary package this error typically indicates a problem during extraction.");
			hashcat_ctx.event_log_warning("For example, using \"7z e\" instead of using \"7z x\".");
			hashcat_ctx.event_log_warning((null));
			return -1;
		} 
		int rc = hashcat_ctx.hashconfig_init();
		if (rc == -1) {
			return -1;
		} 
		hashcat_ctx.hashconfig_destroy();
		ModernizedCProgram.hcfree(modulefile)// same check but for an backend kernel;// same check but for an backend kernel
		Byte kernelfile = (byte)ModernizedCProgram.hcmalloc(-1024);
		ModernizedCProgram.generate_source_kernel_filename(0, attack_exec.ATTACK_EXEC_OUTSIDE_KERNEL, attack_kern.ATTACK_KERN_STRAIGHT, 400, 0, generatedShared_dir, kernelfile);
		if (ModernizedCProgram.hc_path_read(kernelfile) == 0) {
			hashcat_ctx.event_log_error("%s: %s", kernelfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			hashcat_ctx.event_log_warning("If you are using the hashcat binary package this error typically indicates a problem during extraction.");
			hashcat_ctx.event_log_warning("For example, using \"7z e\" instead of using \"7z x\".");
			hashcat_ctx.event_log_warning((null));
			return -1;
		} 
		ModernizedCProgram.hcfree(kernelfile)// loopback - can't check at this point// tuning file check already done;// loopback - can't check at this point// tuning file check already done
		Byte generatedKeyboard_layout_mapping = user_options.getKeyboard_layout_mapping();
		// debugfile check already done// dictstatif (generatedKeyboard_layout_mapping != (null)) {
			if (ModernizedCProgram.hc_path_exist(generatedKeyboard_layout_mapping) == 1) {
				if (ModernizedCProgram.hc_path_read(generatedKeyboard_layout_mapping) == 0) {
					hashcat_ctx.event_log_error("%s: %s", generatedKeyboard_layout_mapping, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
			} else {
					hashcat_ctx.event_log_error("%s: %s", generatedKeyboard_layout_mapping, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
			} 
		} 
		if (/*Error: Function owner not recognized*/chdir(generatedCpath_real) == -/**
		   * default building options
		   */1) {
			hashcat_ctx.event_log_error("%s: %s", generatedCpath_real, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		// this test needs to be done manually because of macOS opencl runtime// if there's a problem with permission, its not reporting back and erroring out silentlybyte[][] files_names = new byte[][]{"inc_cipher_aes.cl", "inc_cipher_serpent.cl", "inc_cipher_twofish.cl", "inc_common.cl", "inc_comp_multi_bs.cl", "inc_comp_multi.cl", "inc_comp_single_bs.cl", "inc_comp_single.cl", "inc_rp_optimized.cl", "inc_rp_optimized.h", "inc_simd.cl", "inc_scalar.cl", "inc_types.h", "inc_vendor.h", (null)};
		for (int i = 0;
		 files_names[i] != (null); i++) {
			if (ModernizedCProgram.hc_path_read(files_names[i]) == 0) {
				hashcat_ctx.event_log_error("%s: %s", files_names[i], /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
				return -1;
			} 
		}
		// return back to the folder we came from initially (workaround)if (/*Error: Function owner not recognized*/chdir("..") == -1) {
			hashcat_ctx.event_log_error("%s: %s", "..", /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		return 0;
	}
	public void user_options_logger() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		Byte generatedTopid = logfile_ctx.getTopid();
		byte generatedSeparator = user_options.getSeparator();
		hashcat_ctx.logfile_append("%s\t%s\t%c", generatedTopid, ("user_options->separator"), (byte)((generatedSeparator)));
		;
		;
		Byte generatedCpu_affinity = user_options.getCpu_affinity();
		if (((generatedCpu_affinity)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->cpu_affinity"), ((generatedCpu_affinity)));
		} 
		;
		;
		Object generatedCustom_charset_1 = user_options.getCustom_charset_1();
		if (((generatedCustom_charset_1)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->custom_charset_1"), ((generatedCustom_charset_1)));
		} 
		;
		;
		Object generatedCustom_charset_2 = user_options.getCustom_charset_2();
		if (((generatedCustom_charset_2)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->custom_charset_2"), ((generatedCustom_charset_2)));
		} 
		;
		;
		Object generatedCustom_charset_3 = user_options.getCustom_charset_3();
		if (((generatedCustom_charset_3)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->custom_charset_3"), ((generatedCustom_charset_3)));
		} 
		;
		;
		Byte generatedCustom_charset_4 = user_options.getCustom_charset_4();
		if (((generatedCustom_charset_4)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->custom_charset_4"), ((generatedCustom_charset_4)));
		} 
		;
		;
		Byte generatedDebug_file = user_options.getDebug_file();
		if (((generatedDebug_file)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->debug_file"), ((generatedDebug_file)));
		} 
		;
		;
		Object generatedEncoding_from = user_options.getEncoding_from();
		if (((generatedEncoding_from)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->encoding_from"), ((generatedEncoding_from)));
		} 
		;
		;
		Object generatedEncoding_to = user_options.getEncoding_to();
		if (((generatedEncoding_to)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->encoding_to"), ((generatedEncoding_to)));
		} 
		;
		;
		Byte generatedInduction_dir = user_options.getInduction_dir();
		if (((generatedInduction_dir)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->induction_dir"), ((generatedInduction_dir)));
		} 
		;
		;
		Byte generatedKeyboard_layout_mapping = user_options.getKeyboard_layout_mapping();
		if (((generatedKeyboard_layout_mapping)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->keyboard_layout_mapping"), ((generatedKeyboard_layout_mapping)));
		} 
		;
		;
		Byte generatedMarkov_hcstat2 = user_options.getMarkov_hcstat2();
		if (((generatedMarkov_hcstat2)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->markov_hcstat2"), ((generatedMarkov_hcstat2)));
		} 
		;
		;
		Byte generatedBackend_devices = user_options.getBackend_devices();
		if (((generatedBackend_devices)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->backend_devices"), ((generatedBackend_devices)));
		} 
		;
		;
		Byte generatedOpencl_device_types = user_options.getOpencl_device_types();
		if (((generatedOpencl_device_types)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->opencl_device_types"), ((generatedOpencl_device_types)));
		} 
		;
		;
		Byte generatedOutfile = user_options.getOutfile();
		if (((generatedOutfile)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->outfile"), ((generatedOutfile)));
		} 
		;
		;
		Byte generatedOutfile_check_dir = user_options.getOutfile_check_dir();
		if (((generatedOutfile_check_dir)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->outfile_check_dir"), ((generatedOutfile_check_dir)));
		} 
		;
		;
		Byte generatedPotfile_path = user_options.getPotfile_path();
		if (((generatedPotfile_path)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->potfile_path"), ((generatedPotfile_path)));
		} 
		;
		;
		Byte generatedRestore_file_path = user_options.getRestore_file_path();
		if (((generatedRestore_file_path)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->restore_file_path"), ((generatedRestore_file_path)));
		} 
		;
		;
		byte[][] generatedRp_files = user_options.getRp_files();
		if (((generatedRp_files[0])) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->rp_files[0]"), ((generatedRp_files[0])));
		} 
		;
		;
		Object generatedRule_buf_l = user_options.getRule_buf_l();
		if (((generatedRule_buf_l)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->rule_buf_l"), ((generatedRule_buf_l)));
		} 
		;
		;
		Object generatedRule_buf_r = user_options.getRule_buf_r();
		if (((generatedRule_buf_r)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->rule_buf_r"), ((generatedRule_buf_r)));
		} 
		;
		;
		Object generatedSession = user_options.getSession();
		if (((generatedSession)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->session"), ((generatedSession)));
		} 
		;
		;
		Byte generatedTruecrypt_keyfiles = user_options.getTruecrypt_keyfiles();
		if (((generatedTruecrypt_keyfiles)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->truecrypt_keyfiles"), ((generatedTruecrypt_keyfiles)));
		} 
		;
		;
		Byte generatedVeracrypt_keyfiles = user_options.getVeracrypt_keyfiles();
		if (((generatedVeracrypt_keyfiles)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("user_options->veracrypt_keyfiles"), ((generatedVeracrypt_keyfiles)));
		} 
		;
		;
		Object generatedLimit = user_options.getLimit();
		hashcat_ctx.logfile_append("%s\t%s\t%I64u", generatedTopid, ("user_options->limit"), (u64)((generatedLimit)));
		;
		;
		Object generatedSkip = user_options.getSkip();
		hashcat_ctx.logfile_append("%s\t%s\t%I64u", generatedTopid, ("user_options->skip"), (u64)((generatedSkip)));
		;
		;
		Object generatedAttack_mode = user_options.getAttack_mode();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->attack_mode"), (u32)((generatedAttack_mode)));
		;
		;
		boolean generatedBenchmark = user_options.getBenchmark();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->benchmark"), (u32)((generatedBenchmark)));
		;
		;
		boolean generatedBenchmark_all = user_options.getBenchmark_all();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->benchmark_all"), (u32)((generatedBenchmark_all)));
		;
		;
		Object generatedBitmap_max = user_options.getBitmap_max();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->bitmap_max"), (u32)((generatedBitmap_max)));
		;
		;
		Object generatedBitmap_min = user_options.getBitmap_min();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->bitmap_min"), (u32)((generatedBitmap_min)));
		;
		;
		Object generatedDebug_mode = user_options.getDebug_mode();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->debug_mode"), (u32)((generatedDebug_mode)));
		;
		;
		boolean generatedExample_hashes = user_options.getExample_hashes();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->example_hashes"), (u32)((generatedExample_hashes)));
		;
		;
		boolean generatedForce = user_options.getForce();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->force"), (u32)((generatedForce)));
		;
		;
		boolean generatedHwmon_disable = user_options.getHwmon_disable();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->hwmon_disable"), (u32)((generatedHwmon_disable)));
		;
		;
		Object generatedHwmon_temp_abort = user_options.getHwmon_temp_abort();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->hwmon_temp_abort"), (u32)((generatedHwmon_temp_abort)));
		;
		;
		int generatedHash_mode = user_options.getHash_mode();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->hash_mode"), (u32)((generatedHash_mode)));
		;
		;
		boolean generatedHex_charset = user_options.getHex_charset();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->hex_charset"), (u32)((generatedHex_charset)));
		;
		;
		boolean generatedHex_salt = user_options.getHex_salt();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->hex_salt"), (u32)((generatedHex_salt)));
		;
		;
		boolean generatedHex_wordlist = user_options.getHex_wordlist();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->hex_wordlist"), (u32)((generatedHex_wordlist)));
		;
		;
		boolean generatedIncrement = user_options.getIncrement();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->increment"), (u32)((generatedIncrement)));
		;
		;
		Object generatedIncrement_max = user_options.getIncrement_max();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->increment_max"), (u32)((generatedIncrement_max)));
		;
		;
		Object generatedIncrement_min = user_options.getIncrement_min();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->increment_min"), (u32)((generatedIncrement_min)));
		;
		;
		boolean generatedKeep_guessing = user_options.getKeep_guessing();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->keep_guessing"), (u32)((generatedKeep_guessing)));
		;
		;
		Object generatedKernel_accel = user_options.getKernel_accel();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->kernel_accel"), (u32)((generatedKernel_accel)));
		;
		;
		Object generatedKernel_loops = user_options.getKernel_loops();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->kernel_loops"), (u32)((generatedKernel_loops)));
		;
		;
		Object generatedKernel_threads = user_options.getKernel_threads();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->kernel_threads"), (u32)((generatedKernel_threads)));
		;
		;
		boolean generatedKeyspace = user_options.getKeyspace();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->keyspace"), (u32)((generatedKeyspace)));
		;
		;
		boolean generatedLeft = user_options.getLeft();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->left"), (u32)((generatedLeft)));
		;
		;
		boolean generatedLogfile_disable = user_options.getLogfile_disable();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->logfile_disable"), (u32)((generatedLogfile_disable)));
		;
		;
		boolean generatedLoopback = user_options.getLoopback();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->loopback"), (u32)((generatedLoopback)));
		;
		;
		boolean generatedMachine_readable = user_options.getMachine_readable();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->machine_readable"), (u32)((generatedMachine_readable)));
		;
		;
		boolean generatedMarkov_classic = user_options.getMarkov_classic();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->markov_classic"), (u32)((generatedMarkov_classic)));
		;
		;
		boolean generatedMarkov_disable = user_options.getMarkov_disable();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->markov_disable"), (u32)((generatedMarkov_disable)));
		;
		;
		Object generatedMarkov_threshold = user_options.getMarkov_threshold();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->markov_threshold"), (u32)((generatedMarkov_threshold)));
		;
		;
		boolean generatedBackend_info = user_options.getBackend_info();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->backend_info"), (u32)((generatedBackend_info)));
		;
		;
		Object generatedBackend_vector_width = user_options.getBackend_vector_width();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->backend_vector_width"), (u32)((generatedBackend_vector_width)));
		;
		;
		boolean generatedOptimized_kernel_enable = user_options.getOptimized_kernel_enable();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->optimized_kernel_enable"), (u32)((generatedOptimized_kernel_enable)));
		;
		;
		boolean generatedOutfile_autohex = user_options.getOutfile_autohex();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->outfile_autohex"), (u32)((generatedOutfile_autohex)));
		;
		;
		Object generatedOutfile_check_timer = user_options.getOutfile_check_timer();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->outfile_check_timer"), (u32)((generatedOutfile_check_timer)));
		;
		;
		Object generatedOutfile_format = user_options.getOutfile_format();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->outfile_format"), (u32)((generatedOutfile_format)));
		;
		;
		boolean generatedWordlist_autohex_disable = user_options.getWordlist_autohex_disable();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->wordlist_autohex_disable"), (u32)((generatedWordlist_autohex_disable)));
		;
		;
		boolean generatedPotfile_disable = user_options.getPotfile_disable();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->potfile_disable"), (u32)((generatedPotfile_disable)));
		;
		;
		boolean generatedProgress_only = user_options.getProgress_only();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->progress_only"), (u32)((generatedProgress_only)));
		;
		;
		boolean generatedQuiet = user_options.getQuiet();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->quiet"), (u32)((generatedQuiet)));
		;
		;
		boolean generatedRemove = user_options.getRemove();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->remove"), (u32)((generatedRemove)));
		;
		;
		Object generatedRemove_timer = user_options.getRemove_timer();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->remove_timer"), (u32)((generatedRemove_timer)));
		;
		;
		boolean generatedRestore = user_options.getRestore();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->restore"), (u32)((generatedRestore)));
		;
		;
		boolean generatedRestore_disable = user_options.getRestore_disable();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->restore_disable"), (u32)((generatedRestore_disable)));
		;
		;
		Object generatedRestore_timer = user_options.getRestore_timer();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->restore_timer"), (u32)((generatedRestore_timer)));
		;
		;
		Object generatedRp_files_cnt = user_options.getRp_files_cnt();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->rp_files_cnt"), (u32)((generatedRp_files_cnt)));
		;
		;
		Object generatedRp_gen = user_options.getRp_gen();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->rp_gen"), (u32)((generatedRp_gen)));
		;
		;
		Object generatedRp_gen_func_max = user_options.getRp_gen_func_max();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->rp_gen_func_max"), (u32)((generatedRp_gen_func_max)));
		;
		;
		Object generatedRp_gen_func_min = user_options.getRp_gen_func_min();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->rp_gen_func_min"), (u32)((generatedRp_gen_func_min)));
		;
		;
		Object generatedRp_gen_seed = user_options.getRp_gen_seed();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->rp_gen_seed"), (u32)((generatedRp_gen_seed)));
		;
		;
		Object generatedRuntime = user_options.getRuntime();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->runtime"), (u32)((generatedRuntime)));
		;
		;
		Object generatedScrypt_tmto = user_options.getScrypt_tmto();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->scrypt_tmto"), (u32)((generatedScrypt_tmto)));
		;
		;
		Object generatedSegment_size = user_options.getSegment_size();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->segment_size"), (u32)((generatedSegment_size)));
		;
		;
		boolean generatedSelf_test_disable = user_options.getSelf_test_disable();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->self_test_disable"), (u32)((generatedSelf_test_disable)));
		;
		;
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->slow_candidates"), (u32)((generatedSlow_candidates)));
		;
		;
		boolean generatedShow = user_options.getShow();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->show"), (u32)((generatedShow)));
		;
		;
		boolean generatedSpeed_only = user_options.getSpeed_only();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->speed_only"), (u32)((generatedSpeed_only)));
		;
		;
		Object generatedSpin_damp = user_options.getSpin_damp();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->spin_damp"), (u32)((generatedSpin_damp)));
		;
		;
		boolean generatedStatus = user_options.getStatus();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->status"), (u32)((generatedStatus)));
		;
		;
		boolean generatedStatus_json = user_options.getStatus_json();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->status_json"), (u32)((generatedStatus_json)));
		;
		;
		Object generatedStatus_timer = user_options.getStatus_timer();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->status_timer"), (u32)((generatedStatus_timer)));
		;
		;
		boolean generatedStdout_flag = user_options.getStdout_flag();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->stdout_flag"), (u32)((generatedStdout_flag)));
		;
		;
		boolean generatedUsage = user_options.getUsage();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->usage"), (u32)((generatedUsage)));
		;
		;
		boolean generatedUsername = user_options.getUsername();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->username"), (u32)((generatedUsername)));
		;
		;
		Object generatedVeracrypt_pim_start = user_options.getVeracrypt_pim_start();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->veracrypt_pim_start"), (u32)((generatedVeracrypt_pim_start)));
		;
		;
		Object generatedVeracrypt_pim_stop = user_options.getVeracrypt_pim_stop();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->veracrypt_pim_stop"), (u32)((generatedVeracrypt_pim_stop)));
		;
		;
		boolean generatedVersion = user_options.getVersion();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->version"), (u32)((generatedVersion)));
		;
		;
		Object generatedWorkload_profile = user_options.getWorkload_profile();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("user_options->workload_profile"), (u32)((generatedWorkload_profile)));
		;
		;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public void loopback_format_plain(Object[] plain_ptr, Object plain_len) {
		loopback_ctx generatedLoopback_ctx = this.getLoopback_ctx();
		loopback_ctx_t loopback_ctx = generatedLoopback_ctx;
		boolean generatedEnabled = loopback_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		int needs_hexify = 0;
		for (u32 i = 0;
		 i < plain_len; i++) {
			if (plain_ptr[i] < -1024) {
				needs_hexify = 1;
				break;
			} 
			if (plain_ptr[i] > -1024) {
				needs_hexify = 1;
				break;
			} 
		}
		hc_fp generatedFp = loopback_ctx.getFp();
		if (needs_hexify == 1) {
			generatedFp.hc_fprintf("$HEX[");
			for (u32 i = 0;
			 i < plain_len; i++) {
				generatedFp.hc_fprintf("%02x", plain_ptr[i]);
			}
			generatedFp.hc_fprintf("]");
		} else {
				generatedFp.hc_fwrite((Object)plain_ptr, plain_len, 1);
		} 
	}
	public int loopback_init() {
		loopback_ctx generatedLoopback_ctx = this.getLoopback_ctx();
		loopback_ctx_t loopback_ctx = generatedLoopback_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		loopback_ctx.setEnabled(0);
		boolean generatedBenchmark = user_options.getBenchmark();
		if (generatedBenchmark == true) {
			return 0;
		} 
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedStdout_flag = user_options.getStdout_flag();
		if (generatedStdout_flag == true) {
			return 0;
		} 
		boolean generatedSpeed_only = user_options.getSpeed_only();
		if (generatedSpeed_only == true) {
			return 0;
		} 
		boolean generatedProgress_only = user_options.getProgress_only();
		if (generatedProgress_only == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		loopback_ctx.setEnabled(1);
		hc_fp generatedFp = loopback_ctx.getFp();
		generatedFp.setPfp((null));
		loopback_ctx.setFilename((byte)ModernizedCProgram.hcmalloc(-1024));
		return 0;
	}
	public void loopback_destroy() {
		loopback_ctx generatedLoopback_ctx = this.getLoopback_ctx();
		loopback_ctx_t loopback_ctx = generatedLoopback_ctx;
		boolean generatedEnabled = loopback_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(loopback_ctx, 0, /*Error: Unsupported expression*/);
	}
	public int loopback_write_open() {
		induct_ctx generatedInduct_ctx = this.getInduct_ctx();
		induct_ctx_t induct_ctx = generatedInduct_ctx;
		loopback_ctx generatedLoopback_ctx = this.getLoopback_ctx();
		loopback_ctx_t loopback_ctx = generatedLoopback_ctx;
		boolean generatedEnabled = loopback_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		if (generatedEnabled == false) {
			return 0;
		} 
		time_t now = new time_t();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/time(now);
		u32 random_num = ModernizedCProgram.get_random_num(0, 9999);
		Byte generatedFilename = loopback_ctx.getFilename();
		Byte generatedRoot_directory = induct_ctx.getRoot_directory();
		ModernizedCProgram.hc_asprintf(generatedFilename, "%s/%s.%d_%u", generatedRoot_directory, ModernizedCProgram.LOOPBACK_FILE, (int)now, random_num);
		hc_fp generatedFp = loopback_ctx.getFp();
		if (generatedFp.hc_fopen(generatedFilename, "ab") == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		loopback_ctx.setUnused(1);
		return 0;
	}
	public void loopback_write_unlink() {
		loopback_ctx generatedLoopback_ctx = this.getLoopback_ctx();
		loopback_ctx_t loopback_ctx = generatedLoopback_ctx;
		boolean generatedEnabled = loopback_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		Byte generatedFilename = loopback_ctx.getFilename();
		if (generatedFilename == (null)) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(generatedFilename);
	}
	public void loopback_write_close() {
		loopback_ctx generatedLoopback_ctx = this.getLoopback_ctx();
		loopback_ctx_t loopback_ctx = generatedLoopback_ctx;
		boolean generatedEnabled = loopback_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		hc_fp generatedFp = loopback_ctx.getFp();
		_iobuf generatedPfp = generatedFp.getPfp();
		if (generatedPfp == (null)) {
			return /*Error: Unsupported expression*/;
		} 
		generatedFp.hc_fclose();
		boolean generatedUnused = loopback_ctx.getUnused();
		if (generatedUnused == true) {
			hashcat_ctx.loopback_write_unlink();
		} 
	}
	public void loopback_write_append(Object plain_ptr, Object plain_len) {
		loopback_ctx generatedLoopback_ctx = this.getLoopback_ctx();
		loopback_ctx_t loopback_ctx = generatedLoopback_ctx;
		boolean generatedEnabled = loopback_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.loopback_format_plain(plain_ptr, plain_len);
		hc_fp generatedFp = loopback_ctx.getFp();
		generatedFp.hc_lockfile();
		generatedFp.hc_fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1);
		generatedFp.hc_fflush();
		Byte generatedFilename = loopback_ctx.getFilename();
		if (generatedFp.hc_unlockfile()) {
			hashcat_ctx.event_log_error("%s: Failed to unlock file", generatedFilename);
		} 
		loopback_ctx.setUnused(0);
	}
	public void main_log_advice(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getAdvice_disable() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		ModernizedCProgram.main_log(hashcat_ctx, (_iob[1]), loglevel.LOGLEVEL_ADVICE);
	}
	public void main_log_info(Object buf, Object len) {
		ModernizedCProgram.main_log(hashcat_ctx, (_iob[1]), loglevel.LOGLEVEL_INFO);
	}
	public void main_log_warning(Object buf, Object len) {
		ModernizedCProgram.main_log(hashcat_ctx, (_iob[1]), loglevel.LOGLEVEL_WARNING);
	}
	public void main_log_error(Object buf, Object len) {
		ModernizedCProgram.main_log(hashcat_ctx, (_iob[2]), loglevel.LOGLEVEL_ERROR);
	}
	public void main_outerloop_starting(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		hashcat_user generatedHashcat_user = this.getHashcat_user();
		hashcat_user_t hashcat_user = generatedHashcat_user;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		hashcat_user.setOuter_threads_cnt(0);
		hashcat_user.setOuter_threads((hc_thread_t)ModernizedCProgram.hccalloc(2, /*Error: Unsupported expression*/));
		Object[] generatedOuter_threads = hashcat_user.getOuter_threads();
		if (generatedOuter_threads == (null)) {
			return /*Error: Unsupported expression*/;
		} 
		status_ctx.setShutdown_outer(0);
		int generatedOuter_threads_cnt = hashcat_user.getOuter_threads_cnt();
		if ((user_options.getExample_hashes() == 0) && (user_options.getKeyspace() == 0) && (user_options.getStdout_flag() == 0) && (user_options.getBackend_info() == 0) && (user_options.getSpeed_only() == 0)) {
			if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
				generatedOuter_threads[generatedOuter_threads_cnt] = /*Error: Function owner not recognized*/CreateThread((null), 0, (LPTHREAD_START_ROUTINE)ModernizedCProgram.thread_keypress, hashcat_ctx, 0, (null));
				generatedOuter_threads_cnt++;
			} 
		} 
	}
	public void main_outerloop_finished(Object buf, Object len) {
		hashcat_user generatedHashcat_user = this.getHashcat_user();
		hashcat_user_t hashcat_user = generatedHashcat_user;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		// we should never stop hashcat with STATUS_INIT:
		Object generatedDevices_status = status_ctx.getDevices_status();
		// keypress thread blocks on STATUS_INIT forever!if (generatedDevices_status == status_rc.STATUS_INIT) {
			status_ctx.setDevices_status(status_rc.STATUS_ERROR);
		} 
		// wait for outer threads// wait for outer threadsstatus_ctx.setShutdown_outer(1);
		int generatedOuter_threads_cnt = hashcat_user.getOuter_threads_cnt();
		Object[] generatedOuter_threads = hashcat_user.getOuter_threads();
		for (int thread_idx = 0;
		 thread_idx < generatedOuter_threads_cnt; thread_idx++) {
			for (int i = 0;
			 i < 1; i++) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject((generatedOuter_threads[thread_idx])[i], -1024);
			}
		}
		ModernizedCProgram.hcfree(generatedOuter_threads);
		hashcat_user.setOuter_threads_cnt(0);
	}
	public void main_cracker_starting(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		// Tell the user we're about to start
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			if ((user_options.getQuiet() == 0) && (user_options.getSpeed_only() == 0)) {
				hashcat_ctx.event_log_info_nn((null));
				hashcat_ctx.send_prompt();
			} 
		}  else if (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_STDIN) {
			hashcat_ctx.event_log_info("Starting attack in stdin mode...");
			hashcat_ctx.event_log_info((null));
		} 
	}
	public void main_cracker_finished(Object buf, Object len) {
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		if (user_options.getExample_hashes() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getKeyspace() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getBackend_info() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if (user_options.getStdout_flag() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		// if we had a prompt, clear it
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			if ((user_options.getSpeed_only() == 0) && (user_options.getQuiet() == 0)) {
				hashcat_ctx.clear_prompt();
			} 
		} 
		// print final statusif (user_options.getBenchmark() == 1) {
			hashcat_ctx.status_benchmark();
			if (user_options.getMachine_readable() == 0) {
				hashcat_ctx.event_log_info((null));
			} 
		}  else if (user_options.getProgress_only() == 1) {
			hashcat_ctx.status_progress();
			if (user_options.getMachine_readable() == 0) {
				hashcat_ctx.event_log_info((null));
			} 
		}  else if (user_options.getSpeed_only() == 1) {
			hashcat_ctx.status_speed();
			if (user_options.getMachine_readable() == 0) {
				hashcat_ctx.event_log_info((null));
			} 
		}  else if (user_options.getMachine_readable() == 1) {
			hashcat_ctx.status_display();
		}  else if (user_options.getStatus() == 1) {
			hashcat_ctx.status_display();
		} else {
				if (user_options.getQuiet() == 0) {
					if (hashes.getDigests_saved() != hashes.getDigests_done()) {
						hashcat_ctx.event_log_info((null));
					} 
					hashcat_ctx.status_display();
					hashcat_ctx.event_log_info((null));
				} 
		} 
	}
	public void main_cracker_hash_cracked(Object buf, Object len) {
		outfile_ctx generatedOutfile_ctx = this.getOutfile_ctx();
		outfile_ctx_t outfile_ctx = generatedOutfile_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		hc_fp generatedFp = outfile_ctx.getFp();
		_iobuf generatedPfp = generatedFp.getPfp();
		// cracked hash was not written to an outfileif (generatedPfp != (null)) {
			return /*Error: Unsupported expression*/;
		} 
		Object generatedWordlist_mode = user_options_extra.getWordlist_mode();
		Byte generatedFilename = outfile_ctx.getFilename();
		boolean generatedQuiet = user_options.getQuiet();
		if ((generatedWordlist_mode == wl_mode.WL_MODE_FILE) || (generatedWordlist_mode == wl_mode.WL_MODE_MASK)) {
			if (generatedFilename == (null)) {
				if (generatedQuiet == false) {
					hashcat_ctx.clear_prompt();
				} 
			} 
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite(buf, len, 1, (_iob[1]));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1, (_iob[1]));
		Object generatedDevices_status = status_ctx.getDevices_status();
		if ((generatedWordlist_mode == wl_mode.WL_MODE_FILE) || (generatedWordlist_mode == wl_mode.WL_MODE_MASK)) {
			if (generatedDevices_status != status_rc.STATUS_CRACKED) {
				if (generatedFilename == (null)) {
					if (generatedQuiet == false) {
						hashcat_ctx.send_prompt();
					} 
				} 
			} 
		} 
	}
	public void main_calculated_words_base(Object buf, Object len) {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getKeyspace() == 0) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info("%I64u", status_ctx.getWords_base());
	}
	public void main_potfile_remove_parse_pre(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Comparing hashes with potfile entries...");
	}
	public void main_potfile_remove_parse_post(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Compared hashes with potfile entries...");
	}
	public void main_potfile_hash_show(Object buf, Object len) {
		outfile_ctx generatedOutfile_ctx = this.getOutfile_ctx();
		outfile_ctx_t outfile_ctx = generatedOutfile_ctx;
		hc_fp generatedFp = outfile_ctx.getFp();
		_iobuf generatedPfp = generatedFp.getPfp();
		// cracked hash was not written to an outfileif (generatedPfp != (null)) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite(buf, len, 1, (_iob[1]));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1, (_iob[1]));
	}
	public void main_potfile_hash_left(Object buf, Object len) {
		outfile_ctx generatedOutfile_ctx = this.getOutfile_ctx();
		outfile_ctx_t outfile_ctx = generatedOutfile_ctx;
		hc_fp generatedFp = outfile_ctx.getFp();
		_iobuf generatedPfp = generatedFp.getPfp();
		// cracked hash was not written to an outfileif (generatedPfp != (null)) {
			return /*Error: Unsupported expression*/;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite(buf, len, 1, (_iob[1]));
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1, (_iob[1]));
	}
	public void main_potfile_num_cracked(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		int potfile_remove_cracks = hashes.getDigests_done();
		if (potfile_remove_cracks > 0) {
			if (potfile_remove_cracks == 1) {
				hashcat_ctx.event_log_info("INFO: Removed 1 hash found in potfile.");
				hashcat_ctx.event_log_info((null));
			} else {
					hashcat_ctx.event_log_info("INFO: Removed %d hashes found in potfile.", potfile_remove_cracks);
					hashcat_ctx.event_log_info((null));
			} 
		} 
	}
	public void main_potfile_all_cracked(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info("INFO: All hashes found in potfile! Use --show to display them.");
		hashcat_ctx.event_log_info((null));
	}
	public void main_outerloop_mainscreen(Object buf, Object len) {
		bitmap_ctx generatedBitmap_ctx = this.getBitmap_ctx();
		bitmap_ctx_t bitmap_ctx = generatedBitmap_ctx;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t[] hashes = generatedHashes;
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getBenchmark() == 1) {
			if (user_options.getMachine_readable() == 0) {
				if ((hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_OUTSIDE_KERNEL) && (hashconfig.getIs_salted() == 1)) {
					hashcat_ctx.event_log_info("Hashmode: %d - %s (Iterations: %d)", hashconfig.getHash_mode(), hashconfig.getHash_name(), hashes[0].getSalts_buf()[0].getSalt_iter());
				} else {
						hashcat_ctx.event_log_info("Hashmode: %d - %s", hashconfig.getHash_mode(), hashconfig.getHash_name());
				} 
				hashcat_ctx.event_log_info((null));
			} 
		} 
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info("Hashes: %u digests; %u unique digests, %u unique salts", hashes.getHashes_cnt_orig(), hashes.getDigests_cnt(), hashes.getSalts_cnt());
		hashcat_ctx.event_log_info("Bitmaps: %u bits, %u entries, 0x%08x mask, %u bytes, %u/%u rotates", bitmap_ctx.getBitmap_bits(), bitmap_ctx.getBitmap_nums(), bitmap_ctx.getBitmap_mask(), bitmap_ctx.getBitmap_size(), bitmap_ctx.getBitmap_shift1(), bitmap_ctx.getBitmap_shift2());
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
			hashcat_ctx.event_log_info("Rules: %u", straight_ctx.getKernel_rules_cnt());
		} 
		if (user_options.getQuiet() == 0) {
			hashcat_ctx.event_log_info((null));
		} 
		if (hashconfig.getOpti_type()) {
			hashcat_ctx.event_log_info("Applicable optimizers:");
			for (u32 i = 0;
			 i < 32; i++) {
				u32 opti_bit = -1024 << i;
				if (hashconfig.getOpti_type() & opti_bit) {
					hashcat_ctx.event_log_info("* %s", ModernizedCProgram.stroptitype(opti_bit));
				} 
			}
		} 
		hashcat_ctx.event_log_info((null));
		hashcat_ctx.event_log_info("Minimum password length supported by kernel: %u", hashconfig.getPw_min());
		hashcat_ctx.event_log_info("Maximum password length supported by kernel: %u", hashconfig.getPw_max());
		if (hashconfig.getIs_salted() == 1) {
			if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_RAW_HASH) {
				hashcat_ctx.event_log_info("Minimim salt length supported by kernel: %u", hashconfig.getSalt_min());
				hashcat_ctx.event_log_info("Maximum salt length supported by kernel: %u", hashconfig.getSalt_max());
			} 
		} 
		hashcat_ctx.event_log_info((null));
		if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) {
			if (hashconfig.getHas_optimized_kernel() == 1) {
				hashcat_ctx.event_log_advice("ATTENTION! Pure (unoptimized) backend kernels selected.");
				hashcat_ctx.event_log_advice("Using pure kernels enables cracking longer passwords but for the price of drastically reduced performance.");
				hashcat_ctx.event_log_advice("If you want to switch to optimized backend kernels, append -O to your commandline.");
				hashcat_ctx.event_log_advice("See the above message to find out about the exact limits.");
				hashcat_ctx.event_log_advice((null));
			} 
		} 
		if (user_options.getKeep_guessing() == 1) {
			hashcat_ctx.event_log_advice("ATTENTION! --keep-guessing mode is enabled.");
			hashcat_ctx.event_log_advice("This tells hashcat to continue attacking all target hashes until exhaustion.");
			hashcat_ctx.event_log_advice("hashcat will NOT check for or remove targets present in the potfile, and");
			hashcat_ctx.event_log_advice("will add ALL plains/collisions found, even duplicates, to the potfile.");
			hashcat_ctx.event_log_advice((null));
		} 
		if (hwmon_ctx.getEnabled() == 0) {
			hashcat_ctx.event_log_info("Watchdog: Hardware monitoring interface not found on your system.");
		} 
		if (hwmon_ctx.getEnabled() == 1 && user_options.getHwmon_temp_abort() > 0) {
			hashcat_ctx.event_log_info("Watchdog: Temperature abort trigger set to %uc", user_options.getHwmon_temp_abort());
		} else {
				hashcat_ctx.event_log_info("Watchdog: Temperature abort trigger disabled.");
		} 
		hashcat_ctx.event_log_info((null));
	}
	public void main_backend_session_pre(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Initializing device kernels and memory...");
	}
	public void main_backend_session_post(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Initialized device kernels and memory...");
	}
	public void main_backend_session_hostmem(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		u64 hostmem = (u64)buf;
		hashcat_ctx.event_log_info("Host memory required for this attack: %I64u MB", hostmem / (1024 * 1024));
		hashcat_ctx.event_log_info((null));
	}
	public void main_backend_device_init_pre(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		u32 device_id = (u32)buf;
		hashcat_ctx.event_log_info_nn("Initializing backend runtime for device #%u...", device_id + 1);
	}
	public void main_backend_device_init_post(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		u32 device_id = (u32)buf;
		hashcat_ctx.event_log_info_nn("Initialized backend runtime for device #%u...", device_id + 1);
	}
	public void main_bitmap_init_pre(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Generating bitmap tables...");
	}
	public void main_bitmap_init_post(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Generated bitmap tables...");
	}
	public void main_bitmap_final_overflow(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_advice("Bitmap table overflowed at %d bits.", user_options.getBitmap_max());
		hashcat_ctx.event_log_advice("This typically happens with too many hashes and reduces your performance.");
		hashcat_ctx.event_log_advice("You can increase the bitmap table size with --bitmap-max, but");
		hashcat_ctx.event_log_advice("this creates a trade-off between L2-cache and bitmap efficiency.");
		hashcat_ctx.event_log_advice("It is therefore not guaranteed to restore full performance.");
		hashcat_ctx.event_log_advice((null));
	}
	public void main_set_kernel_power_final(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.clear_prompt();
		hashcat_ctx.event_log_advice("Approaching final keyspace - workload adjusted.");
		hashcat_ctx.event_log_advice((null));
		hashcat_ctx.send_prompt();
	}
	public void main_monitor_throttle1(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			hashcat_ctx.clear_prompt();
		} 
		u32 device_id = (u32)buf;
		hashcat_ctx.event_log_warning("Driver temperature threshold met on GPU #%u. Expect reduced performance.", device_id + 1);
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			hashcat_ctx.send_prompt();
		} 
	}
	public void main_monitor_throttle2(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			hashcat_ctx.clear_prompt();
		} 
		u32 device_id = (u32)buf;
		hashcat_ctx.event_log_warning("Driver temperature threshold met on GPU #%u. Expect reduced performance.", device_id + 1);
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			hashcat_ctx.send_prompt();
		} 
	}
	public void main_monitor_throttle3(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			hashcat_ctx.clear_prompt();
		} 
		u32 device_id = (u32)buf;
		hashcat_ctx.event_log_warning("Driver temperature threshold met on GPU #%u. Expect reduced performance.", device_id + 1);
		hashcat_ctx.event_log_warning((null));
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			hashcat_ctx.send_prompt();
		} 
	}
	public void main_monitor_performance_hint(Object buf, Object len) {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			hashcat_ctx.clear_prompt();
		} 
		hashcat_ctx.event_log_advice("Cracking performance lower than expected?");
		hashcat_ctx.event_log_advice((null));
		if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) {
			if (hashconfig.getHas_optimized_kernel() == 1) {
				hashcat_ctx.event_log_advice("* Append -O to the commandline.");
				hashcat_ctx.event_log_advice("  This lowers the maximum supported password- and salt-length (typically down to 32).");
				hashcat_ctx.event_log_advice((null));
			} 
		} 
		if (user_options.getWorkload_profile() < 3) {
			hashcat_ctx.event_log_advice("* Append -w 3 to the commandline.");
			hashcat_ctx.event_log_advice("  This can cause your screen to lag.");
			hashcat_ctx.event_log_advice((null));
		} 
		hashcat_ctx.event_log_advice("* Update your backend API runtime / driver the right way:");
		hashcat_ctx.event_log_advice("  https://hashcat.net/faq/wrongdriver");
		hashcat_ctx.event_log_advice((null));
		hashcat_ctx.event_log_advice("* Create more work items to make use of your parallelization power:");
		hashcat_ctx.event_log_advice("  https://hashcat.net/faq/morework");
		hashcat_ctx.event_log_advice((null));
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			hashcat_ctx.send_prompt();
		} 
	}
	public void main_monitor_noinput_hint(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_advice("ATTENTION! Read timeout in stdin mode. The password candidates input is too slow:");
		hashcat_ctx.event_log_advice("* Are you sure that you are using the correct attack mode (--attack-mode or -a)?");
		hashcat_ctx.event_log_advice("* Are you sure that you want to use input from standard input (stdin)?");
		hashcat_ctx.event_log_advice("* If so, are you sure that the input from stdin (the pipe) is working correctly and is fast enough?");
		hashcat_ctx.event_log_advice((null));
	}
	public void main_monitor_noinput_abort(Object buf, Object len) {
		hashcat_ctx.event_log_error("No password candidates received in stdin mode, aborting...");
	}
	public void main_monitor_temp_abort(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			hashcat_ctx.clear_prompt();
		} 
		u32 device_id = (u32)buf;
		hashcat_ctx.event_log_error("Temperature limit on GPU #%u reached, aborting...", device_id + 1);
	}
	public void main_monitor_runtime_limit(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			hashcat_ctx.clear_prompt();
		} 
		hashcat_ctx.event_log_warning("Runtime limit reached, aborting...");
	}
	public void main_monitor_status_refresh(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		if (status_ctx.getAccessible() == 0) {
			return /*Error: Unsupported expression*/;
		} 
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			if (user_options.getQuiet() == 0) {
				hashcat_ctx.event_log_info((null));
				hashcat_ctx.event_log_info((null));
			} 
		} 
		hashcat_ctx.status_display();
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			if (user_options.getQuiet() == 0) {
				hashcat_ctx.event_log_info((null));
				hashcat_ctx.send_prompt();
			} 
		} 
		if (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_STDIN) {
			if (user_options.getQuiet() == 0) {
				hashcat_ctx.event_log_info((null));
			} 
		} 
	}
	public void main_wordlist_cache_hit(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		cache_hit_t cache_hit = (cache_hit_t)buf;
		hashcat_ctx.event_log_info("Dictionary cache hit:");
		hashcat_ctx.event_log_info("* Filename..: %s", cache_hit.getDictfile());
		hashcat_ctx.event_log_info("* Passwords.: %I64u", cache_hit.getCached_cnt());
		hashcat_ctx.event_log_info("* Bytes.....: %I64d", cache_hit.getStat().getSt_size());
		hashcat_ctx.event_log_info("* Keyspace..: %I64u", cache_hit.getKeyspace());
		hashcat_ctx.event_log_info((null));
	}
	public void main_wordlist_cache_generate(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		cache_generate_t cache_generate = (cache_generate_t)buf;
		if (cache_generate.getPercent() < 100) {
			hashcat_ctx.event_log_info_nn("Dictionary cache building %s: %I64u bytes (%.2f%%)", cache_generate.getDictfile(), cache_generate.getComp(), cache_generate.getPercent());
		} else {
				Byte runtime = (byte)ModernizedCProgram.hcmalloc(-1024);
				time_t runtime_sec = cache_generate.getRuntime();
				tm tmp = new tm();
				tm tm = new tm();
				tmp = /*Error: Function owner not recognized*/gmtime_r(runtime_sec, tm);
				tmp.format_timer_display(runtime, -1024);
				hashcat_ctx.event_log_info("Dictionary cache built:");
				hashcat_ctx.event_log_info("* Filename..: %s", cache_generate.getDictfile());
				hashcat_ctx.event_log_info("* Passwords.: %I64u", cache_generate.getCnt2());
				hashcat_ctx.event_log_info("* Bytes.....: %I64d", cache_generate.getComp());
				hashcat_ctx.event_log_info("* Keyspace..: %I64u", cache_generate.getCnt());
				hashcat_ctx.event_log_info("* Runtime...: %s", runtime);
				hashcat_ctx.event_log_info((null));
				ModernizedCProgram.hcfree(runtime);
		} 
	}
	public void main_hashlist_count_lines_pre(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		Byte hashfile = (byte)buf;
		hashcat_ctx.event_log_info_nn("Counting lines in %s...", hashfile);
	}
	public void main_hashlist_count_lines_post(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		Byte hashfile = (byte)buf;
		hashcat_ctx.event_log_info_nn("Counted lines in %s...", hashfile);
	}
	public void main_hashlist_parse_hash(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashlist_parse_t hashlist_parse = (hashlist_parse_t)buf;
		u64 hashes_cnt = hashlist_parse.getHashes_cnt();
		u64 hashes_avail = hashlist_parse.getHashes_avail();
		if (hashes_cnt < hashes_avail) {
			hashcat_ctx.event_log_info_nn("Parsing Hashes: %I64u/%I64u (%0.2f%%)...", hashes_cnt, hashes_avail, ((double)hashes_cnt / hashes_avail) * 100.0);
		} else {
				hashcat_ctx.event_log_info_nn("Parsed Hashes: %I64u/%I64u (%0.2f%%)", hashes_cnt, hashes_avail, 100.0);
		} 
	}
	public void main_hashlist_sort_hash_pre(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Sorting hashes...");
	}
	public void main_hashlist_sort_hash_post(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Sorted hashes...");
	}
	public void main_hashlist_unique_hash_pre(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Removing duplicate hashes...");
	}
	public void main_hashlist_unique_hash_post(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Removed duplicate hashes...");
	}
	public void main_hashlist_sort_salt_pre(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Sorting salts...");
	}
	public void main_hashlist_sort_salt_post(Object buf, Object len) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getQuiet() == 1) {
			return /*Error: Unsupported expression*/;
		} 
		hashcat_ctx.event_log_info_nn("Sorted salts...");
	}
	public void event(Object id, Object buf, Object len) {
		switch (id) {
		case event_identifier.EVENT_CALCULATED_WORDS_BASE:
				hashcat_ctx.main_calculated_words_base(buf, len);
				break;
		case event_identifier.EVENT_BACKEND_DEVICE_INIT_POST:
				hashcat_ctx.main_backend_device_init_post(buf, len);
				break;
		case event_identifier.EVENT_POTFILE_REMOVE_PARSE_POST:
				hashcat_ctx.main_potfile_remove_parse_post(buf, len);
				break;
		case event_identifier.EVENT_BITMAP_INIT_POST:
				hashcat_ctx.main_bitmap_init_post(buf, len);
				break;
		case event_identifier.EVENT_HASHLIST_SORT_HASH_POST:
				hashcat_ctx.main_hashlist_sort_hash_post(buf, len);
				break;
		case event_identifier.EVENT_CRACKER_HASH_CRACKED:
				hashcat_ctx.main_cracker_hash_cracked(buf, len);
				break;
		case event_identifier.EVENT_POTFILE_HASH_SHOW:
				hashcat_ctx.main_potfile_hash_show(buf, len);
				break;
		case event_identifier.EVENT_HASHLIST_SORT_SALT_POST:
				hashcat_ctx.main_hashlist_sort_salt_post(buf, len);
				break;
		case event_identifier.EVENT_CRACKER_STARTING:
				hashcat_ctx.main_cracker_starting(buf, len);
				break;
		case event_identifier.EVENT_BITMAP_INIT_PRE:
				hashcat_ctx.main_bitmap_init_pre(buf, len);
				break;
		case event_identifier.EVENT_MONITOR_THROTTLE1:
				hashcat_ctx.main_monitor_throttle1(buf, len);
				break;
		case event_identifier.EVENT_HASHLIST_SORT_SALT_PRE:
				hashcat_ctx.main_hashlist_sort_salt_pre(buf, len);
				break;
		case event_identifier.EVENT_LOG_INFO:
				hashcat_ctx.main_log_info(buf, len);
				break;
		case event_identifier.EVENT_BACKEND_SESSION_PRE:
				hashcat_ctx.main_backend_session_pre(buf, len);
				break;
		case event_identifier.EVENT_WORDLIST_CACHE_GENERATE:
				hashcat_ctx.main_wordlist_cache_generate(buf, len);
				break;
		case event_identifier.EVENT_POTFILE_ALL_CRACKED:
				hashcat_ctx.main_potfile_all_cracked(buf, len);
				break;
		case event_identifier.EVENT_BACKEND_SESSION_HOSTMEM:
				hashcat_ctx.main_backend_session_hostmem(buf, len);
				break;
		case event_identifier.EVENT_POTFILE_HASH_LEFT:
				hashcat_ctx.main_potfile_hash_left(buf, len);
				break;
		case event_identifier.EVENT_MONITOR_PERFORMANCE_HINT:
				hashcat_ctx.main_monitor_performance_hint(buf, len);
				break;
		case event_identifier.EVENT_SET_KERNEL_POWER_FINAL:
				hashcat_ctx.main_set_kernel_power_final(buf, len);
				break;
		case event_identifier.EVENT_LOG_WARNING:
				hashcat_ctx.main_log_warning(buf, len);
				break;
		case event_identifier.EVENT_BITMAP_FINAL_OVERFLOW:
				hashcat_ctx.main_bitmap_final_overflow(buf, len);
				break;
		case event_identifier.EVENT_HASHLIST_PARSE_HASH:
				hashcat_ctx.main_hashlist_parse_hash(buf, len);
				break;
		case event_identifier.EVENT_BACKEND_SESSION_POST:
				hashcat_ctx.main_backend_session_post(buf, len);
				break;
		case event_identifier.EVENT_OUTERLOOP_MAINSCREEN:
				hashcat_ctx.main_outerloop_mainscreen(buf, len);
				break;
		case event_identifier.EVENT_LOG_ERROR:
				hashcat_ctx.main_log_error(buf, len);
				break;
		case event_identifier.EVENT_CRACKER_FINISHED:
				hashcat_ctx.main_cracker_finished(buf, len);
				break;
		case event_identifier.EVENT_HASHLIST_UNIQUE_HASH_PRE:
				hashcat_ctx.main_hashlist_unique_hash_pre(buf, len);
				break;
		case event_identifier.EVENT_LOG_ADVICE:
				hashcat_ctx.main_log_advice(buf, len);
				break;
		case event_identifier.EVENT_MONITOR_STATUS_REFRESH:
				hashcat_ctx.main_monitor_status_refresh(buf, len);
				break;
		case event_identifier.EVENT_HASHLIST_SORT_HASH_PRE:
				hashcat_ctx.main_hashlist_sort_hash_pre(buf, len);
				break;
		case event_identifier.EVENT_HASHLIST_UNIQUE_HASH_POST:
				hashcat_ctx.main_hashlist_unique_hash_post(buf, len);
				break;
		case event_identifier.EVENT_MONITOR_THROTTLE2:
				hashcat_ctx.main_monitor_throttle2(buf, len);
				break;
		case event_identifier.EVENT_MONITOR_TEMP_ABORT:
				hashcat_ctx.main_monitor_temp_abort(buf, len);
				break;
		case event_identifier.EVENT_BACKEND_DEVICE_INIT_PRE:
				hashcat_ctx.main_backend_device_init_pre(buf, len);
				break;
		case event_identifier.EVENT_MONITOR_NOINPUT_HINT:
				hashcat_ctx.main_monitor_noinput_hint(buf, len);
				break;
		case event_identifier.EVENT_MONITOR_NOINPUT_ABORT:
				hashcat_ctx.main_monitor_noinput_abort(buf, len);
				break;
		case event_identifier.EVENT_MONITOR_THROTTLE3:
				hashcat_ctx.main_monitor_throttle3(buf, len);
				break;
		case event_identifier.EVENT_OUTERLOOP_FINISHED:
				hashcat_ctx.main_outerloop_finished(buf, len);
				break;
		case event_identifier.EVENT_MONITOR_RUNTIME_LIMIT:
				hashcat_ctx.main_monitor_runtime_limit(buf, len);
				break;
		case event_identifier.EVENT_HASHLIST_COUNT_LINES_PRE:
				hashcat_ctx.main_hashlist_count_lines_pre(buf, len);
				break;
		case event_identifier.EVENT_WORDLIST_CACHE_HIT:
				hashcat_ctx.main_wordlist_cache_hit(buf, len);
				break;
		case event_identifier.EVENT_POTFILE_NUM_CRACKED:
				hashcat_ctx.main_potfile_num_cracked(buf, len);
				break;
		case event_identifier.EVENT_HASHLIST_COUNT_LINES_POST:
				hashcat_ctx.main_hashlist_count_lines_post(buf, len);
				break;
		case event_identifier.EVENT_OUTERLOOP_STARTING:
				hashcat_ctx.main_outerloop_starting(buf, len);
				break;
		case event_identifier.EVENT_POTFILE_REMOVE_PARSE_PRE:
				hashcat_ctx.main_potfile_remove_parse_pre(buf, len);
				break;
		}
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public void debugfile_format_plain(Object[] plain_ptr, Object plain_len) {
		debugfile_ctx generatedDebugfile_ctx = this.getDebugfile_ctx();
		debugfile_ctx_t debugfile_ctx = generatedDebugfile_ctx;
		boolean generatedEnabled = debugfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		int needs_hexify = 0;
		for (u32 i = 0;
		 i < plain_len; i++) {
			if (plain_ptr[i] < -1024) {
				needs_hexify = 1;
				break;
			} 
			if (plain_ptr[i] > -1024) {
				needs_hexify = 1;
				break;
			} 
		}
		hc_fp generatedFp = debugfile_ctx.getFp();
		if (needs_hexify == 1) {
			generatedFp.hc_fprintf("$HEX[");
			for (u32 i = 0;
			 i < plain_len; i++) {
				generatedFp.hc_fprintf("%02x", plain_ptr[i]);
			}
			generatedFp.hc_fprintf("]");
		} else {
				generatedFp.hc_fwrite((Object)plain_ptr, plain_len, 1);
		} 
	}
	public void debugfile_write_append(Object rule_buf, Object rule_len, Object mod_plain_ptr, Object mod_plain_len, Object orig_plain_ptr, Object orig_plain_len) {
		debugfile_ctx generatedDebugfile_ctx = this.getDebugfile_ctx();
		debugfile_ctx_t debugfile_ctx = generatedDebugfile_ctx;
		boolean generatedEnabled = debugfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		Object generatedMode = debugfile_ctx.getMode();
		u32 debug_mode = generatedMode;
		hc_fp generatedFp = debugfile_ctx.getFp();
		if ((debug_mode == 2) || (debug_mode == 3) || (debug_mode == 4)) {
			hashcat_ctx.debugfile_format_plain(orig_plain_ptr, orig_plain_len);
			if ((debug_mode == 3) || (debug_mode == 4)) {
				generatedFp.hc_fputc((byte)':');
			} 
		} 
		generatedFp.hc_fwrite((Object)rule_buf, rule_len, 1);
		if (debug_mode == 4) {
			generatedFp.hc_fputc((byte)':');
			hashcat_ctx.debugfile_format_plain(mod_plain_ptr, mod_plain_len);
		} 
		generatedFp.hc_fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1);
	}
	public int debugfile_init() {
		debugfile_ctx generatedDebugfile_ctx = this.getDebugfile_ctx();
		debugfile_ctx_t debugfile_ctx = generatedDebugfile_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		debugfile_ctx.setEnabled(0);
		boolean generatedBenchmark = user_options.getBenchmark();
		if (generatedBenchmark == true) {
			return 0;
		} 
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedStdout_flag = user_options.getStdout_flag();
		if (generatedStdout_flag == true) {
			return 0;
		} 
		boolean generatedSpeed_only = user_options.getSpeed_only();
		if (generatedSpeed_only == true) {
			return 0;
		} 
		boolean generatedProgress_only = user_options.getProgress_only();
		if (generatedProgress_only == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		Object generatedDebug_mode = user_options.getDebug_mode();
		if (generatedDebug_mode == 0) {
			return 0;
		} 
		debugfile_ctx.setEnabled(1);
		debugfile_ctx.setMode(generatedDebug_mode);
		Byte generatedDebug_file = user_options.getDebug_file();
		debugfile_ctx.setFilename(generatedDebug_file);
		Byte generatedFilename = debugfile_ctx.getFilename();
		hc_fp generatedFp = debugfile_ctx.getFp();
		if (generatedFilename) {
			if (generatedFp.hc_fopen(generatedFilename, "ab") == 0) {
				hashcat_ctx.event_log_error("Could not open --debug-file file for writing.");
				return -1;
			} 
			if (generatedFp.hc_lockfile() == -1) {
				generatedFp.hc_fclose();
				hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
				return -1;
			} 
		} else {
				generatedFp.setIs_gzip(0);
				generatedFp.setPfp((_iob[1]));
				generatedFp.setFd((((_iob[1])).get_file()));
		} 
		return 0;
	}
	public void debugfile_destroy() {
		debugfile_ctx generatedDebugfile_ctx = this.getDebugfile_ctx();
		debugfile_ctx_t debugfile_ctx = generatedDebugfile_ctx;
		boolean generatedEnabled = debugfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		Byte generatedFilename = debugfile_ctx.getFilename();
		hc_fp generatedFp = debugfile_ctx.getFp();
		if (generatedFilename) {
			generatedFp.hc_fclose();
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(debugfile_ctx, 0, /*Error: Unsupported expression*/);
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public int set_cpu_affinity() {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		if (user_options.getCpu_affinity() == (null)) {
			return 0;
		} 
		DWORD_PTR aff_mask = 0;
		Byte devices = ModernizedCProgram.hcstrdup(user_options.getCpu_affinity());
		if (devices == (null)) {
			return -1;
		} 
		Byte saveptr = (null);
		Byte next = /*Error: Function owner not recognized*/strtok_r(devices, ",", saveptr);
		do {
			int cpu_id = (int)/*Error: Function owner not recognized*/strtol(next, (null), 10);
			if (cpu_id == 0) {
				aff_mask = 0;
				break;
			} 
			if (cpu_id > 32) {
				hashcat_ctx.event_log_error("Invalid cpu_id %d specified.", cpu_id);
				ModernizedCProgram.hcfree(devices);
				return -1;
			} 
			aff_mask |=  -1024 << (cpu_id - 1);
		} while ((next = /*Error: Function owner not recognized*/strtok_r((byte)(null), ",", saveptr)) != (null));
		ModernizedCProgram.hcfree(devices);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/SetProcessAffinityMask(/*Error: Function owner not recognized*/GetCurrentProcess(), aff_mask);
		if (/*Error: Function owner not recognized*/SetThreadAffinityMask(/*Error: Function owner not recognized*/GetCurrentThread(), aff_mask) == 0) {
			hashcat_ctx.event_log_error("%s", "SetThreadAffinityMask().");
			return -1;
		} 
		return 0;
	}
	public int save_hash() {
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		module_ctx generatedModule_ctx = this.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Object generatedHashfile = hashes.getHashfile();
		Byte hashfile = generatedHashfile;
		Byte new_hashfile;
		Byte old_hashfile;
		ModernizedCProgram.hc_asprintf(new_hashfile, "%s.new", hashfile);
		ModernizedCProgram.hc_asprintf(old_hashfile, "%s.old", hashfile);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(new_hashfile);
		byte generatedSeparator = hashconfig.getSeparator();
		byte separator = generatedSeparator;
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(new_hashfile, "wb") == 0) {
			hashcat_ctx.event_log_error("%s: %s", new_hashfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(new_hashfile);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(old_hashfile);
			return -1;
		} 
		if (fp.hc_lockfile() == -1) {
			fp.hc_fclose();
			hashcat_ctx.event_log_error("%s: %s", new_hashfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(new_hashfile);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(old_hashfile);
			return -1;
		} 
		u8[] out_buf = (u8)ModernizedCProgram.hcmalloc(-1024);
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		Object[] generatedSalts_shown = hashes.getSalts_shown();
		salt[] generatedSalts_buf = hashes.getSalts_buf();
		Object generatedDigests_cnt = salt_buf.getDigests_cnt();
		Object generatedDigests_offset = salt_buf.getDigests_offset();
		Object[] generatedDigests_shown = hashes.getDigests_shown();
		Object generatedModule_hash_binary_save = module_ctx.getModule_hash_binary_save();
		boolean generatedUsername = user_options.getUsername();
		hashinfo[][] generatedHash_info = hashes.getHash_info();
		Object generatedUser_len = user.getUser_len();
		byte[] generatedUser_name = user.getUser_name();
		for (u32 salt_pos = 0;
		 salt_pos < generatedSalts_cnt; salt_pos++) {
			if (generatedSalts_shown[salt_pos] == 1) {
				continue;
			} 
			salt_t salt_buf = generatedSalts_buf[salt_pos];
			for (u32 digest_pos = 0;
			 digest_pos < generatedDigests_cnt; digest_pos++) {
				u32 idx = generatedDigests_offset + digest_pos;
				if (generatedDigests_shown[idx] == 1) {
					continue;
				} 
				if (generatedModule_hash_binary_save != (Object)-1) {
					Byte binary_buf = (null);
					int binary_len = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashes, salt_pos, digest_pos, binary_buf);
					fp.hc_fwrite(binary_buf, binary_len, 1);
					ModernizedCProgram.hcfree(binary_buf);
				} else {
						if (generatedUsername == true) {
							user_t user = generatedHash_info[idx].getUser();
							u32 i = new u32();
							for (i = 0; i < generatedUser_len; i++) {
								fp.hc_fputc(generatedUser_name[i]);
							}
							fp.hc_fputc(separator);
						} 
						int out_len = ModernizedCProgram.hash_encode(generatedHashconfig, generatedHashes, generatedModule_ctx, (byte)out_buf, -1024, salt_pos, digest_pos);
						out_buf[out_len] = 0;
						fp.hc_fprintf("%s\r\n", out_buf);
				} 
			}
		}
		ModernizedCProgram.hcfree(out_buf);
		fp.hc_fflush();
		fp.hc_fclose();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(old_hashfile);
		if (/*Error: Function owner not recognized*/rename(hashfile, old_hashfile) != 0) {
			hashcat_ctx.event_log_error("Rename file '%s' to '%s': %s", hashfile, old_hashfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(new_hashfile);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(old_hashfile);
			return -1;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(hashfile);
		if (/*Error: Function owner not recognized*/rename(new_hashfile, hashfile) != 0) {
			hashcat_ctx.event_log_error("Rename file '%s' to '%s': %s", new_hashfile, hashfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(new_hashfile);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(old_hashfile);
			return -1;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(old_hashfile);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(new_hashfile);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/free(old_hashfile);
		return 0;
	}
	public int hashes_init_filename() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		Object generatedOpts_type = hashconfig.getOpts_type();
		boolean generatedBenchmark = user_options.getBenchmark();
		boolean generatedKeyspace = user_options.getKeyspace();
		Byte generatedHc_hash = user_options_extra.getHc_hash();
		Object generatedHashlist_mode = hashes.getHashlist_mode();
		if (generatedOpts_type & opts_type.OPTS_TYPE_BINARY_HASHFILE) {
			hashes.setHashlist_mode(hl_mode.HL_MODE_FILE_BINARY);
			if ((generatedBenchmark == false) && (generatedKeyspace == false)) {
				if (ModernizedCProgram.hc_path_read(generatedHc_hash) == 0) {
					hashcat_ctx.event_log_error("%s: %s", generatedHc_hash, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				hashes.setHashfile(generatedHc_hash);
			} 
		} else {
				hashes.setHashlist_mode((ModernizedCProgram.hc_path_exist(generatedHc_hash) == 1) ? hl_mode.HL_MODE_FILE_PLAIN : hl_mode.HL_MODE_ARG);
				if (generatedHashlist_mode == hl_mode.HL_MODE_FILE_PLAIN) {
					hashes.setHashfile(generatedHc_hash);
				} 
		} 
		return 0;
	}
	public int hashes_init_stage1() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		module_ctx generatedModule_ctx = this.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		Object generatedHashfile = hashes.getHashfile();
		Byte hashfile = generatedHashfile;
		Object generatedHashlist_mode = hashes.getHashlist_mode();
		u32 hashlist_mode = generatedHashlist_mode;
		u32 hashlist_format = hlfmt_name.HLFMT_HASHCAT;
		u64 hashes_avail = 0;
		boolean generatedBenchmark = user_options.getBenchmark();
		boolean generatedStdout_flag = user_options.getStdout_flag();
		boolean generatedKeyspace = user_options.getKeyspace();
		boolean generatedRemove = user_options.getRemove();
		Object generatedModule_hash_binary_count = module_ctx.getModule_hash_binary_count();
		if ((generatedBenchmark == false) && (generatedStdout_flag == false) && (generatedKeyspace == false)) {
			if (hashlist_mode == hl_mode.HL_MODE_ARG) {
				hashes_avail = 1;
			}  else if (hashlist_mode == hl_mode.HL_MODE_FILE_PLAIN) {
				HCFILE fp = new HCFILE();
				if (fp.hc_fopen(hashfile, "rb") == 0) {
					hashcat_ctx.event_log_error("%s: %s", hashfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				hashcat_ctx.event_call((event_identifier.EVENT_HASHLIST_COUNT_LINES_PRE), (hashfile), (/*Error: Function owner not recognized*/strlen(hashfile)));
				hashes_avail = fp.count_lines();
				hashcat_ctx.event_call((event_identifier.EVENT_HASHLIST_COUNT_LINES_POST), (hashfile), (/*Error: Function owner not recognized*/strlen(hashfile)));
				fp.hc_rewind();
				if (hashes_avail == 0) {
					hashcat_ctx.event_log_error("hashfile is empty or corrupt.");
					fp.hc_fclose();
					return -1;
				} 
				hashlist_format = ModernizedCProgram.hlfmt_detect(hashcat_ctx, fp, 100);
				fp.hc_fclose();
				if ((generatedRemove == true) && (hashlist_format != hlfmt_name.HLFMT_HASHCAT)) {
					hashcat_ctx.event_log_error("Use of --remove is not supported in native hashfile-format mode.");
					return -1;
				} 
			}  else if (hashlist_mode == hl_mode.HL_MODE_FILE_BINARY) {
				stat st = new stat();
				if (/*Error: Function owner not recognized*/stat(generatedHashfile, st) == -1) {
					hashcat_ctx.event_log_error("%s: %s", generatedHashfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				if (generatedModule_hash_binary_count != (Object)-1) {
					int binary_count = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashes);
					if (binary_count == 0) {
						hashcat_ctx.event_log_error("No hashes loaded.");
						return -1;
					} 
					if (binary_count == -1) {
						hashcat_ctx.event_log_error("%s: %s", generatedHashfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						return -1;
					} 
					hashes_avail = binary_count;
				} else {
						hashes_avail = 1;
				} 
			} 
		} else {
				hashes_avail = 1;
		} 
		Object generatedOpts_type = hashconfig.getOpts_type();
		if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_SPLIT) {
			hashes_avail *= 2;
		} 
		hashes.setHashlist_format(hashlist_format/**
		   * load hashes, part II: allocate required memory, set pointers
		   */);
		hash_t[] hashes_buf = (hash_t)ModernizedCProgram.hccalloc(hashes_avail, /*Error: Unsupported expression*/);
		Object generatedDgst_size = hashconfig.getDgst_size();
		Object digests_buf = ModernizedCProgram.hccalloc(hashes_avail, generatedDgst_size);
		salt_t[] salts_buf = (null);
		Object esalts_buf = (null);
		Object hook_salts_buf = (null);
		boolean generatedUsername = user_options.getUsername();
		if ((generatedUsername == true) || (generatedOpts_type & opts_type.OPTS_TYPE_HASH_COPY) || (generatedOpts_type & opts_type.OPTS_TYPE_HASH_SPLIT)) {
			u64 hash_pos = new u64();
			for (hash_pos = 0; hash_pos < hashes_avail; hash_pos++) {
				hashinfo_t hash_info = (hashinfo_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
				hashes_buf[hash_pos].setHash_info(hash_info);
				if (generatedUsername == true) {
					hash_info.setUser((user_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
				} 
				if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_COPY) {
					if (generatedBenchmark == false) {
						hash_info.setOrighash((byte)ModernizedCProgram.hcmalloc(256));
					} 
				} 
				if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_SPLIT) {
					hash_info.setSplit((split_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
				} 
			}
		} 
		boolean generatedIs_salted = hashconfig.getIs_salted();
		Object generatedEsalt_size = hashconfig.getEsalt_size();
		Object generatedHook_salt_size = hashconfig.getHook_salt_size();
		if (generatedIs_salted == true) {
			salts_buf = (salt_t)ModernizedCProgram.hccalloc(hashes_avail, /*Error: Unsupported expression*/);
			if (generatedEsalt_size > 0) {
				esalts_buf = ModernizedCProgram.hccalloc(hashes_avail, generatedEsalt_size);
			} 
			if (generatedHook_salt_size > 0) {
				hook_salts_buf = ModernizedCProgram.hccalloc(hashes_avail, generatedHook_salt_size);
			} 
		} else {
				salts_buf = (salt_t)ModernizedCProgram.hccalloc(1, /*Error: Unsupported expression*/);
		} 
		for (u64 hash_pos = 0;
		 hash_pos < hashes_avail; hash_pos++) {
			hashes_buf[hash_pos].setDigest(((byte)digests_buf) + (hash_pos * generatedDgst_size));
			if (generatedIs_salted == true) {
				hashes_buf[hash_pos].setSalt(salts_buf[hash_pos]);
				if (generatedEsalt_size > 0) {
					hashes_buf[hash_pos].setEsalt(((byte)esalts_buf) + (hash_pos * generatedEsalt_size));
				} 
				if (generatedHook_salt_size > 0) {
					hashes_buf[hash_pos].setHook_salt(((byte)hook_salts_buf) + (hash_pos * generatedHook_salt_size));
				} 
			} else {
					hashes_buf[hash_pos].setSalt(salts_buf[0]);
			} 
		}
		hashes.setHashes_buf(hashes_buf);
		hashes.setDigests_buf(digests_buf);
		hashes.setSalts_buf(salts_buf);
		hashes.setEsalts_buf(esalts_buf);
		hashes.setHook_salts_buf(hook_salts_buf/**
		   * load hashes, part III: parse hashes
		   */);
		u32 hashes_cnt = 0;
		boolean generatedExample_hashes = user_options.getExample_hashes();
		boolean generatedBackend_info = user_options.getBackend_info();
		Byte generatedHc_hash = user_options_extra.getHc_hash();
		Object generatedDigest = hash.getDigest();
		salt generatedSalt = hash.getSalt();
		Object generatedEsalt = hash.getEsalt();
		Object generatedHook_salt = hash.getHook_salt();
		hashinfo generatedHash_info = hash.getHash_info();
		split generatedSplit = generatedHash_info.getSplit();
		user generatedUser = generatedHash_info.getUser();
		Object generatedModule_hash_binary_parse = module_ctx.getModule_hash_binary_parse();
		if (generatedBenchmark == true) {
			hashes.setHashfile("-");
			hashes_cnt = 1;
		}  else if (generatedExample_hashes == true) {
		}  else if (generatedKeyspace == true) {
		}  else if (generatedStdout_flag == true) {
		}  else if (generatedBackend_info == true) {
		} else {
				if (hashlist_mode == hl_mode.HL_MODE_ARG) {
					Byte input_buf = generatedHc_hash;
					size_t input_len = /*Error: Function owner not recognized*/strlen(input_buf);
					Byte hash_buf = (null);
					int hash_len = 0;
					hashcat_ctx.hlfmt_hash(hashlist_format, input_buf, input_len, hash_buf, hash_len);
					boolean hash_fmt_error = false;
					if (hash_len < 1) {
						hash_fmt_error = true;
					} 
					if (hash_buf == (null)) {
						hash_fmt_error = true;
					} 
					if (hash_fmt_error) {
						hashcat_ctx.event_log_warning("Failed to parse hashes using the '%s' format.", ModernizedCProgram.strhlfmt(hashlist_format));
					} else {
							if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_COPY) {
								hashinfo_t hash_info_tmp = hashes_buf[hashes_cnt].getHash_info();
								hash_info_tmp.setOrighash(ModernizedCProgram.hcstrdup(hash_buf));
							} 
							if (generatedIs_salted == true) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(hashes_buf[0].getSalt(), 0, /*Error: Unsupported expression*/);
							} 
							if (generatedEsalt_size > 0) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(hashes_buf[0].getEsalt(), 0, generatedEsalt_size);
							} 
							if (generatedHook_salt_size > 0) {
								/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(hashes_buf[0].getHook_salt(), 0, generatedHook_salt_size);
							} 
							int parser_status = parser_rc.PARSER_OK;
							if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_SPLIT) {
								if (hash_len == 32) {
									hash_t hash = new hash_t();
									hash = hashes_buf[hashes_cnt];
									parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, hash_buf + 0, 16);
									if (parser_status == parser_rc.PARSER_OK) {
										generatedSplit.setSplit_group(0);
										generatedSplit.setSplit_origin(split_origin.SPLIT_ORIGIN_LEFT);
										hashes_cnt++;
									} else {
											hashcat_ctx.event_log_warning("Hash '%s': %s", input_buf, ModernizedCProgram.strparser(parser_status));
									} 
									hash = hashes_buf[hashes_cnt];
									parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, hash_buf + 16, 16);
									if (parser_status == parser_rc.PARSER_OK) {
										generatedSplit.setSplit_group(0);
										generatedSplit.setSplit_origin(split_origin.SPLIT_ORIGIN_RIGHT);
										hashes_cnt++;
									} else {
											hashcat_ctx.event_log_warning("Hash '%s': %s", input_buf, ModernizedCProgram.strparser(parser_status));
									} 
								} else {
										hash_t hash = hashes_buf[hashes_cnt];
										parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, hash_buf, hash_len);
										if (parser_status == parser_rc.PARSER_OK) {
											generatedSplit.setSplit_group(0);
											generatedSplit.setSplit_origin(split_origin.SPLIT_ORIGIN_NONE);
											hashes_cnt++;
										} else {
												hashcat_ctx.event_log_warning("Hash '%s': %s", input_buf, ModernizedCProgram.strparser(parser_status));
										} 
								} 
							} else {
									hash_t hash = hashes_buf[hashes_cnt];
									parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, hash_buf, hash_len);
									if (parser_status == parser_rc.PARSER_OK) {
										hashes_cnt++;
									} else {
											hashcat_ctx.event_log_warning("Hash '%s': %s", input_buf, ModernizedCProgram.strparser(parser_status));
									} 
							} 
					} 
				}  else if (hashlist_mode == hl_mode.HL_MODE_FILE_PLAIN) {
					HCFILE fp = new HCFILE();
					if (fp.hc_fopen(hashfile, "rb") == 0) {
						hashcat_ctx.event_log_error("%s: %s", hashfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						return -1;
					} 
					u32 line_num = 0;
					Byte line_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
					time_t prev = 0;
					time_t now = 0;
					while (!fp.hc_feof()) {
						line_num++;
						size_t line_len = fp.fgetl(line_buf, -1024);
						if (line_len == 0) {
							continue;
						} 
						if (hashes_avail == hashes_cnt) {
							hashcat_ctx.event_log_warning("Hashfile '%s' on line %u: File changed during runtime. Skipping new data.", generatedHashfile, line_num);
							break;
						} 
						Byte hash_buf = (null);
						int hash_len = 0;
						hashcat_ctx.hlfmt_hash(hashlist_format, line_buf, line_len, hash_buf, hash_len);
						boolean hash_fmt_error = false;
						if (hash_len < 1) {
							hash_fmt_error = true;
						} 
						if (hash_buf == (null)) {
							hash_fmt_error = true;
						} 
						if (hash_fmt_error) {
							hashcat_ctx.event_log_warning("Failed to parse hashes using the '%s' format.", ModernizedCProgram.strhlfmt(hashlist_format));
							continue;
						} 
						if (generatedUsername == true) {
							Byte user_buf = (null);
							int user_len = 0;
							hashcat_ctx.hlfmt_user(hashlist_format, line_buf, line_len, user_buf, user_len);
							u32 hashes_per_user = 1;
							if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_SPLIT) {
								if (hash_len == 32) {
									hashes_per_user = 2;
								} 
							} 
							for (u32 i = 0;
							 i < hashes_per_user; i++) {
								user_t user = generatedUser;
								user = (user_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
								user_t user_ptr = user;
								if (user_buf != (null)) {
									user_ptr.setUser_name(ModernizedCProgram.hcstrdup(user_buf));
								} else {
										user_ptr.setUser_name(ModernizedCProgram.hcstrdup(""));
								} 
								user_ptr.setUser_len((u32)user_len);
							}
						} 
						if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_COPY) {
							hashinfo_t hash_info_tmp = generatedHash_info;
							hash_info_tmp.setOrighash(ModernizedCProgram.hcstrdup(hash_buf));
						} 
						if (generatedIs_salted == true) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedSalt, 0, /*Error: Unsupported expression*/);
						} 
						if (generatedEsalt_size > 0) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedEsalt, 0, generatedEsalt_size);
						} 
						if (generatedHook_salt_size > 0) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedHook_salt, 0, generatedHook_salt_size);
						} 
						if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_SPLIT) {
							if (hash_len == 32) {
								hash_t hash = new hash_t();
								hash = hashes_buf[hashes_cnt];
								int parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, hash_buf + 0, 16);
								if (parser_status < parser_rc.PARSER_GLOBAL_ZERO) {
									Byte tmp_line_buf;
									ModernizedCProgram.hc_asprintf(tmp_line_buf, "%s", line_buf);
									ModernizedCProgram.compress_terminal_line_length(tmp_line_buf, 38, 32);
									hashcat_ctx.event_log_warning("Hashfile '%s' on line %u (%s): %s", generatedHashfile, line_num, tmp_line_buf, ModernizedCProgram.strparser(parser_status));
									ModernizedCProgram.hcfree(tmp_line_buf);
									continue;
								} 
								generatedSplit.setSplit_group(line_num);
								generatedSplit.setSplit_origin(split_origin.SPLIT_ORIGIN_LEFT);
								hashes_cnt++;
								hash = hashes_buf[hashes_cnt];
								parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, hash_buf + 16, 16);
								if (parser_status < parser_rc.PARSER_GLOBAL_ZERO) {
									Byte tmp_line_buf;
									ModernizedCProgram.hc_asprintf(tmp_line_buf, "%s", line_buf);
									ModernizedCProgram.compress_terminal_line_length(tmp_line_buf, 38, 32);
									hashcat_ctx.event_log_warning("Hashfile '%s' on line %u (%s): %s", generatedHashfile, line_num, tmp_line_buf, ModernizedCProgram.strparser(parser_status));
									ModernizedCProgram.hcfree(tmp_line_buf);
									continue;
								} 
								generatedSplit.setSplit_group(line_num);
								generatedSplit.setSplit_origin(split_origin.SPLIT_ORIGIN_RIGHT);
								hashes_cnt++;
							} else {
									hash_t hash = hashes_buf[hashes_cnt];
									int parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, hash_buf, hash_len);
									if (parser_status < parser_rc.PARSER_GLOBAL_ZERO) {
										Byte tmp_line_buf;
										ModernizedCProgram.hc_asprintf(tmp_line_buf, "%s", line_buf);
										ModernizedCProgram.compress_terminal_line_length(tmp_line_buf, 38, 32);
										hashcat_ctx.event_log_warning("Hashfile '%s' on line %u (%s): %s", generatedHashfile, line_num, tmp_line_buf, ModernizedCProgram.strparser(parser_status));
										ModernizedCProgram.hcfree(tmp_line_buf);
										continue;
									} 
									generatedSplit.setSplit_group(line_num);
									generatedSplit.setSplit_origin(split_origin.SPLIT_ORIGIN_NONE);
									hashes_cnt++;
							} 
						} else {
								hash_t hash = hashes_buf[hashes_cnt];
								int parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, hash_buf, hash_len);
								if (parser_status < parser_rc.PARSER_GLOBAL_ZERO) {
									Byte tmp_line_buf;
									ModernizedCProgram.hc_asprintf(tmp_line_buf, "%s", line_buf);
									ModernizedCProgram.compress_terminal_line_length(tmp_line_buf, 38, 32);
									hashcat_ctx.event_log_warning("Hashfile '%s' on line %u (%s): %s", generatedHashfile, line_num, tmp_line_buf, ModernizedCProgram.strparser(parser_status));
									ModernizedCProgram.hcfree(tmp_line_buf);
									continue;
								} 
								hashes_cnt++;
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/time(now);
						if ((now - prev) == 0) {
							continue;
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/time(prev);
						hashlist_parse_t hashlist_parse = new hashlist_parse_t();
						hashlist_parse.setHashes_cnt(hashes_cnt);
						hashlist_parse.setHashes_avail(hashes_avail);
						hashcat_ctx.event_call((event_identifier.EVENT_HASHLIST_PARSE_HASH), (hashlist_parse), (/*Error: Unsupported expression*/));
					}
					hashlist_parse_t hashlist_parse = new hashlist_parse_t();
					hashlist_parse.setHashes_cnt(hashes_cnt);
					hashlist_parse.setHashes_avail(hashes_avail);
					hashcat_ctx.event_call((event_identifier.EVENT_HASHLIST_PARSE_HASH), (hashlist_parse), (/*Error: Unsupported expression*/));
					ModernizedCProgram.hcfree(line_buf);
					fp.hc_fclose();
				}  else if (hashlist_mode == hl_mode.HL_MODE_FILE_BINARY) {
					Byte input_buf = generatedHc_hash;
					size_t input_len = /*Error: Function owner not recognized*/strlen(input_buf);
					if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_COPY) {
						hashinfo_t hash_info_tmp = generatedHash_info;
						hash_info_tmp.setOrighash(ModernizedCProgram.hcstrdup(input_buf));
					} 
					if (generatedIs_salted == true) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedSalt, 0, /*Error: Unsupported expression*/);
					} 
					if (generatedEsalt_size > 0) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedEsalt, 0, generatedEsalt_size);
					} 
					if (generatedHook_salt_size > 0) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedHook_salt, 0, generatedHook_salt_size);
					} 
					if (generatedModule_hash_binary_parse != (Object)-1) {
						int hashes_parsed = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra, hashes);
						if (hashes_parsed > 0) {
							hashes_cnt = hashes_parsed;
						} else {
								hashcat_ctx.event_log_warning("Hashfile '%s': %s", generatedHashfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
						} 
					} else {
							hash_t hash = hashes_buf[hashes_cnt];
							int parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, input_buf, input_len);
							if (parser_status == parser_rc.PARSER_OK) {
								hashes_cnt++;
							} else {
									hashcat_ctx.event_log_warning("Hash '%s': %s", input_buf, ModernizedCProgram.strparser(parser_status));
							} 
					} 
				} 
		} 
		hashes.setHashes_cnt(hashes_cnt);
		if (hashes_cnt) {
			hashcat_ctx.event_call((event_identifier.EVENT_HASHLIST_SORT_HASH_PRE), (null), 0);
			if (generatedIs_salted == true) {
				ModernizedCProgram.hc_qsort_r(hashes_buf, hashes_cnt, /*Error: Unsupported expression*/, ModernizedCProgram.sort_by_hash, (Object)hashconfig);
			} else {
					ModernizedCProgram.hc_qsort_r(hashes_buf, hashes_cnt, /*Error: Unsupported expression*/, ModernizedCProgram.sort_by_hash_no_salt, (Object)hashconfig);
			} 
			hashcat_ctx.event_call((event_identifier.EVENT_HASHLIST_SORT_HASH_POST), (null), 0);
		} 
		int generatedSplit_origin = split1.getSplit_origin();
		int generatedSplit_group = split1.getSplit_group();
		if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_SPLIT) {
			for (u32 i = 0;
			 i < hashes_cnt; i++) {
				split_t split1 = generatedSplit;
				if (generatedSplit_origin != split_origin.SPLIT_ORIGIN_LEFT) {
					continue;
				} 
				for (u32 j = 0;
				 j < hashes_cnt; j++) {
					split_t split2 = generatedSplit;
					if (generatedSplit_origin != split_origin.SPLIT_ORIGIN_RIGHT) {
						continue;
					} 
					if (generatedSplit_group != generatedSplit_group) {
						continue;
					} 
					split1.setSplit_neighbor(j);
					split2.setSplit_neighbor(i);
					break;
				}
			}
		} 
		// update split split_neighbor after sorting
		return 0;
	}
	public int hashes_init_stage2() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		hash generatedHashes_buf = hashes.getHashes_buf();
		hash_t[] hashes_buf = generatedHashes_buf;
		Object generatedHashes_cnt = hashes.getHashes_cnt();
		u32 hashes_cnt = generatedHashes_cnt;
		hashcat_ctx.event_call((event_identifier.EVENT_HASHLIST_UNIQUE_HASH_PRE), (null), 0);
		u32 hashes_cnt_new = 1;
		for (u32 hashes_pos = 1;
		 hashes_pos < hashes_cnt; hashes_pos++) {
			if (hashconfig.getPotfile_keep_all_hashes() == 1) {
			}  else if (hashconfig.getIs_salted() == 1) {
				if (ModernizedCProgram.sort_by_salt(hashes_buf[hashes_pos].getSalt(), hashes_buf[hashes_pos - 1].getSalt()) == 0) {
					if (ModernizedCProgram.sort_by_digest_p0p1(hashes_buf[hashes_pos].getDigest(), hashes_buf[hashes_pos - 1].getDigest(), (Object)hashconfig) == 0) {
						continue;
					} 
				} 
			} else {
					if (ModernizedCProgram.sort_by_digest_p0p1(hashes_buf[hashes_pos].getDigest(), hashes_buf[hashes_pos - 1].getDigest(), (Object)hashconfig) == 0) {
						continue;
					} 
			} 
			hash_t tmp = new hash_t();
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(tmp, hashes_buf[hashes_pos], /*Error: Unsupported expression*/);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(hashes_buf[hashes_cnt_new], tmp, /*Error: Unsupported expression*/);
			hashes_cnt_new++;
		}
		for (u32 i = hashes_cnt_new;
		 i < generatedHashes_cnt; i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(hashes_buf[i], 0, /*Error: Unsupported expression*/);
		}
		hashes_cnt = hashes_cnt_new;
		hashes.setHashes_cnt(hashes_cnt);
		hashcat_ctx.event_call((event_identifier.EVENT_HASHLIST_UNIQUE_HASH_POST), (null), 0/**
		   * Now generate all the buffers required for later
		   */);
		Object digests_buf_new = ModernizedCProgram.hccalloc(hashes_cnt, hashconfig.getDgst_size());
		salt_t[] salts_buf_new = (null);
		Object esalts_buf_new = (null);
		Object hook_salts_buf_new = (null);
		if (hashconfig.getIs_salted() == 1) {
			salts_buf_new = (salt_t)ModernizedCProgram.hccalloc(hashes_cnt, /*Error: Unsupported expression*/);
		} else {
				salts_buf_new = (salt_t)ModernizedCProgram.hccalloc(1, /*Error: Unsupported expression*/);
		} 
		if (hashconfig.getEsalt_size() > 0) {
			esalts_buf_new = ModernizedCProgram.hccalloc(hashes_cnt, hashconfig.getEsalt_size());
		} 
		if (hashconfig.getHook_salt_size() > 0) {
			hook_salts_buf_new = ModernizedCProgram.hccalloc(hashes_cnt, hashconfig.getHook_salt_size());
		} 
		hashcat_ctx.event_call((event_identifier.EVENT_HASHLIST_SORT_SALT_PRE), (null), 0);
		u32 digests_cnt = hashes_cnt;
		u32 digests_done = 0;
		u32 digests_shown = (u32)ModernizedCProgram.hccalloc(digests_cnt, /*Error: Unsupported expression*/);
		u32 digests_shown_tmp = (u32)ModernizedCProgram.hccalloc(digests_cnt, /*Error: Unsupported expression*/);
		u32 salts_cnt = 0;
		u32 salts_done = 0;
		hashinfo_t[][] hash_info = (null);
		if ((user_options.getUsername() == 1) || (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_HASH_COPY) || (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_HASH_SPLIT)) {
			hash_info = (hashinfo_t)ModernizedCProgram.hccalloc(hashes_cnt, /*Error: Unsupported expression*/);
		} 
		u32 salts_shown = (u32)ModernizedCProgram.hccalloc(digests_cnt, /*Error: Unsupported expression*/);
		salt_t salt_buf = new salt_t();
		{ 
			salt_buf = salts_buf_new[salts_cnt];
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(salt_buf, hashes_buf[0].getSalt(), /*Error: Unsupported expression*/);
			hashes_buf[0].setSalt(salt_buf);
			if (hashconfig.getHook_salt_size() > 0) {
				Byte hook_salts_buf_new_ptr = ((byte)hook_salts_buf_new) + (salts_cnt * hashconfig.getHook_salt_size());
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(hook_salts_buf_new_ptr, hashes_buf[0].getHook_salt(), hashconfig.getHook_salt_size());
				hashes_buf[0].setHook_salt(hook_salts_buf_new_ptr);
			} 
			salt_buf.setDigests_cnt(0);
			salt_buf.setDigests_done(0);
			salt_buf.setDigests_offset(0);
			salts_cnt++;
		}
		Object generatedDigests_cnt = salt_buf.getDigests_cnt();
		generatedDigests_cnt++;
		Byte digests_buf_new_ptr = ((byte)digests_buf_new) + (0 * hashconfig.getDgst_size());
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(digests_buf_new_ptr, hashes_buf[0].getDigest(), hashconfig.getDgst_size());
		hashes_buf[0].setDigest(digests_buf_new_ptr);
		if (hashconfig.getEsalt_size() > 0) {
			Byte esalts_buf_new_ptr = ((byte)esalts_buf_new) + (0 * hashconfig.getEsalt_size());
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(esalts_buf_new_ptr, hashes_buf[0].getEsalt(), hashconfig.getEsalt_size());
			hashes_buf[0].setEsalt(esalts_buf_new_ptr);
		} 
		if ((user_options.getUsername() == 1) || (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_HASH_COPY) || (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_HASH_SPLIT)) {
			hash_info[0] = hashes_buf[0].getHash_info();
		} 
		// copy from inner loopfor (u32 hashes_pos = 1;
		 hashes_pos < hashes_cnt; hashes_pos++) {
			if (hashconfig.getIs_salted() == 1) {
				if (ModernizedCProgram.sort_by_salt(hashes_buf[hashes_pos].getSalt(), hashes_buf[hashes_pos - 1].getSalt()) != 0) {
					salt_buf = salts_buf_new[salts_cnt];
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(salt_buf, hashes_buf[hashes_pos].getSalt(), /*Error: Unsupported expression*/);
					hashes_buf[hashes_pos].setSalt(salt_buf);
					if (hashconfig.getHook_salt_size() > 0) {
						Byte hook_salts_buf_new_ptr = ((byte)hook_salts_buf_new) + (salts_cnt * hashconfig.getHook_salt_size());
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(hook_salts_buf_new_ptr, hashes_buf[hashes_pos].getHook_salt(), hashconfig.getHook_salt_size());
						hashes_buf[hashes_pos].setHook_salt(hook_salts_buf_new_ptr);
					} 
					salt_buf.setDigests_cnt(0);
					salt_buf.setDigests_done(0);
					salt_buf.setDigests_offset(hashes_pos);
					salts_cnt++;
				} 
				hashes_buf[hashes_pos].setSalt(salt_buf);
				if (hashconfig.getHook_salt_size() > 0) {
					Byte hook_salts_buf_new_ptr = ((byte)hook_salts_buf_new) + (salts_cnt * hashconfig.getHook_salt_size());
					hashes_buf[hashes_pos].setHook_salt(hook_salts_buf_new_ptr);
				} 
			} 
			generatedDigests_cnt++;
			digests_buf_new_ptr = ((byte)digests_buf_new) + (hashes_pos * hashconfig.getDgst_size());
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(digests_buf_new_ptr, hashes_buf[hashes_pos].getDigest(), hashconfig.getDgst_size());
			hashes_buf[hashes_pos].setDigest(digests_buf_new_ptr);
			if (hashconfig.getEsalt_size() > 0) {
				Byte esalts_buf_new_ptr = ((byte)esalts_buf_new) + (hashes_pos * hashconfig.getEsalt_size());
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(esalts_buf_new_ptr, hashes_buf[hashes_pos].getEsalt(), hashconfig.getEsalt_size());
				hashes_buf[hashes_pos].setEsalt(esalts_buf_new_ptr);
			} 
			if ((user_options.getUsername() == 1) || (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_HASH_COPY) || (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_HASH_SPLIT)) {
				hash_info[hashes_pos] = hashes_buf[hashes_pos].getHash_info();
			} 
		}
		hashcat_ctx.event_call((event_identifier.EVENT_HASHLIST_SORT_SALT_POST), (null), 0);
		Object generatedDigests_buf = hashes.getDigests_buf();
		ModernizedCProgram.hcfree(generatedDigests_buf);
		salt[] generatedSalts_buf = hashes.getSalts_buf();
		ModernizedCProgram.hcfree(generatedSalts_buf);
		Object generatedEsalts_buf = hashes.getEsalts_buf();
		ModernizedCProgram.hcfree(generatedEsalts_buf);
		Object generatedHook_salts_buf = hashes.getHook_salts_buf();
		ModernizedCProgram.hcfree(generatedHook_salts_buf);
		hashes.setDigests_cnt(digests_cnt);
		hashes.setDigests_done(digests_done);
		hashes.setDigests_buf(digests_buf_new);
		hashes.setDigests_shown(digests_shown);
		hashes.setDigests_shown_tmp(digests_shown_tmp);
		hashes.setSalts_cnt(salts_cnt);
		hashes.setSalts_done(salts_done);
		hashes.setSalts_buf(salts_buf_new);
		hashes.setSalts_shown(salts_shown);
		hashes.setEsalts_buf(esalts_buf_new);
		hashes.setHook_salts_buf(hook_salts_buf_new);
		hashes.setHash_info(hash_info);
		return 0;
	}
	public int hashes_init_stage3() {
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		Object generatedDigests_done = hashes.getDigests_done();
		u32 digests_done = generatedDigests_done;
		Object[] generatedDigests_shown = hashes.getDigests_shown();
		u32[] digests_shown = generatedDigests_shown;
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		u32 salts_cnt = generatedSalts_cnt;
		Object generatedSalts_done = hashes.getSalts_done();
		u32 salts_done = generatedSalts_done;
		Object[] generatedSalts_shown = hashes.getSalts_shown();
		u32[] salts_shown = generatedSalts_shown;
		hash generatedHashes_buf = hashes.getHashes_buf();
		hash_t[] hashes_buf = generatedHashes_buf;
		salt[] generatedSalts_buf = hashes.getSalts_buf();
		salt_t salts_buf = generatedSalts_buf;
		Object generatedDigests_cnt = salt_buf.getDigests_cnt();
		Object generatedDigests_offset = salt_buf.getDigests_offset();
		for (u32 salt_idx = 0;
		 salt_idx < salts_cnt; salt_idx++) {
			salt_t salt_buf = salts_buf + salt_idx;
			u32 digests_cnt = generatedDigests_cnt;
			for (u32 digest_idx = 0;
			 digest_idx < digests_cnt; digest_idx++) {
				u32 hashes_idx = generatedDigests_offset + digest_idx;
				if (hashes_buf[hashes_idx].getCracked() == 1) {
					digests_shown[hashes_idx] = 1;
					digests_done++;
					generatedDigests_done++;
				} 
			}
			if (generatedDigests_done == generatedDigests_cnt) {
				salts_shown[salt_idx] = 1;
				salts_done++;
			} 
			if (salts_done == salts_cnt) {
				hashcat_ctx.mycracked();
			} 
		}
		hashes.setDigests_done(digests_done);
		hashes.setSalts_cnt(salts_cnt);
		hashes.setSalts_done(salts_done);
		return 0;
	}
	public int hashes_init_stage4() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		module_ctx generatedModule_ctx = this.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		Object generatedOpti_type = hashconfig.getOpti_type();
		if (generatedSalts_cnt == 1) {
			generatedOpti_type |=  opti_type.OPTI_TYPE_SINGLE_SALT;
		} 
		Object generatedDigests_cnt = hashes.getDigests_cnt();
		if (generatedDigests_cnt == 1) {
			generatedOpti_type |=  opti_type.OPTI_TYPE_SINGLE_HASH;
		} 
		Object generatedAttack_exec = hashconfig.getAttack_exec();
		if (generatedAttack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
			generatedOpti_type |=  opti_type.OPTI_TYPE_NOT_ITERATED;
		} 
		Object generatedAttack_mode = user_options.getAttack_mode();
		if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
			generatedOpti_type |=  opti_type.OPTI_TYPE_BRUTE_FORCE;
		} 
		Object generatedOpts_type = hashconfig.getOpts_type();
		if (generatedOpti_type & opti_type.OPTI_TYPE_BRUTE_FORCE) {
			if (generatedOpti_type & opti_type.OPTI_TYPE_SINGLE_HASH) {
				if (generatedOpti_type & opti_type.OPTI_TYPE_APPENDED_SALT) {
					if (generatedOpts_type & opts_type.OPTS_TYPE_ST_ADD80) {
						generatedOpts_type &=  ~opts_type.OPTS_TYPE_ST_ADD80;
						generatedOpts_type |=  opts_type.OPTS_TYPE_PT_ADD80;
					} 
					if (generatedOpts_type & opts_type.OPTS_TYPE_ST_ADDBITS14) {
						generatedOpts_type &=  ~opts_type.OPTS_TYPE_ST_ADDBITS14;
						generatedOpts_type |=  opts_type.OPTS_TYPE_PT_ADDBITS14;
					} 
					if (generatedOpts_type & opts_type.OPTS_TYPE_ST_ADDBITS15) {
						generatedOpts_type &=  ~opts_type.OPTS_TYPE_ST_ADDBITS15;
						generatedOpts_type |=  opts_type.OPTS_TYPE_PT_ADDBITS15;
					} 
				} 
			} 
		} 
		Object generatedModule_extra_tmp_size = module_ctx.getModule_extra_tmp_size();
		// time to update extra_tmp_size which is tmp_size value based on hash configurationif (generatedModule_extra_tmp_size != (Object)-1) {
			u64 extra_tmp_size = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra, hashes);
			if (extra_tmp_size == (u64)-1) {
				hashcat_ctx.event_log_error("Mixed hash settings are not supported.");
				return -1;
			} 
			hashconfig.setExtra_tmp_size(extra_tmp_size);
		} 
		hash generatedHashes_buf = hashes.getHashes_buf();
		// at this point we no longer need hash_t* structurehash_t hashes_buf = generatedHashes_buf;
		ModernizedCProgram.hcfree(hashes_buf);
		hashes.setHashes_cnt(0);
		hashes.setHashes_buf((null))// starting from here, we should allocate some scratch buffer for later use;// starting from here, we should allocate some scratch buffer for later use
		u8 out_buf = (u8)ModernizedCProgram.hcmalloc(-1024);
		hashes.setOut_buf(out_buf)// we need two buffers in parallel;// we need two buffers in parallel
		u8 tmp_buf = (u8)ModernizedCProgram.hcmalloc(-1024);
		hashes.setTmp_buf(tmp_buf)// brain session;// brain session
		return 0;
	}
	public int hashes_init_selftest() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		module_ctx generatedModule_ctx = this.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Object generatedSt_hash = hashconfig.getSt_hash();
		if (generatedSt_hash == (null)) {
			return 0;
		} 
		Object st_digests_buf = (null);
		salt_t st_salts_buf = (null);
		Object st_esalts_buf = (null);
		Object st_hook_salts_buf = (null);
		Object generatedDgst_size = hashconfig.getDgst_size();
		st_digests_buf = ModernizedCProgram.hccalloc(1, generatedDgst_size);
		st_salts_buf = (salt_t)ModernizedCProgram.hccalloc(1, /*Error: Unsupported expression*/);
		Object generatedEsalt_size = hashconfig.getEsalt_size();
		if (generatedEsalt_size > 0) {
			st_esalts_buf = ModernizedCProgram.hccalloc(1, generatedEsalt_size);
		} 
		Object generatedHook_salt_size = hashconfig.getHook_salt_size();
		if (generatedHook_salt_size > 0) {
			st_hook_salts_buf = ModernizedCProgram.hccalloc(1, generatedHook_salt_size);
		} 
		hash_t hash = new hash_t();
		hash.setDigest(st_digests_buf);
		hash.setSalt(st_salts_buf);
		hash.setEsalt(st_esalts_buf);
		hash.setHook_salt(st_hook_salts_buf);
		hash.setCracked(0);
		hash.setHash_info((null));
		hash.setPw_buf((null));
		hash.setPw_len(0);
		int parser_status;
		Object generatedModule_hash_init_selftest = module_ctx.getModule_hash_init_selftest();
		Object generatedOpts_type = hashconfig.getOpts_type();
		Byte generatedSession_dir = folder_config.getSession_dir();
		Object generatedDigest = hash.getDigest();
		salt generatedSalt = hash.getSalt();
		Object generatedEsalt = hash.getEsalt();
		Object generatedHook_salt = hash.getHook_salt();
		hashinfo generatedHash_info = hash.getHash_info();
		boolean generatedHex_salt = user_options.getHex_salt();
		Object generatedSalt_type = hashconfig.getSalt_type();
		if (generatedModule_hash_init_selftest != (Object)-1) {
			parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, hash);
		} else {
				if (generatedOpts_type & opts_type.OPTS_TYPE_BINARY_HASHFILE) {
					Byte tmpfile_bin;
					ModernizedCProgram.hc_asprintf(tmpfile_bin, "%s/selftest.hash", generatedSession_dir);
					HCFILE fp = new HCFILE();
					fp.hc_fopen(tmpfile_bin, "wb");
					size_t st_hash_len = /*Error: Function owner not recognized*/strlen(generatedSt_hash);
					for (size_t i = 0;
					 i < st_hash_len; i += 2) {
						u8 c = ModernizedCProgram.hex_to_u8((u8)generatedSt_hash + i);
						fp.hc_fputc(c);
					}
					fp.hc_fclose();
					parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, tmpfile_bin, /*Error: Function owner not recognized*/strlen(tmpfile_bin));
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(tmpfile_bin);
					ModernizedCProgram.hcfree(tmpfile_bin);
				} else {
						hashconfig_t hashconfig_st = (hashconfig_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(hashconfig_st, hashconfig, /*Error: Unsupported expression*/);
						hashconfig_st.setSeparator(user_options_defaults.SEPARATOR);
						if (generatedHex_salt) {
							if (generatedSalt_type == salt_type.SALT_TYPE_GENERIC) {
								generatedOpts_type &=  ~opts_type.OPTS_TYPE_ST_HEX;
							} 
						} 
						parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig_st, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, generatedSt_hash, /*Error: Function owner not recognized*/strlen(generatedSt_hash));
						ModernizedCProgram.hcfree(hashconfig_st);
				} 
		} 
		if (parser_status == parser_rc.PARSER_OK) {
		} else {
				hashcat_ctx.event_log_error("Self-test hash parsing error: %s", ModernizedCProgram.strparser(parser_status));
				return -1;
		} 
		// nothing to do
		hashes.setSt_digests_buf(st_digests_buf);
		hashes.setSt_salts_buf(st_salts_buf);
		hashes.setSt_esalts_buf(st_esalts_buf);
		hashes.setSt_hook_salts_buf(st_hook_salts_buf);
		return 0;
	}
	public int hashes_init_benchmark() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		module_ctx generatedModule_ctx = this.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		if (user_options.getBenchmark() == 0) {
			return 0;
		} 
		if (hashconfig.getIs_salted() == 0) {
			return 0;
		} 
		salt[] generatedSalts_buf = hashes.getSalts_buf();
		salt[] generatedSt_salts_buf = hashes.getSt_salts_buf();
		if (module_ctx.getModule_benchmark_salt() != (Object)-1) {
			salt_t ptr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedSalts_buf, ptr, /*Error: Unsupported expression*/);
			ModernizedCProgram.hcfree(ptr);
		} else {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedSalts_buf, generatedSt_salts_buf, /*Error: Unsupported expression*/);
		} 
		Object generatedEsalts_buf = hashes.getEsalts_buf();
		Object generatedSt_esalts_buf = hashes.getSt_esalts_buf();
		if (hashconfig.getEsalt_size() > 0) {
			if (module_ctx.getModule_benchmark_esalt() != (Object)-1) {
				Object ptr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedEsalts_buf, ptr, hashconfig.getEsalt_size());
				ModernizedCProgram.hcfree(ptr);
			} else {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedEsalts_buf, generatedSt_esalts_buf, hashconfig.getEsalt_size());
			} 
		} 
		Object generatedHook_salts_buf = hashes.getHook_salts_buf();
		Object generatedSt_hook_salts_buf = hashes.getSt_hook_salts_buf();
		if (hashconfig.getHook_salt_size() > 0) {
			if (module_ctx.getModule_benchmark_hook_salt() != (Object)-1) {
				Object ptr = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedHook_salts_buf, ptr, hashconfig.getHook_salt_size());
				ModernizedCProgram.hcfree(ptr);
			} else {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedHook_salts_buf, generatedSt_hook_salts_buf, hashconfig.getHook_salt_size());
			} 
		} 
		return 0;
	}
	public void hashes_destroy() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Object generatedDigests_buf = hashes.getDigests_buf();
		ModernizedCProgram.hcfree(generatedDigests_buf);
		Object[] generatedDigests_shown = hashes.getDigests_shown();
		ModernizedCProgram.hcfree(generatedDigests_shown);
		Object[] generatedDigests_shown_tmp = hashes.getDigests_shown_tmp();
		ModernizedCProgram.hcfree(generatedDigests_shown_tmp);
		salt[] generatedSalts_buf = hashes.getSalts_buf();
		ModernizedCProgram.hcfree(generatedSalts_buf);
		Object[] generatedSalts_shown = hashes.getSalts_shown();
		ModernizedCProgram.hcfree(generatedSalts_shown);
		boolean generatedUsername = user_options.getUsername();
		Object generatedOpts_type = hashconfig.getOpts_type();
		Object generatedHashes_cnt = hashes.getHashes_cnt();
		hashinfo[][] generatedHash_info = hashes.getHash_info();
		if ((generatedUsername == true) || (generatedOpts_type & opts_type.OPTS_TYPE_HASH_COPY)) {
			for (u32 hash_pos = 0;
			 hash_pos < generatedHashes_cnt; hash_pos++) {
				if (generatedUsername == true) {
					ModernizedCProgram.hcfree(generatedHash_info[hash_pos].getUser());
				} 
				if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_COPY) {
					ModernizedCProgram.hcfree(generatedHash_info[hash_pos].getOrighash());
				} 
				if (generatedOpts_type & opts_type.OPTS_TYPE_HASH_SPLIT) {
					ModernizedCProgram.hcfree(generatedHash_info[hash_pos].getSplit());
				} 
			}
		} 
		ModernizedCProgram.hcfree(generatedHash_info);
		Object generatedEsalts_buf = hashes.getEsalts_buf();
		ModernizedCProgram.hcfree(generatedEsalts_buf);
		Object generatedHook_salts_buf = hashes.getHook_salts_buf();
		ModernizedCProgram.hcfree(generatedHook_salts_buf);
		Object generatedOut_buf = hashes.getOut_buf();
		ModernizedCProgram.hcfree(generatedOut_buf);
		Object generatedTmp_buf = hashes.getTmp_buf();
		ModernizedCProgram.hcfree(generatedTmp_buf);
		Object generatedSt_digests_buf = hashes.getSt_digests_buf();
		ModernizedCProgram.hcfree(generatedSt_digests_buf);
		salt[] generatedSt_salts_buf = hashes.getSt_salts_buf();
		ModernizedCProgram.hcfree(generatedSt_salts_buf);
		Object generatedSt_esalts_buf = hashes.getSt_esalts_buf();
		ModernizedCProgram.hcfree(generatedSt_esalts_buf);
		Object generatedSt_hook_salts_buf = hashes.getSt_hook_salts_buf();
		ModernizedCProgram.hcfree(generatedSt_hook_salts_buf);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(hashes, 0, /*Error: Unsupported expression*/);
	}
	public void hashes_logger() {
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		Object generatedHashfile = hashes.getHashfile();
		Byte generatedTopid = logfile_ctx.getTopid();
		if (((generatedHashfile)) != (null)) {
			hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, ("hashes->hashfile"), ((generatedHashfile)));
		} 
		;
		;
		Object generatedHashlist_mode = hashes.getHashlist_mode();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("hashes->hashlist_mode"), (u32)((generatedHashlist_mode)));
		;
		;
		Object generatedHashlist_format = hashes.getHashlist_format();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("hashes->hashlist_format"), (u32)((generatedHashlist_format)));
		;
		;
		Object generatedHashes_cnt = hashes.getHashes_cnt();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("hashes->hashes_cnt"), (u32)((generatedHashes_cnt)));
		;
		;
		Object generatedDigests_cnt = hashes.getDigests_cnt();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("hashes->digests_cnt"), (u32)((generatedDigests_cnt)));
		;
		;
		Object generatedDigests_done = hashes.getDigests_done();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("hashes->digests_done"), (u32)((generatedDigests_done)));
		;
		;
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("hashes->salts_cnt"), (u32)((generatedSalts_cnt)));
		;
		;
		Object generatedSalts_done = hashes.getSalts_done();
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("hashes->salts_done"), (u32)((generatedSalts_done)));
		;
		;
	}
	public int folder_config_init(Object install_folder, Object shared_folder) {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		Byte cwd = (byte)ModernizedCProgram.hcmalloc(-1024);
		if (/*Error: Function owner not recognized*/getcwd(cwd, -1024 - 1) == (null)) {
			hashcat_ctx.event_log_error("getcwd(): %s", /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			ModernizedCProgram.hcfree(cwd);
			return -1/**
			   * folders, as discussed on https://github.com/hashcat/hashcat/issues/20
			   */;
		} 
		size_t exec_path_sz = 1024;
		Byte exec_path = (byte)ModernizedCProgram.hcmalloc(exec_path_sz);
		int rc = ModernizedCProgram.get_exec_path(exec_path, exec_path_sz);
		if (rc == -1) {
			hashcat_ctx.event_log_error("get_exec_path() failed.");
			ModernizedCProgram.hcfree(cwd);
			ModernizedCProgram.hcfree(exec_path);
			return -1;
		} 
		// makes library use easier/*
		  This causes invalid error out if install_folder (/usr/local/bin) does not exist
		  if (resolved_install_folder == NULL)
		  {
		    event_log_error (hashcat_ctx, "%s: %s", resolved_install_folder, strerror (errno));
		
		    hcfree (cwd);
		
		    hcfree (exec_path);
		
		    hcfree (resolved_install_folder);
		
		    return -1;
		  }
		  */
		Byte install_dir = ModernizedCProgram.hcmalloc(-1024);
		ModernizedCProgram.get_install_dir(install_dir, exec_path);
		Byte profile_dir = install_dir;
		Byte session_dir = install_dir;
		Byte shared_dir = install_dir;
		ModernizedCProgram.hcfree(exec_path/**
		   * There are a lot of problems related to bad support of -I parameters when building the kernel.
		   * Each OpenCL runtime handles it slightly differently.
		   * The most problematic is with new AMD drivers on Windows, which cannot handle quote characters!
		   * The best workaround found so far is to modify the TMP variable (only inside hashcat process) before the runtime is loaded.
		   */);
		Byte cpath;
		ModernizedCProgram.hc_asprintf(cpath, "%s\\OpenCL\\", shared_dir);
		Byte cpath_real;
		ModernizedCProgram.hc_asprintf(cpath_real, "%s\\OpenCL\\", shared_dir)// Attention: since hcfree () doesn't set the pointer to NULL, we need to do it externally such that// we prevent double-freeing the same memory address (this happens if e.g. profile_dir == session_dir);// Attention: since hcfree () doesn't set the pointer to NULL, we need to do it externally such that// we prevent double-freeing the same memory address (this happens if e.g. profile_dir == session_dir)
		ModernizedCProgram.hcfree(cpath);
		//if (getenv ("TMP") == NULL)if (1) {
			Byte tmp;
			ModernizedCProgram.hc_asprintf(tmp, "TMP=%s", cpath_real);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/putenv(tmp);
		} 
		ModernizedCProgram.naive_replace(cpath_real, (byte)'\\', (byte)'/')// not escaping here, windows using quotes later// naive_escape (cpath_real, PATH_MAX,  ' ', '\\');;// not escaping here, windows using quotes later// naive_escape (cpath_real, PATH_MAX,  ' ', '\\');
		/**
		   * kernel cache, we need to make sure folder exist
		   */Byte kernels_folder;
		ModernizedCProgram.hc_asprintf(kernels_folder, "%s/kernels", profile_dir);
		ModernizedCProgram.hc_mkdir(kernels_folder, 700);
		ModernizedCProgram.hcfree(kernels_folder/**
		   * store for later use
		   */);
		folder_config.setCwd(cwd);
		folder_config.setInstall_dir(install_dir);
		folder_config.setProfile_dir(profile_dir);
		folder_config.setSession_dir(session_dir);
		folder_config.setShared_dir(shared_dir);
		folder_config.setCpath_real(cpath_real);
		return 0;
	}
	public void folder_config_destroy() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		Byte generatedCpath_real = folder_config.getCpath_real();
		ModernizedCProgram.hcfree(generatedCpath_real);
		Byte generatedCwd = folder_config.getCwd();
		ModernizedCProgram.hcfree(generatedCwd);
		Byte generatedInstall_dir = folder_config.getInstall_dir();
		ModernizedCProgram.hcfree(generatedInstall_dir);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(folder_config, 0, /*Error: Unsupported expression*/);
	}
	public void usage_big_print() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Byte modulefile = (byte)ModernizedCProgram.hcmalloc(-1024);
		usage_sort_t[] usage_sort_buf = (usage_sort_t)ModernizedCProgram.hccalloc(ModernizedCProgram.MODULE_HASH_MODES_MAXIMUM, /*Error: Unsupported expression*/);
		int usage_sort_cnt = 0;
		for (int i = 0;
		 i < ModernizedCProgram.MODULE_HASH_MODES_MAXIMUM; i++) {
			user_options.setHash_mode(i);
			ModernizedCProgram.module_filename(folder_config, i, modulefile, -1024);
			if (ModernizedCProgram.hc_path_exist(modulefile) == 0) {
				continue;
			} 
			int rc = hashcat_ctx.hashconfig_init();
			if (rc == 0) {
				usage_sort_buf[usage_sort_cnt].setHash_mode(hashconfig.getHash_mode());
				usage_sort_buf[usage_sort_cnt].setHash_name(ModernizedCProgram.hcstrdup(hashconfig.getHash_name()));
				usage_sort_buf[usage_sort_cnt].setHash_category(hashconfig.getHash_category());
				usage_sort_cnt++;
			} 
			hashcat_ctx.hashconfig_destroy();
		}
		ModernizedCProgram.hcfree(modulefile);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/qsort(usage_sort_buf, usage_sort_cnt, /*Error: Unsupported expression*/, sort_by_usage);
		for (int i = 0;
		 ModernizedCProgram.USAGE_BIG_PRE_HASHMODES[i] != (null); i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("%s", ModernizedCProgram.USAGE_BIG_PRE_HASHMODES[i]);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1, (_iob[1]));
		}
		//hc_fwrite (EOL, strlen (EOL), 1, stdout);for (int i = 0;
		 i < usage_sort_cnt; i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("%7u | %-48s | %s", usage_sort_buf[i].getHash_mode(), usage_sort_buf[i].getHash_name(), ModernizedCProgram.strhashcategory(usage_sort_buf[i].getHash_category()));
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1, (_iob[1]));
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1, (_iob[1]));
		for (int i = 0;
		 i < usage_sort_cnt; i++) {
			ModernizedCProgram.hcfree(usage_sort_buf[i].getHash_name());
		}
		ModernizedCProgram.hcfree(usage_sort_buf);
		for (int i = 0;
		 ModernizedCProgram.USAGE_BIG_POST_HASHMODES[i] != (null); i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/printf("%s", ModernizedCProgram.USAGE_BIG_POST_HASHMODES[i]);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1, (_iob[1]));
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1, (_iob[1]));
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	/*
	#if defined (_WIN)
	
	BOOL WINAPI sigHandler_default (DWORD sig)
	{
	  switch (sig)
	  {
	    case CTRL_CLOSE_EVENT:
	
	       *
	       * special case see: https://stackoverflow.com/questions/3640633/c-setconsolectrlhandler-routine-issue/5610042#5610042
	       * if the user interacts w/ the user-interface (GUI/cmd), we need to do the finalization job within this signal handler
	       * function otherwise it is too late (e.g. after returning from this function)
	       *
	
	      myabort (hashcat_ctx->status_ctx);
	
	      SetConsoleCtrlHandler (NULL, TRUE);
	
	      sleep (10);
	
	      return TRUE;
	
	    case CTRL_C_EVENT:
	    case CTRL_LOGOFF_EVENT:
	    case CTRL_SHUTDOWN_EVENT:
	
	      myabort (hashcat_ctx->status_ctx);
	
	      SetConsoleCtrlHandler (NULL, TRUE);
	
	      return TRUE;
	  }
	
	  return FALSE;
	}
	
	BOOL WINAPI sigHandler_benchmark (DWORD sig)
	{
	  switch (sig)
	  {
	    case CTRL_CLOSE_EVENT:
	
	      myquit (hashcat_ctx->status_ctx);
	
	      SetConsoleCtrlHandler (NULL, TRUE);
	
	      sleep (10);
	
	      return TRUE;
	
	    case CTRL_C_EVENT:
	    case CTRL_LOGOFF_EVENT:
	    case CTRL_SHUTDOWN_EVENT:
	
	      myquit (hashcat_ctx->status_ctx);
	
	      SetConsoleCtrlHandler (NULL, TRUE);
	
	      return TRUE;
	  }
	
	  return FALSE;
	}
	
	void hc_signal (BOOL WINAPI (callback) (DWORD))
	{
	  if (callback == NULL)
	  {
	    SetConsoleCtrlHandler ((PHANDLER_ROUTINE) callback, FALSE);
	  }
	  else
	  {
	    SetConsoleCtrlHandler ((PHANDLER_ROUTINE) callback, TRUE);
	  }
	}
	
	#else
	
	void sigHandler_default (int sig)
	{
	  myabort (hashcat_ctx->status_ctx);
	
	  signal (sig, NULL);
	}
	
	void sigHandler_benchmark (int sig)
	{
	  myquit (hashcat_ctx->status_ctx);
	
	  signal (sig, NULL);
	}
	
	void hc_signal (void (callback) (int))
	{
	  if (callback == NULL) callback = SIG_DFL;
	
	  signal (SIGINT,  callback);
	  signal (SIGTERM, callback);
	  signal (SIGABRT, callback);
	}
	
	#endif
	*/
	public int mycracked() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		status_ctx.setDevices_status(status_rc.STATUS_CRACKED);
		status_ctx.setRun_main_level1(0);
		status_ctx.setRun_main_level2(0);
		status_ctx.setRun_main_level3(0);
		status_ctx.setRun_thread_level1(0);
		status_ctx.setRun_thread_level2(0);
		return 0;
	}
	public int myabort_checkpoint() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		status_ctx.setDevices_status(status_rc.STATUS_ABORTED_CHECKPOINT);
		status_ctx.setRun_main_level1(0);
		status_ctx.setRun_main_level2(0);
		status_ctx.setRun_main_level3(0);
		status_ctx.setRun_thread_level1(0);
		status_ctx.setRun_thread_level2(0);
		return 0;
	}
	public int myabort_runtime() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		status_ctx.setDevices_status(status_rc.STATUS_ABORTED_RUNTIME);
		status_ctx.setRun_main_level1(0);
		status_ctx.setRun_main_level2(0);
		status_ctx.setRun_main_level3(0);
		status_ctx.setRun_thread_level1(0);
		status_ctx.setRun_thread_level2(0);
		return 0;
	}
	public int myabort() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		//those checks create problems in benchmark mode, it's simply too short of a timeframe where it's running as STATUS_RUNNING// not sure if this is still valid, but abort is also called by gpu temp monitor
		//if (status_ctx->devices_status != STATUS_RUNNING) return;//if (status_ctx->devices_status != STATUS_RUNNING) return;status_ctx.setDevices_status(status_rc.STATUS_ABORTED);
		status_ctx.setRun_main_level1(0);
		status_ctx.setRun_main_level2(0);
		status_ctx.setRun_main_level3(0);
		status_ctx.setRun_thread_level1(0);
		status_ctx.setRun_thread_level2(0);
		return 0;
	}
	public int myquit() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		Object generatedDevices_status = status_ctx.getDevices_status();
		if (generatedDevices_status != status_rc.STATUS_RUNNING && generatedDevices_status != status_rc.STATUS_PAUSED) {
			return -1;
		} 
		status_ctx.setDevices_status(status_rc.STATUS_QUIT);
		status_ctx.setRun_main_level1(0);
		status_ctx.setRun_main_level2(0);
		status_ctx.setRun_main_level3(0);
		status_ctx.setRun_thread_level1(0);
		status_ctx.setRun_thread_level2(0);
		return 0;
	}
	public int bypass() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		Object generatedDevices_status = status_ctx.getDevices_status();
		if (generatedDevices_status != status_rc.STATUS_RUNNING) {
			return -1;
		} 
		status_ctx.setDevices_status(status_rc.STATUS_BYPASS);
		status_ctx.setRun_main_level1(1);
		status_ctx.setRun_main_level2(1);
		status_ctx.setRun_main_level3(1);
		status_ctx.setRun_thread_level1(0);
		status_ctx.setRun_thread_level2(0);
		return 0;
	}
	public int SuspendThreads() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		Object generatedDevices_status = status_ctx.getDevices_status();
		if (generatedDevices_status != status_rc.STATUS_RUNNING) {
			return -1;
		} 
		Object generatedTimer_paused = status_ctx.getTimer_paused();
		ModernizedCProgram.hc_timer_set(generatedTimer_paused);
		status_ctx.setDevices_status(status_rc.STATUS_PAUSED);
		return 0;
	}
	public int ResumeThreads() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		Object generatedDevices_status = status_ctx.getDevices_status();
		if (generatedDevices_status != status_rc.STATUS_PAUSED) {
			return -1;
		} 
		Object generatedTimer_paused = status_ctx.getTimer_paused();
		double msec_paused = ModernizedCProgram.hc_timer_get(generatedTimer_paused);
		double generatedMsec_paused = status_ctx.getMsec_paused();
		generatedMsec_paused += msec_paused;
		status_ctx.setDevices_status(status_rc.STATUS_RUNNING);
		return 0;
	}
	public int stop_at_checkpoint() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		Object generatedDevices_status = status_ctx.getDevices_status();
		if (generatedDevices_status != status_rc.STATUS_RUNNING) {
			return -1;
		} 
		// this feature only makes sense if --restore-disable was not specified
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		boolean generatedEnabled = restore_ctx.getEnabled();
		if (generatedEnabled == false) {
			hashcat_ctx.event_log_warning("This feature is disabled when --restore-disable is specified.");
			return -1;
		} 
		boolean generatedCheckpoint_shutdown = status_ctx.getCheckpoint_shutdown();
		// Enable or Disableif (generatedCheckpoint_shutdown == false) {
			status_ctx.setCheckpoint_shutdown(1);
			status_ctx.setRun_main_level1(0);
			status_ctx.setRun_main_level2(0);
			status_ctx.setRun_main_level3(0);
			status_ctx.setRun_thread_level1(0);
			status_ctx.setRun_thread_level2(1);
		} else {
				status_ctx.setCheckpoint_shutdown(0);
				status_ctx.setRun_main_level1(1);
				status_ctx.setRun_main_level2(1);
				status_ctx.setRun_main_level3(1);
				status_ctx.setRun_thread_level1(1);
				status_ctx.setRun_thread_level2(1);
		} 
		return 0;
	}
	public void mp_css_split_cnt(Object css_cnt_orig, Object[] css_cnt_lr) {
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		u32 css_cnt_l = mask_ctx.getCss_cnt();
		u32 css_cnt_r = new u32();
		if (user_options.getSlow_candidates() == 1) {
			css_cnt_r = 0;
		} else {
				if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
					if (css_cnt_orig < 6) {
						css_cnt_r = 1;
					}  else if (css_cnt_orig == 6) {
						css_cnt_r = 2;
					} else {
							if ((hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_UTF16LE) || (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_UTF16BE)) {
								if (css_cnt_orig == 8 || css_cnt_orig == 10) {
									css_cnt_r = 2;
								} else {
										css_cnt_r = 4;
								} 
							} else {
									if ((mask_ctx.getCss_buf()[0].getCs_len() * mask_ctx.getCss_buf()[1].getCs_len() * mask_ctx.getCss_buf()[2].getCs_len()) > 256) {
										css_cnt_r = 3;
									} else {
											css_cnt_r = 4;
									} 
							} 
					} 
				} else {
						css_cnt_r = 1/* unfinished code?
						      int sum = css_buf[css_cnt_r - 1].cs_len;
						
						      for (u32 i = 1; i < 4 && i < css_cnt; i++)
						      {
						        if (sum > 1) break; // we really don't need alot of amplifier them for slow hashes
						
						        css_cnt_r++;
						
						        sum *= css_buf[css_cnt_r - 1].cs_len;
						      }
						      */;
				} 
		} 
		css_cnt_l -= css_cnt_r;
		css_cnt_lr[0] = css_cnt_l;
		css_cnt_lr[1] = css_cnt_r;
	}
	public int mp_css_utf16le_expand() {
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		Object generatedCss_cnt = mask_ctx.getCss_cnt();
		u32 css_cnt_utf16le = generatedCss_cnt * 2;
		if (css_cnt_utf16le > 256) {
			return -1;
		} 
		cs_t[] css_buf_utf16le = (cs_t)ModernizedCProgram.hccalloc(css_cnt_utf16le, /*Error: Unsupported expression*/);
		[] generatedCss_buf = mask_ctx.getCss_buf();
		for (u32 i = 0;
		u32 j = 0;
		 i < generatedCss_cnt; ) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(css_buf_utf16le[j + 0], generatedCss_buf[i], /*Error: Unsupported expression*/);
			css_buf_utf16le[j + 1].getCs_buf()[0] = 0;
			css_buf_utf16le[j + 1].setCs_len(1);
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedCss_buf, css_buf_utf16le, css_cnt_utf16le * /*Error: Unsupported expression*/);
		mask_ctx.setCss_cnt(css_cnt_utf16le);
		ModernizedCProgram.hcfree(css_buf_utf16le);
		return 0;
	}
	public int mp_css_utf16be_expand() {
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		Object generatedCss_cnt = mask_ctx.getCss_cnt();
		u32 css_cnt_utf16be = generatedCss_cnt * 2;
		if (css_cnt_utf16be > 256) {
			return -1;
		} 
		cs_t[] css_buf_utf16be = (cs_t)ModernizedCProgram.hccalloc(css_cnt_utf16be, /*Error: Unsupported expression*/);
		[] generatedCss_buf = mask_ctx.getCss_buf();
		for (u32 i = 0;
		u32 j = 0;
		 i < generatedCss_cnt; ) {
			css_buf_utf16be[j + 0].getCs_buf()[0] = 0;
			css_buf_utf16be[j + 0].setCs_len(1);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(css_buf_utf16be[j + 1], generatedCss_buf[i], /*Error: Unsupported expression*/);
		}
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedCss_buf, css_buf_utf16be, css_cnt_utf16be * /*Error: Unsupported expression*/);
		mask_ctx.setCss_cnt(css_cnt_utf16be);
		ModernizedCProgram.hcfree(css_buf_utf16be);
		return 0;
	}
	public int mp_get_truncated_mask(Object[] mask_buf, Object mask_len, Object len, byte[] new_mask_buf) {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		u32 mask_pos = new u32();
		u32 css_pos = new u32();
		for (; mask_pos < mask_len; ) {
			if (css_pos == len) {
				break;
			} 
			byte p0 = mask_buf[mask_pos];
			new_mask_buf[mask_pos] = p0;
			if (p0 == (byte)'?') {
				mask_pos++;
				if (mask_pos == mask_len) {
					break;
				} 
				new_mask_buf[mask_pos] = mask_buf[mask_pos];
			} else {
					if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_HEX) {
						mask_pos++;
						if (mask_pos == mask_len) {
							hashcat_ctx.event_log_error("The hex-charset option expects exactly 2 hexadecimal chars. Failed mask: %s", mask_buf);
							return -1;
						} 
						byte p1 = mask_buf[mask_pos];
						if ((ModernizedCProgram.is_valid_hex_char((u8)p0) == 0) || (ModernizedCProgram.is_valid_hex_char((u8)p1) == 0)) {
							hashcat_ctx.event_log_error("Invalid hex character detected in mask: %s", mask_buf);
							return -1;
						} 
						new_mask_buf[mask_pos] = p1;
					} 
			} 
		}
		return 0;
	}
	public int sp_setup_tbl() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Byte generatedShared_dir = folder_config.getShared_dir();
		Byte shared_dir = generatedShared_dir;
		Byte generatedMarkov_hcstat2 = user_options.getMarkov_hcstat2();
		Byte hcstat = generatedMarkov_hcstat2;
		boolean generatedMarkov_disable = user_options.getMarkov_disable();
		u32 disable = generatedMarkov_disable;
		boolean generatedMarkov_classic = user_options.getMarkov_classic();
		u32 classic = generatedMarkov_classic;
		 generatedRoot_table_buf = mask_ctx.getRoot_table_buf();
		hcstat_table_t[] root_table_buf = generatedRoot_table_buf;
		 generatedMarkov_table_buf = mask_ctx.getMarkov_table_buf();
		hcstat_table_t[] markov_table_buf = generatedMarkov_table_buf;
		u64[] root_stats_buf = (u64)ModernizedCProgram.hccalloc((256 * -1024), /*Error: Unsupported expression*/);
		u64 root_stats_ptr = root_stats_buf;
		u64[][] root_stats_buf_by_pos = new u64();
		for (int i = 0;
		 i < 256; i++) {
			root_stats_buf_by_pos[i] = root_stats_ptr;
			root_stats_ptr += -1024;
		}
		u64[] markov_stats_buf = (u64)ModernizedCProgram.hccalloc((256 * -1024 * -1024), /*Error: Unsupported expression*/);
		u64 markov_stats_ptr = markov_stats_buf;
		u64[][][] markov_stats_buf_by_key = new u64();
		for (int i = 0;
		 i < 256; i++) {
			for (int j = 0;
			 j < -1024; j++) {
				markov_stats_buf_by_key[i][j] = markov_stats_ptr;
				markov_stats_ptr += -1024;
			}
		}
		byte[] hcstat_tmp = new byte[/**
		   * Load hcstats File
		   */256];
		if (hcstat == (null)) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(hcstat_tmp, /*Error: sizeof expression not supported yet*/, "%s/%s", shared_dir, "hashcat.hcstat2");
			hcstat = hcstat_tmp;
		} 
		stat s = new stat();
		if (/*Error: Function owner not recognized*/stat(hcstat, s) == -1) {
			hashcat_ctx.event_log_error("%s: %s", hcstat, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(hcstat, "rb") == 0) {
			hashcat_ctx.event_log_error("%s: %s", hcstat, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		Object generatedSt_size = s.getSt_size();
		u8 inbuf = (u8)ModernizedCProgram.hcmalloc(generatedSt_size);
		SizeT inlen = (SizeT)fp.hc_fread(inbuf, 1, generatedSt_size);
		if (inlen != (SizeT)generatedSt_size) {
			hashcat_ctx.event_log_error("%s: Could not read data.", hcstat);
			fp.hc_fclose();
			ModernizedCProgram.hcfree(inbuf);
			return -1;
		} 
		fp.hc_fclose();
		u8 outbuf = (u8)ModernizedCProgram.hcmalloc((/*Error: Unsupported expression*/ + /*Error: Unsupported expression*/ + (/*Error: Unsupported expression*/ * (256 * -1024)) + (/*Error: Unsupported expression*/ * (256 * -1024 * -1024))));
		SizeT outlen = (/*Error: Unsupported expression*/ + /*Error: Unsupported expression*/ + (/*Error: Unsupported expression*/ * (256 * -1024)) + (/*Error: Unsupported expression*/ * (256 * -1024 * -1024)));
		// lzma properties constant, retrieved with 7z2hashcatbyte props = -1024;
		SRes res = ModernizedCProgram.hc_lzma2_decompress(inbuf, inlen, outbuf, outlen, props);
		if (res != 0) {
			hashcat_ctx.event_log_error("%s: Could not uncompress data.", hcstat);
			ModernizedCProgram.hcfree(inbuf);
			ModernizedCProgram.hcfree(outbuf);
			return -1;
		} 
		if (outlen != (/*Error: Unsupported expression*/ + /*Error: Unsupported expression*/ + (/*Error: Unsupported expression*/ * (256 * -1024)) + (/*Error: Unsupported expression*/ * (256 * -1024 * -1024)))) {
			hashcat_ctx.event_log_error("%s: Could not uncompress data.", hcstat);
			ModernizedCProgram.hcfree(inbuf);
			ModernizedCProgram.hcfree(outbuf);
			return -1;
		} 
		u64 ptr = (u64)outbuf;
		u64 v = ptr++;
		u64 z = ptr++;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(root_stats_buf, ptr, /*Error: Unsupported expression*/ * (256 * -1024));
		ptr += (256 * -1024);
		/*Error: Function owner not recognized*/// ptr += SP_MARKOV_CNT;/*Error: Function owner not recognized*/// ptr += SP_MARKOV_CNT;memcpy(markov_stats_buf, ptr, /*Error: Unsupported expression*/ * (256 * -1024 * -1024));
		ModernizedCProgram.hcfree(inbuf);
		ModernizedCProgram.hcfree(outbuf/**
		   * switch endianess
		   */);
		v = ModernizedCProgram.byte_swap_64(v);
		z = ModernizedCProgram.byte_swap_64(z);
		for (int i = 0;
		 i < (256 * -1024); i++) {
			root_stats_buf[i] = ModernizedCProgram.byte_swap_64(root_stats_buf[i]);
		}
		for (int i = 0;
		 i < (256 * -1024 * -1024); i++) {
			markov_stats_buf[i] = ModernizedCProgram.byte_swap_64(markov_stats_buf[i/**
			   * verify header
			   */]);
		}
		if (v != (-1024 | -1024)) {
			hashcat_ctx.event_log_error("%s: Invalid header", hcstat);
			return -1;
		} 
		if (z != 0) {
			hashcat_ctx.event_log_error("%s: Invalid header", hcstat);
			return -1/**
			   * Markov modifier of hcstat_table on user request
			   */;
		} 
		if (disable) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(root_stats_buf, 0, (256 * -1024) * /*Error: Unsupported expression*/);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(markov_stats_buf, 0, (256 * -1024 * -1024) * /*Error: Unsupported expression*/);
		} 
		if (classic) {
			for (int i = 1;
			 i < 256; /* Add all stats to first position */i++) {
				u64 out = root_stats_buf_by_pos[0];
				u64 in = root_stats_buf_by_pos[i];
				for (int j = 0;
				 j < -1024; j++) {
					out++ += in++;
				}
			}
			for (int i = 1;
			 i < 256; i++) {
				u64 out = markov_stats_buf_by_key[0][0];
				u64 in = markov_stats_buf_by_key[i][0];
				for (int j = 0;
				 j < -1024; j++) {
					for (int k = 0;
					 k < -1024; k++) {
						out++ += in++;
					}
				}
			}
			for (int i = 1;
			 i < 256; /* copy them to all pw_positions */i++) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(root_stats_buf_by_pos[i], root_stats_buf_by_pos[0], -1024 * /*Error: Unsupported expression*/);
			}
			for (int i = 1;
			 i < 256; i++) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(markov_stats_buf_by_key[i][0], markov_stats_buf_by_key[0][0], -1024 * -1024 * /*Error: Unsupported expression*/);
			}
		} 
		hcstat_table_t root_table_ptr = /**
		   * Initialize tables
		   */root_table_buf;
		hcstat_table_t[][] root_table_buf_by_pos = new hcstat_table_t();
		for (int i = 0;
		 i < 256; i++) {
			root_table_buf_by_pos[i] = root_table_ptr;
			root_table_ptr += -1024;
		}
		hcstat_table_t markov_table_ptr = markov_table_buf;
		hcstat_table_t[][][] markov_table_buf_by_key = new hcstat_table_t();
		for (int i = 0;
		 i < 256; i++) {
			for (int j = 0;
			 j < -1024; j++) {
				markov_table_buf_by_key[i][j] = markov_table_ptr;
				markov_table_ptr += -1024;
			}
		}
		for (int i = 0;
		 i < (256 * -1024); /**
		   * Convert hcstat to tables
		   */i++) {
			u32 key = i % -1024;
			root_table_buf[i].setKey(key);
			root_table_buf[i].setVal(root_stats_buf[i]);
		}
		for (int i = 0;
		 i < (256 * -1024 * -1024); i++) {
			u32 key = i % -1024;
			markov_table_buf[i].setKey(key);
			markov_table_buf[i].setVal(markov_stats_buf[i]);
		}
		ModernizedCProgram.hcfree(root_stats_buf);
		ModernizedCProgram.hcfree(markov_stats_buf/**
		   * Finally sort them
		   */);
		for (int i = 0;
		 i < 256; i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/qsort(root_table_buf_by_pos[i], -1024, /*Error: Unsupported expression*/, sp_comp_val);
		}
		for (int i = 0;
		 i < 256; i++) {
			for (int j = 0;
			 j < -1024; j++) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/qsort(markov_table_buf_by_key[i][j], -1024, /*Error: Unsupported expression*/, sp_comp_val);
			}
		}
		return 0;
	}
	public int mask_append_final(Object mask) {
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		Object generatedMasks_avail = mask_ctx.getMasks_avail();
		Object generatedMasks_cnt = mask_ctx.getMasks_cnt();
		byte[][] generatedMasks = mask_ctx.getMasks();
		if (generatedMasks_avail == generatedMasks_cnt) {
			mask_ctx.setMasks((byte)ModernizedCProgram.hcrealloc(generatedMasks, generatedMasks_avail * /*Error: Unsupported expression*/, 1000 * /*Error: Unsupported expression*/));
			generatedMasks_avail += 1000;
		} 
		generatedMasks[generatedMasks_cnt] = ModernizedCProgram.hcstrdup(mask);
		generatedMasks_cnt++;
		return 0;
	}
	public int mask_append(Object mask, Object prepend) {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedIncrement = user_options.getIncrement();
		Object generatedOpts_type = hashconfig.getOpts_type();
		Object generatedIncrement_min = user_options.getIncrement_min();
		Object generatedIncrement_max = user_options.getIncrement_max();
		Object generatedAttack_mode = user_options.getAttack_mode();
		Object generatedPw_min = hashconfig.getPw_min();
		Object generatedPw_max = hashconfig.getPw_max();
		if (generatedIncrement == true) {
			u32 mask_length = ModernizedCProgram.mp_get_length(mask, generatedOpts_type);
			u32 increment_min = generatedIncrement_min;
			u32 increment_max = generatedIncrement_max;
			increment_max = (((increment_max) < (mask_length)) ? (increment_max) : (mask_length));
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
				u32 pw_min = generatedPw_min;
				u32 pw_max = generatedPw_max;
				increment_min = (((increment_min) > (pw_min)) ? (increment_min) : (pw_min));
				increment_max = (((increment_max) < (pw_max)) ? (increment_max) : (pw_max));
			} 
			for (u32 increment_len = increment_min;
			 increment_len <= increment_max; increment_len++) {
				Byte mask_truncated = (byte)ModernizedCProgram.hcmalloc(256);
				Byte mask_truncated_next = mask_truncated;
				if (prepend) {
					mask_truncated_next += /*Error: Function owner not recognized*/snprintf(mask_truncated, 256, "%s,", prepend);
				} 
				if (hashcat_ctx.mp_get_truncated_mask(mask, /*Error: Function owner not recognized*/strlen(mask), increment_len, mask_truncated_next) == -1) {
					ModernizedCProgram.hcfree(mask_truncated);
					break;
				} 
				int rc = hashcat_ctx.mask_append_final(mask_truncated);
				ModernizedCProgram.hcfree(mask_truncated);
				if (rc == -1) {
					return -1;
				} 
			}
		} else {
				if (prepend) {
					Byte prepend_mask = (null);
					ModernizedCProgram.hc_asprintf(prepend_mask, "%s,%s", prepend, mask);
					int rc = hashcat_ctx.mask_append_final(prepend_mask);
					ModernizedCProgram.hcfree(prepend_mask);
					if (rc == -1) {
						return -1;
					} 
				} else {
						if (hashcat_ctx.mask_append_final(mask) == -1) {
							return -1;
						} 
				} 
		} 
		return 0;
	}
	public int mask_ctx_update_loop() {
		combinator_ctx generatedCombinator_ctx = this.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Object generatedAttack_kern = user_options_extra.getAttack_kern();
		Object generatedAttack_mode = user_options.getAttack_mode();
		Object generatedOpti_type = hashconfig.getOpti_type();
		byte[][] generatedMasks = mask_ctx.getMasks();
		Object generatedMasks_pos = mask_ctx.getMasks_pos();
		Byte generatedMask = mask_ctx.getMask();
		 generatedMp_sys = mask_ctx.getMp_sys();
		 generatedMp_usr = mask_ctx.getMp_usr();
		[] generatedCss_buf = mask_ctx.getCss_buf();
		Object generatedCss_cnt = mask_ctx.getCss_cnt();
		 generatedRoot_table_buf = mask_ctx.getRoot_table_buf();
		 generatedMarkov_table_buf = mask_ctx.getMarkov_table_buf();
		 generatedRoot_css_buf = mask_ctx.getRoot_css_buf();
		 generatedMarkov_css_buf = mask_ctx.getMarkov_css_buf();
		Object generatedMarkov_threshold = user_options.getMarkov_threshold();
		Object generatedBfs_cnt = mask_ctx.getBfs_cnt();
		Object generatedCombs_cnt = combinator_ctx.getCombs_cnt();
		Object generatedPw_min = hashconfig.getPw_min();
		Object generatedPw_max = hashconfig.getPw_max();
		boolean generatedBenchmark = user_options.getBenchmark();
		Object generatedOpts_type = hashconfig.getOpts_type();
		Byte generatedTopid = logfile_ctx.getTopid();
		Byte generatedSubid = logfile_ctx.getSubid();
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		salt[] generatedSalts_buf = hashes.getSalts_buf();
		Object generatedWords_cnt = status_ctx.getWords_cnt();
		if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
			}  else if ((generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) || (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2)) {
				if (((generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) && (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2)) {
					mask_ctx.setMask(generatedMasks[generatedMasks_pos]);
					if (hashcat_ctx.mask_ctx_parse_maskfile() == -1) {
						return -1;
					} 
					if (ModernizedCProgram.mp_gen_css(hashcat_ctx, generatedMask, /*Error: Function owner not recognized*/strlen(generatedMask), generatedMp_sys, generatedMp_usr, generatedCss_buf, generatedCss_cnt) == -1) {
						return -1;
					} 
					u32[][] uniq_tbls = new u32[][]{new u32(0)};
					ModernizedCProgram.mp_css_to_uniq_tbl(hashcat_ctx, generatedCss_cnt, generatedCss_buf, uniq_tbls);
					generatedRoot_table_buf.sp_tbl_to_css(generatedMarkov_table_buf, generatedRoot_css_buf, generatedMarkov_css_buf, generatedMarkov_threshold, uniq_tbls);
					if (generatedRoot_css_buf.sp_get_sum(0, generatedCss_cnt, generatedBfs_cnt) == -1) {
						hashcat_ctx.event_log_error("Integer overflow detected in keyspace of mask: %s", generatedMask);
						return -1;
					} 
					if (hashcat_ctx.backend_session_update_mp() == -1) {
						return -1;
					} 
				} else {
						mask_ctx.setMask(generatedMasks[generatedMasks_pos]);
						if (hashcat_ctx.mask_ctx_parse_maskfile() == -1) {
							return -1;
						} 
						if (ModernizedCProgram.mp_gen_css(hashcat_ctx, generatedMask, /*Error: Function owner not recognized*/strlen(generatedMask), generatedMp_sys, generatedMp_usr, generatedCss_buf, generatedCss_cnt) == -1) {
							return -1;
						} 
						u32[][] uniq_tbls = new u32[][]{new u32(0)};
						ModernizedCProgram.mp_css_to_uniq_tbl(hashcat_ctx, generatedCss_cnt, generatedCss_buf, uniq_tbls);
						generatedRoot_table_buf.sp_tbl_to_css(generatedMarkov_table_buf, generatedRoot_css_buf, generatedMarkov_css_buf, generatedMarkov_threshold, uniq_tbls);
						if (generatedRoot_css_buf.sp_get_sum(0, generatedCss_cnt, generatedCombs_cnt) == -1) {
							hashcat_ctx.event_log_error("Integer overflow detected in keyspace of mask: %s", generatedMask);
							return -1;
						} 
						if (hashcat_ctx.backend_session_update_mp() == -1) {
							return -1;
						} 
				} 
			} 
			if (hashcat_ctx.backend_session_update_combinator() == -1) {
				return -1;
			} 
		}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_BF) {
			mask_ctx.setMask(generatedMasks[generatedMasks_pos]);
			if (hashcat_ctx.mask_ctx_parse_maskfile() == -1) {
				return -1;
			} 
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
				if (ModernizedCProgram.mp_gen_css(hashcat_ctx, generatedMask, /*Error: Function owner not recognized*/strlen(generatedMask), generatedMp_sys, generatedMp_usr, generatedCss_buf, generatedCss_cnt) == -1) {
					return -1;
				} 
				u32 pw_min = generatedPw_min;
				u32 pw_max = generatedPw_max;
				if (generatedBenchmark == true) {
					pw_min = ModernizedCProgram.mp_get_length(generatedMask, generatedOpts_type);
					pw_max = pw_min;
				} 
				hashconfig.setPw_min(pw_min);
				hashconfig.setPw_max(pw_max);
				u32 mask_min = generatedPw_min;
				u32 mask_max = generatedPw_max;
				if ((generatedCss_cnt < mask_min) || (generatedCss_cnt > mask_max)) {
					if (generatedCss_cnt < mask_min) {
						hashcat_ctx.event_log_warning("Skipping mask '%s' because it is smaller than the minimum password length.", generatedMask);
						hashcat_ctx.event_log_warning((null));
					} 
					if (generatedCss_cnt > mask_max) {
						hashcat_ctx.event_log_warning("Skipping mask '%s' because it is larger than the maximum password length.", generatedMask);
						hashcat_ctx.event_log_warning((null));
					} 
					hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, generatedSubid, ("STOP"));
					;
					return -1;
				} 
				if (generatedSlow_candidates == false) {
					if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UTF16LE) {
						if (hashcat_ctx.mp_css_utf16le_expand() == -1) {
							return -1;
						} 
					}  else if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UTF16BE) {
						if (hashcat_ctx.mp_css_utf16be_expand() == -1) {
							return -1;
						} 
					} 
				} 
				u32 css_cnt_orig = generatedCss_cnt;
				if (generatedOpti_type & opti_type.OPTI_TYPE_SINGLE_HASH) {
					if (generatedOpti_type & opti_type.OPTI_TYPE_APPENDED_SALT) {
						if (ModernizedCProgram.mp_css_append_salt(hashcat_ctx, generatedSalts_buf[0]) == -1) {
							return -1;
						} 
					} 
				} 
				u32[][] uniq_tbls = new u32[][]{new u32(0)};
				ModernizedCProgram.mp_css_to_uniq_tbl(hashcat_ctx, generatedCss_cnt, generatedCss_buf, uniq_tbls);
				generatedRoot_table_buf.sp_tbl_to_css(generatedMarkov_table_buf, generatedRoot_css_buf, generatedMarkov_css_buf, generatedMarkov_threshold, uniq_tbls);
				if (generatedRoot_css_buf.sp_get_sum(0, generatedCss_cnt, generatedWords_cnt) == -1) {
					hashcat_ctx.event_log_error("Integer overflow detected in keyspace of mask: %s", generatedMask);
					return -1;
				} 
				u32[] css_cnt_lr = new u32();
				hashcat_ctx.mp_css_split_cnt(css_cnt_orig, css_cnt_lr);
				if (generatedRoot_css_buf.sp_get_sum(0, css_cnt_lr[1], generatedBfs_cnt) == -1) {
					hashcat_ctx.event_log_error("Integer overflow detected in keyspace of mask: %s", generatedMask);
					return -1;
				} 
				if (hashcat_ctx.backend_session_update_mp_rl(css_cnt_lr[0], css_cnt_lr[1]) == -1) {
					return -1;
				} 
			} 
		} 
		return 0;
	}
	public int mask_ctx_init() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		mask_ctx.setEnabled(0);
		if (user_options.getExample_hashes() == 1) {
			return 0;
		} 
		if (user_options.getLeft() == 1) {
			return 0;
		} 
		if (user_options.getBackend_info() == 1) {
			return 0;
		} 
		if (user_options.getShow() == 1) {
			return 0;
		} 
		if (user_options.getUsage() == 1) {
			return 0;
		} 
		if (user_options.getVersion() == 1) {
			return 0;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
			return 0;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_COMBI) {
			return 0;
		} 
		mask_ctx.setEnabled(1);
		mask_ctx.setMp_sys((cs_t)ModernizedCProgram.hccalloc(8, /*Error: Unsupported expression*/));
		mask_ctx.setMp_usr((cs_t)ModernizedCProgram.hccalloc(4, /*Error: Unsupported expression*/));
		mask_ctx.setCss_buf((cs_t)ModernizedCProgram.hccalloc(256, /*Error: Unsupported expression*/));
		mask_ctx.setCss_cnt(0);
		mask_ctx.setRoot_table_buf((hcstat_table_t)ModernizedCProgram.hccalloc((256 * -1024), /*Error: Unsupported expression*/));
		mask_ctx.setMarkov_table_buf((hcstat_table_t)ModernizedCProgram.hccalloc((256 * -1024 * -1024), /*Error: Unsupported expression*/));
		if (hashcat_ctx.sp_setup_tbl() == -1) {
			return -1;
		} 
		mask_ctx.setRoot_css_buf((cs_t)ModernizedCProgram.hccalloc(256, /*Error: Unsupported expression*/));
		mask_ctx.setMarkov_css_buf((cs_t)ModernizedCProgram.hccalloc(256 * -1024, /*Error: Unsupported expression*/));
		mask_ctx.setMask_from_file(0);
		mask_ctx.setMasks((null));
		mask_ctx.setMasks_pos(0);
		mask_ctx.setMasks_cnt(0);
		mask_ctx.setMfs((mf_t)ModernizedCProgram.hccalloc(5, /*Error: Unsupported expression*/));
		 generatedMp_sys = mask_ctx.getMp_sys();
		generatedMp_sys.mp_setup_sys();
		 generatedMp_usr = mask_ctx.getMp_usr();
		if (user_options.getCustom_charset_1()) {
			if (ModernizedCProgram.mp_setup_usr(hashcat_ctx, generatedMp_sys, generatedMp_usr, user_options.getCustom_charset_1(), 0) == -1) {
				return -1;
			} 
		} 
		if (user_options.getCustom_charset_2()) {
			if (ModernizedCProgram.mp_setup_usr(hashcat_ctx, generatedMp_sys, generatedMp_usr, user_options.getCustom_charset_2(), 1) == -1) {
				return -1;
			} 
		} 
		if (user_options.getCustom_charset_3()) {
			if (ModernizedCProgram.mp_setup_usr(hashcat_ctx, generatedMp_sys, generatedMp_usr, user_options.getCustom_charset_3(), 2) == -1) {
				return -1;
			} 
		} 
		if (user_options.getCustom_charset_4()) {
			if (ModernizedCProgram.mp_setup_usr(hashcat_ctx, generatedMp_sys, generatedMp_usr, user_options.getCustom_charset_4(), 3) == -1) {
				return -1;
			} 
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
			if (user_options.getBenchmark() == 0) {
				if (user_options_extra.getHc_workc()) {
					Byte arg = user_options_extra.getHc_workv()[0];
					if (ModernizedCProgram.hc_path_exist(arg) == 0) {
						if (hashcat_ctx.mask_append(arg, (null)) == -1) {
							return -1;
						} 
					} else {
							mask_ctx.setMask_from_file(1);
							for (int i = 0;
							 i < user_options_extra.getHc_workc(); i++) {
								arg = user_options_extra.getHc_workv()[i];
								if (ModernizedCProgram.hc_path_is_file(arg) == 1) {
									HCFILE mask_fp = new HCFILE();
									if (mask_fp.hc_fopen(arg, "r") == 0) {
										hashcat_ctx.event_log_error("%s: %s", arg, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
										return -1;
									} 
									Byte line_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
									while (!mask_fp.hc_feof()) {
										size_t line_len = mask_fp.fgetl(line_buf, -1024);
										if (line_len == 0) {
											continue;
										} 
										if (line_buf[0] == (byte)'#') {
											continue;
										} 
										Byte mask_buf = ModernizedCProgram.mask_ctx_parse_maskfile_find_mask(line_buf, line_len);
										Byte prepend_buf = (null);
										if (line_buf != mask_buf) {
											prepend_buf = line_buf;
											mask_buf[-1] = 0;
										} 
										if (hashcat_ctx.mask_append(mask_buf, prepend_buf) == -1) {
											mask_fp.hc_fclose();
											return -1;
										} 
									}
									ModernizedCProgram.hcfree(line_buf);
									mask_fp.hc_fclose();
								} else {
										hashcat_ctx.event_log_error("%s: unsupported file type.", arg);
										return -1;
								} 
							}
					} 
				} else {
						Byte mask = ModernizedCProgram.DEF_MASK;
						if (hashcat_ctx.mask_append(mask, (null)) == -1) {
							return -1;
						} 
				} 
			} else {
					Byte mask = hashconfig.getBenchmark_mask();
					if (hashcat_ctx.mask_append(mask, (null)) == -1) {
						return -1;
					} 
			} 
		}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
			Byte arg = user_options_extra.getHc_workv()[user_options_extra.getHc_workc() - 1];
			if (ModernizedCProgram.hc_path_exist(arg) == 0) {
				if (hashcat_ctx.mask_append(arg, (null)) == -1) {
					return -1;
				} 
			} else {
					if (ModernizedCProgram.hc_path_is_file(arg) == 1) {
						mask_ctx.setMask_from_file(1);
						HCFILE mask_fp = new HCFILE();
						if (mask_fp.hc_fopen(arg, "r") == 0) {
							hashcat_ctx.event_log_error("%s: %s", arg, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
							return -1;
						} 
						Byte line_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
						while (!mask_fp.hc_feof()) {
							size_t line_len = mask_fp.fgetl(line_buf, -1024);
							if (line_len == 0) {
								continue;
							} 
							if (line_buf[0] == (byte)'#') {
								continue;
							} 
							Byte mask_buf = ModernizedCProgram.mask_ctx_parse_maskfile_find_mask(line_buf, line_len);
							Byte prepend_buf = (null);
							if (line_buf != mask_buf) {
								prepend_buf = line_buf;
								mask_buf[-1] = 0;
							} 
							if (hashcat_ctx.mask_append(mask_buf, prepend_buf) == -1) {
								mask_fp.hc_fclose();
								return -1;
							} 
						}
						ModernizedCProgram.hcfree(line_buf);
						mask_fp.hc_fclose();
					} else {
							hashcat_ctx.event_log_error("%s: unsupported file type.", arg);
							return -1;
					} 
			} 
		}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
			Byte arg = user_options_extra.getHc_workv()[0];
			if (ModernizedCProgram.hc_path_exist(arg) == 0) {
				if (hashcat_ctx.mask_append(arg, (null)) == -1) {
					return -1;
				} 
			} else {
					if (ModernizedCProgram.hc_path_is_file(arg) == 1) {
						mask_ctx.setMask_from_file(1);
						HCFILE mask_fp = new HCFILE();
						if (mask_fp.hc_fopen(arg, "r") == 0) {
							hashcat_ctx.event_log_error("%s: %s", arg, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
							return -1;
						} 
						Byte line_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
						while (!mask_fp.hc_feof()) {
							size_t line_len = mask_fp.fgetl(line_buf, -1024);
							if (line_len == 0) {
								continue;
							} 
							if (line_buf[0] == (byte)'#') {
								continue;
							} 
							Byte mask_buf = ModernizedCProgram.mask_ctx_parse_maskfile_find_mask(line_buf, line_len);
							Byte prepend_buf = (null);
							if (line_buf != mask_buf) {
								prepend_buf = line_buf;
								mask_buf[-1] = 0;
							} 
							if (hashcat_ctx.mask_append(mask_buf, prepend_buf) == -1) {
								mask_fp.hc_fclose();
								return -1;
							} 
						}
						ModernizedCProgram.hcfree(line_buf);
						mask_fp.hc_fclose();
					} else {
							hashcat_ctx.event_log_error("%s: unsupported file type.", arg);
							return -1;
					} 
			} 
		} 
		Object generatedMasks_cnt = mask_ctx.getMasks_cnt();
		if (generatedMasks_cnt == 0) {
			hashcat_ctx.event_log_error("Invalid mask.");
			return -1;
		} 
		byte[][] generatedMasks = mask_ctx.getMasks();
		mask_ctx.setMask(generatedMasks[0]);
		return 0;
	}
	public void mask_ctx_destroy() {
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		boolean generatedEnabled = mask_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		 generatedMp_sys = mask_ctx.getMp_sys();
		ModernizedCProgram.hcfree(generatedMp_sys);
		 generatedMp_usr = mask_ctx.getMp_usr();
		ModernizedCProgram.hcfree(generatedMp_usr);
		[] generatedCss_buf = mask_ctx.getCss_buf();
		ModernizedCProgram.hcfree(generatedCss_buf);
		 generatedRoot_css_buf = mask_ctx.getRoot_css_buf();
		ModernizedCProgram.hcfree(generatedRoot_css_buf);
		 generatedMarkov_css_buf = mask_ctx.getMarkov_css_buf();
		ModernizedCProgram.hcfree(generatedMarkov_css_buf);
		 generatedRoot_table_buf = mask_ctx.getRoot_table_buf();
		ModernizedCProgram.hcfree(generatedRoot_table_buf);
		 generatedMarkov_table_buf = mask_ctx.getMarkov_table_buf();
		ModernizedCProgram.hcfree(generatedMarkov_table_buf);
		Object generatedMasks_cnt = mask_ctx.getMasks_cnt();
		byte[][] generatedMasks = mask_ctx.getMasks();
		for (u32 mask_pos = 0;
		 mask_pos < generatedMasks_cnt; mask_pos++) {
			ModernizedCProgram.hcfree(generatedMasks[mask_pos]);
		}
		ModernizedCProgram.hcfree(generatedMasks);
		mf generatedMfs = mask_ctx.getMfs();
		ModernizedCProgram.hcfree(generatedMfs);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(mask_ctx, 0, /*Error: Unsupported expression*/);
	}
	public int mask_ctx_parse_maskfile() {
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedEnabled = mask_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		boolean generatedMask_from_file = mask_ctx.getMask_from_file();
		if (generatedMask_from_file == false) {
			return 0;
		} 
		mf generatedMfs = mask_ctx.getMfs();
		mf_t[] mfs_buf = generatedMfs;
		mfs_buf[0].setMf_len(0);
		mfs_buf[1].setMf_len(0);
		mfs_buf[2].setMf_len(0);
		mfs_buf[3].setMf_len(0);
		mfs_buf[4].setMf_len(0);
		size_t mfs_cnt = 0;
		Byte generatedMask = mask_ctx.getMask();
		byte[] mask_buf = generatedMask;
		size_t mask_len = /*Error: Function owner not recognized*/strlen(mask_buf);
		boolean escaped = false;
		Object[] generatedMf_buf = mf.getMf_buf();
		int generatedMf_len = mf.getMf_len();
		for (size_t i = 0;
		 i < mask_len; i++) {
			mf_t mf = mfs_buf + mfs_cnt;
			if (escaped == true) {
				escaped = false;
				generatedMf_buf[generatedMf_len] = mask_buf[i];
				generatedMf_len++;
			} else {
					if (mask_buf[i] == (byte)'\\') {
						escaped = true;
					}  else if (mask_buf[i] == (byte)',') {
						generatedMf_buf[generatedMf_len] = 0;
						mfs_cnt++;
						if (mfs_cnt == 5) {
							hashcat_ctx.event_log_error("Invalid line '%s' in maskfile.", mask_buf);
							return -1;
						} 
					} else {
							generatedMf_buf[generatedMf_len] = mask_buf[i];
							generatedMf_len++;
					} 
			} 
		}
		mf_t mf = mfs_buf + mfs_cnt;
		generatedMf_buf[generatedMf_len] = 0;
		user_options.setCustom_charset_1((null));
		user_options.setCustom_charset_2((null));
		user_options.setCustom_charset_3((null));
		user_options.setCustom_charset_4((null));
		 generatedMp_usr = mask_ctx.getMp_usr();
		generatedMp_usr.mp_reset_usr(0);
		generatedMp_usr.mp_reset_usr(1);
		generatedMp_usr.mp_reset_usr(2);
		generatedMp_usr.mp_reset_usr(3);
		 generatedMp_sys = mask_ctx.getMp_sys();
		Object generatedCustom_charset_1 = user_options.getCustom_charset_1();
		Object generatedCustom_charset_2 = user_options.getCustom_charset_2();
		Object generatedCustom_charset_3 = user_options.getCustom_charset_3();
		Byte generatedCustom_charset_4 = user_options.getCustom_charset_4();
		for (size_t i = 0;
		 i < mfs_cnt; i++) {
			switch (i) {
			case 1:
					user_options.setCustom_charset_2(generatedMf_buf);
					ModernizedCProgram.mp_setup_usr(hashcat_ctx, generatedMp_sys, generatedMp_usr, generatedCustom_charset_2, 1);
					break;
			case 0:
					user_options.setCustom_charset_1(generatedMf_buf);
					ModernizedCProgram.mp_setup_usr(hashcat_ctx, generatedMp_sys, generatedMp_usr, generatedCustom_charset_1, 0);
					break;
			case 3:
					user_options.setCustom_charset_4(generatedMf_buf);
					ModernizedCProgram.mp_setup_usr(hashcat_ctx, generatedMp_sys, generatedMp_usr, generatedCustom_charset_4, 3);
					break;
			case 2:
					user_options.setCustom_charset_3(generatedMf_buf);
					ModernizedCProgram.mp_setup_usr(hashcat_ctx, generatedMp_sys, generatedMp_usr, generatedCustom_charset_3, 2);
					break;
			}
		}
		mask_ctx.setMask(generatedMf_buf);
		return 0;
	}
	public int monitor() {
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean runtime_check = false;
		boolean remove_check = false;
		boolean status_check = false;
		boolean restore_check = false;
		boolean hwmon_check = false;
		boolean performance_check = false;
		int sleep_time = 1;
		// in msdouble exec_low = 50.0;
		// in percentdouble util_low = 90.0;
		Object generatedRuntime = user_options.getRuntime();
		if (generatedRuntime) {
			runtime_check = true;
		} 
		boolean generatedEnabled = restore_ctx.getEnabled();
		if (generatedEnabled == true) {
			restore_check = true;
		} 
		boolean generatedRemove = user_options.getRemove();
		Object generatedHashlist_mode = hashes.getHashlist_mode();
		if ((generatedRemove == true) && ((generatedHashlist_mode == hl_mode.HL_MODE_FILE_PLAIN) || (generatedHashlist_mode == hl_mode.HL_MODE_FILE_BINARY))) {
			remove_check = true;
		} 
		boolean generatedStatus = user_options.getStatus();
		if (generatedStatus == true) {
			status_check = true;
		} 
		if (generatedEnabled == true) {
			hwmon_check = true;
		} 
		if (generatedEnabled == true) {
			performance_check = true;
		} 
		if ((runtime_check == false) && (remove_check == false) && (status_check == false) && (restore_check == false) && (hwmon_check == false) && (performance_check == false)) {
			return 0;
		} 
		// timeru32 slowdown_warnings = 0;
		u32 performance_warnings = 0;
		Object generatedRestore_timer = user_options.getRestore_timer();
		u32 restore_left = generatedRestore_timer;
		Object generatedRemove_timer = user_options.getRemove_timer();
		u32 remove_left = generatedRemove_timer;
		Object generatedStatus_timer = user_options.getStatus_timer();
		u32 status_left = generatedStatus_timer;
		boolean generatedShutdown_inner = status_ctx.getShutdown_inner();
		Object generatedDevices_status = status_ctx.getDevices_status();
		Object generatedMux_hwmon = status_ctx.getMux_hwmon();
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		Object generatedHwmon_temp_abort = user_options.getHwmon_temp_abort();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedRuntime_start = status_ctx.getRuntime_start();
		Object generatedDigests_saved = hashes.getDigests_saved();
		Object generatedDigests_done = hashes.getDigests_done();
		Object generatedMux_display = status_ctx.getMux_display();
		Object generatedStdin_timeout_abort = user_options.getStdin_timeout_abort();
		Object generatedStdin_read_timeout_cnt = status_ctx.getStdin_read_timeout_cnt();
		while (generatedShutdown_inner == false) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/sleep(sleep_time);
			if (generatedDevices_status == status_rc.STATUS_INIT) {
				continue;
			} 
			if (generatedEnabled == true) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject(generatedMux_hwmon, -1024);
				for (int backend_devices_idx = 0;
				 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
					hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
					if (generatedSkipped == true) {
						continue;
					} 
					if ((generatedDevices_param[backend_devices_idx].getOpencl_device_type() & CL_DEVICE_TYPE_GPU) == 0) {
						continue;
					} 
					int temperature = hashcat_ctx.hm_get_temperature_with_devices_idx(backend_devices_idx);
					if (temperature > (int)generatedHwmon_temp_abort) {
						hashcat_ctx.event_call((event_identifier.EVENT_MONITOR_TEMP_ABORT), (backend_devices_idx), (/*Error: Unsupported expression*/));
						hashcat_ctx.myabort();
					} 
				}
				for (int backend_devices_idx = 0;
				 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
					hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
					if (generatedSkipped == true) {
						continue;
					} 
					if (generatedSkipped_warning == true) {
						continue;
					} 
					int rc_throttle = hashcat_ctx.hm_get_throttle_with_devices_idx(backend_devices_idx);
					if (rc_throttle == -1) {
						continue;
					} 
					if (rc_throttle > 0) {
						slowdown_warnings++;
						if (slowdown_warnings == 1) {
							hashcat_ctx.event_call((event_identifier.EVENT_MONITOR_THROTTLE1), (backend_devices_idx), (/*Error: Unsupported expression*/));
						} 
						if (slowdown_warnings == 2) {
							hashcat_ctx.event_call((event_identifier.EVENT_MONITOR_THROTTLE2), (backend_devices_idx), (/*Error: Unsupported expression*/));
						} 
						if (slowdown_warnings == 3) {
							hashcat_ctx.event_call((event_identifier.EVENT_MONITOR_THROTTLE3), (backend_devices_idx), (/*Error: Unsupported expression*/));
						} 
					} else {
							if (slowdown_warnings > 0) {
								slowdown_warnings--;
							} 
					} 
				}
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseMutex(generatedMux_hwmon);
			} 
			if (restore_check == true) {
				restore_left--;
				if (restore_left == 0) {
					int rc = hashcat_ctx.cycle_restore();
					if (rc == -1) {
						return -1;
					} 
					restore_left = generatedRestore_timer;
				} 
			} 
			if ((runtime_check == true) && (generatedRuntime_start > 0)) {
				int runtime_left = ModernizedCProgram.get_runtime_left(hashcat_ctx);
				if (runtime_left <= 0) {
					hashcat_ctx.event_call((event_identifier.EVENT_MONITOR_RUNTIME_LIMIT), ((null)), (false));
					hashcat_ctx.myabort_runtime();
				} 
			} 
			if (remove_check == true) {
				remove_left--;
				if (remove_left == 0) {
					if (generatedDigests_saved != generatedDigests_done) {
						hashes.setDigests_saved(generatedDigests_done);
						int rc = hashcat_ctx.save_hash();
						if (rc == -1) {
							return -1;
						} 
					} 
					remove_left = generatedRemove_timer;
				} 
			} 
			if (status_check == true) {
				status_left--;
				if (status_left == 0) {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject(generatedMux_display, -1024);
					hashcat_ctx.event_call((event_identifier.EVENT_MONITOR_STATUS_REFRESH), ((null)), (false));
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseMutex(generatedMux_display);
					status_left = generatedStatus_timer;
				} 
			} 
			if (performance_check == true) {
				int exec_cnt = 0;
				int util_cnt = 0;
				double exec_total = 0;
				double util_total = 0;
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject(generatedMux_hwmon, -1024);
				for (int backend_devices_idx = 0;
				 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
					hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
					if (generatedSkipped == true) {
						continue;
					} 
					if (generatedSkipped_warning == true) {
						continue;
					} 
					exec_cnt++;
					double exec = ModernizedCProgram.status_get_exec_msec_dev(hashcat_ctx, backend_devices_idx);
					exec_total += exec;
					int util = hashcat_ctx.hm_get_utilization_with_devices_idx(backend_devices_idx);
					if (util == -1) {
						continue;
					} 
					util_total += (double)util;
					util_cnt++;
				}
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseMutex(generatedMux_hwmon);
				double exec_avg = 0;
				double util_avg = 0;
				if (exec_cnt > 0) {
					exec_avg = exec_total / exec_cnt;
				} 
				if (util_cnt > 0) {
					util_avg = util_total / util_cnt;
				} 
				if ((exec_avg > 0) && (exec_avg < exec_low)) {
					performance_warnings++;
					if (performance_warnings == 10) {
						hashcat_ctx.event_call((event_identifier.EVENT_MONITOR_PERFORMANCE_HINT), ((null)), (false));
					} 
				} 
				if ((util_avg > 0) && (util_avg < util_low)) {
					performance_warnings++;
					if (performance_warnings == 10) {
						hashcat_ctx.event_call((event_identifier.EVENT_MONITOR_PERFORMANCE_HINT), ((null)), (false));
					} 
				} 
			} 
			if (generatedStdin_timeout_abort != 0) {
				if (ModernizedCProgram.status_get_progress_done(hashcat_ctx) == 0) {
					if (generatedStdin_read_timeout_cnt > 0) {
						if (generatedStdin_read_timeout_cnt >= generatedStdin_timeout_abort) {
							hashcat_ctx.event_call((event_identifier.EVENT_MONITOR_NOINPUT_ABORT), ((null)), (false));
							hashcat_ctx.myabort();
							status_ctx.setShutdown_inner(1);
							break;
						} 
						if ((generatedStdin_read_timeout_cnt % 20) == 0) {
							hashcat_ctx.event_call((event_identifier.EVENT_MONITOR_NOINPUT_HINT), ((null)), (false));
						} 
					} 
				} 
			} 
		}
		// final round of save_hashif (remove_check == true) {
			if (generatedDigests_saved != generatedDigests_done) {
				int rc = hashcat_ctx.save_hash();
				if (rc == -1) {
					return -1;
				} 
			} 
		} 
		// final round of cycle_restoreif (restore_check == true) {
			int rc = hashcat_ctx.cycle_restore();
			if (rc == -1) {
				return -1;
			} 
		} 
		return 0;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public int check_running_process() {
		pidfile_ctx generatedPidfile_ctx = this.getPidfile_ctx();
		pidfile_ctx_t pidfile_ctx = generatedPidfile_ctx;
		Byte generatedFilename = pidfile_ctx.getFilename();
		Byte pidfile_filename = generatedFilename;
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(pidfile_filename, "rb") == 0) {
			return 0;
		} 
		pidfile_data_t pd = (pidfile_data_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		size_t nread = fp.hc_fread(pd, /*Error: Unsupported expression*/, 1);
		fp.hc_fclose();
		if (nread != 1) {
			ModernizedCProgram.hcfree(pd);
			return 0;
		} 
		//event_log_error (hashcat_ctx, "Cannot read %s", pidfile_filename);
		Object generatedPid = pd.getPid();
		if (generatedPid) {
			HANDLE hProcess = /*Error: Function owner not recognized*/OpenProcess((-1024 | -1024 | -1024), 0, generatedPid);
			Byte pidbin = (byte)ModernizedCProgram.hcmalloc(-1024);
			Byte pidbin2 = (byte)ModernizedCProgram.hcmalloc(-1024);
			int pidbin_len = /*Error: Function owner not recognized*/GetModuleFileNameA((null), pidbin, -1024);
			int pidbin2_len = /*Error: Function owner not recognized*/GetModuleFileNameExA(hProcess, (null), pidbin2, -1024);
			pidbin[pidbin_len] = 0;
			pidbin2[pidbin2_len] = 0;
			if (pidbin2_len) {
				if (/*Error: Function owner not recognized*/strcmp(pidbin, pidbin2) == 0) {
					hashcat_ctx.event_log_error("Already an instance %s running on pid %d", pidbin2, generatedPid);
					ModernizedCProgram.hcfree(pd);
					ModernizedCProgram.hcfree(pidbin);
					ModernizedCProgram.hcfree(pidbin2);
					return -1;
				} 
			} 
			ModernizedCProgram.hcfree(pidbin);
			ModernizedCProgram.hcfree(pidbin2);
		} 
		ModernizedCProgram.hcfree(pd);
		return 0;
	}
	public int init_pidfile() {
		pidfile_ctx generatedPidfile_ctx = this.getPidfile_ctx();
		pidfile_ctx_t pidfile_ctx = generatedPidfile_ctx;
		pidfile_data_t pd = (pidfile_data_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/);
		pidfile_ctx.setPd(pd);
		int rc = hashcat_ctx.check_running_process();
		if (rc == -1) {
			return -1;
		} 
		pd.setPid(/*Error: Function owner not recognized*/GetCurrentProcessId());
		return 0;
	}
	public int write_pidfile() {
		pidfile_ctx generatedPidfile_ctx = this.getPidfile_ctx();
		pidfile_ctx_t pidfile_ctx = generatedPidfile_ctx;
		pidfile_data_t pd = pidfile_ctx.getPd();
		Byte pidfile_filename = pidfile_ctx.getFilename();
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(pidfile_filename, "wb") == 0) {
			hashcat_ctx.event_log_error("%s: %s", pidfile_filename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		fp.hc_fwrite(pd, /*Error: Unsupported expression*/, 1);
		fp.hc_fflush();
		fp.hc_fclose();
		return 0;
	}
	public int pidfile_ctx_init() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		pidfile_ctx generatedPidfile_ctx = this.getPidfile_ctx();
		pidfile_ctx_t pidfile_ctx = generatedPidfile_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Byte generatedFilename = pidfile_ctx.getFilename();
		Byte generatedSession_dir = folder_config.getSession_dir();
		Object generatedSession = user_options.getSession();
		ModernizedCProgram.hc_asprintf(generatedFilename, "%s/%s.pid", generatedSession_dir, generatedSession);
		pidfile_ctx.setPidfile_written(0);
		int rc_init_pidfile = hashcat_ctx.init_pidfile();
		if (rc_init_pidfile == -1) {
			return -1;
		} 
		int rc = hashcat_ctx.write_pidfile();
		if (rc == 0) {
			pidfile_ctx.setPidfile_written(1);
		} 
		return 0;
	}
	public void pidfile_ctx_destroy() {
		pidfile_ctx generatedPidfile_ctx = this.getPidfile_ctx();
		pidfile_ctx_t pidfile_ctx = generatedPidfile_ctx;
		boolean generatedPidfile_written = pidfile_ctx.getPidfile_written();
		Byte generatedFilename = pidfile_ctx.getFilename();
		if (generatedPidfile_written == true) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(generatedFilename);
		} 
		ModernizedCProgram.hcfree(generatedFilename);
		pidfile_data generatedPd = pidfile_ctx.getPd();
		ModernizedCProgram.hcfree(generatedPd);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(pidfile_ctx, 0, /*Error: Unsupported expression*/);
	}
	public int hashconfig_init() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		module_ctx generatedModule_ctx = this.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		// set some boring defaults
		hashconfig.setBenchmark_mask(ModernizedCProgram.default_benchmark_mask(hashconfig, user_options, user_options_extra));
		hashconfig.setDictstat_disable(ModernizedCProgram.default_dictstat_disable(hashconfig, user_options, user_options_extra));
		hashconfig.setEsalt_size(ModernizedCProgram.default_esalt_size(hashconfig, user_options, user_options_extra));
		hashconfig.setForced_outfile_format(ModernizedCProgram.default_forced_outfile_format(hashconfig, user_options, user_options_extra));
		hashconfig.setHash_mode(ModernizedCProgram.default_hash_mode(hashconfig, user_options, user_options_extra));
		hashconfig.setHashes_count_min(ModernizedCProgram.default_hashes_count_min(hashconfig, user_options, user_options_extra));
		hashconfig.setHashes_count_max(ModernizedCProgram.default_hashes_count_max(hashconfig, user_options, user_options_extra));
		hashconfig.setHlfmt_disable(ModernizedCProgram.default_hlfmt_disable(hashconfig, user_options, user_options_extra));
		hashconfig.setHook_salt_size(ModernizedCProgram.default_hook_salt_size(hashconfig, user_options, user_options_extra));
		hashconfig.setHook_size(ModernizedCProgram.default_hook_size(hashconfig, user_options, user_options_extra));
		hashconfig.setKernel_accel_min(ModernizedCProgram.default_kernel_accel_min(hashconfig, user_options, user_options_extra));
		hashconfig.setKernel_accel_max(ModernizedCProgram.default_kernel_accel_max(hashconfig, user_options, user_options_extra));
		hashconfig.setKernel_loops_min(ModernizedCProgram.default_kernel_loops_min(hashconfig, user_options, user_options_extra));
		hashconfig.setKernel_loops_max(ModernizedCProgram.default_kernel_loops_max(hashconfig, user_options, user_options_extra));
		hashconfig.setKernel_threads_min(ModernizedCProgram.default_kernel_threads_min(hashconfig, user_options, user_options_extra));
		hashconfig.setKernel_threads_max(ModernizedCProgram.default_kernel_threads_max(hashconfig, user_options, user_options_extra));
		hashconfig.setOutfile_check_disable(ModernizedCProgram.default_outfile_check_disable(hashconfig, user_options, user_options_extra));
		hashconfig.setOutfile_check_nocomp(ModernizedCProgram.default_outfile_check_nocomp(hashconfig, user_options, user_options_extra));
		hashconfig.setPotfile_disable(ModernizedCProgram.default_potfile_disable(hashconfig, user_options, user_options_extra));
		hashconfig.setPotfile_keep_all_hashes(ModernizedCProgram.default_potfile_keep_all_hashes(hashconfig, user_options, user_options_extra));
		hashconfig.setPwdump_column(ModernizedCProgram.default_pwdump_column(hashconfig, user_options, user_options_extra));
		hashconfig.setSeparator(ModernizedCProgram.default_separator(hashconfig, user_options, user_options_extra));
		hashconfig.setTmp_size(ModernizedCProgram.default_tmp_size(hashconfig, user_options, user_options_extra));
		hashconfig.setWarmup_disable(ModernizedCProgram.default_warmup_disable(hashconfig, user_options, user_options_extra))// finally, the real stuff;// finally, the real stuff
		boolean rc_load = ModernizedCProgram.module_load(hashcat_ctx, module_ctx, user_options.getHash_mode());
		if (rc_load == 0) {
			return -1;
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(module_ctx);
		Object generatedModule_context_size = module_ctx.getModule_context_size();
		if (generatedModule_context_size != ModernizedCProgram.MODULE_CONTEXT_SIZE_CURRENT) {
			hashcat_ctx.event_log_error("module context size is invalid. Old template?");
			return -1;
		} 
		int generatedModule_interface_version = module_ctx.getModule_interface_version();
		if (generatedModule_interface_version < ModernizedCProgram.MODULE_INTERFACE_VERSION_MINIMUM) {
			hashcat_ctx.event_log_error("module interface version is outdated, please compile");
			return -1;
		} 
		Object generatedModule_attack_exec = module_ctx.getModule_attack_exec();
		if ((generatedModule_attack_exec) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_benchmark_esalt = module_ctx.getModule_benchmark_esalt();
		if ((generatedModule_benchmark_esalt) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_benchmark_hook_salt = module_ctx.getModule_benchmark_hook_salt();
		if ((generatedModule_benchmark_hook_salt) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_benchmark_mask = module_ctx.getModule_benchmark_mask();
		if ((generatedModule_benchmark_mask) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_benchmark_salt = module_ctx.getModule_benchmark_salt();
		if ((generatedModule_benchmark_salt) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_build_plain_postprocess = module_ctx.getModule_build_plain_postprocess();
		if ((generatedModule_build_plain_postprocess) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_deep_comp_kernel = module_ctx.getModule_deep_comp_kernel();
		if ((generatedModule_deep_comp_kernel) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_dgst_pos0 = module_ctx.getModule_dgst_pos0();
		if ((generatedModule_dgst_pos0) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_dgst_pos1 = module_ctx.getModule_dgst_pos1();
		if ((generatedModule_dgst_pos1) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_dgst_pos2 = module_ctx.getModule_dgst_pos2();
		if ((generatedModule_dgst_pos2) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_dgst_pos3 = module_ctx.getModule_dgst_pos3();
		if ((generatedModule_dgst_pos3) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_dgst_size = module_ctx.getModule_dgst_size();
		if ((generatedModule_dgst_size) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_dictstat_disable = module_ctx.getModule_dictstat_disable();
		if ((generatedModule_dictstat_disable) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_esalt_size = module_ctx.getModule_esalt_size();
		if ((generatedModule_esalt_size) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_extra_buffer_size = module_ctx.getModule_extra_buffer_size();
		if ((generatedModule_extra_buffer_size) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_extra_tmp_size = module_ctx.getModule_extra_tmp_size();
		if ((generatedModule_extra_tmp_size) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_forced_outfile_format = module_ctx.getModule_forced_outfile_format();
		if ((generatedModule_forced_outfile_format) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_binary_count = module_ctx.getModule_hash_binary_count();
		if ((generatedModule_hash_binary_count) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_binary_parse = module_ctx.getModule_hash_binary_parse();
		if ((generatedModule_hash_binary_parse) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_binary_save = module_ctx.getModule_hash_binary_save();
		if ((generatedModule_hash_binary_save) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_category = module_ctx.getModule_hash_category();
		if ((generatedModule_hash_category) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_decode = module_ctx.getModule_hash_decode();
		if ((generatedModule_hash_decode) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_decode_potfile = module_ctx.getModule_hash_decode_potfile();
		if ((generatedModule_hash_decode_potfile) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_decode_zero_hash = module_ctx.getModule_hash_decode_zero_hash();
		if ((generatedModule_hash_decode_zero_hash) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_encode = module_ctx.getModule_hash_encode();
		if ((generatedModule_hash_encode) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_encode_potfile = module_ctx.getModule_hash_encode_potfile();
		if ((generatedModule_hash_encode_potfile) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_encode_status = module_ctx.getModule_hash_encode_status();
		if ((generatedModule_hash_encode_status) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_init_selftest = module_ctx.getModule_hash_init_selftest();
		if ((generatedModule_hash_init_selftest) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_mode = module_ctx.getModule_hash_mode();
		if ((generatedModule_hash_mode) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hash_name = module_ctx.getModule_hash_name();
		if ((generatedModule_hash_name) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hashes_count_max = module_ctx.getModule_hashes_count_max();
		if ((generatedModule_hashes_count_max) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hashes_count_min = module_ctx.getModule_hashes_count_min();
		if ((generatedModule_hashes_count_min) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hlfmt_disable = module_ctx.getModule_hlfmt_disable();
		if ((generatedModule_hlfmt_disable) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hook12 = module_ctx.getModule_hook12();
		if ((generatedModule_hook12) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hook23 = module_ctx.getModule_hook23();
		if ((generatedModule_hook23) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hook_salt_size = module_ctx.getModule_hook_salt_size();
		if ((generatedModule_hook_salt_size) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_hook_size = module_ctx.getModule_hook_size();
		if ((generatedModule_hook_size) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_jit_build_options = module_ctx.getModule_jit_build_options();
		if ((generatedModule_jit_build_options) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_jit_cache_disable = module_ctx.getModule_jit_cache_disable();
		if ((generatedModule_jit_cache_disable) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_kern_type = module_ctx.getModule_kern_type();
		if ((generatedModule_kern_type) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_kern_type_dynamic = module_ctx.getModule_kern_type_dynamic();
		if ((generatedModule_kern_type_dynamic) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_kernel_accel_max = module_ctx.getModule_kernel_accel_max();
		if ((generatedModule_kernel_accel_max) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_kernel_accel_min = module_ctx.getModule_kernel_accel_min();
		if ((generatedModule_kernel_accel_min) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_kernel_loops_max = module_ctx.getModule_kernel_loops_max();
		if ((generatedModule_kernel_loops_max) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_kernel_loops_min = module_ctx.getModule_kernel_loops_min();
		if ((generatedModule_kernel_loops_min) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_kernel_threads_max = module_ctx.getModule_kernel_threads_max();
		if ((generatedModule_kernel_threads_max) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_kernel_threads_min = module_ctx.getModule_kernel_threads_min();
		if ((generatedModule_kernel_threads_min) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_opti_type = module_ctx.getModule_opti_type();
		if ((generatedModule_opti_type) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_opts_type = module_ctx.getModule_opts_type();
		if ((generatedModule_opts_type) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_outfile_check_disable = module_ctx.getModule_outfile_check_disable();
		if ((generatedModule_outfile_check_disable) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_outfile_check_nocomp = module_ctx.getModule_outfile_check_nocomp();
		if ((generatedModule_outfile_check_nocomp) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_potfile_custom_check = module_ctx.getModule_potfile_custom_check();
		if ((generatedModule_potfile_custom_check) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_potfile_disable = module_ctx.getModule_potfile_disable();
		if ((generatedModule_potfile_disable) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_potfile_keep_all_hashes = module_ctx.getModule_potfile_keep_all_hashes();
		if ((generatedModule_potfile_keep_all_hashes) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_pw_max = module_ctx.getModule_pw_max();
		if ((generatedModule_pw_max) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_pw_min = module_ctx.getModule_pw_min();
		if ((generatedModule_pw_min) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_pwdump_column = module_ctx.getModule_pwdump_column();
		if ((generatedModule_pwdump_column) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_salt_max = module_ctx.getModule_salt_max();
		if ((generatedModule_salt_max) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_salt_min = module_ctx.getModule_salt_min();
		if ((generatedModule_salt_min) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_salt_type = module_ctx.getModule_salt_type();
		if ((generatedModule_salt_type) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_separator = module_ctx.getModule_separator();
		if ((generatedModule_separator) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_st_hash = module_ctx.getModule_st_hash();
		if ((generatedModule_st_hash) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_st_pass = module_ctx.getModule_st_pass();
		if ((generatedModule_st_pass) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_tmp_size = module_ctx.getModule_tmp_size();
		if ((generatedModule_tmp_size) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_unstable_warning = module_ctx.getModule_unstable_warning();
		if ((generatedModule_unstable_warning) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		;
		Object generatedModule_warmup_disable = module_ctx.getModule_warmup_disable();
		if ((generatedModule_warmup_disable) == (null)) {
			hashcat_ctx.event_log_error("Missing symbol definitions. Old template?");
			return -1;
		} 
		// mandatory functions check
		;
		if ((generatedModule_attack_exec) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_dgst_pos0) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_dgst_pos1) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_dgst_pos2) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_dgst_pos3) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_dgst_size) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_hash_decode) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		// CHECK_MANDATORY (module_ctx->module_hash_encode); we do that one later
		;
		if ((generatedModule_hash_category) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_hash_name) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_kern_type) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_opti_type) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_opts_type) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_salt_type) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_st_hash) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		if ((generatedModule_st_pass) == (Object)-1) {
			hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
			return -1;
		} 
		;
		hashconfig.setAttack_exec(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setDgst_pos0(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setDgst_pos1(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setDgst_pos2(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setDgst_pos3(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setDgst_size(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setHash_category(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setHash_name(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setKern_type(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setOpti_type(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setOpts_type(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setSalt_type(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setSt_hash(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		hashconfig.setSt_pass(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		Object generatedOpts_type = hashconfig.getOpts_type();
		if ((generatedOpts_type & opts_type.OPTS_TYPE_BINARY_HASHFILE) == 0) {
			if ((generatedModule_hash_encode) == (Object)-1) {
				hashcat_ctx.event_log_error("Missing mandatory symbol definitions");
				return -1;
			} 
			;
		} 
		if (generatedModule_benchmark_mask != (Object)-1) {
			hashconfig.setBenchmark_mask(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_dictstat_disable != (Object)-1) {
			hashconfig.setDictstat_disable(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_esalt_size != (Object)-1) {
			hashconfig.setEsalt_size(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_forced_outfile_format != (Object)-1) {
			hashconfig.setForced_outfile_format(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_hash_mode != (Object)-1) {
			hashconfig.setHash_mode(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_hashes_count_min != (Object)-1) {
			hashconfig.setHashes_count_min(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_hashes_count_max != (Object)-1) {
			hashconfig.setHashes_count_max(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_hlfmt_disable != (Object)-1) {
			hashconfig.setHlfmt_disable(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_hook_salt_size != (Object)-1) {
			hashconfig.setHook_salt_size(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_hook_size != (Object)-1) {
			hashconfig.setHook_size(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_kernel_accel_min != (Object)-1) {
			hashconfig.setKernel_accel_min(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_kernel_accel_max != (Object)-1) {
			hashconfig.setKernel_accel_max(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_kernel_loops_min != (Object)-1) {
			hashconfig.setKernel_loops_min(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_kernel_loops_max != (Object)-1) {
			hashconfig.setKernel_loops_max(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_kernel_threads_min != (Object)-1) {
			hashconfig.setKernel_threads_min(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_kernel_threads_max != (Object)-1) {
			hashconfig.setKernel_threads_max(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_outfile_check_disable != (Object)-1) {
			hashconfig.setOutfile_check_disable(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_outfile_check_nocomp != (Object)-1) {
			hashconfig.setOutfile_check_nocomp(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_potfile_disable != (Object)-1) {
			hashconfig.setPotfile_disable(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_potfile_keep_all_hashes != (Object)-1) {
			hashconfig.setPotfile_keep_all_hashes(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_pwdump_column != (Object)-1) {
			hashconfig.setPwdump_column(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_separator != (Object)-1) {
			hashconfig.setSeparator(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_tmp_size != (Object)-1) {
			hashconfig.setTmp_size(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_warmup_disable != (Object)-1) {
			hashconfig.setWarmup_disable(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		int generatedHash_mode = hashconfig.getHash_mode();
		if (user_options.getKeyboard_layout_mapping()) {
			if ((generatedOpts_type & opts_type.OPTS_TYPE_KEYBOARD_MAPPING) == 0) {
				hashcat_ctx.event_log_error("Parameter --keyboard-layout-mapping not valid for hash-type %u", generatedHash_mode);
				return -1;
			} 
		} 
		if (user_options.getHex_charset()) {
			generatedOpts_type |=  opts_type.OPTS_TYPE_PT_HEX;
		} 
		if (user_options.getHex_wordlist()) {
			generatedOpts_type |=  opts_type.OPTS_TYPE_PT_HEX;
		} 
		Object generatedSalt_type = hashconfig.getSalt_type();
		if (user_options.getHex_salt()) {
			if (generatedSalt_type == salt_type.SALT_TYPE_GENERIC) {
				generatedOpts_type |=  opts_type.OPTS_TYPE_ST_HEX;
			} else {
					hashcat_ctx.event_log_error("Parameter --hex-salt not valid for hash-type %u", generatedHash_mode);
					return -1;
			} 
		} 
		Object generatedOpti_type = hashconfig.getOpti_type();
		if (user_options.getKeep_guessing()) {
			generatedOpts_type |=  opts_type.OPTS_TYPE_PT_NEVERCRACK;
		} else {
				if (generatedOpti_type & opts_type.OPTS_TYPE_SUGGEST_KG) {
					if (user_options.getQuiet() == 0) {
						hashcat_ctx.event_log_warning("This hash-mode is known to emit multiple valid password candidates for the same hash.");
						hashcat_ctx.event_log_warning("Use --keep-guessing to prevent hashcat from shutdown after the hash has been cracked.");
						hashcat_ctx.event_log_warning((null));
					} 
				} 
		} 
		hashconfig.setHas_optimized_kernel(0);
		hashconfig.setHas_pure_kernel(0);
		Object generatedAttack_exec = hashconfig.getAttack_exec();
		Object generatedKern_type = hashconfig.getKern_type();
		boolean generatedHas_optimized_kernel = hashconfig.getHas_optimized_kernel();
		boolean generatedHas_pure_kernel = hashconfig.getHas_pure_kernel();
		if (generatedModule_kern_type_dynamic != (Object)-1) {
		} else {
				byte[] source_file = new byte[]{0};
				ModernizedCProgram.generate_source_kernel_filename(user_options.getSlow_candidates(), generatedAttack_exec, user_options_extra.getAttack_kern(), generatedKern_type, 0, folder_config.getShared_dir(), source_file);
				hashconfig.setHas_pure_kernel(ModernizedCProgram.hc_path_read(source_file));
				ModernizedCProgram.generate_source_kernel_filename(user_options.getSlow_candidates(), generatedAttack_exec, user_options_extra.getAttack_kern(), generatedKern_type, 1, folder_config.getShared_dir(), source_file);
				hashconfig.setHas_optimized_kernel(ModernizedCProgram.hc_path_read(source_file));
				if (user_options.getExample_hashes() == 0) {
					if (user_options.getOptimized_kernel_enable() == 1) {
						if (generatedHas_optimized_kernel == false) {
							if (user_options.getQuiet() == 0) {
								hashcat_ctx.event_log_warning("%s: Optimized kernel requested but not needed - falling back to pure kernel", source_file);
							} 
						} else {
								generatedOpti_type |=  opti_type.OPTI_TYPE_OPTIMIZED_KERNEL;
						} 
					} else {
							if (generatedHas_pure_kernel == false) {
								if (user_options.getQuiet() == 0) {
									hashcat_ctx.event_log_warning("%s: Pure kernel not found, falling back to optimized kernel", source_file);
								} 
								generatedOpti_type |=  opti_type.OPTI_TYPE_OPTIMIZED_KERNEL;
							} 
					} 
				} 
		} 
		// some hash modes tell hashcat about their exact hash-mode inside the parser (eg. luks and jwt)
		if ((generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) {
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_PT_UTF16LE;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_PT_UTF16BE;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_PT_ADD01;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_PT_ADD02;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_PT_ADD06;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_PT_ADD80;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_PT_ADDBITS14;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_PT_ADDBITS15;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_ST_UTF16LE;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_ST_UTF16BE;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_ST_ADD01;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_ST_ADD02;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_ST_ADD80;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_ST_ADDBITS14;
			generatedOpts_type &=  ~opts_type.OPTS_TYPE_ST_ADDBITS15;
			generatedOpti_type &=  ~opti_type.OPTI_TYPE_PRECOMPUTE_INIT;
			generatedOpti_type &=  ~opti_type.OPTI_TYPE_MEET_IN_MIDDLE;
			generatedOpti_type &=  ~opti_type.OPTI_TYPE_PREPENDED_SALT;
			generatedOpti_type &=  ~opti_type.OPTI_TYPE_APPENDED_SALT;
		} 
		boolean is_salted = ((generatedSalt_type == salt_type.SALT_TYPE_GENERIC) | (generatedSalt_type == salt_type.SALT_TYPE_EMBEDDED) | (generatedSalt_type == salt_type.SALT_TYPE_VIRTUAL));
		hashconfig.setIs_salted(is_salted)// those depend on some previously defined values;// those depend on some previously defined values
		hashconfig.setPw_max(ModernizedCProgram.default_pw_max(hashconfig, user_options, user_options_extra));
		hashconfig.setPw_min(ModernizedCProgram.default_pw_min(hashconfig, user_options, user_options_extra));
		hashconfig.setSalt_max(ModernizedCProgram.default_salt_max(hashconfig, user_options, user_options_extra));
		hashconfig.setSalt_min(ModernizedCProgram.default_salt_min(hashconfig, user_options, user_options_extra));
		if (generatedModule_pw_max != (Object)-1) {
			hashconfig.setPw_max(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_pw_min != (Object)-1) {
			hashconfig.setPw_min(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_salt_max != (Object)-1) {
			hashconfig.setSalt_max(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		if (generatedModule_salt_min != (Object)-1) {
			hashconfig.setSalt_min(/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, user_options, user_options_extra));
		} 
		return 0;
	}
	public void hashconfig_destroy() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		module_ctx generatedModule_ctx = this.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		module_ctx.module_unload();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(hashconfig, 0, /*Error: Unsupported expression*//**
		 * default functions
		 */);
	}
	public int status_progress_init() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		status_ctx.setWords_progress_done((u64)ModernizedCProgram.hccalloc(generatedSalts_cnt, /*Error: Unsupported expression*/));
		status_ctx.setWords_progress_rejected((u64)ModernizedCProgram.hccalloc(generatedSalts_cnt, /*Error: Unsupported expression*/));
		status_ctx.setWords_progress_restored((u64)ModernizedCProgram.hccalloc(generatedSalts_cnt, /*Error: Unsupported expression*/));
		return 0;
	}
	public void status_progress_destroy() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		Object[] generatedWords_progress_done = status_ctx.getWords_progress_done();
		ModernizedCProgram.hcfree(generatedWords_progress_done);
		Object[] generatedWords_progress_rejected = status_ctx.getWords_progress_rejected();
		ModernizedCProgram.hcfree(generatedWords_progress_rejected);
		Object[] generatedWords_progress_restored = status_ctx.getWords_progress_restored();
		ModernizedCProgram.hcfree(generatedWords_progress_restored);
		status_ctx.setWords_progress_done((null));
		status_ctx.setWords_progress_rejected((null));
		status_ctx.setWords_progress_restored((null));
	}
	public void status_progress_reset() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		Object[] generatedWords_progress_done = status_ctx.getWords_progress_done();
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedWords_progress_done, 0, generatedSalts_cnt * /*Error: Unsupported expression*/);
		Object[] generatedWords_progress_rejected = status_ctx.getWords_progress_rejected();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedWords_progress_rejected, 0, generatedSalts_cnt * /*Error: Unsupported expression*/);
		Object[] generatedWords_progress_restored = status_ctx.getWords_progress_restored();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedWords_progress_restored, 0, generatedSalts_cnt * /*Error: Unsupported expression*/);
	}
	public int status_ctx_init() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		status_ctx.setDevices_status(status_rc.STATUS_INIT);
		status_ctx.setRun_main_level1(1);
		status_ctx.setRun_main_level2(1);
		status_ctx.setRun_main_level3(1);
		status_ctx.setRun_thread_level1(1);
		status_ctx.setRun_thread_level2(1);
		status_ctx.setShutdown_inner(0);
		status_ctx.setShutdown_outer(0);
		status_ctx.setCheckpoint_shutdown(0);
		status_ctx.setHashcat_status_final((hashcat_status_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		status_ctx.setMux_dispatcher(/*Error: Function owner not recognized*/CreateMutexA((null), 0, (null)));
		status_ctx.setMux_counter(/*Error: Function owner not recognized*/CreateMutexA((null), 0, (null)));
		status_ctx.setMux_display(/*Error: Function owner not recognized*/CreateMutexA((null), 0, (null)));
		status_ctx.setMux_hwmon(/*Error: Function owner not recognized*/CreateMutexA((null), 0, (null)));
		return 0;
	}
	public void status_ctx_destroy() {
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		Object generatedMux_dispatcher = status_ctx.getMux_dispatcher();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(generatedMux_dispatcher);
		Object generatedMux_counter = status_ctx.getMux_counter();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(generatedMux_counter);
		Object generatedMux_display = status_ctx.getMux_display();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(generatedMux_display);
		Object generatedMux_hwmon = status_ctx.getMux_hwmon();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(generatedMux_hwmon);
		hashcat_status generatedHashcat_status_final = status_ctx.getHashcat_status_final();
		ModernizedCProgram.hcfree(generatedHashcat_status_final);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(status_ctx, 0, /*Error: Unsupported expression*/);
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public void event_call(Object id, Object buf, Object len) {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		boolean is_log = false;
		switch (id) {
		case event_identifier.EVENT_LOG_ERROR:
				is_log = true;
				break;
		case event_identifier.EVENT_LOG_ADVICE:
				is_log = true;
				break;
		case event_identifier.EVENT_LOG_INFO:
				is_log = true;
				break;
		case event_identifier.EVENT_LOG_WARNING:
				is_log = true;
				break;
		}
		Object generatedMux_event = event_ctx.getMux_event();
		if (is_log == false) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject(generatedMux_event, -1024);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(id, hashcat_ctx, buf, len);
		if (is_log == false) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/ReleaseMutex(generatedMux_event);
		} 
		Object[][] generatedOld_buf = event_ctx.getOld_buf();
		Object[] generatedOld_len = event_ctx.getOld_len();
		// add more back logs in case user wants to access themif (is_log == false) {
			for (int i = 10 - 1;
			 i >= 1; i--) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedOld_buf[i], generatedOld_buf[i - 1], generatedOld_len[i - 1]);
				generatedOld_len[i] = generatedOld_len[i - 1];
			}
			size_t copy_len = 0;
			if (buf) {
				size_t max_buf_len = /*Error: sizeof expression not supported yet*/;
				copy_len = (((len) < (max_buf_len - 1)) ? (len) : (max_buf_len - 1));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedOld_buf[0], buf, copy_len);
			} 
			generatedOld_len[0] = copy_len;
		} 
	}
	public Object event_log_advice_nn(Object fmt) {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		Object[] generatedMsg_buf = event_ctx.getMsg_buf();
		if (fmt == (null)) {
			generatedMsg_buf[0] = 0;
			event_ctx.setMsg_len(0);
		} else {
				va_list ap = new va_list();
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(ap, fmt);
				event_ctx.setMsg_len(ModernizedCProgram.event_log(fmt, ap, generatedMsg_buf, -1024 - 1));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(ap);
		} 
		event_ctx.setMsg_newline(0);
		hashcat_ctx.event_call(event_identifier.EVENT_LOG_ADVICE, (null), 0);
		Object generatedMsg_len = event_ctx.getMsg_len();
		return generatedMsg_len;
	}
	public Object event_log_info_nn(Object fmt) {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		Object[] generatedMsg_buf = event_ctx.getMsg_buf();
		if (fmt == (null)) {
			generatedMsg_buf[0] = 0;
			event_ctx.setMsg_len(0);
		} else {
				va_list ap = new va_list();
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(ap, fmt);
				event_ctx.setMsg_len(ModernizedCProgram.event_log(fmt, ap, generatedMsg_buf, -1024 - 1));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(ap);
		} 
		event_ctx.setMsg_newline(0);
		hashcat_ctx.event_call(event_identifier.EVENT_LOG_INFO, (null), 0);
		Object generatedMsg_len = event_ctx.getMsg_len();
		return generatedMsg_len;
	}
	public Object event_log_warning_nn(Object fmt) {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		Object[] generatedMsg_buf = event_ctx.getMsg_buf();
		if (fmt == (null)) {
			generatedMsg_buf[0] = 0;
			event_ctx.setMsg_len(0);
		} else {
				va_list ap = new va_list();
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(ap, fmt);
				event_ctx.setMsg_len(ModernizedCProgram.event_log(fmt, ap, generatedMsg_buf, -1024 - 1));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(ap);
		} 
		event_ctx.setMsg_newline(0);
		hashcat_ctx.event_call(event_identifier.EVENT_LOG_WARNING, (null), 0);
		Object generatedMsg_len = event_ctx.getMsg_len();
		return generatedMsg_len;
	}
	public Object event_log_error_nn(Object fmt) {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		Object[] generatedMsg_buf = event_ctx.getMsg_buf();
		if (fmt == (null)) {
			generatedMsg_buf[0] = 0;
			event_ctx.setMsg_len(0);
		} else {
				va_list ap = new va_list();
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(ap, fmt);
				event_ctx.setMsg_len(ModernizedCProgram.event_log(fmt, ap, generatedMsg_buf, -1024 - 1));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(ap);
		} 
		event_ctx.setMsg_newline(0);
		hashcat_ctx.event_call(event_identifier.EVENT_LOG_ERROR, (null), 0);
		Object generatedMsg_len = event_ctx.getMsg_len();
		return generatedMsg_len;
	}
	public Object event_log_advice(Object fmt) {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		Object[] generatedMsg_buf = event_ctx.getMsg_buf();
		if (fmt == (null)) {
			generatedMsg_buf[0] = 0;
			event_ctx.setMsg_len(0);
		} else {
				va_list ap = new va_list();
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(ap, fmt);
				event_ctx.setMsg_len(ModernizedCProgram.event_log(fmt, ap, generatedMsg_buf, -1024 - 1));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(ap);
		} 
		event_ctx.setMsg_newline(1);
		hashcat_ctx.event_call(event_identifier.EVENT_LOG_ADVICE, (null), 0);
		Object generatedMsg_len = event_ctx.getMsg_len();
		return generatedMsg_len;
	}
	public Object event_log_info(Object fmt) {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		Object[] generatedMsg_buf = event_ctx.getMsg_buf();
		if (fmt == (null)) {
			generatedMsg_buf[0] = 0;
			event_ctx.setMsg_len(0);
		} else {
				va_list ap = new va_list();
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(ap, fmt);
				event_ctx.setMsg_len(ModernizedCProgram.event_log(fmt, ap, generatedMsg_buf, -1024 - 1));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(ap);
		} 
		event_ctx.setMsg_newline(1);
		hashcat_ctx.event_call(event_identifier.EVENT_LOG_INFO, (null), 0);
		Object generatedMsg_len = event_ctx.getMsg_len();
		return generatedMsg_len;
	}
	public Object event_log_warning(Object fmt) {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		Object[] generatedMsg_buf = event_ctx.getMsg_buf();
		if (fmt == (null)) {
			generatedMsg_buf[0] = 0;
			event_ctx.setMsg_len(0);
		} else {
				va_list ap = new va_list();
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(ap, fmt);
				event_ctx.setMsg_len(ModernizedCProgram.event_log(fmt, ap, generatedMsg_buf, -1024 - 1));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(ap);
		} 
		event_ctx.setMsg_newline(1);
		hashcat_ctx.event_call(event_identifier.EVENT_LOG_WARNING, (null), 0);
		Object generatedMsg_len = event_ctx.getMsg_len();
		return generatedMsg_len;
	}
	public Object event_log_error(Object fmt) {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		Object[] generatedMsg_buf = event_ctx.getMsg_buf();
		if (fmt == (null)) {
			generatedMsg_buf[0] = 0;
			event_ctx.setMsg_len(0);
		} else {
				va_list ap = new va_list();
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(ap, fmt);
				event_ctx.setMsg_len(ModernizedCProgram.event_log(fmt, ap, generatedMsg_buf, -1024 - 1));
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(ap);
		} 
		event_ctx.setMsg_newline(1);
		hashcat_ctx.event_call(event_identifier.EVENT_LOG_ERROR, (null), 0);
		Object generatedMsg_len = event_ctx.getMsg_len();
		return generatedMsg_len;
	}
	public int event_ctx_init() {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(event_ctx, 0, /*Error: Unsupported expression*/);
		event_ctx.setMux_event(/*Error: Function owner not recognized*/CreateMutexA((null), 0, (null)));
		return 0;
	}
	public void event_ctx_destroy() {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		Object generatedMux_event = event_ctx.getMux_event();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/CloseHandle(generatedMux_event);
	}
	public Object brain_compute_session() {
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Object generatedBrain_session = user_options.getBrain_session();
		if (generatedBrain_session != 0) {
			return generatedBrain_session;
		} 
		int generatedHash_mode = hashconfig.getHash_mode();
		u64 seed = (u64)generatedHash_mode;
		XXH64_state_t state = ModernizedCProgram.XXH64_createState();
		state.XXH64_reset(seed);
		Object generatedOpts_type = hashconfig.getOpts_type();
		Object generatedDigests_cnt = hashes.getDigests_cnt();
		Object generatedDigests_buf = hashes.getDigests_buf();
		Object generatedDgst_size = hashconfig.getDgst_size();
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		salt[] generatedSalts_buf = hashes.getSalts_buf();
		Object generatedSalt_iter = salt.getSalt_iter();
		Object[] generatedSalt_buf = salt.getSalt_buf();
		Object generatedEsalt_size = hashconfig.getEsalt_size();
		Object generatedEsalts_buf = hashes.getEsalts_buf();
		module_ctx generatedModule_ctx = this.getModule_ctx();
		if (generatedOpts_type & opts_type.OPTS_TYPE_BINARY_HASHFILE) {
			u32 digests_cnt = generatedDigests_cnt;
			u32 digests_buf = generatedDigests_buf;
			state.XXH64_update(digests_buf, digests_cnt * generatedDgst_size);
			u32 salts_cnt = generatedSalts_cnt;
			salt_t salts_buf = generatedSalts_buf;
			for (u32 salts_idx = 0;
			 salts_idx < salts_cnt; salts_idx++) {
				salt_t salt = salts_buf + salts_idx;
				state.XXH64_update(generatedSalt_iter, /*Error: sizeof expression not supported yet*/);
				state.XXH64_update(generatedSalt_buf, /*Error: sizeof expression not supported yet*/);
			}
			if (generatedEsalt_size > 0) {
				Object esalts_buf = generatedEsalts_buf;
				state.XXH64_update(esalts_buf, digests_cnt * generatedEsalt_size);
			} 
		} else {
				Byte out_bufs = (byte)ModernizedCProgram.hccalloc(generatedDigests_cnt, /*Error: Unsupported expression*/);
				int out_idx = 0;
				u8 out_buf = (u8)ModernizedCProgram.hcmalloc(-1024);
				u32 salts_cnt = generatedSalts_cnt;
				for (u32 salts_idx = 0;
				 salts_idx < salts_cnt; salts_idx++) {
					salt_t salt_buf = generatedSalts_buf[salts_idx];
					for (u32 digest_idx = 0;
					 digest_idx < generatedDigests_cnt; digest_idx++) {
						int out_len = ModernizedCProgram.hash_encode(generatedHashconfig, generatedHashes, generatedModule_ctx, (byte)out_buf, -1024, salts_idx, digest_idx);
						out_buf[out_len] = 0;
						out_bufs[out_idx] = ModernizedCProgram.hcstrdup((byte)out_buf);
					}
				}
				ModernizedCProgram.hcfree(out_buf);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/qsort(out_bufs, out_idx, /*Error: Unsupported expression*/, ModernizedCProgram.sort_by_string);
				for (int i = 0;
				 i <= out_idx; i++) {
					size_t out_len = /*Error: Function owner not recognized*/strlen(out_bufs[out_idx]);
					state.XXH64_update(out_bufs[out_idx], out_len);
					ModernizedCProgram.hcfree(out_bufs[out_idx]);
				}
				ModernizedCProgram.hcfree(out_bufs);
		} 
		// digest
		u32 session = (u32)ModernizedCProgram.XXH64_digest(state);
		state.XXH64_freeState();
		return session;
	}
	public Object brain_compute_attack() {
		combinator_ctx generatedCombinator_ctx = this.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		XXH64_state_t state = ModernizedCProgram.XXH64_createState();
		state.XXH64_reset(user_options.getBrain_session());
		int hash_mode = hashconfig.getHash_mode();
		int attack_mode = user_options.getAttack_mode();
		state.XXH64_update(hash_mode, /*Error: sizeof expression not supported yet*/);
		state.XXH64_update(attack_mode, /*Error: sizeof expression not supported yet*/);
		int skip = user_options.getSkip();
		int limit = user_options.getLimit();
		state.XXH64_update(skip, /*Error: sizeof expression not supported yet*/);
		state.XXH64_update(limit, /*Error: sizeof expression not supported yet*/);
		int hex_salt = user_options.getHex_salt();
		state.XXH64_update(hex_salt, /*Error: sizeof expression not supported yet*/);
		int hccapx_message_pair = user_options.getHccapx_message_pair();
		state.XXH64_update(hccapx_message_pair, /*Error: sizeof expression not supported yet*/);
		int nonce_error_corrections = user_options.getNonce_error_corrections();
		state.XXH64_update(nonce_error_corrections, /*Error: sizeof expression not supported yet*/);
		int veracrypt_pim_start = user_options.getVeracrypt_pim_start();
		state.XXH64_update(veracrypt_pim_start, /*Error: sizeof expression not supported yet*/);
		int veracrypt_pim_stop = user_options.getVeracrypt_pim_stop();
		state.XXH64_update(veracrypt_pim_stop, /*Error: sizeof expression not supported yet*/);
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
			if (straight_ctx.getDict()) {
				u64 wordlist_hash = ModernizedCProgram.brain_compute_attack_wordlist(straight_ctx.getDict());
				state.XXH64_update(wordlist_hash, /*Error: sizeof expression not supported yet*/);
			} 
			int hex_wordlist = user_options.getHex_wordlist();
			state.XXH64_update(hex_wordlist, /*Error: sizeof expression not supported yet*/);
			int wordlist_autohex_disable = user_options.getWordlist_autohex_disable();
			state.XXH64_update(wordlist_autohex_disable, /*Error: sizeof expression not supported yet*/);
			if (user_options.getEncoding_from()) {
				Byte encoding_from = user_options.getEncoding_from();
				state.XXH64_update(encoding_from, /*Error: Function owner not recognized*/strlen(encoding_from));
			} 
			if (user_options.getEncoding_to()) {
				Byte encoding_to = user_options.getEncoding_to();
				state.XXH64_update(encoding_to, /*Error: Function owner not recognized*/strlen(encoding_to));
			} 
			if (user_options.getRule_buf_l()) {
				Byte rule_buf_l = user_options.getRule_buf_l();
				state.XXH64_update(rule_buf_l, /*Error: Function owner not recognized*/strlen(rule_buf_l));
			} 
			if (user_options.getRule_buf_r()) {
				Byte rule_buf_r = user_options.getRule_buf_r();
				state.XXH64_update(rule_buf_r, /*Error: Function owner not recognized*/strlen(rule_buf_r));
			} 
			int loopback = user_options.getLoopback();
			state.XXH64_update(loopback, /*Error: sizeof expression not supported yet*/);
			state.XXH64_update(straight_ctx.getKernel_rules_buf(), straight_ctx.getKernel_rules_cnt() * /*Error: Unsupported expression*/);
		}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_COMBI) {
			u64 wordlist1_hash = ModernizedCProgram.brain_compute_attack_wordlist(combinator_ctx.getDict1());
			u64 wordlist2_hash = ModernizedCProgram.brain_compute_attack_wordlist(combinator_ctx.getDict2());
			state.XXH64_update(wordlist1_hash, /*Error: sizeof expression not supported yet*/);
			state.XXH64_update(wordlist2_hash, /*Error: sizeof expression not supported yet*/);
			int hex_wordlist = user_options.getHex_wordlist();
			state.XXH64_update(hex_wordlist, /*Error: sizeof expression not supported yet*/);
			int wordlist_autohex_disable = user_options.getWordlist_autohex_disable();
			state.XXH64_update(wordlist_autohex_disable, /*Error: sizeof expression not supported yet*/);
			if (user_options.getEncoding_from()) {
				Byte encoding_from = user_options.getEncoding_from();
				state.XXH64_update(encoding_from, /*Error: Function owner not recognized*/strlen(encoding_from));
			} 
			if (user_options.getEncoding_to()) {
				Byte encoding_to = user_options.getEncoding_to();
				state.XXH64_update(encoding_to, /*Error: Function owner not recognized*/strlen(encoding_to));
			} 
			if (user_options.getRule_buf_l()) {
				Byte rule_buf_l = user_options.getRule_buf_l();
				state.XXH64_update(rule_buf_l, /*Error: Function owner not recognized*/strlen(rule_buf_l));
			} 
			if (user_options.getRule_buf_r()) {
				Byte rule_buf_r = user_options.getRule_buf_r();
				state.XXH64_update(rule_buf_r, /*Error: Function owner not recognized*/strlen(rule_buf_r));
			} 
		}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
			Byte mask = mask_ctx.getMask();
			state.XXH64_update(mask, /*Error: Function owner not recognized*/strlen(mask));
			int hex_charset = user_options.getHex_charset();
			state.XXH64_update(hex_charset, /*Error: sizeof expression not supported yet*/);
			int markov_classic = user_options.getMarkov_classic();
			int markov_disable = user_options.getMarkov_disable();
			int markov_threshold = user_options.getMarkov_threshold();
			state.XXH64_update(markov_classic, /*Error: sizeof expression not supported yet*/);
			state.XXH64_update(markov_disable, /*Error: sizeof expression not supported yet*/);
			state.XXH64_update(markov_threshold, /*Error: sizeof expression not supported yet*/);
			if (user_options.getMarkov_hcstat2()) {
				Byte markov_hcstat2 = ModernizedCProgram.filename_from_filepath(user_options.getMarkov_hcstat2());
				state.XXH64_update(markov_hcstat2, /*Error: Function owner not recognized*/strlen(markov_hcstat2));
			} 
			if (user_options.getCustom_charset_1()) {
				Byte custom_charset_1 = user_options.getCustom_charset_1();
				state.XXH64_update(custom_charset_1, /*Error: Function owner not recognized*/strlen(custom_charset_1));
			} 
			if (user_options.getCustom_charset_2()) {
				Byte custom_charset_2 = user_options.getCustom_charset_2();
				state.XXH64_update(custom_charset_2, /*Error: Function owner not recognized*/strlen(custom_charset_2));
			} 
			if (user_options.getCustom_charset_3()) {
				Byte custom_charset_3 = user_options.getCustom_charset_3();
				state.XXH64_update(custom_charset_3, /*Error: Function owner not recognized*/strlen(custom_charset_3));
			} 
			if (user_options.getCustom_charset_4()) {
				Byte custom_charset_4 = user_options.getCustom_charset_4();
				state.XXH64_update(custom_charset_4, /*Error: Function owner not recognized*/strlen(custom_charset_4));
			} 
		}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
			u64 wordlist_hash = ModernizedCProgram.brain_compute_attack_wordlist(straight_ctx.getDict());
			state.XXH64_update(wordlist_hash, /*Error: sizeof expression not supported yet*/);
			Byte mask = mask_ctx.getMask();
			state.XXH64_update(mask, /*Error: Function owner not recognized*/strlen(mask));
			int hex_charset = user_options.getHex_charset();
			state.XXH64_update(hex_charset, /*Error: sizeof expression not supported yet*/);
			int markov_classic = user_options.getMarkov_classic();
			int markov_disable = user_options.getMarkov_disable();
			int markov_threshold = user_options.getMarkov_threshold();
			state.XXH64_update(markov_classic, /*Error: sizeof expression not supported yet*/);
			state.XXH64_update(markov_disable, /*Error: sizeof expression not supported yet*/);
			state.XXH64_update(markov_threshold, /*Error: sizeof expression not supported yet*/);
			if (user_options.getMarkov_hcstat2()) {
				Byte markov_hcstat2 = ModernizedCProgram.filename_from_filepath(user_options.getMarkov_hcstat2());
				state.XXH64_update(markov_hcstat2, /*Error: Function owner not recognized*/strlen(markov_hcstat2));
			} 
			if (user_options.getCustom_charset_1()) {
				Byte custom_charset_1 = user_options.getCustom_charset_1();
				state.XXH64_update(custom_charset_1, /*Error: Function owner not recognized*/strlen(custom_charset_1));
			} 
			if (user_options.getCustom_charset_2()) {
				Byte custom_charset_2 = user_options.getCustom_charset_2();
				state.XXH64_update(custom_charset_2, /*Error: Function owner not recognized*/strlen(custom_charset_2));
			} 
			if (user_options.getCustom_charset_3()) {
				Byte custom_charset_3 = user_options.getCustom_charset_3();
				state.XXH64_update(custom_charset_3, /*Error: Function owner not recognized*/strlen(custom_charset_3));
			} 
			if (user_options.getCustom_charset_4()) {
				Byte custom_charset_4 = user_options.getCustom_charset_4();
				state.XXH64_update(custom_charset_4, /*Error: Function owner not recognized*/strlen(custom_charset_4));
			} 
			int hex_wordlist = user_options.getHex_wordlist();
			state.XXH64_update(hex_wordlist, /*Error: sizeof expression not supported yet*/);
			int wordlist_autohex_disable = user_options.getWordlist_autohex_disable();
			state.XXH64_update(wordlist_autohex_disable, /*Error: sizeof expression not supported yet*/);
			if (user_options.getEncoding_from()) {
				Byte encoding_from = user_options.getEncoding_from();
				state.XXH64_update(encoding_from, /*Error: Function owner not recognized*/strlen(encoding_from));
			} 
			if (user_options.getEncoding_to()) {
				Byte encoding_to = user_options.getEncoding_to();
				state.XXH64_update(encoding_to, /*Error: Function owner not recognized*/strlen(encoding_to));
			} 
			if (user_options.getRule_buf_l()) {
				Byte rule_buf_l = user_options.getRule_buf_l();
				state.XXH64_update(rule_buf_l, /*Error: Function owner not recognized*/strlen(rule_buf_l));
			} 
			if (user_options.getRule_buf_r()) {
				Byte rule_buf_r = user_options.getRule_buf_r();
				state.XXH64_update(rule_buf_r, /*Error: Function owner not recognized*/strlen(rule_buf_r));
			} 
		}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
			Byte mask = mask_ctx.getMask();
			state.XXH64_update(mask, /*Error: Function owner not recognized*/strlen(mask));
			u64 wordlist_hash = ModernizedCProgram.brain_compute_attack_wordlist(straight_ctx.getDict());
			state.XXH64_update(wordlist_hash, /*Error: sizeof expression not supported yet*/);
			int hex_charset = user_options.getHex_charset();
			state.XXH64_update(hex_charset, /*Error: sizeof expression not supported yet*/);
			int markov_classic = user_options.getMarkov_classic();
			int markov_disable = user_options.getMarkov_disable();
			int markov_threshold = user_options.getMarkov_threshold();
			state.XXH64_update(markov_classic, /*Error: sizeof expression not supported yet*/);
			state.XXH64_update(markov_disable, /*Error: sizeof expression not supported yet*/);
			state.XXH64_update(markov_threshold, /*Error: sizeof expression not supported yet*/);
			if (user_options.getMarkov_hcstat2()) {
				Byte markov_hcstat2 = ModernizedCProgram.filename_from_filepath(user_options.getMarkov_hcstat2());
				state.XXH64_update(markov_hcstat2, /*Error: Function owner not recognized*/strlen(markov_hcstat2));
			} 
			if (user_options.getCustom_charset_1()) {
				Byte custom_charset_1 = user_options.getCustom_charset_1();
				state.XXH64_update(custom_charset_1, /*Error: Function owner not recognized*/strlen(custom_charset_1));
			} 
			if (user_options.getCustom_charset_2()) {
				Byte custom_charset_2 = user_options.getCustom_charset_2();
				state.XXH64_update(custom_charset_2, /*Error: Function owner not recognized*/strlen(custom_charset_2));
			} 
			if (user_options.getCustom_charset_3()) {
				Byte custom_charset_3 = user_options.getCustom_charset_3();
				state.XXH64_update(custom_charset_3, /*Error: Function owner not recognized*/strlen(custom_charset_3));
			} 
			if (user_options.getCustom_charset_4()) {
				Byte custom_charset_4 = user_options.getCustom_charset_4();
				state.XXH64_update(custom_charset_4, /*Error: Function owner not recognized*/strlen(custom_charset_4));
			} 
			int hex_wordlist = user_options.getHex_wordlist();
			state.XXH64_update(hex_wordlist, /*Error: sizeof expression not supported yet*/);
			int wordlist_autohex_disable = user_options.getWordlist_autohex_disable();
			state.XXH64_update(wordlist_autohex_disable, /*Error: sizeof expression not supported yet*/);
			if (user_options.getEncoding_from()) {
				Byte encoding_from = user_options.getEncoding_from();
				state.XXH64_update(encoding_from, /*Error: Function owner not recognized*/strlen(encoding_from));
			} 
			if (user_options.getEncoding_to()) {
				Byte encoding_to = user_options.getEncoding_to();
				state.XXH64_update(encoding_to, /*Error: Function owner not recognized*/strlen(encoding_to));
			} 
			if (user_options.getRule_buf_l()) {
				Byte rule_buf_l = user_options.getRule_buf_l();
				state.XXH64_update(rule_buf_l, /*Error: Function owner not recognized*/strlen(rule_buf_l));
			} 
			if (user_options.getRule_buf_r()) {
				Byte rule_buf_r = user_options.getRule_buf_r();
				state.XXH64_update(rule_buf_r, /*Error: Function owner not recognized*/strlen(rule_buf_r));
			} 
		} 
		u32 brain_attack = (u32)ModernizedCProgram.XXH64_digest(state);
		state.XXH64_freeState();
		return brain_attack;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public int cpt_ctx_init() {
		cpt_ctx generatedCpt_ctx = this.getCpt_ctx();
		cpt_ctx_t cpt_ctx = generatedCpt_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		cpt_ctx.setEnabled(0);
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		cpt_ctx.setEnabled(1);
		cpt_ctx.setCpt_buf((cpt_t)ModernizedCProgram.hccalloc(-1024, /*Error: Unsupported expression*/));
		cpt_ctx.setCpt_total(0);
		cpt_ctx.setCpt_pos(0);
		cpt_ctx.setCpt_start(/*Error: Function owner not recognized*/time((null)));
		return 0;
	}
	public void cpt_ctx_destroy() {
		cpt_ctx generatedCpt_ctx = this.getCpt_ctx();
		cpt_ctx_t cpt_ctx = generatedCpt_ctx;
		boolean generatedEnabled = cpt_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		cpt[] generatedCpt_buf = cpt_ctx.getCpt_buf();
		ModernizedCProgram.hcfree(generatedCpt_buf);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(cpt_ctx, 0, /*Error: Unsupported expression*/);
	}
	public void cpt_ctx_reset() {
		cpt_ctx generatedCpt_ctx = this.getCpt_ctx();
		cpt_ctx_t cpt_ctx = generatedCpt_ctx;
		boolean generatedEnabled = cpt_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		cpt[] generatedCpt_buf = cpt_ctx.getCpt_buf();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedCpt_buf, 0, -1024 * /*Error: Unsupported expression*/);
		cpt_ctx.setCpt_total(0);
		cpt_ctx.setCpt_pos(0);
		cpt_ctx.setCpt_start(/*Error: Function owner not recognized*/time((null)));
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	// sysfs functions
	public boolean sysfs_init() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_sysfs = hwmon_ctx.getHm_sysfs();
		SYSFS_PTR sysfs = generatedHm_sysfs;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(sysfs, 0, /*Error: Unsupported expression*/);
		Byte path;
		ModernizedCProgram.hc_asprintf(path, "%s", ModernizedCProgram.SYS_BUS_PCI_DEVICES);
		boolean r = ModernizedCProgram.hc_path_read(path);
		ModernizedCProgram.hcfree(path);
		return r;
	}
	public void sysfs_close() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_sysfs = hwmon_ctx.getHm_sysfs();
		SYSFS_PTR sysfs = generatedHm_sysfs;
		if (sysfs) {
			ModernizedCProgram.hcfree(sysfs);
		} 
	}
	public Byte hm_SYSFS_get_syspath_device(Object backend_device_idx) {
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		hc_device_param_t device_param = generatedDevices_param[backend_device_idx];
		Byte syspath;
		Object generatedPcie_bus = device_param.getPcie_bus();
		Object generatedPcie_device = device_param.getPcie_device();
		Object generatedPcie_function = device_param.getPcie_function();
		ModernizedCProgram.hc_asprintf(syspath, "%s/0000:%02x:%02x.%01x", ModernizedCProgram.SYS_BUS_PCI_DEVICES, generatedPcie_bus, generatedPcie_device, generatedPcie_function);
		return syspath;
	}
	public Byte hm_SYSFS_get_syspath_hwmon(Object backend_device_idx) {
		Byte syspath = hashcat_ctx.hm_SYSFS_get_syspath_device(backend_device_idx);
		if (syspath == (null)) {
			hashcat_ctx.event_log_error("hm_SYSFS_get_syspath_device() failed.");
			return (null);
		} 
		Byte hwmon = ModernizedCProgram.hcmalloc(-1024);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(hwmon, -1024, "%s/hwmon", syspath);
		Byte hwmonN = ModernizedCProgram.first_file_in_directory(hwmon);
		if (hwmonN == (null)) {
			hashcat_ctx.event_log_error("First_file_in_directory() failed.");
			ModernizedCProgram.hcfree(syspath);
			ModernizedCProgram.hcfree(hwmon);
			ModernizedCProgram.hcfree(hwmonN);
			return (null);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(hwmon, -1024, "%s/hwmon/%s", syspath, hwmonN);
		ModernizedCProgram.hcfree(syspath);
		ModernizedCProgram.hcfree(hwmonN);
		return hwmon;
	}
	public int hm_SYSFS_get_fan_speed_current(Object backend_device_idx, Integer val) {
		Byte syspath = hashcat_ctx.hm_SYSFS_get_syspath_hwmon(backend_device_idx);
		if (syspath == (null)) {
			return -1;
		} 
		Byte path_cur;
		Byte path_max;
		ModernizedCProgram.hc_asprintf(path_cur, "%s/pwm1", syspath);
		ModernizedCProgram.hc_asprintf(path_max, "%s/pwm1_max", syspath);
		ModernizedCProgram.hcfree(syspath);
		HCFILE fp_cur = new HCFILE();
		if (fp_cur.hc_fopen(path_cur, "r") == 0) {
			hashcat_ctx.event_log_error("%s: %s", path_cur, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			ModernizedCProgram.hcfree(path_cur);
			ModernizedCProgram.hcfree(path_max);
			return -1;
		} 
		int pwm1_cur = 0;
		if (fp_cur.hc_fscanf("%d", pwm1_cur) != 1) {
			fp_cur.hc_fclose();
			hashcat_ctx.event_log_error("%s: unexpected data.", path_cur);
			ModernizedCProgram.hcfree(path_cur);
			ModernizedCProgram.hcfree(path_max);
			return -1;
		} 
		fp_cur.hc_fclose();
		HCFILE fp_max = new HCFILE();
		if (fp_max.hc_fopen(path_max, "r") == 0) {
			hashcat_ctx.event_log_error("%s: %s", path_max, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			ModernizedCProgram.hcfree(path_cur);
			ModernizedCProgram.hcfree(path_max);
			return -1;
		} 
		int pwm1_max = 0;
		if (fp_max.hc_fscanf("%d", pwm1_max) != 1) {
			fp_max.hc_fclose();
			hashcat_ctx.event_log_error("%s: unexpected data.", path_max);
			ModernizedCProgram.hcfree(path_cur);
			ModernizedCProgram.hcfree(path_max);
			return -1;
		} 
		fp_max.hc_fclose();
		if (pwm1_max == 0) {
			hashcat_ctx.event_log_error("%s: pwm1_max cannot be 0.", path_max);
			ModernizedCProgram.hcfree(path_cur);
			ModernizedCProgram.hcfree(path_max);
			return -1;
		} 
		double p1 = (double)pwm1_max / 100.0;
		double pwm1_percent = (double)pwm1_cur / p1;
		val = (int)pwm1_percent;
		ModernizedCProgram.hcfree(path_cur);
		ModernizedCProgram.hcfree(path_max);
		return 0;
	}
	public int hm_SYSFS_get_temperature_current(Object backend_device_idx, Integer val) {
		Byte syspath = hashcat_ctx.hm_SYSFS_get_syspath_hwmon(backend_device_idx);
		if (syspath == (null)) {
			return -1;
		} 
		Byte path;
		ModernizedCProgram.hc_asprintf(path, "%s/temp1_input", syspath);
		ModernizedCProgram.hcfree(syspath);
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(path, "r") == 0) {
			hashcat_ctx.event_log_error("%s: %s", path, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			ModernizedCProgram.hcfree(path);
			return -1;
		} 
		int temperature = 0;
		if (fp.hc_fscanf("%d", temperature) != 1) {
			fp.hc_fclose();
			hashcat_ctx.event_log_error("%s: unexpected data.", path);
			ModernizedCProgram.hcfree(path);
			return -1;
		} 
		fp.hc_fclose();
		val = temperature / 1000;
		ModernizedCProgram.hcfree(path);
		return 0;
	}
	public int hm_SYSFS_get_pp_dpm_sclk(Object backend_device_idx, Integer val) {
		Byte syspath = hashcat_ctx.hm_SYSFS_get_syspath_device(backend_device_idx);
		if (syspath == (null)) {
			return -1;
		} 
		Byte path;
		ModernizedCProgram.hc_asprintf(path, "%s/pp_dpm_sclk", syspath);
		ModernizedCProgram.hcfree(syspath);
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(path, "r") == 0) {
			hashcat_ctx.event_log_error("%s: %s", path, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			ModernizedCProgram.hcfree(path);
			return -1;
		} 
		int clockfreq = 0;
		while (!fp.hc_feof()) {
			byte[] buf = new byte[]{0};
			Byte ptr = fp.hc_fgets(buf, /*Error: sizeof expression not supported yet*/);
			if (ptr == (null)) {
				continue;
			} 
			size_t len = /*Error: Function owner not recognized*/strlen(ptr);
			if (len < 2) {
				continue;
			} 
			if (ptr[len - 2] != (byte)'*') {
				continue;
			} 
			int profile = 0;
			int rc = /*Error: Function owner not recognized*/sscanf(ptr, "%d: %dMHz", profile, clockfreq);
			if (rc == 2) {
				break;
			} 
		}
		fp.hc_fclose();
		val = clockfreq;
		ModernizedCProgram.hcfree(path);
		return 0;
	}
	public int hm_SYSFS_get_pp_dpm_mclk(Object backend_device_idx, Integer val) {
		Byte syspath = hashcat_ctx.hm_SYSFS_get_syspath_device(backend_device_idx);
		if (syspath == (null)) {
			return -1;
		} 
		Byte path;
		ModernizedCProgram.hc_asprintf(path, "%s/pp_dpm_mclk", syspath);
		ModernizedCProgram.hcfree(syspath);
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(path, "r") == 0) {
			hashcat_ctx.event_log_error("%s: %s", path, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			ModernizedCProgram.hcfree(path);
			return -1;
		} 
		int clockfreq = 0;
		while (!fp.hc_feof()) {
			byte[] buf = new byte[-1024];
			Byte ptr = fp.hc_fgets(buf, /*Error: sizeof expression not supported yet*/);
			if (ptr == (null)) {
				continue;
			} 
			size_t len = /*Error: Function owner not recognized*/strlen(ptr);
			if (len < 2) {
				continue;
			} 
			if (ptr[len - 2] != (byte)'*') {
				continue;
			} 
			int profile = 0;
			int rc = /*Error: Function owner not recognized*/sscanf(ptr, "%d: %dMHz", profile, clockfreq);
			if (rc == 2) {
				break;
			} 
		}
		fp.hc_fclose();
		val = clockfreq;
		ModernizedCProgram.hcfree(path);
		return 0;
	}
	public int hm_SYSFS_get_pp_dpm_pcie(Object backend_device_idx, Integer val) {
		Byte syspath = hashcat_ctx.hm_SYSFS_get_syspath_device(backend_device_idx);
		if (syspath == (null)) {
			return -1;
		} 
		Byte path;
		ModernizedCProgram.hc_asprintf(path, "%s/pp_dpm_pcie", syspath);
		ModernizedCProgram.hcfree(syspath);
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(path, "r") == 0) {
			hashcat_ctx.event_log_error("%s: %s", path, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			ModernizedCProgram.hcfree(path);
			return -1;
		} 
		int lanes = 0;
		while (!fp.hc_feof()) {
			byte[] buf = new byte[-1024];
			Byte ptr = fp.hc_fgets(buf, /*Error: sizeof expression not supported yet*/);
			if (ptr == (null)) {
				continue;
			} 
			size_t len = /*Error: Function owner not recognized*/strlen(ptr);
			if (len < 2) {
				continue;
			} 
			if (ptr[len - 2] != (byte)'*') {
				continue;
			} 
			int profile = 0;
			double speed = 0;
			int rc = /*Error: Function owner not recognized*/sscanf(ptr, "%d: %fGB, x%d *", profile, speed, lanes);
			if (rc == 3) {
				break;
			} 
		}
		fp.hc_fclose();
		val = lanes;
		ModernizedCProgram.hcfree(path);
		return 0;
	}
	// nvml functions
	public int nvml_init() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(nvml, 0, /*Error: Unsupported expression*/);
		nvml.setLib(ModernizedCProgram.hc_dlopen("nvml.dll"));
		if (!nvml.getLib()) {
			DWORD BufferSize = 1024;
			DWORD Type = 1;
			Byte Buffer = (byte)ModernizedCProgram.hcmalloc(BufferSize + 1);
			HKEY hKey = 0;
			if (/*Error: Function owner not recognized*/RegOpenKeyExA(((HKEY)-1024), "SOFTWARE\\NVIDIA Corporation\\Global\\NVSMI", 0, 1, hKey) == -1024) {
				if (/*Error: Function owner not recognized*/RegQueryValueExA(hKey, "NVSMIPATH", (null), Type, (LPBYTE)Buffer, BufferSize) == -1024) {
					Buffer[BufferSize] = 0;
				} else {
						return -1;
				} 
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/RegCloseKey(hKey);
			} else {
					return -1;
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/strcat(Buffer, "\\nvml.dll");
			nvml.setLib(ModernizedCProgram.hc_dlopen(Buffer));
			ModernizedCProgram.hcfree(Buffer);
		} 
		//if (user_options->quiet == false)//  event_log_error (hashcat_ctx, "NVML library load failed: %m. Proceeding without NVML HWMon enabled.");//if (user_options->quiet == false)//  event_log_error (hashcat_ctx, "Could not find NVML on this system. Proceeding without NVML HWMon enabled.");if (!nvml.getLib()) {
			return -1;
		} 
		//if (user_options->quiet == false)
		nvml.setNvmlErrorString((NVML_ERROR_STRING)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlErrorString"));
		if (0 != -1) {
			if (!nvml.getNvmlErrorString()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlErrorString", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlErrorString", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlInit((NVML_INIT)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlInit"));
		if (0 != -1) {
			if (!nvml.getNvmlInit()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlInit", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlInit", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlShutdown((NVML_SHUTDOWN)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlShutdown"));
		if (0 != -1) {
			if (!nvml.getNvmlShutdown()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlShutdown", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlShutdown", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetCount((NVML_DEVICE_GET_COUNT)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetCount"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetCount()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetCount", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetCount", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetName((NVML_DEVICE_GET_NAME)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetName"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetName()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetName", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetName", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetHandleByIndex((NVML_DEVICE_GET_HANDLE_BY_INDEX)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetHandleByIndex"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetHandleByIndex()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetHandleByIndex", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetHandleByIndex", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetTemperature((NVML_DEVICE_GET_TEMPERATURE)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetTemperature"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetTemperature()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetTemperature", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetTemperature", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetFanSpeed((NVML_DEVICE_GET_FAN_SPEED)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetFanSpeed"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetFanSpeed()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetFanSpeed", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetFanSpeed", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetUtilizationRates((NVML_DEVICE_GET_UTILIZATION_RATES)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetUtilizationRates"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetUtilizationRates()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetUtilizationRates", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetUtilizationRates", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetClockInfo((NVML_DEVICE_GET_CLOCKINFO)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetClockInfo"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetClockInfo()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetClockInfo", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetClockInfo", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetTemperatureThreshold((NVML_DEVICE_GET_THRESHOLD)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetTemperatureThreshold"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetTemperatureThreshold()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetTemperatureThreshold", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetTemperatureThreshold", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetCurrPcieLinkGeneration((NVML_DEVICE_GET_CURRPCIELINKGENERATION)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetCurrPcieLinkGeneration"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetCurrPcieLinkGeneration()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetCurrPcieLinkGeneration", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetCurrPcieLinkGeneration", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetCurrPcieLinkWidth((NVML_DEVICE_GET_CURRPCIELINKWIDTH)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetCurrPcieLinkWidth"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetCurrPcieLinkWidth()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetCurrPcieLinkWidth", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetCurrPcieLinkWidth", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetCurrentClocksThrottleReasons((NVML_DEVICE_GET_CURRENTCLOCKSTHROTTLEREASONS)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetCurrentClocksThrottleReasons"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetCurrentClocksThrottleReasons()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetCurrentClocksThrottleReasons", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetCurrentClocksThrottleReasons", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetSupportedClocksThrottleReasons((NVML_DEVICE_GET_SUPPORTEDCLOCKSTHROTTLEREASONS)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetSupportedClocksThrottleReasons"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetSupportedClocksThrottleReasons()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetSupportedClocksThrottleReasons", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetSupportedClocksThrottleReasons", "NVML");
					return 0;
				} 
			} 
		} 
		nvml.setNvmlDeviceGetPciInfo((NVML_DEVICE_GET_PCIINFO)ModernizedCProgram.hc_dlsym(nvml.getLib(), "nvmlDeviceGetPciInfo"));
		if (0 != -1) {
			if (!nvml.getNvmlDeviceGetPciInfo()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvmlDeviceGetPciInfo", "NVML");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvmlDeviceGetPciInfo", "NVML");
					return 0;
				} 
			} 
		} 
		return 0;
	}
	public void nvml_close() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		if (nvml) {
			if (nvml.getLib()) {
				ModernizedCProgram.hc_dlclose(nvml.getLib());
			} 
			ModernizedCProgram.hcfree(nvml);
		} 
	}
	public int hm_NVML_nvmlInit() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		nvmlReturn_t nvml_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME();
		if (nvml_rc != nvmlReturn_enum.NVML_SUCCESS) {
			Byte string = ModernizedCProgram.hm_NVML_nvmlErrorString(nvml, nvml_rc);
			hashcat_ctx.event_log_error("nvmlInit(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NVML_nvmlShutdown() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		nvmlReturn_t nvml_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME();
		if (nvml_rc != nvmlReturn_enum.NVML_SUCCESS) {
			Byte string = ModernizedCProgram.hm_NVML_nvmlErrorString(nvml, nvml_rc);
			hashcat_ctx.event_log_error("nvmlShutdown(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NVML_nvmlDeviceGetCount(Integer deviceCount) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		nvmlReturn_t nvml_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(deviceCount);
		if (nvml_rc != nvmlReturn_enum.NVML_SUCCESS) {
			Byte string = ModernizedCProgram.hm_NVML_nvmlErrorString(nvml, nvml_rc);
			hashcat_ctx.event_log_error("nvmlDeviceGetCount(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NVML_nvmlDeviceGetHandleByIndex(int device_index, Object device) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		nvmlReturn_t nvml_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(device_index, device);
		if (nvml_rc != nvmlReturn_enum.NVML_SUCCESS) {
			Byte string = ModernizedCProgram.hm_NVML_nvmlErrorString(nvml, nvml_rc);
			hashcat_ctx.event_log_error("nvmlDeviceGetHandleByIndex(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NVML_nvmlDeviceGetTemperature(Object device, nvmlTemperatureSensors_enum sensorType, Integer temp) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		nvmlReturn_t nvml_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(device, sensorType, temp);
		if (nvml_rc != nvmlReturn_enum.NVML_SUCCESS) {
			Byte string = ModernizedCProgram.hm_NVML_nvmlErrorString(nvml, nvml_rc);
			hashcat_ctx.event_log_error("nvmlDeviceGetTemperature(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NVML_nvmlDeviceGetFanSpeed(Object device, Integer speed) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		nvmlReturn_t nvml_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(device, speed);
		if (nvml_rc != nvmlReturn_enum.NVML_SUCCESS) {
			Byte string = ModernizedCProgram.hm_NVML_nvmlErrorString(nvml, nvml_rc);
			hashcat_ctx.event_log_error("nvmlDeviceGetFanSpeed(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NVML_nvmlDeviceGetClockInfo(Object device, nvmlClockType_enum type, Integer clockfreq) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		nvmlReturn_t nvml_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(device, type, clockfreq);
		if (nvml_rc != nvmlReturn_enum.NVML_SUCCESS) {
			Byte string = ModernizedCProgram.hm_NVML_nvmlErrorString(nvml, nvml_rc);
			hashcat_ctx.event_log_error("nvmlDeviceGetClockInfo(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NVML_nvmlDeviceGetTemperatureThreshold(Object device, nvmlTemperatureThresholds_enum thresholdType, Integer temp) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		nvmlReturn_t nvml_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(device, thresholdType, temp);
		if (nvml_rc != nvmlReturn_enum.NVML_SUCCESS) {
			Byte string = ModernizedCProgram.hm_NVML_nvmlErrorString(nvml, nvml_rc);
			hashcat_ctx.event_log_error("nvmlDeviceGetTemperatureThreshold(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NVML_nvmlDeviceGetCurrPcieLinkWidth(Object device, Integer currLinkWidth) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		nvmlReturn_t nvml_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(device, currLinkWidth);
		if (nvml_rc != nvmlReturn_enum.NVML_SUCCESS) {
			Byte string = ModernizedCProgram.hm_NVML_nvmlErrorString(nvml, nvml_rc);
			hashcat_ctx.event_log_error("nvmlDeviceGetCurrPcieLinkWidth(): %s", string);
			return -1;
		} 
		return 0;
	}
	// nvapi functions
	public int nvapi_init() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		NVAPI_PTR nvapi = generatedHm_nvapi;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(nvapi, 0, /*Error: Unsupported expression*/);
		nvapi.setLib(ModernizedCProgram.hc_dlopen("nvapi.dll"));
		// uhm yes, but .. yeahif (!nvapi.getLib()) {
			return -1;
		} 
		//if (user_options->quiet == false)
		nvapi.setNvapi_QueryInterface((NVAPI_QUERYINTERFACE)ModernizedCProgram.hc_dlsym(nvapi.getLib(), "nvapi_QueryInterface"));
		if (0 != -1) {
			if (!nvapi.getNvapi_QueryInterface()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "nvapi_QueryInterface", "NVAPI");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "nvapi_QueryInterface", "NVAPI");
					return 0;
				} 
			} 
		} 
		nvapi.setNvAPI_Initialize((NVAPI_INITIALIZE)/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(-1024));
		if (!nvapi.getNvAPI_Initialize()) {
			if (0 == 1) {
				hashcat_ctx.event_log_error("%s at address %08x is missing from %s shared library.", "NvAPI_Initialize", -1024, "NVAPI");
				return -1;
			} 
			if (0 != 1) {
				hashcat_ctx.event_log_warning("%s at address %08x is missing from %s shared library.", "NvAPI_Initialize", -1024, "NVAPI");
				return 0;
			} 
		} 
		nvapi.setNvAPI_Unload((NVAPI_UNLOAD)/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(-1024));
		if (!nvapi.getNvAPI_Unload()) {
			if (0 == 1) {
				hashcat_ctx.event_log_error("%s at address %08x is missing from %s shared library.", "NvAPI_Unload", -1024, "NVAPI");
				return -1;
			} 
			if (0 != 1) {
				hashcat_ctx.event_log_warning("%s at address %08x is missing from %s shared library.", "NvAPI_Unload", -1024, "NVAPI");
				return 0;
			} 
		} 
		nvapi.setNvAPI_GetErrorMessage((NVAPI_GETERRORMESSAGE)/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(-1024));
		if (!nvapi.getNvAPI_GetErrorMessage()) {
			if (0 == 1) {
				hashcat_ctx.event_log_error("%s at address %08x is missing from %s shared library.", "NvAPI_GetErrorMessage", -1024, "NVAPI");
				return -1;
			} 
			if (0 != 1) {
				hashcat_ctx.event_log_warning("%s at address %08x is missing from %s shared library.", "NvAPI_GetErrorMessage", -1024, "NVAPI");
				return 0;
			} 
		} 
		nvapi.setNvAPI_EnumPhysicalGPUs((NVAPI_ENUMPHYSICALGPUS)/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(-1024));
		if (!nvapi.getNvAPI_EnumPhysicalGPUs()) {
			if (0 == 1) {
				hashcat_ctx.event_log_error("%s at address %08x is missing from %s shared library.", "NvAPI_EnumPhysicalGPUs", -1024, "NVAPI");
				return -1;
			} 
			if (0 != 1) {
				hashcat_ctx.event_log_warning("%s at address %08x is missing from %s shared library.", "NvAPI_EnumPhysicalGPUs", -1024, "NVAPI");
				return 0;
			} 
		} 
		nvapi.setNvAPI_GPU_GetPerfPoliciesInfo((NVAPI_GPU_GETPERFPOLICIESINFO)/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(-1024));
		if (!nvapi.getNvAPI_GPU_GetPerfPoliciesInfo()) {
			if (0 == 1) {
				hashcat_ctx.event_log_error("%s at address %08x is missing from %s shared library.", "NvAPI_GPU_GetPerfPoliciesInfo", -1024, "NVAPI");
				return -1;
			} 
			if (0 != 1) {
				hashcat_ctx.event_log_warning("%s at address %08x is missing from %s shared library.", "NvAPI_GPU_GetPerfPoliciesInfo", -1024, "NVAPI");
				return 0;
			} 
		} 
		nvapi.setNvAPI_GPU_GetPerfPoliciesStatus((NVAPI_GPU_GETPERFPOLICIESSTATUS)/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(-1024));
		if (!nvapi.getNvAPI_GPU_GetPerfPoliciesStatus()) {
			if (0 == 1) {
				hashcat_ctx.event_log_error("%s at address %08x is missing from %s shared library.", "NvAPI_GPU_GetPerfPoliciesStatus", -1024, "NVAPI");
				return -1;
			} 
			if (0 != 1) {
				hashcat_ctx.event_log_warning("%s at address %08x is missing from %s shared library.", "NvAPI_GPU_GetPerfPoliciesStatus", -1024, "NVAPI");
				return 0;
			} 
		} 
		nvapi.setNvAPI_GPU_GetBusId((NVAPI_GPU_GETBUSID)/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(-1024));
		if (!nvapi.getNvAPI_GPU_GetBusId()) {
			if (0 == 1) {
				hashcat_ctx.event_log_error("%s at address %08x is missing from %s shared library.", "NvAPI_GPU_GetBusId", -1024, "NVAPI");
				return -1;
			} 
			if (0 != 1) {
				hashcat_ctx.event_log_warning("%s at address %08x is missing from %s shared library.", "NvAPI_GPU_GetBusId", -1024, "NVAPI");
				return 0;
			} 
		} 
		nvapi.setNvAPI_GPU_GetBusSlotId((NVAPI_GPU_GETBUSSLOTID)/*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(-1024));
		if (!nvapi.getNvAPI_GPU_GetBusSlotId()) {
			if (0 == 1) {
				hashcat_ctx.event_log_error("%s at address %08x is missing from %s shared library.", "NvAPI_GPU_GetBusSlotId", -1024, "NVAPI");
				return -1;
			} 
			if (0 != 1) {
				hashcat_ctx.event_log_warning("%s at address %08x is missing from %s shared library.", "NvAPI_GPU_GetBusSlotId", -1024, "NVAPI");
				return 0;
			} 
		} 
		return 0;
	}
	public void nvapi_close() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		NVAPI_PTR nvapi = generatedHm_nvapi;
		if (nvapi) {
			if (nvapi.getLib()) {
				ModernizedCProgram.hc_dlclose(nvapi.getLib());
			} 
			ModernizedCProgram.hcfree(nvapi);
		} 
	}
	public int hm_NvAPI_Initialize() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		NVAPI_PTR nvapi = generatedHm_nvapi;
		NvAPI_Status NvAPI_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME();
		if (NvAPI_rc == _NvAPI_Status.NVAPI_LIBRARY_NOT_FOUND) {
			return -1;
		} 
		if (NvAPI_rc != _NvAPI_Status.NVAPI_OK) {
			NvAPI_ShortString string = new NvAPI_ShortString(0);
			ModernizedCProgram.hm_NvAPI_GetErrorMessage(nvapi, NvAPI_rc, string);
			hashcat_ctx.event_log_error("NvAPI_Initialize(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NvAPI_Unload() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		NVAPI_PTR nvapi = generatedHm_nvapi;
		NvAPI_Status NvAPI_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME();
		if (NvAPI_rc != _NvAPI_Status.NVAPI_OK) {
			NvAPI_ShortString string = new NvAPI_ShortString(0);
			ModernizedCProgram.hm_NvAPI_GetErrorMessage(nvapi, NvAPI_rc, string);
			hashcat_ctx.event_log_error("NvAPI_Unload(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NvAPI_EnumPhysicalGPUs(Object nvGPUHandle, Object pGpuCount) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		NVAPI_PTR nvapi = generatedHm_nvapi;
		NvAPI_Status NvAPI_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(nvGPUHandle, pGpuCount);
		if (NvAPI_rc != _NvAPI_Status.NVAPI_OK) {
			NvAPI_ShortString string = new NvAPI_ShortString(0);
			ModernizedCProgram.hm_NvAPI_GetErrorMessage(nvapi, NvAPI_rc, string);
			hashcat_ctx.event_log_error("NvAPI_EnumPhysicalGPUs(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NvAPI_GPU_GetBusId(Object hPhysicalGpu, Object pBusId) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		NVAPI_PTR nvapi = generatedHm_nvapi;
		NvAPI_Status NvAPI_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hPhysicalGpu, pBusId);
		if (NvAPI_rc != _NvAPI_Status.NVAPI_OK) {
			NvAPI_ShortString string = new NvAPI_ShortString(0);
			ModernizedCProgram.hm_NvAPI_GetErrorMessage(nvapi, NvAPI_rc, string);
			hashcat_ctx.event_log_error("NvAPI_GPU_GetBusId(): %s", string);
			return -1;
		} 
		return 0;
	}
	public int hm_NvAPI_GPU_GetBusSlotId(Object hPhysicalGpu, Object pBusSlotId) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		NVAPI_PTR nvapi = generatedHm_nvapi;
		NvAPI_Status NvAPI_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hPhysicalGpu, pBusSlotId);
		if (NvAPI_rc != _NvAPI_Status.NVAPI_OK) {
			NvAPI_ShortString string = new NvAPI_ShortString(0);
			ModernizedCProgram.hm_NvAPI_GetErrorMessage(nvapi, NvAPI_rc, string);
			hashcat_ctx.event_log_error("NvAPI_GPU_GetBusSlotId(): %s", string);
			return -1;
		} 
		return 0;
	}
	// ADL functions
	public int adl_init() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(adl, 0, /*Error: Unsupported expression*/);
		adl.setLib(ModernizedCProgram.hc_dlopen("atiadlxx.dll"));
		if (!adl.getLib()) {
			adl.setLib(ModernizedCProgram.hc_dlopen("atiadlxy.dll"));
		} 
		if (!adl.getLib()) {
			return -1;
		} 
		//if (user_options->quiet == false)
		adl.setADL_Main_Control_Destroy((ADL_MAIN_CONTROL_DESTROY)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Main_Control_Destroy"));
		if (0 != -1) {
			if (!adl.getADL_Main_Control_Destroy()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Main_Control_Destroy", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Main_Control_Destroy", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Main_Control_Create((ADL_MAIN_CONTROL_CREATE)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Main_Control_Create"));
		if (0 != -1) {
			if (!adl.getADL_Main_Control_Create()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Main_Control_Create", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Main_Control_Create", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Adapter_NumberOfAdapters_Get((ADL_ADAPTER_NUMBEROFADAPTERS_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Adapter_NumberOfAdapters_Get"));
		if (0 != -1) {
			if (!adl.getADL_Adapter_NumberOfAdapters_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Adapter_NumberOfAdapters_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Adapter_NumberOfAdapters_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Adapter_AdapterInfo_Get((ADL_ADAPTER_ADAPTERINFO_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Adapter_AdapterInfo_Get"));
		if (0 != -1) {
			if (!adl.getADL_Adapter_AdapterInfo_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Adapter_AdapterInfo_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Adapter_AdapterInfo_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Display_DisplayInfo_Get((ADL_DISPLAY_DISPLAYINFO_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Display_DisplayInfo_Get"));
		if (0 != -1) {
			if (!adl.getADL_Display_DisplayInfo_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Display_DisplayInfo_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Display_DisplayInfo_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Adapter_ID_Get((ADL_ADAPTER_ID_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Adapter_ID_Get"));
		if (0 != -1) {
			if (!adl.getADL_Adapter_ID_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Adapter_ID_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Adapter_ID_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Adapter_VideoBiosInfo_Get((ADL_ADAPTER_VIDEOBIOSINFO_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Adapter_VideoBiosInfo_Get"));
		if (0 != -1) {
			if (!adl.getADL_Adapter_VideoBiosInfo_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Adapter_VideoBiosInfo_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Adapter_VideoBiosInfo_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive5_ThermalDevices_Enum((ADL_OVERDRIVE5_THERMALDEVICES_ENUM)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive5_ThermalDevices_Enum"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive5_ThermalDevices_Enum()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive5_ThermalDevices_Enum", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive5_ThermalDevices_Enum", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive5_Temperature_Get((ADL_OVERDRIVE5_TEMPERATURE_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive5_Temperature_Get"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive5_Temperature_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive5_Temperature_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive5_Temperature_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive6_Temperature_Get((ADL_OVERDRIVE6_TEMPERATURE_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive6_Temperature_Get"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive6_Temperature_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive6_Temperature_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive6_Temperature_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive5_CurrentActivity_Get((ADL_OVERDRIVE5_CURRENTACTIVITY_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive5_CurrentActivity_Get"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive5_CurrentActivity_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive5_CurrentActivity_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive5_CurrentActivity_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive5_FanSpeedInfo_Get((ADL_OVERDRIVE5_FANSPEEDINFO_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive5_FanSpeedInfo_Get"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive5_FanSpeedInfo_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive5_FanSpeedInfo_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive5_FanSpeedInfo_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive5_FanSpeed_Get((ADL_OVERDRIVE5_FANSPEED_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive5_FanSpeed_Get"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive5_FanSpeed_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive5_FanSpeed_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive5_FanSpeed_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive6_FanSpeed_Get((ADL_OVERDRIVE6_FANSPEED_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive6_FanSpeed_Get"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive6_FanSpeed_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive6_FanSpeed_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive6_FanSpeed_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Adapter_Active_Get((ADL_ADAPTER_ACTIVE_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Adapter_Active_Get"));
		if (0 != -1) {
			if (!adl.getADL_Adapter_Active_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Adapter_Active_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Adapter_Active_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive_Caps((ADL_OVERDRIVE_CAPS)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive_Caps"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive_Caps()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive_Caps", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive_Caps", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive6_Capabilities_Get((ADL_OVERDRIVE6_CAPABILITIES_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive6_Capabilities_Get"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive6_Capabilities_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive6_Capabilities_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive6_Capabilities_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive6_StateInfo_Get((ADL_OVERDRIVE6_STATEINFO_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive6_StateInfo_Get"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive6_StateInfo_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive6_StateInfo_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive6_StateInfo_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive6_CurrentStatus_Get((ADL_OVERDRIVE6_CURRENTSTATUS_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive6_CurrentStatus_Get"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive6_CurrentStatus_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive6_CurrentStatus_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive6_CurrentStatus_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive6_TargetTemperatureData_Get((ADL_OVERDRIVE6_TARGETTEMPERATUREDATA_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive6_TargetTemperatureData_Get"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive6_TargetTemperatureData_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive6_TargetTemperatureData_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive6_TargetTemperatureData_Get", "ADL");
					return 0;
				} 
			} 
		} 
		adl.setADL_Overdrive6_TargetTemperatureRangeInfo_Get((ADL_OVERDRIVE6_TARGETTEMPERATURERANGEINFO_GET)ModernizedCProgram.hc_dlsym(adl.getLib(), "ADL_Overdrive6_TargetTemperatureRangeInfo_Get"));
		if (0 != -1) {
			if (!adl.getADL_Overdrive6_TargetTemperatureRangeInfo_Get()) {
				if (0 == 1) {
					hashcat_ctx.event_log_error("%s is missing from %s shared library.", "ADL_Overdrive6_TargetTemperatureRangeInfo_Get", "ADL");
					return -1;
				} 
				if (0 != 1) {
					hashcat_ctx.event_log_warning("%s is missing from %s shared library.", "ADL_Overdrive6_TargetTemperatureRangeInfo_Get", "ADL");
					return 0;
				} 
			} 
		} 
		return 0;
	}
	public void adl_close() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		if (adl) {
			if (adl.getLib()) {
				ModernizedCProgram.hc_dlclose(adl.getLib());
			} 
			ModernizedCProgram.hcfree(adl);
		} 
	}
	public int hm_ADL_Main_Control_Destroy() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		int ADL_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME();
		if (ADL_rc != 0) {
			hashcat_ctx.event_log_error("ADL_Main_Control_Destroy(): %d", ADL_rc);
			return -1;
		} 
		return 0;
	}
	public int hm_ADL_Main_Control_Create(Object callback, int iEnumConnectedAdapters) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		int ADL_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(callback, iEnumConnectedAdapters);
		if (ADL_rc != 0) {
			hashcat_ctx.event_log_error("ADL_Main_Control_Create(): %d", ADL_rc);
			return -1;
		} 
		return 0;
	}
	public int hm_ADL_Adapter_NumberOfAdapters_Get(Integer lpNumAdapters) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		int ADL_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(lpNumAdapters);
		if (ADL_rc != 0) {
			hashcat_ctx.event_log_error("ADL_Adapter_NumberOfAdapters_Get(): %d", ADL_rc);
			return -1;
		} 
		return 0;
	}
	public int hm_ADL_Adapter_AdapterInfo_Get(Object lpInfo, int iInputSize) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		int ADL_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(lpInfo, iInputSize);
		if (ADL_rc != 0) {
			hashcat_ctx.event_log_error("ADL_Adapter_AdapterInfo_Get(): %d", ADL_rc);
			return -1;
		} 
		return 0;
	}
	public int hm_ADL_Overdrive6_Temperature_Get(int iAdapterIndex, Integer iTemperature) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		int ADL_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(iAdapterIndex, iTemperature);
		if (ADL_rc != 0) {
			hashcat_ctx.event_log_error("ADL_Overdrive6_Temperature_Get(): %d", ADL_rc);
			return -1;
		} 
		return 0;
	}
	public int hm_ADL_Overdrive_Caps(int iAdapterIndex, Integer od_supported, Integer od_enabled, Integer od_version) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		int ADL_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(iAdapterIndex, od_supported, od_enabled, od_version);
		if (ADL_rc != 0) {
			hashcat_ctx.event_log_error("ADL_Overdrive_Caps(): %d", ADL_rc);
			return -1;
		} 
		return 0;
	}
	public int hm_ADL_Overdrive6_TargetTemperatureData_Get(int iAdapterIndex, Integer cur_temp, Integer default_temp) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		int ADL_rc = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(iAdapterIndex, cur_temp, default_temp);
		if (ADL_rc != 0) {
			hashcat_ctx.event_log_error("ADL_Overdrive6_TargetTemperatureData_Get(): %d", ADL_rc);
			return -1;
		} 
		return 0;
	}
	// general functions
	public int get_adapters_num_adl(Integer iNumberAdapters) {
		int hm_rc = hashcat_ctx.hm_ADL_Adapter_NumberOfAdapters_Get(iNumberAdapters);
		if (hm_rc == -1) {
			return -1;
		} 
		if (iNumberAdapters == (null)) {
			hashcat_ctx.event_log_error("No ADL adapters found.");
			return -1;
		} 
		return 0;
	}
	public int hm_get_adapter_index_nvapi(Object nvapiGPUHandle) {
		NvU32 pGpuCount = new NvU32();
		if (hashcat_ctx.hm_NvAPI_EnumPhysicalGPUs(nvapiGPUHandle, pGpuCount) == -1) {
			return 0;
		} 
		if (pGpuCount == 0) {
			hashcat_ctx.event_log_error("No NvAPI adapters found.");
			return 0;
		} 
		return (pGpuCount);
	}
	public int hm_get_adapter_index_nvml(Object[] nvmlGPUHandle) {
		int deviceCount = 0;
		hashcat_ctx.hm_NVML_nvmlDeviceGetCount(deviceCount);
		if (deviceCount == 0) {
			hashcat_ctx.event_log_error("No NVML adapters found.");
			return 0;
		} 
		for (u32 i = 0;
		 i < deviceCount; i++) {
			if (hashcat_ctx.hm_NVML_nvmlDeviceGetHandleByIndex(i, nvmlGPUHandle[i]) == -1) {
				break;
			} 
		}
		// hm_NVML_nvmlDeviceGetName (hashcat_ctx, nvGPUHandle[i], name, sizeof (name) - 1);return (deviceCount);
	}
	public int hm_get_threshold_slowdown_with_devices_idx(Object backend_device_idx) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = hwmon_ctx.getEnabled();
		if (generatedEnabled == false) {
			return -1;
		} 
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		if (generatedHm_device[backend_device_idx].getThreshold_slowdown_get_supported() == 0) {
			return -1;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		if (generatedDevices_param[backend_device_idx].getIs_cuda() == 1) {
			if (generatedHm_nvml) {
				int target = 0;
				if (hashcat_ctx.hm_NVML_nvmlDeviceGetTemperatureThreshold(generatedHm_device[backend_device_idx].getNvml(), nvmlTemperatureThresholds_enum.NVML_TEMPERATURE_THRESHOLD_SLOWDOWN, (int)target) == -1) {
					generatedHm_device[backend_device_idx].setThreshold_slowdown_get_supported(0);
					return -1;
				} 
				return target;
			} 
		} 
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		if (generatedDevices_param[backend_device_idx].getIs_opencl() == 1) {
			if ((generatedDevices_param[backend_device_idx].getOpencl_device_type() & CL_DEVICE_TYPE_GPU) == 0) {
				return -1;
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
				if (generatedHm_adl) {
					if (generatedHm_device[backend_device_idx].getOd_version() == 5) {
					}  else if (generatedHm_device[backend_device_idx].getOd_version() == 6) {
						int CurrentValue = 0;
						int DefaultValue = 0;
						if (hashcat_ctx.hm_ADL_Overdrive6_TargetTemperatureData_Get(generatedHm_device[backend_device_idx].getAdl(), CurrentValue, DefaultValue) == -1) {
							generatedHm_device[backend_device_idx].setThreshold_slowdown_get_supported(0);
							return -1;
						} 
						return DefaultValue;
					} 
				} 
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
				if (generatedHm_nvml) {
					int target = 0;
					if (hashcat_ctx.hm_NVML_nvmlDeviceGetTemperatureThreshold(generatedHm_device[backend_device_idx].getNvml(), nvmlTemperatureThresholds_enum.NVML_TEMPERATURE_THRESHOLD_SLOWDOWN, (int)target) == -1) {
						generatedHm_device[backend_device_idx].setThreshold_slowdown_get_supported(0);
						return -1;
					} 
					return target;
				} 
			} 
		} 
		generatedHm_device[backend_device_idx].setThreshold_slowdown_get_supported(0);
		return -1;
	}
	public int hm_get_threshold_shutdown_with_devices_idx(Object backend_device_idx) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = hwmon_ctx.getEnabled();
		if (generatedEnabled == false) {
			return -1;
		} 
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		if (generatedHm_device[backend_device_idx].getThreshold_shutdown_get_supported() == 0) {
			return -1;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		if (generatedDevices_param[backend_device_idx].getIs_cuda() == 1) {
			if (generatedHm_nvml) {
				int target = 0;
				if (hashcat_ctx.hm_NVML_nvmlDeviceGetTemperatureThreshold(generatedHm_device[backend_device_idx].getNvml(), nvmlTemperatureThresholds_enum.NVML_TEMPERATURE_THRESHOLD_SHUTDOWN, (int)target) == -1) {
					generatedHm_device[backend_device_idx].setThreshold_shutdown_get_supported(0);
					return -1;
				} 
				return target;
			} 
		} 
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		if (generatedDevices_param[backend_device_idx].getIs_opencl() == 1) {
			if ((generatedDevices_param[backend_device_idx].getOpencl_device_type() & CL_DEVICE_TYPE_GPU) == 0) {
				return -1;
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
				if (generatedHm_adl) {
					if (generatedHm_device[backend_device_idx].getOd_version() == 5) {
					}  else if (generatedHm_device[backend_device_idx].getOd_version() == 6) {
					} 
				} 
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
				if (generatedHm_nvml) {
					int target = 0;
					if (hashcat_ctx.hm_NVML_nvmlDeviceGetTemperatureThreshold(generatedHm_device[backend_device_idx].getNvml(), nvmlTemperatureThresholds_enum.NVML_TEMPERATURE_THRESHOLD_SHUTDOWN, (int)target) == -1) {
						generatedHm_device[backend_device_idx].setThreshold_shutdown_get_supported(0);
						return -1;
					} 
					return target;
				} 
			} 
		} 
		generatedHm_device[backend_device_idx].setThreshold_shutdown_get_supported(0);
		return -1;
	}
	public int hm_get_temperature_with_devices_idx(Object backend_device_idx) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = hwmon_ctx.getEnabled();
		if (generatedEnabled == false) {
			return -1;
		} 
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		if (generatedHm_device[backend_device_idx].getTemperature_get_supported() == 0) {
			return -1;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		if (generatedDevices_param[backend_device_idx].getIs_cuda() == 1) {
			if (generatedHm_nvml) {
				int temperature = 0;
				if (hashcat_ctx.hm_NVML_nvmlDeviceGetTemperature(generatedHm_device[backend_device_idx].getNvml(), nvmlTemperatureSensors_enum.NVML_TEMPERATURE_GPU, (u32)temperature) == -1) {
					generatedHm_device[backend_device_idx].setTemperature_get_supported(0);
					return -1;
				} 
				return temperature;
			} 
		} 
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		int generatedITemperature = Temperature.getITemperature();
		Object generatedHm_sysfs = hwmon_ctx.getHm_sysfs();
		if (generatedDevices_param[backend_device_idx].getIs_opencl() == 1) {
			if ((generatedDevices_param[backend_device_idx].getOpencl_device_type() & CL_DEVICE_TYPE_GPU) == 0) {
				return -1;
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
				if (generatedHm_adl) {
					if (generatedHm_device[backend_device_idx].getOd_version() == 5) {
						ADLTemperature Temperature = new ADLTemperature();
						Temperature.setISize(/*Error: Unsupported expression*/);
						if (ModernizedCProgram.hm_ADL_Overdrive5_Temperature_Get(hashcat_ctx, generatedHm_device[backend_device_idx].getAdl(), 0, Temperature) == -1) {
							generatedHm_device[backend_device_idx].setTemperature_get_supported(0);
							return -1;
						} 
						return generatedITemperature / 1000;
					} 
					if (generatedHm_device[backend_device_idx].getOd_version() == 6) {
						int Temperature = 0;
						if (hashcat_ctx.hm_ADL_Overdrive6_Temperature_Get(generatedHm_device[backend_device_idx].getAdl(), Temperature) == -1) {
							generatedHm_device[backend_device_idx].setTemperature_get_supported(0);
							return -1;
						} 
						return Temperature / 1000;
					} 
				} 
				if (generatedHm_sysfs) {
					int temperature = 0;
					if (hashcat_ctx.hm_SYSFS_get_temperature_current(backend_device_idx, temperature) == -1) {
						generatedHm_device[backend_device_idx].setTemperature_get_supported(0);
						return -1;
					} 
					return temperature;
				} 
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
				if (generatedHm_nvml) {
					int temperature = 0;
					if (hashcat_ctx.hm_NVML_nvmlDeviceGetTemperature(generatedHm_device[backend_device_idx].getNvml(), nvmlTemperatureSensors_enum.NVML_TEMPERATURE_GPU, (u32)temperature) == -1) {
						generatedHm_device[backend_device_idx].setTemperature_get_supported(0);
						return -1;
					} 
					return temperature;
				} 
			} 
		} 
		generatedHm_device[backend_device_idx].setTemperature_get_supported(0);
		return -1;
	}
	public int hm_get_fanpolicy_with_devices_idx(Object backend_device_idx) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = hwmon_ctx.getEnabled();
		if (generatedEnabled == false) {
			return -1;
		} 
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		if (generatedHm_device[backend_device_idx].getFanpolicy_get_supported() == 0) {
			return -1;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		if (generatedDevices_param[backend_device_idx].getIs_cuda() == 1) {
			return 1;
		} 
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		int generatedIFanSpeed = lpFanSpeedValue.getIFanSpeed();
		Object generatedHm_sysfs = hwmon_ctx.getHm_sysfs();
		if (generatedDevices_param[backend_device_idx].getIs_opencl() == 1) {
			if ((generatedDevices_param[backend_device_idx].getOpencl_device_type() & CL_DEVICE_TYPE_GPU) == 0) {
				return -1;
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
				if (generatedHm_adl) {
					if (generatedHm_device[backend_device_idx].getOd_version() == 5) {
						ADLFanSpeedValue lpFanSpeedValue = new ADLFanSpeedValue();
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(lpFanSpeedValue, 0, /*Error: sizeof expression not supported yet*/);
						lpFanSpeedValue.setISize(/*Error: sizeof expression not supported yet*/);
						lpFanSpeedValue.setISpeedType(1);
						if (ModernizedCProgram.hm_ADL_Overdrive5_FanSpeed_Get(hashcat_ctx, generatedHm_device[backend_device_idx].getAdl(), 0, lpFanSpeedValue) == -1) {
							generatedHm_device[backend_device_idx].setFanpolicy_get_supported(0);
							generatedHm_device[backend_device_idx].setFanspeed_get_supported(0);
							return -1;
						} 
						return (generatedIFanSpeed & 1) ? 0 : 1;
					} 
					if (generatedHm_device[backend_device_idx].getOd_version() == 6) {
						return 1;
					} 
				} 
				if (generatedHm_sysfs) {
					return 1;
				} 
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
				return 1;
			} 
		} 
		generatedHm_device[backend_device_idx].setFanpolicy_get_supported(0);
		generatedHm_device[backend_device_idx].setFanspeed_get_supported(0);
		return -1;
	}
	public int hm_get_fanspeed_with_devices_idx(Object backend_device_idx) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = hwmon_ctx.getEnabled();
		if (generatedEnabled == false) {
			return -1;
		} 
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		if (generatedHm_device[backend_device_idx].getFanspeed_get_supported() == 0) {
			return -1;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		if (generatedDevices_param[backend_device_idx].getIs_cuda() == 1) {
			if (generatedHm_nvml) {
				int speed = 0;
				if (hashcat_ctx.hm_NVML_nvmlDeviceGetFanSpeed(generatedHm_device[backend_device_idx].getNvml(), (u32)speed) == -1) {
					generatedHm_device[backend_device_idx].setFanspeed_get_supported(0);
					return -1;
				} 
				return speed;
			} 
		} 
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		int generatedIFanSpeed = lpFanSpeedValue.getIFanSpeed();
		int generatedIFanSpeedPercent = faninfo.getIFanSpeedPercent();
		Object generatedHm_sysfs = hwmon_ctx.getHm_sysfs();
		if (generatedDevices_param[backend_device_idx].getIs_opencl() == 1) {
			if ((generatedDevices_param[backend_device_idx].getOpencl_device_type() & CL_DEVICE_TYPE_GPU) == 0) {
				return -1;
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
				if (generatedHm_adl) {
					if (generatedHm_device[backend_device_idx].getOd_version() == 5) {
						ADLFanSpeedValue lpFanSpeedValue = new ADLFanSpeedValue();
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(lpFanSpeedValue, 0, /*Error: sizeof expression not supported yet*/);
						lpFanSpeedValue.setISize(/*Error: sizeof expression not supported yet*/);
						lpFanSpeedValue.setISpeedType(1);
						lpFanSpeedValue.setIFlags(1);
						if (ModernizedCProgram.hm_ADL_Overdrive5_FanSpeed_Get(hashcat_ctx, generatedHm_device[backend_device_idx].getAdl(), 0, lpFanSpeedValue) == -1) {
							generatedHm_device[backend_device_idx].setFanspeed_get_supported(0);
							return -1;
						} 
						return generatedIFanSpeed;
					} 
					if (generatedHm_device[backend_device_idx].getOd_version() == 6) {
						ADLOD6FanSpeedInfo faninfo = new ADLOD6FanSpeedInfo();
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(faninfo, 0, /*Error: sizeof expression not supported yet*/);
						if (ModernizedCProgram.hm_ADL_Overdrive6_FanSpeed_Get(hashcat_ctx, generatedHm_device[backend_device_idx].getAdl(), faninfo) == -1) {
							generatedHm_device[backend_device_idx].setFanspeed_get_supported(0);
							return -1;
						} 
						return generatedIFanSpeedPercent;
					} 
				} 
				if (generatedHm_sysfs) {
					int speed = 0;
					if (hashcat_ctx.hm_SYSFS_get_fan_speed_current(backend_device_idx, speed) == -1) {
						generatedHm_device[backend_device_idx].setFanspeed_get_supported(0);
						return -1;
					} 
					return speed;
				} 
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
				if (generatedHm_nvml) {
					int speed = 0;
					if (hashcat_ctx.hm_NVML_nvmlDeviceGetFanSpeed(generatedHm_device[backend_device_idx].getNvml(), (u32)speed) == -1) {
						generatedHm_device[backend_device_idx].setFanspeed_get_supported(0);
						return -1;
					} 
					return speed;
				} 
			} 
		} 
		generatedHm_device[backend_device_idx].setFanspeed_get_supported(0);
		return -1;
	}
	public int hm_get_buslanes_with_devices_idx(Object backend_device_idx) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = hwmon_ctx.getEnabled();
		if (generatedEnabled == false) {
			return -1;
		} 
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		if (generatedHm_device[backend_device_idx].getBuslanes_get_supported() == 0) {
			return -1;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		if (generatedDevices_param[backend_device_idx].getIs_cuda() == 1) {
			if (generatedHm_nvml) {
				int currLinkWidth;
				if (hashcat_ctx.hm_NVML_nvmlDeviceGetCurrPcieLinkWidth(generatedHm_device[backend_device_idx].getNvml(), currLinkWidth) == -1) {
					generatedHm_device[backend_device_idx].setBuslanes_get_supported(0);
					return -1;
				} 
				return currLinkWidth;
			} 
		} 
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		int generatedICurrentBusLanes = PMActivity.getICurrentBusLanes();
		Object generatedHm_sysfs = hwmon_ctx.getHm_sysfs();
		if (generatedDevices_param[backend_device_idx].getIs_opencl() == 1) {
			if ((generatedDevices_param[backend_device_idx].getOpencl_device_type() & CL_DEVICE_TYPE_GPU) == 0) {
				return -1;
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
				if (generatedHm_adl) {
					ADLPMActivity PMActivity = new ADLPMActivity();
					PMActivity.setISize(/*Error: Unsupported expression*/);
					if (ModernizedCProgram.hm_ADL_Overdrive_CurrentActivity_Get(hashcat_ctx, generatedHm_device[backend_device_idx].getAdl(), PMActivity) == -1) {
						generatedHm_device[backend_device_idx].setBuslanes_get_supported(0);
						return -1;
					} 
					return generatedICurrentBusLanes;
				} 
				if (generatedHm_sysfs) {
					int lanes;
					if (hashcat_ctx.hm_SYSFS_get_pp_dpm_pcie(backend_device_idx, lanes) == -1) {
						generatedHm_device[backend_device_idx].setBuslanes_get_supported(0);
						return -1;
					} 
					return lanes;
				} 
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
				if (generatedHm_nvml) {
					int currLinkWidth;
					if (hashcat_ctx.hm_NVML_nvmlDeviceGetCurrPcieLinkWidth(generatedHm_device[backend_device_idx].getNvml(), currLinkWidth) == -1) {
						generatedHm_device[backend_device_idx].setBuslanes_get_supported(0);
						return -1;
					} 
					return currLinkWidth;
				} 
			} 
		} 
		generatedHm_device[backend_device_idx].setBuslanes_get_supported(0);
		return -1;
	}
	public int hm_get_utilization_with_devices_idx(Object backend_device_idx) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = hwmon_ctx.getEnabled();
		if (generatedEnabled == false) {
			return -1;
		} 
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		if (generatedHm_device[backend_device_idx].getUtilization_get_supported() == 0) {
			return -1;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		int generatedGpu = utilization.getGpu();
		if (generatedDevices_param[backend_device_idx].getIs_cuda() == 1) {
			if (generatedHm_nvml) {
				nvmlUtilization_t utilization = new nvmlUtilization_t();
				if (ModernizedCProgram.hm_NVML_nvmlDeviceGetUtilizationRates(hashcat_ctx, generatedHm_device[backend_device_idx].getNvml(), utilization) == -1) {
					generatedHm_device[backend_device_idx].setUtilization_get_supported(0);
					return -1;
				} 
				return generatedGpu;
			} 
		} 
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		int generatedIActivityPercent = PMActivity.getIActivityPercent();
		if (generatedDevices_param[backend_device_idx].getIs_opencl() == 1) {
			if ((generatedDevices_param[backend_device_idx].getOpencl_device_type() & CL_DEVICE_TYPE_GPU) == 0) {
				return -1;
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
				if (generatedHm_adl) {
					ADLPMActivity PMActivity = new ADLPMActivity();
					PMActivity.setISize(/*Error: Unsupported expression*/);
					if (ModernizedCProgram.hm_ADL_Overdrive_CurrentActivity_Get(hashcat_ctx, generatedHm_device[backend_device_idx].getAdl(), PMActivity) == -1) {
						generatedHm_device[backend_device_idx].setUtilization_get_supported(0);
						return -1;
					} 
					return generatedIActivityPercent;
				} 
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
				if (generatedHm_nvml) {
					nvmlUtilization_t utilization = new nvmlUtilization_t();
					if (ModernizedCProgram.hm_NVML_nvmlDeviceGetUtilizationRates(hashcat_ctx, generatedHm_device[backend_device_idx].getNvml(), utilization) == -1) {
						generatedHm_device[backend_device_idx].setUtilization_get_supported(0);
						return -1;
					} 
					return generatedGpu;
				} 
			} 
		} 
		generatedHm_device[backend_device_idx].setUtilization_get_supported(0);
		return -1;
	}
	public int hm_get_memoryspeed_with_devices_idx(Object backend_device_idx) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = hwmon_ctx.getEnabled();
		if (generatedEnabled == false) {
			return -1;
		} 
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		if (generatedHm_device[backend_device_idx].getMemoryspeed_get_supported() == 0) {
			return -1;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		if (generatedDevices_param[backend_device_idx].getIs_cuda() == 1) {
			if (generatedHm_nvml) {
				int clockfreq;
				if (hashcat_ctx.hm_NVML_nvmlDeviceGetClockInfo(generatedHm_device[backend_device_idx].getNvml(), nvmlClockType_enum.NVML_CLOCK_MEM, clockfreq) == -1) {
					generatedHm_device[backend_device_idx].setMemoryspeed_get_supported(0);
					return -1;
				} 
				return clockfreq;
			} 
		} 
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		int generatedIMemoryClock = PMActivity.getIMemoryClock();
		Object generatedHm_sysfs = hwmon_ctx.getHm_sysfs();
		if (generatedDevices_param[backend_device_idx].getIs_opencl() == 1) {
			if ((generatedDevices_param[backend_device_idx].getOpencl_device_type() & CL_DEVICE_TYPE_GPU) == 0) {
				return -1;
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
				if (generatedHm_adl) {
					ADLPMActivity PMActivity = new ADLPMActivity();
					PMActivity.setISize(/*Error: Unsupported expression*/);
					if (ModernizedCProgram.hm_ADL_Overdrive_CurrentActivity_Get(hashcat_ctx, generatedHm_device[backend_device_idx].getAdl(), PMActivity) == -1) {
						generatedHm_device[backend_device_idx].setMemoryspeed_get_supported(0);
						return -1;
					} 
					return generatedIMemoryClock / 100;
				} 
				if (generatedHm_sysfs) {
					int clockfreq;
					if (hashcat_ctx.hm_SYSFS_get_pp_dpm_mclk(backend_device_idx, clockfreq) == -1) {
						generatedHm_device[backend_device_idx].setMemoryspeed_get_supported(0);
						return -1;
					} 
					return clockfreq;
				} 
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
				if (generatedHm_nvml) {
					int clockfreq;
					if (hashcat_ctx.hm_NVML_nvmlDeviceGetClockInfo(generatedHm_device[backend_device_idx].getNvml(), nvmlClockType_enum.NVML_CLOCK_MEM, clockfreq) == -1) {
						generatedHm_device[backend_device_idx].setMemoryspeed_get_supported(0);
						return -1;
					} 
					return clockfreq;
				} 
			} 
		} 
		generatedHm_device[backend_device_idx].setMemoryspeed_get_supported(0);
		return -1;
	}
	public int hm_get_corespeed_with_devices_idx(Object backend_device_idx) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = hwmon_ctx.getEnabled();
		if (generatedEnabled == false) {
			return -1;
		} 
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		if (generatedHm_device[backend_device_idx].getCorespeed_get_supported() == 0) {
			return -1;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		if (generatedDevices_param[backend_device_idx].getIs_cuda() == 1) {
			if (generatedHm_nvml) {
				int clockfreq;
				if (hashcat_ctx.hm_NVML_nvmlDeviceGetClockInfo(generatedHm_device[backend_device_idx].getNvml(), nvmlClockType_enum.NVML_CLOCK_SM, clockfreq) == -1) {
					generatedHm_device[backend_device_idx].setCorespeed_get_supported(0);
					return -1;
				} 
				return clockfreq;
			} 
		} 
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		int generatedIEngineClock = PMActivity.getIEngineClock();
		Object generatedHm_sysfs = hwmon_ctx.getHm_sysfs();
		if (generatedDevices_param[backend_device_idx].getIs_opencl() == 1) {
			if ((generatedDevices_param[backend_device_idx].getOpencl_device_type() & CL_DEVICE_TYPE_GPU) == 0) {
				return -1;
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
				if (generatedHm_adl) {
					ADLPMActivity PMActivity = new ADLPMActivity();
					PMActivity.setISize(/*Error: Unsupported expression*/);
					if (ModernizedCProgram.hm_ADL_Overdrive_CurrentActivity_Get(hashcat_ctx, generatedHm_device[backend_device_idx].getAdl(), PMActivity) == -1) {
						generatedHm_device[backend_device_idx].setCorespeed_get_supported(0);
						return -1;
					} 
					return generatedIEngineClock / 100;
				} 
				if (generatedHm_sysfs) {
					int clockfreq;
					if (hashcat_ctx.hm_SYSFS_get_pp_dpm_sclk(backend_device_idx, clockfreq) == -1) {
						generatedHm_device[backend_device_idx].setCorespeed_get_supported(0);
						return -1;
					} 
					return clockfreq;
				} 
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
				if (generatedHm_nvml) {
					int clockfreq;
					if (hashcat_ctx.hm_NVML_nvmlDeviceGetClockInfo(generatedHm_device[backend_device_idx].getNvml(), nvmlClockType_enum.NVML_CLOCK_SM, clockfreq) == -1) {
						generatedHm_device[backend_device_idx].setCorespeed_get_supported(0);
						return -1;
					} 
					return clockfreq;
				} 
			} 
		} 
		generatedHm_device[backend_device_idx].setCorespeed_get_supported(0);
		return -1;
	}
	public int hm_get_throttle_with_devices_idx(Object backend_device_idx) {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = hwmon_ctx.getEnabled();
		if (generatedEnabled == false) {
			return -1;
		} 
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		if (generatedHm_device[backend_device_idx].getThrottle_get_supported() == 0) {
			return -1;
		} 
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		Object generatedInfo_value = perfPolicies_info.getInfo_value();
		Object generatedThrottle = perfPolicies_status.getThrottle();
		if (generatedDevices_param[backend_device_idx].getIs_cuda() == 1) {
			if (generatedHm_nvml) {
			} 
			if (generatedHm_nvapi) {
				NV_GPU_PERF_POLICIES_INFO_PARAMS_V1 perfPolicies_info = new NV_GPU_PERF_POLICIES_INFO_PARAMS_V1();
				NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1 perfPolicies_status = new NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1();
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(perfPolicies_info, 0, /*Error: Unsupported expression*/);
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(perfPolicies_status, 0, /*Error: Unsupported expression*/);
				perfPolicies_info.setVersion((NvU32)(/*Error: Unsupported expression*/ | ((true) << 16)));
				perfPolicies_status.setVersion((NvU32)(/*Error: Unsupported expression*/ | ((true) << 16)));
				ModernizedCProgram.hm_NvAPI_GPU_GetPerfPoliciesInfo(hashcat_ctx, generatedHm_device[backend_device_idx].getNvapi(), perfPolicies_info);
				perfPolicies_status.setInfo_value(generatedInfo_value);
				ModernizedCProgram.hm_NvAPI_GPU_GetPerfPoliciesStatus(hashcat_ctx, generatedHm_device[backend_device_idx].getNvapi(), perfPolicies_status);
				return generatedThrottle & 2;
			} 
		} 
		if (generatedDevices_param[backend_device_idx].getIs_opencl() == 1) {
			if ((generatedDevices_param[backend_device_idx].getOpencl_device_type() & CL_DEVICE_TYPE_GPU) == 0) {
				return -1;
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			} 
			if (generatedDevices_param[backend_device_idx].getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
				if (generatedHm_nvml) {
				} 
				if (generatedHm_nvapi) {
					NV_GPU_PERF_POLICIES_INFO_PARAMS_V1 perfPolicies_info = new NV_GPU_PERF_POLICIES_INFO_PARAMS_V1();
					NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1 perfPolicies_status = new NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1();
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(perfPolicies_info, 0, /*Error: Unsupported expression*/);
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(perfPolicies_status, 0, /*Error: Unsupported expression*/);
					perfPolicies_info.setVersion((NvU32)(/*Error: Unsupported expression*/ | ((true) << 16)));
					perfPolicies_status.setVersion((NvU32)(/*Error: Unsupported expression*/ | ((true) << 16)));
					ModernizedCProgram.hm_NvAPI_GPU_GetPerfPoliciesInfo(hashcat_ctx, generatedHm_device[backend_device_idx].getNvapi(), perfPolicies_info);
					perfPolicies_status.setInfo_value(generatedInfo_value);
					ModernizedCProgram.hm_NvAPI_GPU_GetPerfPoliciesStatus(hashcat_ctx, generatedHm_device[backend_device_idx].getNvapi(), perfPolicies_status);
					return generatedThrottle & 2;
				} 
			} 
		} 
		generatedHm_device[backend_device_idx].setThrottle_get_supported(0);
		return -1;
	}
	public int hwmon_ctx_init() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		hwmon_ctx.setEnabled(0);
		return 0;// WITH_HWMON
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedStdout_flag = user_options.getStdout_flag();
		if (generatedStdout_flag == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		boolean generatedHwmon_disable = user_options.getHwmon_disable();
		if (generatedHwmon_disable == true) {
			return 0;
		} 
		hwmon_ctx.setHm_device((hm_attrs_t)ModernizedCProgram.hccalloc(64, /*Error: Unsupported expression*//**
		   * Initialize shared libraries
		   */));
		hm_attrs_t[] hm_adapters_adl = (hm_attrs_t)ModernizedCProgram.hccalloc(64, /*Error: Unsupported expression*/);
		hm_attrs_t[] hm_adapters_nvapi = (hm_attrs_t)ModernizedCProgram.hccalloc(64, /*Error: Unsupported expression*/);
		hm_attrs_t[] hm_adapters_nvml = (hm_attrs_t)ModernizedCProgram.hccalloc(64, /*Error: Unsupported expression*/);
		hm_attrs_t[] hm_adapters_sysfs = (hm_attrs_t)ModernizedCProgram.hccalloc(64, /*Error: Unsupported expression*/);
		boolean generatedNeed_nvml = backend_ctx.getNeed_nvml();
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		if (generatedNeed_nvml == true) {
			hwmon_ctx.setHm_nvml((NVML_PTR)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
			if (hashcat_ctx.nvml_init() == -1) {
				ModernizedCProgram.hcfree(generatedHm_nvml);
				hwmon_ctx.setHm_nvml((null));
			} 
		} 
		boolean generatedNeed_nvapi = backend_ctx.getNeed_nvapi();
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		// nvapi can't work alone, we need nvml, tooif ((generatedNeed_nvapi == true) && (generatedHm_nvml)) {
			hwmon_ctx.setHm_nvapi((NVAPI_PTR)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
			if (hashcat_ctx.nvapi_init() == -1) {
				ModernizedCProgram.hcfree(generatedHm_nvapi);
				hwmon_ctx.setHm_nvapi((null));
			} 
		} 
		boolean generatedNeed_adl = backend_ctx.getNeed_adl();
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		if (generatedNeed_adl == true) {
			hwmon_ctx.setHm_adl((ADL_PTR)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
			if (hashcat_ctx.adl_init() == -1) {
				ModernizedCProgram.hcfree(generatedHm_adl);
				hwmon_ctx.setHm_adl((null));
			} 
		} 
		boolean generatedNeed_sysfs = backend_ctx.getNeed_sysfs();
		Object generatedHm_sysfs = hwmon_ctx.getHm_sysfs();
		if (generatedNeed_sysfs == true) {
			hwmon_ctx.setHm_sysfs((SYSFS_PTR)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
			if (hashcat_ctx.sysfs_init() == 0) {
				ModernizedCProgram.hcfree(generatedHm_sysfs);
				hwmon_ctx.setHm_sysfs((null));
			} 
			if (generatedHm_adl) {
				ModernizedCProgram.hcfree(generatedHm_sysfs);
				hwmon_ctx.setHm_sysfs((null));
			} 
		} 
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedPcie_bus = device_param.getPcie_bus();
		int generatedBus = pci.getBus();
		Object generatedPcie_device = device_param.getPcie_device();
		int generatedDevice = pci.getDevice();
		Object generatedPcie_function = device_param.getPcie_function();
		int generatedDevice_id = device_param.getDevice_id();
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_device_type = device_param.getOpencl_device_type();
		Object generatedOpencl_device_vendor_id = device_param.getOpencl_device_vendor_id();
		if (generatedHm_nvml) {
			if (hashcat_ctx.hm_NVML_nvmlInit() == 0) {
				HM_ADAPTER_NVML nvmlGPUHandle = (HM_ADAPTER_NVML)ModernizedCProgram.hccalloc(64, /*Error: Unsupported expression*/);
				int tmp_in = hashcat_ctx.hm_get_adapter_index_nvml(nvmlGPUHandle);
				for (int backend_devices_idx = 0;
				 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
					hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
					if (generatedSkipped == true) {
						continue;
					} 
					if (generatedIs_cuda == true) {
						for (int i = 0;
						 i < tmp_in; i++) {
							nvmlPciInfo_t pci = new nvmlPciInfo_t();
							int rc = ModernizedCProgram.hm_NVML_nvmlDeviceGetPciInfo(hashcat_ctx, nvmlGPUHandle[i], pci);
							if (rc == -1) {
								continue;
							} 
							if ((generatedPcie_bus == generatedBus) && (generatedPcie_device == (generatedDevice >> 3)) && (generatedPcie_function == (generatedDevice & 7))) {
								u32 device_id = generatedDevice_id;
								hm_adapters_nvml[device_id].setNvml(nvmlGPUHandle[i]);
								hm_adapters_nvml[device_id].setBuslanes_get_supported(1);
								hm_adapters_nvml[device_id].setCorespeed_get_supported(1);
								hm_adapters_nvml[device_id].setFanspeed_get_supported(1);
								hm_adapters_nvml[device_id].setMemoryspeed_get_supported(1);
								hm_adapters_nvml[device_id].setTemperature_get_supported(1);
								hm_adapters_nvml[device_id].setThreshold_shutdown_get_supported(1);
								hm_adapters_nvml[device_id].setThreshold_slowdown_get_supported(1);
								hm_adapters_nvml[device_id].setUtilization_get_supported(1);
							} 
						}
					} 
					if (generatedIs_opencl == true) {
						if ((generatedOpencl_device_type & CL_DEVICE_TYPE_GPU) == 0) {
							continue;
						} 
						if (generatedOpencl_device_vendor_id != vendor_id.VENDOR_ID_NV) {
							continue;
						} 
						for (int i = 0;
						 i < tmp_in; i++) {
							nvmlPciInfo_t pci = new nvmlPciInfo_t();
							int rc = ModernizedCProgram.hm_NVML_nvmlDeviceGetPciInfo(hashcat_ctx, nvmlGPUHandle[i], pci);
							if (rc == -1) {
								continue;
							} 
							if ((generatedPcie_bus == generatedBus) && (generatedPcie_device == (generatedDevice >> 3)) && (generatedPcie_function == (generatedDevice & 7))) {
								u32 device_id = generatedDevice_id;
								hm_adapters_nvml[device_id].setNvml(nvmlGPUHandle[i]);
								hm_adapters_nvml[device_id].setBuslanes_get_supported(1);
								hm_adapters_nvml[device_id].setCorespeed_get_supported(1);
								hm_adapters_nvml[device_id].setFanspeed_get_supported(1);
								hm_adapters_nvml[device_id].setMemoryspeed_get_supported(1);
								hm_adapters_nvml[device_id].setTemperature_get_supported(1);
								hm_adapters_nvml[device_id].setThreshold_shutdown_get_supported(1);
								hm_adapters_nvml[device_id].setThreshold_slowdown_get_supported(1);
								hm_adapters_nvml[device_id].setUtilization_get_supported(1);
							} 
						}
					} 
				}
				ModernizedCProgram.hcfree(nvmlGPUHandle);
			} 
		} 
		if (generatedHm_nvapi) {
			if (hashcat_ctx.hm_NvAPI_Initialize() == 0) {
				HM_ADAPTER_NVAPI nvGPUHandle = (HM_ADAPTER_NVAPI)ModernizedCProgram.hccalloc(64, /*Error: Unsupported expression*/);
				int tmp_in = hashcat_ctx.hm_get_adapter_index_nvapi(nvGPUHandle);
				for (int backend_devices_idx = 0;
				 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
					hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
					if (generatedSkipped == true) {
						continue;
					} 
					if (generatedIs_cuda == true) {
						for (int i = 0;
						 i < tmp_in; i++) {
							NvU32 BusId = 0;
							NvU32 BusSlotId = 0;
							int rc1 = hashcat_ctx.hm_NvAPI_GPU_GetBusId(nvGPUHandle[i], BusId);
							if (rc1 == -1) {
								continue;
							} 
							int rc2 = hashcat_ctx.hm_NvAPI_GPU_GetBusSlotId(nvGPUHandle[i], BusSlotId);
							if (rc2 == -1) {
								continue;
							} 
							if ((generatedPcie_bus == BusId) && (generatedPcie_device == (BusSlotId >> 3)) && (generatedPcie_function == (BusSlotId & 7))) {
								u32 device_id = generatedDevice_id;
								hm_adapters_nvapi[device_id].setNvapi(nvGPUHandle[i]);
								hm_adapters_nvapi[device_id].setFanpolicy_get_supported(1);
								hm_adapters_nvapi[device_id].setThrottle_get_supported(1);
							} 
						}
					} 
					if (generatedIs_opencl == true) {
						if ((generatedOpencl_device_type & CL_DEVICE_TYPE_GPU) == 0) {
							continue;
						} 
						if (generatedOpencl_device_vendor_id != vendor_id.VENDOR_ID_NV) {
							continue;
						} 
						for (int i = 0;
						 i < tmp_in; i++) {
							NvU32 BusId = 0;
							NvU32 BusSlotId = 0;
							int rc1 = hashcat_ctx.hm_NvAPI_GPU_GetBusId(nvGPUHandle[i], BusId);
							if (rc1 == -1) {
								continue;
							} 
							int rc2 = hashcat_ctx.hm_NvAPI_GPU_GetBusSlotId(nvGPUHandle[i], BusSlotId);
							if (rc2 == -1) {
								continue;
							} 
							if ((generatedPcie_bus == BusId) && (generatedPcie_device == (BusSlotId >> 3)) && (generatedPcie_function == (BusSlotId & 7))) {
								u32 device_id = generatedDevice_id;
								hm_adapters_nvapi[device_id].setNvapi(nvGPUHandle[i]);
								hm_adapters_nvapi[device_id].setFanpolicy_get_supported(1);
								hm_adapters_nvapi[device_id].setThrottle_get_supported(1);
							} 
						}
					} 
				}
				ModernizedCProgram.hcfree(nvGPUHandle);
			} 
		} 
		if (generatedHm_adl) {
			if (hashcat_ctx.hm_ADL_Main_Control_Create(ADL_Main_Memory_Alloc, 0) == 0) {
				int tmp_in;
				if (hashcat_ctx.get_adapters_num_adl(tmp_in) == -1) {
					{ 
						ModernizedCProgram.hcfree(hm_adapters_adl);
						ModernizedCProgram.hcfree(hm_adapters_nvapi);
						ModernizedCProgram.hcfree(hm_adapters_nvml);
						ModernizedCProgram.hcfree(hm_adapters_sysfs);
					}
					;
					return -1;
				} 
				LPAdapterInfo lpAdapterInfo = (LPAdapterInfo)ModernizedCProgram.hccalloc(tmp_in, /*Error: Unsupported expression*/);
				int rc_adapter_info_adl = hashcat_ctx.hm_ADL_Adapter_AdapterInfo_Get(lpAdapterInfo, tmp_in * /*Error: Unsupported expression*/);
				if (rc_adapter_info_adl == -1) {
					{ 
						ModernizedCProgram.hcfree(hm_adapters_adl);
						ModernizedCProgram.hcfree(hm_adapters_nvapi);
						ModernizedCProgram.hcfree(hm_adapters_nvml);
						ModernizedCProgram.hcfree(hm_adapters_sysfs);
					}
					;
					return -1;
				} 
				for (int backend_devices_idx = 0;
				 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
					hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
					if (generatedSkipped == true) {
						continue;
					} 
					if (generatedIs_cuda == true) {
					} 
					if (generatedIs_opencl == true) {
						if ((generatedOpencl_device_type & CL_DEVICE_TYPE_GPU) == 0) {
							continue;
						} 
						if (generatedOpencl_device_vendor_id != vendor_id.VENDOR_ID_AMD) {
							continue;
						} 
						for (int i = 0;
						 i < tmp_in; i++) {
							if ((generatedPcie_bus == lpAdapterInfo[i].getIBusNumber()) && (generatedPcie_device == (lpAdapterInfo[i].getIDeviceNumber() >> 3)) && (generatedPcie_function == (lpAdapterInfo[i].getIDeviceNumber() & 7))) {
								u32 device_id = generatedDevice_id;
								int od_supported = 0;
								int od_enabled = 0;
								int od_version = 0;
								hashcat_ctx.hm_ADL_Overdrive_Caps(lpAdapterInfo[i].getIAdapterIndex(), od_supported, od_enabled, od_version);
								hm_adapters_adl[device_id].setOd_version(od_version);
								hm_adapters_adl[device_id].setAdl(lpAdapterInfo[i].getIAdapterIndex());
								hm_adapters_adl[device_id].setBuslanes_get_supported(1);
								hm_adapters_adl[device_id].setCorespeed_get_supported(1);
								hm_adapters_adl[device_id].setFanspeed_get_supported(1);
								hm_adapters_adl[device_id].setFanpolicy_get_supported(1);
								hm_adapters_adl[device_id].setMemoryspeed_get_supported(1);
								hm_adapters_adl[device_id].setTemperature_get_supported(1);
								hm_adapters_adl[device_id].setThreshold_slowdown_get_supported(1);
								hm_adapters_adl[device_id].setUtilization_get_supported(1);
							} 
						}
					} 
				}
				ModernizedCProgram.hcfree(lpAdapterInfo);
			} 
		} 
		if (generatedHm_sysfs) {
			if (1) {
				int hm_adapters_id = 0;
				for (int backend_devices_idx = 0;
				 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
					hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
					if (generatedIs_cuda == true) {
					} 
					if (generatedIs_opencl == true) {
						if ((generatedOpencl_device_type & CL_DEVICE_TYPE_GPU) == 0) {
							continue;
						} 
						hm_adapters_sysfs[hm_adapters_id].setSysfs(backend_devices_idx);
						hm_adapters_sysfs[hm_adapters_id].setBuslanes_get_supported(1);
						hm_adapters_sysfs[hm_adapters_id].setCorespeed_get_supported(1);
						hm_adapters_sysfs[hm_adapters_id].setFanspeed_get_supported(1);
						hm_adapters_sysfs[hm_adapters_id].setFanpolicy_get_supported(1);
						hm_adapters_sysfs[hm_adapters_id].setMemoryspeed_get_supported(1);
						hm_adapters_sysfs[hm_adapters_id].setTemperature_get_supported(1);
						hm_adapters_id++;
					} 
				}
			} 
		} 
		if (generatedHm_adl == (null) && generatedHm_nvml == (null) && generatedHm_sysfs == (null)) {
			{ 
				ModernizedCProgram.hcfree(hm_adapters_adl);
				ModernizedCProgram.hcfree(hm_adapters_nvapi);
				ModernizedCProgram.hcfree(hm_adapters_nvml);
				ModernizedCProgram.hcfree(hm_adapters_sysfs);
			}
			;
			return 0/**
			   * looks like we have some manageable device
			   */;
		} 
		hwmon_ctx.setEnabled(1/**
		   * save buffer required for later restores
		   */);
		hwmon_ctx.setOd_clock_mem_status((ADLOD6MemClockState)ModernizedCProgram.hccalloc(generatedBackend_devices_cnt, /*Error: Unsupported expression*//**
		   * HM devices: copy
		   */));
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
			hc_device_param_t device_param = generatedDevices_param[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			u32 device_id = generatedDevice_id;
			if (generatedIs_cuda == true) {
				generatedHm_device[backend_devices_idx].setAdl(0);
				generatedHm_device[backend_devices_idx].setSysfs(0);
				generatedHm_device[backend_devices_idx].setNvapi(hm_adapters_nvapi[device_id].getNvapi());
				generatedHm_device[backend_devices_idx].setNvml(hm_adapters_nvml[device_id].getNvml());
				generatedHm_device[backend_devices_idx].setOd_version(0);
				if (generatedHm_nvml) {
					generatedHm_device[backend_devices_idx].getBuslanes_get_supported() |=  hm_adapters_nvml[device_id].getBuslanes_get_supported();
					generatedHm_device[backend_devices_idx].getCorespeed_get_supported() |=  hm_adapters_nvml[device_id].getCorespeed_get_supported();
					generatedHm_device[backend_devices_idx].getFanspeed_get_supported() |=  hm_adapters_nvml[device_id].getFanspeed_get_supported();
					generatedHm_device[backend_devices_idx].getFanpolicy_get_supported() |=  hm_adapters_nvml[device_id].getFanpolicy_get_supported();
					generatedHm_device[backend_devices_idx].getMemoryspeed_get_supported() |=  hm_adapters_nvml[device_id].getMemoryspeed_get_supported();
					generatedHm_device[backend_devices_idx].getTemperature_get_supported() |=  hm_adapters_nvml[device_id].getTemperature_get_supported();
					generatedHm_device[backend_devices_idx].getThreshold_shutdown_get_supported() |=  hm_adapters_nvml[device_id].getThreshold_shutdown_get_supported();
					generatedHm_device[backend_devices_idx].getThreshold_slowdown_get_supported() |=  hm_adapters_nvml[device_id].getThreshold_slowdown_get_supported();
					generatedHm_device[backend_devices_idx].getThrottle_get_supported() |=  hm_adapters_nvml[device_id].getThrottle_get_supported();
					generatedHm_device[backend_devices_idx].getUtilization_get_supported() |=  hm_adapters_nvml[device_id].getUtilization_get_supported();
				} 
				if (generatedHm_nvapi) {
					generatedHm_device[backend_devices_idx].getBuslanes_get_supported() |=  hm_adapters_nvapi[device_id].getBuslanes_get_supported();
					generatedHm_device[backend_devices_idx].getCorespeed_get_supported() |=  hm_adapters_nvapi[device_id].getCorespeed_get_supported();
					generatedHm_device[backend_devices_idx].getFanspeed_get_supported() |=  hm_adapters_nvapi[device_id].getFanspeed_get_supported();
					generatedHm_device[backend_devices_idx].getFanpolicy_get_supported() |=  hm_adapters_nvapi[device_id].getFanpolicy_get_supported();
					generatedHm_device[backend_devices_idx].getMemoryspeed_get_supported() |=  hm_adapters_nvapi[device_id].getMemoryspeed_get_supported();
					generatedHm_device[backend_devices_idx].getTemperature_get_supported() |=  hm_adapters_nvapi[device_id].getTemperature_get_supported();
					generatedHm_device[backend_devices_idx].getThreshold_shutdown_get_supported() |=  hm_adapters_nvapi[device_id].getThreshold_shutdown_get_supported();
					generatedHm_device[backend_devices_idx].getThreshold_slowdown_get_supported() |=  hm_adapters_nvapi[device_id].getThreshold_slowdown_get_supported();
					generatedHm_device[backend_devices_idx].getThrottle_get_supported() |=  hm_adapters_nvapi[device_id].getThrottle_get_supported();
					generatedHm_device[backend_devices_idx].getUtilization_get_supported() |=  hm_adapters_nvapi[device_id].getUtilization_get_supported();
				} 
			} 
			if (generatedIs_opencl == true) {
				if ((generatedOpencl_device_type & CL_DEVICE_TYPE_GPU) == 0) {
					continue;
				} 
				if (generatedOpencl_device_vendor_id == vendor_id.VENDOR_ID_AMD) {
					generatedHm_device[backend_devices_idx].setAdl(hm_adapters_adl[device_id].getAdl());
					generatedHm_device[backend_devices_idx].setSysfs(hm_adapters_sysfs[device_id].getSysfs());
					generatedHm_device[backend_devices_idx].setNvapi(0);
					generatedHm_device[backend_devices_idx].setNvml(0);
					generatedHm_device[backend_devices_idx].setOd_version(0);
					if (generatedHm_adl) {
						generatedHm_device[backend_devices_idx].setOd_version(hm_adapters_adl[device_id].getOd_version());
						generatedHm_device[backend_devices_idx].getBuslanes_get_supported() |=  hm_adapters_adl[device_id].getBuslanes_get_supported();
						generatedHm_device[backend_devices_idx].getCorespeed_get_supported() |=  hm_adapters_adl[device_id].getCorespeed_get_supported();
						generatedHm_device[backend_devices_idx].getFanspeed_get_supported() |=  hm_adapters_adl[device_id].getFanspeed_get_supported();
						generatedHm_device[backend_devices_idx].getFanpolicy_get_supported() |=  hm_adapters_adl[device_id].getFanpolicy_get_supported();
						generatedHm_device[backend_devices_idx].getMemoryspeed_get_supported() |=  hm_adapters_adl[device_id].getMemoryspeed_get_supported();
						generatedHm_device[backend_devices_idx].getTemperature_get_supported() |=  hm_adapters_adl[device_id].getTemperature_get_supported();
						generatedHm_device[backend_devices_idx].getThreshold_shutdown_get_supported() |=  hm_adapters_adl[device_id].getThreshold_shutdown_get_supported();
						generatedHm_device[backend_devices_idx].getThreshold_slowdown_get_supported() |=  hm_adapters_adl[device_id].getThreshold_slowdown_get_supported();
						generatedHm_device[backend_devices_idx].getThrottle_get_supported() |=  hm_adapters_adl[device_id].getThrottle_get_supported();
						generatedHm_device[backend_devices_idx].getUtilization_get_supported() |=  hm_adapters_adl[device_id].getUtilization_get_supported();
					} 
					if (generatedHm_sysfs) {
						generatedHm_device[backend_devices_idx].getBuslanes_get_supported() |=  hm_adapters_sysfs[device_id].getBuslanes_get_supported();
						generatedHm_device[backend_devices_idx].getCorespeed_get_supported() |=  hm_adapters_sysfs[device_id].getCorespeed_get_supported();
						generatedHm_device[backend_devices_idx].getFanspeed_get_supported() |=  hm_adapters_sysfs[device_id].getFanspeed_get_supported();
						generatedHm_device[backend_devices_idx].getFanpolicy_get_supported() |=  hm_adapters_sysfs[device_id].getFanpolicy_get_supported();
						generatedHm_device[backend_devices_idx].getMemoryspeed_get_supported() |=  hm_adapters_sysfs[device_id].getMemoryspeed_get_supported();
						generatedHm_device[backend_devices_idx].getTemperature_get_supported() |=  hm_adapters_sysfs[device_id].getTemperature_get_supported();
						generatedHm_device[backend_devices_idx].getThreshold_shutdown_get_supported() |=  hm_adapters_sysfs[device_id].getThreshold_shutdown_get_supported();
						generatedHm_device[backend_devices_idx].getThreshold_slowdown_get_supported() |=  hm_adapters_sysfs[device_id].getThreshold_slowdown_get_supported();
						generatedHm_device[backend_devices_idx].getThrottle_get_supported() |=  hm_adapters_sysfs[device_id].getThrottle_get_supported();
						generatedHm_device[backend_devices_idx].getUtilization_get_supported() |=  hm_adapters_sysfs[device_id].getUtilization_get_supported();
					} 
				} 
				if (generatedOpencl_device_vendor_id == vendor_id.VENDOR_ID_NV) {
					generatedHm_device[backend_devices_idx].setAdl(0);
					generatedHm_device[backend_devices_idx].setSysfs(0);
					generatedHm_device[backend_devices_idx].setNvapi(hm_adapters_nvapi[device_id].getNvapi());
					generatedHm_device[backend_devices_idx].setNvml(hm_adapters_nvml[device_id].getNvml());
					generatedHm_device[backend_devices_idx].setOd_version(0);
					if (generatedHm_nvml) {
						generatedHm_device[backend_devices_idx].getBuslanes_get_supported() |=  hm_adapters_nvml[device_id].getBuslanes_get_supported();
						generatedHm_device[backend_devices_idx].getCorespeed_get_supported() |=  hm_adapters_nvml[device_id].getCorespeed_get_supported();
						generatedHm_device[backend_devices_idx].getFanspeed_get_supported() |=  hm_adapters_nvml[device_id].getFanspeed_get_supported();
						generatedHm_device[backend_devices_idx].getFanpolicy_get_supported() |=  hm_adapters_nvml[device_id].getFanpolicy_get_supported();
						generatedHm_device[backend_devices_idx].getMemoryspeed_get_supported() |=  hm_adapters_nvml[device_id].getMemoryspeed_get_supported();
						generatedHm_device[backend_devices_idx].getTemperature_get_supported() |=  hm_adapters_nvml[device_id].getTemperature_get_supported();
						generatedHm_device[backend_devices_idx].getThreshold_shutdown_get_supported() |=  hm_adapters_nvml[device_id].getThreshold_shutdown_get_supported();
						generatedHm_device[backend_devices_idx].getThreshold_slowdown_get_supported() |=  hm_adapters_nvml[device_id].getThreshold_slowdown_get_supported();
						generatedHm_device[backend_devices_idx].getThrottle_get_supported() |=  hm_adapters_nvml[device_id].getThrottle_get_supported();
						generatedHm_device[backend_devices_idx].getUtilization_get_supported() |=  hm_adapters_nvml[device_id].getUtilization_get_supported();
					} 
					if (generatedHm_nvapi) {
						generatedHm_device[backend_devices_idx].getBuslanes_get_supported() |=  hm_adapters_nvapi[device_id].getBuslanes_get_supported();
						generatedHm_device[backend_devices_idx].getCorespeed_get_supported() |=  hm_adapters_nvapi[device_id].getCorespeed_get_supported();
						generatedHm_device[backend_devices_idx].getFanspeed_get_supported() |=  hm_adapters_nvapi[device_id].getFanspeed_get_supported();
						generatedHm_device[backend_devices_idx].getFanpolicy_get_supported() |=  hm_adapters_nvapi[device_id].getFanpolicy_get_supported();
						generatedHm_device[backend_devices_idx].getMemoryspeed_get_supported() |=  hm_adapters_nvapi[device_id].getMemoryspeed_get_supported();
						generatedHm_device[backend_devices_idx].getTemperature_get_supported() |=  hm_adapters_nvapi[device_id].getTemperature_get_supported();
						generatedHm_device[backend_devices_idx].getThreshold_shutdown_get_supported() |=  hm_adapters_nvapi[device_id].getThreshold_shutdown_get_supported();
						generatedHm_device[backend_devices_idx].getThreshold_slowdown_get_supported() |=  hm_adapters_nvapi[device_id].getThreshold_slowdown_get_supported();
						generatedHm_device[backend_devices_idx].getThrottle_get_supported() |=  hm_adapters_nvapi[device_id].getThrottle_get_supported();
						generatedHm_device[backend_devices_idx].getUtilization_get_supported() |=  hm_adapters_nvapi[device_id].getUtilization_get_supported();
					} 
				} 
			} 
			hashcat_ctx.hm_get_buslanes_with_devices_idx(backend_devices_idx);
			hashcat_ctx.hm_get_corespeed_with_devices_idx(backend_devices_idx);
			hashcat_ctx.hm_get_fanpolicy_with_devices_idx(backend_devices_idx);
			hashcat_ctx.hm_get_fanspeed_with_devices_idx(backend_devices_idx);
			hashcat_ctx.hm_get_memoryspeed_with_devices_idx(backend_devices_idx);
			hashcat_ctx.hm_get_temperature_with_devices_idx(backend_devices_idx);
			hashcat_ctx.hm_get_threshold_shutdown_with_devices_idx(backend_devices_idx);
			hashcat_ctx.hm_get_threshold_slowdown_with_devices_idx(backend_devices_idx);
			hashcat_ctx.hm_get_throttle_with_devices_idx(backend_devices_idx);
			hashcat_ctx.hm_get_utilization_with_devices_idx(backend_devices_idx);
		}
		{ 
			ModernizedCProgram.hcfree(hm_adapters_adl);
			ModernizedCProgram.hcfree(hm_adapters_nvapi);
			ModernizedCProgram.hcfree(hm_adapters_nvml);
			ModernizedCProgram.hcfree(hm_adapters_sysfs);
		}
		;
		return 0;
	}
	public void hwmon_ctx_destroy() {
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		boolean generatedEnabled = hwmon_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		// unload shared libraries
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		if (generatedHm_nvml) {
			hashcat_ctx.hm_NVML_nvmlShutdown();
			hashcat_ctx.nvml_close();
		} 
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		if (generatedHm_nvapi) {
			hashcat_ctx.hm_NvAPI_Unload();
			hashcat_ctx.nvapi_close();
		} 
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		if (generatedHm_adl) {
			hashcat_ctx.hm_ADL_Main_Control_Destroy();
			hashcat_ctx.adl_close();
		} 
		Object generatedHm_sysfs = hwmon_ctx.getHm_sysfs();
		if (generatedHm_sysfs) {
			hashcat_ctx.sysfs_close();
		} 
		struct_ADLOD6MemClockState generatedOd_clock_mem_status = hwmon_ctx.getOd_clock_mem_status();
		// free memory// free memoryModernizedCProgram.hcfree(generatedOd_clock_mem_status);
		hm_attrs[] generatedHm_device = hwmon_ctx.getHm_device();
		ModernizedCProgram.hcfree(generatedHm_device);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(hwmon_ctx, 0, /*Error: Unsupported expression*/);
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public int straight_ctx_add_wl(Object dict) {
		if (ModernizedCProgram.hc_path_has_bom(dict) == 1) {
			hashcat_ctx.event_log_error("%s: Byte Order Mark (BOM) was detected", dict);
			return -1;
		} 
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		Object generatedDicts_avail = straight_ctx.getDicts_avail();
		Object generatedDicts_cnt = straight_ctx.getDicts_cnt();
		byte[][] generatedDicts = straight_ctx.getDicts();
		if (generatedDicts_avail == generatedDicts_cnt) {
			straight_ctx.setDicts((byte)ModernizedCProgram.hcrealloc(generatedDicts, generatedDicts_avail * /*Error: Unsupported expression*/, 1000 * /*Error: Unsupported expression*/));
			generatedDicts_avail += 1000;
		} 
		generatedDicts[generatedDicts_cnt] = ModernizedCProgram.hcstrdup(dict);
		generatedDicts_cnt++;
		return 0;
	}
	public int straight_ctx_update_loop() {
		combinator_ctx generatedCombinator_ctx = this.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		induct_ctx generatedInduct_ctx = this.getInduct_ctx();
		induct_ctx_t induct_ctx = generatedInduct_ctx;
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Object generatedAttack_mode = user_options.getAttack_mode();
		Object generatedWordlist_mode = user_options_extra.getWordlist_mode();
		int generatedInduction_dictionaries_cnt = induct_ctx.getInduction_dictionaries_cnt();
		byte[][] generatedInduction_dictionaries = induct_ctx.getInduction_dictionaries();
		int generatedInduction_dictionaries_pos = induct_ctx.getInduction_dictionaries_pos();
		byte[][] generatedDicts = straight_ctx.getDicts();
		Object generatedDicts_pos = straight_ctx.getDicts_pos();
		Byte generatedDict = straight_ctx.getDict();
		Byte generatedTopid = logfile_ctx.getTopid();
		Byte generatedSubid = logfile_ctx.getSubid();
		Object generatedRp_files_cnt = user_options.getRp_files_cnt();
		byte[][] generatedRp_files = user_options.getRp_files();
		Object generatedWords_cnt = status_ctx.getWords_cnt();
		Byte generatedDict1 = combinator_ctx.getDict1();
		Byte generatedDict2 = combinator_ctx.getDict2();
		Object generatedCombs_mode = combinator_ctx.getCombs_mode();
		Byte generatedMask = mask_ctx.getMask();
		if (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
			if (generatedWordlist_mode == wl_mode.WL_MODE_FILE) {
				if (generatedInduction_dictionaries_cnt) {
					straight_ctx.setDict(generatedInduction_dictionaries[generatedInduction_dictionaries_pos]);
				} else {
						straight_ctx.setDict(generatedDicts[generatedDicts_pos]);
				} 
				if (((generatedDict)) != (null)) {
					hashcat_ctx.logfile_append("%s\t%s\t%s\t%s", generatedTopid, generatedSubid, ("straight_ctx->dict"), ((generatedDict)));
				} 
				;
				;
				for (u32 i = 0;
				 i < generatedRp_files_cnt; i++) {
					if ((generatedRp_files[i]) != (null)) {
						hashcat_ctx.logfile_append("%s\t%s\t%s\t%s", generatedTopid, generatedSubid, ("rulefile"), (generatedRp_files[i]));
					} 
					;
				}
				HCFILE fp = new HCFILE();
				if (fp.hc_fopen(generatedDict, "rb") == 0) {
					hashcat_ctx.event_log_error("%s: %s", generatedDict, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				int rc = ModernizedCProgram.count_words(hashcat_ctx, fp, generatedDict, generatedWords_cnt);
				fp.hc_fclose();
				if (rc == -1) {
					hashcat_ctx.event_log_error("Integer overflow detected in keyspace of wordlist: %s", generatedDict);
					return -1;
				} 
				if (generatedWords_cnt == 0) {
					hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, generatedSubid, ("STOP"));
					;
					return 0;
				} 
			} 
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
			if (((generatedDict1)) != (null)) {
				hashcat_ctx.logfile_append("%s\t%s\t%s\t%s", generatedTopid, generatedSubid, ("combinator_ctx->dict1"), ((generatedDict1)));
			} 
			;
			;
			if (((generatedDict2)) != (null)) {
				hashcat_ctx.logfile_append("%s\t%s\t%s\t%s", generatedTopid, generatedSubid, ("combinator_ctx->dict2"), ((generatedDict2)));
			} 
			;
			;
			if (generatedCombs_mode == combinator_mode.COMBINATOR_MODE_BASE_LEFT) {
				HCFILE fp = new HCFILE();
				if (fp.hc_fopen(generatedDict1, "rb") == 0) {
					hashcat_ctx.event_log_error("%s: %s", generatedDict1, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				int rc = ModernizedCProgram.count_words(hashcat_ctx, fp, generatedDict1, generatedWords_cnt);
				fp.hc_fclose();
				if (rc == -1) {
					hashcat_ctx.event_log_error("Integer overflow detected in keyspace of wordlist: %s", generatedDict1);
					return -1;
				} 
			}  else if (generatedCombs_mode == combinator_mode.COMBINATOR_MODE_BASE_RIGHT) {
				HCFILE fp = new HCFILE();
				if (fp.hc_fopen(generatedDict2, "rb") == 0) {
					hashcat_ctx.event_log_error("%s: %s", generatedDict2, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
					return -1;
				} 
				int rc = ModernizedCProgram.count_words(hashcat_ctx, fp, generatedDict2, generatedWords_cnt);
				fp.hc_fclose();
				if (rc == -1) {
					hashcat_ctx.event_log_error("Integer overflow detected in keyspace of wordlist: %s", generatedDict2);
					return -1;
				} 
			} 
			if (generatedWords_cnt == 0) {
				hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, generatedSubid, ("STOP"));
				;
				return 0;
			} 
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
			if (((generatedMask)) != (null)) {
				hashcat_ctx.logfile_append("%s\t%s\t%s\t%s", generatedTopid, generatedSubid, ("mask_ctx->mask"), ((generatedMask)));
			} 
			;
			;
		}  else if ((generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) || (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2)) {
			if (generatedInduction_dictionaries_cnt) {
				straight_ctx.setDict(generatedInduction_dictionaries[generatedInduction_dictionaries_pos]);
			} else {
					straight_ctx.setDict(generatedDicts[generatedDicts_pos]);
			} 
			if (((generatedDict)) != (null)) {
				hashcat_ctx.logfile_append("%s\t%s\t%s\t%s", generatedTopid, generatedSubid, ("straight_ctx->dict"), ((generatedDict)));
			} 
			;
			;
			if (((generatedMask)) != (null)) {
				hashcat_ctx.logfile_append("%s\t%s\t%s\t%s", generatedTopid, generatedSubid, ("mask_ctx->mask"), ((generatedMask)));
			} 
			;
			;
			HCFILE fp = new HCFILE();
			if (fp.hc_fopen(generatedDict, "rb") == 0) {
				hashcat_ctx.event_log_error("%s: %s", generatedDict, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
				return -1;
			} 
			int rc = ModernizedCProgram.count_words(hashcat_ctx, fp, generatedDict, generatedWords_cnt);
			fp.hc_fclose();
			if (rc == -1) {
				hashcat_ctx.event_log_error("Integer overflow detected in keyspace of wordlist: %s", generatedDict);
				return -1;
			} 
			if (generatedWords_cnt == 0) {
				hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, generatedSubid, ("STOP"));
				;
				return 0;
			} 
		} 
		return 0;
	}
	public int straight_ctx_init() {
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		straight_ctx.setEnabled(0);
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		Object generatedAttack_mode = user_options.getAttack_mode();
		if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
			return 0;
		} 
		straight_ctx.setEnabled(1/**
		   * generate NOP rules
		   */);
		Object generatedRp_files_cnt = user_options.getRp_files_cnt();
		Object generatedRp_gen = user_options.getRp_gen();
		[] generatedKernel_rules_buf = straight_ctx.getKernel_rules_buf();
		Object generatedKernel_rules_cnt = straight_ctx.getKernel_rules_cnt();
		if ((generatedRp_files_cnt == 0) && (generatedRp_gen == 0)) {
			straight_ctx.setKernel_rules_buf((kernel_rule_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
			generatedKernel_rules_buf[0].getCmds()[0] = rule_functions.RULE_OP_MANGLE_NOOP;
			straight_ctx.setKernel_rules_cnt(1);
		} else {
				if (generatedRp_files_cnt) {
					if (ModernizedCProgram.kernel_rules_load(hashcat_ctx, generatedKernel_rules_buf, generatedKernel_rules_cnt) == -1) {
						return -1;
					} 
				}  else if (generatedRp_gen) {
					if (ModernizedCProgram.kernel_rules_generate(hashcat_ctx, generatedKernel_rules_buf, generatedKernel_rules_cnt) == -1) {
						return -1;
					} 
				} 
		} 
		Object generatedWordlist_mode = user_options_extra.getWordlist_mode();
		int generatedHc_workc = user_options_extra.getHc_workc();
		byte[][] generatedHc_workv = user_options_extra.getHc_workv();
		Object generatedDicts_cnt = straight_ctx.getDicts_cnt();
		if (generatedAttack_mode == /**
		   * wordlist based work
		   */attack_mode.ATTACK_MODE_STRAIGHT) {
			if (generatedWordlist_mode == wl_mode.WL_MODE_FILE) {
				for (int i = 0;
				 i < generatedHc_workc; i++) {
					Byte l0_filename = generatedHc_workv[i];
					if (ModernizedCProgram.hc_path_is_directory(l0_filename) == 1) {
						Byte dictionary_files;
						dictionary_files = ModernizedCProgram.scan_directory(l0_filename);
						if (dictionary_files != (null)) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/qsort(dictionary_files, (size_t)ModernizedCProgram.count_dictionaries(dictionary_files), /*Error: Unsupported expression*/, ModernizedCProgram.sort_by_stringptr);
							for (int d = 0;
							 dictionary_files[d] != (null); d++) {
								Byte l1_filename = dictionary_files[d];
								if (ModernizedCProgram.hc_path_read(l1_filename) == 0) {
									hashcat_ctx.event_log_error("%s: %s", l1_filename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
									ModernizedCProgram.hcfree(dictionary_files);
									return -1;
								} 
								if (ModernizedCProgram.hc_path_is_file(l1_filename) == 1) {
									if (hashcat_ctx.straight_ctx_add_wl(l1_filename) == -1) {
										ModernizedCProgram.hcfree(dictionary_files);
										return -1;
									} 
								} 
							}
						} 
						ModernizedCProgram.hcfree(dictionary_files);
					} else {
							if (hashcat_ctx.straight_ctx_add_wl(l0_filename) == -1) {
								return -1;
							} 
					} 
				}
				if (generatedDicts_cnt == 0) {
					hashcat_ctx.event_log_error("No usable dictionary file found.");
					return -1;
				} 
			} 
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
			for (int i = 0;
			 i < generatedHc_workc - 1; i++) {
				Byte l0_filename = generatedHc_workv[i];
				if (ModernizedCProgram.hc_path_is_directory(l0_filename) == 1) {
					Byte dictionary_files;
					dictionary_files = ModernizedCProgram.scan_directory(l0_filename);
					if (dictionary_files != (null)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/qsort(dictionary_files, (size_t)ModernizedCProgram.count_dictionaries(dictionary_files), /*Error: Unsupported expression*/, ModernizedCProgram.sort_by_stringptr);
						for (int d = 0;
						 dictionary_files[d] != (null); d++) {
							Byte l1_filename = dictionary_files[d];
							if (ModernizedCProgram.hc_path_read(l1_filename) == 0) {
								hashcat_ctx.event_log_error("%s: %s", l1_filename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
								ModernizedCProgram.hcfree(dictionary_files);
								return -1;
							} 
							if (ModernizedCProgram.hc_path_is_file(l1_filename) == 1) {
								if (hashcat_ctx.straight_ctx_add_wl(l1_filename) == -1) {
									ModernizedCProgram.hcfree(dictionary_files);
									return -1;
								} 
							} 
						}
					} 
					ModernizedCProgram.hcfree(dictionary_files);
				} else {
						if (hashcat_ctx.straight_ctx_add_wl(l0_filename) == -1) {
							return -1;
						} 
				} 
			}
			if (generatedDicts_cnt == 0) {
				hashcat_ctx.event_log_error("No usable dictionary file found.");
				return -1;
			} 
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
			for (int i = 1;
			 i < generatedHc_workc; i++) {
				Byte l0_filename = generatedHc_workv[i];
				if (ModernizedCProgram.hc_path_is_directory(l0_filename) == 1) {
					Byte dictionary_files;
					dictionary_files = ModernizedCProgram.scan_directory(l0_filename);
					if (dictionary_files != (null)) {
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/qsort(dictionary_files, (size_t)ModernizedCProgram.count_dictionaries(dictionary_files), /*Error: Unsupported expression*/, ModernizedCProgram.sort_by_stringptr);
						for (int d = 0;
						 dictionary_files[d] != (null); d++) {
							Byte l1_filename = dictionary_files[d];
							if (ModernizedCProgram.hc_path_read(l1_filename) == 0) {
								hashcat_ctx.event_log_error("%s: %s", l1_filename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
								ModernizedCProgram.hcfree(dictionary_files);
								return -1;
							} 
							if (ModernizedCProgram.hc_path_is_file(l1_filename) == 1) {
								if (hashcat_ctx.straight_ctx_add_wl(l1_filename) == -1) {
									ModernizedCProgram.hcfree(dictionary_files);
									return -1;
								} 
							} 
						}
					} 
					ModernizedCProgram.hcfree(dictionary_files);
				} else {
						if (hashcat_ctx.straight_ctx_add_wl(l0_filename) == -1) {
							return -1;
						} 
				} 
			}
			if (generatedDicts_cnt == 0) {
				hashcat_ctx.event_log_error("No usable dictionary file found.");
				return -1;
			} 
		} 
		return 0;
	}
	public void straight_ctx_destroy() {
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		boolean generatedEnabled = straight_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		Object generatedDicts_cnt = straight_ctx.getDicts_cnt();
		byte[][] generatedDicts = straight_ctx.getDicts();
		for (u32 dict_pos = 0;
		 dict_pos < generatedDicts_cnt; dict_pos++) {
			ModernizedCProgram.hcfree(generatedDicts[dict_pos]);
		}
		ModernizedCProgram.hcfree(generatedDicts);
		[] generatedKernel_rules_buf = straight_ctx.getKernel_rules_buf();
		ModernizedCProgram.hcfree(generatedKernel_rules_buf);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(straight_ctx, 0, /*Error: Unsupported expression*/);
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public void slow_candidates_seek(Object extra_info, Object cur, Object end) {
		combinator_ctx generatedCombinator_ctx = this.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		Object generatedAttack_mode = user_options.getAttack_mode();
		u32 attack_mode = generatedAttack_mode;
		Object generatedKernel_rules_cnt = straight_ctx.getKernel_rules_cnt();
		Object generatedFp = extra_info_straight.getFp();
		Object generatedRule_len_l = user_options_extra.getRule_len_l();
		Object generatedRule_buf_l = user_options.getRule_buf_l();
		Object[] generatedBase_buf = extra_info_straight.getBase_buf();
		Object generatedRule_pos_prev = extra_info_straight.getRule_pos_prev();
		Object generatedBase_fp = extra_info_combi.getBase_fp();
		Object generatedCombs_fp = extra_info_combi.getCombs_fp();
		Object generatedCombs_cnt = combinator_ctx.getCombs_cnt();
		Byte generatedScratch_buf = extra_info_combi.getScratch_buf();
		Object generatedComb_pos_prev = extra_info_combi.getComb_pos_prev();
		if (attack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
			extra_info_straight_t extra_info_straight = (extra_info_straight_t)extra_info;
			for (u64 i = cur;
			 i < end; i++) {
				if ((i % generatedKernel_rules_cnt) == 0) {
					Byte line_buf = (null);
					u32 line_len = 0;
					while (1) {
						HCFILE fp = generatedFp;
						ModernizedCProgram.get_next_word(hashcat_ctx, fp, line_buf, line_len);
						byte[] rule_buf_out = new byte[256];
						if (ModernizedCProgram.run_rule_engine((int)generatedRule_len_l, generatedRule_buf_l)) {
							if (line_len >= 256) {
								continue;
							} 
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(rule_buf_out, 0, /*Error: sizeof expression not supported yet*/);
							int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_l, (int)generatedRule_len_l, line_buf, (int)line_len, rule_buf_out);
							if (rule_len_out < 0) {
								continue;
							} 
							line_buf = rule_buf_out;
							line_len = (u32)rule_len_out;
						} 
						break;
					}
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBase_buf, line_buf, line_len);
					extra_info_straight.setBase_len(line_len);
				} 
			}
			extra_info_straight.setRule_pos_prev(end % generatedKernel_rules_cnt);
			extra_info_straight.setRule_pos(generatedRule_pos_prev);
		}  else if (attack_mode == attack_mode.ATTACK_MODE_COMBI) {
			extra_info_combi_t extra_info_combi = (extra_info_combi_t)extra_info;
			HCFILE base_fp = generatedBase_fp;
			HCFILE combs_fp = generatedCombs_fp;
			for (u64 i = cur;
			 i < end; i++) {
				if ((i % generatedCombs_cnt) == 0) {
					Byte line_buf = (null);
					u32 line_len = 0;
					while (1) {
						ModernizedCProgram.get_next_word(hashcat_ctx, base_fp, line_buf, line_len);
						byte[] rule_buf_out = new byte[256];
						if (ModernizedCProgram.run_rule_engine((int)generatedRule_len_l, generatedRule_buf_l)) {
							if (line_len >= 256) {
								continue;
							} 
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(rule_buf_out, 0, /*Error: sizeof expression not supported yet*/);
							int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_l, (int)generatedRule_len_l, line_buf, (int)line_len, rule_buf_out);
							if (rule_len_out < 0) {
								continue;
							} 
							line_buf = rule_buf_out;
							line_len = (u32)rule_len_out;
						} 
						break;
					}
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBase_buf, line_buf, line_len);
					extra_info_combi.setBase_len(line_len);
					combs_fp.hc_rewind();
				} 
				Byte line_buf = generatedScratch_buf;
				u32 line_len = 0;
				while (1) {
					line_len = (u32)combs_fp.fgetl(line_buf, -1024);
					line_len = hashcat_ctx.convert_from_hex(line_buf, line_len);
					if (ModernizedCProgram.run_rule_engine((int)generatedRule_len_l, generatedRule_buf_l)) {
						if (line_len >= 256) {
							continue;
						} 
						byte[] rule_buf_out = new byte[256];
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(rule_buf_out, 0, /*Error: sizeof expression not supported yet*/);
						int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_l, (int)generatedRule_len_l, line_buf, (int)line_len, rule_buf_out);
						if (rule_len_out < 0) {
							continue;
						} 
					} 
					break;
				}
			}
			extra_info_combi.setComb_pos_prev(end % generatedCombs_cnt);
			extra_info_combi.setComb_pos(generatedComb_pos_prev);
		}  else if (attack_mode == attack_mode.ATTACK_MODE_BF) {
		} 
	}
	public void slow_candidates_next(Object extra_info) {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		combinator_ctx generatedCombinator_ctx = this.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		Object generatedAttack_mode = user_options.getAttack_mode();
		u32 attack_mode = generatedAttack_mode;
		Object generatedPos = extra_info_straight.getPos();
		Object generatedKernel_rules_cnt = straight_ctx.getKernel_rules_cnt();
		Object generatedFp = extra_info_straight.getFp();
		Object generatedRule_len_l = user_options_extra.getRule_len_l();
		Object generatedRule_buf_l = user_options.getRule_buf_l();
		Object[] generatedBase_buf = extra_info_straight.getBase_buf();
		Object[] generatedOut_buf = extra_info_straight.getOut_buf();
		Object generatedBase_len = extra_info_straight.getBase_len();
		Object generatedOut_len = extra_info_straight.getOut_len();
		Object generatedOpti_type = hashconfig.getOpti_type();
		[] generatedKernel_rules_buf = straight_ctx.getKernel_rules_buf();
		Object generatedRule_pos = extra_info_straight.getRule_pos();
		Object generatedBase_fp = extra_info_combi.getBase_fp();
		Object generatedCombs_fp = extra_info_combi.getCombs_fp();
		Object generatedCombs_cnt = combinator_ctx.getCombs_cnt();
		Byte generatedScratch_buf = extra_info_combi.getScratch_buf();
		Object generatedRule_len_r = user_options_extra.getRule_len_r();
		Object generatedRule_buf_r = user_options.getRule_buf_r();
		Object generatedComb_pos = extra_info_combi.getComb_pos();
		 generatedRoot_css_buf = mask_ctx.getRoot_css_buf();
		 generatedMarkov_css_buf = mask_ctx.getMarkov_css_buf();
		Object generatedCss_cnt = mask_ctx.getCss_cnt();
		if (attack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
			extra_info_straight_t extra_info_straight = (extra_info_straight_t)extra_info;
			if ((generatedPos % generatedKernel_rules_cnt) == 0) {
				Byte line_buf = (null);
				u32 line_len = 0;
				while (1) {
					HCFILE fp = generatedFp;
					ModernizedCProgram.get_next_word(hashcat_ctx, fp, line_buf, line_len);
					byte[] rule_buf_out = new byte[256];
					if (ModernizedCProgram.run_rule_engine((int)generatedRule_len_l, generatedRule_buf_l)) {
						if (line_len >= 256) {
							continue;
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(rule_buf_out, 0, /*Error: sizeof expression not supported yet*/);
						int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_l, (int)generatedRule_len_l, line_buf, (int)line_len, rule_buf_out);
						if (rule_len_out < 0) {
							continue;
						} 
						line_buf = rule_buf_out;
						line_len = (u32)rule_len_out;
					} 
					break;
				}
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBase_buf, line_buf, line_len);
				extra_info_straight.setBase_len(line_len);
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedOut_buf, generatedBase_buf, generatedBase_len);
			extra_info_straight.setOut_len(generatedBase_len);
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedOut_buf + generatedBase_len, 0, /*Error: sizeof expression not supported yet*/ - generatedOut_len);
			u32 out_ptr = (u32)generatedOut_buf;
			if (generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
				extra_info_straight.setOut_len(/*Error: Function owner not recognized*/apply_rules_optimized(generatedKernel_rules_buf[generatedRule_pos].getCmds(), out_ptr[0], out_ptr[4], generatedOut_len));
			} else {
					extra_info_straight.setOut_len(/*Error: Function owner not recognized*/apply_rules(generatedKernel_rules_buf[generatedRule_pos].getCmds(), out_ptr, generatedOut_len));
			} 
			extra_info_straight.setRule_pos_prev(generatedRule_pos);
			generatedRule_pos++;
			if (generatedRule_pos == generatedKernel_rules_cnt) {
				extra_info_straight.setRule_pos(0);
			} 
		}  else if (attack_mode == attack_mode.ATTACK_MODE_COMBI) {
			extra_info_combi_t extra_info_combi = (extra_info_combi_t)extra_info;
			HCFILE base_fp = generatedBase_fp;
			HCFILE combs_fp = generatedCombs_fp;
			if ((generatedPos % generatedCombs_cnt) == 0) {
				Byte line_buf = (null);
				u32 line_len = 0;
				while (1) {
					ModernizedCProgram.get_next_word(hashcat_ctx, base_fp, line_buf, line_len);
					byte[] rule_buf_out = new byte[256];
					if (ModernizedCProgram.run_rule_engine((int)generatedRule_len_l, generatedRule_buf_l)) {
						if (line_len >= 256) {
							continue;
						} 
						/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(rule_buf_out, 0, /*Error: sizeof expression not supported yet*/);
						int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_l, (int)generatedRule_len_l, line_buf, (int)line_len, rule_buf_out);
						if (rule_len_out < 0) {
							continue;
						} 
						line_buf = rule_buf_out;
						line_len = (u32)rule_len_out;
					} 
					break;
				}
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedBase_buf, line_buf, line_len);
				extra_info_combi.setBase_len(line_len);
				combs_fp.hc_rewind();
			} 
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedOut_buf, generatedBase_buf, generatedBase_len);
			extra_info_combi.setOut_len(generatedBase_len);
			Byte line_buf = generatedScratch_buf;
			u32 line_len = 0;
			while (1) {
				line_len = (u32)combs_fp.fgetl(line_buf, -1024);
				line_len = hashcat_ctx.convert_from_hex(line_buf, line_len);
				if (ModernizedCProgram.run_rule_engine((int)generatedRule_len_r, generatedRule_buf_r)) {
					if (line_len >= 256) {
						continue;
					} 
					byte[] rule_buf_out = new byte[256];
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(rule_buf_out, 0, /*Error: sizeof expression not supported yet*/);
					int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_r, (int)generatedRule_len_r, line_buf, (int)line_len, rule_buf_out);
					if (rule_len_out < 0) {
						continue;
					} 
				} 
				break;
			}
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(generatedOut_buf + generatedOut_len, line_buf, line_len);
			generatedOut_len += line_len;
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedOut_buf + generatedOut_len, 0, /*Error: sizeof expression not supported yet*/ - generatedOut_len);
			extra_info_combi.setComb_pos_prev(generatedComb_pos);
			generatedComb_pos++;
			if (generatedComb_pos == generatedCombs_cnt) {
				extra_info_combi.setComb_pos(0);
			} 
		}  else if (attack_mode == attack_mode.ATTACK_MODE_BF) {
			extra_info_mask_t extra_info_mask = (extra_info_mask_t)extra_info;
			generatedRoot_css_buf.sp_exec(generatedPos, (byte)generatedOut_buf, generatedMarkov_css_buf, 0, generatedCss_cnt);
		} 
	}
	public int outfile_remove() {
		hashconfig generatedHashconfig = this.getHashconfig();
		// some hash-dependent constantshashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		module_ctx generatedModule_ctx = this.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		outcheck_ctx generatedOutcheck_ctx = this.getOutcheck_ctx();
		outcheck_ctx_t outcheck_ctx = generatedOutcheck_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		Object generatedDgst_size = hashconfig.getDgst_size();
		size_t dgst_size = generatedDgst_size;
		boolean generatedIs_salted = hashconfig.getIs_salted();
		boolean is_salted = generatedIs_salted;
		byte generatedSeparator = hashconfig.getSeparator();
		byte separator = generatedSeparator;
		salt[] generatedSalts_buf = hashes.getSalts_buf();
		salt_t salts_buf = generatedSalts_buf;
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		u32 salts_cnt = generatedSalts_cnt;
		Object generatedDigests_buf = hashes.getDigests_buf();
		Byte digests_buf = generatedDigests_buf;
		Byte generatedRoot_directory = outcheck_ctx.getRoot_directory();
		Byte root_directory = generatedRoot_directory;
		Object generatedOutfile_check_timer = user_options.getOutfile_check_timer();
		u32 outfile_check_timer = generatedOutfile_check_timer;
		// buffershash_t hash_buf = new hash_t();
		hash_buf.setDigest(ModernizedCProgram.hcmalloc(dgst_size));
		hash_buf.setSalt((null));
		hash_buf.setEsalt((null));
		hash_buf.setHook_salt((null));
		hash_buf.setCracked(0);
		hash_buf.setHash_info((null));
		hash_buf.setPw_buf((null));
		hash_buf.setPw_len(0);
		if (generatedIs_salted == true) {
			hash_buf.setSalt((salt_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		} 
		Object generatedEsalt_size = hashconfig.getEsalt_size();
		if (generatedEsalt_size > 0) {
			hash_buf.setEsalt(ModernizedCProgram.hcmalloc(generatedEsalt_size));
		} 
		Object generatedHook_salt_size = hashconfig.getHook_salt_size();
		if (generatedHook_salt_size > 0) {
			hash_buf.setHook_salt(ModernizedCProgram.hcmalloc(generatedHook_salt_size));
		} 
		outfile_data_t[] out_info = (null);
		Byte out_files = (null);
		time_t folder_mtime = 0;
		int out_cnt = 0;
		// or 1 if we want to check it at startupu32 check_left = outfile_check_timer;
		boolean generatedShutdown_inner = status_ctx.getShutdown_inner();
		Object generatedDevices_status = status_ctx.getDevices_status();
		Object generatedSt_mtime = outfile_check_stat.getSt_mtime();
		Object generatedSt_ctime = outfile_stat.getSt_ctime();
		salt generatedSalt = hash_buf.getSalt();
		Object generatedEsalt = hash_buf.getEsalt();
		Object generatedHook_salt = hash_buf.getHook_salt();
		Object generatedModule_hash_decode_potfile = module_ctx.getModule_hash_decode_potfile();
		Object generatedTmp_size = hashconfig.getTmp_size();
		Object generatedDigest = hash_buf.getDigest();
		hashinfo generatedHash_info = hash_buf.getHash_info();
		Object[] generatedSalts_shown = hashes.getSalts_shown();
		Object generatedDigests_offset = salt_buf.getDigests_offset();
		boolean generatedOutfile_check_nocomp = hashconfig.getOutfile_check_nocomp();
		Object generatedDigests_cnt = salt_buf.getDigests_cnt();
		Object[] generatedDigests_shown = hashes.getDigests_shown();
		Object generatedDigests_done = hashes.getDigests_done();
		Object generatedSalts_done = hashes.getSalts_done();
		while (generatedShutdown_inner == false) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/sleep(1);
			if (generatedDevices_status != status_rc.STATUS_RUNNING) {
				continue;
			} 
			check_left--;
			if (check_left != 0) {
				continue;
			} 
			check_left = outfile_check_timer;
			if (ModernizedCProgram.hc_path_exist(root_directory) == 0) {
				continue;
			} 
			boolean is_dir = ModernizedCProgram.hc_path_is_directory(root_directory);
			if (is_dir == 0) {
				continue;
			} 
			stat outfile_check_stat = new stat();
			if (/*Error: Function owner not recognized*/stat(root_directory, outfile_check_stat) == -1) {
				hashcat_ctx.event_log_error("%s: %s", root_directory, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
				ModernizedCProgram.hcfree(out_files);
				ModernizedCProgram.hcfree(out_info);
				return -1;
			} 
			if (generatedSt_mtime > folder_mtime) {
				Byte out_files_new = ModernizedCProgram.scan_directory(root_directory);
				int out_cnt_new = ModernizedCProgram.count_dictionaries(out_files_new);
				outfile_data_t out_info_new = (null);
				if (out_cnt_new > 0) {
					out_info_new = (outfile_data_t)ModernizedCProgram.hccalloc(out_cnt_new, /*Error: Unsupported expression*/);
					for (int i = 0;
					 i < out_cnt_new; i++) {
						out_info_new[i].setFile_name(out_files_new[i]);
						for (int j = 0;
						 j < out_cnt; j++) {
							if (/*Error: Function owner not recognized*/strcmp(out_info[j].getFile_name(), out_info_new[i].getFile_name()) != 0) {
								continue;
							} 
							stat outfile_stat = new stat();
							if (/*Error: Function owner not recognized*/stat(out_info_new[i].getFile_name(), outfile_stat) != 0) {
								continue;
							} 
							if (generatedSt_ctime != out_info[j].getCtime()) {
								continue;
							} 
							out_info_new[i].setCtime(out_info[j].getCtime());
							out_info_new[i].setSeek(out_info[j].getSeek());
						}
					}
				} 
				ModernizedCProgram.hcfree(out_info);
				ModernizedCProgram.hcfree(out_files);
				out_files = out_files_new;
				out_cnt = out_cnt_new;
				out_info = out_info_new;
				folder_mtime = generatedSt_mtime;
			} 
			for (int j = 0;
			 j < out_cnt; j++) {
				HCFILE fp = new HCFILE();
				if (fp.hc_fopen(out_info[j].getFile_name(), "rb") == 0) {
					continue;
				} 
				stat outfile_stat = new stat();
				if (/*Error: Function owner not recognized*/fstat(fp.hc_fileno(), outfile_stat)) {
					fp.hc_fclose();
					continue;
				} 
				if (generatedSt_ctime > out_info[j].getCtime()) {
					out_info[j].setCtime(generatedSt_ctime);
					out_info[j].setSeek(0);
				} 
				fp.hc_fseek(out_info[j].getSeek(), 0);
				Byte line_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
				while (!fp.hc_feof()) {
					size_t line_len = fp.fgetl(line_buf, -1024);
					if (line_len == 0) {
						continue;
					} 
					line_buf[line_len] = separator;
					line_len++;
					for (int tries = 0;
					 tries < 256; tries++) {
						Byte last_separator = /*Error: Function owner not recognized*/strrchr(line_buf, separator);
						if (last_separator == (null)) {
							break;
						} 
						Byte line_hash_buf = line_buf;
						int line_hash_len = last_separator - line_buf;
						line_hash_buf[line_hash_len] = 0;
						if (line_hash_len == 0) {
							continue;
						} 
						if (generatedSalt) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedSalt, 0, /*Error: Unsupported expression*/);
						} 
						if (generatedEsalt) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedEsalt, 0, generatedEsalt_size);
						} 
						if (generatedHook_salt) {
							/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(generatedHook_salt, 0, generatedHook_salt_size);
						} 
						int parser_status = parser_rc.PARSER_HASH_LENGTH;
						if (generatedModule_hash_decode_potfile != (Object)-1) {
							Object tmps = ModernizedCProgram.hcmalloc(generatedTmp_size);
							parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, line_buf, line_hash_len, tmps);
							ModernizedCProgram.hcfree(tmps);
						} else {
								parser_status = /*Error: Function owner not recognized*/ERROR_UNRECOGNIZED_FUNCTIONNAME(hashconfig, generatedDigest, generatedSalt, generatedEsalt, generatedHook_salt, generatedHash_info, line_buf, line_hash_len);
						} 
						if (parser_status != parser_rc.PARSER_OK) {
							continue;
						} 
						salt_t salt_buf = salts_buf;
						if (is_salted == 1) {
							salt_buf = (salt_t)ModernizedCProgram.hc_bsearch_r(generatedSalt, salts_buf, salts_cnt, /*Error: Unsupported expression*/, sort_by_salt_buf, (Object)hashconfig);
						} 
						if (salt_buf == (null)) {
							continue;
						} 
						u32 salt_pos = salt_buf - salts_buf;
						if (generatedSalts_shown[salt_pos] == 1) {
							break;
						} 
						u32 idx = generatedDigests_offset;
						boolean cracked = false;
						if (generatedOutfile_check_nocomp == true) {
							cracked = true;
						} else {
								Byte digests_buf_ptr = digests_buf + (generatedDigests_offset * dgst_size);
								u32 digests_buf_cnt = generatedDigests_cnt;
								Byte digest_buf = (byte)ModernizedCProgram.hc_bsearch_r(generatedDigest, digests_buf_ptr, digests_buf_cnt, dgst_size, ModernizedCProgram.sort_by_digest_p0p1, (Object)hashconfig);
								if (digest_buf != (null)) {
									idx += (digest_buf - digests_buf_ptr) / dgst_size;
									if (generatedDigests_shown[idx] == 1) {
										break;
									} 
									cracked = true;
								} 
						} 
						if (cracked == true) {
							generatedDigests_shown[idx] = 1;
							generatedDigests_done++;
							generatedDigests_done++;
							if (generatedDigests_done == generatedDigests_cnt) {
								generatedSalts_shown[salt_pos] = 1;
								generatedSalts_done++;
								if (generatedSalts_done == salts_cnt) {
									hashcat_ctx.mycracked();
								} 
							} 
							break;
						} 
						if (generatedShutdown_inner == true) {
							break;
						} 
					}
				}
				ModernizedCProgram.hcfree(line_buf);
				out_info[j].setSeek(fp.hc_ftell());
				fp.hc_fclose();
				if (generatedShutdown_inner == true) {
					break;
				} 
			}
		}
		ModernizedCProgram.hcfree(generatedEsalt);
		ModernizedCProgram.hcfree(generatedHook_salt);
		ModernizedCProgram.hcfree(generatedSalt);
		ModernizedCProgram.hcfree(generatedDigest);
		ModernizedCProgram.hcfree(out_info);
		ModernizedCProgram.hcfree(out_files);
		return 0;
	}
	public int outcheck_ctx_init() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		outcheck_ctx generatedOutcheck_ctx = this.getOutcheck_ctx();
		outcheck_ctx_t outcheck_ctx = generatedOutcheck_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		outcheck_ctx.setEnabled(0);
		if (user_options.getKeyspace() == 1) {
			return 0;
		} 
		if (user_options.getBenchmark() == 1) {
			return 0;
		} 
		if (user_options.getExample_hashes() == 1) {
			return 0;
		} 
		if (user_options.getSpeed_only() == 1) {
			return 0;
		} 
		if (user_options.getProgress_only() == 1) {
			return 0;
		} 
		if (user_options.getBackend_info() == 1) {
			return 0;
		} 
		if (hashconfig.getOutfile_check_disable() == 1) {
			return 0;
		} 
		if (user_options.getOutfile_check_timer() == 0) {
			return 0;
		} 
		Byte generatedRoot_directory = outcheck_ctx.getRoot_directory();
		if (user_options.getOutfile_check_dir() == (null)) {
			ModernizedCProgram.hc_asprintf(generatedRoot_directory, "%s/%s.%s", folder_config.getSession_dir(), user_options.getSession(), "outfiles");
		} else {
				outcheck_ctx.setRoot_directory(user_options.getOutfile_check_dir());
		} 
		outcheck_ctx.setEnabled(1);
		if (ModernizedCProgram.hc_path_exist(generatedRoot_directory) == 0) {
			if (ModernizedCProgram.hc_mkdir(generatedRoot_directory, 700) == -1) {
				hashcat_ctx.event_log_error("%s: %s", generatedRoot_directory, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
				return -1;
			} 
		} 
		return 0;
	}
	public void outcheck_ctx_destroy() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		outcheck_ctx generatedOutcheck_ctx = this.getOutcheck_ctx();
		outcheck_ctx_t outcheck_ctx = generatedOutcheck_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedEnabled = outcheck_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		boolean generatedOutfile_check_disable = hashconfig.getOutfile_check_disable();
		if (generatedOutfile_check_disable == true) {
			return /*Error: Unsupported expression*/;
		} 
		Byte generatedRoot_directory = outcheck_ctx.getRoot_directory();
		if (/*Error: Function owner not recognized*/rmdir(generatedRoot_directory) == -1) {
			if ((/*Error: Function owner not recognized*/_errno()) == 2) {
			}  else if ((/*Error: Function owner not recognized*/_errno()) == 41) {
			} else {
					hashcat_ctx.event_log_error("%s: %s", generatedRoot_directory, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			} 
		} 
		Byte generatedOutfile_check_dir = user_options.getOutfile_check_dir();
		if (generatedOutfile_check_dir == (null)) {
			ModernizedCProgram.hcfree(generatedRoot_directory);
		} 
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(outcheck_ctx, 0, /*Error: Unsupported expression*/);
	}
	public int bitmap_ctx_init() {
		bitmap_ctx generatedBitmap_ctx = this.getBitmap_ctx();
		bitmap_ctx_t bitmap_ctx = generatedBitmap_ctx;
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		bitmap_ctx.setEnabled(0);
		boolean generatedExample_hashes = user_options.getExample_hashes();
		if (generatedExample_hashes == true) {
			return 0;
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			return 0;
		} 
		boolean generatedBackend_info = user_options.getBackend_info();
		if (generatedBackend_info == true) {
			return 0;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			return 0;
		} 
		boolean generatedUsage = user_options.getUsage();
		if (generatedUsage == true) {
			return 0;
		} 
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			return 0;
		} 
		bitmap_ctx.setEnabled(1/**
		   * generate bitmap tables
		   */);
		u32 bitmap_shift1 = 5;
		u32 bitmap_shift2 = 13;
		Object generatedBitmap_min = user_options.getBitmap_min();
		u32 bitmap_min = generatedBitmap_min;
		Object generatedBitmap_max = user_options.getBitmap_max();
		u32 bitmap_max = generatedBitmap_max;
		u32 bitmap_s1_a = (u32)ModernizedCProgram.hcmalloc((-1024 << bitmap_max) * /*Error: Unsupported expression*/);
		u32 bitmap_s1_b = (u32)ModernizedCProgram.hcmalloc((-1024 << bitmap_max) * /*Error: Unsupported expression*/);
		u32 bitmap_s1_c = (u32)ModernizedCProgram.hcmalloc((-1024 << bitmap_max) * /*Error: Unsupported expression*/);
		u32 bitmap_s1_d = (u32)ModernizedCProgram.hcmalloc((-1024 << bitmap_max) * /*Error: Unsupported expression*/);
		u32 bitmap_s2_a = (u32)ModernizedCProgram.hcmalloc((-1024 << bitmap_max) * /*Error: Unsupported expression*/);
		u32 bitmap_s2_b = (u32)ModernizedCProgram.hcmalloc((-1024 << bitmap_max) * /*Error: Unsupported expression*/);
		u32 bitmap_s2_c = (u32)ModernizedCProgram.hcmalloc((-1024 << bitmap_max) * /*Error: Unsupported expression*/);
		u32 bitmap_s2_d = (u32)ModernizedCProgram.hcmalloc((-1024 << bitmap_max) * /*Error: Unsupported expression*/);
		u32 bitmap_bits = new u32();
		u32 bitmap_nums = new u32();
		u32 bitmap_mask = new u32();
		u32 bitmap_size = new u32();
		Object generatedDigests_cnt = hashes.getDigests_cnt();
		Object generatedDgst_size = hashconfig.getDgst_size();
		Object generatedDigests_buf = hashes.getDigests_buf();
		Object generatedDgst_pos0 = hashconfig.getDgst_pos0();
		Object generatedDgst_pos1 = hashconfig.getDgst_pos1();
		Object generatedDgst_pos2 = hashconfig.getDgst_pos2();
		Object generatedDgst_pos3 = hashconfig.getDgst_pos3();
		for (bitmap_bits = bitmap_min; bitmap_bits < bitmap_max; bitmap_bits++) {
			bitmap_nums = -1024 << bitmap_bits;
			bitmap_mask = bitmap_nums - 1;
			bitmap_size = bitmap_nums * /*Error: Unsupported expression*/;
			if ((generatedDigests_cnt & bitmap_mask) == generatedDigests_cnt) {
				break;
			} 
			if (ModernizedCProgram.generate_bitmaps(generatedDigests_cnt, generatedDgst_size, bitmap_shift1, (byte)generatedDigests_buf, generatedDgst_pos0, generatedDgst_pos1, generatedDgst_pos2, generatedDgst_pos3, bitmap_mask, bitmap_size, bitmap_s1_a, bitmap_s1_b, bitmap_s1_c, bitmap_s1_d, generatedDigests_cnt / 2) == 1) {
				continue;
			} 
			if (ModernizedCProgram.generate_bitmaps(generatedDigests_cnt, generatedDgst_size, bitmap_shift2, (byte)generatedDigests_buf, generatedDgst_pos0, generatedDgst_pos1, generatedDgst_pos2, generatedDgst_pos3, bitmap_mask, bitmap_size, bitmap_s1_a, bitmap_s1_b, bitmap_s1_c, bitmap_s1_d, generatedDigests_cnt / 2) == 1) {
				continue;
			} 
			break;
		}
		if (bitmap_bits == bitmap_max) {
			hashcat_ctx.event_call((event_identifier.EVENT_BITMAP_FINAL_OVERFLOW), ((null)), (false));
		} 
		bitmap_nums = -1024 << bitmap_bits;
		bitmap_mask = bitmap_nums - 1;
		bitmap_size = bitmap_nums * /*Error: Unsupported expression*/;
		ModernizedCProgram.generate_bitmaps(generatedDigests_cnt, generatedDgst_size, bitmap_shift1, (byte)generatedDigests_buf, generatedDgst_pos0, generatedDgst_pos1, generatedDgst_pos2, generatedDgst_pos3, bitmap_mask, bitmap_size, bitmap_s1_a, bitmap_s1_b, bitmap_s1_c, bitmap_s1_d, -1);
		ModernizedCProgram.generate_bitmaps(generatedDigests_cnt, generatedDgst_size, bitmap_shift2, (byte)generatedDigests_buf, generatedDgst_pos0, generatedDgst_pos1, generatedDgst_pos2, generatedDgst_pos3, bitmap_mask, bitmap_size, bitmap_s2_a, bitmap_s2_b, bitmap_s2_c, bitmap_s2_d, -1);
		Object generatedSt_hash = hashconfig.getSt_hash();
		Object generatedSt_digests_buf = hashes.getSt_digests_buf();
		if (generatedSt_hash != (null)) {
			ModernizedCProgram.selftest_to_bitmap(bitmap_shift1, (byte)generatedSt_digests_buf, generatedDgst_pos0, generatedDgst_pos1, generatedDgst_pos2, generatedDgst_pos3, bitmap_mask, bitmap_s1_a, bitmap_s1_b, bitmap_s1_c, bitmap_s1_d);
			ModernizedCProgram.selftest_to_bitmap(bitmap_shift2, (byte)generatedSt_digests_buf, generatedDgst_pos0, generatedDgst_pos1, generatedDgst_pos2, generatedDgst_pos3, bitmap_mask, bitmap_s2_a, bitmap_s2_b, bitmap_s2_c, bitmap_s2_d);
		} 
		bitmap_ctx.setBitmap_bits(bitmap_bits);
		bitmap_ctx.setBitmap_nums(bitmap_nums);
		bitmap_ctx.setBitmap_size(bitmap_size);
		bitmap_ctx.setBitmap_mask(bitmap_mask);
		bitmap_ctx.setBitmap_shift1(bitmap_shift1);
		bitmap_ctx.setBitmap_shift2(bitmap_shift2);
		bitmap_ctx.setBitmap_s1_a(bitmap_s1_a);
		bitmap_ctx.setBitmap_s1_b(bitmap_s1_b);
		bitmap_ctx.setBitmap_s1_c(bitmap_s1_c);
		bitmap_ctx.setBitmap_s1_d(bitmap_s1_d);
		bitmap_ctx.setBitmap_s2_a(bitmap_s2_a);
		bitmap_ctx.setBitmap_s2_b(bitmap_s2_b);
		bitmap_ctx.setBitmap_s2_c(bitmap_s2_c);
		bitmap_ctx.setBitmap_s2_d(bitmap_s2_d);
		return 0;
	}
	public void bitmap_ctx_destroy() {
		bitmap_ctx generatedBitmap_ctx = this.getBitmap_ctx();
		bitmap_ctx_t bitmap_ctx = generatedBitmap_ctx;
		boolean generatedEnabled = bitmap_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		Object generatedBitmap_s1_a = bitmap_ctx.getBitmap_s1_a();
		ModernizedCProgram.hcfree(generatedBitmap_s1_a);
		Object generatedBitmap_s1_b = bitmap_ctx.getBitmap_s1_b();
		ModernizedCProgram.hcfree(generatedBitmap_s1_b);
		Object generatedBitmap_s1_c = bitmap_ctx.getBitmap_s1_c();
		ModernizedCProgram.hcfree(generatedBitmap_s1_c);
		Object generatedBitmap_s1_d = bitmap_ctx.getBitmap_s1_d();
		ModernizedCProgram.hcfree(generatedBitmap_s1_d);
		Object generatedBitmap_s2_a = bitmap_ctx.getBitmap_s2_a();
		ModernizedCProgram.hcfree(generatedBitmap_s2_a);
		Object generatedBitmap_s2_b = bitmap_ctx.getBitmap_s2_b();
		ModernizedCProgram.hcfree(generatedBitmap_s2_b);
		Object generatedBitmap_s2_c = bitmap_ctx.getBitmap_s2_c();
		ModernizedCProgram.hcfree(generatedBitmap_s2_c);
		Object generatedBitmap_s2_d = bitmap_ctx.getBitmap_s2_d();
		ModernizedCProgram.hcfree(generatedBitmap_s2_d);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(bitmap_ctx, 0, /*Error: Unsupported expression*/);
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public void logfile_generate_topid() {
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		boolean generatedEnabled = logfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		timeval v = new timeval();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/gettimeofday(v, (null));
		Byte generatedTopid = logfile_ctx.getTopid();
		Object generatedTv_sec = v.getTv_sec();
		Object generatedTv_usec = v.getTv_usec();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(generatedTopid, 40, "TOP.%08x.%08x", (u32)generatedTv_sec, (u32)generatedTv_usec);
	}
	public void logfile_generate_subid() {
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		boolean generatedEnabled = logfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		timeval v = new timeval();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/gettimeofday(v, (null));
		Byte generatedSubid = logfile_ctx.getSubid();
		Object generatedTv_sec = v.getTv_sec();
		Object generatedTv_usec = v.getTv_usec();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/snprintf(generatedSubid, 40, "SUB.%08x.%08x", (u32)generatedTv_sec, (u32)generatedTv_usec);
	}
	public void logfile_append(Object fmt) {
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		boolean generatedEnabled = logfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		HCFILE fp = new HCFILE();
		Byte generatedLogfile = logfile_ctx.getLogfile();
		if (fp.hc_fopen(generatedLogfile, "ab") == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedLogfile, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return /*Error: Unsupported expression*/;
		} 
		fp.hc_lockfile();
		va_list ap = new va_list();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_start(ap, fmt);
		fp.hc_vfprintf(fmt, ap);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/__builtin_va_end(ap);
		fp.hc_fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1);
		fp.hc_fflush();
		fp.hc_fclose();
	}
	public int logfile_init() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedLogfile_disable = user_options.getLogfile_disable();
		if (generatedLogfile_disable == true) {
			return 0;
		} 
		Byte generatedLogfile = logfile_ctx.getLogfile();
		Byte generatedSession_dir = folder_config.getSession_dir();
		Object generatedSession = user_options.getSession();
		ModernizedCProgram.hc_asprintf(generatedLogfile, "%s/%s.log", generatedSession_dir, generatedSession);
		logfile_ctx.setSubid((byte)ModernizedCProgram.hcmalloc(-1024));
		logfile_ctx.setTopid((byte)ModernizedCProgram.hcmalloc(-1024));
		logfile_ctx.setEnabled(1);
		return 0;
	}
	public void logfile_destroy() {
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		boolean generatedEnabled = logfile_ctx.getEnabled();
		if (generatedEnabled == false) {
			return /*Error: Unsupported expression*/;
		} 
		Byte generatedLogfile = logfile_ctx.getLogfile();
		ModernizedCProgram.hcfree(generatedLogfile);
		Byte generatedTopid = logfile_ctx.getTopid();
		ModernizedCProgram.hcfree(generatedTopid);
		Byte generatedSubid = logfile_ctx.getSubid();
		ModernizedCProgram.hcfree(generatedSubid);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(logfile_ctx, 0, /*Error: Unsupported expression*/);
	}
	public int outfile_init() {
		outfile_ctx generatedOutfile_ctx = this.getOutfile_ctx();
		outfile_ctx_t outfile_ctx = generatedOutfile_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		hc_fp generatedFp = outfile_ctx.getFp();
		generatedFp.setPfp((null));
		Byte generatedOutfile = user_options.getOutfile();
		outfile_ctx.setFilename(generatedOutfile);
		Object generatedOutfile_format = user_options.getOutfile_format();
		outfile_ctx.setOutfile_format(generatedOutfile_format);
		boolean generatedOutfile_autohex = user_options.getOutfile_autohex();
		outfile_ctx.setOutfile_autohex(generatedOutfile_autohex);
		return 0;
	}
	public void outfile_destroy() {
		outfile_ctx generatedOutfile_ctx = this.getOutfile_ctx();
		outfile_ctx_t outfile_ctx = generatedOutfile_ctx;
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(outfile_ctx, 0, /*Error: Unsupported expression*/);
	}
	public int outfile_write_open() {
		outfile_ctx generatedOutfile_ctx = this.getOutfile_ctx();
		outfile_ctx_t outfile_ctx = generatedOutfile_ctx;
		Byte generatedFilename = outfile_ctx.getFilename();
		if (generatedFilename == (null)) {
			return 0;
		} 
		hc_fp generatedFp = outfile_ctx.getFp();
		if (generatedFp.hc_fopen(generatedFilename, "ab") == 0) {
			hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		if (generatedFp.hc_lockfile() == -1) {
			generatedFp.hc_fclose();
			hashcat_ctx.event_log_error("%s: %s", generatedFilename, /*Error: Function owner not recognized*/strerror((/*Error: Function owner not recognized*/_errno())));
			return -1;
		} 
		return 0;
	}
	public void outfile_write_close() {
		outfile_ctx generatedOutfile_ctx = this.getOutfile_ctx();
		outfile_ctx_t outfile_ctx = generatedOutfile_ctx;
		hc_fp generatedFp = outfile_ctx.getFp();
		_iobuf generatedPfp = generatedFp.getPfp();
		if (generatedPfp == (null)) {
			return /*Error: Unsupported expression*/;
		} 
		generatedFp.hc_fclose();
	}
	public int outfile_write(Object out_buf, Object out_len, Object plain_ptr, Object plain_len, Object crackpos, Object username, Object user_len, byte[] tmp_buf) {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		outfile_ctx generatedOutfile_ctx = this.getOutfile_ctx();
		outfile_ctx_t outfile_ctx = generatedOutfile_ctx;
		Object generatedOutfile_format = outfile_ctx.getOutfile_format();
		u32 outfile_format = (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ALWAYS_HEXIFY) ? 5 : generatedOutfile_format;
		int tmp_len = 0;
		if (user_len > 0) {
			if (username != (null)) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(tmp_buf + tmp_len, username, user_len);
				tmp_len += user_len;
				if (outfile_format & (outfile_fmt.OUTFILE_FMT_HASH | outfile_fmt.OUTFILE_FMT_PLAIN | outfile_fmt.OUTFILE_FMT_HEXPLAIN | outfile_fmt.OUTFILE_FMT_CRACKPOS)) {
					tmp_buf[tmp_len] = hashconfig.getSeparator();
					tmp_len += 1;
				} 
			} 
		} 
		if (outfile_format & outfile_fmt.OUTFILE_FMT_HASH) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(tmp_buf + tmp_len, out_buf, out_len);
			tmp_len += out_len;
			if (outfile_format & (outfile_fmt.OUTFILE_FMT_PLAIN | outfile_fmt.OUTFILE_FMT_HEXPLAIN | outfile_fmt.OUTFILE_FMT_CRACKPOS)) {
				tmp_buf[tmp_len] = hashconfig.getSeparator();
				tmp_len += 1;
			} 
		} 
		if (outfile_format & outfile_fmt.OUTFILE_FMT_PLAIN) {
			boolean convert_to_hex = false;
			if (user_options.getShow() == 0) {
				if (user_options.getOutfile_autohex() == 1) {
					boolean always_ascii = (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ALWAYS_ASCII) ? 1 : 0;
					convert_to_hex = ModernizedCProgram.need_hexify(plain_ptr, plain_len, hashconfig.getSeparator(), always_ascii);
				} 
			} 
			if (convert_to_hex) {
				tmp_buf[tmp_len++] = (byte)'$';
				tmp_buf[tmp_len++] = (byte)'H';
				tmp_buf[tmp_len++] = (byte)'E';
				tmp_buf[tmp_len++] = (byte)'X';
				tmp_buf[tmp_len++] = (byte)'[';
				ModernizedCProgram.exec_hexify(plain_ptr, plain_len, (u8)tmp_buf + tmp_len);
				tmp_len += plain_len * 2;
				tmp_buf[tmp_len++] = (byte)']';
			} else {
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memcpy(tmp_buf + tmp_len, plain_ptr, plain_len);
					tmp_len += plain_len;
			} 
			if (outfile_format & (outfile_fmt.OUTFILE_FMT_HEXPLAIN | outfile_fmt.OUTFILE_FMT_CRACKPOS)) {
				tmp_buf[tmp_len] = hashconfig.getSeparator();
				tmp_len += 1;
			} 
		} 
		if (outfile_format & outfile_fmt.OUTFILE_FMT_HEXPLAIN) {
			ModernizedCProgram.exec_hexify(plain_ptr, plain_len, (u8)tmp_buf + tmp_len);
			tmp_len += plain_len * 2;
			if (outfile_format & (outfile_fmt.OUTFILE_FMT_CRACKPOS)) {
				tmp_buf[tmp_len] = hashconfig.getSeparator();
				tmp_len += 1;
			} 
		} 
		if (outfile_format & outfile_fmt.OUTFILE_FMT_CRACKPOS) {
			tmp_len += /*Error: Function owner not recognized*/snprintf(tmp_buf + tmp_len, -1024 - tmp_len, "%I64u", crackpos);
		} 
		tmp_buf[tmp_len] = 0;
		hc_fp generatedFp = outfile_ctx.getFp();
		_iobuf generatedPfp = generatedFp.getPfp();
		if (generatedPfp != (null)) {
			generatedFp.hc_fwrite(tmp_buf, tmp_len, 1);
			generatedFp.hc_fwrite("\r\n", /*Error: Function owner not recognized*/strlen("\r\n"), 1);
		} 
		return tmp_len;
	}
	public int benchmark_next() {
		folder_config generatedFolder_config = this.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		int cur = 0;
		if (user_options.getBenchmark_all() == 0) {
			int hash_mode = ModernizedCProgram.DEFAULT_BENCHMARK_ALGORITHMS_BUF[cur];
			if (hash_mode == -1) {
				return -1;
			} 
			cur++;
			return hash_mode;
		} 
		Byte modulefile = (byte)ModernizedCProgram.hcmalloc(-1024);
		for (int i = cur;
		 i < ModernizedCProgram.MODULE_HASH_MODES_MAXIMUM; i++) {
			ModernizedCProgram.module_filename(folder_config, i, modulefile, -1024);
			if (ModernizedCProgram.hc_path_exist(modulefile) == 1) {
				int hash_mode = i;
				cur = hash_mode + 1;
				ModernizedCProgram.hcfree(modulefile);
				return hash_mode;
			} 
		}
		ModernizedCProgram.hcfree(modulefile);
		return -1;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	// basic tools
	// features
	// inner2_loop iterates through wordlists, then calls kernel execution
	public int inner2_loop() {
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		induct_ctx generatedInduct_ctx = this.getInduct_ctx();
		induct_ctx_t induct_ctx = generatedInduct_ctx;
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		//status_ctx->run_main_level1   = true;
		//status_ctx->run_main_level2   = true;//status_ctx->run_main_level3   = true;//status_ctx->run_main_level2   = true;//status_ctx->run_main_level3   = true;status_ctx.setRun_thread_level1(1);
		status_ctx.setRun_thread_level2(1);
		status_ctx.setDevices_status(status_rc.STATUS_INIT);
		hashcat_ctx.logfile_generate_subid();
		Byte generatedTopid = logfile_ctx.getTopid();
		Byte generatedSubid = logfile_ctx.getSubid();
		hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, generatedSubid, ("START"));
		;
		hashcat_ctx.status_progress_reset();
		status_ctx.setMsec_paused(0);
		status_ctx.setWords_off(0);
		status_ctx.setWords_cur(0);
		boolean generatedRestore_execute = restore_ctx.getRestore_execute();
		restore_data generatedRd = restore_ctx.getRd();
		Object generatedWords_cur = rd.getWords_cur();
		Object generatedWords_off = status_ctx.getWords_off();
		if (generatedRestore_execute == true) {
			restore_ctx.setRestore_execute(0);
			restore_data_t rd = generatedRd;
			status_ctx.setWords_off(generatedWords_cur);
			status_ctx.setWords_cur(generatedWords_off);
			user_options.setSkip(0);
		} 
		Object generatedSkip = user_options.getSkip();
		if (generatedSkip > 0) {
			status_ctx.setWords_off(generatedSkip);
			status_ctx.setWords_cur(generatedWords_off);
			user_options.setSkip(0);
		} 
		hashcat_ctx.backend_session_reset();
		hashcat_ctx/**
		   * Update attack-mode specific stuff based on mask
		   */.cpt_ctx_reset();
		if (hashcat_ctx.mask_ctx_update_loop() == -1) {
			return 0/**
			   * Update attack-mode specific stuff based on wordlist
			   */;
		} 
		if (hashcat_ctx.straight_ctx_update_loop() == -1) {
			return 0;
		} 
		// words base
		u64 amplifier_cnt = hashcat_ctx.user_options_extra_amplifier();
		Object generatedWords_cnt = status_ctx.getWords_cnt();
		status_ctx.setWords_base(generatedWords_cnt / amplifier_cnt);
		hashcat_ctx.event_call((event_identifier.EVENT_CALCULATED_WORDS_BASE), (null), 0);
		boolean generatedKeyspace = user_options.getKeyspace();
		if (generatedKeyspace == true) {
			status_ctx.setDevices_status(status_rc.STATUS_RUNNING);
			return 0;
		} 
		Object generatedWords_base = status_ctx.getWords_base();
		// restore stuffif (generatedWords_off > generatedWords_base) {
			hashcat_ctx.event_log_error("Restore value is greater than keyspace.");
			return -1;
		} 
		u64 progress_restored = generatedWords_off * amplifier_cnt;
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		Object[] generatedWords_progress_restored = status_ctx.getWords_progress_restored();
		for (u32 i = 0;
		 i < generatedSalts_cnt; i++) {
			generatedWords_progress_restored[i] = progress_restored;
		}
		/**
		   * limit kernel loops by the amplification count we have from:
		   * - straight_ctx, combinator_ctx or mask_ctx for fast hashes
		   * - hash iteration count for slow hashes
		   * this is required for autotune
		   */hashcat_ctx/**
		   * prepare thread buffers
		   */.backend_ctx_devices_kernel_loops();
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		thread_param_t threads_param = (thread_param_t)ModernizedCProgram.hccalloc(generatedBackend_devices_cnt, /*Error: Unsupported expression*/);
		hc_thread_t[] c_threads = (hc_thread_t)ModernizedCProgram.hccalloc(generatedBackend_devices_cnt, /*Error: Unsupported expression*//**
		   * create autotune threads
		   */);
		hashcat_ctx.event_call((event_identifier.EVENT_AUTOTUNE_STARTING), (null), 0);
		status_ctx.setDevices_status(status_rc.STATUS_AUTOTUNE);
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
			thread_param_t thread_param = threads_param + backend_devices_idx;
			thread_param.setHashcat_ctx(hashcat_ctx);
			thread_param.setTid(backend_devices_idx);
			c_threads[backend_devices_idx] = /*Error: Function owner not recognized*/CreateThread((null), 0, (LPTHREAD_START_ROUTINE)ModernizedCProgram.thread_autotune, thread_param, 0, (null));
		}
		for (int i = 0;
		 i < generatedBackend_devices_cnt; i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject((c_threads)[i], -1024);
		}
		hashcat_ctx.event_call((event_identifier.EVENT_AUTOTUNE_FINISHED), (null), 0/**
		   * find same backend devices and equal results
		   */);
		hashcat_ctx/**
		   * autotune modified kernel_accel, which modifies backend_ctx->kernel_power_all
		   */.backend_ctx_devices_sync_tuning();
		hashcat_ctx/**
		   * Begin loopback recording
		   */.backend_ctx_devices_update_power();
		boolean generatedLoopback = user_options.getLoopback();
		if (generatedLoopback == true) {
			hashcat_ctx/**
			   * Prepare cracking stats
			   */.loopback_write_open();
		} 
		Object generatedTimer_running = status_ctx.getTimer_running();
		ModernizedCProgram.hc_timer_set(generatedTimer_running);
		time_t runtime_start = new time_t();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/time(runtime_start);
		status_ctx.setRuntime_start(runtime_start/**
		   * create cracker threads
		   */);
		hashcat_ctx.event_call((event_identifier.EVENT_CRACKER_STARTING), (null), 0);
		status_ctx.setDevices_status(status_rc.STATUS_RUNNING);
		status_ctx.setAccessible(1);
		Object generatedWordlist_mode = user_options_extra.getWordlist_mode();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
			thread_param_t thread_param = threads_param + backend_devices_idx;
			thread_param.setHashcat_ctx(hashcat_ctx);
			thread_param.setTid(backend_devices_idx);
			if (generatedWordlist_mode == wl_mode.WL_MODE_STDIN) {
				c_threads[backend_devices_idx] = /*Error: Function owner not recognized*/CreateThread((null), 0, (LPTHREAD_START_ROUTINE)ModernizedCProgram.thread_calc_stdin, thread_param, 0, (null));
			} else {
					c_threads[backend_devices_idx] = /*Error: Function owner not recognized*/CreateThread((null), 0, (LPTHREAD_START_ROUTINE)ModernizedCProgram.thread_calc, thread_param, 0, (null));
			} 
		}
		for (int i = 0;
		 i < generatedBackend_devices_cnt; i++) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject((c_threads)[i], -1024);
		}
		ModernizedCProgram.hcfree(c_threads);
		ModernizedCProgram.hcfree(threads_param);
		Object generatedDevices_status = status_ctx.getDevices_status();
		boolean generatedCheckpoint_shutdown = status_ctx.getCheckpoint_shutdown();
		if ((generatedDevices_status == status_rc.STATUS_RUNNING) && (generatedCheckpoint_shutdown == true)) {
			hashcat_ctx.myabort_checkpoint();
		} 
		if ((generatedDevices_status != status_rc.STATUS_CRACKED) && (generatedDevices_status != status_rc.STATUS_ERROR) && (generatedDevices_status != status_rc.STATUS_ABORTED) && (generatedDevices_status != status_rc.STATUS_ABORTED_CHECKPOINT) && (generatedDevices_status != status_rc.STATUS_ABORTED_RUNTIME) && (generatedDevices_status != status_rc.STATUS_QUIT) && (generatedDevices_status != status_rc.STATUS_BYPASS)) {
			status_ctx.setDevices_status(status_rc.STATUS_EXHAUSTED);
		} 
		boolean generatedSpeed_only = user_options.getSpeed_only();
		boolean generatedProgress_only = user_options.getProgress_only();
		if (generatedDevices_status == status_rc.STATUS_EXHAUSTED) {
			if ((generatedSpeed_only == true) || (generatedProgress_only == true)) {
				status_ctx.setDevices_status(status_rc.STATUS_BYPASS);
			} 
		} 
		// the options speed-only and progress-only cause hashcat to abort quickly.// therefore, they will end up (if no other error occured) as STATUS_EXHAUSTED.// however, that can create confusion in hashcats RC, because exhausted translates to RC = 1.// but then having RC = 1 does not match our expection if we use for speed-only and progress-only.
		// update some timertime_t runtime_stop = new time_t();
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/time(runtime_stop);
		status_ctx.setRuntime_stop(runtime_stop);
		hashcat_ctx.logfile_append("%s\t%s\t%s\t%u", generatedTopid, generatedSubid, ("runtime_start"), (u32)((runtime_start)));
		;
		;
		hashcat_ctx.logfile_append("%s\t%s\t%s\t%u", generatedTopid, generatedSubid, ("runtime_stop"), (u32)((runtime_stop)));
		;
		;
		hashcat_status generatedHashcat_status_final = status_ctx.getHashcat_status_final();
		if (ModernizedCProgram.hashcat_get_status(hashcat_ctx, generatedHashcat_status_final) == -1) {
			/*Error: Function owner not recognized*//*Error: Function owner not recognized*/fprintf((_iob[2]), "Initialization problem: the hashcat status monitoring function returned an unexpected value\n");
		} 
		status_ctx.setAccessible(0);
		hashcat_ctx.event_call((event_identifier.EVENT_CRACKER_FINISHED), (null), 0)// mark sub logfile;// mark sub logfile
		hashcat_ctx.logfile_append("%s\t%s\t%s\t%u", generatedTopid, generatedSubid, ("status-after-work"), (u32)(generatedDevices_status));
		;
		hashcat_ctx.logfile_append("%s\t%s\t%s", generatedTopid, generatedSubid, ("STOP"))// stop loopback recording;// stop loopback recording
		;
		if (generatedLoopback == true) {
			hashcat_ctx.loopback_write_close();
		} 
		int generatedInduction_dictionaries_cnt = induct_ctx.getInduction_dictionaries_cnt();
		int generatedInduction_dictionaries_pos = induct_ctx.getInduction_dictionaries_pos();
		boolean generatedRun_main_level3 = status_ctx.getRun_main_level3();
		byte[][] generatedInduction_dictionaries = induct_ctx.getInduction_dictionaries();
		// New induction folder check, which is a controlled recursionif (generatedInduction_dictionaries_cnt == 0) {
			hashcat_ctx.induct_ctx_scan();
			while (generatedInduction_dictionaries_cnt) {
				for (induct_ctx.setInduction_dictionaries_pos(0); generatedInduction_dictionaries_pos < generatedInduction_dictionaries_cnt; generatedInduction_dictionaries_pos++) {
					if (generatedDevices_status == status_rc.STATUS_EXHAUSTED) {
						if (hashcat_ctx.inner2_loop() == -1) {
							hashcat_ctx.myabort();
						} 
						if (generatedRun_main_level3 == false) {
							break;
						} 
					} 
					/*Error: Function owner not recognized*//*Error: Function owner not recognized*/unlink(generatedInduction_dictionaries[generatedInduction_dictionaries_pos]);
				}
				ModernizedCProgram.hcfree(generatedInduction_dictionaries);
				hashcat_ctx.induct_ctx_scan();
			}
		} 
		return 0;
	}
	// inner1_loop iterates through masks, then calls inner2_loop
	public int inner1_loop() {
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		//status_ctx->run_main_level1   = true;
		//status_ctx->run_main_level2   = true;//status_ctx->run_main_level2   = true;status_ctx.setRun_main_level3(1);
		status_ctx.setRun_thread_level1(1);
		status_ctx.setRun_thread_level2(1/**
		   * loop through wordlists
		   */);
		hashcat_ctx.event_call((event_identifier.EVENT_INNERLOOP2_STARTING), (null), 0);
		restore_data generatedRd = restore_ctx.getRd();
		Object generatedDicts_pos = rd.getDicts_pos();
		if (generatedRd) {
			restore_data_t rd = generatedRd;
			if (generatedDicts_pos > 0) {
				straight_ctx.setDicts_pos(generatedDicts_pos);
				rd.setDicts_pos(0);
			} 
		} 
		Object generatedDicts_cnt = straight_ctx.getDicts_cnt();
		boolean generatedRun_main_level3 = status_ctx.getRun_main_level3();
		if (generatedDicts_cnt) {
			for (u32 dicts_pos = generatedDicts_pos;
			 dicts_pos < generatedDicts_cnt; dicts_pos++) {
				straight_ctx.setDicts_pos(dicts_pos);
				if (hashcat_ctx.inner2_loop() == -1) {
					hashcat_ctx.myabort();
				} 
				if (generatedRun_main_level3 == false) {
					break;
				} 
			}
			if (generatedRun_main_level3 == true) {
				if (generatedDicts_pos + 1 == generatedDicts_cnt) {
					straight_ctx.setDicts_pos(0);
				} 
			} 
		} else {
				if (hashcat_ctx.inner2_loop() == -1) {
					hashcat_ctx.myabort();
				} 
		} 
		hashcat_ctx.event_call((event_identifier.EVENT_INNERLOOP2_FINISHED), (null), 0);
		return 0;// outer_loop iterates through hash_modes (in benchmark mode)
	}
	// also initializes stuff that depend on hash mode
	public int outer_loop() {
		hashconfig generatedHashconfig = this.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = this.getHashes();
		hashes_t hashes = generatedHashes;
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		outcheck_ctx generatedOutcheck_ctx = this.getOutcheck_ctx();
		outcheck_ctx_t outcheck_ctx = generatedOutcheck_ctx;
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		restore_ctx_t restore_ctx = generatedRestore_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		status_ctx.setDevices_status(status_rc.STATUS_INIT);
		//status_ctx->run_main_level1   = true;//status_ctx->run_main_level1   = true;status_ctx.setRun_main_level2(1);
		status_ctx.setRun_main_level3(1);
		status_ctx.setRun_thread_level1(1);
		status_ctx.setRun_thread_level2(1/**
		   * setup variables and buffers depending on hash_mode
		   */);
		int generatedHash_mode = user_options.getHash_mode();
		if (hashcat_ctx.hashconfig_init() == -1) {
			hashcat_ctx.event_log_error("Invalid hash-mode '%u' selected.", generatedHash_mode);
			return -1/**
			   * generate hashlist filename for later use
			   */;
		} 
		if (hashcat_ctx.hashes_init_filename() == -1) {
			return -1/**
			   * load hashes, stage 1
			   */;
		} 
		if (hashcat_ctx.hashes_init_stage1() == -1) {
			return -1;
		} 
		boolean generatedKeyspace = user_options.getKeyspace();
		boolean generatedStdout_flag = user_options.getStdout_flag();
		Object generatedHashes_cnt = hashes.getHashes_cnt();
		if ((generatedKeyspace == false) && (generatedStdout_flag == false)) {
			if (generatedHashes_cnt == 0) {
				hashcat_ctx.event_log_error("No hashes loaded.");
				return -1;
			} 
		} 
		hashes.setHashes_cnt_orig(generatedHashes_cnt);
		if (hashcat_ctx.hashes_init_stage2() == -1) {
			return -1/**
			   * potfile removes
			   */;
		} 
		boolean generatedPotfile_disable = user_options.getPotfile_disable();
		boolean generatedLoopback = user_options.getLoopback();
		if (generatedPotfile_disable == false) {
			hashcat_ctx.event_call((event_identifier.EVENT_POTFILE_REMOVE_PARSE_PRE), (null), 0);
			if (generatedLoopback == true) {
				hashcat_ctx.loopback_write_open();
			} 
			hashcat_ctx.potfile_remove_parse();
			if (generatedLoopback == true) {
				hashcat_ctx.loopback_write_close();
			} 
			hashcat_ctx.event_call((event_identifier.EVENT_POTFILE_REMOVE_PARSE_POST), (null), 0/**
			   * load hashes, stage 3, update cracked results from potfile
			   */);
		} 
		if (hashcat_ctx.hashes_init_stage3() == -1) {
			return -1/**
			   * potfile show/left handling
			   */;
		} 
		boolean generatedShow = user_options.getShow();
		if (generatedShow == true) {
			status_ctx.setDevices_status(status_rc.STATUS_RUNNING);
			hashcat_ctx.outfile_write_open();
			if (hashcat_ctx.potfile_handle_show() == -1) {
				return -1;
			} 
			hashcat_ctx.outfile_write_close();
			return 0;
		} 
		boolean generatedLeft = user_options.getLeft();
		if (generatedLeft == true) {
			status_ctx.setDevices_status(status_rc.STATUS_RUNNING);
			hashcat_ctx.outfile_write_open();
			if (hashcat_ctx.potfile_handle_left() == -1) {
				return -1;
			} 
			hashcat_ctx.outfile_write_close();
			return 0/**
			   * check global hash count in case module developer sets a them to a specific limit
			   */;
		} 
		Object generatedDigests_cnt = hashes.getDigests_cnt();
		Object generatedHashes_count_min = hashconfig.getHashes_count_min();
		if (generatedDigests_cnt < generatedHashes_count_min) {
			hashcat_ctx.event_log_error("Not enough hashes loaded - minimum is %u for this hash-mode.", generatedHashes_count_min);
			return -1;
		} 
		Object generatedHashes_count_max = hashconfig.getHashes_count_max();
		if (generatedDigests_cnt > generatedHashes_count_max) {
			hashcat_ctx.event_log_error("Too many hashes loaded - maximum is %u for this hash-mode.", generatedHashes_count_max);
			return -1/**
			   * maybe all hashes were cracked, we can exit here
			   */;
		} 
		Object generatedDevices_status = status_ctx.getDevices_status();
		boolean generatedRemove = user_options.getRemove();
		Object generatedHashlist_mode = hashes.getHashlist_mode();
		Object generatedDigests_saved = hashes.getDigests_saved();
		Object generatedDigests_done = hashes.getDigests_done();
		if (generatedDevices_status == status_rc.STATUS_CRACKED) {
			if ((generatedRemove == true) && ((generatedHashlist_mode == hl_mode.HL_MODE_FILE_PLAIN) || (generatedHashlist_mode == hl_mode.HL_MODE_FILE_BINARY))) {
				if (generatedDigests_saved != generatedDigests_done) {
					int rc = hashcat_ctx.save_hash();
					if (rc == -1) {
						return -1;
					} 
				} 
			} 
			hashcat_ctx.event_call((event_identifier.EVENT_POTFILE_ALL_CRACKED), (null), 0);
			return 0/**
			   * load hashes, stage 4, automatic Optimizers
			   */;
		} 
		if (hashcat_ctx.hashes_init_stage4() == -1) {
			return -1/**
			   * load hashes, selftest
			   */;
		} 
		if (hashcat_ctx.hashes_init_selftest() == -1) {
			return -1/**
			   * load hashes, benchmark
			   */;
		} 
		if (hashcat_ctx.hashes_init_benchmark() == -1) {
			return -1/**
			   * Done loading hashes, log results
			   */;
		} 
		hashcat_ctx/**
		   * bitmaps
		   */.hashes_logger();
		hashcat_ctx.event_call((event_identifier.EVENT_BITMAP_INIT_PRE), (null), 0);
		if (hashcat_ctx.bitmap_ctx_init() == -1) {
			return -1;
		} 
		hashcat_ctx.event_call((event_identifier.EVENT_BITMAP_INIT_POST), (null), 0/**
		   * cracks-per-time allocate buffer
		   */);
		hashcat_ctx/**
		   * Wordlist allocate buffer
		   */.cpt_ctx_init();
		if (hashcat_ctx.wl_data_init() == -1) {
			return -1/**
			   * straight mode init
			   */;
		} 
		if (hashcat_ctx.straight_ctx_init() == -1) {
			return -1/**
			   * straight mode init
			   */;
		} 
		if (hashcat_ctx.combinator_ctx_init() == -1) {
			return -1/**
			   * charsets : keep them together for more easy maintainnce
			   */;
		} 
		if (hashcat_ctx.mask_ctx_init() == -1) {
			return -1/**
			   * prevent the user from using --skip/--limit together with maskfile and/or multiple word lists
			   */;
		} 
		Object generatedSkip = user_options.getSkip();
		Object generatedLimit = user_options.getLimit();
		Object generatedMasks_cnt = mask_ctx.getMasks_cnt();
		Object generatedDicts_cnt = straight_ctx.getDicts_cnt();
		if (generatedSkip != 0 || generatedLimit != 0) {
			if ((generatedMasks_cnt > 1) || (generatedDicts_cnt > 1)) {
				hashcat_ctx.event_log_error("Use of --skip/--limit is not supported with --increment or mask files.");
				return -1;
			} 
		} 
		if (generatedKeyspace == /**
		   * prevent the user from using --keyspace together with maskfile and/or multiple word lists
		   */true) {
			if ((generatedMasks_cnt > 1) || (generatedDicts_cnt > 1)) {
				hashcat_ctx.event_log_error("Use of --keyspace is not supported with --increment or mask files.");
				return -1;
			} 
		} 
		if (hashcat_ctx.status_progress_init() == -1) {
			return -/**
			   * status progress init; needs hashes that's why we have to do it here and separate from status_ctx_init
			   */1/**
			   * main screen
			   */;
		} 
		hashcat_ctx.event_call((event_identifier.EVENT_OUTERLOOP_MAINSCREEN), (null), 0/**
		   * Tell user about cracked hashes by potfile
		   */);
		hashcat_ctx.event_call((event_identifier.EVENT_POTFILE_NUM_CRACKED), (null), 0/**
		   * inform the user
		   */);
		hashcat_ctx.event_call((event_identifier.EVENT_BACKEND_SESSION_PRE), (null), 0);
		if (hashcat_ctx.backend_session_begin() == -1) {
			return -1;
		} 
		hashcat_ctx.event_call((event_identifier.EVENT_BACKEND_SESSION_POST), (null), 0/**
		   * create self-test threads
		   */);
		boolean generatedSelf_test_disable = user_options.getSelf_test_disable();
		Object generatedSt_hash = hashconfig.getSt_hash();
		Object generatedSt_pass = hashconfig.getSt_pass();
		int generatedBackend_devices_cnt = backend_ctx.getBackend_devices_cnt();
		boolean generatedEnabled = backend_ctx.getEnabled();
		hc_device_param[] generatedDevices_param = backend_ctx.getDevices_param();
		boolean generatedSkipped = device_param.getSkipped();
		st_status_rc generatedSt_status = device_param.getSt_status();
		if ((generatedSelf_test_disable == false) && (generatedSt_hash != (null)) && (generatedSt_pass != (null))) {
			hashcat_ctx.event_call((event_identifier.EVENT_SELFTEST_STARTING), (null), 0);
			thread_param_t threads_param = (thread_param_t)ModernizedCProgram.hccalloc(generatedBackend_devices_cnt, /*Error: Unsupported expression*/);
			hc_thread_t selftest_threads = (hc_thread_t)ModernizedCProgram.hccalloc(generatedBackend_devices_cnt, /*Error: Unsupported expression*/);
			status_ctx.setDevices_status(status_rc.STATUS_SELFTEST);
			for (int backend_devices_idx = 0;
			 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
				thread_param_t thread_param = threads_param + backend_devices_idx;
				thread_param.setHashcat_ctx(hashcat_ctx);
				thread_param.setTid(backend_devices_idx);
				selftest_threads[backend_devices_idx] = /*Error: Function owner not recognized*/CreateThread((null), 0, (LPTHREAD_START_ROUTINE)ModernizedCProgram.thread_selftest, thread_param, 0, (null));
			}
			for (int i = 0;
			 i < generatedBackend_devices_cnt; i++) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject((selftest_threads)[i], -1024);
			}
			ModernizedCProgram.hcfree(threads_param);
			ModernizedCProgram.hcfree(selftest_threads);
			for (int backend_devices_idx = 0;
			 backend_devices_idx < generatedBackend_devices_cnt; backend_devices_idx++) {
				if (generatedEnabled == false) {
					continue;
				} 
				hc_device_param_t device_param = generatedDevices_param + backend_devices_idx;
				if (generatedSkipped == true) {
					continue;
				} 
				if (generatedSt_status == st_status_rc.ST_STATUS_FAILED) {
					hashcat_ctx.event_log_error("Aborting session due to kernel self-test failure.");
					hashcat_ctx.event_log_warning("You can use --self-test-disable to override this, but do not report related errors.");
					hashcat_ctx.event_log_warning((null));
					return -1;
				} 
			}
			status_ctx.setDevices_status(status_rc.STATUS_INIT);
			hashcat_ctx.event_call((event_identifier.EVENT_SELFTEST_FINISHED), (null), 0/**
			   * (old) weak hash check is the first to write to potfile, so open it for writing from here
			   * the weak hash check was removed maybe we can move this more to the bottom now
			   */);
		} 
		if (hashcat_ctx.potfile_write_open() == -1) {
			return -1/**
			   * status and monitor threads
			   */;
		} 
		int inner_threads_cnt = 0;
		hc_thread_t[] inner_threads = (hc_thread_t)ModernizedCProgram.hccalloc(10, /*Error: Unsupported expression*/);
		status_ctx.setShutdown_inner(0/**
		    * Outfile remove
		    */);
		boolean generatedSpeed_only = user_options.getSpeed_only();
		if (generatedKeyspace == false && generatedStdout_flag == false && generatedSpeed_only == false) {
			inner_threads[inner_threads_cnt] = /*Error: Function owner not recognized*/CreateThread((null), 0, (LPTHREAD_START_ROUTINE)ModernizedCProgram.thread_monitor, hashcat_ctx, 0, (null));
			inner_threads_cnt++;
			if (generatedEnabled == true) {
				inner_threads[inner_threads_cnt] = /*Error: Function owner not recognized*/CreateThread((null), 0, (LPTHREAD_START_ROUTINE)ModernizedCProgram.thread_outfile_remove, hashcat_ctx, 0, (null));
				inner_threads_cnt++;
			} 
		} 
		restore_data generatedRd = restore_ctx.getRd();
		Object generatedMasks_pos = rd.getMasks_pos();
		// main callif (generatedRd) {
			restore_data_t rd = generatedRd;
			if (generatedMasks_pos > 0) {
				mask_ctx.setMasks_pos(generatedMasks_pos);
				rd.setMasks_pos(0);
			} 
		} 
		hashcat_ctx.event_call((event_identifier.EVENT_INNERLOOP1_STARTING), (null), 0);
		boolean generatedRun_main_level2 = status_ctx.getRun_main_level2();
		if (generatedMasks_cnt) {
			for (u32 masks_pos = generatedMasks_pos;
			 masks_pos < generatedMasks_cnt; masks_pos++) {
				mask_ctx.setMasks_pos(masks_pos);
				if (hashcat_ctx.inner1_loop() == -1) {
					hashcat_ctx.myabort();
				} 
				if (generatedRun_main_level2 == false) {
					break;
				} 
			}
			if (generatedRun_main_level2 == true) {
				if (generatedMasks_pos + 1 == generatedMasks_cnt) {
					mask_ctx.setMasks_pos(0);
				} 
			} 
		} else {
				if (hashcat_ctx.inner1_loop() == -1) {
					hashcat_ctx.myabort();
				} 
		} 
		// wait for inner threads// wait for inner threadsstatus_ctx.setShutdown_inner(1);
		for (int thread_idx = 0;
		 thread_idx < inner_threads_cnt; thread_idx++) {
			for (int i = 0;
			 i < 1; i++) {
				/*Error: Function owner not recognized*//*Error: Function owner not recognized*/WaitForSingleObject((inner_threads[thread_idx])[i], -1024);
			}
		}
		ModernizedCProgram.hcfree(inner_threads);
		hashcat_ctx.event_call((event_identifier.EVENT_INNERLOOP1_FINISHED), (null), 0)// finalize potfile;// finalize potfile
		hashcat_ctx.potfile_write_close()// finalize backend session;// finalize backend session
		hashcat_ctx.backend_session_destroy()// clean up;// clean up
		hashcat_ctx.bitmap_ctx_destroy();
		hashcat_ctx.combinator_ctx_destroy();
		hashcat_ctx.cpt_ctx_destroy();
		hashcat_ctx.hashconfig_destroy();
		hashcat_ctx.hashes_destroy();
		hashcat_ctx.mask_ctx_destroy();
		hashcat_ctx.status_progress_destroy();
		hashcat_ctx.straight_ctx_destroy();
		hashcat_ctx.wl_data_destroy();
		return 0;
	}
	public void event_stub(Object id, Object buf, Object len) {
	}
	public int hashcat_init(Object event) {
		if (event == (null)) {
			this.setEvent(event_stub);
		} else {
				this.setEvent(event);
		} 
		this.setBitmap_ctx((bitmap_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setCombinator_ctx((combinator_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setCpt_ctx((cpt_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setDebugfile_ctx((debugfile_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setDictstat_ctx((dictstat_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setEvent_ctx((event_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setFolder_config((folder_config_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setHashcat_user((hashcat_user_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setHashconfig((hashconfig_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setHashes((hashes_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setHwmon_ctx((hwmon_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setInduct_ctx((induct_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setLogfile_ctx((logfile_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setLoopback_ctx((loopback_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setMask_ctx((mask_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setModule_ctx((module_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setBackend_ctx((backend_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setOutcheck_ctx((outcheck_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setOutfile_ctx((outfile_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setPidfile_ctx((pidfile_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setPotfile_ctx((potfile_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setRestore_ctx((restore_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setStatus_ctx((status_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setStraight_ctx((straight_ctx_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setTuning_db((tuning_db_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setUser_options_extra((user_options_extra_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setUser_options((user_options_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		this.setWl_data((wl_data_t)ModernizedCProgram.hcmalloc(/*Error: Unsupported expression*/));
		return 0;
	}
	public void hashcat_destroy() {
		bitmap_ctx generatedBitmap_ctx = this.getBitmap_ctx();
		ModernizedCProgram.hcfree(generatedBitmap_ctx);
		combinator_ctx generatedCombinator_ctx = this.getCombinator_ctx();
		ModernizedCProgram.hcfree(generatedCombinator_ctx);
		cpt_ctx generatedCpt_ctx = this.getCpt_ctx();
		ModernizedCProgram.hcfree(generatedCpt_ctx);
		debugfile_ctx generatedDebugfile_ctx = this.getDebugfile_ctx();
		ModernizedCProgram.hcfree(generatedDebugfile_ctx);
		dictstat_ctx generatedDictstat_ctx = this.getDictstat_ctx();
		ModernizedCProgram.hcfree(generatedDictstat_ctx);
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		ModernizedCProgram.hcfree(generatedEvent_ctx);
		folder_config generatedFolder_config = this.getFolder_config();
		ModernizedCProgram.hcfree(generatedFolder_config);
		hashcat_user generatedHashcat_user = this.getHashcat_user();
		ModernizedCProgram.hcfree(generatedHashcat_user);
		hashconfig generatedHashconfig = this.getHashconfig();
		ModernizedCProgram.hcfree(generatedHashconfig);
		hashes generatedHashes = this.getHashes();
		ModernizedCProgram.hcfree(generatedHashes);
		hwmon_ctx generatedHwmon_ctx = this.getHwmon_ctx();
		ModernizedCProgram.hcfree(generatedHwmon_ctx);
		induct_ctx generatedInduct_ctx = this.getInduct_ctx();
		ModernizedCProgram.hcfree(generatedInduct_ctx);
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		ModernizedCProgram.hcfree(generatedLogfile_ctx);
		loopback_ctx generatedLoopback_ctx = this.getLoopback_ctx();
		ModernizedCProgram.hcfree(generatedLoopback_ctx);
		mask_ctx generatedMask_ctx = this.getMask_ctx();
		ModernizedCProgram.hcfree(generatedMask_ctx);
		module_ctx generatedModule_ctx = this.getModule_ctx();
		ModernizedCProgram.hcfree(generatedModule_ctx);
		backend_ctx generatedBackend_ctx = this.getBackend_ctx();
		ModernizedCProgram.hcfree(generatedBackend_ctx);
		outcheck_ctx generatedOutcheck_ctx = this.getOutcheck_ctx();
		ModernizedCProgram.hcfree(generatedOutcheck_ctx);
		outfile_ctx generatedOutfile_ctx = this.getOutfile_ctx();
		ModernizedCProgram.hcfree(generatedOutfile_ctx);
		pidfile_ctx generatedPidfile_ctx = this.getPidfile_ctx();
		ModernizedCProgram.hcfree(generatedPidfile_ctx);
		potfile_ctx generatedPotfile_ctx = this.getPotfile_ctx();
		ModernizedCProgram.hcfree(generatedPotfile_ctx);
		restore_ctx generatedRestore_ctx = this.getRestore_ctx();
		ModernizedCProgram.hcfree(generatedRestore_ctx);
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		ModernizedCProgram.hcfree(generatedStatus_ctx);
		straight_ctx generatedStraight_ctx = this.getStraight_ctx();
		ModernizedCProgram.hcfree(generatedStraight_ctx);
		tuning_db generatedTuning_db = this.getTuning_db();
		ModernizedCProgram.hcfree(generatedTuning_db);
		user_options_extra generatedUser_options_extra = this.getUser_options_extra();
		ModernizedCProgram.hcfree(generatedUser_options_extra);
		user_options generatedUser_options = this.getUser_options();
		ModernizedCProgram.hcfree(generatedUser_options);
		wl_data generatedWl_data = this.getWl_data();
		ModernizedCProgram.hcfree(generatedWl_data);
		/*Error: Function owner not recognized*//*Error: Function owner not recognized*/memset(hashcat_ctx, 0, /*Error: Unsupported expression*/);
	}
	public int hashcat_session_init(Object install_folder, Object shared_folder, int argc, Byte argv, Object comptime) {
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		hashcat_ctx/**
		   * event init (needed for logging so should be first)
		   */.user_options_session_auto();
		if (hashcat_ctx.event_ctx_init() == -1) {
			return -1/**
			   * status init
			   */;
		} 
		if (hashcat_ctx.status_ctx_init() == -1) {
			return -1/**
			   * folder
			   */;
		} 
		if (hashcat_ctx.folder_config_init(install_folder, shared_folder) == -1) {
			return -1/**
			   * pidfile
			   */;
		} 
		if (hashcat_ctx.pidfile_ctx_init() == -1) {
			return -1/**
			   * restore
			   */;
		} 
		if (hashcat_ctx.restore_ctx_init(argc, argv) == -1) {
			return -1/**
			   * process user input
			   */;
		} 
		hashcat_ctx.user_options_preprocess();
		hashcat_ctx.user_options_extra_init();
		hashcat_ctx/**
		   * windows and sockets...
		   */.user_options_postprocess();
		if (hashcat_ctx.logfile_init() == -1) {
			return -/**
			   * logfile
			   */1/**
			   * cpu affinity
			   */;
		} 
		if (hashcat_ctx.set_cpu_affinity() == -1) {
			return -1/**
			   * prepare seeding for random number generator, required by logfile and rules generator
			   */;
		} 
		boolean generatedRp_gen_seed_chgd = user_options.getRp_gen_seed_chgd();
		Object generatedRp_gen_seed = user_options.getRp_gen_seed();
		ModernizedCProgram.setup_seeding(generatedRp_gen_seed_chgd, generatedRp_gen_seed);
		folder_config generatedFolder_config = this.getFolder_config();
		ModernizedCProgram.setup_environment_variables(generatedFolder_config);
		ModernizedCProgram.setup_umask();
		if (hashcat_ctx.tuning_db_init() == -1) {
			return -1/**
			   * induction directory
			   */;
		} 
		if (hashcat_ctx.induct_ctx_init() == -1) {
			return -1/**
			   * outfile-check directory
			   */;
		} 
		if (hashcat_ctx.outcheck_ctx_init() == -1) {
			return -1/**
			   * outfile itself
			   */;
		} 
		if (hashcat_ctx.outfile_init() == -1) {
			return -1/**
			   * potfile init
			   * this is only setting path because potfile can be used in read and write mode depending on user options
			   * plus it depends on hash_mode, so we continue using it in outer_loop
			   */;
		} 
		if (hashcat_ctx.potfile_init() == -1) {
			return -1/**
			   * dictstat init
			   */;
		} 
		if (hashcat_ctx.dictstat_init() == -1) {
			return -1/**
			   * loopback init
			   */;
		} 
		if (hashcat_ctx.loopback_init() == -1) {
			return -1/**
			   * debugfile init
			   */;
		} 
		if (hashcat_ctx.debugfile_init() == -1) {
			return -1/**
			   * Try to detect if all the files we're going to use are accessible in the mode we want them
			   */;
		} 
		if (hashcat_ctx.user_options_check_files() == -1) {
			return -1/**
			   * Init backend library loader
			   */;
		} 
		if (hashcat_ctx.backend_ctx_init() == -1) {
			return -1/**
			   * Init backend devices
			   */;
		} 
		if (hashcat_ctx.backend_ctx_devices_init(comptime) == -1) {
			return -1/**
			   * HM devices: init
			   */;
		} 
		if (hashcat_ctx.hwmon_ctx_init() == -1) {
			return -1;
		} 
		// done
		return 0;
	}
	public int hashcat_session_execute() {
		logfile_ctx generatedLogfile_ctx = this.getLogfile_ctx();
		logfile_ctx_t logfile_ctx = generatedLogfile_ctx;
		status_ctx generatedStatus_ctx = this.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options generatedUser_options = this.getUser_options();
		user_options_t user_options = generatedUser_options;
		// start logfile entry
		time_t proc_start = /*Error: Function owner not recognized*/time((null));
		hashcat_ctx.logfile_generate_topid();
		Byte generatedTopid = logfile_ctx.getTopid();
		hashcat_ctx.logfile_append("%s\t%s", generatedTopid, ("START"))// add all user options to logfile in case we want to debug some user session;// add all user options to logfile in case we want to debug some user session
		;
		hashcat_ctx.user_options_logger()// read dictionary cache;// read dictionary cache
		hashcat_ctx/**
		   * outer loop
		   */.dictstat_read();
		hashcat_ctx.event_call((event_identifier.EVENT_OUTERLOOP_STARTING), (null), 0);
		int rc_final = -1;
		boolean generatedBenchmark = user_options.getBenchmark();
		boolean generatedHash_mode_chgd = user_options.getHash_mode_chgd();
		boolean generatedRun_main_level1 = status_ctx.getRun_main_level1();
		boolean generatedSpeed_only = user_options.getSpeed_only();
		if (generatedBenchmark == true) {
			user_options.setQuiet(1);
			if (generatedHash_mode_chgd == true) {
				rc_final = hashcat_ctx.outer_loop();
				if (rc_final == -1) {
					hashcat_ctx.myabort();
				} 
			} else {
					int hash_mode = 0;
					while ((hash_mode = hashcat_ctx.benchmark_next()) != -1) {
						user_options.setHash_mode(hash_mode);
						rc_final = hashcat_ctx.outer_loop();
						if (rc_final == -1) {
							hashcat_ctx.myabort();
						} 
						if (generatedRun_main_level1 == false) {
							break;
						} 
					}
			} 
			user_options.setQuiet(0);
		} else {
				if (generatedSpeed_only == true) {
					user_options.setQuiet(1);
				} 
				rc_final = hashcat_ctx.outer_loop();
				if (rc_final == -1) {
					hashcat_ctx.myabort();
				} 
				if (generatedSpeed_only == true) {
					user_options.setQuiet(0);
				} 
		} 
		hashcat_ctx.event_call((event_identifier.EVENT_OUTERLOOP_FINISHED), (null), 0)// if exhausted or cracked, unlink the restore file;// if exhausted or cracked, unlink the restore file
		hashcat_ctx.unlink_restore()// final update dictionary cache;// final update dictionary cache
		hashcat_ctx.dictstat_write()// final logfile entry;// final logfile entry
		time_t proc_stop = /*Error: Function owner not recognized*/time((null));
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("proc_start"), (u32)((proc_start)));
		;
		;
		hashcat_ctx.logfile_append("%s\t%s\t%u", generatedTopid, ("proc_stop"), (u32)((proc_stop)));
		;
		;
		hashcat_ctx.logfile_append("%s\t%s", generatedTopid, ("STOP"))// free memory;// free memory
		;
		Object generatedDevices_status = status_ctx.getDevices_status();
		if (rc_final == 0) {
			if (generatedDevices_status == status_rc.STATUS_ABORTED_RUNTIME) {
				rc_final = 4;
			} 
			if (generatedDevices_status == status_rc.STATUS_ABORTED_CHECKPOINT) {
				rc_final = 3;
			} 
			if (generatedDevices_status == status_rc.STATUS_ABORTED) {
				rc_final = 2;
			} 
			if (generatedDevices_status == status_rc.STATUS_QUIT) {
				rc_final = 2;
			} 
			if (generatedDevices_status == status_rc.STATUS_EXHAUSTED) {
				rc_final = 1;
			} 
			if (generatedDevices_status == status_rc.STATUS_CRACKED) {
				rc_final = 0;
			} 
			if (generatedDevices_status == status_rc.STATUS_ERROR) {
				rc_final = -1;
			} 
		} 
		// donereturn rc_final;
	}
	public int hashcat_session_pause() {
		return hashcat_ctx.SuspendThreads();
	}
	public int hashcat_session_resume() {
		return hashcat_ctx.ResumeThreads();
	}
	public int hashcat_session_bypass() {
		return hashcat_ctx.bypass();
	}
	public int hashcat_session_checkpoint() {
		return hashcat_ctx.stop_at_checkpoint();
	}
	public int hashcat_session_quit() {
		return hashcat_ctx.myabort();
	}
	public int hashcat_session_destroy() {
		hashcat_ctx.debugfile_destroy();
		hashcat_ctx.dictstat_destroy();
		hashcat_ctx.folder_config_destroy();
		hashcat_ctx.hwmon_ctx_destroy();
		hashcat_ctx.induct_ctx_destroy();
		hashcat_ctx.logfile_destroy();
		hashcat_ctx.loopback_destroy();
		hashcat_ctx.backend_ctx_devices_destroy();
		hashcat_ctx.backend_ctx_destroy();
		hashcat_ctx.outcheck_ctx_destroy();
		hashcat_ctx.outfile_destroy();
		hashcat_ctx.pidfile_ctx_destroy();
		hashcat_ctx.potfile_destroy();
		hashcat_ctx.restore_ctx_destroy();
		hashcat_ctx.tuning_db_destroy();
		hashcat_ctx.user_options_destroy();
		hashcat_ctx.user_options_extra_destroy();
		hashcat_ctx.status_ctx_destroy();
		hashcat_ctx.event_ctx_destroy();
		return 0;
	}
	public Byte hashcat_get_log() {
		event_ctx generatedEvent_ctx = this.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		Object[] generatedMsg_buf = event_ctx.getMsg_buf();
		return generatedMsg_buf;
	}
	public bitmap_ctx getBitmap_ctx() {
		return bitmap_ctx;
	}
	public void setBitmap_ctx(bitmap_ctx newBitmap_ctx) {
		bitmap_ctx = newBitmap_ctx;
	}
	public combinator_ctx getCombinator_ctx() {
		return combinator_ctx;
	}
	public void setCombinator_ctx(combinator_ctx newCombinator_ctx) {
		combinator_ctx = newCombinator_ctx;
	}
	public cpt_ctx getCpt_ctx() {
		return cpt_ctx;
	}
	public void setCpt_ctx(cpt_ctx newCpt_ctx) {
		cpt_ctx = newCpt_ctx;
	}
	public debugfile_ctx getDebugfile_ctx() {
		return debugfile_ctx;
	}
	public void setDebugfile_ctx(debugfile_ctx newDebugfile_ctx) {
		debugfile_ctx = newDebugfile_ctx;
	}
	public dictstat_ctx getDictstat_ctx() {
		return dictstat_ctx;
	}
	public void setDictstat_ctx(dictstat_ctx newDictstat_ctx) {
		dictstat_ctx = newDictstat_ctx;
	}
	public event_ctx getEvent_ctx() {
		return event_ctx;
	}
	public void setEvent_ctx(event_ctx newEvent_ctx) {
		event_ctx = newEvent_ctx;
	}
	public folder_config getFolder_config() {
		return folder_config;
	}
	public void setFolder_config(folder_config newFolder_config) {
		folder_config = newFolder_config;
	}
	public hashcat_user getHashcat_user() {
		return hashcat_user;
	}
	public void setHashcat_user(hashcat_user newHashcat_user) {
		hashcat_user = newHashcat_user;
	}
	public hashconfig getHashconfig() {
		return hashconfig;
	}
	public void setHashconfig(hashconfig newHashconfig) {
		hashconfig = newHashconfig;
	}
	public hashes getHashes() {
		return hashes;
	}
	public void setHashes(hashes newHashes) {
		hashes = newHashes;
	}
	public hwmon_ctx getHwmon_ctx() {
		return hwmon_ctx;
	}
	public void setHwmon_ctx(hwmon_ctx newHwmon_ctx) {
		hwmon_ctx = newHwmon_ctx;
	}
	public induct_ctx getInduct_ctx() {
		return induct_ctx;
	}
	public void setInduct_ctx(induct_ctx newInduct_ctx) {
		induct_ctx = newInduct_ctx;
	}
	public logfile_ctx getLogfile_ctx() {
		return logfile_ctx;
	}
	public void setLogfile_ctx(logfile_ctx newLogfile_ctx) {
		logfile_ctx = newLogfile_ctx;
	}
	public loopback_ctx getLoopback_ctx() {
		return loopback_ctx;
	}
	public void setLoopback_ctx(loopback_ctx newLoopback_ctx) {
		loopback_ctx = newLoopback_ctx;
	}
	public mask_ctx getMask_ctx() {
		return mask_ctx;
	}
	public void setMask_ctx(mask_ctx newMask_ctx) {
		mask_ctx = newMask_ctx;
	}
	public module_ctx getModule_ctx() {
		return module_ctx;
	}
	public void setModule_ctx(module_ctx newModule_ctx) {
		module_ctx = newModule_ctx;
	}
	public backend_ctx getBackend_ctx() {
		return backend_ctx;
	}
	public void setBackend_ctx(backend_ctx newBackend_ctx) {
		backend_ctx = newBackend_ctx;
	}
	public outcheck_ctx getOutcheck_ctx() {
		return outcheck_ctx;
	}
	public void setOutcheck_ctx(outcheck_ctx newOutcheck_ctx) {
		outcheck_ctx = newOutcheck_ctx;
	}
	public outfile_ctx getOutfile_ctx() {
		return outfile_ctx;
	}
	public void setOutfile_ctx(outfile_ctx newOutfile_ctx) {
		outfile_ctx = newOutfile_ctx;
	}
	public pidfile_ctx getPidfile_ctx() {
		return pidfile_ctx;
	}
	public void setPidfile_ctx(pidfile_ctx newPidfile_ctx) {
		pidfile_ctx = newPidfile_ctx;
	}
	public potfile_ctx getPotfile_ctx() {
		return potfile_ctx;
	}
	public void setPotfile_ctx(potfile_ctx newPotfile_ctx) {
		potfile_ctx = newPotfile_ctx;
	}
	public restore_ctx getRestore_ctx() {
		return restore_ctx;
	}
	public void setRestore_ctx(restore_ctx newRestore_ctx) {
		restore_ctx = newRestore_ctx;
	}
	public status_ctx getStatus_ctx() {
		return status_ctx;
	}
	public void setStatus_ctx(status_ctx newStatus_ctx) {
		status_ctx = newStatus_ctx;
	}
	public straight_ctx getStraight_ctx() {
		return straight_ctx;
	}
	public void setStraight_ctx(straight_ctx newStraight_ctx) {
		straight_ctx = newStraight_ctx;
	}
	public tuning_db getTuning_db() {
		return tuning_db;
	}
	public void setTuning_db(tuning_db newTuning_db) {
		tuning_db = newTuning_db;
	}
	public user_options_extra getUser_options_extra() {
		return user_options_extra;
	}
	public void setUser_options_extra(user_options_extra newUser_options_extra) {
		user_options_extra = newUser_options_extra;
	}
	public user_options getUser_options() {
		return user_options;
	}
	public void setUser_options(user_options newUser_options) {
		user_options = newUser_options;
	}
	public wl_data getWl_data() {
		return wl_data;
	}
	public void setWl_data(wl_data newWl_data) {
		wl_data = newWl_data;
	}
	public Object getEvent() {
		return event;
	}
	public void setEvent(Object newEvent) {
		event = newEvent;
	}
}
