package application;

public class ModernizedCProgram {
	public static u32 ATTACK_EXEC = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */attack_exec.ATTACK_EXEC_INSIDE_KERNEL;
	public static u32 DGST_POS0 = 3;
	public static u32 DGST_POS1 = 4;
	public static u32 DGST_POS2 = 2;
	public static u32 DGST_POS3 = 1;
	public static u32 DGST_SIZE = dgst_size.DGST_SIZE_4_5;
	public static u32 HASH_CATEGORY = hash_category.HASH_CATEGORY_EAS;
	public static byte HASH_NAME = "SAP CODVN F/G (PASSCODE) from RFC_READ_TABLE";
	public static u64 KERN_TYPE = 7801;
	public static u32 OPTI_TYPE = opti_type.OPTI_TYPE_ZERO_BYTE | opti_type.OPTI_TYPE_PRECOMPUTE_INIT | opti_type.OPTI_TYPE_NOT_ITERATED;
	public static u64 OPTS_TYPE = opts_type.OPTS_TYPE_PT_GENERATE_BE | opts_type.OPTS_TYPE_ST_ADD80 | opts_type.OPTS_TYPE_ST_UPPER;
	public static u32 SALT_TYPE = salt_type.SALT_TYPE_EMBEDDED;
	public static byte ST_PASS = "hashcat";
	public static byte ST_HASH = "604020408266$32837BA7B97672BA4E5A00000000000000000000";
	public static byte SIGNATURE_AXCRYPT = "$axcrypt$";
	public static byte SIGNATURE_BSDICRYPT = "_";
	public static int ROUNDS_VERACRYPT_500000 = 500000;
	public static double MIN_SUFFICIENT_ENTROPY_FILE = 7.0;
	public static byte SIGNATURE_EPISERVER = "$episerver$";
	public static int ROUNDS_QNX = 1000;
	public static Byte[] XZ_SIG = new Byte[]{-1024, (byte)'7', (byte)'z', (byte)'X', (byte)'Z', /* Xz.c - Xz
	2017-05-12 : Igor Pavlov : Public domain */0/* const Byte XZ_FOOTER_SIG[XZ_FOOTER_SIG_SIZE] = { 'Y', 'Z' }; */};
	public static byte SIGNATURE_AUTHME = "$SHA$";
	public static byte SIGNATURE_SHA512AIX = "{ssha512}";
	public static int[] extra_lbits = new int[]{0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
	public static int[] extra_dbits = new int[]{0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
	public static int[] extra_blbits = new int[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7};
	public static uch[] bl_order = new uch[]{16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15/* The lengths of the bit length codes are sent in order of decreasing
	 * probability, to avoid transmitting the lengths for unused bit length codes.
	 *//* ===========================================================================
	 * Local data. These are initialized only once.
	 *//* see definition of array dist_code below *//* non ANSI compilers may not accept trees.h *//* The static literal tree. Since the bit lengths are imposed, there is no
	 * need for the L_CODES extra codes used during heap construction. However
	 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
	 * below).
	 *//* The static distance tree. (Actually a trivial tree since all codes use
	 * 5 bits.)
	 */};
	public static static_tree_desc static_l_desc = new static_tree_desc(static_ltree, extra_lbits, 256 + 1, (256 + 1 + 29), 15);
	public static static_tree_desc static_d_desc = new static_tree_desc(static_dtree, extra_dbits, 0, 30, 15);
	public static static_tree_desc static_bl_desc = new static_tree_desc((ct_data)0, extra_blbits, 0, 19, 7/* ===========================================================================
	 * Local (static) routines in this file.
	 */);
	public static Object tr_static_init;
	public static Object init_block;
	public static Object pqdownheap;
	public static Object gen_bitlen;
	public static Object gen_codes;
	public static Object build_tree;
	public static Object scan_tree;
	public static Object send_tree;
	public static int build_bl_tree;
	public static Object send_all_trees;
	public static Object compress_block;
	public static int detect_data_type;
	public static int bi_reverse;
	public static Object bi_windup;
	public static Object bi_flush;
	public static Object AF_sha1_diffuse16;
	public static Object AF_sha1_diffuse32;
	public static Object AF_sha1_diffuse64;
	public static Object AF_sha256_diffuse16;
	public static Object AF_sha256_diffuse32;
	public static Object AF_sha256_diffuse64;
	public static Object AF_sha512_diffuse16;
	public static Object AF_sha512_diffuse32;
	public static Object AF_sha512_diffuse64;
	public static Object AF_ripemd160_diffuse16;
	public static Object AF_ripemd160_diffuse32;
	public static Object AF_ripemd160_diffuse64;
	public static  initialize_keyboard_layout_mapping = new ();
	public static int find_keyboard_layout_map;
	public static int execute_keyboard_layout_mapping;
	public static u32[] crc32tab = new u32[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static int cl_int;
	public static int cl_mem;
	public static int cl_command_queue;
	public static int cl_context;
	public static int cl_kernel;
	public static int cl_program;
	public static int cl_event;
	public static hc_opencl_lib_t OCL_PTR = new hc_opencl_lib_t();
	public static byte val2cstr_cl;
	public static byte SIGNATURE_SAPH_SHA1 = "{x-issha, ";
	public static byte kCantReadMessage = /* LzmaUtil.c -- Test application for LZMA compression
	2018-07-04 : Igor Pavlov : Public domain */"Can not read input file";
	public static byte kCantWriteMessage = "Can not write output file";
	public static byte kCantAllocateMessage = "Can not allocate memory";
	public static byte kDataErrorMessage = "Data error";
	public static byte[] kExts = new byte[]{/* SfxSetup.c - 7z SFX Setup
	2019-02-02 : Igor Pavlov : Public domain */"bat", "cmd", "exe", "inf", "msi", "html", "htm"};
	public static byte[] kNames = new byte[]{"setup", "install", "run", "start"};
	public static int gz_init;
	public static int gz_comp;
	public static int gz_zero;
	public static z_size_t gz_write = new z_size_t();
	public static  is_hexify = new ();
	public static  exec_unhexify = new ();
	public static  need_hexify = new ();
	public static Object exec_hexify;
	public static  is_valid_base64a_string = new ();
	public static  is_valid_base64a_char = new ();
	public static  is_valid_base64b_string = new ();
	public static  is_valid_base64b_char = new ();
	public static  is_valid_base64c_string = new ();
	public static  is_valid_base64c_char = new ();
	public static  is_valid_hex_string = new ();
	public static  is_valid_hex_char = new ();
	public static  is_valid_digit_string = new ();
	public static  is_valid_digit_char = new ();
	public static  is_valid_float_string = new ();
	public static  is_valid_float_char = new ();
	public static  hex_convert = new ();
	public static  hex_to_u8 = new ();
	public static  hex_to_u32 = new ();
	public static  hex_to_u64 = new ();
	public static Object u8_to_hex;
	public static Object u32_to_hex;
	public static Object u64_to_hex;
	public static  int_to_base32 = new ();
	public static  base32_to_int = new ();
	public static  int_to_base64 = new ();
	public static  base64_to_int = new ();
	public static  int_to_ab64 = new ();
	public static  ab64_to_int = new ();
	public static  int_to_base64url = new ();
	public static  base64url_to_int = new ();
	public static  int_to_itoa32 = new ();
	public static  itoa32_to_int = new ();
	public static  int_to_itoa64 = new ();
	public static  itoa64_to_int = new ();
	public static  int_to_bf64 = new ();
	public static  bf64_to_int = new ();
	public static  int_to_lotus64 = new ();
	public static  lotus64_to_int = new ();
	public static  base32_decode = new ();
	public static  base32_encode = new ();
	public static  base64_decode = new ();
	public static  base64_encode = new ();
	public static Object lowercase;
	public static Object uppercase;
	public static  v8a_from_v32 = new ();
	public static  v8b_from_v32 = new ();
	public static  v8c_from_v32 = new ();
	public static  v8d_from_v32 = new ();
	public static  v16a_from_v32 = new ();
	public static  v16b_from_v32 = new ();
	public static  v32_from_v16ab = new ();
	public static  v32a_from_v64 = new ();
	public static  v32b_from_v64 = new ();
	public static  v64_from_v32ab = new ();
	public static int hex_decode;
	public static int hex_encode;
	public static byte SIGNATURE_PDF = "$pdf$";
	public static u32 ROUNDS_WPA_PMK = 1/*
	typedef struct wpa_eapol
	{
	  u32  pke[32];
	  u32  eapol[64 + 16];
	  u16  eapol_len;
	  u8   message_pair;
	  int  message_pair_chgd;
	  u8   keyver;
	  u8   orig_mac_ap[6];
	  u8   orig_mac_sta[6];
	  u8   orig_nonce_ap[32];
	  u8   orig_nonce_sta[32];
	  u8   essid_len;
	  u8   essid[32];
	  u32  keymic[4];
	  int  nonce_compare;
	  int  nonce_error_corrections;
	  int  detected_le;
	  int  detected_be;
	
	} wpa_eapol_t;
	
	typedef struct wpa_pmk_tmp
	{
	  u32 out[8];
	
	} wpa_pmk_tmp_t;
	*/;
	public static hccapx hccapx_t = new hccapx();
	public static byte[] SYS_BUS_PCI_DEVICES = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */"/sys/bus/pci/devices";
	public static int HM_ADAPTER_SYSFS;
	public static Object SYSFS_LIB;
	public static hm_sysfs_lib_t SYSFS_PTR = new hm_sysfs_lib_t();
	public static int _dowildcard = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */-1;
	public static byte SIGNATURE_OLDOFFICE = "$oldoffice$";
	public static byte SIGNATURE_OLDOFFICE3 = "$oldoffice$3";
	public static byte SIGNATURE_OLDOFFICE4 = "$oldoffice$4";
	public static byte SIGNATURE_MYWALLETV2 = "$blockchain$v2$";
	public static int cycle_restore;
	public static Object unlink_restore;
	public static int restore_ctx_init;
	public static Object restore_ctx_destroy;
	public static byte SIGNATURE_POSTGRESQL_AUTH = "$postgres$";
	public static  clSetMemObjectDestructorAPPLE = new ();
	public static int CL_EXT_SUFFIX__VERSION_1_0;
	public static  cl_queue_properties_khr = new ();
	public static  cl_device_partition_property_ext = new ();
	public static  cl_mem_migration_flags_ext = new ();
	public static  cl_image_pitch_info_qcom = new ();
	public static  cl_kernel_sub_group_info = new ();
	public static  cl_queue_priority_khr = new ();
	public static  cl_queue_throttle_khr = new ();
	public static  cl_import_properties_arm = new ();
	public static  cl_svm_mem_flags_arm = new ();
	public static  cl_kernel_exec_info_arm = new ();
	public static  cl_device_svm_capabilities_arm = new ();
	public static  u8 = new ();
	public static  u16 = new ();
	public static  u32 = new ();
	public static  u64 = new ();
	public static u8 u8a = new u8();
	public static u16 u16a = new u16();
	public static u32 u32a = new u32();
	public static u64 u64a = new u64();
	public static u8 u8x = new u8();
	public static u16 u16x = new u16();
	public static u32 u32x = new u32();
	public static u64 u64x = new u64();
	public static u32 ROUNDS_WPA_PBKDF2 = 4096/*
	typedef struct wpa_eapol
	{
	  u32  pke[32];
	  u32  eapol[64 + 16];
	  u16  eapol_len;
	  u8   message_pair;
	  int  message_pair_chgd;
	  u8   keyver;
	  u8   orig_mac_ap[6];
	  u8   orig_mac_sta[6];
	  u8   orig_nonce_ap[32];
	  u8   orig_nonce_sta[32];
	  u8   essid_len;
	  u8   essid[32];
	  u32  keymic[4];
	  int  nonce_compare;
	  int  nonce_error_corrections;
	  int  detected_le;
	  int  detected_be;
	
	} wpa_eapol_t;
	
	typedef struct wpa_pbkdf2_tmp
	{
	  u32 ipad[5];
	  u32 opad[5];
	
	  u32 dgst[10];
	  u32 out[10];
	
	} wpa_pbkdf2_tmp_t;
	*/;
	public static int ROUNDS_RAR3 = 262144;
	public static byte SIGNATURE_RAR3 = "$RAR3$";
	public static int blast_in;
	public static int blast_out;
	public static int blast;
	public static int8_t cl_char = new int8_t();
	public static uint8_t cl_uchar = new uint8_t();
	public static int16_t cl_short = new int16_t();
	public static uint16_t cl_ushort = new uint16_t();
	public static uint32_t cl_uint = new uint32_t();
	public static int64_t cl_long = new int64_t();
	public static uint64_t cl_ulong = new uint64_t();
	public static uint16_t cl_half = new uint16_t();
	public static double cl_float;
	public static double cl_double;
	public static int cl_GLuint;
	public static int cl_GLint;
	public static int cl_GLenum;
	public static cl_char4 cl_char3 = new cl_char4();
	public static cl_uchar4 cl_uchar3 = new cl_uchar4();
	public static cl_short4 cl_short3 = new cl_short4();
	public static cl_ushort4 cl_ushort3 = new cl_ushort4();
	public static cl_half4 cl_half3 = new cl_half4();
	public static cl_int4 cl_int3 = new cl_int4();
	public static cl_uint4 cl_uint3 = new cl_uint4();
	public static cl_long4 cl_long3 = new cl_long4();
	public static cl_ulong4 cl_ulong3 = new cl_ulong4();
	public static cl_float4 cl_float3 = new cl_float4();
	public static cl_double4 cl_double3 = new cl_double4();
	public static _nvrtcProgram nvrtcProgram = new _nvrtcProgram();
	public static nvrtcResult NVRTC_NVRTCADDNAMEEXPRESSION = new nvrtcResult();
	public static nvrtcResult NVRTC_NVRTCCOMPILEPROGRAM = new nvrtcResult();
	public static nvrtcResult NVRTC_NVRTCCREATEPROGRAM = new nvrtcResult();
	public static nvrtcResult NVRTC_NVRTCDESTROYPROGRAM = new nvrtcResult();
	public static nvrtcResult NVRTC_NVRTCGETLOWEREDNAME = new nvrtcResult();
	public static nvrtcResult NVRTC_NVRTCGETPTX = new nvrtcResult();
	public static nvrtcResult NVRTC_NVRTCGETPTXSIZE = new nvrtcResult();
	public static nvrtcResult NVRTC_NVRTCGETPROGRAMLOG = new nvrtcResult();
	public static nvrtcResult NVRTC_NVRTCGETPROGRAMLOGSIZE = new nvrtcResult();
	public static byte NVRTC_NVRTCGETERRORSTRING;
	public static nvrtcResult NVRTC_NVRTCVERSION = new nvrtcResult();
	public static hc_nvrtc_lib_t NVRTC_PTR = new hc_nvrtc_lib_t();
	public static int nvrtc_make_options_array_from_string;
	public static int ROUNDS_TRUECRYPT_1K = 1000;
	public static Object Lzma2DecMtProps_Init;
	public static Object CLzma2DecMtHandle;
	public static CLzma2DecMtHandle Lzma2DecMt_Create = new CLzma2DecMtHandle();
	public static Object Lzma2DecMt_Destroy;
	public static SRes Lzma2DecMt_Decode = new SRes();
	public static SRes Lzma2DecMt_Init = new SRes();
	public static SRes Lzma2DecMt_Read = new SRes();
	public static u32 ROUNDS_SOLARWINDS_ORION = 1000;
	public static byte SIGNATURE_SOLARWINDS_ORION = "$solarwinds$0$";
	public static  rotl32 = new ();
	public static  rotr32 = new ();
	public static  rotl64 = new ();
	public static  rotr64 = new ();
	public static  byte_swap_16 = new ();
	public static  byte_swap_32 = new ();
	public static  byte_swap_64 = new ();
	public static byte SIGNATURE_APFS = "$fvde$";
	public static [] static_ltree = new []{{new (12), new (8)}, {new (140), new (8)}, {new (76), new (8)}, {new (204), new (8)}, {new (44), new (8)}, {new (172), new (8)}, {new (108), new (8)}, {new (236), new (8)}, {new (28), new (8)}, {new (156), new (8)}, {new (92), new (8)}, {new (220), new (8)}, {new (60), new (8)}, {new (188), new (8)}, {new (124), new (8)}, {new (252), new (8)}, {new (2), new (8)}, {new (130), new (8)}, {new (66), new (8)}, {new (194), new (8)}, {new (34), new (8)}, {new (162), new (8)}, {new (98), new (8)}, {new (226), new (8)}, {new (18), new (8)}, {new (146), new (8)}, {new (82), new (8)}, {new (210), new (8)}, {new (50), new (8)}, {new (178), new (8)}, {new (114), new (8)}, {new (242), new (8)}, {new (10), new (8)}, {new (138), new (8)}, {new (74), new (8)}, {new (202), new (8)}, {new (42), new (8)}, {new (170), new (8)}, {new (106), new (8)}, {new (234), new (8)}, {new (26), new (8)}, {new (154), new (8)}, {new (90), new (8)}, {new (218), new (8)}, {new (58), new (8)}, {new (186), new (8)}, {new (122), new (8)}, {new (250), new (8)}, {new (6), new (8)}, {new (134), new (8)}, {new (70), new (8)}, {new (198), new (8)}, {new (38), new (8)}, {new (166), new (8)}, {new (102), new (8)}, {new (230), new (8)}, {new (22), new (8)}, {new (150), new (8)}, {new (86), new (8)}, {new (214), new (8)}, {new (54), new (8)}, {new (182), new (8)}, {new (118), new (8)}, {new (246), new (8)}, {new (14), new (8)}, {new (142), new (8)}, {new (78), new (8)}, {new (206), new (8)}, {new (46), new (8)}, {new (174), new (8)}, {new (110), new (8)}, {new (238), new (8)}, {new (30), new (8)}, {new (158), new (8)}, {new (94), new (8)}, {new (222), new (8)}, {new (62), new (8)}, {new (190), new (8)}, {new (126), new (8)}, {new (254), new (8)}, {new (1), new (8)}, {new (129), new (8)}, {new (65), new (8)}, {new (193), new (8)}, {new (33), new (8)}, {new (161), new (8)}, {new (97), new (8)}, {new (225), new (8)}, {new (17), new (8)}, {new (145), new (8)}, {new (81), new (8)}, {new (209), new (8)}, {new (49), new (8)}, {new (177), new (8)}, {new (113), new (8)}, {new (241), new (8)}, {new (9), new (8)}, {new (137), new (8)}, {new (73), new (8)}, {new (201), new (8)}, {new (41), new (8)}, {new (169), new (8)}, {new (105), new (8)}, {new (233), new (8)}, {new (25), new (8)}, {new (153), new (8)}, {new (89), new (8)}, {new (217), new (8)}, {new (57), new (8)}, {new (185), new (8)}, {new (121), new (8)}, {new (249), new (8)}, {new (5), new (8)}, {new (133), new (8)}, {new (69), new (8)}, {new (197), new (8)}, {new (37), new (8)}, {new (165), new (8)}, {new (101), new (8)}, {new (229), new (8)}, {new (21), new (8)}, {new (149), new (8)}, {new (85), new (8)}, {new (213), new (8)}, {new (53), new (8)}, {new (181), new (8)}, {new (117), new (8)}, {new (245), new (8)}, {new (13), new (8)}, {new (141), new (8)}, {new (77), new (8)}, {new (205), new (8)}, {new (45), new (8)}, {new (173), new (8)}, {new (109), new (8)}, {new (237), new (8)}, {new (29), new (8)}, {new (157), new (8)}, {new (93), new (8)}, {new (221), new (8)}, {new (61), new (8)}, {new (189), new (8)}, {new (125), new (8)}, {new (253), new (8)}, {new (19), new (9)}, {new (275), new (9)}, {new (147), new (9)}, {new (403), new (9)}, {new (83), new (9)}, {new (339), new (9)}, {new (211), new (9)}, {new (467), new (9)}, {new (51), new (9)}, {new (307), new (9)}, {new (179), new (9)}, {new (435), new (9)}, {new (115), new (9)}, {new (371), new (9)}, {new (243), new (9)}, {new (499), new (9)}, {new (11), new (9)}, {new (267), new (9)}, {new (139), new (9)}, {new (395), new (9)}, {new (75), new (9)}, {new (331), new (9)}, {new (203), new (9)}, {new (459), new (9)}, {new (43), new (9)}, {new (299), new (9)}, {new (171), new (9)}, {new (427), new (9)}, {new (107), new (9)}, {new (363), new (9)}, {new (235), new (9)}, {new (491), new (9)}, {new (27), new (9)}, {new (283), new (9)}, {new (155), new (9)}, {new (411), new (9)}, {new (91), new (9)}, {new (347), new (9)}, {new (219), new (9)}, {new (475), new (9)}, {new (59), new (9)}, {new (315), new (9)}, {new (187), new (9)}, {new (443), new (9)}, {new (123), new (9)}, {new (379), new (9)}, {new (251), new (9)}, {new (507), new (9)}, {new (7), new (9)}, {new (263), new (9)}, {new (135), new (9)}, {new (391), new (9)}, {new (71), new (9)}, {new (327), new (9)}, {new (199), new (9)}, {new (455), new (9)}, {new (39), new (9)}, {new (295), new (9)}, {new (167), new (9)}, {new (423), new (9)}, {new (103), new (9)}, {new (359), new (9)}, {new (231), new (9)}, {new (487), new (9)}, {new (23), new (9)}, {new (279), new (9)}, {new (151), new (9)}, {new (407), new (9)}, {new (87), new (9)}, {new (343), new (9)}, {new (215), new (9)}, {new (471), new (9)}, {new (55), new (9)}, {new (311), new (9)}, {new (183), new (9)}, {new (439), new (9)}, {new (119), new (9)}, {new (375), new (9)}, {new (247), new (9)}, {new (503), new (9)}, {new (15), new (9)}, {new (271), new (9)}, {new (143), new (9)}, {new (399), new (9)}, {new (79), new (9)}, {new (335), new (9)}, {new (207), new (9)}, {new (463), new (9)}, {new (47), new (9)}, {new (303), new (9)}, {new (175), new (9)}, {new (431), new (9)}, {new (111), new (9)}, {new (367), new (9)}, {new (239), new (9)}, {new (495), new (9)}, {new (31), new (9)}, {new (287), new (9)}, {new (159), new (9)}, {new (415), new (9)}, {new (95), new (9)}, {new (351), new (9)}, {new (223), new (9)}, {new (479), new (9)}, {new (63), new (9)}, {new (319), new (9)}, {new (191), new (9)}, {new (447), new (9)}, {new (127), new (9)}, {new (383), new (9)}, {new (255), new (9)}, {new (511), new (9)}, {new (0), new (7)}, {new (64), new (7)}, {new (32), new (7)}, {new (96), new (7)}, {new (16), new (7)}, {new (80), new (7)}, {new (48), new (7)}, {new (112), new (7)}, {new (8), new (7)}, {new (72), new (7)}, {new (40), new (7)}, {new (104), new (7)}, {new (24), new (7)}, {new (88), new (7)}, {new (56), new (7)}, {new (120), new (7)}, {new (4), new (7)}, {new (68), new (7)}, {new (36), new (7)}, {new (100), new (7)}, {new (20), new (7)}, {new (84), new (7)}, {new (52), new (7)}, {new (116), new (7)}, {new (3), new (8)}, {new (131), new (8)}, {new (67), new (8)}, {new (195), new (8)}, {new (35), new (8)}, {new (163), new (8)}, {new (99), new (8)}, {new (227), new (8)}};
	public static [] static_dtree = new []{{new (0), new (5)}, {new (16), new (5)}, {new (8), new (5)}, {new (24), new (5)}, {new (4), new (5)}, {new (20), new (5)}, {new (12), new (5)}, {new (28), new (5)}, {new (2), new (5)}, {new (18), new (5)}, {new (10), new (5)}, {new (26), new (5)}, {new (6), new (5)}, {new (22), new (5)}, {new (14), new (5)}, {new (30), new (5)}, {new (1), new (5)}, {new (17), new (5)}, {new (9), new (5)}, {new (25), new (5)}, {new (5), new (5)}, {new (21), new (5)}, {new (13), new (5)}, {new (29), new (5)}, {new (3), new (5)}, {new (19), new (5)}, {new (11), new (5)}, {new (27), new (5)}, {new (7), new (5)}, {new (23), new (5)}};
	public static int[] base_length = new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0};
	public static int[] base_dist = new int[]{0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576};
	public static Object MyAlloc;
	public static Object MyFree;
	public static Object SetLargePageSize;
	public static Object MidAlloc;
	public static Object MidFree;
	public static Object BigAlloc;
	public static Object BigFree;
	public static ISzAlloc g_Alloc = new ISzAlloc();
	public static ISzAlloc g_BigAlloc = new ISzAlloc();
	public static ISzAlloc g_MidAlloc = new ISzAlloc();
	public static ISzAlloc g_AlignedAlloc = new ISzAlloc();
	public static Object AlignOffsetAlloc_CreateVTable;
	public static int ROUNDS_TRUECRYPT_2K = 2000;
	public static byte SIGNATURE_DRUPAL7 = "$S$";
	public static byte SIGNATURE_DJANGOPBKDF2 = "pbkdf2_sha256";
	public static byte SIGNATURE_ELECTRUM_WALLET = "$electrum$";
	public static Object My_SetDefaultDllDirectories;
	public static Object LoadSecurityDlls;
	public static byte[] inbuf = new byte[/* memory for gunpipe() and lunpipe() --
	   the first 256 entries of prefix[] and suffix[] are never used, could
	   have offset the index, but it's faster to waste the memory *//* input buffer */-1024];
	public static byte[] outbuf = new byte[/* output buffer */-1024];
	public static int[] prefix = new int[/* index to LZW prefix string */65536];
	public static byte[] suffix = new byte[/* one-character LZW suffix */65536];
	public static byte[] match = new byte[65280 + /* buffer for reversed match or gzip
	                                           32K sliding window */2/* throw out what's left in the current bits byte buffer (this is a vestigial
	   aspect of the compressed data format derived from an implementation that
	   made use of a special VAX machine instruction!) */];
	public static byte SIGNATURE_MYSQL_AUTH = "$mysqlna$";
	public static byte SIGNATURE_KRB5TGS = "$krb5tgs$18$";
	public static [] te0 = new ();
	public static [] te1 = new ();
	public static [] te2 = new ();
	public static [] te3 = new ();
	public static [] te4 = new ();
	public static [] td0 = new ();
	public static [] td1 = new ();
	public static [] td2 = new ();
	public static [] td3 = new ();
	public static [] td4 = new ();
	public static byte SIGNATURE_AXCRYPT_SHA1 = "$axcrypt_sha1$";
	public static Object cam_feistel;
	public static Object cam_fl;
	public static Object camellia256_set_key;
	public static Object camellia256_encrypt;
	public static Object camellia256_decrypt;
	public static byte SIGNATURE_MEDIAWIKI_B = "$B$";
	public static byte SIGNATURE_DCC2 = "$DCC2$";
	public static pkzip_hash pkzip_hash_t = new pkzip_hash();
	public static pkzip pkzip_t = new pkzip();
	public static byte SIGNATURE_PKZIP_V1 = "$pkzip$";
	public static byte SIGNATURE_PKZIP_V2 = "$pkzip2$";
	public static byte SIGNATURE_ITUNES_BACKUP = "$itunes_backup$";
	public static byte SIGNATURE_ANDROIDFDE = "$fde$";
	public static int ROUNDS_ANDROIDFDE = 2000;
	public static byte SIGNATURE_NETSCALER = "1";
	public static int BRAIN_CLIENT_CONNECT_TIMEOUT = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */5;
	public static int BRAIN_SERVER_DUMP_EVERY = 5 * 60;
	public static int BRAIN_SERVER_SESSIONS_MAX = 64;
	public static int BRAIN_SERVER_ATTACKS_MAX = 64 * 1024;
	public static int BRAIN_SERVER_CLIENTS_MAX = 256;
	public static int BRAIN_SERVER_REALLOC_HASH_SIZE = 1024 * 1024;
	public static int BRAIN_SERVER_REALLOC_ATTACK_SIZE = 1024;
	public static int BRAIN_HASH_SIZE = 2 * ;
	public static int BRAIN_LINK_VERSION_CUR = 1;
	public static int BRAIN_LINK_VERSION_MIN = 1;
	public static int BRAIN_LINK_CHUNK_SIZE = 4 * 1024;
	public static int BRAIN_LINK_CANDIDATES_MAX = 128 * 1024 * 256;
	public static int brain_logging;
	public static  brain_compute_session = new ();
	public static  brain_compute_attack = new ();
	public static  brain_compute_attack_wordlist = new ();
	public static  brain_auth_challenge = new ();
	public static  brain_auth_hash = new ();
	public static int brain_connect;
	public static  brain_recv = new ();
	public static  brain_send = new ();
	public static  brain_recv_all = new ();
	public static  brain_send_all = new ();
	public static  brain_client_reserve = new ();
	public static  brain_client_commit = new ();
	public static  brain_client_lookup = new ();
	public static  brain_client_connect = new ();
	public static Object brain_client_disconnect;
	public static Object brain_client_generate_hash;
	public static int brain_server;
	public static  brain_server_read_hash_dumps = new ();
	public static  brain_server_write_hash_dumps = new ();
	public static  brain_server_read_hash_dump = new ();
	public static  brain_server_write_hash_dump = new ();
	public static  brain_server_read_attack_dumps = new ();
	public static  brain_server_write_attack_dumps = new ();
	public static  brain_server_read_attack_dump = new ();
	public static  brain_server_write_attack_dump = new ();
	public static int brain_server_get_client_idx;
	public static  brain_server_highest_attack = new ();
	public static  brain_server_highest_attack_long = new ();
	public static  brain_server_highest_attack_short = new ();
	public static  brain_server_find_attack_long = new ();
	public static  brain_server_find_attack_short = new ();
	public static  brain_server_find_hash_long = new ();
	public static  brain_server_find_hash_short = new ();
	public static int brain_server_sort_db_hash;
	public static int brain_server_sort_db_attack;
	public static int brain_server_sort_attack_long;
	public static int brain_server_sort_attack_short;
	public static int brain_server_sort_hash;
	public static int brain_server_sort_hash_long;
	public static int brain_server_sort_hash_short;
	public static int brain_server_sort_hash_unique;
	public static Object brain_server_handle_signal;
	public static Object brain_server_handle_client;
	public static Object brain_server_handle_dumps;
	public static Object brain_server_db_hash_init;
	public static  brain_server_db_hash_realloc = new ();
	public static Object brain_server_db_hash_free;
	public static Object brain_server_db_attack_init;
	public static  brain_server_db_attack_realloc = new ();
	public static Object brain_server_db_attack_free;
	public static byte SIGNATURE_RAR5 = "$rar5$";
	public static Object MtProgressThunk_CreateVTable;
	public static Object MtCoder_Construct;
	public static Object MtCoder_Destruct;
	public static SRes MtCoder_Code = new SRes();
	public static [] k_sha256 = new ();
	public static byte SIGNATURE_SHA512GRUB = "grub.pbkdf2.sha512.";
	public static int ROUNDS_PDF17L8 = 64;
	public static UInt16 CState = new UInt16();
	public static UInt16 CExtra = new UInt16();
	public static UInt16 CLzmaProb = new UInt16();
	public static UInt32 CProbPrice = new UInt32();
	public static Byte[] kLiteralNextStates = new Byte[]{0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 4, 5};
	public static Byte[] kMatchNextStates = new Byte[]{7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
	public static Byte[] kRepNextStates = new Byte[]{8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
	public static Byte[] kShortRepNextStates = new Byte[]{9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
	public static byte SIGNATURE_ZIP2_START = "$zip2$";
	public static byte SIGNATURE_ZIP2_STOP = "$/zip2$";
	public static int ROUNDS_ZIP2 = 1000;
	public static byte SIGNATURE_OTM_SHA256 = "otm_sha256";
	public static u32 HASH_LEN_RAW = 64;
	public static u32 HASH_LEN_B64 = 86;
	public static byte SIGNATURE_PASSLIB_PBKDF2_SHA512 = "pbkdf2-sha512";
	public static int ROUNDS_VERACRYPT_200000 = 200000;
	public static Object File_Construct;
	public static WRes InFile_Open = new WRes();
	public static WRes OutFile_Open = new WRes();
	public static WRes InFile_OpenW = new WRes();
	public static WRes OutFile_OpenW = new WRes();
	public static WRes File_Close = new WRes();
	public static WRes File_Read = new WRes();
	public static WRes File_Write = new WRes();
	public static WRes File_Seek = new WRes();
	public static WRes File_GetLength = new WRes();
	public static Object FileSeqInStream_CreateVTable;
	public static Object FileInStream_CreateVTable;
	public static Object FileOutStream_CreateVTable;
	public static byte SIGNATURE_SHA256AIX = "{ssha256}";
	public static int sort_by_string;
	public static int sort_by_digest_p0p1;
	public static int sort_by_salt;
	public static int sort_by_hash;
	public static int sort_by_hash_no_salt;
	public static int hash_encode;
	public static int save_hash;
	public static Object check_hash;
	public static int check_cracked;
	public static int hashes_init_filename;
	public static int hashes_init_stage1;
	public static int hashes_init_stage2;
	public static int hashes_init_stage3;
	public static int hashes_init_stage4;
	public static int hashes_init_selftest;
	public static int hashes_init_benchmark;
	public static Object hashes_destroy;
	public static Object hashes_logger;
	public static  cl_va_api_device_source_intel = new ();
	public static  cl_va_api_device_set_intel = new ();
	public static byte SIGNATURE_BCRYPT1 = "$2a$";
	public static byte SIGNATURE_BCRYPT2 = "$2b$";
	public static byte SIGNATURE_BCRYPT3 = "$2x$";
	public static byte SIGNATURE_BCRYPT4 = "$2y$";
	public static Object camellia256_decrypt_xts_first;
	public static Object camellia256_decrypt_xts_next;
	public static Object kuznyechik_decrypt_xts_first;
	public static Object kuznyechik_decrypt_xts_next;
	public static byte SIGNATURE_PBKDF2_SHA512 = "sha512";
	public static Object xts_mul2;
	public static byte SIGNATURE_PHPS = "$PHPS$";
	public static byte SIGNATURE_ATLASSIAN = "{PKCS5S2}";
	public static int ROUNDS_ATLASSIAN = 10000;
	public static int DISKCRYPTOR_VERSION = 0;
	public static int ROUNDS_DISKCRYPTOR = 1000;
	public static byte SIGNATURE_DISKCRYPTOR = "$diskcryptor$";
	public static Object thread_autotune;
	public static Object ripemd160_transform;
	public static Object ripemd160_init;
	public static Object ripemd160_update_64;
	public static Object ripemd160_update;
	public static Object ripemd160_update_swap;
	public static Object ripemd160_update_utf16le;
	public static Object ripemd160_update_utf16le_swap;
	public static Object ripemd160_final;
	public static Object ripemd160_hmac_init_64;
	public static Object ripemd160_hmac_init;
	public static Object ripemd160_hmac_init_swap;
	public static Object ripemd160_hmac_update_64;
	public static Object ripemd160_hmac_update;
	public static Object ripemd160_hmac_update_swap;
	public static Object ripemd160_hmac_update_utf16le;
	public static Object ripemd160_hmac_update_utf16le_swap;
	public static Object ripemd160_hmac_final;
	public static Object ripemd160_transform_vector;
	public static Object ripemd160_init_vector;
	public static Object ripemd160_init_vector_from_scalar;
	public static Object ripemd160_update_vector_64;
	public static Object ripemd160_update_vector;
	public static Object ripemd160_update_vector_swap;
	public static Object ripemd160_update_vector_utf16le;
	public static Object ripemd160_update_vector_utf16le_swap;
	public static Object ripemd160_final_vector;
	public static Object ripemd160_hmac_init_vector_64;
	public static Object ripemd160_hmac_init_vector;
	public static Object ripemd160_hmac_update_vector_64;
	public static Object ripemd160_hmac_update_vector;
	public static Object ripemd160_hmac_final_vector;
	public static nvmlDevice_st nvmlDevice_t = new nvmlDevice_st();
	public static nvmlDevice_t HM_ADAPTER_NVML = new nvmlDevice_t();
	public static byte NVML_ERROR_STRING;
	public static int NVML_INIT;
	public static int NVML_SHUTDOWN;
	public static nvmlReturn_t NVML_DEVICE_GET_COUNT = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_NAME = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_HANDLE_BY_INDEX = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_TEMPERATURE = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_FAN_SPEED = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_UTILIZATION_RATES = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_CLOCKINFO = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_THRESHOLD = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_CURRPCIELINKGENERATION = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_CURRPCIELINKWIDTH = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_CURRENTCLOCKSTHROTTLEREASONS = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_SUPPORTEDCLOCKSTHROTTLEREASONS = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_SET_COMPUTEMODE = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_SET_OPERATIONMODE = new nvmlReturn_t();
	public static nvmlReturn_t NVML_DEVICE_GET_PCIINFO = new nvmlReturn_t();
	public static hm_nvml_lib_t NVML_PTR = new hm_nvml_lib_t();
	public static gzFile gzopen64 = new gzFile();
	public static long gzseek64;
	public static long gztell64;
	public static long gzoffset64;
	public static gz_state gz_statep = new gz_state();
	public static Object gz_error;
	public static byte SIGNATURE_ETHEREUM_SCRYPT = "$ethereum$s";
	public static u32 SCRYPT_MAX_ACCEL = 16;
	public static u32 SCRYPT_MAX_THREADS = 1;
	public static byte[] USAGE_MINI = new byte[]{/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */"Usage: hashcat [options]... hash|hashfile|hccapxfile [dictionary|mask|directory]...", "", "Try --help for more help.", ((Object)0)};
	public static byte[] USAGE_BIG_PRE_HASHMODES = new byte[]{"Usage: hashcat [options]... hash|hashfile|hccapxfile [dictionary|mask|directory]...", "", "- [ Options ] -", "", " Options Short / Long           | Type | Description                                          | Example", "================================+======+======================================================+=======================", " -m, --hash-type                | Num  | Hash-type, see references below                      | -m 1000", " -a, --attack-mode              | Num  | Attack-mode, see references below                    | -a 3", " -V, --version                  |      | Print version                                        |", " -h, --help                     |      | Print help                                           |", "     --quiet                    |      | Suppress output                                      |", "     --hex-charset              |      | Assume charset is given in hex                       |", "     --hex-salt                 |      | Assume salt is given in hex                          |", "     --hex-wordlist             |      | Assume words in wordlist are given in hex            |", "     --force                    |      | Ignore warnings                                      |", "     --status                   |      | Enable automatic update of the status screen         |", "     --status-json              |      | Enable JSON format for status ouput                  |", "     --status-timer             | Num  | Sets seconds between status screen updates to X      | --status-timer=1", "     --stdin-timeout-abort      | Num  | Abort if there is no input from stdin for X seconds  | --stdin-timeout-abort=300", "     --machine-readable         |      | Display the status view in a machine-readable format |", "     --keep-guessing            |      | Keep guessing the hash after it has been cracked     |", "     --self-test-disable        |      | Disable self-test functionality on startup           |", "     --loopback                 |      | Add new plains to induct directory                   |", "     --markov-hcstat2           | File | Specify hcstat2 file to use                          | --markov-hcstat2=my.hcstat2", "     --markov-disable           |      | Disables markov-chains, emulates classic brute-force |", "     --markov-classic           |      | Enables classic markov-chains, no per-position       |", " -t, --markov-threshold         | Num  | Threshold X when to stop accepting new markov-chains | -t 50", "     --runtime                  | Num  | Abort session after X seconds of runtime             | --runtime=10", "     --session                  | Str  | Define specific session name                         | --session=mysession", "     --restore                  |      | Restore session from --session                       |", "     --restore-disable          |      | Do not write restore file                            |", "     --restore-file-path        | File | Specific path to restore file                        | --restore-file-path=x.restore", " -o, --outfile                  | File | Define outfile for recovered hash                    | -o outfile.txt", "     --outfile-format           | Num  | Define outfile-format X for recovered hash           | --outfile-format=7", "     --outfile-autohex-disable  |      | Disable the use of $HEX[] in output plains           |", "     --outfile-check-timer      | Num  | Sets seconds between outfile checks to X             | --outfile-check=30", "     --wordlist-autohex-disable |      | Disable the conversion of $HEX[] from the wordlist   |", " -p, --separator                | Char | Separator char for hashlists and outfile             | -p :", "     --stdout                   |      | Do not crack a hash, instead print candidates only   |", "     --show                     |      | Compare hashlist with potfile; show cracked hashes   |", "     --left                     |      | Compare hashlist with potfile; show uncracked hashes |", "     --username                 |      | Enable ignoring of usernames in hashfile             |", "     --remove                   |      | Enable removal of hashes once they are cracked       |", "     --remove-timer             | Num  | Update input hash file each X seconds                | --remove-timer=30", "     --potfile-disable          |      | Do not write potfile                                 |", "     --potfile-path             | File | Specific path to potfile                             | --potfile-path=my.pot", "     --encoding-from            | Code | Force internal wordlist encoding from X              | --encoding-from=iso-8859-15", "     --encoding-to              | Code | Force internal wordlist encoding to X                | --encoding-to=utf-32le", "     --debug-mode               | Num  | Defines the debug mode (hybrid only by using rules)  | --debug-mode=4", "     --debug-file               | File | Output file for debugging rules                      | --debug-file=good.log", "     --induction-dir            | Dir  | Specify the induction directory to use for loopback  | --induction=inducts", "     --outfile-check-dir        | Dir  | Specify the outfile directory to monitor for plains  | --outfile-check-dir=x", "     --logfile-disable          |      | Disable the logfile                                  |", "     --hccapx-message-pair      | Num  | Load only message pairs from hccapx matching X       | --hccapx-message-pair=2", "     --nonce-error-corrections  | Num  | The BF size range to replace AP's nonce last bytes   | --nonce-error-corrections=16", "     --keyboard-layout-mapping  | File | Keyboard layout mapping table for special hash-modes | --keyb=german.hckmap", "     --truecrypt-keyfiles       | File | Keyfiles to use, separated with commas               | --truecrypt-keyf=x.png", "     --veracrypt-keyfiles       | File | Keyfiles to use, separated with commas               | --veracrypt-keyf=x.txt", "     --veracrypt-pim-start      | Num  | VeraCrypt personal iterations multiplier start       | --veracrypt-pim-start=450", "     --veracrypt-pim-stop       | Num  | VeraCrypt personal iterations multiplier stop        | --veracrypt-pim-stop=500", " -b, --benchmark                |      | Run benchmark of selected hash-modes                 |", "     --benchmark-all            |      | Run benchmark of all hash-modes (requires -b)        |", "     --speed-only               |      | Return expected speed of the attack, then quit       |", "     --progress-only            |      | Return ideal progress step size and time to process  |", " -c, --segment-size             | Num  | Sets size in MB to cache from the wordfile to X      | -c 32", "     --bitmap-min               | Num  | Sets minimum bits allowed for bitmaps to X           | --bitmap-min=24", "     --bitmap-max               | Num  | Sets maximum bits allowed for bitmaps to X           | --bitmap-max=24", "     --cpu-affinity             | Str  | Locks to CPU devices, separated with commas          | --cpu-affinity=1,2,3", "     --example-hashes           |      | Show an example hash for each hash-mode              |", " -I, --backend-info             |      | Show info about detected backend API devices         | -I", " -d, --backend-devices          | Str  | Backend devices to use, separated with commas        | -d 1", " -D, --opencl-device-types      | Str  | OpenCL device-types to use, separated with commas    | -D 1", " -O, --optimized-kernel-enable  |      | Enable optimized kernels (limits password length)    |", " -w, --workload-profile         | Num  | Enable a specific workload profile, see pool below   | -w 3", " -n, --kernel-accel             | Num  | Manual workload tuning, set outerloop step size to X | -n 64", " -u, --kernel-loops             | Num  | Manual workload tuning, set innerloop step size to X | -u 256", " -T, --kernel-threads           | Num  | Manual workload tuning, set thread count to X        | -T 64", "     --backend-vector-width     | Num  | Manually override backend vector-width to X          | --backend-vector=4", "     --spin-damp                | Num  | Use CPU for device synchronization, in percent       | --spin-damp=50", "     --hwmon-disable            |      | Disable temperature and fanspeed reads and triggers  |", "     --hwmon-temp-abort         | Num  | Abort if temperature reaches X degrees Celsius       | --hwmon-temp-abort=100", "     --scrypt-tmto              | Num  | Manually override TMTO value for scrypt to X         | --scrypt-tmto=3", " -s, --skip                     | Num  | Skip X words from the start                          | -s 1000000", " -l, --limit                    | Num  | Limit X words from the start + skipped words         | -l 1000000", "     --keyspace                 |      | Show keyspace base:mod values and quit               |", " -j, --rule-left                | Rule | Single rule applied to each word from left wordlist  | -j 'c'", " -k, --rule-right               | Rule | Single rule applied to each word from right wordlist | -k '^-'", " -r, --rules-file               | File | Multiple rules applied to each word from wordlists   | -r rules/best64.rule", " -g, --generate-rules           | Num  | Generate X random rules                              | -g 10000", "     --generate-rules-func-min  | Num  | Force min X functions per rule                       |", "     --generate-rules-func-max  | Num  | Force max X functions per rule                       |", "     --generate-rules-seed      | Num  | Force RNG seed set to X                              |", " -1, --custom-charset1          | CS   | User-defined charset ?1                              | -1 ?l?d?u", " -2, --custom-charset2          | CS   | User-defined charset ?2                              | -2 ?l?d?s", " -3, --custom-charset3          | CS   | User-defined charset ?3                              |", " -4, --custom-charset4          | CS   | User-defined charset ?4                              |", " -i, --increment                |      | Enable mask increment mode                           |", "     --increment-min            | Num  | Start mask incrementing at X                         | --increment-min=4", "     --increment-max            | Num  | Stop mask incrementing at X                          | --increment-max=8", " -S, --slow-candidates          |      | Enable slower (but advanced) candidate generators    |", "", "- [ Hash modes ] -", "", "      # | Name                                             | Category", "  ======+==================================================+======================================", ((Object)0)};
	public static byte[] USAGE_BIG_POST_HASHMODES = new byte[]{"- [ Outfile Formats ] -", "", "  # | Format", " ===+========", "  1 | hash[:salt]", "  2 | plain", "  3 | hash[:salt]:plain", "  4 | hex_plain", "  5 | hash[:salt]:hex_plain", "  6 | plain:hex_plain", "  7 | hash[:salt]:plain:hex_plain", "  8 | crackpos", "  9 | hash[:salt]:crack_pos", " 10 | plain:crack_pos", " 11 | hash[:salt]:plain:crack_pos", " 12 | hex_plain:crack_pos", " 13 | hash[:salt]:hex_plain:crack_pos", " 14 | plain:hex_plain:crack_pos", " 15 | hash[:salt]:plain:hex_plain:crack_pos", "", "- [ Rule Debugging Modes ] -", "", "  # | Format", " ===+========", "  1 | Finding-Rule", "  2 | Original-Word", "  3 | Original-Word:Finding-Rule", "  4 | Original-Word:Finding-Rule:Processed-Word", "", "- [ Attack Modes ] -", "", "  # | Mode", " ===+======", "  0 | Straight", "  1 | Combination", "  3 | Brute-force", "  6 | Hybrid Wordlist + Mask", "  7 | Hybrid Mask + Wordlist", "", "- [ Built-in Charsets ] -", "", "  ? | Charset", " ===+=========", "  l | abcdefghijklmnopqrstuvwxyz", "  u | ABCDEFGHIJKLMNOPQRSTUVWXYZ", "  d | 0123456789", "  h | 0123456789abcdef", "  H | 0123456789ABCDEF", "  s |  !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", "  a | ?l?u?d?s", "  b | 0x00 - 0xff", "", "- [ OpenCL Device Types ] -", "", "  # | Device Type", " ===+=============", "  1 | CPU", "  2 | GPU", "  3 | FPGA, DSP, Co-Processor", "", "- [ Workload Profiles ] -", "", "  # | Performance | Runtime | Power Consumption | Desktop Impact", " ===+=============+=========+===================+=================", "  1 | Low         |   2 ms  | Low               | Minimal", "  2 | Default     |  12 ms  | Economic          | Noticeable", "  3 | High        |  96 ms  | High              | Unresponsive", "  4 | Nightmare   | 480 ms  | Insane            | Headless", "", "- [ Basic Examples ] -", "", "  Attack-          | Hash- |", "  Mode             | Type  | Example command", " ==================+=======+==================================================================", "  Wordlist         | $P$   | hashcat -a 0 -m 400 example400.hash example.dict", "  Wordlist + Rules | MD5   | hashcat -a 0 -m 0 example0.hash example.dict -r rules/best64.rule", "  Brute-Force      | MD5   | hashcat -a 3 -m 0 example0.hash ?a?a?a?a?a?a", "  Combinator       | MD5   | hashcat -a 1 -m 0 example0.hash example.dict example.dict", "", "If you still have no idea what just happened, try the following pages:", "", "* https://hashcat.net/wiki/#howtos_videos_papers_articles_etc_in_the_wild", "* https://hashcat.net/faq/", ((Object)0)};
	public static long big_t;
	public static long code_t;
	public static int max;
	public static int root;
	public static int large;
	public static size_t size = new size_t();
	public static int code;
	public static big_t num = new big_t();
	public static tab done = new tab();
	public static Object twofish128_decrypt_cbc;
	public static Object twofish256_decrypt_cbc;
	public static Object twofish128_decrypt_xts;
	public static Object twofish256_decrypt_xts;
	public static Object usage_mini_print;
	public static Object usage_big_print;
	public static int8_t i8 = new int8_t();
	public static int16_t i16 = new int16_t();
	public static int32_t i32 = new int32_t();
	public static int64_t i64 = new int64_t();
	public static uint32_t uint4 = new uint32_t();
	public static LARGE_INTEGER hc_timer_t = new LARGE_INTEGER();
	public static HANDLE hc_thread_t = new HANDLE();
	public static HANDLE hc_thread_mutex_t = new HANDLE();
	public static HANDLE hc_thread_semaphore_t = new HANDLE();
	public static HMODULE hc_dynlib_t = new HMODULE();
	public static FARPROC hc_dynfunc_t = new FARPROC();
	public static hashconfig hashconfig_t = new hashconfig();
	public static aes_context_t aes_ctx = new aes_context_t();
	public static Object MODULE_INIT;
	public static aes_ctx AES_KEY = new aes_ctx();
	public static UInt32 CrcUpdateT4 = new UInt32();
	public static UInt32 CrcUpdateT8 = new UInt32();
	public static UInt32 CRC_FUNC = new UInt32();
	public static CRC_FUNC g_CrcUpdateT4 = new CRC_FUNC();
	public static CRC_FUNC g_CrcUpdateT8 = new CRC_FUNC();
	public static CRC_FUNC g_CrcUpdate = new CRC_FUNC();
	public static UInt32[] g_CrcTable = new UInt32();
	public static byte SIGNATURE_CISCO8 = "$8$";
	public static int ROUNDS_CISCO8 = 20000;
	public static byte SIGNATURE_APPLE_SECURE_NOTES = "$ASN$";
	public static boolean keep_running = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */true;
	public static hc_timer_t timer_logging = new hc_timer_t();
	public static hc_thread_mutex_t mux_display = new hc_thread_mutex_t();
	public static int Xz_ReadVarInt;
	public static int Xz_WriteVarInt;
	public static SRes XzBlock_Parse = new SRes();
	public static SRes XzBlock_ReadHeader = new SRes();
	public static Object XzCheck_Init;
	public static Object XzCheck_Update;
	public static int XzCheck_Final;
	public static UInt16 CXzStreamFlags = new UInt16();
	public static int XzFlags_GetCheckSize;
	public static SRes Xz_ParseHeader = new SRes();
	public static SRes Xz_ReadHeader = new SRes();
	public static Object Xz_Construct;
	public static Object Xz_Free;
	public static UInt64 Xz_GetUnpackSize = new UInt64();
	public static UInt64 Xz_GetPackSize = new UInt64();
	public static Object Xzs_Construct;
	public static Object Xzs_Free;
	public static SRes Xzs_ReadBackward = new SRes();
	public static UInt64 Xzs_GetNumBlocks = new UInt64();
	public static UInt64 Xzs_GetUnpackSize = new UInt64();
	public static Object XzUnpacker_Construct;
	public static Object XzUnpacker_Init;
	public static Object XzUnpacker_SetOutBuf;
	public static Object XzUnpacker_Free;
	public static SRes XzUnpacker_Code = new SRes();
	public static SRes XzUnpacker_CodeFull = new SRes();
	public static BoolInt XzUnpacker_IsStreamWasFinished = new BoolInt();
	public static UInt64 XzUnpacker_GetExtraSize = new UInt64();
	public static Object XzUnpacker_PrepareToRandomBlockDecoding;
	public static BoolInt XzUnpacker_IsBlockFinished = new BoolInt();
	public static Object XzDecMtProps_Init;
	public static Object CXzDecMtHandle;
	public static CXzDecMtHandle XzDecMt_Create = new CXzDecMtHandle();
	public static Object XzDecMt_Destroy;
	public static Object XzStatInfo_Clear;
	public static SRes XzDecMt_Decode = new SRes();
	public static  overflow_check_u32_add = new ();
	public static  overflow_check_u32_mul = new ();
	public static  overflow_check_u64_add = new ();
	public static  overflow_check_u64_mul = new ();
	public static  is_power_of_2 = new ();
	public static  get_random_num = new ();
	public static  mydivc32 = new ();
	public static  mydivc64 = new ();
	public static byte filename_from_filepath;
	public static Object naive_replace;
	public static Object naive_escape;
	public static int hc_asprintf;
	public static Object setup_environment_variables;
	public static Object setup_umask;
	public static Object setup_seeding;
	public static Object hc_qsort_r;
	public static Object hc_bsearch_r;
	public static  hc_path_is_file = new ();
	public static  hc_path_is_directory = new ();
	public static  hc_path_is_empty = new ();
	public static  hc_path_exist = new ();
	public static  hc_path_read = new ();
	public static  hc_path_write = new ();
	public static  hc_path_create = new ();
	public static  hc_path_has_bom = new ();
	public static  hc_string_is_digit = new ();
	public static Object hc_string_trim_trailing;
	public static Object hc_string_trim_leading;
	public static  hc_same_files = new ();
	public static  hc_strtoul = new ();
	public static  hc_strtoull = new ();
	public static  power_of_two_ceil_32 = new ();
	public static  power_of_two_floor_32 = new ();
	public static  round_up_multiple_32 = new ();
	public static  round_up_multiple_64 = new ();
	public static Object hc_strncat;
	public static int count_char;
	public static double get_entropy;
	public static int select_read_timeout;
	public static int select_write_timeout;
	public static int select_read_timeout_console;
	public static byte strparser;
	public static byte strhashcategory;
	public static byte stroptitype;
	public static int input_tokenizer;
	public static int ROUNDS_ANDROIDPIN = 1024;
	public static byte short_options = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */"hVvm:a:r:j:k:g:o:t:d:D:n:u:T:c:p:s:l:1:2:3:4:iIbw:OS";
	public static option[] long_options = new option[]{new option("advice-disable", .no_argument, ((Object)0), user_options_map.IDX_ADVICE_DISABLE), new option("attack-mode", .required_argument, ((Object)0), user_options_map.IDX_ATTACK_MODE), new option("backend-devices", .required_argument, ((Object)0), user_options_map.IDX_BACKEND_DEVICES), new option("backend-info", .no_argument, ((Object)0), user_options_map.IDX_BACKEND_INFO), new option("backend-vector-width", .required_argument, ((Object)0), user_options_map.IDX_BACKEND_VECTOR_WIDTH), new option("benchmark-all", .no_argument, ((Object)0), user_options_map.IDX_BENCHMARK_ALL), new option("benchmark", .no_argument, ((Object)0), user_options_map.IDX_BENCHMARK), new option("bitmap-max", .required_argument, ((Object)0), user_options_map.IDX_BITMAP_MAX), new option("bitmap-min", .required_argument, ((Object)0), user_options_map.IDX_BITMAP_MIN), new option("cpu-affinity", .required_argument, ((Object)0), user_options_map.IDX_CPU_AFFINITY), new option("custom-charset1", .required_argument, ((Object)0), user_options_map.IDX_CUSTOM_CHARSET_1), new option("custom-charset2", .required_argument, ((Object)0), user_options_map.IDX_CUSTOM_CHARSET_2), new option("custom-charset3", .required_argument, ((Object)0), user_options_map.IDX_CUSTOM_CHARSET_3), new option("custom-charset4", .required_argument, ((Object)0), user_options_map.IDX_CUSTOM_CHARSET_4), new option("debug-file", .required_argument, ((Object)0), user_options_map.IDX_DEBUG_FILE), new option("debug-mode", .required_argument, ((Object)0), user_options_map.IDX_DEBUG_MODE), new option("encoding-from", .required_argument, ((Object)0), user_options_map.IDX_ENCODING_FROM), new option("encoding-to", .required_argument, ((Object)0), user_options_map.IDX_ENCODING_TO), new option("example-hashes", .no_argument, ((Object)0), user_options_map.IDX_EXAMPLE_HASHES), new option("force", .no_argument, ((Object)0), user_options_map.IDX_FORCE), new option("generate-rules-func-max", .required_argument, ((Object)0), user_options_map.IDX_RP_GEN_FUNC_MAX), new option("generate-rules-func-min", .required_argument, ((Object)0), user_options_map.IDX_RP_GEN_FUNC_MIN), new option("generate-rules", .required_argument, ((Object)0), user_options_map.IDX_RP_GEN), new option("generate-rules-seed", .required_argument, ((Object)0), user_options_map.IDX_RP_GEN_SEED), new option("hwmon-disable", .no_argument, ((Object)0), user_options_map.IDX_HWMON_DISABLE), new option("hwmon-temp-abort", .required_argument, ((Object)0), user_options_map.IDX_HWMON_TEMP_ABORT), new option("hash-type", .required_argument, ((Object)0), user_options_map.IDX_HASH_MODE), new option("hccapx-message-pair", .required_argument, ((Object)0), user_options_map.IDX_HCCAPX_MESSAGE_PAIR), new option("help", .no_argument, ((Object)0), user_options_map.IDX_HELP), new option("hex-charset", .no_argument, ((Object)0), user_options_map.IDX_HEX_CHARSET), new option("hex-salt", .no_argument, ((Object)0), user_options_map.IDX_HEX_SALT), new option("hex-wordlist", .no_argument, ((Object)0), user_options_map.IDX_HEX_WORDLIST), new option("increment-max", .required_argument, ((Object)0), user_options_map.IDX_INCREMENT_MAX), new option("increment-min", .required_argument, ((Object)0), user_options_map.IDX_INCREMENT_MIN), new option("increment", .no_argument, ((Object)0), user_options_map.IDX_INCREMENT), new option("induction-dir", .required_argument, ((Object)0), user_options_map.IDX_INDUCTION_DIR), new option("keep-guessing", .no_argument, ((Object)0), user_options_map.IDX_KEEP_GUESSING), new option("kernel-accel", .required_argument, ((Object)0), user_options_map.IDX_KERNEL_ACCEL), new option("kernel-loops", .required_argument, ((Object)0), user_options_map.IDX_KERNEL_LOOPS), new option("kernel-threads", .required_argument, ((Object)0), user_options_map.IDX_KERNEL_THREADS), new option("keyboard-layout-mapping", .required_argument, ((Object)0), user_options_map.IDX_KEYBOARD_LAYOUT_MAPPING), new option("keyspace", .no_argument, ((Object)0), user_options_map.IDX_KEYSPACE), new option("left", .no_argument, ((Object)0), user_options_map.IDX_LEFT), new option("limit", .required_argument, ((Object)0), user_options_map.IDX_LIMIT), new option("logfile-disable", .no_argument, ((Object)0), user_options_map.IDX_LOGFILE_DISABLE), new option("loopback", .no_argument, ((Object)0), user_options_map.IDX_LOOPBACK), new option("machine-readable", .no_argument, ((Object)0), user_options_map.IDX_MACHINE_READABLE), new option("markov-classic", .no_argument, ((Object)0), user_options_map.IDX_MARKOV_CLASSIC), new option("markov-disable", .no_argument, ((Object)0), user_options_map.IDX_MARKOV_DISABLE), new option("markov-hcstat2", .required_argument, ((Object)0), user_options_map.IDX_MARKOV_HCSTAT2), new option("markov-threshold", .required_argument, ((Object)0), user_options_map.IDX_MARKOV_THRESHOLD), new option("nonce-error-corrections", .required_argument, ((Object)0), user_options_map.IDX_NONCE_ERROR_CORRECTIONS), new option("opencl-device-types", .required_argument, ((Object)0), user_options_map.IDX_OPENCL_DEVICE_TYPES), new option("optimized-kernel-enable", .no_argument, ((Object)0), user_options_map.IDX_OPTIMIZED_KERNEL_ENABLE), new option("outfile-autohex-disable", .no_argument, ((Object)0), user_options_map.IDX_OUTFILE_AUTOHEX_DISABLE), new option("outfile-check-dir", .required_argument, ((Object)0), user_options_map.IDX_OUTFILE_CHECK_DIR), new option("outfile-check-timer", .required_argument, ((Object)0), user_options_map.IDX_OUTFILE_CHECK_TIMER), new option("outfile-format", .required_argument, ((Object)0), user_options_map.IDX_OUTFILE_FORMAT), new option("outfile", .required_argument, ((Object)0), user_options_map.IDX_OUTFILE), new option("potfile-disable", .no_argument, ((Object)0), user_options_map.IDX_POTFILE_DISABLE), new option("potfile-path", .required_argument, ((Object)0), user_options_map.IDX_POTFILE_PATH), new option("progress-only", .no_argument, ((Object)0), user_options_map.IDX_PROGRESS_ONLY), new option("quiet", .no_argument, ((Object)0), user_options_map.IDX_QUIET), new option("remove", .no_argument, ((Object)0), user_options_map.IDX_REMOVE), new option("remove-timer", .required_argument, ((Object)0), user_options_map.IDX_REMOVE_TIMER), new option("restore-disable", .no_argument, ((Object)0), user_options_map.IDX_RESTORE_DISABLE), new option("restore-file-path", .required_argument, ((Object)0), user_options_map.IDX_RESTORE_FILE_PATH), new option("restore", .no_argument, ((Object)0), user_options_map.IDX_RESTORE), new option("rule-left", .required_argument, ((Object)0), user_options_map.IDX_RULE_BUF_L), new option("rule-right", .required_argument, ((Object)0), user_options_map.IDX_RULE_BUF_R), new option("rules-file", .required_argument, ((Object)0), user_options_map.IDX_RP_FILE), new option("runtime", .required_argument, ((Object)0), user_options_map.IDX_RUNTIME), new option("scrypt-tmto", .required_argument, ((Object)0), user_options_map.IDX_SCRYPT_TMTO), new option("segment-size", .required_argument, ((Object)0), user_options_map.IDX_SEGMENT_SIZE), new option("self-test-disable", .no_argument, ((Object)0), user_options_map.IDX_SELF_TEST_DISABLE), new option("separator", .required_argument, ((Object)0), user_options_map.IDX_SEPARATOR), new option("seperator", .required_argument, ((Object)0), user_options_map.IDX_SEPARATOR), new option("session", .required_argument, ((Object)0), user_options_map.IDX_SESSION), new option("show", .no_argument, ((Object)0), user_options_map.IDX_SHOW), new option("skip", .required_argument, ((Object)0), user_options_map.IDX_SKIP), new option("slow-candidates", .no_argument, ((Object)0), user_options_map.IDX_SLOW_CANDIDATES), new option("speed-only", .no_argument, ((Object)0), user_options_map.IDX_SPEED_ONLY), new option("spin-damp", .required_argument, ((Object)0), user_options_map.IDX_SPIN_DAMP), new option("status", .no_argument, ((Object)0), user_options_map.IDX_STATUS), new option("status-json", .no_argument, ((Object)0), user_options_map.IDX_STATUS_JSON), new option("status-timer", .required_argument, ((Object)0), user_options_map.IDX_STATUS_TIMER), new option("stdout", .no_argument, ((Object)0), user_options_map.IDX_STDOUT_FLAG), new option("stdin-timeout-abort", .required_argument, ((Object)0), user_options_map.IDX_STDIN_TIMEOUT_ABORT), new option("truecrypt-keyfiles", .required_argument, ((Object)0), user_options_map.IDX_TRUECRYPT_KEYFILES), new option("username", .no_argument, ((Object)0), user_options_map.IDX_USERNAME), new option("veracrypt-keyfiles", .required_argument, ((Object)0), user_options_map.IDX_VERACRYPT_KEYFILES), new option("veracrypt-pim-start", .required_argument, ((Object)0), user_options_map.IDX_VERACRYPT_PIM_START), new option("veracrypt-pim-stop", .required_argument, ((Object)0), user_options_map.IDX_VERACRYPT_PIM_STOP), new option("version", .no_argument, ((Object)0), user_options_map.IDX_VERSION), new option("wordlist-autohex-disable", .no_argument, ((Object)0), user_options_map.IDX_WORDLIST_AUTOHEX_DISABLE), new option("workload-profile", .required_argument, ((Object)0), user_options_map.IDX_WORKLOAD_PROFILE), new option(((Object)0), 0, ((Object)0), 0)};
	public static byte ENCODING_FROM = "utf-8";
	public static byte ENCODING_TO = "utf-8";
	public static byte RULE_BUF_R = ":";
	public static byte RULE_BUF_L = ":";
	public static byte DEF_MASK_CS_1 = "?l?d?u";
	public static byte DEF_MASK_CS_2 = "?l?d";
	public static byte DEF_MASK_CS_3 = "?l?d*!$@_";
	public static byte SIGNATURE_PASSLIB_PBKDF2_SHA1 = "pbkdf2";
	public static Object XzFilterProps_Init;
	public static Object XzProps_Init;
	public static Object CXzEncHandle;
	public static CXzEncHandle XzEnc_Create = new CXzEncHandle();
	public static Object XzEnc_Destroy;
	public static SRes XzEnc_SetProps = new SRes();
	public static Object XzEnc_SetDataSize;
	public static SRes XzEnc_Encode = new SRes();
	public static SRes Xz_Encode = new SRes();
	public static SRes Xz_EncodeEmpty = new SRes();
	public static voidpf fopen_file_func = new voidpf();
	public static uLong fread_file_func = new uLong();
	public static uLong fwrite_file_func = new uLong();
	public static ZPOS64_T ftell64_file_func = new ZPOS64_T();
	public static long fseek64_file_func;
	public static int fclose_file_func;
	public static int ferror_file_func;
	public static int combinator_ctx_init;
	public static Object combinator_ctx_destroy;
	public static Object Delta_Init;
	public static Object Delta_Encode;
	public static Object Delta_Decode;
	public static int LzmaCompress;
	public static int LzmaUncompress;
	public static Byte[] k7zSignature = new Byte();
	public static SRes SzGetNextFolderItem = new SRes();
	public static UInt64 SzAr_GetFolderUnpackSize = new UInt64();
	public static SRes SzAr_DecodeFolder = new SRes();
	public static Object SzArEx_Init;
	public static Object SzArEx_Free;
	public static UInt64 SzArEx_GetFolderStreamPos = new UInt64();
	public static int SzArEx_GetFolderFullPackSize;
	public static size_t SzArEx_GetFileNameUtf16 = new size_t();
	public static SRes SzArEx_Extract = new SRes();
	public static SRes SzArEx_Open = new SRes();
	public static Object Sha256_Init;
	public static Object Sha256_Update;
	public static Object Sha256_Final;
	public static long crc32_little;
	public static long crc32_big;
	public static long gf2_matrix_times;
	public static Object gf2_matrix_square;
	public static uLong crc32_combine_ = new uLong();
	public static u32 full01 = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */-1024;
	public static u32 full06 = -1024;
	public static u32 full80 = -1024;
	public static double[] TARGET_MSEC_PROFILE = new double[]{2, 12, 96, 480};
	public static size_t convert_from_hex = new size_t();
	public static Object pw_pre_add;
	public static Object pw_base_add;
	public static Object pw_add;
	public static Object get_next_word_lm;
	public static Object get_next_word_uc;
	public static Object get_next_word_std;
	public static Object get_next_word;
	public static int load_segment;
	public static int count_words;
	public static int wl_data_init;
	public static Object wl_data_destroy;
	public static u32 PWDUMP_COLUMN = pwdump_column.PWDUMP_COLUMN_NTLM_HASH;
	public static byte SIGNATURE_KRB5PA = "$krb5pa$23$";
	public static Object sha384_transform;
	public static Object sha384_init;
	public static Object sha384_update_128;
	public static Object sha384_update;
	public static Object sha384_update_swap;
	public static Object sha384_update_utf16le;
	public static Object sha384_update_utf16le_swap;
	public static Object sha384_final;
	public static Object sha384_hmac_init_128;
	public static Object sha384_hmac_init;
	public static Object sha384_hmac_init_swap;
	public static Object sha384_hmac_update_128;
	public static Object sha384_hmac_update;
	public static Object sha384_hmac_update_swap;
	public static Object sha384_hmac_update_utf16le;
	public static Object sha384_hmac_update_utf16le_swap;
	public static Object sha384_hmac_final;
	public static Object sha384_transform_vector;
	public static Object sha384_init_vector;
	public static Object sha384_init_vector_from_scalar;
	public static Object sha384_update_vector_128;
	public static Object sha384_update_vector;
	public static Object sha384_update_vector_swap;
	public static Object sha384_update_vector_utf16le;
	public static Object sha384_update_vector_utf16le_swap;
	public static Object sha384_update_vector_utf16beN;
	public static Object sha384_final_vector;
	public static Object sha384_hmac_init_vector_128;
	public static Object sha384_hmac_init_vector;
	public static Object sha384_hmac_update_vector_128;
	public static Object sha384_hmac_update_vector;
	public static Object sha384_hmac_final_vector;
	public static size_t z_size_t = new size_t();
	public static byte Byte;
	public static int uInt;
	public static long uLong;
	public static Byte Bytef = new Byte();
	public static byte charf;
	public static int intf;
	public static uInt uIntf = new uInt();
	public static uLong uLongf = new uLong();
	public static Object voidpc;
	public static Object voidpf;
	public static Object voidp;
	public static int z_crc_t;
	public static byte SIGNATURE_ETHEREUM_PBKDF2 = "$ethereum$p";
	public static byte SIGNATURE_MSSQL = "0x0100";
	public static UInt32[][] kVendors = new UInt32[][]{new UInt32(-1024, -1024, -1024), new UInt32(-1024, -1024, -1024), new UInt32(-1024, -1024, -1024)};
	public static byte SIGNATURE_SHA512MACOS = "$ml$";
	public static [] lenfix = new []{new (96, 7, 0), new (0, 8, 80), new (0, 8, 16), new (20, 8, 115), new (18, 7, 31), new (0, 8, 112), new (0, 8, 48), new (0, 9, 192), new (16, 7, 10), new (0, 8, 96), new (0, 8, 32), new (0, 9, 160), new (0, 8, 0), new (0, 8, 128), new (0, 8, 64), new (0, 9, 224), new (16, 7, 6), new (0, 8, 88), new (0, 8, 24), new (0, 9, 144), new (19, 7, 59), new (0, 8, 120), new (0, 8, 56), new (0, 9, 208), new (17, 7, 17), new (0, 8, 104), new (0, 8, 40), new (0, 9, 176), new (0, 8, 8), new (0, 8, 136), new (0, 8, 72), new (0, 9, 240), new (16, 7, 4), new (0, 8, 84), new (0, 8, 20), new (21, 8, 227), new (19, 7, 43), new (0, 8, 116), new (0, 8, 52), new (0, 9, 200), new (17, 7, 13), new (0, 8, 100), new (0, 8, 36), new (0, 9, 168), new (0, 8, 4), new (0, 8, 132), new (0, 8, 68), new (0, 9, 232), new (16, 7, 8), new (0, 8, 92), new (0, 8, 28), new (0, 9, 152), new (20, 7, 83), new (0, 8, 124), new (0, 8, 60), new (0, 9, 216), new (18, 7, 23), new (0, 8, 108), new (0, 8, 44), new (0, 9, 184), new (0, 8, 12), new (0, 8, 140), new (0, 8, 76), new (0, 9, 248), new (16, 7, 3), new (0, 8, 82), new (0, 8, 18), new (21, 8, 163), new (19, 7, 35), new (0, 8, 114), new (0, 8, 50), new (0, 9, 196), new (17, 7, 11), new (0, 8, 98), new (0, 8, 34), new (0, 9, 164), new (0, 8, 2), new (0, 8, 130), new (0, 8, 66), new (0, 9, 228), new (16, 7, 7), new (0, 8, 90), new (0, 8, 26), new (0, 9, 148), new (20, 7, 67), new (0, 8, 122), new (0, 8, 58), new (0, 9, 212), new (18, 7, 19), new (0, 8, 106), new (0, 8, 42), new (0, 9, 180), new (0, 8, 10), new (0, 8, 138), new (0, 8, 74), new (0, 9, 244), new (16, 7, 5), new (0, 8, 86), new (0, 8, 22), new (64, 8, 0), new (19, 7, 51), new (0, 8, 118), new (0, 8, 54), new (0, 9, 204), new (17, 7, 15), new (0, 8, 102), new (0, 8, 38), new (0, 9, 172), new (0, 8, 6), new (0, 8, 134), new (0, 8, 70), new (0, 9, 236), new (16, 7, 9), new (0, 8, 94), new (0, 8, 30), new (0, 9, 156), new (20, 7, 99), new (0, 8, 126), new (0, 8, 62), new (0, 9, 220), new (18, 7, 27), new (0, 8, 110), new (0, 8, 46), new (0, 9, 188), new (0, 8, 14), new (0, 8, 142), new (0, 8, 78), new (0, 9, 252), new (96, 7, 0), new (0, 8, 81), new (0, 8, 17), new (21, 8, 131), new (18, 7, 31), new (0, 8, 113), new (0, 8, 49), new (0, 9, 194), new (16, 7, 10), new (0, 8, 97), new (0, 8, 33), new (0, 9, 162), new (0, 8, 1), new (0, 8, 129), new (0, 8, 65), new (0, 9, 226), new (16, 7, 6), new (0, 8, 89), new (0, 8, 25), new (0, 9, 146), new (19, 7, 59), new (0, 8, 121), new (0, 8, 57), new (0, 9, 210), new (17, 7, 17), new (0, 8, 105), new (0, 8, 41), new (0, 9, 178), new (0, 8, 9), new (0, 8, 137), new (0, 8, 73), new (0, 9, 242), new (16, 7, 4), new (0, 8, 85), new (0, 8, 21), new (16, 8, 258), new (19, 7, 43), new (0, 8, 117), new (0, 8, 53), new (0, 9, 202), new (17, 7, 13), new (0, 8, 101), new (0, 8, 37), new (0, 9, 170), new (0, 8, 5), new (0, 8, 133), new (0, 8, 69), new (0, 9, 234), new (16, 7, 8), new (0, 8, 93), new (0, 8, 29), new (0, 9, 154), new (20, 7, 83), new (0, 8, 125), new (0, 8, 61), new (0, 9, 218), new (18, 7, 23), new (0, 8, 109), new (0, 8, 45), new (0, 9, 186), new (0, 8, 13), new (0, 8, 141), new (0, 8, 77), new (0, 9, 250), new (16, 7, 3), new (0, 8, 83), new (0, 8, 19), new (21, 8, 195), new (19, 7, 35), new (0, 8, 115), new (0, 8, 51), new (0, 9, 198), new (17, 7, 11), new (0, 8, 99), new (0, 8, 35), new (0, 9, 166), new (0, 8, 3), new (0, 8, 131), new (0, 8, 67), new (0, 9, 230), new (16, 7, 7), new (0, 8, 91), new (0, 8, 27), new (0, 9, 150), new (20, 7, 67), new (0, 8, 123), new (0, 8, 59), new (0, 9, 214), new (18, 7, 19), new (0, 8, 107), new (0, 8, 43), new (0, 9, 182), new (0, 8, 11), new (0, 8, 139), new (0, 8, 75), new (0, 9, 246), new (16, 7, 5), new (0, 8, 87), new (0, 8, 23), new (64, 8, 0), new (19, 7, 51), new (0, 8, 119), new (0, 8, 55), new (0, 9, 206), new (17, 7, 15), new (0, 8, 103), new (0, 8, 39), new (0, 9, 174), new (0, 8, 7), new (0, 8, 135), new (0, 8, 71), new (0, 9, 238), new (16, 7, 9), new (0, 8, 95), new (0, 8, 31), new (0, 9, 158), new (20, 7, 99), new (0, 8, 127), new (0, 8, 63), new (0, 9, 222), new (18, 7, 27), new (0, 8, 111), new (0, 8, 47), new (0, 9, 190), new (0, 8, 15), new (0, 8, 143), new (0, 8, 79), new (0, 9, 254), new (96, 7, 0), new (0, 8, 80), new (0, 8, 16), new (20, 8, 115), new (18, 7, 31), new (0, 8, 112), new (0, 8, 48), new (0, 9, 193), new (16, 7, 10), new (0, 8, 96), new (0, 8, 32), new (0, 9, 161), new (0, 8, 0), new (0, 8, 128), new (0, 8, 64), new (0, 9, 225), new (16, 7, 6), new (0, 8, 88), new (0, 8, 24), new (0, 9, 145), new (19, 7, 59), new (0, 8, 120), new (0, 8, 56), new (0, 9, 209), new (17, 7, 17), new (0, 8, 104), new (0, 8, 40), new (0, 9, 177), new (0, 8, 8), new (0, 8, 136), new (0, 8, 72), new (0, 9, 241), new (16, 7, 4), new (0, 8, 84), new (0, 8, 20), new (21, 8, 227), new (19, 7, 43), new (0, 8, 116), new (0, 8, 52), new (0, 9, 201), new (17, 7, 13), new (0, 8, 100), new (0, 8, 36), new (0, 9, 169), new (0, 8, 4), new (0, 8, 132), new (0, 8, 68), new (0, 9, 233), new (16, 7, 8), new (0, 8, 92), new (0, 8, 28), new (0, 9, 153), new (20, 7, 83), new (0, 8, 124), new (0, 8, 60), new (0, 9, 217), new (18, 7, 23), new (0, 8, 108), new (0, 8, 44), new (0, 9, 185), new (0, 8, 12), new (0, 8, 140), new (0, 8, 76), new (0, 9, 249), new (16, 7, 3), new (0, 8, 82), new (0, 8, 18), new (21, 8, 163), new (19, 7, 35), new (0, 8, 114), new (0, 8, 50), new (0, 9, 197), new (17, 7, 11), new (0, 8, 98), new (0, 8, 34), new (0, 9, 165), new (0, 8, 2), new (0, 8, 130), new (0, 8, 66), new (0, 9, 229), new (16, 7, 7), new (0, 8, 90), new (0, 8, 26), new (0, 9, 149), new (20, 7, 67), new (0, 8, 122), new (0, 8, 58), new (0, 9, 213), new (18, 7, 19), new (0, 8, 106), new (0, 8, 42), new (0, 9, 181), new (0, 8, 10), new (0, 8, 138), new (0, 8, 74), new (0, 9, 245), new (16, 7, 5), new (0, 8, 86), new (0, 8, 22), new (64, 8, 0), new (19, 7, 51), new (0, 8, 118), new (0, 8, 54), new (0, 9, 205), new (17, 7, 15), new (0, 8, 102), new (0, 8, 38), new (0, 9, 173), new (0, 8, 6), new (0, 8, 134), new (0, 8, 70), new (0, 9, 237), new (16, 7, 9), new (0, 8, 94), new (0, 8, 30), new (0, 9, 157), new (20, 7, 99), new (0, 8, 126), new (0, 8, 62), new (0, 9, 221), new (18, 7, 27), new (0, 8, 110), new (0, 8, 46), new (0, 9, 189), new (0, 8, 14), new (0, 8, 142), new (0, 8, 78), new (0, 9, 253), new (96, 7, 0), new (0, 8, 81), new (0, 8, 17), new (21, 8, 131), new (18, 7, 31), new (0, 8, 113), new (0, 8, 49), new (0, 9, 195), new (16, 7, 10), new (0, 8, 97), new (0, 8, 33), new (0, 9, 163), new (0, 8, 1), new (0, 8, 129), new (0, 8, 65), new (0, 9, 227), new (16, 7, 6), new (0, 8, 89), new (0, 8, 25), new (0, 9, 147), new (19, 7, 59), new (0, 8, 121), new (0, 8, 57), new (0, 9, 211), new (17, 7, 17), new (0, 8, 105), new (0, 8, 41), new (0, 9, 179), new (0, 8, 9), new (0, 8, 137), new (0, 8, 73), new (0, 9, 243), new (16, 7, 4), new (0, 8, 85), new (0, 8, 21), new (16, 8, 258), new (19, 7, 43), new (0, 8, 117), new (0, 8, 53), new (0, 9, 203), new (17, 7, 13), new (0, 8, 101), new (0, 8, 37), new (0, 9, 171), new (0, 8, 5), new (0, 8, 133), new (0, 8, 69), new (0, 9, 235), new (16, 7, 8), new (0, 8, 93), new (0, 8, 29), new (0, 9, 155), new (20, 7, 83), new (0, 8, 125), new (0, 8, 61), new (0, 9, 219), new (18, 7, 23), new (0, 8, 109), new (0, 8, 45), new (0, 9, 187), new (0, 8, 13), new (0, 8, 141), new (0, 8, 77), new (0, 9, 251), new (16, 7, 3), new (0, 8, 83), new (0, 8, 19), new (21, 8, 195), new (19, 7, 35), new (0, 8, 115), new (0, 8, 51), new (0, 9, 199), new (17, 7, 11), new (0, 8, 99), new (0, 8, 35), new (0, 9, 167), new (0, 8, 3), new (0, 8, 131), new (0, 8, 67), new (0, 9, 231), new (16, 7, 7), new (0, 8, 91), new (0, 8, 27), new (0, 9, 151), new (20, 7, 67), new (0, 8, 123), new (0, 8, 59), new (0, 9, 215), new (18, 7, 19), new (0, 8, 107), new (0, 8, 43), new (0, 9, 183), new (0, 8, 11), new (0, 8, 139), new (0, 8, 75), new (0, 9, 247), new (16, 7, 5), new (0, 8, 87), new (0, 8, 23), new (64, 8, 0), new (19, 7, 51), new (0, 8, 119), new (0, 8, 55), new (0, 9, 207), new (17, 7, 15), new (0, 8, 103), new (0, 8, 39), new (0, 9, 175), new (0, 8, 7), new (0, 8, 135), new (0, 8, 71), new (0, 9, 239), new (16, 7, 9), new (0, 8, 95), new (0, 8, 31), new (0, 9, 159), new (20, 7, 99), new (0, 8, 127), new (0, 8, 63), new (0, 9, 223), new (18, 7, 27), new (0, 8, 111), new (0, 8, 47), new (0, 9, 191), new (0, 8, 15), new (0, 8, 143), new (0, 8, 79), new (0, 9, 255)};
	public static [] distfix = new []{new (16, 5, 1), new (23, 5, 257), new (19, 5, 17), new (27, 5, 4097), new (17, 5, 5), new (25, 5, 1025), new (21, 5, 65), new (29, 5, 16385), new (16, 5, 3), new (24, 5, 513), new (20, 5, 33), new (28, 5, 8193), new (18, 5, 9), new (26, 5, 2049), new (22, 5, 129), new (64, 5, 0), new (16, 5, 2), new (23, 5, 385), new (19, 5, 25), new (27, 5, 6145), new (17, 5, 7), new (25, 5, 1537), new (21, 5, 97), new (29, 5, 24577), new (16, 5, 4), new (24, 5, 769), new (20, 5, 49), new (28, 5, 12289), new (18, 5, 13), new (26, 5, 3073), new (22, 5, 193), new (64, 5, 0)};
	public static  atomic_dec = new ();
	public static  atomic_inc = new ();
	public static  get_global_id = new ();
	public static  get_local_id = new ();
	public static  get_local_size = new ();
	public static SizeT x86_Convert = new SizeT();
	public static SizeT ARM_Convert = new SizeT();
	public static SizeT ARMT_Convert = new SizeT();
	public static SizeT PPC_Convert = new SizeT();
	public static SizeT SPARC_Convert = new SizeT();
	public static SizeT IA64_Convert = new SizeT();
	public static BOOL Func_SetDefaultDllDirectories = new BOOL();
	public static byte g_Dlls = /* DllSecur.c -- DLL loading security
	2018-02-21 : Igor Pavlov : Public domain */"UXTHEME\0USERENV\0SETUPAPI\0APPHELP\0PROPSYS\0DWMAPI\0CRYPTBASE\0OLEACC\0CLBCATQ\0VERSION\0";
	public static byte ST_0000 = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */"Initializing";
	public static byte ST_0001 = "Autotuning";
	public static byte ST_0002 = "Selftest";
	public static byte ST_0003 = "Running";
	public static byte ST_0004 = "Paused";
	public static byte ST_0005 = "Exhausted";
	public static byte ST_0006 = "Cracked";
	public static byte ST_0007 = "Aborted";
	public static byte ST_0008 = "Quit";
	public static byte ST_0009 = "Bypass";
	public static byte ST_0010 = "Aborted (Checkpoint)";
	public static byte ST_0011 = "Aborted (Runtime)";
	public static byte ST_0012 = "Running (Checkpoint Quit requested)";
	public static byte ST_0013 = "Error";
	public static byte ST_9999 = "Unknown! Bug!";
	public static byte[] UNITS = new byte[]{(byte)' ', (byte)'k', (byte)'M', (byte)'G', (byte)'T', (byte)'P', (byte)'E'};
	public static byte ETA_ABSOLUTE_MAX_EXCEEDED = "Next Big Bang";
	public static byte ETA_RELATIVE_MAX_EXCEEDED = "> 10 years";
	public static SRes BraState_SetFromMethod = new SRes();
	public static int gz_load;
	public static int gz_avail;
	public static int gz_look;
	public static int gz_decomp;
	public static int gz_fetch;
	public static int gz_skip;
	public static z_size_t gz_read = new z_size_t();
	public static byte SIGNATURE_SEVEN_ZIP = "$7z$";
	public static byte SIGNATURE_ODF = "$odf$";
	public static byte PA_000 = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */"OK";
	public static byte PA_001 = "Ignored due to comment";
	public static byte PA_002 = "Ignored due to zero length";
	public static byte PA_003 = "Line-length exception";
	public static byte PA_004 = "Hash-length exception";
	public static byte PA_005 = "Hash-value exception";
	public static byte PA_006 = "Salt-length exception";
	public static byte PA_007 = "Salt-value exception";
	public static byte PA_008 = "Salt-iteration count exception";
	public static byte PA_009 = "Separator unmatched";
	public static byte PA_010 = "Signature unmatched";
	public static byte PA_011 = "Invalid hccapx file size";
	public static byte PA_012 = "Invalid hccapx eapol size";
	public static byte PA_013 = "Invalid psafe2 filesize";
	public static byte PA_014 = "Invalid psafe3 filesize";
	public static byte PA_015 = "Invalid truecrypt filesize";
	public static byte PA_016 = "Invalid veracrypt filesize";
	public static byte PA_017 = "Invalid SIP directive, only MD5 is supported";
	public static byte PA_018 = "Hash-file exception";
	public static byte PA_019 = "Hash-encoding exception";
	public static byte PA_020 = "Salt-encoding exception";
	public static byte PA_021 = "Invalid LUKS filesize";
	public static byte PA_022 = "Invalid LUKS identifier";
	public static byte PA_023 = "Invalid LUKS version";
	public static byte PA_024 = "Invalid or unsupported LUKS cipher type";
	public static byte PA_025 = "Invalid or unsupported LUKS cipher mode";
	public static byte PA_026 = "Invalid or unsupported LUKS hash type";
	public static byte PA_027 = "Invalid LUKS key size";
	public static byte PA_028 = "Disabled LUKS key detected";
	public static byte PA_029 = "Invalid LUKS key AF stripes count";
	public static byte PA_030 = "Invalid combination of LUKS hash type and cipher type";
	public static byte PA_031 = "Invalid hccapx signature";
	public static byte PA_032 = "Invalid hccapx version";
	public static byte PA_033 = "Invalid hccapx message pair";
	public static byte PA_034 = "Token encoding exception";
	public static byte PA_035 = "Token length exception";
	public static byte PA_036 = "Insufficient entropy exception";
	public static byte PA_037 = "Hash contains unsupported compression type for current mode";
	public static byte PA_255 = "Unknown error";
	public static byte OPTI_STR_OPTIMIZED_KERNEL = "Optimized-Kernel";
	public static byte OPTI_STR_ZERO_BYTE = "Zero-Byte";
	public static byte OPTI_STR_PRECOMPUTE_INIT = "Precompute-Init";
	public static byte OPTI_STR_MEET_IN_MIDDLE = "Meet-In-The-Middle";
	public static byte OPTI_STR_EARLY_SKIP = "Early-Skip";
	public static byte OPTI_STR_NOT_SALTED = "Not-Salted";
	public static byte OPTI_STR_NOT_ITERATED = "Not-Iterated";
	public static byte OPTI_STR_PREPENDED_SALT = "Prepended-Salt";
	public static byte OPTI_STR_APPENDED_SALT = "Appended-Salt";
	public static byte OPTI_STR_SINGLE_HASH = "Single-Hash";
	public static byte OPTI_STR_SINGLE_SALT = "Single-Salt";
	public static byte OPTI_STR_BRUTE_FORCE = "Brute-Force";
	public static byte OPTI_STR_RAW_HASH = "Raw-Hash";
	public static byte OPTI_STR_SLOW_HASH_SIMD_INIT = "Slow-Hash-SIMD-INIT";
	public static byte OPTI_STR_SLOW_HASH_SIMD_LOOP = "Slow-Hash-SIMD-LOOP";
	public static byte OPTI_STR_SLOW_HASH_SIMD_COMP = "Slow-Hash-SIMD-COMP";
	public static byte OPTI_STR_USES_BITS_8 = "Uses-8-Bit";
	public static byte OPTI_STR_USES_BITS_16 = "Uses-16-Bit";
	public static byte OPTI_STR_USES_BITS_32 = "Uses-32-Bit";
	public static byte OPTI_STR_USES_BITS_64 = "Uses-64-Bit";
	public static byte HASH_CATEGORY_UNDEFINED_STR = "Undefined";
	public static byte HASH_CATEGORY_RAW_HASH_STR = "Raw Hash";
	public static byte HASH_CATEGORY_RAW_HASH_SALTED_STR = "Raw Hash, Salted and/or Iterated";
	public static byte HASH_CATEGORY_RAW_HASH_AUTHENTICATED_STR = "Raw Hash, Authenticated";
	public static byte HASH_CATEGORY_RAW_CIPHER_KPA_STR = "Raw Cipher, Known-Plaintext attack";
	public static byte HASH_CATEGORY_GENERIC_KDF_STR = "Generic KDF";
	public static byte HASH_CATEGORY_NETWORK_PROTOCOL_STR = "Network Protocols";
	public static byte HASH_CATEGORY_FORUM_SOFTWARE_STR = "Forums, CMS, E-Commerce, Frameworks";
	public static byte HASH_CATEGORY_DATABASE_SERVER_STR = "Database Server";
	public static byte HASH_CATEGORY_NETWORK_SERVER_STR = "FTP, HTTP, SMTP, LDAP Server";
	public static byte HASH_CATEGORY_RAW_CHECKSUM_STR = "Raw Checksum";
	public static byte HASH_CATEGORY_OS_STR = "Operating System";
	public static byte HASH_CATEGORY_EAS_STR = "Enterprise Application Software (EAS)";
	public static byte HASH_CATEGORY_ARCHIVE_STR = "Archives";
	public static byte HASH_CATEGORY_FDE_STR = "Full-Disk Encryption (FDE)";
	public static byte HASH_CATEGORY_DOCUMENTS_STR = "Documents";
	public static byte HASH_CATEGORY_PASSWORD_MANAGER_STR = "Password Managers";
	public static byte HASH_CATEGORY_OTP_STR = "One-Time Passwords";
	public static byte HASH_CATEGORY_PLAIN_STR = "Plaintext";
	public static byte HASH_CATEGORY_FRAMEWORK_STR = "Framework";
	public static Object Buf_Init;
	public static int Buf_Create;
	public static Object Buf_Free;
	public static Object DynBuf_Construct;
	public static Object DynBuf_SeekToBeg;
	public static int DynBuf_Write;
	public static Object DynBuf_Free;
	public static Object streebog512_add;
	public static Object streebog512_transform;
	public static Object streebog512_update_64;
	public static Object streebog512_update;
	public static Object streebog512_update_swap;
	public static Object streebog512_final;
	public static Object streebog512_hmac_update_64;
	public static Object streebog512_hmac_update;
	public static Object streebog512_hmac_update_swap;
	public static Object streebog512_hmac_final;
	public static Object streebog512_add_vector;
	public static Object streebog512_transform_vector;
	public static Object streebog512_update_vector_64;
	public static Object streebog512_update_vector;
	public static Object streebog512_update_vector_swap;
	public static Object streebog512_final_vector;
	public static Object streebog512_hmac_update_vector;
	public static Object streebog512_hmac_update_vector_swap;
	public static Object streebog512_hmac_final_vector;
	public static Object ESSIV_sha256_transform_S;
	public static Object ESSIV_sha256_init128;
	public static Object ESSIV_sha256_init256;
	public static byte SIGNATURE_NETBSD_SHA1CRYPT = "$sha1$";
	public static int debugfile_init;
	public static Object debugfile_destroy;
	public static Object debugfile_write_append;
	public static byte SIGNATURE_OLDOFFICE0 = "$oldoffice$0";
	public static byte SIGNATURE_OLDOFFICE1 = "$oldoffice$1";
	public static u32 ROUNDS_MD5CRYPT = 1000;
	public static byte SIGNATURE_MD5CRYPT = "$1$";
	public static int ROUNDS_ORACLET = 4096;
	public static byte SIGNATURE_TACACS_PLUS = "$tacacs-plus$0$";
	public static byte SIGNATURE_OFFICE2007 = "$office$";
	public static int ROUNDS_OFFICE2007 = 50000;
	public static uLong adler32_combine_ = new uLong();
	public static byte SIGNATURE_FORTIGATE = "AK1";
	public static int bitmap_ctx_init;
	public static Object bitmap_ctx_destroy;
	public static byte DEF_MASK = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */"?1?2?2?2?2?2?2?3?3?3?3?d?d?d?d";
	public static SRes LzmaEnc_PrepareForLzma2 = new SRes();
	public static SRes LzmaEnc_MemPrepare = new SRes();
	public static SRes LzmaEnc_CodeOneMemBlock = new SRes();
	public static Byte LzmaEnc_GetCurBuf = new Byte();
	public static Object LzmaEnc_Finish;
	public static Object LzmaEnc_SaveState;
	public static Object LzmaEnc_RestoreState;
	public static int ROUNDS_ANDROIDFDE_SAMSUNG = 4096;
	public static byte SIGNATURE_SHA512B64S = "{SSHA512}";
	public static byte SIGNATURE_CHACHA20 = "$chacha20$";
	public static Object LzmaEncProps_Init;
	public static Object LzmaEncProps_Normalize;
	public static UInt32 LzmaEncProps_GetDictSize = new UInt32();
	public static Object CLzmaEncHandle;
	public static CLzmaEncHandle LzmaEnc_Create = new CLzmaEncHandle();
	public static Object LzmaEnc_Destroy;
	public static SRes LzmaEnc_SetProps = new SRes();
	public static Object LzmaEnc_SetDataSize;
	public static SRes LzmaEnc_WriteProperties = new SRes();
	public static int LzmaEnc_IsWriteEndMark;
	public static SRes LzmaEnc_Encode = new SRes();
	public static SRes LzmaEnc_MemEncode = new SRes();
	public static SRes LzmaEncode = new SRes();
	public static byte SIGNATURE_ANSIBLE_VAULT = "$ansible$";
	public static int ROUNDS_ANSIBLE_VAULT = 10000;
	public static byte SIGNATURE_ETHEREUM_PRESALE = "$ethereum$w";
	public static int ROUNDS_ETHEREUM_PRESALE = 2000;
	public static Object CLeglImageKHR;
	public static Object CLeglDisplayKHR;
	public static Object CLeglSyncKHR;
	public static  cl_egl_image_properties_khr = new ();
	public static Object MtProgress_Init;
	public static SRes MtProgress_Progress_ST = new SRes();
	public static SRes MtProgress_ProgressAdd = new SRes();
	public static SRes MtProgress_GetError = new SRes();
	public static Object MtProgress_SetError;
	public static Object MtDecThread_FreeInBufs;
	public static Object MtDec_Construct;
	public static Object MtDec_Destruct;
	public static SRes MtDec_Code = new SRes();
	public static Byte MtDec_GetCrossBuff = new Byte();
	public static int MtDec_PrepareRead;
	public static Byte MtDec_Read = new Byte();
	public static byte SIGNATURE_FILEVAULT2 = "$fvde$";
	public static int potfile_init;
	public static int potfile_read_open;
	public static Object potfile_read_close;
	public static int potfile_write_open;
	public static Object potfile_write_close;
	public static Object potfile_write_append;
	public static int potfile_remove_parse;
	public static Object potfile_destroy;
	public static int potfile_handle_show;
	public static int potfile_handle_left;
	public static Object potfile_update_hash;
	public static Object potfile_update_hashes;
	public static Object pot_tree_destroy;
	public static int sort_pot_tree_by_hash;
	public static Object serpent256_decrypt_xts_first;
	public static Object serpent256_decrypt_xts_next;
	public static Object twofish256_decrypt_xts_first;
	public static Object twofish256_decrypt_xts_next;
	public static uint8_t BYTE = new uint8_t();
	public static uint16_t U16 = new uint16_t();
	public static uint32_t U32 = new uint32_t();
	public static int32_t S32 = new int32_t();
	public static uint64_t U64 = new uint64_t();
	public static int g_nbBits = (int)( * 8);
	public static byte[] g_lename = "little endian";
	public static byte[] g_bename = "big endian";
	public static byte[] author = "Yann Collet";
	public static size_t XXH_DEFAULT_SAMPLE_SIZE = 100 * (1 << 10/* Default number of benchmark iterations *//* Minimum timing per iteration *//* Default seed for algo_xxh32 */);
	public static byte[] stdinName = /* Default seed for algo_xxh64 */"-";
	public static algoType g_defaultAlgo = /* required within main() & usage() */.algo_xxh64/* <16 hex char> <SPC> <SPC> <filename> <'\0'>
	 * '4096' is typical Linux PATH_MAX configuration. *//* Maximum acceptable line length. */;
	public static int g_displayLevel = /* ************************************
	 *  Display macros
	 **************************************/2;
	public static U32 g_nbIterations = /* ************************************
	 *  Local variables
	 **************************************/3/* ************************************
	 *  Benchmark Functions
	 **************************************/;
	public static U32 hashFunction = new U32();
	public static int hc_lockfile;
	public static int hc_unlockfile;
	public static byte SIGNATURE_SYBASEASE = "0xc007";
	public static int MODULE_INTERFACE_VERSION_MINIMUM = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */520;
	public static int MODULE_HASH_MODES_MAXIMUM = 100000/**
	 * output functions
	 */;
	public static int module_filename;
	public static  module_load = new ();
	public static Object module_unload;
	public static int hashconfig_init;
	public static Object hashconfig_destroy;
	public static int CUdeviceptr;
	public static int CUdevice;
	public static CUctx_st CUcontext = new CUctx_st();
	public static CUevent_st CUevent = new CUevent_st();
	public static CUfunc_st CUfunction = new CUfunc_st();
	public static CUmod_st CUmodule = new CUmod_st();
	public static CUstream_st CUstream = new CUstream_st();
	public static CUresult CUDA_CUCTXCREATE = new CUresult();
	public static CUresult CUDA_CUCTXDESTROY = new CUresult();
	public static CUresult CUDA_CUCTXGETCACHECONFIG = new CUresult();
	public static CUresult CUDA_CUCTXGETCURRENT = new CUresult();
	public static CUresult CUDA_CUCTXGETSHAREDMEMCONFIG = new CUresult();
	public static CUresult CUDA_CUCTXPOPCURRENT = new CUresult();
	public static CUresult CUDA_CUCTXPUSHCURRENT = new CUresult();
	public static CUresult CUDA_CUCTXSETCACHECONFIG = new CUresult();
	public static CUresult CUDA_CUCTXSETCURRENT = new CUresult();
	public static CUresult CUDA_CUCTXSETSHAREDMEMCONFIG = new CUresult();
	public static CUresult CUDA_CUCTXSYNCHRONIZE = new CUresult();
	public static CUresult CUDA_CUDEVICEGETATTRIBUTE = new CUresult();
	public static CUresult CUDA_CUDEVICEGETCOUNT = new CUresult();
	public static CUresult CUDA_CUDEVICEGET = new CUresult();
	public static CUresult CUDA_CUDEVICEGETNAME = new CUresult();
	public static CUresult CUDA_CUDEVICETOTALMEM = new CUresult();
	public static CUresult CUDA_CUDRIVERGETVERSION = new CUresult();
	public static CUresult CUDA_CUEVENTCREATE = new CUresult();
	public static CUresult CUDA_CUEVENTDESTROY = new CUresult();
	public static CUresult CUDA_CUEVENTELAPSEDTIME = new CUresult();
	public static CUresult CUDA_CUEVENTQUERY = new CUresult();
	public static CUresult CUDA_CUEVENTRECORD = new CUresult();
	public static CUresult CUDA_CUEVENTSYNCHRONIZE = new CUresult();
	public static CUresult CUDA_CUFUNCGETATTRIBUTE = new CUresult();
	public static CUresult CUDA_CUFUNCSETATTRIBUTE = new CUresult();
	public static CUresult CUDA_CUFUNCSETCACHECONFIG = new CUresult();
	public static CUresult CUDA_CUFUNCSETSHAREDMEMCONFIG = new CUresult();
	public static CUresult CUDA_CUGETERRORNAME = new CUresult();
	public static CUresult CUDA_CUGETERRORSTRING = new CUresult();
	public static CUresult CUDA_CUINIT = new CUresult();
	public static CUresult CUDA_CULAUNCHKERNEL = new CUresult();
	public static CUresult CUDA_CUMEMALLOC = new CUresult();
	public static CUresult CUDA_CUMEMALLOCHOST = new CUresult();
	public static CUresult CUDA_CUMEMCPYDTOD = new CUresult();
	public static CUresult CUDA_CUMEMCPYDTOH = new CUresult();
	public static CUresult CUDA_CUMEMCPYHTOD = new CUresult();
	public static CUresult CUDA_CUMEMFREE = new CUresult();
	public static CUresult CUDA_CUMEMFREEHOST = new CUresult();
	public static CUresult CUDA_CUMEMGETINFO = new CUresult();
	public static CUresult CUDA_CUMEMSETD32 = new CUresult();
	public static CUresult CUDA_CUMEMSETD8 = new CUresult();
	public static CUresult CUDA_CUMODULEGETFUNCTION = new CUresult();
	public static CUresult CUDA_CUMODULEGETGLOBAL = new CUresult();
	public static CUresult CUDA_CUMODULELOAD = new CUresult();
	public static CUresult CUDA_CUMODULELOADDATA = new CUresult();
	public static CUresult CUDA_CUMODULELOADDATAEX = new CUresult();
	public static CUresult CUDA_CUMODULEUNLOAD = new CUresult();
	public static CUresult CUDA_CUPROFILERSTART = new CUresult();
	public static CUresult CUDA_CUPROFILERSTOP = new CUresult();
	public static CUresult CUDA_CUSTREAMCREATE = new CUresult();
	public static CUresult CUDA_CUSTREAMDESTROY = new CUresult();
	public static CUresult CUDA_CUSTREAMSYNCHRONIZE = new CUresult();
	public static CUresult CUDA_CUSTREAMWAITEVENT = new CUresult();
	public static hc_cuda_lib_t CUDA_PTR = new hc_cuda_lib_t();
	public static Object AesCbc_Encode;
	public static Object AesCbc_Decode;
	public static Object AesCtr_Code;
	public static int straight_ctx_update_loop;
	public static int straight_ctx_init;
	public static Object straight_ctx_destroy;
	public static voidp zipFile = new voidp();
	public static byte zipcharpc;
	public static zipFile zipOpen = new zipFile();
	public static zipFile zipOpen64 = new zipFile();
	public static zipFile zipOpen2 = new zipFile();
	public static zipFile zipOpen2_64 = new zipFile();
	public static int zipOpenNewFileInZip;
	public static int zipOpenNewFileInZip64;
	public static int zipOpenNewFileInZip2;
	public static int zipOpenNewFileInZip2_64;
	public static int zipOpenNewFileInZip3;
	public static int zipOpenNewFileInZip3_64;
	public static int zipOpenNewFileInZip4;
	public static int zipOpenNewFileInZip4_64;
	public static int zipWriteInFileInZip;
	public static int zipCloseFileInZip;
	public static int zipCloseFileInZipRaw;
	public static int zipCloseFileInZipRaw64;
	public static int zipClose;
	public static int zipRemoveExtraInfoBlock;
	public static Object serpent128_decrypt_cbc;
	public static Object serpent256_decrypt_cbc;
	public static Object serpent128_decrypt_xts;
	public static Object serpent256_decrypt_xts;
	public static  mp_get_length = new ();
	public static Object sp_exec;
	public static int mask_ctx_update_loop;
	public static int mask_ctx_init;
	public static Object mask_ctx_destroy;
	public static int mask_ctx_parse_maskfile;
	public static byte SIGNATURE_SCRYPT = "SCRYPT";
	public static byte SIGNATURE_ANDROID_BACKUP = "$ab$";
	public static byte adm = ":Administration Tools:";
	public static Object sha512_transform;
	public static Object sha512_init;
	public static Object sha512_update_128;
	public static Object sha512_update;
	public static Object sha512_update_swap;
	public static Object sha512_update_utf16le;
	public static Object sha512_update_utf16le_swap;
	public static Object sha512_final;
	public static Object sha512_hmac_init_128;
	public static Object sha512_hmac_init;
	public static Object sha512_hmac_init_swap;
	public static Object sha512_hmac_update_128;
	public static Object sha512_hmac_update;
	public static Object sha512_hmac_update_swap;
	public static Object sha512_hmac_update_utf16le;
	public static Object sha512_hmac_update_utf16le_swap;
	public static Object sha512_hmac_final;
	public static Object sha512_transform_vector;
	public static Object sha512_init_vector;
	public static Object sha512_init_vector_from_scalar;
	public static Object sha512_update_vector_128;
	public static Object sha512_update_vector;
	public static Object sha512_update_vector_swap;
	public static Object sha512_update_vector_utf16le;
	public static Object sha512_update_vector_utf16le_swap;
	public static Object sha512_update_vector_utf16beN;
	public static Object sha512_final_vector;
	public static Object sha512_hmac_init_vector_128;
	public static Object sha512_hmac_init_vector;
	public static Object sha512_hmac_update_vector_128;
	public static Object sha512_hmac_update_vector;
	public static Object sha512_hmac_final_vector;
	public static Object welcome_screen;
	public static Object goodbye_screen;
	public static int setup_console;
	public static Object send_prompt;
	public static Object clear_prompt;
	public static Object thread_keypress;
	public static int tty_break;
	public static int tty_getchar;
	public static int tty_fix;
	public static Object compress_terminal_line_length;
	public static Object example_hashes;
	public static Object backend_info;
	public static Object backend_info_compact;
	public static Object status_progress_machine_readable;
	public static Object status_progress;
	public static Object status_speed_machine_readable;
	public static Object status_speed;
	public static Object status_display_machine_readable;
	public static Object status_display;
	public static Object status_benchmark_machine_readable;
	public static Object status_benchmark;
	public static byte SIGNATURE_PBKDF2_MD5 = "md5";
	public static int NvU32;
	public static int NvS32;
	public static NvPhysicalGpuHandle__ NvPhysicalGpuHandle = new NvPhysicalGpuHandle__();
	public static byte[] NvAPI_String = new byte[4096];
	public static byte[] NvAPI_LongString = new byte[256];
	public static byte[] NvAPI_ShortString = new byte[64];
	public static NvAPI_Status NvAPI_QueryInterface = new NvAPI_Status();
	public static NvAPI_Status NvAPI_Initialize = new NvAPI_Status();
	public static NvAPI_Status NvAPI_Unload = new NvAPI_Status();
	public static NvAPI_Status NvAPI_GetErrorMessage = new NvAPI_Status();
	public static NvAPI_Status NvAPI_EnumPhysicalGPUs = new NvAPI_Status();
	public static NvAPI_Status NvAPI_GPU_GetPerfPoliciesInfo = new NvAPI_Status();
	public static NvAPI_Status NvAPI_GPU_GetPerfPoliciesStatus = new NvAPI_Status();
	public static NvAPI_Status NvAPI_GPU_GetBusId = new NvAPI_Status();
	public static NvAPI_Status NvAPI_GPU_GetBusSlotId = new NvAPI_Status();
	public static NvPhysicalGpuHandle HM_ADAPTER_NVAPI = new NvPhysicalGpuHandle();
	public static int NVAPI_QUERYINTERFACE;
	public static int NVAPI_INITIALIZE;
	public static int NVAPI_UNLOAD;
	public static int NVAPI_GETERRORMESSAGE;
	public static int NVAPI_ENUMPHYSICALGPUS;
	public static int NVAPI_GPU_GETPERFPOLICIESINFO;
	public static int NVAPI_GPU_GETPERFPOLICIESSTATUS;
	public static int NVAPI_GPU_GETBUSID;
	public static int NVAPI_GPU_GETBUSSLOTID;
	public static hm_nvapi_lib_t NVAPI_PTR = new hm_nvapi_lib_t();
	public static Object MyCPUID;
	public static BoolInt x86cpuid_CheckAndRead = new BoolInt();
	public static int x86cpuid_GetFirm;
	public static BoolInt CPU_Is_InOrder = new BoolInt();
	public static BoolInt CPU_Is_Aes_Supported = new BoolInt();
	public static BoolInt CPU_IsSupported_PageGB = new BoolInt();
	public static Object dcrp_xts_mul2;
	public static Object dcrp_serpent256_decrypt_xts;
	public static Object dcrp_twofish256_decrypt_xts;
	public static _cl_accelerator_intel cl_accelerator_intel = new _cl_accelerator_intel();
	public static  cl_accelerator_type_intel = new ();
	public static  cl_accelerator_info_intel = new ();
	public static  cl_diagnostics_verbose_level = new ();
	public static int pidfile_ctx_init;
	public static Object pidfile_ctx_destroy;
	public static Object Bcj2Dec_Init;
	public static SRes Bcj2Dec_Decode = new SRes();
	public static Object Bcj2Enc_Init;
	public static Object Bcj2Enc_Encode;
	public static SRes LzmaProps_Decode = new SRes();
	public static Object LzmaDec_Init;
	public static SRes LzmaDec_AllocateProbs = new SRes();
	public static Object LzmaDec_FreeProbs;
	public static SRes LzmaDec_Allocate = new SRes();
	public static Object LzmaDec_Free;
	public static SRes LzmaDec_DecodeToDic = new SRes();
	public static SRes LzmaDec_DecodeToBuf = new SRes();
	public static SRes LzmaDecode = new SRes();
	public static UInt32 Mf_Mix_Matches = new UInt32();
	public static Object Mf_GetHeads;
	public static Object MatchFinderMt_Construct;
	public static Object MatchFinderMt_Destruct;
	public static SRes MatchFinderMt_Create = new SRes();
	public static Object MatchFinderMt_CreateVTable;
	public static Object MatchFinderMt_ReleaseStream;
	public static Object ADL_MAIN_MALLOC_CALLBACK;
	public static int HM_ADAPTER_ADL;
	public static int ADL_MAIN_CONTROL_DESTROY;
	public static int ADL_MAIN_CONTROL_CREATE;
	public static int ADL_ADAPTER_NUMBEROFADAPTERS_GET;
	public static int ADL_ADAPTER_ADAPTERINFO_GET;
	public static int ADL_DISPLAY_DISPLAYINFO_GET;
	public static int ADL_OVERDRIVE5_TEMPERATURE_GET;
	public static int ADL_OVERDRIVE6_TEMPERATURE_GET;
	public static int ADL_OVERDRIVE5_CURRENTACTIVITY_GET;
	public static int ADL_OVERDRIVE5_THERMALDEVICES_ENUM;
	public static int ADL_ADAPTER_ID_GET;
	public static int ADL_ADAPTER_VIDEOBIOSINFO_GET;
	public static int ADL_OVERDRIVE5_FANSPEEDINFO_GET;
	public static int ADL_OVERDRIVE5_FANSPEED_GET;
	public static int ADL_OVERDRIVE6_FANSPEED_GET;
	public static int ADL_OVERDRIVE5_ODPARAMETERS_GET;
	public static int ADL_OVERDRIVE5_ODPERFORMANCELEVELS_GET;
	public static int ADL_ADAPTER_ACTIVE_GET;
	public static int ADL_OVERDRIVE_CAPS;
	public static int ADL_OVERDRIVE6_CURRENTSTATUS_GET;
	public static int ADL_OVERDRIVE6_STATEINFO_GET;
	public static int ADL_OVERDRIVE6_CAPABILITIES_GET;
	public static int ADL_OVERDRIVE6_TARGETTEMPERATUREDATA_GET;
	public static int ADL_OVERDRIVE6_TARGETTEMPERATURERANGEINFO_GET;
	public static hm_adl_lib_t ADL_PTR = new hm_adl_lib_t();
	public static byte[] unz_copyright = /* unzip.c -- IO for uncompress .zip files using zlib
	   Version 1.1, February 14h, 2010
	   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
	
	         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
	
	         Modifications of Unzip for Zip64
	         Copyright (C) 2007-2008 Even Rouault
	
	         Modifications for Zip64 support on both zip and unzip
	         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
	
	         For more info read MiniZip_info.txt
	
	
	  ------------------------------------------------------------------------------------
	  Decryption code comes from crypt.c by Info-ZIP but has been greatly reduced in terms of
	  compatibility with older software. The following is from the original crypt.c.
	  Code woven in by Terry Thorsen 1/2003.
	
	  Copyright (c) 1990-2000 Info-ZIP.  All rights reserved.
	
	  See the accompanying file LICENSE, version 2000-Apr-09 or later
	  (the contents of which are also included in zip.h) for terms of use.
	  If, for some reason, all these files are missing, the Info-ZIP license
	  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html
	
	        crypt.c (full version) by Info-ZIP.      Last revised:  [see crypt.h]
	
	  The encryption/decryption parts of this source code (as opposed to the
	  non-echoing password parts) were originally written in Europe.  The
	  whole source package can be freely distributed, including from the USA.
	  (Prior to January 2000, re-export from the US was a violation of US law.)
	
	        This encryption code is a direct transcription of the algorithm from
	  Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
	  file (appnote.txt) is distributed with the PKZIP program (even in the
	  version without encryption capabilities).
	
	        ------------------------------------------------------------------------------------
	
	        Changes in unzip.c
	
	        2007-2008 - Even Rouault - Addition of cpl_unzGetCurrentFileZStreamPos
	  2007-2008 - Even Rouault - Decoration of symbol names unz* -> cpl_unz*
	  2007-2008 - Even Rouault - Remove old C style function prototypes
	  2007-2008 - Even Rouault - Add unzip support for ZIP64
	
	        Copyright (C) 2007-2008 Even Rouault
	
	
	        Oct-2009 - Mathias Svensson - Removed cpl_* from symbol names (Even Rouault added them but since this is now moved to a new project (minizip64) I renamed them again).
	  Oct-2009 - Mathias Svensson - Fixed problem if uncompressed size was > 4G and compressed size was <4G
	                                should only read the compressed/uncompressed size from the Zip64 format if
	                                the size from normal header was 0xFFFFFFFF
	  Oct-2009 - Mathias Svensson - Applied some bug fixes from paches recived from Gilles Vollant
	        Oct-2009 - Mathias Svensson - Applied support to unzip files with compression mathod BZIP2 (bzip2 lib is required)
	                                Patch created by Daniel Borca
	
	  Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer
	
	  Copyright (C) 1998 - 2010 Gilles Vollant, Even Rouault, Mathias Svensson
	
	*//* compile with -Dlocal if your debugger can't find static symbols */" unzip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
	public static int unz64local_getByte;
	public static int unz64local_getShort;
	public static int unz64local_getLong;
	public static int unz64local_getLong64;
	public static ZPOS64_T unz64local_SearchCentralDir = new ZPOS64_T();
	public static ZPOS64_T unz64local_SearchCentralDir64 = new ZPOS64_T();
	public static int unz64local_GetCurrentFileInfoInternal;
	public static byte SIGNATURE_BITCOIN_WALLET = "$bitcoin$";
	public static byte[] grp_op_nop = new byte[]{/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */rule_functions.RULE_OP_MANGLE_LREST, rule_functions.RULE_OP_MANGLE_UREST, rule_functions.RULE_OP_MANGLE_LREST_UFIRST, rule_functions.RULE_OP_MANGLE_UREST_LFIRST, rule_functions.RULE_OP_MANGLE_TREST, rule_functions.RULE_OP_MANGLE_REVERSE, rule_functions.RULE_OP_MANGLE_DUPEWORD, rule_functions.RULE_OP_MANGLE_REFLECT, rule_functions.RULE_OP_MANGLE_DELETE_FIRST, rule_functions.RULE_OP_MANGLE_DELETE_LAST, rule_functions.RULE_OP_MANGLE_ROTATE_LEFT, rule_functions.RULE_OP_MANGLE_ROTATE_RIGHT, rule_functions.RULE_OP_MANGLE_SWITCH_FIRST, rule_functions.RULE_OP_MANGLE_SWITCH_LAST, rule_functions.RULE_OP_MANGLE_DUPECHAR_ALL, rule_functions.RULE_OP_MANGLE_TITLE};
	public static byte[] grp_op_pos_p0 = new byte[]{rule_functions.RULE_OP_MANGLE_TOGGLE_AT, rule_functions.RULE_OP_MANGLE_DELETE_AT, rule_functions.RULE_OP_MANGLE_TRUNCATE_AT, rule_functions.RULE_OP_MANGLE_CHR_INCR, rule_functions.RULE_OP_MANGLE_CHR_DECR, rule_functions.RULE_OP_MANGLE_CHR_SHIFTL, rule_functions.RULE_OP_MANGLE_CHR_SHIFTR, rule_functions.RULE_OP_MANGLE_REPLACE_NP1, rule_functions.RULE_OP_MANGLE_REPLACE_NM1};
	public static byte[] grp_op_pos_p1 = new byte[]{rule_functions.RULE_OP_MANGLE_DUPEWORD_TIMES, rule_functions.RULE_OP_MANGLE_DUPECHAR_FIRST, rule_functions.RULE_OP_MANGLE_DUPECHAR_LAST, rule_functions.RULE_OP_MANGLE_DUPEBLOCK_FIRST, rule_functions.RULE_OP_MANGLE_DUPEBLOCK_LAST};
	public static byte[] grp_op_chr = new byte[]{rule_functions.RULE_OP_MANGLE_APPEND, rule_functions.RULE_OP_MANGLE_PREPEND, rule_functions.RULE_OP_MANGLE_PURGECHAR, rule_functions.RULE_OP_MANGLE_TITLE_SEP};
	public static byte[] grp_op_chr_chr = new byte[]{rule_functions.RULE_OP_MANGLE_REPLACE};
	public static byte[] grp_op_pos_chr = new byte[]{rule_functions.RULE_OP_MANGLE_INSERT, rule_functions.RULE_OP_MANGLE_OVERSTRIKE};
	public static byte[] grp_op_pos_pos0 = new byte[]{rule_functions.RULE_OP_MANGLE_SWITCH_AT};
	public static byte[] grp_op_pos_pos1 = new byte[]{rule_functions.RULE_OP_MANGLE_EXTRACT, rule_functions.RULE_OP_MANGLE_OMIT};
	public static byte[] grp_pos = new byte[]{(byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'A', (byte)'B'};
	public static Object hccalloc;
	public static Object hcmalloc;
	public static Object hcrealloc;
	public static byte hcstrdup;
	public static Object hcfree;
	public static Object SzAlloc;
	public static Object SzFree;
	public static Object SzAllocTemp;
	public static Object SzFreeTemp;
	public static Object AesGenTables;
	public static Object AES_SET_KEY_FUNC;
	public static Object Aes_SetKey_Enc;
	public static Object Aes_SetKey_Dec;
	public static Object AesCbc_Init;
	public static Object AES_CODE_FUNC;
	public static AES_CODE_FUNC g_AesCbc_Encode = new AES_CODE_FUNC();
	public static AES_CODE_FUNC g_AesCbc_Decode = new AES_CODE_FUNC();
	public static AES_CODE_FUNC g_AesCtr_Code = new AES_CODE_FUNC();
	public static int puff;
	public static Object serpent128_set_key;
	public static Object serpent128_encrypt;
	public static Object serpent128_decrypt;
	public static Object serpent256_set_key;
	public static Object serpent256_encrypt;
	public static Object serpent256_decrypt;
	public static byte SIGNATURE_PBKDF2_SHA256 = "sha256";
	public static byte SIGNATURE_RACF = "$racf$";
	public static byte SIGNATURE_SHA1AIX = "{ssha1}";
	public static byte strhlfmt;
	public static Object hlfmt_hash;
	public static Object hlfmt_user;
	public static  hlfmt_detect = new ();
	public static byte SIGNATURE_MSSQL2012 = "0x0200";
	public static Object sha224_transform;
	public static Object sha224_init;
	public static Object sha224_update_64;
	public static Object sha224_update;
	public static Object sha224_update_swap;
	public static Object sha224_update_utf16le;
	public static Object sha224_update_utf16le_swap;
	public static Object sha224_final;
	public static Object sha224_hmac_init_64;
	public static Object sha224_hmac_init;
	public static Object sha224_hmac_init_swap;
	public static Object sha224_hmac_update_64;
	public static Object sha224_hmac_update;
	public static Object sha224_hmac_update_swap;
	public static Object sha224_hmac_update_utf16le;
	public static Object sha224_hmac_update_utf16le_swap;
	public static Object sha224_hmac_final;
	public static Object sha224_transform_vector;
	public static Object sha224_init_vector;
	public static Object sha224_init_vector_from_scalar;
	public static Object sha224_update_vector_64;
	public static Object sha224_update_vector;
	public static Object sha224_update_vector_swap;
	public static Object sha224_update_vector_utf16le;
	public static Object sha224_update_vector_utf16le_swap;
	public static Object sha224_update_vector_utf16beN;
	public static Object sha224_final_vector;
	public static Object sha224_hmac_init_vector_64;
	public static Object sha224_hmac_init_vector;
	public static Object sha224_hmac_update_vector_64;
	public static Object sha224_hmac_update_vector;
	public static Object sha224_hmac_final_vector;
	public static byte[] LOOPBACK_FILE = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */"hashcat.loopback";
	public static int loopback_init;
	public static Object loopback_destroy;
	public static int loopback_write_open;
	public static Object loopback_write_close;
	public static Object loopback_write_append;
	public static Object loopback_write_unlink;
	public static u32 ROUNDS_SHA256CRYPT = 5000;
	public static byte SIGNATURE_SHA256CRYPT = "$5$";
	public static UInt32[] T = new UInt32();
	public static Byte[] Sbox = new Byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static Object AesCbc_Encode_Intel;
	public static Object AesCbc_Decode_Intel;
	public static Object AesCtr_Code_Intel;
	public static UInt32[] D = new UInt32();
	public static Byte[] InvS = new Byte();
	public static Byte[] Rcon = new Byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static int _old_apply_rule;
	public static int run_rule_engine;
	public static int hm_get_threshold_slowdown_with_devices_idx;
	public static int hm_get_threshold_shutdown_with_devices_idx;
	public static int hm_get_temperature_with_devices_idx;
	public static int hm_get_fanpolicy_with_devices_idx;
	public static int hm_get_fanspeed_with_devices_idx;
	public static int hm_get_buslanes_with_devices_idx;
	public static int hm_get_utilization_with_devices_idx;
	public static int hm_get_memoryspeed_with_devices_idx;
	public static int hm_get_corespeed_with_devices_idx;
	public static int hm_get_throttle_with_devices_idx;
	public static int hwmon_ctx_init;
	public static Object hwmon_ctx_destroy;
	public static static_tree_desc_s static_tree_desc = new static_tree_desc_s();
	public static ush Pos = new ush();
	public static Pos Posf = new Pos();
	public static int IPos;
	public static Object _tr_init;
	public static int _tr_tally;
	public static Object _tr_flush_block;
	public static Object _tr_flush_bits;
	public static Object _tr_align;
	public static Object _tr_stored_block;
	public static uch[] _length_code = new uch();
	public static uch[] _dist_code = new uch();
	public static byte SIGNATURE_KRB5ASREP = "$krb5asrep$23$";
	public static Object streebog256_add;
	public static Object streebog256_transform;
	public static Object streebog256_update_64;
	public static Object streebog256_update;
	public static Object streebog256_update_swap;
	public static Object streebog256_final;
	public static Object streebog256_hmac_update_64;
	public static Object streebog256_hmac_update;
	public static Object streebog256_hmac_update_swap;
	public static Object streebog256_hmac_final;
	public static Object streebog256_add_vector;
	public static Object streebog256_transform_vector;
	public static Object streebog256_update_vector_64;
	public static Object streebog256_update_vector;
	public static Object streebog256_update_vector_swap;
	public static Object streebog256_final_vector;
	public static Object streebog256_hmac_update_vector;
	public static Object streebog256_hmac_update_vector_swap;
	public static Object streebog256_hmac_final_vector;
	public static Object thread_selftest;
	public static Object logfile_generate_topid;
	public static Object logfile_generate_subid;
	public static Object logfile_append;
	public static int logfile_init;
	public static Object logfile_destroy;
	public static byte[] CL_VENDOR_AMD1 = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */"Advanced Micro Devices, Inc.";
	public static byte[] CL_VENDOR_AMD2 = "AuthenticAMD";
	public static byte[] CL_VENDOR_AMD_USE_INTEL = "GenuineIntel";
	public static byte[] CL_VENDOR_APPLE = "Apple";
	public static byte[] CL_VENDOR_APPLE_USE_AMD = "AMD";
	public static byte[] CL_VENDOR_APPLE_USE_NV = "NVIDIA";
	public static byte[] CL_VENDOR_APPLE_USE_INTEL = "Intel Inc.";
	public static byte[] CL_VENDOR_INTEL_BEIGNET = "Intel";
	public static byte[] CL_VENDOR_INTEL_SDK = "Intel(R) Corporation";
	public static byte[] CL_VENDOR_MESA = "Mesa";
	public static byte[] CL_VENDOR_NV = "NVIDIA Corporation";
	public static byte[] CL_VENDOR_POCL = "The pocl project";
	public static int cuda_init;
	public static Object cuda_close;
	public static int nvrtc_init;
	public static Object nvrtc_close;
	public static int ocl_init;
	public static Object ocl_close;
	public static int hc_nvrtcCreateProgram;
	public static int hc_nvrtcDestroyProgram;
	public static int hc_nvrtcCompileProgram;
	public static int hc_nvrtcGetProgramLogSize;
	public static int hc_nvrtcGetProgramLog;
	public static int hc_nvrtcGetPTXSize;
	public static int hc_nvrtcGetPTX;
	public static int hc_nvrtcVersion;
	public static int hc_cuCtxCreate;
	public static int hc_cuCtxDestroy;
	public static int hc_cuCtxSetCurrent;
	public static int hc_cuCtxSetCacheConfig;
	public static int hc_cuCtxSynchronize;
	public static int hc_cuDeviceGetAttribute;
	public static int hc_cuDeviceGetCount;
	public static int hc_cuDeviceGet;
	public static int hc_cuDeviceGetName;
	public static int hc_cuDeviceTotalMem;
	public static int hc_cuDriverGetVersion;
	public static int hc_cuEventCreate;
	public static int hc_cuEventDestroy;
	public static int hc_cuEventElapsedTime;
	public static int hc_cuEventQuery;
	public static int hc_cuEventRecord;
	public static int hc_cuEventSynchronize;
	public static int hc_cuFuncGetAttribute;
	public static int hc_cuFuncSetAttribute;
	public static int hc_cuInit;
	public static int hc_cuLaunchKernel;
	public static int hc_cuMemAlloc;
	public static int hc_cuMemcpyDtoD;
	public static int hc_cuMemcpyDtoH;
	public static int hc_cuMemcpyHtoD;
	public static int hc_cuMemFree;
	public static int hc_cuModuleGetFunction;
	public static int hc_cuModuleLoadDataEx;
	public static int hc_cuModuleLoadDataExLog;
	public static int hc_cuModuleUnload;
	public static int hc_cuStreamCreate;
	public static int hc_cuStreamDestroy;
	public static int hc_cuStreamSynchronize;
	public static int hc_cuCtxPushCurrent;
	public static int hc_cuCtxPopCurrent;
	public static int hc_clCreateBuffer;
	public static int hc_clCreateCommandQueue;
	public static int hc_clCreateKernel;
	public static int hc_clCreateProgramWithBinary;
	public static int hc_clCreateProgramWithSource;
	public static int hc_clEnqueueCopyBuffer;
	public static int hc_clEnqueueMapBuffer;
	public static int hc_clEnqueueNDRangeKernel;
	public static int hc_clEnqueueReadBuffer;
	public static int hc_clEnqueueUnmapMemObject;
	public static int hc_clEnqueueWriteBuffer;
	public static int hc_clFinish;
	public static int hc_clFlush;
	public static int hc_clGetDeviceIDs;
	public static int hc_clGetDeviceInfo;
	public static int hc_clGetEventInfo;
	public static int hc_clGetEventProfilingInfo;
	public static int hc_clGetKernelWorkGroupInfo;
	public static int hc_clGetPlatformIDs;
	public static int hc_clGetPlatformInfo;
	public static int hc_clGetProgramBuildInfo;
	public static int hc_clGetProgramInfo;
	public static int hc_clReleaseCommandQueue;
	public static int hc_clReleaseContext;
	public static int hc_clReleaseEvent;
	public static int hc_clReleaseKernel;
	public static int hc_clReleaseMemObject;
	public static int hc_clReleaseProgram;
	public static int hc_clSetKernelArg;
	public static int hc_clWaitForEvents;
	public static int gidd_to_pw_t;
	public static int choose_kernel;
	public static Object rebuild_pws_compressed_append;
	public static int run_cuda_kernel_atinit;
	public static int run_cuda_kernel_memset;
	public static int run_cuda_kernel_bzero;
	public static int run_opencl_kernel_atinit;
	public static int run_opencl_kernel_memset;
	public static int run_opencl_kernel_bzero;
	public static int run_kernel;
	public static int run_kernel_mp;
	public static int run_kernel_tm;
	public static int run_kernel_amp;
	public static int run_kernel_decompress;
	public static int run_copy;
	public static int run_cracker;
	public static Object generate_source_kernel_filename;
	public static Object generate_cached_kernel_filename;
	public static Object generate_source_kernel_mp_filename;
	public static Object generate_cached_kernel_mp_filename;
	public static Object generate_source_kernel_amp_filename;
	public static Object generate_cached_kernel_amp_filename;
	public static int backend_ctx_init;
	public static Object backend_ctx_destroy;
	public static int backend_ctx_devices_init;
	public static Object backend_ctx_devices_destroy;
	public static Object backend_ctx_devices_sync_tuning;
	public static Object backend_ctx_devices_update_power;
	public static Object backend_ctx_devices_kernel_loops;
	public static int backend_session_begin;
	public static Object backend_session_destroy;
	public static Object backend_session_reset;
	public static int backend_session_update_combinator;
	public static int backend_session_update_mp;
	public static int backend_session_update_mp_rl;
	public static long ZPOS64_T;
	public static voidpf open_file_func = new voidpf();
	public static uLong read_file_func = new uLong();
	public static uLong write_file_func = new uLong();
	public static int close_file_func;
	public static int testerror_file_func;
	public static long tell_file_func;
	public static long seek_file_func;
	public static ZPOS64_T tell64_file_func = new ZPOS64_T();
	public static long seek64_file_func;
	public static voidpf open64_file_func = new voidpf();
	public static Object fill_fopen64_filefunc;
	public static Object fill_fopen_filefunc;
	public static voidpf call_zopen64 = new voidpf();
	public static long call_zseek64;
	public static ZPOS64_T call_ztell64 = new ZPOS64_T();
	public static Object fill_zlib_filefunc64_32_def_from_filefunc32;
	public static Object HeapSort;
	public static Object HeapSort64;
	public static CPpmd7_Context_ CPpmd7_Context_Ref = new CPpmd7_Context_();
	public static Object Ppmd7_Construct;
	public static BoolInt Ppmd7_Alloc = new BoolInt();
	public static Object Ppmd7_Free;
	public static Object Ppmd7_Init;
	public static Byte[] PPMD7_kExpEscape = new Byte();
	public static Object Ppmd7_Update1;
	public static Object Ppmd7_Update1_0;
	public static Object Ppmd7_Update2;
	public static Object Ppmd7_UpdateBin;
	public static CPpmd_See Ppmd7_MakeEscFreq = new CPpmd_See();
	public static IPpmd7_RangeDec IPpmd7_RangeDec = new IPpmd7_RangeDec();
	public static Object Ppmd7z_RangeDec_CreateVTable;
	public static BoolInt Ppmd7z_RangeDec_Init = new BoolInt();
	public static int Ppmd7_DecodeSymbol;
	public static Object Ppmd7z_RangeEnc_Init;
	public static Object Ppmd7z_RangeEnc_FlushData;
	public static Object Ppmd7_EncodeSymbol;
	public static int inflateStateCheck;
	public static Object fixedtables;
	public static int updatewindow;
	public static int syncsearch;
	public static _cl_platform_id cl_platform_id = new _cl_platform_id();
	public static _cl_device_id cl_device_id = new _cl_device_id();
	public static _cl_sampler cl_sampler = new _cl_sampler();
	public static  cl_bool = new ();
	public static  cl_bitfield = new ();
	public static cl_bitfield cl_device_type = new cl_bitfield();
	public static  cl_platform_info = new ();
	public static  cl_device_info = new ();
	public static cl_bitfield cl_device_fp_config = new cl_bitfield();
	public static  cl_device_mem_cache_type = new ();
	public static  cl_device_local_mem_type = new ();
	public static cl_bitfield cl_device_exec_capabilities = new cl_bitfield();
	public static cl_bitfield cl_command_queue_properties = new cl_bitfield();
	public static  cl_context_properties = new ();
	public static  cl_context_info = new ();
	public static  cl_command_queue_info = new ();
	public static  cl_channel_order = new ();
	public static  cl_channel_type = new ();
	public static cl_bitfield cl_mem_flags = new cl_bitfield();
	public static  cl_mem_object_type = new ();
	public static  cl_mem_info = new ();
	public static  cl_image_info = new ();
	public static  cl_addressing_mode = new ();
	public static  cl_filter_mode = new ();
	public static  cl_sampler_info = new ();
	public static cl_bitfield cl_map_flags = new cl_bitfield();
	public static  cl_program_info = new ();
	public static  cl_program_build_info = new ();
	public static  cl_build_status = new ();
	public static  cl_kernel_info = new ();
	public static  cl_kernel_work_group_info = new ();
	public static  cl_event_info = new ();
	public static  cl_command_type = new ();
	public static  cl_profiling_info = new ();
	public static CPpmd_State CPpmd_State_Ref = new CPpmd_State();
	public static Object CPpmd_Void_Ref;
	public static Byte CPpmd_Byte_Ref = new Byte();
	public static byte SIGNATURE_OFFICE2013 = "$office$";
	public static byte uch;
	public static uch uchf = new uch();
	public static int ush;
	public static ush ushf = new ush();
	public static long ulg;
	public static byte[] z_errmsg = new byte[/* zutil.h -- internal interface and configuration of the compression library
	 * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 *//* WARNING: this file should *not* be used by applications. It is
	   part of the implementation of the compression library and is
	   subject to change. Applications should only use zlib.h.
	 *//* @(#) $Id$ *//* guess -- will be caught if guess is wrong *//* since "static" is used to mean two completely different things in C, we
	   define "local" for the non-static meaning of "static", for readability
	   (compile with -Dlocal if your debugger can't find static symbols) *//* indexed by 2-zlib_error */10/* (size given to avoid silly warnings with Visual C++) *//* To be used only when the state is known to be valid *//* common constants *//* default windowBits for decompression. MAX_WBITS is for compression only *//* default memLevel *//* The three kinds of block type *//* The minimum and maximum match lengths *//* preset dictionary flag in zlib header *//* target dependencies *//* Allow compilation with ANSI keywords only enabled *//* MSC or DJGPP *//* for fdopen *//* No fdopen() */];
	public static voidpf zcalloc = new voidpf();
	public static Object zcfree;
	public static UInt16[] kInitBinEsc = new UInt16[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static CPpmd7_Context CTX_PTR = new CPpmd7_Context();
	public static CPpmd7_Node_ CPpmd7_Node_Ref = new CPpmd7_Node_();
	public static byte SIGNATURE_PASSLIB_PBKDF2_SHA256 = "pbkdf2-sha256";
	public static byte SIGNATURE_OFFICE2010 = "$office$";
	public static voidpf alloc_func = new voidpf();
	public static Object free_func;
	public static z_stream z_streamp = new z_stream();
	public static gz_header gz_headerp = new gz_header();
	public static byte zlibVersion;
	public static int deflate;
	public static int deflateEnd;
	public static int inflate;
	public static int inflateEnd;
	public static int deflateSetDictionary;
	public static int deflateGetDictionary;
	public static int deflateCopy;
	public static int deflateReset;
	public static int deflateParams;
	public static int deflateTune;
	public static uLong deflateBound = new uLong();
	public static int deflatePending;
	public static int deflatePrime;
	public static int deflateSetHeader;
	public static int inflateSetDictionary;
	public static int inflateGetDictionary;
	public static int inflateSync;
	public static int inflateCopy;
	public static int inflateReset;
	public static int inflateReset2;
	public static int inflatePrime;
	public static long inflateMark;
	public static int inflateGetHeader;
	public static int in_func;
	public static int out_func;
	public static int inflateBack;
	public static int inflateBackEnd;
	public static uLong zlibCompileFlags = new uLong();
	public static int compress;
	public static int compress2;
	public static uLong compressBound = new uLong();
	public static int uncompress;
	public static int uncompress2;
	public static gzFile_s gzFile = new gzFile_s();
	public static gzFile gzdopen = new gzFile();
	public static int gzbuffer;
	public static int gzsetparams;
	public static int gzread;
	public static z_size_t gzfread = new z_size_t();
	public static int gzwrite;
	public static z_size_t gzfwrite = new z_size_t();
	public static int gzprintf;
	public static int gzputs;
	public static byte gzgets;
	public static int gzputc;
	public static int gzgetc;
	public static int gzungetc;
	public static int gzflush;
	public static int gzrewind;
	public static int gzeof;
	public static int gzdirect;
	public static int gzclose;
	public static int gzclose_r;
	public static int gzclose_w;
	public static byte gzerror;
	public static Object gzclearerr;
	public static uLong adler32 = new uLong();
	public static uLong adler32_z = new uLong();
	public static uLong crc32 = new uLong();
	public static uLong crc32_z = new uLong();
	public static int deflateInit_;
	public static int inflateInit_;
	public static int deflateInit2_;
	public static int inflateInit2_;
	public static int inflateBackInit_;
	public static int gzgetc_;
	public static gzFile gzopen = new gzFile();
	public static long gzseek;
	public static long gztell;
	public static long gzoffset;
	public static uLong adler32_combine = new uLong();
	public static uLong crc32_combine = new uLong();
	public static byte zError;
	public static int inflateSyncPoint;
	public static z_crc_t get_crc_table = new z_crc_t();
	public static int inflateUndermine;
	public static int inflateValidate;
	public static long inflateCodesUsed;
	public static int inflateResetKeep;
	public static int deflateResetKeep;
	public static gzFile gzopen_w = new gzFile();
	public static int gzvprintf;
	public static byte[] inflate_copyright = /* inftrees.c -- generate Huffman trees for efficient decoding
	 * Copyright (C) 1995-2017 Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */" inflate 1.2.11 Copyright 1995-2017 Mark Adler "/*
	  If you use the zlib library in a product, an acknowledgment is welcome
	  in the documentation of your product. If for some reason you cannot
	  include such an acknowledgment, I would appreciate that you keep this
	  copyright string in the executable of your product.
	 *//*
	   Build a set of tables to decode the provided canonical Huffman code.
	   The code lengths are lens[0..codes-1].  The result starts at *table,
	   whose indices are 0..2^bits-1.  work is a writable array of at least
	   lens shorts, which is used as a work area.  type is the type of code
	   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
	   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
	   on return points to the next available entry's address.  bits is the
	   requested root table index bits, and on return it is the actual root
	   table index bits.  It will differ if the request is greater than the
	   longest code or if it is less than the shortest code.
	 */;
	public static  cl_gl_object_type = new ();
	public static  cl_gl_texture_info = new ();
	public static  cl_gl_platform_info = new ();
	public static __GLsync cl_GLsync = new __GLsync();
	public static  cl_gl_context_info = new ();
	public static  MODULE_CONTEXT_SIZE_CURRENT = ;
	public static Object module_init;
	public static Object module_hook12;
	public static Object module_hook23;
	public static  cl_dx9_media_adapter_type_khr = new ();
	public static  cl_dx9_media_adapter_set_khr = new ();
	public static UInt32 CLzRef = new UInt32();
	public static int MatchFinder_NeedMove;
	public static Byte MatchFinder_GetPointerToCurrentPos = new Byte();
	public static Object MatchFinder_MoveBlock;
	public static Object MatchFinder_ReadIfRequired;
	public static Object MatchFinder_Construct;
	public static int MatchFinder_Create;
	public static Object MatchFinder_Free;
	public static Object MatchFinder_Normalize3;
	public static Object MatchFinder_ReduceOffsets;
	public static UInt32 GetMatchesSpec1 = new UInt32();
	public static Object Mf_Init_Func;
	public static UInt32 Mf_GetNumAvailableBytes_Func = new UInt32();
	public static Byte Mf_GetPointerToCurrentPos_Func = new Byte();
	public static UInt32 Mf_GetMatches_Func = new UInt32();
	public static Object Mf_Skip_Func;
	public static Object MatchFinder_CreateVTable;
	public static Object MatchFinder_Init_LowHash;
	public static Object MatchFinder_Init_HighHash;
	public static Object MatchFinder_Init_3;
	public static Object MatchFinder_Init;
	public static UInt32 Bt3Zip_MatchFinder_GetMatches = new UInt32();
	public static UInt32 Hc3Zip_MatchFinder_GetMatches = new UInt32();
	public static Object Bt3Zip_MatchFinder_Skip;
	public static Object Hc3Zip_MatchFinder_Skip;
	public static Object thread_calc_stdin;
	public static Object thread_calc;
	public static byte SIGNATURE_PHPASS1 = "$P$";
	public static byte SIGNATURE_PHPASS2 = "$H$";
	public static byte SIGNATURE_PBKDF2_SHA1 = "sha1";
	public static int XXH_versionNumber;
	public static int XXH32_hash_t;
	public static XXH32_hash_t XXH32 = new XXH32_hash_t();
	public static XXH32_state_s XXH32_state_t = new XXH32_state_s();
	public static XXH32_state_t XXH32_createState = new XXH32_state_t();
	public static XXH_errorcode XXH32_freeState = new XXH_errorcode();
	public static Object XXH32_copyState;
	public static XXH_errorcode XXH32_reset = new XXH_errorcode();
	public static XXH_errorcode XXH32_update = new XXH_errorcode();
	public static XXH32_hash_t XXH32_digest = new XXH32_hash_t();
	public static Object XXH32_canonicalFromHash;
	public static XXH32_hash_t XXH32_hashFromCanonical = new XXH32_hash_t();
	public static long XXH64_hash_t;
	public static XXH64_hash_t XXH64 = new XXH64_hash_t();
	public static XXH64_state_s XXH64_state_t = new XXH64_state_s();
	public static XXH64_state_t XXH64_createState = new XXH64_state_t();
	public static XXH_errorcode XXH64_freeState = new XXH_errorcode();
	public static Object XXH64_copyState;
	public static XXH_errorcode XXH64_reset = new XXH_errorcode();
	public static XXH_errorcode XXH64_update = new XXH_errorcode();
	public static XXH64_hash_t XXH64_digest = new XXH64_hash_t();
	public static Object XXH64_canonicalFromHash;
	public static XXH64_hash_t XXH64_hashFromCanonical = new XXH64_hash_t();
	public static Object md5_transform;
	public static Object md5_init;
	public static Object md5_update_64;
	public static Object md5_update;
	public static Object md5_update_swap;
	public static Object md5_update_utf16le;
	public static Object md5_update_utf16le_swap;
	public static Object md5_final;
	public static Object md5_hmac_init_64;
	public static Object md5_hmac_init;
	public static Object md5_hmac_init_swap;
	public static Object md5_hmac_update_64;
	public static Object md5_hmac_update;
	public static Object md5_hmac_update_swap;
	public static Object md5_hmac_update_utf16le;
	public static Object md5_hmac_update_utf16le_swap;
	public static Object md5_hmac_final;
	public static Object md5_transform_vector;
	public static Object md5_init_vector;
	public static Object md5_init_vector_from_scalar;
	public static Object md5_update_vector_64;
	public static Object md5_update_vector;
	public static Object md5_update_vector_swap;
	public static Object md5_update_vector_utf16le;
	public static Object md5_update_vector_utf16le_swap;
	public static Object md5_final_vector;
	public static Object md5_hmac_init_vector_64;
	public static Object md5_hmac_init_vector;
	public static Object md5_hmac_update_vector_64;
	public static Object md5_hmac_update_vector;
	public static Object md5_hmac_final_vector;
	public static int SRes;
	public static int WRes;
	public static int Int16;
	public static int UInt16;
	public static int Int32;
	public static int UInt32;
	public static long Int64;
	public static long UInt64;
	public static size_t SizeT = new size_t();
	public static int BoolInt;
	public static IByteIn IByteIn = new IByteIn();
	public static IByteOut IByteOut = new IByteOut();
	public static ISeqInStream ISeqInStream = new ISeqInStream();
	public static SRes SeqInStream_Read = new SRes();
	public static SRes SeqInStream_Read2 = new SRes();
	public static SRes SeqInStream_ReadByte = new SRes();
	public static ISeqOutStream ISeqOutStream = new ISeqOutStream();
	public static ISeekInStream ISeekInStream = new ISeekInStream();
	public static ILookInStream ILookInStream = new ILookInStream();
	public static SRes LookInStream_LookRead = new SRes();
	public static SRes LookInStream_SeekTo = new SRes();
	public static SRes LookInStream_Read2 = new SRes();
	public static SRes LookInStream_Read = new SRes();
	public static Object LookToRead2_CreateVTable;
	public static Object SecToLook_CreateVTable;
	public static Object SecToRead_CreateVTable;
	public static ICompressProgress ICompressProgress = new ICompressProgress();
	public static ISzAlloc ISzAlloc = new ISzAlloc();
	public static ISzAlloc ISzAllocPtr = new ISzAlloc();
	public static int ROUNDS_VERACRYPT_655331 = 655331;
	public static byte[] inflate9_copyright = /* inftree9.c -- generate Huffman trees for efficient decoding
	 * Copyright (C) 1995-2017 Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */" inflate9 1.2.11 Copyright 1995-2017 Mark Adler "/*
	  If you use the zlib library in a product, an acknowledgment is welcome
	  in the documentation of your product. If for some reason you cannot
	  include such an acknowledgment, I would appreciate that you keep this
	  copyright string in the executable of your product.
	 *//*
	   Build a set of tables to decode the provided canonical Huffman code.
	   The code lengths are lens[0..codes-1].  The result starts at *table,
	   whose indices are 0..2^bits-1.  work is a writable array of at least
	   lens shorts, which is used as a work area.  type is the type of code
	   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
	   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
	   on return points to the next available entry's address.  bits is the
	   requested root table index bits, and on return it is the actual root
	   table index bits.  It will differ if the request is greater than the
	   longest code or if it is less than the shortest code.
	 */;
	public static byte SIGNATURE_SSHA1B64_lower = "{ssha}";
	public static byte SIGNATURE_SSHA1B64_upper = "{SSHA}";
	public static  cl_d3d11_device_source_khr = new ();
	public static  cl_d3d11_device_set_khr = new ();
	public static UInt64 XzCrc64UpdateT4 = new UInt64();
	public static UInt64 CRC64_FUNC = new UInt64();
	public static CRC64_FUNC g_Crc64Update = new CRC64_FUNC();
	public static UInt64[] g_Crc64Table = new UInt64();
	public static byte SIGNATURE_MYWALLET = "$blockchain$";
	public static int ROUNDS_MYWALLET = 10;
	public static [][] c_SPtrans = new ();
	public static [][] c_skb = new ();
	public static Object sha1_transform;
	public static Object sha1_init;
	public static Object sha1_update_64;
	public static Object sha1_update;
	public static Object sha1_update_swap;
	public static Object sha1_update_utf16le;
	public static Object sha1_update_utf16le_swap;
	public static Object sha1_update_utf16be;
	public static Object sha1_update_utf16be_swap;
	public static Object sha1_final;
	public static Object sha1_hmac_init_64;
	public static Object sha1_hmac_init;
	public static Object sha1_hmac_init_swap;
	public static Object sha1_hmac_update_64;
	public static Object sha1_hmac_update;
	public static Object sha1_hmac_update_swap;
	public static Object sha1_hmac_update_utf16le;
	public static Object sha1_hmac_update_utf16le_swap;
	public static Object sha1_hmac_final;
	public static Object sha1_transform_vector;
	public static Object sha1_init_vector;
	public static Object sha1_init_vector_from_scalar;
	public static Object sha1_update_vector_64;
	public static Object sha1_update_vector;
	public static Object sha1_update_vector_swap;
	public static Object sha1_update_vector_utf16le;
	public static Object sha1_update_vector_utf16le_swap;
	public static Object sha1_update_vector_utf16leN;
	public static Object sha1_update_vector_utf16beN;
	public static Object sha1_final_vector;
	public static Object sha1_hmac_init_vector_64;
	public static Object sha1_hmac_init_vector;
	public static Object sha1_hmac_update_vector_64;
	public static Object sha1_hmac_update_vector;
	public static Object sha1_hmac_final_vector;
	public static byte[] INDUCT_DIR = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */"induct";
	public static int induct_ctx_init;
	public static Object induct_ctx_scan;
	public static Object induct_ctx_destroy;
	public static byte SIGNATURE_MD5APR1 = "$apr1$";
	public static UInt32[] K = new UInt32[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
	public static SRes Lzma86_Encode = new SRes();
	public static SRes Lzma86_GetUnpackSize = new SRes();
	public static SRes Lzma86_Decode = new SRes();
	public static int sort_by_dictstat;
	public static int dictstat_init;
	public static Object dictstat_destroy;
	public static Object dictstat_read;
	public static int dictstat_write;
	public static  dictstat_find = new ();
	public static Object dictstat_append;
	public static byte SIGNATURE_MS_DRSR = "v1;PPH1_MD4";
	public static int cpt_ctx_init;
	public static Object cpt_ctx_destroy;
	public static Object cpt_ctx_reset;
	public static  v8a_from_v32_S = new ();
	public static  v8b_from_v32_S = new ();
	public static  v8c_from_v32_S = new ();
	public static  v8d_from_v32_S = new ();
	public static  v16a_from_v32_S = new ();
	public static  v16b_from_v32_S = new ();
	public static  v32a_from_v64_S = new ();
	public static  v32b_from_v64_S = new ();
	public static  v32_from_v16ab_S = new ();
	public static  v64_from_v32ab_S = new ();
	public static  unpack_v8a_from_v32_S = new ();
	public static  unpack_v8b_from_v32_S = new ();
	public static  unpack_v8c_from_v32_S = new ();
	public static  unpack_v8d_from_v32_S = new ();
	public static  l32_from_64 = new ();
	public static  h32_from_64 = new ();
	public static  l32_from_64_S = new ();
	public static  h32_from_64_S = new ();
	public static  hl32_to_64 = new ();
	public static  hl32_to_64_S = new ();
	public static  hc_rotl32 = new ();
	public static  hc_rotr32 = new ();
	public static  hc_rotl32_S = new ();
	public static  hc_rotr32_S = new ();
	public static  hc_rotl64 = new ();
	public static  hc_rotr64 = new ();
	public static  hc_rotl64_S = new ();
	public static  hc_rotr64_S = new ();
	public static  hc_swap32 = new ();
	public static  hc_swap32_S = new ();
	public static  hc_swap64 = new ();
	public static  hc_swap64_S = new ();
	public static  hc_bytealign = new ();
	public static  hc_bytealign_S = new ();
	public static  hc_bytealign_be = new ();
	public static  hc_bytealign_be_S = new ();
	public static  hc_byte_perm = new ();
	public static  hc_byte_perm_S = new ();
	public static  hc_add3 = new ();
	public static  hc_add3_S = new ();
	public static  hc_bfe = new ();
	public static  hc_bfe_S = new ();
	public static  hc_lop_0x96 = new ();
	public static  hc_lop_0x96_S = new ();
	public static int ffz;
	public static int hc_count_char;
	public static double hc_get_entropy;
	public static int is_valid_hex_8;
	public static int is_valid_hex_32;
	public static int is_valid_base58_8;
	public static int is_valid_base58_32;
	public static Object make_utf16be;
	public static Object make_utf16beN;
	public static Object make_utf16le;
	public static Object make_utf16leN;
	public static Object undo_utf16be;
	public static Object undo_utf16le;
	public static Object set_mark_1x4;
	public static Object append_helper_1x4;
	public static Object append_0x80_1x4;
	public static Object append_0x80_2x4;
	public static Object append_0x80_3x4;
	public static Object append_0x80_4x4;
	public static Object append_0x80_8x4;
	public static Object append_0x80_1x16;
	public static Object switch_buffer_by_offset_le;
	public static Object switch_buffer_by_offset_carry_le;
	public static Object switch_buffer_by_offset_be;
	public static Object switch_buffer_by_offset_carry_be;
	public static Object switch_buffer_by_offset_8x4_le;
	public static Object switch_buffer_by_offset_8x4_be;
	public static Object switch_buffer_by_offset_8x4_carry_be;
	public static Object switch_buffer_by_offset_1x64_le;
	public static Object switch_buffer_by_offset_1x64_be;
	public static Object truncate_block_4x4_le_S;
	public static Object truncate_block_4x4_be_S;
	public static Object truncate_block_16x4_le_S;
	public static Object truncate_block_16x4_be_S;
	public static Object set_mark_1x4_S;
	public static Object append_helper_1x4_S;
	public static Object append_0x01_2x4_S;
	public static Object append_0x06_2x4_S;
	public static Object append_0x01_4x4_S;
	public static Object append_0x80_1x4_S;
	public static Object append_0x80_2x4_S;
	public static Object append_0x80_3x4_S;
	public static Object append_0x80_4x4_S;
	public static Object append_0x80_8x4_S;
	public static Object make_utf16be_S;
	public static Object make_utf16le_S;
	public static Object undo_utf16be_S;
	public static Object undo_utf16le_S;
	public static Object switch_buffer_by_offset_le_S;
	public static Object switch_buffer_by_offset_carry_le_S;
	public static Object switch_buffer_by_offset_be_S;
	public static Object switch_buffer_by_offset_carry_be_S;
	public static Object switch_buffer_by_offset_8x4_le_S;
	public static Object switch_buffer_by_offset_8x4_be_S;
	public static Object switch_buffer_by_offset_8x4_carry_be_S;
	public static Object switch_buffer_by_offset_1x64_le_S;
	public static Object switch_buffer_by_offset_1x64_be_S;
	public static Object switch_buffer_by_offset_le_VV;
	public static Object switch_buffer_by_offset_8x4_le_VV;
	public static Object append_0x01_2x4_VV;
	public static Object append_0x01_4x4_VV;
	public static Object append_0x06_2x4_VV;
	public static Object append_0x80_2x4_VV;
	public static Object append_0x80_4x4_VV;
	public static u32 DGST_BLK_SIZE = 64;
	public static byte SIGNATURE_KEEPASS = "$keepass$";
	public static Object thread_outfile_remove;
	public static int outcheck_ctx_init;
	public static Object outcheck_ctx_destroy;
	public static Object kuznyechik_linear;
	public static Object kuznyechik_linear_inv;
	public static Object kuznyechik_set_key;
	public static Object kuznyechik_encrypt;
	public static Object kuznyechik_decrypt;
	public static size_t TERMINAL_LINE_LENGTH = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */79;
	public static byte PROMPT_ACTIVE = "[s]tatus [p]ause [b]ypass [c]heckpoint [q]uit => ";
	public static byte PROMPT_PAUSED = "[s]tatus [r]esume [b]ypass [c]heckpoint [q]uit => ";
	public static DWORD saveMode = 0;
	public static byte[] MASKED_PLAIN = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */"[notfound]";
	public static Object whirlpool_update_64;
	public static Object whirlpool_update;
	public static Object whirlpool_update_swap;
	public static Object whirlpool_update_utf16le;
	public static Object whirlpool_update_utf16le_swap;
	public static Object whirlpool_final;
	public static Object whirlpool_hmac_update_64;
	public static Object whirlpool_hmac_update;
	public static Object whirlpool_hmac_update_swap;
	public static Object whirlpool_hmac_update_utf16le;
	public static Object whirlpool_hmac_update_utf16le_swap;
	public static Object whirlpool_hmac_final;
	public static Object whirlpool_init_vector_from_scalar;
	public static Object whirlpool_update_vector_64;
	public static Object whirlpool_update_vector;
	public static Object whirlpool_update_vector_swap;
	public static Object whirlpool_update_vector_utf16le;
	public static Object whirlpool_update_vector_utf16le_swap;
	public static Object whirlpool_final_vector;
	public static Object whirlpool_hmac_update_vector_64;
	public static Object whirlpool_hmac_update_vector;
	public static Object whirlpool_hmac_final_vector;
	public static byte SIGNATURE_DJANGOSHA1 = "sha1$";
	public static byte SIGNATURE_CISCO9 = "$9$";
	public static int ROUNDS_VERACRYPT_327661 = 327661;
	public static int build_plain;
	public static int build_crackpos;
	public static int build_debugdata;
	public static int outfile_init;
	public static Object outfile_destroy;
	public static int outfile_write_open;
	public static Object outfile_write_close;
	public static int outfile_write;
	public static Object LzmaDec_InitDicAndState;
	public static byte SIGNATURE_BLAKE2B = "$BLAKE2$";
	public static Object slow_candidates_seek;
	public static Object slow_candidates_next;
	public static Object md4_transform;
	public static Object md4_init;
	public static Object md4_update_64;
	public static Object md4_update;
	public static Object md4_update_swap;
	public static Object md4_update_utf16le;
	public static Object md4_update_utf16le_swap;
	public static Object md4_final;
	public static Object md4_hmac_init_64;
	public static Object md4_hmac_init;
	public static Object md4_hmac_init_swap;
	public static Object md4_hmac_update_64;
	public static Object md4_hmac_update;
	public static Object md4_hmac_update_swap;
	public static Object md4_hmac_update_utf16le;
	public static Object md4_hmac_update_utf16le_swap;
	public static Object md4_hmac_final;
	public static Object md4_transform_vector;
	public static Object md4_init_vector;
	public static Object md4_init_vector_from_scalar;
	public static Object md4_update_vector_64;
	public static Object md4_update_vector;
	public static Object md4_update_vector_swap;
	public static Object md4_update_vector_utf16le;
	public static Object md4_update_vector_utf16le_swap;
	public static Object md4_final_vector;
	public static Object md4_hmac_init_vector_64;
	public static Object md4_hmac_init_vector;
	public static Object md4_hmac_update_vector_64;
	public static Object md4_hmac_update_vector;
	public static Object md4_hmac_final_vector;
	public static byte[] zip_copyright = /* zip.c -- IO on .zip files using zlib
	   Version 1.1, February 14h, 2010
	   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
	
	         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
	
	         Modifications for Zip64 support
	         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
	
	         For more info read MiniZip_info.txt
	
	         Changes
	   Oct-2009 - Mathias Svensson - Remove old C style function prototypes
	   Oct-2009 - Mathias Svensson - Added Zip64 Support when creating new file archives
	   Oct-2009 - Mathias Svensson - Did some code cleanup and refactoring to get better overview of some functions.
	   Oct-2009 - Mathias Svensson - Added zipRemoveExtraInfoBlock to strip extra field data from its ZIP64 data
	                                 It is used when recreting zip archive with RAW when deleting items from a zip.
	                                 ZIP64 data is automatically added to items that needs it, and existing ZIP64 data need to be removed.
	   Oct-2009 - Mathias Svensson - Added support for BZIP2 as compression mode (bzip2 lib is required)
	   Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer
	
	*//* compile with -Dlocal if your debugger can't find static symbols *//* platform depedent *//*
	#define SIZECENTRALDIRITEM (0x2e)
	#define SIZEZIPLOCALHEADER (0x1e)
	*//* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */" zip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
	public static int zip64local_putValue;
	public static Object zip64local_putValue_inmemory;
	public static int zip64local_getByte;
	public static int zip64local_getShort;
	public static int zip64local_getLong;
	public static int zip64local_getLong64;
	public static ZPOS64_T zip64local_SearchCentralDir = new ZPOS64_T();
	public static ZPOS64_T zip64local_SearchCentralDir64 = new ZPOS64_T();
	public static THREAD_FUNC_RET_TYPE ThreadFunc = new THREAD_FUNC_RET_TYPE();
	public static  u8add = new ();
	public static Object gzlog;
	public static gzlog gzlog_open = new gzlog();
	public static int gzlog_write;
	public static int gzlog_compress;
	public static int gzlog_close;
	public static byte SIGNATURE_MD5AIX = "{smd5}";
	public static byte[] hello = /* example.c -- usage example of the zlib compression library
	 * Copyright (C) 1995-2006, 2011, 2016 Jean-loup Gailly
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 *//* @(#) $Id$ */"hello, hello!"/* "hello world" would be more standard, but the repeated "hello"
	 * stresses the compression code better, sorry...
	 */;
	public static byte[] dictionary = "hello"/* Adler32 value of the dictionary */;
	public static uLong dictId = new uLong();
	public static Object test_deflate;
	public static Object test_inflate;
	public static Object test_large_deflate;
	public static Object test_large_inflate;
	public static Object test_flush;
	public static Object test_sync;
	public static Object test_dict_deflate;
	public static Object test_dict_inflate;
	public static int main;
	public static alloc_func zalloc = (alloc_func)/* !Z_SOLO */0;
	public static free_func zfree = (free_func)0;
	public static Object test_compress;
	public static Object test_gzio;
	public static int unzRepair;
	public static double get_avg_exec_time;
	public static Object format_timer_display;
	public static Object format_speed_display;
	public static Object format_speed_display_1k;
	public static int status_get_device_info_cnt;
	public static int status_get_device_info_active;
	public static  status_get_skipped_dev = new ();
	public static  status_get_skipped_warning_dev = new ();
	public static byte status_get_session;
	public static byte status_get_status_string;
	public static int status_get_status_number;
	public static int status_get_guess_mode;
	public static byte status_get_guess_base;
	public static int status_get_guess_base_offset;
	public static int status_get_guess_base_count;
	public static double status_get_guess_base_percent;
	public static byte status_get_guess_mod;
	public static int status_get_guess_mod_offset;
	public static int status_get_guess_mod_count;
	public static double status_get_guess_mod_percent;
	public static byte status_get_guess_charset;
	public static int status_get_guess_mask_length;
	public static byte status_get_guess_candidates_dev;
	public static byte status_get_hash_name;
	public static byte status_get_hash_target;
	public static int status_get_digests_done;
	public static int status_get_digests_cnt;
	public static double status_get_digests_percent;
	public static int status_get_salts_done;
	public static int status_get_salts_cnt;
	public static double status_get_salts_percent;
	public static double status_get_msec_running;
	public static double status_get_msec_paused;
	public static double status_get_msec_real;
	public static byte status_get_time_started_absolute;
	public static byte status_get_time_started_relative;
	public static time_t status_get_sec_etc = new time_t();
	public static byte status_get_time_estimated_absolute;
	public static byte status_get_time_estimated_relative;
	public static  status_get_restore_point = new ();
	public static  status_get_restore_total = new ();
	public static double status_get_restore_percent;
	public static int status_get_progress_mode;
	public static double status_get_progress_finished_percent;
	public static  status_get_progress_done = new ();
	public static  status_get_progress_rejected = new ();
	public static double status_get_progress_rejected_percent;
	public static  status_get_progress_restored = new ();
	public static  status_get_progress_cur = new ();
	public static  status_get_progress_end = new ();
	public static  status_get_progress_ignore = new ();
	public static  status_get_progress_skip = new ();
	public static  status_get_progress_cur_relative_skip = new ();
	public static  status_get_progress_end_relative_skip = new ();
	public static double status_get_hashes_msec_all;
	public static double status_get_hashes_msec_dev;
	public static double status_get_hashes_msec_dev_benchmark;
	public static double status_get_exec_msec_all;
	public static double status_get_exec_msec_dev;
	public static byte status_get_speed_sec_all;
	public static byte status_get_speed_sec_dev;
	public static int status_get_cpt_cur_min;
	public static int status_get_cpt_cur_hour;
	public static int status_get_cpt_cur_day;
	public static int status_get_cpt_avg_min;
	public static int status_get_cpt_avg_hour;
	public static int status_get_cpt_avg_day;
	public static byte status_get_cpt;
	public static int status_get_salt_pos_dev;
	public static int status_get_innerloop_pos_dev;
	public static int status_get_innerloop_left_dev;
	public static int status_get_iteration_pos_dev;
	public static int status_get_iteration_left_dev;
	public static byte status_get_hwmon_dev;
	public static int status_get_corespeed_dev;
	public static int status_get_memoryspeed_dev;
	public static  status_get_progress_dev = new ();
	public static double status_get_runtime_msec_dev;
	public static int status_get_kernel_accel_dev;
	public static int status_get_kernel_loops_dev;
	public static int status_get_kernel_threads_dev;
	public static int status_get_vector_width_dev;
	public static int status_progress_init;
	public static Object status_progress_destroy;
	public static Object status_progress_reset;
	public static int status_ctx_init;
	public static Object status_ctx_destroy;
	public static Object status_status_destroy;
	public static byte SIGNATURE_JKS_SHA1 = "$jksprivk$";
	public static int set_cpu_affinity;
	public static int hashcat_init;
	public static Object hashcat_destroy;
	public static int hashcat_session_init;
	public static int hashcat_session_execute;
	public static int hashcat_session_pause;
	public static int hashcat_session_resume;
	public static int hashcat_session_bypass;
	public static int hashcat_session_checkpoint;
	public static int hashcat_session_quit;
	public static int hashcat_session_destroy;
	public static byte hashcat_get_log;
	public static int hashcat_get_status;
	public static  hc_dlopen = new ();
	public static int hc_dlclose;
	public static  hc_dlsym = new ();
	public static UINT_PTR UIntPtr = new UINT_PTR();
	public static voidpf win32_open_file_func = new voidpf();
	public static uLong win32_read_file_func = new uLong();
	public static uLong win32_write_file_func = new uLong();
	public static ZPOS64_T win32_tell64_file_func = new ZPOS64_T();
	public static long win32_seek64_file_func;
	public static int win32_close_file_func;
	public static int win32_error_file_func;
	public static SRes Lzma2Dec_AllocateProbs = new SRes();
	public static SRes Lzma2Dec_Allocate = new SRes();
	public static Object Lzma2Dec_Init;
	public static SRes Lzma2Dec_DecodeToDic = new SRes();
	public static SRes Lzma2Dec_DecodeToBuf = new SRes();
	public static ELzma2ParseStatus Lzma2Dec_Parse = new ELzma2ParseStatus();
	public static SRes Lzma2Decode = new SRes();
	public static int user_options_init;
	public static Object user_options_destroy;
	public static int user_options_getopt;
	public static int user_options_sanity;
	public static Object user_options_session_auto;
	public static Object user_options_preprocess;
	public static Object user_options_postprocess;
	public static Object user_options_extra_init;
	public static Object user_options_extra_destroy;
	public static  user_options_extra_amplifier = new ();
	public static Object user_options_logger;
	public static int user_options_check_files;
	public static Object user_options_info;
	public static  cl_dx9_device_source_intel = new ();
	public static  cl_dx9_device_set_intel = new ();
	public static int hc_lzma1_decompress;
	public static int hc_lzma2_decompress;
	public static u32 ROUNDS_SHA512CRYPT = 5000;
	public static byte SIGNATURE_SHA512CRYPT = "$6$";
	public static voidp unzFile = new voidp();
	public static int unzStringFileNameCompare;
	public static unzFile unzOpen = new unzFile();
	public static unzFile unzOpen64 = new unzFile();
	public static unzFile unzOpen2 = new unzFile();
	public static unzFile unzOpen2_64 = new unzFile();
	public static int unzClose;
	public static int unzGetGlobalInfo;
	public static int unzGetGlobalInfo64;
	public static int unzGetGlobalComment;
	public static int unzGoToFirstFile;
	public static int unzGoToNextFile;
	public static int unzLocateFile;
	public static int unzGetFilePos;
	public static int unzGoToFilePos;
	public static int unzGetFilePos64;
	public static int unzGoToFilePos64;
	public static int unzGetCurrentFileInfo64;
	public static int unzGetCurrentFileInfo;
	public static ZPOS64_T unzGetCurrentFileZStreamPos64 = new ZPOS64_T();
	public static int unzOpenCurrentFile;
	public static int unzOpenCurrentFilePassword;
	public static int unzOpenCurrentFile2;
	public static int unzOpenCurrentFile3;
	public static int unzCloseCurrentFile;
	public static int unzReadCurrentFile;
	public static long unztell;
	public static ZPOS64_T unztell64 = new ZPOS64_T();
	public static int unzeof;
	public static int unzGetLocalExtrafield;
	public static ZPOS64_T unzGetOffset64 = new ZPOS64_T();
	public static uLong unzGetOffset = new uLong();
	public static int unzSetOffset64;
	public static int unzSetOffset;
	public static byte SIGNATURE_CRAM_MD5_DOVECOT = "{CRAM-MD5}";
	public static  hc_fopen = new ();
	public static int hc_fscanf;
	public static int hc_fprintf;
	public static int hc_vfprintf;
	public static int hc_fseek;
	public static Object hc_rewind;
	public static off_t hc_ftell = new off_t();
	public static int hc_fgetc;
	public static int hc_fileno;
	public static int hc_feof;
	public static Object hc_fflush;
	public static Object hc_fclose;
	public static int hc_fputc;
	public static byte hc_fgets;
	public static size_t hc_fwrite = new size_t();
	public static size_t hc_fread = new size_t();
	public static size_t fgetl = new size_t();
	public static  count_lines = new ();
	public static size_t in_superchop = new size_t();
	public static size_t superchop_with_length = new size_t();
	public static Object gz_reset;
	public static gzFile gz_open = new gzFile();
	public static byte HLFMT_TEXT_HASHCAT = /**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */"native hashcat";
	public static byte HLFMT_TEXT_PWDUMP = "pwdump";
	public static byte HLFMT_TEXT_PASSWD = "passwd";
	public static byte HLFMT_TEXT_SHADOW = "shadow";
	public static byte HLFMT_TEXT_DCC = "DCC";
	public static byte HLFMT_TEXT_DCC2 = "DCC 2";
	public static byte HLFMT_TEXT_NETNTLM1 = "NetNTLMv1";
	public static byte HLFMT_TEXT_NETNTLM2 = "NetNTLMv2";
	public static byte HLFMT_TEXT_NSLDAP = "nsldap";
	public static byte HLFMT_TEXT_NSLDAPS = "nsldaps";
	public static Object event_call;
	public static size_t event_log_advice_nn = new size_t();
	public static size_t event_log_info_nn = new size_t();
	public static size_t event_log_warning_nn = new size_t();
	public static size_t event_log_error_nn = new size_t();
	public static size_t event_log_advice = new size_t();
	public static size_t event_log_info = new size_t();
	public static size_t event_log_warning = new size_t();
	public static size_t event_log_error = new size_t();
	public static int event_ctx_init;
	public static Object event_ctx_destroy;
	public static byte SIGNATURE_PSAFE3 = "PWS3";
	public static  mds_rem = new ();
	public static  h_fun128 = new ();
	public static Object twofish128_set_key;
	public static Object twofish128_encrypt;
	public static Object twofish128_decrypt;
	public static  h_fun256 = new ();
	public static Object twofish256_set_key;
	public static Object twofish256_encrypt;
	public static Object twofish256_decrypt;
	public static Object Lzma2EncProps_Init;
	public static Object Lzma2EncProps_Normalize;
	public static Object CLzma2EncHandle;
	public static CLzma2EncHandle Lzma2Enc_Create = new CLzma2EncHandle();
	public static Object Lzma2Enc_Destroy;
	public static SRes Lzma2Enc_SetProps = new SRes();
	public static Object Lzma2Enc_SetDataSize;
	public static Byte Lzma2Enc_WriteProperties = new Byte();
	public static SRes Lzma2Enc_Encode2 = new SRes();
	public static int sort_by_stringptr;
	public static int count_dictionaries;
	public static byte first_file_in_directory;
	public static byte scan_directory;
	public static Object folder_config_destroy;
	public static U32 PRIME32_1 = /* *******************************************************************
	*  32-bit hash functions
	*********************************************************************/-1024;
	public static U32 PRIME32_2 = -1024;
	public static U32 PRIME32_3 = -1024;
	public static U32 PRIME32_4 = -1024;
	public static U32 PRIME32_5 = -1024;
	public static U64 PRIME64_1 = /*======   xxh64   ======*/-1024;
	public static U64 PRIME64_2 = -1024;
	public static U64 PRIME64_3 = -1024;
	public static U64 PRIME64_4 = -1024;
	public static U64 PRIME64_5 = -1024;
	public static int benchmark_next;
	public static byte SIGNATURE_SIP_AUTH = "$sip$";
	public static __CMtDecBufLink CMtDecBufLink = new __CMtDecBufLink();
	public static int cpu_crc32;
	public static  cpu_crc32_buffer = new ();
	public static byte SIGNATURE_CRAM_MD5 = "$cram_md5$";
	public static  round_crc32 = new ();
	public static  round_crc32_4 = new ();
	public static byte skyper = "\nskyper\n";
	public static byte prog;
	public static Object error;
	public static Object gz_compress;
	public static Object gz_uncompress;
	public static Object file_compress;
	public static Object file_uncompress;
	public static  class_num = new ();
	public static  class_lower = new ();
	public static  class_upper = new ();
	public static  class_alpha = new ();
	public static int conv_ctoi;
	public static int conv_itoc;
	public static int generate_random_rule;
	public static  is_hex_notation = new ();
	public static int cpu_rule_to_kernel_rule;
	public static int kernel_rule_to_cpu_rule;
	public static  kernel_rules_has_noop = new ();
	public static int kernel_rules_load;
	public static int kernel_rules_generate;
	public static int[] DEFAULT_BENCHMARK_ALGORITHMS_BUF = new int[]{/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */0, 100, 1400, 1700, 2500, 1000, 3000, 5500, 5600, 1500, 500, 3200, 1800, 7500, 13100, 15300, 15900, 7100, 11600, 12500, 13000, 6211, 13400, 6800, 11300, -1};
	public static byte SIGNATURE_DPAPIMK = "$DPAPImk$";
	public static int process_stdout;
	public static byte SIGNATURE_SHA256B64S = "{SSHA256}";
	public static byte[] deflate_copyright = /* deflate.c -- compress data using the deflation algorithm
	 * Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 *//*
	 *  ALGORITHM
	 *
	 *      The "deflation" process depends on being able to identify portions
	 *      of the input text which are identical to earlier input (within a
	 *      sliding window trailing behind the input currently being processed).
	 *
	 *      The most straightforward technique turns out to be the fastest for
	 *      most input files: try all possible matches and select the longest.
	 *      The key feature of this algorithm is that insertions into the string
	 *      dictionary are very simple and thus fast, and deletions are avoided
	 *      completely. Insertions are performed at each input character, whereas
	 *      string matches are performed only when the previous match ends. So it
	 *      is preferable to spend more time in matches to allow very fast string
	 *      insertions and avoid deletions. The matching algorithm for small
	 *      strings is inspired from that of Rabin & Karp. A brute force approach
	 *      is used to find longer strings when a small match has been found.
	 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
	 *      (by Leonid Broukhis).
	 *         A previous version of this file used a more sophisticated algorithm
	 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
	 *      time, but has a larger average cost, uses more memory and is patented.
	 *      However the F&G algorithm may be faster for some highly redundant
	 *      files if the parameter max_chain_length (described below) is too large.
	 *
	 *  ACKNOWLEDGEMENTS
	 *
	 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
	 *      I found it in 'freeze' written by Leonid Broukhis.
	 *      Thanks to many people for bug reports and testing.
	 *
	 *  REFERENCES
	 *
	 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
	 *      Available in http://tools.ietf.org/html/rfc1951
	 *
	 *      A description of the Rabin and Karp algorithm is given in the book
	 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
	 *
	 *      Fiala,E.R., and Greene,D.H.
	 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
	 *
	 *//* @(#) $Id$ */" deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler "/*
	  If you use the zlib library in a product, an acknowledgment is welcome
	  in the documentation of your product. If for some reason you cannot
	  include such an acknowledgment, I would appreciate that you keep this
	  copyright string in the executable of your product.
	 *//* ===========================================================================
	 *  Function prototypes.
	 */;
	public static block_state compress_func = new block_state();
	public static int deflateStateCheck;
	public static Object slide_hash;
	public static Object fill_window;
	public static block_state deflate_stored = new block_state();
	public static block_state deflate_fast = new block_state();
	public static block_state deflate_slow = new block_state();
	public static block_state deflate_rle = new block_state();
	public static block_state deflate_huff = new block_state();
	public static Object lm_init;
	public static Object putShortMSB;
	public static Object flush_pending;
	public static int read_buf;
	public static uInt longest_match = new uInt();
	public static config[] configuration_table = new config[]{new config(0, 0, 0, 0, /*      good lazy nice chain *//* 0 *//* store only */deflate_stored), new config(4, 4, 8, 4, /* 1 *//* max speed, no lazy matches */deflate_fast), new config(4, 5, 16, 8, /* 2 */deflate_fast), new config(4, 6, 32, 32, /* 3 */deflate_fast), new config(4, 4, 16, 16, /* 4 *//* lazy matches */deflate_slow), new config(8, 16, 32, 32, /* 5 */deflate_slow), new config(8, 16, 128, 128, /* 6 */deflate_slow), new config(8, 32, 128, 256, /* 7 */deflate_slow), new config(32, 128, 258, 1024, /* 8 */deflate_slow), new config(32, 258, 258, 4096, /* 9 *//* max compression */deflate_slow/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
	 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
	 * meaning.
	 *//* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH *//* ===========================================================================
	 * Update a hash value with the given input byte
	 * IN  assertion: all calls to UPDATE_HASH are made with consecutive input
	 *    characters, so that a running hash key can be computed from the previous
	 *    key instead of complete recalculation each time.
	 *//* ===========================================================================
	 * Insert string str in the dictionary and set match_head to the previous head
	 * of the hash chain (the most recent string with same hash key). Return
	 * the previous length of the hash chain.
	 * If this file is compiled with -DFASTEST, the compression level is forced
	 * to 1, and no hash chains are maintained.
	 * IN  assertion: all calls to INSERT_STRING are made with consecutive input
	 *    characters and the first MIN_MATCH bytes of str are valid (except for
	 *    the last MIN_MATCH-1 bytes of the input file).
	 */)};
	public static Object Crc64GenerateTable;
	public static UInt64 Crc64Update = new UInt64();
	public static UInt64 Crc64Calc = new UInt64();
	public static Object hc_timer_set;
	public static double hc_timer_get;
	public static int mycracked;
	public static int myabort_runtime;
	public static int myabort_checkpoint;
	public static int myabort;
	public static int myquit;
	public static int bypass;
	public static int SuspendThreads;
	public static int ResumeThreads;
	public static int stop_at_checkpoint;
	public static byte SIGNATURE_ECRYPTFS = "$ecryptfs$";
	public static int ROUNDS_ECRYPTFS = 65536;
	public static int get_runtime_left;
	public static Object thread_monitor;
	public static Object sha256_transform;
	public static Object sha256_init;
	public static Object sha256_update_64;
	public static Object sha256_update;
	public static Object sha256_update_swap;
	public static Object sha256_update_utf16le;
	public static Object sha256_update_utf16le_swap;
	public static Object sha256_final;
	public static Object sha256_hmac_init_64;
	public static Object sha256_hmac_init;
	public static Object sha256_hmac_init_swap;
	public static Object sha256_hmac_update_64;
	public static Object sha256_hmac_update;
	public static Object sha256_hmac_update_swap;
	public static Object sha256_hmac_update_utf16le;
	public static Object sha256_hmac_update_utf16le_swap;
	public static Object sha256_hmac_final;
	public static Object sha256_transform_vector;
	public static Object sha256_init_vector;
	public static Object sha256_init_vector_from_scalar;
	public static Object sha256_update_vector_64;
	public static Object sha256_update_vector;
	public static Object sha256_update_vector_swap;
	public static Object sha256_update_vector_utf16le;
	public static Object sha256_update_vector_utf16le_swap;
	public static Object sha256_update_vector_utf16beN;
	public static Object sha256_final_vector;
	public static Object sha256_hmac_init_vector_64;
	public static Object sha256_hmac_init_vector;
	public static Object sha256_hmac_update_vector_64;
	public static Object sha256_hmac_update_vector;
	public static Object sha256_hmac_final_vector;
	public static int tuning_db_init;
	public static Object tuning_db_destroy;
	public static  tuning_db_search = new ();
	public static  generate_cmask = new ();
	public static Object append_four_byte;
	public static Object append_three_byte;
	public static Object append_two_byte;
	public static Object append_one_byte;
	public static Object append_block;
	public static Object exchange_byte;
	public static int mangle_lrest;
	public static int mangle_lrest_ufirst;
	public static int mangle_urest;
	public static int mangle_urest_lfirst;
	public static int mangle_trest;
	public static int mangle_toggle_at;
	public static int mangle_reverse;
	public static int mangle_dupeword;
	public static int mangle_dupeword_times;
	public static int mangle_reflect;
	public static int mangle_append;
	public static int mangle_prepend;
	public static int mangle_rotate_left;
	public static int mangle_rotate_right;
	public static int mangle_delete_at;
	public static int mangle_delete_first;
	public static int mangle_delete_last;
	public static int mangle_extract;
	public static int mangle_omit;
	public static int mangle_insert;
	public static int mangle_overstrike;
	public static int mangle_truncate_at;
	public static int mangle_replace;
	public static int mangle_purgechar;
	public static int mangle_dupechar_first;
	public static int mangle_dupechar_last;
	public static int mangle_dupechar_all;
	public static int mangle_switch_first;
	public static int mangle_switch_last;
	public static int mangle_switch_at;
	public static int mangle_chr_shiftl;
	public static int mangle_chr_shiftr;
	public static int mangle_chr_incr;
	public static int mangle_chr_decr;
	public static int mangle_replace_np1;
	public static int mangle_replace_nm1;
	public static int mangle_dupeblock_first;
	public static int mangle_dupeblock_last;
	public static int mangle_title_sep;
	public static int apply_rule;
	public static WRes HandlePtr_Close = new WRes();
	public static WRes Handle_WaitObject = new WRes();
	public static HANDLE CThread = new HANDLE();
	public static int THREAD_FUNC_RET_TYPE;
	public static THREAD_FUNC_RET_TYPE THREAD_FUNC_TYPE = new THREAD_FUNC_RET_TYPE();
	public static WRes Thread_Create = new WRes();
	public static HANDLE CEvent = new HANDLE();
	public static CEvent CAutoResetEvent = new CEvent();
	public static CEvent CManualResetEvent = new CEvent();
	public static WRes Event_Set = new WRes();
	public static WRes Event_Reset = new WRes();
	public static WRes ManualResetEvent_Create = new WRes();
	public static WRes ManualResetEvent_CreateNotSignaled = new WRes();
	public static WRes AutoResetEvent_Create = new WRes();
	public static WRes AutoResetEvent_CreateNotSignaled = new WRes();
	public static HANDLE CSemaphore = new HANDLE();
	public static WRes Semaphore_Create = new WRes();
	public static WRes Semaphore_ReleaseN = new WRes();
	public static WRes Semaphore_Release1 = new WRes();
	public static CRITICAL_SECTION CCriticalSection = new CRITICAL_SECTION();
	public static WRes CriticalSection_Init = new WRes();
	public static  generate_cmask_optimized = new ();
	public static Object truncate_right_optimized;
	public static Object truncate_left_optimized;
	public static Object lshift_block_optimized;
	public static Object rshift_block_optimized;
	public static Object lshift_block_optimized_N;
	public static Object rshift_block_optimized_N;
	public static Object append_block1_optimized;
	public static Object append_block8_optimized;
	public static Object reverse_block_optimized;
	public static Object exchange_byte_optimized;
	public static  rule_op_mangle_lrest = new ();
	public static  rule_op_mangle_urest = new ();
	public static  rule_op_mangle_lrest_ufirst = new ();
	public static  rule_op_mangle_urest_lfirst = new ();
	public static  rule_op_mangle_trest = new ();
	public static  rule_op_mangle_toggle_at = new ();
	public static  rule_op_mangle_reverse = new ();
	public static  rule_op_mangle_dupeword = new ();
	public static  rule_op_mangle_dupeword_times = new ();
	public static  rule_op_mangle_reflect = new ();
	public static  rule_op_mangle_append = new ();
	public static  rule_op_mangle_prepend = new ();
	public static  rule_op_mangle_rotate_left = new ();
	public static  rule_op_mangle_rotate_right = new ();
	public static  rule_op_mangle_delete_first = new ();
	public static  rule_op_mangle_delete_last = new ();
	public static  rule_op_mangle_delete_at = new ();
	public static  rule_op_mangle_extract = new ();
	public static  rule_op_mangle_omit = new ();
	public static  rule_op_mangle_insert = new ();
	public static  rule_op_mangle_overstrike = new ();
	public static  rule_op_mangle_truncate_at = new ();
	public static  search_on_register = new ();
	public static  replace_on_register = new ();
	public static  rule_op_mangle_replace = new ();
	public static  rule_op_mangle_purgechar = new ();
	public static  rule_op_mangle_dupechar_first = new ();
	public static  rule_op_mangle_dupechar_last = new ();
	public static  rule_op_mangle_dupechar_all = new ();
	public static  rule_op_mangle_switch_first = new ();
	public static  rule_op_mangle_switch_last = new ();
	public static  rule_op_mangle_switch_at = new ();
	public static  rule_op_mangle_chr_shiftl = new ();
	public static  rule_op_mangle_chr_shiftr = new ();
	public static  rule_op_mangle_chr_incr = new ();
	public static  rule_op_mangle_chr_decr = new ();
	public static  rule_op_mangle_replace_np1 = new ();
	public static  rule_op_mangle_replace_nm1 = new ();
	public static  rule_op_mangle_dupeblock_first = new ();
	public static  rule_op_mangle_dupeblock_last = new ();
	public static  toggle_on_register = new ();
	public static  rule_op_mangle_title_sep = new ();
	public static  apply_rule_optimized = new ();
	public static Object CrcGenerateTable;
	public static UInt32 CrcUpdate = new UInt32();
	public static UInt32 CrcCalc = new UInt32();
	public static int uint;
	public static long ulong;
	public static byte[] log_gzhead = new byte[]{-1024, /* gzip header for gzlog *//* magic gzip id */-1024, /* compression method is deflate */8, /* there is an extra field (no file name) */4, 0, 0, 0, /* no modification time provided */0, 0, /* no extra flags, no OS specified */-1024, 39, 0, (byte)'a', (byte)'p', 35, /* extra field with "ap" subfield */0/* 35 is EXTRA, 39 is EXTRA + 4 */};
	public static byte[] log_gzext = new byte[]{52, 0, 0, 0, 0, 0, 0, /* should be 16 *//* initial gzip extra field content (52 == HEAD + EXTRA + 1) *//* offset of first stored block length */0, 52, 0, 0, 0, 0, 0, 0, /* offset of last stored block length */0, 0, 0, 0, 0, 0, 0, 0, /* compressed data crc and length */0, 0, 0, 0, 0, 0, 0, 0, /* total data crc and length */0, 0, /* final stored block data length */0, /* op is NO_OP, last bit 8 bits back */5/* should be 35 */};
	public static byte[] log_gzbody = new byte[]{1, 0, 0, -1024, /* initial gzip data and trailer *//* empty stored block (last) */-1024, 0, 0, 0, /* crc */0, 0, 0, 0, /* uncompressed length */0/* Exclusively create foo.lock in order to negotiate exclusive access to the
	   foo.* files.  If the modify time of an existing lock file is greater than
	   PATIENCE seconds in the past, then consider the lock file to have been
	   abandoned, delete it, and try the exclusive create again.  Save the lock
	   file modify time for verification of ownership.  Return 0 on success, or -1
	   on failure, usually due to an access restriction or invalid path.  Note that
	   if stat() or unlink() fails, it may be due to another process noticing the
	   abandoned lock file a smidge sooner and deleting it, so those are not
	   flagged as an error. */};
	public static  cl_d3d10_device_source_khr = new ();
	public static  cl_d3d10_device_set_khr = new ();
	public static byte TGZfname;
	public static Object TGZnotfound;
	public static int getoct;
	public static byte strtime;
	public static int setfiletime;
	public static Object push_attr;
	public static Object restore_attr;
	public static int ExprMatch;
	public static int makedir;
	public static int matchname;
	public static int tar;
	public static Object help;
	public static byte[] TGZsuffix = new byte[]{"\0", ".tar", ".tar.gz", ".taz", ".tgz", ((Object)0/* return the file name of the TGZ archive */)};
	public static int _CRT_glob = /* ============================================================ *//* disable argument globbing in MinGW */0;
	
	
	public static Object module_attack_exec(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		// OPTS_TYPE_ST_ADD80 added within kernelreturn ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		// the self-test is disabled, because the original scrypt settings would create a too long startup timereturn ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		// the self-test can't work because the salt is not part of the code at compile-timereturn ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		// the self-test can't work because the scrypt settings is part of the code at compile-timereturn ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		//6d455b6e8945bebfd0a5878eaa201523:hashcat"; //c8f4f1202e7aaebb14e49903ca973d39:943038186";return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		// actually "hashcat"return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		// ST_HASH_14600  multi-hash-mode algorithm, unlikely to match self-test hash settingsreturn ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		// multi-hash-mode algorithm, unlikely to match self-test hash settingsreturn ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
		return ModernizedCProgram.ATTACK_EXEC;
	}
	public static Object module_dgst_pos0(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
		return ModernizedCProgram.DGST_POS0;
	}
	public static Object module_dgst_pos1(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
		return ModernizedCProgram.DGST_POS1;
	}
	public static Object module_dgst_pos2(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
		return ModernizedCProgram.DGST_POS2;
	}
	public static Object module_dgst_pos3(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
		return ModernizedCProgram.DGST_POS3;
	}
	public static Object module_dgst_size(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
		return ModernizedCProgram.DGST_SIZE;
	}
	public static Object module_hash_category(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
		return ModernizedCProgram.HASH_CATEGORY;
	}
	public static Object module_hash_name(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
		return ModernizedCProgram.HASH_NAME;
	}
	public static Object module_kern_type(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
		return ModernizedCProgram.KERN_TYPE;
	}
	public static Object module_opti_type(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
		return ModernizedCProgram.OPTI_TYPE;
	}
	public static Object module_opts_type(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
		return ModernizedCProgram.OPTS_TYPE;
	}
	public static Object module_salt_type(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
		return ModernizedCProgram.SALT_TYPE;
	}
	public static Object module_st_hash(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
		return ModernizedCProgram.ST_HASH;
	}
	public static Object module_st_pass(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;// limit scrypt accel otherwise we hurt ourself when calculating the scrypt tmto// 16 is actually a bit low, we may need to change this depending on user response
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;// limit scrypt accel otherwise we hurt ourself when calculating the scrypt tmto// 16 is actually a bit low, we may need to change this depending on user response
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;// original headers from luks.h
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
		return ModernizedCProgram.ST_PASS;
	}
	public static Object module_pw_max(Object hashconfig, Object user_options, Object user_options_extra) {
		// https://www.daniel-berlin.de/security/sap-sec/password-hash-algorithms/u32 pw_max = 40;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// https://www.daniel-berlin.de/security/sap-sec/password-hash-algorithms/u32 pw_max = 40;
		return pw_max;
		// http://www.red-database-security.de/whitepaper/oracle_passwords.htmlu32 pw_max = 30;
		return pw_max;
		// https://www.pdflib.com/knowledge-base/pdf-password-security/encryption/u32 pw_max = 32;
		return pw_max;
		u32 pw_max = 64;
		return pw_max;
		// RC4-40 fixedu32 pw_max = 5;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 63;
		return pw_max;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		u32 pw_max = 256;
		if (optimized_kernel == 1) {
			pw_max = 20;
		} 
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// https://www.daniel-berlin.de/security/sap-sec/password-hash-algorithms/u32 pw_max = 8;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// https://msdn.microsoft.com/en-us/library/dd772916(v=office.12).aspxu32 pw_max = 15;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// https://www.pdflib.com/knowledge-base/pdf-password-security/encryption/u32 pw_max = 127;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 64;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		u32 pw_max = 63;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// Underlaying Blowfish maxu32 pw_max = 72;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		// https://www.pdflib.com/knowledge-base/pdf-password-security/encryption/u32 pw_max = 127;
		if (optimized_kernel == 1) {
			pw_max = 16;
		} 
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 256;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		if (optimized_kernel == 1) {
			pw_max = 16;
		} 
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 32;
		return pw_max;
		// RAdmin2 sets w[25] = 0x80u32 pw_max = 100;
		return pw_max;
		// https://www.ibm.com/support/knowledgecenter/en/SSKTWP_8.5.3/com.ibm.notes85.client.doc/fram_limits_of_notes_r.htmlu32 pw_max = 64;
		return pw_max;
		// https://msdn.microsoft.com/en-us/library/dd772916(v=office.12).aspxu32 pw_max = 15;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// Underlaying DES maxu32 pw_max = 8;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// RC4-40 fixedu32 pw_max = 5;
		return pw_max;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		u32 pw_max = (optimized_kernel == 1) ? 15 : 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 256;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		if (optimized_kernel == 1) {
			pw_max = 19;
		} 
		return pw_max;
		// Underlaying 3DES maxu32 pw_max = 24;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		u32 pw_max = 256;
		if (optimized_kernel == 1) {
			pw_max = 24;
		} 
		return pw_max;
		// ChaCha20 fixedu32 pw_max = 32;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// https://www.daniel-berlin.de/security/sap-sec/password-hash-algorithms/u32 pw_max = 40;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		// http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.infocenter.dc31654.1570/html/sag1/CIHIBDBA.htmu32 pw_max = 30;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// Underlaying DES maxu32 pw_max = 8;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 256;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		if (optimized_kernel == 1) {
			pw_max = 15;
		} 
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		u32 pw_max = (optimized_kernel == 1) ? 15 : 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// Skip32 fixedu32 pw_max = 10;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		u32 pw_max = (optimized_kernel == 1) ? 15 : 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256// Bogus SHA-1 in StarOffice codeu32 pw_max = 51;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// https://www.pdflib.com/knowledge-base/pdf-password-security/encryption/u32 pw_max = 32;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		u32 pw_max = (optimized_kernel == 1) ? 15 : 256;
		return pw_max;
		// Lotus Notes/Domino 5 limits itself to 16u32 pw_max = 16;
		return pw_max;
		// https://www.toadworld.com/platforms/oracle/b/weblog/archive/2013/11/12/oracle-12c-passwordsu32 pw_max = 30;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		u32 pw_max = 256;
		if (optimized_kernel == 1) {
			pw_max = 16;
		} 
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		u32 pw_max = 32;
		if (optimized_kernel == 1) {
		} else {
				pw_max = 64;
		} 
		return pw_max;
		// RC4-40 fixedu32 pw_max = 5;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		u32 pw_max = (optimized_kernel == 1) ? 15 : 256;
		return pw_max;
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		// HMAC-MD5 and `doveadm pw` are different for password more than 64 bytesu32 pw_max = (optimized_kernel == 1) ? 55 : 64;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		// https://www.pdflib.com/knowledge-base/pdf-password-security/encryption/u32 pw_max = 32;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// https://msdn.microsoft.com/en-us/library/dd772916(v=office.12).aspxu32 pw_max = 15;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// LM maxu32 pw_max = 7;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// Underlaying DES maxu32 pw_max = 8;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 256u32 pw_max = 256;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
		u32 pw_max = 256;
		return pw_max;
		// https://msdn.microsoft.com/en-us/library/dd772916(v=office.12).aspxu32 pw_max = 15;
		return pw_max;
		// Underlaying DES maxu32 pw_max = 8;
		return pw_max;
		// IOW, even in optimized kernel mode it support length 64u32 pw_max = 64;
		return pw_max;
	}
	public static boolean module_unstable_warning(Object hashconfig, Object user_options, Object user_options_extra, Object device_param) {
		// amdgpu-pro-18.50-708488-ubuntu-18.04:  password not foundif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: self-test failedif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		// OpenCL 1.2 pocl HSTR: pthread-x86_64-pc-linux-gnu-skylake: Segmentation faultif (device_param.getOpencl_platform_vendor_id() == vendor_id.VENDOR_ID_POCL) {
			return 1;
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: CL_OUT_OF_RESOURCESif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		if (device_param.getOpencl_platform_vendor_id() == vendor_id.VENDOR_ID_APPLE) {
			if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_INTEL_SDK) && (device_param.getOpencl_device_type() & CL_DEVICE_TYPE_GPU)) {
				return 1;
			} 
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: Segmentation faultif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		// OpenCL 1.2 pocl HSTR: pthread-x86_64-pc-linux-gnu-skylake: Segmentation faultif (device_param.getOpencl_platform_vendor_id() == vendor_id.VENDOR_ID_POCL) {
			return 1;
		} 
		// l_opencl_p_18.1.0.013: password not foundif (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_INTEL_SDK) {
			if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) {
				return 1;
			} 
		} 
		// amdgpu-pro-18.50-708488-ubuntu-18.04: Segmentation faultif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 1) {
				return 1;
			} 
		} 
		// amdgpu-pro-18.50-708488-ubuntu-18.04: self-test failed.if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) {
				return 1;
			} 
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: Segmentation faultif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) {
				return 1;
			} 
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: CL_OUT_OF_RESOURCESif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		// OpenCL 1.2 pocl HSTR: pthread-x86_64-pc-linux-gnu-skylake: Segmentation faultif (device_param.getOpencl_platform_vendor_id() == vendor_id.VENDOR_ID_POCL) {
			return 1;
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: CL_OUT_OF_RESOURCESif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) {
				return 1;
			} 
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: Segmentation faultif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: Segmentation faultif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 1) {
				return 1;
			} 
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04:  password not foundif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		if (device_param.getOpencl_platform_vendor_id() == vendor_id.VENDOR_ID_APPLE) {
			if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_INTEL_SDK) && (device_param.getOpencl_device_type() & CL_DEVICE_TYPE_GPU)) {
				return 1;
			} 
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: CL_OUT_OF_RESOURCESif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: CL_OUT_OF_RESOURCESif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) {
				return 1;
			} 
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: CL_OUT_OF_RESOURCESif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) {
				return 1;
			} 
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: CL_OUT_OF_RESOURCESif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			if ((hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) {
				return 1;
			} 
		} 
		return 0;
		// OpenCL 1.2 pocl HSTR: pthread-x86_64-pc-linux-gnu-skylake: self-test failedif (device_param.getOpencl_platform_vendor_id() == vendor_id.VENDOR_ID_POCL) {
			return 1;
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: Segmentation faultif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: CL_OUT_OF_RESOURCESif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		if (device_param.getOpencl_platform_vendor_id() == vendor_id.VENDOR_ID_APPLE) {
			if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_INTEL_SDK) && (device_param.getOpencl_device_type() & CL_DEVICE_TYPE_GPU)) {
				return 1;
			} 
		} 
		// amdgpu-pro-18.50-708488-ubuntu-18.04: self-test failedif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		// amdgpu-pro-18.50-708488-ubuntu-18.04: Segmentation faultif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
		if (device_param.getOpencl_platform_vendor_id() == vendor_id.VENDOR_ID_APPLE) {
			if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_INTEL_SDK) && (device_param.getOpencl_device_type() & CL_DEVICE_TYPE_GPU)) {
				return 1;
			} 
		} 
		// amdgpu-pro-18.50-708488-ubuntu-18.04: self-test failedif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			return 1;
		} 
		return 0;
	}
	public static int module_hash_decode(Object hashconfig, Object digest_buf, salt salt, Object esalt_buf, Object hook_salt_buf, hashinfo hash_info, Object line_buf, Object line_len) {
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'$';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[1] = 40;
		generatedLen_max[1] = 40;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer/**
			   * salt
			   */);
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[0];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[0];
		int user_len = 0;
		for (int i = 0;
		 i < salt_len; i++) {
			if (salt_pos[i] == (byte)' ') {
				continue;
			} 
			user_len++;
		}
		// SAP user names cannot be longer than 12 charactersif (user_len > 12) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// SAP user name cannot start with ! or ?if (salt_pos[0] == (byte)'!' || salt_pos[0] == (byte)'?') {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH/**
			   * hash
			   */);
		} 
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u32((u8)hash_pos[0]);
		digest[1] = ModernizedCProgram.hex_to_u32((u8)hash_pos[8]);
		digest[2] = ModernizedCProgram.hex_to_u32((u8)hash_pos[16]);
		digest[3] = ModernizedCProgram.hex_to_u32((u8)hash_pos[24]);
		digest[4] = ModernizedCProgram.hex_to_u32((u8)hash_pos[32]);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		devise_hash_t devise_double_salt = (devise_hash_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[1] = hashconfig.getSeparator();
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[2] = hashconfig.getSeparator();
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 256;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedLen_min[2] *= 2;
			generatedLen_max[2] *= 2;
			generatedAttr[2] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		Object generatedLen = token.getLen();
		Object generatedSalt_buf = devise_double_salt.getSalt_buf();
		int generatedSalt_len = devise_double_salt.getSalt_len();
		boolean parse_rc1 = ModernizedCProgram.generic_salt_decode(hashconfig, generatedBuf[1], generatedLen[1], (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc1 == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSite_key_buf = devise_double_salt.getSite_key_buf();
		int generatedSite_key_len = devise_double_salt.getSite_key_len();
		boolean parse_rc2 = ModernizedCProgram.generic_salt_decode(hashconfig, generatedBuf[2], generatedLen[2], (u8)generatedSite_key_buf, (int)generatedSite_key_len);
		if (parse_rc2 == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// make salt sorter happy
		md5_ctx_t md5_ctx = new md5_ctx_t();
		.md5_init(md5_ctx);
		.md5_update(md5_ctx, generatedSalt_buf, generatedSalt_len);
		.md5_update(md5_ctx, generatedSite_key_buf, generatedSite_key_len);
		.md5_final(md5_ctx);
		Object generatedH = md5_ctx.getH();
		generatedSalt_buf[0] = generatedH[0];
		generatedSalt_buf[1] = generatedH[1];
		generatedSalt_buf[2] = generatedH[2];
		generatedSalt_buf[3] = generatedH[3];
		salt.setSalt_len(16);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 40;
		generatedLen_max[1] = 40;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_64_constants.SHA512M_A;
			digest[1] -= sha2_64_constants.SHA512M_B;
			digest[2] -= sha2_64_constants.SHA512M_C;
			digest[3] -= sha2_64_constants.SHA512M_D;
			digest[4] -= sha2_64_constants.SHA512M_E;
			digest[5] -= sha2_64_constants.SHA512M_F;
			digest[6] -= sha2_64_constants.SHA512M_G;
			digest[7] -= sha2_64_constants.SHA512M_H;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(5);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_AXCRYPT;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 9;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)'*';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 6;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[4] = (byte)'*';
		generatedLen_min[4] = 48;
		generatedLen_max[4] = 48;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		Object generatedBuf = token.getBuf();
		u8 wrapping_rounds_pos = generatedBuf[2];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)wrapping_rounds_pos, ((Object)0), 10))// salt;// salt
		u8 wrapped_key_pos = generatedBuf[3];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(wrapped_key_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(wrapped_key_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(wrapped_key_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(wrapped_key_pos + 24);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3])// data;// data
		u8 data_pos = generatedBuf[4];
		generatedSalt_buf[4] = ModernizedCProgram.hex_to_u32(data_pos + 0);
		generatedSalt_buf[5] = ModernizedCProgram.hex_to_u32(data_pos + 8);
		generatedSalt_buf[6] = ModernizedCProgram.hex_to_u32(data_pos + 16);
		generatedSalt_buf[7] = ModernizedCProgram.hex_to_u32(data_pos + 24);
		generatedSalt_buf[8] = ModernizedCProgram.hex_to_u32(data_pos + 32);
		generatedSalt_buf[9] = ModernizedCProgram.hex_to_u32(data_pos + 40);
		generatedSalt_buf[4] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[4]);
		generatedSalt_buf[5] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[5]);
		generatedSalt_buf[6] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[6]);
		generatedSalt_buf[7] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[7]);
		generatedSalt_buf[8] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[8]);
		generatedSalt_buf[9] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[9]);
		salt.setSalt_len(40);
		digest[0] = generatedSalt_buf[0];
		digest[1] = generatedSalt_buf[1];
		digest[2] = generatedSalt_buf[2];
		digest[3] = generatedSalt_buf[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_BSDICRYPT;
		Object generatedLen = token.getLen();
		generatedLen[0] = 1;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen[1] = 4;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		generatedLen[2] = 4;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		generatedLen[3] = 11;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iteration count
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		salt.setSalt_iter(ModernizedCProgram.itoa64_to_int(iter_pos[0]) | ModernizedCProgram.itoa64_to_int(iter_pos[1]) << 6 | ModernizedCProgram.itoa64_to_int(iter_pos[2]) << 12 | ModernizedCProgram.itoa64_to_int(iter_pos[3]) << 18);
		// set saltu8 salt_pos = generatedBuf[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.itoa64_to_int(salt_pos[0]) | ModernizedCProgram.itoa64_to_int(salt_pos[1]) << 6 | ModernizedCProgram.itoa64_to_int(salt_pos[2]) << 12 | ModernizedCProgram.itoa64_to_int(salt_pos[3]) << 18;
		salt.setSalt_len(4)// hash;// hash
		u8 hash_pos = generatedBuf[3];
		int hash_len = generatedLen[3];
		byte c19 = ModernizedCProgram.itoa64_to_int(hash_pos[10]);
		if (c19 & 3) {
			return (parser_rc.PARSER_HASH_VALUE);
		} 
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.itoa64_to_int, hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, 8);
		{ 
			{ 
				u32x t = new u32x();
				t = digest[1] >> 4;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 4;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 16;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 16;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 2;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 2;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 8;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 8;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 1;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 1;
				digest[1] = digest[1] ^ t;
			}
			;
		}
		;
		digest[0] = ModernizedCProgram.rotr32(digest[0], 31);
		digest[1] = ModernizedCProgram.rotr32(digest[1], 31);
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_EPISERVER;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 11;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 11;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = ((0 * 8) / 6) + 0;
		generatedLen_max[2] = ((256 * 8) / 6) + 3;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		generatedLen_min[3] = 27;
		generatedLen_max[3] = 27;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[3];
		Object generatedLen = token.getLen();
		int hash_len = generatedLen[3];
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, 20);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'@';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 0;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[1] = (byte)'@';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 8;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[2] = (byte)'@';
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 128;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'@';
		generatedLen_min[3] = 8;
		generatedLen_max[3] = 16;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// check hash type
		Object generatedBuf = token.getBuf();
		if (generatedBuf[1][0] != (byte)'s') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		// check iter
		u32 iter = ModernizedCProgram.ROUNDS_QNX;
		Object generatedLen = token.getLen();
		if (generatedLen[1] > 1) {
			if (generatedBuf[1][1] != (byte)',') {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
			iter = ModernizedCProgram.hc_strtoul((byte)generatedBuf[1] + 2, ((Object)0), 10);
		} 
		// iter++; the additinal round is added in the init kernel// iter++; the additinal round is added in the init kernelsalt.setSalt_iter(iter)// digest;// digest
		if (generatedLen[2] != 64) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 0);
		digest[1] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 8);
		digest[2] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 16);
		digest[3] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 24);
		digest[4] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 32);
		digest[5] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 40);
		digest[6] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 48);
		digest[7] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 56)// salt;// salt
		Object generatedSalt_buf = salt.getSalt_buf();
		if ((generatedLen[3] == 8) || (generatedLen[3] == 16)) {
			.memcpy(generatedSalt_buf, generatedBuf[3], generatedLen[3]);
			salt.setSalt_len(generatedLen[3]);
		} else {
				return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_AUTHME;
		Object generatedLen = token.getLen();
		generatedLen[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 16;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 16;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 64;
		generatedLen_max[2] = 64;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// salt
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy((u8)generatedSalt_buf, salt_pos, salt_len);
		salt.setSalt_len(salt_len)// hash;// hash
		u8 hash_pos = generatedBuf[2];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SHA512AIX;
		Object generatedLen = token.getLen();
		generatedLen[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 2;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 2;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[2] = 16;
		generatedLen_max[2] = 48;
		generatedSep[2] = (byte)'$';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen[3] = 86;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		byte[] salt_iter = new byte[]{iter_pos[0], iter_pos[1], 0};
		Object generatedSalt_sign = salt.getSalt_sign();
		generatedSalt_sign[0] = ModernizedCProgram.hc_strtoul((byte)salt_iter, ((Object)0), 10);
		salt.setSalt_iter((-1024 << ModernizedCProgram.hc_strtoul((byte)salt_iter, ((Object)0), 10)) - 1);
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 hash_pos = generatedBuf[3];
		ModernizedCProgram.sha512aix_decode((u8)digest, hash_pos);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SAPH_SHA1;
		Object generatedLen = token.getLen();
		generatedLen[0] = 10;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'}';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 49;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		if (iter < 1) {
			return (parser_rc.PARSER_SALT_ITERATION);
		} 
		// first iteration is special// first iteration is specialiter--;
		salt.setSalt_iter(iter)// decode;// decode
		u8 base64_pos = generatedBuf[2];
		int base64_len = generatedLen[2];
		u8[] tmp_buf = new u8[]{0};
		u32 decoded_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, (u8)base64_pos, base64_len, tmp_buf);
		if (decoded_len < 24) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// copy the salt
		u32 salt_len = decoded_len - 20;
		if (salt_len > 16) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy(generatedSalt_buf, tmp_buf + 20, salt_len);
		salt.setSalt_len(salt_len)// set digest;// set digest
		u32 digest_ptr = (u32)tmp_buf;
		digest[0] = ModernizedCProgram.byte_swap_32(digest_ptr[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest_ptr[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest_ptr[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest_ptr[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest_ptr[4]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 16;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 16;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 30;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = 0;
		digest[3] = 0;
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pdf_t pdf = (pdf_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(12);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PDF;
		Object generatedLen = token.getLen();
		generatedLen[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 2;
		generatedLen_max[3] = 2;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 1;
		generatedLen_max[4] = 6;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[5] = 1;
		generatedLen_max[5] = 1;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[6] = 2;
		generatedLen_max[6] = 2;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[7] = 32;
		generatedLen_max[7] = 32;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[8] = 2;
		generatedLen_max[8] = 2;
		generatedSep[8] = (byte)'*';
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[9] = 64;
		generatedLen_max[9] = 64;
		generatedSep[9] = (byte)'*';
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[10] = 2;
		generatedLen_max[10] = 2;
		generatedSep[10] = (byte)'*';
		generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[11] = 64;
		generatedLen_max[11] = 64;
		generatedSep[11] = (byte)'*';
		generatedAttr[11] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 V_pos = generatedBuf[1];
		u8 R_pos = generatedBuf[2];
		u8 bits_pos = generatedBuf[3];
		u8 P_pos = generatedBuf[4];
		u8 enc_md_pos = generatedBuf[5];
		u8 id_len_pos = generatedBuf[6];
		u8 id_buf_pos = generatedBuf[7];
		u8 u_len_pos = generatedBuf[8];
		u8 u_buf_pos = generatedBuf[9];
		u8 o_len_pos = generatedBuf[10];
		u8 o_buf_pos = generatedBuf[11];
		// validate data
		int V = .strtol((byte)V_pos, ((Object)0), 10);
		int R = .strtol((byte)R_pos, ((Object)0), 10);
		int P = .strtol((byte)P_pos, ((Object)0), 10);
		if (V != 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (R != 2) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int enc_md = .strtol((byte)enc_md_pos, ((Object)0), 10);
		if ((enc_md != 0) && (enc_md != 1)) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int id_len = .strtol((byte)id_len_pos, ((Object)0), 10);
		int u_len = .strtol((byte)u_len_pos, ((Object)0), 10);
		int o_len = .strtol((byte)o_len_pos, ((Object)0), 10);
		if (id_len != 16) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (u_len != 32) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (o_len != 32) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int bits = .strtol((byte)bits_pos, ((Object)0), 10);
		if (bits != 40) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		// copy data to esalt
		pdf.setV(V);
		pdf.setR(R);
		pdf.setP(P);
		pdf.setEnc_md(enc_md);
		Object generatedId_buf = pdf.getId_buf();
		generatedId_buf[0] = ModernizedCProgram.hex_to_u32(id_buf_pos + 0);
		generatedId_buf[1] = ModernizedCProgram.hex_to_u32(id_buf_pos + 8);
		generatedId_buf[2] = ModernizedCProgram.hex_to_u32(id_buf_pos + 16);
		generatedId_buf[3] = ModernizedCProgram.hex_to_u32(id_buf_pos + 24);
		pdf.setId_len(id_len);
		Object generatedU_buf = pdf.getU_buf();
		generatedU_buf[0] = ModernizedCProgram.hex_to_u32(u_buf_pos + 0);
		generatedU_buf[1] = ModernizedCProgram.hex_to_u32(u_buf_pos + 8);
		generatedU_buf[2] = ModernizedCProgram.hex_to_u32(u_buf_pos + 16);
		generatedU_buf[3] = ModernizedCProgram.hex_to_u32(u_buf_pos + 24);
		generatedU_buf[4] = ModernizedCProgram.hex_to_u32(u_buf_pos + 32);
		generatedU_buf[5] = ModernizedCProgram.hex_to_u32(u_buf_pos + 40);
		generatedU_buf[6] = ModernizedCProgram.hex_to_u32(u_buf_pos + 48);
		generatedU_buf[7] = ModernizedCProgram.hex_to_u32(u_buf_pos + 56);
		pdf.setU_len(u_len);
		Object generatedO_buf = pdf.getO_buf();
		generatedO_buf[0] = ModernizedCProgram.hex_to_u32(o_buf_pos + 0);
		generatedO_buf[1] = ModernizedCProgram.hex_to_u32(o_buf_pos + 8);
		generatedO_buf[2] = ModernizedCProgram.hex_to_u32(o_buf_pos + 16);
		generatedO_buf[3] = ModernizedCProgram.hex_to_u32(o_buf_pos + 24);
		generatedO_buf[4] = ModernizedCProgram.hex_to_u32(o_buf_pos + 32);
		generatedO_buf[5] = ModernizedCProgram.hex_to_u32(o_buf_pos + 40);
		generatedO_buf[6] = ModernizedCProgram.hex_to_u32(o_buf_pos + 48);
		generatedO_buf[7] = ModernizedCProgram.hex_to_u32(o_buf_pos + 56);
		pdf.setO_len(o_len)// we use ID for salt, maybe needs to change, we will see...;// we use ID for salt, maybe needs to change, we will see...
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedId_buf[0];
		generatedSalt_buf[1] = generatedId_buf[1];
		generatedSalt_buf[2] = generatedId_buf[2];
		generatedSalt_buf[3] = generatedId_buf[3];
		int generatedId_len = pdf.getId_len();
		salt.setSalt_len(generatedId_len);
		digest[0] = generatedU_buf[0];
		digest[1] = generatedU_buf[1];
		digest[2] = generatedU_buf[2];
		digest[3] = generatedU_buf[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		wpa_eapol_t wpa_eapol = (wpa_eapol_t)esalt_buf;
		// the *wpa was partially initialized beforehand, we can not simply memset it to zero
		hccapx_t in = new hccapx_t();
		.memcpy(in, line_buf, );
		Object generatedSignature = in.getSignature();
		if (generatedSignature != -1024) {
			return (parser_rc.PARSER_HCCAPX_SIGNATURE);
		} 
		Object generatedVersion = in.getVersion();
		if (generatedVersion != 4) {
			return (parser_rc.PARSER_HCCAPX_VERSION);
		} 
		Object generatedEapol_len = in.getEapol_len();
		if (generatedEapol_len < 1 || generatedEapol_len > 255) {
			return (parser_rc.PARSER_HCCAPX_EAPOL_LEN);
		} 
		Object generatedKeymic = wpa_eapol.getKeymic();
		.memcpy(generatedKeymic, generatedKeymic, 16/*
		    http://www.one-net.eu/jsw/j_sec/m_ptype.html
		    The phrase "Pairwise key expansion"
		    Access Point Address (referred to as Authenticator Address AA)
		    Supplicant Address (referred to as Supplicant Address SA)
		    Access Point Nonce (referred to as Authenticator Anonce)
		    Wireless Device Nonce (referred to as Supplicant Nonce Snonce)
		  */);
		Object generatedEssid_len = in.getEssid_len();
		u32 salt_len = generatedEssid_len;
		if (salt_len > 32) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedEssid = in.getEssid();
		.memcpy(generatedSalt_buf, generatedEssid, generatedEssid_len);
		salt.setSalt_len(salt_len);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_WPA_PMK - 1);
		.memcpy(generatedEssid, generatedEssid, generatedEssid_len);
		wpa_eapol.setEssid_len(generatedEssid_len);
		Object generatedKeyver = in.getKeyver();
		wpa_eapol.setKeyver(generatedKeyver);
		if ((generatedKeyver != 0) && (generatedKeyver != 1) && (generatedKeyver != 2) && (generatedKeyver != 3)) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedPke = wpa_eapol.getPke();
		u8 pke_ptr = (u8)generatedPke;
		.memset(pke_ptr, 0, 128);
		Object generatedMac_ap = in.getMac_ap();
		Object generatedMac_sta = in.getMac_sta();
		Object generatedNonce_ap = in.getNonce_ap();
		Object generatedNonce_sta = in.getNonce_sta();
		Object generatedNonce_compare = wpa_eapol.getNonce_compare();
		if ((generatedKeyver == 1) || (generatedKeyver == 2)) {
			.memcpy(pke_ptr, "Pairwise key expansion", 23);
			if (.memcmp(generatedMac_ap, generatedMac_sta, 6) < 0) {
				.memcpy(pke_ptr + 23, generatedMac_ap, 6);
				.memcpy(pke_ptr + 29, generatedMac_sta, 6);
			} else {
					.memcpy(pke_ptr + 23, generatedMac_sta, 6);
					.memcpy(pke_ptr + 29, generatedMac_ap, 6);
			} 
			wpa_eapol.setNonce_compare(.memcmp(generatedNonce_ap, generatedNonce_sta, 32));
			if (generatedNonce_compare < 0) {
				.memcpy(pke_ptr + 35, generatedNonce_ap, 32);
				.memcpy(pke_ptr + 67, generatedNonce_sta, 32);
			} else {
					.memcpy(pke_ptr + 35, generatedNonce_sta, 32);
					.memcpy(pke_ptr + 67, generatedNonce_ap, 32);
			} 
		}  else if ((generatedKeyver == 0) || (generatedKeyver == 3)) {
			pke_ptr[0] = 1;
			pke_ptr[1] = 0;
			.memcpy(pke_ptr + 2, "Pairwise key expansion", 22);
			if (.memcmp(generatedMac_ap, generatedMac_sta, 6) < 0) {
				.memcpy(pke_ptr + 24, generatedMac_ap, 6);
				.memcpy(pke_ptr + 30, generatedMac_sta, 6);
			} else {
					.memcpy(pke_ptr + 24, generatedMac_sta, 6);
					.memcpy(pke_ptr + 30, generatedMac_ap, 6);
			} 
			wpa_eapol.setNonce_compare(.memcmp(generatedNonce_ap, generatedNonce_sta, 32));
			if (generatedNonce_compare < 0) {
				.memcpy(pke_ptr + 36, generatedNonce_ap, 32);
				.memcpy(pke_ptr + 68, generatedNonce_sta, 32);
			} else {
					.memcpy(pke_ptr + 36, generatedNonce_sta, 32);
					.memcpy(pke_ptr + 68, generatedNonce_ap, 32);
			} 
			pke_ptr[100] = -1024;
			pke_ptr[101] = 1;
		} 
		for (int i = 0;
		 i < 32; i++) {
			generatedPke[i] = ModernizedCProgram.byte_swap_32(generatedPke[i]);
		}
		Object generatedOrig_mac_ap = wpa_eapol.getOrig_mac_ap();
		.memcpy(generatedOrig_mac_ap, generatedMac_ap, 6);
		Object generatedOrig_mac_sta = wpa_eapol.getOrig_mac_sta();
		.memcpy(generatedOrig_mac_sta, generatedMac_sta, 6);
		Object generatedOrig_nonce_ap = wpa_eapol.getOrig_nonce_ap();
		.memcpy(generatedOrig_nonce_ap, generatedNonce_ap, 32);
		Object generatedOrig_nonce_sta = wpa_eapol.getOrig_nonce_sta();
		.memcpy(generatedOrig_nonce_sta, generatedNonce_sta, 32);
		Object generatedMessage_pair = in.getMessage_pair();
		u8 message_pair_orig = generatedMessage_pair;
		// ignore the highest bit (it is used to indicate if the replay counters did match)// ignore the highest bit (it is used to indicate if the replay counters did match)generatedMessage_pair &=  -1024;
		Object generatedMessage_pair_chgd = wpa_eapol.getMessage_pair_chgd();
		if (generatedMessage_pair_chgd == 1) {
			if (generatedMessage_pair != generatedMessage_pair) {
				return (parser_rc.PARSER_HCCAPX_MESSAGE_PAIR);
			} 
		} 
		wpa_eapol.setMessage_pair(message_pair_orig);
		wpa_eapol.setEapol_len(generatedEapol_len);
		Object generatedEapol = wpa_eapol.getEapol();
		u8 eapol_ptr = (u8)generatedEapol;
		.memcpy(eapol_ptr, generatedEapol, generatedEapol_len);
		.memset(eapol_ptr + generatedEapol_len, 0, (256 + 64) - generatedEapol_len);
		eapol_ptr[generatedEapol_len] = -1024;
		if (generatedKeyver == 1) {
		}  else if (generatedKeyver == 2) {
			generatedKeymic[0] = ModernizedCProgram.byte_swap_32(generatedKeymic[0]);
			generatedKeymic[1] = ModernizedCProgram.byte_swap_32(generatedKeymic[1]);
			generatedKeymic[2] = ModernizedCProgram.byte_swap_32(generatedKeymic[2]);
			generatedKeymic[3] = ModernizedCProgram.byte_swap_32(generatedKeymic[3]);
			for (int i = 0;
			 i < 64; i++) {
				generatedEapol[i] = ModernizedCProgram.byte_swap_32(generatedEapol[i]);
			}
		}  else if ((generatedKeyver == 0) || (generatedKeyver == 3)) {
		} 
		// nothing to do
		// Create a hash of the nonce as ESSID is not unique enough// Not a regular MD5 but good enough// We can also ignore cases where we should bzero the work bufferu32[] hash = new u32();
		hash[0] = 0;
		hash[1] = 1;
		hash[2] = 2;
		hash[3] = 3;
		u32[] block = new u32();
		.memset(block, 0, );
		u8 block_ptr = (u8)block;
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedSalt_buf[i];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedPke[i + 0];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedPke[i + 16];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedEapol[i + 0];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedEapol[i + 16];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedEapol[i + 32];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedEapol[i + 48];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 6; i++) {
			block_ptr[i + 0] = generatedOrig_mac_ap[i];
		}
		for (int i = 0;
		 i < 6; i++) {
			block_ptr[i + 6] = generatedOrig_mac_sta[i];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 32; i++) {
			block_ptr[i + 0] = generatedOrig_nonce_ap[i];
		}
		for (int i = 0;
		 i < 32; i++) {
			block_ptr[i + 32] = generatedOrig_nonce_sta[i];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		block[0] = generatedKeymic[0];
		block[1] = generatedKeymic[1];
		block[2] = generatedKeymic[2];
		block[3] = generatedKeymic[3];
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash)// make all this stuff unique;// make all this stuff unique
		digest[0] = hash[0];
		digest[1] = hash[1];
		digest[2] = hash[2];
		digest[3] = hash[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		oldoffice34_t oldoffice34 = (oldoffice34_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(5);
		token.setSignatures_cnt(2);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_OLDOFFICE3;
		generatedSignatures_buf[1] = ModernizedCProgram.SIGNATURE_OLDOFFICE4;
		Object generatedLen = token.getLen();
		generatedLen[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 32;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[4] = 40;
		generatedLen_max[4] = 40;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 osalt_pos = generatedBuf[2];
		u8 encryptedVerifier_pos = generatedBuf[3];
		u8 encryptedVerifierHash_pos = generatedBuf[4];
		// esalt
		u32 version = version_pos - -1024;
		if (version != 3 && version != 4) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		oldoffice34.setVersion(version);
		Object generatedEncryptedVerifier = oldoffice34.getEncryptedVerifier();
		generatedEncryptedVerifier[0] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 0);
		generatedEncryptedVerifier[1] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 8);
		generatedEncryptedVerifier[2] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 16);
		generatedEncryptedVerifier[3] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 24);
		Object generatedEncryptedVerifierHash = oldoffice34.getEncryptedVerifierHash();
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 0);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 8);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 16);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 24);
		generatedEncryptedVerifierHash[4] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 32)// salt;// salt
		salt.setSalt_len(16);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(osalt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(osalt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(osalt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(osalt_pos + 24);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3])// this is a workaround as office produces multiple documents with the same salt;// this is a workaround as office produces multiple documents with the same salt
		generatedSalt_buf[4] = generatedEncryptedVerifier[0];
		generatedSalt_buf[5] = generatedEncryptedVerifier[1];
		generatedSalt_buf[6] = generatedEncryptedVerifier[2];
		generatedSalt_buf[7] = generatedEncryptedVerifier[3];
		generatedSalt_buf[8] = generatedEncryptedVerifierHash[0];
		generatedSalt_buf[9] = generatedEncryptedVerifierHash[1];
		generatedSalt_buf[10] = generatedEncryptedVerifierHash[2];
		generatedSalt_buf[11] = generatedEncryptedVerifierHash[3];
		Object generatedSalt_len = salt.getSalt_len();
		generatedSalt_len += 32/**
		   * digest
		   */;
		digest[0] = generatedEncryptedVerifierHash[0];
		digest[1] = generatedEncryptedVerifierHash[1];
		digest[2] = generatedEncryptedVerifierHash[2];
		digest[3] = generatedEncryptedVerifierHash[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MYWALLETV2;
		Object generatedLen = token.getLen();
		generatedLen[0] = 15;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 5;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 64;
		generatedLen_max[3] = 20000;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		salt.setSalt_iter(iter - 1)// salt;// salt
		u8 data_pos = generatedBuf[3];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32((u8)data_pos[0]);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32((u8)data_pos[8]);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32((u8)data_pos[16]);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32((u8)data_pos[24]);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3])// this is actually the CT, which is also the hash later (if matched);// this is actually the CT, which is also the hash later (if matched)
		generatedSalt_buf[4] = ModernizedCProgram.hex_to_u32((u8)data_pos[32]);
		generatedSalt_buf[5] = ModernizedCProgram.hex_to_u32((u8)data_pos[40]);
		generatedSalt_buf[6] = ModernizedCProgram.hex_to_u32((u8)data_pos[48]);
		generatedSalt_buf[7] = ModernizedCProgram.hex_to_u32((u8)data_pos[56]);
		generatedSalt_buf[4] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[4]);
		generatedSalt_buf[5] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[5]);
		generatedSalt_buf[6] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[6]);
		generatedSalt_buf[7] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[7]);
		// note we need to fix this to 16 in kernel// note we need to fix this to 16 in kernelsalt.setSalt_len(32)// hash;// hash
		digest[0] = generatedSalt_buf[4];
		digest[1] = generatedSalt_buf[5];
		digest[2] = generatedSalt_buf[6];
		digest[3] = generatedSalt_buf[7];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		ikepsk_t ikepsk = (ikepsk_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(9);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 1024;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[1] = (byte)':';
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 1024;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[2] = (byte)':';
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 1024;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)':';
		generatedLen_min[3] = 0;
		generatedLen_max[3] = 1024;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[4] = (byte)':';
		generatedLen_min[4] = 0;
		generatedLen_max[4] = 1024;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[5] = (byte)':';
		generatedLen_min[5] = 0;
		generatedLen_max[5] = 1024;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[6] = (byte)':';
		generatedLen_min[6] = 0;
		generatedLen_max[6] = 128;
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[7] = (byte)':';
		generatedLen_min[7] = 0;
		generatedLen_max[7] = 128;
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[8] = (byte)':';
		generatedLen_min[8] = 32;
		generatedLen_max[8] = 32;
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedMsg_len = ikepsk.getMsg_len();
		Object generatedLen = token.getLen();
		generatedMsg_len[0] = generatedLen[0] / 2;
		generatedMsg_len[1] = generatedMsg_len[0] + generatedLen[1] / 2;
		generatedMsg_len[2] = generatedMsg_len[1] + generatedLen[2] / 2;
		generatedMsg_len[3] = generatedMsg_len[2] + generatedLen[3] / 2;
		generatedMsg_len[4] = generatedMsg_len[3] + generatedLen[4] / 2;
		generatedMsg_len[5] = generatedMsg_len[4] + generatedLen[5] / 2;
		ikepsk.setNr_len((generatedLen[6] + generatedLen[7]) / 2);
		if (generatedMsg_len[5] > 512) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedNr_len = ikepsk.getNr_len();
		if (generatedNr_len > 64) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedMsg_buf = ikepsk.getMsg_buf();
		u8 ptr1 = (u8)generatedMsg_buf;
		Object generatedNr_buf = ikepsk.getNr_buf();
		u8 ptr2 = (u8)generatedNr_buf;
		Object generatedBuf = token.getBuf();
		for (int i = 0;
		 i < generatedLen[0]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[0] + i);
		}
		for (int i = 0;
		 i < generatedLen[1]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[1] + i);
		}
		for (int i = 0;
		 i < generatedLen[2]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[2] + i);
		}
		for (int i = 0;
		 i < generatedLen[3]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[3] + i);
		}
		for (int i = 0;
		 i < generatedLen[4]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[4] + i);
		}
		for (int i = 0;
		 i < generatedLen[5]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[5] + i);
		}
		for (int i = 0;
		 i < generatedLen[6]; i += 2) {
			ptr2++ = ModernizedCProgram.hex_to_u8(generatedBuf[6] + i);
		}
		for (int i = 0;
		 i < generatedLen[7]; i += 2) {
			ptr2++ = ModernizedCProgram.hex_to_u8(generatedBuf[7] + i);
		}
		ptr1++ = -1024;
		ptr2++ = -1024/**
		   * Store to database
		   */;
		u8 hash_pos = generatedBuf[8];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		salt.setSalt_len(32);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedNr_buf[0];
		generatedSalt_buf[1] = generatedNr_buf[1];
		generatedSalt_buf[2] = generatedNr_buf[2];
		generatedSalt_buf[3] = generatedNr_buf[3];
		generatedSalt_buf[4] = generatedNr_buf[4];
		generatedSalt_buf[5] = generatedNr_buf[5];
		generatedSalt_buf[6] = generatedNr_buf[6];
		generatedSalt_buf[7] = generatedNr_buf[7];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_POSTGRESQL_AUTH;
		Object generatedLen = token.getLen();
		generatedLen[0] = 10;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 32;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 8;
		generatedLen_max[2] = 8;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// hash
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[3];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D/*
			   * store salt
			   */;
		} 
		u8 salt_pos = generatedBuf[2];
		// first 4 bytes are the "challenge"
		Object generatedSalt_buf = salt.getSalt_buf();
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		salt_buf_ptr[0] = ModernizedCProgram.hex_to_u8(salt_pos + 0);
		salt_buf_ptr[1] = ModernizedCProgram.hex_to_u8(salt_pos + 2);
		salt_buf_ptr[2] = ModernizedCProgram.hex_to_u8(salt_pos + 4);
		salt_buf_ptr[3] = ModernizedCProgram.hex_to_u8(salt_pos + 6)// append the user name;// append the user name
		u8 user_pos = generatedBuf[1];
		int user_len = generatedLen[1];
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, user_pos, user_len, salt_buf_ptr + 4, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		generatedSalt_len += 4;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		wpa_eapol_t wpa_eapol = (wpa_eapol_t)esalt_buf;
		// the *wpa was partially initialized beforehand, we can not simply memset it to zero
		hccapx_t in = new hccapx_t();
		.memcpy(in, line_buf, );
		Object generatedSignature = in.getSignature();
		if (generatedSignature != -1024) {
			return (parser_rc.PARSER_HCCAPX_SIGNATURE);
		} 
		Object generatedVersion = in.getVersion();
		if (generatedVersion != 4) {
			return (parser_rc.PARSER_HCCAPX_VERSION);
		} 
		Object generatedEapol_len = in.getEapol_len();
		if (generatedEapol_len < 1 || generatedEapol_len > 255) {
			return (parser_rc.PARSER_HCCAPX_EAPOL_LEN);
		} 
		Object generatedKeymic = wpa_eapol.getKeymic();
		.memcpy(generatedKeymic, generatedKeymic, 16/*
		    http://www.one-net.eu/jsw/j_sec/m_ptype.html
		    The phrase "Pairwise key expansion"
		    Access Point Address (referred to as Authenticator Address AA)
		    Supplicant Address (referred to as Supplicant Address SA)
		    Access Point Nonce (referred to as Authenticator Anonce)
		    Wireless Device Nonce (referred to as Supplicant Nonce Snonce)
		  */);
		Object generatedEssid_len = in.getEssid_len();
		u32 salt_len = generatedEssid_len;
		if (salt_len > 32) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedEssid = in.getEssid();
		.memcpy(generatedSalt_buf, generatedEssid, generatedEssid_len);
		salt.setSalt_len(salt_len);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_WPA_PBKDF2 - 1);
		.memcpy(generatedEssid, generatedEssid, generatedEssid_len);
		wpa_eapol.setEssid_len(generatedEssid_len);
		Object generatedKeyver = in.getKeyver();
		wpa_eapol.setKeyver(generatedKeyver);
		if ((generatedKeyver != 1) && (generatedKeyver != 2) && (generatedKeyver != 3)) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedPke = wpa_eapol.getPke();
		u8 pke_ptr = (u8)generatedPke;
		.memset(pke_ptr, 0, 128);
		Object generatedMac_ap = in.getMac_ap();
		Object generatedMac_sta = in.getMac_sta();
		Object generatedNonce_ap = in.getNonce_ap();
		Object generatedNonce_sta = in.getNonce_sta();
		Object generatedNonce_compare = wpa_eapol.getNonce_compare();
		if ((generatedKeyver == 1) || (generatedKeyver == 2)) {
			.memcpy(pke_ptr, "Pairwise key expansion", 23);
			if (.memcmp(generatedMac_ap, generatedMac_sta, 6) < 0) {
				.memcpy(pke_ptr + 23, generatedMac_ap, 6);
				.memcpy(pke_ptr + 29, generatedMac_sta, 6);
			} else {
					.memcpy(pke_ptr + 23, generatedMac_sta, 6);
					.memcpy(pke_ptr + 29, generatedMac_ap, 6);
			} 
			wpa_eapol.setNonce_compare(.memcmp(generatedNonce_ap, generatedNonce_sta, 32));
			if (generatedNonce_compare < 0) {
				.memcpy(pke_ptr + 35, generatedNonce_ap, 32);
				.memcpy(pke_ptr + 67, generatedNonce_sta, 32);
			} else {
					.memcpy(pke_ptr + 35, generatedNonce_sta, 32);
					.memcpy(pke_ptr + 67, generatedNonce_ap, 32);
			} 
		}  else if (generatedKeyver == 3) {
			pke_ptr[0] = 1;
			pke_ptr[1] = 0;
			.memcpy(pke_ptr + 2, "Pairwise key expansion", 22);
			if (.memcmp(generatedMac_ap, generatedMac_sta, 6) < 0) {
				.memcpy(pke_ptr + 24, generatedMac_ap, 6);
				.memcpy(pke_ptr + 30, generatedMac_sta, 6);
			} else {
					.memcpy(pke_ptr + 24, generatedMac_sta, 6);
					.memcpy(pke_ptr + 30, generatedMac_ap, 6);
			} 
			wpa_eapol.setNonce_compare(.memcmp(generatedNonce_ap, generatedNonce_sta, 32));
			if (generatedNonce_compare < 0) {
				.memcpy(pke_ptr + 36, generatedNonce_ap, 32);
				.memcpy(pke_ptr + 68, generatedNonce_sta, 32);
			} else {
					.memcpy(pke_ptr + 36, generatedNonce_sta, 32);
					.memcpy(pke_ptr + 68, generatedNonce_ap, 32);
			} 
			pke_ptr[100] = -1024;
			pke_ptr[101] = 1;
		} 
		for (int i = 0;
		 i < 32; i++) {
			generatedPke[i] = ModernizedCProgram.byte_swap_32(generatedPke[i]);
		}
		Object generatedOrig_mac_ap = wpa_eapol.getOrig_mac_ap();
		.memcpy(generatedOrig_mac_ap, generatedMac_ap, 6);
		Object generatedOrig_mac_sta = wpa_eapol.getOrig_mac_sta();
		.memcpy(generatedOrig_mac_sta, generatedMac_sta, 6);
		Object generatedOrig_nonce_ap = wpa_eapol.getOrig_nonce_ap();
		.memcpy(generatedOrig_nonce_ap, generatedNonce_ap, 32);
		Object generatedOrig_nonce_sta = wpa_eapol.getOrig_nonce_sta();
		.memcpy(generatedOrig_nonce_sta, generatedNonce_sta, 32);
		Object generatedMessage_pair = in.getMessage_pair();
		u8 message_pair_orig = generatedMessage_pair;
		// ignore the highest bit (it is used to indicate if the replay counters did match)// ignore the highest bit (it is used to indicate if the replay counters did match)generatedMessage_pair &=  -1024;
		Object generatedMessage_pair_chgd = wpa_eapol.getMessage_pair_chgd();
		if (generatedMessage_pair_chgd == 1) {
			if (generatedMessage_pair != generatedMessage_pair) {
				return (parser_rc.PARSER_HCCAPX_MESSAGE_PAIR);
			} 
		} 
		wpa_eapol.setMessage_pair(message_pair_orig);
		wpa_eapol.setEapol_len(generatedEapol_len);
		Object generatedEapol = wpa_eapol.getEapol();
		u8 eapol_ptr = (u8)generatedEapol;
		.memcpy(eapol_ptr, generatedEapol, generatedEapol_len);
		.memset(eapol_ptr + generatedEapol_len, 0, (256 + 64) - generatedEapol_len);
		eapol_ptr[generatedEapol_len] = -1024;
		if (generatedKeyver == 1) {
		}  else if (generatedKeyver == 2) {
			generatedKeymic[0] = ModernizedCProgram.byte_swap_32(generatedKeymic[0]);
			generatedKeymic[1] = ModernizedCProgram.byte_swap_32(generatedKeymic[1]);
			generatedKeymic[2] = ModernizedCProgram.byte_swap_32(generatedKeymic[2]);
			generatedKeymic[3] = ModernizedCProgram.byte_swap_32(generatedKeymic[3]);
			for (int i = 0;
			 i < 64; i++) {
				generatedEapol[i] = ModernizedCProgram.byte_swap_32(generatedEapol[i]);
			}
		}  else if (generatedKeyver == 3) {
		} 
		// nothing to do
		// Create a hash of the nonce as ESSID is not unique enough// Not a regular MD5 but good enough// We can also ignore cases where we should bzero the work bufferu32[] hash = new u32();
		hash[0] = 0;
		hash[1] = 1;
		hash[2] = 2;
		hash[3] = 3;
		u32[] block = new u32();
		.memset(block, 0, );
		u8 block_ptr = (u8)block;
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedSalt_buf[i];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedPke[i + 0];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedPke[i + 16];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedEapol[i + 0];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedEapol[i + 16];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedEapol[i + 32];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 16; i++) {
			block[i] = generatedEapol[i + 48];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 6; i++) {
			block_ptr[i + 0] = generatedOrig_mac_ap[i];
		}
		for (int i = 0;
		 i < 6; i++) {
			block_ptr[i + 6] = generatedOrig_mac_sta[i];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		for (int i = 0;
		 i < 32; i++) {
			block_ptr[i + 0] = generatedOrig_nonce_ap[i];
		}
		for (int i = 0;
		 i < 32; i++) {
			block_ptr[i + 32] = generatedOrig_nonce_sta[i];
		}
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
		block[0] = generatedKeymic[0];
		block[1] = generatedKeymic[1];
		block[2] = generatedKeymic[2];
		block[3] = generatedKeymic[3];
		.md5_transform(block + 0, block + 4, block + 8, block + 12, hash)// make all this stuff unique;// make all this stuff unique
		digest[0] = hash[0];
		digest[1] = hash[1];
		digest[2] = hash[2];
		digest[3] = hash[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_64_constants.SHA512M_A;
			digest[1] -= sha2_64_constants.SHA512M_B;
			digest[2] -= sha2_64_constants.SHA512M_C;
			digest[3] -= sha2_64_constants.SHA512M_D;
			digest[4] -= sha2_64_constants.SHA512M_E;
			digest[5] -= sha2_64_constants.SHA512M_F;
			digest[6] -= sha2_64_constants.SHA512M_G;
			digest[7] -= sha2_64_constants.SHA512M_H;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_RAR3;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 6;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)'*';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 16;
		generatedLen_max[2] = 16;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 type_pos = generatedBuf[1];
		u8 salt_pos = generatedBuf[2];
		u8 crypted_pos = generatedBuf[3];
		if (type_pos[0] != (byte)'0') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED/**
			   * copy data
			   */);
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(crypted_pos + 0);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(crypted_pos + 8);
		generatedSalt_buf[4] = ModernizedCProgram.hex_to_u32(crypted_pos + 16);
		generatedSalt_buf[5] = ModernizedCProgram.hex_to_u32(crypted_pos + 24);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3]);
		generatedSalt_buf[4] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[4]);
		generatedSalt_buf[5] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[5]);
		salt.setSalt_len(24);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_RAR3)// there's no hash for rar3. the data which is in crypted_pos is some encrypted data and;// there's no hash for rar3. the data which is in crypted_pos is some encrypted data and
		// if it matches the value \xc4\x3d\x7b\x00\x40\x07\x00 after decrypt we know that we successfully cracked it.// if it matches the value \xc4\x3d\x7b\x00\x40\x07\x00 after decrypt we know that we successfully cracked it.digest[0] = -1024;
		digest[1] = -1024;
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_1K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		solarwinds_t solarwinds = (solarwinds_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SOLARWINDS_ORION;
		Object generatedLen = token.getLen();
		generatedLen[0] = 14;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 88;
		generatedLen_max[2] = 88;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_SOLARWINDS_ORION - 1)// save original salt for encode function;// save original salt for encode function
		Object generatedBuf = token.getBuf();
		// this is the only reason why we have an esalt in this hash-modebyte salt_pos = (byte)generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = solarwinds.getSalt_buf();
		.memcpy(generatedSalt_buf, salt_pos, salt_len)// for pbkdf2 salt we need to do hash-mode specific modifications;// for pbkdf2 salt we need to do hash-mode specific modifications
		byte[] custom_salt = new byte[8];
		.memcpy(custom_salt, salt_pos, (((true) < (salt_len)) ? (true) : (salt_len)));
		if (salt_len < 8) {
			byte SALT_PADDING = "1244352345234";
			.memcpy(custom_salt + salt_len, SALT_PADDING, 8 - salt_len);
		} 
		ModernizedCProgram.lowercase((u8)custom_salt, 8);
		.memcpy(generatedSalt_buf, custom_salt, 8);
		salt.setSalt_len(8)// hash;// hash
		u8 hash_pos = generatedBuf[2];
		int hash_len = generatedLen[2];
		u8[] tmp_buf = new u8();
		.memset(tmp_buf, 0, );
		int tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hash_pos, hash_len, tmp_buf);
		if (tmp_len < 64) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		.memcpy(digest, tmp_buf, tmp_len);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		if (line_len == 0) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen((byte)line_buf, "rb") == 0) {
			return (parser_rc.PARSER_HASH_FILE);
		} 
		psafe2_hdr buf = new psafe2_hdr();
		.memset(buf, 0, );
		size_t n = fp.hc_fread(buf, , 1);
		fp.hc_fclose();
		if (n != 1) {
			return (parser_rc.PARSER_PSAFE2_FILE_SIZE);
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedRandom = buf.getRandom();
		generatedSalt_buf[0] = generatedRandom[0];
		generatedSalt_buf[1] = generatedRandom[1];
		salt.setSalt_len(8);
		salt.setSalt_iter(1000);
		Object generatedHash = buf.getHash();
		digest[0] = ModernizedCProgram.byte_swap_32(generatedHash[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(generatedHash[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(generatedHash[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(generatedHash[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(generatedHash[4]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		apple_secure_notes_t apple_secure_notes = (apple_secure_notes_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(6);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_APFS;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 10;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 6;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[4] = (byte)'$';
		generatedLen_min[4] = 1;
		generatedLen_max[4] = 6;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[5] = (byte)'$';
		generatedLen_min[5] = 80;
		generatedLen_max[5] = 80;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// Z_PK
		Object generatedBuf = token.getBuf();
		u8 Z_PK_pos = generatedBuf[1];
		u32 Z_PK = ModernizedCProgram.hc_strtoul((byte)Z_PK_pos, ((Object)0), 10);
		if (Z_PK != 2) {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		apple_secure_notes.setZ_PK(Z_PK)// ZCRYPTOSALT;// ZCRYPTOSALT
		u8 ZCRYPTOSALT_pos = generatedBuf[3];
		Object generatedZCRYPTOSALT = apple_secure_notes.getZCRYPTOSALT();
		generatedZCRYPTOSALT[0] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[0]);
		generatedZCRYPTOSALT[1] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[8]);
		generatedZCRYPTOSALT[2] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[16]);
		generatedZCRYPTOSALT[3] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[24]);
		generatedZCRYPTOSALT[4] = 0;
		generatedZCRYPTOSALT[5] = 0;
		generatedZCRYPTOSALT[6] = 0;
		generatedZCRYPTOSALT[7] = 0;
		generatedZCRYPTOSALT[8] = 0;
		generatedZCRYPTOSALT[9] = 0;
		generatedZCRYPTOSALT[10] = 0;
		generatedZCRYPTOSALT[11] = 0;
		generatedZCRYPTOSALT[12] = 0;
		generatedZCRYPTOSALT[13] = 0;
		generatedZCRYPTOSALT[14] = 0;
		generatedZCRYPTOSALT[15] = 0// ZCRYPTOITERATIONCOUNT;// ZCRYPTOITERATIONCOUNT
		u8 ZCRYPTOITERATIONCOUNT_pos = generatedBuf[4];
		u32 ZCRYPTOITERATIONCOUNT = ModernizedCProgram.hc_strtoul((byte)ZCRYPTOITERATIONCOUNT_pos, ((Object)0), 10);
		apple_secure_notes.setZCRYPTOITERATIONCOUNT(ZCRYPTOITERATIONCOUNT)// ZCRYPTOWRAPPEDKEY;// ZCRYPTOWRAPPEDKEY
		u8 ZCRYPTOWRAPPEDKEY_pos = generatedBuf[5];
		Object generatedZCRYPTOWRAPPEDKEY = apple_secure_notes.getZCRYPTOWRAPPEDKEY();
		generatedZCRYPTOWRAPPEDKEY[0] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[0]);
		generatedZCRYPTOWRAPPEDKEY[1] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[8]);
		generatedZCRYPTOWRAPPEDKEY[2] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[16]);
		generatedZCRYPTOWRAPPEDKEY[3] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[24]);
		generatedZCRYPTOWRAPPEDKEY[4] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[32]);
		generatedZCRYPTOWRAPPEDKEY[5] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[40]);
		generatedZCRYPTOWRAPPEDKEY[6] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[48]);
		generatedZCRYPTOWRAPPEDKEY[7] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[56]);
		generatedZCRYPTOWRAPPEDKEY[8] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[64]);
		generatedZCRYPTOWRAPPEDKEY[9] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[72])// fake salt;// fake salt
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedZCRYPTOSALT[0];
		generatedSalt_buf[1] = generatedZCRYPTOSALT[1];
		generatedSalt_buf[2] = generatedZCRYPTOSALT[2];
		generatedSalt_buf[3] = generatedZCRYPTOSALT[3];
		Object generatedZ_PK = apple_secure_notes.getZ_PK();
		generatedSalt_buf[4] = generatedZ_PK;
		Object generatedZCRYPTOITERATIONCOUNT = apple_secure_notes.getZCRYPTOITERATIONCOUNT();
		salt.setSalt_iter(generatedZCRYPTOITERATIONCOUNT - 1);
		salt.setSalt_len(20)// fake hash;// fake hash
		digest[0] = generatedZCRYPTOWRAPPEDKEY[0];
		digest[1] = generatedZCRYPTOWRAPPEDKEY[1];
		digest[2] = generatedZCRYPTOWRAPPEDKEY[2];
		digest[3] = generatedZCRYPTOWRAPPEDKEY[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 64;
		generatedLen_max[1] = 64;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_64_constants.SHA512M_A;
			digest[1] -= sha2_64_constants.SHA512M_B;
			digest[2] -= sha2_64_constants.SHA512M_C;
			digest[3] -= sha2_64_constants.SHA512M_D;
			digest[4] -= sha2_64_constants.SHA512M_E;
			digest[5] -= sha2_64_constants.SHA512M_F;
			digest[6] -= sha2_64_constants.SHA512M_G;
			digest[7] -= sha2_64_constants.SHA512M_H;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'$';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[1] = 16;
		generatedLen_max[1] = 16;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer/**
			   * salt
			   */);
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[0];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[0];
		int user_len = 0;
		for (int i = 0;
		 i < salt_len; i++) {
			if (salt_pos[i] == (byte)' ') {
				continue;
			} 
			user_len++;
		}
		// SAP user names cannot be longer than 12 charactersif (user_len > 12) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// SAP user name cannot start with ! or ?if (salt_pos[0] == (byte)'!' || salt_pos[0] == (byte)'?') {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH/**
			   * hash
			   */);
		} 
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_2K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_1K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_DRUPAL7;
		Object generatedLen = token.getLen();
		generatedLen[0] = 3;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		generatedLen[2] = 8;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		generatedLen[3] = 43;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u32 salt_iter = -1024 << ModernizedCProgram.itoa64_to_int(iter_pos[0]);
		if (salt_iter > -1024) {
			return (parser_rc.PARSER_SALT_ITERATION);
		} 
		Object generatedSalt_sign = salt.getSalt_sign();
		.memcpy((u8)generatedSalt_sign, line_buf, 4);
		salt.setSalt_iter(salt_iter)// salt;// salt
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy((u8)generatedSalt_buf, salt_pos, salt_len);
		salt.setSalt_len(salt_len)// hash;// hash
		u8 hash_pos = generatedBuf[3];
		ModernizedCProgram.drupal7_decode((u8)digest, hash_pos)// ugly hack start;// ugly hack start
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		u8 tmp = (u8)generatedSalt_buf_pc;
		tmp[0] = hash_pos[42]// ugly hack end;// ugly hack end
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = 0;
		digest[5] = 0;
		digest[6] = 0;
		digest[7] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pbkdf2_sha256_t pbkdf2_sha256 = (pbkdf2_sha256_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_DJANGOPBKDF2;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 13;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 13;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)'$';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 256;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 44;
		generatedLen_max[3] = 44;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		int iter = .strtol((byte)iter_pos, ((Object)0), 10);
		if (iter < 1) {
			return (parser_rc.PARSER_SALT_ITERATION);
		} 
		salt.setSalt_iter(iter - 1)// salt;// salt
		u8 salt_pos = generatedBuf[2];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = pbkdf2_sha256.getSalt_buf();
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		.memcpy(salt_buf_ptr, salt_pos, salt_len);
		salt.setSalt_len(salt_len)//leftover from prehistoric times?//salt_buf_ptr[salt_len + 3] = 0x01;//salt_buf_ptr[salt_len + 4] = 0x80;;//leftover from prehistoric times?//salt_buf_ptr[salt_len + 3] = 0x01;//salt_buf_ptr[salt_len + 4] = 0x80;
		// add some stuff to normal salt to make sorted happy// add some stuff to normal salt to make sorted happygeneratedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_buf[4] = generatedSalt_iter// base64 decode hash;// base64 decode hash
		u8 hash_pos = generatedBuf[3];
		int hash_len = generatedLen[3];
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, (u8)hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		electrum_wallet_t electrum_wallet = (electrum_wallet_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ELECTRUM_WALLET;
		Object generatedLen = token.getLen();
		generatedLen[0] = 10;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 32;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// salt_type
		Object generatedBuf = token.getBuf();
		u8 salt_type_pos = generatedBuf[1];
		u32 salt_type = ModernizedCProgram.hc_strtoul((byte)salt_type_pos, ((Object)0), 10);
		if ((salt_type == 1) || (salt_type == 2) || (salt_type == 3)) {
		} else {
				return (parser_rc.PARSER_SALT_VALUE);
		} 
		// all ok
		electrum_wallet.setSalt_type(salt_type)// iv;// iv
		u8 iv_pos = generatedBuf[2];
		Object generatedIv = electrum_wallet.getIv();
		generatedIv[0] = ModernizedCProgram.hex_to_u32((u8)iv_pos[0]);
		generatedIv[1] = ModernizedCProgram.hex_to_u32((u8)iv_pos[8]);
		generatedIv[2] = ModernizedCProgram.hex_to_u32((u8)iv_pos[16]);
		generatedIv[3] = ModernizedCProgram.hex_to_u32((u8)iv_pos[24])// encrypted;// encrypted
		u8 encrypted_pos = generatedBuf[3];
		Object generatedEncrypted = electrum_wallet.getEncrypted();
		generatedEncrypted[0] = ModernizedCProgram.hex_to_u32((u8)encrypted_pos[0]);
		generatedEncrypted[1] = ModernizedCProgram.hex_to_u32((u8)encrypted_pos[8]);
		generatedEncrypted[2] = ModernizedCProgram.hex_to_u32((u8)encrypted_pos[16]);
		generatedEncrypted[3] = ModernizedCProgram.hex_to_u32((u8)encrypted_pos[24])// salt fake;// salt fake
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedIv[0];
		generatedSalt_buf[1] = generatedIv[1];
		generatedSalt_buf[2] = generatedIv[2];
		generatedSalt_buf[3] = generatedIv[3];
		generatedSalt_buf[4] = generatedEncrypted[0];
		generatedSalt_buf[5] = generatedEncrypted[1];
		generatedSalt_buf[6] = generatedEncrypted[2];
		generatedSalt_buf[7] = generatedEncrypted[3];
		salt.setSalt_len(32)// hash fake;// hash fake
		digest[0] = generatedIv[0];
		digest[1] = generatedIv[1];
		digest[2] = generatedIv[2];
		digest[3] = generatedIv[3];
		digest[4] = generatedEncrypted[0];
		digest[5] = generatedEncrypted[1];
		digest[6] = generatedEncrypted[2];
		digest[7] = generatedEncrypted[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md4_constants.MD4M_A;
			digest[1] -= md4_constants.MD4M_B;
			digest[2] -= md4_constants.MD4M_C;
			digest[3] -= md4_constants.MD4M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 24;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 24;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(hash_pos + 0));
		digest[1] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(hash_pos + 8));
		digest[2] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(hash_pos + 16));
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MYSQL_AUTH;
		Object generatedLen = token.getLen();
		generatedLen[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 40;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 40;
		generatedLen_max[2] = 40;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// hash
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[2];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4/*
		   * store salt
		   */]);
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		krb5tgs_18_t krb5tgs = (krb5tgs_18_t)esalt_buf;
		token_t token = new token_t();
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_KRB5TGS;
		Object generatedLen = token.getLen();
		generatedLen[0] = 12;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE/**
		   * $krb5tgs$18$*user*realm*$checksum$edata2
		   * $krb5tgs$18$*user*realm*spn*$checksum$edata2
		   */;
		// assume no signature foundif (line_len < 12) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		byte spn_info_start = .strchr((byte)line_buf + 12 + 1, (byte)'*');
		int is_spn_provided = 0;
		Object generatedSep = token.getSep();
		Object generatedLen_min = token.getLen_min();
		Object generatedLen_max = token.getLen_max();
		// assume $krb5tgs$17$user$realm$checksum$edata2if (spn_info_start == ((Object)0)) {
			token.setToken_cnt(5);
			generatedSep[1] = (byte)'$';
			generatedLen_min[1] = 1;
			generatedLen_max[1] = 512;
			generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
			generatedSep[2] = (byte)'$';
			generatedLen_min[2] = 1;
			generatedLen_max[2] = 512;
			generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
			generatedSep[3] = (byte)'$';
			generatedLen_min[3] = 24;
			generatedLen_max[3] = 24;
			generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[4] = (byte)'$';
			generatedLen_min[4] = 64;
			generatedLen_max[4] = 40960;
			generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		} else {
				byte spn_info_stop = .strchr((byte)spn_info_start + 1, (byte)'*');
				if (spn_info_stop == ((Object)0)) {
					return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
				} 
				spn_info_stop++;
				spn_info_stop++;
				int spn_info_len = spn_info_stop - spn_info_start;
				token.setToken_cnt(6);
				generatedSep[1] = (byte)'$';
				generatedLen_min[1] = 1;
				generatedLen_max[1] = 512;
				generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
				generatedSep[2] = (byte)'$';
				generatedLen_min[2] = 1;
				generatedLen_max[2] = 512;
				generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
				generatedLen[3] = spn_info_len;
				generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
				generatedSep[4] = (byte)'$';
				generatedLen_min[4] = 24;
				generatedLen_max[4] = 24;
				generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
				generatedSep[5] = (byte)'$';
				generatedLen_min[5] = 64;
				generatedLen_max[5] = 40960;
				generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
				is_spn_provided = 1;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		u8 user_pos = new u8();
		u8 domain_pos = new u8();
		u8 checksum_pos = new u8();
		u8 data_pos = new u8();
		int user_len;
		int domain_len;
		int data_len;
		int account_info_len;
		Object generatedBuf = token.getBuf();
		user_pos = generatedBuf[1];
		user_len = generatedLen[1];
		Object generatedUser = krb5tgs.getUser();
		.memcpy(generatedUser, user_pos, user_len);
		domain_pos = generatedBuf[2];
		domain_len = generatedLen[2];
		Object generatedDomain = krb5tgs.getDomain();
		.memcpy(generatedDomain, domain_pos, domain_len);
		checksum_pos = generatedBuf[3 + is_spn_provided];
		data_pos = generatedBuf[4 + is_spn_provided];
		data_len = generatedLen[4 + is_spn_provided];
		account_info_len = generatedLen[2] + generatedLen[1];
		Object generatedAccount_info = krb5tgs.getAccount_info();
		u8 account_info_ptr = (u8)generatedAccount_info;
		// domain must be uppercaseu8[] domain = new u8();
		.memcpy(domain, domain_pos, domain_len);
		ModernizedCProgram.uppercase(domain, domain_len);
		.memcpy(account_info_ptr, domain, domain_len);
		.memcpy(account_info_ptr + domain_len, user_pos, user_len);
		krb5tgs.setAccount_info_len(account_info_len);
		Object generatedChecksum = krb5tgs.getChecksum();
		// hmac-sha1 is reduced to 12 bytes// hmac-sha1 is reduced to 12 bytesgeneratedChecksum[0] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 0));
		generatedChecksum[1] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 8));
		generatedChecksum[2] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 16));
		Object generatedEdata2 = krb5tgs.getEdata2();
		u8 edata_ptr = (u8)generatedEdata2;
		for (int i = 0;
		 i < data_len; i += 2) {
			u8 p0 = data_pos[i + 0];
			u8 p1 = data_pos[i + 1];
			edata_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		krb5tgs.setEdata2_len(data_len / 2);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedChecksum[0];
		generatedSalt_buf[1] = generatedChecksum[1];
		generatedSalt_buf[2] = generatedChecksum[2];
		salt.setSalt_iter(4096 - 1);
		digest[0] = generatedChecksum[0];
		digest[1] = generatedChecksum[1];
		digest[2] = generatedChecksum[2];
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_AXCRYPT_SHA1;
		Object generatedLen = token.getLen();
		generatedLen[0] = 14;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 40;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = 0;
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		oldoffice34_t oldoffice34 = (oldoffice34_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(6);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_OLDOFFICE3;
		Object generatedLen = token.getLen();
		generatedLen[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 32;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[4] = 40;
		generatedLen_max[4] = 40;
		generatedSep[4] = (byte)':';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[5] = 10;
		generatedLen_max[5] = 10;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 osalt_pos = generatedBuf[2];
		u8 encryptedVerifier_pos = generatedBuf[3];
		u8 encryptedVerifierHash_pos = generatedBuf[4];
		u8 rc4key_pos = generatedBuf[5];
		// esalt
		u32 version = version_pos - -1024;
		if (version != 3 && version != 4) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		oldoffice34.setVersion(version);
		Object generatedEncryptedVerifier = oldoffice34.getEncryptedVerifier();
		generatedEncryptedVerifier[0] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 0);
		generatedEncryptedVerifier[1] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 8);
		generatedEncryptedVerifier[2] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 16);
		generatedEncryptedVerifier[3] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 24);
		Object generatedEncryptedVerifierHash = oldoffice34.getEncryptedVerifierHash();
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 0);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 8);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 16);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 24);
		generatedEncryptedVerifierHash[4] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 32);
		Object generatedRc4key = oldoffice34.getRc4key();
		generatedRc4key[1] = 0;
		generatedRc4key[0] = 0;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[0]) << 28;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[1]) << 24;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[2]) << 20;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[3]) << 16;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[4]) << 12;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[5]) << 8;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[6]) << 4;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[7]) << 0;
		generatedRc4key[1] |=  ModernizedCProgram.hex_convert(rc4key_pos[8]) << 28;
		generatedRc4key[1] |=  ModernizedCProgram.hex_convert(rc4key_pos[9]) << 24;
		generatedRc4key[0] = ModernizedCProgram.byte_swap_32(generatedRc4key[0]);
		generatedRc4key[1] = ModernizedCProgram.byte_swap_32(generatedRc4key[1])// salt;// salt
		salt.setSalt_len(16);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(osalt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(osalt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(osalt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(osalt_pos + 24);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3])// this is a workaround as office produces multiple documents with the same salt;// this is a workaround as office produces multiple documents with the same salt
		generatedSalt_buf[4] = generatedEncryptedVerifier[0];
		generatedSalt_buf[5] = generatedEncryptedVerifier[1];
		generatedSalt_buf[6] = generatedEncryptedVerifier[2];
		generatedSalt_buf[7] = generatedEncryptedVerifier[3];
		generatedSalt_buf[8] = generatedEncryptedVerifierHash[0];
		generatedSalt_buf[9] = generatedEncryptedVerifierHash[1];
		generatedSalt_buf[10] = generatedEncryptedVerifierHash[2];
		generatedSalt_buf[11] = generatedEncryptedVerifierHash[3];
		Object generatedSalt_len = salt.getSalt_len();
		generatedSalt_len += 32/**
		   * digest
		   */;
		digest[0] = generatedRc4key[0];
		digest[1] = generatedRc4key[1];
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen = token.getLen();
		generatedLen[0] = 10;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[1] = 40;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[0];
		int salt_len = generatedLen[0];
		if ((salt_pos[8] != (byte)'0') || (salt_pos[9] != (byte)'1')) {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MEDIAWIKI_B;
		Object generatedLen = token.getLen();
		generatedLen[0] = 3;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 32;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[2];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		salt_buf_ptr[salt_len] = -1024;
		salt.setSalt_len(salt_len + 1);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_DCC2;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 6;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'#';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 256;
		generatedSep[2] = (byte)'#';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[3];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 iter_pos = generatedBuf[1];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		salt.setSalt_iter(iter - 1);
		return (parser_rc.PARSER_OK);
		pkzip_t pkzip = (pkzip_t)esalt_buf;
		u32 digest = (u32)digest_buf;
		byte[] input = new byte[line_len + 1];
		input[line_len] = (byte)'\0';
		.memcpy(input, line_buf, line_len);
		byte saveptr = ((Object)0);
		byte p = .strtok_r(input, "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		if (.strncmp(p, ModernizedCProgram.SIGNATURE_PKZIP_V1, 7) != 0 && .strncmp(p, ModernizedCProgram.SIGNATURE_PKZIP_V2, 8) != 0) {
			return parser_rc.PARSER_SIGNATURE_UNMATCHED;
		} 
		pkzip.setVersion(1);
		if (.strlen(p) == 9) {
			pkzip.setVersion(2);
		} 
		byte[] sub = new byte[2];
		sub[0] = p[.strlen(p) - 1];
		sub[1] = (byte)'\0';
		pkzip.setHash_count(.atoi(sub));
		Object generatedHash_count = pkzip.getHash_count();
		// check here that the hash_count is valid for the attack typeif (generatedHash_count != 1) {
			return parser_rc.PARSER_HASH_VALUE;
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		pkzip.setChecksum_size(.atoi(p));
		Object generatedChecksum_size = pkzip.getChecksum_size();
		if (generatedChecksum_size != 1 && generatedChecksum_size != 2) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		pkzip_hash generatedHash = pkzip.getHash();
		generatedHash.setData_type_enum(.atoi(p));
		Object generatedData_type_enum = generatedHash.getData_type_enum();
		if (generatedData_type_enum > 3) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		generatedHash.setMagic_type_enum(.atoi(p));
		Object generatedCompressed_length = generatedHash.getCompressed_length();
		if (generatedData_type_enum > 1) {
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHash.setCompressed_length(.strtoul(p, ((Object)0), 16));
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHash.setUncompressed_length(.strtoul(p, ((Object)0), 16));
			if (generatedCompressed_length > (320 * 1024)) {
				return parser_rc.PARSER_TOKEN_LENGTH;
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			u32 crc32 = 0;
			.sscanf(p, "%x", ModernizedCProgram.crc32);
			generatedHash.setCrc32(ModernizedCProgram.crc32);
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHash.setOffset(.strtoul(p, ((Object)0), 16));
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHash.setAdditional_offset(.strtoul(p, ((Object)0), 16));
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		generatedHash.setCompression_type(.atoi(p));
		Object generatedCompression_type = generatedHash.getCompression_type();
		if (generatedCompression_type != 0) {
			return parser_rc.PARSER_PKZIP_CT_UNMATCHED;
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		generatedHash.setData_length(.strtoul(p, ((Object)0), 16));
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		u16 checksum_from_crc = 0;
		.sscanf(p, "%hx", checksum_from_crc);
		generatedHash.setChecksum_from_crc(checksum_from_crc);
		Object generatedVersion = pkzip.getVersion();
		Object generatedChecksum_from_crc = generatedHash.getChecksum_from_crc();
		if (generatedVersion == 2) {
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			u16 checksum_from_timestamp = 0;
			.sscanf(p, "%hx", checksum_from_timestamp);
			generatedHash.setChecksum_from_timestamp(checksum_from_timestamp);
		} else {
				generatedHash.setChecksum_from_timestamp(generatedChecksum_from_crc);
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		Object generatedData = generatedHash.getData();
		ModernizedCProgram.hex_to_binary(p, .strlen(p), (byte)(generatedData));
		Object generatedSalt_buf = salt.getSalt_buf();
		// fake salt// fake saltgeneratedSalt_buf[0] = generatedData[0];
		generatedSalt_buf[1] = generatedData[1];
		generatedSalt_buf[2] = generatedData[2];
		generatedSalt_buf[3] = generatedData[3];
		salt.setSalt_len(16);
		Object generatedCrc32 = generatedHash.getCrc32();
		digest[0] = generatedCrc32;
		digest[1] = 0;
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		itunes_backup_t itunes_backup = (itunes_backup_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(7);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ITUNES_BACKUP;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 15;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 15;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 2;
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 80;
		generatedLen_max[2] = 80;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[3] = 1;
		generatedLen_max[3] = 6;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 40;
		generatedLen_max[4] = 40;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[5] = 0;
		generatedLen_max[5] = 10;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[6] = 0;
		generatedLen_max[6] = 40;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// version
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u32 version = ModernizedCProgram.hc_strtoul((byte)version_pos, ((Object)0), 10);
		u32 hash_mode = hashconfig.getHash_mode();
		if (hash_mode == 14700) {
			if (version != 9) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
		}  else if (hash_mode == 14800) {
			if (version != 10) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
		} 
		Object generatedSalt_sign = salt.getSalt_sign();
		generatedSalt_sign[0] = (byte)version// wpky;// wpky
		u8 wpky_pos = generatedBuf[2];
		Object generatedWpky = itunes_backup.getWpky();
		u32 wpky_buf_ptr = (u32)generatedWpky;
		wpky_buf_ptr[0] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[0]);
		wpky_buf_ptr[1] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[8]);
		wpky_buf_ptr[2] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[16]);
		wpky_buf_ptr[3] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[24]);
		wpky_buf_ptr[4] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[32]);
		wpky_buf_ptr[5] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[40]);
		wpky_buf_ptr[6] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[48]);
		wpky_buf_ptr[7] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[56]);
		wpky_buf_ptr[8] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[64]);
		wpky_buf_ptr[9] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[72]);
		wpky_buf_ptr[0] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[0]);
		wpky_buf_ptr[1] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[1]);
		wpky_buf_ptr[2] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[2]);
		wpky_buf_ptr[3] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[3]);
		wpky_buf_ptr[4] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[4]);
		wpky_buf_ptr[5] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[5]);
		wpky_buf_ptr[6] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[6]);
		wpky_buf_ptr[7] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[7]);
		wpky_buf_ptr[8] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[8]);
		wpky_buf_ptr[9] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[9])// iter;// iter
		u8 iter_pos = generatedBuf[3];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		if (iter < 1) {
			return (parser_rc.PARSER_SALT_ITERATION);
		} 
		if (hash_mode == 14700) {
			salt.setSalt_iter(iter - 1);
		}  else if (hash_mode == 14800) {
			salt.setSalt_iter(0);
			salt.setSalt_iter2(iter - 1);
		} 
		// saltu8 salt_pos = generatedBuf[4];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[4];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3]);
		generatedSalt_buf[4] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[4])// dpic + dpsl;// dpic + dpsl
		u8 dpic_pos = generatedBuf[5];
		int dpic_len = generatedLen[5];
		u8 dpsl_pos = generatedBuf[6];
		int dpsl_len = generatedLen[6];
		u32 dpic = 0;
		Object generatedDpsl = itunes_backup.getDpsl();
		if (hash_mode == 14700) {
			if (dpic_len > 0) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
			if (dpsl_len > 0) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
		}  else if (hash_mode == 14800) {
			if (dpic_len < 1) {
				return (parser_rc.PARSER_SALT_ITERATION);
			} 
			if (dpic_len > 9) {
				return (parser_rc.PARSER_SALT_ITERATION);
			} 
			dpic = ModernizedCProgram.hc_strtoul((byte)dpic_pos, ((Object)0), 10);
			if (dpic < 1) {
				return (parser_rc.PARSER_SALT_ITERATION);
			} 
			salt.setSalt_iter(dpic - 1);
			if (dpsl_len != 40) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
			u32 dpsl_buf_ptr = (u32)generatedDpsl;
			dpsl_buf_ptr[0] = ModernizedCProgram.hex_to_u32((u8)dpsl_pos[0]);
			dpsl_buf_ptr[1] = ModernizedCProgram.hex_to_u32((u8)dpsl_pos[8]);
			dpsl_buf_ptr[2] = ModernizedCProgram.hex_to_u32((u8)dpsl_pos[16]);
			dpsl_buf_ptr[3] = ModernizedCProgram.hex_to_u32((u8)dpsl_pos[24]);
			dpsl_buf_ptr[4] = ModernizedCProgram.hex_to_u32((u8)dpsl_pos[32]);
			dpsl_buf_ptr[0] = ModernizedCProgram.byte_swap_32(dpsl_buf_ptr[0]);
			dpsl_buf_ptr[1] = ModernizedCProgram.byte_swap_32(dpsl_buf_ptr[1]);
			dpsl_buf_ptr[2] = ModernizedCProgram.byte_swap_32(dpsl_buf_ptr[2]);
			dpsl_buf_ptr[3] = ModernizedCProgram.byte_swap_32(dpsl_buf_ptr[3]);
			dpsl_buf_ptr[4] = ModernizedCProgram.byte_swap_32(dpsl_buf_ptr[4]);
		} 
		digest[0] = generatedDpsl[0] ^ generatedWpky[0];
		digest[1] = generatedDpsl[1] ^ generatedWpky[1];
		digest[2] = generatedDpsl[2] ^ generatedWpky[2];
		digest[3] = generatedDpsl[3] ^ generatedWpky[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		androidfde_t androidfde = (androidfde_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(6);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ANDROIDFDE;
		Object generatedLen = token.getLen();
		generatedLen[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 2;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 2;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 32;
		generatedSep[2] = (byte)'$';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[3] = 2;
		generatedLen_max[3] = 2;
		generatedSep[3] = (byte)'$';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[4] = 32;
		generatedLen_max[4] = 32;
		generatedSep[4] = (byte)'$';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[5] = 3072;
		generatedLen_max[5] = 3072;
		generatedSep[5] = (byte)'$';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// hash
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[4];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3])// salt;// salt
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(salt_pos + 24);
		salt.setSalt_len(salt_len / 2);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_ANDROIDFDE - 1)// data;// data
		u8 data_pos = generatedBuf[5];
		int data_len = generatedLen[5];
		Object generatedData = androidfde.getData();
		for (int i = 0;
		int j = 0;
		 i < data_len; ) {
			generatedData[j] = ModernizedCProgram.hex_to_u32(data_pos + i);
			generatedData[j] = ModernizedCProgram.byte_swap_32(generatedData[j]);
		}
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_NETSCALER;
		Object generatedLen = token.getLen();
		generatedLen[0] = 1;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen[1] = 8;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		generatedLen[2] = 40;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// salt
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy(generatedSalt_buf, salt_pos, salt_len);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		salt.setSalt_len(salt_len)// hash;// hash
		u8 hash_pos = generatedBuf[2];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		rar5_t rar5 = (rar5_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(7);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_RAR5;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 2;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 2;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 32;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 2;
		generatedLen_max[3] = 2;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[4] = (byte)'$';
		generatedLen_min[4] = 32;
		generatedLen_max[4] = 32;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[5] = (byte)'$';
		generatedLen_min[5] = 1;
		generatedLen_max[5] = 1;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[6] = (byte)'$';
		generatedLen_min[6] = 16;
		generatedLen_max[6] = 16;
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[3];
		u32 iterations = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		salt.setSalt_iter(((-1024 << iterations) + 32) - 1);
		if (iterations == 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedSalt_sign = salt.getSalt_sign();
		generatedSalt_sign[0] = iterations// salt;// salt
		u8 salt_buf = generatedBuf[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_buf + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_buf + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt_buf + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(salt_buf + 24);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3])// iv;// iv
		u8 iv = generatedBuf[4];
		Object generatedIv = rar5.getIv();
		generatedIv[0] = ModernizedCProgram.hex_to_u32(iv + 0);
		generatedIv[1] = ModernizedCProgram.hex_to_u32(iv + 8);
		generatedIv[2] = ModernizedCProgram.hex_to_u32(iv + 16);
		generatedIv[3] = ModernizedCProgram.hex_to_u32(iv + 24);
		generatedIv[0] = ModernizedCProgram.byte_swap_32(generatedIv[0]);
		generatedIv[1] = ModernizedCProgram.byte_swap_32(generatedIv[1]);
		generatedIv[2] = ModernizedCProgram.byte_swap_32(generatedIv[2]);
		generatedIv[3] = ModernizedCProgram.byte_swap_32(generatedIv[3]);
		salt.setSalt_len(16)// hash;// hash
		u8 pswcheck = generatedBuf[6];
		digest[0] = ModernizedCProgram.hex_to_u32(pswcheck + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(pswcheck + 8);
		digest[2] = 0;
		digest[3] = 0;
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		pbkdf2_sha512_t pbkdf2_sha512 = (pbkdf2_sha512_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SHA512GRUB;
		Object generatedLen = token.getLen();
		generatedLen[0] = 19;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 6;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'.';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 256;
		generatedSep[2] = (byte)'.';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[3] = 128;
		generatedLen_max[3] = 128;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[3];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2] / 2;
		Object generatedSalt_buf = pbkdf2_sha512.getSalt_buf();
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		for (int i = 0;
		int j = 0;
		 i < salt_len; ) {
			salt_buf_ptr[i] = ModernizedCProgram.hex_to_u8(salt_pos + j);
		}
		salt_buf_ptr[salt_len + 3] = -1024;
		salt_buf_ptr[salt_len + 4] = -1024;
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		generatedSalt_buf[4] = generatedSalt_buf[4];
		generatedSalt_buf[5] = generatedSalt_buf[5];
		generatedSalt_buf[6] = generatedSalt_buf[6];
		generatedSalt_buf[7] = generatedSalt_buf[7];
		salt.setSalt_len(salt_len);
		u8 iter_pos = generatedBuf[1];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10) - 1);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pdf_t pdf = (pdf_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(16);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PDF;
		Object generatedLen = token.getLen();
		generatedLen[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 3;
		generatedLen_max[3] = 3;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 1;
		generatedLen_max[4] = 6;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[5] = 1;
		generatedLen_max[5] = 1;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[6] = 1;
		generatedLen_max[6] = 4;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[7] = 0;
		generatedLen_max[7] = 1024;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[8] = 1;
		generatedLen_max[8] = 4;
		generatedSep[8] = (byte)'*';
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[9] = 0;
		generatedLen_max[9] = 1024;
		generatedSep[9] = (byte)'*';
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[10] = 1;
		generatedLen_max[10] = 4;
		generatedSep[10] = (byte)'*';
		generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[11] = 0;
		generatedLen_max[11] = 1024;
		generatedSep[11] = (byte)'*';
		generatedAttr[11] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[12] = 1;
		generatedLen_max[12] = 4;
		generatedSep[12] = (byte)'*';
		generatedAttr[12] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[13] = 0;
		generatedLen_max[13] = 1024;
		generatedSep[13] = (byte)'*';
		generatedAttr[13] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[14] = 1;
		generatedLen_max[14] = 4;
		generatedSep[14] = (byte)'*';
		generatedAttr[14] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[15] = 0;
		generatedLen_max[15] = 1024;
		generatedSep[15] = (byte)'*';
		generatedAttr[15] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 V_pos = generatedBuf[1];
		u8 R_pos = generatedBuf[2];
		u8 bits_pos = generatedBuf[3];
		u8 enc_md_pos = generatedBuf[5];
		u8 u_len_pos = generatedBuf[8];
		u8 u_buf_pos = generatedBuf[9];
		// validate data
		int V = .strtol((byte)V_pos, ((Object)0), 10);
		int R = .strtol((byte)R_pos, ((Object)0), 10);
		int vr_ok = 0;
		if ((V == 5) && (R == 5)) {
			vr_ok = 1;
		} 
		if ((V == 5) && (R == 6)) {
			vr_ok = 1;
		} 
		if (vr_ok == 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int bits = .strtol((byte)bits_pos, ((Object)0), 10);
		if (bits != 256) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int enc_md = .strtol((byte)enc_md_pos, ((Object)0), 10);
		if ((enc_md != 0) && (enc_md != 1)) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		u32 u_len = ModernizedCProgram.hc_strtoul((byte)u_len_pos, ((Object)0), 10);
		// copy data to esalt
		if (u_len < 40) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (ModernizedCProgram.is_valid_hex_string(u_buf_pos, 80) == 0) {
			return (parser_rc.PARSER_SALT_ENCODING);
		} 
		Object generatedU_buf = pdf.getU_buf();
		for (int i = 0;
		int j = 0;
		 i < 8 + 2; ) {
			generatedU_buf[i] = ModernizedCProgram.hex_to_u32((u8)u_buf_pos[j]);
		}
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedU_buf[8];
		generatedSalt_buf[1] = generatedU_buf[9];
		salt.setSalt_len(8);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_PDF17L8);
		digest[0] = ModernizedCProgram.byte_swap_32(generatedU_buf[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(generatedU_buf[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(generatedU_buf[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(generatedU_buf[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(generatedU_buf[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(generatedU_buf[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(generatedU_buf[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(generatedU_buf[7])// extra;// extra
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		generatedSalt_buf[2] = -1024;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		zip2_t zip2 = (zip2_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(10);
		token.setSignatures_cnt(2);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ZIP2_START;
		generatedSignatures_buf[1] = ModernizedCProgram.SIGNATURE_ZIP2_STOP;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 6;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 6;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 1;
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 1;
		generatedLen_max[3] = 1;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 16;
		generatedLen_max[4] = 32;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[5] = 1;
		generatedLen_max[5] = 6;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[6] = 1;
		generatedLen_max[6] = 6;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[7] = 0;
		generatedLen_max[7] = 16384;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[8] = 20;
		generatedLen_max[8] = 20;
		generatedSep[8] = (byte)'*';
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[9] = 7;
		generatedLen_max[9] = 7;
		generatedSep[9] = (byte)'*';
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// type
		Object generatedBuf = token.getBuf();
		u8 type_pos = generatedBuf[1];
		u32 type = ModernizedCProgram.hc_strtoul((byte)type_pos, ((Object)0), 10);
		if (type != 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		zip2.setType(type)// mode;// mode
		u8 mode_pos = generatedBuf[2];
		u32 mode = ModernizedCProgram.hc_strtoul((byte)mode_pos, ((Object)0), 10);
		zip2.setMode(mode)// magic;// magic
		u8 magic_pos = generatedBuf[3];
		u32 magic = ModernizedCProgram.hc_strtoul((byte)magic_pos, ((Object)0), 10);
		if (magic != 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		zip2.setMagic(magic)// verify_bytes;// verify_bytes
		u8 verify_bytes_pos = generatedBuf[5];
		u32 verify_bytes = new u32();
		if (.sscanf((byte)verify_bytes_pos, "%4x*", verify_bytes) == (true)) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (verify_bytes >= -1024) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		zip2.setVerify_bytes(verify_bytes)// compress_length;// compress_length
		u8 compress_length_pos = generatedBuf[6];
		u32 compress_length = ModernizedCProgram.hc_strtoul((byte)compress_length_pos, ((Object)0), 10);
		zip2.setCompress_length(compress_length)// salt;// salt
		u8 salt_pos = generatedBuf[4];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[4];
		Object generatedSalt_buf = zip2.getSalt_buf();
		if (mode == 1) {
			if (salt_len != 16) {
				return (parser_rc.PARSER_SALT_VALUE);
			} 
			generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32((u8)salt_pos[0]);
			generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32((u8)salt_pos[8]);
			generatedSalt_buf[2] = 0;
			generatedSalt_buf[3] = 0;
			zip2.setSalt_len(8);
		}  else if (mode == 2) {
			if (salt_len != 24) {
				return (parser_rc.PARSER_SALT_VALUE);
			} 
			generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32((u8)salt_pos[0]);
			generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32((u8)salt_pos[8]);
			generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32((u8)salt_pos[16]);
			generatedSalt_buf[3] = 0;
			zip2.setSalt_len(12);
		}  else if (mode == 3) {
			if (salt_len != 32) {
				return (parser_rc.PARSER_SALT_VALUE);
			} 
			generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32((u8)salt_pos[0]);
			generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32((u8)salt_pos[8]);
			generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32((u8)salt_pos[16]);
			generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32((u8)salt_pos[24]);
			zip2.setSalt_len(16);
		} else {
				return (parser_rc.PARSER_SALT_VALUE);
		} 
		// datau8 data_buf = generatedBuf[7];
		int data_len = generatedLen[7];
		Object generatedData_buf = zip2.getData_buf();
		u8 data_buf_ptr = (u8)generatedData_buf;
		Object generatedData_len = zip2.getData_len();
		for (int i = 0;
		 i < data_len; i += 2) {
			u8 p0 = data_buf[i + 0];
			u8 p1 = data_buf[i + 1];
			data_buf_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
			generatedData_len++;
		}
		data_buf_ptr = -1024// auth;// auth
		u8 auth_buf = generatedBuf[8];
		int auth_len = generatedLen[8];
		Object generatedAuth_buf = zip2.getAuth_buf();
		u8 auth_ptr = (u8)generatedAuth_buf;
		Object generatedAuth_len = zip2.getAuth_len();
		for (int i = 0;
		 i < auth_len; i += 2) {
			u8 p0 = auth_buf[i + 0];
			u8 p1 = auth_buf[i + 1];
			auth_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
			generatedAuth_len++;
		}
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		generatedSalt_buf[4] = generatedData_buf[0];
		generatedSalt_buf[5] = generatedData_buf[1];
		generatedSalt_buf[6] = generatedData_buf[2];
		generatedSalt_buf[7] = generatedData_buf[3];
		salt.setSalt_len(32);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_ZIP2 - 1/**
		   * digest buf (fake)
		   */);
		digest[0] = generatedAuth_buf[0];
		digest[1] = generatedAuth_buf[1];
		digest[2] = generatedAuth_buf[2];
		digest[3] = generatedAuth_buf[3];
		return (parser_rc.PARSER_OK);
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_OTM_SHA256// sig;// sig
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 10;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 10;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		// iter// itergeneratedSep[1] = (byte)':';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// salt// saltgeneratedSep[2] = (byte)':';
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 16;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// hash// hashgeneratedSep[3] = (byte)':';
		Object generatedLen = token.getLen();
		generatedLen[3] = 44;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		salt.setSalt_iter(iter - 1)// salt;// salt
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy(generatedSalt_buf, salt_pos, salt_len);
		salt.setSalt_len(salt_len)// hash;// hash
		u8 hash_pos = generatedBuf[3];
		int hash_len = generatedLen[3];
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hash_pos, hash_len, tmp_buf);
		.memcpy(digest_buf, tmp_buf, 32);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		wpa_pmkid_t wpa_pmkid = (wpa_pmkid_t)esalt_buf;
		// detect old/new format
		int old_sep = 0;
		int new_sep = 0;
		for (int i = 0;
		 i < line_len; i++) {
			byte c = line_buf[i];
			if (c == (byte)'*') {
				old_sep++;
			} 
			if (c == (byte)':') {
				new_sep++;
			} 
		}
		u8 sep = (new_sep > old_sep) ? (byte)':' : (byte)'*';
		// start normal parsing
		token_t token = new token_t();
		// real 16801 pmkid hash-lines
		token.setToken_cnt(3);
		Object generatedSep = token.getSep();
		generatedSep[0] = sep;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[1] = sep;
		generatedLen_min[1] = 12;
		generatedLen_max[1] = 12;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[2] = sep;
		generatedLen_min[2] = 12;
		generatedLen_max[2] = 12;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		Object generatedBuf = token.getBuf();
		Object generatedLen = token.getLen();
		Object generatedEssid_buf = wpa_pmkid.getEssid_buf();
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			token.setToken_cnt(4);
			generatedSep[0] = sep;
			generatedLen_min[0] = 32;
			generatedLen_max[0] = 32;
			generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[1] = sep;
			generatedLen_min[1] = 12;
			generatedLen_max[1] = 12;
			generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[2] = sep;
			generatedLen_min[2] = 12;
			generatedLen_max[2] = 12;
			generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[3] = sep;
			generatedLen_min[3] = 0;
			generatedLen_max[3] = 64;
			generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			int rc_tokenizer2 = token.input_tokenizer((u8)line_buf, line_len);
			if (rc_tokenizer2 != parser_rc.PARSER_OK) {
				return (rc_tokenizer);
			} 
			u8 essid_buf = generatedBuf[3];
			int essid_len = generatedLen[3];
			if (essid_len & 1) {
				return (parser_rc.PARSER_SALT_VALUE);
			} 
			wpa_pmkid.setEssid_len(ModernizedCProgram.hex_decode(essid_buf, essid_len, (u8)generatedEssid_buf));
		} 
		// we'll accept normal 16800 pmkid hash-lines, too
		// pmkidu8 pmkid_buf = generatedBuf[0];
		Object generatedPmkid = wpa_pmkid.getPmkid();
		generatedPmkid[0] = ModernizedCProgram.hex_to_u32(pmkid_buf + 0);
		generatedPmkid[1] = ModernizedCProgram.hex_to_u32(pmkid_buf + 8);
		generatedPmkid[2] = ModernizedCProgram.hex_to_u32(pmkid_buf + 16);
		generatedPmkid[3] = ModernizedCProgram.hex_to_u32(pmkid_buf + 24)// mac_ap;// mac_ap
		u8 macap_buf = generatedBuf[1];
		Object generatedOrig_mac_ap = wpa_pmkid.getOrig_mac_ap();
		generatedOrig_mac_ap[0] = ModernizedCProgram.hex_to_u8(macap_buf + 0);
		generatedOrig_mac_ap[1] = ModernizedCProgram.hex_to_u8(macap_buf + 2);
		generatedOrig_mac_ap[2] = ModernizedCProgram.hex_to_u8(macap_buf + 4);
		generatedOrig_mac_ap[3] = ModernizedCProgram.hex_to_u8(macap_buf + 6);
		generatedOrig_mac_ap[4] = ModernizedCProgram.hex_to_u8(macap_buf + 8);
		generatedOrig_mac_ap[5] = ModernizedCProgram.hex_to_u8(macap_buf + 10)// mac_sta;// mac_sta
		u8 macsta_buf = generatedBuf[2];
		Object generatedOrig_mac_sta = wpa_pmkid.getOrig_mac_sta();
		generatedOrig_mac_sta[0] = ModernizedCProgram.hex_to_u8(macsta_buf + 0);
		generatedOrig_mac_sta[1] = ModernizedCProgram.hex_to_u8(macsta_buf + 2);
		generatedOrig_mac_sta[2] = ModernizedCProgram.hex_to_u8(macsta_buf + 4);
		generatedOrig_mac_sta[3] = ModernizedCProgram.hex_to_u8(macsta_buf + 6);
		generatedOrig_mac_sta[4] = ModernizedCProgram.hex_to_u8(macsta_buf + 8);
		generatedOrig_mac_sta[5] = ModernizedCProgram.hex_to_u8(macsta_buf + 10)// pmkid_data;// pmkid_data
		Object generatedPmkid_data = wpa_pmkid.getPmkid_data();
		// "PMK "// "PMK "generatedPmkid_data[0] = -1024;
		// "Name"// "Name"generatedPmkid_data[1] = -1024;
		generatedPmkid_data[2] = (generatedOrig_mac_ap[0] << 0) | (generatedOrig_mac_ap[1] << 8) | (generatedOrig_mac_ap[2] << 16) | (generatedOrig_mac_ap[3] << 24);
		generatedPmkid_data[3] = (generatedOrig_mac_ap[4] << 0) | (generatedOrig_mac_ap[5] << 8) | (generatedOrig_mac_sta[0] << 16) | (generatedOrig_mac_sta[1] << 24);
		generatedPmkid_data[4] = (generatedOrig_mac_sta[2] << 0) | (generatedOrig_mac_sta[3] << 8) | (generatedOrig_mac_sta[4] << 16) | (generatedOrig_mac_sta[5] << 24);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedPmkid_data[0];
		generatedSalt_buf[1] = generatedPmkid_data[1];
		generatedSalt_buf[2] = generatedPmkid_data[2];
		generatedSalt_buf[3] = generatedPmkid_data[3];
		generatedSalt_buf[4] = generatedPmkid_data[4];
		generatedSalt_buf[5] = generatedPmkid_data[5];
		generatedSalt_buf[6] = generatedPmkid_data[6];
		generatedSalt_buf[7] = generatedPmkid_data[7];
		salt.setSalt_len(32);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_WPA_PMK - 1)// hash;// hash
		digest[0] = generatedPmkid[0];
		digest[1] = generatedPmkid[1];
		digest[2] = generatedPmkid[2];
		digest[3] = generatedPmkid[3];
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		pbkdf2_sha512_t pbkdf2_sha512 = (pbkdf2_sha512_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(5);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PASSLIB_PBKDF2_SHA512;
		Object generatedSep = token.getSep();
		// the hash starts with a $// the hash starts with a $generatedSep[0] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 0;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[1] = (byte)'$';
		generatedLen_min[1] = 13;
		generatedLen_max[1] = 13;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		// iterations in decimal representation// iterations in decimal representationgeneratedSep[2] = (byte)'$';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 6;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// salt in alternate base64 repretentation// salt in alternate base64 repretentationgeneratedSep[3] = (byte)'$';
		generatedLen_min[3] = 0;
		generatedLen_max[3] = 256;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		// payload in alternate base64 representanion// payload in alternate base64 representaniongeneratedSep[4] = (byte)'$';
		generatedLen_min[4] = ModernizedCProgram.HASH_LEN_B64;
		generatedLen_max[4] = ModernizedCProgram.HASH_LEN_B64;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		// iteru8 iter_pos = generatedBuf[2];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10) - 1);
		// base64 decode saltu8 salt_pos = generatedBuf[3];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[3];
		u8[] tmp_buf = new u8[]{0};
		size_t salt_len_decoded = ModernizedCProgram.base64_decode(ModernizedCProgram.ab64_to_int, (u8)salt_pos, salt_len, tmp_buf);
		Object generatedSalt_buf = pbkdf2_sha512.getSalt_buf();
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		.memcpy(salt_buf_ptr, tmp_buf, salt_len_decoded);
		.memcpy(generatedSalt_buf, salt_buf_ptr, salt_len_decoded);
		salt.setSalt_len(salt_len_decoded);
		// base64 decode hashu8 hash_pos = generatedBuf[4];
		int hash_len = generatedLen[4];
		ModernizedCProgram.base64_decode(ModernizedCProgram.ab64_to_int, (u8)hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, ModernizedCProgram.HASH_LEN_RAW);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		return (parser_rc.PARSER_OK);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_200000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(2048);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		wpa_pmkid_t wpa_pmkid = (wpa_pmkid_t)esalt_buf;
		// detect old/new format
		int old_sep = 0;
		int new_sep = 0;
		for (int i = 0;
		 i < line_len; i++) {
			byte c = line_buf[i];
			if (c == (byte)'*') {
				old_sep++;
			} 
			if (c == (byte)':') {
				new_sep++;
			} 
		}
		u8 sep = (new_sep > old_sep) ? (byte)':' : (byte)'*';
		// start normal parsing
		token_t token = new token_t();
		token.setToken_cnt(4);
		Object generatedSep = token.getSep();
		generatedSep[0] = sep;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[1] = sep;
		generatedLen_min[1] = 12;
		generatedLen_max[1] = 12;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[2] = sep;
		generatedLen_min[2] = 12;
		generatedLen_max[2] = 12;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = sep;
		generatedLen_min[3] = 0;
		generatedLen_max[3] = 64;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// pmkid
		Object generatedBuf = token.getBuf();
		u8 pmkid_buf = generatedBuf[0];
		Object generatedPmkid = wpa_pmkid.getPmkid();
		generatedPmkid[0] = ModernizedCProgram.hex_to_u32(pmkid_buf + 0);
		generatedPmkid[1] = ModernizedCProgram.hex_to_u32(pmkid_buf + 8);
		generatedPmkid[2] = ModernizedCProgram.hex_to_u32(pmkid_buf + 16);
		generatedPmkid[3] = ModernizedCProgram.hex_to_u32(pmkid_buf + 24)// mac_ap;// mac_ap
		u8 macap_buf = generatedBuf[1];
		Object generatedOrig_mac_ap = wpa_pmkid.getOrig_mac_ap();
		generatedOrig_mac_ap[0] = ModernizedCProgram.hex_to_u8(macap_buf + 0);
		generatedOrig_mac_ap[1] = ModernizedCProgram.hex_to_u8(macap_buf + 2);
		generatedOrig_mac_ap[2] = ModernizedCProgram.hex_to_u8(macap_buf + 4);
		generatedOrig_mac_ap[3] = ModernizedCProgram.hex_to_u8(macap_buf + 6);
		generatedOrig_mac_ap[4] = ModernizedCProgram.hex_to_u8(macap_buf + 8);
		generatedOrig_mac_ap[5] = ModernizedCProgram.hex_to_u8(macap_buf + 10)// mac_sta;// mac_sta
		u8 macsta_buf = generatedBuf[2];
		Object generatedOrig_mac_sta = wpa_pmkid.getOrig_mac_sta();
		generatedOrig_mac_sta[0] = ModernizedCProgram.hex_to_u8(macsta_buf + 0);
		generatedOrig_mac_sta[1] = ModernizedCProgram.hex_to_u8(macsta_buf + 2);
		generatedOrig_mac_sta[2] = ModernizedCProgram.hex_to_u8(macsta_buf + 4);
		generatedOrig_mac_sta[3] = ModernizedCProgram.hex_to_u8(macsta_buf + 6);
		generatedOrig_mac_sta[4] = ModernizedCProgram.hex_to_u8(macsta_buf + 8);
		generatedOrig_mac_sta[5] = ModernizedCProgram.hex_to_u8(macsta_buf + 10)// essid;// essid
		u8 essid_buf = generatedBuf[3];
		Object generatedLen = token.getLen();
		int essid_len = generatedLen[3];
		if (essid_len & 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedEssid_buf = wpa_pmkid.getEssid_buf();
		wpa_pmkid.setEssid_len(ModernizedCProgram.hex_decode(essid_buf, essid_len, (u8)generatedEssid_buf))// pmkid_data;// pmkid_data
		Object generatedPmkid_data = wpa_pmkid.getPmkid_data();
		// "PMK "// "PMK "generatedPmkid_data[0] = -1024;
		// "Name"// "Name"generatedPmkid_data[1] = -1024;
		generatedPmkid_data[2] = (generatedOrig_mac_ap[0] << 0) | (generatedOrig_mac_ap[1] << 8) | (generatedOrig_mac_ap[2] << 16) | (generatedOrig_mac_ap[3] << 24);
		generatedPmkid_data[3] = (generatedOrig_mac_ap[4] << 0) | (generatedOrig_mac_ap[5] << 8) | (generatedOrig_mac_sta[0] << 16) | (generatedOrig_mac_sta[1] << 24);
		generatedPmkid_data[4] = (generatedOrig_mac_sta[2] << 0) | (generatedOrig_mac_sta[3] << 8) | (generatedOrig_mac_sta[4] << 16) | (generatedOrig_mac_sta[5] << 24);
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedEssid_len = wpa_pmkid.getEssid_len();
		.memcpy(generatedSalt_buf, generatedEssid_buf, generatedEssid_len);
		salt.setSalt_len(generatedEssid_len);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_WPA_PBKDF2 - 1)// hash;// hash
		digest[0] = generatedPmkid[0];
		digest[1] = generatedPmkid[1];
		digest[2] = generatedPmkid[2];
		digest[3] = generatedPmkid[3];
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SHA256AIX;
		Object generatedLen = token.getLen();
		generatedLen[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 2;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 2;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[2] = 16;
		generatedLen_max[2] = 48;
		generatedSep[2] = (byte)'$';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen[3] = 43;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		byte[] salt_iter = new byte[]{iter_pos[0], iter_pos[1], 0};
		Object generatedSalt_sign = salt.getSalt_sign();
		generatedSalt_sign[0] = ModernizedCProgram.hc_strtoul((byte)salt_iter, ((Object)0), 10);
		salt.setSalt_iter((-1024 << ModernizedCProgram.hc_strtoul((byte)salt_iter, ((Object)0), 10)) - 1);
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 hash_pos = generatedBuf[3];
		ModernizedCProgram.sha256aix_decode((u8)digest, hash_pos);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D/**
			   * This is a virtual salt. While the algorithm is basically not salted
			   * we can exploit the salt buffer to set the 0x80 and the w[14] value.
			   * This way we can save a special md5md5 kernel and reuse the one from vbull.
			   */;
		} 
		u8 zero = (u8)"";
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, zero, 0, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'$';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[1] = 16;
		generatedLen_max[1] = 16;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer/**
			   * salt
			   */);
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[0];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[0];
		int user_len = 0;
		for (int i = 0;
		 i < salt_len; i++) {
			if (salt_pos[i] == (byte)' ') {
				continue;
			} 
			user_len++;
		}
		// SAP user names cannot be longer than 12 charactersif (user_len > 12) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// SAP user name cannot start with ! or ?if (salt_pos[0] == (byte)'!' || salt_pos[0] == (byte)'?') {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH/**
			   * hash
			   */);
		} 
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(4);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_BCRYPT1;
		generatedSignatures_buf[1] = ModernizedCProgram.SIGNATURE_BCRYPT2;
		generatedSignatures_buf[2] = ModernizedCProgram.SIGNATURE_BCRYPT3;
		generatedSignatures_buf[3] = ModernizedCProgram.SIGNATURE_BCRYPT4;
		Object generatedLen = token.getLen();
		generatedLen[0] = 4;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 2;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 2;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen[2] = 22;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		generatedLen[3] = 31;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u8 salt_pos = generatedBuf[2];
		u8 hash_pos = generatedBuf[3];
		int salt_len = generatedLen[2];
		int hash_len = generatedLen[3];
		salt.setSalt_len(16);
		salt.setSalt_iter(-1024 << ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10));
		Object generatedSalt_sign = salt.getSalt_sign();
		.memcpy((byte)generatedSalt_sign, line_buf, 6);
		Object generatedSalt_buf = salt.getSalt_buf();
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		u8[] tmp_buf = new u8();
		.memset(tmp_buf, 0, );
		ModernizedCProgram.base64_decode(ModernizedCProgram.bf64_to_int, (u8)salt_pos, salt_len, tmp_buf);
		.memcpy(salt_buf_ptr, tmp_buf, 16);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3]);
		.memset(tmp_buf, 0, );
		ModernizedCProgram.base64_decode(ModernizedCProgram.bf64_to_int, (u8)hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, 24);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		// its just 23 not 24 !// its just 23 not 24 !digest[5] &=  ~-1024;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		itunes_backup_t itunes_backup = (itunes_backup_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(7);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ITUNES_BACKUP;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 15;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 15;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 2;
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 80;
		generatedLen_max[2] = 80;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[3] = 1;
		generatedLen_max[3] = 6;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 40;
		generatedLen_max[4] = 40;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[5] = 0;
		generatedLen_max[5] = 10;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[6] = 0;
		generatedLen_max[6] = 40;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// version
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u32 version = ModernizedCProgram.hc_strtoul((byte)version_pos, ((Object)0), 10);
		u32 hash_mode = hashconfig.getHash_mode();
		if (hash_mode == 14700) {
			if (version != 9) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
		}  else if (hash_mode == 14800) {
			if (version != 10) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
		} 
		Object generatedSalt_sign = salt.getSalt_sign();
		generatedSalt_sign[0] = (byte)version// wpky;// wpky
		u8 wpky_pos = generatedBuf[2];
		Object generatedWpky = itunes_backup.getWpky();
		u32 wpky_buf_ptr = (u32)generatedWpky;
		wpky_buf_ptr[0] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[0]);
		wpky_buf_ptr[1] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[8]);
		wpky_buf_ptr[2] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[16]);
		wpky_buf_ptr[3] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[24]);
		wpky_buf_ptr[4] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[32]);
		wpky_buf_ptr[5] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[40]);
		wpky_buf_ptr[6] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[48]);
		wpky_buf_ptr[7] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[56]);
		wpky_buf_ptr[8] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[64]);
		wpky_buf_ptr[9] = ModernizedCProgram.hex_to_u32((u8)wpky_pos[72]);
		wpky_buf_ptr[0] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[0]);
		wpky_buf_ptr[1] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[1]);
		wpky_buf_ptr[2] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[2]);
		wpky_buf_ptr[3] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[3]);
		wpky_buf_ptr[4] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[4]);
		wpky_buf_ptr[5] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[5]);
		wpky_buf_ptr[6] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[6]);
		wpky_buf_ptr[7] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[7]);
		wpky_buf_ptr[8] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[8]);
		wpky_buf_ptr[9] = ModernizedCProgram.byte_swap_32(wpky_buf_ptr[9])// iter;// iter
		u8 iter_pos = generatedBuf[3];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		if (iter < 1) {
			return (parser_rc.PARSER_SALT_ITERATION);
		} 
		if (hash_mode == 14700) {
			salt.setSalt_iter(iter - 1);
		}  else if (hash_mode == 14800) {
			salt.setSalt_iter(0);
			salt.setSalt_iter2(iter - 1);
		} 
		// saltu8 salt_pos = generatedBuf[4];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[4];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3]);
		generatedSalt_buf[4] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[4])// dpic + dpsl;// dpic + dpsl
		u8 dpic_pos = generatedBuf[5];
		int dpic_len = generatedLen[5];
		u8 dpsl_pos = generatedBuf[6];
		int dpsl_len = generatedLen[6];
		u32 dpic = 0;
		Object generatedDpsl = itunes_backup.getDpsl();
		if (hash_mode == 14700) {
			if (dpic_len > 0) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
			if (dpsl_len > 0) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
		}  else if (hash_mode == 14800) {
			if (dpic_len < 1) {
				return (parser_rc.PARSER_SALT_ITERATION);
			} 
			if (dpic_len > 9) {
				return (parser_rc.PARSER_SALT_ITERATION);
			} 
			dpic = ModernizedCProgram.hc_strtoul((byte)dpic_pos, ((Object)0), 10);
			if (dpic < 1) {
				return (parser_rc.PARSER_SALT_ITERATION);
			} 
			salt.setSalt_iter(dpic - 1);
			if (dpsl_len != 40) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
			u32 dpsl_buf_ptr = (u32)generatedDpsl;
			dpsl_buf_ptr[0] = ModernizedCProgram.hex_to_u32((u8)dpsl_pos[0]);
			dpsl_buf_ptr[1] = ModernizedCProgram.hex_to_u32((u8)dpsl_pos[8]);
			dpsl_buf_ptr[2] = ModernizedCProgram.hex_to_u32((u8)dpsl_pos[16]);
			dpsl_buf_ptr[3] = ModernizedCProgram.hex_to_u32((u8)dpsl_pos[24]);
			dpsl_buf_ptr[4] = ModernizedCProgram.hex_to_u32((u8)dpsl_pos[32]);
			dpsl_buf_ptr[0] = ModernizedCProgram.byte_swap_32(dpsl_buf_ptr[0]);
			dpsl_buf_ptr[1] = ModernizedCProgram.byte_swap_32(dpsl_buf_ptr[1]);
			dpsl_buf_ptr[2] = ModernizedCProgram.byte_swap_32(dpsl_buf_ptr[2]);
			dpsl_buf_ptr[3] = ModernizedCProgram.byte_swap_32(dpsl_buf_ptr[3]);
			dpsl_buf_ptr[4] = ModernizedCProgram.byte_swap_32(dpsl_buf_ptr[4]);
		} 
		digest[0] = generatedDpsl[0] ^ generatedWpky[0];
		digest[1] = generatedDpsl[1] ^ generatedWpky[1];
		digest[2] = generatedDpsl[2] ^ generatedWpky[2];
		digest[3] = generatedDpsl[3] ^ generatedWpky[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 16;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 16;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = 0;
		digest[3] = 0;
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		pbkdf2_sha512_t pbkdf2_sha512 = (pbkdf2_sha512_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PBKDF2_SHA512;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 6;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)':';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)':';
		generatedLen_min[2] = ((0 * 8) / 6) + 0;
		generatedLen_max[2] = ((256 * 8) / 6) + 3;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		generatedSep[3] = (byte)':';
		generatedLen_min[3] = 16;
		generatedLen_max[3] = 256;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		u8[] tmp_buf = new u8();
		int tmp_len;
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		salt.setSalt_iter(iter - 1)// salt;// salt
		u8 salt_pos = generatedBuf[2];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[2];
		.memset(tmp_buf, 0, );
		tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, salt_pos, salt_len, tmp_buf);
		if (tmp_len > 256) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt_buf = pbkdf2_sha512.getSalt_buf();
		.memcpy(generatedSalt_buf, tmp_buf, tmp_len);
		salt.setSalt_len(tmp_len);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_buf[4] = generatedSalt_iter// hash;// hash
		u8 hash_pos = generatedBuf[3];
		int hash_len = generatedLen[3];
		.memset(tmp_buf, 0, );
		tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hash_pos, hash_len, tmp_buf);
		if (tmp_len < 16) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		.memcpy(digest, tmp_buf, 64);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		pkzip_t pkzip = (pkzip_t)esalt_buf;
		u32 digest = (u32)digest_buf;
		byte[] input = new byte[line_len + 1];
		input[line_len] = (byte)'\0';
		.memcpy(input, line_buf, line_len);
		byte saveptr = ((Object)0);
		byte p = .strtok_r(input, "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		if (.strncmp(p, ModernizedCProgram.SIGNATURE_PKZIP_V1, 7) != 0 && .strncmp(p, ModernizedCProgram.SIGNATURE_PKZIP_V2, 8) != 0) {
			return parser_rc.PARSER_SIGNATURE_UNMATCHED;
		} 
		pkzip.setVersion(1);
		if (.strlen(p) == 9) {
			pkzip.setVersion(2);
		} 
		byte[] sub = new byte[2];
		sub[0] = p[.strlen(p) - 1];
		sub[1] = (byte)'\0';
		pkzip.setHash_count(.atoi(sub));
		Object generatedHash_count = pkzip.getHash_count();
		// check here that the hash_count is valid for the attack typeif (generatedHash_count > 8) {
			return parser_rc.PARSER_HASH_VALUE;
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		pkzip.setChecksum_size(.atoi(p));
		Object generatedChecksum_size = pkzip.getChecksum_size();
		if (generatedChecksum_size != 1 && generatedChecksum_size != 2) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		Object generatedHashes = pkzip.getHashes();
		Object generatedVersion = pkzip.getVersion();
		Object generatedSalt_buf = salt.getSalt_buf();
		for (int i = 0;
		 i < generatedHash_count; i++) {
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setData_type_enum(.atoi(p));
			if (generatedHashes[i].getData_type_enum() > 3) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setMagic_type_enum(.atoi(p));
			if (generatedHashes[i].getData_type_enum() > 1) {
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setCompressed_length(.strtoul(p, ((Object)0), 16));
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setUncompressed_length(.strtoul(p, ((Object)0), 16));
				if (generatedHashes[i].getCompressed_length() > (320 * 1024)) {
					return parser_rc.PARSER_TOKEN_LENGTH;
				} 
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				u32 crc32 = 0;
				.sscanf(p, "%x", ModernizedCProgram.crc32);
				generatedHashes[i].setCrc32(ModernizedCProgram.crc32);
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setOffset(.strtoul(p, ((Object)0), 16));
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setAdditional_offset(.strtoul(p, ((Object)0), 16));
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setCompression_type(.atoi(p));
			if (generatedHashes[i].getCompression_type() != 8 && generatedHashes[i].getCompression_type() != 0) {
				return parser_rc.PARSER_HASH_VALUE;
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setData_length(.strtoul(p, ((Object)0), 16));
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			u16 checksum_from_crc = 0;
			.sscanf(p, "%hx", checksum_from_crc);
			generatedHashes[i].setChecksum_from_crc(checksum_from_crc);
			if (generatedVersion == 2) {
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				u16 checksum_from_timestamp = 0;
				.sscanf(p, "%hx", checksum_from_timestamp);
				generatedHashes[i].setChecksum_from_timestamp(checksum_from_timestamp);
			} else {
					generatedHashes[i].setChecksum_from_timestamp(generatedHashes[i].getChecksum_from_crc());
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			ModernizedCProgram.hex_to_binary(p, .strlen(p), (byte)(generatedHashes[i].getData()));
			generatedSalt_buf[i] = generatedHashes[i].getData()[0];
			if (i == 0) {
				digest[i] = generatedHashes[i].getChecksum_from_crc();
			} 
		}
		salt.setSalt_len(generatedHash_count << 2);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PHPS;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 0 * 2;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 256 * 2;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 32;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[2];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pbkdf2_sha1_t pbkdf2_sha1 = (pbkdf2_sha1_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ATLASSIAN;
		Object generatedLen = token.getLen();
		generatedLen[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 64;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hashsalt_pos = generatedBuf[1];
		int hashsalt_len = generatedLen[1];
		u8[] tmp_buf = new u8[]{0};
		int base64_decode_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hashsalt_pos, hashsalt_len, tmp_buf);
		if (base64_decode_len != (16 + 32)) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		u8 hash_pos = tmp_buf + 16;
		.memcpy(digest, hash_pos, 16);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3])// store salt;// store salt
		u8 salt_pos = tmp_buf;
		int salt_len = 16;
		Object generatedSalt_buf = pbkdf2_sha1.getSalt_buf();
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		.memcpy(salt_buf_ptr, salt_pos, salt_len);
		salt.setSalt_len(salt_len);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_ATLASSIAN - 1)// add some stuff to normal salt to make sorted happy;// add some stuff to normal salt to make sorted happy
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_buf[4] = generatedSalt_iter;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 96;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 96;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = 0;
		digest[7] = 0;
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = 0;
		digest[7] = 0;
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_64_constants.SHA384M_A;
			digest[1] -= sha2_64_constants.SHA384M_B;
			digest[2] -= sha2_64_constants.SHA384M_C;
			digest[3] -= sha2_64_constants.SHA384M_D;
			digest[4] -= sha2_64_constants.SHA384M_E;
			digest[5] -= sha2_64_constants.SHA384M_F;
			digest[6] -= 0;
			digest[7] -= 0;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		diskcryptor_esalt_t diskcryptor_esalt = (diskcryptor_esalt_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_DISKCRYPTOR;
		Object generatedLen = token.getLen();
		generatedLen[0] = 13;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[2] = 4096;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// version
		Object generatedBuf = token.getBuf();
		u8 version = generatedBuf[1];
		if (version[0] != (byte)'0' + ModernizedCProgram.DISKCRYPTOR_VERSION) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		// esalt
		u8 data_buf = generatedBuf[2];
		Object generatedSalt_buf = diskcryptor_esalt.getSalt_buf();
		for (u32 i = 0;
		 i < 512; i++) {
			generatedSalt_buf[i] = ModernizedCProgram.hex_to_u32(data_buf[i * 8]);
		}
		// salt param// salt paramsalt.setSalt_len(64);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_DISKCRYPTOR - 1)// salt;// salt
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		generatedSalt_buf[4] = generatedSalt_buf[4];
		generatedSalt_buf[5] = generatedSalt_buf[5];
		generatedSalt_buf[6] = generatedSalt_buf[6];
		generatedSalt_buf[7] = generatedSalt_buf[7];
		generatedSalt_buf[8] = generatedSalt_buf[8];
		generatedSalt_buf[9] = generatedSalt_buf[9];
		generatedSalt_buf[10] = generatedSalt_buf[10];
		generatedSalt_buf[11] = generatedSalt_buf[11];
		generatedSalt_buf[12] = generatedSalt_buf[12];
		generatedSalt_buf[13] = generatedSalt_buf[13];
		generatedSalt_buf[14] = generatedSalt_buf[14];
		generatedSalt_buf[15] = generatedSalt_buf[15]// digest;// digest
		digest[0] = generatedSalt_buf[16];
		digest[1] = generatedSalt_buf[17];
		digest[2] = generatedSalt_buf[18];
		digest[3] = generatedSalt_buf[19];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'@';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 0;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[1] = (byte)'@';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 8;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[2] = (byte)'@';
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 128;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'@';
		generatedLen_min[3] = 8;
		generatedLen_max[3] = 16;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// check hash type
		Object generatedBuf = token.getBuf();
		if (generatedBuf[1][0] != (byte)'m') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		// check iter
		u32 iter = ModernizedCProgram.ROUNDS_QNX;
		Object generatedLen = token.getLen();
		if (generatedLen[1] > 1) {
			if (generatedBuf[1][1] != (byte)',') {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
			iter = ModernizedCProgram.hc_strtoul((byte)generatedBuf[1] + 2, ((Object)0), 10);
		} 
		// iter++; the additinal round is added in the init kernel// iter++; the additinal round is added in the init kernelsalt.setSalt_iter(iter)// digest;// digest
		if (generatedLen[2] != 32) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 0);
		digest[1] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 8);
		digest[2] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 16);
		digest[3] = ModernizedCProgram.hex_to_u32((u8)generatedBuf[2] + 24)// salt;// salt
		Object generatedSalt_buf = salt.getSalt_buf();
		if ((generatedLen[3] == 8) || (generatedLen[3] == 16)) {
			.memcpy(generatedSalt_buf, generatedBuf[3], generatedLen[3]);
			salt.setSalt_len(generatedLen[3]);
		} else {
				return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		int hash_len = generatedLen[0];
		if (hash_len != 128) {
			return (parser_rc.PARSER_GLOBAL_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 55;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		.memset(digest, 0, hashconfig.getDgst_size());
		Object generatedBuf = token.getBuf();
		u8 pw_buf = generatedBuf[0];
		Object generatedLen = token.getLen();
		int pw_len = generatedLen[0];
		.memcpy((byte)digest + 64, pw_buf, pw_len)//strncpy ((char *) digest + 64, (char *) input_buf, 64);;//strncpy ((char *) digest + 64, (char *) input_buf, 64);
		u32[] w = new u32[]{0};
		//strncpy ((char *) w, (char *) input_buf, 64);
		.memcpy(w, pw_buf, pw_len);
		md4_ctx_t ctx = new md4_ctx_t();
		.md4_init(ctx);
		.md4_update(ctx, w, pw_len);
		.md4_final(ctx);
		Object generatedH = ctx.getH();
		digest[0] = generatedH[0];
		digest[1] = generatedH[1];
		digest[2] = generatedH[2];
		digest[3] = generatedH[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md4_constants.MD4M_A;
			digest[1] -= md4_constants.MD4M_B;
			digest[2] -= md4_constants.MD4M_C;
			digest[3] -= md4_constants.MD4M_D;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 32;
		generatedLen_max[1] = 32;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		ethereum_scrypt_t ethereum_scrypt = (ethereum_scrypt_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(7);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ETHEREUM_SCRYPT;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 11;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)'*';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 6;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 1;
		generatedLen_max[3] = 6;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[4] = (byte)'*';
		generatedLen_min[4] = 64;
		generatedLen_max[4] = 64;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[5] = (byte)'*';
		generatedLen_min[5] = 64;
		generatedLen_max[5] = 64;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[6] = (byte)'*';
		generatedLen_min[6] = 64;
		generatedLen_max[6] = 64;
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// scrypt settings
		Object generatedBuf = token.getBuf();
		u8 scryptN_pos = generatedBuf[1];
		u8 scryptr_pos = generatedBuf[2];
		u8 scryptp_pos = generatedBuf[3];
		u32 scrypt_N = ModernizedCProgram.hc_strtoul((byte)scryptN_pos, ((Object)0), 10);
		u32 scrypt_r = ModernizedCProgram.hc_strtoul((byte)scryptr_pos, ((Object)0), 10);
		u32 scrypt_p = ModernizedCProgram.hc_strtoul((byte)scryptp_pos, ((Object)0), 10);
		salt.setScrypt_N(scrypt_N);
		salt.setScrypt_r(scrypt_r);
		salt.setScrypt_p(scrypt_p)// salt;// salt
		u8 salt_pos = generatedBuf[4];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[4];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		generatedSalt_buf[4] = generatedSalt_buf[4];
		generatedSalt_buf[5] = generatedSalt_buf[5];
		generatedSalt_buf[6] = generatedSalt_buf[6];
		generatedSalt_buf[7] = generatedSalt_buf[7];
		salt.setSalt_iter(1)// ciphertext;// ciphertext
		u8 ciphertext_pos = generatedBuf[5];
		Object generatedCiphertext = ethereum_scrypt.getCiphertext();
		generatedCiphertext[0] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[0]);
		generatedCiphertext[1] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[8]);
		generatedCiphertext[2] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[16]);
		generatedCiphertext[3] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[24]);
		generatedCiphertext[4] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[32]);
		generatedCiphertext[5] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[40]);
		generatedCiphertext[6] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[48]);
		generatedCiphertext[7] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[56])// hash;// hash
		u8 hash_pos = generatedBuf[6];
		digest[0] = ModernizedCProgram.hex_to_u32((u8)hash_pos[0]);
		digest[1] = ModernizedCProgram.hex_to_u32((u8)hash_pos[8]);
		digest[2] = ModernizedCProgram.hex_to_u32((u8)hash_pos[16]);
		digest[3] = ModernizedCProgram.hex_to_u32((u8)hash_pos[24]);
		digest[4] = ModernizedCProgram.hex_to_u32((u8)hash_pos[32]);
		digest[5] = ModernizedCProgram.hex_to_u32((u8)hash_pos[40]);
		digest[6] = ModernizedCProgram.hex_to_u32((u8)hash_pos[48]);
		digest[7] = ModernizedCProgram.hex_to_u32((u8)hash_pos[56]);
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		int hash_len = generatedLen[0];
		if (hash_len != 64) {
			return (parser_rc.PARSER_GLOBAL_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		rakp_t rakp = (rakp_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 512;
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 40;
		generatedLen_max[1] = 40;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[0];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[0];
		Object generatedSalt_buf = rakp.getSalt_buf();
		u8 rakp_ptr = (u8)generatedSalt_buf;
		int i;
		int j;
		for (; i < salt_len; ) {
			rakp_ptr[j] = ModernizedCProgram.hex_to_u8(salt_pos + i);
		}
		rakp_ptr[j] = -1024;
		rakp.setSalt_len(j);
		for (i = 0; i < 64; i++) {
			generatedSalt_buf[i] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[i]);
		}
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		generatedSalt_buf[4] = generatedSalt_buf[4];
		generatedSalt_buf[5] = generatedSalt_buf[5];
		generatedSalt_buf[6] = generatedSalt_buf[6];
		generatedSalt_buf[7] = generatedSalt_buf[7];
		// muss min. 32 haben// muss min. 32 habensalt.setSalt_len(32);
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		ikepsk_t ikepsk = (ikepsk_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(9);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 1024;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[1] = (byte)':';
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 1024;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[2] = (byte)':';
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 1024;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)':';
		generatedLen_min[3] = 0;
		generatedLen_max[3] = 1024;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[4] = (byte)':';
		generatedLen_min[4] = 0;
		generatedLen_max[4] = 1024;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[5] = (byte)':';
		generatedLen_min[5] = 0;
		generatedLen_max[5] = 1024;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[6] = (byte)':';
		generatedLen_min[6] = 0;
		generatedLen_max[6] = 128;
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[7] = (byte)':';
		generatedLen_min[7] = 0;
		generatedLen_max[7] = 128;
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[8] = (byte)':';
		generatedLen_min[8] = 40;
		generatedLen_max[8] = 40;
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedMsg_len = ikepsk.getMsg_len();
		Object generatedLen = token.getLen();
		generatedMsg_len[0] = generatedLen[0] / 2;
		generatedMsg_len[1] = generatedMsg_len[0] + generatedLen[1] / 2;
		generatedMsg_len[2] = generatedMsg_len[1] + generatedLen[2] / 2;
		generatedMsg_len[3] = generatedMsg_len[2] + generatedLen[3] / 2;
		generatedMsg_len[4] = generatedMsg_len[3] + generatedLen[4] / 2;
		generatedMsg_len[5] = generatedMsg_len[4] + generatedLen[5] / 2;
		ikepsk.setNr_len((generatedLen[6] + generatedLen[7]) / 2);
		if (generatedMsg_len[5] > 512) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedNr_len = ikepsk.getNr_len();
		if (generatedNr_len > 64) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedMsg_buf = ikepsk.getMsg_buf();
		u8 ptr1 = (u8)generatedMsg_buf;
		Object generatedNr_buf = ikepsk.getNr_buf();
		u8 ptr2 = (u8)generatedNr_buf;
		Object generatedBuf = token.getBuf();
		for (int i = 0;
		 i < generatedLen[0]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[0] + i);
		}
		for (int i = 0;
		 i < generatedLen[1]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[1] + i);
		}
		for (int i = 0;
		 i < generatedLen[2]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[2] + i);
		}
		for (int i = 0;
		 i < generatedLen[3]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[3] + i);
		}
		for (int i = 0;
		 i < generatedLen[4]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[4] + i);
		}
		for (int i = 0;
		 i < generatedLen[5]; i += 2) {
			ptr1++ = ModernizedCProgram.hex_to_u8(generatedBuf[5] + i);
		}
		for (int i = 0;
		 i < generatedLen[6]; i += 2) {
			ptr2++ = ModernizedCProgram.hex_to_u8(generatedBuf[6] + i);
		}
		for (int i = 0;
		 i < generatedLen[7]; i += 2) {
			ptr2++ = ModernizedCProgram.hex_to_u8(generatedBuf[7] + i);
		}
		ptr1++ = -1024;
		ptr2++ = -1024/**
		   * Store to database
		   */;
		u8 hash_pos = generatedBuf[8];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		salt.setSalt_len(32);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedNr_buf[0];
		generatedSalt_buf[1] = generatedNr_buf[1];
		generatedSalt_buf[2] = generatedNr_buf[2];
		generatedSalt_buf[3] = generatedNr_buf[3];
		generatedSalt_buf[4] = generatedNr_buf[4];
		generatedSalt_buf[5] = generatedNr_buf[5];
		generatedSalt_buf[6] = generatedNr_buf[6];
		generatedSalt_buf[7] = generatedNr_buf[7];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pbkdf2_sha256_t pbkdf2_sha256 = (pbkdf2_sha256_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_CISCO8;
		Object generatedLen = token.getLen();
		generatedLen[0] = 3;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 14;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 14;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen[2] = 43;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// salt is not encoded
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = pbkdf2_sha256.getSalt_buf();
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		.memcpy(salt_buf_ptr, salt_pos, salt_len);
		salt_buf_ptr[17] = -1024;
		salt_buf_ptr[18] = -1024// add some stuff to normal salt to make sorted happy;// add some stuff to normal salt to make sorted happy
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		salt.setSalt_len(salt_len);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_CISCO8 - 1)// base64 decode hash;// base64 decode hash
		u8 hash_pos = generatedBuf[2];
		int hash_len = generatedLen[2];
		u8[] tmp_buf = new u8[]{0};
		int tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.itoa64_to_int, hash_pos, hash_len, tmp_buf);
		if (tmp_len != 32) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		.memcpy(digest, tmp_buf, 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		apple_secure_notes_t apple_secure_notes = (apple_secure_notes_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(5);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_APPLE_SECURE_NOTES;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 5;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)'*';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 10;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 6;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[4] = (byte)'*';
		generatedLen_min[4] = 48;
		generatedLen_max[4] = 48;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer/**
			   * parse line
			   */);
		} 
		Object generatedBuf = token.getBuf();
		// Z_PKu8 Z_PK_pos = generatedBuf[1];
		u32 Z_PK = ModernizedCProgram.hc_strtoul((byte)Z_PK_pos, ((Object)0), 10);
		apple_secure_notes.setZ_PK(Z_PK)// ZCRYPTOITERATIONCOUNT;// ZCRYPTOITERATIONCOUNT
		u8 ZCRYPTOITERATIONCOUNT_pos = generatedBuf[2];
		u32 ZCRYPTOITERATIONCOUNT = ModernizedCProgram.hc_strtoul((byte)ZCRYPTOITERATIONCOUNT_pos, ((Object)0), 10);
		apple_secure_notes.setZCRYPTOITERATIONCOUNT(ZCRYPTOITERATIONCOUNT)// ZCRYPTOSALT;// ZCRYPTOSALT
		u8 ZCRYPTOSALT_pos = generatedBuf[3];
		Object generatedZCRYPTOSALT = apple_secure_notes.getZCRYPTOSALT();
		generatedZCRYPTOSALT[0] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[0]);
		generatedZCRYPTOSALT[1] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[8]);
		generatedZCRYPTOSALT[2] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[16]);
		generatedZCRYPTOSALT[3] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[24]);
		generatedZCRYPTOSALT[4] = 0;
		generatedZCRYPTOSALT[5] = 0;
		generatedZCRYPTOSALT[6] = 0;
		generatedZCRYPTOSALT[7] = 0;
		generatedZCRYPTOSALT[8] = 0;
		generatedZCRYPTOSALT[9] = 0;
		generatedZCRYPTOSALT[10] = 0;
		generatedZCRYPTOSALT[11] = 0;
		generatedZCRYPTOSALT[12] = 0;
		generatedZCRYPTOSALT[13] = 0;
		generatedZCRYPTOSALT[14] = 0;
		generatedZCRYPTOSALT[15] = 0// ZCRYPTOWRAPPEDKEY;// ZCRYPTOWRAPPEDKEY
		u8 ZCRYPTOWRAPPEDKEY_pos = generatedBuf[4];
		Object generatedZCRYPTOWRAPPEDKEY = apple_secure_notes.getZCRYPTOWRAPPEDKEY();
		generatedZCRYPTOWRAPPEDKEY[0] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[0]);
		generatedZCRYPTOWRAPPEDKEY[1] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[8]);
		generatedZCRYPTOWRAPPEDKEY[2] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[16]);
		generatedZCRYPTOWRAPPEDKEY[3] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[24]);
		generatedZCRYPTOWRAPPEDKEY[4] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[32]);
		generatedZCRYPTOWRAPPEDKEY[5] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[40])// fake salt;// fake salt
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedZCRYPTOSALT[0];
		generatedSalt_buf[1] = generatedZCRYPTOSALT[1];
		generatedSalt_buf[2] = generatedZCRYPTOSALT[2];
		generatedSalt_buf[3] = generatedZCRYPTOSALT[3];
		Object generatedZ_PK = apple_secure_notes.getZ_PK();
		generatedSalt_buf[4] = generatedZ_PK;
		Object generatedZCRYPTOITERATIONCOUNT = apple_secure_notes.getZCRYPTOITERATIONCOUNT();
		salt.setSalt_iter(generatedZCRYPTOITERATIONCOUNT - 1);
		salt.setSalt_len(20)// fake hash;// fake hash
		digest[0] = generatedZCRYPTOWRAPPEDKEY[0];
		digest[1] = generatedZCRYPTOWRAPPEDKEY[1];
		digest[2] = generatedZCRYPTOWRAPPEDKEY[2];
		digest[3] = generatedZCRYPTOWRAPPEDKEY[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pdf_t pdf = (pdf_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(16);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PDF;
		Object generatedLen = token.getLen();
		generatedLen[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 3;
		generatedLen_max[3] = 3;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 1;
		generatedLen_max[4] = 6;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[5] = 1;
		generatedLen_max[5] = 1;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[6] = 1;
		generatedLen_max[6] = 4;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[7] = 0;
		generatedLen_max[7] = 1024;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[8] = 1;
		generatedLen_max[8] = 4;
		generatedSep[8] = (byte)'*';
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[9] = 0;
		generatedLen_max[9] = 1024;
		generatedSep[9] = (byte)'*';
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[10] = 1;
		generatedLen_max[10] = 4;
		generatedSep[10] = (byte)'*';
		generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[11] = 0;
		generatedLen_max[11] = 1024;
		generatedSep[11] = (byte)'*';
		generatedAttr[11] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[12] = 1;
		generatedLen_max[12] = 4;
		generatedSep[12] = (byte)'*';
		generatedAttr[12] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[13] = 0;
		generatedLen_max[13] = 1024;
		generatedSep[13] = (byte)'*';
		generatedAttr[13] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[14] = 1;
		generatedLen_max[14] = 4;
		generatedSep[14] = (byte)'*';
		generatedAttr[14] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[15] = 0;
		generatedLen_max[15] = 1024;
		generatedSep[15] = (byte)'*';
		generatedAttr[15] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 V_pos = generatedBuf[1];
		u8 R_pos = generatedBuf[2];
		u8 bits_pos = generatedBuf[3];
		u8 enc_md_pos = generatedBuf[5];
		u8 u_len_pos = generatedBuf[8];
		u8 u_buf_pos = generatedBuf[9];
		// validate data
		int V = .strtol((byte)V_pos, ((Object)0), 10);
		int R = .strtol((byte)R_pos, ((Object)0), 10);
		int vr_ok = 0;
		if ((V == 5) && (R == 5)) {
			vr_ok = 1;
		} 
		if ((V == 5) && (R == 6)) {
			vr_ok = 1;
		} 
		if (vr_ok == 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int bits = .strtol((byte)bits_pos, ((Object)0), 10);
		if (bits != 256) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int enc_md = .strtol((byte)enc_md_pos, ((Object)0), 10);
		if ((enc_md != 0) && (enc_md != 1)) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		u32 u_len = ModernizedCProgram.hc_strtoul((byte)u_len_pos, ((Object)0), 10);
		// copy data to esalt
		if (u_len < 40) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (ModernizedCProgram.is_valid_hex_string(u_buf_pos, 80) == 0) {
			return (parser_rc.PARSER_SALT_ENCODING);
		} 
		Object generatedU_buf = pdf.getU_buf();
		for (int i = 0;
		int j = 0;
		 i < 8 + 2; ) {
			generatedU_buf[i] = ModernizedCProgram.hex_to_u32((u8)u_buf_pos[j]);
		}
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedU_buf[8];
		generatedSalt_buf[1] = generatedU_buf[9];
		salt.setSalt_len(8);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_PDF17L8);
		digest[0] = ModernizedCProgram.byte_swap_32(generatedU_buf[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(generatedU_buf[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(generatedU_buf[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(generatedU_buf[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(generatedU_buf[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(generatedU_buf[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(generatedU_buf[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(generatedU_buf[7]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_EPISERVER;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 11;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 11;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = ((0 * 8) / 6) + 0;
		generatedLen_max[2] = ((256 * 8) / 6) + 3;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		generatedLen_min[3] = 43;
		generatedLen_max[3] = 43;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[3];
		Object generatedLen = token.getLen();
		int hash_len = generatedLen[3];
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedSep[1] = (byte)':';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 32;
		generatedSep[2] = (byte)':';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		u8 iter_pos = generatedBuf[1];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10) - 1);
		u8 salt_pos = generatedBuf[2];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 16;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_ANDROIDPIN - 1);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_1K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pbkdf2_sha1_t pbkdf2_sha1 = (pbkdf2_sha1_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(5);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PASSLIB_PBKDF2_SHA1;
		Object generatedSep = token.getSep();
		// the hash starts with a $// the hash starts with a $generatedSep[0] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 0;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[1] = (byte)'$';
		generatedLen_min[1] = 6;
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		// iterations in decimal representation// iterations in decimal representationgeneratedSep[2] = (byte)'$';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 6;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// salt in alternate base64 repretentation// salt in alternate base64 repretentationgeneratedSep[3] = (byte)'$';
		generatedLen_min[3] = 0;
		generatedLen_max[3] = 256;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		// payload in alternate base64 representanion// payload in alternate base64 representaniongeneratedSep[4] = (byte)'$';
		generatedLen_min[4] = ModernizedCProgram.HASH_LEN_B64;
		generatedLen_max[4] = ModernizedCProgram.HASH_LEN_B64;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		// iteru8 iter_pos = generatedBuf[2];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10) - 1);
		// base64 decode saltu8 salt_pos = generatedBuf[3];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[3];
		u8[] tmp_buf = new u8[]{0};
		size_t salt_len_decoded = ModernizedCProgram.base64_decode(ModernizedCProgram.ab64_to_int, (u8)salt_pos, salt_len, tmp_buf);
		Object generatedSalt_buf = pbkdf2_sha1.getSalt_buf();
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		.memcpy(salt_buf_ptr, tmp_buf, salt_len_decoded);
		.memcpy(generatedSalt_buf, salt_buf_ptr, salt_len_decoded);
		salt.setSalt_len(salt_len_decoded);
		// base64 decode hashu8 hash_pos = generatedBuf[4];
		int hash_len = generatedLen[4];
		ModernizedCProgram.base64_decode(ModernizedCProgram.ab64_to_int, (u8)hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, ModernizedCProgram.HASH_LEN_RAW);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 8;
		generatedLen_max[1] = 8;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 28;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 28;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		Object generatedLen = token.getLen();
		int hash_len = generatedLen[0];
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, 20);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = -1024;
		salt.setSalt_len(0);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		krb5pa_t krb5pa = (krb5pa_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(6);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_KRB5PA;
		Object generatedLen = token.getLen();
		generatedLen[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 64;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 64;
		generatedSep[2] = (byte)'$';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[3] = 0;
		generatedLen_max[3] = 128;
		generatedSep[3] = (byte)'$';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen[4] = 72;
		generatedAttr[4] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[5] = 32;
		generatedAttr[5] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 user_pos = generatedBuf[1];
		u8 realm_pos = generatedBuf[2];
		u8 salt_pos = generatedBuf[3];
		int user_len = generatedLen[1];
		int realm_len = generatedLen[2];
		int salt_len = generatedLen[3/**
		   * copy data
		   */];
		Object generatedUser = krb5pa.getUser();
		.memcpy(generatedUser, user_pos, user_len);
		Object generatedRealm = krb5pa.getRealm();
		.memcpy(generatedRealm, realm_pos, realm_len);
		Object generatedSalt = krb5pa.getSalt();
		.memcpy(generatedSalt, salt_pos, salt_len/**
		   * decode data
		   */);
		u8 timestamp_pos = generatedBuf[4];
		Object generatedTimestamp = krb5pa.getTimestamp();
		u8 timestamp_ptr = (u8)generatedTimestamp;
		for (int i = 0;
		 i < 72; i += 2) {
			u8 p0 = timestamp_pos[i + 0];
			u8 p1 = timestamp_pos[i + 1];
			timestamp_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		u8 checksum_pos = generatedBuf[5];
		Object generatedChecksum = krb5pa.getChecksum();
		u8 checksum_ptr = (u8)generatedChecksum;
		for (int i = 0;
		 i < 32; i += 2) {
			u8 p0 = checksum_pos[i + 0];
			u8 p1 = checksum_pos[i + 1];
			checksum_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4/**
			   * copy some data to generic buffers to make sorting happy
			   */;
		}
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedTimestamp[0];
		generatedSalt_buf[1] = generatedTimestamp[1];
		generatedSalt_buf[2] = generatedTimestamp[2];
		generatedSalt_buf[3] = generatedTimestamp[3];
		generatedSalt_buf[4] = generatedTimestamp[4];
		generatedSalt_buf[5] = generatedTimestamp[5];
		generatedSalt_buf[6] = generatedTimestamp[6];
		generatedSalt_buf[7] = generatedTimestamp[7];
		generatedSalt_buf[8] = generatedTimestamp[8];
		salt.setSalt_len(36);
		digest[0] = generatedChecksum[0];
		digest[1] = generatedChecksum[1];
		digest[2] = generatedChecksum[2];
		digest[3] = generatedChecksum[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		Object generatedLen = token.getLen();
		generatedLen[0] = 1;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		generatedLen[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		generatedLen[2] = 48;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		generatedLen[3] = 1;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		if (generatedBuf[0][0] != (byte)'(') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		if (generatedBuf[1][0] != (byte)'H') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		if (generatedBuf[3][0] != (byte)')') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		// decode
		u8 hash_pos = generatedBuf[2];
		int hash_len = generatedLen[2];
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.lotus64_to_int, hash_pos, hash_len, tmp_buf);
		// dont ask!// dont ask!tmp_buf[3] += -4// salt;// salt
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy(generatedSalt_buf, tmp_buf, 16);
		// Attention: in theory we have 2 salt_len, one for the -m 8700 part (len: 8), 2nd for the 9100 part (len: 16)// Attention: in theory we have 2 salt_len, one for the -m 8700 part (len: 8), 2nd for the 9100 part (len: 16)salt.setSalt_len(16)// iteration;// iteration
		byte[] tmp_iter_buf = new byte[]{0};
		.memcpy(tmp_iter_buf, tmp_buf + 16, 10);
		tmp_iter_buf[10] = 0;
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)tmp_iter_buf, ((Object)0), 10));
		Object generatedSalt_iter = salt.getSalt_iter();
		// well, the limit hopefully is much higherif (generatedSalt_iter < 1) {
			return (parser_rc.PARSER_SALT_ITERATION);
		} 
		// first round in init// first round in initgeneratedSalt_iter--// 2 additional bytes for display only;// 2 additional bytes for display only
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		generatedSalt_buf_pc[0] = tmp_buf[26];
		generatedSalt_buf_pc[1] = tmp_buf[27]// digest;// digest
		.memcpy(digest, tmp_buf + 28, 8);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[8] = ModernizedCProgram.hex_to_u32(hash_pos + 64);
		digest[9] = ModernizedCProgram.hex_to_u32(hash_pos + 72);
		digest[10] = ModernizedCProgram.hex_to_u32(hash_pos + 80);
		digest[11] = ModernizedCProgram.hex_to_u32(hash_pos + 88);
		digest[12] = ModernizedCProgram.hex_to_u32(hash_pos + 96);
		digest[13] = ModernizedCProgram.hex_to_u32(hash_pos + 104);
		digest[14] = ModernizedCProgram.hex_to_u32(hash_pos + 112);
		digest[15] = ModernizedCProgram.hex_to_u32(hash_pos + 120);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		oldoffice34_t oldoffice34 = (oldoffice34_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(5);
		token.setSignatures_cnt(2);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_OLDOFFICE3;
		generatedSignatures_buf[1] = ModernizedCProgram.SIGNATURE_OLDOFFICE4;
		Object generatedLen = token.getLen();
		generatedLen[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 32;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[4] = 40;
		generatedLen_max[4] = 40;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 osalt_pos = generatedBuf[2];
		u8 encryptedVerifier_pos = generatedBuf[3];
		u8 encryptedVerifierHash_pos = generatedBuf[4];
		// esalt
		u32 version = version_pos - -1024;
		if (version != 3 && version != 4) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		oldoffice34.setVersion(version);
		Object generatedEncryptedVerifier = oldoffice34.getEncryptedVerifier();
		generatedEncryptedVerifier[0] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 0);
		generatedEncryptedVerifier[1] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 8);
		generatedEncryptedVerifier[2] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 16);
		generatedEncryptedVerifier[3] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 24);
		Object generatedEncryptedVerifierHash = oldoffice34.getEncryptedVerifierHash();
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 0);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 8);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 16);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 24);
		generatedEncryptedVerifierHash[4] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 32)// salt;// salt
		salt.setSalt_len(16);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(osalt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(osalt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(osalt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(osalt_pos + 24);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3])// this is a workaround as office produces multiple documents with the same salt;// this is a workaround as office produces multiple documents with the same salt
		generatedSalt_buf[4] = generatedEncryptedVerifier[0];
		generatedSalt_buf[5] = generatedEncryptedVerifier[1];
		generatedSalt_buf[6] = generatedEncryptedVerifier[2];
		generatedSalt_buf[7] = generatedEncryptedVerifier[3];
		generatedSalt_buf[8] = generatedEncryptedVerifierHash[0];
		generatedSalt_buf[9] = generatedEncryptedVerifierHash[1];
		generatedSalt_buf[10] = generatedEncryptedVerifierHash[2];
		generatedSalt_buf[11] = generatedEncryptedVerifierHash[3];
		Object generatedSalt_len = salt.getSalt_len();
		generatedSalt_len += 32/**
		   * digest
		   */;
		digest[0] = generatedEncryptedVerifierHash[0];
		digest[1] = generatedEncryptedVerifierHash[1];
		digest[2] = generatedEncryptedVerifierHash[2];
		digest[3] = generatedEncryptedVerifierHash[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		win8phone_t esalt = (win8phone_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 256;
		generatedLen_max[1] = 256;
		generatedSep[1] = hashconfig.getSeparator();
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// hash
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7])// salt;// salt
		u8 salt_pos = generatedBuf[1];
		Object generatedSalt_buf = esalt.getSalt_buf();
		u32 salt_buf = generatedSalt_buf;
		for (int i = 0;
		int j = 0;
		 i < 32; ) {
			salt_buf[i] = ModernizedCProgram.hex_to_u32(salt_pos + j);
			salt_buf[i] = ModernizedCProgram.byte_swap_32(salt_buf[i]);
		}
		generatedSalt_buf[0] = salt_buf[0];
		generatedSalt_buf[1] = salt_buf[1];
		generatedSalt_buf[2] = salt_buf[2];
		generatedSalt_buf[3] = salt_buf[3];
		generatedSalt_buf[4] = salt_buf[4];
		generatedSalt_buf[5] = salt_buf[5];
		generatedSalt_buf[6] = salt_buf[6];
		generatedSalt_buf[7] = salt_buf[7];
		salt.setSalt_len(32);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		krb5tgs_17_t krb5tgs = (krb5tgs_17_t)esalt_buf;
		token_t token = new token_t();
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_KRB5TGS;
		Object generatedLen = token.getLen();
		generatedLen[0] = 12;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE/**
		   * $krb5tgs$17$*user*realm*$checksum$edata2
		   * $krb5tgs$17$*user*realm*spn*$checksum$edata2
		   */;
		// assume no signature foundif (line_len < 12) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		byte spn_info_start = .strchr((byte)line_buf + 12 + 1, (byte)'*');
		int is_spn_provided = 0;
		Object generatedSep = token.getSep();
		Object generatedLen_min = token.getLen_min();
		Object generatedLen_max = token.getLen_max();
		// assume $krb5tgs$17$user$realm$checksum$edata2if (spn_info_start == ((Object)0)) {
			token.setToken_cnt(5);
			generatedSep[1] = (byte)'$';
			generatedLen_min[1] = 1;
			generatedLen_max[1] = 512;
			generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
			generatedSep[2] = (byte)'$';
			generatedLen_min[2] = 1;
			generatedLen_max[2] = 512;
			generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
			generatedSep[3] = (byte)'$';
			generatedLen_min[3] = 24;
			generatedLen_max[3] = 24;
			generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[4] = (byte)'$';
			generatedLen_min[4] = 64;
			generatedLen_max[4] = 40960;
			generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		} else {
				byte spn_info_stop = .strchr((byte)spn_info_start + 1, (byte)'*');
				if (spn_info_stop == ((Object)0)) {
					return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
				} 
				spn_info_stop++;
				spn_info_stop++;
				int spn_info_len = spn_info_stop - spn_info_start;
				token.setToken_cnt(6);
				generatedSep[1] = (byte)'$';
				generatedLen_min[1] = 1;
				generatedLen_max[1] = 512;
				generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
				generatedSep[2] = (byte)'$';
				generatedLen_min[2] = 1;
				generatedLen_max[2] = 512;
				generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
				generatedLen[3] = spn_info_len;
				generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
				generatedSep[4] = (byte)'$';
				generatedLen_min[4] = 24;
				generatedLen_max[4] = 24;
				generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
				generatedSep[5] = (byte)'$';
				generatedLen_min[5] = 64;
				generatedLen_max[5] = 40960;
				generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
				is_spn_provided = 1;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		u8 user_pos = new u8();
		u8 domain_pos = new u8();
		u8 checksum_pos = new u8();
		u8 data_pos = new u8();
		int user_len;
		int domain_len;
		int data_len;
		int account_info_len;
		Object generatedBuf = token.getBuf();
		user_pos = generatedBuf[1];
		user_len = generatedLen[1];
		Object generatedUser = krb5tgs.getUser();
		.memcpy(generatedUser, user_pos, user_len);
		domain_pos = generatedBuf[2];
		domain_len = generatedLen[2];
		Object generatedDomain = krb5tgs.getDomain();
		.memcpy(generatedDomain, domain_pos, domain_len);
		checksum_pos = generatedBuf[3 + is_spn_provided];
		data_pos = generatedBuf[4 + is_spn_provided];
		data_len = generatedLen[4 + is_spn_provided];
		account_info_len = generatedLen[2] + generatedLen[1];
		Object generatedAccount_info = krb5tgs.getAccount_info();
		u8 account_info_ptr = (u8)generatedAccount_info;
		// domain must be uppercaseu8[] domain = new u8();
		.memcpy(domain, domain_pos, domain_len);
		ModernizedCProgram.uppercase(domain, domain_len);
		.memcpy(account_info_ptr, domain, domain_len);
		.memcpy(account_info_ptr + domain_len, user_pos, user_len);
		krb5tgs.setAccount_info_len(account_info_len);
		Object generatedChecksum = krb5tgs.getChecksum();
		// hmac-sha1 is reduced to 12 bytes// hmac-sha1 is reduced to 12 bytesgeneratedChecksum[0] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 0));
		generatedChecksum[1] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 8));
		generatedChecksum[2] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 16));
		Object generatedEdata2 = krb5tgs.getEdata2();
		u8 edata_ptr = (u8)generatedEdata2;
		for (int i = 0;
		 i < data_len; i += 2) {
			u8 p0 = data_pos[i + 0];
			u8 p1 = data_pos[i + 1];
			edata_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		krb5tgs.setEdata2_len(data_len / 2);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedChecksum[0];
		generatedSalt_buf[1] = generatedChecksum[1];
		generatedSalt_buf[2] = generatedChecksum[2];
		salt.setSalt_iter(4096 - 1);
		digest[0] = generatedChecksum[0];
		digest[1] = generatedChecksum[1];
		digest[2] = generatedChecksum[2];
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[8] = ModernizedCProgram.hex_to_u32(hash_pos + 64);
		digest[9] = ModernizedCProgram.hex_to_u32(hash_pos + 72);
		digest[10] = ModernizedCProgram.hex_to_u32(hash_pos + 80);
		digest[11] = ModernizedCProgram.hex_to_u32(hash_pos + 88);
		digest[12] = ModernizedCProgram.hex_to_u32(hash_pos + 96);
		digest[13] = ModernizedCProgram.hex_to_u32(hash_pos + 104);
		digest[14] = ModernizedCProgram.hex_to_u32(hash_pos + 112);
		digest[15] = ModernizedCProgram.hex_to_u32(hash_pos + 120);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		ethereum_pbkdf2_t ethereum_pbkdf2 = (ethereum_pbkdf2_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(5);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ETHEREUM_PBKDF2;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 11;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)'*';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 64;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 64;
		generatedLen_max[3] = 64;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[4] = (byte)'*';
		generatedLen_min[4] = 64;
		generatedLen_max[4] = 64;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		if (iter < 1) {
			return (parser_rc.PARSER_SALT_ITERATION);
		} 
		salt.setSalt_iter(iter - 1)// salt;// salt
		u8 salt_pos = generatedBuf[2];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[2];
		if ((salt_len != 32) && (salt_len != 64)) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		generatedSalt_buf[4] = generatedSalt_buf[4];
		generatedSalt_buf[5] = generatedSalt_buf[5];
		generatedSalt_buf[6] = generatedSalt_buf[6];
		generatedSalt_buf[7] = generatedSalt_buf[7]// ciphertext;// ciphertext
		u8 ciphertext_pos = generatedBuf[3];
		Object generatedCiphertext = ethereum_pbkdf2.getCiphertext();
		generatedCiphertext[0] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[0]);
		generatedCiphertext[1] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[8]);
		generatedCiphertext[2] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[16]);
		generatedCiphertext[3] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[24]);
		generatedCiphertext[4] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[32]);
		generatedCiphertext[5] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[40]);
		generatedCiphertext[6] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[48]);
		generatedCiphertext[7] = ModernizedCProgram.hex_to_u32((u8)ciphertext_pos[56])// hash;// hash
		u8 hash_pos = generatedBuf[4];
		digest[0] = ModernizedCProgram.hex_to_u32((u8)hash_pos[0]);
		digest[1] = ModernizedCProgram.hex_to_u32((u8)hash_pos[8]);
		digest[2] = ModernizedCProgram.hex_to_u32((u8)hash_pos[16]);
		digest[3] = ModernizedCProgram.hex_to_u32((u8)hash_pos[24]);
		digest[4] = ModernizedCProgram.hex_to_u32((u8)hash_pos[32]);
		digest[5] = ModernizedCProgram.hex_to_u32((u8)hash_pos[40]);
		digest[6] = ModernizedCProgram.hex_to_u32((u8)hash_pos[48]);
		digest[7] = ModernizedCProgram.hex_to_u32((u8)hash_pos[56]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MSSQL;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen[1] = 8;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[2] = 40;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[3] = 40;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[3];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		pbkdf2_sha512_t pbkdf2_sha512 = (pbkdf2_sha512_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SHA512MACOS;
		Object generatedLen = token.getLen();
		generatedLen[0] = 4;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 6;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 64;
		generatedLen_max[2] = 64;
		generatedSep[2] = (byte)'$';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[3] = 128;
		generatedLen_max[3] = 128;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[3];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2] / 2;
		Object generatedSalt_buf = pbkdf2_sha512.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(salt_pos + 24);
		generatedSalt_buf[4] = ModernizedCProgram.hex_to_u32(salt_pos + 32);
		generatedSalt_buf[5] = ModernizedCProgram.hex_to_u32(salt_pos + 40);
		generatedSalt_buf[6] = ModernizedCProgram.hex_to_u32(salt_pos + 48);
		generatedSalt_buf[7] = ModernizedCProgram.hex_to_u32(salt_pos + 56);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		generatedSalt_buf[4] = generatedSalt_buf[4];
		generatedSalt_buf[5] = generatedSalt_buf[5];
		generatedSalt_buf[6] = generatedSalt_buf[6];
		generatedSalt_buf[7] = generatedSalt_buf[7];
		salt.setSalt_len(salt_len);
		u8 iter_pos = generatedBuf[1];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10) - 1);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_1K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen = token.getLen();
		generatedLen[0] = 2;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		generatedLen[1] = 11;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[0];
		u8 hash_pos = generatedBuf[1];
		int hash_len = generatedLen[1];
		u8 c10 = ModernizedCProgram.itoa64_to_int(hash_pos[10]);
		if (c10 & 3) {
			return (parser_rc.PARSER_HASH_VALUE);
		} 
		Object generatedSalt_sign = salt.getSalt_sign();
		// for ascii_to_ebcdic_digest// for ascii_to_ebcdic_digestgeneratedSalt_sign[0] = salt_pos[0];
		generatedSalt_sign[1] = salt_pos[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.itoa64_to_int(salt_pos[0]) | ModernizedCProgram.itoa64_to_int(salt_pos[1]) << 6;
		// doesn't eliminate salts that are identical but have different salt signs// doesn't eliminate salts that are identical but have different salt signsgeneratedSalt_buf[0] |=  salt_pos[0] << 16 | salt_pos[1] << 24;
		// actually it is only 2 (but we need to add the original salt_sign to it)// actually it is only 2 (but we need to add the original salt_sign to it)salt.setSalt_len(4);
		u32[] tmp = new u32[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.itoa64_to_int, hash_pos, hash_len, (u8)tmp);
		digest[0] = tmp[0];
		digest[1] = tmp[1];
		digest[2] = 0;
		digest[3] = 0;
		{ 
			{ 
				u32x t = new u32x();
				t = digest[1] >> 4;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 4;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 16;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 16;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 2;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 2;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 8;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 8;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 1;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 1;
				digest[1] = digest[1] ^ t;
			}
			;
		}
		;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 32;
		generatedLen_max[1] = 32;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		seven_zip_hook_salt_t seven_zip = (seven_zip_hook_salt_t)hook_salt_buf;
		token_t token = new token_t();
		token.setToken_cnt(11);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SEVEN_ZIP;
		Object generatedLen = token.getLen();
		generatedLen[0] = 4;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 2;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 1;
		generatedLen_max[3] = 1;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[4] = (byte)'$';
		generatedLen_min[4] = 0;
		generatedLen_max[4] = 64;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[5] = (byte)'$';
		generatedLen_min[5] = 1;
		generatedLen_max[5] = 2;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[6] = (byte)'$';
		generatedLen_min[6] = 32;
		generatedLen_max[6] = 32;
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[7] = (byte)'$';
		generatedLen_min[7] = 1;
		generatedLen_max[7] = 10;
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[8] = (byte)'$';
		generatedLen_min[8] = 1;
		generatedLen_max[8] = 6;
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[9] = (byte)'$';
		generatedLen_min[9] = 1;
		generatedLen_max[9] = 6;
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[10] = (byte)'$';
		generatedLen_min[10] = 2;
		generatedLen_max[10] = 655056;
		generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 data_type_pos = generatedBuf[1];
		u8 NumCyclesPower_pos = generatedBuf[2];
		u8 salt_len_pos = generatedBuf[3];
		u8 salt_buf_pos = generatedBuf[4];
		u8 iv_len_pos = generatedBuf[5];
		u8 iv_buf_pos = generatedBuf[6];
		u8 crc_buf_pos = generatedBuf[7];
		u8 data_len_pos = generatedBuf[8];
		u8 unpack_size_pos = generatedBuf[9];
		u8 data_buf_pos = generatedBuf[10];
		int data_type_len = generatedLen[1];
		int NumCyclesPower_len = generatedLen[2];
		int salt_len_len = generatedLen[3];
		int salt_buf_len = generatedLen[4];
		int iv_len_len = generatedLen[5];
		int iv_buf_len = generatedLen[6];
		int crc_buf_len = generatedLen[7];
		int data_len_len = generatedLen[8];
		int unpack_size_len = generatedLen[9];
		int data_buf_len = generatedLen[10];
		// fields only used when data was compressed:
		u8 crc_len_pos = (u8).strchr((byte)data_buf_pos, (byte)'$');
		u32 crc_len_len = 0;
		u8 coder_attributes_pos = 0;
		u32 coder_attributes_len = 0;
		if (crc_len_pos != ((Object)0)) {
			data_buf_len = crc_len_pos - data_buf_pos;
			crc_len_pos++;
			coder_attributes_pos = (u8).strchr((byte)crc_len_pos, (byte)'$');
			if (coder_attributes_pos == ((Object)0)) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
			crc_len_len = coder_attributes_pos - crc_len_pos;
			coder_attributes_pos++;
		} 
		if (ModernizedCProgram.is_valid_hex_string(data_buf_pos, data_buf_len) == 0) {
			return (parser_rc.PARSER_SALT_ENCODING);
		} 
		int iter = ModernizedCProgram.hc_strtoul((byte)NumCyclesPower_pos, ((Object)0), 10);
		int crc = ModernizedCProgram.hc_strtoul((byte)crc_buf_pos, ((Object)0), 10);
		int data_type = ModernizedCProgram.hc_strtoul((byte)data_type_pos, ((Object)0), 10);
		int salt_len = ModernizedCProgram.hc_strtoul((byte)salt_len_pos, ((Object)0), 10);
		int iv_len = ModernizedCProgram.hc_strtoul((byte)iv_len_pos, ((Object)0), 10);
		int unpack_size = ModernizedCProgram.hc_strtoul((byte)unpack_size_pos, ((Object)0), 10);
		int data_len = ModernizedCProgram.hc_strtoul((byte)data_len_pos, ((Object)0), 10);
		// if neither uncompressed nor truncated, then we need the length for crc and coder attributes
		int crc_len = 0;
		boolean is_compressed = ((data_type != 0) && (data_type != -1024));
		if (is_compressed == true) {
			if (crc_len_pos == ((Object)0)) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
			coder_attributes_len = line_len - 1 - 2 - 1 - data_type_len - 1 - NumCyclesPower_len - 1 - salt_len_len - 1 - salt_buf_len - 1 - iv_len_len - 1 - iv_buf_len - 1 - crc_buf_len - 1 - data_len_len - 1 - unpack_size_len - 1 - data_buf_len - 1 - crc_len_len - 1;
			crc_len = ModernizedCProgram.hc_strtoul((byte)crc_len_pos, ((Object)0), 10/**
			   * verify some data
			   */);
		} 
		// this check also returns an error with data_type == 0x80 (special case that means "truncated")if ((data_type != 0) && (data_type != 1) && (data_type != 2) && (data_type != 7)) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (salt_len != 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if ((data_len * 2) != data_buf_len) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (data_len > 327528) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (unpack_size > data_len) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (is_compressed == true) {
			if (crc_len_len > 7) {
				return (parser_rc.PARSER_SALT_VALUE);
			} 
			if (coder_attributes_len > 10) {
				return (parser_rc.PARSER_SALT_VALUE);
			} 
			if ((coder_attributes_len % 2) != 0) {
				return (parser_rc.PARSER_SALT_VALUE);
			} 
			if (data_type == 1) {
				if ((coder_attributes_len / 2) != 5) {
					return (parser_rc.PARSER_SALT_VALUE);
				} 
			}  else if (data_type == 2) {
				if ((coder_attributes_len / 2) != 1) {
					return (parser_rc.PARSER_SALT_VALUE);
				} 
			} 
		} 
		seven_zip.setData_type(/**
		   * store data
		   */data_type);
		Object generatedIv_buf = seven_zip.getIv_buf();
		generatedIv_buf[0] = ModernizedCProgram.hex_to_u32(iv_buf_pos + 0);
		generatedIv_buf[1] = ModernizedCProgram.hex_to_u32(iv_buf_pos + 8);
		generatedIv_buf[2] = ModernizedCProgram.hex_to_u32(iv_buf_pos + 16);
		generatedIv_buf[3] = ModernizedCProgram.hex_to_u32(iv_buf_pos + 24);
		seven_zip.setIv_len(iv_len);
		Object generatedSalt_buf = seven_zip.getSalt_buf();
		// we just need that for later ascii_digest()// we just need that for later ascii_digest().memcpy(generatedSalt_buf, salt_buf_pos, salt_buf_len);
		seven_zip.setSalt_len(0);
		seven_zip.setCrc(crc);
		Object generatedData_buf = seven_zip.getData_buf();
		for (int i = 0;
		int j = 0;
		 j < data_buf_len; ) {
			generatedData_buf[i] = ModernizedCProgram.hex_to_u32(data_buf_pos + j);
		}
		seven_zip.setData_len(data_len);
		seven_zip.setUnpack_size(unpack_size);
		seven_zip.setCrc_len(crc_len);
		Object generatedCoder_attributes = seven_zip.getCoder_attributes();
		.memset(generatedCoder_attributes, 0, );
		seven_zip.setCoder_attributes_len(0);
		Object generatedCoder_attributes_len = seven_zip.getCoder_attributes_len();
		if (is_compressed == true) {
			if (ModernizedCProgram.is_valid_hex_string(coder_attributes_pos, coder_attributes_len) == 0) {
				return (parser_rc.PARSER_SALT_ENCODING);
			} 
			for (u32 i = 0;
			u32 j = 0;
			 j < coder_attributes_len; ) {
				generatedCoder_attributes[i] = ModernizedCProgram.hex_to_u8((u8)coder_attributes_pos[j]);
				generatedCoder_attributes_len++;
			}
		} 
		// normally: crc_len <= unpacksize <= packsize (== data_len)int aes_len = data_len;
		// it is 0 only in case of uncompressed data or truncated dataif (crc_len != 0) {
			if (data_type == 1) {
				aes_len = 32.5 + (double)crc_len * 1.05;
			}  else if (data_type == 2) {
				aes_len = 4.5 + (double)crc_len * 1.01;
			} 
			aes_len = (((aes_len) < (data_len)) ? (aes_len) : (data_len));
		} 
		// in theory we could just use crc_len, but sometimes (very rare) the compressed data// is larger than the original data! (because of some additional bytes from lzma/headers)
		seven_zip.setAes_len(aes_len)// real salt;// real salt
		generatedSalt_buf[0] = generatedData_buf[0];
		generatedSalt_buf[1] = generatedData_buf[1];
		generatedSalt_buf[2] = generatedData_buf[2];
		generatedSalt_buf[3] = generatedData_buf[3];
		salt.setSalt_len(16);
		Object generatedSalt_sign = salt.getSalt_sign();
		generatedSalt_sign[0] = data_type;
		salt.setSalt_iter(-1024 << iter/**
		   * digest
		   */);
		digest[0] = crc;
		digest[1] = 0;
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		odf12_t odf12 = (odf12_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(12);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ODF;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 5;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 5;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 1;
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 4;
		generatedLen_max[3] = 6;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 2;
		generatedLen_max[4] = 2;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[5] = 64;
		generatedLen_max[5] = 64;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[6] = 2;
		generatedLen_max[6] = 2;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[7] = 32;
		generatedLen_max[7] = 32;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[8] = 2;
		generatedLen_max[8] = 2;
		generatedSep[8] = (byte)'*';
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[9] = 32;
		generatedLen_max[9] = 32;
		generatedSep[9] = (byte)'*';
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[10] = 1;
		generatedLen_max[10] = 1;
		generatedSep[10] = (byte)'*';
		generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		Object generatedLen = token.getLen();
		generatedLen[11] = 2048;
		generatedAttr[11] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 checksum = generatedBuf[5];
		u8 iv = generatedBuf[7];
		u8 salt_buf = generatedBuf[9];
		u8 encrypted_data = generatedBuf[11];
		u32 cipher_type = .strtol((byte)generatedBuf[1], ((Object)0), 10);
		u32 checksum_type = .strtol((byte)generatedBuf[2], ((Object)0), 10);
		u32 iterations = .strtol((byte)generatedBuf[3], ((Object)0), 10);
		u32 key_size = .strtol((byte)generatedBuf[4], ((Object)0), 10);
		u32 iv_len = .strtol((byte)generatedBuf[6], ((Object)0), 10);
		u32 salt_len = .strtol((byte)generatedBuf[8], ((Object)0), 10);
		u32 unused = .strtol((byte)generatedBuf[10], ((Object)0), 10);
		if (cipher_type != 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (checksum_type != 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (key_size != 32) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (iv_len != 16) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (salt_len != 16) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (unused != 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		// esalt
		odf12.setIterations(iterations);
		Object generatedChecksum = odf12.getChecksum();
		generatedChecksum[0] = ModernizedCProgram.hex_to_u32(checksum[0]);
		generatedChecksum[1] = ModernizedCProgram.hex_to_u32(checksum[8]);
		generatedChecksum[2] = ModernizedCProgram.hex_to_u32(checksum[16]);
		generatedChecksum[3] = ModernizedCProgram.hex_to_u32(checksum[24]);
		generatedChecksum[4] = ModernizedCProgram.hex_to_u32(checksum[32]);
		generatedChecksum[5] = ModernizedCProgram.hex_to_u32(checksum[40]);
		generatedChecksum[6] = ModernizedCProgram.hex_to_u32(checksum[48]);
		generatedChecksum[7] = ModernizedCProgram.hex_to_u32(checksum[56]);
		Object generatedIv = odf12.getIv();
		generatedIv[0] = ModernizedCProgram.hex_to_u32(iv[0]);
		generatedIv[1] = ModernizedCProgram.hex_to_u32(iv[8]);
		generatedIv[2] = ModernizedCProgram.hex_to_u32(iv[16]);
		generatedIv[3] = ModernizedCProgram.hex_to_u32(iv[24]);
		Object generatedEncrypted_data = odf12.getEncrypted_data();
		for (int i = 0;
		int j = 0;
		 i < 256; ) {
			generatedEncrypted_data[i] = ModernizedCProgram.hex_to_u32(encrypted_data[j]);
		}
		// salt// saltsalt.setSalt_len(salt_len);
		salt.setSalt_iter(iterations - 1);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_buf[8]);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt_buf[16]);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(salt_buf[24/**
		   * digest
		   */]);
		digest[0] = generatedChecksum[0];
		digest[1] = generatedChecksum[1];
		digest[2] = generatedChecksum[2];
		digest[3] = generatedChecksum[3];
		digest[4] = generatedChecksum[4];
		digest[5] = generatedChecksum[5];
		digest[6] = generatedChecksum[6];
		digest[7] = generatedChecksum[7];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_NETBSD_SHA1CRYPT;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 8;
		generatedLen_max[2] = 8;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 28;
		generatedLen_max[3] = 28;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		// (actually: CRYPT_SHA1_ITERATIONS should be 24680 or more)if (iter < 99) {
			return (parser_rc.PARSER_SALT_ITERATION);
		} 
		salt.setSalt_iter(iter - 1)// salt;// salt
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy((u8)generatedSalt_buf, salt_pos, salt_len);
		salt.setSalt_len(salt_len)// hash;// hash
		u8 hash_pos = generatedBuf[3];
		Object generatedSalt_sign = salt.getSalt_sign();
		ModernizedCProgram.netbsd_sha1crypt_decode((u8)digest, hash_pos, (u8)generatedSalt_sign);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4])// precompute salt;// precompute salt
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		byte ptr = (byte)generatedSalt_buf_pc;
		int salt_len_pc = .snprintf(ptr, 64, "%s$sha1$%u", (byte)generatedSalt_buf, iter);
		ptr[salt_len_pc] = -1024;
		salt.setSalt_len_pc(salt_len_pc);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		oldoffice01_t oldoffice01 = (oldoffice01_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(5);
		token.setSignatures_cnt(2);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_OLDOFFICE0;
		generatedSignatures_buf[1] = ModernizedCProgram.SIGNATURE_OLDOFFICE1;
		Object generatedLen = token.getLen();
		generatedLen[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 32;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[4] = 32;
		generatedLen_max[4] = 32;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 osalt_pos = generatedBuf[2];
		u8 encryptedVerifier_pos = generatedBuf[3];
		u8 encryptedVerifierHash_pos = generatedBuf[4];
		// esalt
		u32 version = version_pos - -1024;
		if (version != 0 && version != 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		oldoffice01.setVersion(version);
		Object generatedEncryptedVerifier = oldoffice01.getEncryptedVerifier();
		generatedEncryptedVerifier[0] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 0);
		generatedEncryptedVerifier[1] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 8);
		generatedEncryptedVerifier[2] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 16);
		generatedEncryptedVerifier[3] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 24);
		Object generatedEncryptedVerifierHash = oldoffice01.getEncryptedVerifierHash();
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 0);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 8);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 16);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 24)// salt;// salt
		salt.setSalt_len(16);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(osalt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(osalt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(osalt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(osalt_pos + 24)// this is a workaround as office produces multiple documents with the same salt;// this is a workaround as office produces multiple documents with the same salt
		generatedSalt_buf[4] = generatedEncryptedVerifier[0];
		generatedSalt_buf[5] = generatedEncryptedVerifier[1];
		generatedSalt_buf[6] = generatedEncryptedVerifier[2];
		generatedSalt_buf[7] = generatedEncryptedVerifier[3];
		generatedSalt_buf[8] = generatedEncryptedVerifierHash[0];
		generatedSalt_buf[9] = generatedEncryptedVerifierHash[1];
		generatedSalt_buf[10] = generatedEncryptedVerifierHash[2];
		generatedSalt_buf[11] = generatedEncryptedVerifierHash[3];
		Object generatedSalt_len = salt.getSalt_len();
		generatedSalt_len += 32/**
		   * digest
		   */;
		digest[0] = generatedEncryptedVerifierHash[0];
		digest[1] = generatedEncryptedVerifierHash[1];
		digest[2] = generatedEncryptedVerifierHash[2];
		digest[3] = generatedEncryptedVerifierHash[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 104;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 104;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iv + hashu8[] decrypted = new u8[]{0};
		Object generatedBuf = token.getBuf();
		Object generatedLen = token.getLen();
		ModernizedCProgram.juniper_decrypt_hash(generatedBuf[0], generatedLen[0], decrypted)// from here we are parsing a normal md5crypt hash;// from here we are parsing a normal md5crypt hash
		u8 md5crypt_hash = decrypted + 12;
		token_t token2 = new token_t();
		token2.setToken_cnt(3);
		token2.setSignatures_cnt(1);
		Object generatedSignatures_buf = token2.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MD5CRYPT;
		generatedLen[0] = 3;
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 8;
		generatedLen_max[1] = 8;
		Object generatedSep = token2.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen[2] = 22;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer2 = token2.input_tokenizer(md5crypt_hash, 34);
		if (rc_tokenizer2 != parser_rc.PARSER_OK) {
			return (rc_tokenizer2);
		} 
		byte danastre = "danastre";
		if (.memcmp(generatedBuf[1], danastre, 8) != 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_MD5CRYPT);
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 hash_pos = generatedBuf[2];
		ModernizedCProgram.md5crypt_decode((u8)digest, hash_pos);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 43;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		int hash_len = generatedLen[0];
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.itoa64_to_int, (u8)hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen = token.getLen();
		generatedLen[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[1] = 32;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[8] = ModernizedCProgram.hex_to_u32(hash_pos + 64);
		digest[9] = ModernizedCProgram.hex_to_u32(hash_pos + 72);
		digest[10] = ModernizedCProgram.hex_to_u32(hash_pos + 80);
		digest[11] = ModernizedCProgram.hex_to_u32(hash_pos + 88);
		digest[12] = ModernizedCProgram.hex_to_u32(hash_pos + 96);
		digest[13] = ModernizedCProgram.hex_to_u32(hash_pos + 104);
		digest[14] = ModernizedCProgram.hex_to_u32(hash_pos + 112);
		digest[15] = ModernizedCProgram.hex_to_u32(hash_pos + 120);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		digest[8] = ModernizedCProgram.byte_swap_32(digest[8]);
		digest[9] = ModernizedCProgram.byte_swap_32(digest[9]);
		digest[10] = ModernizedCProgram.byte_swap_32(digest[10]);
		digest[11] = ModernizedCProgram.byte_swap_32(digest[11]);
		digest[12] = ModernizedCProgram.byte_swap_32(digest[12]);
		digest[13] = ModernizedCProgram.byte_swap_32(digest[13]);
		digest[14] = ModernizedCProgram.byte_swap_32(digest[14]);
		digest[15] = ModernizedCProgram.byte_swap_32(digest[15]);
		u8 salt_pos = generatedBuf[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(salt_pos + 24);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3]);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_ORACLET - 1);
		salt.setSalt_len(16);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tacacs_plus_t tacacs_plus = (tacacs_plus_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_TACACS_PLUS;
		Object generatedLen = token.getLen();
		generatedLen[0] = 15;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 8;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 8;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 12;
		generatedLen_max[2] = 256;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 4;
		generatedLen_max[3] = 4;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// session
		Object generatedBuf = token.getBuf();
		u8 session_pos = generatedBuf[1];
		Object generatedSession_buf = tacacs_plus.getSession_buf();
		u8 session_ptr = (u8)generatedSession_buf;
		session_ptr[0] = ModernizedCProgram.hex_to_u8((u8)session_pos + 0);
		session_ptr[1] = ModernizedCProgram.hex_to_u8((u8)session_pos + 2);
		session_ptr[2] = ModernizedCProgram.hex_to_u8((u8)session_pos + 4);
		session_ptr[3] = ModernizedCProgram.hex_to_u8((u8)session_pos + 6)// ct_buf;// ct_buf
		u8 ct_buf_pos = generatedBuf[2];
		int ct_buf_len = generatedLen[2];
		Object generatedCt_data_buf = tacacs_plus.getCt_data_buf();
		u8 ct_data_ptr = (u8)generatedCt_data_buf;
		Object generatedCt_data_len = tacacs_plus.getCt_data_len();
		for (int i = 0;
		int j = 0;
		 j < ct_buf_len; ) {
			ct_data_ptr[i] = ModernizedCProgram.hex_to_u8((u8)ct_buf_pos[j]);
			generatedCt_data_len++;
		}
		// sequenceu8 sequence_pos = generatedBuf[3];
		Object generatedSequence_buf = tacacs_plus.getSequence_buf();
		u8 sequence_ptr = (u8)generatedSequence_buf;
		sequence_ptr[0] = ModernizedCProgram.hex_to_u8((u8)sequence_pos + 0);
		sequence_ptr[1] = ModernizedCProgram.hex_to_u8((u8)sequence_pos + 2)// fake salt;// fake salt
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedSession_buf[0];
		generatedSalt_buf[1] = generatedSequence_buf[0];
		generatedSalt_buf[2] = generatedCt_data_buf[0];
		generatedSalt_buf[3] = generatedCt_data_buf[1];
		salt.setSalt_len(16)// fake hash;// fake hash
		digest[0] = generatedCt_data_buf[2];
		digest[1] = generatedCt_data_buf[3];
		digest[2] = generatedCt_data_buf[4];
		digest[3] = generatedCt_data_buf[5];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		office2007_t office2007 = (office2007_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(8);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_OFFICE2007;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 8;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 8;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 4;
		generatedLen_max[1] = 4;
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 2;
		generatedLen_max[2] = 2;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 3;
		generatedLen_max[3] = 3;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 2;
		generatedLen_max[4] = 2;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[5] = 32;
		generatedLen_max[5] = 32;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[6] = 32;
		generatedLen_max[6] = 32;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[7] = 40;
		generatedLen_max[7] = 40;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 verifierHashSize_pos = generatedBuf[2];
		u8 keySize_pos = generatedBuf[3];
		u8 saltSize_pos = generatedBuf[4];
		u8 osalt_pos = generatedBuf[5];
		u8 encryptedVerifier_pos = generatedBuf[6];
		u8 encryptedVerifierHash_pos = generatedBuf[7];
		u32 version = ModernizedCProgram.hc_strtoul((byte)version_pos, ((Object)0), 10);
		u32 verifierHashSize = ModernizedCProgram.hc_strtoul((byte)verifierHashSize_pos, ((Object)0), 10);
		u32 keySize = ModernizedCProgram.hc_strtoul((byte)keySize_pos, ((Object)0), 10);
		u32 saltSize = ModernizedCProgram.hc_strtoul((byte)saltSize_pos, ((Object)0), 10);
		if (version != 2007) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (verifierHashSize != 20) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (saltSize != 16) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if ((keySize != 128) && (keySize != 256)) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		office2007.setKeySize(keySize/**
		   * salt
		   */);
		salt.setSalt_len(16);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_OFFICE2007);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(osalt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(osalt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(osalt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(osalt_pos + 24);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3/**
		   * esalt
		   */]);
		Object generatedEncryptedVerifier = office2007.getEncryptedVerifier();
		generatedEncryptedVerifier[0] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 0);
		generatedEncryptedVerifier[1] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 8);
		generatedEncryptedVerifier[2] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 16);
		generatedEncryptedVerifier[3] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 24);
		generatedEncryptedVerifier[0] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[0]);
		generatedEncryptedVerifier[1] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[1]);
		generatedEncryptedVerifier[2] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[2]);
		generatedEncryptedVerifier[3] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[3]);
		Object generatedEncryptedVerifierHash = office2007.getEncryptedVerifierHash();
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 0);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 8);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 16);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 24);
		generatedEncryptedVerifierHash[4] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 32);
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[0]);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[1]);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[2]);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[3]);
		generatedEncryptedVerifierHash[4] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[4/**
		   * digest
		   */]);
		digest[0] = generatedEncryptedVerifierHash[0];
		digest[1] = generatedEncryptedVerifierHash[1];
		digest[2] = generatedEncryptedVerifierHash[2];
		digest[3] = generatedEncryptedVerifierHash[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_FORTIGATE;
		Object generatedLen = token.getLen();
		generatedLen[0] = 3;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen[1] = 44;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer/**
			   * verify data
			   */);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[1];
		int hash_len = generatedLen[1];
		// decode salt + SHA1 hash (12 + 20 = 32)
		u8[] tmp_buf = new u8[]{0};
		int decoded_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hash_pos, hash_len, tmp_buf);
		if (decoded_len != 32) {
			return (parser_rc.PARSER_HASH_LENGTH/**
			   * store data
			   */);
		} 
		// saltu32 salt_len = 12;
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy(generatedSalt_buf, tmp_buf, salt_len);
		salt.setSalt_len(salt_len)// digest;// digest
		.memcpy(digest, tmp_buf + salt_len, 20);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 16;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 16;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 16;
		generatedLen_max[1] = 16;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// salt
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[2] = 0;
		generatedSalt_buf[3] = 0;
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		generatedSalt_buf_pc[0] = generatedSalt_buf[0];
		generatedSalt_buf_pc[1] = generatedSalt_buf[1];
		{ 
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[1] >> 4;
				t = t ^ generatedSalt_buf_pc[0];
				t = t & -1024;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
				t = t << 4;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[0] >> 16;
				t = t ^ generatedSalt_buf_pc[1];
				t = t & -1024;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
				t = t << 16;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[1] >> 2;
				t = t ^ generatedSalt_buf_pc[0];
				t = t & -1024;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
				t = t << 2;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[0] >> 8;
				t = t ^ generatedSalt_buf_pc[1];
				t = t & -1024;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
				t = t << 8;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[1] >> 1;
				t = t ^ generatedSalt_buf_pc[0];
				t = t & -1024;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
				t = t << 1;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
			}
			;
		}
		;
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = 0;
		digest[3] = 0;
		{ 
			{ 
				u32x t = new u32x();
				t = digest[1] >> 4;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 4;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 16;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 16;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 2;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 2;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 8;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 8;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 1;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 1;
				digest[1] = digest[1] ^ t;
			}
			;
		}
		;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md4_constants.MD4M_A;
			digest[1] -= md4_constants.MD4M_B;
			digest[2] -= md4_constants.MD4M_C;
			digest[3] -= md4_constants.MD4M_D;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		Object generatedLen = token.getLen();
		generatedLen[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[1] = 64;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[2] = 32;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer/**
			   * salt
			   */);
		} 
		Object generatedBuf = token.getBuf();
		u8 salt1_pos = generatedBuf[2];
		u8 salt2_pos = generatedBuf[0];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt1_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt1_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt1_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(salt1_pos + 24);
		generatedSalt_buf[4] = ModernizedCProgram.hex_to_u32(salt2_pos + 0);
		generatedSalt_buf[5] = ModernizedCProgram.hex_to_u32(salt2_pos + 8);
		generatedSalt_buf[6] = ModernizedCProgram.hex_to_u32(salt2_pos + 16);
		generatedSalt_buf[7] = ModernizedCProgram.hex_to_u32(salt2_pos + 24);
		generatedSalt_buf[8] = ModernizedCProgram.hex_to_u32(salt2_pos + 32);
		generatedSalt_buf[9] = ModernizedCProgram.hex_to_u32(salt2_pos + 40);
		generatedSalt_buf[10] = ModernizedCProgram.hex_to_u32(salt2_pos + 48);
		generatedSalt_buf[11] = ModernizedCProgram.hex_to_u32(salt2_pos + 56);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3]);
		generatedSalt_buf[4] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[4]);
		generatedSalt_buf[5] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[5]);
		generatedSalt_buf[6] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[6]);
		generatedSalt_buf[7] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[7]);
		generatedSalt_buf[8] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[8]);
		generatedSalt_buf[9] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[9]);
		generatedSalt_buf[10] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[10]);
		generatedSalt_buf[11] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[11]);
		salt.setSalt_len(48);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_ANDROIDFDE_SAMSUNG - 1/**
		   * digest buf
		   */);
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SHA512B64S;
		Object generatedLen = token.getLen();
		generatedLen[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = (((64 + 0) * 8) / 6) + 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = (((64 + 256) * 8) / 6) + 3;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hashsalt_pos = generatedBuf[1];
		int hashsalt_len = generatedLen[1];
		u8[] tmp_buf = new u8[]{0};
		int tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hashsalt_pos, hashsalt_len, tmp_buf);
		if (tmp_len < 64) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		u8 hash_pos = tmp_buf;
		.memcpy(digest, hash_pos, 64);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_64_constants.SHA512M_A;
			digest[1] -= sha2_64_constants.SHA512M_B;
			digest[2] -= sha2_64_constants.SHA512M_C;
			digest[3] -= sha2_64_constants.SHA512M_D;
			digest[4] -= sha2_64_constants.SHA512M_E;
			digest[5] -= sha2_64_constants.SHA512M_F;
			digest[6] -= sha2_64_constants.SHA512M_G;
			digest[7] -= sha2_64_constants.SHA512M_H;
		} 
		// saltu8 salt_pos = tmp_buf + 64;
		int salt_len = tmp_len - 64;
		salt.setSalt_len(salt_len);
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy(generatedSalt_buf, salt_pos, salt_len);
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_ADD80) {
			u8 ptr = (u8)generatedSalt_buf;
			ptr[salt_len] = -1024;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 20;
		generatedLen_max[1] = 20;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		chacha20_t chacha20 = (chacha20_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(6);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_CHACHA20;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 10;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 10;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)'*';
		generatedLen_min[1] = 16;
		generatedLen_max[1] = 16;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 2;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 16;
		generatedLen_max[3] = 16;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[4] = (byte)'*';
		generatedLen_min[4] = 16;
		generatedLen_max[4] = 16;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[5] = (byte)'*';
		generatedLen_min[5] = 16;
		generatedLen_max[5] = 16;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// offset
		Object generatedBuf = token.getBuf();
		u8 offset_marker = generatedBuf[2];
		int offset = .strtol((byte)offset_marker, ((Object)0), 10);
		if (offset > 63) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		chacha20.setOffset(offset)// position;// position
		u8 position_marker = generatedBuf[1];
		Object generatedPosition = chacha20.getPosition();
		generatedPosition[0] = ModernizedCProgram.hex_to_u32((u8)position_marker + 0);
		generatedPosition[1] = ModernizedCProgram.hex_to_u32((u8)position_marker + 8)// iv;// iv
		u8 iv_marker = generatedBuf[3];
		Object generatedIv = chacha20.getIv();
		generatedIv[0] = ModernizedCProgram.hex_to_u32((u8)iv_marker + 8);
		generatedIv[1] = ModernizedCProgram.hex_to_u32((u8)iv_marker + 0)// plain;// plain
		u8 plain_marker = generatedBuf[4];
		Object generatedPlain = chacha20.getPlain();
		generatedPlain[0] = ModernizedCProgram.hex_to_u32((u8)plain_marker + 0);
		generatedPlain[1] = ModernizedCProgram.hex_to_u32((u8)plain_marker + 8);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedIv[/* some fake salt for the sorting mechanisms */0];
		generatedSalt_buf[1] = generatedIv[1];
		generatedSalt_buf[2] = generatedPlain[0];
		generatedSalt_buf[3] = generatedPlain[1];
		generatedSalt_buf[4] = generatedPosition[0];
		generatedSalt_buf[5] = generatedPosition[1];
		Object generatedOffset = chacha20.getOffset();
		generatedSalt_buf[6] = generatedOffset;
		generatedSalt_buf[7] = 0;
		salt.setSalt_len(32);
		u8 cipher_marker = generatedBuf[/* Store cipher for search mechanism */5];
		digest[0] = ModernizedCProgram.hex_to_u32((u8)cipher_marker + 8);
		digest[1] = ModernizedCProgram.hex_to_u32((u8)cipher_marker + 0);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		ansible_vault_t ansible_vault = (ansible_vault_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(6);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ANSIBLE_VAULT;
		Object generatedLen = token.getLen();
		generatedLen[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 64;
		generatedLen_max[3] = 64;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[4] = (byte)'*';
		generatedLen_min[4] = 32;
		generatedLen_max[4] = 32768;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[5] = (byte)'*';
		generatedLen_min[5] = 64;
		generatedLen_max[5] = 64;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// cipher (unused)
		Object generatedBuf = token.getBuf();
		u8 cipher_pos = generatedBuf[1];
		ansible_vault.setCipher(ModernizedCProgram.hc_strtoul((byte)cipher_pos, ((Object)0), 10))// version (unused);// version (unused)
		u8 version_pos = generatedBuf[2];
		ansible_vault.setVersion(ModernizedCProgram.hc_strtoul((byte)version_pos, ((Object)0), 10))// salt;// salt
		u8 salt_pos = generatedBuf[3];
		salt.setSalt_len(32);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_ANSIBLE_VAULT - 1);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(salt_pos + 24);
		generatedSalt_buf[4] = ModernizedCProgram.hex_to_u32(salt_pos + 32);
		generatedSalt_buf[5] = ModernizedCProgram.hex_to_u32(salt_pos + 40);
		generatedSalt_buf[6] = ModernizedCProgram.hex_to_u32(salt_pos + 48);
		generatedSalt_buf[7] = ModernizedCProgram.hex_to_u32(salt_pos + 56);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3]);
		generatedSalt_buf[4] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[4]);
		generatedSalt_buf[5] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[5]);
		generatedSalt_buf[6] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[6]);
		generatedSalt_buf[7] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[7])// ciphertext;// ciphertext
		u8 ct_buf_pos = generatedBuf[4];
		int ct_buf_len = generatedLen[4];
		Object generatedCt_data_buf = ansible_vault.getCt_data_buf();
		u8 ct_data_ptr = (u8)generatedCt_data_buf;
		Object generatedCt_data_len = ansible_vault.getCt_data_len();
		for (int i = 0;
		int j = 0;
		 j < ct_buf_len; ) {
			ct_data_ptr[i] = ModernizedCProgram.hex_to_u8((u8)ct_buf_pos[j]);
			generatedCt_data_len++;
		}
		// hashu8 hash_pos = generatedBuf[5];
		digest[0] = ModernizedCProgram.hex_to_u32((u8)hash_pos[0]);
		digest[1] = ModernizedCProgram.hex_to_u32((u8)hash_pos[8]);
		digest[2] = ModernizedCProgram.hex_to_u32((u8)hash_pos[16]);
		digest[3] = ModernizedCProgram.hex_to_u32((u8)hash_pos[24]);
		digest[4] = ModernizedCProgram.hex_to_u32((u8)hash_pos[32]);
		digest[5] = ModernizedCProgram.hex_to_u32((u8)hash_pos[40]);
		digest[6] = ModernizedCProgram.hex_to_u32((u8)hash_pos[48]);
		digest[7] = ModernizedCProgram.hex_to_u32((u8)hash_pos[56]);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		ethereum_presale_t ethereum_presale = (ethereum_presale_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ETHEREUM_PRESALE;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 11;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)'*';
		generatedLen_min[1] = 64;
		generatedLen_max[1] = 1248;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 40;
		generatedLen_max[2] = 40;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// encseed
		Object generatedBuf = token.getBuf();
		u8 encseed_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int encseed_len = generatedLen[1];
		Object generatedIv = ethereum_presale.getIv();
		generatedIv[0] = ModernizedCProgram.hex_to_u32((u8)encseed_pos[0]);
		generatedIv[1] = ModernizedCProgram.hex_to_u32((u8)encseed_pos[8]);
		generatedIv[2] = ModernizedCProgram.hex_to_u32((u8)encseed_pos[16]);
		generatedIv[3] = ModernizedCProgram.hex_to_u32((u8)encseed_pos[24]);
		generatedIv[0] = ModernizedCProgram.byte_swap_32(generatedIv[0]);
		generatedIv[1] = ModernizedCProgram.byte_swap_32(generatedIv[1]);
		generatedIv[2] = ModernizedCProgram.byte_swap_32(generatedIv[2]);
		generatedIv[3] = ModernizedCProgram.byte_swap_32(generatedIv[3]);
		Object generatedEnc_seed = ethereum_presale.getEnc_seed();
		u32 esalt_buf_ptr = generatedEnc_seed;
		for (int i = 32;
		int j = 0;
		 i < encseed_len; ) {
			esalt_buf_ptr[j] = ModernizedCProgram.hex_to_u32((u8)encseed_pos[i]);
			esalt_buf_ptr[j] = ModernizedCProgram.byte_swap_32(esalt_buf_ptr[j]);
		}
		// encseed length without IV (raw bytes, not hex)// encseed length without IV (raw bytes, not hex)ethereum_presale.setEnc_seed_len((encseed_len - 32) / 2)// salt (address);// salt (address)
		u8 ethaddr_pos = generatedBuf[2];
		int ethaddr_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, ethaddr_pos, ethaddr_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_ETHEREUM_PRESALE - 1)// hash (bkp);// hash (bkp)
		u8 bkp_pos = generatedBuf[3];
		digest[0] = ModernizedCProgram.hex_to_u32((u8)bkp_pos[0]);
		digest[1] = ModernizedCProgram.hex_to_u32((u8)bkp_pos[8]);
		digest[2] = ModernizedCProgram.hex_to_u32((u8)bkp_pos[16]);
		digest[3] = ModernizedCProgram.hex_to_u32((u8)bkp_pos[24]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		apple_secure_notes_t apple_secure_notes = (apple_secure_notes_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(6);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_FILEVAULT2;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 10;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 6;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[4] = (byte)'$';
		generatedLen_min[4] = 1;
		generatedLen_max[4] = 6;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[5] = (byte)'$';
		generatedLen_min[5] = 48;
		generatedLen_max[5] = 48;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// Z_PK
		Object generatedBuf = token.getBuf();
		u8 Z_PK_pos = generatedBuf[1];
		u32 Z_PK = ModernizedCProgram.hc_strtoul((byte)Z_PK_pos, ((Object)0), 10);
		if (Z_PK != 1) {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		apple_secure_notes.setZ_PK(Z_PK)// ZCRYPTOSALT;// ZCRYPTOSALT
		u8 ZCRYPTOSALT_pos = generatedBuf[3];
		Object generatedZCRYPTOSALT = apple_secure_notes.getZCRYPTOSALT();
		generatedZCRYPTOSALT[0] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[0]);
		generatedZCRYPTOSALT[1] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[8]);
		generatedZCRYPTOSALT[2] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[16]);
		generatedZCRYPTOSALT[3] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOSALT_pos[24]);
		generatedZCRYPTOSALT[4] = 0;
		generatedZCRYPTOSALT[5] = 0;
		generatedZCRYPTOSALT[6] = 0;
		generatedZCRYPTOSALT[7] = 0;
		generatedZCRYPTOSALT[8] = 0;
		generatedZCRYPTOSALT[9] = 0;
		generatedZCRYPTOSALT[10] = 0;
		generatedZCRYPTOSALT[11] = 0;
		generatedZCRYPTOSALT[12] = 0;
		generatedZCRYPTOSALT[13] = 0;
		generatedZCRYPTOSALT[14] = 0;
		generatedZCRYPTOSALT[15] = 0// ZCRYPTOITERATIONCOUNT;// ZCRYPTOITERATIONCOUNT
		u8 ZCRYPTOITERATIONCOUNT_pos = generatedBuf[4];
		u32 ZCRYPTOITERATIONCOUNT = ModernizedCProgram.hc_strtoul((byte)ZCRYPTOITERATIONCOUNT_pos, ((Object)0), 10);
		apple_secure_notes.setZCRYPTOITERATIONCOUNT(ZCRYPTOITERATIONCOUNT)// ZCRYPTOWRAPPEDKEY;// ZCRYPTOWRAPPEDKEY
		u8 ZCRYPTOWRAPPEDKEY_pos = generatedBuf[5];
		Object generatedZCRYPTOWRAPPEDKEY = apple_secure_notes.getZCRYPTOWRAPPEDKEY();
		generatedZCRYPTOWRAPPEDKEY[0] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[0]);
		generatedZCRYPTOWRAPPEDKEY[1] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[8]);
		generatedZCRYPTOWRAPPEDKEY[2] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[16]);
		generatedZCRYPTOWRAPPEDKEY[3] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[24]);
		generatedZCRYPTOWRAPPEDKEY[4] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[32]);
		generatedZCRYPTOWRAPPEDKEY[5] = ModernizedCProgram.hex_to_u32((u8)ZCRYPTOWRAPPEDKEY_pos[40])// fake salt;// fake salt
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedZCRYPTOSALT[0];
		generatedSalt_buf[1] = generatedZCRYPTOSALT[1];
		generatedSalt_buf[2] = generatedZCRYPTOSALT[2];
		generatedSalt_buf[3] = generatedZCRYPTOSALT[3];
		Object generatedZ_PK = apple_secure_notes.getZ_PK();
		generatedSalt_buf[4] = generatedZ_PK;
		Object generatedZCRYPTOITERATIONCOUNT = apple_secure_notes.getZCRYPTOITERATIONCOUNT();
		salt.setSalt_iter(generatedZCRYPTOITERATIONCOUNT - 1);
		salt.setSalt_len(20)// fake hash;// fake hash
		digest[0] = generatedZCRYPTOWRAPPEDKEY[0];
		digest[1] = generatedZCRYPTOWRAPPEDKEY[1];
		digest[2] = generatedZCRYPTOWRAPPEDKEY[2];
		digest[3] = generatedZCRYPTOWRAPPEDKEY[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'$';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[1] = 40;
		generatedLen_max[1] = 40;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer/**
			   * salt
			   */);
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[0];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[0];
		int user_len = 0;
		for (int i = 0;
		 i < salt_len; i++) {
			if (salt_pos[i] == (byte)' ') {
				continue;
			} 
			user_len++;
		}
		// SAP user names cannot be longer than 12 charactersif (user_len > 12) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// SAP user name cannot start with ! or ?if (salt_pos[0] == (byte)'!' || salt_pos[0] == (byte)'?') {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH/**
			   * hash
			   */);
		} 
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u32((u8)hash_pos[0]);
		digest[1] = ModernizedCProgram.hex_to_u32((u8)hash_pos[8]);
		digest[2] = ModernizedCProgram.hex_to_u32((u8)hash_pos[16]);
		digest[3] = ModernizedCProgram.hex_to_u32((u8)hash_pos[24]);
		digest[4] = ModernizedCProgram.hex_to_u32((u8)hash_pos[32]);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 32;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		diskcryptor_esalt_t diskcryptor_esalt = (diskcryptor_esalt_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_DISKCRYPTOR;
		Object generatedLen = token.getLen();
		generatedLen[0] = 13;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[2] = 4096;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// version
		Object generatedBuf = token.getBuf();
		u8 version = generatedBuf[1];
		if (version[0] != (byte)'0' + ModernizedCProgram.DISKCRYPTOR_VERSION) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		// esalt
		u8 data_buf = generatedBuf[2];
		Object generatedSalt_buf = diskcryptor_esalt.getSalt_buf();
		for (u32 i = 0;
		 i < 512; i++) {
			generatedSalt_buf[i] = ModernizedCProgram.hex_to_u32(data_buf[i * 8]);
		}
		// salt param// salt paramsalt.setSalt_len(64);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_DISKCRYPTOR - 1)// salt;// salt
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		generatedSalt_buf[4] = generatedSalt_buf[4];
		generatedSalt_buf[5] = generatedSalt_buf[5];
		generatedSalt_buf[6] = generatedSalt_buf[6];
		generatedSalt_buf[7] = generatedSalt_buf[7];
		generatedSalt_buf[8] = generatedSalt_buf[8];
		generatedSalt_buf[9] = generatedSalt_buf[9];
		generatedSalt_buf[10] = generatedSalt_buf[10];
		generatedSalt_buf[11] = generatedSalt_buf[11];
		generatedSalt_buf[12] = generatedSalt_buf[12];
		generatedSalt_buf[13] = generatedSalt_buf[13];
		generatedSalt_buf[14] = generatedSalt_buf[14];
		generatedSalt_buf[15] = generatedSalt_buf[15]// digest;// digest
		digest[0] = generatedSalt_buf[16];
		digest[1] = generatedSalt_buf[17];
		digest[2] = generatedSalt_buf[18];
		digest[3] = generatedSalt_buf[19];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SYBASEASE;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen[1] = 16;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[2] = 64;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// salt
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// hash
		u8 hash_pos = generatedBuf[2];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 56;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		int hash_len = generatedLen[0];
		if (hash_len != 56) {
			return (parser_rc.PARSER_GLOBAL_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_1K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 96;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		int hash_len = generatedLen[0];
		if (hash_len != 96) {
			return (parser_rc.PARSER_GLOBAL_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(6);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SCRYPT;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 6;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 6;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedSep[1] = (byte)':';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 6;
		generatedSep[2] = (byte)':';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[3] = 1;
		generatedLen_max[3] = 6;
		generatedSep[3] = (byte)':';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[4] = 0;
		generatedLen_max[4] = 45;
		generatedSep[4] = (byte)':';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		generatedLen_min[5] = 44;
		generatedLen_max[5] = 44;
		generatedSep[5] = (byte)':';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// scrypt settings
		Object generatedBuf = token.getBuf();
		u8 N_pos = generatedBuf[1];
		u8 r_pos = generatedBuf[2];
		u8 p_pos = generatedBuf[3];
		salt.setScrypt_N(ModernizedCProgram.hc_strtoul((byte)N_pos, ((Object)0), 10));
		salt.setScrypt_r(ModernizedCProgram.hc_strtoul((byte)r_pos, ((Object)0), 10));
		salt.setScrypt_p(ModernizedCProgram.hc_strtoul((byte)p_pos, ((Object)0), 10))// salt;// salt
		u8 salt_pos = generatedBuf[4];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[4];
		u8[] tmp_buf = new u8[]{0};
		int tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, (u8)salt_pos, salt_len, tmp_buf);
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy(generatedSalt_buf, tmp_buf, tmp_len);
		salt.setSalt_len(tmp_len);
		salt.setSalt_iter(1)// digest - base64 decode;// digest - base64 decode
		u8 hash_pos = generatedBuf[5];
		int hash_len = generatedLen[5];
		.memset(tmp_buf, 0, );
		ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, (u8)hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, 32);
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		int hash_len = generatedLen[0];
		if (hash_len != 128) {
			return (parser_rc.PARSER_GLOBAL_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		android_backup_t android_backup = (android_backup_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(8);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ANDROID_BACKUP;
		Object generatedLen = token.getLen();
		// signature// signaturegeneratedLen[0] = 4;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		// version// versiongeneratedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// cipher// ciphergeneratedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// iter// itergeneratedLen_min[3] = 1;
		generatedLen_max[3] = 6;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// user_salt// user_saltgeneratedLen_min[4] = 128;
		generatedLen_max[4] = 128;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		// ck_salt// ck_saltgeneratedLen_min[5] = 128;
		generatedLen_max[5] = 128;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		// user_iv// user_ivgeneratedLen_min[6] = 32;
		generatedLen_max[6] = 32;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		// masterkey_blob// masterkey_blobgeneratedLen_min[7] = 192;
		generatedLen_max[7] = 192;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 cipher_pos = generatedBuf[2];
		u8 iter_pos = generatedBuf[3];
		u8 user_salt_pos = generatedBuf[4];
		u8 ck_salt_pos = generatedBuf[5];
		u8 user_iv_pos = generatedBuf[6];
		u8 masterkey_blob_pos = generatedBuf[7];
		// version
		int version = ModernizedCProgram.hc_strtoul((byte)version_pos, ((Object)0), 10);
		android_backup.setVersion(version)// cipher;// cipher
		int cipher = ModernizedCProgram.hc_strtoul((byte)cipher_pos, ((Object)0), 10);
		android_backup.setCipher(cipher)// iter;// iter
		int iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		android_backup.setIter(iter)// user_salt;// user_salt
		Object generatedUser_salt = android_backup.getUser_salt();
		for (int i = 0;
		int j = 0;
		 j < 128; ) {
			generatedUser_salt[i] = ModernizedCProgram.hex_to_u32((u8)user_salt_pos + j);
		}
		Object generatedCk_salt = android_backup.getCk_salt();
		// ck_saltfor (int i = 0;
		int j = 0;
		 j < 128; ) {
			generatedCk_salt[i] = ModernizedCProgram.hex_to_u32((u8)ck_salt_pos + j);
		}
		Object generatedUser_iv = android_backup.getUser_iv();
		// user_ivfor (int i = 0;
		int j = 0;
		 j < 32; ) {
			generatedUser_iv[i] = ModernizedCProgram.hex_to_u32((u8)user_iv_pos + j);
		}
		Object generatedMasterkey_blob = android_backup.getMasterkey_blob();
		// masterkey_blobfor (int i = 0;
		int j = 0;
		 j < 192; ) {
			generatedMasterkey_blob[i] = ModernizedCProgram.hex_to_u32((u8)masterkey_blob_pos + j);
		}
		Object generatedSalt_buf = salt.getSalt_buf();
		// make the entry unique in our databases// make the entry unique in our databasesgeneratedSalt_buf[0] = generatedUser_salt[0];
		generatedSalt_buf[1] = generatedUser_salt[1];
		generatedSalt_buf[2] = generatedUser_salt[2];
		generatedSalt_buf[3] = generatedUser_salt[3];
		generatedSalt_buf[4] = generatedUser_salt[4];
		generatedSalt_buf[5] = generatedUser_salt[5];
		generatedSalt_buf[6] = generatedUser_salt[6];
		generatedSalt_buf[7] = generatedUser_salt[7];
		generatedSalt_buf[8] = generatedUser_salt[8];
		generatedSalt_buf[9] = generatedUser_salt[9];
		generatedSalt_buf[10] = generatedUser_salt[10];
		generatedSalt_buf[11] = generatedUser_salt[11];
		generatedSalt_buf[12] = generatedUser_salt[12];
		generatedSalt_buf[13] = generatedUser_salt[13];
		generatedSalt_buf[14] = generatedUser_salt[14];
		generatedSalt_buf[15] = generatedUser_salt[15];
		salt.setSalt_len(64);
		Object generatedIter = android_backup.getIter();
		salt.setSalt_iter(generatedIter - 1);
		digest[0] = generatedMasterkey_blob[0];
		digest[1] = generatedMasterkey_blob[1];
		digest[2] = generatedMasterkey_blob[2];
		digest[3] = generatedMasterkey_blob[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 30;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 30;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256 - 23;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		// unscramble
		u8[] clean_input_buf = new u8[]{0};
		byte[] sig = new byte[]{(byte)'n', (byte)'r', (byte)'c', (byte)'s', (byte)'t', (byte)'n'};
		int[] pos = new int[]{0, 6, 12, 17, 23, 29};
		for (int i = 0;
		int j = 0;
		int k = 0;
		 i < 30; i++) {
			if (i == pos[j]) {
				if (sig[j] != hash_pos[i]) {
					return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
				} 
				j++;
			} else {
					clean_input_buf[k] = hash_pos[i];
					k++;
			} 
		}
		// base64 decodeu32 a = new u32();
		u32 b = new u32();
		u32 c = new u32();
		u32 d = new u32();
		u32 e = new u32();
		u32 f = new u32();
		a = ModernizedCProgram.base64_to_int(clean_input_buf[0] & -1024);
		b = ModernizedCProgram.base64_to_int(clean_input_buf[1] & -1024);
		c = ModernizedCProgram.base64_to_int(clean_input_buf[2] & -1024);
		d = ModernizedCProgram.base64_to_int(clean_input_buf[3] & -1024);
		e = ModernizedCProgram.base64_to_int(clean_input_buf[4] & -1024);
		f = ModernizedCProgram.base64_to_int(clean_input_buf[5] & -1024);
		digest[0] = (((a << 12) | (b << 6) | (c)) << 16) | (((d << 12) | (e << 6) | (f)) << 0);
		a = ModernizedCProgram.base64_to_int(clean_input_buf[6] & -1024);
		b = ModernizedCProgram.base64_to_int(clean_input_buf[7] & -1024);
		c = ModernizedCProgram.base64_to_int(clean_input_buf[8] & -1024);
		d = ModernizedCProgram.base64_to_int(clean_input_buf[9] & -1024);
		e = ModernizedCProgram.base64_to_int(clean_input_buf[10] & -1024);
		f = ModernizedCProgram.base64_to_int(clean_input_buf[11] & -1024);
		digest[1] = (((a << 12) | (b << 6) | (c)) << 16) | (((d << 12) | (e << 6) | (f)) << 0);
		a = ModernizedCProgram.base64_to_int(clean_input_buf[12] & -1024);
		b = ModernizedCProgram.base64_to_int(clean_input_buf[13] & -1024);
		c = ModernizedCProgram.base64_to_int(clean_input_buf[14] & -1024);
		d = ModernizedCProgram.base64_to_int(clean_input_buf[15] & -1024);
		e = ModernizedCProgram.base64_to_int(clean_input_buf[16] & -1024);
		f = ModernizedCProgram.base64_to_int(clean_input_buf[17] & -1024);
		digest[2] = (((a << 12) | (b << 6) | (c)) << 16) | (((d << 12) | (e << 6) | (f)) << 0);
		a = ModernizedCProgram.base64_to_int(clean_input_buf[18] & -1024);
		b = ModernizedCProgram.base64_to_int(clean_input_buf[19] & -1024);
		c = ModernizedCProgram.base64_to_int(clean_input_buf[20] & -1024);
		d = ModernizedCProgram.base64_to_int(clean_input_buf[21] & -1024);
		e = ModernizedCProgram.base64_to_int(clean_input_buf[22] & -1024);
		f = ModernizedCProgram.base64_to_int(clean_input_buf[23] & -1024);
		digest[3] = (((a << 12) | (b << 6) | (c)) << 16) | (((d << 12) | (e << 6) | (f)) << 0);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			if (generatedSalt_len > 32) {
				return (parser_rc.PARSER_SALT_LENGTH);
			} 
		} 
		// max. salt length: 55 (max for MD5) - 22 (":Administration Tools:") - 1 (0x80) = 32
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		.memcpy(salt_buf_ptr + generatedSalt_len, ModernizedCProgram.adm, .strlen(ModernizedCProgram.adm));
		generatedSalt_len += .strlen(ModernizedCProgram.adm);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pbkdf2_md5_t pbkdf2_md5 = (pbkdf2_md5_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PBKDF2_MD5;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 3;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 3;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)':';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)':';
		generatedLen_min[2] = ((0 * 8) / 6) + 0;
		generatedLen_max[2] = ((256 * 8) / 6) + 3;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		generatedSep[3] = (byte)':';
		generatedLen_min[3] = 16;
		generatedLen_max[3] = 256;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		u8[] tmp_buf = new u8();
		int tmp_len;
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		salt.setSalt_iter(iter - 1)// salt;// salt
		u8 salt_pos = generatedBuf[2];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[2];
		.memset(tmp_buf, 0, );
		tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, salt_pos, salt_len, tmp_buf);
		if (tmp_len > 256) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt_buf = pbkdf2_md5.getSalt_buf();
		.memcpy(generatedSalt_buf, tmp_buf, tmp_len);
		salt.setSalt_len(tmp_len);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_buf[4] = generatedSalt_iter// hash;// hash
		u8 hash_pos = generatedBuf[3];
		int hash_len = generatedLen[3];
		.memset(tmp_buf, 0, );
		tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hash_pos, hash_len, tmp_buf);
		if (tmp_len < 16) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		.memcpy(digest, tmp_buf, 16);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		agilekey_t agilekey = (agilekey_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 6;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[1] = 16;
		generatedLen_max[1] = 16;
		generatedSep[1] = (byte)':';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[2] = 2080;
		generatedLen_max[2] = 2080;
		generatedSep[2] = (byte)':';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer/**
			   * pbkdf2 iterations
			   */);
		} 
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[0];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10) - 1/**
		   * handle salt encoding
		   */);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		u8 saltbuf_ptr = (u8)generatedSalt_buf;
		for (int i = 0;
		 i < salt_len; i += 2) {
			u8 p0 = salt_pos[i + 0];
			u8 p1 = salt_pos[i + 1];
			saltbuf_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		salt.setSalt_len(salt_len / 2/**
		   * handle cipher encoding
		   */);
		u8 cipher_pos = generatedBuf[2];
		int cipher_len = generatedLen[2];
		u32[] tmp = new u32[]{0};
		u8 cipherbuf_ptr = (u8)tmp;
		for (int i = 2016;
		 i < cipher_len; i += 2) {
			u8 p0 = cipher_pos[i + 0];
			u8 p1 = cipher_pos[i + 1];
			cipherbuf_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		// iv   is stored at salt_buf 4 (length 16)// data is stored at salt_buf 8 (length 16)// iv   is stored at salt_buf 4 (length 16)// data is stored at salt_buf 8 (length 16)generatedSalt_buf[4] = ModernizedCProgram.byte_swap_32(tmp[0]);
		generatedSalt_buf[5] = ModernizedCProgram.byte_swap_32(tmp[1]);
		generatedSalt_buf[6] = ModernizedCProgram.byte_swap_32(tmp[2]);
		generatedSalt_buf[7] = ModernizedCProgram.byte_swap_32(tmp[3]);
		generatedSalt_buf[8] = ModernizedCProgram.byte_swap_32(tmp[4]);
		generatedSalt_buf[9] = ModernizedCProgram.byte_swap_32(tmp[5]);
		generatedSalt_buf[10] = ModernizedCProgram.byte_swap_32(tmp[6]);
		generatedSalt_buf[11] = ModernizedCProgram.byte_swap_32(tmp[7]);
		Object generatedCipher = agilekey.getCipher();
		for (int i = 0;
		int j = 0;
		 i < 1040; ) {
			u8 p0 = cipher_pos[j + 0];
			u8 p1 = cipher_pos[j + 1];
			generatedCipher[i] = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4/**
			   * digest buf
			   */;
		}
		digest[0] = -1024;
		digest[1] = -1024;
		digest[2] = -1024;
		digest[3] = -1024;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 8;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 8;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[1] = hashconfig.getSeparator();
		generatedLen_min[1] = 8;
		generatedLen_max[1] = 8;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = 0;
		digest[2] = 0;
		digest[3] = 0;
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = 0;
		digest[2] = 0;
		digest[3] = 0;
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		pkzip_t pkzip = (pkzip_t)esalt_buf;
		u32 digest = (u32)digest_buf;
		byte[] input = new byte[line_len + 1];
		input[line_len] = (byte)'\0';
		.memcpy(input, line_buf, line_len);
		byte saveptr = ((Object)0);
		byte p = .strtok_r(input, "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		if (.strncmp(p, ModernizedCProgram.SIGNATURE_PKZIP_V1, 7) != 0 && .strncmp(p, ModernizedCProgram.SIGNATURE_PKZIP_V2, 8) != 0) {
			return parser_rc.PARSER_SIGNATURE_UNMATCHED;
		} 
		pkzip.setVersion(1);
		if (.strlen(p) == 9) {
			pkzip.setVersion(2);
		} 
		byte[] sub = new byte[2];
		sub[0] = p[.strlen(p) - 1];
		sub[1] = (byte)'\0';
		pkzip.setHash_count(.atoi(sub));
		Object generatedHash_count = pkzip.getHash_count();
		// check here that the hash_count is valid for the attack typeif (generatedHash_count > 8) {
			return parser_rc.PARSER_HASH_VALUE;
		} 
		if (generatedHash_count < 3) {
			return parser_rc.PARSER_HASH_VALUE;
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		pkzip.setChecksum_size(.atoi(p));
		Object generatedChecksum_size = pkzip.getChecksum_size();
		if (generatedChecksum_size != 1 && generatedChecksum_size != 2) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		Object generatedHashes = pkzip.getHashes();
		Object generatedVersion = pkzip.getVersion();
		Object generatedSalt_buf = salt.getSalt_buf();
		for (int i = 0;
		 i < generatedHash_count; i++) {
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setData_type_enum(.atoi(p));
			if (generatedHashes[i].getData_type_enum() > 3) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setMagic_type_enum(.atoi(p));
			if (generatedHashes[i].getData_type_enum() > 1) {
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setCompressed_length(.strtoul(p, ((Object)0), 16));
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setUncompressed_length(.strtoul(p, ((Object)0), 16));
				if (generatedHashes[i].getCompressed_length() > (320 * 1024)) {
					return parser_rc.PARSER_TOKEN_LENGTH;
				} 
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				u32 crc32 = 0;
				.sscanf(p, "%x", ModernizedCProgram.crc32);
				generatedHashes[i].setCrc32(ModernizedCProgram.crc32);
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setOffset(.strtoul(p, ((Object)0), 16));
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setAdditional_offset(.strtoul(p, ((Object)0), 16));
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setCompression_type(.atoi(p));
			if (generatedHashes[i].getCompression_type() != 8 && generatedHashes[i].getCompression_type() != 0) {
				return parser_rc.PARSER_PKZIP_CT_UNMATCHED;
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setData_length(.strtoul(p, ((Object)0), 16));
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			u16 checksum_from_crc = 0;
			.sscanf(p, "%hx", checksum_from_crc);
			generatedHashes[i].setChecksum_from_crc(checksum_from_crc);
			if (generatedVersion == 2) {
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				u16 checksum_from_timestamp = 0;
				.sscanf(p, "%hx", checksum_from_timestamp);
				generatedHashes[i].setChecksum_from_timestamp(checksum_from_timestamp);
			} else {
					generatedHashes[i].setChecksum_from_timestamp(generatedHashes[i].getChecksum_from_crc());
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			ModernizedCProgram.hex_to_binary(p, .strlen(p), (byte)(generatedHashes[i].getData()));
			generatedSalt_buf[i] = generatedHashes[i].getData()[0];
			if (i == 0) {
				digest[i] = generatedHashes[i].getChecksum_from_crc();
			} 
		}
		salt.setSalt_len(generatedHash_count << 2);
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_64_constants.SHA512M_A;
			digest[1] -= sha2_64_constants.SHA512M_B;
			digest[2] -= sha2_64_constants.SHA512M_C;
			digest[3] -= sha2_64_constants.SHA512M_D;
			digest[4] -= sha2_64_constants.SHA512M_E;
			digest[5] -= sha2_64_constants.SHA512M_F;
			digest[6] -= sha2_64_constants.SHA512M_G;
			digest[7] -= sha2_64_constants.SHA512M_H;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		diskcryptor_esalt_t diskcryptor_esalt = (diskcryptor_esalt_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_DISKCRYPTOR;
		Object generatedLen = token.getLen();
		generatedLen[0] = 13;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[2] = 4096;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// version
		Object generatedBuf = token.getBuf();
		u8 version = generatedBuf[1];
		if (version[0] != (byte)'0' + ModernizedCProgram.DISKCRYPTOR_VERSION) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		// esalt
		u8 data_buf = generatedBuf[2];
		Object generatedSalt_buf = diskcryptor_esalt.getSalt_buf();
		for (u32 i = 0;
		 i < 512; i++) {
			generatedSalt_buf[i] = ModernizedCProgram.hex_to_u32(data_buf[i * 8]);
		}
		// salt param// salt paramsalt.setSalt_len(64);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_DISKCRYPTOR - 1)// salt;// salt
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		generatedSalt_buf[4] = generatedSalt_buf[4];
		generatedSalt_buf[5] = generatedSalt_buf[5];
		generatedSalt_buf[6] = generatedSalt_buf[6];
		generatedSalt_buf[7] = generatedSalt_buf[7];
		generatedSalt_buf[8] = generatedSalt_buf[8];
		generatedSalt_buf[9] = generatedSalt_buf[9];
		generatedSalt_buf[10] = generatedSalt_buf[10];
		generatedSalt_buf[11] = generatedSalt_buf[11];
		generatedSalt_buf[12] = generatedSalt_buf[12];
		generatedSalt_buf[13] = generatedSalt_buf[13];
		generatedSalt_buf[14] = generatedSalt_buf[14];
		generatedSalt_buf[15] = generatedSalt_buf[15]// digest;// digest
		digest[0] = generatedSalt_buf[16];
		digest[1] = generatedSalt_buf[17];
		digest[2] = generatedSalt_buf[18];
		digest[3] = generatedSalt_buf[19];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		pkzip_t pkzip = (pkzip_t)esalt_buf;
		u32 digest = (u32)digest_buf;
		byte[] input = new byte[line_len + 1];
		input[line_len] = (byte)'\0';
		.memcpy(input, line_buf, line_len);
		byte saveptr = ((Object)0);
		byte p = .strtok_r(input, "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		if (.strncmp(p, ModernizedCProgram.SIGNATURE_PKZIP_V1, 7) != 0 && .strncmp(p, ModernizedCProgram.SIGNATURE_PKZIP_V2, 8) != 0) {
			return parser_rc.PARSER_SIGNATURE_UNMATCHED;
		} 
		pkzip.setVersion(1);
		if (.strlen(p) == 9) {
			pkzip.setVersion(2);
		} 
		byte[] sub = new byte[2];
		sub[0] = p[.strlen(p) - 1];
		sub[1] = (byte)'\0';
		pkzip.setHash_count(.atoi(sub));
		Object generatedHash_count = pkzip.getHash_count();
		// check here that the hash_count is valid for the attack typeif (generatedHash_count > 8) {
			return parser_rc.PARSER_HASH_VALUE;
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		pkzip.setChecksum_size(.atoi(p));
		Object generatedChecksum_size = pkzip.getChecksum_size();
		if (generatedChecksum_size != 1 && generatedChecksum_size != 2) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		Object generatedHashes = pkzip.getHashes();
		Object generatedVersion = pkzip.getVersion();
		Object generatedSalt_buf = salt.getSalt_buf();
		for (int i = 0;
		 i < generatedHash_count; i++) {
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setData_type_enum(.atoi(p));
			if (generatedHashes[i].getData_type_enum() > 3) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setMagic_type_enum(.atoi(p));
			if (generatedHashes[i].getData_type_enum() > 1) {
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setCompressed_length(.strtoul(p, ((Object)0), 16));
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setUncompressed_length(.strtoul(p, ((Object)0), 16));
				if (generatedHashes[i].getCompressed_length() > (320 * 1024)) {
					return parser_rc.PARSER_TOKEN_LENGTH;
				} 
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				u32 crc32 = 0;
				.sscanf(p, "%x", ModernizedCProgram.crc32);
				generatedHashes[i].setCrc32(ModernizedCProgram.crc32);
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setOffset(.strtoul(p, ((Object)0), 16));
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				generatedHashes[i].setAdditional_offset(.strtoul(p, ((Object)0), 16));
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setCompression_type(.atoi(p));
			if (generatedHashes[i].getCompression_type() != 8) {
				return parser_rc.PARSER_PKZIP_CT_UNMATCHED;
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHashes[i].setData_length(.strtoul(p, ((Object)0), 16));
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			u16 checksum_from_crc = 0;
			.sscanf(p, "%hx", checksum_from_crc);
			generatedHashes[i].setChecksum_from_crc(checksum_from_crc);
			if (generatedVersion == 2) {
				p = .strtok_r(((Object)0), "*", saveptr);
				if (p == ((Object)0)) {
					return parser_rc.PARSER_HASH_LENGTH;
				} 
				u16 checksum_from_timestamp = 0;
				.sscanf(p, "%hx", checksum_from_timestamp);
				generatedHashes[i].setChecksum_from_timestamp(checksum_from_timestamp);
			} else {
					generatedHashes[i].setChecksum_from_timestamp(generatedHashes[i].getChecksum_from_crc());
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			ModernizedCProgram.hex_to_binary(p, .strlen(p), (byte)(generatedHashes[i].getData()));
			generatedSalt_buf[i] = generatedHashes[i].getData()[0];
			if (i == 0) {
				digest[i] = generatedHashes[i].getChecksum_from_crc();
			} 
		}
		salt.setSalt_len(generatedHash_count << 2);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		bitcoin_wallet_t bitcoin_wallet = (bitcoin_wallet_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(10);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_BITCOIN_WALLET;
		Object generatedLen = token.getLen();
		generatedLen[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 2;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 2;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 16;
		generatedLen_max[2] = 256;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 2;
		generatedLen_max[3] = 2;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[4] = (byte)'$';
		generatedLen_min[4] = 16;
		generatedLen_max[4] = 16;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[5] = (byte)'$';
		generatedLen_min[5] = 1;
		generatedLen_max[5] = 6;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[6] = (byte)'$';
		generatedLen_min[6] = 0;
		generatedLen_max[6] = 6;
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[7] = (byte)'$';
		generatedLen_min[7] = 0;
		generatedLen_max[7] = 999999;
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[8] = (byte)'$';
		generatedLen_min[8] = 0;
		generatedLen_max[8] = 6;
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[9] = (byte)'$';
		generatedLen_min[9] = 0;
		generatedLen_max[9] = 999999;
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 cry_master_len_pos = generatedBuf[1];
		u8 cry_master_buf_pos = generatedBuf[2];
		u8 cry_salt_len_pos = generatedBuf[3];
		u8 cry_salt_buf_pos = generatedBuf[4];
		u8 cry_rounds_pos = generatedBuf[5];
		u8 ckey_len_pos = generatedBuf[6];
		u8 public_key_len_pos = generatedBuf[8];
		int cry_master_buf_len = generatedLen[2];
		int cry_salt_buf_len = generatedLen[4];
		int ckey_buf_len = generatedLen[7];
		int public_key_buf_len = generatedLen[9];
		// verify
		int cry_master_len = ModernizedCProgram.hc_strtoul((byte)cry_master_len_pos, ((Object)0), 10);
		int cry_salt_len = ModernizedCProgram.hc_strtoul((byte)cry_salt_len_pos, ((Object)0), 10);
		int ckey_len = ModernizedCProgram.hc_strtoul((byte)ckey_len_pos, ((Object)0), 10);
		int public_key_len = ModernizedCProgram.hc_strtoul((byte)public_key_len_pos, ((Object)0), 10);
		if (cry_master_buf_len != cry_master_len) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (cry_salt_buf_len != cry_salt_len) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (ckey_buf_len != ckey_len) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (public_key_buf_len != public_key_len) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (cry_master_len % 16) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		// esalt
		Object generatedCry_master_buf = bitcoin_wallet.getCry_master_buf();
		for (int i = 0;
		int j = 0;
		 j < cry_master_len; ) {
			generatedCry_master_buf[i] = ModernizedCProgram.hex_to_u32((u8)cry_master_buf_pos[j]);
		}
		bitcoin_wallet.setCry_master_len(cry_master_len / 2)// hash;// hash
		digest[0] = generatedCry_master_buf[0];
		digest[1] = generatedCry_master_buf[1];
		digest[2] = generatedCry_master_buf[2];
		digest[3] = generatedCry_master_buf[3]// iter;// iter
		int cry_rounds = ModernizedCProgram.hc_strtoul((byte)cry_rounds_pos, ((Object)0), 10);
		salt.setSalt_iter(cry_rounds - 1)// salt;// salt
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, cry_salt_buf_pos, cry_salt_buf_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 16;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 16;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pbkdf2_sha256_t pbkdf2_sha256 = (pbkdf2_sha256_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PBKDF2_SHA256;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 6;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)':';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)':';
		generatedLen_min[2] = ((0 * 8) / 6) + 0;
		generatedLen_max[2] = ((256 * 8) / 6) + 3;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		generatedSep[3] = (byte)':';
		generatedLen_min[3] = 16;
		generatedLen_max[3] = 256;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		u8[] tmp_buf = new u8();
		int tmp_len;
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		salt.setSalt_iter(iter - 1)// salt;// salt
		u8 salt_pos = generatedBuf[2];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[2];
		.memset(tmp_buf, 0, );
		tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, salt_pos, salt_len, tmp_buf);
		if (tmp_len > 256) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt_buf = pbkdf2_sha256.getSalt_buf();
		.memcpy(generatedSalt_buf, tmp_buf, tmp_len);
		salt.setSalt_len(tmp_len);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_buf[4] = generatedSalt_iter// hash;// hash
		u8 hash_pos = generatedBuf[3];
		int hash_len = generatedLen[3];
		.memset(tmp_buf, 0, );
		tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hash_pos, hash_len, tmp_buf);
		if (tmp_len < 16) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		.memcpy(digest, tmp_buf, 16);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_64_constants.SHA512M_A;
			digest[1] -= sha2_64_constants.SHA512M_B;
			digest[2] -= sha2_64_constants.SHA512M_C;
			digest[3] -= sha2_64_constants.SHA512M_D;
			digest[4] -= sha2_64_constants.SHA512M_E;
			digest[5] -= sha2_64_constants.SHA512M_F;
			digest[6] -= sha2_64_constants.SHA512M_G;
			digest[7] -= sha2_64_constants.SHA512M_H;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		u8[] ascii_to_ebcdic = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_RACF;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 6;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 6;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 8;
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[2] = 2;
		generatedLen_max[2] = 16;
		generatedSep[2] = (byte)'$';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// salt
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// salt pc
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		u8 salt_buf_pc_ptr = (u8)generatedSalt_buf_pc;
		for (u32 i = 0;
		 i < generatedSalt_len; i++) {
			salt_buf_pc_ptr[i] = ascii_to_ebcdic[(int)salt_buf_ptr[i]];
		}
		for (u32 i = salt_len;
		 i < 8; i++) {
			salt_buf_pc_ptr[i] = -1024;
		}
		{ 
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[1] >> 4;
				t = t ^ generatedSalt_buf_pc[0];
				t = t & -1024;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
				t = t << 4;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[0] >> 16;
				t = t ^ generatedSalt_buf_pc[1];
				t = t & -1024;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
				t = t << 16;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[1] >> 2;
				t = t ^ generatedSalt_buf_pc[0];
				t = t & -1024;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
				t = t << 2;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[0] >> 8;
				t = t ^ generatedSalt_buf_pc[1];
				t = t & -1024;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
				t = t << 8;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[1] >> 1;
				t = t ^ generatedSalt_buf_pc[0];
				t = t & -1024;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
				t = t << 1;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
			}
			;
		}
		;
		generatedSalt_buf_pc[0] = ModernizedCProgram.rotl32(generatedSalt_buf_pc[0], -1024);
		generatedSalt_buf_pc[1] = ModernizedCProgram.rotl32(generatedSalt_buf_pc[1], -1024)// hash;// hash
		u8 hash_pos = generatedBuf[2];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		{ 
			{ 
				u32x t = new u32x();
				t = digest[1] >> 4;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 4;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 16;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 16;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 2;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 2;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 8;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 8;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 1;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 1;
				digest[1] = digest[1] ^ t;
			}
			;
		}
		;
		digest[0] = ModernizedCProgram.rotr32(digest[0], 29);
		digest[1] = ModernizedCProgram.rotr32(digest[1], 29);
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SHA1AIX;
		Object generatedLen = token.getLen();
		generatedLen[0] = 7;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 2;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 2;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[2] = 16;
		generatedLen_max[2] = 48;
		generatedSep[2] = (byte)'$';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen[3] = 27;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		byte[] salt_iter = new byte[]{iter_pos[0], iter_pos[1], 0};
		Object generatedSalt_sign = salt.getSalt_sign();
		generatedSalt_sign[0] = ModernizedCProgram.hc_strtoul((byte)salt_iter, ((Object)0), 10);
		salt.setSalt_iter((-1024 << ModernizedCProgram.hc_strtoul((byte)salt_iter, ((Object)0), 10)) - 1);
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 hash_pos = generatedBuf[3];
		ModernizedCProgram.sha1aix_decode((u8)digest, hash_pos);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[8] = ModernizedCProgram.hex_to_u32(hash_pos + 64);
		digest[9] = ModernizedCProgram.hex_to_u32(hash_pos + 72);
		digest[10] = ModernizedCProgram.hex_to_u32(hash_pos + 80);
		digest[11] = ModernizedCProgram.hex_to_u32(hash_pos + 88);
		digest[12] = ModernizedCProgram.hex_to_u32(hash_pos + 96);
		digest[13] = ModernizedCProgram.hex_to_u32(hash_pos + 104);
		digest[14] = ModernizedCProgram.hex_to_u32(hash_pos + 112);
		digest[15] = ModernizedCProgram.hex_to_u32(hash_pos + 120);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		digest[8] = ModernizedCProgram.byte_swap_32(digest[8]);
		digest[9] = ModernizedCProgram.byte_swap_32(digest[9]);
		digest[10] = ModernizedCProgram.byte_swap_32(digest[10]);
		digest[11] = ModernizedCProgram.byte_swap_32(digest[11]);
		digest[12] = ModernizedCProgram.byte_swap_32(digest[12]);
		digest[13] = ModernizedCProgram.byte_swap_32(digest[13]);
		digest[14] = ModernizedCProgram.byte_swap_32(digest[14]);
		digest[15] = ModernizedCProgram.byte_swap_32(digest[15]);
		return (parser_rc.PARSER_OK);
		pkzip_t pkzip = (pkzip_t)esalt_buf;
		u32 digest = (u32)digest_buf;
		byte[] input = new byte[line_len + 1];
		input[line_len] = (byte)'\0';
		.memcpy(input, line_buf, line_len);
		byte saveptr = ((Object)0);
		byte p = .strtok_r(input, "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		if (.strncmp(p, ModernizedCProgram.SIGNATURE_PKZIP_V1, 7) != 0 && .strncmp(p, ModernizedCProgram.SIGNATURE_PKZIP_V2, 8) != 0) {
			return parser_rc.PARSER_SIGNATURE_UNMATCHED;
		} 
		pkzip.setVersion(1);
		if (.strlen(p) == 9) {
			pkzip.setVersion(2);
		} 
		byte[] sub = new byte[2];
		sub[0] = p[.strlen(p) - 1];
		sub[1] = (byte)'\0';
		pkzip.setHash_count(.atoi(sub));
		Object generatedHash_count = pkzip.getHash_count();
		// check here that the hash_count is valid for the attack typeif (generatedHash_count != 1) {
			return parser_rc.PARSER_HASH_VALUE;
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		pkzip.setChecksum_size(.atoi(p));
		Object generatedChecksum_size = pkzip.getChecksum_size();
		if (generatedChecksum_size != 1 && generatedChecksum_size != 2) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		pkzip_hash generatedHash = pkzip.getHash();
		generatedHash.setData_type_enum(.atoi(p));
		Object generatedData_type_enum = generatedHash.getData_type_enum();
		if (generatedData_type_enum > 3) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		generatedHash.setMagic_type_enum(.atoi(p));
		Object generatedCompressed_length = generatedHash.getCompressed_length();
		if (generatedData_type_enum > 1) {
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHash.setCompressed_length(.strtoul(p, ((Object)0), 16));
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHash.setUncompressed_length(.strtoul(p, ((Object)0), 16));
			if (generatedCompressed_length > (320 * 1024)) {
				return parser_rc.PARSER_TOKEN_LENGTH;
			} 
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			u32 crc32 = 0;
			.sscanf(p, "%x", ModernizedCProgram.crc32);
			generatedHash.setCrc32(ModernizedCProgram.crc32);
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHash.setOffset(.strtoul(p, ((Object)0), 16));
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			generatedHash.setAdditional_offset(.strtoul(p, ((Object)0), 16));
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		generatedHash.setCompression_type(.atoi(p));
		Object generatedCompression_type = generatedHash.getCompression_type();
		if (generatedCompression_type != 8) {
			return parser_rc.PARSER_PKZIP_CT_UNMATCHED;
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		generatedHash.setData_length(.strtoul(p, ((Object)0), 16));
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		u16 checksum_from_crc = 0;
		.sscanf(p, "%hx", checksum_from_crc);
		generatedHash.setChecksum_from_crc(checksum_from_crc);
		Object generatedVersion = pkzip.getVersion();
		Object generatedChecksum_from_crc = generatedHash.getChecksum_from_crc();
		if (generatedVersion == 2) {
			p = .strtok_r(((Object)0), "*", saveptr);
			if (p == ((Object)0)) {
				return parser_rc.PARSER_HASH_LENGTH;
			} 
			u16 checksum_from_timestamp = 0;
			.sscanf(p, "%hx", checksum_from_timestamp);
			generatedHash.setChecksum_from_timestamp(checksum_from_timestamp);
		} else {
				generatedHash.setChecksum_from_timestamp(generatedChecksum_from_crc);
		} 
		p = .strtok_r(((Object)0), "*", saveptr);
		if (p == ((Object)0)) {
			return parser_rc.PARSER_HASH_LENGTH;
		} 
		Object generatedData = generatedHash.getData();
		ModernizedCProgram.hex_to_binary(p, .strlen(p), (byte)(generatedData));
		Object generatedSalt_buf = salt.getSalt_buf();
		// fake salt// fake saltgeneratedSalt_buf[0] = generatedData[0];
		generatedSalt_buf[1] = generatedData[1];
		generatedSalt_buf[2] = generatedData[2];
		generatedSalt_buf[3] = generatedData[3];
		salt.setSalt_len(16);
		Object generatedCrc32 = generatedHash.getCrc32();
		digest[0] = generatedCrc32;
		digest[1] = 0;
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MSSQL2012;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen[1] = 8;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[2] = 128;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[2];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_64_constants.SHA512M_A;
			digest[1] -= sha2_64_constants.SHA512M_B;
			digest[2] -= sha2_64_constants.SHA512M_C;
			digest[3] -= sha2_64_constants.SHA512M_D;
			digest[4] -= sha2_64_constants.SHA512M_E;
			digest[5] -= sha2_64_constants.SHA512M_F;
			digest[6] -= sha2_64_constants.SHA512M_G;
			digest[7] -= sha2_64_constants.SHA512M_H;
		} 
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SHA256CRYPT;
		Object generatedLen = token.getLen();
		generatedLen[0] = 3;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 16;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_OPTIONAL_ROUNDS;
		generatedLen[2] = 43;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_SHA256CRYPT);
		int generatedOpt_len = token.getOpt_len();
		Object generatedOpt_buf = token.getOpt_buf();
		if (generatedOpt_len != -1) {
			salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)generatedOpt_buf + 7, ((Object)0), 10));
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 hash_pos = generatedBuf[2];
		ModernizedCProgram.sha256crypt_decode((u8)digest, hash_pos);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[8] = ModernizedCProgram.hex_to_u32(hash_pos + 64);
		digest[9] = ModernizedCProgram.hex_to_u32(hash_pos + 72);
		digest[10] = ModernizedCProgram.hex_to_u32(hash_pos + 80);
		digest[11] = ModernizedCProgram.hex_to_u32(hash_pos + 88);
		digest[12] = ModernizedCProgram.hex_to_u32(hash_pos + 96);
		digest[13] = ModernizedCProgram.hex_to_u32(hash_pos + 104);
		digest[14] = ModernizedCProgram.hex_to_u32(hash_pos + 112);
		digest[15] = ModernizedCProgram.hex_to_u32(hash_pos + 120);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_1K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		krb5asrep_t krb5asrep = (krb5asrep_t)esalt_buf;
		token_t token = new token_t();
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_KRB5ASREP;
		Object generatedLen = token.getLen();
		generatedLen[0] = .strlen(ModernizedCProgram.SIGNATURE_KRB5ASREP);
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE/**
		   * $krb5asrep$23$user_principal_name:checksum$edata2
		   */;
		if (line_len < 16) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		byte upn_info_start = (byte)line_buf + .strlen(ModernizedCProgram.SIGNATURE_KRB5ASREP);
		byte upn_info_stop = .strchr((byte)upn_info_start, (byte)':');
		if (upn_info_stop == ((Object)0)) {
			return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
		} 
		// we want the : char included// we want the : char includedupn_info_stop++;
		int upn_info_len = upn_info_stop - upn_info_start;
		token.setToken_cnt(4);
		generatedLen[1] = upn_info_len;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		Object generatedSep = token.getSep();
		generatedSep[2] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[2] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[2] = 32;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 64;
		generatedLen_max[3] = 40960;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 checksum_pos = generatedBuf[2];
		u8 data_pos = generatedBuf[3];
		int data_len = generatedLen[3];
		Object generatedAccount_info = krb5asrep.getAccount_info();
		.memcpy(generatedAccount_info, generatedBuf[1], generatedLen[1]);
		Object generatedChecksum = krb5asrep.getChecksum();
		generatedChecksum[0] = ModernizedCProgram.hex_to_u32(checksum_pos + 0);
		generatedChecksum[1] = ModernizedCProgram.hex_to_u32(checksum_pos + 8);
		generatedChecksum[2] = ModernizedCProgram.hex_to_u32(checksum_pos + 16);
		generatedChecksum[3] = ModernizedCProgram.hex_to_u32(checksum_pos + 24);
		Object generatedEdata2 = krb5asrep.getEdata2();
		u8 edata_ptr = (u8)generatedEdata2;
		for (int i = 0;
		 i < data_len; i += 2) {
			u8 p0 = data_pos[i + 0];
			u8 p1 = data_pos[i + 1];
			edata_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		krb5asrep.setEdata2_len(data_len / 2);
		edata_ptr++ = /* this is needed for hmac_md5 */-1024;
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedChecksum[0];
		generatedSalt_buf[1] = generatedChecksum[1];
		generatedSalt_buf[2] = generatedChecksum[2];
		generatedSalt_buf[3] = generatedChecksum[3];
		salt.setSalt_len(16);
		digest[0] = generatedChecksum[0];
		digest[1] = generatedChecksum[1];
		digest[2] = generatedChecksum[2];
		digest[3] = generatedChecksum[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 56;
		generatedLen_max[1] = 56;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MD5CRYPT;
		Object generatedLen = token.getLen();
		generatedLen[0] = 3;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 8;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_OPTIONAL_ROUNDS;
		generatedLen[2] = 22;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_MD5CRYPT);
		int generatedOpt_len = token.getOpt_len();
		Object generatedOpt_buf = token.getOpt_buf();
		if (generatedOpt_len != -1) {
			salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)generatedOpt_buf + 7, ((Object)0), 10));
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 hash_pos = generatedBuf[2];
		ModernizedCProgram.md5crypt_decode((u8)digest, hash_pos);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		office2013_t office2013 = (office2013_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(8);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_OFFICE2013;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 8;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 8;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 4;
		generatedLen_max[1] = 4;
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 6;
		generatedLen_max[2] = 6;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 3;
		generatedLen_max[3] = 3;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 2;
		generatedLen_max[4] = 2;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[5] = 32;
		generatedLen_max[5] = 32;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[6] = 32;
		generatedLen_max[6] = 32;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[7] = 64;
		generatedLen_max[7] = 64;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 spinCount_pos = generatedBuf[2];
		u8 keySize_pos = generatedBuf[3];
		u8 saltSize_pos = generatedBuf[4];
		u8 osalt_pos = generatedBuf[5];
		u8 encryptedVerifier_pos = generatedBuf[6];
		u8 encryptedVerifierHash_pos = generatedBuf[7];
		u32 version = ModernizedCProgram.hc_strtoul((byte)version_pos, ((Object)0), 10);
		u32 spinCount = ModernizedCProgram.hc_strtoul((byte)spinCount_pos, ((Object)0), 10);
		u32 keySize = ModernizedCProgram.hc_strtoul((byte)keySize_pos, ((Object)0), 10);
		u32 saltSize = ModernizedCProgram.hc_strtoul((byte)saltSize_pos, ((Object)0), 10);
		if (version != 2013) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (spinCount != 100000) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (keySize != 256) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (saltSize != 16) {
			return (parser_rc.PARSER_SALT_VALUE/**
			   * salt
			   */);
		} 
		salt.setSalt_len(16);
		salt.setSalt_iter(spinCount);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(osalt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(osalt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(osalt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(osalt_pos + 24);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3/**
		   * esalt
		   */]);
		Object generatedEncryptedVerifier = office2013.getEncryptedVerifier();
		generatedEncryptedVerifier[0] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 0);
		generatedEncryptedVerifier[1] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 8);
		generatedEncryptedVerifier[2] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 16);
		generatedEncryptedVerifier[3] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 24);
		generatedEncryptedVerifier[0] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[0]);
		generatedEncryptedVerifier[1] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[1]);
		generatedEncryptedVerifier[2] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[2]);
		generatedEncryptedVerifier[3] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[3]);
		Object generatedEncryptedVerifierHash = office2013.getEncryptedVerifierHash();
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 0);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 8);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 16);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 24);
		generatedEncryptedVerifierHash[4] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 32);
		generatedEncryptedVerifierHash[5] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 40);
		generatedEncryptedVerifierHash[6] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 48);
		generatedEncryptedVerifierHash[7] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 56);
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[0]);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[1]);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[2]);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[3]);
		generatedEncryptedVerifierHash[4] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[4]);
		generatedEncryptedVerifierHash[5] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[5]);
		generatedEncryptedVerifierHash[6] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[6]);
		generatedEncryptedVerifierHash[7] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[7/**
		   * digest
		   */]);
		digest[0] = generatedEncryptedVerifierHash[0];
		digest[1] = generatedEncryptedVerifierHash[1];
		digest[2] = generatedEncryptedVerifierHash[2];
		digest[3] = generatedEncryptedVerifierHash[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pbkdf2_sha256_t pbkdf2_sha256 = (pbkdf2_sha256_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(5);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PASSLIB_PBKDF2_SHA256;
		Object generatedSep = token.getSep();
		// the hash starts with a $// the hash starts with a $generatedSep[0] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 0;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[1] = (byte)'$';
		generatedLen_min[1] = 13;
		generatedLen_max[1] = 13;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		// iterations in decimal representation// iterations in decimal representationgeneratedSep[2] = (byte)'$';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 6;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// salt in alternate base64 repretentation// salt in alternate base64 repretentationgeneratedSep[3] = (byte)'$';
		generatedLen_min[3] = 0;
		generatedLen_max[3] = 256;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		// payload in alternate base64 representanion// payload in alternate base64 representaniongeneratedSep[4] = (byte)'$';
		generatedLen_min[4] = ModernizedCProgram.HASH_LEN_B64;
		generatedLen_max[4] = ModernizedCProgram.HASH_LEN_B64;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		// iteru8 iter_pos = generatedBuf[2];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10) - 1);
		// base64 decode saltu8 salt_pos = generatedBuf[3];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[3];
		u8[] tmp_buf = new u8[]{0};
		size_t salt_len_decoded = ModernizedCProgram.base64_decode(ModernizedCProgram.ab64_to_int, (u8)salt_pos, salt_len, tmp_buf);
		Object generatedSalt_buf = pbkdf2_sha256.getSalt_buf();
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		.memcpy(salt_buf_ptr, tmp_buf, salt_len_decoded);
		.memcpy(generatedSalt_buf, salt_buf_ptr, salt_len_decoded);
		salt.setSalt_len(salt_len_decoded);
		// base64 decode hashu8 hash_pos = generatedBuf[4];
		int hash_len = generatedLen[4];
		ModernizedCProgram.base64_decode(ModernizedCProgram.ab64_to_int, (u8)hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, ModernizedCProgram.HASH_LEN_RAW);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		office2010_t office2010 = (office2010_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(8);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_OFFICE2010;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 8;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 8;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 4;
		generatedLen_max[1] = 4;
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 6;
		generatedLen_max[2] = 6;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 3;
		generatedLen_max[3] = 3;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 2;
		generatedLen_max[4] = 2;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[5] = 32;
		generatedLen_max[5] = 32;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[6] = 32;
		generatedLen_max[6] = 32;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[7] = 64;
		generatedLen_max[7] = 64;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 spinCount_pos = generatedBuf[2];
		u8 keySize_pos = generatedBuf[3];
		u8 saltSize_pos = generatedBuf[4];
		u8 osalt_pos = generatedBuf[5];
		u8 encryptedVerifier_pos = generatedBuf[6];
		u8 encryptedVerifierHash_pos = generatedBuf[7];
		u32 version = ModernizedCProgram.hc_strtoul((byte)version_pos, ((Object)0), 10);
		u32 spinCount = ModernizedCProgram.hc_strtoul((byte)spinCount_pos, ((Object)0), 10);
		u32 keySize = ModernizedCProgram.hc_strtoul((byte)keySize_pos, ((Object)0), 10);
		u32 saltSize = ModernizedCProgram.hc_strtoul((byte)saltSize_pos, ((Object)0), 10);
		if (version != 2010) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (spinCount != 100000) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (keySize != 128) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (saltSize != 16) {
			return (parser_rc.PARSER_SALT_VALUE/**
			   * salt
			   */);
		} 
		salt.setSalt_len(16);
		salt.setSalt_iter(spinCount);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(osalt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(osalt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(osalt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(osalt_pos + 24);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3/**
		   * esalt
		   */]);
		Object generatedEncryptedVerifier = office2010.getEncryptedVerifier();
		generatedEncryptedVerifier[0] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 0);
		generatedEncryptedVerifier[1] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 8);
		generatedEncryptedVerifier[2] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 16);
		generatedEncryptedVerifier[3] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 24);
		generatedEncryptedVerifier[0] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[0]);
		generatedEncryptedVerifier[1] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[1]);
		generatedEncryptedVerifier[2] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[2]);
		generatedEncryptedVerifier[3] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifier[3]);
		Object generatedEncryptedVerifierHash = office2010.getEncryptedVerifierHash();
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 0);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 8);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 16);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 24);
		generatedEncryptedVerifierHash[4] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 32);
		generatedEncryptedVerifierHash[5] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 40);
		generatedEncryptedVerifierHash[6] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 48);
		generatedEncryptedVerifierHash[7] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 56);
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[0]);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[1]);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[2]);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[3]);
		generatedEncryptedVerifierHash[4] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[4]);
		generatedEncryptedVerifierHash[5] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[5]);
		generatedEncryptedVerifierHash[6] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[6]);
		generatedEncryptedVerifierHash[7] = ModernizedCProgram.byte_swap_32(generatedEncryptedVerifierHash[7/**
		   * digest
		   */]);
		digest[0] = generatedEncryptedVerifierHash[0];
		digest[1] = generatedEncryptedVerifierHash[1];
		digest[2] = generatedEncryptedVerifierHash[2];
		digest[3] = generatedEncryptedVerifierHash[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		krb5tgs_t krb5tgs = (krb5tgs_t)esalt_buf;
		token_t token = new token_t();
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_KRB5TGS;
		Object generatedLen = token.getLen();
		generatedLen[0] = 12;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE/**
		   * $krb5tgs$23$checksum$edata2
		   * $krb5tgs$23$*user*realm*spn*$checksum$edata2
		   */;
		if (line_len < 16) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSep = token.getSep();
		Object generatedLen_min = token.getLen_min();
		Object generatedLen_max = token.getLen_max();
		if (line_buf[12] == (byte)'*') {
			byte account_info_start = (byte)line_buf + 12;
			byte account_info_stop = .strchr((byte)account_info_start + 1, (byte)'*');
			if (account_info_stop == ((Object)0)) {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
			account_info_stop++;
			account_info_stop++;
			int account_info_len = account_info_stop - account_info_start;
			token.setToken_cnt(4);
			generatedLen[1] = account_info_len;
			generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
			generatedSep[2] = (byte)'$';
			generatedLen_min[2] = 32;
			generatedLen_max[2] = 32;
			generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[3] = (byte)'$';
			generatedLen_min[3] = 64;
			generatedLen_max[3] = 40960;
			generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		} else {
				token.setToken_cnt(3);
				generatedSep[1] = (byte)'$';
				generatedLen_min[1] = 32;
				generatedLen_max[1] = 32;
				generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
				generatedSep[2] = (byte)'$';
				generatedLen_min[2] = 64;
				generatedLen_max[2] = 40960;
				generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		u8 checksum_pos = new u8();
		u8 data_pos = new u8();
		int data_len;
		Object generatedBuf = token.getBuf();
		Object generatedAccount_info = krb5tgs.getAccount_info();
		if (line_buf[12] == (byte)'*') {
			checksum_pos = generatedBuf[2];
			data_pos = generatedBuf[3];
			data_len = generatedLen[3];
			.memcpy(generatedAccount_info, generatedBuf[1], generatedLen[1]);
		} else {
				checksum_pos = generatedBuf[1];
				data_pos = generatedBuf[2];
				data_len = generatedLen[2];
				generatedAccount_info[0] = 0;
		} 
		Object generatedChecksum = krb5tgs.getChecksum();
		generatedChecksum[0] = ModernizedCProgram.hex_to_u32(checksum_pos + 0);
		generatedChecksum[1] = ModernizedCProgram.hex_to_u32(checksum_pos + 8);
		generatedChecksum[2] = ModernizedCProgram.hex_to_u32(checksum_pos + 16);
		generatedChecksum[3] = ModernizedCProgram.hex_to_u32(checksum_pos + 24);
		Object generatedEdata2 = krb5tgs.getEdata2();
		u8 edata_ptr = (u8)generatedEdata2;
		for (int i = 0;
		 i < data_len; i += 2) {
			u8 p0 = data_pos[i + 0];
			u8 p1 = data_pos[i + 1];
			edata_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		krb5tgs.setEdata2_len(data_len / 2);
		edata_ptr++ = /* this is needed for hmac_md5 */-1024;
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedChecksum[0];
		generatedSalt_buf[1] = generatedChecksum[1];
		generatedSalt_buf[2] = generatedChecksum[2];
		generatedSalt_buf[3] = generatedChecksum[3];
		salt.setSalt_len(16);
		digest[0] = generatedChecksum[0];
		digest[1] = generatedChecksum[1];
		digest[2] = generatedChecksum[2];
		digest[3] = generatedChecksum[3];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 24;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 24;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(2);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PHPASS1;
		generatedSignatures_buf[1] = ModernizedCProgram.SIGNATURE_PHPASS2;
		Object generatedLen = token.getLen();
		generatedLen[0] = 3;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		generatedLen[2] = 8;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		generatedLen[3] = 22;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedSalt_sign = salt.getSalt_sign();
		.memcpy((u8)generatedSalt_sign, line_buf, 4);
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u32 salt_iter = -1024 << ModernizedCProgram.itoa64_to_int(iter_pos[0]);
		if (salt_iter > -1024) {
			return (parser_rc.PARSER_SALT_ITERATION);
		} 
		salt.setSalt_iter(salt_iter);
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy((u8)generatedSalt_buf, salt_pos, salt_len);
		salt.setSalt_len(salt_len);
		u8 hash_pos = generatedBuf[3];
		ModernizedCProgram.phpass_decode((u8)digest, hash_pos);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pbkdf2_sha1_t pbkdf2_sha1 = (pbkdf2_sha1_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PBKDF2_SHA1;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 4;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 4;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)':';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 6;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)':';
		generatedLen_min[2] = ((0 * 8) / 6) + 0;
		generatedLen_max[2] = ((256 * 8) / 6) + 3;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		generatedSep[3] = (byte)':';
		generatedLen_min[3] = 16;
		generatedLen_max[3] = 256;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		u8[] tmp_buf = new u8();
		int tmp_len;
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_pos = generatedBuf[1];
		u32 iter = ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10);
		salt.setSalt_iter(iter - 1)// salt;// salt
		u8 salt_pos = generatedBuf[2];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[2];
		.memset(tmp_buf, 0, );
		tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, salt_pos, salt_len, tmp_buf);
		if (tmp_len > 256) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt_buf = pbkdf2_sha1.getSalt_buf();
		.memcpy(generatedSalt_buf, tmp_buf, tmp_len);
		salt.setSalt_len(tmp_len);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_buf[4] = generatedSalt_iter// hash;// hash
		u8 hash_pos = generatedBuf[3];
		int hash_len = generatedLen[3];
		.memset(tmp_buf, 0, );
		tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hash_pos, hash_len, tmp_buf);
		if (tmp_len < 16) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		.memcpy(digest, tmp_buf, 16);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 8;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 8;
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 8;
		generatedLen_max[1] = 8;
		generatedSep[1] = hashconfig.getSeparator();
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// digest
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32((u8)hash_pos[0]);
		digest[1] = 0;
		digest[2] = 0;
		digest[3] = 0// salt;// salt
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32((u8)salt_pos[0]);
		// 4// 4salt.setSalt_len(salt_len / 2);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		krb5pa_18_t krb5pa = (krb5pa_18_t)esalt_buf;
		token_t token = new token_t();
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_KRB5PA;
		Object generatedLen = token.getLen();
		generatedLen[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE/**
		   * $krb5pa$18$*user*realm*$enc_timestamp+checksum
		   */;
		// assume no signature foundif (line_len < 11) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// assume $krb5pa$18$user$realm$enc_timestamp+checksum// assume $krb5pa$18$user$realm$enc_timestamp+checksumtoken.setToken_cnt(4);
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 512;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 512;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 104;
		generatedLen_max[3] = 112;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		u8 user_pos = new u8();
		u8 domain_pos = new u8();
		u8 data_pos = new u8();
		u8 checksum_pos = new u8();
		int user_len;
		int domain_len;
		int data_len;
		int account_info_len;
		Object generatedBuf = token.getBuf();
		user_pos = generatedBuf[1];
		user_len = generatedLen[1];
		Object generatedUser = krb5pa.getUser();
		.memcpy(generatedUser, user_pos, user_len);
		domain_pos = generatedBuf[2];
		domain_len = generatedLen[2];
		Object generatedDomain = krb5pa.getDomain();
		.memcpy(generatedDomain, domain_pos, domain_len);
		data_pos = generatedBuf[3];
		data_len = generatedLen[3];
		account_info_len = generatedLen[2] + generatedLen[1];
		Object generatedAccount_info = krb5pa.getAccount_info();
		u8 account_info_ptr = (u8)generatedAccount_info;
		// domain must be uppercaseu8[] domain = new u8();
		.memcpy(domain, domain_pos, domain_len);
		ModernizedCProgram.uppercase(domain, domain_len);
		.memcpy(account_info_ptr, domain, domain_len);
		.memcpy(account_info_ptr + domain_len, user_pos, user_len);
		krb5pa.setAccount_info_len(account_info_len);
		// Split checksum// Split checksumchecksum_pos = data_pos + data_len - 24;
		data_len = data_len - 24;
		Object generatedChecksum = krb5pa.getChecksum();
		// hmac-sha1 is reduced to 12 bytes// hmac-sha1 is reduced to 12 bytesgeneratedChecksum[0] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 0));
		generatedChecksum[1] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 8));
		generatedChecksum[2] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 16));
		Object generatedEnc_timestamp = krb5pa.getEnc_timestamp();
		u8 edata_ptr = (u8)generatedEnc_timestamp;
		for (int i = 0;
		 i < data_len; i += 2) {
			u8 p0 = data_pos[i + 0];
			u8 p1 = data_pos[i + 1];
			edata_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		krb5pa.setEnc_timestamp_len(data_len / 2);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedChecksum[0];
		generatedSalt_buf[1] = generatedChecksum[1];
		generatedSalt_buf[2] = generatedChecksum[2];
		salt.setSalt_iter(4096 - 1);
		digest[0] = generatedChecksum[0];
		digest[1] = generatedChecksum[1];
		digest[2] = generatedChecksum[2];
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 56;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 56;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA224M_A;
			digest[1] -= sha2_32_constants.SHA224M_B;
			digest[2] -= sha2_32_constants.SHA224M_C;
			digest[3] -= sha2_32_constants.SHA224M_D;
			digest[4] -= sha2_32_constants.SHA224M_E;
			digest[5] -= sha2_32_constants.SHA224M_F;
			digest[6] -= sha2_32_constants.SHA224M_G;
		} 
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		int hash_len = generatedLen[0];
		if (hash_len != 64) {
			return (parser_rc.PARSER_GLOBAL_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_655331);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_655331);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		token.setSignatures_cnt(2);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SSHA1B64_lower;
		generatedSignatures_buf[1] = ModernizedCProgram.SIGNATURE_SSHA1B64_upper;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = (((20 + 0) * 8) / 6) + 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = (((20 + 256) * 8) / 6) + 3;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hashsalt_pos = generatedBuf[1];
		int hashsalt_len = generatedLen[1];
		u8[] tmp_buf = new u8[]{0};
		int tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hashsalt_pos, hashsalt_len, tmp_buf);
		if (tmp_len < 20) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		u8 hash_pos = tmp_buf;
		.memcpy(digest, hash_pos, 20);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		// saltu8 salt_pos = tmp_buf + 20;
		int salt_len = tmp_len - 20;
		salt.setSalt_len(salt_len);
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy(generatedSalt_buf, salt_pos, salt_len);
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_ADD80) {
			u8 ptr = (u8)generatedSalt_buf;
			ptr[salt_len] = -1024;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_1K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_2K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MYWALLET;
		Object generatedLen = token.getLen();
		generatedLen[0] = 12;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 6;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 64;
		generatedLen_max[2] = 65536;
		generatedSep[2] = (byte)'$';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer/**
			   * salt
			   */);
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(salt_pos + 24);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3])// this is actually the CT, which is also the hash later (if matched);// this is actually the CT, which is also the hash later (if matched)
		generatedSalt_buf[4] = ModernizedCProgram.hex_to_u32(salt_pos + 32);
		generatedSalt_buf[5] = ModernizedCProgram.hex_to_u32(salt_pos + 40);
		generatedSalt_buf[6] = ModernizedCProgram.hex_to_u32(salt_pos + 48);
		generatedSalt_buf[7] = ModernizedCProgram.hex_to_u32(salt_pos + 56);
		generatedSalt_buf[4] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[4]);
		generatedSalt_buf[5] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[5]);
		generatedSalt_buf[6] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[6]);
		generatedSalt_buf[7] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[7]);
		// note we need to fix this to 16 in kernel// note we need to fix this to 16 in kernelsalt.setSalt_len(32);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_MYWALLET - 1/**
		   * digest buf
		   */);
		digest[0] = generatedSalt_buf[4];
		digest[1] = generatedSalt_buf[5];
		digest[2] = generatedSalt_buf[6];
		digest[3] = generatedSalt_buf[7];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen = token.getLen();
		generatedLen[0] = 8;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[1] = 40;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[0];
		int salt_len = generatedLen[0];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		bsp_t bsp = (bsp_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 80;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 80;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		u8[] tmp_buf = new u8();
		Object generatedBuf = token.getBuf();
		Object generatedLen = token.getLen();
		int tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, generatedBuf[0], generatedLen[0], (u8)tmp_buf);
		if (tmp_len != 59) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		Object generatedSignature = bsp.getSignature();
		.memcpy((byte)generatedSignature, tmp_buf + 0, 3);
		Object generatedDigest = bsp.getDigest();
		.memcpy((byte)generatedDigest, tmp_buf + 3, 32);
		Object generatedSalt = bsp.getSalt();
		.memcpy((byte)generatedSalt, tmp_buf + 35, 16);
		Object generatedIter = bsp.getIter();
		.memcpy((byte)generatedIter, tmp_buf + 51, 4);
		Object generatedCrc32 = bsp.getCrc32();
		.memcpy((byte)generatedCrc32, tmp_buf + 55, 4)// version;// version
		if (generatedSignature[0] != (byte)'b') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		if (generatedSignature[1] != (byte)'s') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		if (generatedSignature[2] != (byte)':') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		// digest
		digest[0] = ModernizedCProgram.byte_swap_32(generatedDigest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(generatedDigest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(generatedDigest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(generatedDigest[3])// salt;// salt
		u8 ptr = (u8)generatedSalt;
		Object generatedSalt_buf = salt.getSalt_buf();
		u8 uuid = (u8)generatedSalt_buf;
		int uuid_len = 0;
		ModernizedCProgram.u8_to_hex(ptr[0], uuid + uuid_len);
		uuid_len += 2;
		ModernizedCProgram.u8_to_hex(ptr[1], uuid + uuid_len);
		uuid_len += 2;
		ModernizedCProgram.u8_to_hex(ptr[2], uuid + uuid_len);
		uuid_len += 2;
		ModernizedCProgram.u8_to_hex(ptr[3], uuid + uuid_len);
		uuid_len += 2;
		uuid[uuid_len] = (byte)'-';
		uuid_len += 1;
		ModernizedCProgram.u8_to_hex(ptr[4], uuid + uuid_len);
		uuid_len += 2;
		ModernizedCProgram.u8_to_hex(ptr[5], uuid + uuid_len);
		uuid_len += 2;
		uuid[uuid_len] = (byte)'-';
		uuid_len += 1;
		ModernizedCProgram.u8_to_hex(ptr[6], uuid + uuid_len);
		uuid_len += 2;
		ModernizedCProgram.u8_to_hex(ptr[7], uuid + uuid_len);
		uuid_len += 2;
		uuid[uuid_len] = (byte)'-';
		uuid_len += 1;
		ModernizedCProgram.u8_to_hex(ptr[8], uuid + uuid_len);
		uuid_len += 2;
		ModernizedCProgram.u8_to_hex(ptr[9], uuid + uuid_len);
		uuid_len += 2;
		uuid[uuid_len] = (byte)'-';
		uuid_len += 1;
		ModernizedCProgram.u8_to_hex(ptr[10], uuid + uuid_len);
		uuid_len += 2;
		ModernizedCProgram.u8_to_hex(ptr[11], uuid + uuid_len);
		uuid_len += 2;
		ModernizedCProgram.u8_to_hex(ptr[12], uuid + uuid_len);
		uuid_len += 2;
		ModernizedCProgram.u8_to_hex(ptr[13], uuid + uuid_len);
		uuid_len += 2;
		ModernizedCProgram.u8_to_hex(ptr[14], uuid + uuid_len);
		uuid_len += 2;
		ModernizedCProgram.u8_to_hex(ptr[15], uuid + uuid_len);
		uuid_len += 2;
		uuid[uuid_len] = 0;
		salt.setSalt_len(36);
		salt.setSalt_iter(generatedIter - 1);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MD5APR1;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 8;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_OPTIONAL_ROUNDS;
		generatedLen[2] = 22;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_MD5CRYPT);
		int generatedOpt_len = token.getOpt_len();
		Object generatedOpt_buf = token.getOpt_buf();
		if (generatedOpt_len != -1) {
			salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)generatedOpt_buf + 7, ((Object)0), 10));
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 hash_pos = generatedBuf[2];
		ModernizedCProgram.md5crypt_decode((u8)digest, hash_pos);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		odf11_t odf11 = (odf11_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(12);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ODF;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 5;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 5;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 1;
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 4;
		generatedLen_max[3] = 6;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 2;
		generatedLen_max[4] = 2;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[5] = 40;
		generatedLen_max[5] = 40;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[6] = 1;
		generatedLen_max[6] = 1;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[7] = 16;
		generatedLen_max[7] = 16;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[8] = 2;
		generatedLen_max[8] = 2;
		generatedSep[8] = (byte)'*';
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[9] = 32;
		generatedLen_max[9] = 32;
		generatedSep[9] = (byte)'*';
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[10] = 1;
		generatedLen_max[10] = 1;
		generatedSep[10] = (byte)'*';
		generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		Object generatedLen = token.getLen();
		generatedLen[11] = 2048;
		generatedAttr[11] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 checksum = generatedBuf[5];
		u8 iv = generatedBuf[7];
		u8 salt_buf = generatedBuf[9];
		u8 encrypted_data = generatedBuf[11];
		u32 cipher_type = .strtol((byte)generatedBuf[1], ((Object)0), 10);
		u32 checksum_type = .strtol((byte)generatedBuf[2], ((Object)0), 10);
		u32 iterations = .strtol((byte)generatedBuf[3], ((Object)0), 10);
		u32 key_size = .strtol((byte)generatedBuf[4], ((Object)0), 10);
		u32 iv_len = .strtol((byte)generatedBuf[6], ((Object)0), 10);
		u32 salt_len = .strtol((byte)generatedBuf[8], ((Object)0), 10);
		u32 unused = .strtol((byte)generatedBuf[10], ((Object)0), 10);
		if (cipher_type != 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (checksum_type != 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (key_size != 16) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (iv_len != 8) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (salt_len != 16) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (unused != 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		// esalt
		odf11.setIterations(iterations);
		Object generatedChecksum = odf11.getChecksum();
		generatedChecksum[0] = ModernizedCProgram.hex_to_u32(checksum[0]);
		generatedChecksum[1] = ModernizedCProgram.hex_to_u32(checksum[8]);
		generatedChecksum[2] = ModernizedCProgram.hex_to_u32(checksum[16]);
		generatedChecksum[3] = ModernizedCProgram.hex_to_u32(checksum[24]);
		generatedChecksum[4] = ModernizedCProgram.hex_to_u32(checksum[32]);
		Object generatedIv = odf11.getIv();
		generatedIv[0] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(iv[0]));
		generatedIv[1] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(iv[8]));
		Object generatedEncrypted_data = odf11.getEncrypted_data();
		for (int i = 0;
		int j = 0;
		 i < 256; ) {
			generatedEncrypted_data[i] = ModernizedCProgram.hex_to_u32(encrypted_data[j]);
			generatedEncrypted_data[i] = ModernizedCProgram.byte_swap_32(generatedEncrypted_data[i]);
		}
		// salt// saltsalt.setSalt_len(salt_len);
		salt.setSalt_iter(iterations - 1);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_buf[8]);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt_buf[16]);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(salt_buf[24]);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		generatedSalt_buf[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		generatedSalt_buf[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3/**
		   * digest
		   */]);
		digest[0] = ModernizedCProgram.byte_swap_32(generatedChecksum[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(generatedChecksum[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(generatedChecksum[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(generatedChecksum[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(generatedChecksum[4]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 16;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 16;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.itoa64_to_int(hash_pos[0]) << 0 | ModernizedCProgram.itoa64_to_int(hash_pos[1]) << 6 | ModernizedCProgram.itoa64_to_int(hash_pos[2]) << 12 | ModernizedCProgram.itoa64_to_int(hash_pos[3]) << 18;
		digest[1] = ModernizedCProgram.itoa64_to_int(hash_pos[4]) << 0 | ModernizedCProgram.itoa64_to_int(hash_pos[5]) << 6 | ModernizedCProgram.itoa64_to_int(hash_pos[6]) << 12 | ModernizedCProgram.itoa64_to_int(hash_pos[7]) << 18;
		digest[2] = ModernizedCProgram.itoa64_to_int(hash_pos[8]) << 0 | ModernizedCProgram.itoa64_to_int(hash_pos[9]) << 6 | ModernizedCProgram.itoa64_to_int(hash_pos[10]) << 12 | ModernizedCProgram.itoa64_to_int(hash_pos[11]) << 18;
		digest[3] = ModernizedCProgram.itoa64_to_int(hash_pos[12]) << 0 | ModernizedCProgram.itoa64_to_int(hash_pos[13]) << 6 | ModernizedCProgram.itoa64_to_int(hash_pos[14]) << 12 | ModernizedCProgram.itoa64_to_int(hash_pos[15]) << 18;
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		// store for encoder// store for encoderdigest[4] = digest[0];
		digest[5] = digest[1];
		digest[6] = digest[2];
		digest[7] = digest[3];
		digest[0] &=  -1024;
		digest[1] &=  -1024;
		digest[2] &=  -1024;
		digest[3] &=  -1024;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MS_DRSR;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 11;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 11;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)',';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen_min[1] = 20;
		generatedLen_max[1] = 20;
		generatedSep[1] = (byte)',';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 6;
		generatedSep[2] = (byte)',';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 64;
		generatedLen_max[3] = 64;
		generatedSep[3] = (byte)',';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// salt
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt_pos + 16) & -1024;
		generatedSalt_buf[3] = 0;
		salt.setSalt_len(salt_len / 2)// iter;// iter
		u8 iter_pos = generatedBuf[2];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10) - -1024)// hash;// hash
		u8 hash_pos = generatedBuf[3];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		keepass_t keepass = (keepass_t)esalt_buf;
		boolean is_keyfile_present = false;
		if (line_len < 128) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		if ((line_buf[line_len - (64 + 1 + 2 + 1 + 2)] == (byte)'*') && (line_buf[line_len - (64 + 1 + 2 + 1 + 1)] == (byte)'1') && (line_buf[line_len - (64 + 1 + 2 + 1 + 0)] == (byte)'*')) {
			is_keyfile_present = true;
		} 
		token_t token = new token_t();
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_KEEPASS;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 9;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)'*';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 8;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 1;
		generatedLen_max[3] = 3;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		if (line_len < 16) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 version = line_buf[10];
		if (version == (byte)'1') {
			token.setToken_cnt(11);
			generatedSep[4] = (byte)'*';
			generatedLen_min[4] = 32;
			generatedLen_max[4] = 32;
			generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[5] = (byte)'*';
			generatedLen_min[5] = 64;
			generatedLen_max[5] = 64;
			generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[6] = (byte)'*';
			generatedLen_min[6] = 32;
			generatedLen_max[6] = 32;
			generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[7] = (byte)'*';
			generatedLen_min[7] = 64;
			generatedLen_max[7] = 64;
			generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[8] = (byte)'*';
			generatedLen_min[8] = 1;
			generatedLen_max[8] = 1;
			generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
			generatedSep[9] = (byte)'*';
			generatedLen_min[9] = 1;
			generatedLen_max[9] = 6;
			generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
			generatedSep[10] = (byte)'*';
			generatedLen_min[10] = 2;
			generatedLen_max[10] = 600000;
			generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			if (is_keyfile_present == true) {
				token.setToken_cnt(14);
				generatedSep[11] = (byte)'*';
				generatedLen_min[11] = 1;
				generatedLen_max[11] = 1;
				generatedAttr[11] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
				generatedSep[12] = (byte)'*';
				generatedLen_min[12] = 2;
				generatedLen_max[12] = 2;
				generatedAttr[12] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
				generatedSep[13] = (byte)'*';
				generatedLen_min[13] = 64;
				generatedLen_max[13] = 64;
				generatedAttr[13] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			} 
		}  else if (version == (byte)'2') {
			token.setToken_cnt(9);
			generatedSep[4] = (byte)'*';
			generatedLen_min[4] = 64;
			generatedLen_max[4] = 64;
			generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[5] = (byte)'*';
			generatedLen_min[5] = 64;
			generatedLen_max[5] = 64;
			generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[6] = (byte)'*';
			generatedLen_min[6] = 32;
			generatedLen_max[6] = 32;
			generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[7] = (byte)'*';
			generatedLen_min[7] = 64;
			generatedLen_max[7] = 64;
			generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedSep[8] = (byte)'*';
			generatedLen_min[8] = 64;
			generatedLen_max[8] = 64;
			generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			if (is_keyfile_present == true) {
				token.setToken_cnt(12);
				generatedSep[9] = (byte)'*';
				generatedLen_min[9] = 1;
				generatedLen_max[9] = 1;
				generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
				generatedSep[10] = (byte)'*';
				generatedLen_min[10] = 2;
				generatedLen_max[10] = 2;
				generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
				generatedSep[11] = (byte)'*';
				generatedLen_min[11] = 64;
				generatedLen_max[11] = 64;
				generatedAttr[11] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
			} 
		} else {
				return (parser_rc.PARSER_SALT_VALUE);
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// version
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		keepass.setVersion(ModernizedCProgram.hc_strtoul((byte)version_pos, ((Object)0), 10))// iter;// iter
		u8 rounds_pos = generatedBuf[2];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)rounds_pos, ((Object)0), 10))// algo;// algo
		u8 algorithm_pos = generatedBuf[3];
		keepass.setAlgorithm(ModernizedCProgram.hc_strtoul((byte)algorithm_pos, ((Object)0), 10))// final_random_seed_pos;// final_random_seed_pos
		u8 final_random_seed_pos = generatedBuf[4];
		Object generatedFinal_random_seed = keepass.getFinal_random_seed();
		generatedFinal_random_seed[0] = ModernizedCProgram.hex_to_u32((u8)final_random_seed_pos[0]);
		generatedFinal_random_seed[1] = ModernizedCProgram.hex_to_u32((u8)final_random_seed_pos[8]);
		generatedFinal_random_seed[2] = ModernizedCProgram.hex_to_u32((u8)final_random_seed_pos[16]);
		generatedFinal_random_seed[3] = ModernizedCProgram.hex_to_u32((u8)final_random_seed_pos[24]);
		generatedFinal_random_seed[0] = ModernizedCProgram.byte_swap_32(generatedFinal_random_seed[0]);
		generatedFinal_random_seed[1] = ModernizedCProgram.byte_swap_32(generatedFinal_random_seed[1]);
		generatedFinal_random_seed[2] = ModernizedCProgram.byte_swap_32(generatedFinal_random_seed[2]);
		generatedFinal_random_seed[3] = ModernizedCProgram.byte_swap_32(generatedFinal_random_seed[3]);
		Object generatedVersion = keepass.getVersion();
		if (generatedVersion == 2) {
			generatedFinal_random_seed[4] = ModernizedCProgram.hex_to_u32((u8)final_random_seed_pos[32]);
			generatedFinal_random_seed[5] = ModernizedCProgram.hex_to_u32((u8)final_random_seed_pos[40]);
			generatedFinal_random_seed[6] = ModernizedCProgram.hex_to_u32((u8)final_random_seed_pos[48]);
			generatedFinal_random_seed[7] = ModernizedCProgram.hex_to_u32((u8)final_random_seed_pos[56]);
			generatedFinal_random_seed[4] = ModernizedCProgram.byte_swap_32(generatedFinal_random_seed[4]);
			generatedFinal_random_seed[5] = ModernizedCProgram.byte_swap_32(generatedFinal_random_seed[5]);
			generatedFinal_random_seed[6] = ModernizedCProgram.byte_swap_32(generatedFinal_random_seed[6]);
			generatedFinal_random_seed[7] = ModernizedCProgram.byte_swap_32(generatedFinal_random_seed[7]);
		} 
		// transf_random_seed_posu8 transf_random_seed_pos = generatedBuf[5];
		Object generatedTransf_random_seed = keepass.getTransf_random_seed();
		generatedTransf_random_seed[0] = ModernizedCProgram.hex_to_u32((u8)transf_random_seed_pos[0]);
		generatedTransf_random_seed[1] = ModernizedCProgram.hex_to_u32((u8)transf_random_seed_pos[8]);
		generatedTransf_random_seed[2] = ModernizedCProgram.hex_to_u32((u8)transf_random_seed_pos[16]);
		generatedTransf_random_seed[3] = ModernizedCProgram.hex_to_u32((u8)transf_random_seed_pos[24]);
		generatedTransf_random_seed[4] = ModernizedCProgram.hex_to_u32((u8)transf_random_seed_pos[32]);
		generatedTransf_random_seed[5] = ModernizedCProgram.hex_to_u32((u8)transf_random_seed_pos[40]);
		generatedTransf_random_seed[6] = ModernizedCProgram.hex_to_u32((u8)transf_random_seed_pos[48]);
		generatedTransf_random_seed[7] = ModernizedCProgram.hex_to_u32((u8)transf_random_seed_pos[56]);
		generatedTransf_random_seed[0] = ModernizedCProgram.byte_swap_32(generatedTransf_random_seed[0]);
		generatedTransf_random_seed[1] = ModernizedCProgram.byte_swap_32(generatedTransf_random_seed[1]);
		generatedTransf_random_seed[2] = ModernizedCProgram.byte_swap_32(generatedTransf_random_seed[2]);
		generatedTransf_random_seed[3] = ModernizedCProgram.byte_swap_32(generatedTransf_random_seed[3]);
		generatedTransf_random_seed[4] = ModernizedCProgram.byte_swap_32(generatedTransf_random_seed[4]);
		generatedTransf_random_seed[5] = ModernizedCProgram.byte_swap_32(generatedTransf_random_seed[5]);
		generatedTransf_random_seed[6] = ModernizedCProgram.byte_swap_32(generatedTransf_random_seed[6]);
		generatedTransf_random_seed[7] = ModernizedCProgram.byte_swap_32(generatedTransf_random_seed[7])// enc_iv_pos;// enc_iv_pos
		u8 enc_iv_pos = generatedBuf[6];
		Object generatedEnc_iv = keepass.getEnc_iv();
		generatedEnc_iv[0] = ModernizedCProgram.hex_to_u32((u8)enc_iv_pos[0]);
		generatedEnc_iv[1] = ModernizedCProgram.hex_to_u32((u8)enc_iv_pos[8]);
		generatedEnc_iv[2] = ModernizedCProgram.hex_to_u32((u8)enc_iv_pos[16]);
		generatedEnc_iv[3] = ModernizedCProgram.hex_to_u32((u8)enc_iv_pos[24]);
		generatedEnc_iv[0] = ModernizedCProgram.byte_swap_32(generatedEnc_iv[0]);
		generatedEnc_iv[1] = ModernizedCProgram.byte_swap_32(generatedEnc_iv[1]);
		generatedEnc_iv[2] = ModernizedCProgram.byte_swap_32(generatedEnc_iv[2]);
		generatedEnc_iv[3] = ModernizedCProgram.byte_swap_32(generatedEnc_iv[3]);
		u8 keyfile_pos = ((Object)0);
		Object generatedContents_hash = keepass.getContents_hash();
		Object generatedLen = token.getLen();
		Object generatedContents = keepass.getContents();
		Object generatedExpected_bytes = keepass.getExpected_bytes();
		if (generatedVersion == 1) {
			u8 contents_hash_pos = generatedBuf[7];
			generatedContents_hash[0] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[0]);
			generatedContents_hash[1] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[8]);
			generatedContents_hash[2] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[16]);
			generatedContents_hash[3] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[24]);
			generatedContents_hash[4] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[32]);
			generatedContents_hash[5] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[40]);
			generatedContents_hash[6] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[48]);
			generatedContents_hash[7] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[56]);
			generatedContents_hash[0] = ModernizedCProgram.byte_swap_32(generatedContents_hash[0]);
			generatedContents_hash[1] = ModernizedCProgram.byte_swap_32(generatedContents_hash[1]);
			generatedContents_hash[2] = ModernizedCProgram.byte_swap_32(generatedContents_hash[2]);
			generatedContents_hash[3] = ModernizedCProgram.byte_swap_32(generatedContents_hash[3]);
			generatedContents_hash[4] = ModernizedCProgram.byte_swap_32(generatedContents_hash[4]);
			generatedContents_hash[5] = ModernizedCProgram.byte_swap_32(generatedContents_hash[5]);
			generatedContents_hash[6] = ModernizedCProgram.byte_swap_32(generatedContents_hash[6]);
			generatedContents_hash[7] = ModernizedCProgram.byte_swap_32(generatedContents_hash[7]);
			u8 contents_pos = generatedBuf[10];
			int contents_len = generatedLen[10];
			keepass.setContents_len(contents_len / 2);
			for (int i = 0;
			int j = 0;
			 j < contents_len; ) {
				generatedContents[i] = ModernizedCProgram.hex_to_u32((u8)contents_pos[j]);
				generatedContents[i] = ModernizedCProgram.byte_swap_32(generatedContents[i]);
			}
			if (is_keyfile_present == true) {
				keyfile_pos = generatedBuf[13];
			} 
		}  else if (generatedVersion == 2) {
			u8 expected_bytes_pos = generatedBuf[7];
			generatedExpected_bytes[0] = ModernizedCProgram.hex_to_u32((u8)expected_bytes_pos[0]);
			generatedExpected_bytes[1] = ModernizedCProgram.hex_to_u32((u8)expected_bytes_pos[8]);
			generatedExpected_bytes[2] = ModernizedCProgram.hex_to_u32((u8)expected_bytes_pos[16]);
			generatedExpected_bytes[3] = ModernizedCProgram.hex_to_u32((u8)expected_bytes_pos[24]);
			generatedExpected_bytes[4] = ModernizedCProgram.hex_to_u32((u8)expected_bytes_pos[32]);
			generatedExpected_bytes[5] = ModernizedCProgram.hex_to_u32((u8)expected_bytes_pos[40]);
			generatedExpected_bytes[6] = ModernizedCProgram.hex_to_u32((u8)expected_bytes_pos[48]);
			generatedExpected_bytes[7] = ModernizedCProgram.hex_to_u32((u8)expected_bytes_pos[56]);
			generatedExpected_bytes[0] = ModernizedCProgram.byte_swap_32(generatedExpected_bytes[0]);
			generatedExpected_bytes[1] = ModernizedCProgram.byte_swap_32(generatedExpected_bytes[1]);
			generatedExpected_bytes[2] = ModernizedCProgram.byte_swap_32(generatedExpected_bytes[2]);
			generatedExpected_bytes[3] = ModernizedCProgram.byte_swap_32(generatedExpected_bytes[3]);
			generatedExpected_bytes[4] = ModernizedCProgram.byte_swap_32(generatedExpected_bytes[4]);
			generatedExpected_bytes[5] = ModernizedCProgram.byte_swap_32(generatedExpected_bytes[5]);
			generatedExpected_bytes[6] = ModernizedCProgram.byte_swap_32(generatedExpected_bytes[6]);
			generatedExpected_bytes[7] = ModernizedCProgram.byte_swap_32(generatedExpected_bytes[7]);
			u8 contents_hash_pos = generatedBuf[8];
			generatedContents_hash[0] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[0]);
			generatedContents_hash[1] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[8]);
			generatedContents_hash[2] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[16]);
			generatedContents_hash[3] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[24]);
			generatedContents_hash[4] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[32]);
			generatedContents_hash[5] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[40]);
			generatedContents_hash[6] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[48]);
			generatedContents_hash[7] = ModernizedCProgram.hex_to_u32((u8)contents_hash_pos[56]);
			generatedContents_hash[0] = ModernizedCProgram.byte_swap_32(generatedContents_hash[0]);
			generatedContents_hash[1] = ModernizedCProgram.byte_swap_32(generatedContents_hash[1]);
			generatedContents_hash[2] = ModernizedCProgram.byte_swap_32(generatedContents_hash[2]);
			generatedContents_hash[3] = ModernizedCProgram.byte_swap_32(generatedContents_hash[3]);
			generatedContents_hash[4] = ModernizedCProgram.byte_swap_32(generatedContents_hash[4]);
			generatedContents_hash[5] = ModernizedCProgram.byte_swap_32(generatedContents_hash[5]);
			generatedContents_hash[6] = ModernizedCProgram.byte_swap_32(generatedContents_hash[6]);
			generatedContents_hash[7] = ModernizedCProgram.byte_swap_32(generatedContents_hash[7]);
			if (is_keyfile_present == true) {
				keyfile_pos = generatedBuf[11];
			} 
		} 
		// contents_hash
		Object generatedKeyfile = keepass.getKeyfile();
		if (is_keyfile_present == true) {
			keepass.setKeyfile_len(32);
			generatedKeyfile[0] = ModernizedCProgram.hex_to_u32((u8)keyfile_pos[0]);
			generatedKeyfile[1] = ModernizedCProgram.hex_to_u32((u8)keyfile_pos[8]);
			generatedKeyfile[2] = ModernizedCProgram.hex_to_u32((u8)keyfile_pos[16]);
			generatedKeyfile[3] = ModernizedCProgram.hex_to_u32((u8)keyfile_pos[24]);
			generatedKeyfile[4] = ModernizedCProgram.hex_to_u32((u8)keyfile_pos[32]);
			generatedKeyfile[5] = ModernizedCProgram.hex_to_u32((u8)keyfile_pos[40]);
			generatedKeyfile[6] = ModernizedCProgram.hex_to_u32((u8)keyfile_pos[48]);
			generatedKeyfile[7] = ModernizedCProgram.hex_to_u32((u8)keyfile_pos[56]);
			generatedKeyfile[0] = ModernizedCProgram.byte_swap_32(generatedKeyfile[0]);
			generatedKeyfile[1] = ModernizedCProgram.byte_swap_32(generatedKeyfile[1]);
			generatedKeyfile[2] = ModernizedCProgram.byte_swap_32(generatedKeyfile[2]);
			generatedKeyfile[3] = ModernizedCProgram.byte_swap_32(generatedKeyfile[3]);
			generatedKeyfile[4] = ModernizedCProgram.byte_swap_32(generatedKeyfile[4]);
			generatedKeyfile[5] = ModernizedCProgram.byte_swap_32(generatedKeyfile[5]);
			generatedKeyfile[6] = ModernizedCProgram.byte_swap_32(generatedKeyfile[6]);
			generatedKeyfile[7] = ModernizedCProgram.byte_swap_32(generatedKeyfile[7]);
		} 
		if (generatedVersion == 1) {
			digest[0] = generatedContents_hash[0];
			digest[1] = generatedContents_hash[1];
			digest[2] = generatedContents_hash[2];
			digest[3] = generatedContents_hash[3];
		} else {
				digest[0] = generatedExpected_bytes[0];
				digest[1] = generatedExpected_bytes[1];
				digest[2] = generatedExpected_bytes[2];
				digest[3] = generatedExpected_bytes[3];
		} 
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedTransf_random_seed[0];
		generatedSalt_buf[1] = generatedTransf_random_seed[1];
		generatedSalt_buf[2] = generatedTransf_random_seed[2];
		generatedSalt_buf[3] = generatedTransf_random_seed[3];
		generatedSalt_buf[4] = generatedTransf_random_seed[4];
		generatedSalt_buf[5] = generatedTransf_random_seed[5];
		generatedSalt_buf[6] = generatedTransf_random_seed[6];
		generatedSalt_buf[7] = generatedTransf_random_seed[7];
		salt.setSalt_len(32);
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen = token.getLen();
		generatedLen[0] = 8;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[1] = 128;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_64_constants.SHA512M_A;
			digest[1] -= sha2_64_constants.SHA512M_B;
			digest[2] -= sha2_64_constants.SHA512M_C;
			digest[3] -= sha2_64_constants.SHA512M_D;
			digest[4] -= sha2_64_constants.SHA512M_E;
			digest[5] -= sha2_64_constants.SHA512M_F;
			digest[6] -= sha2_64_constants.SHA512M_G;
			digest[7] -= sha2_64_constants.SHA512M_H;
		} 
		u8 salt_pos = generatedBuf[0];
		int salt_len = generatedLen[0];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_DJANGOSHA1;
		Object generatedLen = token.getLen();
		generatedLen[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen[2] = 40;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[2];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_CISCO9;
		Object generatedLen = token.getLen();
		generatedLen[0] = 3;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 14;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 14;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen[2] = 43;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// salt is not encoded
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		.memcpy(salt_buf_ptr, salt_pos, salt_len);
		salt.setSalt_len(salt_len);
		salt.setSalt_iter(1);
		salt.setScrypt_N(16384);
		salt.setScrypt_r(1);
		salt.setScrypt_p(1)// base64 decode hash;// base64 decode hash
		u8 hash_pos = generatedBuf[2];
		int hash_len = generatedLen[2];
		u8[] tmp_buf = new u8[]{0};
		int tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.itoa64_to_int, hash_pos, hash_len, tmp_buf);
		if (tmp_len != 32) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		.memcpy(digest, tmp_buf, 32);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D/**
			   * This is a virtual salt. While the algorithm is basically not salted
			   * we can exploit the salt buffer to set the 0x80 and the w[14] value.
			   * This way we can save a special md5md5 kernel and reuse the one from vbull.
			   */;
		} 
		u8 zero = (u8)"";
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, zero, 0, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_327661);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(2048);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pdf_t pdf = (pdf_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(13);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PDF;
		Object generatedLen = token.getLen();
		generatedLen[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 2;
		generatedLen_max[3] = 2;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 1;
		generatedLen_max[4] = 6;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[5] = 1;
		generatedLen_max[5] = 1;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[6] = 2;
		generatedLen_max[6] = 2;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[7] = 32;
		generatedLen_max[7] = 32;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[8] = 2;
		generatedLen_max[8] = 2;
		generatedSep[8] = (byte)'*';
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[9] = 64;
		generatedLen_max[9] = 64;
		generatedSep[9] = (byte)'*';
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[10] = 2;
		generatedLen_max[10] = 2;
		generatedSep[10] = (byte)'*';
		generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[11] = 64;
		generatedLen_max[11] = 64;
		generatedSep[11] = (byte)':';
		generatedAttr[11] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[12] = 10;
		generatedLen_max[12] = 10;
		generatedSep[12] = (byte)'*';
		generatedAttr[12] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 V_pos = generatedBuf[1];
		u8 R_pos = generatedBuf[2];
		u8 bits_pos = generatedBuf[3];
		u8 P_pos = generatedBuf[4];
		u8 enc_md_pos = generatedBuf[5];
		u8 id_len_pos = generatedBuf[6];
		u8 id_buf_pos = generatedBuf[7];
		u8 u_len_pos = generatedBuf[8];
		u8 u_buf_pos = generatedBuf[9];
		u8 o_len_pos = generatedBuf[10];
		u8 o_buf_pos = generatedBuf[11];
		u8 rc4key_pos = generatedBuf[12];
		// validate data
		int V = .strtol((byte)V_pos, ((Object)0), 10);
		int R = .strtol((byte)R_pos, ((Object)0), 10);
		int P = .strtol((byte)P_pos, ((Object)0), 10);
		if (V != 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (R != 2) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int enc_md = .strtol((byte)enc_md_pos, ((Object)0), 10);
		if ((enc_md != 0) && (enc_md != 1)) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int id_len = .strtol((byte)id_len_pos, ((Object)0), 10);
		int u_len = .strtol((byte)u_len_pos, ((Object)0), 10);
		int o_len = .strtol((byte)o_len_pos, ((Object)0), 10);
		if (id_len != 16) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (u_len != 32) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (o_len != 32) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int bits = .strtol((byte)bits_pos, ((Object)0), 10);
		if (bits != 40) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		// copy data to esalt
		pdf.setV(V);
		pdf.setR(R);
		pdf.setP(P);
		pdf.setEnc_md(enc_md);
		Object generatedId_buf = pdf.getId_buf();
		generatedId_buf[0] = ModernizedCProgram.hex_to_u32(id_buf_pos + 0);
		generatedId_buf[1] = ModernizedCProgram.hex_to_u32(id_buf_pos + 8);
		generatedId_buf[2] = ModernizedCProgram.hex_to_u32(id_buf_pos + 16);
		generatedId_buf[3] = ModernizedCProgram.hex_to_u32(id_buf_pos + 24);
		pdf.setId_len(id_len);
		Object generatedU_buf = pdf.getU_buf();
		generatedU_buf[0] = ModernizedCProgram.hex_to_u32(u_buf_pos + 0);
		generatedU_buf[1] = ModernizedCProgram.hex_to_u32(u_buf_pos + 8);
		generatedU_buf[2] = ModernizedCProgram.hex_to_u32(u_buf_pos + 16);
		generatedU_buf[3] = ModernizedCProgram.hex_to_u32(u_buf_pos + 24);
		generatedU_buf[4] = ModernizedCProgram.hex_to_u32(u_buf_pos + 32);
		generatedU_buf[5] = ModernizedCProgram.hex_to_u32(u_buf_pos + 40);
		generatedU_buf[6] = ModernizedCProgram.hex_to_u32(u_buf_pos + 48);
		generatedU_buf[7] = ModernizedCProgram.hex_to_u32(u_buf_pos + 56);
		pdf.setU_len(u_len);
		Object generatedO_buf = pdf.getO_buf();
		generatedO_buf[0] = ModernizedCProgram.hex_to_u32(o_buf_pos + 0);
		generatedO_buf[1] = ModernizedCProgram.hex_to_u32(o_buf_pos + 8);
		generatedO_buf[2] = ModernizedCProgram.hex_to_u32(o_buf_pos + 16);
		generatedO_buf[3] = ModernizedCProgram.hex_to_u32(o_buf_pos + 24);
		generatedO_buf[4] = ModernizedCProgram.hex_to_u32(o_buf_pos + 32);
		generatedO_buf[5] = ModernizedCProgram.hex_to_u32(o_buf_pos + 40);
		generatedO_buf[6] = ModernizedCProgram.hex_to_u32(o_buf_pos + 48);
		generatedO_buf[7] = ModernizedCProgram.hex_to_u32(o_buf_pos + 56);
		pdf.setO_len(o_len);
		Object generatedRc4key = pdf.getRc4key();
		generatedRc4key[1] = 0;
		generatedRc4key[0] = 0;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[0]) << 28;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[1]) << 24;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[2]) << 20;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[3]) << 16;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[4]) << 12;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[5]) << 8;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[6]) << 4;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[7]) << 0;
		generatedRc4key[1] |=  ModernizedCProgram.hex_convert(rc4key_pos[8]) << 28;
		generatedRc4key[1] |=  ModernizedCProgram.hex_convert(rc4key_pos[9]) << 24;
		generatedRc4key[0] = ModernizedCProgram.byte_swap_32(generatedRc4key[0]);
		generatedRc4key[1] = ModernizedCProgram.byte_swap_32(generatedRc4key[1])// we use ID for salt, maybe needs to change, we will see...;// we use ID for salt, maybe needs to change, we will see...
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedId_buf[0];
		generatedSalt_buf[1] = generatedId_buf[1];
		generatedSalt_buf[2] = generatedId_buf[2];
		generatedSalt_buf[3] = generatedId_buf[3];
		generatedSalt_buf[4] = generatedU_buf[0];
		generatedSalt_buf[5] = generatedU_buf[1];
		generatedSalt_buf[6] = generatedO_buf[0];
		generatedSalt_buf[7] = generatedO_buf[1];
		int generatedId_len = pdf.getId_len();
		salt.setSalt_len(generatedId_len + 16);
		digest[0] = generatedRc4key[0];
		digest[1] = generatedRc4key[1];
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		blake2_t blake2 = (blake2_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_BLAKE2B;
		Object generatedLen = token.getLen();
		generatedLen[0] = 8;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen[1] = 128;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112)// Initialize BLAKE2 Params and State;// Initialize BLAKE2 Params and State
		.memset(blake2, 0, );
		Object generatedH = blake2.getH();
		generatedH[0] = blake2b_constants.BLAKE2B_IV_00;
		generatedH[1] = blake2b_constants.BLAKE2B_IV_01;
		generatedH[2] = blake2b_constants.BLAKE2B_IV_02;
		generatedH[3] = blake2b_constants.BLAKE2B_IV_03;
		generatedH[4] = blake2b_constants.BLAKE2B_IV_04;
		generatedH[5] = blake2b_constants.BLAKE2B_IV_05;
		generatedH[6] = blake2b_constants.BLAKE2B_IV_06;
		generatedH[7] = blake2b_constants.BLAKE2B_IV_07;
		// blake2->h[0] ^= 0x0000000001010040; // digest_lenght = 0x40, depth = 0x01, fanout = 0x01// blake2->h[0] ^= 0x0000000001010040; // digest_lenght = 0x40, depth = 0x01, fanout = 0x01generatedH[0] ^=  -1024 << 0;
		generatedH[0] ^=  -1024 << 16;
		generatedH[0] ^=  -1024 << 24;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		cloudkey_t cloudkey = (cloudkey_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[1] = (byte)':';
		generatedLen_min[1] = 32;
		generatedLen_max[1] = 32;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[2] = (byte)':';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 6;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[3] = 2;
		generatedLen_max[3] = 2048;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// hash
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7])// salt;// salt
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		u8 saltbuf_ptr = (u8)generatedSalt_buf;
		for (int i = 0;
		 i < salt_len; i += 2) {
			u8 p0 = salt_pos[i + 0];
			u8 p1 = salt_pos[i + 1];
			saltbuf_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		generatedSalt_buf[4] = -1024;
		generatedSalt_buf[5] = -1024;
		salt.setSalt_len(salt_len / 2)// iteration;// iteration
		u8 iter_pos = generatedBuf[2];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10) - 1)// data;// data
		u8 data_pos = generatedBuf[3];
		int data_len = generatedLen[3];
		Object generatedData_buf = cloudkey.getData_buf();
		u8 databuf_ptr = (u8)generatedData_buf;
		for (int i = 0;
		 i < data_len; i += 2) {
			u8 p0 = data_pos[i + 0];
			u8 p1 = data_pos[i + 1];
			databuf_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		databuf_ptr++ = -1024;
		for (int i = 0;
		 i < 512; i++) {
			generatedData_buf[i] = ModernizedCProgram.byte_swap_32(generatedData_buf[i]);
		}
		cloudkey.setData_len(data_len / 2);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MD5AIX;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 8;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_OPTIONAL_ROUNDS;
		generatedLen[2] = 22;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_MD5CRYPT);
		int generatedOpt_len = token.getOpt_len();
		Object generatedOpt_buf = token.getOpt_buf();
		if (generatedOpt_len != -1) {
			salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)generatedOpt_buf + 7, ((Object)0), 10));
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 hash_pos = generatedBuf[2];
		ModernizedCProgram.md5crypt_decode((u8)digest, hash_pos);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pstoken_t pstoken = (pstoken_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 32;
		generatedLen_max[1] = 1024;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = pstoken.getSalt_buf();
		u8 pstoken_ptr = (u8)generatedSalt_buf;
		for (int i = 0;
		int j = 0;
		 i < salt_len; ) {
			pstoken_ptr[j] = ModernizedCProgram.hex_to_u8(salt_pos + i);
		}
		pstoken.setSalt_len(salt_len / 2);
		generatedSalt_buf[0] = generatedSalt_buf[/* some fake salt for the sorting mechanisms */0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		generatedSalt_buf[4] = generatedSalt_buf[4];
		generatedSalt_buf[5] = generatedSalt_buf[5];
		generatedSalt_buf[6] = generatedSalt_buf[6];
		generatedSalt_buf[7] = generatedSalt_buf[7];
		salt.setSalt_len(32/* we need to check if we can precompute some of the data --
		     this is possible since the scheme is badly designed */);
		Object generatedPc_digest = pstoken.getPc_digest();
		generatedPc_digest[0] = sha1_constants.SHA1M_A;
		generatedPc_digest[1] = sha1_constants.SHA1M_B;
		generatedPc_digest[2] = sha1_constants.SHA1M_C;
		generatedPc_digest[3] = sha1_constants.SHA1M_D;
		generatedPc_digest[4] = sha1_constants.SHA1M_E;
		pstoken.setPc_offset(0);
		Object generatedSalt_len = pstoken.getSalt_len();
		Object generatedPc_offset = pstoken.getPc_offset();
		for (int i = 0;
		 i < (int)generatedSalt_len - 63; i += 64) {
			u32[] w = new u32();
			w[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 0]);
			w[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 1]);
			w[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 2]);
			w[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 3]);
			w[4] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 4]);
			w[5] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 5]);
			w[6] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 6]);
			w[7] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 7]);
			w[8] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 8]);
			w[9] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 9]);
			w[10] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 10]);
			w[11] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 11]);
			w[12] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 12]);
			w[13] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 13]);
			w[14] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 14]);
			w[15] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[generatedPc_offset + 15]);
			.sha1_transform(w + 0, w + 4, w + 8, w + 12, generatedPc_digest);
			generatedPc_offset += 16;
		}
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 20;
		generatedLen_max[1] = 20;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_200000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(2048);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		jks_sha1_t jks_sha1 = (jks_sha1_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(7);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_JKS_SHA1;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 10;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 10;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)'*';
		generatedLen_min[1] = 40;
		generatedLen_max[1] = 40;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 40;
		generatedLen_max[2] = 40;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 2;
		generatedLen_max[3] = 16384;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[4] = (byte)'*';
		generatedLen_min[4] = 2;
		generatedLen_max[4] = 2;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[5] = (byte)'*';
		generatedLen_min[5] = 28;
		generatedLen_max[5] = 28;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[6] = (byte)'*';
		generatedLen_min[6] = 0;
		generatedLen_max[6] = 64;
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// checksum
		Object generatedBuf = token.getBuf();
		u8 checksum_pos = generatedBuf[1];
		Object generatedChecksum = jks_sha1.getChecksum();
		generatedChecksum[0] = ModernizedCProgram.hex_to_u32((u8)checksum_pos[0]);
		generatedChecksum[1] = ModernizedCProgram.hex_to_u32((u8)checksum_pos[8]);
		generatedChecksum[2] = ModernizedCProgram.hex_to_u32((u8)checksum_pos[16]);
		generatedChecksum[3] = ModernizedCProgram.hex_to_u32((u8)checksum_pos[24]);
		generatedChecksum[4] = ModernizedCProgram.hex_to_u32((u8)checksum_pos[32])// iv;// iv
		u8 iv_pos = generatedBuf[2];
		Object generatedIv = jks_sha1.getIv();
		generatedIv[0] = ModernizedCProgram.hex_to_u32((u8)iv_pos[0]);
		generatedIv[1] = ModernizedCProgram.hex_to_u32((u8)iv_pos[8]);
		generatedIv[2] = ModernizedCProgram.hex_to_u32((u8)iv_pos[16]);
		generatedIv[3] = ModernizedCProgram.hex_to_u32((u8)iv_pos[24]);
		generatedIv[4] = ModernizedCProgram.hex_to_u32((u8)iv_pos[32])// enc_key;// enc_key
		u8 enc_key_pos = generatedBuf[3];
		Object generatedLen = token.getLen();
		int enc_key_len = generatedLen[3];
		Object generatedEnc_key_buf = jks_sha1.getEnc_key_buf();
		u8 enc_key_buf = (u8)generatedEnc_key_buf;
		Object generatedEnc_key_len = jks_sha1.getEnc_key_len();
		for (int i = 0;
		int j = 0;
		 j < enc_key_len; ) {
			enc_key_buf[i] = ModernizedCProgram.hex_to_u8((u8)enc_key_pos[j]);
			generatedEnc_key_len++;
		}
		// der1u8 der1_pos = generatedBuf[4];
		Object generatedDer = jks_sha1.getDer();
		u8 der = (u8)generatedDer;
		der[0] = ModernizedCProgram.hex_to_u8((u8)der1_pos[0])// der2;// der2
		u8 der2_pos = generatedBuf[5];
		for (int i = 6;
		int j = 0;
		 j < 28; ) {
			der[i] = ModernizedCProgram.hex_to_u8((u8)der2_pos[j]);
		}
		der[1] = 0;
		der[2] = 0;
		der[3] = 0;
		der[4] = 0;
		der[5] = 0// alias;// alias
		u8 alias_pos = generatedBuf[6];
		Object generatedAlias = jks_sha1.getAlias();
		.strncpy((byte)generatedAlias, (byte)alias_pos, 64)// fake salt;// fake salt
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedIv[0];
		generatedSalt_buf[1] = generatedIv[1];
		generatedSalt_buf[2] = generatedIv[2];
		generatedSalt_buf[3] = generatedIv[3];
		generatedSalt_buf[4] = generatedIv[4];
		salt.setSalt_len(20)// fake digest;// fake digest
		digest[0] = ModernizedCProgram.byte_swap_32(generatedDer[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(generatedDer[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(generatedDer[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(generatedDer[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(generatedDer[4]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		luks_t luks = (luks_t)esalt_buf;
		int keyslot_idx_sav = 0;
		int keyslot_idx = keyslot_idx_sav;
		keyslot_idx_sav++;
		if (line_len == 0) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen((byte)line_buf, "rb") == 0) {
			return (parser_rc.PARSER_HASH_FILE);
		} 
		luks_phdr hdr = new luks_phdr();
		size_t nread = fp.hc_fread(hdr, , 1);
		if (nread != 1) {
			fp.hc_fclose();
			return (parser_rc.PARSER_LUKS_FILE_SIZE);
		} 
		Object generatedMkDigest = hdr.getMkDigest();
		// copy digest which we're not using ;)u32 mkDigest_ptr = (u32)generatedMkDigest;
		digest[0] = mkDigest_ptr[0];
		digest[1] = mkDigest_ptr[1];
		digest[2] = mkDigest_ptr[2];
		digest[3] = mkDigest_ptr[3];
		digest[4] = mkDigest_ptr[4];
		digest[5] = 0;
		digest[6] = 0;
		digest[7] = 0// verify the content;// verify the content
		byte[] luks_magic = new byte[]{(byte)'L', (byte)'U', (byte)'K', (byte)'S', -1024, -1024};
		;
		Object generatedMagic = hdr.getMagic();
		if (.memcmp(generatedMagic, luks_magic, 6) != 0) {
			fp.hc_fclose();
			return (parser_rc.PARSER_LUKS_MAGIC);
		} 
		Object generatedVersion = hdr.getVersion();
		if (ModernizedCProgram.byte_swap_16(generatedVersion) != 1) {
			fp.hc_fclose();
			return (parser_rc.PARSER_LUKS_VERSION);
		} 
		Object generatedCipherName = hdr.getCipherName();
		if (.strcmp(generatedCipherName, "aes") == 0) {
			luks.setCipher_type(hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_AES);
		}  else if (.strcmp(generatedCipherName, "serpent") == 0) {
			luks.setCipher_type(hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_SERPENT);
		}  else if (.strcmp(generatedCipherName, "twofish") == 0) {
			luks.setCipher_type(hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_TWOFISH);
		} else {
				fp.hc_fclose();
				return (parser_rc.PARSER_LUKS_CIPHER_TYPE);
		} 
		Object generatedCipherMode = hdr.getCipherMode();
		if (.strcmp(generatedCipherMode, "cbc-essiv:sha256") == 0) {
			luks.setCipher_mode(hc_luks_cipher_mode.HC_LUKS_CIPHER_MODE_CBC_ESSIV);
		}  else if (.strcmp(generatedCipherMode, "cbc-plain") == 0) {
			luks.setCipher_mode(hc_luks_cipher_mode.HC_LUKS_CIPHER_MODE_CBC_PLAIN);
		}  else if (.strcmp(generatedCipherMode, "cbc-plain64") == 0) {
			luks.setCipher_mode(hc_luks_cipher_mode.HC_LUKS_CIPHER_MODE_CBC_PLAIN);
		}  else if (.strcmp(generatedCipherMode, "xts-plain") == 0) {
			luks.setCipher_mode(hc_luks_cipher_mode.HC_LUKS_CIPHER_MODE_XTS_PLAIN);
		}  else if (.strcmp(generatedCipherMode, "xts-plain64") == 0) {
			luks.setCipher_mode(hc_luks_cipher_mode.HC_LUKS_CIPHER_MODE_XTS_PLAIN);
		} else {
				fp.hc_fclose();
				return (parser_rc.PARSER_LUKS_CIPHER_MODE);
		} 
		Object generatedHashSpec = hdr.getHashSpec();
		if (.strcmp(generatedHashSpec, "sha1") == 0) {
			luks.setHash_type(hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA1);
		}  else if (.strcmp(generatedHashSpec, "sha256") == 0) {
			luks.setHash_type(hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA256);
		}  else if (.strcmp(generatedHashSpec, "sha512") == 0) {
			luks.setHash_type(hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA512);
		}  else if (.strcmp(generatedHashSpec, "ripemd160") == 0) {
			luks.setHash_type(hc_luks_hash_type.HC_LUKS_HASH_TYPE_RIPEMD160);
		}  else if (.strcmp(generatedHashSpec, "whirlpool") == 0) {
			luks.setHash_type(hc_luks_hash_type.HC_LUKS_HASH_TYPE_WHIRLPOOL);
		} else {
				fp.hc_fclose();
				return (parser_rc.PARSER_LUKS_HASH_TYPE);
		} 
		Object generatedKeyBytes = hdr.getKeyBytes();
		u32 keyBytes = ModernizedCProgram.byte_swap_32(generatedKeyBytes);
		if (keyBytes == 16) {
			luks.setKey_size(hc_luks_key_size.HC_LUKS_KEY_SIZE_128);
		}  else if (keyBytes == 32) {
			luks.setKey_size(hc_luks_key_size.HC_LUKS_KEY_SIZE_256);
		}  else if (keyBytes == 64) {
			luks.setKey_size(hc_luks_key_size.HC_LUKS_KEY_SIZE_512);
		} else {
				fp.hc_fclose();
				return (parser_rc.PARSER_LUKS_KEY_SIZE);
		} 
		Object generatedKeyblock = hdr.getKeyblock();
		// verify the selected keyslot informationsu32 active = ModernizedCProgram.byte_swap_32(generatedKeyblock[keyslot_idx].getActive());
		u32 stripes = ModernizedCProgram.byte_swap_32(generatedKeyblock[keyslot_idx].getStripes());
		if (active != -1024) {
			fp.hc_fclose();
			return (parser_rc.PARSER_LUKS_KEY_DISABLED);
		} 
		if (stripes != 4000) {
			fp.hc_fclose();
			return (parser_rc.PARSER_LUKS_KEY_STRIPES);
		} 
		// configure the salt (not esalt)u32 passwordSalt_ptr = (u32)generatedKeyblock[keyslot_idx].getPasswordSalt();
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = passwordSalt_ptr[0];
		generatedSalt_buf[1] = passwordSalt_ptr[1];
		generatedSalt_buf[2] = passwordSalt_ptr[2];
		generatedSalt_buf[3] = passwordSalt_ptr[3];
		generatedSalt_buf[4] = passwordSalt_ptr[4];
		generatedSalt_buf[5] = passwordSalt_ptr[5];
		generatedSalt_buf[6] = passwordSalt_ptr[6];
		generatedSalt_buf[7] = passwordSalt_ptr[7];
		salt.setSalt_len(32);
		u32 passwordIterations = ModernizedCProgram.byte_swap_32(generatedKeyblock[keyslot_idx].getPasswordIterations());
		salt.setSalt_iter(passwordIterations - 1)// Load AF data for this keyslot into esalt;// Load AF data for this keyslot into esalt
		u32 keyMaterialOffset = ModernizedCProgram.byte_swap_32(generatedKeyblock[keyslot_idx].getKeyMaterialOffset());
		int rc_seek1 = fp.hc_fseek(keyMaterialOffset * 512, 0);
		if (rc_seek1 == -1) {
			fp.hc_fclose();
			return (parser_rc.PARSER_LUKS_FILE_SIZE);
		} 
		Object generatedAf_src_buf = luks.getAf_src_buf();
		size_t nread2 = fp.hc_fread(generatedAf_src_buf, keyBytes, stripes);
		if (nread2 != stripes) {
			fp.hc_fclose();
			return (parser_rc.PARSER_LUKS_FILE_SIZE);
		} 
		Object generatedPayloadOffset = hdr.getPayloadOffset();
		// finally, copy some encrypted payload data for entropy checku32 payloadOffset = ModernizedCProgram.byte_swap_32(generatedPayloadOffset);
		int rc_seek2 = fp.hc_fseek(payloadOffset * 512, 0);
		if (rc_seek2 == -1) {
			fp.hc_fclose();
			return (parser_rc.PARSER_LUKS_FILE_SIZE);
		} 
		Object generatedCt_buf = luks.getCt_buf();
		size_t nread3 = fp.hc_fread(generatedCt_buf, , 128);
		if (nread3 != 128) {
			fp.hc_fclose();
			return (parser_rc.PARSER_LUKS_FILE_SIZE);
		} 
		// that should be it, close the fp// that should be it, close the fpfp.hc_fclose();
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		sha1_double_salt_t sha1_double_salt = (sha1_double_salt_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[1] = hashconfig.getSeparator();
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[2] = hashconfig.getSeparator();
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 256;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
			generatedLen_min[2] *= 2;
			generatedLen_max[2] *= 2;
			generatedAttr[2] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		Object generatedLen = token.getLen();
		Object generatedSalt1_buf = sha1_double_salt.getSalt1_buf();
		int generatedSalt1_len = sha1_double_salt.getSalt1_len();
		boolean parse_rc1 = ModernizedCProgram.generic_salt_decode(hashconfig, generatedBuf[1], generatedLen[1], (u8)generatedSalt1_buf, (int)generatedSalt1_len);
		if (parse_rc1 == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt2_buf = sha1_double_salt.getSalt2_buf();
		int generatedSalt2_len = sha1_double_salt.getSalt2_len();
		boolean parse_rc2 = ModernizedCProgram.generic_salt_decode(hashconfig, generatedBuf[2], generatedLen[2], (u8)generatedSalt2_buf, (int)generatedSalt2_len);
		if (parse_rc2 == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// make salt sorter happy
		md5_ctx_t md5_ctx = new md5_ctx_t();
		.md5_init(md5_ctx);
		.md5_update(md5_ctx, generatedSalt1_buf, generatedSalt1_len);
		.md5_update(md5_ctx, generatedSalt2_buf, generatedSalt2_len);
		.md5_final(md5_ctx);
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedH = md5_ctx.getH();
		generatedSalt_buf[0] = generatedH[0];
		generatedSalt_buf[1] = generatedH[1];
		generatedSalt_buf[2] = generatedH[2];
		generatedSalt_buf[3] = generatedH[3];
		salt.setSalt_len(16);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		krb5pa_17_t krb5pa = (krb5pa_17_t)esalt_buf;
		token_t token = new token_t();
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_KRB5PA;
		Object generatedLen = token.getLen();
		generatedLen[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE/**
		   * $krb5pa$17$*user*realm*$enc_timestamp+checksum
		   */;
		// assume no signature foundif (line_len < 11) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// assume $krb5pa$17$user$realm$enc_timestamp+checksum// assume $krb5pa$17$user$realm$enc_timestamp+checksumtoken.setToken_cnt(4);
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 512;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 512;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 104;
		generatedLen_max[3] = 112;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		u8 user_pos = new u8();
		u8 domain_pos = new u8();
		u8 data_pos = new u8();
		u8 checksum_pos = new u8();
		int user_len;
		int domain_len;
		int data_len;
		int account_info_len;
		Object generatedBuf = token.getBuf();
		user_pos = generatedBuf[1];
		user_len = generatedLen[1];
		Object generatedUser = krb5pa.getUser();
		.memcpy(generatedUser, user_pos, user_len);
		domain_pos = generatedBuf[2];
		domain_len = generatedLen[2];
		Object generatedDomain = krb5pa.getDomain();
		.memcpy(generatedDomain, domain_pos, domain_len);
		data_pos = generatedBuf[3];
		data_len = generatedLen[3];
		account_info_len = generatedLen[2] + generatedLen[1];
		Object generatedAccount_info = krb5pa.getAccount_info();
		u8 account_info_ptr = (u8)generatedAccount_info;
		// domain must be uppercaseu8[] domain = new u8();
		.memcpy(domain, domain_pos, domain_len);
		ModernizedCProgram.uppercase(domain, domain_len);
		.memcpy(account_info_ptr, domain, domain_len);
		.memcpy(account_info_ptr + domain_len, user_pos, user_len);
		krb5pa.setAccount_info_len(account_info_len);
		// Split checksum// Split checksumchecksum_pos = data_pos + data_len - 24;
		data_len = data_len - 24;
		Object generatedChecksum = krb5pa.getChecksum();
		// hmac-sha1 is reduced to 12 bytes// hmac-sha1 is reduced to 12 bytesgeneratedChecksum[0] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 0));
		generatedChecksum[1] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 8));
		generatedChecksum[2] = ModernizedCProgram.byte_swap_32(ModernizedCProgram.hex_to_u32(checksum_pos + 16));
		Object generatedEnc_timestamp = krb5pa.getEnc_timestamp();
		u8 edata_ptr = (u8)generatedEnc_timestamp;
		for (int i = 0;
		 i < data_len; i += 2) {
			u8 p0 = data_pos[i + 0];
			u8 p1 = data_pos[i + 1];
			edata_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		krb5pa.setEnc_timestamp_len(data_len / 2);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedChecksum[0];
		generatedSalt_buf[1] = generatedChecksum[1];
		generatedSalt_buf[2] = generatedChecksum[2];
		salt.setSalt_iter(4096 - 1);
		digest[0] = generatedChecksum[0];
		digest[1] = generatedChecksum[1];
		digest[2] = generatedChecksum[2];
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 16;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 16;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[1] = (byte)':';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)':';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		Object generatedLen = token.getLen();
		generatedLen[3] = 32;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		Object generatedBuf = token.getBuf();
		u8 iter_c = generatedBuf[1][0];
		u8 iter_d = generatedBuf[2][0];
		// atm only defaults, let's see if there's more requestif (iter_c != (byte)'2') {
			return (parser_rc.PARSER_SALT_ITERATION);
		} 
		if (iter_d != (byte)'4') {
			return (parser_rc.PARSER_SALT_ITERATION);
		} 
		// hash
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = 0;
		digest[3] = 0// salt;// salt
		u8 salt_pos = generatedBuf[3];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(salt_pos + 24);
		salt.setSalt_len(16);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		netntlm_t netntlm = (netntlm_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(6);
		Object generatedLen_min = token.getLen_min();
		// username// usernamegeneratedLen_min[0] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 60;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// unused// unusedgeneratedLen_min[1] = 0;
		generatedLen_max[1] = 0;
		generatedSep[1] = (byte)':';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// domain// domaingeneratedLen_min[2] = 0;
		generatedLen_max[2] = 45;
		generatedSep[2] = (byte)':';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// lm response// lm responsegeneratedLen_min[3] = 0;
		generatedLen_max[3] = 48;
		generatedSep[3] = (byte)':';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		// ntlm response// ntlm responsegeneratedLen_min[4] = 48;
		generatedLen_max[4] = 48;
		generatedSep[4] = (byte)':';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		// challenge// challengegeneratedLen_min[5] = 16;
		generatedLen_max[5] = 16;
		generatedSep[5] = (byte)':';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 user_pos = generatedBuf[0];
		u8 domain_pos = generatedBuf[2];
		u8 srvchall_pos = generatedBuf[3];
		u8 hash_pos = generatedBuf[4];
		u8 clichall_pos = generatedBuf[5];
		Object generatedLen = token.getLen();
		int user_len = generatedLen[0];
		int domain_len = generatedLen[2];
		int srvchall_len = generatedLen[3];
		int clichall_len = generatedLen[5/**
		   * store some data for later use
		   */];
		netntlm.setUser_len(user_len * 2);
		netntlm.setDomain_len(domain_len * 2);
		netntlm.setSrvchall_len(srvchall_len / 2);
		netntlm.setClichall_len(clichall_len / 2);
		Object generatedUserdomain_buf = netntlm.getUserdomain_buf();
		u8 userdomain_ptr = (u8)generatedUserdomain_buf;
		Object generatedChall_buf = netntlm.getChall_buf();
		u8 chall_ptr = (u8)generatedChall_buf;
		for (int i = 0;
		 i < user_len; i++) {
			userdomain_ptr++ = user_pos[i];
			userdomain_ptr++ = 0;
		}
		for (int i = 0;
		 i < domain_len; i++) {
			userdomain_ptr++ = domain_pos[i];
			userdomain_ptr++ = 0/**
			   * handle server challenge encoding
			   */;
		}
		for (int i = 0;
		 i < srvchall_len; i += 2) {
			u8 p0 = srvchall_pos[i + 0];
			u8 p1 = srvchall_pos[i + 1];
			chall_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4/**
			   * handle client challenge encoding
			   */;
		}
		for (int i = 0;
		 i < clichall_len; i += 2) {
			u8 p0 = clichall_pos[i + 0];
			u8 p1 = clichall_pos[i + 1];
			chall_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4/**
			   * store data
			   */;
		}
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, clichall_pos, clichall_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		u32[] digest_tmp = new u32();
		digest_tmp[0] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest_tmp[1] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		if (srvchall_len == /* special case 2: ESS */48) {
			if ((generatedChall_buf[2] == 0) && (generatedChall_buf[3] == 0) && (generatedChall_buf[4] == 0) && (generatedChall_buf[5] == 0)) {
				u32[] w = new u32[]{0};
				w[0] = generatedSalt_buf[0];
				w[1] = generatedSalt_buf[1];
				w[2] = generatedChall_buf[0];
				w[3] = generatedChall_buf[1];
				w[4] = -1024;
				w[14] = 16 * 8;
				u32[] dgst = new u32[]{0};
				dgst[0] = md5_constants.MD5M_A;
				dgst[1] = md5_constants.MD5M_B;
				dgst[2] = md5_constants.MD5M_C;
				dgst[3] = md5_constants.MD5M_D;
				.md5_transform(w + 0, w + 4, w + 8, w + 12, dgst);
				generatedSalt_buf[0] = dgst[0];
				generatedSalt_buf[1] = dgst[1];
			} 
		} 
		for (u32 i = 0;
		 i < -1024; /* precompute netntlmv1 exploit start */i++) {
			u32[] key_md4 = new u32[]{0};
			u32[] key_des = new u32[]{0};
			key_md4[0] = i;
			ModernizedCProgram.transform_netntlmv1_key((u8)key_md4, (u8)key_des);
			u32[] Kc = new u32[]{0};
			u32[] Kd = new u32[]{0};
			._des_crypt_keysetup(key_des[0], key_des[1], Kc, Kd, (u32)ModernizedCProgram.c_skb);
			u32[] data3 = new u32[]{generatedSalt_buf[0], generatedSalt_buf[1]};
			._des_crypt_encrypt(data3, data3, Kc, Kd, (u32)ModernizedCProgram.c_SPtrans);
			if (data3[0] != digest_tmp[0]) {
				continue;
			} 
			if (data3[1] != digest_tmp[1]) {
				continue;
			} 
			generatedSalt_buf[2] = i;
			salt.setSalt_len(24);
			break;
		}
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		generatedSalt_buf_pc[0] = digest_tmp[0];
		generatedSalt_buf_pc[1] = digest_tmp[1];
		{ 
			{ 
				u32x t = new u32x();
				t = digest[1] >> 4;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 4;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 16;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 16;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 2;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 2;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 8;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 8;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 1;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 1;
				digest[1] = digest[1] ^ /* precompute netntlmv1 exploit stop */t;
			}
			;
		}
		;
		{ 
			{ 
				u32x t = new u32x();
				t = digest[3] >> 4;
				t = t ^ digest[2];
				t = t & -1024;
				digest[2] = digest[2] ^ t;
				t = t << 4;
				digest[3] = digest[3] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[2] >> 16;
				t = t ^ digest[3];
				t = t & -1024;
				digest[3] = digest[3] ^ t;
				t = t << 16;
				digest[2] = digest[2] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[3] >> 2;
				t = t ^ digest[2];
				t = t & -1024;
				digest[2] = digest[2] ^ t;
				t = t << 2;
				digest[3] = digest[3] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[2] >> 8;
				t = t ^ digest[3];
				t = t & -1024;
				digest[3] = digest[3] ^ t;
				t = t << 8;
				digest[2] = digest[2] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[3] >> 1;
				t = t ^ digest[2];
				t = t & -1024;
				digest[2] = digest[2] ^ t;
				t = t << 1;
				digest[3] = digest[3] ^ t;
			}
			;
		}
		;
		digest[0] = ModernizedCProgram.rotr32(digest[0], 29);
		digest[1] = ModernizedCProgram.rotr32(digest[1], 29);
		digest[2] = ModernizedCProgram.rotr32(digest[2], 29);
		digest[3] = ModernizedCProgram.rotr32(digest[3], 29);
		{ 
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf[1] >> 4;
				t = t ^ generatedSalt_buf[0];
				t = t & -1024;
				generatedSalt_buf[0] = generatedSalt_buf[0] ^ t;
				t = t << 4;
				generatedSalt_buf[1] = generatedSalt_buf[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf[0] >> 16;
				t = t ^ generatedSalt_buf[1];
				t = t & -1024;
				generatedSalt_buf[1] = generatedSalt_buf[1] ^ t;
				t = t << 16;
				generatedSalt_buf[0] = generatedSalt_buf[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf[1] >> 2;
				t = t ^ generatedSalt_buf[0];
				t = t & -1024;
				generatedSalt_buf[0] = generatedSalt_buf[0] ^ t;
				t = t << 2;
				generatedSalt_buf[1] = generatedSalt_buf[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf[0] >> 8;
				t = t ^ generatedSalt_buf[1];
				t = t & -1024;
				generatedSalt_buf[1] = generatedSalt_buf[1] ^ t;
				t = t << 8;
				generatedSalt_buf[0] = generatedSalt_buf[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf[1] >> 1;
				t = t ^ generatedSalt_buf[0];
				t = t & -1024;
				generatedSalt_buf[0] = generatedSalt_buf[0] ^ t;
				t = t << 1;
				generatedSalt_buf[1] = generatedSalt_buf[1] ^ t;
			}
			;
		}
		;
		generatedSalt_buf[0] = ModernizedCProgram.rotl32(generatedSalt_buf[0], 3);
		generatedSalt_buf[1] = ModernizedCProgram.rotl32(generatedSalt_buf[1], 3);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		return (parser_rc.PARSER_OK);
		jwt_t jwt = (jwt_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'.';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 2047;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64C;
		generatedSep[1] = (byte)'.';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 2047;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64C;
		generatedSep[2] = (byte)'.';
		generatedLen_min[2] = 43;
		generatedLen_max[2] = 86;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64C;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// header
		Object generatedLen = token.getLen();
		int header_len = generatedLen[0];
		// payload
		int payload_len = generatedLen[1];
		// signature
		Object generatedBuf = token.getBuf();
		u8 signature_pos = generatedBuf[2];
		int signature_len = generatedLen[2];
		jwt.setSignature_len(signature_len)// esalt;// esalt
		int esalt_len = header_len + 1 + payload_len;
		if (esalt_len > 4096) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt_buf = jwt.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, esalt_len);
		jwt.setSalt_len(esalt_len)// salt//;// salt//
		// Create a hash of the esalt because esalt buffer can change somewhere behind salt->salt_buf size// Not a regular MD5 but good enoughu32[] hash = new u32();
		hash[0] = 0;
		hash[1] = 1;
		hash[2] = 2;
		hash[3] = 3;
		u32[] block = new u32();
		.memset(block, 0, );
		for (int i = 0;
		 i < 1024; i += 16) {
			for (int j = 0;
			 j < 16; j++) {
				block[j] = generatedSalt_buf[i + j];
				.md5_transform(block + 0, block + 4, block + 8, block + 12, hash);
			}
		}
		generatedSalt_buf[0] = hash[0];
		generatedSalt_buf[1] = hash[1];
		generatedSalt_buf[2] = hash[2];
		generatedSalt_buf[3] = hash[3];
		salt.setSalt_len(16)// hash;// hash
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.base64url_to_int, signature_pos, signature_len, tmp_buf);
		if (signature_len == 43) {
			.memcpy(digest_buf, tmp_buf, 32);
			u32 digest = (u32)digest_buf;
			digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
			digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
			digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
			digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
			digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
			digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
			digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
			digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		}  else if (signature_len == 64) {
			.memcpy(digest_buf, tmp_buf, 48);
			u64 digest = (u64)digest_buf;
			digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
			digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
			digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
			digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
			digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
			digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		}  else if (signature_len == 86) {
			.memcpy(digest_buf, tmp_buf, 64);
			u64 digest = (u64)digest_buf;
			digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
			digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
			digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
			digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
			digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
			digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
			digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
			digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		Object generatedLen = token.getLen();
		generatedLen[0] = 1;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		generatedLen[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		generatedLen[2] = 19;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		generatedLen[3] = 1;
		generatedAttr[3] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		if (generatedBuf[0][0] != (byte)'(') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		if (generatedBuf[1][0] != (byte)'G') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		if (generatedBuf[3][0] != (byte)')') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		u8 hash_pos = generatedBuf[2];
		int hash_len = generatedLen[2];
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.lotus64_to_int, hash_pos, hash_len, tmp_buf);
		// dont ask!// dont ask!tmp_buf[3] += -4// salt;// salt
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy(generatedSalt_buf, tmp_buf, 5);
		salt.setSalt_len(5);
		.memcpy(digest, tmp_buf + 5, 9)// yes, only 9 byte are needed to crack, but 10 to display;// yes, only 9 byte are needed to crack, but 10 to display
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		generatedSalt_buf_pc[7] = hash_pos[18];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pdf_t pdf = (pdf_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(12);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PDF;
		Object generatedLen = token.getLen();
		generatedLen[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 2;
		generatedLen_max[3] = 2;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 1;
		generatedLen_max[4] = 6;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[5] = 1;
		generatedLen_max[5] = 1;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[6] = 2;
		generatedLen_max[6] = 2;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[7] = 32;
		generatedLen_max[7] = 32;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[8] = 2;
		generatedLen_max[8] = 2;
		generatedSep[8] = (byte)'*';
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[9] = 64;
		generatedLen_max[9] = 64;
		generatedSep[9] = (byte)'*';
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[10] = 2;
		generatedLen_max[10] = 2;
		generatedSep[10] = (byte)'*';
		generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[11] = 64;
		generatedLen_max[11] = 64;
		generatedSep[11] = (byte)'*';
		generatedAttr[11] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 V_pos = generatedBuf[1];
		u8 R_pos = generatedBuf[2];
		u8 bits_pos = generatedBuf[3];
		u8 P_pos = generatedBuf[4];
		u8 enc_md_pos = generatedBuf[5];
		u8 id_len_pos = generatedBuf[6];
		u8 id_buf_pos = generatedBuf[7];
		u8 u_len_pos = generatedBuf[8];
		u8 u_buf_pos = generatedBuf[9];
		u8 o_len_pos = generatedBuf[10];
		u8 o_buf_pos = generatedBuf[11];
		// validate data
		int V = .strtol((byte)V_pos, ((Object)0), 10);
		int R = .strtol((byte)R_pos, ((Object)0), 10);
		int P = .strtol((byte)P_pos, ((Object)0), 10);
		if (V != 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (R != 2) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int enc_md = .strtol((byte)enc_md_pos, ((Object)0), 10);
		if ((enc_md != 0) && (enc_md != 1)) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int id_len = .strtol((byte)id_len_pos, ((Object)0), 10);
		int u_len = .strtol((byte)u_len_pos, ((Object)0), 10);
		int o_len = .strtol((byte)o_len_pos, ((Object)0), 10);
		if (id_len != 16) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (u_len != 32) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (o_len != 32) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int bits = .strtol((byte)bits_pos, ((Object)0), 10);
		if (bits != 40) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		// copy data to esalt
		pdf.setV(V);
		pdf.setR(R);
		pdf.setP(P);
		pdf.setEnc_md(enc_md);
		Object generatedId_buf = pdf.getId_buf();
		generatedId_buf[0] = ModernizedCProgram.hex_to_u32(id_buf_pos + 0);
		generatedId_buf[1] = ModernizedCProgram.hex_to_u32(id_buf_pos + 8);
		generatedId_buf[2] = ModernizedCProgram.hex_to_u32(id_buf_pos + 16);
		generatedId_buf[3] = ModernizedCProgram.hex_to_u32(id_buf_pos + 24);
		pdf.setId_len(id_len);
		Object generatedU_buf = pdf.getU_buf();
		generatedU_buf[0] = ModernizedCProgram.hex_to_u32(u_buf_pos + 0);
		generatedU_buf[1] = ModernizedCProgram.hex_to_u32(u_buf_pos + 8);
		generatedU_buf[2] = ModernizedCProgram.hex_to_u32(u_buf_pos + 16);
		generatedU_buf[3] = ModernizedCProgram.hex_to_u32(u_buf_pos + 24);
		generatedU_buf[4] = ModernizedCProgram.hex_to_u32(u_buf_pos + 32);
		generatedU_buf[5] = ModernizedCProgram.hex_to_u32(u_buf_pos + 40);
		generatedU_buf[6] = ModernizedCProgram.hex_to_u32(u_buf_pos + 48);
		generatedU_buf[7] = ModernizedCProgram.hex_to_u32(u_buf_pos + 56);
		pdf.setU_len(u_len);
		Object generatedO_buf = pdf.getO_buf();
		generatedO_buf[0] = ModernizedCProgram.hex_to_u32(o_buf_pos + 0);
		generatedO_buf[1] = ModernizedCProgram.hex_to_u32(o_buf_pos + 8);
		generatedO_buf[2] = ModernizedCProgram.hex_to_u32(o_buf_pos + 16);
		generatedO_buf[3] = ModernizedCProgram.hex_to_u32(o_buf_pos + 24);
		generatedO_buf[4] = ModernizedCProgram.hex_to_u32(o_buf_pos + 32);
		generatedO_buf[5] = ModernizedCProgram.hex_to_u32(o_buf_pos + 40);
		generatedO_buf[6] = ModernizedCProgram.hex_to_u32(o_buf_pos + 48);
		generatedO_buf[7] = ModernizedCProgram.hex_to_u32(o_buf_pos + 56);
		pdf.setO_len(o_len)// we use ID for salt, maybe needs to change, we will see...;// we use ID for salt, maybe needs to change, we will see...
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedId_buf[0];
		generatedSalt_buf[1] = generatedId_buf[1];
		generatedSalt_buf[2] = generatedId_buf[2];
		generatedSalt_buf[3] = generatedId_buf[3];
		int generatedId_len = pdf.getId_len();
		salt.setSalt_len(generatedId_len);
		digest[0] = generatedU_buf[0];
		digest[1] = generatedU_buf[1];
		digest[2] = generatedU_buf[2];
		digest[3] = generatedU_buf[3];
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'@';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 0;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[1] = (byte)'@';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 8;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[2] = (byte)'@';
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 128;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[3] = (byte)'@';
		generatedLen_min[3] = 8;
		generatedLen_max[3] = 16;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// check hash type
		Object generatedBuf = token.getBuf();
		if (generatedBuf[1][0] != (byte)'S') {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		// check iter
		u32 iter = ModernizedCProgram.ROUNDS_QNX;
		Object generatedLen = token.getLen();
		if (generatedLen[1] > 1) {
			if (generatedBuf[1][1] != (byte)',') {
				return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
			} 
			iter = ModernizedCProgram.hc_strtoul((byte)generatedBuf[1] + 2, ((Object)0), 10);
		} 
		// iter++; the additinal round is added in the init kernel// iter++; the additinal round is added in the init kernelsalt.setSalt_iter(iter)// digest;// digest
		if (generatedLen[2] != 128) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u64((u8)generatedBuf[2] + 0);
		digest[1] = ModernizedCProgram.hex_to_u64((u8)generatedBuf[2] + 16);
		digest[2] = ModernizedCProgram.hex_to_u64((u8)generatedBuf[2] + 32);
		digest[3] = ModernizedCProgram.hex_to_u64((u8)generatedBuf[2] + 48);
		digest[4] = ModernizedCProgram.hex_to_u64((u8)generatedBuf[2] + 64);
		digest[5] = ModernizedCProgram.hex_to_u64((u8)generatedBuf[2] + 80);
		digest[6] = ModernizedCProgram.hex_to_u64((u8)generatedBuf[2] + 96);
		digest[7] = ModernizedCProgram.hex_to_u64((u8)generatedBuf[2] + 112)// salt;// salt
		Object generatedSalt_buf = salt.getSalt_buf();
		if ((generatedLen[3] == 8) || (generatedLen[3] == 16)) {
			.memcpy(generatedSalt_buf, generatedBuf[3], generatedLen[3]);
			salt.setSalt_len(generatedLen[3]);
		} else {
				return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_200000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(2048);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SHA512CRYPT;
		Object generatedLen = token.getLen();
		generatedLen[0] = 3;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 16;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_OPTIONAL_ROUNDS;
		generatedLen[2] = 86;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_SHA512CRYPT);
		int generatedOpt_len = token.getOpt_len();
		Object generatedOpt_buf = token.getOpt_buf();
		if (generatedOpt_len != -1) {
			salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)generatedOpt_buf + 7, ((Object)0), 10));
		} 
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u8 hash_pos = generatedBuf[2];
		ModernizedCProgram.sha512crypt_decode((u8)digest, hash_pos);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		ModernizedCProgram.precompute_salt_md5(generatedSalt_buf, generatedSalt_len, (u8)generatedSalt_buf_pc);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_CRAM_MD5_DOVECOT;
		Object generatedLen = token.getLen();
		generatedLen[0] = 10;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen[1] = 32;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[2] = 32;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// iter
		u8 hash_pos = (u8)line_buf + 10;
		digest[0] = ModernizedCProgram.hex_to_u32((u8)hash_pos[0]);
		digest[1] = ModernizedCProgram.hex_to_u32((u8)hash_pos[8]);
		digest[2] = ModernizedCProgram.hex_to_u32((u8)hash_pos[16]);
		digest[3] = ModernizedCProgram.hex_to_u32((u8)hash_pos[24]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		netntlm_t netntlm = (netntlm_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(6);
		Object generatedLen_min = token.getLen_min();
		// username// usernamegeneratedLen_min[0] = 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 60;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// unused// unusedgeneratedLen_min[1] = 0;
		generatedLen_max[1] = 0;
		generatedSep[1] = (byte)':';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// domain// domaingeneratedLen_min[2] = 0;
		generatedLen_max[2] = 45;
		generatedSep[2] = (byte)':';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// lm response// lm responsegeneratedLen_min[3] = 16;
		generatedLen_max[3] = 16;
		generatedSep[3] = (byte)':';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		// ntlm response// ntlm responsegeneratedLen_min[4] = 32;
		generatedLen_max[4] = 32;
		generatedSep[4] = (byte)':';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		// challenge// challengegeneratedLen_min[5] = 2;
		generatedLen_max[5] = 1024;
		generatedSep[5] = (byte)':';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 user_pos = generatedBuf[0];
		u8 domain_pos = generatedBuf[2];
		u8 srvchall_pos = generatedBuf[3];
		u8 hash_pos = generatedBuf[4];
		u8 clichall_pos = generatedBuf[5];
		Object generatedLen = token.getLen();
		int user_len = generatedLen[0];
		int domain_len = generatedLen[2];
		int srvchall_len = generatedLen[3];
		int clichall_len = generatedLen[5/**
		   * store some data for later use
		   */];
		netntlm.setUser_len(user_len * 2);
		netntlm.setDomain_len(domain_len * 2);
		netntlm.setSrvchall_len(srvchall_len / 2);
		netntlm.setClichall_len(clichall_len / 2);
		Object generatedUserdomain_buf = netntlm.getUserdomain_buf();
		u8 userdomain_ptr = (u8)generatedUserdomain_buf;
		Object generatedChall_buf = netntlm.getChall_buf();
		u8 chall_ptr = (u8)generatedChall_buf;
		for (int i = 0;
		 i < user_len; i++) {
			userdomain_ptr++ = .toupper(user_pos[i]);
			userdomain_ptr++ = 0;
		}
		for (int i = 0;
		 i < domain_len; i++) {
			userdomain_ptr++ = domain_pos[i];
			userdomain_ptr++ = 0;
		}
		userdomain_ptr++ = -1024/**
		   * handle server challenge encoding
		   */;
		for (int i = 0;
		 i < srvchall_len; i += 2) {
			u8 p0 = srvchall_pos[i + 0];
			u8 p1 = srvchall_pos[i + 1];
			chall_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4/**
			   * handle client challenge encoding
			   */;
		}
		for (int i = 0;
		 i < clichall_len; i += 2) {
			u8 p0 = clichall_pos[i + 0];
			u8 p1 = clichall_pos[i + 1];
			chall_ptr++ = ModernizedCProgram.hex_convert(p1) << 0 | ModernizedCProgram.hex_convert(p0) << 4;
		}
		chall_ptr++ = -1024/**
		   * handle hash itself
		   */;
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24/**
		   * reuse challange data as salt_buf, its the buffer that is most likely unique
		   */);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = 0;
		generatedSalt_buf[1] = 0;
		generatedSalt_buf[2] = 0;
		generatedSalt_buf[3] = 0;
		generatedSalt_buf[4] = 0;
		generatedSalt_buf[5] = 0;
		generatedSalt_buf[6] = 0;
		generatedSalt_buf[7] = 0;
		u32 uptr = new u32();
		uptr = (u32)generatedUserdomain_buf;
		for (u32 i = 0;
		 i < 64; ) {
			.md5_transform(uptr + 0, uptr + 4, uptr + 8, uptr + 12, generatedSalt_buf);
		}
		uptr = (u32)generatedChall_buf;
		for (u32 i = 0;
		 i < 256; ) {
			.md5_transform(uptr + 0, uptr + 4, uptr + 8, uptr + 12, generatedSalt_buf);
		}
		salt.setSalt_len(16);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		if (line_len == 0) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen((byte)line_buf, "rb") == 0) {
			return (parser_rc.PARSER_HASH_FILE);
		} 
		psafe3_t in = new psafe3_t();
		.memset(in, 0, );
		size_t n = fp.hc_fread(in, , 1);
		fp.hc_fclose();
		if (n != 1) {
			return (parser_rc.PARSER_PSAFE3_FILE_SIZE);
		} 
		Object generatedSignature = in.getSignature();
		if (.memcmp(ModernizedCProgram.SIGNATURE_PSAFE3, generatedSignature, 4) != 0) {
			return (parser_rc.PARSER_SIGNATURE_UNMATCHED);
		} 
		Object generatedIterations = in.getIterations();
		salt.setSalt_iter(generatedIterations + 1);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedSalt_buf[0];
		generatedSalt_buf[1] = generatedSalt_buf[1];
		generatedSalt_buf[2] = generatedSalt_buf[2];
		generatedSalt_buf[3] = generatedSalt_buf[3];
		generatedSalt_buf[4] = generatedSalt_buf[4];
		generatedSalt_buf[5] = generatedSalt_buf[5];
		generatedSalt_buf[6] = generatedSalt_buf[6];
		generatedSalt_buf[7] = generatedSalt_buf[7];
		salt.setSalt_len(32);
		Object generatedHash_buf = in.getHash_buf();
		digest[0] = generatedHash_buf[0];
		digest[1] = generatedHash_buf[1];
		digest[2] = generatedHash_buf[2];
		digest[3] = generatedHash_buf[3];
		digest[4] = generatedHash_buf[4];
		digest[5] = generatedHash_buf[5];
		digest[6] = generatedHash_buf[6];
		digest[7] = generatedHash_buf[7];
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 8;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 8;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 64;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[1];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		u8 salt_pos = generatedBuf[0];
		int salt_len = generatedLen[0];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		pdf_t pdf = (pdf_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(12);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_PDF;
		Object generatedLen = token.getLen();
		generatedLen[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[3] = 3;
		generatedLen_max[3] = 3;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[4] = 1;
		generatedLen_max[4] = 6;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[5] = 1;
		generatedLen_max[5] = 1;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[6] = 2;
		generatedLen_max[6] = 2;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[7] = 32;
		generatedLen_max[7] = 64;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[8] = 2;
		generatedLen_max[8] = 2;
		generatedSep[8] = (byte)'*';
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[9] = 64;
		generatedLen_max[9] = 64;
		generatedSep[9] = (byte)'*';
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[10] = 2;
		generatedLen_max[10] = 2;
		generatedSep[10] = (byte)'*';
		generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[11] = 64;
		generatedLen_max[11] = 64;
		generatedSep[11] = (byte)'*';
		generatedAttr[11] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 V_pos = generatedBuf[1];
		u8 R_pos = generatedBuf[2];
		u8 bits_pos = generatedBuf[3];
		u8 P_pos = generatedBuf[4];
		u8 enc_md_pos = generatedBuf[5];
		u8 id_len_pos = generatedBuf[6];
		u8 id_buf_pos = generatedBuf[7];
		u8 u_len_pos = generatedBuf[8];
		u8 u_buf_pos = generatedBuf[9];
		u8 o_len_pos = generatedBuf[10];
		u8 o_buf_pos = generatedBuf[11];
		// validate data
		int V = .strtol((byte)V_pos, ((Object)0), 10);
		int R = .strtol((byte)R_pos, ((Object)0), 10);
		int P = .strtol((byte)P_pos, ((Object)0), 10);
		int vr_ok = 0;
		if ((V == 2) && (R == 3)) {
			vr_ok = 1;
		} 
		if ((V == 4) && (R == 4)) {
			vr_ok = 1;
		} 
		if (vr_ok == 0) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int id_len = .strtol((byte)id_len_pos, ((Object)0), 10);
		int u_len = .strtol((byte)u_len_pos, ((Object)0), 10);
		int o_len = .strtol((byte)o_len_pos, ((Object)0), 10);
		if ((id_len != 16) && (id_len != 32)) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (u_len != 32) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (o_len != 32) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int bits = .strtol((byte)bits_pos, ((Object)0), 10);
		if (bits != 128) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		int enc_md = 1;
		if (R >= 4) {
			enc_md = .strtol((byte)enc_md_pos, ((Object)0), 10);
		} 
		// copy data to esalt// copy data to esaltpdf.setV(V);
		pdf.setR(R);
		pdf.setP(P);
		pdf.setEnc_md(enc_md);
		Object generatedId_buf = pdf.getId_buf();
		generatedId_buf[0] = ModernizedCProgram.hex_to_u32(id_buf_pos + 0);
		generatedId_buf[1] = ModernizedCProgram.hex_to_u32(id_buf_pos + 8);
		generatedId_buf[2] = ModernizedCProgram.hex_to_u32(id_buf_pos + 16);
		generatedId_buf[3] = ModernizedCProgram.hex_to_u32(id_buf_pos + 24);
		if (id_len == 32) {
			generatedId_buf[4] = ModernizedCProgram.hex_to_u32(id_buf_pos + 32);
			generatedId_buf[5] = ModernizedCProgram.hex_to_u32(id_buf_pos + 40);
			generatedId_buf[6] = ModernizedCProgram.hex_to_u32(id_buf_pos + 48);
			generatedId_buf[7] = ModernizedCProgram.hex_to_u32(id_buf_pos + 56);
		} 
		pdf.setId_len(id_len);
		Object generatedU_buf = pdf.getU_buf();
		generatedU_buf[0] = ModernizedCProgram.hex_to_u32(u_buf_pos + 0);
		generatedU_buf[1] = ModernizedCProgram.hex_to_u32(u_buf_pos + 8);
		generatedU_buf[2] = ModernizedCProgram.hex_to_u32(u_buf_pos + 16);
		generatedU_buf[3] = ModernizedCProgram.hex_to_u32(u_buf_pos + 24);
		generatedU_buf[4] = ModernizedCProgram.hex_to_u32(u_buf_pos + 32);
		generatedU_buf[5] = ModernizedCProgram.hex_to_u32(u_buf_pos + 40);
		generatedU_buf[6] = ModernizedCProgram.hex_to_u32(u_buf_pos + 48);
		generatedU_buf[7] = ModernizedCProgram.hex_to_u32(u_buf_pos + 56);
		pdf.setU_len(u_len);
		Object generatedO_buf = pdf.getO_buf();
		generatedO_buf[0] = ModernizedCProgram.hex_to_u32(o_buf_pos + 0);
		generatedO_buf[1] = ModernizedCProgram.hex_to_u32(o_buf_pos + 8);
		generatedO_buf[2] = ModernizedCProgram.hex_to_u32(o_buf_pos + 16);
		generatedO_buf[3] = ModernizedCProgram.hex_to_u32(o_buf_pos + 24);
		generatedO_buf[4] = ModernizedCProgram.hex_to_u32(o_buf_pos + 32);
		generatedO_buf[5] = ModernizedCProgram.hex_to_u32(o_buf_pos + 40);
		generatedO_buf[6] = ModernizedCProgram.hex_to_u32(o_buf_pos + 48);
		generatedO_buf[7] = ModernizedCProgram.hex_to_u32(o_buf_pos + 56);
		pdf.setO_len(o_len)// precompute rc4 data for later use;// precompute rc4 data for later use
		u32[] padding = new u32[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		// md5u32[] salt_pc_block = new u32[]{0};
		u8 salt_pc_ptr = (u8)salt_pc_block;
		.memcpy(salt_pc_ptr, padding, 32);
		int generatedId_len = pdf.getId_len();
		.memcpy(salt_pc_ptr + 32, generatedId_buf, generatedId_len);
		u32[] salt_pc_digest = new u32[]{0};
		ModernizedCProgram.md5_complete_no_limit(salt_pc_digest, salt_pc_block, 32 + generatedId_len);
		Object generatedRc4data = pdf.getRc4data();
		generatedRc4data[0] = salt_pc_digest[0];
		generatedRc4data[1] = salt_pc_digest[1]// we use ID for salt, maybe needs to change, we will see...;// we use ID for salt, maybe needs to change, we will see...
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedId_buf[0];
		generatedSalt_buf[1] = generatedId_buf[1];
		generatedSalt_buf[2] = generatedId_buf[2];
		generatedSalt_buf[3] = generatedId_buf[3];
		generatedSalt_buf[4] = generatedU_buf[0];
		generatedSalt_buf[5] = generatedU_buf[1];
		generatedSalt_buf[6] = generatedO_buf[0];
		generatedSalt_buf[7] = generatedO_buf[1];
		salt.setSalt_len(generatedId_len + 16);
		salt.setSalt_iter((50 + 20));
		digest[0] = generatedU_buf[0];
		digest[1] = generatedU_buf[1];
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 12;
		generatedLen_max[1] = 12;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_327661);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(2048);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		sip_t sip = (sip_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(15);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SIP_AUTH;
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)'*';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 5;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedSep[1] = (byte)'*';
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 512;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[2] = (byte)'*';
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 512;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[3] = (byte)'*';
		generatedLen_min[3] = 0;
		generatedLen_max[3] = 116;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[4] = (byte)'*';
		generatedLen_min[4] = 0;
		generatedLen_max[4] = 116;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[5] = (byte)'*';
		generatedLen_min[5] = 0;
		generatedLen_max[5] = 246;
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[6] = (byte)'*';
		generatedLen_min[6] = 0;
		generatedLen_max[6] = 245;
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[7] = (byte)'*';
		generatedLen_min[7] = 1;
		generatedLen_max[7] = 246;
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[8] = (byte)'*';
		generatedLen_min[8] = 0;
		generatedLen_max[8] = 245;
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[9] = (byte)'*';
		generatedLen_min[9] = 1;
		generatedLen_max[9] = 1024;
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[10] = (byte)'*';
		generatedLen_min[10] = 0;
		generatedLen_max[10] = 1024;
		generatedAttr[10] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[11] = (byte)'*';
		generatedLen_min[11] = 0;
		generatedLen_max[11] = 1024;
		generatedAttr[11] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[12] = (byte)'*';
		generatedLen_min[12] = 0;
		generatedLen_max[12] = 1024;
		generatedAttr[12] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[13] = (byte)'*';
		generatedLen_min[13] = 3;
		generatedLen_max[13] = 3;
		generatedAttr[13] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[14] = (byte)'*';
		generatedLen_min[14] = 32;
		generatedLen_max[14] = 32;
		generatedAttr[14] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 user_pos = generatedBuf[3];
		u8 realm_pos = generatedBuf[4];
		u8 method_pos = generatedBuf[5];
		u8 URI_prefix_pos = generatedBuf[6];
		u8 URI_resource_pos = generatedBuf[7];
		u8 URI_suffix_pos = generatedBuf[8];
		u8 nonce_pos = generatedBuf[9];
		u8 nonce_client_pos = generatedBuf[10];
		u8 nonce_count_pos = generatedBuf[11];
		u8 qop_pos = generatedBuf[12];
		u8 directive_pos = generatedBuf[13];
		u8 digest_pos = generatedBuf[14];
		Object generatedLen = token.getLen();
		int user_len = generatedLen[3];
		int realm_len = generatedLen[4];
		int method_len = generatedLen[5];
		int URI_prefix_len = generatedLen[6];
		int URI_resource_len = generatedLen[7];
		int URI_suffix_len = generatedLen[8];
		int nonce_len = generatedLen[9];
		int nonce_client_len = generatedLen[10];
		int nonce_count_len = generatedLen[11];
		int qop_len = generatedLen[12];
		// verify
		if (.memcmp(directive_pos, "MD5", 3) != 0) {
			return (parser_rc.PARSER_SIP_AUTH_DIRECTIVE/*
			   * first (pre-)compute: HA2 = md5 ($method . ":" . $uri)
			   */);
		} 
		u8 pcsep = (u8)":";
		int md5_len = method_len + 1 + URI_prefix_len + URI_resource_len + URI_suffix_len;
		if (URI_prefix_len) {
			md5_len++;
		} 
		if (URI_suffix_len) {
			md5_len++;
		} 
		int md5_max_len = 4 * 64;
		if (md5_len >= md5_max_len) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		u32[] tmp_md5_buf = new u32[]{0};
		u8 tmp_md5_ptr = (u8)tmp_md5_buf;
		// method
		ModernizedCProgram.hc_strncat(tmp_md5_ptr, method_pos, method_len);
		ModernizedCProgram.hc_strncat(tmp_md5_ptr, pcsep, 1)// URI_prefix;// URI_prefix
		if (URI_prefix_len > 0) {
			ModernizedCProgram.hc_strncat(tmp_md5_ptr, URI_prefix_pos, URI_prefix_len);
			ModernizedCProgram.hc_strncat(tmp_md5_ptr, pcsep, 1);
		} 
		// URI_resource// URI_resourceModernizedCProgram.hc_strncat(tmp_md5_ptr, URI_resource_pos, URI_resource_len);
		ModernizedCProgram.hc_strncat(tmp_md5_ptr, pcsep, 1)// URI_suffix;// URI_suffix
		if (URI_suffix_len > 0) {
			ModernizedCProgram.hc_strncat(tmp_md5_ptr, URI_suffix_pos, URI_suffix_len);
			ModernizedCProgram.hc_strncat(tmp_md5_ptr, pcsep, 1);
		} 
		.memset(tmp_md5_ptr + md5_len, 0,  - md5_len);
		u32[] tmp_digest = new u32();
		ModernizedCProgram.md5_complete_no_limit(tmp_digest, tmp_md5_buf, md5_len);
		tmp_digest[0] = ModernizedCProgram.byte_swap_32(tmp_digest[0]);
		tmp_digest[1] = ModernizedCProgram.byte_swap_32(tmp_digest[1]);
		tmp_digest[2] = ModernizedCProgram.byte_swap_32(tmp_digest[2]);
		tmp_digest[3] = ModernizedCProgram.byte_swap_32(tmp_digest[3/*
		   * esalt
		   */]);
		Object generatedEsalt_buf = sip.getEsalt_buf();
		u8 esalt_buf_ptr = (u8)generatedEsalt_buf;
		int esalt_len = 0;
		int max_esalt_len = ;
		// there are 2 possibilities for the esalt:
		boolean with_auth = false;
		if (qop_len == 4) {
			if (.memcmp((byte)qop_pos, "auth", 4) == 0) {
				with_auth = true;
			} 
		} 
		if (qop_len == 8) {
			if (.memcmp((byte)qop_pos, "auth-int", 8) == 0) {
				with_auth = true;
			} 
		} 
		if (with_auth == true) {
			esalt_len = 1 + nonce_len + 1 + nonce_count_len + 1 + nonce_client_len + 1 + qop_len + 1 + 32;
			if (esalt_len > max_esalt_len) {
				return (parser_rc.PARSER_SALT_LENGTH);
			} 
			ModernizedCProgram.hc_strncat(esalt_buf_ptr, pcsep, 1);
			ModernizedCProgram.hc_strncat(esalt_buf_ptr, nonce_pos, nonce_len);
			ModernizedCProgram.hc_strncat(esalt_buf_ptr, pcsep, 1);
			ModernizedCProgram.hc_strncat(esalt_buf_ptr, nonce_count_pos, nonce_count_len);
			ModernizedCProgram.hc_strncat(esalt_buf_ptr, pcsep, 1);
			ModernizedCProgram.hc_strncat(esalt_buf_ptr, nonce_client_pos, nonce_client_len);
			ModernizedCProgram.hc_strncat(esalt_buf_ptr, pcsep, 1);
			ModernizedCProgram.hc_strncat(esalt_buf_ptr, qop_pos, qop_len);
			ModernizedCProgram.hc_strncat(esalt_buf_ptr, pcsep, 1);
		} else {
				esalt_len = 1 + nonce_len + 1 + 32;
				if (esalt_len > max_esalt_len) {
					return (parser_rc.PARSER_SALT_LENGTH);
				} 
				ModernizedCProgram.hc_strncat(esalt_buf_ptr, pcsep, 1);
				ModernizedCProgram.hc_strncat(esalt_buf_ptr, nonce_pos, nonce_len);
				ModernizedCProgram.hc_strncat(esalt_buf_ptr, pcsep, 1);
		} 
		// tmp_digestu8[] tmp = new u8();
		.snprintf((byte)tmp, , "%08x%08x%08x%08x", tmp_digest[0], tmp_digest[1], tmp_digest[2], tmp_digest[3]);
		ModernizedCProgram.hc_strncat(esalt_buf_ptr, tmp, 32)// add 0x80 to esalt;// add 0x80 to esalt
		esalt_buf_ptr[esalt_len] = -1024;
		sip.setEsalt_len(esalt_len/*
		   * actual salt
		   */);
		Object generatedSalt_buf = sip.getSalt_buf();
		u8 sip_salt_ptr = (u8)generatedSalt_buf;
		int salt_len = user_len + 1 + realm_len + 1;
		int max_salt_len = 119;
		if (salt_len > max_salt_len) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// user_pos
		ModernizedCProgram.hc_strncat(sip_salt_ptr, user_pos, user_len);
		ModernizedCProgram.hc_strncat(sip_salt_ptr, pcsep, 1)// realm_pos;// realm_pos
		ModernizedCProgram.hc_strncat(sip_salt_ptr, realm_pos, realm_len);
		ModernizedCProgram.hc_strncat(sip_salt_ptr, pcsep, 1);
		sip.setSalt_len(salt_len/*
		   * fake salt (for sorting)
		   */);
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		max_salt_len = 55;
		int fake_salt_len = salt_len;
		if (fake_salt_len > max_salt_len) {
			fake_salt_len = max_salt_len;
		} 
		.memcpy(salt_buf_ptr, sip_salt_ptr, fake_salt_len);
		salt.setSalt_len(fake_salt_len/*
		   * digest
		   */);
		digest[0] = ModernizedCProgram.hex_to_u32((u8)digest_pos[0]);
		digest[1] = ModernizedCProgram.hex_to_u32((u8)digest_pos[8]);
		digest[2] = ModernizedCProgram.hex_to_u32((u8)digest_pos[16]);
		digest[3] = ModernizedCProgram.hex_to_u32((u8)digest_pos[24]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		cram_md5_t cram_md5 = (cram_md5_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_CRAM_MD5;
		Object generatedLen = token.getLen();
		generatedLen[0] = 10;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = ((0 * 8) / 6) + 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = ((256 * 8) / 6) + 3;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 44;
		generatedLen_max[2] = 132;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// salt
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// hash
		u8 hash_pos = generatedBuf[2];
		int hash_len = generatedLen[2];
		u8[] tmp_buf = new u8[]{0};
		int tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, (u8)hash_pos, hash_len, tmp_buf);
		if (tmp_len < 32 + 1) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		u32 user_len = tmp_len - 32;
		u8 tmp_hash = tmp_buf + user_len;
		// skip the trailing space// skip the trailing spaceuser_len--;
		if (ModernizedCProgram.is_valid_hex_string(tmp_hash, 32) == 0) {
			return (parser_rc.PARSER_HASH_ENCODING);
		} 
		digest[0] = ModernizedCProgram.hex_to_u32(tmp_hash + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(tmp_hash + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(tmp_hash + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(tmp_hash + 24)// store username for host only (output hash if cracked);// store username for host only (output hash if cracked)
		Object generatedUser = cram_md5.getUser();
		.memset(generatedUser, 0, );
		.memcpy(generatedUser, tmp_buf, user_len);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = "{SHA}";
		Object generatedLen = token.getLen();
		generatedLen[0] = 5;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 28;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 28;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[1];
		int hash_len = generatedLen[1];
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, 20);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256 - 8;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH/*
			   * add static "salt" part
			   */);
		} 
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			if (generatedSalt_len > 46) {
				return (parser_rc.PARSER_SALT_LENGTH);
			} 
		} 
		// max. salt length: 55 (max for MD5) - 8 ("\nskyper\n") - 1 (0x80) = 46
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		.memcpy(salt_buf_ptr + generatedSalt_len, ModernizedCProgram.skyper, .strlen(ModernizedCProgram.skyper));
		generatedSalt_len += .strlen(ModernizedCProgram.skyper);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_2K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		oldoffice01_t oldoffice01 = (oldoffice01_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(5);
		token.setSignatures_cnt(2);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_OLDOFFICE0;
		generatedSignatures_buf[1] = ModernizedCProgram.SIGNATURE_OLDOFFICE1;
		Object generatedLen = token.getLen();
		generatedLen[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 32;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[4] = 32;
		generatedLen_max[4] = 32;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 osalt_pos = generatedBuf[2];
		u8 encryptedVerifier_pos = generatedBuf[3];
		u8 encryptedVerifierHash_pos = generatedBuf[4];
		// esalt
		u32 version = version_pos - -1024;
		if (version != 0 && version != 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		oldoffice01.setVersion(version);
		Object generatedEncryptedVerifier = oldoffice01.getEncryptedVerifier();
		generatedEncryptedVerifier[0] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 0);
		generatedEncryptedVerifier[1] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 8);
		generatedEncryptedVerifier[2] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 16);
		generatedEncryptedVerifier[3] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 24);
		Object generatedEncryptedVerifierHash = oldoffice01.getEncryptedVerifierHash();
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 0);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 8);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 16);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 24)// salt;// salt
		salt.setSalt_len(16);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(osalt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(osalt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(osalt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(osalt_pos + 24)// this is a workaround as office produces multiple documents with the same salt;// this is a workaround as office produces multiple documents with the same salt
		generatedSalt_buf[4] = generatedEncryptedVerifier[0];
		generatedSalt_buf[5] = generatedEncryptedVerifier[1];
		generatedSalt_buf[6] = generatedEncryptedVerifier[2];
		generatedSalt_buf[7] = generatedEncryptedVerifier[3];
		generatedSalt_buf[8] = generatedEncryptedVerifierHash[0];
		generatedSalt_buf[9] = generatedEncryptedVerifierHash[1];
		generatedSalt_buf[10] = generatedEncryptedVerifierHash[2];
		generatedSalt_buf[11] = generatedEncryptedVerifierHash[3];
		Object generatedSalt_len = salt.getSalt_len();
		generatedSalt_len += 32/**
		   * digest
		   */;
		digest[0] = generatedEncryptedVerifierHash[0];
		digest[1] = generatedEncryptedVerifierHash[1];
		digest[2] = generatedEncryptedVerifierHash[2];
		digest[3] = generatedEncryptedVerifierHash[3];
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_64_constants.SHA512M_A;
			digest[1] -= sha2_64_constants.SHA512M_B;
			digest[2] -= sha2_64_constants.SHA512M_C;
			digest[3] -= sha2_64_constants.SHA512M_D;
			digest[4] -= sha2_64_constants.SHA512M_E;
			digest[5] -= sha2_64_constants.SHA512M_F;
			digest[6] -= sha2_64_constants.SHA512M_G;
			digest[7] -= sha2_64_constants.SHA512M_H;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_MSSQL;
		Object generatedLen = token.getLen();
		generatedLen[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		generatedLen[1] = 8;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen[2] = 40;
		generatedAttr[2] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[2];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(3);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[1] = (byte)':';
		generatedLen_min[1] = 32;
		generatedLen_max[1] = 32;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[2] = 2;
		generatedLen_max[2] = 2;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(salt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(salt_pos + 24);
		salt.setSalt_len(16 + 1);
		generatedSalt_buf[4] = ModernizedCProgram.hex_to_u8(generatedBuf[2]);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		dpapimk_t dpapimk = (dpapimk_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(10);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_DPAPIMK;
		Object generatedLen = token.getLen();
		// signature// signaturegeneratedLen[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		// version// versiongeneratedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// context// contextgeneratedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// sid// sidgeneratedLen_min[3] = 10;
		generatedLen_max[3] = 60;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// cipher// ciphergeneratedLen_min[4] = 4;
		generatedLen_max[4] = 6;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// hash// hashgeneratedLen_min[5] = 4;
		generatedLen_max[5] = 6;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// iterations// iterationsgeneratedLen_min[6] = 1;
		generatedLen_max[6] = 6;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// iv// ivgeneratedLen_min[7] = 32;
		generatedLen_max[7] = 32;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		// content len// content lengeneratedLen_min[8] = 1;
		generatedLen_max[8] = 6;
		generatedSep[8] = (byte)'*';
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// content// contentgeneratedLen_min[9] = 0;
		generatedLen_max[9] = 1024;
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 context_pos = generatedBuf[2];
		u8 SID_pos = generatedBuf[3];
		u8 rounds_pos = generatedBuf[6];
		u8 iv_pos = generatedBuf[7];
		u8 contents_len_pos = generatedBuf[8];
		u8 contents_pos = generatedBuf[9/**
		   * content verification
		   */];
		int version = ModernizedCProgram.hc_strtoul((byte)version_pos, ((Object)0), 10);
		int contents_len = ModernizedCProgram.hc_strtoul((byte)contents_len_pos, ((Object)0), 10);
		if (version == 1) {
			if (contents_len != 208) {
				return (parser_rc.PARSER_SALT_LENGTH);
			} 
		}  else if (version == 2) {
			if (contents_len != 288) {
				return (parser_rc.PARSER_SALT_LENGTH);
			} 
		} else {
				return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (contents_len != generatedLen[9]) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		dpapimk.setContents_len(contents_len);
		dpapimk.setContext(ModernizedCProgram.hc_strtoul((byte)context_pos, ((Object)0), 10))// division by 4 should be fine because contents_len is either 208 or 288;// division by 4 should be fine because contents_len is either 208 or 288
		Object generatedContents_len = dpapimk.getContents_len();
		Object generatedContents = dpapimk.getContents();
		for (u32 i = 0;
		 i < generatedContents_len / 4; i++) {
			generatedContents[i] = ModernizedCProgram.hex_to_u32((u8)contents_pos[i * 8]);
			generatedContents[i] = ModernizedCProgram.byte_swap_32(generatedContents[i]);
		}
		// SIDint SID_len = generatedLen[3];
		u8[] SID_utf16le = new u8[]{0};
		for (int i = 0;
		 i < SID_len; i++) {
			SID_utf16le[i * 2] = SID_pos[i];
		}
		dpapimk.setSID_len((SID_len + 1) * /* Specific to DPAPI: needs trailing '\0' while computing hash */2);
		Object generatedSID_len = dpapimk.getSID_len();
		SID_utf16le[generatedSID_len] = -1024;
		Object generatedSID = dpapimk.getSID();
		.memcpy((u8)generatedSID, SID_utf16le, );
		for (u32 i = 0;
		 i < 32; i++) {
			generatedSID[i] = ModernizedCProgram.byte_swap_32(generatedSID[i]);
		}
		Object generatedIv = dpapimk.getIv();
		// iv// ivgeneratedIv[0] = ModernizedCProgram.hex_to_u32((u8)iv_pos[0]);
		generatedIv[1] = ModernizedCProgram.hex_to_u32((u8)iv_pos[8]);
		generatedIv[2] = ModernizedCProgram.hex_to_u32((u8)iv_pos[16]);
		generatedIv[3] = ModernizedCProgram.hex_to_u32((u8)iv_pos[24]);
		generatedIv[0] = ModernizedCProgram.byte_swap_32(generatedIv[0]);
		generatedIv[1] = ModernizedCProgram.byte_swap_32(generatedIv[1]);
		generatedIv[2] = ModernizedCProgram.byte_swap_32(generatedIv[2]);
		generatedIv[3] = ModernizedCProgram.byte_swap_32(generatedIv[3]);
		digest[0] = generatedIv[0];
		digest[1] = generatedIv[1];
		digest[2] = generatedIv[2];
		digest[3] = generatedIv[3];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedIv[0];
		generatedSalt_buf[1] = generatedIv[1];
		generatedSalt_buf[2] = generatedIv[2];
		generatedSalt_buf[3] = generatedIv[3];
		salt.setSalt_len(16)// iter;// iter
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)rounds_pos, ((Object)0), 10) - 1);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_SHA256B64S;
		Object generatedLen = token.getLen();
		generatedLen[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = (((32 + 0) * 8) / 6) + 0;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = (((32 + 256) * 8) / 6) + 3;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64A;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hashsalt_pos = generatedBuf[1];
		int hashsalt_len = generatedLen[1];
		u8[] tmp_buf = new u8[]{0};
		int tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, hashsalt_pos, hashsalt_len, tmp_buf);
		if (tmp_len < 32) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		u8 hash_pos = tmp_buf;
		.memcpy(digest, hash_pos, 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_32_constants.SHA256M_A;
			digest[1] -= sha2_32_constants.SHA256M_B;
			digest[2] -= sha2_32_constants.SHA256M_C;
			digest[3] -= sha2_32_constants.SHA256M_D;
			digest[4] -= sha2_32_constants.SHA256M_E;
			digest[5] -= sha2_32_constants.SHA256M_F;
			digest[6] -= sha2_32_constants.SHA256M_G;
			digest[7] -= sha2_32_constants.SHA256M_H;
		} 
		// saltu8 salt_pos = tmp_buf + 32;
		int salt_len = tmp_len - 32;
		salt.setSalt_len(salt_len);
		Object generatedSalt_buf = salt.getSalt_buf();
		.memcpy(generatedSalt_buf, salt_pos, salt_len);
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_ADD80) {
			u8 ptr = (u8)generatedSalt_buf;
			ptr[salt_len] = -1024;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_500000);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 16;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 16;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = 0;
		digest[3] = 0;
		{ 
			{ 
				u32x t = new u32x();
				t = digest[1] >> 4;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 4;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 16;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 16;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 2;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 2;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 8;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 8;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 1;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 1;
				digest[1] = digest[1] ^ t;
			}
			;
		}
		;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_1K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 64;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 64;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 64;
		generatedLen_max[1] = 64;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// hash
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		digest[7] = ModernizedCProgram.hex_to_u32(hash_pos + 56);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_32(digest[7])// salt;// salt
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH/**
			   * we can precompute the first sha256 transform
			   */);
		} 
		u32[] w = new u32[]{0};
		w[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		w[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		w[2] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[2]);
		w[3] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[3]);
		w[4] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[4]);
		w[5] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[5]);
		w[6] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[6]);
		w[7] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[7]);
		w[8] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[8]);
		w[9] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[9]);
		w[10] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[10]);
		w[11] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[11]);
		w[12] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[12]);
		w[13] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[13]);
		w[14] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[14]);
		w[15] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[15]);
		u32[] pc256 = new u32[]{sha2_32_constants.SHA256M_A, sha2_32_constants.SHA256M_B, sha2_32_constants.SHA256M_C, sha2_32_constants.SHA256M_D, sha2_32_constants.SHA256M_E, sha2_32_constants.SHA256M_F, sha2_32_constants.SHA256M_G, sha2_32_constants.SHA256M_H};
		.sha256_transform(w + 0, w + 4, w + 8, w + 12, pc256);
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		generatedSalt_buf_pc[0] = pc256[0];
		generatedSalt_buf_pc[1] = pc256[1];
		generatedSalt_buf_pc[2] = pc256[2];
		generatedSalt_buf_pc[3] = pc256[3];
		generatedSalt_buf_pc[4] = pc256[4];
		generatedSalt_buf_pc[5] = pc256[5];
		generatedSalt_buf_pc[6] = pc256[6];
		generatedSalt_buf_pc[7] = pc256[7];
		digest[0] -= pc256[0];
		digest[1] -= pc256[1];
		digest[2] -= pc256[2];
		digest[3] -= pc256[3];
		digest[4] -= pc256[4];
		digest[5] -= pc256[5];
		digest[6] -= pc256[6];
		digest[7] -= pc256[7];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 19;
		generatedLen_max[1] = 19;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 128;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 128;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		digest[6] = ModernizedCProgram.hex_to_u64(hash_pos + 96);
		digest[7] = ModernizedCProgram.hex_to_u64(hash_pos + 112);
		digest[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		digest[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		digest[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		digest[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha2_64_constants.SHA512M_A;
			digest[1] -= sha2_64_constants.SHA512M_B;
			digest[2] -= sha2_64_constants.SHA512M_C;
			digest[3] -= sha2_64_constants.SHA512M_D;
			digest[4] -= sha2_64_constants.SHA512M_E;
			digest[5] -= sha2_64_constants.SHA512M_F;
			digest[6] -= sha2_64_constants.SHA512M_G;
			digest[7] -= sha2_64_constants.SHA512M_H;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 16;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 16;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 16;
		generatedLen_max[1] = 16;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// salt
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[2] = 0;
		generatedSalt_buf[3] = 0;
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		generatedSalt_buf_pc[0] = generatedSalt_buf[0];
		generatedSalt_buf_pc[1] = generatedSalt_buf[1];
		{ 
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[1] >> 4;
				t = t ^ generatedSalt_buf_pc[0];
				t = t & -1024;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
				t = t << 4;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[0] >> 16;
				t = t ^ generatedSalt_buf_pc[1];
				t = t & -1024;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
				t = t << 16;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[1] >> 2;
				t = t ^ generatedSalt_buf_pc[0];
				t = t & -1024;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
				t = t << 2;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[0] >> 8;
				t = t ^ generatedSalt_buf_pc[1];
				t = t & -1024;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
				t = t << 8;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = generatedSalt_buf_pc[1] >> 1;
				t = t ^ generatedSalt_buf_pc[0];
				t = t & -1024;
				generatedSalt_buf_pc[0] = generatedSalt_buf_pc[0] ^ t;
				t = t << 1;
				generatedSalt_buf_pc[1] = generatedSalt_buf_pc[1] ^ t;
			}
			;
		}
		;
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = 0;
		digest[3] = 0;
		{ 
			{ 
				u32x t = new u32x();
				t = digest[1] >> 4;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 4;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 16;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 16;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 2;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 2;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 8;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 8;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 1;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 1;
				digest[1] = digest[1] ^ t;
			}
			;
		}
		;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 16;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 16;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 4;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.itoa64_to_int(hash_pos[0]) << 0 | ModernizedCProgram.itoa64_to_int(hash_pos[1]) << 6 | ModernizedCProgram.itoa64_to_int(hash_pos[2]) << 12 | ModernizedCProgram.itoa64_to_int(hash_pos[3]) << 18;
		digest[1] = ModernizedCProgram.itoa64_to_int(hash_pos[4]) << 0 | ModernizedCProgram.itoa64_to_int(hash_pos[5]) << 6 | ModernizedCProgram.itoa64_to_int(hash_pos[6]) << 12 | ModernizedCProgram.itoa64_to_int(hash_pos[7]) << 18;
		digest[2] = ModernizedCProgram.itoa64_to_int(hash_pos[8]) << 0 | ModernizedCProgram.itoa64_to_int(hash_pos[9]) << 6 | ModernizedCProgram.itoa64_to_int(hash_pos[10]) << 12 | ModernizedCProgram.itoa64_to_int(hash_pos[11]) << 18;
		digest[3] = ModernizedCProgram.itoa64_to_int(hash_pos[12]) << 0 | ModernizedCProgram.itoa64_to_int(hash_pos[13]) << 6 | ModernizedCProgram.itoa64_to_int(hash_pos[14]) << 12 | ModernizedCProgram.itoa64_to_int(hash_pos[15]) << 18;
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		// store for encoder// store for encoderdigest[4] = digest[0];
		digest[5] = digest[1];
		digest[6] = digest[2];
		digest[7] = digest[3];
		digest[0] &=  -1024;
		digest[1] &=  -1024;
		digest[2] &=  -1024;
		digest[3] &=  -1024;
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md4_constants.MD4M_A;
			digest[1] -= md4_constants.MD4M_B;
			digest[2] -= md4_constants.MD4M_C;
			digest[3] -= md4_constants.MD4M_D;
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_327661);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(2048);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(5);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_ECRYPTFS;
		Object generatedLen = token.getLen();
		generatedLen[0] = 10;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'$';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[2] = (byte)'$';
		generatedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedSep[3] = (byte)'$';
		generatedLen_min[3] = 16;
		generatedLen_max[3] = 16;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedSep[4] = (byte)'$';
		generatedLen_min[4] = 16;
		generatedLen_max[4] = 16;
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// hash
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[4];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = 0;
		digest[3] = 0;
		digest[4] = 0;
		digest[5] = 0;
		digest[6] = 0;
		digest[7] = 0;
		digest[8] = 0;
		digest[9] = 0;
		digest[10] = 0;
		digest[11] = 0;
		digest[12] = 0;
		digest[13] = 0;
		digest[14] = 0;
		digest[15] = 0;
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1])// salt;// salt
		u8 salt_pos = generatedBuf[3];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(salt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(salt_pos + 8);
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[0]);
		generatedSalt_buf[1] = ModernizedCProgram.byte_swap_32(generatedSalt_buf[1]);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_ECRYPTFS);
		salt.setSalt_len(8);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 56;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		int hash_len = generatedLen[0];
		if (hash_len != 56) {
			return (parser_rc.PARSER_GLOBAL_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[5] = ModernizedCProgram.hex_to_u32(hash_pos + 40);
		digest[6] = ModernizedCProgram.hex_to_u32(hash_pos + 48);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 6;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 6;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// now we need to reduce our hash into a tokenint otp_code = ModernizedCProgram.hc_strtoul((byte)line_buf, ((Object)0), 10);
		digest[0] = otp_code;
		Object generatedBuf = token.getBuf();
		u8 salt_pos = generatedBuf[1];
		// convert ascii timestamp to ulong timestampu64 timestamp = ModernizedCProgram.hc_strtoull((byte)salt_pos, ((Object)0), 10);
		Object generatedSalt_buf = salt.getSalt_buf();
		// store the original salt value. Step division will destroy granularity for output// store the original salt value. Step division will destroy granularity for outputgeneratedSalt_buf[3] = ((u32)(timestamp >> 0));
		generatedSalt_buf[2] = ((u32)(timestamp >> 32));
		// divide our timestamp by our step. We will use the RFC 6238 default of 30 for now// divide our timestamp by our step. We will use the RFC 6238 default of 30 for nowtimestamp /= 30;
		// convert counter to 8-byte salt// convert counter to 8-byte saltgeneratedSalt_buf[1] = ModernizedCProgram.byte_swap_32((u32)(timestamp >> 0));
		generatedSalt_buf[0] = ModernizedCProgram.byte_swap_32((u32)(timestamp >> 32));
		// our salt will always be 8 bytes, but we are going to cheat and store it twice, so...// our salt will always be 8 bytes, but we are going to cheat and store it twice, so...salt.setSalt_len(16);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		ModernizedCProgram.precompute_salt_md5(generatedSalt_buf, generatedSalt_len, (u8)generatedSalt_buf_pc);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		Object generatedLen = token.getLen();
		generatedLen[1] = 2;
		generatedAttr[1] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u64 digest = (u64)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 96;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		int hash_len = generatedLen[0];
		if (hash_len != 96) {
			return (parser_rc.PARSER_GLOBAL_LENGTH);
		} 
		digest[0] = ModernizedCProgram.hex_to_u64(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u64(hash_pos + 16);
		digest[2] = ModernizedCProgram.hex_to_u64(hash_pos + 32);
		digest[3] = ModernizedCProgram.hex_to_u64(hash_pos + 48);
		digest[4] = ModernizedCProgram.hex_to_u64(hash_pos + 64);
		digest[5] = ModernizedCProgram.hex_to_u64(hash_pos + 80);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		vc_t vc = (vc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = vc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = vc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_VERACRYPT_655331);
		Object generatedSalt_iter = salt.getSalt_iter();
		generatedSalt_iter--;
		vc.setPim_multi(1000);
		vc.setPim_start(0);
		vc.setPim_stop(0);
		// "VERA"// "VERA"vc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 0;
		generatedLen_max[1] = 256;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			generatedLen_min[1] *= 2;
			generatedLen_max[1] *= 2;
			generatedAttr[1] |=  token_attr.TOKEN_ATTR_VERIFY_HEX;
		} 
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= sha1_constants.SHA1M_A;
			digest[1] -= sha1_constants.SHA1M_B;
			digest[2] -= sha1_constants.SHA1M_C;
			digest[3] -= sha1_constants.SHA1M_D;
			digest[4] -= sha1_constants.SHA1M_E;
		} 
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(2);
		Object generatedSep = token.getSep();
		generatedSep[0] = hashconfig.getSeparator();
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 40;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 40;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[1] = 9;
		generatedLen_max[1] = 9;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		digest[4] = ModernizedCProgram.hex_to_u32(hash_pos + 32);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		u8 salt_pos = generatedBuf[1];
		Object generatedLen = token.getLen();
		int salt_len = generatedLen[1];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		dpapimk_t dpapimk = (dpapimk_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(10);
		token.setSignatures_cnt(1);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_DPAPIMK;
		Object generatedLen = token.getLen();
		// signature// signaturegeneratedLen[0] = 9;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		// version// versiongeneratedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// context// contextgeneratedLen_min[2] = 1;
		generatedLen_max[2] = 1;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// sid// sidgeneratedLen_min[3] = 10;
		generatedLen_max[3] = 60;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// cipher// ciphergeneratedLen_min[4] = 4;
		generatedLen_max[4] = 6;
		generatedSep[4] = (byte)'*';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// hash// hashgeneratedLen_min[5] = 4;
		generatedLen_max[5] = 6;
		generatedSep[5] = (byte)'*';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		// iterations// iterationsgeneratedLen_min[6] = 1;
		generatedLen_max[6] = 6;
		generatedSep[6] = (byte)'*';
		generatedAttr[6] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// iv// ivgeneratedLen_min[7] = 32;
		generatedLen_max[7] = 32;
		generatedSep[7] = (byte)'*';
		generatedAttr[7] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		// content len// content lengeneratedLen_min[8] = 1;
		generatedLen_max[8] = 6;
		generatedSep[8] = (byte)'*';
		generatedAttr[8] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		// content// contentgeneratedLen_min[9] = 0;
		generatedLen_max[9] = 1024;
		generatedAttr[9] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 context_pos = generatedBuf[2];
		u8 SID_pos = generatedBuf[3];
		u8 rounds_pos = generatedBuf[6];
		u8 iv_pos = generatedBuf[7];
		u8 contents_len_pos = generatedBuf[8];
		u8 contents_pos = generatedBuf[9/**
		   * content verification
		   */];
		int version = ModernizedCProgram.hc_strtoul((byte)version_pos, ((Object)0), 10);
		int contents_len = ModernizedCProgram.hc_strtoul((byte)contents_len_pos, ((Object)0), 10);
		if (version == 1) {
			if (contents_len != 208) {
				return (parser_rc.PARSER_SALT_LENGTH);
			} 
		}  else if (version == 2) {
			if (contents_len != 288) {
				return (parser_rc.PARSER_SALT_LENGTH);
			} 
		} else {
				return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (contents_len != generatedLen[9]) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		dpapimk.setContents_len(contents_len);
		dpapimk.setContext(ModernizedCProgram.hc_strtoul((byte)context_pos, ((Object)0), 10))// division by 4 should be fine because contents_len is either 208 or 288;// division by 4 should be fine because contents_len is either 208 or 288
		Object generatedContents_len = dpapimk.getContents_len();
		Object generatedContents = dpapimk.getContents();
		for (u32 i = 0;
		 i < generatedContents_len / 4; i++) {
			generatedContents[i] = ModernizedCProgram.hex_to_u32((u8)contents_pos[i * 8]);
			generatedContents[i] = ModernizedCProgram.byte_swap_32(generatedContents[i]);
		}
		// SIDint SID_len = generatedLen[3];
		u8[] SID_utf16le = new u8[]{0};
		for (int i = 0;
		 i < SID_len; i++) {
			SID_utf16le[i * 2] = SID_pos[i];
		}
		dpapimk.setSID_len((SID_len + 1) * /* Specific to DPAPI: needs trailing '\0' while computing hash */2);
		Object generatedSID_len = dpapimk.getSID_len();
		SID_utf16le[generatedSID_len] = -1024;
		Object generatedSID = dpapimk.getSID();
		.memcpy((u8)generatedSID, SID_utf16le, );
		for (u32 i = 0;
		 i < 32; i++) {
			generatedSID[i] = ModernizedCProgram.byte_swap_32(generatedSID[i]);
		}
		Object generatedIv = dpapimk.getIv();
		// iv// ivgeneratedIv[0] = ModernizedCProgram.hex_to_u32((u8)iv_pos[0]);
		generatedIv[1] = ModernizedCProgram.hex_to_u32((u8)iv_pos[8]);
		generatedIv[2] = ModernizedCProgram.hex_to_u32((u8)iv_pos[16]);
		generatedIv[3] = ModernizedCProgram.hex_to_u32((u8)iv_pos[24]);
		generatedIv[0] = ModernizedCProgram.byte_swap_32(generatedIv[0]);
		generatedIv[1] = ModernizedCProgram.byte_swap_32(generatedIv[1]);
		generatedIv[2] = ModernizedCProgram.byte_swap_32(generatedIv[2]);
		generatedIv[3] = ModernizedCProgram.byte_swap_32(generatedIv[3]);
		digest[0] = generatedIv[0];
		digest[1] = generatedIv[1];
		digest[2] = generatedIv[2];
		digest[3] = generatedIv[3];
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = generatedIv[0];
		generatedSalt_buf[1] = generatedIv[1];
		generatedSalt_buf[2] = generatedIv[2];
		generatedSalt_buf[3] = generatedIv[3];
		salt.setSalt_len(16)// iter;// iter
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)rounds_pos, ((Object)0), 10) - 1);
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(4);
		Object generatedSep = token.getSep();
		generatedSep[0] = (byte)':';
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[1] = (byte)':';
		generatedLen_min[1] = 1;
		generatedLen_max[1] = 32;
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[2] = (byte)':';
		generatedLen_min[2] = 0;
		generatedLen_max[2] = 32;
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedSep[3] = (byte)':';
		generatedLen_min[3] = 1;
		generatedLen_max[3] = 6;
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		// ok, the plan for this algorithm is the following:// we have 2 salts here, the domain-name and a random salt// while both are used in the initial transformation,// only the random salt is used in the following iterations
		Object generatedBuf = token.getBuf();
		// so we create two buffer, one that includes domain-name (stored into salt_buf_pc[])// and one that includes only the real salt (stored into salt_buf[]).// the domain-name length is put into array position 7 of salt_buf_pc[] since there is not salt_pc_lenu8 hash_pos = generatedBuf[0];
		Object generatedLen = token.getLen();
		int hash_len = generatedLen[0];
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base32_decode(ModernizedCProgram.itoa32_to_int, hash_pos, hash_len, tmp_buf);
		.memcpy(digest, tmp_buf, 20);
		digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		digest[4] = ModernizedCProgram.byte_swap_32(digest[4])// domain;// domain
		u8 domain_pos = generatedBuf[1];
		int domain_len = generatedLen[1];
		Object generatedSalt_buf_pc = salt.getSalt_buf_pc();
		u8 salt_buf_pc_ptr = (u8)generatedSalt_buf_pc;
		.memcpy(salt_buf_pc_ptr, domain_pos, domain_len);
		if (salt_buf_pc_ptr[0] != (byte)'.') {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		u8 len_ptr = salt_buf_pc_ptr;
		len_ptr = 0;
		for (int i = 1;
		 i < domain_len; i++) {
			if (salt_buf_pc_ptr[i] == (byte)'.') {
				len_ptr = salt_buf_pc_ptr + i;
				len_ptr = 0;
			} else {
					len_ptr += 1;
			} 
		}
		salt.setSalt_len_pc(domain_len)// "real" salt;// "real" salt
		u8 salt_pos = generatedBuf[2];
		int salt_len = generatedLen[2];
		Object generatedSalt_buf = salt.getSalt_buf();
		Object generatedSalt_len = salt.getSalt_len();
		boolean parse_rc = ModernizedCProgram.generic_salt_decode(hashconfig, salt_pos, salt_len, (u8)generatedSalt_buf, (int)generatedSalt_len);
		if (parse_rc == 0) {
			return (parser_rc.PARSER_SALT_LENGTH);
		} 
		// iteration
		u8 iter_pos = generatedBuf[3];
		salt.setSalt_iter(ModernizedCProgram.hc_strtoul((byte)iter_pos, ((Object)0), 10));
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		oldoffice01_t oldoffice01 = (oldoffice01_t)esalt_buf;
		token_t token = new token_t();
		token.setToken_cnt(6);
		token.setSignatures_cnt(2);
		Object generatedSignatures_buf = token.getSignatures_buf();
		generatedSignatures_buf[0] = ModernizedCProgram.SIGNATURE_OLDOFFICE0;
		generatedSignatures_buf[1] = ModernizedCProgram.SIGNATURE_OLDOFFICE1;
		Object generatedLen = token.getLen();
		generatedLen[0] = 11;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_SIGNATURE;
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[1] = 1;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[1] = 1;
		Object generatedSep = token.getSep();
		generatedSep[1] = (byte)'*';
		generatedAttr[1] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_DIGIT;
		generatedLen_min[2] = 32;
		generatedLen_max[2] = 32;
		generatedSep[2] = (byte)'*';
		generatedAttr[2] = token_attr.TOKEN_ATTR_VERIFY_LENGTH;
		generatedLen_min[3] = 32;
		generatedLen_max[3] = 32;
		generatedSep[3] = (byte)'*';
		generatedAttr[3] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[4] = 32;
		generatedLen_max[4] = 32;
		generatedSep[4] = (byte)':';
		generatedAttr[4] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		generatedLen_min[5] = 10;
		generatedLen_max[5] = 10;
		generatedSep[5] = (byte)':';
		generatedAttr[5] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 version_pos = generatedBuf[1];
		u8 osalt_pos = generatedBuf[2];
		u8 encryptedVerifier_pos = generatedBuf[3];
		u8 encryptedVerifierHash_pos = generatedBuf[4];
		u8 rc4key_pos = generatedBuf[5];
		// esalt
		u32 version = version_pos - -1024;
		if (version != 0 && version != 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		oldoffice01.setVersion(version);
		Object generatedEncryptedVerifier = oldoffice01.getEncryptedVerifier();
		generatedEncryptedVerifier[0] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 0);
		generatedEncryptedVerifier[1] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 8);
		generatedEncryptedVerifier[2] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 16);
		generatedEncryptedVerifier[3] = ModernizedCProgram.hex_to_u32(encryptedVerifier_pos + 24);
		Object generatedEncryptedVerifierHash = oldoffice01.getEncryptedVerifierHash();
		generatedEncryptedVerifierHash[0] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 0);
		generatedEncryptedVerifierHash[1] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 8);
		generatedEncryptedVerifierHash[2] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 16);
		generatedEncryptedVerifierHash[3] = ModernizedCProgram.hex_to_u32(encryptedVerifierHash_pos + 24);
		Object generatedRc4key = oldoffice01.getRc4key();
		generatedRc4key[1] = 0;
		generatedRc4key[0] = 0;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[0]) << 28;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[1]) << 24;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[2]) << 20;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[3]) << 16;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[4]) << 12;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[5]) << 8;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[6]) << 4;
		generatedRc4key[0] |=  ModernizedCProgram.hex_convert(rc4key_pos[7]) << 0;
		generatedRc4key[1] |=  ModernizedCProgram.hex_convert(rc4key_pos[8]) << 28;
		generatedRc4key[1] |=  ModernizedCProgram.hex_convert(rc4key_pos[9]) << 24;
		generatedRc4key[0] = ModernizedCProgram.byte_swap_32(generatedRc4key[0]);
		generatedRc4key[1] = ModernizedCProgram.byte_swap_32(generatedRc4key[1])// salt;// salt
		salt.setSalt_len(16);
		Object generatedSalt_buf = salt.getSalt_buf();
		generatedSalt_buf[0] = ModernizedCProgram.hex_to_u32(osalt_pos + 0);
		generatedSalt_buf[1] = ModernizedCProgram.hex_to_u32(osalt_pos + 8);
		generatedSalt_buf[2] = ModernizedCProgram.hex_to_u32(osalt_pos + 16);
		generatedSalt_buf[3] = ModernizedCProgram.hex_to_u32(osalt_pos + 24)// this is a workaround as office produces multiple documents with the same salt;// this is a workaround as office produces multiple documents with the same salt
		generatedSalt_buf[4] = generatedEncryptedVerifier[0];
		generatedSalt_buf[5] = generatedEncryptedVerifier[1];
		generatedSalt_buf[6] = generatedEncryptedVerifier[2];
		generatedSalt_buf[7] = generatedEncryptedVerifier[3];
		generatedSalt_buf[8] = generatedEncryptedVerifierHash[0];
		generatedSalt_buf[9] = generatedEncryptedVerifierHash[1];
		generatedSalt_buf[10] = generatedEncryptedVerifierHash[2];
		generatedSalt_buf[11] = generatedEncryptedVerifierHash[3];
		Object generatedSalt_len = salt.getSalt_len();
		generatedSalt_len += 32/**
		   * digest
		   */;
		digest[0] = generatedRc4key[0];
		digest[1] = generatedRc4key[1];
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen = token.getLen();
		generatedLen[0] = 10;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_FIXED_LENGTH | token_attr.TOKEN_ATTR_VERIFY_BASE64B;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		byte c9 = ModernizedCProgram.itoa64_to_int(hash_pos[9]);
		if (c9 & 3) {
			return (parser_rc.PARSER_HASH_VALUE);
		} 
		u8[] add_leading_zero = new u8();
		add_leading_zero[0] = (byte)'.';
		.memcpy(add_leading_zero + 1, line_buf, 10);
		u8[] tmp_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.itoa64_to_int, (u8)add_leading_zero, 11, tmp_buf);
		.memcpy(digest, tmp_buf, 8);
		{ 
			{ 
				u32x t = new u32x();
				t = digest[1] >> 4;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 4;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 16;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 16;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 2;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 2;
				digest[1] = digest[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[0] >> 8;
				t = t ^ digest[1];
				t = t & -1024;
				digest[1] = digest[1] ^ t;
				t = t << 8;
				digest[0] = digest[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = digest[1] >> 1;
				t = t ^ digest[0];
				t = t & -1024;
				digest[0] = digest[0] ^ t;
				t = t << 1;
				digest[1] = digest[1] ^ t;
			}
			;
		}
		;
		digest[2] = 0;
		digest[3] = 0;
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		tc_t tc = (tc_t)esalt_buf;
		double entropy = ModernizedCProgram.get_entropy((u8)line_buf, line_len);
		if (entropy < ModernizedCProgram.MIN_SUFFICIENT_ENTROPY_FILE) {
			return (parser_rc.PARSER_INSUFFICIENT_ENTROPY);
		} 
		Object generatedSalt_buf = tc.getSalt_buf();
		.memcpy(generatedSalt_buf, line_buf, 64);
		Object generatedData_buf = tc.getData_buf();
		.memcpy(generatedData_buf, line_buf + 64, 512 - 64);
		generatedSalt_buf[0] = generatedSalt_buf[0];
		salt.setSalt_len(4);
		salt.setSalt_iter(ModernizedCProgram.ROUNDS_TRUECRYPT_1K - 1);
		// "TRUE"// "TRUE"tc.setSignature(-1024);
		digest[0] = generatedData_buf[0];
		return (parser_rc.PARSER_OK);
		u32 digest = (u32)digest_buf;
		token_t token = new token_t();
		token.setToken_cnt(1);
		Object generatedLen_min = token.getLen_min();
		generatedLen_min[0] = 32;
		Object generatedLen_max = token.getLen_max();
		generatedLen_max[0] = 32;
		Object generatedAttr = token.getAttr();
		generatedAttr[0] = token_attr.TOKEN_ATTR_VERIFY_LENGTH | token_attr.TOKEN_ATTR_VERIFY_HEX;
		int rc_tokenizer = token.input_tokenizer((u8)line_buf, line_len);
		if (rc_tokenizer != parser_rc.PARSER_OK) {
			return (rc_tokenizer);
		} 
		Object generatedBuf = token.getBuf();
		u8 hash_pos = generatedBuf[0];
		digest[0] = ModernizedCProgram.hex_to_u32(hash_pos + 0);
		digest[1] = ModernizedCProgram.hex_to_u32(hash_pos + 8);
		digest[2] = ModernizedCProgram.hex_to_u32(hash_pos + 16);
		digest[3] = ModernizedCProgram.hex_to_u32(hash_pos + 24);
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			digest[0] -= md5_constants.MD5M_A;
			digest[1] -= md5_constants.MD5M_B;
			digest[2] -= md5_constants.MD5M_C;
			digest[3] -= md5_constants.MD5M_D;
		} 
		return (parser_rc.PARSER_OK);
	}
	public static int module_hash_encode(Object hashconfig, Object digest_buf, Object salt, Object esalt_buf, Object hook_salt_buf, Object hash_info, Byte line_buf, Object line_size) {
		u32 digest = (u32)digest_buf;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s$%08X%08X%08X%08X%08X", tmp_salt, digest[0], digest[1], digest[2], digest[3], digest[4]);
		return line_len;
		u32 digest = (u32)digest_buf;
		devise_hash_t devise_double_salt = (devise_hash_t)esalt_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)devise_double_salt.getSalt_buf(), (int)devise_double_salt.getSalt_len(), out_buf + out_len);
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)devise_double_salt.getSite_key_buf(), (int)devise_double_salt.getSite_key_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u64 digest = (u64)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_64_constants.SHA512M_A;
			tmp[1] += sha2_64_constants.SHA512M_B;
			tmp[2] += sha2_64_constants.SHA512M_C;
			tmp[3] += sha2_64_constants.SHA512M_D;
			tmp[4] += sha2_64_constants.SHA512M_E;
			tmp[5] += sha2_64_constants.SHA512M_F;
			tmp[6] += sha2_64_constants.SHA512M_G;
			tmp[7] += sha2_64_constants.SHA512M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(tmp[7]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + 16);
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + 32);
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + 48);
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + 64);
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + 80);
		ModernizedCProgram.u64_to_hex(tmp[6], out_buf + 96);
		ModernizedCProgram.u64_to_hex(tmp[7], out_buf + 112);
		int out_len = 128;
		return out_len;
		int line_len = .snprintf(line_buf, line_size, "%s*1*%u*%08x%08x%08x%08x*%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_AXCRYPT, salt.getSalt_iter(), salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3], salt.getSalt_buf()[4], salt.getSalt_buf()[5], salt.getSalt_buf()[6], salt.getSalt_buf()[7], salt.getSalt_buf()[8], salt.getSalt_buf()[9]);
		return line_len;
		u32 digest = (u32)digest_buf;
		// encode iteration count
		byte[] salt_iter = new byte[5];
		salt_iter[0] = ModernizedCProgram.int_to_itoa64((salt.getSalt_iter()) & -1024);
		salt_iter[1] = ModernizedCProgram.int_to_itoa64((salt.getSalt_iter() >> 6) & -1024);
		salt_iter[2] = ModernizedCProgram.int_to_itoa64((salt.getSalt_iter() >> 12) & -1024);
		salt_iter[3] = ModernizedCProgram.int_to_itoa64((salt.getSalt_iter() >> 18) & -1024);
		salt_iter[4] = 0// encode salt;// encode salt
		byte[] ptr_salt = new byte[5];
		ptr_salt[0] = ModernizedCProgram.int_to_itoa64((salt.getSalt_buf()[0]) & -1024);
		ptr_salt[1] = ModernizedCProgram.int_to_itoa64((salt.getSalt_buf()[0] >> 6) & -1024);
		ptr_salt[2] = ModernizedCProgram.int_to_itoa64((salt.getSalt_buf()[0] >> 12) & -1024);
		ptr_salt[3] = ModernizedCProgram.int_to_itoa64((salt.getSalt_buf()[0] >> 18) & -1024);
		ptr_salt[4] = 0// encode digest;// encode digest
		u32[] tmp = new u32();
		tmp[0] = ModernizedCProgram.rotl32(digest[0], 31);
		tmp[1] = ModernizedCProgram.rotl32(digest[1], 31);
		{ 
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 1;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 1;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 8;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 8;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 2;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 2;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 16;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 16;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 4;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 4;
				tmp[1] = tmp[1] ^ t;
			}
			;
		}
		;
		byte[] ptr_plain = new byte[12];
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_itoa64, (u8)tmp, 8, (u8)ptr_plain);
		ptr_plain[11] = 0// fill the resulting buffer;// fill the resulting buffer
		int line_len = .snprintf(line_buf, line_size, "_%s%s%s", salt_iter, ptr_salt, ptr_plain);
		return line_len;
		u32 digest = (u32)digest_buf;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		byte[] ptr_plain = new byte[32];
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp, 20, (u8)ptr_plain);
		ptr_plain[27] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s*0*%s*%s", ModernizedCProgram.SIGNATURE_EPISERVER, tmp_salt, ptr_plain);
		return line_len;
		u32 digest = (u32)digest_buf;
		int line_len = 0;
		int iter = salt.getSalt_iter();
		if (iter == ModernizedCProgram.ROUNDS_QNX) {
			line_buf[line_len++] = (byte)'@';
			line_buf[line_len++] = (byte)'s';
			line_buf[line_len++] = (byte)'@';
		} else {
				line_buf[line_len++] = (byte)'@';
				line_buf[line_len++] = (byte)'s';
				line_buf[line_len++] = (byte)',';
				line_len += .snprintf(line_buf + line_len, line_size - line_len, "%d", iter);
				line_buf[line_len++] = (byte)'@';
		} 
		ModernizedCProgram.u32_to_hex(digest[0], (u8)line_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(digest[1], (u8)line_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(digest[2], (u8)line_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(digest[3], (u8)line_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(digest[4], (u8)line_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(digest[5], (u8)line_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(digest[6], (u8)line_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(digest[7], (u8)line_buf + line_len);
		line_len += 8;
		line_buf[line_len++] = (byte)'@';
		.memcpy(line_buf + line_len, salt.getSalt_buf(), salt.getSalt_len());
		line_len += salt.getSalt_len();
		line_buf[line_len] = 0;
		return line_len;
		u32 digest = (u32)digest_buf;
		int line_len = 0;
		// signature
		line_buf[line_len++] = (byte)'$';
		line_buf[line_len++] = (byte)'S';
		line_buf[line_len++] = (byte)'H';
		line_buf[line_len++] = (byte)'A';
		line_buf[line_len++] = (byte)'$'// salt;// salt
		.memcpy(line_buf + line_len, salt.getSalt_buf(), salt.getSalt_len());
		line_len += salt.getSalt_len();
		line_buf[line_len++] = (byte)'$'// digest;// digest
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + line_len);
		line_len += 8;
		line_buf[line_len] = 0;
		return line_len;
		u64 digest = (u64)digest_buf;
		// this (useless?) initialization makes scan-build happyu64[] tmp = new u64[]{0};
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(tmp[7]);
		byte[] ptr_plain = new byte[]{0};
		ModernizedCProgram.sha512aix_encode((byte)tmp, (byte)ptr_plain);
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%02u$%s$%s", ModernizedCProgram.SIGNATURE_SHA512AIX, salt.getSalt_sign()[0], tmp_salt, ptr_plain);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		byte[] tmp_buf = new byte[64];
		.memcpy(tmp_buf + 0, tmp, 20);
		.memcpy(tmp_buf + 20, salt.getSalt_buf(), salt.getSalt_len());
		u32 tmp_len = 20 + salt.getSalt_len();
		// base64 encode it
		byte[] base64_encoded = new byte[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp_buf, tmp_len, (u8)base64_encoded);
		int line_len = .snprintf(line_buf, line_size, "%s%u}%s", ModernizedCProgram.SIGNATURE_SAPH_SHA1, salt.getSalt_iter() + 1, base64_encoded);
		return line_len;
		u32 digest = (u32)digest_buf;
		int line_len = .snprintf(line_buf, line_size, "%08X%08X", ModernizedCProgram.byte_swap_32(digest[0]), ModernizedCProgram.byte_swap_32(digest[1]));
		line_buf[line_len] = hashconfig.getSeparator();
		line_len += 1;
		line_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)line_buf + line_len);
		return line_len;
		pdf_t pdf = (pdf_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "$pdf$%d*%d*%d*%d*%d*%d*%08x%08x%08x%08x*%d*%08x%08x%08x%08x%08x%08x%08x%08x*%d*%08x%08x%08x%08x%08x%08x%08x%08x", pdf.getV(), pdf.getR(), 40, pdf.getP(), pdf.getEnc_md(), pdf.getId_len(), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[3]), pdf.getU_len(), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[3]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[4]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[5]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[6]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[7]), pdf.getO_len(), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[3]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[4]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[5]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[6]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[7]));
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		wpa_eapol_t wpa_eapol = (wpa_eapol_t)esalt_buf;
		int line_len = 0;
		if (ModernizedCProgram.need_hexify(wpa_eapol.getEssid(), wpa_eapol.getEssid_len(), (byte)':', 0) == 1) {
			byte[] tmp_buf = new byte[128];
			int tmp_len = 0;
			tmp_buf[tmp_len++] = (byte)'$';
			tmp_buf[tmp_len++] = (byte)'H';
			tmp_buf[tmp_len++] = (byte)'E';
			tmp_buf[tmp_len++] = (byte)'X';
			tmp_buf[tmp_len++] = (byte)'[';
			ModernizedCProgram.exec_hexify(wpa_eapol.getEssid(), wpa_eapol.getEssid_len(), (u8)tmp_buf + tmp_len);
			tmp_len += wpa_eapol.getEssid_len() * 2;
			tmp_buf[tmp_len++] = (byte)']';
			tmp_buf[tmp_len++] = 0;
			line_len = .snprintf(line_buf, line_size, "%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%s", wpa_eapol.getOrig_mac_ap()[0], wpa_eapol.getOrig_mac_ap()[1], wpa_eapol.getOrig_mac_ap()[2], wpa_eapol.getOrig_mac_ap()[3], wpa_eapol.getOrig_mac_ap()[4], wpa_eapol.getOrig_mac_ap()[5], wpa_eapol.getOrig_mac_sta()[0], wpa_eapol.getOrig_mac_sta()[1], wpa_eapol.getOrig_mac_sta()[2], wpa_eapol.getOrig_mac_sta()[3], wpa_eapol.getOrig_mac_sta()[4], wpa_eapol.getOrig_mac_sta()[5], tmp_buf);
		} else {
				line_len = .snprintf(line_buf, line_size, "%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%s", wpa_eapol.getOrig_mac_ap()[0], wpa_eapol.getOrig_mac_ap()[1], wpa_eapol.getOrig_mac_ap()[2], wpa_eapol.getOrig_mac_ap()[3], wpa_eapol.getOrig_mac_ap()[4], wpa_eapol.getOrig_mac_ap()[5], wpa_eapol.getOrig_mac_sta()[0], wpa_eapol.getOrig_mac_sta()[1], wpa_eapol.getOrig_mac_sta()[2], wpa_eapol.getOrig_mac_sta()[3], wpa_eapol.getOrig_mac_sta()[4], wpa_eapol.getOrig_mac_sta()[5], wpa_eapol.getEssid());
		} 
		return line_len;
		oldoffice34_t oldoffice34 = (oldoffice34_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%s%u*%08x%08x%08x%08x*%08x%08x%08x%08x*%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_OLDOFFICE, oldoffice34.getVersion(), salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3], ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[0]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[1]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[2]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[3]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[0]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[1]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[2]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[3]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[4]));
		return line_len;
		return .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		u32 digest = (u32)digest_buf;
		ikepsk_t ikepsk = (ikepsk_t)esalt_buf;
		int line_len = 0;
		// msg_buf
		u32 ikepsk_msg_len = ikepsk.getMsg_len()[5] / 4;
		for (u32 i = 0;
		 i < ikepsk_msg_len; i++) {
			if ((i == ikepsk.getMsg_len()[0] / 4) || (i == ikepsk.getMsg_len()[1] / 4) || (i == ikepsk.getMsg_len()[2] / 4) || (i == ikepsk.getMsg_len()[3] / 4) || (i == ikepsk.getMsg_len()[4] / 4)) {
				line_len += .snprintf(line_buf + line_len, line_size - line_len, ":");
			} 
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%08x", ModernizedCProgram.byte_swap_32(ikepsk.getMsg_buf()[i]));
		}
		// nr_bufu32 ikepsk_nr_len = ikepsk.getNr_len() / 4;
		for (u32 i = 0;
		 i < ikepsk_nr_len; i++) {
			if ((i == 0) || (i == 5)) {
				line_len += .snprintf(line_buf + line_len, line_size - line_len, ":");
			} 
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%08x", ModernizedCProgram.byte_swap_32(ikepsk.getNr_buf()[i]));
		}
		// digest_buffor (u32 i = 0;
		 i < 4; i++) {
			if (i == 0) {
				line_len += .snprintf(line_buf + line_len, line_size - line_len, ":");
			} 
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%08x", ModernizedCProgram.byte_swap_32(digest[i]));
		}
		return line_len;
		u32 digest = (u32)digest_buf;
		u32 salt_challenge = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]);
		byte[] user_name = new byte[]{0};
		.memcpy(user_name, salt.getSalt_buf() + 1, salt.getSalt_len() - 4);
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		int line_len = .snprintf(line_buf, line_size, "%s%s*%08x*%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_POSTGRESQL_AUTH, user_name, salt_challenge, ModernizedCProgram.byte_swap_32(tmp[0]), ModernizedCProgram.byte_swap_32(tmp[1]), ModernizedCProgram.byte_swap_32(tmp[2]), ModernizedCProgram.byte_swap_32(tmp[3]));
		return line_len;
		wpa_eapol_t wpa_eapol = (wpa_eapol_t)esalt_buf;
		int line_len = 0;
		if (ModernizedCProgram.need_hexify(wpa_eapol.getEssid(), wpa_eapol.getEssid_len(), (byte)':', 0) == 1) {
			byte[] tmp_buf = new byte[128];
			int tmp_len = 0;
			tmp_buf[tmp_len++] = (byte)'$';
			tmp_buf[tmp_len++] = (byte)'H';
			tmp_buf[tmp_len++] = (byte)'E';
			tmp_buf[tmp_len++] = (byte)'X';
			tmp_buf[tmp_len++] = (byte)'[';
			ModernizedCProgram.exec_hexify(wpa_eapol.getEssid(), wpa_eapol.getEssid_len(), (u8)tmp_buf + tmp_len);
			tmp_len += wpa_eapol.getEssid_len() * 2;
			tmp_buf[tmp_len++] = (byte)']';
			tmp_buf[tmp_len++] = 0;
			line_len = .snprintf(line_buf, line_size, "%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%s", wpa_eapol.getOrig_mac_ap()[0], wpa_eapol.getOrig_mac_ap()[1], wpa_eapol.getOrig_mac_ap()[2], wpa_eapol.getOrig_mac_ap()[3], wpa_eapol.getOrig_mac_ap()[4], wpa_eapol.getOrig_mac_ap()[5], wpa_eapol.getOrig_mac_sta()[0], wpa_eapol.getOrig_mac_sta()[1], wpa_eapol.getOrig_mac_sta()[2], wpa_eapol.getOrig_mac_sta()[3], wpa_eapol.getOrig_mac_sta()[4], wpa_eapol.getOrig_mac_sta()[5], tmp_buf);
		} else {
				line_len = .snprintf(line_buf, line_size, "%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%s", wpa_eapol.getOrig_mac_ap()[0], wpa_eapol.getOrig_mac_ap()[1], wpa_eapol.getOrig_mac_ap()[2], wpa_eapol.getOrig_mac_ap()[3], wpa_eapol.getOrig_mac_ap()[4], wpa_eapol.getOrig_mac_ap()[5], wpa_eapol.getOrig_mac_sta()[0], wpa_eapol.getOrig_mac_sta()[1], wpa_eapol.getOrig_mac_sta()[2], wpa_eapol.getOrig_mac_sta()[3], wpa_eapol.getOrig_mac_sta()[4], wpa_eapol.getOrig_mac_sta()[5], wpa_eapol.getEssid());
		} 
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u64 digest = (u64)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_64_constants.SHA512M_A;
			tmp[1] += sha2_64_constants.SHA512M_B;
			tmp[2] += sha2_64_constants.SHA512M_C;
			tmp[3] += sha2_64_constants.SHA512M_D;
			tmp[4] += sha2_64_constants.SHA512M_E;
			tmp[5] += sha2_64_constants.SHA512M_F;
			tmp[6] += sha2_64_constants.SHA512M_G;
			tmp[7] += sha2_64_constants.SHA512M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[6], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[7], out_buf + out_len);
		out_len += 16;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		return .snprintf(line_buf, line_size, "%s*0*%08x%08x*%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_RAR3, ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]), salt.getSalt_buf()[2], salt.getSalt_buf()[3], salt.getSalt_buf()[4], salt.getSalt_buf()[5]);
		u64 digest = (u64)digest_buf;
		solarwinds_t solarwinds = (solarwinds_t)esalt_buf;
		// hash
		u64[] tmp = new u64();
		tmp[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		tmp[8] = 0;
		byte[] hash_enc = new byte[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp, 64, (u8)hash_enc);
		// outputint line_len = .snprintf(line_buf, line_size, "%s%s$%s", ModernizedCProgram.SIGNATURE_SOLARWINDS_ORION, (byte)solarwinds.getSalt_buf(), hash_enc);
		return line_len;
		apple_secure_notes_t apple_secure_notes = (apple_secure_notes_t)esalt_buf;
		Object generatedZ_PK = apple_secure_notes.getZ_PK();
		Object generatedZCRYPTOSALT = apple_secure_notes.getZCRYPTOSALT();
		Object generatedZCRYPTOITERATIONCOUNT = apple_secure_notes.getZCRYPTOITERATIONCOUNT();
		Object generatedZCRYPTOWRAPPEDKEY = apple_secure_notes.getZCRYPTOWRAPPEDKEY();
		int out_len = .snprintf(line_buf, line_size, "%s%u$16$%08x%08x%08x%08x$%u$%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_APFS, generatedZ_PK, ModernizedCProgram.byte_swap_32(generatedZCRYPTOSALT[0]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOSALT[1]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOSALT[2]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOSALT[3]), generatedZCRYPTOITERATIONCOUNT, ModernizedCProgram.byte_swap_32(generatedZCRYPTOWRAPPEDKEY[0]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOWRAPPEDKEY[1]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOWRAPPEDKEY[2]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOWRAPPEDKEY[3]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOWRAPPEDKEY[4]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOWRAPPEDKEY[5]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOWRAPPEDKEY[6]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOWRAPPEDKEY[7]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOWRAPPEDKEY[8]), ModernizedCProgram.byte_swap_32(generatedZCRYPTOWRAPPEDKEY[9]));
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u64 digest = (u64)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_64_constants.SHA512M_A;
			tmp[1] += sha2_64_constants.SHA512M_B;
			tmp[2] += sha2_64_constants.SHA512M_C;
			tmp[3] += sha2_64_constants.SHA512M_D;
			tmp[4] += sha2_64_constants.SHA512M_E;
			tmp[5] += sha2_64_constants.SHA512M_F;
			tmp[6] += sha2_64_constants.SHA512M_G;
			tmp[7] += sha2_64_constants.SHA512M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[6], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[7], out_buf + out_len);
		out_len += 16;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s$%08X%08X", tmp_salt, ModernizedCProgram.byte_swap_32(digest[0]), ModernizedCProgram.byte_swap_32(digest[1]));
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + 56);
		int out_len = 64;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u64 digest = (u64)digest_buf;
		// this (useless?) initialization makes scan-build happyu64[] tmp = new u64[]{0};
		tmp[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		tmp[4] = 0;
		tmp[5] = 0;
		tmp[6] = 0;
		tmp[7] = 0;
		byte[] ptr_plain = new byte[]{0};
		ModernizedCProgram.drupal7_encode((u8)tmp, (u8)ptr_plain)// ugly hack start;// ugly hack start
		byte tmpx = (byte)salt.getSalt_buf_pc();
		ptr_plain[42] = tmpx[0]// ugly hack end;// ugly hack end
		ptr_plain[43] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%s%s", (byte)salt.getSalt_sign(), (byte)salt.getSalt_buf(), ptr_plain);
		return line_len;
		u32 digest = (u32)digest_buf;
		pbkdf2_sha256_t pbkdf2_sha256 = (pbkdf2_sha256_t)esalt_buf;
		// hash
		u32[] tmp = new u32();
		tmp[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		tmp[8] = 0;
		byte[] tmp_buf = new byte[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp, 32, (u8)tmp_buf)// output;// output
		int line_len = .snprintf(line_buf, line_size, "%s$%u$%s$%s", ModernizedCProgram.SIGNATURE_DJANGOPBKDF2, salt.getSalt_iter() + 1, (byte)pbkdf2_sha256.getSalt_buf(), tmp_buf);
		return line_len;
		electrum_wallet_t electrum_wallet = (electrum_wallet_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%s%u*%08x%08x%08x%08x*%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_ELECTRUM_WALLET, electrum_wallet.getSalt_type(), ModernizedCProgram.byte_swap_32(electrum_wallet.getIv()[0]), ModernizedCProgram.byte_swap_32(electrum_wallet.getIv()[1]), ModernizedCProgram.byte_swap_32(electrum_wallet.getIv()[2]), ModernizedCProgram.byte_swap_32(electrum_wallet.getIv()[3]), ModernizedCProgram.byte_swap_32(electrum_wallet.getEncrypted()[0]), ModernizedCProgram.byte_swap_32(electrum_wallet.getEncrypted()[1]), ModernizedCProgram.byte_swap_32(electrum_wallet.getEncrypted()[2]), ModernizedCProgram.byte_swap_32(electrum_wallet.getEncrypted()[3]));
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md4_constants.MD4M_A;
			tmp[1] += md4_constants.MD4M_B;
			tmp[2] += md4_constants.MD4M_C;
			tmp[3] += md4_constants.MD4M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		int out_len = 24;
		return out_len;
		u32 digest = (u32)digest_buf;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%s*%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_MYSQL_AUTH, tmp_salt, digest[0], digest[1], digest[2], digest[3], digest[4]);
		return line_len;
		krb5tgs_18_t krb5tgs = (krb5tgs_18_t)esalt_buf;
		byte[] data = new byte[]{0};
		for (u32 i = 0;
		u32 j = 0;
		 i < krb5tgs.getEdata2_len(); ) {
			u8 ptr_edata2 = (u8)krb5tgs.getEdata2();
			.sprintf(data + j, "%02x", ptr_edata2[i]);
		}
		int line_len = .snprintf(line_buf, line_size, "%s%s$%s$%08x%08x%08x$%s", ModernizedCProgram.SIGNATURE_KRB5TGS, (byte)krb5tgs.getUser(), (byte)krb5tgs.getDomain(), krb5tgs.getChecksum()[0], krb5tgs.getChecksum()[1], krb5tgs.getChecksum()[2], data);
		return line_len;
		u32 digest = (u32)digest_buf;
		int line_len = .snprintf(line_buf, line_size, "%s%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_AXCRYPT_SHA1, digest[0], digest[1], digest[2], digest[3]);
		return line_len;
		oldoffice34_t oldoffice34 = (oldoffice34_t)esalt_buf;
		u8 rc4key = (u8)oldoffice34.getRc4key();
		int line_len = .snprintf(line_buf, line_size, "%s%u*%08x%08x%08x%08x*%08x%08x%08x%08x*%08x%08x%08x%08x%08x:%02x%02x%02x%02x%02x", ModernizedCProgram.SIGNATURE_OLDOFFICE, oldoffice34.getVersion(), salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3], ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[0]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[1]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[2]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[3]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[0]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[1]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[2]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[3]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[4]), rc4key[0], rc4key[1], rc4key[2], rc4key[3], rc4key[4]);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%08x%08x%08x%08x%08x", tmp_salt, tmp[0], tmp[1], tmp[2], tmp[3], tmp[4]);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len() - 1, (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%s$%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_MEDIAWIKI_B, tmp_salt, ModernizedCProgram.byte_swap_32(tmp[0]), ModernizedCProgram.byte_swap_32(tmp[1]), ModernizedCProgram.byte_swap_32(tmp[2]), ModernizedCProgram.byte_swap_32(tmp[3]));
		return line_len;
		u32 digest = (u32)digest_buf;
		int line_len = 0;
		line_len += .snprintf(line_buf + line_len, line_size - line_len, "%s%u#", ModernizedCProgram.SIGNATURE_DCC2, salt.getSalt_iter() + 1);
		line_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)line_buf + line_len);
		line_len += .snprintf(line_buf + line_len, line_size - line_len, "#%08x%08x%08x%08x", digest[0], digest[1], digest[2], digest[3]);
		return line_len;
		pkzip_t pkzip = (pkzip_t)esalt_buf;
		int out_len = 0;
		if (pkzip.getVersion() == 1) {
			.sprintf(line_buf, "%s", ModernizedCProgram.SIGNATURE_PKZIP_V1);
			out_len += 7;
		} else {
				.sprintf(line_buf, "%s", ModernizedCProgram.SIGNATURE_PKZIP_V2);
				out_len += 8;
		} 
		out_len += .sprintf(line_buf + out_len, "%i*%i*", pkzip.getHash_count(), pkzip.getChecksum_size());
		out_len += .sprintf(line_buf + out_len, "%i*%i*", pkzip.getHash().getData_type_enum(), pkzip.getHash().getMagic_type_enum());
		if (pkzip.getHash().getData_type_enum() > 1) {
			out_len += .sprintf(line_buf + out_len, "%x*%x*%x*%x*%x*", pkzip.getHash().getCompressed_length(), pkzip.getHash().getUncompressed_length(), pkzip.getHash().getCrc32(), pkzip.getHash().getOffset(), pkzip.getHash().getAdditional_offset());
		} 
		out_len += .sprintf(line_buf + out_len, "%i*%x*%04x*", pkzip.getHash().getCompression_type(), pkzip.getHash().getData_length(), pkzip.getHash().getChecksum_from_crc());
		if (pkzip.getVersion() == 2) {
			out_len += .sprintf(line_buf + out_len, "%04x*", pkzip.getHash().getChecksum_from_timestamp());
		} 
		for (u32 i = 0;
		 i < pkzip.getHash().getData_length() / 4; i++) {
			out_len += .sprintf(line_buf + out_len, "%08x", ModernizedCProgram.byte_swap_32(pkzip.getHash().getData()[i]));
		}
		for (u32 i = 0;
		 i < pkzip.getHash().getData_length() % 4; i++) {
			out_len += .sprintf(line_buf + out_len, "%02x", (pkzip.getHash().getData()[pkzip.getHash().getData_length() / 4] >> i * 8) & -1024);
		}
		if (pkzip.getVersion() == 1) {
			out_len += .sprintf(line_buf + out_len, "*$/pkzip$");
		} else {
				out_len += .sprintf(line_buf + out_len, "*$/pkzip2$");
		} 
		return out_len;
		itunes_backup_t itunes_backup = (itunes_backup_t)esalt_buf;
		// WPKY
		u32[] wkpy_u32 = new u32();
		wkpy_u32[0] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[0]);
		wkpy_u32[1] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[1]);
		wkpy_u32[2] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[2]);
		wkpy_u32[3] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[3]);
		wkpy_u32[4] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[4]);
		wkpy_u32[5] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[5]);
		wkpy_u32[6] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[6]);
		wkpy_u32[7] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[7]);
		wkpy_u32[8] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[8]);
		wkpy_u32[9] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[9]);
		u8[] wpky = new u8();
		ModernizedCProgram.u32_to_hex(wkpy_u32[0], wpky + 0);
		ModernizedCProgram.u32_to_hex(wkpy_u32[1], wpky + 8);
		ModernizedCProgram.u32_to_hex(wkpy_u32[2], wpky + 16);
		ModernizedCProgram.u32_to_hex(wkpy_u32[3], wpky + 24);
		ModernizedCProgram.u32_to_hex(wkpy_u32[4], wpky + 32);
		ModernizedCProgram.u32_to_hex(wkpy_u32[5], wpky + 40);
		ModernizedCProgram.u32_to_hex(wkpy_u32[6], wpky + 48);
		ModernizedCProgram.u32_to_hex(wkpy_u32[7], wpky + 56);
		ModernizedCProgram.u32_to_hex(wkpy_u32[8], wpky + 64);
		ModernizedCProgram.u32_to_hex(wkpy_u32[9], wpky + 72);
		wpky[80] = 0;
		u32[] salt_in = new u32();
		salt_in[0] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]);
		salt_in[1] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]);
		salt_in[2] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[2]);
		salt_in[3] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[3]);
		salt_in[4] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[4]);
		salt_in[5] = 0;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt_in, (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0// DPSL;// DPSL
		u32[] dpsl_u32 = new u32();
		dpsl_u32[0] = ModernizedCProgram.byte_swap_32(itunes_backup.getDpsl()[0]);
		dpsl_u32[1] = ModernizedCProgram.byte_swap_32(itunes_backup.getDpsl()[1]);
		dpsl_u32[2] = ModernizedCProgram.byte_swap_32(itunes_backup.getDpsl()[2]);
		dpsl_u32[3] = ModernizedCProgram.byte_swap_32(itunes_backup.getDpsl()[3]);
		dpsl_u32[4] = ModernizedCProgram.byte_swap_32(itunes_backup.getDpsl()[4]);
		u8[] dpsl = new u8();
		ModernizedCProgram.u32_to_hex(dpsl_u32[0], dpsl + 0);
		ModernizedCProgram.u32_to_hex(dpsl_u32[1], dpsl + 8);
		ModernizedCProgram.u32_to_hex(dpsl_u32[2], dpsl + 16);
		ModernizedCProgram.u32_to_hex(dpsl_u32[3], dpsl + 24);
		ModernizedCProgram.u32_to_hex(dpsl_u32[4], dpsl + 32);
		dpsl[40] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s*%u*%s*%u*%s*%u*%s", ModernizedCProgram.SIGNATURE_ITUNES_BACKUP, salt.getSalt_sign()[0], wpky, salt.getSalt_iter2() + 1, tmp_salt, salt.getSalt_iter() + 1, dpsl);
		return line_len;
		u32 digest = (u32)digest_buf;
		androidfde_t androidfde = (androidfde_t)esalt_buf;
		byte[] tmp = new byte[]{0};
		for (u32 i = 0;
		u32 j = 0;
		 i < 384; ) {
			.sprintf(tmp + j, "%08x", androidfde.getData()[i]);
		}
		tmp[3072] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s16$%08x%08x%08x%08x$16$%08x%08x%08x%08x$%s", ModernizedCProgram.SIGNATURE_ANDROIDFDE, ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[2]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[3]), digest[0], digest[1], digest[2], digest[3], tmp);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		u32[] tmp_salt = new u32();
		tmp_salt[0] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]);
		tmp_salt[1] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]);
		tmp_salt[2] = 0;
		int line_len = .snprintf(line_buf, line_size, "1%s%08x%08x%08x%08x%08x", (byte)tmp_salt, tmp[0], tmp[1], tmp[2], tmp[3], tmp[4]);
		return line_len;
		u32 digest = (u32)digest_buf;
		rar5_t rar5 = (rar5_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "$rar5$16$%08x%08x%08x%08x$%u$%08x%08x%08x%08x$8$%08x%08x", salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3], salt.getSalt_sign()[0], rar5.getIv()[0], rar5.getIv()[1], rar5.getIv()[2], rar5.getIv()[3], digest[0], digest[1]);
		return line_len;
		u32 digest = digest_buf;
		pbkdf2_sha512_t pbkdf2_sha512 = (pbkdf2_sha512_t)esalt_buf;
		int line_len = 0;
		line_len += .snprintf(line_buf + line_len, line_size - line_len, "%s%u.", ModernizedCProgram.SIGNATURE_SHA512GRUB, salt.getSalt_iter() + 1);
		byte salt_buf_ptr = (byte)pbkdf2_sha512.getSalt_buf();
		for (u32 i = 0;
		 i < salt.getSalt_len(); i++) {
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%02x", salt_buf_ptr[i]);
		}
		line_len += .snprintf(line_buf + line_len, line_size - line_len, ".%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x", digest[1], digest[0], digest[3], digest[2], digest[5], digest[4], digest[7], digest[6], digest[9], digest[8], digest[11], digest[10], digest[13], digest[12], digest[15], digest[14]);
		return line_len;
		int line_len = .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		return line_len;
		zip2_t zip2 = (zip2_t)esalt_buf;
		u32 salt_len = zip2.getSalt_len();
		byte[] salt_tmp = new byte[]{0};
		for (u32 i = 0;
		u32 j = 0;
		 i < salt_len; ) {
			u8 ptr = (u8)zip2.getSalt_buf();
			.sprintf(salt_tmp + j, "%02x", ptr[i]);
		}
		u32 data_len = zip2.getData_len();
		byte[] data_tmp = new byte[]{0};
		for (u32 i = 0;
		u32 j = 0;
		 i < data_len; ) {
			u8 ptr = (u8)zip2.getData_buf();
			.sprintf(data_tmp + j, "%02x", ptr[i]);
		}
		u32 auth_len = zip2.getAuth_len();
		byte[] auth_tmp = new byte[]{0};
		for (u32 i = 0;
		u32 j = 0;
		 i < auth_len; ) {
			u8 ptr = (u8)zip2.getAuth_buf();
			.sprintf(auth_tmp + j, "%02x", ptr[i]);
		}
		int line_len = .snprintf(line_buf, line_size, "%s*%u*%u*%u*%s*%x*%u*%s*%s*%s", ModernizedCProgram.SIGNATURE_ZIP2_START, zip2.getType(), zip2.getMode(), zip2.getMagic(), salt_tmp, zip2.getVerify_bytes(), zip2.getCompress_length(), data_tmp, auth_tmp, ModernizedCProgram.SIGNATURE_ZIP2_STOP);
		return line_len;
		u8[] ptr_plain = new u8[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)digest_buf, 32, (u8)ptr_plain);
		int out_len = .snprintf(line_buf, line_size, "otm_sha256:%d:%s:%s", salt.getSalt_iter() + 1, (byte)salt.getSalt_buf(), (byte)ptr_plain);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		wpa_pmkid_t wpa_pmkid = (wpa_pmkid_t)esalt_buf;
		int line_len = 0;
		if (wpa_pmkid.getEssid_len()) {
			if (ModernizedCProgram.need_hexify((u8)wpa_pmkid.getEssid_buf(), wpa_pmkid.getEssid_len(), (byte)':', 0) == 1) {
				byte[] tmp_buf = new byte[128];
				int tmp_len = 0;
				tmp_buf[tmp_len++] = (byte)'$';
				tmp_buf[tmp_len++] = (byte)'H';
				tmp_buf[tmp_len++] = (byte)'E';
				tmp_buf[tmp_len++] = (byte)'X';
				tmp_buf[tmp_len++] = (byte)'[';
				ModernizedCProgram.exec_hexify((u8)wpa_pmkid.getEssid_buf(), wpa_pmkid.getEssid_len(), (u8)tmp_buf + tmp_len);
				tmp_len += wpa_pmkid.getEssid_len() * 2;
				tmp_buf[tmp_len++] = (byte)']';
				tmp_buf[tmp_len++] = 0;
				line_len = .snprintf(line_buf, line_size, "%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%s", wpa_pmkid.getOrig_mac_ap()[0], wpa_pmkid.getOrig_mac_ap()[1], wpa_pmkid.getOrig_mac_ap()[2], wpa_pmkid.getOrig_mac_ap()[3], wpa_pmkid.getOrig_mac_ap()[4], wpa_pmkid.getOrig_mac_ap()[5], wpa_pmkid.getOrig_mac_sta()[0], wpa_pmkid.getOrig_mac_sta()[1], wpa_pmkid.getOrig_mac_sta()[2], wpa_pmkid.getOrig_mac_sta()[3], wpa_pmkid.getOrig_mac_sta()[4], wpa_pmkid.getOrig_mac_sta()[5], tmp_buf);
			} else {
					line_len = .snprintf(line_buf, line_size, "%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%s", wpa_pmkid.getOrig_mac_ap()[0], wpa_pmkid.getOrig_mac_ap()[1], wpa_pmkid.getOrig_mac_ap()[2], wpa_pmkid.getOrig_mac_ap()[3], wpa_pmkid.getOrig_mac_ap()[4], wpa_pmkid.getOrig_mac_ap()[5], wpa_pmkid.getOrig_mac_sta()[0], wpa_pmkid.getOrig_mac_sta()[1], wpa_pmkid.getOrig_mac_sta()[2], wpa_pmkid.getOrig_mac_sta()[3], wpa_pmkid.getOrig_mac_sta()[4], wpa_pmkid.getOrig_mac_sta()[5], (byte)wpa_pmkid.getEssid_buf());
			} 
		} else {
				line_len = .snprintf(line_buf, line_size, "%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x", wpa_pmkid.getOrig_mac_ap()[0], wpa_pmkid.getOrig_mac_ap()[1], wpa_pmkid.getOrig_mac_ap()[2], wpa_pmkid.getOrig_mac_ap()[3], wpa_pmkid.getOrig_mac_ap()[4], wpa_pmkid.getOrig_mac_ap()[5], wpa_pmkid.getOrig_mac_sta()[0], wpa_pmkid.getOrig_mac_sta()[1], wpa_pmkid.getOrig_mac_sta()[2], wpa_pmkid.getOrig_mac_sta()[3], wpa_pmkid.getOrig_mac_sta()[4], wpa_pmkid.getOrig_mac_sta()[5]);
		} 
		return line_len;
		u64 digest = (u64)digest_buf;
		pbkdf2_sha512_t pbkdf2_sha512 = (pbkdf2_sha512_t)esalt_buf;
		// hashu64[] tmp = new u64();
		tmp[0] = ModernizedCProgram.byte_swap_64(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(digest[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(digest[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(digest[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(digest[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(digest[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(digest[7]);
		tmp[8] = 0;
		byte[] salt_enc = new byte[]{0};
		byte[] hash_enc = new byte[]{0};
		size_t salt_len_enc = ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_ab64, (u8)pbkdf2_sha512.getSalt_buf(), salt.getSalt_len(), (u8)salt_enc);
		size_t hash_len_enc = ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_ab64, (u8)tmp, ModernizedCProgram.HASH_LEN_RAW, (u8)hash_enc);
		// remove padding =for (size_t i = 0;
		 i < salt_len_enc; i++) {
			if (salt_enc[i] == (byte)'=') {
				salt_enc[i] = (byte)'\0';
			} 
		}
		for (size_t i = 0;
		 i < hash_len_enc; i++) {
			if (hash_enc[i] == (byte)'=') {
				hash_enc[i] = (byte)'\0';
			} 
		}
		// outputint line_len = .snprintf(line_buf, line_size, "$%s$%u$%s$%s", ModernizedCProgram.SIGNATURE_PASSLIB_PBKDF2_SHA512, salt.getSalt_iter() + 1, salt_enc, hash_enc);
		return line_len;
		return 0;
		wpa_pmkid_t wpa_pmkid = (wpa_pmkid_t)esalt_buf;
		int line_len = 0;
		if (ModernizedCProgram.need_hexify((u8)wpa_pmkid.getEssid_buf(), wpa_pmkid.getEssid_len(), (byte)':', 0) == 1) {
			byte[] tmp_buf = new byte[128];
			int tmp_len = 0;
			tmp_buf[tmp_len++] = (byte)'$';
			tmp_buf[tmp_len++] = (byte)'H';
			tmp_buf[tmp_len++] = (byte)'E';
			tmp_buf[tmp_len++] = (byte)'X';
			tmp_buf[tmp_len++] = (byte)'[';
			ModernizedCProgram.exec_hexify((u8)wpa_pmkid.getEssid_buf(), wpa_pmkid.getEssid_len(), (u8)tmp_buf + tmp_len);
			tmp_len += wpa_pmkid.getEssid_len() * 2;
			tmp_buf[tmp_len++] = (byte)']';
			tmp_buf[tmp_len++] = 0;
			line_len = .snprintf(line_buf, line_size, "%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%s", wpa_pmkid.getOrig_mac_ap()[0], wpa_pmkid.getOrig_mac_ap()[1], wpa_pmkid.getOrig_mac_ap()[2], wpa_pmkid.getOrig_mac_ap()[3], wpa_pmkid.getOrig_mac_ap()[4], wpa_pmkid.getOrig_mac_ap()[5], wpa_pmkid.getOrig_mac_sta()[0], wpa_pmkid.getOrig_mac_sta()[1], wpa_pmkid.getOrig_mac_sta()[2], wpa_pmkid.getOrig_mac_sta()[3], wpa_pmkid.getOrig_mac_sta()[4], wpa_pmkid.getOrig_mac_sta()[5], tmp_buf);
		} else {
				line_len = .snprintf(line_buf, line_size, "%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%s", wpa_pmkid.getOrig_mac_ap()[0], wpa_pmkid.getOrig_mac_ap()[1], wpa_pmkid.getOrig_mac_ap()[2], wpa_pmkid.getOrig_mac_ap()[3], wpa_pmkid.getOrig_mac_ap()[4], wpa_pmkid.getOrig_mac_ap()[5], wpa_pmkid.getOrig_mac_sta()[0], wpa_pmkid.getOrig_mac_sta()[1], wpa_pmkid.getOrig_mac_sta()[2], wpa_pmkid.getOrig_mac_sta()[3], wpa_pmkid.getOrig_mac_sta()[4], wpa_pmkid.getOrig_mac_sta()[5], (byte)wpa_pmkid.getEssid_buf());
		} 
		return line_len;
		u32 digest = (u32)digest_buf;
		// this (useless?) initialization makes scan-build happyu32[] tmp = new u32[]{0};
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		byte[] ptr_plain = new byte[]{0};
		ModernizedCProgram.sha256aix_encode((byte)tmp, (byte)ptr_plain);
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%02u$%s$%s", ModernizedCProgram.SIGNATURE_SHA256AIX, salt.getSalt_sign()[0], tmp_salt, ptr_plain);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		return out_len;
		u32 digest = (u32)digest_buf;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s$%08X%08X", tmp_salt, ModernizedCProgram.byte_swap_32(digest[0]), ModernizedCProgram.byte_swap_32(digest[1]));
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp_digest = new u32();
		tmp_digest[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		tmp_digest[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		tmp_digest[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		tmp_digest[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		tmp_digest[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		tmp_digest[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		u32[] tmp_salt = new u32();
		tmp_salt[0] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]);
		tmp_salt[1] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]);
		tmp_salt[2] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[2]);
		tmp_salt[3] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[3]);
		byte[] tmp_buf = new byte[64];
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_bf64, (u8)tmp_salt, 16, (u8)tmp_buf + 0);
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_bf64, (u8)tmp_digest, 23, (u8)tmp_buf + 22);
		// base64_encode wants to pad// base64_encode wants to padtmp_buf[22 + 31] = 0;
		return .snprintf(line_buf, line_size, "%s$%s", (byte)salt.getSalt_sign(), tmp_buf);
		itunes_backup_t itunes_backup = (itunes_backup_t)esalt_buf;
		// WPKY
		u32[] wkpy_u32 = new u32();
		wkpy_u32[0] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[0]);
		wkpy_u32[1] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[1]);
		wkpy_u32[2] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[2]);
		wkpy_u32[3] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[3]);
		wkpy_u32[4] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[4]);
		wkpy_u32[5] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[5]);
		wkpy_u32[6] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[6]);
		wkpy_u32[7] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[7]);
		wkpy_u32[8] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[8]);
		wkpy_u32[9] = ModernizedCProgram.byte_swap_32(itunes_backup.getWpky()[9]);
		u8[] wpky = new u8();
		ModernizedCProgram.u32_to_hex(wkpy_u32[0], wpky + 0);
		ModernizedCProgram.u32_to_hex(wkpy_u32[1], wpky + 8);
		ModernizedCProgram.u32_to_hex(wkpy_u32[2], wpky + 16);
		ModernizedCProgram.u32_to_hex(wkpy_u32[3], wpky + 24);
		ModernizedCProgram.u32_to_hex(wkpy_u32[4], wpky + 32);
		ModernizedCProgram.u32_to_hex(wkpy_u32[5], wpky + 40);
		ModernizedCProgram.u32_to_hex(wkpy_u32[6], wpky + 48);
		ModernizedCProgram.u32_to_hex(wkpy_u32[7], wpky + 56);
		ModernizedCProgram.u32_to_hex(wkpy_u32[8], wpky + 64);
		ModernizedCProgram.u32_to_hex(wkpy_u32[9], wpky + 72);
		wpky[80] = 0;
		u32[] salt_in = new u32();
		salt_in[0] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]);
		salt_in[1] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]);
		salt_in[2] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[2]);
		salt_in[3] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[3]);
		salt_in[4] = ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[4]);
		salt_in[5] = 0;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt_in, (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s*%u*%s*%u*%s**", ModernizedCProgram.SIGNATURE_ITUNES_BACKUP, salt.getSalt_sign()[0], wpky, salt.getSalt_iter() + 1, tmp_salt);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = 0;
		tmp[3] = 0;
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = 0;
		tmp[3] = 0;
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		int out_len = 16;
		return out_len;
		return .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		pkzip_t pkzip = (pkzip_t)esalt_buf;
		int out_len = 0;
		if (pkzip.getVersion() == 1) {
			.sprintf(line_buf, "%s", ModernizedCProgram.SIGNATURE_PKZIP_V1);
			out_len += 7;
		} else {
				.sprintf(line_buf, "%s", ModernizedCProgram.SIGNATURE_PKZIP_V2);
				out_len += 8;
		} 
		out_len += .sprintf(line_buf + out_len, "%i*%i*", pkzip.getHash_count(), pkzip.getChecksum_size());
		for (int cnt = 0;
		 cnt < pkzip.getHash_count(); cnt++) {
			if (cnt > 0) {
				out_len += .sprintf(line_buf + out_len, "*");
			} 
			out_len += .sprintf(line_buf + out_len, "%i*%i*", pkzip.getHashes()[cnt].getData_type_enum(), pkzip.getHashes()[cnt].getMagic_type_enum());
			if (pkzip.getHashes()[cnt].getData_type_enum() > 1) {
				out_len += .sprintf(line_buf + out_len, "%x*%x*%x*%x*%x*", pkzip.getHashes()[cnt].getCompressed_length(), pkzip.getHashes()[cnt].getUncompressed_length(), pkzip.getHashes()[cnt].getCrc32(), pkzip.getHashes()[cnt].getOffset(), pkzip.getHashes()[cnt].getAdditional_offset());
			} 
			out_len += .sprintf(line_buf + out_len, "%i*%x*%04x*", pkzip.getHashes()[cnt].getCompression_type(), pkzip.getHashes()[cnt].getData_length(), pkzip.getHashes()[cnt].getChecksum_from_crc());
			if (pkzip.getVersion() == 2) {
				out_len += .sprintf(line_buf + out_len, "%04x*", pkzip.getHashes()[cnt].getChecksum_from_timestamp());
			} 
			for (u32 i = 0;
			 i < pkzip.getHashes()[cnt].getData_length() / 4; i++) {
				out_len += .sprintf(line_buf + out_len, "%08x", ModernizedCProgram.byte_swap_32(pkzip.getHashes()[cnt].getData()[i]));
			}
			for (u32 i = 0;
			 i < pkzip.getHashes()[cnt].getData_length() % 4; i++) {
				out_len += .sprintf(line_buf + out_len, "%02x", (pkzip.getHashes()[cnt].getData()[pkzip.getHashes()[cnt].getData_length() / 4] >> i * 8) & -1024);
			}
		}
		if (pkzip.getVersion() == 1) {
			out_len += .sprintf(line_buf + out_len, "*$/pkzip$");
		} else {
				out_len += .sprintf(line_buf + out_len, "*$/pkzip2$");
		} 
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%s$%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_PHPS, tmp_salt, ModernizedCProgram.byte_swap_32(tmp[0]), ModernizedCProgram.byte_swap_32(tmp[1]), ModernizedCProgram.byte_swap_32(tmp[2]), ModernizedCProgram.byte_swap_32(tmp[3]));
		return line_len;
		return .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		int out_len = 40;
		return out_len;
		u64 digest = (u64)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = 0;
		tmp[7] = 0;
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_64_constants.SHA384M_A;
			tmp[1] += sha2_64_constants.SHA384M_B;
			tmp[2] += sha2_64_constants.SHA384M_C;
			tmp[3] += sha2_64_constants.SHA384M_D;
			tmp[4] += sha2_64_constants.SHA384M_E;
			tmp[5] += sha2_64_constants.SHA384M_F;
			tmp[6] += 0;
			tmp[7] += 0;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = 0;
		tmp[7] = 0;
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + 16);
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + 32);
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + 48);
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + 64);
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + 80);
		int out_len = 96;
		return out_len;
		diskcryptor_esalt_t diskcryptor_esalt = (diskcryptor_esalt_t)esalt_buf;
		// first only add the signature and version number:
		int line_len = .snprintf(line_buf, line_size, "%s%i*", ModernizedCProgram.SIGNATURE_DISKCRYPTOR, ModernizedCProgram.DISKCRYPTOR_VERSION);
		// ... then add the full header (in hexadecimal):
		for (u32 i = 0;
		 i < 512; i++) {
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%08x", ModernizedCProgram.byte_swap_32(diskcryptor_esalt.getSalt_buf()[i]));
		}
		return line_len;
		u32 digest = (u32)digest_buf;
		int line_len = 0;
		int iter = salt.getSalt_iter();
		if (iter == ModernizedCProgram.ROUNDS_QNX) {
			line_buf[line_len++] = (byte)'@';
			line_buf[line_len++] = (byte)'m';
			line_buf[line_len++] = (byte)'@';
		} else {
				line_buf[line_len++] = (byte)'@';
				line_buf[line_len++] = (byte)'m';
				line_buf[line_len++] = (byte)',';
				line_len += .snprintf(line_buf + line_len, line_size - line_len, "%d", iter);
				line_buf[line_len++] = (byte)'@';
		} 
		ModernizedCProgram.u32_to_hex(digest[0], (u8)line_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(digest[1], (u8)line_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(digest[2], (u8)line_buf + line_len);
		line_len += 8;
		ModernizedCProgram.u32_to_hex(digest[3], (u8)line_buf + line_len);
		line_len += 8;
		line_buf[line_len++] = (byte)'@';
		.memcpy(line_buf + line_len, salt.getSalt_buf(), salt.getSalt_len());
		line_len += salt.getSalt_len();
		line_buf[line_len] = 0;
		return line_len;
		u64 digest = (u64)digest_buf;
		u64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + 16);
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + 32);
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + 48);
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + 64);
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + 80);
		ModernizedCProgram.u64_to_hex(tmp[6], out_buf + 96);
		ModernizedCProgram.u64_to_hex(tmp[7], out_buf + 112);
		int out_len = 128;
		return out_len;
		byte ptr = (byte)digest_buf;
		return .snprintf(line_buf, line_size, "%s", ptr + 64);
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		ethereum_scrypt_t ethereum_scrypt = (ethereum_scrypt_t)esalt_buf;
		Object generatedCiphertext = ethereum_scrypt.getCiphertext();
		int line_len = .snprintf(line_buf, line_size, "%s*%u*%u*%u*%s*%08x%08x%08x%08x%08x%08x%08x%08x*%08x%08x%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_ETHEREUM_SCRYPT, salt.getScrypt_N(), salt.getScrypt_r(), salt.getScrypt_p(), (byte)tmp_salt, ModernizedCProgram.byte_swap_32(generatedCiphertext[0]), ModernizedCProgram.byte_swap_32(generatedCiphertext[1]), ModernizedCProgram.byte_swap_32(generatedCiphertext[2]), ModernizedCProgram.byte_swap_32(generatedCiphertext[3]), ModernizedCProgram.byte_swap_32(generatedCiphertext[4]), ModernizedCProgram.byte_swap_32(generatedCiphertext[5]), ModernizedCProgram.byte_swap_32(generatedCiphertext[6]), ModernizedCProgram.byte_swap_32(generatedCiphertext[7]), ModernizedCProgram.byte_swap_32(digest[0]), ModernizedCProgram.byte_swap_32(digest[1]), ModernizedCProgram.byte_swap_32(digest[2]), ModernizedCProgram.byte_swap_32(digest[3]), ModernizedCProgram.byte_swap_32(digest[4]), ModernizedCProgram.byte_swap_32(digest[5]), ModernizedCProgram.byte_swap_32(digest[6]), ModernizedCProgram.byte_swap_32(digest[7]));
		return line_len;
		u64 digest = (u64)digest_buf;
		u64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + 16);
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + 32);
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + 48);
		int out_len = 64;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		int out_len = 40;
		return out_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		rakp_t rakp = (rakp_t)esalt_buf;
		u8 ptr = (u8)rakp.getSalt_buf();
		int line_len = 0;
		for (u32 i = 0;
		 i < rakp.getSalt_len(); i++) {
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%02x", ptr[i ^ 3]);
		}
		line_len += .snprintf(line_buf + line_len, line_size - line_len, ":%08x%08x%08x%08x%08x", digest[0], digest[1], digest[2], digest[3], digest[4]);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		ikepsk_t ikepsk = (ikepsk_t)esalt_buf;
		int line_len = 0;
		// msg_buf
		u32 ikepsk_msg_len = ikepsk.getMsg_len()[5] / 4;
		for (u32 i = 0;
		 i < ikepsk_msg_len; i++) {
			if ((i == ikepsk.getMsg_len()[0] / 4) || (i == ikepsk.getMsg_len()[1] / 4) || (i == ikepsk.getMsg_len()[2] / 4) || (i == ikepsk.getMsg_len()[3] / 4) || (i == ikepsk.getMsg_len()[4] / 4)) {
				line_len += .snprintf(line_buf + line_len, line_size - line_len, ":");
			} 
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%08x", ModernizedCProgram.byte_swap_32(ikepsk.getMsg_buf()[i]));
		}
		// nr_bufu32 ikepsk_nr_len = ikepsk.getNr_len() / 4;
		for (u32 i = 0;
		 i < ikepsk_nr_len; i++) {
			if ((i == 0) || (i == 5)) {
				line_len += .snprintf(line_buf + line_len, line_size - line_len, ":");
			} 
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%08x", ModernizedCProgram.byte_swap_32(ikepsk.getNr_buf()[i]));
		}
		// digest_buffor (u32 i = 0;
		 i < 5; i++) {
			if (i == 0) {
				line_len += .snprintf(line_buf + line_len, line_size - line_len, ":");
			} 
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%08x", digest[i]);
		}
		return line_len;
		u32 digest = (u32)digest_buf;
		// salt
		pbkdf2_sha256_t pbkdf2_sha256 = (pbkdf2_sha256_t)esalt_buf;
		byte salt_buf_ptr = (byte)pbkdf2_sha256.getSalt_buf();
		// hash
		u32[] tmp = new u32();
		tmp[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		// needed for base64_encode ()// needed for base64_encode ()tmp[8] = 0;
		byte[] tmp_buf = new byte[48];
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_itoa64, (u8)tmp, 32, (u8)tmp_buf);
		// cut it here// cut it heretmp_buf[43] = 0// output;// output
		int line_len = .snprintf(line_buf, line_size, "%s%s$%s", ModernizedCProgram.SIGNATURE_CISCO8, salt_buf_ptr, tmp_buf);
		return line_len;
		apple_secure_notes_t apple_secure_notes = (apple_secure_notes_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%s*%u*%u*%08x%08x%08x%08x*%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_APPLE_SECURE_NOTES, apple_secure_notes.getZ_PK(), apple_secure_notes.getZCRYPTOITERATIONCOUNT(), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOSALT()[0]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOSALT()[1]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOSALT()[2]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOSALT()[3]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[0]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[1]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[2]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[3]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[4]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[5]));
		return line_len;
		int line_len = .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		return line_len;
		u32 digest = (u32)digest_buf;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		byte[] ptr_plain = new byte[64];
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp, 32, (u8)ptr_plain);
		ptr_plain[43] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s*1*%s*%s", ModernizedCProgram.SIGNATURE_EPISERVER, tmp_salt, ptr_plain);
		return line_len;
		u32 digest = (u32)digest_buf;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		return .snprintf(line_buf, line_size, "%08x%08x%08x%08x:%u:%s", digest[0], digest[1], digest[2], digest[3], salt.getSalt_iter() + 1, tmp_salt);
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		pbkdf2_sha1_t pbkdf2_sha1 = (pbkdf2_sha1_t)esalt_buf;
		// hashu32[] tmp = new u32();
		tmp[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		tmp[5] = 0;
		byte[] salt_enc = new byte[]{0};
		byte[] hash_enc = new byte[]{0};
		size_t salt_len_enc = ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_ab64, (u8)pbkdf2_sha1.getSalt_buf(), salt.getSalt_len(), (u8)salt_enc);
		size_t hash_len_enc = ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_ab64, (u8)tmp, ModernizedCProgram.HASH_LEN_RAW, (u8)hash_enc);
		// remove padding =for (size_t i = 0;
		 i < salt_len_enc; i++) {
			if (salt_enc[i] == (byte)'=') {
				salt_enc[i] = (byte)'\0';
			} 
		}
		for (size_t i = 0;
		 i < hash_len_enc; i++) {
			if (hash_enc[i] == (byte)'=') {
				hash_enc[i] = (byte)'\0';
			} 
		}
		// outputint line_len = .snprintf(line_buf, line_size, "$%s$%u$%s$%s", ModernizedCProgram.SIGNATURE_PASSLIB_PBKDF2_SHA1, salt.getSalt_iter() + 1, salt_enc, hash_enc);
		return line_len;
		u32 digest = (u32)digest_buf;
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(digest[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(digest[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(digest[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(digest[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(digest[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(digest[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(digest[6], out_buf + 48);
		ModernizedCProgram.u32_to_hex(digest[7], out_buf + 56);
		int out_len = 64;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		int out_len = 32;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		int out_len = 32;
		return out_len;
		u64 digest = (u64)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[6], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[7], out_buf + out_len);
		out_len += 16;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		byte[] ptr_plain = new byte[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp, 20, (u8)ptr_plain);
		int line_len = .snprintf(line_buf, line_size, "%s", ptr_plain);
		return line_len;
		krb5pa_t krb5pa = (krb5pa_t)esalt_buf;
		u8 ptr_timestamp = (u8)krb5pa.getTimestamp();
		u8 ptr_checksum = (u8)krb5pa.getChecksum();
		byte[] data = new byte[]{0};
		byte ptr_data = data;
		for (u32 i = 0;
		 i < 36; ) {
			.sprintf(ptr_data, "%02x", ptr_timestamp[i]);
		}
		for (u32 i = 0;
		 i < 16; ) {
			.sprintf(ptr_data, "%02x", ptr_checksum[i]);
		}
		ptr_data = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%s$%s$%s$%s", ModernizedCProgram.SIGNATURE_KRB5PA, (byte)krb5pa.getUser(), (byte)krb5pa.getRealm(), (byte)krb5pa.getSalt(), data);
		return line_len;
		u32 digest = (u32)digest_buf;
		byte[] buf = new byte[]{0};
		// salt
		.memcpy(buf + 0, salt.getSalt_buf(), 16);
		buf[3] -= -4// iteration;// iteration
		.snprintf(buf + 16, 11, "%010u", salt.getSalt_iter() + 1)// chars;// chars
		// not a bug// not a bugbuf[26] = salt.getSalt_buf_pc()[0];
		// not a bug// not a bugbuf[27] = salt.getSalt_buf_pc()[1]// digest;// digest
		u32[] tmp = new u32();
		tmp[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		.memcpy(buf + 28, tmp, 8);
		byte[] tmp_buf = new byte[64];
		int tmp_len = ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_lotus64, (u8)buf, 36, (u8)tmp_buf);
		tmp_buf[tmp_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "(H%s)", tmp_buf);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		tmp[8] = digest[8];
		tmp[9] = digest[9];
		tmp[10] = digest[10];
		tmp[11] = digest[11];
		tmp[12] = digest[12];
		tmp[13] = digest[13];
		tmp[14] = digest[14];
		tmp[15] = digest[15];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + 56);
		ModernizedCProgram.u32_to_hex(tmp[8], out_buf + 64);
		ModernizedCProgram.u32_to_hex(tmp[9], out_buf + 72);
		ModernizedCProgram.u32_to_hex(tmp[10], out_buf + 80);
		ModernizedCProgram.u32_to_hex(tmp[11], out_buf + 88);
		ModernizedCProgram.u32_to_hex(tmp[12], out_buf + 96);
		ModernizedCProgram.u32_to_hex(tmp[13], out_buf + 104);
		ModernizedCProgram.u32_to_hex(tmp[14], out_buf + 112);
		ModernizedCProgram.u32_to_hex(tmp[15], out_buf + 120);
		int out_len = 128;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		oldoffice34_t oldoffice34 = (oldoffice34_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%s%u*%08x%08x%08x%08x*%08x%08x%08x%08x*%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_OLDOFFICE, oldoffice34.getVersion(), salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3], ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[0]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[1]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[2]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifier()[3]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[0]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[1]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[2]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[3]), ModernizedCProgram.byte_swap_32(oldoffice34.getEncryptedVerifierHash()[4]));
		return line_len;
		u32 digest = (u32)digest_buf;
		win8phone_t esalt = (win8phone_t)esalt_buf;
		byte[] buf = new byte[]{0};
		for (int i = 0;
		int j = 0;
		 i < 32; ) {
			.sprintf(buf + j, "%08x", esalt.getSalt_buf()[i]);
		}
		int line_len = .snprintf(line_buf, line_size, "%08x%08x%08x%08x%08x%08x%08x%08x:%s", digest[0], digest[1], digest[2], digest[3], digest[4], digest[5], digest[6], digest[7], buf);
		return line_len;
		krb5tgs_17_t krb5tgs = (krb5tgs_17_t)esalt_buf;
		byte[] data = new byte[]{0};
		for (u32 i = 0;
		u32 j = 0;
		 i < krb5tgs.getEdata2_len(); ) {
			u8 ptr_edata2 = (u8)krb5tgs.getEdata2();
			.sprintf(data + j, "%02x", ptr_edata2[i]);
		}
		int line_len = .snprintf(line_buf, line_size, "%s%s$%s$%08x%08x%08x$%s", ModernizedCProgram.SIGNATURE_KRB5TGS, (byte)krb5tgs.getUser(), (byte)krb5tgs.getDomain(), krb5tgs.getChecksum()[0], krb5tgs.getChecksum()[1], krb5tgs.getChecksum()[2], data);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		tmp[8] = digest[8];
		tmp[9] = digest[9];
		tmp[10] = digest[10];
		tmp[11] = digest[11];
		tmp[12] = digest[12];
		tmp[13] = digest[13];
		tmp[14] = digest[14];
		tmp[15] = digest[15];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + 56);
		ModernizedCProgram.u32_to_hex(tmp[8], out_buf + 64);
		ModernizedCProgram.u32_to_hex(tmp[9], out_buf + 72);
		ModernizedCProgram.u32_to_hex(tmp[10], out_buf + 80);
		ModernizedCProgram.u32_to_hex(tmp[11], out_buf + 88);
		ModernizedCProgram.u32_to_hex(tmp[12], out_buf + 96);
		ModernizedCProgram.u32_to_hex(tmp[13], out_buf + 104);
		ModernizedCProgram.u32_to_hex(tmp[14], out_buf + 112);
		ModernizedCProgram.u32_to_hex(tmp[15], out_buf + 120);
		int out_len = 128;
		return out_len;
		u32 digest = (u32)digest_buf;
		ethereum_pbkdf2_t ethereum_pbkdf2 = (ethereum_pbkdf2_t)esalt_buf;
		byte tmp_salt = (byte)ModernizedCProgram.hcmalloc((salt.getSalt_len() * 2) + 1);
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s*%u*%s*%08x%08x%08x%08x%08x%08x%08x%08x*%08x%08x%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_ETHEREUM_PBKDF2, salt.getSalt_iter() + 1, tmp_salt, ModernizedCProgram.byte_swap_32(ethereum_pbkdf2.getCiphertext()[0]), ModernizedCProgram.byte_swap_32(ethereum_pbkdf2.getCiphertext()[1]), ModernizedCProgram.byte_swap_32(ethereum_pbkdf2.getCiphertext()[2]), ModernizedCProgram.byte_swap_32(ethereum_pbkdf2.getCiphertext()[3]), ModernizedCProgram.byte_swap_32(ethereum_pbkdf2.getCiphertext()[4]), ModernizedCProgram.byte_swap_32(ethereum_pbkdf2.getCiphertext()[5]), ModernizedCProgram.byte_swap_32(ethereum_pbkdf2.getCiphertext()[6]), ModernizedCProgram.byte_swap_32(ethereum_pbkdf2.getCiphertext()[7]), ModernizedCProgram.byte_swap_32(digest[0]), ModernizedCProgram.byte_swap_32(digest[1]), ModernizedCProgram.byte_swap_32(digest[2]), ModernizedCProgram.byte_swap_32(digest[3]), ModernizedCProgram.byte_swap_32(digest[4]), ModernizedCProgram.byte_swap_32(digest[5]), ModernizedCProgram.byte_swap_32(digest[6]), ModernizedCProgram.byte_swap_32(digest[7]));
		ModernizedCProgram.hcfree(tmp_salt);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "0x0100%s%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x", tmp_salt, -1024, -1024, -1024, -1024, -1024, tmp[0], tmp[1], tmp[2], tmp[3], tmp[4]);
		return line_len;
		u32 digest = (u32)digest_buf;
		pbkdf2_sha512_t pbkdf2_sha512 = (pbkdf2_sha512_t)esalt_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] esalt = new u32[]{0};
		esalt[0] = ModernizedCProgram.byte_swap_32(pbkdf2_sha512.getSalt_buf()[0]);
		esalt[1] = ModernizedCProgram.byte_swap_32(pbkdf2_sha512.getSalt_buf()[1]);
		esalt[2] = ModernizedCProgram.byte_swap_32(pbkdf2_sha512.getSalt_buf()[2]);
		esalt[3] = ModernizedCProgram.byte_swap_32(pbkdf2_sha512.getSalt_buf()[3]);
		esalt[4] = ModernizedCProgram.byte_swap_32(pbkdf2_sha512.getSalt_buf()[4]);
		esalt[5] = ModernizedCProgram.byte_swap_32(pbkdf2_sha512.getSalt_buf()[5]);
		esalt[6] = ModernizedCProgram.byte_swap_32(pbkdf2_sha512.getSalt_buf()[6]);
		esalt[7] = ModernizedCProgram.byte_swap_32(pbkdf2_sha512.getSalt_buf()[7]);
		int line_len = .snprintf(line_buf, line_size, "%s%u$%08x%08x%08x%08x%08x%08x%08x%08x$%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_SHA512MACOS, salt.getSalt_iter() + 1, esalt[0], esalt[1], esalt[2], esalt[3], esalt[4], esalt[5], esalt[6], esalt[7], digest[1], digest[0], digest[3], digest[2], digest[5], digest[4], digest[7], digest[6], digest[9], digest[8], digest[11], digest[10], digest[13], digest[12], digest[15], digest[14]);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = 0;
		tmp[3] = 0;
		{ 
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 1;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 1;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 8;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 8;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 2;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 2;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 16;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 16;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 4;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 4;
				tmp[1] = tmp[1] ^ t;
			}
			;
		}
		;
		u8[] ptr_plain = new u8[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_itoa64, (u8)tmp, 8, ptr_plain);
		line_buf[0] = salt.getSalt_sign()[0] & -1024;
		line_buf[1] = salt.getSalt_sign()[1] & -1024//original method, but changed because of this ticket: https://hashcat.net/trac/ticket/269//line_buf[0] = int_to_itoa64 ((salt->salt_buf[0] >> 0) & 0x3f);;//original method, but changed because of this ticket: https://hashcat.net/trac/ticket/269//line_buf[0] = int_to_itoa64 ((salt->salt_buf[0] >> 0) & 0x3f);
		//line_buf[1] = int_to_itoa64 ((salt->salt_buf[0] >> 6) & 0x3f);//line_buf[1] = int_to_itoa64 ((salt->salt_buf[0] >> 6) & 0x3f);.snprintf(line_buf + 2, line_size - 2, "%s", ptr_plain);
		int out_len = 2 + 11;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		seven_zip_hook_salt_t seven_zip = (seven_zip_hook_salt_t)hook_salt_buf;
		Object generatedData_len = seven_zip.getData_len();
		u32 data_len = generatedData_len;
		byte data_buf = (byte)ModernizedCProgram.hcmalloc((data_len * 2) + 1);
		Object generatedData_buf = seven_zip.getData_buf();
		for (u32 i = 0;
		u32 j = 0;
		 i < data_len; ) {
			u8 ptr = (u8)generatedData_buf;
			.snprintf(data_buf + j, (data_len * 2) + 1 - j, "%02x", ptr[i]);
		}
		u32 salt_iter = salt.getSalt_iter();
		u32[] iv = new u32();
		Object generatedIv_buf = seven_zip.getIv_buf();
		iv[0] = ModernizedCProgram.byte_swap_32(generatedIv_buf[0]);
		iv[1] = ModernizedCProgram.byte_swap_32(generatedIv_buf[1]);
		iv[2] = ModernizedCProgram.byte_swap_32(generatedIv_buf[2]);
		iv[3] = ModernizedCProgram.byte_swap_32(generatedIv_buf[3]);
		Object generatedIv_len = seven_zip.getIv_len();
		u32 iv_len = generatedIv_len;
		// the log2 () of salt_iteru32 cost = 0;
		while (salt_iter >>=  1) {
			cost++;
		}
		Object generatedSalt_len = seven_zip.getSalt_len();
		Object generatedSalt_buf = seven_zip.getSalt_buf();
		Object generatedCrc = seven_zip.getCrc();
		Object generatedUnpack_size = seven_zip.getUnpack_size();
		int bytes_written = .snprintf(line_buf, line_size, "%s%u$%u$%u$%s$%u$%08x%08x%08x%08x$%u$%u$%u$%s", ModernizedCProgram.SIGNATURE_SEVEN_ZIP, salt.getSalt_sign()[0], cost, generatedSalt_len, (byte)generatedSalt_buf, iv_len, iv[0], iv[1], iv[2], iv[3], generatedCrc, generatedData_len, generatedUnpack_size, data_buf);
		Object generatedData_type = seven_zip.getData_type();
		Object generatedCrc_len = seven_zip.getCrc_len();
		Object generatedCoder_attributes = seven_zip.getCoder_attributes();
		Object generatedCoder_attributes_len = seven_zip.getCoder_attributes_len();
		if (generatedData_type > 0) {
			bytes_written += .snprintf(line_buf + bytes_written, line_size - bytes_written, "$%u$", generatedCrc_len);
			u8 ptr = (u8)generatedCoder_attributes;
			for (u32 i = 0;
			u32 j = 0;
			 i < generatedCoder_attributes_len; ) {
				bytes_written += .snprintf(line_buf + bytes_written, line_size - bytes_written, "%02x", ptr[i]);
			}
		} 
		ModernizedCProgram.hcfree(data_buf);
		return bytes_written;
		odf12_t odf12 = (odf12_t)esalt_buf;
		int out_len = .snprintf(line_buf, line_size, "%s*1*1*%u*32*%08x%08x%08x%08x%08x%08x%08x%08x*16*%08x%08x%08x%08x*16*%08x%08x%08x%08x*0*", ModernizedCProgram.SIGNATURE_ODF, odf12.getIterations(), ModernizedCProgram.byte_swap_32(odf12.getChecksum()[0]), ModernizedCProgram.byte_swap_32(odf12.getChecksum()[1]), ModernizedCProgram.byte_swap_32(odf12.getChecksum()[2]), ModernizedCProgram.byte_swap_32(odf12.getChecksum()[3]), ModernizedCProgram.byte_swap_32(odf12.getChecksum()[4]), ModernizedCProgram.byte_swap_32(odf12.getChecksum()[5]), ModernizedCProgram.byte_swap_32(odf12.getChecksum()[6]), ModernizedCProgram.byte_swap_32(odf12.getChecksum()[7]), ModernizedCProgram.byte_swap_32(odf12.getIv()[0]), ModernizedCProgram.byte_swap_32(odf12.getIv()[1]), ModernizedCProgram.byte_swap_32(odf12.getIv()[2]), ModernizedCProgram.byte_swap_32(odf12.getIv()[3]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[2]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[3]));
		u8 out_buf = (u8)line_buf;
		for (int i = 0;
		 i < 256; i++) {
			ModernizedCProgram.u32_to_hex(odf12.getEncrypted_data()[i], out_buf + out_len);
			out_len += 8;
		}
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// encode the digest:
		// this (useless?) initialization makes scan-build happyu32[] tmp = new u32[]{0};
		tmp[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		byte[] ptr_plain = new byte[]{0};
		ModernizedCProgram.netbsd_sha1crypt_encode((byte)tmp, salt.getSalt_sign()[0], (byte)ptr_plain)// salt;// salt
		byte[] tmp_salt = new byte[256 * 2];
		.memcpy(tmp_salt, salt.getSalt_buf(), salt.getSalt_len());
		tmp_salt[salt.getSalt_len()] = 0// output:;// output:
		int line_len = .snprintf(line_buf, line_size, "$sha1$%u$%s$%s", salt.getSalt_iter() + 1, tmp_salt, ptr_plain);
		return line_len;
		oldoffice01_t oldoffice01 = (oldoffice01_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%s%u*%08x%08x%08x%08x*%08x%08x%08x%08x*%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_OLDOFFICE, oldoffice01.getVersion(), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[2]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[3]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[0]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[1]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[2]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[3]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[0]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[1]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[2]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[3]));
		return line_len;
		int line_len = .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		return line_len;
		u32 digest = (u32)digest_buf;
		// the encoder is a bit too intelligent, it expects the input data in the wrong BOM
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		byte[] ptr_plain = new byte[64];
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_itoa64, (u8)tmp, 32, (u8)ptr_plain);
		ptr_plain[43] = 0;
		return .snprintf(line_buf, line_size, "%s", ptr_plain);
		u32 digest = (u32)digest_buf;
		int line_len = .snprintf(line_buf, line_size, "%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X%08X", digest[0], digest[1], digest[2], digest[3], digest[4], digest[5], digest[6], digest[7], digest[8], digest[9], digest[10], digest[11], digest[12], digest[13], digest[14], digest[15], salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3]);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + 56);
		int out_len = 64;
		return out_len;
		tacacs_plus_t tacacs_plus = (tacacs_plus_t)esalt_buf;
		byte[] ct_data = new byte[]{0};
		u8 ct_data_ptr = (u8)tacacs_plus.getCt_data_buf();
		for (u32 i = 0;
		u32 j = 0;
		 i < tacacs_plus.getCt_data_len(); ) {
			.sprintf(ct_data + j, "%02x", ct_data_ptr[i]);
		}
		u8 session_ptr = (u8)tacacs_plus.getSession_buf();
		u8 sequence_ptr = (u8)tacacs_plus.getSequence_buf();
		int line_len = .snprintf(line_buf, line_size, "%s%02x%02x%02x%02x$%s$%02x%02x", ModernizedCProgram.SIGNATURE_TACACS_PLUS, session_ptr[0], session_ptr[1], session_ptr[2], session_ptr[3], ct_data, sequence_ptr[0], sequence_ptr[1]);
		return line_len;
		office2007_t office2007 = (office2007_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%s*%d*%d*%u*%d*%08x%08x%08x%08x*%08x%08x%08x%08x*%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_OFFICE2007, 2007, 20, office2007.getKeySize(), 16, salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3], office2007.getEncryptedVerifier()[0], office2007.getEncryptedVerifier()[1], office2007.getEncryptedVerifier()[2], office2007.getEncryptedVerifier()[3], office2007.getEncryptedVerifierHash()[0], office2007.getEncryptedVerifierHash()[1], office2007.getEncryptedVerifierHash()[2], office2007.getEncryptedVerifierHash()[3], office2007.getEncryptedVerifierHash()[4]);
		return line_len;
		u32 digest = (u32)digest_buf;
		byte[] tmp_buf = new byte[64];
		// salt
		.memcpy(tmp_buf, salt.getSalt_buf(), 12)// digest;// digest
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		.memcpy(tmp_buf + 12, tmp, 20)// base64 encode (salt + SHA1);// base64 encode (salt + SHA1)
		byte[] ptr_plain = new byte[48];
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp_buf, 12 + 20, (u8)ptr_plain);
		ptr_plain[44] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%s", ModernizedCProgram.SIGNATURE_FORTIGATE, ptr_plain);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = 0;
		tmp[3] = 0;
		{ 
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 1;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 1;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 8;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 8;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 2;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 2;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 16;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 16;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 4;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 4;
				tmp[1] = tmp[1] ^ t;
			}
			;
		}
		;
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len++;
		ModernizedCProgram.u32_to_hex(salt.getSalt_buf()[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(salt.getSalt_buf()[1], out_buf + out_len);
		out_len += 8;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md4_constants.MD4M_A;
			tmp[1] += md4_constants.MD4M_B;
			tmp[2] += md4_constants.MD4M_C;
			tmp[3] += md4_constants.MD4M_D;
		} 
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		int out_len = 32;
		return out_len;
		u32 digest = (u32)digest_buf;
		int line_len = .snprintf(line_buf, line_size, "%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x", salt.getSalt_buf()[4], salt.getSalt_buf()[5], salt.getSalt_buf()[6], salt.getSalt_buf()[7], salt.getSalt_buf()[8], salt.getSalt_buf()[9], salt.getSalt_buf()[10], salt.getSalt_buf()[11], digest[0], digest[1], digest[2], digest[3], digest[4], digest[5], digest[6], digest[7], salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3]);
		return line_len;
		u64 digest = (u64)digest_buf;
		u64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_64_constants.SHA512M_A;
			tmp[1] += sha2_64_constants.SHA512M_B;
			tmp[2] += sha2_64_constants.SHA512M_C;
			tmp[3] += sha2_64_constants.SHA512M_D;
			tmp[4] += sha2_64_constants.SHA512M_E;
			tmp[5] += sha2_64_constants.SHA512M_F;
			tmp[6] += sha2_64_constants.SHA512M_G;
			tmp[7] += sha2_64_constants.SHA512M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(tmp[7]);
		byte[] tmp_buf = new byte[512];
		.memcpy(tmp_buf, tmp, 64);
		.memcpy(tmp_buf + 64, salt.getSalt_buf(), salt.getSalt_len());
		byte[] ptr_plain = new byte[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp_buf, 64 + salt.getSalt_len(), (u8)ptr_plain);
		int line_len = .snprintf(line_buf, line_size, "%s%s", ModernizedCProgram.SIGNATURE_SHA512B64S, ptr_plain);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		int out_len = 40;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		chacha20_t chacha20 = (chacha20_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%s*%08x%08x*%u*%08x%08x*%08x%08x*%08x%08x", ModernizedCProgram.SIGNATURE_CHACHA20, ModernizedCProgram.byte_swap_32(chacha20.getPosition()[0]), ModernizedCProgram.byte_swap_32(chacha20.getPosition()[1]), chacha20.getOffset(), ModernizedCProgram.byte_swap_32(chacha20.getIv()[1]), ModernizedCProgram.byte_swap_32(chacha20.getIv()[0]), ModernizedCProgram.byte_swap_32(chacha20.getPlain()[0]), ModernizedCProgram.byte_swap_32(chacha20.getPlain()[1]), ModernizedCProgram.byte_swap_32(digest[1]), ModernizedCProgram.byte_swap_32(digest[0]));
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		ansible_vault_t ansible_vault = (ansible_vault_t)esalt_buf;
		u8[] ct_data = new u8[]{0};
		u32 ct_data_ptr = ansible_vault.getCt_data_buf();
		for (u32 i = 0;
		u32 j = 0;
		 i < ansible_vault.getCt_data_len() / 4; ) {
			ModernizedCProgram.u32_to_hex(ct_data_ptr[i], ct_data + j);
		}
		int line_len = .snprintf(line_buf, line_size, "%s%u*%u*%08x%08x%08x%08x%08x%08x%08x%08x*%s*%08x%08x%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_ANSIBLE_VAULT, ansible_vault.getCipher(), ansible_vault.getVersion(), salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3], salt.getSalt_buf()[4], salt.getSalt_buf()[5], salt.getSalt_buf()[6], salt.getSalt_buf()[7], ct_data, digest[0], digest[1], digest[2], digest[3], digest[4], digest[5], digest[6], digest[7]);
		return line_len;
		u32 digest = (u32)digest_buf;
		ethereum_presale_t ethereum_presale = (ethereum_presale_t)esalt_buf;
		// get the initialization vector:
		u8[] encseed = new u8[]{0};
		u32[] iv = new u32();
		iv[0] = ModernizedCProgram.byte_swap_32(ethereum_presale.getIv()[0]);
		iv[1] = ModernizedCProgram.byte_swap_32(ethereum_presale.getIv()[1]);
		iv[2] = ModernizedCProgram.byte_swap_32(ethereum_presale.getIv()[2]);
		iv[3] = ModernizedCProgram.byte_swap_32(ethereum_presale.getIv()[3]);
		ModernizedCProgram.u32_to_hex(iv[0], encseed + 0);
		ModernizedCProgram.u32_to_hex(iv[1], encseed + 8);
		ModernizedCProgram.u32_to_hex(iv[2], encseed + 16);
		ModernizedCProgram.u32_to_hex(iv[3], encseed + 24)// get the raw enc_seed (without iv):;// get the raw enc_seed (without iv):
		u32 enc_seed_ptr = (u32)ethereum_presale.getEnc_seed();
		for (u32 i = 0;
		u32 j = 32;
		 i < ethereum_presale.getEnc_seed_len() / 4; ) {
			u32 tmp = enc_seed_ptr[i];
			tmp = ModernizedCProgram.byte_swap_32(tmp);
			ModernizedCProgram.u32_to_hex(tmp, encseed + j);
		}
		// 16 bytes IV + encrypted seed (in hex)u32 max_hex_len = (16 + ethereum_presale.getEnc_seed_len()) * 2;
		u32 max_pos = ((( - 1) < (max_hex_len)) ? ( - 1) : (max_hex_len));
		encseed[max_pos] = 0// salt:;// salt:
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0// output:;// output:
		int line_len = .snprintf(line_buf, line_size, "%s*%s*%s*%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_ETHEREUM_PRESALE, encseed, tmp_salt, ModernizedCProgram.byte_swap_32(digest[0]), ModernizedCProgram.byte_swap_32(digest[1]), ModernizedCProgram.byte_swap_32(digest[2]), ModernizedCProgram.byte_swap_32(digest[3]));
		return line_len;
		apple_secure_notes_t apple_secure_notes = (apple_secure_notes_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%s%u$16$%08x%08x%08x%08x$%u$%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_FILEVAULT2, apple_secure_notes.getZ_PK(), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOSALT()[0]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOSALT()[1]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOSALT()[2]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOSALT()[3]), apple_secure_notes.getZCRYPTOITERATIONCOUNT(), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[0]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[1]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[2]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[3]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[4]), ModernizedCProgram.byte_swap_32(apple_secure_notes.getZCRYPTOWRAPPEDKEY()[5]));
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s$%08X%08X%08X%08X%08X", tmp_salt, digest[0], digest[1], digest[2], digest[3], digest[4]);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		diskcryptor_esalt_t diskcryptor_esalt = (diskcryptor_esalt_t)esalt_buf;
		// first only add the signature and version number:
		int line_len = .snprintf(line_buf, line_size, "%s%i*", ModernizedCProgram.SIGNATURE_DISKCRYPTOR, ModernizedCProgram.DISKCRYPTOR_VERSION);
		// ... then add the full header (in hexadecimal):
		for (u32 i = 0;
		 i < 512; i++) {
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%08x", ModernizedCProgram.byte_swap_32(diskcryptor_esalt.getSalt_buf()[i]));
		}
		return line_len;
		u32 digest = (u32)digest_buf;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%s%08x%08x%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_SYBASEASE, tmp_salt, digest[0], digest[1], digest[2], digest[3], digest[4], digest[5], digest[6], digest[7]);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		int out_len = 56;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + 56);
		int out_len = 64;
		return out_len;
		u64 digest = (u64)digest_buf;
		u64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + 16);
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + 32);
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + 48);
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + 64);
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + 80);
		int out_len = 96;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		byte[] base64_salt = new byte[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)salt.getSalt_buf(), salt.getSalt_len(), (u8)base64_salt);
		byte[] base64_digest = new byte[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)digest_buf, 32, (u8)base64_digest);
		int line_len = .snprintf(line_buf, line_size, "%s:%u:%u:%u:%s:%s", ModernizedCProgram.SIGNATURE_SCRYPT, salt.getScrypt_N(), salt.getScrypt_r(), salt.getScrypt_p(), base64_salt, base64_digest);
		return line_len;
		u64 digest = (u64)digest_buf;
		u64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + 16);
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + 32);
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + 48);
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + 64);
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + 80);
		ModernizedCProgram.u64_to_hex(tmp[6], out_buf + 96);
		ModernizedCProgram.u64_to_hex(tmp[7], out_buf + 112);
		int out_len = 128;
		return out_len;
		android_backup_t android_backup = (android_backup_t)esalt_buf;
		int line_len = 0;
		line_len += .snprintf(line_buf + line_len, line_size - line_len, "%s%u*%u*%u", ModernizedCProgram.SIGNATURE_ANDROID_BACKUP, android_backup.getVersion(), android_backup.getCipher(), android_backup.getIter());
		line_buf[line_len++] = (byte)'*';
		for (int i = 0;
		 i < 16; i++) {
			ModernizedCProgram.u32_to_hex(android_backup.getUser_salt()[i], (u8)line_buf + line_len);
			line_len += 8;
		}
		line_buf[line_len++] = (byte)'*';
		for (int i = 0;
		 i < 16; i++) {
			ModernizedCProgram.u32_to_hex(android_backup.getCk_salt()[i], (u8)line_buf + line_len);
			line_len += 8;
		}
		line_buf[line_len++] = (byte)'*';
		for (int i = 0;
		 i < 4; i++) {
			ModernizedCProgram.u32_to_hex(android_backup.getUser_iv()[i], (u8)line_buf + line_len);
			line_len += 8;
		}
		line_buf[line_len++] = (byte)'*';
		for (int i = 0;
		 i < 24; i++) {
			ModernizedCProgram.u32_to_hex(android_backup.getMasterkey_blob()[i], (u8)line_buf + line_len);
			line_len += 8;
		}
		return line_len;
		u32 digest = (u32)digest_buf;
		byte[] sig = new byte[]{(byte)'n', (byte)'r', (byte)'c', (byte)'s', (byte)'t', (byte)'n'};
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		u8[] tmp_buf = new u8();
		tmp_buf[0] = sig[0];
		tmp_buf[1] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[0])) >> 12) & -1024);
		tmp_buf[2] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[0])) >> 6) & -1024);
		tmp_buf[3] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[0])) >> 0) & -1024);
		tmp_buf[4] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[0])) >> 12) & -1024);
		tmp_buf[5] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[0])) >> 6) & -1024);
		tmp_buf[6] = sig[1];
		tmp_buf[7] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[0])) >> 0) & -1024);
		tmp_buf[8] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[1])) >> 12) & -1024);
		tmp_buf[9] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[1])) >> 6) & -1024);
		tmp_buf[10] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[1])) >> 0) & -1024);
		tmp_buf[11] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[1])) >> 12) & -1024);
		tmp_buf[12] = sig[2];
		tmp_buf[13] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[1])) >> 6) & -1024);
		tmp_buf[14] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[1])) >> 0) & -1024);
		tmp_buf[15] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[2])) >> 12) & -1024);
		tmp_buf[16] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[2])) >> 6) & -1024);
		tmp_buf[17] = sig[3];
		tmp_buf[18] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[2])) >> 0) & -1024);
		tmp_buf[19] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[2])) >> 12) & -1024);
		tmp_buf[20] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[2])) >> 6) & -1024);
		tmp_buf[21] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[2])) >> 0) & -1024);
		tmp_buf[22] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[3])) >> 12) & -1024);
		tmp_buf[23] = sig[4];
		tmp_buf[24] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[3])) >> 6) & -1024);
		tmp_buf[25] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16b_from_v32(tmp[3])) >> 0) & -1024);
		tmp_buf[26] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[3])) >> 12) & -1024);
		tmp_buf[27] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[3])) >> 6) & -1024);
		tmp_buf[28] = ModernizedCProgram.int_to_base64(((ModernizedCProgram.v16a_from_v32(tmp[3])) >> 0) & -1024);
		tmp_buf[29] = sig[5];
		tmp_buf[30] = 0;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len() - .strlen(ModernizedCProgram.adm), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s:%s", tmp_buf, tmp_salt);
		return line_len;
		return .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		agilekey_t agilekey = (agilekey_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%u:%08x%08x:", salt.getSalt_iter() + 1, ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]));
		for (u32 i = 0;
		 i < 1040; i++) {
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%02x", agilekey.getCipher()[i]);
		}
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%08x:%s", digest[0], tmp_salt);
		return line_len;
		pkzip_t pkzip = (pkzip_t)esalt_buf;
		int out_len = 0;
		if (pkzip.getVersion() == 1) {
			.sprintf(line_buf, "%s", ModernizedCProgram.SIGNATURE_PKZIP_V1);
			out_len += 7;
		} else {
				.sprintf(line_buf, "%s", ModernizedCProgram.SIGNATURE_PKZIP_V2);
				out_len += 8;
		} 
		out_len += .sprintf(line_buf + out_len, "%i*%i*", pkzip.getHash_count(), pkzip.getChecksum_size());
		for (int cnt = 0;
		 cnt < pkzip.getHash_count(); cnt++) {
			if (cnt > 0) {
				out_len += .sprintf(line_buf + out_len, "*");
			} 
			out_len += .sprintf(line_buf + out_len, "%i*%i*", pkzip.getHashes()[cnt].getData_type_enum(), pkzip.getHashes()[cnt].getMagic_type_enum());
			if (pkzip.getHashes()[cnt].getData_type_enum() > 1) {
				out_len += .sprintf(line_buf + out_len, "%x*%x*%x*%x*%x*", pkzip.getHashes()[cnt].getCompressed_length(), pkzip.getHashes()[cnt].getUncompressed_length(), pkzip.getHashes()[cnt].getCrc32(), pkzip.getHashes()[cnt].getOffset(), pkzip.getHashes()[cnt].getAdditional_offset());
			} 
			out_len += .sprintf(line_buf + out_len, "%i*%x*%04x*", pkzip.getHashes()[cnt].getCompression_type(), pkzip.getHashes()[cnt].getData_length(), pkzip.getHashes()[cnt].getChecksum_from_crc());
			if (pkzip.getVersion() == 2) {
				out_len += .sprintf(line_buf + out_len, "%04x*", pkzip.getHashes()[cnt].getChecksum_from_timestamp());
			} 
			for (u32 i = 0;
			 i < pkzip.getHashes()[cnt].getData_length() / 4; i++) {
				out_len += .sprintf(line_buf + out_len, "%08x", ModernizedCProgram.byte_swap_32(pkzip.getHashes()[cnt].getData()[i]));
			}
			for (u32 i = 0;
			 i < pkzip.getHashes()[cnt].getData_length() % 4; i++) {
				out_len += .sprintf(line_buf + out_len, "%02x", (pkzip.getHashes()[cnt].getData()[pkzip.getHashes()[cnt].getData_length() / 4] >> i * 8) & -1024);
			}
		}
		if (pkzip.getVersion() == 1) {
			out_len += .sprintf(line_buf + out_len, "*$/pkzip$");
		} else {
				out_len += .sprintf(line_buf + out_len, "*$/pkzip2$");
		} 
		return out_len;
		u64 digest = (u64)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_64_constants.SHA512M_A;
			tmp[1] += sha2_64_constants.SHA512M_B;
			tmp[2] += sha2_64_constants.SHA512M_C;
			tmp[3] += sha2_64_constants.SHA512M_D;
			tmp[4] += sha2_64_constants.SHA512M_E;
			tmp[5] += sha2_64_constants.SHA512M_F;
			tmp[6] += sha2_64_constants.SHA512M_G;
			tmp[7] += sha2_64_constants.SHA512M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[6], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[7], out_buf + out_len);
		out_len += 16;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		diskcryptor_esalt_t diskcryptor_esalt = (diskcryptor_esalt_t)esalt_buf;
		// first only add the signature and version number:
		int line_len = .snprintf(line_buf, line_size, "%s%i*", ModernizedCProgram.SIGNATURE_DISKCRYPTOR, ModernizedCProgram.DISKCRYPTOR_VERSION);
		// ... then add the full header (in hexadecimal):
		for (u32 i = 0;
		 i < 512; i++) {
			line_len += .snprintf(line_buf + line_len, line_size - line_len, "%08x", ModernizedCProgram.byte_swap_32(diskcryptor_esalt.getSalt_buf()[i]));
		}
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		pkzip_t pkzip = (pkzip_t)esalt_buf;
		int out_len = 0;
		if (pkzip.getVersion() == 1) {
			.sprintf(line_buf, "%s", ModernizedCProgram.SIGNATURE_PKZIP_V1);
			out_len += 7;
		} else {
				.sprintf(line_buf, "%s", ModernizedCProgram.SIGNATURE_PKZIP_V2);
				out_len += 8;
		} 
		out_len += .sprintf(line_buf + out_len, "%i*%i*", pkzip.getHash_count(), pkzip.getChecksum_size());
		for (int cnt = 0;
		 cnt < pkzip.getHash_count(); cnt++) {
			if (cnt > 0) {
				out_len += .sprintf(line_buf + out_len, "*");
			} 
			out_len += .sprintf(line_buf + out_len, "%i*%i*", pkzip.getHashes()[cnt].getData_type_enum(), pkzip.getHashes()[cnt].getMagic_type_enum());
			if (pkzip.getHashes()[cnt].getData_type_enum() > 1) {
				out_len += .sprintf(line_buf + out_len, "%x*%x*%x*%x*%x*", pkzip.getHashes()[cnt].getCompressed_length(), pkzip.getHashes()[cnt].getUncompressed_length(), pkzip.getHashes()[cnt].getCrc32(), pkzip.getHashes()[cnt].getOffset(), pkzip.getHashes()[cnt].getAdditional_offset());
			} 
			out_len += .sprintf(line_buf + out_len, "%i*%x*%04x*", pkzip.getHashes()[cnt].getCompression_type(), pkzip.getHashes()[cnt].getData_length(), pkzip.getHashes()[cnt].getChecksum_from_crc());
			if (pkzip.getVersion() == 2) {
				out_len += .sprintf(line_buf + out_len, "%04x*", pkzip.getHashes()[cnt].getChecksum_from_timestamp());
			} 
			for (u32 i = 0;
			 i < pkzip.getHashes()[cnt].getData_length() / 4; i++) {
				out_len += .sprintf(line_buf + out_len, "%08x", ModernizedCProgram.byte_swap_32(pkzip.getHashes()[cnt].getData()[i]));
			}
			for (u32 i = 0;
			 i < pkzip.getHashes()[cnt].getData_length() % 4; i++) {
				out_len += .sprintf(line_buf + out_len, "%02x", (pkzip.getHashes()[cnt].getData()[pkzip.getHashes()[cnt].getData_length() / 4] >> i * 8) & -1024);
			}
		}
		if (pkzip.getVersion() == 1) {
			out_len += .sprintf(line_buf + out_len, "*$/pkzip$");
		} else {
				out_len += .sprintf(line_buf + out_len, "*$/pkzip2$");
		} 
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		return .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = 0;
		tmp[3] = 0;
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		int out_len = 16;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		return out_len;
		return .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		u64 digest = (u64)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_64_constants.SHA512M_A;
			tmp[1] += sha2_64_constants.SHA512M_B;
			tmp[2] += sha2_64_constants.SHA512M_C;
			tmp[3] += sha2_64_constants.SHA512M_D;
			tmp[4] += sha2_64_constants.SHA512M_E;
			tmp[5] += sha2_64_constants.SHA512M_F;
			tmp[6] += sha2_64_constants.SHA512M_G;
			tmp[7] += sha2_64_constants.SHA512M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[6], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[7], out_buf + out_len);
		out_len += 16;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = ModernizedCProgram.rotl32(digest[0], 29);
		tmp[1] = ModernizedCProgram.rotl32(digest[1], 29);
		{ 
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 1;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 1;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 8;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 8;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 2;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 2;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 16;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 16;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 4;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 4;
				tmp[1] = tmp[1] ^ t;
			}
			;
		}
		;
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s*%s*%08X%08X", ModernizedCProgram.SIGNATURE_RACF, tmp_salt, ModernizedCProgram.byte_swap_32(tmp[0]), ModernizedCProgram.byte_swap_32(tmp[1]));
		return line_len;
		u32 digest = (u32)digest_buf;
		// this (useless?) initialization makes scan-build happyu32[] tmp = new u32[]{0};
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		byte[] ptr_plain = new byte[]{0};
		ModernizedCProgram.sha1aix_encode((byte)tmp, (byte)ptr_plain);
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%02u$%s$%s", ModernizedCProgram.SIGNATURE_SHA1AIX, salt.getSalt_sign()[0], tmp_salt, ptr_plain);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		tmp[8] = digest[8];
		tmp[9] = digest[9];
		tmp[10] = digest[10];
		tmp[11] = digest[11];
		tmp[12] = digest[12];
		tmp[13] = digest[13];
		tmp[14] = digest[14];
		tmp[15] = digest[15];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		tmp[8] = ModernizedCProgram.byte_swap_32(tmp[8]);
		tmp[9] = ModernizedCProgram.byte_swap_32(tmp[9]);
		tmp[10] = ModernizedCProgram.byte_swap_32(tmp[10]);
		tmp[11] = ModernizedCProgram.byte_swap_32(tmp[11]);
		tmp[12] = ModernizedCProgram.byte_swap_32(tmp[12]);
		tmp[13] = ModernizedCProgram.byte_swap_32(tmp[13]);
		tmp[14] = ModernizedCProgram.byte_swap_32(tmp[14]);
		tmp[15] = ModernizedCProgram.byte_swap_32(tmp[15]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + 56);
		ModernizedCProgram.u32_to_hex(tmp[8], out_buf + 64);
		ModernizedCProgram.u32_to_hex(tmp[9], out_buf + 72);
		ModernizedCProgram.u32_to_hex(tmp[10], out_buf + 80);
		ModernizedCProgram.u32_to_hex(tmp[11], out_buf + 88);
		ModernizedCProgram.u32_to_hex(tmp[12], out_buf + 96);
		ModernizedCProgram.u32_to_hex(tmp[13], out_buf + 104);
		ModernizedCProgram.u32_to_hex(tmp[14], out_buf + 112);
		ModernizedCProgram.u32_to_hex(tmp[15], out_buf + 120);
		int out_len = 128;
		return out_len;
		pkzip_t pkzip = (pkzip_t)esalt_buf;
		int out_len = 0;
		if (pkzip.getVersion() == 1) {
			.sprintf(line_buf, "%s", ModernizedCProgram.SIGNATURE_PKZIP_V1);
			out_len += 7;
		} else {
				.sprintf(line_buf, "%s", ModernizedCProgram.SIGNATURE_PKZIP_V2);
				out_len += 8;
		} 
		out_len += .sprintf(line_buf + out_len, "%i*%i*", pkzip.getHash_count(), pkzip.getChecksum_size());
		out_len += .sprintf(line_buf + out_len, "%i*%i*", pkzip.getHash().getData_type_enum(), pkzip.getHash().getMagic_type_enum());
		if (pkzip.getHash().getData_type_enum() > 1) {
			out_len += .sprintf(line_buf + out_len, "%x*%x*%x*%x*%x*", pkzip.getHash().getCompressed_length(), pkzip.getHash().getUncompressed_length(), pkzip.getHash().getCrc32(), pkzip.getHash().getOffset(), pkzip.getHash().getAdditional_offset());
		} 
		out_len += .sprintf(line_buf + out_len, "%i*%x*%04x*", pkzip.getHash().getCompression_type(), pkzip.getHash().getData_length(), pkzip.getHash().getChecksum_from_crc());
		if (pkzip.getVersion() == 2) {
			out_len += .sprintf(line_buf + out_len, "%04x*", pkzip.getHash().getChecksum_from_timestamp());
		} 
		for (u32 i = 0;
		 i < pkzip.getHash().getData_length() / 4; i++) {
			out_len += .sprintf(line_buf + out_len, "%08x", ModernizedCProgram.byte_swap_32(pkzip.getHash().getData()[i]));
		}
		for (u32 i = 0;
		 i < pkzip.getHash().getData_length() % 4; i++) {
			out_len += .sprintf(line_buf + out_len, "%02x", (pkzip.getHash().getData()[pkzip.getHash().getData_length() / 4] >> i * 8) & -1024);
		}
		if (pkzip.getVersion() == 1) {
			out_len += .sprintf(line_buf + out_len, "*$/pkzip$");
		} else {
				out_len += .sprintf(line_buf + out_len, "*$/pkzip2$");
		} 
		return out_len;
		u64 digest = (u64)digest_buf;
		u64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_64_constants.SHA512M_A;
			tmp[1] += sha2_64_constants.SHA512M_B;
			tmp[2] += sha2_64_constants.SHA512M_C;
			tmp[3] += sha2_64_constants.SHA512M_D;
			tmp[4] += sha2_64_constants.SHA512M_E;
			tmp[5] += sha2_64_constants.SHA512M_F;
			tmp[6] += sha2_64_constants.SHA512M_G;
			tmp[7] += sha2_64_constants.SHA512M_H;
		} 
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "0x0200%s%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x", tmp_salt, ModernizedCProgram.v32b_from_v64(tmp[0]), ModernizedCProgram.v32a_from_v64(tmp[0]), ModernizedCProgram.v32b_from_v64(tmp[1]), ModernizedCProgram.v32a_from_v64(tmp[1]), ModernizedCProgram.v32b_from_v64(tmp[2]), ModernizedCProgram.v32a_from_v64(tmp[2]), ModernizedCProgram.v32b_from_v64(tmp[3]), ModernizedCProgram.v32a_from_v64(tmp[3]), ModernizedCProgram.v32b_from_v64(tmp[4]), ModernizedCProgram.v32a_from_v64(tmp[4]), ModernizedCProgram.v32b_from_v64(tmp[5]), ModernizedCProgram.v32a_from_v64(tmp[5]), ModernizedCProgram.v32b_from_v64(tmp[6]), ModernizedCProgram.v32a_from_v64(tmp[6]), ModernizedCProgram.v32b_from_v64(tmp[7]), ModernizedCProgram.v32a_from_v64(tmp[7]));
		return line_len;
		byte[] ptr_plain = new byte[]{0};
		ModernizedCProgram.sha256crypt_encode((byte)digest_buf, (byte)ptr_plain);
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len;
		if (salt.getSalt_iter() == ModernizedCProgram.ROUNDS_SHA256CRYPT) {
			line_len = .snprintf(line_buf, line_size, "$5$%s$%s", tmp_salt, ptr_plain);
		} else {
				line_len = .snprintf(line_buf, line_size, "$5$rounds=%u$%s$%s", salt.getSalt_iter(), tmp_salt, ptr_plain);
		} 
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		tmp[8] = digest[8];
		tmp[9] = digest[9];
		tmp[10] = digest[10];
		tmp[11] = digest[11];
		tmp[12] = digest[12];
		tmp[13] = digest[13];
		tmp[14] = digest[14];
		tmp[15] = digest[15];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + 56);
		ModernizedCProgram.u32_to_hex(tmp[8], out_buf + 64);
		ModernizedCProgram.u32_to_hex(tmp[9], out_buf + 72);
		ModernizedCProgram.u32_to_hex(tmp[10], out_buf + 80);
		ModernizedCProgram.u32_to_hex(tmp[11], out_buf + 88);
		ModernizedCProgram.u32_to_hex(tmp[12], out_buf + 96);
		ModernizedCProgram.u32_to_hex(tmp[13], out_buf + 104);
		ModernizedCProgram.u32_to_hex(tmp[14], out_buf + 112);
		ModernizedCProgram.u32_to_hex(tmp[15], out_buf + 120);
		int out_len = 128;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		krb5asrep_t krb5asrep = (krb5asrep_t)esalt_buf;
		byte[] data = new byte[]{0};
		for (u32 i = 0;
		u32 j = 0;
		 i < krb5asrep.getEdata2_len(); ) {
			u8 ptr_edata2 = (u8)krb5asrep.getEdata2();
			.sprintf(data + j, "%02x", ptr_edata2[i]);
		}
		int line_len = .snprintf(line_buf, line_size, "%s%s%08x%08x%08x%08x$%s", ModernizedCProgram.SIGNATURE_KRB5ASREP, (byte)krb5asrep.getAccount_info(), ModernizedCProgram.byte_swap_32(krb5asrep.getChecksum()[0]), ModernizedCProgram.byte_swap_32(krb5asrep.getChecksum()[1]), ModernizedCProgram.byte_swap_32(krb5asrep.getChecksum()[2]), ModernizedCProgram.byte_swap_32(krb5asrep.getChecksum()[3]), data);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + 56);
		int out_len = 64;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		int out_len = 40;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u8[] tmp = new u8[]{0};
		ModernizedCProgram.md5crypt_encode(digest_buf, tmp);
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = 0;
		if (salt.getSalt_iter() == ModernizedCProgram.ROUNDS_MD5CRYPT) {
			line_len = .snprintf(line_buf, line_size, "$1$%s$%s", tmp_salt, tmp);
		} else {
				line_len = .snprintf(line_buf, line_size, "$1$rounds=%u$%s$%s", salt.getSalt_iter(), tmp_salt, tmp);
		} 
		return line_len;
		office2013_t office2013 = (office2013_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%s*%d*%d*%d*%d*%08x%08x%08x%08x*%08x%08x%08x%08x*%08x%08x%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_OFFICE2013, 2013, 100000, 256, 16, salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3], office2013.getEncryptedVerifier()[0], office2013.getEncryptedVerifier()[1], office2013.getEncryptedVerifier()[2], office2013.getEncryptedVerifier()[3], office2013.getEncryptedVerifierHash()[0], office2013.getEncryptedVerifierHash()[1], office2013.getEncryptedVerifierHash()[2], office2013.getEncryptedVerifierHash()[3], office2013.getEncryptedVerifierHash()[4], office2013.getEncryptedVerifierHash()[5], office2013.getEncryptedVerifierHash()[6], office2013.getEncryptedVerifierHash()[7]);
		return line_len;
		u32 digest = (u32)digest_buf;
		pbkdf2_sha256_t pbkdf2_sha256 = (pbkdf2_sha256_t)esalt_buf;
		// hashu32[] tmp = new u32();
		tmp[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(digest[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(digest[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(digest[7]);
		tmp[8] = 0;
		byte[] salt_enc = new byte[]{0};
		byte[] hash_enc = new byte[]{0};
		size_t salt_len_enc = ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_ab64, (u8)pbkdf2_sha256.getSalt_buf(), salt.getSalt_len(), (u8)salt_enc);
		size_t hash_len_enc = ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_ab64, (u8)tmp, ModernizedCProgram.HASH_LEN_RAW, (u8)hash_enc);
		// remove padding =for (size_t i = 0;
		 i < salt_len_enc; i++) {
			if (salt_enc[i] == (byte)'=') {
				salt_enc[i] = (byte)'\0';
			} 
		}
		for (size_t i = 0;
		 i < hash_len_enc; i++) {
			if (hash_enc[i] == (byte)'=') {
				hash_enc[i] = (byte)'\0';
			} 
		}
		// outputint line_len = .snprintf(line_buf, line_size, "$%s$%u$%s$%s", ModernizedCProgram.SIGNATURE_PASSLIB_PBKDF2_SHA256, salt.getSalt_iter() + 1, salt_enc, hash_enc);
		return line_len;
		office2010_t office2010 = (office2010_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%s*%d*%d*%d*%d*%08x%08x%08x%08x*%08x%08x%08x%08x*%08x%08x%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_OFFICE2010, 2010, 100000, 128, 16, salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3], office2010.getEncryptedVerifier()[0], office2010.getEncryptedVerifier()[1], office2010.getEncryptedVerifier()[2], office2010.getEncryptedVerifier()[3], office2010.getEncryptedVerifierHash()[0], office2010.getEncryptedVerifierHash()[1], office2010.getEncryptedVerifierHash()[2], office2010.getEncryptedVerifierHash()[3], office2010.getEncryptedVerifierHash()[4], office2010.getEncryptedVerifierHash()[5], office2010.getEncryptedVerifierHash()[6], office2010.getEncryptedVerifierHash()[7]);
		return line_len;
		krb5tgs_t krb5tgs = (krb5tgs_t)esalt_buf;
		byte[] data = new byte[]{0};
		for (u32 i = 0;
		u32 j = 0;
		 i < krb5tgs.getEdata2_len(); ) {
			u8 ptr_edata2 = (u8)krb5tgs.getEdata2();
			.sprintf(data + j, "%02x", ptr_edata2[i]);
		}
		int line_len = .snprintf(line_buf, line_size, "%s%s%08x%08x%08x%08x$%s", ModernizedCProgram.SIGNATURE_KRB5TGS, (byte)krb5tgs.getAccount_info(), ModernizedCProgram.byte_swap_32(krb5tgs.getChecksum()[0]), ModernizedCProgram.byte_swap_32(krb5tgs.getChecksum()[1]), ModernizedCProgram.byte_swap_32(krb5tgs.getChecksum()[2]), ModernizedCProgram.byte_swap_32(krb5tgs.getChecksum()[3]), data);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		int out_len = 24;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)out_buf + out_len);
		return out_len;
		u8[] tmp = new u8[]{0};
		ModernizedCProgram.phpass_encode(digest_buf, tmp);
		return .snprintf(line_buf, line_size, "%s%s%s", (byte)salt.getSalt_sign(), (byte)salt.getSalt_buf(), tmp);
		return .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		u32 digest = (u32)digest_buf;
		int line_len = .snprintf(line_buf, line_size, "%08x:%08x", ModernizedCProgram.byte_swap_32(digest[0]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]));
		return line_len;
		krb5pa_18_t krb5pa = (krb5pa_18_t)esalt_buf;
		byte[] data = new byte[]{0};
		for (u32 i = 0;
		u32 j = 0;
		 i < krb5pa.getEnc_timestamp_len(); ) {
			u8 ptr_enc_timestamp = (u8)krb5pa.getEnc_timestamp();
			.sprintf(data + j, "%02x", ptr_enc_timestamp[i]);
		}
		int line_len = .snprintf(line_buf, line_size, "%s%s$%s$%s%08x%08x%08x", ModernizedCProgram.SIGNATURE_KRB5PA, (byte)krb5pa.getUser(), (byte)krb5pa.getDomain(), data, krb5pa.getChecksum()[0], krb5pa.getChecksum()[1], krb5pa.getChecksum()[2]);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA224M_A;
			tmp[1] += sha2_32_constants.SHA224M_B;
			tmp[2] += sha2_32_constants.SHA224M_C;
			tmp[3] += sha2_32_constants.SHA224M_D;
			tmp[4] += sha2_32_constants.SHA224M_E;
			tmp[5] += sha2_32_constants.SHA224M_F;
			tmp[6] += sha2_32_constants.SHA224M_G;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		int out_len = 56;
		return out_len;
		u64 digest = (u64)digest_buf;
		u64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + 16);
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + 32);
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + 48);
		int out_len = 64;
		return out_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		byte[] tmp_buf = new byte[512];
		.memcpy(tmp_buf, tmp, 20);
		.memcpy(tmp_buf + 20, salt.getSalt_buf(), salt.getSalt_len());
		byte[] ptr_plain = new byte[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp_buf, 20 + salt.getSalt_len(), (u8)ptr_plain);
		int line_len = .snprintf(line_buf, line_size, "{SSHA}%s", ptr_plain);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		return .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%08x%08x%08x%08x%08x", tmp_salt, tmp[0], tmp[1], tmp[2], tmp[3], tmp[4]);
		return line_len;
		bsp_t bsp = (bsp_t)esalt_buf;
		u8[] tmp_buf = new u8();
		.memcpy(tmp_buf + 0, bsp.getSignature(), 3);
		.memcpy(tmp_buf + 3, bsp.getDigest(), 32);
		.memcpy(tmp_buf + 35, bsp.getSalt(), 16);
		.memcpy(tmp_buf + 51, bsp.getIter(), 4);
		.memcpy(tmp_buf + 55, bsp.getCrc32(), 4);
		return ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp_buf, 59, (u8)line_buf);
		u8[] tmp = new u8[]{0};
		ModernizedCProgram.md5crypt_encode(digest_buf, tmp);
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = 0;
		if (salt.getSalt_iter() == ModernizedCProgram.ROUNDS_MD5CRYPT) {
			line_len = .snprintf(line_buf, line_size, "$apr1$%s$%s", tmp_salt, tmp);
		} else {
				line_len = .snprintf(line_buf, line_size, "$apr1$rounds=%u$%s$%s", salt.getSalt_iter(), tmp_salt, tmp);
		} 
		return line_len;
		odf11_t odf11 = (odf11_t)esalt_buf;
		int out_len = .snprintf(line_buf, line_size, "%s*0*0*%u*16*%08x%08x%08x%08x%08x*8*%08x%08x*16*%08x%08x%08x%08x*0*", ModernizedCProgram.SIGNATURE_ODF, odf11.getIterations(), ModernizedCProgram.byte_swap_32(odf11.getChecksum()[0]), ModernizedCProgram.byte_swap_32(odf11.getChecksum()[1]), ModernizedCProgram.byte_swap_32(odf11.getChecksum()[2]), ModernizedCProgram.byte_swap_32(odf11.getChecksum()[3]), ModernizedCProgram.byte_swap_32(odf11.getChecksum()[4]), odf11.getIv()[0], odf11.getIv()[1], salt.getSalt_buf()[0], salt.getSalt_buf()[1], salt.getSalt_buf()[2], salt.getSalt_buf()[3]);
		u8 out_buf = (u8)line_buf;
		for (int i = 0;
		 i < 256; i++) {
			ModernizedCProgram.u32_to_hex(ModernizedCProgram.byte_swap_32(odf11.getEncrypted_data()[i]), out_buf + out_len);
			out_len += 8;
		}
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[4];
		tmp[1] = digest[5];
		tmp[2] = digest[6];
		tmp[3] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		out_buf[0] = ModernizedCProgram.int_to_itoa64((tmp[0] >> 0) & -1024);
		out_buf[1] = ModernizedCProgram.int_to_itoa64((tmp[0] >> 6) & -1024);
		out_buf[2] = ModernizedCProgram.int_to_itoa64((tmp[0] >> 12) & -1024);
		out_buf[3] = ModernizedCProgram.int_to_itoa64((tmp[0] >> 18) & -1024);
		out_buf[4] = ModernizedCProgram.int_to_itoa64((tmp[1] >> 0) & -1024);
		out_buf[5] = ModernizedCProgram.int_to_itoa64((tmp[1] >> 6) & -1024);
		out_buf[6] = ModernizedCProgram.int_to_itoa64((tmp[1] >> 12) & -1024);
		out_buf[7] = ModernizedCProgram.int_to_itoa64((tmp[1] >> 18) & -1024);
		out_buf[8] = ModernizedCProgram.int_to_itoa64((tmp[2] >> 0) & -1024);
		out_buf[9] = ModernizedCProgram.int_to_itoa64((tmp[2] >> 6) & -1024);
		out_buf[10] = ModernizedCProgram.int_to_itoa64((tmp[2] >> 12) & -1024);
		out_buf[11] = ModernizedCProgram.int_to_itoa64((tmp[2] >> 18) & -1024);
		out_buf[12] = ModernizedCProgram.int_to_itoa64((tmp[3] >> 0) & -1024);
		out_buf[13] = ModernizedCProgram.int_to_itoa64((tmp[3] >> 6) & -1024);
		out_buf[14] = ModernizedCProgram.int_to_itoa64((tmp[3] >> 12) & -1024);
		out_buf[15] = ModernizedCProgram.int_to_itoa64((tmp[3] >> 18) & -1024);
		int out_len = 16;
		return out_len;
		u32 digest = (u32)digest_buf;
		u8 ptr = (u8)salt.getSalt_buf();
		int line_len = .snprintf(line_buf, line_size, "%s,%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x,%u,%08x%08x%08x%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_MS_DRSR, ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7], ptr[8], ptr[9], salt.getSalt_iter() + 1, digest[0], digest[1], digest[2], digest[3], digest[4], digest[5], digest[6], digest[7]);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		keepass_t keepass = (keepass_t)esalt_buf;
		u32 version = keepass.getVersion();
		u32 rounds = salt.getSalt_iter();
		u32 algorithm = keepass.getAlgorithm();
		u32 keyfile_len = keepass.getKeyfile_len();
		u32 ptr_final_random_seed = (u32)keepass.getFinal_random_seed();
		u32 ptr_transf_random_seed = (u32)keepass.getTransf_random_seed();
		u32 ptr_enc_iv = (u32)keepass.getEnc_iv();
		u32 ptr_contents_hash = (u32)keepass.getContents_hash();
		u32 ptr_keyfile = (u32)keepass.getKeyfile();
		// specific to version 2u32 expected_bytes_len = new u32();
		u32 ptr_expected_bytes = new u32();
		u32 final_random_seed_len = new u32();
		u32 transf_random_seed_len = new u32();
		u32 enc_iv_len = new u32();
		u32 contents_hash_len = new u32();
		transf_random_seed_len = 8;
		enc_iv_len = 4;
		contents_hash_len = 8;
		final_random_seed_len = 8;
		if (version == 1) {
			final_random_seed_len = 4;
		} 
		.snprintf(line_buf, line_size, "%s*%u*%u*%u", ModernizedCProgram.SIGNATURE_KEEPASS, version, rounds, algorithm);
		byte ptr_data = line_buf;
		ptr_data += .strlen(line_buf);
		ptr_data = (byte)'*';
		ptr_data++;
		for (u32 i = 0;
		 i < final_random_seed_len; ) {
			.sprintf(ptr_data, "%08x", ptr_final_random_seed[i]);
		}
		ptr_data = (byte)'*';
		ptr_data++;
		for (u32 i = 0;
		 i < transf_random_seed_len; ) {
			.sprintf(ptr_data, "%08x", ptr_transf_random_seed[i]);
		}
		ptr_data = (byte)'*';
		ptr_data++;
		for (u32 i = 0;
		 i < enc_iv_len; ) {
			.sprintf(ptr_data, "%08x", ptr_enc_iv[i]);
		}
		ptr_data = (byte)'*';
		ptr_data++;
		if (version == 1) {
			u32 contents_len = keepass.getContents_len();
			u32 ptr_contents = (u32)keepass.getContents();
			for (u32 i = 0;
			 i < contents_hash_len; ) {
				.sprintf(ptr_data, "%08x", ptr_contents_hash[i]);
			}
			ptr_data = (byte)'*';
			ptr_data++;
			ptr_data = (byte)'1';
			ptr_data++;
			ptr_data = (byte)'*';
			ptr_data++;
			byte[] ptr_contents_len = new byte[]{0};
			.sprintf((byte)ptr_contents_len, "%u", contents_len);
			.sprintf(ptr_data, "%u", contents_len);
			ptr_data += .strlen(ptr_contents_len);
			ptr_data = (byte)'*';
			ptr_data++;
			for (u32 i = 0;
			 i < contents_len / 4; ) {
				.sprintf(ptr_data, "%08x", ptr_contents[i]);
			}
		}  else if (version == 2) {
			expected_bytes_len = 8;
			ptr_expected_bytes = (u32)keepass.getExpected_bytes();
			for (u32 i = 0;
			 i < expected_bytes_len; ) {
				.sprintf(ptr_data, "%08x", ptr_expected_bytes[i]);
			}
			ptr_data = (byte)'*';
			ptr_data++;
			for (u32 i = 0;
			 i < contents_hash_len; ) {
				.sprintf(ptr_data, "%08x", ptr_contents_hash[i]);
			}
		} 
		if (keyfile_len) {
			ptr_data = (byte)'*';
			ptr_data++;
			ptr_data = (byte)'1';
			ptr_data++;
			ptr_data = (byte)'*';
			ptr_data++;
			.sprintf(ptr_data, "%u", keyfile_len * 2);
			ptr_data += 2;
			ptr_data = (byte)'*';
			ptr_data++;
			for (u32 i = 0;
			 i < 8; ) {
				.sprintf(ptr_data, "%08x", ptr_keyfile[i]);
			}
		} 
		return .strlen(line_buf);
		u64 digest = (u64)digest_buf;
		u64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_64_constants.SHA512M_A;
			tmp[1] += sha2_64_constants.SHA512M_B;
			tmp[2] += sha2_64_constants.SHA512M_C;
			tmp[3] += sha2_64_constants.SHA512M_D;
			tmp[4] += sha2_64_constants.SHA512M_E;
			tmp[5] += sha2_64_constants.SHA512M_F;
			tmp[6] += sha2_64_constants.SHA512M_G;
			tmp[7] += sha2_64_constants.SHA512M_H;
		} 
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x", tmp_salt, ModernizedCProgram.v32b_from_v64(tmp[0]), ModernizedCProgram.v32a_from_v64(tmp[0]), ModernizedCProgram.v32b_from_v64(tmp[1]), ModernizedCProgram.v32a_from_v64(tmp[1]), ModernizedCProgram.v32b_from_v64(tmp[2]), ModernizedCProgram.v32a_from_v64(tmp[2]), ModernizedCProgram.v32b_from_v64(tmp[3]), ModernizedCProgram.v32a_from_v64(tmp[3]), ModernizedCProgram.v32b_from_v64(tmp[4]), ModernizedCProgram.v32a_from_v64(tmp[4]), ModernizedCProgram.v32b_from_v64(tmp[5]), ModernizedCProgram.v32a_from_v64(tmp[5]), ModernizedCProgram.v32b_from_v64(tmp[6]), ModernizedCProgram.v32a_from_v64(tmp[6]), ModernizedCProgram.v32b_from_v64(tmp[7]), ModernizedCProgram.v32a_from_v64(tmp[7]));
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%s$%08x%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_DJANGOSHA1, tmp_salt, ModernizedCProgram.byte_swap_32(tmp[0]), ModernizedCProgram.byte_swap_32(tmp[1]), ModernizedCProgram.byte_swap_32(tmp[2]), ModernizedCProgram.byte_swap_32(tmp[3]), ModernizedCProgram.byte_swap_32(tmp[4]));
		return line_len;
		byte[] tmp_buf = new byte[64];
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_itoa64, (u8)digest_buf, 32, (u8)tmp_buf);
		// cut it here// cut it heretmp_buf[43] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%s$%s", ModernizedCProgram.SIGNATURE_CISCO9, (byte)salt.getSalt_buf(), tmp_buf);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		return out_len;
		pdf_t pdf = (pdf_t)esalt_buf;
		u8 rc4key = (u8)pdf.getRc4key();
		int line_len = .snprintf(line_buf, line_size, "$pdf$%d*%d*%d*%d*%d*%d*%08x%08x%08x%08x*%d*%08x%08x%08x%08x%08x%08x%08x%08x*%d*%08x%08x%08x%08x%08x%08x%08x%08x:%02x%02x%02x%02x%02x", pdf.getV(), pdf.getR(), 40, pdf.getP(), pdf.getEnc_md(), pdf.getId_len(), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[3]), pdf.getU_len(), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[3]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[4]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[5]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[6]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[7]), pdf.getO_len(), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[3]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[4]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[5]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[6]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[7]), rc4key[0], rc4key[1], rc4key[2], rc4key[3], rc4key[4]);
		return line_len;
		u64 digest = (u64)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu8 out_buf = (u8)line_buf;
		int out_len = .strlen(ModernizedCProgram.SIGNATURE_BLAKE2B);
		.memcpy(out_buf, ModernizedCProgram.SIGNATURE_BLAKE2B, out_len);
		ModernizedCProgram.u64_to_hex(digest[0], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(digest[1], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(digest[2], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(digest[3], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(digest[4], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(digest[5], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(digest[6], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(digest[7], out_buf + out_len);
		out_len += 16;
		return out_len;
		u32 digest = (u32)digest_buf;
		cloudkey_t cloudkey = (cloudkey_t)esalt_buf;
		byte[] data_buf = new byte[]{0};
		for (int i = 0;
		int j = 0;
		 i < 512; ) {
			.sprintf(data_buf + j, "%08x", cloudkey.getData_buf()[i]);
		}
		data_buf[cloudkey.getData_len() * 2] = 0;
		int line_len = .snprintf(line_buf, line_size, "%08x%08x%08x%08x%08x%08x%08x%08x:%08x%08x%08x%08x:%u:%s", digest[0], digest[1], digest[2], digest[3], digest[4], digest[5], digest[6], digest[7], ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[2]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[3]), salt.getSalt_iter() + 1, data_buf);
		return line_len;
		u8[] tmp = new u8[]{0};
		ModernizedCProgram.md5crypt_encode(digest_buf, tmp);
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%s$%s", ModernizedCProgram.SIGNATURE_MD5AIX, tmp_salt, tmp);
		return line_len;
		u32 digest = (u32)digest_buf;
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(digest[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(digest[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(digest[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(digest[3], out_buf + 24);
		int out_len = 32;
		return out_len;
		u32 digest = (u32)digest_buf;
		pstoken_t pstoken = (pstoken_t)esalt_buf;
		u32 salt_len = (pstoken.getSalt_len() > 512) ? 512 : pstoken.getSalt_len();
		byte[] pstoken_tmp = new byte[]{0};
		for (u32 i = 0;
		u32 j = 0;
		 i < salt_len; ) {
			u8 ptr = (u8)pstoken.getSalt_buf();
			.sprintf(pstoken_tmp + j, "%02x", ptr[i]);
		}
		int line_len = .snprintf(line_buf, line_size, "%08x%08x%08x%08x%08x:%s", digest[0], digest[1], digest[2], digest[3], digest[4], pstoken_tmp);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		jks_sha1_t jks_sha1 = (jks_sha1_t)esalt_buf;
		byte[] enc_key = new byte[]{0};
		u8 ptr = (u8)jks_sha1.getEnc_key_buf();
		for (u32 i = 0;
		u32 j = 0;
		 i < jks_sha1.getEnc_key_len(); ) {
			.sprintf(enc_key + j, "%02X", ptr[i]);
		}
		u8 der = (u8)jks_sha1.getDer();
		int line_len = .snprintf(line_buf, line_size, "%s*%08X%08X%08X%08X%08X*%08X%08X%08X%08X%08X*%s*%02X*%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X*%s", ModernizedCProgram.SIGNATURE_JKS_SHA1, ModernizedCProgram.byte_swap_32(jks_sha1.getChecksum()[0]), ModernizedCProgram.byte_swap_32(jks_sha1.getChecksum()[1]), ModernizedCProgram.byte_swap_32(jks_sha1.getChecksum()[2]), ModernizedCProgram.byte_swap_32(jks_sha1.getChecksum()[3]), ModernizedCProgram.byte_swap_32(jks_sha1.getChecksum()[4]), ModernizedCProgram.byte_swap_32(jks_sha1.getIv()[0]), ModernizedCProgram.byte_swap_32(jks_sha1.getIv()[1]), ModernizedCProgram.byte_swap_32(jks_sha1.getIv()[2]), ModernizedCProgram.byte_swap_32(jks_sha1.getIv()[3]), ModernizedCProgram.byte_swap_32(jks_sha1.getIv()[4]), enc_key, der[0], der[6], der[7], der[8], der[9], der[10], der[11], der[12], der[13], der[14], der[15], der[16], der[17], der[18], der[19], (byte)jks_sha1.getAlias());
		return line_len;
		u32 digest = (u32)digest_buf;
		sha1_double_salt_t sha1_double_salt = (sha1_double_salt_t)esalt_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)sha1_double_salt.getSalt1_buf(), (int)sha1_double_salt.getSalt1_len(), out_buf + out_len);
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)sha1_double_salt.getSalt2_buf(), (int)sha1_double_salt.getSalt2_len(), out_buf + out_len);
		return out_len;
		krb5pa_17_t krb5pa = (krb5pa_17_t)esalt_buf;
		byte[] data = new byte[]{0};
		for (u32 i = 0;
		u32 j = 0;
		 i < krb5pa.getEnc_timestamp_len(); ) {
			u8 ptr_enc_timestamp = (u8)krb5pa.getEnc_timestamp();
			.sprintf(data + j, "%02x", ptr_enc_timestamp[i]);
		}
		int line_len = .snprintf(line_buf, line_size, "%s%s$%s$%s%08x%08x%08x", ModernizedCProgram.SIGNATURE_KRB5PA, (byte)krb5pa.getUser(), (byte)krb5pa.getDomain(), data, krb5pa.getChecksum()[0], krb5pa.getChecksum()[1], krb5pa.getChecksum()[2]);
		return line_len;
		u32 digest = (u32)digest_buf;
		int line_len = .snprintf(line_buf, line_size, "%08x%08x:%d:%d:%08x%08x%08x%08x", ModernizedCProgram.byte_swap_32(digest[0]), ModernizedCProgram.byte_swap_32(digest[1]), 2, 4, ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[2]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[3]));
		return line_len;
		u32 digest = (u32)digest_buf;
		netntlm_t netntlm = (netntlm_t)esalt_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[0] = ModernizedCProgram.rotl32(tmp[0], 29);
		tmp[1] = ModernizedCProgram.rotl32(tmp[1], 29);
		tmp[2] = ModernizedCProgram.rotl32(tmp[2], 29);
		tmp[3] = ModernizedCProgram.rotl32(tmp[3], 29);
		{ 
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 1;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 1;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 8;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 8;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 2;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 2;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 16;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 16;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 4;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 4;
				tmp[1] = tmp[1] ^ t;
			}
			;
		}
		;
		{ 
			{ 
				u32x t = new u32x();
				t = tmp[3] >> 1;
				t = t ^ tmp[2];
				t = t & -1024;
				tmp[2] = tmp[2] ^ t;
				t = t << 1;
				tmp[3] = tmp[3] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[2] >> 8;
				t = t ^ tmp[3];
				t = t & -1024;
				tmp[3] = tmp[3] ^ t;
				t = t << 8;
				tmp[2] = tmp[2] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[3] >> 2;
				t = t ^ tmp[2];
				t = t & -1024;
				tmp[2] = tmp[2] ^ t;
				t = t << 2;
				tmp[3] = tmp[3] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[2] >> 16;
				t = t ^ tmp[3];
				t = t & -1024;
				tmp[3] = tmp[3] ^ t;
				t = t << 16;
				tmp[2] = tmp[2] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[3] >> 4;
				t = t ^ tmp[2];
				t = t & -1024;
				tmp[2] = tmp[2] ^ t;
				t = t << 4;
				tmp[3] = tmp[3] ^ t;
			}
			;
		}
		;
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		u8 ptr = new u8();
		ptr = (u8)netntlm.getUserdomain_buf();
		for (int i = 0;
		 i < netntlm.getUser_len(); i += 2) {
			out_buf[out_len++] = ptr[i];
		}
		out_buf[out_len++] = (byte)':';
		out_buf[out_len++] = (byte)':';
		ptr += netntlm.getUser_len();
		for (int i = 0;
		 i < netntlm.getDomain_len(); i += 2) {
			out_buf[out_len++] = ptr[i];
		}
		out_buf[out_len++] = (byte)':';
		ptr = (u8)netntlm.getChall_buf();
		for (int i = 0;
		 i < netntlm.getSrvchall_len(); i++) {
			ModernizedCProgram.u8_to_hex(ptr[i], out_buf + out_len);
			out_len += 2;
		}
		out_buf[out_len++] = (byte)':';
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(salt.getSalt_buf_pc()[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(salt.getSalt_buf_pc()[1], out_buf + out_len);
		out_len += 8;
		out_buf[out_len++] = (byte)':';
		ptr += netntlm.getSrvchall_len();
		for (int i = 0;
		 i < netntlm.getClichall_len(); i++) {
			ModernizedCProgram.u8_to_hex(ptr[i], out_buf + out_len);
			out_len += 2;
		}
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + 56);
		int out_len = 64;
		return out_len;
		jwt_t jwt = (jwt_t)esalt_buf;
		u32 digest32 = (u32)digest_buf;
		u64 digest64 = (u64)digest_buf;
		byte[] tmp_buf = new byte[]{0};
		byte[] ptr_plain = new byte[128];
		if (hashconfig.getKern_type() == kern_type_jwt.KERN_TYPE_JWT_HS256) {
			u32[] tmp = new u32();
			tmp[0] = ModernizedCProgram.byte_swap_32(digest32[0]);
			tmp[1] = ModernizedCProgram.byte_swap_32(digest32[1]);
			tmp[2] = ModernizedCProgram.byte_swap_32(digest32[2]);
			tmp[3] = ModernizedCProgram.byte_swap_32(digest32[3]);
			tmp[4] = ModernizedCProgram.byte_swap_32(digest32[4]);
			tmp[5] = ModernizedCProgram.byte_swap_32(digest32[5]);
			tmp[6] = ModernizedCProgram.byte_swap_32(digest32[6]);
			tmp[7] = ModernizedCProgram.byte_swap_32(digest32[7]);
			.memcpy(tmp_buf, tmp, 32);
			ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64url, (u8)tmp_buf, 32, (u8)ptr_plain);
			ptr_plain[43] = 0;
		}  else if (hashconfig.getKern_type() == kern_type_jwt.KERN_TYPE_JWT_HS384) {
			u64[] tmp = new u64();
			tmp[0] = ModernizedCProgram.byte_swap_64(digest64[0]);
			tmp[1] = ModernizedCProgram.byte_swap_64(digest64[1]);
			tmp[2] = ModernizedCProgram.byte_swap_64(digest64[2]);
			tmp[3] = ModernizedCProgram.byte_swap_64(digest64[3]);
			tmp[4] = ModernizedCProgram.byte_swap_64(digest64[4]);
			tmp[5] = ModernizedCProgram.byte_swap_64(digest64[5]);
			.memcpy(tmp_buf, tmp, 48);
			ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64url, (u8)tmp_buf, 48, (u8)ptr_plain);
			ptr_plain[64] = 0;
		}  else if (hashconfig.getKern_type() == kern_type_jwt.KERN_TYPE_JWT_HS512) {
			u64[] tmp = new u64();
			tmp[0] = ModernizedCProgram.byte_swap_64(digest64[0]);
			tmp[1] = ModernizedCProgram.byte_swap_64(digest64[1]);
			tmp[2] = ModernizedCProgram.byte_swap_64(digest64[2]);
			tmp[3] = ModernizedCProgram.byte_swap_64(digest64[3]);
			tmp[4] = ModernizedCProgram.byte_swap_64(digest64[4]);
			tmp[5] = ModernizedCProgram.byte_swap_64(digest64[5]);
			tmp[6] = ModernizedCProgram.byte_swap_64(digest64[6]);
			tmp[7] = ModernizedCProgram.byte_swap_64(digest64[7]);
			.memcpy(tmp_buf, tmp, 64);
			ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64url, (u8)tmp_buf, 64, (u8)ptr_plain);
			ptr_plain[86] = 0;
		} 
		int line_len = .snprintf(line_buf, line_size, "%s.%s", (byte)jwt.getSalt_buf(), (byte)ptr_plain);
		return line_len;
		byte[] buf = new byte[]{0};
		.memcpy(buf + 0, salt.getSalt_buf(), 5);
		.memcpy(buf + 5, digest_buf, 9);
		buf[3] -= -4;
		byte[] tmp_buf = new byte[20];
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_lotus64, (u8)buf, 14, (u8)tmp_buf);
		tmp_buf[18] = salt.getSalt_buf_pc()[7];
		tmp_buf[19] = 0;
		int line_len = .snprintf(line_buf, line_size, "(G%s)", tmp_buf);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		pdf_t pdf = (pdf_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "$pdf$%d*%d*%d*%d*%d*%d*%08x%08x%08x%08x*%d*%08x%08x%08x%08x%08x%08x%08x%08x*%d*%08x%08x%08x%08x%08x%08x%08x%08x", pdf.getV(), pdf.getR(), 40, pdf.getP(), pdf.getEnc_md(), pdf.getId_len(), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[3]), pdf.getU_len(), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[3]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[4]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[5]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[6]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[7]), pdf.getO_len(), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[3]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[4]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[5]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[6]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[7]));
		return line_len;
		u64 digest = (u64)digest_buf;
		int line_len = 0;
		int iter = salt.getSalt_iter();
		if (iter == ModernizedCProgram.ROUNDS_QNX) {
			line_buf[line_len++] = (byte)'@';
			line_buf[line_len++] = (byte)'S';
			line_buf[line_len++] = (byte)'@';
		} else {
				line_buf[line_len++] = (byte)'@';
				line_buf[line_len++] = (byte)'S';
				line_buf[line_len++] = (byte)',';
				line_len += .snprintf(line_buf + line_len, line_size - line_len, "%d", iter);
				line_buf[line_len++] = (byte)'@';
		} 
		ModernizedCProgram.u64_to_hex(digest[0], (u8)line_buf + line_len);
		line_len += 16;
		ModernizedCProgram.u64_to_hex(digest[1], (u8)line_buf + line_len);
		line_len += 16;
		ModernizedCProgram.u64_to_hex(digest[2], (u8)line_buf + line_len);
		line_len += 16;
		ModernizedCProgram.u64_to_hex(digest[3], (u8)line_buf + line_len);
		line_len += 16;
		ModernizedCProgram.u64_to_hex(digest[4], (u8)line_buf + line_len);
		line_len += 16;
		ModernizedCProgram.u64_to_hex(digest[5], (u8)line_buf + line_len);
		line_len += 16;
		ModernizedCProgram.u64_to_hex(digest[6], (u8)line_buf + line_len);
		line_len += 16;
		ModernizedCProgram.u64_to_hex(digest[7], (u8)line_buf + line_len);
		line_len += 16;
		line_buf[line_len++] = (byte)'@';
		.memcpy(line_buf + line_len, salt.getSalt_buf(), salt.getSalt_len());
		line_len += salt.getSalt_len();
		line_buf[line_len] = 0;
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		return out_len;
		u8[] tmp = new u8[]{0};
		ModernizedCProgram.sha512crypt_encode(digest_buf, tmp);
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = 0;
		if (salt.getSalt_iter() == ModernizedCProgram.ROUNDS_SHA512CRYPT) {
			line_len = .snprintf(line_buf, line_size, "$6$%s$%s", tmp_salt, tmp);
		} else {
				line_len = .snprintf(line_buf, line_size, "$6$rounds=%u$%s$%s", salt.getSalt_iter(), tmp_salt, tmp);
		} 
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		return .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		u32 digest = (u32)digest_buf;
		netntlm_t netntlm = (netntlm_t)esalt_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		u8 ptr = new u8();
		ptr = (u8)netntlm.getUserdomain_buf();
		for (int i = 0;
		 i < netntlm.getUser_len(); i += 2) {
			out_buf[out_len++] = ptr[i];
		}
		out_buf[out_len++] = (byte)':';
		out_buf[out_len++] = (byte)':';
		ptr += netntlm.getUser_len();
		for (int i = 0;
		 i < netntlm.getDomain_len(); i += 2) {
			out_buf[out_len++] = ptr[i];
		}
		out_buf[out_len++] = (byte)':';
		ptr = (u8)netntlm.getChall_buf();
		for (int i = 0;
		 i < netntlm.getSrvchall_len(); i++) {
			ModernizedCProgram.u8_to_hex(ptr[i], out_buf + out_len);
			out_len += 2;
		}
		out_buf[out_len++] = (byte)':';
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len++] = (byte)':';
		ptr += netntlm.getSrvchall_len();
		for (int i = 0;
		 i < netntlm.getClichall_len(); i++) {
			ModernizedCProgram.u8_to_hex(ptr[i], out_buf + out_len);
			out_len += 2;
		}
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u64 digest = (u64)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[6], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[7], out_buf + out_len);
		out_len += 16;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		u32 tmp = ModernizedCProgram.byte_swap_32(digest[0]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp, out_buf);
		int out_len = 8;
		return out_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s%08x%08x%08x%08x%08x%08x%08x%08x", tmp_salt, tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7]);
		return line_len;
		pdf_t pdf = (pdf_t)esalt_buf;
		int line_len = 0;
		if (pdf.getId_len() == 32) {
			line_len = .snprintf(line_buf, line_size, "$pdf$%d*%d*%d*%d*%d*%d*%08x%08x%08x%08x%08x%08x%08x%08x*%d*%08x%08x%08x%08x%08x%08x%08x%08x*%d*%08x%08x%08x%08x%08x%08x%08x%08x", pdf.getV(), pdf.getR(), 128, pdf.getP(), pdf.getEnc_md(), pdf.getId_len(), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[3]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[4]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[5]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[6]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[7]), pdf.getU_len(), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[3]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[4]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[5]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[6]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[7]), pdf.getO_len(), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[3]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[4]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[5]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[6]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[7]));
		} else {
				line_len = .snprintf(line_buf, line_size, "$pdf$%d*%d*%d*%d*%d*%d*%08x%08x%08x%08x*%d*%08x%08x%08x%08x%08x%08x%08x%08x*%d*%08x%08x%08x%08x%08x%08x%08x%08x", pdf.getV(), pdf.getR(), 128, pdf.getP(), pdf.getEnc_md(), pdf.getId_len(), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getId_buf()[3]), pdf.getU_len(), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[3]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[4]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[5]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[6]), ModernizedCProgram.byte_swap_32(pdf.getU_buf()[7]), pdf.getO_len(), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[0]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[1]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[2]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[3]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[4]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[5]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[6]), ModernizedCProgram.byte_swap_32(pdf.getO_buf()[7]));
		} 
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		return .snprintf(line_buf, line_size, "%s", hash_info.getOrighash());
		u32 digest = (u32)digest_buf;
		cram_md5_t cram_md5 = (cram_md5_t)esalt_buf;
		// challenge
		byte[] chal_buf = new byte[256 * 2];
		int chal_len = ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)salt.getSalt_buf(), salt.getSalt_len(), (u8)chal_buf);
		chal_buf[chal_len] = 0// response;// response
		byte[] tmp_buf = new byte[256 * 2];
		int tmp_len = .snprintf(tmp_buf, , "%s %08x%08x%08x%08x", (byte)cram_md5.getUser(), ModernizedCProgram.byte_swap_32(digest[0]), ModernizedCProgram.byte_swap_32(digest[1]), ModernizedCProgram.byte_swap_32(digest[2]), ModernizedCProgram.byte_swap_32(digest[3]));
		tmp_buf[tmp_len] = 0;
		byte[] resp_buf = new byte[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp_buf, tmp_len, (u8)resp_buf);
		int line_len = .snprintf(line_buf, line_size, "%s%s$%s", ModernizedCProgram.SIGNATURE_CRAM_MD5, chal_buf, resp_buf);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8[] ptr_plain = new u8[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp, 20, (u8)ptr_plain);
		int out_len = .snprintf(line_buf, line_size, "{SHA}%s", (byte)ptr_plain);
		return out_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len() - .strlen(ModernizedCProgram.skyper), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int out_len = .snprintf(line_buf, line_size, "%08x%08x%08x%08x:%s", ModernizedCProgram.byte_swap_32(tmp[0]), ModernizedCProgram.byte_swap_32(tmp[1]), ModernizedCProgram.byte_swap_32(tmp[2]), ModernizedCProgram.byte_swap_32(tmp[3]), tmp_salt);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + 56);
		int out_len = 64;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		oldoffice01_t oldoffice01 = (oldoffice01_t)esalt_buf;
		int line_len = .snprintf(line_buf, line_size, "%s%u*%08x%08x%08x%08x*%08x%08x%08x%08x*%08x%08x%08x%08x", ModernizedCProgram.SIGNATURE_OLDOFFICE, oldoffice01.getVersion(), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[2]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[3]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[0]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[1]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[2]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[3]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[0]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[1]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[2]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[3]));
		return line_len;
		u64 digest = (u64)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_64_constants.SHA512M_A;
			tmp[1] += sha2_64_constants.SHA512M_B;
			tmp[2] += sha2_64_constants.SHA512M_C;
			tmp[3] += sha2_64_constants.SHA512M_D;
			tmp[4] += sha2_64_constants.SHA512M_E;
			tmp[5] += sha2_64_constants.SHA512M_F;
			tmp[6] += sha2_64_constants.SHA512M_G;
			tmp[7] += sha2_64_constants.SHA512M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[6], out_buf + out_len);
		out_len += 16;
		ModernizedCProgram.u64_to_hex(tmp[7], out_buf + out_len);
		out_len += 16;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "0x0100%s%08x%08x%08x%08x%08x", tmp_salt, tmp[0], tmp[1], tmp[2], tmp[3], tmp[4]);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 chap_id_byte = (u8)salt.getSalt_buf()[4];
		int line_len = .snprintf(line_buf, line_size, "%08x%08x%08x%08x:%08x%08x%08x%08x:%02x", ModernizedCProgram.byte_swap_32(tmp[0]), ModernizedCProgram.byte_swap_32(tmp[1]), ModernizedCProgram.byte_swap_32(tmp[2]), ModernizedCProgram.byte_swap_32(tmp[3]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[2]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[3]), chap_id_byte);
		return line_len;
		dpapimk_t dpapimk = (dpapimk_t)esalt_buf;
		u32 version = 1;
		u32 context = dpapimk.getContext();
		u32 rounds = salt.getSalt_iter() + 1;
		u32 contents_len = dpapimk.getContents_len();
		u32 SID_len = dpapimk.getSID_len();
		u32 iv_len = 32;
		u8[] cipher_algorithm = new u8[]{0};
		u8[] hash_algorithm = new u8[]{0};
		u8[] SID = new u8[]{0};
		u8 SID_tmp = new u8();
		u32 ptr_SID = (u32)dpapimk.getSID();
		u32 ptr_iv = (u32)dpapimk.getIv();
		u32 ptr_contents = (u32)dpapimk.getContents();
		u32[] u32_iv = new u32();
		u8[] iv = new u8();
		// convert back SID
		SID_tmp = (u8)ModernizedCProgram.hcmalloc((SID_len + 1) * );
		for (u32 i = 0;
		 i < (SID_len / 4) + 1; i++) {
			u8[] hex = new u8[]{0};
			ModernizedCProgram.u32_to_hex(ModernizedCProgram.byte_swap_32(ptr_SID[i]), hex);
			for (u32 j = 0;
			u32 k = 0;
			 j < 8; ) {
				SID_tmp[i * 4 + k] = ModernizedCProgram.hex_to_u8(hex[j]);
			}
		}
		// overwrite trailing 0x80// overwrite trailing 0x80SID_tmp[SID_len] = 0;
		for (u32 i = 0;
		u32 j = 0;
		 j < SID_len; ) {
			SID[i] = SID_tmp[j];
		}
		ModernizedCProgram.hcfree(SID_tmp);
		for (u32 i = 0;
		 i < iv_len / 8; i++) {
			u32_iv[i] = ModernizedCProgram.byte_swap_32(ptr_iv[i]);
			ModernizedCProgram.u32_to_hex(u32_iv[i], iv + i * 8);
		}
		iv[32] = 0;
		u32[] u32_contents = new u32();
		u8[] contents = new u8();
		for (u32 i = 0;
		 i < contents_len / 8; i++) {
			u32_contents[i] = ModernizedCProgram.byte_swap_32(ptr_contents[i]);
			ModernizedCProgram.u32_to_hex(u32_contents[i], contents + i * 8);
		}
		contents[208] = 0;
		if (contents_len == 208) {
			.memcpy(cipher_algorithm, "des3", .strlen("des3"));
			.memcpy(hash_algorithm, "sha1", .strlen("sha1"));
		} 
		int line_len = .snprintf(line_buf, line_size, "%s%u*%u*%s*%s*%s*%u*%s*%u*%s", ModernizedCProgram.SIGNATURE_DPAPIMK, version, context, SID, cipher_algorithm, hash_algorithm, rounds, iv, contents_len, contents);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_32_constants.SHA256M_A;
			tmp[1] += sha2_32_constants.SHA256M_B;
			tmp[2] += sha2_32_constants.SHA256M_C;
			tmp[3] += sha2_32_constants.SHA256M_D;
			tmp[4] += sha2_32_constants.SHA256M_E;
			tmp[5] += sha2_32_constants.SHA256M_F;
			tmp[6] += sha2_32_constants.SHA256M_G;
			tmp[7] += sha2_32_constants.SHA256M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		byte[] tmp_buf = new byte[512];
		.memcpy(tmp_buf, tmp, 32);
		.memcpy(tmp_buf + 32, salt.getSalt_buf(), salt.getSalt_len());
		byte[] ptr_plain = new byte[]{0};
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, (u8)tmp_buf, 32 + salt.getSalt_len(), (u8)ptr_plain);
		int line_len = .snprintf(line_buf, line_size, "%s%s", ModernizedCProgram.SIGNATURE_SHA256B64S, ptr_plain);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = 0;
		tmp[3] = 0;
		{ 
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 1;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 1;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 8;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 8;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 2;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 2;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 16;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 16;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 4;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 4;
				tmp[1] = tmp[1] ^ t;
			}
			;
		}
		;
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0] + salt.getSalt_buf_pc()[0];
		tmp[1] = digest[1] + salt.getSalt_buf_pc()[1];
		tmp[2] = digest[2] + salt.getSalt_buf_pc()[2];
		tmp[3] = digest[3] + salt.getSalt_buf_pc()[3];
		tmp[4] = digest[4] + salt.getSalt_buf_pc()[4];
		tmp[5] = digest[5] + salt.getSalt_buf_pc()[5];
		tmp[6] = digest[6] + salt.getSalt_buf_pc()[6];
		tmp[7] = digest[7] + salt.getSalt_buf_pc()[7];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_32(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_32(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_32(tmp[7]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[7], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u64 digest = (u64)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		tmp[7] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha2_64_constants.SHA512M_A;
			tmp[1] += sha2_64_constants.SHA512M_B;
			tmp[2] += sha2_64_constants.SHA512M_C;
			tmp[3] += sha2_64_constants.SHA512M_D;
			tmp[4] += sha2_64_constants.SHA512M_E;
			tmp[5] += sha2_64_constants.SHA512M_F;
			tmp[6] += sha2_64_constants.SHA512M_G;
			tmp[7] += sha2_64_constants.SHA512M_H;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_64(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_64(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_64(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_64(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_64(tmp[4]);
		tmp[5] = ModernizedCProgram.byte_swap_64(tmp[5]);
		tmp[6] = ModernizedCProgram.byte_swap_64(tmp[6]);
		tmp[7] = ModernizedCProgram.byte_swap_64(tmp[7]);
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + 16);
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + 32);
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + 48);
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + 64);
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + 80);
		ModernizedCProgram.u64_to_hex(tmp[6], out_buf + 96);
		ModernizedCProgram.u64_to_hex(tmp[7], out_buf + 112);
		int out_len = 128;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = 0;
		tmp[3] = 0;
		{ 
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 1;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 1;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 8;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 8;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 2;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 2;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 16;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 16;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 4;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 4;
				tmp[1] = tmp[1] ^ t;
			}
			;
		}
		;
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len++;
		ModernizedCProgram.u32_to_hex(salt.getSalt_buf()[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(salt.getSalt_buf()[1], out_buf + out_len);
		out_len += 8;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[4];
		tmp[1] = digest[5];
		tmp[2] = digest[6];
		tmp[3] = digest[7];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		out_buf[0] = ModernizedCProgram.int_to_itoa64((tmp[0] >> 0) & -1024);
		out_buf[1] = ModernizedCProgram.int_to_itoa64((tmp[0] >> 6) & -1024);
		out_buf[2] = ModernizedCProgram.int_to_itoa64((tmp[0] >> 12) & -1024);
		out_buf[3] = ModernizedCProgram.int_to_itoa64((tmp[0] >> 18) & -1024);
		out_buf[4] = ModernizedCProgram.int_to_itoa64((tmp[1] >> 0) & -1024);
		out_buf[5] = ModernizedCProgram.int_to_itoa64((tmp[1] >> 6) & -1024);
		out_buf[6] = ModernizedCProgram.int_to_itoa64((tmp[1] >> 12) & -1024);
		out_buf[7] = ModernizedCProgram.int_to_itoa64((tmp[1] >> 18) & -1024);
		out_buf[8] = ModernizedCProgram.int_to_itoa64((tmp[2] >> 0) & -1024);
		out_buf[9] = ModernizedCProgram.int_to_itoa64((tmp[2] >> 6) & -1024);
		out_buf[10] = ModernizedCProgram.int_to_itoa64((tmp[2] >> 12) & -1024);
		out_buf[11] = ModernizedCProgram.int_to_itoa64((tmp[2] >> 18) & -1024);
		out_buf[12] = ModernizedCProgram.int_to_itoa64((tmp[3] >> 0) & -1024);
		out_buf[13] = ModernizedCProgram.int_to_itoa64((tmp[3] >> 6) & -1024);
		out_buf[14] = ModernizedCProgram.int_to_itoa64((tmp[3] >> 12) & -1024);
		out_buf[15] = ModernizedCProgram.int_to_itoa64((tmp[3] >> 18) & -1024);
		int out_len = 16;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md4_constants.MD4M_A;
			tmp[1] += md4_constants.MD4M_B;
			tmp[2] += md4_constants.MD4M_C;
			tmp[3] += md4_constants.MD4M_D;
		} 
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		int out_len = 32;
		return out_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		int line_len = .snprintf(line_buf, line_size, "%s0$1$%08x%08x$%08x%08x", ModernizedCProgram.SIGNATURE_ECRYPTFS, salt.getSalt_buf()[0], salt.getSalt_buf()[1], digest[0], digest[1]);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		tmp[6] = digest[6];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + 8);
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + 16);
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + 24);
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + 32);
		ModernizedCProgram.u32_to_hex(tmp[5], out_buf + 40);
		ModernizedCProgram.u32_to_hex(tmp[6], out_buf + 48);
		int out_len = 56;
		return out_len;
		u32 digest = (u32)digest_buf;
		// salt_buf[1] holds our 32 bit value. salt_buf[0] and salt_buf[1] would be 64 bits.// we also need to multiply salt by our step to see the floor of our original timestamp range.
		// again, we will use the default RFC 6238 step of 30.u64 tmp_salt_buf = (((u64)(salt.getSalt_buf()[2])) << 32) | ((u64)(salt.getSalt_buf()[3]));
		int line_len = .snprintf(line_buf, line_size, "%06d:%I64u", digest[0], tmp_salt_buf);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u64 digest = (u64)digest_buf;
		u64[] tmp = new u64();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[5] = digest[5];
		u8 out_buf = (u8)line_buf;
		ModernizedCProgram.u64_to_hex(tmp[0], out_buf + 0);
		ModernizedCProgram.u64_to_hex(tmp[1], out_buf + 16);
		ModernizedCProgram.u64_to_hex(tmp[2], out_buf + 32);
		ModernizedCProgram.u64_to_hex(tmp[3], out_buf + 48);
		ModernizedCProgram.u64_to_hex(tmp[4], out_buf + 64);
		ModernizedCProgram.u64_to_hex(tmp[5], out_buf + 80);
		int out_len = 96;
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += sha1_constants.SHA1M_A;
			tmp[1] += sha1_constants.SHA1M_B;
			tmp[2] += sha1_constants.SHA1M_C;
			tmp[3] += sha1_constants.SHA1M_D;
			tmp[4] += sha1_constants.SHA1M_E;
		} 
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		tmp[4] = digest[4];
		tmp[0] = ModernizedCProgram.byte_swap_32(tmp[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(tmp[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(tmp[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(tmp[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(tmp[4]);
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[4], out_buf + out_len);
		out_len += 8;
		out_buf[out_len] = hashconfig.getSeparator();
		out_len += 1;
		out_len += ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), out_buf + out_len);
		return out_len;
		dpapimk_t dpapimk = (dpapimk_t)esalt_buf;
		u32 version = 2;
		u32 context = dpapimk.getContext();
		u32 rounds = salt.getSalt_iter() + 1;
		u32 contents_len = dpapimk.getContents_len();
		u32 SID_len = dpapimk.getSID_len();
		u32 iv_len = 32;
		u8[] cipher_algorithm = new u8[]{0};
		u8[] hash_algorithm = new u8[]{0};
		u8[] SID = new u8[]{0};
		u8 SID_tmp = new u8();
		u32 ptr_SID = (u32)dpapimk.getSID();
		u32 ptr_iv = (u32)dpapimk.getIv();
		u32 ptr_contents = (u32)dpapimk.getContents();
		u32[] u32_iv = new u32();
		u8[] iv = new u8();
		// convert back SID
		SID_tmp = (u8)ModernizedCProgram.hcmalloc((SID_len + 1) * );
		for (u32 i = 0;
		 i < (SID_len / 4) + 1; i++) {
			u8[] hex = new u8[]{0};
			ModernizedCProgram.u32_to_hex(ModernizedCProgram.byte_swap_32(ptr_SID[i]), hex);
			for (u32 j = 0;
			u32 k = 0;
			 j < 8; ) {
				SID_tmp[i * 4 + k] = ModernizedCProgram.hex_to_u8(hex[j]);
			}
		}
		// overwrite trailing 0x80// overwrite trailing 0x80SID_tmp[SID_len] = 0;
		for (u32 i = 0;
		u32 j = 0;
		 j < SID_len; ) {
			SID[i] = SID_tmp[j];
		}
		ModernizedCProgram.hcfree(SID_tmp);
		for (u32 i = 0;
		 i < iv_len / 8; i++) {
			u32_iv[i] = ModernizedCProgram.byte_swap_32(ptr_iv[i]);
			ModernizedCProgram.u32_to_hex(u32_iv[i], iv + i * 8);
		}
		iv[32] = 0;
		u32[] u32_contents = new u32();
		u8[] contents = new u8();
		for (u32 i = 0;
		 i < contents_len / 8; i++) {
			u32_contents[i] = ModernizedCProgram.byte_swap_32(ptr_contents[i]);
			ModernizedCProgram.u32_to_hex(u32_contents[i], contents + i * 8);
		}
		contents[288] = 0;
		if (contents_len == 288) {
			.memcpy(cipher_algorithm, "aes256", .strlen("aes256"));
			.memcpy(hash_algorithm, "sha512", .strlen("sha512"));
		} 
		int line_len = .snprintf(line_buf, line_size, "%s%u*%u*%s*%s*%s*%u*%s*%u*%s", ModernizedCProgram.SIGNATURE_DPAPIMK, version, context, SID, cipher_algorithm, hash_algorithm, rounds, iv, contents_len, contents);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = ModernizedCProgram.byte_swap_32(digest[0]);
		tmp[1] = ModernizedCProgram.byte_swap_32(digest[1]);
		tmp[2] = ModernizedCProgram.byte_swap_32(digest[2]);
		tmp[3] = ModernizedCProgram.byte_swap_32(digest[3]);
		tmp[4] = ModernizedCProgram.byte_swap_32(digest[4]);
		byte[] digest_buf_c = new byte[34];
		ModernizedCProgram.base32_encode(ModernizedCProgram.int_to_itoa32, (u8)tmp, 20, (u8)digest_buf_c);
		digest_buf_c[32] = 0// domain;// domain
		u32 salt_pc_len = salt.getSalt_len_pc();
		byte[] domain_buf_c = new byte[]{0};
		.memcpy(domain_buf_c, (byte)salt.getSalt_buf_pc(), salt_pc_len);
		for (u32 i = 0;
		 i < salt_pc_len; i++) {
			byte next = domain_buf_c[i];
			domain_buf_c[i] = (byte)'.';
			i += next;
		}
		domain_buf_c[salt_pc_len] = 0// final;// final
		byte[] tmp_salt = new byte[256 * 2];
		int salt_len = ModernizedCProgram.generic_salt_encode(hashconfig, (u8)salt.getSalt_buf(), (int)salt.getSalt_len(), (u8)tmp_salt);
		tmp_salt[salt_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s:%s:%s:%u", digest_buf_c, domain_buf_c, tmp_salt, salt.getSalt_iter());
		return line_len;
		oldoffice01_t oldoffice01 = (oldoffice01_t)esalt_buf;
		u8 rc4key = (u8)oldoffice01.getRc4key();
		int line_len = .snprintf(line_buf, line_size, "%s%u*%08x%08x%08x%08x*%08x%08x%08x%08x*%08x%08x%08x%08x:%02x%02x%02x%02x%02x", ModernizedCProgram.SIGNATURE_OLDOFFICE, oldoffice01.getVersion(), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[0]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[1]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[2]), ModernizedCProgram.byte_swap_32(salt.getSalt_buf()[3]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[0]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[1]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[2]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifier()[3]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[0]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[1]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[2]), ModernizedCProgram.byte_swap_32(oldoffice01.getEncryptedVerifierHash()[3]), rc4key[0], rc4key[1], rc4key[2], rc4key[3], rc4key[4]);
		return line_len;
		u32 digest = (u32)digest_buf;
		u32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		{ 
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 1;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 1;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 8;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 8;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 2;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 2;
				tmp[1] = tmp[1] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[0] >> 16;
				t = t ^ tmp[1];
				t = t & -1024;
				tmp[1] = tmp[1] ^ t;
				t = t << 16;
				tmp[0] = tmp[0] ^ t;
			}
			;
			{ 
				u32x t = new u32x();
				t = tmp[1] >> 4;
				t = t ^ tmp[0];
				t = t & -1024;
				tmp[0] = tmp[0] ^ t;
				t = t << 4;
				tmp[1] = tmp[1] ^ t;
			}
			;
		}
		;
		byte[] ptr_plain = new byte[32];
		ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_itoa64, (u8)tmp, 8, (u8)ptr_plain);
		ptr_plain[11] = 0;
		int line_len = .snprintf(line_buf, line_size, "%s", ptr_plain + 1);
		return line_len;
		u32 digest = (u32)digest_buf;
		// we can not change anything in the original buffer, otherwise destroying sorting
		// therefore create some local bufferu32[] tmp = new u32();
		tmp[0] = digest[0];
		tmp[1] = digest[1];
		tmp[2] = digest[2];
		tmp[3] = digest[3];
		if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			tmp[0] += md5_constants.MD5M_A;
			tmp[1] += md5_constants.MD5M_B;
			tmp[2] += md5_constants.MD5M_C;
			tmp[3] += md5_constants.MD5M_D;
		} 
		u8 out_buf = (u8)line_buf;
		int out_len = 0;
		ModernizedCProgram.u32_to_hex(tmp[0], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[1], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[2], out_buf + out_len);
		out_len += 8;
		ModernizedCProgram.u32_to_hex(tmp[3], out_buf + out_len);
		out_len += 8;
		return out_len;
	}
	public static Object module_esalt_size(Object hashconfig, Object user_options, Object user_options_extra) {
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
		u64 esalt_size = (u64);
		return esalt_size;
	}
	public static Object module_tmp_size(Object hashconfig, Object user_options, Object user_options_extra) {
		u64 tmp_size = (u64);
		return tmp_size;
		u64 pw_max = (u64);
		return pw_max;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		// we'll add some lateru64 tmp_size = 0;
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		// we'll add some lateru64 tmp_size = 0;
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		// we'll add some lateru64 tmp_size = 0;
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
		u64 tmp_size = (u64);
		return tmp_size;
	}
	public static int module_build_plain_postprocess(Object hashconfig, Object hashes, Object tmps, Object src_buf, Object src_sz, Object src_len, Object dst_buf, Object dst_sz) {
		vc64_tmp_t vc64_tmp = (vc64_tmp_t)tmps;
		if (vc64_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc64_tmp.getPim() - 15);
		} 
		tc_t tc = (tc_t)hashes.getEsalts_buf();
		if (src_len < (int)dst_sz) {
			.memcpy(dst_buf, src_buf, src_len);
		} 
		return ModernizedCProgram.execute_keyboard_layout_mapping(dst_buf, src_len, tc.getKeyboard_layout_mapping_buf(), tc.getKeyboard_layout_mapping_cnt());
		vc_t vc = (vc_t)hashes.getEsalts_buf();
		u32[] tmp_buf = new u32[]{0};
		.memcpy(tmp_buf, src_buf, src_len);
		ModernizedCProgram.execute_keyboard_layout_mapping(tmp_buf, src_len, vc.getKeyboard_layout_mapping_buf(), vc.getKeyboard_layout_mapping_cnt());
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)tmp_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)tmp_buf, vc_tmp.getPim());
		} 
		vc64_tmp_t vc64_tmp = (vc64_tmp_t)tmps;
		if (vc64_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc64_tmp.getPim() - 15);
		} 
		vc64_sbog_tmp_t vc64_sbog_tmp = (vc64_sbog_tmp_t)tmps;
		if (vc64_sbog_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc64_sbog_tmp.getPim() - 15);
		} 
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc_tmp.getPim() - 15);
		} 
		u8 ptr_src = (u8)src_buf;
		u8 ptr_dst = (u8)dst_buf;
		for (int i = 0;
		 i < src_len; i++) {
			byte v = ptr_src[i];
			if (v & -1024) {
				byte v2 = v & -1024;
				if (v2 >= -1024) {
					ptr_dst[i] = v2;
				} else {
						ptr_dst[i] = v;
				} 
			} else {
					ptr_dst[i] = v;
			} 
		}
		return src_len;
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc_tmp.getPim() - 15);
		} 
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc_tmp.getPim() - 15);
		} 
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc_tmp.getPim() - 15);
		} 
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc_tmp.getPim() - 15);
		} 
		vc64_sbog_tmp_t vc64_sbog_tmp = (vc64_sbog_tmp_t)tmps;
		if (vc64_sbog_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc64_sbog_tmp.getPim() - 15);
		} 
		tc_t tc = (tc_t)hashes.getEsalts_buf();
		if (src_len < (int)dst_sz) {
			.memcpy(dst_buf, src_buf, src_len);
		} 
		return ModernizedCProgram.execute_keyboard_layout_mapping(dst_buf, src_len, tc.getKeyboard_layout_mapping_buf(), tc.getKeyboard_layout_mapping_cnt());
		pkzip_extra_t pkzip_extra = (pkzip_extra_t)tmps;
		if (pkzip_extra.getLen() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				byte dst_ptr = (byte)dst_buf;
				.memcpy(dst_ptr, pkzip_extra.getBuf(), pkzip_extra.getLen());
				return pkzip_extra.getLen() + .snprintf(dst_ptr + pkzip_extra.getLen(), dst_sz - pkzip_extra.getLen(), "%s", (byte)src_buf);
		} 
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc_tmp.getPim() - 15);
		} 
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc_tmp.getPim() - 15);
		} 
		vc64_sbog_tmp_t vc64_sbog_tmp = (vc64_sbog_tmp_t)tmps;
		if (vc64_sbog_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc64_sbog_tmp.getPim() - 15);
		} 
		vc64_tmp_t vc64_tmp = (vc64_tmp_t)tmps;
		if (vc64_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc64_tmp.getPim() - 15);
		} 
		vc_t vc = (vc_t)hashes.getEsalts_buf();
		u32[] tmp_buf = new u32[]{0};
		.memcpy(tmp_buf, src_buf, src_len);
		ModernizedCProgram.execute_keyboard_layout_mapping(tmp_buf, src_len, vc.getKeyboard_layout_mapping_buf(), vc.getKeyboard_layout_mapping_cnt());
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)tmp_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)tmp_buf, vc_tmp.getPim());
		} 
		vc_t vc = (vc_t)hashes.getEsalts_buf();
		u32[] tmp_buf = new u32[]{0};
		.memcpy(tmp_buf, src_buf, src_len);
		ModernizedCProgram.execute_keyboard_layout_mapping(tmp_buf, src_len, vc.getKeyboard_layout_mapping_buf(), vc.getKeyboard_layout_mapping_cnt());
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)tmp_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)tmp_buf, vc_tmp.getPim());
		} 
		vc_t vc = (vc_t)hashes.getEsalts_buf();
		u32[] tmp_buf = new u32[]{0};
		.memcpy(tmp_buf, src_buf, src_len);
		ModernizedCProgram.execute_keyboard_layout_mapping(tmp_buf, src_len, vc.getKeyboard_layout_mapping_buf(), vc.getKeyboard_layout_mapping_cnt());
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)tmp_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)tmp_buf, vc_tmp.getPim());
		} 
		vc_t vc = (vc_t)hashes.getEsalts_buf();
		u32[] tmp_buf = new u32[]{0};
		.memcpy(tmp_buf, src_buf, src_len);
		ModernizedCProgram.execute_keyboard_layout_mapping(tmp_buf, src_len, vc.getKeyboard_layout_mapping_buf(), vc.getKeyboard_layout_mapping_cnt());
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)tmp_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)tmp_buf, vc_tmp.getPim());
		} 
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc_tmp.getPim() - 15);
		} 
		vc_t vc = (vc_t)hashes.getEsalts_buf();
		u32[] tmp_buf = new u32[]{0};
		.memcpy(tmp_buf, src_buf, src_len);
		ModernizedCProgram.execute_keyboard_layout_mapping(tmp_buf, src_len, vc.getKeyboard_layout_mapping_buf(), vc.getKeyboard_layout_mapping_cnt());
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)tmp_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)tmp_buf, vc_tmp.getPim());
		} 
		return ModernizedCProgram.base32_encode(ModernizedCProgram.int_to_base32, (u8)src_buf, src_len, (u8)dst_buf);
		vc_tmp_t vc_tmp = (vc_tmp_t)tmps;
		if (vc_tmp.getPim() == 0) {
			return .snprintf((byte)dst_buf, dst_sz, "%s", (byte)src_buf);
		} else {
				return .snprintf((byte)dst_buf, dst_sz, "%s   (PIM=%d)", (byte)src_buf, vc_tmp.getPim() - 15);
		} 
		tc_t tc = (tc_t)hashes.getEsalts_buf();
		if (src_len < (int)dst_sz) {
			.memcpy(dst_buf, src_buf, src_len);
		} 
		return ModernizedCProgram.execute_keyboard_layout_mapping(dst_buf, src_len, tc.getKeyboard_layout_mapping_buf(), tc.getKeyboard_layout_mapping_cnt());
	}
	public static boolean module_potfile_disable(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
		boolean potfile_disable = true;
		return potfile_disable;
	}
	public static boolean module_outfile_check_disable(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
		boolean outfile_check_disable = true;
		return outfile_check_disable;
	}
	public static Object module_kernel_loops_max(Object hashconfig, Object user_options, Object user_options_extra) {
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		u32 kernel_loops_max = ModernizedCProgram.ROUNDS_RAR3 / 16;
		return kernel_loops_max;
		u32 kernel_loops_max = ModernizedCProgram.ROUNDS_ZIP2 - 1;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		u32 kernel_loops_max = 1;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		u32 kernel_loops_max = kernel_workload.KERNEL_LOOPS_MAX;
		if (user_options.getSlow_candidates() == 0) {
			if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
				kernel_loops_max = 1024;
			} 
		} 
		return kernel_loops_max;
		u32 kernel_loops_max = kernel_workload.KERNEL_LOOPS_MAX;
		if (user_options.getSlow_candidates() == 0) {
			if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
				kernel_loops_max = 1024;
			} 
		} 
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		u32 kernel_loops_max = 1;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		u32 kernel_loops_max = 1;
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
		u32 kernel_loops_max = kernel_workload.KERNEL_LOOPS_MAX;
		if (user_options.getSlow_candidates() == 0) {
			if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
				kernel_loops_max = 1024;
			} 
		} 
		return kernel_loops_max;
		u32 kernel_loops_max = kernel_workload.KERNEL_LOOPS_MAX;
		if (user_options.getSlow_candidates() == 0) {
			if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
				kernel_loops_max = 1024;
			} 
		} 
		return kernel_loops_max;
		// lowest PIM multiplieru32 kernel_loops_max = 1000;
		return kernel_loops_max;
	}
	public static Byte module_jit_build_options(Object hashconfig, Object user_options, Object user_options_extra, Object hashes, Object device_param) {
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		// this uses some nice feedback effect.// based on the device_local_mem_size the reqd_work_group_size in the kernel is set to some value
		// which is then is read from the opencl host in the kernel_preferred_wgs_multiple1/2/3 result.// therefore we do not need to set module_kernel_threads_min/max except for CPU, where the threads are set to fixed 1.u32 fixed_local_size = 0;
		if (device_param.getOpencl_device_type() & CL_DEVICE_TYPE_CPU) {
			fixed_local_size = 1;
		} else {
				u32 overhead = 0;
				if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
					if (device_param.getIs_opencl() == 1) {
						overhead = 4;
					} 
				} 
				if (user_options.getKernel_threads_chgd() == 1) {
					fixed_local_size = user_options.getKernel_threads();
					if ((fixed_local_size * 4096) > (device_param.getDevice_local_mem_size() - overhead)) {
						fixed_local_size = (device_param.getDevice_local_mem_size() - overhead) / 4096;
					} 
				} else {
						fixed_local_size = (device_param.getDevice_local_mem_size() - overhead) / 4096;
				} 
		} 
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D FIXED_LOCAL_SIZE=%u", fixed_local_size);
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		// this uses some nice feedback effect.// based on the device_local_mem_size the reqd_work_group_size in the kernel is set to some value
		// which is then is read from the opencl host in the kernel_preferred_wgs_multiple1/2/3 result.// therefore we do not need to set module_kernel_threads_min/max except for CPU, where the threads are set to fixed 1.u32 fixed_local_size = 0;
		if (device_param.getOpencl_device_type() & CL_DEVICE_TYPE_CPU) {
			fixed_local_size = 1;
		} else {
				u32 overhead = 0;
				if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
					if (device_param.getIs_opencl() == 1) {
						overhead = 4;
					} 
				} 
				if (user_options.getKernel_threads_chgd() == 1) {
					fixed_local_size = user_options.getKernel_threads();
					if ((fixed_local_size * 4096) > (device_param.getDevice_local_mem_size() - overhead)) {
						fixed_local_size = (device_param.getDevice_local_mem_size() - overhead) / 4096;
					} 
				} else {
						fixed_local_size = (device_param.getDevice_local_mem_size() - overhead) / 4096;
				} 
		} 
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D FIXED_LOCAL_SIZE=%u", fixed_local_size);
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		// -Wpass-failed=transform-warningif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 1)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		u32 scrypt_N = (hashes.getSalts_buf()[0].getScrypt_N()) ? hashes.getSalts_buf()[0].getScrypt_N() : 262144;
		u32 scrypt_r = (hashes.getSalts_buf()[0].getScrypt_r()) ? hashes.getSalts_buf()[0].getScrypt_r() : 8;
		u32 scrypt_p = (hashes.getSalts_buf()[0].getScrypt_p()) ? hashes.getSalts_buf()[0].getScrypt_p() : 1;
		u64 extra_buffer_size = device_param.getExtra_buffer_size();
		u64 kernel_power_max = (u64)(device_param.getDevice_processors() * hashconfig.getKernel_threads_max() * hashconfig.getKernel_accel_max());
		u64 size_scrypt = (u64)(128 * scrypt_r * scrypt_N);
		u64 scrypt_tmto_final = (kernel_power_max * size_scrypt) / extra_buffer_size;
		u64 tmp_size = (u64)(128 * scrypt_r * scrypt_p);
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-DSCRYPT_N=%u -DSCRYPT_R=%u -DSCRYPT_P=%u -DSCRYPT_TMTO=%I64u -DSCRYPT_TMP_ELEM=%I64u", hashes.getSalts_buf()[0].getScrypt_N(), hashes.getSalts_buf()[0].getScrypt_r(), hashes.getSalts_buf()[0].getScrypt_p(), scrypt_tmto_final, tmp_size / 16);
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		// -Wpass-failed=transform-warningif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 1)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if ((user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) && (hashes.getSalts_cnt() == 1) && (user_options.getSlow_candidates() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-DDESCRYPT_SALT=%u", hashes.getSalts_buf()[0].getSalt_buf()[0] & -1024);
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		// -Wpass-failed=transform-warningif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 1)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		// -Wpass-failed=transform-warningif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 1)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		u32 scrypt_N = (hashes.getSalts_buf()[0].getScrypt_N()) ? hashes.getSalts_buf()[0].getScrypt_N() : 1024;
		u32 scrypt_r = (hashes.getSalts_buf()[0].getScrypt_r()) ? hashes.getSalts_buf()[0].getScrypt_r() : 1;
		u32 scrypt_p = (hashes.getSalts_buf()[0].getScrypt_p()) ? hashes.getSalts_buf()[0].getScrypt_p() : 1;
		u64 extra_buffer_size = device_param.getExtra_buffer_size();
		u64 kernel_power_max = (u64)(device_param.getDevice_processors() * hashconfig.getKernel_threads_max() * hashconfig.getKernel_accel_max());
		u64 size_scrypt = (u64)(128 * scrypt_r * scrypt_N);
		u64 scrypt_tmto_final = (kernel_power_max * size_scrypt) / extra_buffer_size;
		u64 tmp_size = (u64)(128 * scrypt_r * scrypt_p);
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-DSCRYPT_N=%u -DSCRYPT_R=%u -DSCRYPT_P=%u -DSCRYPT_TMTO=%I64u -DSCRYPT_TMP_ELEM=%I64u", hashes.getSalts_buf()[0].getScrypt_N(), hashes.getSalts_buf()[0].getScrypt_r(), hashes.getSalts_buf()[0].getScrypt_p(), scrypt_tmto_final, tmp_size / 16);
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		// -Wpass-failed=transform-warningif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 1)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		// -Wpass-failed=transform-warningif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 1)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		// this uses some nice feedback effect.// based on the device_local_mem_size the reqd_work_group_size in the kernel is set to some value
		// which is then is read from the opencl host in the kernel_preferred_wgs_multiple1/2/3 result.// therefore we do not need to set module_kernel_threads_min/max except for CPU, where the threads are set to fixed 1.u32 fixed_local_size = 0;
		if (device_param.getOpencl_device_type() & CL_DEVICE_TYPE_CPU) {
			fixed_local_size = 1;
		} else {
				u32 overhead = 0;
				if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
					if (device_param.getIs_opencl() == 1) {
						overhead = 4;
					} 
				} 
				if (user_options.getKernel_threads_chgd() == 1) {
					fixed_local_size = user_options.getKernel_threads();
					if ((fixed_local_size * 4096) > (device_param.getDevice_local_mem_size() - overhead)) {
						fixed_local_size = (device_param.getDevice_local_mem_size() - overhead) / 4096;
					} 
				} else {
						fixed_local_size = (device_param.getDevice_local_mem_size() - overhead) / 4096;
				} 
		} 
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D FIXED_LOCAL_SIZE=%u", fixed_local_size);
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		u32 scrypt_N = 16384;
		u32 scrypt_r = 1;
		u32 scrypt_p = 1;
		u64 extra_buffer_size = device_param.getExtra_buffer_size();
		u64 kernel_power_max = (u64)(device_param.getDevice_processors() * hashconfig.getKernel_threads_max() * hashconfig.getKernel_accel_max());
		u64 size_scrypt = (u64)(128 * scrypt_r * scrypt_N);
		u64 scrypt_tmto_final = (kernel_power_max * size_scrypt) / extra_buffer_size;
		u64 tmp_size = (u64)(128 * scrypt_r * scrypt_p);
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-DSCRYPT_N=%u -DSCRYPT_R=%u -DSCRYPT_P=%u -DSCRYPT_TMTO=%I64u -DSCRYPT_TMP_ELEM=%I64u", hashes.getSalts_buf()[0].getScrypt_N(), hashes.getSalts_buf()[0].getScrypt_r(), hashes.getSalts_buf()[0].getScrypt_p(), scrypt_tmto_final, tmp_size / 16);
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getIs_cuda() == 1) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_NV) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		if ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 0)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		// -Wpass-failed=transform-warningif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 1)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		// -Wpass-failed=transform-warningif ((device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) && (device_param.getHas_vperm() == 1)) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
		byte jit_build_options = ((Object)0);
		if (device_param.getOpencl_device_vendor_id() == vendor_id.VENDOR_ID_AMD) {
			ModernizedCProgram.hc_asprintf(jit_build_options, "-D NO_UNROLL");
		} 
		return jit_build_options;
	}
	public static int Xz_WriteVarInt(Object buf, Object v) {
		int i = 0;
		do {
			buf[i++] = (Byte)((v & -1024) | -1024);
			v >>=  7;
		} while (v != 0);
		buf[(size_t)i - 1] &=  -1024;
		return i;
	}
	public static void Xz_Construct() {
		this.setNumBlocks(0);
		this.setBlocks(((Object)0));
		this.setFlags(0);
	}
	public static void Xz_Free(Object alloc) {
		Object generatedBlocks = this.getBlocks();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedBlocks);
		this.setNumBlocks(0);
		this.setBlocks(((Object)0));
	}
	public static int XzFlags_GetCheckSize(Object f) {
		int t = ((f) & -1024);
		return (t == 0) ? 0 : (4 << ((t - 1) / 3));
	}
	public static void XzCheck_Init(int mode) {
		this.setMode(mode);
		Object generatedSha = this.getSha();
		switch (mode) {
		case 4:
				this.setCrc64(-1024);
				break;
		case 10:
				generatedSha.Sha256_Init();
				break;
		case 1:
				this.setCrc(-1024);
				break;
		}
	}
	public static void XzCheck_Update(Object data, Object size) {
		Object generatedCrc = this.getCrc();
		Object generatedCrc64 = this.getCrc64();
		Object generatedSha = this.getSha();
		Object generatedMode = this.getMode();
		switch (generatedMode) {
		case 1:
				this.setCrc(ModernizedCProgram.CrcUpdate(generatedCrc, data, size));
				break;
		case 10:
				generatedSha.Sha256_Update((Byte)data, size);
				break;
		case 4:
				this.setCrc64(ModernizedCProgram.Crc64Update(generatedCrc64, data, size));
				break;
		}
	}
	public static int XzCheck_Final(Object digest) {
		Object generatedCrc = this.getCrc();
		Object generatedCrc64 = this.getCrc64();
		Object generatedSha = this.getSha();
		Object generatedMode = this.getMode();
		switch (generatedMode) {
		case 1:
				{ 
					(UInt32)(digest) = (((generatedCrc) ^ -1024));
				}
				;
				break;
		case 10:
				generatedSha.Sha256_Final(digest);
				break;
		case 4:
				{ 
					int i;
					UInt64 v = ((generatedCrc64) ^ -1024);
					for (i = 0; i < 8; ) {
						digest[i] = (Byte)(v & -1024);
					}
					break;
				}
		default:
				return 0;
		}
		return 1;
	}
	public static Object module_salt_min(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 salt_min = 16;
		return salt_min;
		u32 salt_min = 64;
		return salt_min;
		u32 salt_min = 8;
		return salt_min;
		// Underlaying DES minu32 salt_min = 8;
		return salt_min;
		u32 salt_min = 56;
		return salt_min;
		u32 salt_min = 64;
		return salt_min;
		// Underlaying DES minu32 salt_min = 8;
		return salt_min;
	}
	public static Object module_salt_max(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 salt_max = 16;
		return salt_max;
		u32 salt_max = 64;
		return salt_max;
		u32 salt_max = 8;
		return salt_max;
		// Underlaying DES maxu32 salt_max = 8;
		return salt_max;
		u32 salt_max = 56;
		return salt_max;
		return ModernizedCProgram.DGST_BLK_SIZE;
		u32 salt_max = 64;
		return salt_max;
		// Underlaying DES maxu32 salt_max = 8;
		return salt_max;
	}
	public static void sha512aix_decode(Object digest, Object buf) {
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[2] = (l >> 0) & -1024;
		digest[1] = (l >> 8) & -1024;
		digest[0] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[5] = (l >> 0) & -1024;
		digest[4] = (l >> 8) & -1024;
		digest[3] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[8] = (l >> 0) & -1024;
		digest[7] = (l >> 8) & -1024;
		digest[6] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[11] = (l >> 0) & -1024;
		digest[10] = (l >> 8) & -1024;
		digest[9] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[14] = (l >> 0) & -1024;
		digest[13] = (l >> 8) & -1024;
		digest[12] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[22]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[23]) << 18;
		digest[17] = (l >> 0) & -1024;
		digest[16] = (l >> 8) & -1024;
		digest[15] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[24]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[25]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[26]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[27]) << 18;
		digest[20] = (l >> 0) & -1024;
		digest[19] = (l >> 8) & -1024;
		digest[18] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[28]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[29]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[30]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[31]) << 18;
		digest[23] = (l >> 0) & -1024;
		digest[22] = (l >> 8) & -1024;
		digest[21] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[32]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[33]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[34]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[35]) << 18;
		digest[26] = (l >> 0) & -1024;
		digest[25] = (l >> 8) & -1024;
		digest[24] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[36]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[37]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[38]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[39]) << 18;
		digest[29] = (l >> 0) & -1024;
		digest[28] = (l >> 8) & -1024;
		digest[27] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[40]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[41]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[42]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[43]) << 18;
		digest[32] = (l >> 0) & -1024;
		digest[31] = (l >> 8) & -1024;
		digest[30] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[44]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[45]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[46]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[47]) << 18;
		digest[35] = (l >> 0) & -1024;
		digest[34] = (l >> 8) & -1024;
		digest[33] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[48]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[49]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[50]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[51]) << 18;
		digest[38] = (l >> 0) & -1024;
		digest[37] = (l >> 8) & -1024;
		digest[36] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[52]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[53]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[54]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[55]) << 18;
		digest[41] = (l >> 0) & -1024;
		digest[40] = (l >> 8) & -1024;
		digest[39] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[56]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[57]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[58]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[59]) << 18;
		digest[44] = (l >> 0) & -1024;
		digest[43] = (l >> 8) & -1024;
		digest[42] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[60]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[61]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[62]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[63]) << 18;
		digest[47] = (l >> 0) & -1024;
		digest[46] = (l >> 8) & -1024;
		digest[45] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[64]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[65]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[66]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[67]) << 18;
		digest[50] = (l >> 0) & -1024;
		digest[49] = (l >> 8) & -1024;
		digest[48] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[68]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[69]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[70]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[71]) << 18;
		digest[53] = (l >> 0) & -1024;
		digest[52] = (l >> 8) & -1024;
		digest[51] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[72]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[73]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[74]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[75]) << 18;
		digest[56] = (l >> 0) & -1024;
		digest[55] = (l >> 8) & -1024;
		digest[54] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[76]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[77]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[78]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[79]) << 18;
		digest[59] = (l >> 0) & -1024;
		digest[58] = (l >> 8) & -1024;
		digest[57] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[80]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[81]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[82]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[83]) << 18;
		digest[62] = (l >> 0) & -1024;
		digest[61] = (l >> 8) & -1024;
		digest[60] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[84]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[85]) << 6;
		digest[63] = (l >> 16) & -1024;
	}
	public static void sha512aix_encode(Object digest, Object buf) {
		int l;
		l = (digest[2] << 0) | (digest[1] << 8) | (digest[0] << 16);
		buf[0] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[1] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[2] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[3] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[5] << 0) | (digest[4] << 8) | (digest[3] << 16);
		buf[4] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[5] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[6] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[7] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[8] << 0) | (digest[7] << 8) | (digest[6] << 16);
		buf[8] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[9] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[10] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[11] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[11] << 0) | (digest[10] << 8) | (digest[9] << 16);
		buf[12] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[13] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[14] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[15] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[14] << 0) | (digest[13] << 8) | (digest[12] << 16);
		buf[16] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[17] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[18] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[19] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[17] << 0) | (digest[16] << 8) | (digest[15] << 16);
		buf[20] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[21] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[22] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[23] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[20] << 0) | (digest[19] << 8) | (digest[18] << 16);
		buf[24] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[25] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[26] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[27] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[23] << 0) | (digest[22] << 8) | (digest[21] << 16);
		buf[28] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[29] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[30] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[31] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[26] << 0) | (digest[25] << 8) | (digest[24] << 16);
		buf[32] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[33] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[34] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[35] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[29] << 0) | (digest[28] << 8) | (digest[27] << 16);
		buf[36] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[37] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[38] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[39] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[32] << 0) | (digest[31] << 8) | (digest[30] << 16);
		buf[40] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[41] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[42] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[43] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[35] << 0) | (digest[34] << 8) | (digest[33] << 16);
		buf[44] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[45] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[46] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[47] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[38] << 0) | (digest[37] << 8) | (digest[36] << 16);
		buf[48] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[49] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[50] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[51] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[41] << 0) | (digest[40] << 8) | (digest[39] << 16);
		buf[52] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[53] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[54] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[55] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[44] << 0) | (digest[43] << 8) | (digest[42] << 16);
		buf[56] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[57] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[58] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[59] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[47] << 0) | (digest[46] << 8) | (digest[45] << 16);
		buf[60] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[61] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[62] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[63] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[50] << 0) | (digest[49] << 8) | (digest[48] << 16);
		buf[64] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[65] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[66] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[67] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[53] << 0) | (digest[52] << 8) | (digest[51] << 16);
		buf[68] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[69] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[70] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[71] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[56] << 0) | (digest[55] << 8) | (digest[54] << 16);
		buf[72] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[73] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[74] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[75] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[59] << 0) | (digest[58] << 8) | (digest[57] << 16);
		buf[76] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[77] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[78] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[79] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[62] << 0) | (digest[61] << 8) | (digest[60] << 16);
		buf[80] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[81] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[82] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[83] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[63] << 16);
		buf[84] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[85] = ModernizedCProgram.int_to_itoa64(l & -1024);
	}
	/* inffast.c -- fast decoding
	 * Copyright (C) 1995-2017 Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */
	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.
	
	   Entry assumptions:
	
	        state->mode == LEN
	        strm->avail_in >= 6
	        strm->avail_out >= 258
	        start >= strm->avail_out
	        state->bits < 8
	
	   On return, state->mode is one of:
	
	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data
	
	   Notes:
	
	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm->avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.
	
	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm->avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	public static void inflate_fast(Object strm, int start) {
		/* inflate()'s starting value for strm->avail_out */inflate_state state = new inflate_state();
		/* local strm->next_in */byte in;
		/* have enough input while in < last */byte last;
		/* local strm->next_out */byte out;
		/* inflate()'s initial strm->next_out */byte beg;
		/* while out < end, enough space available */byte end;
		/* maximum distance from zlib header */
		/* window size or zero if not using window */int wsize;
		/* valid bytes in the window */int whave;
		/* window write index */int wnext;
		/* allocated sliding window, if wsize != 0 */byte window;
		/* local strm->hold */long hold;
		/* local strm->bits */int bits;
		/* local strm->lencode */code lcode = new code();
		/* local strm->distcode */code dcode = new code();
		/* mask for first level of length codes */int lmask;
		/* mask for first level of distance codes */int dmask;
		/* retrieved table entry */code here = new code();
		/* code bits, operation, extra bits, or */int op;
		/*  window position, window bytes to copy */
		/* match length, unused bytes */int len;
		/* match distance */int dist;
		/* where to copy match from */byte from;
		state = (inflate_state)strm.getState();
		in = strm.getNext_in();
		last = in + (strm.getAvail_in() - 5);
		out = strm.getNext_out();
		beg = out - (start - strm.getAvail_out());
		end = out + (strm.getAvail_out() - 257);
		Object generatedWsize = state.getWsize();
		wsize = generatedWsize;
		Object generatedWhave = state.getWhave();
		whave = generatedWhave;
		Object generatedWnext = state.getWnext();
		wnext = generatedWnext;
		Object generatedWindow = state.getWindow();
		window = generatedWindow;
		Object generatedHold = state.getHold();
		hold = generatedHold;
		Object generatedBits = state.getBits();
		bits = generatedBits;
		Object generatedLencode = state.getLencode();
		lcode = generatedLencode;
		Object generatedDistcode = state.getDistcode();
		dcode = generatedDistcode;
		Object generatedLenbits = state.getLenbits();
		lmask = (-1024 << generatedLenbits) - 1;
		Object generatedDistbits = state.getDistbits();
		dmask = (-1024 << generatedDistbits) - 1/* decode literals and length/distances until end-of-block or not enough
		       input data or output space */;
		len = bits >> /* return unused bytes (on entry, bits < 8, so in won't go too far back) */3;
		in -= len;
		bits -= len << 3;
		hold &=  (-1024 << bits) - 1;
		strm.setNext_in(/* update state and return */in);
		strm.setNext_out(out);
		strm.setAvail_in((int)(in < last ? 5 + (last - in) : 5 - (in - last)));
		strm.setAvail_out((int)(out < end ? 257 + (end - out) : 257 - (out - end)));
		state.setHold(hold);
		state.setBits(bits);
		return ;/*
		   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
		   - Using bit fields for code structure
		   - Different op definition to avoid & for extra bits (do & for table bits)
		   - Three separate decoding do-loops for direct, window, and wnext == 0
		   - Special case for distance > 1 copies to do overlapped load and store copy
		   - Explicit branch predictions (based on measured branch probabilities)
		   - Deferring match copy and interspersed it with decoding subsequent codes
		   - Swapping literal/length else
		   - Swapping window/direct else
		   - Larger unrolled copy loops (three is about right)
		   - Moving len -= 3 statement into middle of loop
		 */
		/* inflate()'s starting value for strm->avail_out */inflate_state state = new inflate_state();
		Object ar;
		/* 64   32                               x86  x86_64 */
		state = (inflate_state)strm.getState();
		ar.setIn(strm.getNext_in());
		byte generatedIn = ar.getIn();
		ar.setLast(generatedIn + (strm.getAvail_in() - 5));
		ar.setOut(strm.getNext_out());
		Byte generatedOut = ar.getOut();
		ar.setBeg(generatedOut - (start - strm.getAvail_out()));
		ar.setEnd(generatedOut + (strm.getAvail_out() - 257));
		Object generatedWsize = state.getWsize();
		ar.setWsize(generatedWsize);
		Object generatedWnext = state.getWnext();
		ar.setWrite(generatedWnext);
		Object generatedWindow = state.getWindow();
		ar.setWindow(generatedWindow);
		Object generatedHold = state.getHold();
		ar.setHold(generatedHold);
		Object generatedBits = state.getBits();
		ar.setBits(generatedBits);
		Object generatedLencode = state.getLencode();
		ar.setLcode(generatedLencode);
		Object generatedDistcode = state.getDistcode();
		ar.setDcode(generatedDistcode);
		Object generatedLenbits = state.getLenbits();
		ar.setLmask((-1024 << generatedLenbits) - 1);
		Object generatedDistbits = state.getDistbits();
		ar.setDmask((-1024 << generatedDistbits) - 1/* decode literals and length/distances until end-of-block or not enough
		       input data or output space */);
		while (((long)(Object)generatedIn & ( / 2 - 1)) != /* align in on 1/2 hold size boundary */0) {
			generatedHold += (long)generatedIn++ << generatedBits;
			generatedBits += 8;
		}/* make rsp point to &ar *//* rsi  = in *//* rdi  = out *//* r9   = last *//* r10  = end *//* rbp  = lcode *//* r11  = dcode *//* rdx  = hold *//* ebx  = bits *//* r12d = lmask *//* r13d = dmask *//* r14d = len *//* r15d = dist *//* if only one decode left *//* r8 = lmask *//* eax = *(uint *)in++ *//* cl = bits, needs it for shifting *//* bits += 32 *//* hold |= *((uint *)in)++ << bits *//* r8 = lmask *//* if (32 < bits) *//* eax = *(uint *)in++ *//* cl = bits, needs it for shifting *//* bits += 32 *//* hold |= *((uint *)in)++ << bits *//* r8 &= hold *//* eax = lcode[hold & lmask] *//* cl = this.bits *//* bits -= this.bits *//* hold >>= this.bits *//* if (op != 0) 45.7% *//* r8 = lmask *//* output this.val char *//* r8 &= hold *//* eax = lcode[hold & lmask] *//* cl = this.bits *//* bits -= this.bits *//* hold >>= this.bits *//* if (op != 0) 45.7% *//* output this.val char *//* len = this *//* len = this.val *//* if ((op & 16) == 0) 8% *//* op &= 15 *//* if (!op) *//* eax &= hold *//* len += hold & mask[op] *//* r8 = dmask *//* if (32 < bits) *//* eax = *(uint *)in++ *//* cl = bits, needs it for shifting *//* bits += 32 *//* hold |= *((uint *)in)++ << bits *//* r8 &= hold *//* eax = dcode[hold & dmask] *//* dist = this *//* dist = this.val *//* bits -= this.bits *//* hold >>= this.bits *//* cl = this.op *//* if ((op & 16) == 0) *//* op &= 15 *//* (1 << op) - 1 *//* eax &= hold *//* dist += hold & ((1 << op) - 1) *//* save in so from can use it's reg *//* nbytes = out - beg *//* if (dist > nbytes) 4.2% *//* ecx = len *//* from = out - dist *//* if len % 2 == 0 *//* move in back to %rsi, toss from */
		/* move in back to %rsi, toss from *//* if dist 1, is a memset *//* if out == beg, outside window *//* ecx = len *//* if ((op & 64) != 0) *//* eax &= hold *//* eax += len *//* eax = lcode[val+(hold&mask[op])]*//* if ((op & 64) != 0) *//* eax &= hold *//* eax += dist *//* eax = dcode[val+(hold&mask[op])]*//* ecx = nbytes *//* eax = wsize, prepare for dist cmp *//* nbytes = -nbytes *//* if (dist > wsize) *//* nbytes = dist - nbytes *//* if (write != 0) *//* from  = window *//* eax  -= nbytes *//* from += wsize - nbytes *//* eax = len *//* if (nbytes >= len) *//* eax -= nbytes *//* from = &out[ -dist ] *//* eax = write *//* if (write >= nbytes) *//* from  = wsize *//* from += window *//* from += write *//* from -= nbytes *//* nbytes -= write *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = window *//* nbytes = write *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* rsi = window *//* from += write - nbytes *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* if (nbytes >= len) *//* ecx = len *//* move in back to %esi, toss from *//* put in, out, bits, and hold back into ar and pop esp *//* in *//* out *//* bits *//* hold *//* restore rbp and rsp *//* move in back to %rsi, toss from *//* if dist 1, is a memset *//* if out == beg, outside window *//* ecx = len *//* if ((op & 64) != 0) *//* eax &= hold *//* eax += len *//* eax = lcode[val+(hold&mask[op])]*//* if ((op & 64) != 0) *//* eax &= hold *//* eax += dist *//* eax = dcode[val+(hold&mask[op])]*//* ecx = nbytes *//* eax = wsize, prepare for dist cmp *//* nbytes = -nbytes *//* if (dist > wsize) *//* nbytes = dist - nbytes *//* if (write != 0) *//* from  = window *//* eax  -= nbytes *//* from += wsize - nbytes *//* eax = len *//* if (nbytes >= len) *//* eax -= nbytes *//* from = &out[ -dist ] *//* eax = write *//* if (write >= nbytes) *//* from  = wsize *//* from += window *//* from += write *//* from -= nbytes *//* nbytes -= write *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = window *//* nbytes = write *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* rsi = window *//* from += write - nbytes *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* if (nbytes >= len) *//* ecx = len *//* move in back to %esi, toss from *//* put in, out, bits, and hold back into ar and pop esp *//* in *//* out *//* bits *//* hold *//* restore rbp and rsp *//* save esp, ebp *//* esi = in *//* edi = out *//* edx = hold *//* ebx = bits *//* ebp = lcode *//* out < end *//* in < last *//* if (15 < bits) *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* eax = lmask *//* eax &= hold *//* eax = lcode[hold & lmask] *//* cl = this.bits *//* bits -= this.bits *//* hold >>= this.bits *//* if (op != 0) 45.7% *//* output this.val char *//* len = this *//* len = this.val *//* save len *//* if ((op & 16) == 0) 8% *//* op &= 15 *//* if (!op) *//* if (op <= bits) *//* stash op in ch, freeing cl *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* move op back to ecx *//* eax &= hold *//* len += hold & mask[op] *//* if (15 < bits) *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* eax = dmask *//* ecx = dcode *//* eax &= hold *//* eax = dcode[hold & dmask] *//* dist = this *//* dist = this.val *//* bits -= this.bits *//* hold >>= this.bits *//* cl = this.op *//* if ((op & 16) == 0) *//* op &= 15 *//* if (op <= bits) 97.6% *//* stash op in ch, freeing cl *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* move op back to ecx *//* (1 << op) - 1 *//* eax &= hold *//* dist += hold & ((1 << op) - 1) *//* save in so from can use it's reg *//* nbytes = out - beg *//* if (dist > nbytes) 4.2% *//* ecx = len *//* from = out - dist *//* if len % 2 == 0 *//* move in back to %esi, toss from *//* ebp = lcode *//* move in back to %esi, toss from *//* ebp = lcode *//* if dist 1, is a memset *//* out == beg, if outside window *//* ecx = len *//* ebp = lcode *//* if ((op & 64) != 0) *//* eax &= hold *//* eax += len *//* eax = lcode[val+(hold&mask[op])]*//* if ((op & 64) != 0) *//* eax &= hold *//* eax += dist *//* ecx = dcode *//* eax = dcode[val+(hold&mask[op])]*//* eax = wsize *//* nbytes = -nbytes *//* from = window *//* if (dist > wsize) *//* nbytes = dist - nbytes *//* if (write != 0) *//* from += wsize - nbytes *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* eax = write *//* if (write >= nbytes) *//* from += wsize *//* from += write *//* from -= nbytes *//* nbytes -= write *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = window *//* nbytes = write *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* from += write - nbytes *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* if (nbytes >= len) *//* move in back to %esi, toss from *//* ebp = lcode *//* put in, out, bits, and hold back into ar and pop esp *//* save in *//* save out *//* save bits *//* save hold *//* restore esp, ebp */;/* save esp, ebp *//* esi = in *//* edi = out *//* edx = hold *//* ebx = bits *//* ebp = lcode *//* out < end *//* in < last *//* if (15 < bits) *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* eax = lmask *//* eax &= hold *//* eax = lcode[hold & lmask] *//* cl = this.bits *//* bits -= this.bits *//* hold >>= this.bits *//* if (op != 0) 45.7% *//* output this.val char *//* len = this *//* len = this.val *//* save len *//* if ((op & 16) == 0) 8% *//* op &= 15 *//* if (!op) *//* if (op <= bits) *//* stash op in ch, freeing cl *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* move op back to ecx *//* eax &= hold *//* len += hold & mask[op] *//* if (15 < bits) *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* eax = dmask *//* ecx = dcode *//* eax &= hold *//* eax = dcode[hold & dmask] *//* dist = this *//* dist = this.val *//* bits -= this.bits *//* hold >>= this.bits *//* cl = this.op *//* if ((op & 16) == 0) *//* op &= 15 *//* if (op <= bits) 97.6% *//* stash op in ch, freeing cl *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* move op back to ecx *//* (1 << op) - 1 *//* eax &= hold *//* dist += hold & ((1 << op) - 1) *//* save in so from can use it's reg *//* nbytes = out - beg *//* if (dist > nbytes) 4.2% *//* ecx = len *//* from = out - dist *//* if len % 2 == 0 *//* move in back to %esi, toss from *//* ebp = lcode *//* move in back to %esi, toss from *//* ebp = lcode *//* if dist 1, is a memset *//* out == beg, if outside window *//* ecx = len *//* ebp = lcode *//* if ((op & 64) != 0) *//* eax &= hold *//* eax += len *//* eax = lcode[val+(hold&mask[op])]*//* if ((op & 64) != 0) *//* eax &= hold *//* eax += dist *//* ecx = dcode *//* eax = dcode[val+(hold&mask[op])]*//* eax = wsize *//* nbytes = -nbytes *//* from = window *//* if (dist > wsize) *//* nbytes = dist - nbytes *//* if (write != 0) *//* from += wsize - nbytes *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* eax = write *//* if (write >= nbytes) *//* from += wsize *//* from += write *//* from -= nbytes *//* nbytes -= write *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = window *//* nbytes = write *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* from += write - nbytes *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* if (nbytes >= len) *//* move in back to %esi, toss from *//* ebp = lcode *//* put in, out, bits, and hold back into ar and pop esp *//* save in *//* save out *//* save bits *//* save hold *//* restore esp, ebp */
		int generatedStatus = ar.getStatus();
		/* save esp, ebp *//* esi = in *//* edi = out *//* edx = hold *//* ebx = bits *//* ebp = lcode *//* if (15 < bits) *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* eax = lmask *//* eax &= hold *//* eax = lcode[hold & lmask] *//* cl = this.bits *//* bits -= this.bits *//* hold >>= this.bits *//* if (op != 0) 45.7% *//* output this.val char *//* len = this *//* len = this.val *//* save len *//* if ((op & 16) == 0) 8% *//* op &= 15 *//* if (!op) *//* if (op <= bits) *//* stash op in ch, freeing cl *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* move op back to ecx *//* eax &= hold *//* len += hold & mask[op] *//* if (15 < bits) *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* eax = dmask *//* ecx = dcode *//* eax &= hold *//* eax = dcode[hold & dmask] *//* dist = this *//* dist = this.val *//* bits -= this.bits *//* hold >>= this.bits *//* cl = this.op *//* if ((op & 16) == 0) *//* op &= 15 *//* if (op <= bits) 97.6% *//* stash op in ch, freeing cl *//* al = *(ushort *)in++ *//* cl = bits, needs it for shifting *//* bits += 16 *//* hold |= *((ushort *)in)++ << bits *//* move op back to ecx *//* (1 << op) - 1 *//* eax &= hold *//* dist += hold & ((1 << op) - 1) *//* save in so from can use it's reg *//* nbytes = out - beg *//* if (dist > nbytes) 4.2% *//* ecx = len *//* from = out - dist *//* move in back to %esi, toss from *//* ebp = lcode *//* move in back to %esi, toss from *//* ebp = lcode *//* if dist 1, is a memset *//* out == beg, if outside window *//* ecx = len *//* memset out with from[-1] *//* ebp = lcode *//* if ((op & 64) != 0) *//* eax &= hold *//* eax += len *//* eax = lcode[val+(hold&mask[op])]*//* if ((op & 64) != 0) *//* eax &= hold *//* eax += dist *//* ecx = dcode *//* eax = dcode[val+(hold&mask[op])]*//* eax = wsize *//* nbytes = -nbytes *//* from = window *//* if (dist > wsize) *//* nbytes = dist - nbytes *//* if (write != 0) *//* from += wsize - nbytes *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* eax = write *//* if (write >= nbytes) *//* from += wsize *//* from += write *//* from -= nbytes *//* nbytes -= write *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = window *//* nbytes = write *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* from += write - nbytes *//* eax = len *//* if (nbytes >= len) *//* len -= nbytes *//* from = out - dist *//* move in back to %esi, toss from *//* ebp = lcode *//* put in, out, bits, and hold back into ar and pop esp *//* save in *//* save out *//* save bits *//* save hold *//* restore esp, ebp */if (generatedStatus > 1) {
			if (generatedStatus == 2) {
				strm.setMsg("invalid literal/length code");
			}  else if (generatedStatus == 3) {
				strm.setMsg("invalid distance code");
			} else {
					strm.setMsg("invalid distance too far back");
			} 
			state.setMode(.BAD);
		}  else if (generatedStatus == 1) {
			state.setMode(.TYPE);
		} 
		ar.setLen(generatedBits >> /* return unused bytes (on entry, bits < 8, so in won't go too far back) */3);
		int generatedLen = ar.getLen();
		generatedIn -= generatedLen;
		generatedBits -= generatedLen << 3;
		generatedHold &=  (-1024 << generatedBits) - 1;
		strm.setNext_in(generatedIn);
		strm.setNext_out(generatedOut);
		Byte generatedLast = ar.getLast();
		strm.setAvail_in((int)(generatedIn < generatedLast ? 5 + (generatedLast - generatedIn) : 5 - (generatedIn - generatedLast)));
		Byte generatedEnd = ar.getEnd();
		strm.setAvail_out((int)(generatedOut < generatedEnd ? 257 + (generatedEnd - generatedOut) : 257 - (generatedOut - generatedEnd)));
		state.setHold(generatedHold);
		state.setBits(generatedBits);
		return ;
	}
	/* !ASMINF */
	/* If not enough room in bi_buf, use (valid) bits from bi_buf and
	     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
	     * unused bits in value.
	     */
	/* !ZLIB_DEBUG */
	/* ZLIB_DEBUG */
	/* the arguments must not have side effects */
	/* ===========================================================================
	 * Initialize the various 'constant' tables.
	 */
	public static void tr_static_init() {
	}
	/* iterates over tree elements */
	/* bit counter */
	/* length value */
	/* code value */
	/* distance index */
	/* number of codes at each bit length for an optimal tree */
	/* For some embedded targets, global variables are not initialized: */
	/* Initialize the mapping length (0..255) -> length code (0..28) */
	/* Note that the length 255 (match length 258) can be represented
	     * in two different ways: code 284 + 5 bits or code 285, so we
	     * overwrite length_code[255] to use the best encoding:
	     */
	/* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	/* from now on, all distances are divided by 128 */
	/* Construct the codes of the static literal tree */
	/* Codes 286 and 287 do not exist, but we must include them in the
	     * tree construction to get a canonical Huffman tree (longest code
	     * all ones)
	     */
	/* The static distance tree is trivial: */
	/* ===========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	/* ===========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 */
	public static void pqdownheap(internal_state s, ct_data_s tree, int k) {
		Object generatedHeap = s.getHeap();
		int v = generatedHeap[/* node to move down */k];
		int j = k << /* left son of k */1;
		int generatedHeap_len = s.getHeap_len();
		Object generatedDepth = s.getDepth();
		while (j <= generatedHeap_len) {
			if (j < generatedHeap_len && (tree[generatedHeap[j + 1]].getFc().getFreq() < tree[generatedHeap[j]].getFc().getFreq() || (tree[generatedHeap[j + 1]].getFc().getFreq() == tree[generatedHeap[j]].getFc().getFreq() && generatedDepth[generatedHeap[j + 1]] <= generatedDepth[generatedHeap[j]]))) {
				j++;
			} 
			if ((tree[v].getFc().getFreq() < tree[generatedHeap[j]].getFc().getFreq() || (tree[v].getFc().getFreq() == tree[generatedHeap[j]].getFc().getFreq() && generatedDepth[v] <= generatedDepth[generatedHeap[/* Exit if v is smaller than both sons */j]]))) {
				break;
			} 
			generatedHeap[k] = generatedHeap[j];
			k = /* Exchange v with the smallest son */j;
			j <<=  /* And continue down the tree, setting j to the left son of k */1;
		}
		generatedHeap[k] = v/* ===========================================================================
		 * Compute the optimal bit lengths for a tree and update the total bit length
		 * for the current block.
		 * IN assertion: the fields freq and dad are set, heap[heap_max] and
		 *    above are the tree nodes sorted by increasing frequency.
		 * OUT assertions: the field len is set to the optimal bit length, the
		 *     array bl_count contains the frequencies for each bit length.
		 *     The length opt_len is updated; static_len is also updated if stree is
		 *     not null.
		 */;
	}
	/* the tree to restore */
	public static void gen_bitlen(internal_state s, tree_desc_s desc) {
		ct_data_s generatedDyn_tree = desc.getDyn_tree();
		ct_data tree = generatedDyn_tree;
		int generatedMax_code = desc.getMax_code();
		int max_code = generatedMax_code;
		Object generatedStat_desc = desc.getStat_desc();
		ct_data stree = generatedStat_desc.getStatic_tree();
		intf extra = generatedStat_desc.getExtra_bits();
		int base = generatedStat_desc.getExtra_base();
		int max_length = generatedStat_desc.getMax_length();
		/* heap index */int h;
		/* iterate over the tree elements */int n;
		int m;
		/* bit length */int bits;
		/* extra bits */int xbits;
		/* frequency */ush f = new ush();
		int overflow = /* number of elements with bit length too large */0;
		Object generatedBl_count = s.getBl_count();
		for (bits = 0; bits <= 15; bits++) {
			generatedBl_count[bits] = 0/* In a first pass, compute the optimal bit lengths (which may
			     * overflow in the case of the bit length tree).
			     */;
		}
		Object generatedHeap = s.getHeap();
		int generatedHeap_max = s.getHeap_max();
		tree[generatedHeap[generatedHeap_max]].getDl().setLen(/* root of the heap */0);
		Object generatedOpt_len = s.getOpt_len();
		Object generatedStatic_len = s.getStatic_len();
		for (h = generatedHeap_max + 1; h < (2 * (256 + 1 + 29) + 1); h++) {
			n = generatedHeap[h];
			bits = tree[tree[n].getDl().getDad()].getDl().getLen() + 1;
			if (bits > max_length) {
				;
			} 
			tree[n].getDl().setLen((ush)bits/* We overwrite tree[n].Dad which is no longer needed */);
			if (n > /* not a leaf node */max_code) {
				continue;
			} 
			generatedBl_count[bits]++;
			xbits = 0;
			if (n >= base) {
				xbits = extra[n - base];
			} 
			f = tree[n].getFc().getFreq();
			generatedOpt_len += (ulg)f * (int)(bits + xbits);
			if (stree) {
				generatedStatic_len += (ulg)f * (int)(stree[n].getDl().getLen() + xbits);
			} 
		}
		if (overflow == 0) {
			return ;
		} 
		;/* This happens for example on obj2 and pic of the Calgary corpus */
		/* Find the first bit length which could increase: */do {
			bits = max_length - 1;
			while (generatedBl_count[bits] == 0) {
				bits--;
			}
			generatedBl_count[/* move one leaf down the tree */bits]--;
			generatedBl_count[bits + 1] += /* move one overflow item as its brother */2;
			generatedBl_count[max_length/* The brother of the overflow item also moves one step up,
			         * but this does not affect bl_count[max_length]
			         */]--;
			overflow -= 2;
		} while (overflow > 0/* Now recompute all bit lengths, scanning in increasing frequency.
		     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
		     * lengths instead of fixing only the wrong ones. This idea is taken
		     * from 'ar' written by Haruhiko Okumura.)
		     */);
		for (bits = max_length; bits != 0; bits--) {
			n = generatedBl_count[bits];
			while (n != 0) {
				m = generatedHeap[--h];
				if (m > max_code) {
					continue;
				} 
				if ((int)tree[m].getDl().getLen() != (int)bits) {
					;
					generatedOpt_len += ((ulg)bits - tree[m].getDl().getLen()) * tree[m].getFc().getFreq();
					tree[m].getDl().setLen((ush)bits);
				} 
				n/* ===========================================================================
				 * Generate the codes for a given tree and bit counts (which need not be
				 * optimal).
				 * IN assertion: the array bl_count contains the bit length statistics for
				 * the given tree and the field len is set for all tree elements.
				 * OUT assertion: the field code is set for all tree elements of non
				 *     zero code length.
				 */--;
			}
		}
	}
	public static void build_tree(internal_state s, tree_desc_s desc) {
		ct_data_s generatedDyn_tree = desc.getDyn_tree();
		ct_data tree = generatedDyn_tree;
		Object generatedStat_desc = desc.getStat_desc();
		ct_data stree = generatedStat_desc.getStatic_tree();
		int elems = generatedStat_desc.getElems();
		/* iterate over heap elements */int n;
		int m;
		int max_code = -/* largest code with non zero frequency */1;
		/* new node being created */int node;
		/* Construct the initial heap, with least frequent element in
		     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
		     * heap[0] is not used.
		     */
		;
		Object generatedHeap = s.getHeap();
		int generatedHeap_len = s.getHeap_len();
		Object generatedDepth = s.getDepth();
		for (n = 0; n < elems; n++) {
			if (tree[n].getFc().getFreq() != 0) {
				generatedHeap[++(generatedHeap_len)] = max_code = n;
				generatedDepth[n] = 0;
			} else {
					tree[n].getDl().setLen(0/* The pkzip format requires that at least one distance code exists,
					     * and that at least one bit should be sent even if there is only one
					     * possible code. So to avoid special checks later on we force at least
					     * two codes of non zero frequency.
					     */);
			} 
		}
		Object generatedOpt_len = s.getOpt_len();
		Object generatedStatic_len = s.getStatic_len();
		while (generatedHeap_len < 2) {
			node = generatedHeap[++(generatedHeap_len)] = (max_code < 2 ? ++max_code : 0);
			tree[node].getFc().setFreq(1);
			generatedDepth[node] = 0;
			generatedOpt_len--;
			if (stree) {
				generatedStatic_len -= stree[node].getDl().getLen();
			} 
		}
		desc.setMax_code(max_code/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
		     * establish sub-heaps of increasing lengths:
		     */);
		for (n = generatedHeap_len / 2; n >= 1; n--) {
			ModernizedCProgram.pqdownheap(s, tree, n/* Construct the Huffman tree by repeatedly combining the least two
			     * frequent nodes.
			     */);
		}
		node = /* next internal node of the tree */elems;
		int generatedHeap_max = s.getHeap_max();
		do {
			{ 
				n = generatedHeap[1];
				generatedHeap[1] = generatedHeap[generatedHeap_len--];
				ModernizedCProgram.pqdownheap(s, tree, /* n = node of least frequency */1);
			}
			;
			m = generatedHeap[/* m = node of next least frequency */1];
			generatedHeap[--(generatedHeap_max)] = /* keep the nodes sorted by frequency */n;
			generatedHeap[--(generatedHeap_max)] = m;
			tree[node].getFc().setFreq(tree[n].getFc().getFreq() + tree[m].getFc().getFreq());
			generatedDepth[node] = (uch)((generatedDepth[n] >= generatedDepth[m] ? generatedDepth[n] : generatedDepth[m]) + 1);
			tree[n].getDl().setDad(tree[m].getDl().setDad((ush)node));
			generatedHeap[1] = /* and insert the new node in the heap */node++;
			ModernizedCProgram.pqdownheap(s, tree, 1);
		} while (generatedHeap_len >= 2);
		generatedHeap[--(generatedHeap_max)] = generatedHeap[1/* At this point, the fields freq and dad are set. We can now
		     * generate the bit lengths.
		     */];
		ModernizedCProgram.gen_bitlen(s, (tree_desc)desc);
		Object generatedBl_count = s.getBl_count();
		(ct_data)tree.gen_codes(max_code, generatedBl_count);
	}
	public static void scan_tree(internal_state s, ct_data_s tree, int max_code) {
		/* and its largest code of non zero frequency *//* iterates over all tree elements */int n;
		int prevlen = -/* last emitted length */1;
		/* length of current code */int curlen;
		int nextlen = tree[0].getDl().getLen();
		int count = /* repeat count of the current code */0;
		int max_count = /* max repeat count */7;
		int min_count = /* min repeat count */4;
		if (nextlen == 0) {
			;
		} 
		tree[max_code + 1].getDl().setLen((ush)/* guard */-1024);
		Object generatedBl_tree = s.getBl_tree();
		for (n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[n + 1].getDl().getLen();
			if (++count < max_count && curlen == nextlen) {
				continue;
			}  else if (count < min_count) {
				generatedBl_tree[curlen].getFc().getFreq() += count;
			}  else if (curlen != 0) {
				if (curlen != prevlen) {
					generatedBl_tree[curlen].getFc().getFreq()++;
				} 
				generatedBl_tree[16].getFc().getFreq()++;
			}  else if (count <= 10) {
				generatedBl_tree[17].getFc().getFreq()++;
			} else {
					generatedBl_tree[18].getFc().getFreq()++;
			} 
			count = 0;
			prevlen = curlen;
			if (nextlen == 0) {
				;
			}  else if (curlen == nextlen) {
				;
			} else {
					;
			} 
		}
	}
	/* the tree to be scanned */
	/* ===========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 */
	public static void send_tree(internal_state s, ct_data_s tree, int max_code) {
		/* and its largest code of non zero frequency *//* iterates over all tree elements */int n;
		int prevlen = -/* last emitted length */1;
		/* length of current code */int curlen;
		int nextlen = tree[0].getDl().getLen();
		int count = /* repeat count of the current code */0;
		int max_count = /* max repeat count */7;
		int min_count = /* min repeat count */4;
		if (nextlen == 0) {
			;
		} 
		Object generatedBl_tree = s.getBl_tree();
		int generatedBi_valid = s.getBi_valid();
		Object generatedBi_buf = s.getBi_buf();
		Object generatedPending_buf = s.getPending_buf();
		Object generatedPending = s.getPending();
		for (n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[n + 1].getDl().getLen();
			if (++count < max_count && curlen == nextlen) {
				continue;
			}  else if (count < min_count) {
				do {
					{ 
						int len = generatedBl_tree[curlen].getDl().getLen();
						if (generatedBi_valid > (int)16 - len) {
							int val = (int)generatedBl_tree[curlen].getFc().getCode();
							generatedBi_buf |=  (ush)val << generatedBi_valid;
							{ 
								{ 
									generatedPending_buf[generatedPending++] = (Bytef)((uch)((generatedBi_buf) & -1024));
								}
								;
								{ 
									generatedPending_buf[generatedPending++] = (Bytef)((uch)((ush)(generatedBi_buf) >> 8));
								}
								;
							}
							;
							s.setBi_buf((ush)val >> (16 - generatedBi_valid));
							generatedBi_valid += len - 16;
						} else {
								generatedBi_buf |=  (ush)(generatedBl_tree[curlen].getFc().getCode()) << generatedBi_valid;
								generatedBi_valid += len;
						} 
					}
					;
				} while (--count != 0);
			}  else if (curlen != 0) {
				if (curlen != prevlen) {
					{ 
						int len = generatedBl_tree[curlen].getDl().getLen();
						if (generatedBi_valid > (int)16 - len) {
							int val = (int)generatedBl_tree[curlen].getFc().getCode();
							generatedBi_buf |=  (ush)val << generatedBi_valid;
							{ 
								{ 
									generatedPending_buf[generatedPending++] = (Bytef)((uch)((generatedBi_buf) & -1024));
								}
								;
								{ 
									generatedPending_buf[generatedPending++] = (Bytef)((uch)((ush)(generatedBi_buf) >> 8));
								}
								;
							}
							;
							s.setBi_buf((ush)val >> (16 - generatedBi_valid));
							generatedBi_valid += len - 16;
						} else {
								generatedBi_buf |=  (ush)(generatedBl_tree[curlen].getFc().getCode()) << generatedBi_valid;
								generatedBi_valid += len;
						} 
					}
					;
					count--;
				} 
				;
				{ 
					int len = generatedBl_tree[16].getDl().getLen();
					if (generatedBi_valid > (int)16 - len) {
						int val = (int)generatedBl_tree[16].getFc().getCode();
						generatedBi_buf |=  (ush)val << generatedBi_valid;
						{ 
							{ 
								generatedPending_buf[generatedPending++] = (Bytef)((uch)((generatedBi_buf) & -1024));
							}
							;
							{ 
								generatedPending_buf[generatedPending++] = (Bytef)((uch)((ush)(generatedBi_buf) >> 8));
							}
							;
						}
						;
						s.setBi_buf((ush)val >> (16 - generatedBi_valid));
						generatedBi_valid += len - 16;
					} else {
							generatedBi_buf |=  (ush)(generatedBl_tree[16].getFc().getCode()) << generatedBi_valid;
							generatedBi_valid += len;
					} 
				}
				;
				{ 
					int len = 2;
					if (generatedBi_valid > (int)16 - len) {
						int val = (int)count - 3;
						generatedBi_buf |=  (ush)val << generatedBi_valid;
						{ 
							{ 
								generatedPending_buf[generatedPending++] = (Bytef)((uch)((generatedBi_buf) & -1024));
							}
							;
							{ 
								generatedPending_buf[generatedPending++] = (Bytef)((uch)((ush)(generatedBi_buf) >> 8));
							}
							;
						}
						;
						s.setBi_buf((ush)val >> (16 - generatedBi_valid));
						generatedBi_valid += len - 16;
					} else {
							generatedBi_buf |=  (ush)(count - 3) << generatedBi_valid;
							generatedBi_valid += len;
					} 
				}
				;
			}  else if (count <= 10) {
				{ 
					int len = generatedBl_tree[17].getDl().getLen();
					if (generatedBi_valid > (int)16 - len) {
						int val = (int)generatedBl_tree[17].getFc().getCode();
						generatedBi_buf |=  (ush)val << generatedBi_valid;
						{ 
							{ 
								generatedPending_buf[generatedPending++] = (Bytef)((uch)((generatedBi_buf) & -1024));
							}
							;
							{ 
								generatedPending_buf[generatedPending++] = (Bytef)((uch)((ush)(generatedBi_buf) >> 8));
							}
							;
						}
						;
						s.setBi_buf((ush)val >> (16 - generatedBi_valid));
						generatedBi_valid += len - 16;
					} else {
							generatedBi_buf |=  (ush)(generatedBl_tree[17].getFc().getCode()) << generatedBi_valid;
							generatedBi_valid += len;
					} 
				}
				;
				{ 
					int len = 3;
					if (generatedBi_valid > (int)16 - len) {
						int val = (int)count - 3;
						generatedBi_buf |=  (ush)val << generatedBi_valid;
						{ 
							{ 
								generatedPending_buf[generatedPending++] = (Bytef)((uch)((generatedBi_buf) & -1024));
							}
							;
							{ 
								generatedPending_buf[generatedPending++] = (Bytef)((uch)((ush)(generatedBi_buf) >> 8));
							}
							;
						}
						;
						s.setBi_buf((ush)val >> (16 - generatedBi_valid));
						generatedBi_valid += len - 16;
					} else {
							generatedBi_buf |=  (ush)(count - 3) << generatedBi_valid;
							generatedBi_valid += len;
					} 
				}
				;
			} else {
					{ 
						int len = generatedBl_tree[18].getDl().getLen();
						if (generatedBi_valid > (int)16 - len) {
							int val = (int)generatedBl_tree[18].getFc().getCode();
							generatedBi_buf |=  (ush)val << generatedBi_valid;
							{ 
								{ 
									generatedPending_buf[generatedPending++] = (Bytef)((uch)((generatedBi_buf) & -1024));
								}
								;
								{ 
									generatedPending_buf[generatedPending++] = (Bytef)((uch)((ush)(generatedBi_buf) >> 8));
								}
								;
							}
							;
							s.setBi_buf((ush)val >> (16 - generatedBi_valid));
							generatedBi_valid += len - 16;
						} else {
								generatedBi_buf |=  (ush)(generatedBl_tree[18].getFc().getCode()) << generatedBi_valid;
								generatedBi_valid += len;
						} 
					}
					;
					{ 
						int len = 7;
						if (generatedBi_valid > (int)16 - len) {
							int val = (int)count - 11;
							generatedBi_buf |=  (ush)val << generatedBi_valid;
							{ 
								{ 
									generatedPending_buf[generatedPending++] = (Bytef)((uch)((generatedBi_buf) & -1024));
								}
								;
								{ 
									generatedPending_buf[generatedPending++] = (Bytef)((uch)((ush)(generatedBi_buf) >> 8));
								}
								;
							}
							;
							s.setBi_buf((ush)val >> (16 - generatedBi_valid));
							generatedBi_valid += len - 16;
						} else {
								generatedBi_buf |=  (ush)(count - 11) << generatedBi_valid;
								generatedBi_valid += len;
						} 
					}
					;
			} 
			count = 0;
			prevlen = curlen;
			if (nextlen == 0) {
				;
			}  else if (curlen == nextlen) {
				;
			} else {
					;
			} 
		}
	}
	/* the tree to be scanned */
	public static int bi_reverse(int code, int len) {
		int res = /* its bit length */0;
		do {
			res |=  code & 1;
			;
		} while (--len > 0);
		return res >> 1/* ===========================================================================
		 * Flush the bit buffer, keeping at most 7 bits in it.
		 */;
	}
	/* the value to invert */
	/* gzjoin -- command to join gzip files into one gzip file
	
	  Copyright (C) 2004, 2005, 2012 Mark Adler, all rights reserved
	  version 1.2, 14 Aug 2012
	
	  This software is provided 'as-is', without any express or implied
	  warranty.  In no event will the author be held liable for any damages
	  arising from the use of this software.
	
	  Permission is granted to anyone to use this software for any purpose,
	  including commercial applications, and to alter it and redistribute it
	  freely, subject to the following restrictions:
	
	  1. The origin of this software must not be misrepresented; you must not
	     claim that you wrote the original software. If you use this software
	     in a product, an acknowledgment in the product documentation would be
	     appreciated but is not required.
	  2. Altered source versions must be plainly marked as such, and must not be
	     misrepresented as being the original software.
	  3. This notice may not be removed or altered from any source distribution.
	
	  Mark Adler    madler@alumni.caltech.edu
	 */
	/*
	 * Change history:
	 *
	 * 1.0  11 Dec 2004     - First version
	 * 1.1  12 Jun 2005     - Changed ssize_t to long for portability
	 * 1.2  14 Aug 2012     - Clean up for z_const usage
	 */
	/*
	   gzjoin takes one or more gzip files on the command line and writes out a
	   single gzip file that will uncompress to the concatenation of the
	   uncompressed data from the individual gzip files.  gzjoin does this without
	   having to recompress any of the data and without having to calculate a new
	   crc32 for the concatenated uncompressed data.  gzjoin does however have to
	   decompress all of the input data in order to find the bits in the compressed
	   data that need to be modified to concatenate the streams.
	
	   gzjoin does not do an integrity check on the input gzip files other than
	   checking the gzip header and decompressing the compressed data.  They are
	   otherwise assumed to be complete and correct.
	
	   Each joint between gzip files removes at least 18 bytes of previous trailer
	   and subsequent header, and inserts an average of about three bytes to the
	   compressed data in order to connect the streams.  The output gzip file
	   has a minimal ten-byte gzip header with no file name or modification time.
	
	   This program was written to illustrate the use of the Z_BLOCK option of
	   inflate() and the crc32_combine() function.  gzjoin will not compile with
	   versions of zlib earlier than 1.2.3.
	 */
	/* fputs(), fprintf(), fwrite(), putc() */
	/* exit(), malloc(), free() */
	/* open() */
	/* close(), read(), lseek() */
	/* crc32(), crc32_combine(), inflateInit2(), inflate(), inflateEnd() */
	/* exit with an error (return a value to allow use in an expression) */
	public static int bail(Byte why1, Byte why2) {
		.fprintf((_iob[2]), "gzjoin error: %s%s, output incomplete\n", why1, why2);
		.exit(1);
		return 0/* -- simple buffered file input with access to the buffer -- */;
	}
	/* close a buffered file and free allocated memory */
	public static void bclose() {
		Object generatedFd = this.getFd();
		Object generatedBuf = this.getBuf();
		if (in != ((Object)0)) {
			if (generatedFd != -1) {
				ModernizedCProgram.close(generatedFd);
			} 
			if (generatedBuf != ((Object)0)) {
				.free(generatedBuf);
			} 
			.free(in);
		} 
	}
	/* open a buffered file for input, return a pointer to type bin, or NULL on
	   failure */
	public static  bopen(Byte name) {
		bin in = new bin();
		in = .malloc();
		if (in == ((Object)0)) {
			return ((Object)0);
		} 
		in.setBuf(.malloc(32768));
		in.setFd(ModernizedCProgram.open(name, 0, 0));
		Object generatedBuf = in.getBuf();
		Object generatedFd = in.getFd();
		if (generatedBuf == ((Object)0) || generatedFd == -1) {
			in.bclose();
			return ((Object)0);
		} 
		in.setLeft(0);
		in.setNext(generatedBuf);
		in.setName(name);
		return in;
	}
	/* load buffer from file, return -1 on read error, 0 or 1 on success, with
	   1 indicating that end-of-file was reached */
	public static int bload() {
		long len;
		if (in == ((Object)0)) {
			return -1;
		} 
		Object generatedLeft = this.getLeft();
		if (generatedLeft != 0) {
			return 0;
		} 
		Object generatedBuf = this.getBuf();
		this.setNext(generatedBuf);
		Object generatedFd = this.getFd();
		do {
			len = (long).read(generatedFd, generatedBuf + generatedLeft, 32768 - generatedLeft);
			if (len < 0) {
				return -1;
			} 
			generatedLeft += (int)len;
		} while (len != 0 && generatedLeft < 32768);
		return len == 0 ? 1 : 0/* get a byte from the file, bail if end of file */;
	}
	/* get a four-byte little-endian unsigned integer from file */
	public static long bget4() {
		long val;
		val = ();
		val += (long)(()) << 8;
		val += (long)(()) << 16;
		val += (long)(()) << 24;
		return val;
	}
	/* skip bytes in file */
	public static void bskip(int skip) {
		if (in == ((Object)/* check pointer */0)) {
			return ;
		} 
		Object generatedLeft = this.getLeft();
		Object generatedNext = this.getNext();
		if (skip <= generatedLeft) {
			generatedLeft -= skip;
			generatedNext += skip;
			return ;
		} 
		skip -= generatedLeft;
		this.setLeft(0);
		Object generatedFd = this.getFd();
		Object generatedBuf = this.getBuf();
		Object generatedName = this.getName();
		if (skip > /* seek past multiples of CHUNK bytes */32768) {
			int left;
			left = skip & (32768 - 1);
			if (left == 0/* exact number of chunks: seek all the way minus one byte to check
			               for end-of-file with a read */) {
				.lseek(generatedFd, skip - 1, 1);
				if (.read(generatedFd, generatedBuf, 1) != 1) {
					ModernizedCProgram.bail("unexpected end of file on ", generatedName);
				} 
				return ;
			} 
			.lseek(generatedFd, skip - left, /* skip the integral chunks, update skip with remainder */1);
			skip = left;
		} 
		/* read more input and skip remainder */in.bload();
		if (skip > generatedLeft) {
			ModernizedCProgram.bail("unexpected end of file on ", generatedName);
		} 
		generatedLeft -= skip;
		generatedNext += skip/* -- end of buffered input functions -- */;
	}
	/* skip the gzip header from file in */
	public static void gzhead() {
		int flags;
		Object generatedName = this.getName();
		if (() != -1024 || () != -1024 || () != /* verify gzip magic header and compression method */8) {
			ModernizedCProgram.bail(generatedName, " is not a valid gzip file");
		} 
		flags = ();
		if ((flags & -1024) != 0) {
			ModernizedCProgram.bail("unknown reserved bits set in ", generatedName);
		} 
		in.bskip(/* skip modification time, extra flags, and os */6);
		if (flags & /* skip extra field if present */4) {
			int len;
			len = ();
			len += (int)(()) << 8;
			in.bskip(len);
		} 
		if (flags & /* skip file name if present */8) {
			while (() != 0) {
				;
			}
		} 
		if (flags & /* skip comment if present */16) {
			while (() != 0) {
				;
			}
		} 
		if (flags & /* skip header crc if present */2) {
			in.bskip(2);
		} 
	}
	/* write a four-byte little-endian unsigned integer to out */
	public static void put4(long val) {
		.putc(val & -1024, out);
		.putc((val >> 8) & -1024, out);
		.putc((val >> 16) & -1024, out);
		.putc((val >> 24) & -1024, out);
	}
	/* Load up zlib stream from buffered input, bail if end of file */
	public static void zpull(Object strm) {
		Object generatedLeft = this.getLeft();
		if (generatedLeft == 0) {
			in.bload();
		} 
		Object generatedName = this.getName();
		if (generatedLeft == 0) {
			ModernizedCProgram.bail("unexpected end of file on ", generatedName);
		} 
		strm.setAvail_in(generatedLeft);
		Object generatedNext = this.getNext();
		strm.setNext_in(generatedNext);
	}
	/* Write header for gzip file to out and initialize trailer. */
	public static void gzinit(long crc, long tot) {
		.fwrite("\x1f\x8b\x08\0\0\0\0\0\0\xff", 1, 10, out);
		crc = ModernizedCProgram.crc32(-1024, 0, 0);
		tot = 0/* Copy the compressed data from name, zeroing the last block bit of the last
		   block if clr is true, and adding empty blocks as needed to get to a byte
		   boundary.  If clr is false, then the last block becomes the last block of
		   the output, and the gzip trailer is written.  crc and tot maintains the
		   crc and length (modulo 2^32) of the output for the trailer.  The resulting
		   gzip file is written to out.  gzinit() must be called before the first call
		   of gzcopy() to write the gzip header and to initialize crc and tot. */;
	}
	public static void gzcopy(Byte name, int clr, long crc, long tot) {
		/* return value from zlib functions */int ret;
		/* where the "last block" bit is in byte */int pos;
		/* true if processing the last block */int last;
		/* buffered input file */bin in = new bin();
		/* start of compressed data in buffer */byte start;
		/* buffer for uncompressed data -- discarded */byte junk;
		/* length of uncompressed data (support > 4 GB) */long len;
		/* zlib inflate stream */z_stream strm = new z_stream();
		in = ModernizedCProgram.bopen(/* open gzip file and skip header */name);
		if (in == ((Object)0)) {
			ModernizedCProgram.bail("could not open ", name);
		} 
		in.gzhead();
		junk = .malloc(/* allocate buffer for uncompressed data and initialize raw inflate
		       stream */32768);
		strm.setZalloc(0);
		strm.setZfree(0);
		strm.setOpaque(0);
		strm.setAvail_in(0);
		strm.setNext_in(0);
		ret = ModernizedCProgram.inflateInit2_((strm), (true), "1.2.11", (int));
		if (junk == ((Object)0) || ret != 0) {
			ModernizedCProgram.bail("out of memory", "");
		} 
		len = /* inflate and copy compressed data, clear last-block bit if requested */0;
		in.zpull(strm);
		Object generatedNext = in.getNext();
		start = generatedNext;
		last = start[0] & 1;
		if (last && clr) {
			start[0] &=  ~1;
		} 
		strm.setAvail_out(0);
		Object generatedAvail_in = strm.getAvail_in();
		Object generatedAvail_out = strm.getAvail_out();
		Object generatedNext_in = strm.getNext_in();
		Object generatedBuf = in.getBuf();
		Object generatedName = in.getName();
		int generatedData_type = strm.getData_type();
		for (; ; ) {
			if (generatedAvail_in == 0 && generatedAvail_out != /* if input used and output done, write used input and get more */0) {
				.fwrite(start, 1, generatedNext_in - start, out);
				start = generatedBuf;
				in.setLeft(0);
				in.zpull(strm);
			} 
			strm.setAvail_out(/* decompress -- return early when end-of-block reached */32768);
			strm.setNext_out(junk);
			ret = ModernizedCProgram.inflate(strm, 5);
			switch (ret) {
			case (true):
					ModernizedCProgram.bail("invalid compressed data in ", generatedName);
			case (true):
					ModernizedCProgram.bail("out of memory", "");
			}
			len += 32768 - generatedAvail_out;
			if (generatedData_type & /* check for block boundary (only get this when block copied out) */128) {
				if (/* if that was the last block, then done */last) {
					break;
				} 
				pos = generatedData_type & /* number of unused bits in last byte */7;
				if (pos != /* find the next last-block bit */0) {
					pos = -1024 >> /* next last-block bit is in last used byte */pos;
					last = generatedNext_in[-1] & pos;
					if (last && clr) {
						generatedBuf[generatedNext_in - generatedBuf - 1] &=  ~pos;
					} 
				} else {
						if (generatedAvail_in == /* next last-block bit is in next unused byte */0) {
							.fwrite(start, 1, generatedNext_in - start, /* don't have that byte yet -- get it */out);
							start = generatedBuf;
							in.setLeft(0);
							in.zpull(strm);
						} 
						last = generatedNext_in[0] & 1;
						if (last && clr) {
							generatedBuf[generatedNext_in - generatedBuf] &=  ~1;
						} 
				} 
			} 
		}
		in.setLeft(generatedAvail_in);
		in.setNext(generatedBuf + (generatedNext_in - generatedBuf));
		pos = generatedData_type & /* copy used input, write empty blocks to get to byte boundary */7;
		.fwrite(start, 1, generatedNext - start - 1, out);
		last = generatedNext[-1];
		if (pos == 0 || !clr) {
			.putc(last, /* already at byte boundary, or last file: write last byte */out);
		} else {
				last &=  ((-1024 >> pos) - /* append empty blocks to last byte *//* assure unused bits are zero */1);
				if (pos & 1) {
					.putc(last, /* odd -- append an empty stored block */out);
					if (pos == 1) {
						.putc(0, /* two more bits in block header */out);
					} 
					.fwrite("\0\0\xff\xff", 1, 4, out);
				} else {
						switch (/* even -- append 1, 2, or 3 empty fixed blocks */pos) {
						case 4:
								.putc(last | -1024, out);
								last = 0;
						case 6:
								.putc(last | 8, out);
								last = 0;
						case 2:
								.putc(last | -1024, out);
								.putc(0, out);
						}
				} 
		} 
		crc = ModernizedCProgram.crc32_combine(crc, in.bget4(), /* update crc and tot */len);
		tot += (long)len;
		ModernizedCProgram.inflateEnd(/* clean up */strm);
		.free(junk);
		in.bclose();
		if (!/* write trailer if this is the last gzip file */clr) {
			out.put4(crc);
			out.put4(tot);
		} 
	}
	/* join the gzip files on the command line, write result to stdout */
	public static int main(int argc, byte argv) {
		/* running crc and total uncompressed length */long crc;
		long tot;
		/* skip command name */argc--;
		argv++;
		if (argc == /* show usage if no arguments */0) {
			.fputs("gzjoin usage: gzjoin f1.gz [f2.gz [f3.gz ...]] > fjoin.gz\n", (_iob[2]));
			return 0;
		} 
		(_iob[/* join gzip files on command line and write to stdout */1]).gzinit(crc, tot);
		while (argc--) {
			(_iob[1]).gzcopy(argv++, argc, crc, tot);
		}
		return /* done */0;
		byte[] rs = new byte[]{0};
		int res = ModernizedCProgram.main2(numArgs, args, rs);
		.fputs(rs, (_iob[1]));
		return res;
		int BlockSizeCompress = -1024;
		int BlockSizeUncompress = -1024;
		int cprLevel = (true);
		long lFileSize;
		byte FilePtr;
		long lBufferSizeCpr;
		long lBufferSizeUncpr;
		long lCompressedSize = 0;
		byte CprPtr;
		byte UncprPtr;
		long lSizeCpr;
		long lSizeUncpr;
		DWORD dwGetTick = new DWORD();
		DWORD dwMsecQP = new DWORD();
		LARGE_INTEGER li_qp = new LARGE_INTEGER();
		LARGE_INTEGER li_rdtsc = new LARGE_INTEGER();
		LARGE_INTEGER dwResRdtsc = new LARGE_INTEGER();
		if (argc <= 1) {
			.printf("run TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [compres. level]\n");
			return 0;
		} 
		if (ModernizedCProgram.ReadFileMemory(argv[1], lFileSize, FilePtr) == 0) {
			.printf("error reading %s\n", argv[1]);
			return 1;
		} else {
				.printf("file %s read, %u bytes\n", argv[1], lFileSize);
		} 
		if (argc >= 3) {
			BlockSizeCompress = .atol(argv[2]);
		} 
		if (argc >= 4) {
			BlockSizeUncompress = .atol(argv[3]);
		} 
		if (argc >= 5) {
			cprLevel = (int).atol(argv[4]);
		} 
		lBufferSizeCpr = lFileSize + (lFileSize / -1024) + -1024;
		lBufferSizeUncpr = lBufferSizeCpr;
		CprPtr = (byte).malloc(lBufferSizeCpr + BlockSizeCompress);
		li_qp.BeginCountPerfCounter(1);
		dwGetTick = .GetTickCount();
		li_rdtsc.BeginCountRdtsc();
		Object generatedTotal_in = zcpr.getTotal_in();
		Object generatedAvail_in = zcpr.getAvail_in();
		Object generatedTotal_out = zcpr.getTotal_out();
		Object generatedQuadPart = dwResRdtsc.getQuadPart();
		{ 
			z_stream zcpr = new z_stream();
			int ret = 0;
			long lOrigToDo = lFileSize;
			long lOrigDone = 0;
			int step = 0;
			.memset(zcpr, 0, );
			ModernizedCProgram.deflateInit_((zcpr), (cprLevel), "1.2.11", (int));
			zcpr.setNext_in(FilePtr);
			zcpr.setNext_out(CprPtr);
			do {
				long all_read_before = generatedTotal_in;
				zcpr.setAvail_in(((lOrigToDo) < (BlockSizeCompress) ? (lOrigToDo) : (BlockSizeCompress)));
				zcpr.setAvail_out(BlockSizeCompress);
				ret = ModernizedCProgram.deflate(zcpr, (generatedAvail_in == lOrigToDo) ? 4 : 2);
				lOrigDone += (generatedTotal_in - all_read_before);
				lOrigToDo -= (generatedTotal_in - all_read_before);
				step++;
			} while (ret == 0);
			lSizeCpr = generatedTotal_out;
			ModernizedCProgram.deflateEnd(zcpr);
			dwGetTick = .GetTickCount() - dwGetTick;
			dwMsecQP = li_qp.GetMsecSincePerfCounter(1);
			dwResRdtsc = li_rdtsc.GetResRdtsc(1);
			.printf("total compress size = %u, in %u step\n", lSizeCpr, step);
			.printf("time = %u msec = %f sec\n", dwGetTick, dwGetTick / (double)1000.0);
			.printf("defcpr time QP = %u msec = %f sec\n", dwMsecQP, dwMsecQP / (double)1000.0);
			.printf("defcpr result rdtsc = %I64x\n\n", generatedQuadPart);
		}
		CprPtr = (byte).realloc(CprPtr, lSizeCpr);
		UncprPtr = (byte).malloc(lBufferSizeUncpr + BlockSizeUncompress);
		li_qp.BeginCountPerfCounter(1);
		dwGetTick = .GetTickCount();
		li_rdtsc.BeginCountRdtsc();
		{ 
			z_stream zcpr = new z_stream();
			int ret = 0;
			long lOrigToDo = lSizeCpr;
			long lOrigDone = 0;
			int step = 0;
			.memset(zcpr, 0, );
			ModernizedCProgram.inflateInit_((zcpr), "1.2.11", (int));
			zcpr.setNext_in(CprPtr);
			zcpr.setNext_out(UncprPtr);
			do {
				long all_read_before = generatedTotal_in;
				zcpr.setAvail_in(((lOrigToDo) < (BlockSizeUncompress) ? (lOrigToDo) : (BlockSizeUncompress)));
				zcpr.setAvail_out(BlockSizeUncompress);
				ret = ModernizedCProgram.inflate(zcpr, 2);
				lOrigDone += (generatedTotal_in - all_read_before);
				lOrigToDo -= (generatedTotal_in - all_read_before);
				step++;
			} while (ret == 0);
			lSizeUncpr = generatedTotal_out;
			ModernizedCProgram.inflateEnd(zcpr);
			dwGetTick = .GetTickCount() - dwGetTick;
			dwMsecQP = li_qp.GetMsecSincePerfCounter(1);
			dwResRdtsc = li_rdtsc.GetResRdtsc(1);
			.printf("total uncompress size = %u, in %u step\n", lSizeUncpr, step);
			.printf("time = %u msec = %f sec\n", dwGetTick, dwGetTick / (double)1000.0);
			.printf("uncpr  time QP = %u msec = %f sec\n", dwMsecQP, dwMsecQP / (double)1000.0);
			.printf("uncpr  result rdtsc = %I64x\n\n", generatedQuadPart);
		}
		if (lSizeUncpr == lFileSize) {
			if (.memcmp(FilePtr, UncprPtr, lFileSize) == 0) {
				.printf("compare ok\n");
			} 
		} 
		return 0;
		// this increases the size on windows dos boxes// this increases the size on windows dos boxesModernizedCProgram.setup_console();
		time_t proc_start = .time(((Object)0));
		// hashcat main context
		hashcat_ctx_t hashcat_ctx = (hashcat_ctx_t)ModernizedCProgram.hcmalloc();
		if (hashcat_ctx.hashcat_init(event) == -1) {
			ModernizedCProgram.hcfree(hashcat_ctx);
			return -1;
		} 
		byte install_folder = ((Object)0);
		byte shared_folder = ((Object)0);
		// initialize the user options with some defaults (you can override them later)if (hashcat_ctx.user_options_init() == -1) {
			ModernizedCProgram.hcfree(hashcat_ctx);
			return -1;
		} 
		// parse commandline parameters and check themif (hashcat_ctx.user_options_getopt(argc, argv) == -1) {
			ModernizedCProgram.hcfree(hashcat_ctx);
			return -1;
		} 
		if (hashcat_ctx.user_options_sanity() == -1) {
			ModernizedCProgram.hcfree(hashcat_ctx);
			return -1;
		} 
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		// some early exitsuser_options_t user_options = generatedUser_options;
		boolean generatedVersion = user_options.getVersion();
		if (generatedVersion == true) {
			.printf("%s\n", VERSION_TAG);
			ModernizedCProgram.hcfree(hashcat_ctx);
			return 0;
		} 
		// init a hashcat session; this initializes backend devices, hwmon, etc// init a hashcat session; this initializes backend devices, hwmon, etchashcat_ctx.welcome_screen(VERSION_TAG);
		int rc_final = -1;
		boolean generatedUsage = user_options.getUsage();
		boolean generatedExample_hashes = user_options.getExample_hashes();
		boolean generatedBackend_info = user_options.getBackend_info();
		if (hashcat_ctx.hashcat_session_init(install_folder, shared_folder, argc, argv, COMPTIME) == 0) {
			if (generatedUsage == true) {
				hashcat_ctx.usage_big_print();
				rc_final = 0;
			}  else if (generatedExample_hashes == true) {
				hashcat_ctx.example_hashes();
				rc_final = 0;
			}  else if (generatedBackend_info == true) {
				hashcat_ctx.backend_info();
				rc_final = 0;
			} else {
					hashcat_ctx.backend_info_compact();
					hashcat_ctx.user_options_info();
					rc_final = hashcat_ctx.hashcat_session_execute();
			} 
		} 
		// finish the hashcat session, this shuts down backend devices, hwmon, etc// finish the hashcat session, this shuts down backend devices, hwmon, etchashcat_ctx.hashcat_session_destroy()// finished with hashcat, clean up;// finished with hashcat, clean up
		time_t proc_stop = .time(((Object)0));
		hashcat_ctx.goodbye_screen(proc_start, proc_stop);
		hashcat_ctx.hashcat_destroy();
		ModernizedCProgram.hcfree(hashcat_ctx);
		return rc_final;
		int ret;
		int len;
		int test;
		byte outname;
		byte window;
		z_stream strm = new z_stream();
		window = /* initialize inflateBack state for repeated use *//* reuse LZW match buffer */ModernizedCProgram.match;
		strm.setZalloc(0);
		strm.setZfree(0);
		strm.setOpaque(0);
		ret = ModernizedCProgram.inflateBackInit_((strm), (true), (window), "1.2.11", (int));
		if (ret != 0) {
			.fprintf((_iob[2]), "gun out of memory error--aborting\n");
			return 1;
		} 
		/* decompress each file to the same name with the suffix removed */argc--;
		argv++;
		test = 0;
		if (argc && .strcmp(argv, "-h") == 0) {
			.fprintf((_iob[2]), "gun 1.6 (17 Jan 2010)\n");
			.fprintf((_iob[2]), "Copyright (C) 2003-2010 Mark Adler\n");
			.fprintf((_iob[2]), "usage: gun [-t] [file1.gz [file2.Z ...]]\n");
			return 0;
		} 
		if (argc && .strcmp(argv, "-t") == 0) {
			test = 1;
			argc--;
			argv++;
		} 
		if (argc) {
			do {
				if (test) {
					outname = ((Object)0);
				} else {
						len = (int).strlen(argv);
						if (.strcmp(argv + len - 3, ".gz") == 0 || .strcmp(argv + len - 3, "-gz") == 0) {
							len -= 3;
						}  else if (.strcmp(argv + len - 2, ".z") == 0 || .strcmp(argv + len - 2, "-z") == 0 || .strcmp(argv + len - 2, "_z") == 0 || .strcmp(argv + len - 2, ".Z") == 0) {
							len -= 2;
						} else {
								.fprintf((_iob[2]), "gun error: no gz type on %s--skipping\n", argv);
								continue;
						} 
						outname = .malloc(len + 1);
						if (outname == ((Object)0)) {
							.fprintf((_iob[2]), "gun out of memory error--aborting\n");
							ret = 1;
							break;
						} 
						.memcpy(outname, argv, len);
						outname[len] = 0;
				} 
				ret = strm.gunzip(argv, outname, test);
				if (outname != ((Object)0)) {
					.free(outname);
				} 
				if (ret) {
					break;
				} 
			} while ();
		} else {
				ret = strm.gunzip(((Object)0), ((Object)0), test);
		} 
		ModernizedCProgram.inflateBackEnd(/* clean up */strm);
		return ret;
		int ret;
		.setmode((((_iob[0])).get_file()), /* avoid end-of-line conversions */-1024);
		.setmode((((_iob[1])).get_file()), -1024);
		if (argc == /* do compression if no arguments */1) {
			ret = (_iob[0]).def((_iob[1]), (true));
			if (ret != 0) {
				ModernizedCProgram.zerr(ret);
			} 
			return ret;
		}  else if (argc == 2 && .strcmp(argv[1], "-d") == /* do decompression if -d specified */0) {
			ret = (_iob[0]).inf((_iob[1]));
			if (ret != 0) {
				ModernizedCProgram.zerr(ret);
			} 
			return ret;
		} else {
				.fputs("zpipe usage: zpipe [-d] < source > dest\n", (_iob[/* otherwise, report usage */2]));
				return 1;
		} 
		.fprintf((_iob[2]), "%s\n", ModernizedCProgram.zlibVersion());
		ModernizedCProgram.cover_support();
		ModernizedCProgram.cover_wrap();
		ModernizedCProgram.cover_back();
		ModernizedCProgram.cover_inflate();
		ModernizedCProgram.cover_trees();
		ModernizedCProgram.cover_fast();
		return 0;
		int ret;
		int put = 0;
		int fail = 0;
		int skip = 0;
		byte arg;
		byte name = ((Object)0);
		byte source = ((Object)0);
		byte dest;
		size_t len = 0;
		long sourcelen;
		long destlen;
		while () {
			if (arg[0] == (byte)'-') {
				if (arg[1] == (byte)'w' && arg[2] == 0) {
					put = 1;
				}  else if (arg[1] == (byte)'f' && arg[2] == 0) {
					;
				}  else if (arg[1] >= (byte)'0' && arg[1] <= (byte)'9') {
					skip = (int).atoi(arg + 1);
				} else {
						.fprintf((_iob[2]), "invalid option %s\n", arg);
						return 3;
				} 
			}  else if (name != ((Object)0)) {
				.fprintf((_iob[2]), "only one file name allowed\n");
				return 3;
			} else {
					name = arg;
			} 
		}
		source = ModernizedCProgram.load(name, len);
		if (source == ((Object)0)) {
			.fprintf((_iob[2]), "memory allocation failure\n");
			return 4;
		} 
		if (len == 0) {
			.fprintf((_iob[2]), "could not read %s, or it was empty\n", name == ((Object)0) ? "<stdin>" : name);
			.free(source);
			return 3;
		} 
		if (skip >= len) {
			.fprintf((_iob[2]), "skip request of %d leaves no input\n", skip);
			.free(source);
			return 3;
		} 
		len -= /* test inflate data with offset skip */skip;
		sourcelen = (long)len;
		ret = ModernizedCProgram.puff(((byte)0), destlen, source + skip, sourcelen);
		if (ret) {
			.fprintf((_iob[2]), "puff() failed with return code %d\n", ret);
		} else {
				.fprintf((_iob[2]), "puff() succeeded uncompressing %lu bytes\n", destlen);
				if (sourcelen < len) {
					.fprintf((_iob[2]), "%lu compressed bytes unused\n", len - sourcelen);
				} 
		} 
		if (put && ret == /* if requested, inflate again and write decompressd data to stdout */0) {
			if (fail) {
				destlen >>=  1;
			} 
			dest = .malloc(destlen);
			if (dest == ((Object)0)) {
				.fprintf((_iob[2]), "memory allocation failure\n");
				.free(source);
				return 4;
			} 
			ModernizedCProgram.puff(dest, destlen, source + skip, sourcelen);
			.setmode((((_iob[1])).get_file()), -1024);
			.fwrite(dest, 1, destlen, (_iob[1]));
			.free(dest);
		} 
		.free(/* clean up */source);
		return ret;
		/* total number of symbols to code */int syms;
		/* number of symbols to code for this run */int n;
		/* return value of count() */big_t got = new big_t();
		/* accumulated number of codes over n */big_t sum = new big_t();
		/* for counting bits in code_t */code_t word = new code_t();
		ModernizedCProgram.code = ((Object)/* set up globals for cleanup() */0);
		ModernizedCProgram.num = ((Object)0);
		ModernizedCProgram.done = ((Object)0);
		syms = /* get arguments -- default to the deflate literal/length code */286;
		ModernizedCProgram.root = 9;
		ModernizedCProgram.max = 15;
		if (argc > 1) {
			syms = .atoi(argv[1]);
			if (argc > 2) {
				ModernizedCProgram.root = .atoi(argv[2]);
				if (argc > 3) {
					ModernizedCProgram.max = .atoi(argv[3]);
				} 
			} 
		} 
		if (argc > 4 || syms < 2 || ModernizedCProgram.root < 1 || ModernizedCProgram.max < 1) {
			.fputs("invalid arguments, need: [sym >= 2 [root >= 1 [max >= 1]]]\n", (_iob[2]));
			return 1;
		} 
		if (ModernizedCProgram.max > syms - /* if not restricting the code length, the longest is syms - 1 */1) {
			ModernizedCProgram.max = syms - 1;
		} 
		for (; word; ) {
			;
		}
		if (ModernizedCProgram.max > n || (code_t)(syms - 2) >= (((code_t)0 - 1) >> (ModernizedCProgram.max - /* make sure that the calculation of most will not overflow */1))) {
			.fputs("abort: code length too long for internal types\n", (_iob[2]));
			return 1;
		} 
		if ((code_t)(syms - 1) > ((code_t)1 << ModernizedCProgram.max) - /* reject impossible code requests */1) {
			.fprintf((_iob[2]), "%d symbols cannot be coded in %d bits\n", syms, ModernizedCProgram.max);
			return 1;
		} 
		ModernizedCProgram.code = .calloc(ModernizedCProgram.max + 1, /* allocate code vector */);
		if (ModernizedCProgram.code == ((Object)0)) {
			.fputs("abort: unable to allocate enough memory\n", (_iob[2]));
			return 1;
		} 
		if (syms == /* determine size of saved results array, checking for overflows,
		       allocate and clear the array (set all to zero with calloc()) *//* iff max == 1 */2) {
			ModernizedCProgram.num = ((Object)/* won't be saving any results */0);
		} else {
				ModernizedCProgram.size = syms >> 1;
				if (ModernizedCProgram.size > ((size_t)0 - 1) / (n = (syms - 1) >> 1) || () || () || (ModernizedCProgram.num = .calloc(ModernizedCProgram.size, )) == ((Object)0)) {
					.fputs("abort: unable to allocate enough memory\n", (_iob[2]));
					ModernizedCProgram.cleanup();
					return 1;
				} 
		} 
		sum = /* count possible codes for all numbers of symbols, add up counts */0;
		for (n = 2; n <= syms; n++) {
			got = ModernizedCProgram.count(n, 1, 2);
			sum += got;
			if (got == (big_t)0 - 1 || sum < /* overflow */got) {
				.fputs("abort: can't count that high!\n", (_iob[2]));
				ModernizedCProgram.cleanup();
				return 1;
			} 
			.printf("%llu %d-codes\n", got, n);
		}
		.printf("%llu total codes for 2 to %d symbols", sum, syms);
		if (ModernizedCProgram.max < syms - 1) {
			.printf(" (%d-bit length limit)\n", ModernizedCProgram.max);
		} else {
				.puts(" (no length limit)");
		} 
		if (syms == /* allocate and clear done array for beenhere() */2) {
			ModernizedCProgram.done = ((Object)0);
		}  else if (ModernizedCProgram.size > ((size_t)0 - 1) /  || (ModernizedCProgram.done = .calloc(ModernizedCProgram.size, )) == ((Object)0)) {
			.fputs("abort: unable to allocate enough memory\n", (_iob[2]));
			ModernizedCProgram.cleanup();
			return 1;
		} 
		if (ModernizedCProgram.root > /* find and show maximum inflate table usage *//* reduce root to max length */ModernizedCProgram.max) {
			ModernizedCProgram.root = ModernizedCProgram.max;
		} 
		if ((code_t)syms < ((code_t)1 << (ModernizedCProgram.root + 1))) {
			ModernizedCProgram.enough(syms);
		} else {
				.puts("cannot handle minimum code lengths > root");
		} 
		ModernizedCProgram.cleanup();
		return 0;
		int gd;
		int level;
		z_stream strm = new z_stream();
		argc--;
		/* ignore command name */argv++;
		if (argv == ((Object)/* provide usage if no arguments */0)) {
			.printf("gzappend 1.2 (11 Oct 2012) Copyright (C) 2003, 2012 Mark Adler\n");
			.printf("usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\n");
			return 0;
		} 
		level = (/* set compression level */true);
		if (argv[0][0] == (byte)'-') {
			if (argv[0][1] < (byte)'0' || argv[0][1] > (byte)'9' || argv[0][2] != 0) {
				ModernizedCProgram.bye("invalid compression level", "");
			} 
			level = argv[0][1] - (byte)'0';
			if (++argv == ((Object)0)) {
				ModernizedCProgram.bye("no gzip file name after options", "");
			} 
		} 
		gd = strm.gzscan(argv++, /* prepare to append to gzip file */level);
		if (argv == ((Object)/* append files on command line, or from stdin if none */0)) {
			strm.gztack(((Object)0), gd, 1);
		} else {
				do {
					strm.gztack(argv, gd, argv[1] == ((Object)0));
				} while (++argv != ((Object)0));
		} 
		return 0;
		// Construct a stream object with this filebuffer.  Anything sent// to this stream will go to standard out.gzofstream os = ;
		// This text is getting compressed and sent to stdout.
		// To prove this, run 'test | zcat'.// To prove this, run 'test | zcat'.os << "Hello, Mommy" << endl;
		os << ModernizedCProgram.setcompressionlevel(0);
		os << "hello, hello, hi, ho!" << endl;
		ModernizedCProgram.setcompressionlevel(os, (true)) << "I'm compressing again" << endl;
		.UNRECOGNIZEDFUNCTIONNAME();
		return 0;
		byte[] h = "Hello";
		byte g = "Goodbye";
		ozstream out = ;
		out < "This works well" < h < g;
		.UNRECOGNIZEDFUNCTIONNAME();
		// read it backizstream in = ;
		byte x = .read_string(in);
		byte y = ;
		byte[] z = new byte[256];
		in > y > z;
		.UNRECOGNIZEDFUNCTIONNAME();
		cout << x << endl << y << endl << z << endl;
		// try ascii output; zcat temp.gz to see the results// try ascii output; zcat temp.gz to see the results.UNRECOGNIZEDFUNCTIONNAME("temp.gz");
		out << .setw(50) << .setfill((byte)'#') << .setprecision(20) << x << endl << y << endl << z << endl;
		out << z << endl << y << endl << x << endl;
		out << 1.1234567890123457 << endl;
		;
		;
		int i;
		int filenamesStart = 0;
		byte exename = argv[0];
		U32 benchmarkMode = 0;
		U32 fileCheckMode = 0;
		U32 strictMode = 0;
		U32 statusOnly = 0;
		U32 warn = 0;
		U32 quiet = 0;
		U32 specificTest = 0;
		size_t keySize = ModernizedCProgram.XXH_DEFAULT_SAMPLE_SIZE;
		algoType algo = ModernizedCProgram.g_defaultAlgo;
		endianess displayEndianess = .big_endian;
		if (.strstr(exename, "xxh32sum") != ((Object)0)) {
			algo = /* special case : xxh32sum default to 32 bits checksum */.algo_xxh32;
		} 
		for (i = 1; i < argc; i++) {
			byte argument = argv[i];
			if (!/* Protection, if argument empty */argument) {
				continue;
			} 
			if (!.strcmp(argument, "--little-endian")) {
				displayEndianess = .little_endian;
				continue;
			} 
			if (!.strcmp(argument, "--check")) {
				fileCheckMode = 1;
				continue;
			} 
			if (!.strcmp(argument, "--strict")) {
				strictMode = 1;
				continue;
			} 
			if (!.strcmp(argument, "--status")) {
				statusOnly = 1;
				continue;
			} 
			if (!.strcmp(argument, "--quiet")) {
				quiet = 1;
				continue;
			} 
			if (!.strcmp(argument, "--warn")) {
				warn = 1;
				continue;
			} 
			if (!.strcmp(argument, "--help")) {
				return ModernizedCProgram.usage_advanced(exename);
			} 
			if (!.strcmp(argument, "--version")) {
				.fprintf((_iob[2]), "%s %s (%i-bits %s), by %s \n", exename, "0.6.5", ModernizedCProgram.g_nbBits, (ModernizedCProgram.BMK_isLittleEndian() ? ModernizedCProgram.g_lename : ModernizedCProgram.g_bename), ModernizedCProgram.author);
				return 0;
			} 
			if (argument != (byte)'-') {
				if (filenamesStart == 0) {
					filenamesStart = /* only supports a continuous list of filenames */i;
				} 
				continue;
			} 
			/* command selection *//* note : *argument=='-' */argument++;
			while (argument != 0) {
				switch (argument) {
				case /* Modify Nb Iterations (benchmark only) */(byte)'i':
						argument++;
						ModernizedCProgram.g_nbIterations = ModernizedCProgram.readU32FromChar(argument);
						break;
				case /* Display help on usage */(byte)'h':
						return ModernizedCProgram.usage_advanced(exename);
				case /* Modify Block size (benchmark only) */(byte)'B':
						argument++;
						keySize = ModernizedCProgram.readU32FromChar(argument);
						break;
				case /* Warning mode (file check mode only, alias of "--warning") */(byte)'w':
						warn = 1;
						argument++;
						break;
				case /* File check mode */(byte)'c':
						fileCheckMode = 1;
						argument++;
						break;
				case /* Display version */(byte)'V':
						.fprintf((_iob[2]), "%s %s (%i-bits %s), by %s \n", exename, "0.6.5", ModernizedCProgram.g_nbBits, (ModernizedCProgram.BMK_isLittleEndian() ? ModernizedCProgram.g_lename : ModernizedCProgram.g_bename), ModernizedCProgram.author);
						return 0;
				case /* select hash algorithm */(byte)'H':
						algo = (algoType)(argument[1] - (byte)'0');
						argument += 2;
						break;
				case /* Modify verbosity of benchmark output (hidden option) */(byte)'q':
						argument++;
						ModernizedCProgram.g_displayLevel--;
						break;
				case /* Trigger benchmark mode */(byte)'b':
						argument++;
						benchmarkMode = 1;
						specificTest = ModernizedCProgram.readU32FromChar(/* select one specific test (hidden option) */argument);
						break;
				default:
						return ModernizedCProgram.badusage(exename);
				}
			}
		}
		if (/* for(i=1; i<argc; i++) *//* Check benchmark mode */benchmarkMode) {
			do {
				if (ModernizedCProgram.g_displayLevel >= 2) {
					.fprintf((_iob[2]), "%s %s (%i-bits %s), by %s \n", exename, "0.6.5", ModernizedCProgram.g_nbBits, (ModernizedCProgram.BMK_isLittleEndian() ? ModernizedCProgram.g_lename : ModernizedCProgram.g_bename), ModernizedCProgram.author);
				} 
			} while (0);
			ModernizedCProgram.BMK_sanityCheck();
			if (filenamesStart == 0) {
				return ModernizedCProgram.BMK_benchInternal(keySize, specificTest);
			} 
			return ModernizedCProgram.BMK_benchFiles(argv + filenamesStart, argc - filenamesStart, specificTest);
		} 
		if ((filenamesStart == 0) && ._isatty((((_iob[0])).get_file()))) {
			return ModernizedCProgram.badusage(/* Check if input is defined as console; trigger an error in this case */exename);
		} 
		if (filenamesStart == 0) {
			filenamesStart = argc;
		} 
		if (fileCheckMode) {
			return ModernizedCProgram.checkFiles(argv + filenamesStart, argc - filenamesStart, displayEndianess, strictMode, statusOnly, warn, quiet);
		} else {
				return ModernizedCProgram.BMK_hashFiles(argv + filenamesStart, argc - filenamesStart, algo, displayEndianess/* XXHASH_C_2097394837 */);
		} 
		/* return code */int ret;
		/* requested fixed output block size */int size;
		/* bytes written by deflate() call */int have;
		/* intermediate and final stream */byte blk;
		/* close to desired size stream */byte tmp;
		/* zlib deflate and inflate states */z_stream def = new z_stream();
		z_stream inf = new z_stream();
		if (argc != /* get requested output size */2) {
			ModernizedCProgram.quit("need one argument: size of output block");
		} 
		ret = .strtol(argv[1], argv + 1, 10);
		if (argv[1][0] != 0) {
			ModernizedCProgram.quit("argument must be a number");
		} 
		if (ret < /* 8 is minimum zlib stream size */8) {
			ModernizedCProgram.quit("need positive size of 8 or greater");
		} 
		size = (int)ret;
		blk = .malloc(size + /* allocate memory for buffers and compression engine */256);
		def.setZalloc(0);
		def.setZfree(0);
		def.setOpaque(0);
		ret = ModernizedCProgram.deflateInit_((def), ((true)), "1.2.11", (int));
		if (ret != 0 || blk == ((Object)0)) {
			ModernizedCProgram.quit("out of memory");
		} 
		def.setAvail_out(size + /* compress from stdin until output full, or no more input */256);
		def.setNext_out(blk);
		ret = (_iob[0]).partcompress(def);
		if (ret == (true)) {
			ModernizedCProgram.quit("error reading input");
		} 
		Object generatedAvail_out = def.getAvail_out();
		if (ret == 1 && generatedAvail_out >= /* if it all fit, then size was undersubscribed -- done! */256) {
			have = size + 256 - generatedAvail_out;
			if (.fwrite(blk, 1, have, (_iob[1])) != have || (((_iob[1])).get_flag() & -1024)) {
				ModernizedCProgram.quit("error writing output");
			} 
			ret = ModernizedCProgram.deflateEnd(/* clean up and print results to stderr */def);
			((ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\fitblk.c", 171));
			.free(blk);
			.fprintf((_iob[2]), "%u bytes unused out of %u requested (all input)\n", size - have, size);
			return 0;
		} 
		inf.setZalloc(/* it didn't all fit -- set up for recompression */0);
		inf.setZfree(0);
		inf.setOpaque(0);
		inf.setAvail_in(0);
		inf.setNext_in(0);
		ret = ModernizedCProgram.inflateInit_((inf), "1.2.11", (int));
		tmp = .malloc(size + 256);
		if (ret != 0 || tmp == ((Object)0)) {
			ModernizedCProgram.quit("out of memory");
		} 
		ret = ModernizedCProgram.deflateReset(def);
		((ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\fitblk.c", 190));
		inf.setAvail_in(size + /* do first recompression close to the right amount */256);
		inf.setNext_in(blk);
		def.setAvail_out(size + 256);
		def.setNext_out(tmp);
		ret = ModernizedCProgram.recompress(inf, def);
		if (ret == (true)) {
			ModernizedCProgram.quit("out of memory");
		} 
		ret = ModernizedCProgram.inflateReset(/* set up for next reocmpression */inf);
		((ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\fitblk.c", 203));
		ret = ModernizedCProgram.deflateReset(def);
		((ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\fitblk.c", 205));
		inf.setAvail_in(size - /* do second and final recompression (third compression) *//* assure stream will complete */8);
		inf.setNext_in(tmp);
		def.setAvail_out(size);
		def.setNext_out(blk);
		ret = ModernizedCProgram.recompress(inf, def);
		if (ret == (true)) {
			ModernizedCProgram.quit("out of memory");
		} 
		((ret == 1) ? (Object)0 : ._assert("ret == Z_STREAM_END", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\fitblk.c", /* otherwise MARGIN too small */215));
		have = size - generatedAvail_out;
		if (.fwrite(blk, 1, have, (_iob[1])) != have || (((_iob[1])).get_flag() & -1024)) {
			ModernizedCProgram.quit("error writing output");
		} 
		.free(/* clean up and print results to stderr */tmp);
		ret = ModernizedCProgram.inflateEnd(inf);
		((ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\fitblk.c", 225));
		ret = ModernizedCProgram.deflateEnd(def);
		((ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\fitblk.c", 227));
		.free(blk);
		Object generatedTotal_in = def.getTotal_in();
		.fprintf((_iob[2]), "%u bytes unused out of %u requested (%lu input)\n", size - have, size, generatedTotal_in);
		return 0;
		int i;
		int opt_overwrite = 0;
		int opt_compress_level = (true);
		int opt_exclude_path = 0;
		int zipfilenamearg = 0;
		byte[] filename_try = new byte[(true) + 16];
		int zipok;
		int err = 0;
		int size_buf = 0;
		Object buf = ((Object)0);
		byte password = ((Object)0);
		ModernizedCProgram.do_banner();
		if (argc == 1) {
			ModernizedCProgram.do_help();
			return 0;
		} else {
				for (i = 1; i < argc; i++) {
					if ((argv[i]) == (byte)'-') {
						byte p = argv[i] + 1;
						while ((p) != (byte)'\0') {
							byte c = (p++);
							;
							if ((c == (byte)'o') || (c == (byte)'O')) {
								opt_overwrite = 1;
							} 
							if ((c == (byte)'a') || (c == (byte)'A')) {
								opt_overwrite = 2;
							} 
							if ((c >= (byte)'0') && (c <= (byte)'9')) {
								opt_compress_level = c - (byte)'0';
							} 
							if ((c == (byte)'j') || (c == (byte)'J')) {
								opt_exclude_path = 1;
							} 
							if (((c == (byte)'p') || (c == (byte)'P')) && (i + 1 < argc)) {
								password = argv[i + 1];
								i++;
							} 
						}
					} else {
							if (zipfilenamearg == 0) {
								zipfilenamearg = i;
							} 
					} 
				}
		} 
		size_buf = (true);
		buf = (Object).malloc(size_buf);
		if (buf == ((Object)0)) {
			.printf("Error allocating memory\n");
			return (true);
		} 
		if (zipfilenamearg == 0) {
			zipok = 0;
		} else {
				int i;
				int len;
				int dot_found = 0;
				zipok = 1;
				.strncpy(filename_try, argv[zipfilenamearg], (true) - 1);
				filename_try[(true)] = /* strncpy doesnt append the trailing NULL, of the string is too long. */(byte)'\0';
				len = (int).strlen(filename_try);
				for (i = 0; i < len; i++) {
					if (filename_try[i] == (byte)'.') {
						dot_found = 1;
					} 
				}
				if (dot_found == 0) {
					.strcat(filename_try, ".zip");
				} 
				if (opt_overwrite == 2) {
					if (ModernizedCProgram.check_exist_file(filename_try) == /* if the file don't exist, we not append file */0) {
						opt_overwrite = 1;
					} 
				}  else if (opt_overwrite == 0) {
					if (ModernizedCProgram.check_exist_file(filename_try) != 0) {
						byte rep = 0;
						do {
							byte[] answer = new byte[128];
							int ret;
							.printf("The file %s exists. Overwrite ? [y]es, [n]o, [a]ppend : ", filename_try);
							ret = .scanf("%1s", answer);
							if (ret != 1) {
								.exit(1);
							} 
							rep = answer[0];
							if ((rep >= (byte)'a') && (rep <= (byte)'z')) {
								rep -= -1024;
							} 
						} while ((rep != (byte)'Y') && (rep != (byte)'N') && (rep != (byte)'A'));
						if (rep == (byte)'N') {
							zipok = 0;
						} 
						if (rep == (byte)'A') {
							opt_overwrite = 2;
						} 
					} 
				} 
		} 
		Object generatedTmz_date = zi.getTmz_date();
		Object generatedDosDate = zi.getDosDate();
		Object generated_flag = (fin).get_flag();
		if (zipok == 1) {
			zipFile zf = new zipFile();
			int errclose;
			zlib_filefunc64_def ffunc = new zlib_filefunc64_def();
			ffunc.fill_win32_filefunc64A();
			zf = ffunc.zipOpen2_64(filename_try, (opt_overwrite == 2) ? 2 : 0, ((Object)0));
			if (zf == ((Object)0)) {
				.printf("error opening %s\n", filename_try);
				err = ((true));
			} else {
					.printf("creating %s\n", filename_try);
			} 
			for (i = zipfilenamearg + 1; (i < argc) && (err == (false)); i++) {
				if (!(((((argv[i])) == (byte)'-') || (((argv[i])) == (byte)'/')) && ((argv[i][1] == (byte)'o') || (argv[i][1] == (byte)'O') || (argv[i][1] == (byte)'a') || (argv[i][1] == (byte)'A') || (argv[i][1] == (byte)'p') || (argv[i][1] == (byte)'P') || ((argv[i][1] >= (byte)'0') || (argv[i][1] <= (byte)'9'))) && (.strlen(argv[i]) == 2))) {
					FILE fin = new FILE();
					int size_read;
					byte filenameinzip = argv[i];
					byte savefilenameinzip;
					zip_fileinfo zi = new zip_fileinfo();
					long crcFile = 0;
					int zip64 = 0;
					generatedTmz_date.setTm_sec(generatedTmz_date.setTm_min(generatedTmz_date.setTm_hour(generatedTmz_date.setTm_mday(generatedTmz_date.setTm_mon(generatedTmz_date.setTm_year(0))))));
					zi.setDosDate(0);
					zi.setInternal_fa(0);
					zi.setExternal_fa(0);
					generatedTmz_date.filetime(filenameinzip, generatedDosDate);
					if ((password != ((Object)0)) && (err == (false))) {
						err = ModernizedCProgram.getFileCrc(filenameinzip, buf, size_buf, crcFile);
					} 
					zip64 = ModernizedCProgram.isLargeFile(filenameinzip);
					savefilenameinzip = /* The path name saved, should not include a leading slash. *//*if it did, windows/xp and dynazip couldn't read the zip file. */filenameinzip;
					while (savefilenameinzip[0] == (byte)'\\' || savefilenameinzip[0] == (byte)'/') {
						savefilenameinzip++;
					}
					if (/*should the zip file contain any path at all?*/opt_exclude_path) {
						byte tmpptr;
						byte lastslash = 0;
						for (tmpptr = savefilenameinzip; tmpptr; tmpptr++) {
							if (tmpptr == (byte)'\\' || tmpptr == (byte)'/') {
								lastslash = tmpptr;
							} 
						}
						if (lastslash != ((Object)0)) {
							savefilenameinzip = lastslash + 1;
						} 
					} 
					err = ModernizedCProgram.zipOpenNewFileInZip3_64(zf, savefilenameinzip, /**/zi, ((Object)0), 0, ((Object)0), 0, ((Object)/* comment*/0), (opt_compress_level != 0) ? 8 : 0, opt_compress_level, 0, -15, 8, /* -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, */0, password, crcFile, zip64);
					if (err != (false)) {
						.printf("error in opening %s in zipfile\n", filenameinzip);
					} else {
							fin = .fopen64(filenameinzip, "rb");
							if (fin == ((Object)0)) {
								err = ((true));
								.printf("error in opening %s for reading\n", filenameinzip);
							} 
					} 
					if (err == (false)) {
						do {
							err = (false);
							size_read = (int).fread(buf, 1, size_buf, fin);
							if (size_read < size_buf) {
								if ((generated_flag & -1024) == 0) {
									.printf("error in reading %s\n", filenameinzip);
									err = ((true));
								} 
							} 
							if (size_read > 0) {
								err = ModernizedCProgram.zipWriteInFileInZip(zf, buf, size_read);
								if (err < 0) {
									.printf("error in writing %s in the zipfile\n", filenameinzip);
								} 
							} 
						} while ((err == (false)) && (size_read > 0));
					} 
					if (fin) {
						.fclose(fin);
					} 
					if (err < 0) {
						err = ((true));
					} else {
							err = ModernizedCProgram.zipCloseFileInZip(zf);
							if (err != (false)) {
								.printf("error in closing %s in the zipfile\n", filenameinzip);
							} 
					} 
				} 
			}
			errclose = ModernizedCProgram.zipClose(zf, ((Object)0));
			if (errclose != (false)) {
				.printf("error in closing %s\n", filename_try);
			} 
		} else {
				ModernizedCProgram.do_help();
		} 
		.free(buf);
		return 0;
		byte zipfilename = ((Object)0);
		byte filename_to_extract = ((Object)0);
		byte password = ((Object)0);
		byte[] filename_try = "";
		int i;
		int ret_value = 0;
		int opt_do_list = 0;
		int opt_do_extract = 1;
		int opt_do_extract_withoutpath = 0;
		int opt_overwrite = 0;
		int opt_extractdir = 0;
		byte dirname = ((Object)0);
		unzFile uf = ((Object)0);
		ModernizedCProgram.do_banner();
		if (argc == 1) {
			ModernizedCProgram.do_help();
			return 0;
		} else {
				for (i = 1; i < argc; i++) {
					if ((argv[i]) == (byte)'-') {
						byte p = argv[i] + 1;
						while ((p) != (byte)'\0') {
							byte c = (p++);
							;
							if ((c == (byte)'l') || (c == (byte)'L')) {
								opt_do_list = 1;
							} 
							if ((c == (byte)'v') || (c == (byte)'V')) {
								opt_do_list = 1;
							} 
							if ((c == (byte)'x') || (c == (byte)'X')) {
								opt_do_extract = 1;
							} 
							if ((c == (byte)'e') || (c == (byte)'E')) {
								opt_do_extract = opt_do_extract_withoutpath = 1;
							} 
							if ((c == (byte)'o') || (c == (byte)'O')) {
								opt_overwrite = 1;
							} 
							if ((c == (byte)'d') || (c == (byte)'D')) {
								opt_extractdir = 1;
								dirname = argv[i + 1];
							} 
							if (((c == (byte)'p') || (c == (byte)'P')) && (i + 1 < argc)) {
								password = argv[i + 1];
								i++;
							} 
						}
					} else {
							if (zipfilename == ((Object)0)) {
								zipfilename = argv[i];
							}  else if ((filename_to_extract == ((Object)0)) && (!opt_extractdir)) {
								filename_to_extract = argv[i];
							} 
					} 
				}
		} 
		if (zipfilename != ((Object)0)) {
			zlib_filefunc64_def ffunc = new zlib_filefunc64_def();
			.strncpy(filename_try, zipfilename, (true) - 1);
			filename_try[(true)] = /* strncpy doesnt append the trailing NULL, of the string is too long. */(byte)'\0';
			ffunc.fill_win32_filefunc64A();
			uf = ffunc.unzOpen2_64(zipfilename);
			if (uf == ((Object)0)) {
				.strcat(filename_try, ".zip");
				uf = ffunc.unzOpen2_64(filename_try);
			} 
		} 
		if (uf == ((Object)0)) {
			.printf("Cannot open %s or %s.zip\n", zipfilename, zipfilename);
			return 1;
		} 
		.printf("%s opened\n", filename_try);
		if (opt_do_list == 1) {
			ret_value = ModernizedCProgram.do_list(uf);
		}  else if (opt_do_extract == 1) {
			if (opt_extractdir && ._chdir(dirname)) {
				.printf("Error changing into %s, aborting\n", dirname);
				.exit(-1);
			} 
			if (filename_to_extract == ((Object)0)) {
				ret_value = ModernizedCProgram.do_extract(uf, opt_do_extract_withoutpath, opt_overwrite, password);
			} else {
					ret_value = ModernizedCProgram.do_extract_onefile(uf, filename_to_extract, opt_do_extract_withoutpath, opt_overwrite, password);
			} 
		} 
		ModernizedCProgram.unzClose(uf);
		return ret_value;
		Byte compr = new Byte();
		Byte uncompr = new Byte();
		uLong comprLen = 10000 * /* don't overflow on MSDOS */;
		uLong uncomprLen = comprLen;
		byte myVersion = "1.2.11";
		if (ModernizedCProgram.zlibVersion()[0] != myVersion[0]) {
			.fprintf((_iob[2]), "incompatible zlib version\n");
			.exit(1);
		}  else if (.strcmp(ModernizedCProgram.zlibVersion(), "1.2.11") != 0) {
			.fprintf((_iob[2]), "warning: different zlib version\n");
		} 
		.printf("zlib version %s = 0x%04x, compile flags = 0x%lx\n", "1.2.11", -1024, ModernizedCProgram.zlibCompileFlags());
		compr = (Byte).calloc((uInt)comprLen, 1);
		uncompr = (Byte).calloc((uInt)uncomprLen, 1/* compr and uncompr are cleared to avoid reading uninitialized
		     * data and to ensure that uncompr compresses well.
		     */);
		if (compr == 0 || uncompr == 0) {
			.printf("out of memory\n");
			.exit(1);
		} 
		ModernizedCProgram.test_compress(compr, comprLen, uncompr, uncomprLen);
		ModernizedCProgram.test_gzio((argc > 1 ? argv[1] : "foo.gz"), uncompr, uncomprLen);
		ModernizedCProgram.test_deflate(compr, comprLen);
		ModernizedCProgram.test_inflate(compr, comprLen, uncompr, uncomprLen);
		ModernizedCProgram.test_large_deflate(compr, comprLen, uncompr, uncomprLen);
		ModernizedCProgram.test_large_inflate(compr, comprLen, uncompr, uncomprLen);
		ModernizedCProgram.test_flush(compr, comprLen);
		ModernizedCProgram.test_sync(compr, comprLen, uncompr, uncomprLen);
		comprLen = uncomprLen;
		ModernizedCProgram.test_dict_deflate(compr, comprLen);
		ModernizedCProgram.test_dict_inflate(compr, comprLen, uncompr, uncomprLen);
		.free(compr);
		.free(uncompr);
		return 0;
		int len;
		off_t offset = new off_t();
		FILE in = new FILE();
		access index = ((Object)0);
		byte[] buf = new byte[16384];
		if (argc != /* open input file */2) {
			.fprintf((_iob[2]), "usage: zran file.gz\n");
			return 1;
		} 
		in = .fopen(argv[1], "rb");
		if (in == ((Object)0)) {
			.fprintf((_iob[2]), "zran: could not open %s for reading\n", argv[1]);
			return 1;
		} 
		len = ModernizedCProgram.build_index(in, -1024, /* build index */index);
		if (len < 0) {
			.fclose(in);
			switch (len) {
			case (true):
					.fprintf((_iob[2]), "zran: read error on %s\n", argv[1]);
					break;
			case (true):
					.fprintf((_iob[2]), "zran: out of memory\n");
					break;
			case (true):
					.fprintf((_iob[2]), "zran: compressed data error in %s\n", argv[1]);
					break;
			default:
					.fprintf((_iob[2]), "zran: error %d while building index\n", len);
			}
			return 1;
		} 
		.fprintf((_iob[2]), "zran: built index with %d access points\n", len);
		point generatedList = index.getList();
		int generatedHave = index.getHave();
		offset = (generatedList[generatedHave - 1].getOut() << 1) / /* use index by reading some bytes from an arbitrary offset */3;
		len = ModernizedCProgram.extract(in, index, offset, buf, 16384);
		if (len < 0) {
			.fprintf((_iob[2]), "zran: extraction failed: %s error\n", len == (true) ? "out of memory" : "input corrupted");
		} else {
				.fwrite(buf, 1, len, (_iob[1]));
				.fprintf((_iob[2]), "zran: extracted %d bytes at %llu\n", len, offset);
		} 
		/* clean up and exit */index.free_index();
		.fclose(in);
		return 0;
		ISzAlloc allocImp = new ISzAlloc();
		ISzAlloc allocTempImp = new ISzAlloc();
		CFileInStream archiveStream = new CFileInStream();
		CLookToRead2 lookStream = new CLookToRead2();
		CSzArEx db = new CSzArEx();
		SRes res = new SRes();
		UInt16 temp = ((Object)0);
		size_t tempSize = 0;
		// UInt32 parents[NUM_PARENTS_MAX];
		ModernizedCProgram.Print("\n7z Decoder 19.00 (x86) : Igor Pavlov : Public domain : 2019-02-21\n\n");
		if (numargs == 1) {
			ModernizedCProgram.Print("Usage: 7zDec <command> <archive_name>\n\n<Commands>\n  e: Extract files from archive (without using directory names)\n  l: List contents of archive\n  t: Test integrity of archive\n  x: eXtract files with full paths\n");
			return 0;
		} 
		if (numargs < 3) {
			ModernizedCProgram.PrintError("incorrect command");
			return 1;
		} 
		allocImp = ModernizedCProgram.g_Alloc;
		allocTempImp = ModernizedCProgram.g_Alloc;
		Object generatedFile = archiveStream.getFile();
		if (generatedFile.InFile_Open(args[2])) {
			ModernizedCProgram.PrintError("can not open input file");
			return 1;
		} 
		archiveStream.FileInStream_CreateVTable();
		lookStream.LookToRead2_CreateVTable(0);
		lookStream.setBuf(((Object)0));
		res = 0;
		Object generatedBuf = lookStream.getBuf();
		Object generatedVt = archiveStream.getVt();
		{ 
			lookStream.setBuf((Byte).UNRECOGNIZEDFUNCTIONNAME(allocImp, ((size_t)1 << 18)));
			if (!generatedBuf) {
				res = 2;
			} else {
					lookStream.setBufSize(((size_t)1 << 18));
					lookStream.setRealStream(generatedVt);
					{ 
						(lookStream).setPos((lookStream).setSize(0));
					}
					;
			} 
		}
		ModernizedCProgram.CrcGenerateTable();
		db.SzArEx_Init();
		if (res == 0) {
			res = ModernizedCProgram.SzArEx_Open(db, generatedVt, allocImp, allocTempImp);
		} 
		Object generatedNumFiles = db.getNumFiles();
		Object generatedIsDirs = (db).getIsDirs();
		Object generatedAttribs = db.getAttribs();
		Object generatedUnpackPositions = (db).getUnpackPositions();
		Object generatedMTime = db.getMTime();
		Object generatedCTime = db.getCTime();
		Object generatedHandle = outFile.getHandle();
		if (res == 0) {
			byte command = args[1];
			int listCommand = 0;
			int testCommand = 0;
			int fullPaths = 0;
			if (.strcmp(command, "l") == 0) {
				listCommand = 1;
			}  else if (.strcmp(command, "t") == 0) {
				testCommand = 1;
			}  else if (.strcmp(command, "e") == 0) {
			}  else if (.strcmp(command, "x") == 0) {
				fullPaths = 1;
			} else {
					ModernizedCProgram.PrintError("incorrect command");
					res = 11;
			} 
			if (res == 0) {
				UInt32 i = new UInt32();
				UInt32 blockIndex = /* it can have any value before first call (if outBuffer = 0) */-1024;
				Byte outBuffer = /* it must be 0 before first call for each new archive. */0;
				size_t outBufferSize = /* it can have any value before first call (if outBuffer = 0) */0;
				for (i = 0; i < generatedNumFiles; i++) {
					size_t offset = 0;
					size_t outSizeProcessed = 0;
					size_t len = new size_t();
					int isDir = ((((generatedIsDirs)[(i) >> 3] & (-1024 >> ((i) & 7))) != 0));
					if (listCommand == 0 && isDir && !fullPaths) {
						continue;
					} 
					len = ModernizedCProgram.SzArEx_GetFileNameUtf16(db, i, ((Object)0));
					if (len > tempSize) {
						ModernizedCProgram.SzFree(((Object)0), temp);
						tempSize = len;
						temp = (UInt16)ModernizedCProgram.SzAlloc(((Object)0), tempSize * );
						if (!temp) {
							res = 2;
							break;
						} 
					} 
					ModernizedCProgram.SzArEx_GetFileNameUtf16(db, i, temp/*
					        if (SzArEx_GetFullNameUtf16_Back(&db, i, temp + len) != temp)
					        {
					          res = SZ_ERROR_FAIL;
					          break;
					        }
					        */);
					if (listCommand) {
						byte[] attr = new byte[8];
						byte[] s = new byte[32];
						byte[] t = new byte[32];
						UInt64 fileSize = new UInt64();
						ModernizedCProgram.GetAttribString(((generatedAttribs).getDefs() && ((generatedAttribs).getDefs()[(i) >> 3] & (-1024 >> ((i) & 7))) != 0) ? generatedAttribs.getVals()[i] : 0, isDir, attr);
						fileSize = (generatedUnpackPositions[(i) + 1] - generatedUnpackPositions[i]);
						ModernizedCProgram.UInt64ToStr(fileSize, s, 10);
						if (((generatedMTime).getDefs() && ((generatedMTime).getDefs()[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
							ModernizedCProgram.ConvertFileTimeToString(generatedMTime.getVals()[i], t);
						} else {
								size_t j = new size_t();
								for (j = 0; j < 19; j++) {
									t[j] = (byte)' ';
								}
								t[j] = (byte)'\0';
						} 
						ModernizedCProgram.Print(t);
						ModernizedCProgram.Print(" ");
						ModernizedCProgram.Print(attr);
						ModernizedCProgram.Print(" ");
						ModernizedCProgram.Print(s);
						ModernizedCProgram.Print("  ");
						res = ModernizedCProgram.PrintString(temp);
						if (res != 0) {
							break;
						} 
						if (isDir) {
							ModernizedCProgram.Print("/");
						} 
						ModernizedCProgram.PrintLF();
						continue;
					} 
					ModernizedCProgram.Print(testCommand ? "Testing    " : "Extracting ");
					res = ModernizedCProgram.PrintString(temp);
					if (res != 0) {
						break;
					} 
					if (isDir) {
						ModernizedCProgram.Print("/");
					} else {
							res = generatedVt.SzArEx_Extract(db, i, blockIndex, outBuffer, outBufferSize, offset, outSizeProcessed, allocImp, allocTempImp);
							if (res != 0) {
								break;
							} 
					} 
					if (!testCommand) {
						CSzFile outFile = new CSzFile();
						size_t processedSize = new size_t();
						size_t j = new size_t();
						UInt16 name = (UInt16)temp;
						UInt16 destPath = (UInt16)name;
						for (j = 0; name[j] != 0; j++) {
							if (name[j] == (byte)'/') {
								if (fullPaths) {
									name[j] = 0;
									ModernizedCProgram.MyCreateDir(name);
									name[j] = (byte)'\\';
								} else {
										destPath = name + j + 1;
								} 
							} 
						}
						if (isDir) {
							ModernizedCProgram.MyCreateDir(destPath);
							ModernizedCProgram.PrintLF();
							continue;
						}  else if (outFile.OutFile_OpenUtf16(destPath)) {
							ModernizedCProgram.PrintError("can not open output file");
							res = 11;
							break;
						} 
						processedSize = outSizeProcessed;
						if (outFile.File_Write(outBuffer + offset, processedSize) != 0 || processedSize != outSizeProcessed) {
							ModernizedCProgram.PrintError("can not write output file");
							res = 11;
							break;
						} 
						{ 
							FILETIME mtime = new FILETIME();
							FILETIME ctime = new FILETIME();
							FILETIME mtimePtr = ((Object)0);
							FILETIME ctimePtr = ((Object)0);
							if (((generatedMTime).getDefs() && ((generatedMTime).getDefs()[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
								CNtfsFileTime t = generatedMTime.getVals()[i];
								mtime.setDwLowDateTime((DWORD)(t.getLow()));
								mtime.setDwHighDateTime((DWORD)(t.getHigh()));
								mtimePtr = mtime;
							} 
							if (((generatedCTime).getDefs() && ((generatedCTime).getDefs()[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
								CNtfsFileTime t = generatedCTime.getVals()[i];
								ctime.setDwLowDateTime((DWORD)(t.getLow()));
								ctime.setDwHighDateTime((DWORD)(t.getHigh()));
								ctimePtr = ctime;
							} 
							if (mtimePtr || ctimePtr) {
								.SetFileTime(generatedHandle, ctimePtr, ((Object)0), mtimePtr);
							} 
						}
						if (outFile.File_Close()) {
							ModernizedCProgram.PrintError("can not close output file");
							res = 11;
							break;
						} 
						if (((generatedAttribs).getDefs() && ((generatedAttribs).getDefs()[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
							UInt32 attrib = generatedAttribs.getVals()[i/* p7zip stores posix attributes in high 16 bits and adds 0x8000 as marker.
							               We remove posix bits, if we detect posix mode field */];
							if ((attrib & -1024) != 0) {
								attrib &=  -1024;
							} 
							.SetFileAttributesW((LPCWSTR)destPath, attrib);
						} 
					} 
					ModernizedCProgram.PrintLF();
				}
				.UNRECOGNIZEDFUNCTIONNAME(allocImp, outBuffer);
			} 
		} 
		ModernizedCProgram.SzFree(((Object)0), temp);
		db.SzArEx_Free(allocImp);
		.UNRECOGNIZEDFUNCTIONNAME(allocImp, generatedBuf);
		generatedFile.File_Close();
		if (res == 0) {
			ModernizedCProgram.Print("\nEverything is Ok\n");
			return 0;
		} 
		if (res == 4) {
			ModernizedCProgram.PrintError("decoder doesn't support this archive");
		}  else if (res == 2) {
			ModernizedCProgram.PrintError("can not allocate memory");
		}  else if (res == 3) {
			ModernizedCProgram.PrintError("CRC error");
		} else {
				byte[] s = new byte[32];
				ModernizedCProgram.UInt64ToStr(res, s, 0);
				ModernizedCProgram.PrintError(s);
		} 
		return 1;
		int copyout = 0;
		int uncompr = 0;
		gzFile file = new gzFile();
		byte bname;
		byte[] outmode = new byte[20];
		.snprintf(outmode, , "%s", "wb6 ");
		ModernizedCProgram.prog = argv[0];
		bname = .strrchr(argv[0], (byte)'/');
		if (bname) {
			bname++;
		} else {
				bname = argv[0];
		} 
		;
		if (!.strcmp(bname, "gunzip")) {
			uncompr = 1;
		}  else if (!.strcmp(bname, "zcat")) {
			copyout = uncompr = 1;
		} 
		while (argc > 0) {
			if (.strcmp(argv, "-c") == 0) {
				copyout = 1;
			}  else if (.strcmp(argv, "-d") == 0) {
				uncompr = 1;
			}  else if (.strcmp(argv, "-f") == 0) {
				outmode[3] = (byte)'f';
			}  else if (.strcmp(argv, "-h") == 0) {
				outmode[3] = (byte)'h';
			}  else if (.strcmp(argv, "-r") == 0) {
				outmode[3] = (byte)'R';
			}  else if ((argv)[0] == (byte)'-' && (argv)[1] >= (byte)'1' && (argv)[1] <= (byte)'9' && (argv)[2] == 0) {
				outmode[2] = (argv)[1];
			} else {
					break;
			} 
			;
		}
		if (outmode[3] == (byte)' ') {
			outmode[3] = 0;
		} 
		if (argc == 0) {
			.setmode((((_iob[0])).get_file()), -1024);
			.setmode((((_iob[1])).get_file()), -1024);
			if (uncompr) {
				file = ModernizedCProgram.gzdopen((((_iob[0])).get_file()), "rb");
				if (file == ((Object)0)) {
					ModernizedCProgram.error("can't gzdopen stdin");
				} 
				(_iob[1]).gz_uncompress(file);
			} else {
					file = ModernizedCProgram.gzdopen((((_iob[1])).get_file()), outmode);
					if (file == ((Object)0)) {
						ModernizedCProgram.error("can't gzdopen stdout");
					} 
					(_iob[0]).gz_compress(file);
			} 
		} else {
				if (copyout) {
					.setmode((((_iob[1])).get_file()), -1024);
				} 
				do {
					if (uncompr) {
						if (copyout) {
							file = ModernizedCProgram.gzopen(argv, "rb");
							if (file == ((Object)0)) {
								.fprintf((_iob[2]), "%s: can't gzopen %s\n", ModernizedCProgram.prog, argv);
							} else {
									(_iob[1]).gz_uncompress(file);
							} 
						} else {
								ModernizedCProgram.file_uncompress(argv);
						} 
					} else {
							if (copyout) {
								FILE in = .fopen(argv, "rb");
								if (in == ((Object)0)) {
									.perror(argv);
								} else {
										file = ModernizedCProgram.gzdopen((((_iob[1])).get_file()), outmode);
										if (file == ((Object)0)) {
											ModernizedCProgram.error("can't gzdopen stdout");
										} 
										in.gz_compress(file);
								} 
							} else {
									ModernizedCProgram.file_compress(argv, outmode);
							} 
					} 
				} while ();
		} 
		return 0;
		gzofstream outf = new gzofstream();
		gzifstream inf = new gzifstream();
		byte[] buf = new byte[80];
		.UNRECOGNIZEDFUNCTIONNAME("test1.txt.gz");
		outf << "The quick brown fox sidestepped the lazy canine\n" << 1.3 << "\nPlan " << 9 << endl;
		.UNRECOGNIZEDFUNCTIONNAME();
		cout << "Wrote the following message to 'test1.txt.gz' (check with zcat or zless):\n" << "The quick brown fox sidestepped the lazy canine\n" << 1.3 << "\nPlan " << 9 << endl;
		cout << "\nReading 'test1.txt.gz' (buffered) produces:\n";
		.UNRECOGNIZEDFUNCTIONNAME("test1.txt.gz");
		while (.UNRECOGNIZEDFUNCTIONNAME(buf, 80, (byte)'\n')) {
			cout << buf << "\t(" << .UNRECOGNIZEDFUNCTIONNAME() << " chars left in buffer)\n";
		}
		.UNRECOGNIZEDFUNCTIONNAME();
		.UNRECOGNIZEDFUNCTIONNAME(0, 0);
		.UNRECOGNIZEDFUNCTIONNAME("test2.txt.gz");
		outf << .setcompression(0) << "The quick brown fox sidestepped the lazy canine\n" << 1.3 << "\nPlan " << 9 << endl;
		.UNRECOGNIZEDFUNCTIONNAME();
		cout << "\nWrote the same message to 'test2.txt.gz' in uncompressed form";
		cout << "\nReading 'test2.txt.gz' (unbuffered) produces:\n";
		.UNRECOGNIZEDFUNCTIONNAME(0, 0);
		.UNRECOGNIZEDFUNCTIONNAME("test2.txt.gz");
		while (.UNRECOGNIZEDFUNCTIONNAME(buf, 80, (byte)'\n')) {
			cout << buf << "\t(" << .UNRECOGNIZEDFUNCTIONNAME() << " chars left in buffer)\n";
		}
		.UNRECOGNIZEDFUNCTIONNAME();
		return 0;
		int action = .TGZ_EXTRACT;
		int arg = 1;
		byte TGZfile;
		gzFile f = new gzFile();
		ModernizedCProgram.prog = .strrchr(argv[0], (byte)'\\');
		if (ModernizedCProgram.prog == ((Object)0)) {
			ModernizedCProgram.prog = .strrchr(argv[0], (byte)'/');
			if (ModernizedCProgram.prog == ((Object)0)) {
				ModernizedCProgram.prog = .strrchr(argv[0], (byte)':');
				if (ModernizedCProgram.prog == ((Object)0)) {
					ModernizedCProgram.prog = argv[0];
				} else {
						ModernizedCProgram.prog++;
				} 
			} else {
					ModernizedCProgram.prog++;
			} 
		} else {
				ModernizedCProgram.prog++;
		} 
		if (argc == 1) {
			ModernizedCProgram.help(0);
		} 
		if (.strcmp(argv[arg], "-l") == 0) {
			action = .TGZ_LIST;
			if (argc == ++arg) {
				ModernizedCProgram.help(0);
			} 
		}  else if (.strcmp(argv[arg], "-h") == 0) {
			ModernizedCProgram.help(0);
		} 
		if ((TGZfile = ModernizedCProgram.TGZfname(argv[arg])) == ((Object)0)) {
			ModernizedCProgram.TGZnotfound(argv[arg]);
		} 
		++arg;
		if ((action == .TGZ_LIST) && (arg != argc)) {
			ModernizedCProgram.help(1/*
			 *  Process the TGZ file
			 */);
		} 
		switch (action) {
		case .TGZ_EXTRACT:
				f = ModernizedCProgram.gzopen(TGZfile, "rb");
				if (f == ((Object)0)) {
					.fprintf((_iob[2]), "%s: Couldn't gzopen %s\n", ModernizedCProgram.prog, TGZfile);
					return 1;
				} 
				.exit(ModernizedCProgram.tar(f, action, arg, argc, argv));
				break;
		case .TGZ_LIST:
		default:
				ModernizedCProgram.error("Unknown option");
				.exit(1);
		}
		return 0;
	}
	public static Object cpu_crc32_buffer(Object buf, Object length) {
		u32 crc = ~-1024;
		for (size_t pos = 0;
		 pos < length; pos++) {
			crc = ModernizedCProgram.crc32tab[(crc ^ buf[pos]) & -1024] ^ (crc >> 8);
		}
		return crc ^ -1024;
		;
	}
	public static int cpu_crc32(Object filename, Object keytab) {
		u32 crc = ~-1024;
		HCFILE fp = new HCFILE();
		fp.hc_fopen(filename, "rb");
		u8 buf = (u8)ModernizedCProgram.hcmalloc((1024 * 1024) + 1);
		size_t nread = fp.hc_fread(buf, , (1024 * 1024));
		fp.hc_fclose();
		size_t kpos = 0;
		for (size_t fpos = 0;
		 fpos < nread; fpos++) {
			crc = ModernizedCProgram.crc32tab[(crc ^ buf[fpos]) & -1024] ^ (crc >> 8);
			keytab[kpos++] += (crc >> 24) & -1024;
			if (kpos >= 64) {
				kpos = 0;
			} 
			keytab[kpos++] += (crc >> 16) & -1024;
			if (kpos >= 64) {
				kpos = 0;
			} 
			keytab[kpos++] += (crc >> 8) & -1024;
			if (kpos >= 64) {
				kpos = 0;
			} 
			keytab[kpos++] += (crc >> 0) & -1024;
			if (kpos >= 64) {
				kpos = 0;
			} 
		}
		ModernizedCProgram.hcfree(buf);
		return 0;
	}
	public static void PrintHelp(Byte buffer) {
		.strcat(buffer, "\nLZMA-C 19.00 (x86) : Igor Pavlov : Public domain : 2019-02-21\n\nUsage:  lzma <e|d> inputFile outputFile\n  e: encode file\n  d: decode file\n");
	}
	public static int PrintError(Byte buffer, Object message) {
		.strcat(buffer, "\nError: ");
		.strcat(buffer, message);
		.strcat(buffer, "\n");
		return 1;
		ModernizedCProgram.Print("\nERROR: ");
		ModernizedCProgram.Print(s);
		ModernizedCProgram.PrintLF();
	}
	public static int PrintErrorNumber(Byte buffer, Object val) {
		.sprintf(buffer + .strlen(buffer), "\nError code: %x\n", (int)val);
		return 1;
	}
	public static int PrintUserError(Byte buffer) {
		return ModernizedCProgram.PrintError(buffer, "Incorrect command");
	}
	public static Object Decode2( state, ISeqOutStream outStream, ISeqInStream inStream, Object unpackSize) {
		int thereIsSize = (unpackSize != (UInt64)(Int64)-1);
		Byte[] inBuf = new Byte();
		Byte[] outBuf = new Byte();
		size_t inPos = 0;
		size_t inSize = 0;
		size_t outPos = 0;
		state.LzmaDec_Init();
		for (; ; ) {
			if (inPos == inSize) {
				inSize = (1 << 16);
				{ 
					int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(inStream, inBuf, inSize));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				inPos = 0;
			} 
			{ 
				SRes res = new SRes();
				SizeT inProcessed = inSize - inPos;
				SizeT outProcessed = (1 << 16) - outPos;
				ELzmaFinishMode finishMode = .LZMA_FINISH_ANY;
				ELzmaStatus status = new ELzmaStatus();
				if (thereIsSize && outProcessed > unpackSize) {
					outProcessed = (SizeT)unpackSize;
					finishMode = .LZMA_FINISH_END;
				} 
				res = state.LzmaDec_DecodeToBuf(outBuf + outPos, outProcessed, inBuf + inPos, inProcessed, finishMode, status);
				inPos += inProcessed;
				outPos += outProcessed;
				unpackSize -= outProcessed;
				if (outStream) {
					if (.UNRECOGNIZEDFUNCTIONNAME(outStream, outBuf, outPos) != outPos) {
						return 9;
					} 
				} 
				outPos = 0;
				if (res != 0 || (thereIsSize && unpackSize == 0)) {
					return res;
				} 
				if (inProcessed == 0 && outProcessed == 0) {
					if (thereIsSize || status != .LZMA_STATUS_FINISHED_WITH_MARK) {
						return 1;
					} 
					return res;
				} 
			}
		}
	}
	public static Object Decode(ISeqOutStream outStream, ISeqInStream inStream) {
		UInt64 unpackSize = new UInt64();
		int i;
		SRes res = 0;
		CLzmaDec state = new CLzmaDec();
		byte[] header = new byte[5 + /* header: 5 bytes of LZMA properties and 8 bytes of uncompressed size */8];
		{ 
			int __result__ = (ModernizedCProgram.SeqInStream_Read(inStream, header, ));
			if (__result__ != 0) {
				return /* Read and parse header */__result__;
			} 
		}
		;
		unpackSize = 0;
		for (i = 0; i < 8; i++) {
			unpackSize += (UInt64)header[5 + i] << (i * 8);
		}
		{ 
			(state).setDic(((Object)0));
			(state).setProbs(((Object)0));
		}
		;
		{ 
			int __result__ = (state.LzmaDec_Allocate(header, 5, ModernizedCProgram.g_Alloc));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		res = ModernizedCProgram.Decode2(state, outStream, inStream, unpackSize);
		state.LzmaDec_Free(ModernizedCProgram.g_Alloc);
		return res;
	}
	public static Object Encode(ISeqOutStream outStream, ISeqInStream inStream, Object fileSize, Byte rs) {
		CLzmaEncHandle enc = new CLzmaEncHandle();
		SRes res = new SRes();
		CLzmaEncProps props = new CLzmaEncProps();
		(Object)rs;
		;
		enc = ModernizedCProgram.LzmaEnc_Create(ModernizedCProgram.g_Alloc);
		if (enc == 0) {
			return 2;
		} 
		props.LzmaEncProps_Init();
		res = ModernizedCProgram.LzmaEnc_SetProps(enc, props);
		if (res == 0) {
			Byte[] header = new Byte();
			size_t headerSize = 5;
			int i;
			res = ModernizedCProgram.LzmaEnc_WriteProperties(enc, header, headerSize);
			for (i = 0; i < 8; i++) {
				header[headerSize++] = (Byte)(fileSize >> (8 * i));
			}
			if (.UNRECOGNIZEDFUNCTIONNAME(outStream, header, headerSize) != headerSize) {
				res = 9;
			} else {
					if (res == 0) {
						res = ModernizedCProgram.LzmaEnc_Encode(enc, outStream, inStream, ((Object)0), ModernizedCProgram.g_Alloc, ModernizedCProgram.g_Alloc);
					} 
			} 
		} 
		ModernizedCProgram.LzmaEnc_Destroy(enc, ModernizedCProgram.g_Alloc, ModernizedCProgram.g_Alloc);
		return res;
	}
	public static int main2(int numArgs, Object args, Byte rs) {
		CFileSeqInStream inStream = new CFileSeqInStream();
		CFileOutStream outStream = new CFileOutStream();
		byte c;
		int res;
		int encodeMode;
		BoolInt useOutFile = 0;
		inStream.FileSeqInStream_CreateVTable();
		Object generatedFile = inStream.getFile();
		generatedFile.File_Construct();
		outStream.FileOutStream_CreateVTable();
		generatedFile.File_Construct();
		if (numArgs == 1) {
			ModernizedCProgram.PrintHelp(rs);
			return 0;
		} 
		if (numArgs < 3 || numArgs > 4 || .strlen(args[1]) != 1) {
			return ModernizedCProgram.PrintUserError(rs);
		} 
		c = args[1][0];
		encodeMode = (c == (byte)'e' || c == (byte)'E');
		if (!encodeMode && c != (byte)'d' && c != (byte)'D') {
			return ModernizedCProgram.PrintUserError(rs);
		} 
		{ 
			size_t t4 = ;
			size_t t8 = ;
			if (t4 != 4 || t8 != 8) {
				return ModernizedCProgram.PrintError(rs, "Incorrect UInt32 or UInt64");
			} 
		}
		if (generatedFile.InFile_Open(args[2]) != 0) {
			return ModernizedCProgram.PrintError(rs, "Can not open input file");
		} 
		if (numArgs > 3) {
			useOutFile = 1;
			if (generatedFile.OutFile_Open(args[3]) != 0) {
				return ModernizedCProgram.PrintError(rs, "Can not open output file");
			} 
		}  else if (encodeMode) {
			ModernizedCProgram.PrintUserError(rs);
		} 
		Object generatedVt = outStream.getVt();
		if (encodeMode) {
			UInt64 fileSize = new UInt64();
			generatedFile.File_GetLength(fileSize);
			res = ModernizedCProgram.Encode(generatedVt, generatedVt, fileSize, rs);
		} else {
				res = ModernizedCProgram.Decode(generatedVt, useOutFile ? generatedVt : ((Object)0));
		} 
		if (useOutFile) {
			generatedFile.File_Close();
		} 
		generatedFile.File_Close();
		if (res != 0) {
			if (res == 2) {
				return ModernizedCProgram.PrintError(rs, ModernizedCProgram.kCantAllocateMessage);
			}  else if (res == 1) {
				return ModernizedCProgram.PrintError(rs, ModernizedCProgram.kDataErrorMessage);
			}  else if (res == 9) {
				return ModernizedCProgram.PrintError(rs, ModernizedCProgram.kCantWriteMessage);
			}  else if (res == 8) {
				return ModernizedCProgram.PrintError(rs, ModernizedCProgram.kCantReadMessage);
			} 
			return ModernizedCProgram.PrintErrorNumber(rs, res);
		} 
		return 0;
	}
	public static int FindExt(Object s, int extLen) {
		int len = (int).wcslen(s);
		int i;
		for (i = len; i > 0; i--) {
			if (s[i - 1] == (byte)'.') {
				extLen = len - i;
				return i - 1;
			} 
		}
		extLen = 0;
		return len;
	}
	public static int FindItem(Object items, int num, Object s, int len) {
		int i;
		for (i = 0; i < num; i++) {
			byte item = items[i];
			int itemLen = (int).strlen(item);
			int j;
			if (len != itemLen) {
				continue;
			} 
			for (j = 0; j < len; j++) {
				int c = (Byte)item[j];
				if (c != s[j] && ((((c) >= (byte)'a' && (c) <= (byte)'z') ? (c) -= -1024 : (c))) != s[j]) {
					break;
				} 
			}
			if (j == len) {
				return i;
			} 
		}
		return i;
	}
	public static void PrintErrorMessage(Object message) {
		.MessageBoxA(0, message, "7-Zip Error", 16);
	}
	public static Object MyCreateDir(Object name) {
		return .CreateDirectoryW(name, ((Object)0)) ? 0 : .GetLastError();
		return .CreateDirectoryW((LPCWSTR)name, ((Object)0)) ? 0 : .GetLastError();
	}
	public static Object FindSignature(Object resPos) {
		Byte[] buf = new Byte();
		size_t numPrevBytes = 0;
		resPos = 0;
		for (; ; ) {
			size_t processed = new size_t();
			size_t pos = new size_t();
			if (resPos > (1 << 22)) {
				return 0;
			} 
			processed = (1 << 15) - numPrevBytes;
			if (stream.File_Read(buf + numPrevBytes, processed) != 0) {
				return 0;
			} 
			processed += numPrevBytes;
			if (processed < -1024 || (processed == -1024 && numPrevBytes != 0)) {
				return 0;
			} 
			processed -= -1024;
			for (pos = 0; pos <= processed; pos++) {
				for (; pos <= processed && buf[pos] != (byte)'7'; pos++) {
					;
				}
				if (pos > processed) {
					break;
				} 
				if (.memcmp(buf + pos, ModernizedCProgram.k7zSignature, 6) == 0) {
					if (ModernizedCProgram.CrcCalc(buf + pos + 12, 20) == ((UInt32)(Object)(buf + pos + 8))) {
						resPos += pos;
						return 1;
					} 
				} 
			}
			resPos += processed;
			numPrevBytes = -1024;
			.memmove(buf, buf + processed, -1024);
		}
	}
	public static Object DoesFileOrDirExist(Object path) {
		WIN32_FIND_DATAW fd = new WIN32_FIND_DATAW();
		HANDLE handle = new HANDLE();
		handle = .FindFirstFileW(path, fd);
		if (handle == (HANDLE)(true)) {
			return 0;
		} 
		.FindClose(handle);
		return 1;
	}
	public static Object RemoveDirWithSubItems(Object path) {
		WIN32_FIND_DATAW fd = new WIN32_FIND_DATAW();
		HANDLE handle = new HANDLE();
		WRes res = 0;
		size_t len = .wcslen(path);
		.wcscpy(path + len, L"*");
		handle = .FindFirstFileW(path, fd);
		path[len] = (byte)L'\0';
		if (handle == (HANDLE)(true)) {
			return .GetLastError();
		} 
		Object generatedCFileName = fd.getCFileName();
		Object generatedDwFileAttributes = fd.getDwFileAttributes();
		for (; ; ) {
			if (.wcscmp(generatedCFileName, L".") != 0 && .wcscmp(generatedCFileName, L"..") != 0) {
				.wcscpy(path + len, generatedCFileName);
				if ((generatedDwFileAttributes & -1024) != 0) {
					.wcscat(path, L"\\");
					res = ModernizedCProgram.RemoveDirWithSubItems(path);
				} else {
						.SetFileAttributesW(path, 0);
						if (.DeleteFileW(path) == 0) {
							res = .GetLastError();
						} 
				} 
				if (res != 0) {
					break;
				} 
			} 
			if (!.FindNextFileW(handle, fd)) {
				res = .GetLastError();
				if (res == -1024) {
					res = 0;
				} 
				break;
			} 
		}
		path[len] = (byte)L'\0';
		.FindClose(handle);
		if (res == 0) {
			if (!.RemoveDirectoryW(path)) {
				res = .GetLastError();
			} 
		} 
		return res;
	}
	public static int WinMain(Object hInstance, Object hPrevInstance, Object lpCmdLine, int nCmdShow) {
		CFileInStream archiveStream = new CFileInStream();
		CLookToRead2 lookStream = new CLookToRead2();
		CSzArEx db = new CSzArEx();
		SRes res = 0;
		ISzAlloc allocImp = new ISzAlloc();
		ISzAlloc allocTempImp = new ISzAlloc();
		WCHAR[] sfxPath = new WCHAR();
		WCHAR[] path = new WCHAR();
		WCHAR[] workCurDir = new WCHAR();
		size_t pathLen = new size_t();
		DWORD winRes = new DWORD();
		wchar_t cmdLineParams = new wchar_t();
		byte errorMessage = ((Object)0);
		BoolInt useShellExecute = 1;
		DWORD exitCode = 0;
		ModernizedCProgram.LoadSecurityDlls();
		(Object)hInstance;
		;
		(Object)hPrevInstance;
		;
		(Object)lpCmdLine;
		;
		(Object)nCmdShow;
		;
		ModernizedCProgram.CrcGenerateTable();
		allocImp.setAlloc(ModernizedCProgram.SzAlloc);
		allocImp.setFree(ModernizedCProgram.SzFree);
		allocTempImp.setAlloc(ModernizedCProgram.SzAllocTemp);
		allocTempImp.setFree(ModernizedCProgram.SzFreeTemp);
		archiveStream.FileInStream_CreateVTable();
		lookStream.LookToRead2_CreateVTable(0);
		lookStream.setBuf(((Object)0));
		winRes = .GetModuleFileNameW(((Object)0), sfxPath, 260);
		if (winRes == 0 || winRes > 260) {
			return 1;
		} 
		{ 
			cmdLineParams = .GetCommandLineW();
			{ 
				BoolInt quoteMode = 0;
				for (; ; cmdLineParams++) {
					wchar_t c = cmdLineParams;
					if (c == (byte)L'\"') {
						quoteMode = !quoteMode;
					}  else if (c == 0 || (c == (byte)L' ' && !quoteMode)) {
						break;
					} 
				}
			}
		}
		{ 
			int i;
			DWORD d = new DWORD();
			winRes = .GetTempPathW(260, path);
			if (winRes == 0 || winRes > 260) {
				return 1;
			} 
			pathLen = .wcslen(path);
			d = (.GetTickCount() << 12) ^ (.GetCurrentThreadId() << 14) ^ .GetCurrentProcessId();
			for (i = 0; ; ) {
				if (i >= 100) {
					res = 11;
					break;
				} 
				.wcscpy(path + pathLen, L"7z");
				{ 
					wchar_t s = path + .wcslen(path);
					UInt32 value = d;
					int k;
					for (k = 0; k < 8; k++) {
						int t = value & -1024;
						value >>=  4;
						s[7 - k] = (wchar_t)((t < 10) ? ((byte)'0' + t) : ((byte)'A' + (t - 10)));
					}
					s[k] = (byte)'\0';
				}
				if (ModernizedCProgram.DoesFileOrDirExist(path)) {
					continue;
				} 
				if (.CreateDirectoryW(path, ((Object)0))) {
					.wcscat(path, L"\\");
					pathLen = .wcslen(path);
					break;
				} 
				if (.GetLastError() != -1024) {
					res = 11;
					break;
				} 
			}
			.wcscpy(workCurDir, path);
			if (res != 0) {
				errorMessage = "Can't create temp folder";
			} 
		}
		if (res != 0) {
			if (!errorMessage) {
				errorMessage = "Error";
			} 
			ModernizedCProgram.PrintErrorMessage(errorMessage);
			return 1;
		} 
		Object generatedFile = archiveStream.getFile();
		if (generatedFile.InFile_OpenW(sfxPath) != 0) {
			errorMessage = "can not open input file";
			res = 11;
		} else {
				UInt64 pos = 0;
				if (!generatedFile.FindSignature(pos)) {
					res = 11;
				}  else if (generatedFile.File_Seek((Int64)pos, .SZ_SEEK_SET) != 0) {
					res = 11;
				} 
				if (res != 0) {
					errorMessage = "Can't find 7z archive";
				} 
		} 
		Object generatedBuf = lookStream.getBuf();
		Object generatedVt = archiveStream.getVt();
		if (res == 0) {
			lookStream.setBuf((Byte).UNRECOGNIZEDFUNCTIONNAME(allocImp, ((size_t)1 << 18)));
			if (!generatedBuf) {
				res = 2;
			} else {
					lookStream.setBufSize(((size_t)1 << 18));
					lookStream.setRealStream(generatedVt);
					{ 
						(lookStream).setPos((lookStream).setSize(0));
					}
					;
			} 
		} 
		db.SzArEx_Init();
		if (res == 0) {
			res = ModernizedCProgram.SzArEx_Open(db, generatedVt, allocImp, allocTempImp);
		} 
		Object generatedNumFiles = db.getNumFiles();
		Object generatedIsDirs = (db).getIsDirs();
		Object generatedMTime = db.getMTime();
		Object generatedHandle = outFile.getHandle();
		Object generatedAttribs = db.getAttribs();
		if (res == 0) {
			UInt32 executeFileIndex = (UInt32)(Int32)-1;
			UInt32 minPrice = 1 << 30;
			UInt32 i = new UInt32();
			UInt32 blockIndex = /* it can have any value before first call (if outBuffer = 0) */-1024;
			Byte outBuffer = /* it must be 0 before first call for each new archive. */0;
			size_t outBufferSize = /* it can have any value before first call (if outBuffer = 0) */0;
			for (i = 0; i < generatedNumFiles; i++) {
				size_t offset = 0;
				size_t outSizeProcessed = 0;
				WCHAR temp = new WCHAR();
				if (ModernizedCProgram.SzArEx_GetFileNameUtf16(db, i, ((Object)0)) >= 260) {
					res = 11;
					break;
				} 
				temp = path + pathLen;
				ModernizedCProgram.SzArEx_GetFileNameUtf16(db, i, (UInt16)temp);
				{ 
					res = generatedVt.SzArEx_Extract(db, i, blockIndex, outBuffer, outBufferSize, offset, outSizeProcessed, allocImp, allocTempImp);
					if (res != 0) {
						break;
					} 
				}
				{ 
					CSzFile outFile = new CSzFile();
					size_t processedSize = new size_t();
					size_t j = new size_t();
					size_t nameStartPos = 0;
					for (j = 0; temp[j] != 0; j++) {
						if (temp[j] == (byte)'/') {
							temp[j] = 0;
							ModernizedCProgram.MyCreateDir(path);
							temp[j] = (byte)'\\';
							nameStartPos = j + 1;
						} 
					}
					if (((((generatedIsDirs)[(i) >> 3] & (-1024 >> ((i) & 7))) != 0))) {
						ModernizedCProgram.MyCreateDir(path);
						continue;
					} else {
							int extLen;
							WCHAR name = temp + nameStartPos;
							int len = (int).wcslen(name);
							int nameLen = ModernizedCProgram.FindExt(temp + nameStartPos, extLen);
							int extPrice = ModernizedCProgram.FindItem(ModernizedCProgram.kExts,  / , name + len - extLen, extLen);
							int namePrice = ModernizedCProgram.FindItem(ModernizedCProgram.kNames,  / , name, nameLen);
							int price = namePrice + extPrice * 64 + (nameStartPos == 0 ? 0 : (1 << 12));
							if (minPrice > price) {
								minPrice = price;
								executeFileIndex = i;
								useShellExecute = (extPrice != 2);
							} 
							if (ModernizedCProgram.DoesFileOrDirExist(path)) {
								errorMessage = "Duplicate file";
								res = 11;
								break;
							} 
							if (outFile.OutFile_OpenW(path)) {
								errorMessage = "Can't open output file";
								res = 11;
								break;
							} 
					} 
					processedSize = outSizeProcessed;
					if (outFile.File_Write(outBuffer + offset, processedSize) != 0 || processedSize != outSizeProcessed) {
						errorMessage = "Can't write output file";
						res = 11;
					} 
					if (((generatedMTime).getDefs() && ((generatedMTime).getDefs()[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
						CNtfsFileTime t = generatedMTime.getVals() + i;
						FILETIME mTime = new FILETIME();
						mTime.setDwLowDateTime(t.getLow());
						mTime.setDwHighDateTime(t.getHigh());
						.SetFileTime(generatedHandle, ((Object)0), ((Object)0), mTime);
					} 
					{ 
						SRes res2 = outFile.File_Close();
						if (res != 0) {
							break;
						} 
						if (res2 != 0) {
							res = res2;
							break;
						} 
					}
					if (((generatedAttribs).getDefs() && ((generatedAttribs).getDefs()[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
						.SetFileAttributesW(path, generatedAttribs.getVals()[i]);
					} 
				}
			}
			if (res == 0) {
				if (executeFileIndex == (UInt32)(Int32)-1) {
					errorMessage = "There is no file to execute";
					res = 11;
				} else {
						WCHAR temp = path + pathLen;
						UInt32 j = new UInt32();
						ModernizedCProgram.SzArEx_GetFileNameUtf16(db, executeFileIndex, (UInt16)temp);
						for (j = 0; temp[j] != 0; j++) {
							if (temp[j] == (byte)'/') {
								temp[j] = (byte)'\\';
							} 
						}
				} 
			} 
			.UNRECOGNIZEDFUNCTIONNAME(allocImp, outBuffer);
		} 
		db.SzArEx_Free(allocImp);
		.UNRECOGNIZEDFUNCTIONNAME(allocImp, generatedBuf);
		generatedFile.File_Close();
		Object generatedHThread = pi.getHThread();
		Object generatedHProcess = pi.getHProcess();
		if (res == 0) {
			HANDLE hProcess = 0;
			WCHAR[] oldCurDir = new WCHAR();
			oldCurDir[0] = 0;
			{ 
				DWORD needLen = .GetCurrentDirectoryW(260 + 1, oldCurDir);
				if (needLen == 0 || needLen > 260) {
					oldCurDir[0] = 0;
				} 
				.SetCurrentDirectoryW(workCurDir);
			}
			if (useShellExecute) {
				SHELLEXECUTEINFO ei = new SHELLEXECUTEINFO();
				UINT32 executeRes = new UINT32();
				BOOL success = new BOOL();
				.memset(ei, 0, );
				ei.setCbSize();
				ei.setLpFile(path);
				ei.setFMask(-1024 | -1024);
				if (.wcslen(cmdLineParams) != /* | SEE_MASK_NO_CONSOLE */0) {
					ei.setLpParameters(cmdLineParams);
				} 
				ei.setNShow(/* SW_HIDE; */1);
				success = .ShellExecuteExW(ei);
				executeRes = (UINT32)(UINT_PTR)ei.getHInstApp();
				if (!success || (executeRes <= 32 && executeRes != /* executeRes = 0 in Windows CE */0)) {
					res = 11;
				} else {
						hProcess = ei.getHProcess();
				} 
			} else {
					STARTUPINFOW si = new STARTUPINFOW();
					PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
					WCHAR[] cmdLine = new WCHAR();
					.wcscpy(cmdLine, path);
					.wcscat(cmdLine, cmdLineParams);
					.memset(si, 0, );
					si.setCb();
					if (.CreateProcessW(((Object)0), cmdLine, ((Object)0), ((Object)0), 0, 0, ((Object)0), ((Object)0), si, pi) == 0) {
						res = 11;
					} else {
							.CloseHandle(generatedHThread);
							hProcess = generatedHProcess;
					} 
			} 
			if (hProcess != 0) {
				.WaitForSingleObject(hProcess, -1024);
				if (!.GetExitCodeProcess(hProcess, exitCode)) {
					exitCode = 1;
				} 
				.CloseHandle(hProcess);
			} 
			.SetCurrentDirectoryW(oldCurDir);
		} 
		path[pathLen] = (byte)L'\0';
		ModernizedCProgram.RemoveDirWithSubItems(path);
		if (res == 0) {
			return (int)exitCode;
		} 
		{ 
			if (res == 4) {
				errorMessage = "Decoder doesn't support this archive";
			}  else if (res == 2) {
				errorMessage = "Can't allocate required memory";
			}  else if (res == 3) {
				errorMessage = "CRC error";
			} else {
					if (!errorMessage) {
						errorMessage = "ERROR";
					} 
			} 
			if (errorMessage) {
				ModernizedCProgram.PrintErrorMessage(errorMessage);
			} 
		}
		return 1;
	}
	/* gzwrite.c -- zlib functions for writing gzip files
	 * Copyright (C) 2004-2017 Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */
	/* Local functions */
	public static int gz_init(Object state) {
		int ret;
		z_streamp strm = (state.getStrm());
		state.setIn((byte).malloc(state.getWant() << /* allocate input buffer (double size for gzprintf) */1));
		if (state.getIn() == ((Object)0)) {
			ModernizedCProgram.gz_error(state, (true), "out of memory");
			return -1;
		} 
		if (!state.getDirect()) {
			state.setOut((byte).malloc(state.getWant()));
			if (state.getOut() == ((Object)0)) {
				.free(state.getIn());
				ModernizedCProgram.gz_error(state, (true), "out of memory");
				return -1;
			} 
			strm.setZalloc(/* allocate deflate memory, set up for gzip compression */0);
			strm.setZfree(0);
			strm.setOpaque(0);
			ret = ModernizedCProgram.deflateInit2_((strm), (state.getLevel()), (true), (15 + 16), (true), (state.getStrategy()), "1.2.11", (int));
			if (ret != 0) {
				.free(state.getOut());
				.free(state.getIn());
				ModernizedCProgram.gz_error(state, (true), "out of memory");
				return -1;
			} 
			strm.setNext_in(((Object)0));
		} 
		state.setSize(state.getWant());
		if (!state.getDirect()) {
			strm.setAvail_out(state.getSize());
			strm.setNext_out(state.getOut());
			state.getX().setNext(strm.getNext_out());
		} 
		return 0/* Compress whatever is at avail_in and next_in and write to the output file.
		   Return -1 if there is an error writing to the output file or if gz_init()
		   fails to allocate memory, otherwise 0.  flush is assumed to be a valid
		   deflate() flush value.  If flush is Z_FINISH, then the deflate() state is
		   reset to start a new gzip stream.  If gz->direct is true, then simply write
		   to the output file without compressing, and ignore flush. */;
	}
	public static int gz_comp(Object state, int flush) {
		int ret;
		int writ;
		int have;
		int put;
		int max = ((int)-1 >> 2) + 1;
		z_streamp strm = (state.getStrm());
		if (state.getSize() == 0 && ModernizedCProgram.gz_init(state) == -/* allocate memory if this is the first time through */1) {
			return -1;
		} 
		if (state.getDirect()) {
			while (strm.getAvail_in()) {
				put = strm.getAvail_in() > max ? max : strm.getAvail_in();
				writ = .write(state.getFd(), strm.getNext_in(), put);
				if (writ < 0) {
					ModernizedCProgram.gz_error(state, (true), .strerror((._errno())));
					return -1;
				} 
				strm.getAvail_in() -= (int)writ;
				strm.getNext_in() += writ;
			}
			return 0;
		} 
		ret = /* run deflate() on provided input until it produces no more output */0;
		do {
			if (strm.getAvail_out() == 0 || (flush != 0 && (flush != 4 || ret == 1))) {
				while (strm.getNext_out() > state.getX().getNext()) {
					put = strm.getNext_out() - state.getX().getNext() > (int)max ? max : (int)(strm.getNext_out() - state.getX().getNext());
					writ = .write(state.getFd(), state.getX().getNext(), put);
					if (writ < 0) {
						ModernizedCProgram.gz_error(state, (true), .strerror((._errno())));
						return -1;
					} 
					state.getX().getNext() += writ;
				}
				if (strm.getAvail_out() == 0) {
					strm.setAvail_out(state.getSize());
					strm.setNext_out(state.getOut());
					state.getX().setNext(state.getOut());
				} 
			} 
			have = strm.getAvail_out();
			ret = ModernizedCProgram.deflate(strm, flush);
			if (ret == (true)) {
				ModernizedCProgram.gz_error(state, (true), "internal error: deflate stream corrupt");
				return -1;
			} 
			have -= strm.getAvail_out();
		} while (have);/* write out current buffer contents if full, or if flushing, but if
		           doing Z_FINISH then don't write until we get to Z_STREAM_END */
		if (flush == /* if that completed a deflate stream, allow another to start */4) {
			ModernizedCProgram.deflateReset(strm);
		} 
		return /* all done, no errors */0;
	}
	/* Compress len zeros to output.  Return -1 on a write error or memory
	   allocation failure by gz_comp(), or 0 on success. */
	public static int gz_zero(Object state, long len) {
		int first;
		int n;
		z_streamp strm = (state.getStrm());
		if (strm.getAvail_in() && ModernizedCProgram.gz_comp(state, 0) == -/* consume whatever's left in the input buffer */1) {
			return -1;
		} 
		first = /* compress len zeros (len guaranteed > 0) */1;
		while (len) {
			n = ( ==  && (state.getSize()) > 2147483647) || (long)state.getSize() > len ? (int)len : state.getSize();
			if (first) {
				.memset(state.getIn(), 0, n);
				first = 0;
			} 
			strm.setAvail_in(n);
			strm.setNext_in(state.getIn());
			state.getX().getPos() += n;
			if (ModernizedCProgram.gz_comp(state, 0) == -1) {
				return -1;
			} 
			len -= n;
		}
		return 0;
	}
	/* Write len bytes from buf to file.  Return the number of bytes written.  If
	   the returned value is less than len, then there was an error. */
	public static Object gz_write(Object state, Object buf, Object len) {
		z_size_t put = len;
		if (len == /* if len is zero, avoid unnecessary operations */0) {
			return 0;
		} 
		if (state.getSize() == 0 && ModernizedCProgram.gz_init(state) == -/* allocate memory if this is the first time through */1) {
			return 0;
		} 
		if (state.getSeek()) {
			state.setSeek(0);
			if (ModernizedCProgram.gz_zero(state, state.getSkip()) == -1) {
				return 0;
			} 
		} 
		if (len < state.getSize()) {
			do {
				int have;
				int copy;
				if (state.getStrm().getAvail_in() == 0) {
					state.getStrm().setNext_in(state.getIn());
				} 
				have = (int)((state.getStrm().getNext_in() + state.getStrm().getAvail_in()) - state.getIn());
				copy = state.getSize() - have;
				if (copy > len) {
					copy = len;
				} 
				.memcpy(state.getIn() + have, buf, copy);
				state.getStrm().getAvail_in() += copy;
				state.getX().getPos() += copy;
				buf = (byte)buf + copy;
				len -= copy;
				if (len && ModernizedCProgram.gz_comp(state, 0) == -1) {
					return 0;
				} 
			} while (len);
		} else {
				if (state.getStrm().getAvail_in() && ModernizedCProgram.gz_comp(state, 0) == -/* consume whatever's left in the input buffer */1) {
					return 0;
				} 
				state.getStrm().setNext_in((Bytef)/* directly compress user buffer to file */buf);
				do {
					int n = (int)-1;
					if (n > len) {
						n = len;
					} 
					state.getStrm().setAvail_in(n);
					state.getX().getPos() += n;
					if (ModernizedCProgram.gz_comp(state, 0) == -1) {
						return 0;
					} 
					len -= n;
				} while (len);
		} 
		return /* input was all buffered or compressed */put;
	}
	/* Initialize state for writing a gzip file.  Mark initialization by setting
	   state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on
	   success. */
	/* -- see zlib.h -- */
	public static int gzwrite(Object file, Object buf, int len) {
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return 0;
		} 
		state = (gz_statep)file;
		if (state.getMode() != 31153 || state.getErr() != /* check that we're writing and that there's no error */0) {
			return 0;
		} 
		if ((int)len < /* since an int is returned, make sure len fits in one, otherwise return
		       with an error (this avoids a flaw in the interface) */0) {
			ModernizedCProgram.gz_error(state, (true), "requested length does not fit in int");
			return 0;
		} 
		return (int)ModernizedCProgram.gz_write(state, buf, /* write len bytes from buf (the return value will fit in an int) */len);
	}
	/* -- see zlib.h -- */
	public static Object gzfwrite(Object buf, Object size, Object nitems, Object file) {
		z_size_t len = new z_size_t();
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return 0;
		} 
		state = (gz_statep)file;
		if (state.getMode() != 31153 || state.getErr() != /* check that we're writing and that there's no error */0) {
			return 0;
		} 
		len = nitems * /* compute bytes to read -- error on overflow */size;
		if (size && len / size != nitems) {
			ModernizedCProgram.gz_error(state, (true), "request does not fit in a size_t");
			return 0;
		} 
		return len ? ModernizedCProgram.gz_write(state, buf, len) / size : /* write len bytes to buf, return the number of full items written */0;
	}
	/* -- see zlib.h -- */
	public static int gzputc(Object file, int c) {
		int have;
		byte[] buf = new byte[1];
		gz_statep state = new gz_statep();
		z_streamp strm = new z_streamp();
		if (file == ((Object)/* get internal structure */0)) {
			return -1;
		} 
		state = (gz_statep)file;
		strm = (state.getStrm());
		if (state.getMode() != 31153 || state.getErr() != /* check that we're writing and that there's no error */0) {
			return -1;
		} 
		if (state.getSeek()) {
			state.setSeek(0);
			if (ModernizedCProgram.gz_zero(state, state.getSkip()) == -1) {
				return -1;
			} 
		} 
		if (state.getSize()) {
			if (strm.getAvail_in() == 0) {
				strm.setNext_in(state.getIn());
			} 
			have = (int)((strm.getNext_in() + strm.getAvail_in()) - state.getIn());
			if (have < state.getSize()) {
				state.getIn()[have] = (byte)c;
				strm.getAvail_in()++;
				state.getX().getPos()++;
				return c & -1024;
			} 
		} 
		buf[0] = (byte)/* no room in buffer or not initialized, use gz_write() */c;
		if (ModernizedCProgram.gz_write(state, buf, 1) != 1) {
			return -1;
		} 
		return c & -1024;
	}
	/* -- see zlib.h -- */
	public static int gzputs(Object file, Object str) {
		int ret;
		z_size_t len = new z_size_t();
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return -1;
		} 
		state = (gz_statep)file;
		if (state.getMode() != 31153 || state.getErr() != /* check that we're writing and that there's no error */0) {
			return -1;
		} 
		len = .strlen(/* write string */str);
		ret = ModernizedCProgram.gz_write(state, str, len);
		return ret == 0 && len != 0 ? -1 : ret;
	}
	/* -- see zlib.h -- */
	public static int gzvprintf(Object file, Object format, Object va) {
		int len;
		int left;
		byte next;
		gz_statep state = new gz_statep();
		z_streamp strm = new z_streamp();
		if (file == ((Object)/* get internal structure */0)) {
			return (true);
		} 
		state = (gz_statep)file;
		strm = (state.getStrm());
		if (state.getMode() != 31153 || state.getErr() != /* check that we're writing and that there's no error */0) {
			return (true);
		} 
		if (state.getSize() == 0 && ModernizedCProgram.gz_init(state) == -/* make sure we have some buffer space */1) {
			return state.getErr();
		} 
		if (state.getSeek()) {
			state.setSeek(0);
			if (ModernizedCProgram.gz_zero(state, state.getSkip()) == -1) {
				return state.getErr();
			} 
		} 
		if (strm.getAvail_in() == /* do the printf() into the input buffer, put length in len -- the input
		       buffer is double-sized just for this function, so there is guaranteed to
		       be state->size bytes available after the current contents */0) {
			strm.setNext_in(state.getIn());
		} 
		next = (byte)(state.getIn() + (strm.getNext_in() - state.getIn()) + strm.getAvail_in());
		next[state.getSize() - 1] = 0;
		len = .vsnprintf(next, state.getSize(), format, va);
		if (len == 0 || (int)len >= state.getSize() || next[state.getSize() - 1] != /* check that printf() results fit in buffer */0) {
			return 0;
		} 
		strm.getAvail_in() += (int)/* update buffer and position, compress first half if past that */len;
		state.getX().getPos() += len;
		if (strm.getAvail_in() >= state.getSize()) {
			left = strm.getAvail_in() - state.getSize();
			strm.setAvail_in(state.getSize());
			if (ModernizedCProgram.gz_comp(state, 0) == -1) {
				return state.getErr();
			} 
			.memcpy(state.getIn(), state.getIn() + state.getSize(), left);
			strm.setNext_in(state.getIn());
			strm.setAvail_in(left);
		} 
		return len;
	}
	public static int gzprintf(Object file, Object format) {
		va_list va = new va_list();
		int ret;
		.__builtin_va_start(va, format);
		ret = ModernizedCProgram.gzvprintf(file, format, va);
		.__builtin_va_end(va);
		return ret/* !STDC && !Z_HAVE_STDARG_H *//* -- see zlib.h -- */;
	}
	/* get internal structure */
	/* check that can really pass pointer in ints */
	/* check that we're writing and that there's no error */
	/* make sure we have some buffer space */
	/* check for seek request */
	/* do the printf() into the input buffer, put length in len -- the input
	       buffer is double-sized just for this function, so there is guaranteed to
	       be state->size bytes available after the current contents */
	/* check that printf() results fit in buffer */
	/* update buffer and position, compress first half if past that */
	/* -- see zlib.h -- */
	public static int gzflush(Object file, int flush) {
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return (true);
		} 
		state = (gz_statep)file;
		if (state.getMode() != 31153 || state.getErr() != /* check that we're writing and that there's no error */0) {
			return (true);
		} 
		if (flush < 0 || flush > /* check flush parameter */4) {
			return (true);
		} 
		if (state.getSeek()) {
			state.setSeek(0);
			if (ModernizedCProgram.gz_zero(state, state.getSkip()) == -1) {
				return state.getErr();
			} 
		} 
		(Object)ModernizedCProgram.gz_comp(state, /* compress remaining data with requested flush */flush);
		return state.getErr();
	}
	/* -- see zlib.h -- */
	public static int gzsetparams(Object file, int level, int strategy) {
		gz_statep state = new gz_statep();
		z_streamp strm = new z_streamp();
		if (file == ((Object)/* get internal structure */0)) {
			return (true);
		} 
		state = (gz_statep)file;
		strm = (state.getStrm());
		if (state.getMode() != 31153 || state.getErr() != /* check that we're writing and that there's no error */0) {
			return (true);
		} 
		if (level == state.getLevel() && strategy == state.getStrategy()) {
			return 0;
		} 
		if (state.getSeek()) {
			state.setSeek(0);
			if (ModernizedCProgram.gz_zero(state, state.getSkip()) == -1) {
				return state.getErr();
			} 
		} 
		if (state.getSize()) {
			if (strm.getAvail_in() && ModernizedCProgram.gz_comp(state, 5) == -/* flush previous input with previous parameters before changing */1) {
				return state.getErr();
			} 
			ModernizedCProgram.deflateParams(strm, level, strategy);
		} 
		state.setLevel(level);
		state.setStrategy(strategy);
		return 0;
	}
	/* -- see zlib.h -- */
	public static int gzclose_w(Object file) {
		int ret = 0;
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return (true);
		} 
		state = (gz_statep)file;
		if (state.getMode() != /* check that we're writing */31153) {
			return (true);
		} 
		if (state.getSeek()) {
			state.setSeek(0);
			if (ModernizedCProgram.gz_zero(state, state.getSkip()) == -1) {
				ret = state.getErr();
			} 
		} 
		if (ModernizedCProgram.gz_comp(state, 4) == -/* flush, free memory, and close file */1) {
			ret = state.getErr();
		} 
		if (state.getSize()) {
			if (!state.getDirect()) {
				(Object)ModernizedCProgram.deflateEnd((state.getStrm()));
				.free(state.getOut());
			} 
			.free(state.getIn());
		} 
		ModernizedCProgram.gz_error(state, 0, ((Object)0));
		.free(state.getPath());
		if (ModernizedCProgram.close(state.getFd()) == -1) {
			ret = (true);
		} 
		.free(state);
		return ret;
	}
	public static void MyDoMinus64(_LARGE_INTEGER A, _LARGE_INTEGER B) {
		Object generatedHighPart = A.getHighPart();
		this.setHighPart(generatedHighPart - generatedHighPart);
		Object generatedLowPart = A.getLowPart();
		if (generatedLowPart >= generatedLowPart) {
			this.setLowPart(generatedLowPart - generatedLowPart);
		} else {
				this.setLowPart(generatedLowPart - generatedLowPart);
				generatedHighPart--;
		} 
	}
	//   printf("rdtsc = %I64x\n",__rdtsc());
	// printf("rdtsc = %I64x\n",__rdtsc());
	public static void myGetRDTSC32() {
		DWORD dwEdx = new DWORD();
		DWORD dwEax = new DWORD();
		_asm;
		this.setLowPart(dwEax);
		this.setHighPart(dwEdx);
	}
	public static void BeginCountRdtsc() {
		pbeginTime64.myGetRDTSC32();
	}
	public static _LARGE_INTEGER GetResRdtsc(Object fComputeTimeQueryPerf) {
		LARGE_INTEGER LIres = new LARGE_INTEGER();
		LARGE_INTEGER endTime64 = new LARGE_INTEGER();
		endTime64.myGetRDTSC32();
		LIres.setLowPart(LIres.setHighPart(0));
		LIres.MyDoMinus64(endTime64, beginTime64);
		return LIres;
	}
	public static void BeginCountPerfCounter(Object fComputeTimeQueryPerf) {
		if ((!fComputeTimeQueryPerf) || (!.QueryPerformanceCounter(pbeginTime64))) {
			this.setLowPart(.GetTickCount());
			this.setHighPart(0);
		} 
	}
	public static Object GetMsecSincePerfCounter(Object fComputeTimeQueryPerf) {
		LARGE_INTEGER endTime64 = new LARGE_INTEGER();
		LARGE_INTEGER ticksPerSecond = new LARGE_INTEGER();
		LARGE_INTEGER ticks = new LARGE_INTEGER();
		DWORDLONG ticksShifted = new DWORDLONG();
		DWORDLONG tickSecShifted = new DWORDLONG();
		DWORD dwLog = 16 + 0;
		DWORD dwRet = new DWORD();
		Object generatedLowPart = this.getLowPart();
		if ((!fComputeTimeQueryPerf) || (!.QueryPerformanceCounter(endTime64))) {
			dwRet = (.GetTickCount() - generatedLowPart) * 1;
		} else {
				ticks.MyDoMinus64(endTime64, beginTime64);
				.QueryPerformanceFrequency(ticksPerSecond);
				{ 
					ticksShifted = ((DWORDLONG)((DWORDLONG)ticks) >> (dwLog));
					tickSecShifted = ((DWORDLONG)((DWORDLONG)ticksPerSecond) >> (dwLog));
				}
				dwRet = (DWORD)((((DWORD)ticksShifted) * 1000) / (DWORD)(tickSecShifted));
				dwRet *= 1;
		} 
		return dwRet;
	}
	public static int ReadFileMemory(Object filename, long plFileSize, byte pFilePtr) {
		FILE stream = new FILE();
		byte ptr;
		int retVal = 1;
		stream = .fopen(filename, "rb");
		if (stream == ((Object)0)) {
			return 0;
		} 
		.fseek(stream, 0, 2);
		plFileSize = .ftell(stream);
		.fseek(stream, 0, 0);
		ptr = .malloc((plFileSize) + 1);
		if (ptr == ((Object)0)) {
			retVal = 0;
		} else {
				if (.fread(ptr, 1, plFileSize, stream) != (plFileSize)) {
					retVal = 0;
				} 
		} 
		.fclose(stream);
		pFilePtr = ptr;
		return retVal;
	}
	/* BraIA64.c -- Converter for IA-64 code
	2017-01-26 : Igor Pavlov : Public domain */
	public static Object IA64_Convert(Object data, Object size, Object ip, int encoding) {
		SizeT i = new SizeT();
		if (size < 16) {
			return 0;
		} 
		size -= 16;
		i = 0;
		do {
			int m = ((UInt32)-1024 >> (data[i] & -1024)) & 3;
			if (m) {
				m++;
				do {
					Byte p = data + (i + (size_t)m * 5 - 8);
					if (((p[3] >> m) & 15) == 5 && (((p[-1] | ((UInt32)p[0] << 8)) >> m) & -1024) == 0) {
						int raw = ((UInt32)(Object)(p));
						int v = raw >> m;
						v = (v & -1024) | ((v & (1 << 23)) >> 3);
						v <<=  4;
						if (encoding) {
							v += ip + (UInt32)i;
						} else {
								v -= ip + (UInt32)i;
						} 
						v >>=  4;
						v &=  -1024;
						v += -1024;
						v &=  -1024;
						raw &=  ~((UInt32)-1024 << m);
						raw |=  (v << m);
						{ 
							(UInt32)(p) = (raw);
						}
						;
					} 
				} while (++m <= 4);
			} 
			i += 16;
		} while (i <= size);
		return i;
	}
	public static Object module_kernel_threads_min(Object hashconfig, Object user_options, Object user_options_extra) {
		// RC4u32 kernel_threads_min = 64;
		return kernel_threads_min;
		// RC4u32 kernel_threads_min = 64;
		return kernel_threads_min;
		u32 kernel_threads_min = 1;
		return kernel_threads_min;
		u32 kernel_threads_min = 64;
		return kernel_threads_min;
		// RC4u32 kernel_threads_min = 64;
		return kernel_threads_min;
		// RC4u32 kernel_threads_min = 64;
		return kernel_threads_min;
		u32 kernel_threads_min = 1;
		return kernel_threads_min;
		u32 kernel_threads_min = 64;
		return kernel_threads_min;
		u32 kernel_threads_min = 64;
		return kernel_threads_min;
		u32 kernel_threads_min = 1;
		return kernel_threads_min;
		// RC4u32 kernel_threads_min = 64;
		return kernel_threads_min;
		// RC4u32 kernel_threads_min = 64;
		return kernel_threads_min;
		// RC4u32 kernel_threads_min = 64;
		return kernel_threads_min;
	}
	public static Object module_kernel_threads_max(Object hashconfig, Object user_options, Object user_options_extra) {
		// RC4u32 kernel_threads_max = 64;
		return kernel_threads_max;
		// RC4u32 kernel_threads_max = 64;
		return kernel_threads_max;
		// 16 is actually a bit low, we may need to change this depending on user responseu32 kernel_threads_max = (user_options.getKernel_threads_chgd() == 1) ? user_options.getKernel_threads() : ModernizedCProgram.SCRYPT_MAX_THREADS;
		return kernel_threads_max;
		u32 kernel_threads_max = 64;
		return kernel_threads_max;
		// RC4u32 kernel_threads_max = 64;
		return kernel_threads_max;
		// RC4u32 kernel_threads_max = 64;
		return kernel_threads_max;
		// 16 is actually a bit low, we may need to change this depending on user responseu32 kernel_threads_max = (user_options.getKernel_threads_chgd() == 1) ? user_options.getKernel_threads() : ModernizedCProgram.SCRYPT_MAX_THREADS;
		return kernel_threads_max;
		u32 kernel_threads_max = 64;
		return kernel_threads_max;
		u32 kernel_threads_max = 64;
		return kernel_threads_max;
		// 16 is actually a bit low, we may need to change this depending on user responseu32 kernel_threads_max = (user_options.getKernel_threads_chgd() == 1) ? user_options.getKernel_threads() : ModernizedCProgram.SCRYPT_MAX_THREADS;
		return kernel_threads_max;
		// performance only optimizationu32 kernel_threads_max = 64;
		return kernel_threads_max;
		// it's possible, if using too many threads, there's not enough registers available, typically ending with misleading error message:// cuLaunchKernel(): out of memoryu32 kernel_threads_max = 64;
		return kernel_threads_max;
		// RC4u32 kernel_threads_max = 64;
		return kernel_threads_max;
		// RC4u32 kernel_threads_max = 64;
		return kernel_threads_max;
		// RC4u32 kernel_threads_max = 64;
		return kernel_threads_max;
		// performance only optimizationu32 kernel_threads_max = 64;
		return kernel_threads_max;
		// performance only optimizationu32 kernel_threads_max = 64;
		return kernel_threads_max;
	}
	public static Object module_benchmark_mask(Object hashconfig, Object user_options, Object user_options_extra) {
		byte mask = "?a?a?a?a?a?a?a?axxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
		return mask;
		return "?b?b?b?b?b";
		byte mask = "?a?a?a?a?a?a?a?a";
		return mask;
		byte mask = "?b?b?b?b?b";
		return mask;
		byte mask = "?a?a?a?a?a?a?a?axxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
		return mask;
		byte mask = "?a?a?a?a?a?a?a?a";
		return mask;
		return "?b?b?b?b?b";
		byte mask = "?b?b?b?b?b?b?bxxxxxxxxxxxxxxxxx";
		return mask;
		byte mask = "?a?a?a?a?a?a?a?axxxxxxxxxxxxxxxxxxxxxxxxx";
		return mask;
		return "?b?b?b?b?bxxxxx";
		return "?b?b?b?b?b";
		byte mask = "?b?b?b?b?b?b?bx";
		return mask;
	}
	public static Object module_pw_min(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 pw_min = 64;
		return pw_min;
		// RC4-40 fixedu32 pw_min = 5;
		return pw_min;
		u32 pw_min = 8;
		return pw_min;
		u32 pw_min = 64;
		return pw_min;
		u32 pw_min = 8;
		return pw_min;
		// RC4-40 fixedu32 pw_min = 5;
		return pw_min;
		// Underlaying 3DES minu32 pw_min = 24;
		return pw_min;
		// ChaCha20 fixedu32 pw_min = 32;
		return pw_min;
		// Skip32 fixedu32 pw_min = 10;
		return pw_min;
		// RC4-40 fixedu32 pw_min = 5;
		return pw_min;
		// Underlaying DES minu32 pw_min = 8;
		return pw_min;
	}
	public static int module_hash_decode_potfile(Object hashconfig, Object digest_buf, salt salt, Object esalt_buf, Object hook_salt_buf, hashinfo hash_info, Object line_buf, Object line_len, Object tmps) {
		wpa_eapol_t wpa_eapol = (wpa_eapol_t)esalt_buf;
		wpa_pmk_tmp_t wpa_pmk_tmp = (wpa_pmk_tmp_t)tmps;
		// here we have in line_hash_buf: PMK*essid:password// but we don't care about the password
		Object generatedOut = wpa_pmk_tmp.getOut();
		// PMK// PMKgeneratedOut[0] = ModernizedCProgram.hex_to_u32((u8)line_buf + 0);
		generatedOut[1] = ModernizedCProgram.hex_to_u32((u8)line_buf + 8);
		generatedOut[2] = ModernizedCProgram.hex_to_u32((u8)line_buf + 16);
		generatedOut[3] = ModernizedCProgram.hex_to_u32((u8)line_buf + 24);
		generatedOut[4] = ModernizedCProgram.hex_to_u32((u8)line_buf + 32);
		generatedOut[5] = ModernizedCProgram.hex_to_u32((u8)line_buf + 40);
		generatedOut[6] = ModernizedCProgram.hex_to_u32((u8)line_buf + 48);
		generatedOut[7] = ModernizedCProgram.hex_to_u32((u8)line_buf + 56)// essid;// essid
		byte sep_pos = .strrchr(line_buf, (byte)':');
		if (sep_pos == ((Object)0)) {
			return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
		} 
		if ((line_buf + 64) != sep_pos) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		byte essid_pos = sep_pos + 1;
		int essid_len = .strlen(essid_pos);
		if (essid_len & 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (essid_len > 64) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedEssid = wpa_eapol.getEssid();
		wpa_eapol.setEssid_len(ModernizedCProgram.hex_decode((u8)essid_pos, essid_len, (u8)generatedEssid));
		return parser_rc.PARSER_OK;
		wpa_eapol_t wpa_eapol = (wpa_eapol_t)esalt_buf;
		wpa_pbkdf2_tmp_t wpa_pbkdf2_tmp = (wpa_pbkdf2_tmp_t)tmps;
		// here we have in line_hash_buf: PMK*essid:password// but we don't care about the password
		Object generatedOut = wpa_pbkdf2_tmp.getOut();
		// PMK// PMKgeneratedOut[0] = ModernizedCProgram.hex_to_u32((u8)line_buf + 0);
		generatedOut[1] = ModernizedCProgram.hex_to_u32((u8)line_buf + 8);
		generatedOut[2] = ModernizedCProgram.hex_to_u32((u8)line_buf + 16);
		generatedOut[3] = ModernizedCProgram.hex_to_u32((u8)line_buf + 24);
		generatedOut[4] = ModernizedCProgram.hex_to_u32((u8)line_buf + 32);
		generatedOut[5] = ModernizedCProgram.hex_to_u32((u8)line_buf + 40);
		generatedOut[6] = ModernizedCProgram.hex_to_u32((u8)line_buf + 48);
		generatedOut[7] = ModernizedCProgram.hex_to_u32((u8)line_buf + 56)// essid;// essid
		byte sep_pos = .strrchr(line_buf, (byte)':');
		if (sep_pos == ((Object)0)) {
			return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
		} 
		if ((line_buf + 64) != sep_pos) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		byte essid_pos = sep_pos + 1;
		int essid_len = .strlen(essid_pos);
		if (essid_len & 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (essid_len > 64) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedEssid = wpa_eapol.getEssid();
		wpa_eapol.setEssid_len(ModernizedCProgram.hex_decode((u8)essid_pos, essid_len, (u8)generatedEssid));
		return parser_rc.PARSER_OK;
		wpa_pmkid_t wpa_pmkid = (wpa_pmkid_t)esalt_buf;
		wpa_pmk_tmp_t wpa_pmk_tmp = (wpa_pmk_tmp_t)tmps;
		// here we have in line_hash_buf: PMK*essid:password// but we don't care about the password
		Object generatedOut = wpa_pmk_tmp.getOut();
		// PMK// PMKgeneratedOut[0] = ModernizedCProgram.hex_to_u32((u8)line_buf + 0);
		generatedOut[1] = ModernizedCProgram.hex_to_u32((u8)line_buf + 8);
		generatedOut[2] = ModernizedCProgram.hex_to_u32((u8)line_buf + 16);
		generatedOut[3] = ModernizedCProgram.hex_to_u32((u8)line_buf + 24);
		generatedOut[4] = ModernizedCProgram.hex_to_u32((u8)line_buf + 32);
		generatedOut[5] = ModernizedCProgram.hex_to_u32((u8)line_buf + 40);
		generatedOut[6] = ModernizedCProgram.hex_to_u32((u8)line_buf + 48);
		generatedOut[7] = ModernizedCProgram.hex_to_u32((u8)line_buf + 56)// essid;// essid
		byte sep_pos = .strrchr(line_buf, (byte)':');
		if (sep_pos == ((Object)0)) {
			return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
		} 
		if ((line_buf + 64) != sep_pos) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		byte essid_pos = sep_pos + 1;
		int essid_len = .strlen(essid_pos);
		if (essid_len & 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (essid_len > 64) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedEssid_buf = wpa_pmkid.getEssid_buf();
		wpa_pmkid.setEssid_len(ModernizedCProgram.hex_decode((u8)essid_pos, essid_len, (u8)generatedEssid_buf));
		return parser_rc.PARSER_OK;
		wpa_pmkid_t wpa_pmkid = (wpa_pmkid_t)esalt_buf;
		wpa_pbkdf2_tmp_t wpa_pbkdf2_tmp = (wpa_pbkdf2_tmp_t)tmps;
		// here we have in line_hash_buf: PMK*essid:password// but we don't care about the password
		Object generatedOut = wpa_pbkdf2_tmp.getOut();
		// PMK// PMKgeneratedOut[0] = ModernizedCProgram.hex_to_u32((u8)line_buf + 0);
		generatedOut[1] = ModernizedCProgram.hex_to_u32((u8)line_buf + 8);
		generatedOut[2] = ModernizedCProgram.hex_to_u32((u8)line_buf + 16);
		generatedOut[3] = ModernizedCProgram.hex_to_u32((u8)line_buf + 24);
		generatedOut[4] = ModernizedCProgram.hex_to_u32((u8)line_buf + 32);
		generatedOut[5] = ModernizedCProgram.hex_to_u32((u8)line_buf + 40);
		generatedOut[6] = ModernizedCProgram.hex_to_u32((u8)line_buf + 48);
		generatedOut[7] = ModernizedCProgram.hex_to_u32((u8)line_buf + 56)// essid;// essid
		byte sep_pos = .strrchr(line_buf, (byte)':');
		if (sep_pos == ((Object)0)) {
			return (parser_rc.PARSER_SEPARATOR_UNMATCHED);
		} 
		if ((line_buf + 64) != sep_pos) {
			return (parser_rc.PARSER_HASH_LENGTH);
		} 
		byte essid_pos = sep_pos + 1;
		int essid_len = .strlen(essid_pos);
		if (essid_len & 1) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		if (essid_len > 64) {
			return (parser_rc.PARSER_SALT_VALUE);
		} 
		Object generatedEssid_buf = wpa_pmkid.getEssid_buf();
		wpa_pmkid.setEssid_len(ModernizedCProgram.hex_decode((u8)essid_pos, essid_len, (u8)generatedEssid_buf));
		return parser_rc.PARSER_OK;
	}
	public static int module_hash_encode_potfile(Object hashconfig, Object digest_buf, Object salt, Object esalt_buf, Object hook_salt_buf, Object hash_info, Byte line_buf, Object line_size, Object tmps) {
		wpa_eapol_t wpa_eapol = (wpa_eapol_t)esalt_buf;
		wpa_pmk_tmp_t wpa_pmk_tmp = (wpa_pmk_tmp_t)tmps;
		byte[] tmp_buf = new byte[128];
		int tmp_len = ModernizedCProgram.hex_encode((u8)wpa_eapol.getEssid(), wpa_eapol.getEssid_len(), (u8)tmp_buf);
		tmp_buf[tmp_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%08x%08x%08x%08x%08x%08x%08x%08x:%s", wpa_pmk_tmp.getOut()[0], wpa_pmk_tmp.getOut()[1], wpa_pmk_tmp.getOut()[2], wpa_pmk_tmp.getOut()[3], wpa_pmk_tmp.getOut()[4], wpa_pmk_tmp.getOut()[5], wpa_pmk_tmp.getOut()[6], wpa_pmk_tmp.getOut()[7], tmp_buf);
		return line_len;
		wpa_eapol_t wpa_eapol = (wpa_eapol_t)esalt_buf;
		wpa_pbkdf2_tmp_t wpa_pbkdf2_tmp = (wpa_pbkdf2_tmp_t)tmps;
		byte[] tmp_buf = new byte[128];
		int tmp_len = ModernizedCProgram.hex_encode((u8)wpa_eapol.getEssid(), wpa_eapol.getEssid_len(), (u8)tmp_buf);
		tmp_buf[tmp_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%08x%08x%08x%08x%08x%08x%08x%08x:%s", wpa_pbkdf2_tmp.getOut()[0], wpa_pbkdf2_tmp.getOut()[1], wpa_pbkdf2_tmp.getOut()[2], wpa_pbkdf2_tmp.getOut()[3], wpa_pbkdf2_tmp.getOut()[4], wpa_pbkdf2_tmp.getOut()[5], wpa_pbkdf2_tmp.getOut()[6], wpa_pbkdf2_tmp.getOut()[7], tmp_buf);
		return line_len;
		wpa_pmkid_t wpa_pmkid = (wpa_pmkid_t)esalt_buf;
		wpa_pmk_tmp_t wpa_pmk_tmp = (wpa_pmk_tmp_t)tmps;
		byte[] tmp_buf = new byte[128];
		int tmp_len = ModernizedCProgram.hex_encode((u8)wpa_pmkid.getEssid_buf(), wpa_pmkid.getEssid_len(), (u8)tmp_buf);
		tmp_buf[tmp_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%08x%08x%08x%08x%08x%08x%08x%08x:%s", wpa_pmk_tmp.getOut()[0], wpa_pmk_tmp.getOut()[1], wpa_pmk_tmp.getOut()[2], wpa_pmk_tmp.getOut()[3], wpa_pmk_tmp.getOut()[4], wpa_pmk_tmp.getOut()[5], wpa_pmk_tmp.getOut()[6], wpa_pmk_tmp.getOut()[7], tmp_buf);
		return line_len;
		wpa_pmkid_t wpa_pmkid = (wpa_pmkid_t)esalt_buf;
		wpa_pbkdf2_tmp_t wpa_pbkdf2_tmp = (wpa_pbkdf2_tmp_t)tmps;
		byte[] tmp_buf = new byte[128];
		int tmp_len = ModernizedCProgram.hex_encode((u8)wpa_pmkid.getEssid_buf(), wpa_pmkid.getEssid_len(), (u8)tmp_buf);
		tmp_buf[tmp_len] = 0;
		int line_len = .snprintf(line_buf, line_size, "%08x%08x%08x%08x%08x%08x%08x%08x:%s", wpa_pbkdf2_tmp.getOut()[0], wpa_pbkdf2_tmp.getOut()[1], wpa_pbkdf2_tmp.getOut()[2], wpa_pbkdf2_tmp.getOut()[3], wpa_pbkdf2_tmp.getOut()[4], wpa_pbkdf2_tmp.getOut()[5], wpa_pbkdf2_tmp.getOut()[6], wpa_pbkdf2_tmp.getOut()[7], tmp_buf);
		return line_len;
	}
	public static int module_hash_binary_save(Object hashes, Object salt_pos, Object digest_pos, byte buf) {
		hccapx_t hccapx = ModernizedCProgram.hcmalloc();
		hccapx.to_hccapx_t(hashes, salt_pos, digest_pos);
		buf = (byte)hccapx;
		return ;
		hccapx_t hccapx = ModernizedCProgram.hcmalloc();
		hccapx.to_hccapx_t(hashes, salt_pos, digest_pos);
		buf = (byte)hccapx;
		return ;
		salt_t salts_buf = hashes.getSalts_buf();
		Object esalts_buf = hashes.getEsalts_buf();
		salt_t salt = salts_buf[salt_pos];
		u32 digest_cur = salt.getDigests_offset() + digest_pos;
		wpa_pmkid_t wpa_pmkids = (wpa_pmkid_t)esalts_buf;
		wpa_pmkid_t wpa_pmkid = wpa_pmkids[digest_cur];
		int len = 0;
		if (wpa_pmkid.getEssid_len()) {
			byte[] tmp_buf = new byte[128];
			int tmp_len = ModernizedCProgram.hex_encode((u8)wpa_pmkid.getEssid_buf(), wpa_pmkid.getEssid_len(), (u8)tmp_buf);
			tmp_buf[tmp_len] = 0;
			len = ModernizedCProgram.hc_asprintf(buf, "%08x%08x%08x%08x:%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%s\r\n", ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[0]), ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[1]), ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[2]), ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[3]), wpa_pmkid.getOrig_mac_ap()[0], wpa_pmkid.getOrig_mac_ap()[1], wpa_pmkid.getOrig_mac_ap()[2], wpa_pmkid.getOrig_mac_ap()[3], wpa_pmkid.getOrig_mac_ap()[4], wpa_pmkid.getOrig_mac_ap()[5], wpa_pmkid.getOrig_mac_sta()[0], wpa_pmkid.getOrig_mac_sta()[1], wpa_pmkid.getOrig_mac_sta()[2], wpa_pmkid.getOrig_mac_sta()[3], wpa_pmkid.getOrig_mac_sta()[4], wpa_pmkid.getOrig_mac_sta()[5], tmp_buf);
		} else {
				len = ModernizedCProgram.hc_asprintf(buf, "%08x%08x%08x%08x:%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x\r\n", ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[0]), ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[1]), ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[2]), ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[3]), wpa_pmkid.getOrig_mac_ap()[0], wpa_pmkid.getOrig_mac_ap()[1], wpa_pmkid.getOrig_mac_ap()[2], wpa_pmkid.getOrig_mac_ap()[3], wpa_pmkid.getOrig_mac_ap()[4], wpa_pmkid.getOrig_mac_ap()[5], wpa_pmkid.getOrig_mac_sta()[0], wpa_pmkid.getOrig_mac_sta()[1], wpa_pmkid.getOrig_mac_sta()[2], wpa_pmkid.getOrig_mac_sta()[3], wpa_pmkid.getOrig_mac_sta()[4], wpa_pmkid.getOrig_mac_sta()[5]);
		} 
		return len;
		salt_t salts_buf = hashes.getSalts_buf();
		Object esalts_buf = hashes.getEsalts_buf();
		salt_t salt = salts_buf[salt_pos];
		u32 digest_cur = salt.getDigests_offset() + digest_pos;
		wpa_pmkid_t wpa_pmkids = (wpa_pmkid_t)esalts_buf;
		wpa_pmkid_t wpa_pmkid = wpa_pmkids[digest_cur];
		byte[] tmp_buf = new byte[128];
		int tmp_len = ModernizedCProgram.hex_encode((u8)wpa_pmkid.getEssid_buf(), wpa_pmkid.getEssid_len(), (u8)tmp_buf);
		tmp_buf[tmp_len] = 0;
		int len = ModernizedCProgram.hc_asprintf(buf, "%08x%08x%08x%08x:%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%s\r\n", ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[0]), ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[1]), ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[2]), ModernizedCProgram.byte_swap_32(wpa_pmkid.getPmkid()[3]), wpa_pmkid.getOrig_mac_ap()[0], wpa_pmkid.getOrig_mac_ap()[1], wpa_pmkid.getOrig_mac_ap()[2], wpa_pmkid.getOrig_mac_ap()[3], wpa_pmkid.getOrig_mac_ap()[4], wpa_pmkid.getOrig_mac_ap()[5], wpa_pmkid.getOrig_mac_sta()[0], wpa_pmkid.getOrig_mac_sta()[1], wpa_pmkid.getOrig_mac_sta()[2], wpa_pmkid.getOrig_mac_sta()[3], wpa_pmkid.getOrig_mac_sta()[4], wpa_pmkid.getOrig_mac_sta()[5], tmp_buf);
		return len;
	}
	public static int module_hash_binary_count(Object hashes) {
		stat st = new stat();
		if (.stat(hashes.getHashfile(), st) == -1) {
			return -1;
		} 
		Object generatedSt_size = st.getSt_size();
		return generatedSt_size / ;
		stat st = new stat();
		if (.stat(hashes.getHashfile(), st) == -1) {
			return -1;
		} 
		Object generatedSt_size = st.getSt_size();
		return generatedSt_size / ;
		return 8;
	}
	public static Object module_deep_comp_kernel(Object hashes, Object salt_pos, Object digest_pos) {
		u32 digests_offset = hashes.getSalts_buf()[salt_pos].getDigests_offset();
		wpa_eapol_t wpa_eapols = (wpa_eapol_t)hashes.getEsalts_buf();
		wpa_eapol_t wpa_eapol = wpa_eapols[digests_offset + digest_pos];
		Object generatedKeyver = wpa_eapol.getKeyver();
		if (generatedKeyver == 1) {
			return kern_run.KERN_RUN_AUX1;
		}  else if (generatedKeyver == 2) {
			return kern_run.KERN_RUN_AUX2;
		}  else if ((generatedKeyver == 0) || (generatedKeyver == 3)) {
			return kern_run.KERN_RUN_AUX3;
		} 
		return 0;
		u32 digests_offset = hashes.getSalts_buf()[salt_pos].getDigests_offset();
		wpa_eapol_t wpa_eapols = (wpa_eapol_t)hashes.getEsalts_buf();
		wpa_eapol_t wpa_eapol = wpa_eapols[digests_offset + digest_pos];
		Object generatedKeyver = wpa_eapol.getKeyver();
		if (generatedKeyver == 1) {
			return kern_run.KERN_RUN_AUX1;
		}  else if (generatedKeyver == 2) {
			return kern_run.KERN_RUN_AUX2;
		}  else if (generatedKeyver == 3) {
			return kern_run.KERN_RUN_AUX3;
		} 
		return 0;
		return kern_run.KERN_RUN_AUX1;
		return kern_run.KERN_RUN_AUX1;
		return kern_run.KERN_RUN_3;
	}
	public static boolean module_potfile_custom_check(Object hashconfig, Object db, Object entry_hash, Object entry_tmps) {
		wpa_eapol_t wpa_eapol_entry = (wpa_eapol_t)entry_hash.getEsalt();
		wpa_eapol_t wpa_eapol_db = (wpa_eapol_t)db.getEsalt();
		if (wpa_eapol_db.getEssid_len() != wpa_eapol_entry.getEssid_len()) {
			return 0;
		} 
		if (.strcmp((byte)wpa_eapol_db.getEssid(), (byte)wpa_eapol_entry.getEssid())) {
			return 0;
		} 
		wpa_pmk_tmp_t wpa_pmk_tmp = (wpa_pmk_tmp_t)entry_tmps;
		wpa_pmk_tmp_t tmps = new wpa_pmk_tmp_t();
		Object generatedOut = tmps.getOut();
		generatedOut[0] = ModernizedCProgram.byte_swap_32(generatedOut[0]);
		generatedOut[1] = ModernizedCProgram.byte_swap_32(generatedOut[1]);
		generatedOut[2] = ModernizedCProgram.byte_swap_32(generatedOut[2]);
		generatedOut[3] = ModernizedCProgram.byte_swap_32(generatedOut[3]);
		generatedOut[4] = ModernizedCProgram.byte_swap_32(generatedOut[4]);
		generatedOut[5] = ModernizedCProgram.byte_swap_32(generatedOut[5]);
		generatedOut[6] = ModernizedCProgram.byte_swap_32(generatedOut[6]);
		generatedOut[7] = ModernizedCProgram.byte_swap_32(generatedOut[7]);
		plain_t plains_buf = new plain_t();
		u32 hashes_shown = 0;
		u32 d_return_buf = 0;
		Object m02501_aux;
		if (wpa_eapol_db.getKeyver() == 1) {
			m02501_aux = m02501_aux1;
		}  else if (wpa_eapol_db.getKeyver() == 2) {
			m02501_aux = m02501_aux2;
		}  else if ((wpa_eapol_db.getKeyver() == 0) || (wpa_eapol_db.getKeyver() == 3)) {
			m02501_aux = m02501_aux3;
		} else {
				return 0;
		} 
		.m02501_aux(((Object)0), ((Object)0), ((Object)0), ((Object)0), tmps, ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), plains_buf, db.getDigest(), hashes_shown, db.getSalt(), db.getEsalt(), d_return_buf, ((Object)0), ((Object)0), ((Object)0), ((Object)0), 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1)// pws// rules_buf// combs_buf// bfs_buf// tmps// hooks// bitmaps_buf_s1_a;// pws// rules_buf// combs_buf// bfs_buf// tmps// hooks// bitmaps_buf_s1_a
		// loop_pos// loop_cnt// il_cnt// digests_cnt// digests_offset// combs_mode// gid_maxboolean r = (d_return_buf == 0) ? 0 : 1;
		return r;
		wpa_eapol_t wpa_eapol_entry = (wpa_eapol_t)entry_hash.getEsalt();
		wpa_eapol_t wpa_eapol_db = (wpa_eapol_t)db.getEsalt();
		if (wpa_eapol_db.getEssid_len() != wpa_eapol_entry.getEssid_len()) {
			return 0;
		} 
		if (.strcmp((byte)wpa_eapol_db.getEssid(), (byte)wpa_eapol_entry.getEssid())) {
			return 0;
		} 
		wpa_pbkdf2_tmp_t wpa_pbkdf2_tmp = (wpa_pbkdf2_tmp_t)entry_tmps;
		wpa_pbkdf2_tmp_t tmps = new wpa_pbkdf2_tmp_t();
		Object generatedOut = tmps.getOut();
		generatedOut[0] = ModernizedCProgram.byte_swap_32(generatedOut[0]);
		generatedOut[1] = ModernizedCProgram.byte_swap_32(generatedOut[1]);
		generatedOut[2] = ModernizedCProgram.byte_swap_32(generatedOut[2]);
		generatedOut[3] = ModernizedCProgram.byte_swap_32(generatedOut[3]);
		generatedOut[4] = ModernizedCProgram.byte_swap_32(generatedOut[4]);
		generatedOut[5] = ModernizedCProgram.byte_swap_32(generatedOut[5]);
		generatedOut[6] = ModernizedCProgram.byte_swap_32(generatedOut[6]);
		generatedOut[7] = ModernizedCProgram.byte_swap_32(generatedOut[7]);
		plain_t plains_buf = new plain_t();
		u32 hashes_shown = 0;
		u32 d_return_buf = 0;
		Object m02500_aux;
		if (wpa_eapol_db.getKeyver() == 1) {
			m02500_aux = m02500_aux1;
		}  else if (wpa_eapol_db.getKeyver() == 2) {
			m02500_aux = m02500_aux2;
		}  else if (wpa_eapol_db.getKeyver() == 3) {
			m02500_aux = m02500_aux3;
		} else {
				return 0;
		} 
		.m02500_aux(((Object)0), ((Object)0), ((Object)0), ((Object)0), tmps, ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), plains_buf, db.getDigest(), hashes_shown, db.getSalt(), db.getEsalt(), d_return_buf, ((Object)0), ((Object)0), ((Object)0), ((Object)0), 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1)// pws// rules_buf// combs_buf// bfs_buf// tmps// hooks// bitmaps_buf_s1_a;// pws// rules_buf// combs_buf// bfs_buf// tmps// hooks// bitmaps_buf_s1_a
		// loop_pos// loop_cnt// il_cnt// digests_cnt// digests_offset// combs_mode// gid_maxboolean r = (d_return_buf == 0) ? 0 : 1;
		return r;
		wpa_pmkid_t wpa_pmkid_entry = (wpa_pmkid_t)entry_hash.getEsalt();
		wpa_pmkid_t wpa_pmkid_db = (wpa_pmkid_t)db.getEsalt();
		if (wpa_pmkid_db.getEssid_len() != wpa_pmkid_entry.getEssid_len()) {
			return 0;
		} 
		if (.strcmp((byte)wpa_pmkid_db.getEssid_buf(), (byte)wpa_pmkid_entry.getEssid_buf())) {
			return 0;
		} 
		wpa_pmk_tmp_t wpa_pmk_tmp = (wpa_pmk_tmp_t)entry_tmps;
		wpa_pmk_tmp_t tmps = new wpa_pmk_tmp_t();
		Object generatedOut = tmps.getOut();
		generatedOut[0] = ModernizedCProgram.byte_swap_32(generatedOut[0]);
		generatedOut[1] = ModernizedCProgram.byte_swap_32(generatedOut[1]);
		generatedOut[2] = ModernizedCProgram.byte_swap_32(generatedOut[2]);
		generatedOut[3] = ModernizedCProgram.byte_swap_32(generatedOut[3]);
		generatedOut[4] = ModernizedCProgram.byte_swap_32(generatedOut[4]);
		generatedOut[5] = ModernizedCProgram.byte_swap_32(generatedOut[5]);
		generatedOut[6] = ModernizedCProgram.byte_swap_32(generatedOut[6]);
		generatedOut[7] = ModernizedCProgram.byte_swap_32(generatedOut[7]);
		plain_t plains_buf = new plain_t();
		u32 hashes_shown = 0;
		u32 d_return_buf = 0;
		Object m16801_aux;
		m16801_aux = m16801_aux1;
		.m16801_aux(((Object)0), ((Object)0), ((Object)0), ((Object)0), tmps, ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), plains_buf, db.getDigest(), hashes_shown, db.getSalt(), db.getEsalt(), d_return_buf, ((Object)0), ((Object)0), ((Object)0), ((Object)0), 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1)// pws// rules_buf// combs_buf// bfs_buf// tmps// hooks// bitmaps_buf_s1_a;// pws// rules_buf// combs_buf// bfs_buf// tmps// hooks// bitmaps_buf_s1_a
		// loop_pos// loop_cnt// il_cnt// digests_cnt// digests_offset// combs_mode// gid_maxboolean r = (d_return_buf == 0) ? 0 : 1;
		return r;
		wpa_pmkid_t wpa_pmkid_entry = (wpa_pmkid_t)entry_hash.getEsalt();
		wpa_pmkid_t wpa_pmkid_db = (wpa_pmkid_t)db.getEsalt();
		if (wpa_pmkid_db.getEssid_len() != wpa_pmkid_entry.getEssid_len()) {
			return 0;
		} 
		if (.strcmp((byte)wpa_pmkid_db.getEssid_buf(), (byte)wpa_pmkid_entry.getEssid_buf())) {
			return 0;
		} 
		wpa_pbkdf2_tmp_t wpa_pbkdf2_tmp = (wpa_pbkdf2_tmp_t)entry_tmps;
		wpa_pbkdf2_tmp_t tmps = new wpa_pbkdf2_tmp_t();
		Object generatedOut = tmps.getOut();
		generatedOut[0] = ModernizedCProgram.byte_swap_32(generatedOut[0]);
		generatedOut[1] = ModernizedCProgram.byte_swap_32(generatedOut[1]);
		generatedOut[2] = ModernizedCProgram.byte_swap_32(generatedOut[2]);
		generatedOut[3] = ModernizedCProgram.byte_swap_32(generatedOut[3]);
		generatedOut[4] = ModernizedCProgram.byte_swap_32(generatedOut[4]);
		generatedOut[5] = ModernizedCProgram.byte_swap_32(generatedOut[5]);
		generatedOut[6] = ModernizedCProgram.byte_swap_32(generatedOut[6]);
		generatedOut[7] = ModernizedCProgram.byte_swap_32(generatedOut[7]);
		plain_t plains_buf = new plain_t();
		u32 hashes_shown = 0;
		u32 d_return_buf = 0;
		Object m16800_aux;
		m16800_aux = m16800_aux1;
		.m16800_aux(((Object)0), ((Object)0), ((Object)0), ((Object)0), tmps, ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), ((Object)0), plains_buf, db.getDigest(), hashes_shown, db.getSalt(), db.getEsalt(), d_return_buf, ((Object)0), ((Object)0), ((Object)0), ((Object)0), 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1)// pws// rules_buf// combs_buf// bfs_buf// tmps// hooks// bitmaps_buf_s1_a;// pws// rules_buf// combs_buf// bfs_buf// tmps// hooks// bitmaps_buf_s1_a
		// loop_pos// loop_cnt// il_cnt// digests_cnt// digests_offset// combs_mode// gid_maxboolean r = (d_return_buf == 0) ? 0 : 1;
		return r;
	}
	public static int module_hash_encode_status(Object hashconfig, Object digest_buf, Object salt, Object esalt_buf, Object hook_salt_buf, Object hash_info, Byte line_buf, Object line_size) {
		wpa_eapol_t wpa_eapol = (wpa_eapol_t)esalt_buf;
		Object generatedOrig_mac_ap = wpa_eapol.getOrig_mac_ap();
		Object generatedOrig_mac_sta = wpa_eapol.getOrig_mac_sta();
		int line_len = .snprintf(line_buf, line_size, "%s (AP:%02x:%02x:%02x:%02x:%02x:%02x STA:%02x:%02x:%02x:%02x:%02x:%02x)", (byte)salt.getSalt_buf(), generatedOrig_mac_ap[0], generatedOrig_mac_ap[1], generatedOrig_mac_ap[2], generatedOrig_mac_ap[3], generatedOrig_mac_ap[4], generatedOrig_mac_ap[5], generatedOrig_mac_sta[0], generatedOrig_mac_sta[1], generatedOrig_mac_sta[2], generatedOrig_mac_sta[3], generatedOrig_mac_sta[4], generatedOrig_mac_sta[5]);
		return line_len;
		wpa_eapol_t wpa_eapol = (wpa_eapol_t)esalt_buf;
		Object generatedOrig_mac_ap = wpa_eapol.getOrig_mac_ap();
		Object generatedOrig_mac_sta = wpa_eapol.getOrig_mac_sta();
		int line_len = .snprintf(line_buf, line_size, "%s (AP:%02x:%02x:%02x:%02x:%02x:%02x STA:%02x:%02x:%02x:%02x:%02x:%02x)", (byte)salt.getSalt_buf(), generatedOrig_mac_ap[0], generatedOrig_mac_ap[1], generatedOrig_mac_ap[2], generatedOrig_mac_ap[3], generatedOrig_mac_ap[4], generatedOrig_mac_ap[5], generatedOrig_mac_sta[0], generatedOrig_mac_sta[1], generatedOrig_mac_sta[2], generatedOrig_mac_sta[3], generatedOrig_mac_sta[4], generatedOrig_mac_sta[5]);
		return line_len;
	}
	public static void main_log_clear_line(Object prev_len) {
		.fputc((byte)'\r', fp);
		for (size_t i = 0;
		 i < prev_len; i++) {
			.fputc((byte)' ', fp);
		}
		.fputc((byte)'\r', fp);
	}
	public static void main_log(hashcat_ctx hashcat_ctx, _iobuf fp, Object loglevel) {
		event_ctx generatedEvent_ctx = hashcat_ctx.getEvent_ctx();
		event_ctx_t event_ctx = generatedEvent_ctx;
		Object generatedMsg_buf = event_ctx.getMsg_buf();
		byte msg_buf = generatedMsg_buf;
		Object generatedMsg_len = event_ctx.getMsg_len();
		size_t msg_len = generatedMsg_len;
		boolean generatedMsg_newline = event_ctx.getMsg_newline();
		boolean msg_newline = generatedMsg_newline;
		// handle last_len
		Object generatedPrev_len = event_ctx.getPrev_len();
		size_t prev_len = generatedPrev_len;
		if (prev_len) {
			fp.main_log_clear_line(prev_len);
		} 
		if (msg_newline == 1) {
			event_ctx.setPrev_len(0);
		} else {
				event_ctx.setPrev_len(msg_len);
		} 
		HANDLE hConsole = .GetStdHandle((DWORD)(true));
		CONSOLE_SCREEN_BUFFER_INFO con_info = new CONSOLE_SCREEN_BUFFER_INFO();
		.GetConsoleScreenBufferInfo(hConsole, con_info);
		Object generatedWAttributes = con_info.getWAttributes();
		int orig = generatedWAttributes;
		switch (loglevel) {
		case loglevel.LOGLEVEL_ERROR:
				.SetConsoleTextAttribute(hConsole, 4 | 8);
				break;
		case loglevel.LOGLEVEL_WARNING:
				.SetConsoleTextAttribute(hConsole, 6);
				break;
		case loglevel.LOGLEVEL_INFO:
				break;
		case loglevel.LOGLEVEL_ADVICE:
				.SetConsoleTextAttribute(hConsole, 6);
				break;
		}
		// finally, print// finally, print.fwrite(msg_buf, msg_len, 1, fp)// color stuff post;// color stuff post
		switch (loglevel) {
		case loglevel.LOGLEVEL_INFO:
				break;
		case loglevel.LOGLEVEL_ADVICE:
				.SetConsoleTextAttribute(hConsole, orig);
				break;
		case loglevel.LOGLEVEL_WARNING:
				.SetConsoleTextAttribute(hConsole, orig);
				break;
		case loglevel.LOGLEVEL_ERROR:
				.SetConsoleTextAttribute(hConsole, orig);
				break;
		}
		// eventual newlineif (msg_newline == 1) {
			.fwrite("\r\n", .strlen("\r\n"), 1, fp);
			if (loglevel == loglevel.LOGLEVEL_ERROR) {
				.fwrite("\r\n", .strlen("\r\n"), 1, fp);
			} 
		} 
		.fflush(fp);
	}
	public static Object module_forced_outfile_format(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 forced_outfile_format = 5;
		return forced_outfile_format;
		u32 forced_outfile_format = 5;
		return forced_outfile_format;
		u32 forced_outfile_format = 5;
		return forced_outfile_format;
	}
	public static boolean module_hlfmt_disable(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean hlfmt_disable = true;
		return hlfmt_disable;
		boolean hlfmt_disable = true;
		return hlfmt_disable;
	}
	public static Object module_kernel_loops_min(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 kernel_loops_min = ModernizedCProgram.ROUNDS_RAR3 / 16;
		return kernel_loops_min;
		u32 kernel_loops_min = ModernizedCProgram.ROUNDS_ZIP2 - 1;
		return kernel_loops_min;
		u32 kernel_loops_min = 1;
		return kernel_loops_min;
		u32 kernel_loops_min = kernel_workload.KERNEL_LOOPS_MIN;
		if (user_options.getSlow_candidates() == 0) {
			if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
				kernel_loops_min = 1024;
			} 
		} 
		return kernel_loops_min;
		u32 kernel_loops_min = kernel_workload.KERNEL_LOOPS_MIN;
		if (user_options.getSlow_candidates() == 0) {
			if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
				kernel_loops_min = 1024;
			} 
		} 
		return kernel_loops_min;
		u32 kernel_loops_min = 1;
		return kernel_loops_min;
		u32 kernel_loops_min = 1;
		return kernel_loops_min;
		u32 kernel_loops_min = kernel_workload.KERNEL_LOOPS_MIN;
		if (user_options.getSlow_candidates() == 0) {
			if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
				kernel_loops_min = 1024;
			} 
		} 
		return kernel_loops_min;
		u32 kernel_loops_min = kernel_workload.KERNEL_LOOPS_MIN;
		if (user_options.getSlow_candidates() == 0) {
			if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
				kernel_loops_min = 1024;
			} 
		} 
		return kernel_loops_min;
	}
	/* 7zAlloc.c -- Allocation functions
	2017-04-03 : Igor Pavlov : Public domain */
	/* #define _SZ_ALLOC_DEBUG */
	/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
	public static Object SzAlloc(Object p, Object size) {
		(Object)p;
		;
		if (size == 0) {
			return 0;
		} 
		return .malloc(size);
		(Object)p;
		;
		return ModernizedCProgram.MyAlloc(size);
	}
	public static void SzFree(Object p, Object address) {
		(Object)p;
		;
		.free(address);
		(Object)p;
		;
		ModernizedCProgram.MyFree(address);
	}
	public static Object SzAllocTemp(Object p, Object size) {
		(Object)p;
		;
		if (size == 0) {
			return 0;
		} 
		return .malloc(size);
	}
	public static void SzFreeTemp(Object p, Object address) {
		(Object)p;
		;
		.free(address);
	}
	/* Bra.c -- Converters for RISC code
	2017-04-04 : Igor Pavlov : Public domain */
	public static Object ARM_Convert(Object data, Object size, Object ip, int encoding) {
		Byte p = new Byte();
		Byte lim = new Byte();
		size &=  ~(size_t)3;
		ip += 4;
		p = data;
		lim = data + size;
		if (encoding) {
			for (; ; ) {
				for (; ; ) {
					if (p >= lim) {
						return p - data;
					} 
					p += 4;
					if (p[-1] == -1024) {
						break;
					} 
				}
				{ 
					UInt32 v = ((UInt32)(Object)(p - 4));
					v <<=  2;
					v += ip + (UInt32)(p - data);
					v >>=  2;
					v &=  -1024;
					v |=  -1024;
					{ 
						(UInt32)(p - 4) = (v);
					}
					;
				}
			}
		} 
		for (; ; ) {
			for (; ; ) {
				if (p >= lim) {
					return p - data;
				} 
				p += 4;
				if (p[-1] == -1024) {
					break;
				} 
			}
			{ 
				UInt32 v = ((UInt32)(Object)(p - 4));
				v <<=  2;
				v -= ip + (UInt32)(p - data);
				v >>=  2;
				v &=  -1024;
				v |=  -1024;
				{ 
					(UInt32)(p - 4) = (v);
				}
				;
			}
		}
	}
	public static Object ARMT_Convert(Object data, Object size, Object ip, int encoding) {
		Byte p = new Byte();
		Byte lim = new Byte();
		size &=  ~(size_t)1;
		p = data;
		lim = data + size - 4;
		if (encoding) {
			for (; ; ) {
				UInt32 b1 = new UInt32();
				for (; ; ) {
					UInt32 b3 = new UInt32();
					if (p > lim) {
						return p - data;
					} 
					b1 = p[1];
					b3 = p[3];
					p += 2;
					b1 ^=  8;
					if ((b3 & b1) >= -1024) {
						break;
					} 
				}
				{ 
					UInt32 v = ((UInt32)b1 << 19) + (((UInt32)p[1] & -1024) << 8) + (((UInt32)p[-2] << 11)) + (p[0]);
					p += 2;
					{ 
						UInt32 cur = (ip + (UInt32)(p - data)) >> 1;
						v += cur;
					}
					p[-4] = (Byte)(v >> 11);
					p[-3] = (Byte)(-1024 | ((v >> 19) & -1024));
					p[-2] = (Byte)v;
					p[-1] = (Byte)(-1024 | (v >> 8));
				}
			}
		} 
		for (; ; ) {
			UInt32 b1 = new UInt32();
			for (; ; ) {
				UInt32 b3 = new UInt32();
				if (p > lim) {
					return p - data;
				} 
				b1 = p[1];
				b3 = p[3];
				p += 2;
				b1 ^=  8;
				if ((b3 & b1) >= -1024) {
					break;
				} 
			}
			{ 
				UInt32 v = ((UInt32)b1 << 19) + (((UInt32)p[1] & -1024) << 8) + (((UInt32)p[-2] << 11)) + (p[0]);
				p += 2;
				{ 
					UInt32 cur = (ip + (UInt32)(p - data)) >> 1;
					v -= cur/*
					      SetUi16(p - 4, (UInt16)(((v >> 11) & 0x7FF) | 0xF000));
					      SetUi16(p - 2, (UInt16)(v | 0xF800));
					      */;
				}
				p[-4] = (Byte)(v >> 11);
				p[-3] = (Byte)(-1024 | ((v >> 19) & -1024));
				p[-2] = (Byte)v;
				p[-1] = (Byte)(-1024 | (v >> 8));
			}
		}
	}
	public static Object PPC_Convert(Object data, Object size, Object ip, int encoding) {
		Byte p = new Byte();
		Byte lim = new Byte();
		size &=  ~(size_t)3;
		ip -= 4;
		p = data;
		lim = data + size;
		for (; ; ) {
			for (; ; ) {
				if (p >= lim) {
					return p - data;
				} 
				p += 4;
				if ((p[-4] & -1024) == -1024 && (p[-1] & 3) == /* if ((v & 0xFC000003) == 0x48000001) */1) {
					break;
				} 
			}
			{ 
				UInt32 v = .__builtin_bswap32((UInt32)(Byte)(p - 4));
				if (encoding) {
					v += ip + (UInt32)(p - data);
				} else {
						v -= ip + (UInt32)(p - data);
				} 
				v &=  -1024;
				v |=  -1024;
				((UInt32)(Object)(p - 4)) = .__builtin_bswap32(v);
			}
		}
	}
	public static Object SPARC_Convert(Object data, Object size, Object ip, int encoding) {
		Byte p = new Byte();
		Byte lim = new Byte();
		size &=  ~(size_t)3;
		ip -= 4;
		p = data;
		lim = data + size;
		for (; ; ) {
			for (; ; ) {
				if (p >= lim) {
					return p - data/*
					      v = GetBe32(p);
					      p += 4;
					      m = v + ((UInt32)5 << 29);
					      m ^= (UInt32)7 << 29;
					      m += (UInt32)1 << 22;
					      if ((m & ((UInt32)0x1FF << 23)) == 0)
					        break;
					      */;
				} 
				p += 4;
				if ((p[-4] == -1024 && (p[-3] & -1024) == 0) || (p[-4] == -1024 && (p[-3] >= -1024))) {
					break;
				} 
			}
			{ 
				UInt32 v = .__builtin_bswap32((UInt32)(Byte)(p - 4));
				v <<=  2;
				if (encoding) {
					v += ip + (UInt32)(p - data);
				} else {
						v -= ip + (UInt32)(p - data);
				} 
				v &=  -1024;
				v -= (UInt32)1 << 24;
				v ^=  -1024;
				v >>=  2;
				v |=  -1024;
				((UInt32)(Object)(p - 4)) = .__builtin_bswap32(v);
			}
		}
	}
	/* Threads.c -- multithreading library
	2017-06-26 : Igor Pavlov : Public domain */
	public static Object GetError() {
		DWORD res = .GetLastError();
		return res ? (WRes)res : 1;
	}
	public static Object HandleToWRes(Object h) {
		return (h != ((Object)0)) ? 0 : ModernizedCProgram.GetError();
	}
	public static Object BOOLToWRes(Object v) {
		return v ? 0 : ModernizedCProgram.GetError();
	}
	public static Object HandlePtr_Close(Object p) {
		if (p != ((Object)0)) {
			if (!.CloseHandle(p)) {
				return ModernizedCProgram.GetError();
			} 
			p = ((Object)0);
		} 
		return 0;
	}
	public static Object Handle_WaitObject(Object h) {
		return (WRes).WaitForSingleObject(h, -1024);
	}
	public static Object Thread_Create(Object p, Object func, Object param) {
		int threadId;
		p = (HANDLE)._beginthreadex(((Object)0), 0, func, param, 0, threadId);
		return ModernizedCProgram.HandleToWRes(/* maybe we must use errno here, but probably GetLastError() is also OK. */p);
	}
	/* Windows Me/98/95: threadId parameter may not be NULL in _beginthreadex/CreateThread functions */
	public static Object Event_Create(Object p, Object manualReset, int signaled) {
		p = .CreateEventA(((Object)0), manualReset, (signaled ? 1 : 0), ((Object)0));
		return ModernizedCProgram.HandleToWRes(p);
	}
	public static Object Event_Set(Object p) {
		return ModernizedCProgram.BOOLToWRes(.SetEvent(p));
	}
	public static Object Event_Reset(Object p) {
		return ModernizedCProgram.BOOLToWRes(.ResetEvent(p));
	}
	public static Object ManualResetEvent_Create(Object p, int signaled) {
		return ModernizedCProgram.Event_Create(p, 1, signaled);
	}
	public static Object AutoResetEvent_Create(Object p, int signaled) {
		return ModernizedCProgram.Event_Create(p, 0, signaled);
	}
	public static Object ManualResetEvent_CreateNotSignaled(Object p) {
		return ModernizedCProgram.ManualResetEvent_Create(p, 0);
	}
	public static Object AutoResetEvent_CreateNotSignaled(Object p) {
		return ModernizedCProgram.AutoResetEvent_Create(p, 0);
	}
	public static Object Semaphore_Create(Object p, Object initCount, Object maxCount) {
		p = .CreateSemaphoreA(((Object)0), (LONG)initCount, (LONG)maxCount, ((Object)0));
		return ModernizedCProgram.HandleToWRes(p);
	}
	public static Object Semaphore_Release(Object p, Object releaseCount, Object previousCount) {
		return ModernizedCProgram.BOOLToWRes(.ReleaseSemaphore(p, releaseCount, previousCount));
	}
	public static Object Semaphore_ReleaseN(Object p, Object num) {
		return ModernizedCProgram.Semaphore_Release(p, (LONG)num, ((Object)0));
	}
	public static Object Semaphore_Release1(Object p) {
		return ModernizedCProgram.Semaphore_ReleaseN(p, 1);
	}
	public static Object CriticalSection_Init(Object p) {
		{ 
			.InitializeCriticalSection(p/* InitializeCriticalSectionAndSpinCount(p, 0); */);
		}
		return 0;
	}
	/* InitializeCriticalSection can raise only STATUS_NO_MEMORY exception */
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static Object get_highest_words_done(Object hashcat_ctx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		u64 words_cur = 0;
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedWords_done = device_param.getWords_done();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < backend_ctx.getBackend_devices_cnt(); backend_devices_idx++) {
			hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			if (generatedSkipped_warning == true) {
				continue;
			} 
			u64 words_done = generatedWords_done;
			if (words_done > words_cur) {
				words_cur = words_done;
			} 
		}
		return words_cur;
	}
	public static Object get_lowest_words_done(Object hashcat_ctx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		u64 words_cur = -1024;
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedWords_done = device_param.getWords_done();
		for (int backend_devices_idx = 0;
		 backend_devices_idx < backend_ctx.getBackend_devices_cnt(); backend_devices_idx++) {
			hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
			if (generatedSkipped == true) {
				continue;
			} 
			if (generatedSkipped_warning == true) {
				continue;
			} 
			u64 words_done = generatedWords_done;
			if (words_done < words_cur) {
				words_cur = words_done;
			} 
		}
		// In that case, this function would return 0 and overwrite the real restore pointstatus_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		if (words_cur < status_ctx.getWords_cur()) {
			words_cur = status_ctx.getWords_cur();
		} 
		return words_cur;
	}
	public static Object get_power(backend_ctx backend_ctx, hc_device_param device_param) {
		Object generatedKernel_power_final = backend_ctx.getKernel_power_final();
		u64 kernel_power_final = generatedKernel_power_final;
		Object generatedHardware_power = device_param.getHardware_power();
		Object generatedHardware_power_all = backend_ctx.getHardware_power_all();
		Object generatedKernel_power = device_param.getKernel_power();
		if (kernel_power_final) {
			double device_factor = (double)generatedHardware_power / generatedHardware_power_all;
			u64 words_left_device = (u64)((kernel_power_final * device_factor - (int)(kernel_power_final * device_factor)) > 0 ? kernel_power_final * device_factor + 1 : kernel_power_final * device_factor);
			u64 work = (((words_left_device) > (generatedHardware_power)) ? (words_left_device) : (generatedHardware_power));
			u64 work_final = (((work) < (generatedKernel_power)) ? (work) : (generatedKernel_power));
			return work_final;
		} 
		return generatedKernel_power;
	}
	public static Object get_work(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object max) {
		backend_ctx generatedBackend_ctx = hashcat_ctx.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		Object generatedMux_dispatcher = status_ctx.getMux_dispatcher();
		.WaitForSingleObject(generatedMux_dispatcher, -1024);
		Object generatedWords_off = status_ctx.getWords_off();
		u64 words_off = generatedWords_off;
		Object generatedLimit = user_options.getLimit();
		Object generatedWords_base = status_ctx.getWords_base();
		u64 words_base = (generatedLimit == 0) ? generatedWords_base : (((generatedLimit) < (generatedWords_base)) ? (generatedLimit) : (generatedWords_base));
		device_param.setWords_off(words_off);
		Object generatedKernel_power_all = backend_ctx.getKernel_power_all();
		u64 kernel_power_all = generatedKernel_power_all;
		u64 words_left = words_base - words_off;
		Object generatedKernel_power_final = backend_ctx.getKernel_power_final();
		if (words_left < kernel_power_all) {
			if (generatedKernel_power_final == 0) {
				hashcat_ctx.set_kernel_power_final(words_left);
			} 
		} 
		u64 kernel_power = ModernizedCProgram.get_power(backend_ctx, device_param);
		u64 work = (((words_left) < (kernel_power)) ? (words_left) : (kernel_power));
		work = (((work) < (max)) ? (work) : (max));
		generatedWords_off += work;
		.ReleaseMutex(generatedMux_dispatcher);
		return work;
	}
	public static int calc_stdin(hashcat_ctx hashcat_ctx, hc_device_param device_param) {
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = hashcat_ctx.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = hashcat_ctx.getHashes();
		hashes_t hashes = generatedHashes;
		straight_ctx generatedStraight_ctx = hashcat_ctx.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		byte buf = (byte)ModernizedCProgram.hcmalloc(-1024);
		boolean iconv_enabled = false;
		 iconv_ctx = ((Object)0);
		byte iconv_tmp = ((Object)0);
		Object generatedEncoding_from = user_options.getEncoding_from();
		Object generatedEncoding_to = user_options.getEncoding_to();
		if (.strcmp(generatedEncoding_from, generatedEncoding_to) != 0) {
			iconv_enabled = true;
			iconv_ctx = .iconv_open(generatedEncoding_to, generatedEncoding_from);
			if (iconv_ctx == (iconv_t) - 1) {
				ModernizedCProgram.hcfree(buf);
				return -1;
			} 
			iconv_tmp = (byte)ModernizedCProgram.hcmalloc(-1024);
		} 
		boolean generatedRun_thread_level1 = status_ctx.getRun_thread_level1();
		Object generatedMux_dispatcher = status_ctx.getMux_dispatcher();
		Object generatedPws_comp = device_param.getPws_comp();
		Object generatedSize_pws_comp = device_param.getSize_pws_comp();
		pw_idx generatedPws_idx = device_param.getPws_idx();
		Object generatedSize_pws_idx = device_param.getSize_pws_idx();
		Object generatedPws_cnt = device_param.getPws_cnt();
		Object generatedKernel_power = device_param.getKernel_power();
		Object generatedStdin_read_timeout_cnt = status_ctx.getStdin_read_timeout_cnt();
		Object generatedRule_len_l = user_options_extra.getRule_len_l();
		Object generatedRule_buf_l = user_options.getRule_buf_l();
		Object generatedAttack_kern = user_options_extra.getAttack_kern();
		Object generatedPw_min = hashconfig.getPw_min();
		Object generatedPw_max = hashconfig.getPw_max();
		Object generatedMux_counter = status_ctx.getMux_counter();
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		Object generatedWords_progress_rejected = status_ctx.getWords_progress_rejected();
		Object generatedKernel_rules_cnt = straight_ctx.getKernel_rules_cnt();
		boolean generatedSpeed_only_finish = device_param.getSpeed_only_finish();
		while (generatedRun_thread_level1 == true) {
			.WaitForSingleObject(generatedMux_dispatcher, -1024);
			if ((((_iob[0])).get_flag() & -1024) != 0) {
				.ReleaseMutex(generatedMux_dispatcher);
				break;
			} 
			u64 words_extra_total = 0;
			.memset(generatedPws_comp, 0, generatedSize_pws_comp);
			.memset(generatedPws_idx, 0, generatedSize_pws_idx);
			while (generatedPws_cnt < generatedKernel_power) {
				int rc_select = ModernizedCProgram.select_read_timeout_console(1);
				if (rc_select == -1) {
					break;
				} 
				if (rc_select == 0) {
					if (generatedRun_thread_level1 == false) {
						break;
					} 
					generatedStdin_read_timeout_cnt++;
					continue;
				} 
				status_ctx.setStdin_read_timeout_cnt(0);
				byte line_buf = .fgets(buf, -1024 - 1, (_iob[0]));
				if (line_buf == ((Object)0)) {
					break;
				} 
				size_t line_len = ModernizedCProgram.in_superchop(line_buf);
				line_len = hashcat_ctx.convert_from_hex(line_buf, (u32)line_len);
				if (iconv_enabled == true) {
					byte iconv_ptr = iconv_tmp;
					size_t iconv_sz = -1024;
					if (.iconv(iconv_ctx, line_buf, line_len, iconv_ptr, iconv_sz) == (size_t)-1) {
						continue;
					} 
					line_buf = iconv_tmp;
					line_len = -1024 - iconv_sz;
				} 
				byte[] rule_buf_out = new byte[256];
				if (ModernizedCProgram.run_rule_engine((int)generatedRule_len_l, generatedRule_buf_l)) {
					if (line_len >= 256) {
						continue;
					} 
					.memset(rule_buf_out, 0, );
					int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_l, (int)generatedRule_len_l, line_buf, (int)line_len, rule_buf_out);
					if (rule_len_out < 0) {
						continue;
					} 
					line_buf = rule_buf_out;
					line_len = (size_t)rule_len_out;
				} 
				if (line_len > 256) {
					continue;
				} 
				u32 attack_kern = generatedAttack_kern;
				if (attack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
					if ((line_len < generatedPw_min) || (line_len > generatedPw_max)) {
						words_extra_total++;
						continue;
					} 
				} 
				device_param.pw_add((u8)line_buf, (int)line_len);
				if (generatedRun_thread_level1 == false) {
					break;
				} 
			}
			.ReleaseMutex(generatedMux_dispatcher);
			if (words_extra_total > 0) {
				.WaitForSingleObject(generatedMux_counter, -1024);
				for (u32 salt_pos = 0;
				 salt_pos < generatedSalts_cnt; salt_pos++) {
					generatedWords_progress_rejected[salt_pos] += words_extra_total * generatedKernel_rules_cnt;
				}
				.ReleaseMutex(generatedMux_counter);
			} 
			if (generatedRun_thread_level1 == false) {
				break;
			} 
			if (generatedPws_cnt == 0) {
				break;
			} 
			if (ModernizedCProgram.run_copy(hashcat_ctx, device_param, generatedPws_cnt) == -1) {
				ModernizedCProgram.hcfree(buf);
				return -1;
			} 
			if (ModernizedCProgram.run_cracker(hashcat_ctx, device_param, generatedPws_cnt) == -1) {
				ModernizedCProgram.hcfree(buf);
				return -1;
			} 
			device_param.setPws_cnt(0);
			if (generatedRun_thread_level1 == false) {
				break;
			} 
			if (generatedSpeed_only_finish == true) {
				break;
			} 
		}
		Object generatedKernel_accel = device_param.getKernel_accel();
		device_param.setKernel_accel_prev(generatedKernel_accel);
		Object generatedKernel_loops = device_param.getKernel_loops();
		device_param.setKernel_loops_prev(generatedKernel_loops);
		device_param.setKernel_accel(0);
		device_param.setKernel_loops(0);
		if (iconv_enabled == true) {
			.iconv_close(iconv_ctx);
			ModernizedCProgram.hcfree(iconv_tmp);
		} 
		ModernizedCProgram.hcfree(buf);
		return 0;
	}
	public static Object thread_calc_stdin(Object p) {
		thread_param_t thread_param = (thread_param_t)p;
		hashcat_ctx generatedHashcat_ctx = thread_param.getHashcat_ctx();
		hashcat_ctx_t hashcat_ctx = generatedHashcat_ctx;
		backend_ctx generatedBackend_ctx = hashcat_ctx.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return ((Object)0);
		} 
		hc_device_param generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedTid = thread_param.getTid();
		hc_device_param_t device_param = generatedDevices_param + generatedTid;
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped) {
			return ((Object)0);
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return ((Object)0);
		} 
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_context = device_param.getCuda_context();
		if (generatedIs_cuda == true) {
			if (hashcat_ctx.hc_cuCtxSetCurrent(generatedCuda_context) == -1) {
				return ((Object)0);
			} 
		} 
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		if (ModernizedCProgram.calc_stdin(hashcat_ctx, device_param) == -1) {
			status_ctx_t status_ctx = generatedStatus_ctx;
			status_ctx.setDevices_status(status_rc.STATUS_ERROR);
		} 
		return ((Object)0);
	}
	public static int calc(hashcat_ctx hashcat_ctx, hc_device_param device_param) {
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = hashcat_ctx.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = hashcat_ctx.getHashes();
		hashes_t hashes = generatedHashes;
		mask_ctx generatedMask_ctx = hashcat_ctx.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		straight_ctx generatedStraight_ctx = hashcat_ctx.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		combinator_ctx generatedCombinator_ctx = hashcat_ctx.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		backend_ctx generatedBackend_ctx = hashcat_ctx.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		Object generatedAttack_mode = user_options.getAttack_mode();
		u32 attack_mode = generatedAttack_mode;
		Object generatedAttack_kern = user_options_extra.getAttack_kern();
		u32 attack_kern = generatedAttack_kern;
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		Byte generatedDict = straight_ctx.getDict();
		Object generatedFp = extra_info_straight.getFp();
		wl_data generatedWl_data = hashcat_ctx_tmp.getWl_data();
		boolean generatedRun_thread_level1 = status_ctx.getRun_thread_level1();
		Object generatedPws_comp = device_param.getPws_comp();
		Object generatedSize_pws_comp = device_param.getSize_pws_comp();
		pw_idx generatedPws_idx = device_param.getPws_idx();
		Object generatedSize_pws_idx = device_param.getSize_pws_idx();
		pw_pre generatedPws_base_buf = device_param.getPws_base_buf();
		Object generatedSize_pws_base = device_param.getSize_pws_base();
		pw_pre generatedPws_pre_buf = device_param.getPws_pre_buf();
		Object generatedSize_pws_pre = device_param.getSize_pws_pre();
		Object generatedWords_off = device_param.getWords_off();
		Object generatedOut_len = extra_info_straight.getOut_len();
		Object generatedPw_min = hashconfig.getPw_min();
		Object generatedPw_max = hashconfig.getPw_max();
		Object generatedOut_buf = extra_info_straight.getOut_buf();
		Object generatedBase_buf = extra_info_straight.getBase_buf();
		Object generatedBase_len = extra_info_straight.getBase_len();
		Object generatedRule_pos_prev = extra_info_straight.getRule_pos_prev();
		Object generatedPws_pre_cnt = device_param.getPws_pre_cnt();
		Object generatedPw_buf = pw_pre.getPw_buf();
		Object generatedPw_len = pw_pre.getPw_len();
		Object generatedMux_counter = status_ctx.getMux_counter();
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		Object generatedWords_progress_rejected = status_ctx.getWords_progress_rejected();
		Object generatedPws_cnt = device_param.getPws_cnt();
		boolean generatedSpeed_only_finish = device_param.getSpeed_only_finish();
		boolean generatedRun_thread_level2 = status_ctx.getRun_thread_level2();
		Object generatedWords_done = device_param.getWords_done();
		Object generatedCombs_mode = combinator_ctx.getCombs_mode();
		Byte generatedDict1 = combinator_ctx.getDict1();
		Byte generatedDict2 = combinator_ctx.getDict2();
		Object generatedBase_fp = extra_info_combi.getBase_fp();
		Object generatedCombs_fp = extra_info_combi.getCombs_fp();
		Byte generatedScratch_buf = device_param.getScratch_buf();
		Object generatedCss_cnt = mask_ctx.getCss_cnt();
		Object generatedOpti_type = hashconfig.getOpti_type();
		Object generatedRule_len_l = user_options_extra.getRule_len_l();
		Object generatedRule_buf_l = user_options.getRule_buf_l();
		Object generatedKernel_rules_cnt = straight_ctx.getKernel_rules_cnt();
		Object generatedCombs_cnt = combinator_ctx.getCombs_cnt();
		if (generatedSlow_candidates == true) {
			if (attack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
				byte dictfile = generatedDict;
				extra_info_straight_t extra_info_straight = new extra_info_straight_t();
				.memset(extra_info_straight, 0, );
				if (generatedFp.hc_fopen(dictfile, "rb") == 0) {
					hashcat_ctx.event_log_error("%s: %s", dictfile, .strerror((._errno())));
					return -1;
				} 
				hashcat_ctx_t hashcat_ctx_tmp = (hashcat_ctx_t)ModernizedCProgram.hcmalloc();
				.memcpy(hashcat_ctx_tmp, hashcat_ctx, );
				hashcat_ctx_tmp.setWl_data((wl_data_t)ModernizedCProgram.hcmalloc());
				if (hashcat_ctx_tmp.wl_data_init() == -1) {
					generatedFp.hc_fclose();
					ModernizedCProgram.hcfree(generatedWl_data);
					ModernizedCProgram.hcfree(hashcat_ctx_tmp);
					return -1;
				} 
				u64 words_cur = 0;
				while (generatedRun_thread_level1 == true) {
					u64 words_fin = 0;
					.memset(generatedPws_comp, 0, generatedSize_pws_comp);
					.memset(generatedPws_idx, 0, generatedSize_pws_idx);
					.memset(generatedPws_base_buf, 0, generatedSize_pws_base);
					u64 pre_rejects = -1;
					u64 pre_rejects_ignore = ModernizedCProgram.get_power(backend_ctx, device_param) / 2;
					while (pre_rejects > pre_rejects_ignore) {
						u64 words_extra_total = 0;
						u64 words_extra = pre_rejects;
						pre_rejects = 0;
						.memset(generatedPws_pre_buf, 0, generatedSize_pws_pre);
						device_param.setPws_pre_cnt(0);
						while (words_extra) {
							u64 work = ModernizedCProgram.get_work(hashcat_ctx, device_param, words_extra);
							if (work == 0) {
								break;
							} 
							u64 words_off = generatedWords_off;
							words_fin = words_off + work;
							words_extra = 0;
							hashcat_ctx_tmp.slow_candidates_seek(extra_info_straight, words_cur, words_off);
							words_cur = words_off;
							for (u64 i = words_cur;
							 i < words_fin; i++) {
								extra_info_straight.setPos(i);
								hashcat_ctx_tmp.slow_candidates_next(extra_info_straight);
								if ((generatedOut_len < generatedPw_min) || (generatedOut_len > generatedPw_max)) {
									pre_rejects++;
									continue;
								} 
								device_param.pw_pre_add(generatedOut_buf, generatedOut_len, generatedBase_buf, generatedBase_len, generatedRule_pos_prev);
								if (generatedRun_thread_level1 == false) {
									break;
								} 
							}
							words_cur = words_fin;
							words_extra_total += words_extra;
							if (generatedRun_thread_level1 == false) {
								break;
							} 
						}
						u64 pws_pre_cnt = generatedPws_pre_cnt;
						for (u64 pws_pre_idx = 0;
						 pws_pre_idx < pws_pre_cnt; pws_pre_idx++) {
							pw_pre_t pw_pre = generatedPws_pre_buf + pws_pre_idx;
							ModernizedCProgram.pw_base_add(device_param, pw_pre);
							device_param.pw_add((u8)generatedPw_buf, (int)generatedPw_len);
						}
						words_extra_total += pre_rejects;
						if (generatedRun_thread_level1 == false) {
							break;
						} 
						if (words_extra_total > 0) {
							.WaitForSingleObject(generatedMux_counter, -1024);
							for (u32 salt_pos = 0;
							 salt_pos < generatedSalts_cnt; salt_pos++) {
								generatedWords_progress_rejected[salt_pos] += words_extra_total;
							}
							.ReleaseMutex(generatedMux_counter);
						} 
					}
					u64 pws_cnt = generatedPws_cnt;
					if (pws_cnt) {
						if (ModernizedCProgram.run_copy(hashcat_ctx, device_param, pws_cnt) == -1) {
							generatedFp.hc_fclose();
							ModernizedCProgram.hcfree(generatedWl_data);
							ModernizedCProgram.hcfree(hashcat_ctx_tmp);
							return -1;
						} 
						if (ModernizedCProgram.run_cracker(hashcat_ctx, device_param, pws_cnt) == -1) {
							generatedFp.hc_fclose();
							ModernizedCProgram.hcfree(generatedWl_data);
							ModernizedCProgram.hcfree(hashcat_ctx_tmp);
							return -1;
						} 
						device_param.setPws_cnt(0);
						device_param.setPws_base_cnt(0);
					} 
					if (generatedSpeed_only_finish == true) {
						break;
					} 
					if (generatedRun_thread_level2 == true) {
						device_param.setWords_done((((generatedWords_done) > (words_fin)) ? (generatedWords_done) : (words_fin)));
						status_ctx.setWords_cur(ModernizedCProgram.get_highest_words_done(hashcat_ctx));
					} 
					if (generatedRun_thread_level1 == false) {
						break;
					} 
					if (words_fin == 0) {
						break;
					} 
				}
				generatedFp.hc_fclose();
				hashcat_ctx_tmp.wl_data_destroy();
				ModernizedCProgram.hcfree(generatedWl_data);
				ModernizedCProgram.hcfree(hashcat_ctx_tmp);
			}  else if (attack_mode == attack_mode.ATTACK_MODE_COMBI) {
				u32 combs_mode = generatedCombs_mode;
				byte base_file;
				byte combs_file;
				if (combs_mode == combinator_mode.COMBINATOR_MODE_BASE_LEFT) {
					base_file = generatedDict1;
					combs_file = generatedDict2;
				} else {
						base_file = generatedDict2;
						combs_file = generatedDict1;
				} 
				extra_info_combi_t extra_info_combi = new extra_info_combi_t();
				.memset(extra_info_combi, 0, );
				if (generatedBase_fp.hc_fopen(base_file, "rb") == 0) {
					hashcat_ctx.event_log_error("%s: %s", base_file, .strerror((._errno())));
					return -1;
				} 
				if (generatedCombs_fp.hc_fopen(combs_file, "rb") == 0) {
					hashcat_ctx.event_log_error("%s: %s", combs_file, .strerror((._errno())));
					generatedBase_fp.hc_fclose();
					return -1;
				} 
				extra_info_combi.setScratch_buf(generatedScratch_buf);
				hashcat_ctx_t hashcat_ctx_tmp = (hashcat_ctx_t)ModernizedCProgram.hcmalloc();
				.memcpy(hashcat_ctx_tmp, hashcat_ctx, );
				hashcat_ctx_tmp.setWl_data((wl_data_t)ModernizedCProgram.hcmalloc());
				if (hashcat_ctx_tmp.wl_data_init() == -1) {
					generatedBase_fp.hc_fclose();
					generatedCombs_fp.hc_fclose();
					ModernizedCProgram.hcfree(generatedWl_data);
					ModernizedCProgram.hcfree(hashcat_ctx_tmp);
					return -1;
				} 
				u64 words_cur = 0;
				while (generatedRun_thread_level1 == true) {
					u64 words_fin = 0;
					.memset(generatedPws_comp, 0, generatedSize_pws_comp);
					.memset(generatedPws_idx, 0, generatedSize_pws_idx);
					.memset(generatedPws_base_buf, 0, generatedSize_pws_base);
					u64 pre_rejects = -1;
					u64 pre_rejects_ignore = ModernizedCProgram.get_power(backend_ctx, device_param) / 2;
					while (pre_rejects > pre_rejects_ignore) {
						u64 words_extra_total = 0;
						u64 words_extra = pre_rejects;
						pre_rejects = 0;
						.memset(generatedPws_pre_buf, 0, generatedSize_pws_pre);
						device_param.setPws_pre_cnt(0);
						while (words_extra) {
							u64 work = ModernizedCProgram.get_work(hashcat_ctx, device_param, words_extra);
							if (work == 0) {
								break;
							} 
							words_extra = 0;
							u64 words_off = generatedWords_off;
							words_fin = words_off + work;
							hashcat_ctx_tmp.slow_candidates_seek(extra_info_combi, words_cur, words_off);
							words_cur = words_off;
							for (u64 i = words_cur;
							 i < words_fin; i++) {
								extra_info_combi.setPos(i);
								hashcat_ctx_tmp.slow_candidates_next(extra_info_combi);
								if ((generatedOut_len < generatedPw_min) || (generatedOut_len > generatedPw_max)) {
									pre_rejects++;
									continue;
								} 
								device_param.pw_pre_add(generatedOut_buf, generatedOut_len, ((Object)0), 0, 0);
								if (generatedRun_thread_level1 == false) {
									break;
								} 
							}
							words_cur = words_fin;
							words_extra_total += words_extra;
							if (generatedRun_thread_level1 == false) {
								break;
							} 
						}
						u64 pws_pre_cnt = generatedPws_pre_cnt;
						for (u64 pws_pre_idx = 0;
						 pws_pre_idx < pws_pre_cnt; pws_pre_idx++) {
							pw_pre_t pw_pre = generatedPws_pre_buf + pws_pre_idx;
							ModernizedCProgram.pw_base_add(device_param, pw_pre);
							device_param.pw_add((u8)generatedPw_buf, (int)generatedPw_len);
						}
						words_extra_total += pre_rejects;
						if (generatedRun_thread_level1 == false) {
							break;
						} 
						if (words_extra_total > 0) {
							.WaitForSingleObject(generatedMux_counter, -1024);
							for (u32 salt_pos = 0;
							 salt_pos < generatedSalts_cnt; salt_pos++) {
								generatedWords_progress_rejected[salt_pos] += words_extra_total;
							}
							.ReleaseMutex(generatedMux_counter);
						} 
					}
					u64 pws_cnt = generatedPws_cnt;
					if (pws_cnt) {
						if (ModernizedCProgram.run_copy(hashcat_ctx, device_param, pws_cnt) == -1) {
							generatedBase_fp.hc_fclose();
							generatedCombs_fp.hc_fclose();
							ModernizedCProgram.hcfree(generatedWl_data);
							ModernizedCProgram.hcfree(hashcat_ctx_tmp);
							return -1;
						} 
						if (ModernizedCProgram.run_cracker(hashcat_ctx, device_param, pws_cnt) == -1) {
							generatedBase_fp.hc_fclose();
							generatedCombs_fp.hc_fclose();
							ModernizedCProgram.hcfree(generatedWl_data);
							ModernizedCProgram.hcfree(hashcat_ctx_tmp);
							return -1;
						} 
						device_param.setPws_cnt(0);
						device_param.setPws_base_cnt(0);
					} 
					if (generatedSpeed_only_finish == true) {
						break;
					} 
					if (generatedRun_thread_level2 == true) {
						device_param.setWords_done((((generatedWords_done) > (words_fin)) ? (generatedWords_done) : (words_fin)));
						status_ctx.setWords_cur(ModernizedCProgram.get_highest_words_done(hashcat_ctx));
					} 
					if (generatedRun_thread_level1 == false) {
						break;
					} 
					if (words_fin == 0) {
						break;
					} 
				}
				generatedBase_fp.hc_fclose();
				generatedCombs_fp.hc_fclose();
				hashcat_ctx_tmp.wl_data_destroy();
				ModernizedCProgram.hcfree(generatedWl_data);
				ModernizedCProgram.hcfree(hashcat_ctx_tmp);
			}  else if (attack_mode == attack_mode.ATTACK_MODE_BF) {
				extra_info_mask_t extra_info_mask = new extra_info_mask_t();
				.memset(extra_info_mask, 0, );
				extra_info_mask.setOut_len(generatedCss_cnt);
				u64 words_cur = 0;
				while (generatedRun_thread_level1 == true) {
					u64 words_fin = 0;
					.memset(generatedPws_comp, 0, generatedSize_pws_comp);
					.memset(generatedPws_idx, 0, generatedSize_pws_idx);
					u64 pre_rejects = -1;
					u64 pre_rejects_ignore = ModernizedCProgram.get_power(backend_ctx, device_param) / 2;
					while (pre_rejects > pre_rejects_ignore) {
						u64 words_extra_total = 0;
						u64 words_extra = pre_rejects;
						pre_rejects = 0;
						.memset(generatedPws_pre_buf, 0, generatedSize_pws_pre);
						device_param.setPws_pre_cnt(0);
						while (words_extra) {
							u64 work = ModernizedCProgram.get_work(hashcat_ctx, device_param, words_extra);
							if (work == 0) {
								break;
							} 
							words_extra = 0;
							u64 words_off = generatedWords_off;
							words_fin = words_off + work;
							words_cur = words_off;
							for (u64 i = words_cur;
							 i < words_fin; i++) {
								extra_info_mask.setPos(i);
								hashcat_ctx.slow_candidates_next(extra_info_mask);
								device_param.pw_pre_add(generatedOut_buf, generatedOut_len, ((Object)0), 0, 0);
								if (generatedRun_thread_level1 == false) {
									break;
								} 
							}
							words_cur = words_fin;
							words_extra_total += words_extra;
							if (generatedRun_thread_level1 == false) {
								break;
							} 
						}
						u64 pws_pre_cnt = generatedPws_pre_cnt;
						for (u64 pws_pre_idx = 0;
						 pws_pre_idx < pws_pre_cnt; pws_pre_idx++) {
							pw_pre_t pw_pre = generatedPws_pre_buf + pws_pre_idx;
							device_param.pw_add((u8)generatedPw_buf, (int)generatedPw_len);
						}
						words_extra_total += pre_rejects;
						if (generatedRun_thread_level1 == false) {
							break;
						} 
						if (words_extra_total > 0) {
							.WaitForSingleObject(generatedMux_counter, -1024);
							for (u32 salt_pos = 0;
							 salt_pos < generatedSalts_cnt; salt_pos++) {
								generatedWords_progress_rejected[salt_pos] += words_extra_total;
							}
							.ReleaseMutex(generatedMux_counter);
						} 
					}
					u64 pws_cnt = generatedPws_cnt;
					if (pws_cnt) {
						if (ModernizedCProgram.run_copy(hashcat_ctx, device_param, pws_cnt) == -1) {
							return -1;
						} 
						if (ModernizedCProgram.run_cracker(hashcat_ctx, device_param, pws_cnt) == -1) {
							return -1;
						} 
						device_param.setPws_cnt(0);
					} 
					if (generatedSpeed_only_finish == true) {
						break;
					} 
					if (generatedRun_thread_level2 == true) {
						device_param.setWords_done((((generatedWords_done) > (words_fin)) ? (generatedWords_done) : (words_fin)));
						status_ctx.setWords_cur(ModernizedCProgram.get_highest_words_done(hashcat_ctx));
					} 
					if (generatedRun_thread_level1 == false) {
						break;
					} 
					if (words_fin == 0) {
						break;
					} 
				}
			} 
		} else {
				if ((attack_mode == attack_mode.ATTACK_MODE_BF) || (((generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) && (attack_mode == attack_mode.ATTACK_MODE_HYBRID2))) {
					if (((generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) && (attack_mode == attack_mode.ATTACK_MODE_HYBRID2)) {
						byte dictfile = generatedDict;
						if (generatedCombs_fp.hc_fopen(dictfile, "rb") == 0) {
							hashcat_ctx.event_log_error("%s: %s", dictfile, .strerror((._errno())));
							return -1;
						} 
					} 
					while (generatedRun_thread_level1 == true) {
						u64 work = ModernizedCProgram.get_work(hashcat_ctx, device_param, -1);
						if (work == 0) {
							break;
						} 
						u64 words_off = generatedWords_off;
						u64 words_fin = words_off + work;
						device_param.setPws_cnt(work);
						if (ModernizedCProgram.run_copy(hashcat_ctx, device_param, generatedPws_cnt) == -1) {
							return -1;
						} 
						if (ModernizedCProgram.run_cracker(hashcat_ctx, device_param, generatedPws_cnt) == -1) {
							return -1;
						} 
						device_param.setPws_cnt(0);
						if (generatedSpeed_only_finish == true) {
							break;
						} 
						if (generatedRun_thread_level2 == true) {
							device_param.setWords_done((((generatedWords_done) > (words_fin)) ? (generatedWords_done) : (words_fin)));
							status_ctx.setWords_cur(ModernizedCProgram.get_lowest_words_done(hashcat_ctx));
						} 
					}
				} else {
						byte dictfile = generatedDict;
						if (attack_mode == attack_mode.ATTACK_MODE_COMBI) {
							if (generatedCombs_mode == combinator_mode.COMBINATOR_MODE_BASE_LEFT) {
								dictfile = generatedDict1;
							} else {
									dictfile = generatedDict2;
							} 
							u32 combs_mode = generatedCombs_mode;
							if (combs_mode == combinator_mode.COMBINATOR_MODE_BASE_LEFT) {
								byte dictfilec = generatedDict2;
								if (generatedCombs_fp.hc_fopen(dictfilec, "rb") == 0) {
									hashcat_ctx.event_log_error("%s: %s", generatedDict2, .strerror((._errno())));
									return -1;
								} 
							}  else if (combs_mode == combinator_mode.COMBINATOR_MODE_BASE_RIGHT) {
								byte dictfilec = generatedDict1;
								if (generatedCombs_fp.hc_fopen(dictfilec, "rb") == 0) {
									hashcat_ctx.event_log_error("%s: %s", dictfilec, .strerror((._errno())));
									return -1;
								} 
							} 
						} 
						HCFILE fp = new HCFILE();
						if (fp.hc_fopen(dictfile, "rb") == 0) {
							hashcat_ctx.event_log_error("%s: %s", dictfile, .strerror((._errno())));
							return -1;
						} 
						hashcat_ctx_t hashcat_ctx_tmp = (hashcat_ctx_t)ModernizedCProgram.hcmalloc();
						.memcpy(hashcat_ctx_tmp, hashcat_ctx, );
						hashcat_ctx_tmp.setWl_data((wl_data_t)ModernizedCProgram.hcmalloc());
						if (hashcat_ctx_tmp.wl_data_init() == -1) {
							if (attack_mode == attack_mode.ATTACK_MODE_COMBI) {
								generatedCombs_fp.hc_fclose();
							} 
							fp.hc_fclose();
							ModernizedCProgram.hcfree(generatedWl_data);
							ModernizedCProgram.hcfree(hashcat_ctx_tmp);
							return -1;
						} 
						u64 words_cur = 0;
						while (generatedRun_thread_level1 == true) {
							u64 words_off = 0;
							u64 words_fin = 0;
							u64 words_extra = --1024;
							u64 words_extra_total = 0;
							.memset(generatedPws_comp, 0, generatedSize_pws_comp);
							.memset(generatedPws_idx, 0, generatedSize_pws_idx);
							while (words_extra) {
								u64 work = ModernizedCProgram.get_work(hashcat_ctx, device_param, words_extra);
								if (work == 0) {
									break;
								} 
								words_extra = 0;
								words_off = generatedWords_off;
								words_fin = words_off + work;
								byte line_buf;
								u32 line_len = new u32();
								byte[] rule_buf_out = new byte[256];
								for (; words_cur < words_off; words_cur++) {
									ModernizedCProgram.get_next_word(hashcat_ctx_tmp, fp, line_buf, line_len);
								}
								for (; words_cur < words_fin; words_cur++) {
									ModernizedCProgram.get_next_word(hashcat_ctx_tmp, fp, line_buf, line_len);
									if (ModernizedCProgram.run_rule_engine((int)generatedRule_len_l, generatedRule_buf_l)) {
										if (line_len >= 256) {
											continue;
										} 
										.memset(rule_buf_out, 0, );
										int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_l, (int)generatedRule_len_l, line_buf, (int)line_len, rule_buf_out);
										if (rule_len_out < 0) {
											continue;
										} 
										line_buf = rule_buf_out;
										line_len = (u32)rule_len_out;
									} 
									if (attack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
										if ((line_len < generatedPw_min) || (line_len > generatedPw_max)) {
											words_extra++;
											continue;
										} 
									}  else if (attack_kern == attack_kern.ATTACK_KERN_COMBI) {
										if (line_len > generatedPw_max) {
											words_extra++;
											continue;
										} 
									} 
									device_param.pw_add((u8)line_buf, (int)line_len);
									if (generatedRun_thread_level1 == false) {
										break;
									} 
								}
								words_extra_total += words_extra;
								if (generatedRun_thread_level1 == false) {
									break;
								} 
							}
							if (generatedRun_thread_level1 == false) {
								break;
							} 
							if (words_extra_total > 0) {
								.WaitForSingleObject(generatedMux_counter, -1024);
								for (u32 salt_pos = 0;
								 salt_pos < generatedSalts_cnt; salt_pos++) {
									if (attack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
										generatedWords_progress_rejected[salt_pos] += words_extra_total * generatedKernel_rules_cnt;
									}  else if (attack_kern == attack_kern.ATTACK_KERN_COMBI) {
										generatedWords_progress_rejected[salt_pos] += words_extra_total * generatedCombs_cnt;
									} 
								}
								.ReleaseMutex(generatedMux_counter);
							} 
							u64 pws_cnt = generatedPws_cnt;
							if (pws_cnt) {
								if (ModernizedCProgram.run_copy(hashcat_ctx, device_param, pws_cnt) == -1) {
									if (attack_mode == attack_mode.ATTACK_MODE_COMBI) {
										generatedCombs_fp.hc_fclose();
									} 
									fp.hc_fclose();
									ModernizedCProgram.hcfree(generatedWl_data);
									ModernizedCProgram.hcfree(hashcat_ctx_tmp);
									return -1;
								} 
								if (ModernizedCProgram.run_cracker(hashcat_ctx, device_param, pws_cnt) == -1) {
									if (attack_mode == attack_mode.ATTACK_MODE_COMBI) {
										generatedCombs_fp.hc_fclose();
									} 
									fp.hc_fclose();
									ModernizedCProgram.hcfree(generatedWl_data);
									ModernizedCProgram.hcfree(hashcat_ctx_tmp);
									return -1;
								} 
								device_param.setPws_cnt(0/*
								          still required?
								          if (attack_kern == ATTACK_KERN_STRAIGHT)
								          {
								            CL_rc = run_kernel_bzero (device_param, device_param->d_rules_c, device_param->size_rules_c);
								            if (CL_rc == -1)
								            {
								              if (attack_mode == ATTACK_MODE_COMBI) fclose (device_param->combs_fp);
								              fclose (fd);
								              hcfree (hashcat_ctx_tmp->wl_data);
								              hcfree (hashcat_ctx_tmp);
								              return -1;
								            }
								          }
								          else if (attack_kern == ATTACK_KERN_COMBI)
								          {
								            CL_rc = run_kernel_bzero (device_param, device_param->d_combs_c, device_param->size_combs);
								            if (CL_rc == -1)
								            {
								              if (attack_mode == ATTACK_MODE_COMBI) fclose (device_param->combs_fp);
								              fclose (fd);
								              hcfree (hashcat_ctx_tmp->wl_data);
								              hcfree (hashcat_ctx_tmp);
								              return -1;
								            }
								          }
								          */);
							} 
							if (generatedSpeed_only_finish == true) {
								break;
							} 
							if (generatedRun_thread_level2 == true) {
								device_param.setWords_done((((generatedWords_done) > (words_fin)) ? (generatedWords_done) : (words_fin)));
								status_ctx.setWords_cur(ModernizedCProgram.get_lowest_words_done(hashcat_ctx));
							} 
							if (generatedRun_thread_level1 == false) {
								break;
							} 
							if (words_fin == 0) {
								break;
							} 
						}
						if (attack_mode == attack_mode.ATTACK_MODE_COMBI) {
							generatedCombs_fp.hc_fclose();
						} 
						fp.hc_fclose();
						hashcat_ctx_tmp.wl_data_destroy();
						ModernizedCProgram.hcfree(generatedWl_data);
						ModernizedCProgram.hcfree(hashcat_ctx_tmp);
				} 
		} 
		Object generatedKernel_accel = device_param.getKernel_accel();
		device_param.setKernel_accel_prev(generatedKernel_accel);
		Object generatedKernel_loops = device_param.getKernel_loops();
		device_param.setKernel_loops_prev(generatedKernel_loops);
		device_param.setKernel_accel(0);
		device_param.setKernel_loops(0);
		return 0;
	}
	public static Object thread_calc(Object p) {
		thread_param_t thread_param = (thread_param_t)p;
		hashcat_ctx generatedHashcat_ctx = thread_param.getHashcat_ctx();
		hashcat_ctx_t hashcat_ctx = generatedHashcat_ctx;
		backend_ctx generatedBackend_ctx = hashcat_ctx.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return ((Object)0);
		} 
		hc_device_param generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedTid = thread_param.getTid();
		hc_device_param_t device_param = generatedDevices_param + generatedTid;
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped) {
			return ((Object)0);
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return ((Object)0);
		} 
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_context = device_param.getCuda_context();
		if (generatedIs_cuda == true) {
			if (hashcat_ctx.hc_cuCtxSetCurrent(generatedCuda_context) == -1) {
				return ((Object)0);
			} 
		} 
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		if (ModernizedCProgram.calc(hashcat_ctx, device_param) == -1) {
			status_ctx_t status_ctx = generatedStatus_ctx;
			status_ctx.setDevices_status(status_rc.STATUS_ERROR);
		} 
		return ((Object)0);
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int build_plain(hashcat_ctx hashcat_ctx, hc_device_param device_param, plain plain, Object plain_buf, int out_len) {
		combinator_ctx generatedCombinator_ctx = hashcat_ctx.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = hashcat_ctx.getHashes();
		hashes_t hashes = generatedHashes;
		mask_ctx generatedMask_ctx = hashcat_ctx.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		straight_ctx generatedStraight_ctx = hashcat_ctx.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = hashcat_ctx.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		Object generatedGidvid = plain.getGidvid();
		u64 gidvid = generatedGidvid;
		Object generatedIl_pos = plain.getIl_pos();
		u32 il_pos = generatedIl_pos;
		int plain_len = 0;
		u8 plain_ptr = (u8)plain_buf;
		Object generatedI = pw.getI();
		Object generatedPw_len = pw.getPw_len();
		Object generatedInnerloop_pos = device_param.getInnerloop_pos();
		Object generatedKernel_params_mp_l_buf64 = device_param.getKernel_params_mp_l_buf64();
		Object generatedKernel_params_mp_r_buf64 = device_param.getKernel_params_mp_r_buf64();
		Object generatedKernel_params_mp_l_buf32 = device_param.getKernel_params_mp_l_buf32();
		Object generatedKernel_params_mp_r_buf32 = device_param.getKernel_params_mp_r_buf32();
		Object generatedKernel_params_mp_buf64 = device_param.getKernel_params_mp_buf64();
		Object generatedKernel_params_mp_buf32 = device_param.getKernel_params_mp_buf32();
		if (user_options.getSlow_candidates() == 1) {
			pw_t pw = new pw_t();
			int rc = ModernizedCProgram.gidd_to_pw_t(hashcat_ctx, device_param, gidvid, pw);
			if (rc == -1) {
				return -1;
			} 
			.memcpy(plain_buf, generatedI, generatedPw_len);
			plain_len = generatedPw_len;
		} else {
				if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
					pw_t pw = new pw_t();
					int rc = ModernizedCProgram.gidd_to_pw_t(hashcat_ctx, device_param, gidvid, pw);
					if (rc == -1) {
						return -1;
					} 
					u64 off = generatedInnerloop_pos + il_pos;
					if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
						for (int i = 0;
						 i < 8; i++) {
							plain_buf[i] = generatedI[i];
						}
						plain_len = .apply_rules_optimized(straight_ctx.getKernel_rules_buf()[off].getCmds(), plain_buf[0], plain_buf[4], generatedPw_len);
					} else {
							for (int i = 0;
							 i < 64; i++) {
								plain_buf[i] = generatedI[i];
							}
							plain_len = .apply_rules(straight_ctx.getKernel_rules_buf()[off].getCmds(), plain_buf, generatedPw_len);
					} 
				}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_COMBI) {
					pw_t pw = new pw_t();
					int rc = ModernizedCProgram.gidd_to_pw_t(hashcat_ctx, device_param, gidvid, pw);
					if (rc == -1) {
						return -1;
					} 
					for (int i = 0;
					 i < 64; i++) {
						plain_buf[i] = generatedI[i];
					}
					plain_len = (int)generatedPw_len;
					byte comb_buf = (byte)generatedI;
					u32 comb_len = generatedPw_len;
					if (combinator_ctx.getCombs_mode() == combinator_mode.COMBINATOR_MODE_BASE_LEFT) {
						.memcpy(plain_ptr + plain_len, comb_buf, (size_t)comb_len);
					} else {
							.memmove(plain_ptr + comb_len, plain_ptr, (size_t)plain_len);
							.memcpy(plain_ptr, comb_buf, comb_len);
					} 
					plain_len += comb_len;
				}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
					u64 l_off = generatedKernel_params_mp_l_buf64[3] + gidvid;
					u64 r_off = generatedKernel_params_mp_r_buf64[3] + il_pos;
					u32 l_start = generatedKernel_params_mp_l_buf32[5];
					u32 r_start = generatedKernel_params_mp_r_buf32[5];
					u32 l_stop = generatedKernel_params_mp_l_buf32[4];
					u32 r_stop = generatedKernel_params_mp_r_buf32[4];
					mask_ctx.getRoot_css_buf().sp_exec(l_off, (byte)plain_ptr + l_start, mask_ctx.getMarkov_css_buf(), l_start, l_start + l_stop);
					mask_ctx.getRoot_css_buf().sp_exec(r_off, (byte)plain_ptr + r_start, mask_ctx.getMarkov_css_buf(), r_start, r_start + r_stop);
					plain_len = (int)mask_ctx.getCss_cnt();
				}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
					pw_t pw = new pw_t();
					int rc = ModernizedCProgram.gidd_to_pw_t(hashcat_ctx, device_param, gidvid, pw);
					if (rc == -1) {
						return -1;
					} 
					for (int i = 0;
					 i < 64; i++) {
						plain_buf[i] = generatedI[i];
					}
					plain_len = (int)generatedPw_len;
					u64 off = generatedKernel_params_mp_buf64[3] + il_pos;
					u32 start = 0;
					u32 stop = generatedKernel_params_mp_buf32[4];
					mask_ctx.getRoot_css_buf().sp_exec(off, (byte)plain_ptr + plain_len, mask_ctx.getMarkov_css_buf(), start, start + stop);
					plain_len += start + stop;
				}  else if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
					if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
						pw_t pw = new pw_t();
						int rc = ModernizedCProgram.gidd_to_pw_t(hashcat_ctx, device_param, gidvid, pw);
						if (rc == -1) {
							return -1;
						} 
						for (int i = 0;
						 i < 64; i++) {
							plain_buf[i] = generatedI[i];
						}
						plain_len = (int)generatedPw_len;
						u64 off = generatedKernel_params_mp_buf64[3] + il_pos;
						u32 start = 0;
						u32 stop = generatedKernel_params_mp_buf32[4];
						.memmove(plain_ptr + stop, plain_ptr, plain_len);
						mask_ctx.getRoot_css_buf().sp_exec(off, (byte)plain_ptr, mask_ctx.getMarkov_css_buf(), start, start + stop);
						plain_len += start + stop;
					} else {
							pw_t pw = new pw_t();
							int rc = ModernizedCProgram.gidd_to_pw_t(hashcat_ctx, device_param, gidvid, pw);
							if (rc == -1) {
								return -1;
							} 
							u64 off = generatedKernel_params_mp_buf64[3] + gidvid;
							u32 start = 0;
							u32 stop = generatedKernel_params_mp_buf32[4];
							mask_ctx.getRoot_css_buf().sp_exec(off, (byte)plain_ptr, mask_ctx.getMarkov_css_buf(), start, start + stop);
							plain_len = stop;
							byte comb_buf = (byte)generatedI;
							u32 comb_len = generatedPw_len;
							.memcpy(plain_ptr + plain_len, comb_buf, comb_len);
							plain_len += comb_len;
					} 
				} 
				if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
					if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_BRUTE_FORCE) {
						if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_SINGLE_HASH) {
							if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_APPENDED_SALT) {
								plain_len = plain_len - hashes.getSalts_buf()[0].getSalt_len();
							} 
						} 
						if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_UTF16LE) {
							for (int i = 0;
							int j = 0;
							 i < plain_len; ) {
								plain_ptr[j] = plain_ptr[i];
							}
							plain_len = plain_len / 2;
						}  else if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_UTF16BE) {
							for (int i = 1;
							int j = 0;
							 i < plain_len; ) {
								plain_ptr[j] = plain_ptr[i];
							}
							plain_len = plain_len / 2;
						} 
					} 
				} 
		} 
		int pw_max = (int)hashconfig.getPw_max();
		// pw_max is per pw_t element but in combinator we have two pw_t elements.// therefore we can support up to 64 in combinator in optimized mode (but limited by general hash limit 55)// or full 512 in pure mode (but limited by hashcat buffer size limit 256).
		// some algorithms do not support general default pw_max = 31,// therefore we need to use pw_max as a base and not hardcode it.if (plain_len > pw_max) {
			if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_COMBI) {
				if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
					pw_max = ((((pw_max * 2)) < (true)) ? ((pw_max * 2)) : (true));
				} else {
						pw_max = ((((pw_max * 2)) < (true)) ? ((pw_max * 2)) : (true));
				} 
			} 
		} 
		if (plain_len > pw_max) {
			plain_len = (((plain_len) < (pw_max)) ? (plain_len) : (pw_max));
		} 
		plain_ptr[plain_len] = 0;
		out_len = plain_len;
		return 0;
	}
	public static int build_crackpos(hashcat_ctx hashcat_ctx, hc_device_param device_param, plain plain, Object out_pos) {
		combinator_ctx generatedCombinator_ctx = hashcat_ctx.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		mask_ctx generatedMask_ctx = hashcat_ctx.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		straight_ctx generatedStraight_ctx = hashcat_ctx.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = hashcat_ctx.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		Object generatedGidvid = plain.getGidvid();
		u64 gidvid = generatedGidvid;
		Object generatedIl_pos = plain.getIl_pos();
		u32 il_pos = generatedIl_pos;
		Object generatedWords_off = device_param.getWords_off();
		u64 crackpos = generatedWords_off;
		Object generatedInnerloop_pos = device_param.getInnerloop_pos();
		if (user_options.getSlow_candidates() == 1) {
			crackpos = gidvid;
		} else {
				if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_STRAIGHT) {
					crackpos += gidvid;
					crackpos *= straight_ctx.getKernel_rules_cnt();
					crackpos += generatedInnerloop_pos + il_pos;
				}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_COMBI) {
					crackpos += gidvid;
					crackpos *= combinator_ctx.getCombs_cnt();
					crackpos += generatedInnerloop_pos + il_pos;
				}  else if (user_options_extra.getAttack_kern() == attack_mode.ATTACK_MODE_BF) {
					crackpos += gidvid;
					crackpos *= mask_ctx.getBfs_cnt();
					crackpos += generatedInnerloop_pos + il_pos;
				} 
		} 
		out_pos = crackpos;
		return 0;
	}
	public static int build_debugdata(hashcat_ctx hashcat_ctx, hc_device_param device_param, plain plain, Object debug_rule_buf, int debug_rule_len, Object debug_plain_ptr, int debug_plain_len) {
		debugfile_ctx generatedDebugfile_ctx = hashcat_ctx.getDebugfile_ctx();
		debugfile_ctx_t debugfile_ctx = generatedDebugfile_ctx;
		straight_ctx generatedStraight_ctx = hashcat_ctx.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		Object generatedGidvid = plain.getGidvid();
		u64 gidvid = generatedGidvid;
		Object generatedIl_pos = plain.getIl_pos();
		u32 il_pos = generatedIl_pos;
		if (user_options.getAttack_mode() != attack_mode.ATTACK_MODE_STRAIGHT) {
			return 0;
		} 
		u32 debug_mode = debugfile_ctx.getMode();
		if (debug_mode == 0) {
			return 0;
		} 
		pw_pre generatedPws_base_buf = device_param.getPws_base_buf();
		Object generatedRule_idx = pw_base.getRule_idx();
		Object generatedBase_buf = pw_base.getBase_buf();
		Object generatedBase_len = pw_base.getBase_len();
		Object generatedPw_len = pw.getPw_len();
		Object generatedInnerloop_pos = device_param.getInnerloop_pos();
		Object generatedI = pw.getI();
		if (user_options.getSlow_candidates() == 1) {
			pw_pre_t pw_base = generatedPws_base_buf + gidvid;
			if ((debug_mode == 1) || (debug_mode == 3) || (debug_mode == 4)) {
				int len = straight_ctx.getKernel_rules_buf()[generatedRule_idx].kernel_rule_to_cpu_rule((byte)debug_rule_buf);
				debug_rule_buf[len] = 0;
				debug_rule_len = len;
			} 
			if ((debug_mode == 2) || (debug_mode == 3) || (debug_mode == 4)) {
				.memcpy(debug_plain_ptr, generatedBase_buf, generatedBase_len);
				debug_plain_ptr[generatedBase_len] = 0;
				debug_plain_len = generatedBase_len;
			} 
		} else {
				pw_t pw = new pw_t();
				int rc = ModernizedCProgram.gidd_to_pw_t(hashcat_ctx, device_param, gidvid, pw);
				if (rc == -1) {
					return -1;
				} 
				int plain_len = (int)generatedPw_len;
				u64 off = generatedInnerloop_pos + il_pos;
				if ((debug_mode == 1) || (debug_mode == 3) || (debug_mode == 4)) {
					int len = straight_ctx.getKernel_rules_buf()[off].kernel_rule_to_cpu_rule((byte)debug_rule_buf);
					debug_rule_buf[len] = 0;
					debug_rule_len = len;
				} 
				if ((debug_mode == 2) || (debug_mode == 3) || (debug_mode == 4)) {
					.memcpy(debug_plain_ptr, (byte)generatedI, (size_t)plain_len);
					debug_plain_ptr[plain_len] = 0;
					debug_plain_len = plain_len;
				} 
		} 
		return 0;
	}
	/*
	  Additional tools for Minizip
	  Code: Xavier Roche '2004
	  License: Same as ZLIB (www.gzip.org)
	*/
	/* Code */
	public static int unzRepair(Object file, Object fileOut, Object fileOutTmp, Object nRecovered, Object bytesRecovered) {
		int err = 0;
		FILE fpZip = .fopen(file, "rb");
		FILE fpOut = .fopen(fileOut, "wb");
		FILE fpOutCD = .fopen(fileOutTmp, "wb");
		if (fpZip != ((Object)0) && fpOut != ((Object)0)) {
			int entries = 0;
			uLong totalBytes = 0;
			byte[] header = new byte[30];
			byte[] filename = new byte[1024];
			byte[] extra = new byte[1024];
			int offset = 0;
			int offsetCD = 0;
			while (.fread(header, 1, 30, fpZip) == 30) {
				int currentOffset = offset;
				if (((((byte)(header)) | (((byte)(header + 1)) << 8)) | ((((byte)((header) + 2)) | (((byte)((header) + 2 + 1)) << 8)) << 16)) == /* File entry */-1024) {
					int version = (((byte)(header + 4)) | (((byte)(header + 4 + 1)) << 8));
					int gpflag = (((byte)(header + 6)) | (((byte)(header + 6 + 1)) << 8));
					int method = (((byte)(header + 8)) | (((byte)(header + 8 + 1)) << 8));
					int filetime = (((byte)(header + 10)) | (((byte)(header + 10 + 1)) << 8));
					int filedate = (((byte)(header + 12)) | (((byte)(header + 12 + 1)) << 8));
					int crc = ((((byte)(header + 14)) | (((byte)(header + 14 + 1)) << 8)) | ((((byte)((header + 14) + 2)) | (((byte)((header + 14) + 2 + 1)) << 8)) << /* crc */16));
					int cpsize = ((((byte)(header + 18)) | (((byte)(header + 18 + 1)) << 8)) | ((((byte)((header + 18) + 2)) | (((byte)((header + 18) + 2 + 1)) << 8)) << /* compressed size */16));
					int uncpsize = ((((byte)(header + 22)) | (((byte)(header + 22 + 1)) << 8)) | ((((byte)((header + 22) + 2)) | (((byte)((header + 22) + 2 + 1)) << 8)) << /* uncompressed sz */16));
					int fnsize = (((byte)(header + 26)) | (((byte)(header + 26 + 1)) << /* file name length */8));
					int extsize = (((byte)(header + 28)) | (((byte)(header + 28 + 1)) << /* extra field length */8));
					filename[0] = extra[0] = (byte)'\0';
					if (.fwrite(header, 1, 30, fpOut) == /* Header */30) {
						offset += 30;
					} else {
							err = (true);
							break;
					} 
					if (fnsize > /* Filename */0) {
						if (fnsize < ) {
							if (.fread(filename, 1, fnsize, fpZip) == fnsize) {
								if (.fwrite(filename, 1, fnsize, fpOut) == fnsize) {
									offset += fnsize;
								} else {
										err = (true);
										break;
								} 
							} else {
									err = (true);
									break;
							} 
						} else {
								err = (true);
								break;
						} 
					} else {
							err = (true);
							break;
					} 
					if (extsize > /* Extra field */0) {
						if (extsize < ) {
							if (.fread(extra, 1, extsize, fpZip) == extsize) {
								if (.fwrite(extra, 1, extsize, fpOut) == extsize) {
									offset += extsize;
								} else {
										err = (true);
										break;
								} 
							} else {
									err = (true);
									break;
							} 
						} else {
								err = (true);
								break;
						} 
					} 
					{ 
						int dataSize = /* Data */cpsize;
						if (dataSize == 0) {
							dataSize = uncpsize;
						} 
						if (dataSize > 0) {
							byte data = .malloc(dataSize);
							if (data != ((Object)0)) {
								if ((int).fread(data, 1, dataSize, fpZip) == dataSize) {
									if ((int).fwrite(data, 1, dataSize, fpOut) == dataSize) {
										offset += dataSize;
										totalBytes += dataSize;
									} else {
											err = (true);
									} 
								} else {
										err = (true);
								} 
								.free(data);
								if (err != 0) {
									break;
								} 
							} else {
									err = (true);
									break;
							} 
						} 
					}
					{ 
						byte[] header = new byte[/* Central directory entry */46];
						byte comment = "";
						int comsize = (int).strlen(comment);
						do {
							do {
								do {
									((byte)((byte)((byte)(header)))) = (byte)(((true) & -1024) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header))) + 1)) = (byte)((((true) & -1024) >> 8) & -1024);
								} while (0);
							} while (0);
							do {
								do {
									((byte)((byte)((byte)(header) + 2))) = (byte)(((true) >> 16) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header) + 2)) + 1)) = (byte)((((true) >> 16) >> 8) & -1024);
								} while (0);
							} while (0);
						} while (0);
						do {
							do {
								((byte)((byte)(header + 4))) = (byte)((version) & -1024);
							} while (0);
							do {
								((byte)(((byte)(header + 4)) + 1)) = (byte)(((version) >> 8) & -1024);
							} while (0);
						} while (0);
						do {
							do {
								((byte)((byte)(header + 6))) = (byte)((version) & -1024);
							} while (0);
							do {
								((byte)(((byte)(header + 6)) + 1)) = (byte)(((version) >> 8) & -1024);
							} while (0);
						} while (0);
						do {
							do {
								((byte)((byte)(header + 8))) = (byte)((gpflag) & -1024);
							} while (0);
							do {
								((byte)(((byte)(header + 8)) + 1)) = (byte)(((gpflag) >> 8) & -1024);
							} while (0);
						} while (0);
						do {
							do {
								((byte)((byte)(header + 10))) = (byte)((method) & -1024);
							} while (0);
							do {
								((byte)(((byte)(header + 10)) + 1)) = (byte)(((method) >> 8) & -1024);
							} while (0);
						} while (0);
						do {
							do {
								((byte)((byte)(header + 12))) = (byte)((filetime) & -1024);
							} while (0);
							do {
								((byte)(((byte)(header + 12)) + 1)) = (byte)(((filetime) >> 8) & -1024);
							} while (0);
						} while (0);
						do {
							do {
								((byte)((byte)(header + 14))) = (byte)((filedate) & -1024);
							} while (0);
							do {
								((byte)(((byte)(header + 14)) + 1)) = (byte)(((filedate) >> 8) & -1024);
							} while (0);
						} while (0);
						do {
							do {
								do {
									((byte)((byte)((byte)(header + 16)))) = (byte)(((crc) & -1024) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header + 16))) + 1)) = (byte)((((crc) & -1024) >> 8) & -1024);
								} while (0);
							} while (0);
							do {
								do {
									((byte)((byte)((byte)(header + 16) + 2))) = (byte)(((crc) >> 16) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header + 16) + 2)) + 1)) = (byte)((((crc) >> 16) >> 8) & -1024);
								} while (0);
							} while (0);
						} while (0);
						do {
							do {
								do {
									((byte)((byte)((byte)(header + 20)))) = (byte)(((cpsize) & -1024) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header + 20))) + 1)) = (byte)((((cpsize) & -1024) >> 8) & -1024);
								} while (0);
							} while (0);
							do {
								do {
									((byte)((byte)((byte)(header + 20) + 2))) = (byte)(((cpsize) >> 16) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header + 20) + 2)) + 1)) = (byte)((((cpsize) >> 16) >> 8) & -1024);
								} while (0);
							} while (0);
						} while (0);
						do {
							do {
								do {
									((byte)((byte)((byte)(header + 24)))) = (byte)(((uncpsize) & -1024) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header + 24))) + 1)) = (byte)((((uncpsize) & -1024) >> 8) & -1024);
								} while (0);
							} while (0);
							do {
								do {
									((byte)((byte)((byte)(header + 24) + 2))) = (byte)(((uncpsize) >> 16) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header + 24) + 2)) + 1)) = (byte)((((uncpsize) >> 16) >> 8) & -1024);
								} while (0);
							} while (0);
						} while (0);
						do {
							do {
								((byte)((byte)(header + 28))) = (byte)((fnsize) & -1024);
							} while (0);
							do {
								((byte)(((byte)(header + 28)) + 1)) = (byte)(((fnsize) >> 8) & -1024);
							} while (0);
						} while (0);
						do {
							do {
								((byte)((byte)(header + 30))) = (byte)((extsize) & -1024);
							} while (0);
							do {
								((byte)(((byte)(header + 30)) + 1)) = (byte)(((extsize) >> 8) & -1024);
							} while (0);
						} while (0);
						do {
							do {
								((byte)((byte)(header + 32))) = (byte)((comsize) & -1024);
							} while (0);
							do {
								((byte)(((byte)(header + 32)) + 1)) = (byte)(((comsize) >> 8) & -1024);
							} while (0);
						} while (0);
						do {
							do {
								((byte)((byte)(header + 34))) = (byte)((false) & -1024);
							} while (0);
							do {
								((byte)(((byte)(header + 34)) + 1)) = (byte)(((false) >> 8) & -1024);
							} while (0);
						} while (/* disk # */0);
						do {
							do {
								((byte)((byte)(header + 36))) = (byte)((false) & -1024);
							} while (0);
							do {
								((byte)(((byte)(header + 36)) + 1)) = (byte)(((false) >> 8) & -1024);
							} while (0);
						} while (/* int attrb */0);
						do {
							do {
								do {
									((byte)((byte)((byte)(header + 38)))) = (byte)(((false) & -1024) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header + 38))) + 1)) = (byte)((((false) & -1024) >> 8) & -1024);
								} while (0);
							} while (0);
							do {
								do {
									((byte)((byte)((byte)(header + 38) + 2))) = (byte)(((false) >> 16) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header + 38) + 2)) + 1)) = (byte)((((false) >> 16) >> 8) & -1024);
								} while (0);
							} while (0);
						} while (/* ext attrb */0);
						do {
							do {
								do {
									((byte)((byte)((byte)(header + 42)))) = (byte)(((currentOffset) & -1024) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header + 42))) + 1)) = (byte)((((currentOffset) & -1024) >> 8) & -1024);
								} while (0);
							} while (0);
							do {
								do {
									((byte)((byte)((byte)(header + 42) + 2))) = (byte)(((currentOffset) >> 16) & -1024);
								} while (0);
								do {
									((byte)(((byte)((byte)(header + 42) + 2)) + 1)) = (byte)((((currentOffset) >> 16) >> 8) & -1024);
								} while (0);
							} while (0);
						} while (0);
						if (.fwrite(header, 1, 46, fpOutCD) == /* Header */46) {
							offsetCD += 46;
							if (fnsize > /* Filename */0) {
								if (.fwrite(filename, 1, fnsize, fpOutCD) == fnsize) {
									offsetCD += fnsize;
								} else {
										err = (true);
										break;
								} 
							} else {
									err = (true);
									break;
							} 
							if (extsize > /* Extra field */0) {
								if (.fwrite(extra, 1, extsize, fpOutCD) == extsize) {
									offsetCD += extsize;
								} else {
										err = (true);
										break;
								} 
							} 
							if (comsize > /* Comment field */0) {
								if ((int).fwrite(comment, 1, comsize, fpOutCD) == comsize) {
									offsetCD += comsize;
								} else {
										err = (true);
										break;
								} 
							} 
						} else {
								err = (true);
								break;
						} 
					}
					/* Success */entries++;
				} else {
						break;
				} 
			}
			{ 
				int entriesZip = /* Final central directory  */entries;
				byte[] header = new byte[22];
				byte comment = "";
				int comsize = (int).strlen(comment);
				if (entriesZip > -1024) {
					entriesZip = -1024;
				} 
				do {
					do {
						do {
							((byte)((byte)((byte)(header)))) = (byte)(((true) & -1024) & -1024);
						} while (0);
						do {
							((byte)(((byte)((byte)(header))) + 1)) = (byte)((((true) & -1024) >> 8) & -1024);
						} while (0);
					} while (0);
					do {
						do {
							((byte)((byte)((byte)(header) + 2))) = (byte)(((true) >> 16) & -1024);
						} while (0);
						do {
							((byte)(((byte)((byte)(header) + 2)) + 1)) = (byte)((((true) >> 16) >> 8) & -1024);
						} while (0);
					} while (0);
				} while (0);
				do {
					do {
						((byte)((byte)(header + 4))) = (byte)((false) & -1024);
					} while (0);
					do {
						((byte)(((byte)(header + 4)) + 1)) = (byte)(((false) >> 8) & -1024);
					} while (0);
				} while (/* disk # */0);
				do {
					do {
						((byte)((byte)(header + 6))) = (byte)((false) & -1024);
					} while (0);
					do {
						((byte)(((byte)(header + 6)) + 1)) = (byte)(((false) >> 8) & -1024);
					} while (0);
				} while (/* disk # */0);
				do {
					do {
						((byte)((byte)(header + 8))) = (byte)((entriesZip) & -1024);
					} while (0);
					do {
						((byte)(((byte)(header + 8)) + 1)) = (byte)(((entriesZip) >> 8) & -1024);
					} while (0);
				} while (/* hack */0);
				do {
					do {
						((byte)((byte)(header + 10))) = (byte)((entriesZip) & -1024);
					} while (0);
					do {
						((byte)(((byte)(header + 10)) + 1)) = (byte)(((entriesZip) >> 8) & -1024);
					} while (0);
				} while (/* hack */0);
				do {
					do {
						do {
							((byte)((byte)((byte)(header + 12)))) = (byte)(((offsetCD) & -1024) & -1024);
						} while (0);
						do {
							((byte)(((byte)((byte)(header + 12))) + 1)) = (byte)((((offsetCD) & -1024) >> 8) & -1024);
						} while (0);
					} while (0);
					do {
						do {
							((byte)((byte)((byte)(header + 12) + 2))) = (byte)(((offsetCD) >> 16) & -1024);
						} while (0);
						do {
							((byte)(((byte)((byte)(header + 12) + 2)) + 1)) = (byte)((((offsetCD) >> 16) >> 8) & -1024);
						} while (0);
					} while (0);
				} while (/* size of CD */0);
				do {
					do {
						do {
							((byte)((byte)((byte)(header + 16)))) = (byte)(((offset) & -1024) & -1024);
						} while (0);
						do {
							((byte)(((byte)((byte)(header + 16))) + 1)) = (byte)((((offset) & -1024) >> 8) & -1024);
						} while (0);
					} while (0);
					do {
						do {
							((byte)((byte)((byte)(header + 16) + 2))) = (byte)(((offset) >> 16) & -1024);
						} while (0);
						do {
							((byte)(((byte)((byte)(header + 16) + 2)) + 1)) = (byte)((((offset) >> 16) >> 8) & -1024);
						} while (0);
					} while (0);
				} while (/* offset to CD */0);
				do {
					do {
						((byte)((byte)(header + 20))) = (byte)((comsize) & -1024);
					} while (0);
					do {
						((byte)(((byte)(header + 20)) + 1)) = (byte)(((comsize) >> 8) & -1024);
					} while (0);
				} while (/* comment */0);
				if (.fwrite(header, 1, 22, fpOutCD) == /* Header */22) {
					if (comsize > /* Comment field */0) {
						if ((int).fwrite(comment, 1, comsize, fpOutCD) != comsize) {
							err = (true);
						} 
					} 
				} else {
						err = (true);
				} 
			}
			.fclose(/* Final merge (file + central directory) */fpOutCD);
			if (err == 0) {
				fpOutCD = .fopen(fileOutTmp, "rb");
				if (fpOutCD != ((Object)0)) {
					int nRead;
					byte[] buffer = new byte[8192];
					while ((nRead = (int).fread(buffer, 1, , fpOutCD)) > 0) {
						if ((int).fwrite(buffer, 1, nRead, fpOut) != nRead) {
							err = (true);
							break;
						} 
					}
					.fclose(fpOutCD);
				} 
			} 
			.fclose(/* Close */fpZip);
			.fclose(fpOut);
			(Object).remove(/* Wipe temporary file */fileOutTmp);
			if (err == /* Number of recovered entries */0) {
				if (nRecovered != ((Object)0)) {
					nRecovered = entries;
				} 
				if (bytesRecovered != ((Object)0)) {
					bytesRecovered = totalBytes;
				} 
			} 
		} else {
				err = (true);
		} 
		return err;
	}
	public static void drupal7_decode(Object digest, Object buf) {
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[0] = (l >> 0) & -1024;
		digest[1] = (l >> 8) & -1024;
		digest[2] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[3] = (l >> 0) & -1024;
		digest[4] = (l >> 8) & -1024;
		digest[5] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[6] = (l >> 0) & -1024;
		digest[7] = (l >> 8) & -1024;
		digest[8] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[9] = (l >> 0) & -1024;
		digest[10] = (l >> 8) & -1024;
		digest[11] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[12] = (l >> 0) & -1024;
		digest[13] = (l >> 8) & -1024;
		digest[14] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[22]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[23]) << 18;
		digest[15] = (l >> 0) & -1024;
		digest[16] = (l >> 8) & -1024;
		digest[17] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[24]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[25]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[26]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[27]) << 18;
		digest[18] = (l >> 0) & -1024;
		digest[19] = (l >> 8) & -1024;
		digest[20] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[28]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[29]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[30]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[31]) << 18;
		digest[21] = (l >> 0) & -1024;
		digest[22] = (l >> 8) & -1024;
		digest[23] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[32]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[33]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[34]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[35]) << 18;
		digest[24] = (l >> 0) & -1024;
		digest[25] = (l >> 8) & -1024;
		digest[26] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[36]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[37]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[38]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[39]) << 18;
		digest[27] = (l >> 0) & -1024;
		digest[28] = (l >> 8) & -1024;
		digest[29] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[40]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[41]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[42]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[43]) << 18;
		digest[30] = (l >> 0) & -1024;
		digest[31] = (l >> 8) & -1024;
		digest[32] = (l >> 16) & -1024;
		digest[33] = 0;
		digest[34] = 0;
		digest[35] = 0;
		digest[36] = 0;
		digest[37] = 0;
		digest[38] = 0;
		digest[39] = 0;
		digest[40] = 0;
		digest[41] = 0;
		digest[42] = 0;
		digest[43] = 0;
		digest[44] = 0;
		digest[45] = 0;
		digest[46] = 0;
		digest[47] = 0;
		digest[48] = 0;
		digest[49] = 0;
		digest[50] = 0;
		digest[51] = 0;
		digest[52] = 0;
		digest[53] = 0;
		digest[54] = 0;
		digest[55] = 0;
		digest[56] = 0;
		digest[57] = 0;
		digest[58] = 0;
		digest[59] = 0;
		digest[60] = 0;
		digest[61] = 0;
		digest[62] = 0;
		digest[63] = 0;
	}
	public static void drupal7_encode(Object digest, Object buf) {
		int l;
		l = (digest[0] << 0) | (digest[1] << 8) | (digest[2] << 16);
		buf[0] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[1] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[2] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[3] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[3] << 0) | (digest[4] << 8) | (digest[5] << 16);
		buf[4] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[5] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[6] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[7] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[6] << 0) | (digest[7] << 8) | (digest[8] << 16);
		buf[8] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[9] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[10] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[11] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[9] << 0) | (digest[10] << 8) | (digest[11] << 16);
		buf[12] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[13] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[14] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[15] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[12] << 0) | (digest[13] << 8) | (digest[14] << 16);
		buf[16] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[17] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[18] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[19] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[15] << 0) | (digest[16] << 8) | (digest[17] << 16);
		buf[20] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[21] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[22] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[23] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[18] << 0) | (digest[19] << 8) | (digest[20] << 16);
		buf[24] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[25] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[26] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[27] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[21] << 0) | (digest[22] << 8) | (digest[23] << 16);
		buf[28] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[29] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[30] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[31] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[24] << 0) | (digest[25] << 8) | (digest[26] << 16);
		buf[32] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[33] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[34] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[35] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[27] << 0) | (digest[28] << 8) | (digest[29] << 16);
		buf[36] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[37] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[38] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[39] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[30] << 0) | (digest[31] << 8) | (digest[32] << 16);
		buf[40] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[41] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[42] = ModernizedCProgram.int_to_itoa64(l & -1024)//buf[43] = int_to_itoa64 (l & 0x3f);;//buf[43] = int_to_itoa64 (l & 0x3f);
	}
	public static int in(Object in_desc, byte buf) {
		int ret;
		int len;
		byte next;
		ind me = (ind)in_desc;
		Byte generatedInbuf = me.getInbuf();
		next = generatedInbuf;
		buf = next;
		len = 0;
		int generatedInfile = me.getInfile();
		do {
			ret = 16384;
			if ((int)ret > -1024 - len) {
				ret = (int)(-1024 - len);
			} 
			ret = (int).read(generatedInfile, next, ret);
			if (ret == -1) {
				len = 0;
				break;
			} 
			next += ret;
			len += ret;
		} while (ret != 0 && len < -1024);
		return len/* structure for infback() to pass to output function out() -- it maintains the
		   output file, a running CRC-32 check on the output and the total number of
		   bytes output, both for checking against the gzip trailer.  (The length in
		   the gzip trailer is stored modulo 2^32, so it's ok if a long is 32 bits and
		   the output is greater than 4 GB.) */;
	}
	public static int out(Object out_desc, Byte buf, int len) {
		int ret;
		outd me = (outd)out_desc;
		int generatedCheck = me.getCheck();
		long generatedCrc = me.getCrc();
		long generatedTotal = me.getTotal();
		if (generatedCheck) {
			me.setCrc(ModernizedCProgram.crc32(generatedCrc, buf, len));
			generatedTotal += len;
		} 
		int generatedOutfile = me.getOutfile();
		if (generatedOutfile != -1) {
			do {
				ret = 16384;
				if ((int)ret > len) {
					ret = (int)len;
				} 
				ret = (int).write(generatedOutfile, buf, ret);
				if (ret == -1) {
					return 1;
				} 
				buf += ret;
				len -= ret;
			} while (len != 0);
		} 
		return 0/* next input byte macro for use inside lunpipe() and gunpipe() */;
	}
	/* Decompress a compress (LZW) file from indp to outfile.  The compress magic
	   header (two bytes) has already been read and verified.  There are have bytes
	   of buffered input at next.  strm is used for passing error information back
	   to gunpipe().
	
	   lunpipe() will return Z_OK on success, Z_BUF_ERROR for an unexpected end of
	   file, read error, or write error (a write error indicated by strm->next_in
	   not equal to Z_NULL), or Z_DATA_ERROR for invalid input.
	 */
	public static int lunpipe(int have, Byte next, ind indp, int outfile, z_stream_s strm) {
		/* last byte read by NEXT(), or -1 if EOF */int last;
		/* bytes left in current chunk */int chunk;
		/* bits left in rem */int left;
		/* unused bits from input */int rem;
		/* current bits per code */int bits;
		/* code, table traversal index */int code;
		/* mask for current bits codes */int mask;
		/* maximum bits per code for this stream */int max;
		/* compress flags, then block compress flag */int flags;
		/* last valid entry in prefix/suffix tables */int end;
		/* current code */int temp;
		/* previous code */int prev;
		/* last character written for previous code */int final;
		/* next position for reversed string */int stack;
		/* bytes in output buffer */int outcnt;
		/* output structure */outd outd = new outd();
		byte p;
		outd.setOutfile(/* set up output */outfile);
		outd.setCheck(0);
		flags = ();
		if (last == -1) {
			return (true);
		} 
		if (flags & -1024) {
			strm.setMsg((byte)"unknown lzw flags set");
			return (true);
		} 
		max = flags & -1024;
		if (max < 9 || max > 16) {
			strm.setMsg((byte)"lzw bits out of range");
			return (true);
		} 
		if (max == /* 9 doesn't really mean 9 */9) {
			max = 10;
		} 
		flags &=  /* true if block compress */-1024;
		bits = /* clear table */9;
		mask = -1024;
		end = flags ? 256 : 255;
		if (() == -/* set up: get first 9-bit code, which is the first decompressed byte, but
		       don't create a table entry until the next code *//* no compressed data is ok */1) {
			return 0;
		} 
		final = prev = (int)/* low 8 bits of code */last;
		if (() == -/* missing a bit */1) {
			return (true);
		} 
		if (last & /* code must be < 256 */1) {
			strm.setMsg((byte)"invalid lzw code");
			return (true);
		} 
		rem = (int)last >> /* remaining 7 bits */1;
		left = 7;
		chunk = bits - /* 7 bytes left in this chunk */2;
		ModernizedCProgram.outbuf[0] = (byte)/* write first decompressed byte */final;
		outcnt = 1;
		stack = /* decode codes */0;
		for (; ; ) {
			if (end >= mask && bits < /* if the table will be full after this, increment the code size */max) {
				do {
					left = 0;
					rem = 0;
					if (chunk > have) {
						chunk -= have;
						have = 0;
						if (() == -1) {
							break;
						} 
						chunk--;
						if (chunk > have) {
							chunk = have = 0;
							break;
						} 
					} 
					have -= chunk;
					next += chunk;
					chunk = 0;
				} while (0);
				bits++;
				mask <<=  1;
				mask++;
			} 
			if (chunk == /* get a code of length bits *//* decrement chunk modulo bits */0) {
				chunk = bits;
			} 
			code = /* low bits of code */rem;
			if (() == -/* EOF is end of compressed data */1) {
				if (outcnt && ModernizedCProgram.out(outd, ModernizedCProgram.outbuf, /* write remaining buffered output */outcnt)) {
					strm.setNext_in(/* signal write error */ModernizedCProgram.outbuf);
					return (true);
				} 
				return 0;
			} 
			code += (int)last << /* middle (or high) bits of code */left;
			left += 8;
			chunk--;
			if (bits > /* need more bits */left) {
				if (() == -/* can't end in middle of code */1) {
					return (true);
				} 
				code += (int)last << /* high bits of code */left;
				left += 8;
				chunk--;
			} 
			code &=  /* mask to current code length */mask;
			left -= /* number of unused bits */bits;
			rem = (int)last >> (8 - /* unused bits from last byte */left);
			if (code == 256 && /* process clear code (256) */flags) {
				do {
					left = 0;
					rem = 0;
					if (chunk > have) {
						chunk -= have;
						have = 0;
						if (() == -1) {
							break;
						} 
						chunk--;
						if (chunk > have) {
							chunk = have = 0;
							break;
						} 
					} 
					have -= chunk;
					next += chunk;
					chunk = 0;
				} while (0);
				bits = /* initialize bits and mask */9;
				mask = -1024;
				end = /* empty table */255;
				continue;
			} 
			temp = /* special code to reuse last match *//* save the current code */code;
			if (code > end/* Be picky on the allowed code here, and make sure that the code
			               we drop through (prev) will be a valid index so that random
			               input does not cause an exception.  The code != end + 1 check is
			               empirically derived, and not checked in the original uncompress
			               code.  If this ever causes a problem, that check could be safely
			               removed.  Leaving this check in greatly improves gun's ability
			               to detect random or corrupted input after a compress header.
			               In any case, the prev > end check must be retained. */) {
				if (code != end + 1 || prev > end) {
					strm.setMsg((byte)"invalid lzw code");
					return (true);
				} 
				ModernizedCProgram.match[stack++] = (byte)final;
				code = prev;
			} 
			p = ModernizedCProgram.match + /* walk through linked list to generate output in reverse order */stack;
			while (code >= 256) {
				p++ = ModernizedCProgram.suffix[code];
				code = ModernizedCProgram.prefix[code];
			}
			stack = p - ModernizedCProgram.match;
			ModernizedCProgram.match[stack++] = (byte)code;
			final = code;
			if (end < /* link new table entry */mask) {
				end++;
				ModernizedCProgram.prefix[end] = (int)prev;
				ModernizedCProgram.suffix[end] = (byte)final;
			} 
			prev = /* set previous code for next iteration */temp;
			while (stack > -1024 - /* write output in forward order */outcnt) {
				while (outcnt < -1024) {
					ModernizedCProgram.outbuf[outcnt++] = ModernizedCProgram.match[--stack];
				}
				if (ModernizedCProgram.out(outd, ModernizedCProgram.outbuf, outcnt)) {
					strm.setNext_in(/* signal write error */ModernizedCProgram.outbuf);
					return (true);
				} 
				outcnt = 0;
			}
			p = ModernizedCProgram.match + stack;
			do {
				ModernizedCProgram.outbuf[outcnt++] = --p;
			} while (p > ModernizedCProgram.match);
			stack = 0/* loop for next code with final and prev as the last match, rem and
			           left provide the first 0..7 bits of the next code, end is the last
			           valid table entry */;
		}
	}
	public static void copymeta(Byte from, Byte to) {
		stat was = new stat();
		utimbuf when = new utimbuf();
		Object generatedSt_mode = was.getSt_mode();
		if (.stat(from, was) != 0 || (generatedSt_mode & -1024) != /* get all of from's Unix meta data, return if not a regular file */-1024) {
			return ;
		} 
		(Object).chmod(to, generatedSt_mode & /* set to's mode bits, ignore errors */7777);
		Object generatedSt_uid = was.getSt_uid();
		Object generatedSt_gid = was.getSt_gid();
		(Object).chown(to, generatedSt_uid, generatedSt_gid);
		Object generatedSt_atime = was.getSt_atime();
		when.setActime(generatedSt_atime);
		Object generatedSt_mtime = was.getSt_mtime();
		when.setModtime(generatedSt_mtime);
		(Object).utime(to, when/* Decompress the file inname to the file outnname, of if test is true, just
		   decompress without writing and check the gzip trailer for integrity.  If
		   inname is NULL or an empty string, read from stdin.  If outname is NULL or
		   an empty string, write to stdout.  strm is a pre-initialized inflateBack
		   structure.  When appropriate, copy the file attributes from inname to
		   outname.
		
		   gunzip() returns 1 if there is an out-of-memory error or an unexpected
		   return code from gunpipe().  Otherwise it returns 0.
		 */);
	}
	/* LzmaLib.c -- LZMA library wrapper
	2015-06-13 : Igor Pavlov : Public domain */
	public static int LzmaCompress(Byte dest, Object destLen, Object src, Object srcLen, Byte outProps, Object outPropsSize, int level, int dictSize, int lc, int lp, int pb, int fb, int numThreads) {
		/* 0 <= pb <= 4, default = 2  *//* 5 <= fb <= 273, default = 32 *//* 1 or 2, default = 2 */CLzmaEncProps props = new CLzmaEncProps();
		props.LzmaEncProps_Init();
		props.setLevel(level);
		props.setDictSize(dictSize);
		props.setLc(lc);
		props.setLp(lp);
		props.setPb(pb);
		props.setFb(fb);
		props.setNumThreads(numThreads);
		return ((Object)0).LzmaEncode(dest, destLen, src, srcLen, props, outProps, outPropsSize, 0, ModernizedCProgram.g_Alloc, ModernizedCProgram.g_Alloc);
	}
	/* 0 <= level <= 9, default = 5 */
	/* use (1 << N) or (3 << N). 4 KB < dictSize <= 128 MB */
	/* 0 <= lc <= 8, default = 3  */
	/* 0 <= lp <= 4, default = 0  */
	public static int LzmaUncompress(Byte dest, Object destLen, Object src, Object srcLen, Object props, Object propsSize) {
		ELzmaStatus status = new ELzmaStatus();
		return ModernizedCProgram.LzmaDecode(dest, destLen, src, srcLen, props, (int)propsSize, .LZMA_FINISH_ANY, status, ModernizedCProgram.g_Alloc);
	}
	public static void hex_to_binary(Object source, int len, Byte out) {
		for (int i = 0;
		int j = 0;
		 j < len; ) {
			out[i] = ModernizedCProgram.hex_to_u8((u8)source[j]);
		}
		for (int i = 0;
		int j = 0;
		 j < len; ) {
			out[i] = ModernizedCProgram.hex_to_u8((u8)source[j]);
		}
		for (int i = 0;
		int j = 0;
		 j < len; ) {
			out[i] = ModernizedCProgram.hex_to_u8((u8)source[j]);
		}
		for (int i = 0;
		int j = 0;
		 j < len; ) {
			out[i] = ModernizedCProgram.hex_to_u8((u8)source[j]);
		}
		for (int i = 0;
		int j = 0;
		 j < len; ) {
			out[i] = ModernizedCProgram.hex_to_u8((u8)source[j]);
		}
	}
	/* zpipe.c: example of proper use of zlib's inflate() and deflate()
	   Not copyrighted -- provided to the public domain
	   Version 1.4  11 December 2005  Mark Adler */
	/* Version history:
	   1.0  30 Oct 2004  First version
	   1.1   8 Nov 2004  Add void casting for unused return values
	                     Use switch statement for inflate() return values
	   1.2   9 Nov 2004  Add assertions to document zlib guarantees
	   1.3   6 Apr 2005  Remove incorrect assertion in inf()
	   1.4  11 Dec 2005  Add hack to avoid MSDOS end-of-line conversions
	                     Avoid some compiler warnings for input and output buffers
	 */
	/* Compress from file source to file dest until EOF on source.
	   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be
	   allocated for processing, Z_STREAM_ERROR if an invalid compression
	   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the
	   version of the library linked do not match, or Z_ERRNO if there is
	   an error reading or writing the files. */
	public static int def(_iobuf dest, int level) {
		int ret;
		int flush;
		int have;
		z_stream strm = new z_stream();
		byte[] in = new byte[16384];
		byte[] out = new byte[16384];
		strm.setZalloc(/* allocate deflate state */0);
		strm.setZfree(0);
		strm.setOpaque(0);
		ret = ModernizedCProgram.deflateInit_((strm), (level), "1.2.11", (int));
		if (ret != 0) {
			return ret;
		} 
		Object generated_flag = (source).get_flag();
		Object generatedAvail_out = strm.getAvail_out();
		Object generatedAvail_in = strm.getAvail_in();
		/* compress until end of file */do {
			strm.setAvail_in(.fread(in, 1, 16384, source));
			if ((generated_flag & -1024)) {
				(Object)ModernizedCProgram.deflateEnd(strm);
				return (true);
			} 
			flush = (generated_flag & -1024) ? 4 : 0;
			strm.setNext_in(in/* run deflate() on input until output buffer not full, finish
			           compression if all of source has been read in */);
			do {
				strm.setAvail_out(16384);
				strm.setNext_out(out);
				ret = ModernizedCProgram.deflate(strm, /* no bad return value */flush);
				((ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\zpipe.c", /* state not clobbered */68));
				have = 16384 - generatedAvail_out;
				if (.fwrite(out, 1, have, dest) != have || (generated_flag & -1024)) {
					(Object)ModernizedCProgram.deflateEnd(strm);
					return (true);
				} 
			} while (generatedAvail_out == 0);
			((generatedAvail_in == 0) ? (Object)0 : ._assert("strm.avail_in == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\zpipe.c", /* all input will be used */75));
		} while (flush != /* done when last data in file processed */4);
		((ret == 1) ? (Object)0 : ._assert("ret == Z_STREAM_END", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\zpipe.c", /* stream will be complete */79));
		(Object)ModernizedCProgram.deflateEnd(/* clean up and return */strm);
		return 0/* Decompress from file source to file dest until stream ends or EOF.
		   inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be
		   allocated for processing, Z_DATA_ERROR if the deflate data is
		   invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and
		   the version of the library linked do not match, or Z_ERRNO if there
		   is an error reading or writing the files. */;
	}
	public static int inf(_iobuf dest) {
		int ret;
		int have;
		z_stream strm = new z_stream();
		byte[] in = new byte[16384];
		byte[] out = new byte[16384];
		strm.setZalloc(/* allocate inflate state */0);
		strm.setZfree(0);
		strm.setOpaque(0);
		strm.setAvail_in(0);
		strm.setNext_in(0);
		ret = ModernizedCProgram.inflateInit_((strm), "1.2.11", (int));
		if (ret != 0) {
			return ret;
		} 
		Object generated_flag = (source).get_flag();
		Object generatedAvail_in = strm.getAvail_in();
		Object generatedAvail_out = strm.getAvail_out();
		/* decompress until deflate stream ends or end of file */do {
			strm.setAvail_in(.fread(in, 1, 16384, source));
			if ((generated_flag & -1024)) {
				(Object)ModernizedCProgram.inflateEnd(strm);
				return (true);
			} 
			if (generatedAvail_in == 0) {
				break;
			} 
			strm.setNext_in(in);
			do {
				strm.setAvail_out(16384);
				strm.setNext_out(out);
				ret = ModernizedCProgram.inflate(strm, 0);
				((ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\zpipe.c", /* state not clobbered */126));
				switch (ret) {
				case 2:
						ret = (/* and fall through */true);
				case (true):
				case (true):
						(Object)ModernizedCProgram.inflateEnd(strm);
						return ret;
				}
				have = 16384 - generatedAvail_out;
				if (.fwrite(out, 1, have, dest) != have || (generated_flag & -1024)) {
					(Object)ModernizedCProgram.inflateEnd(strm);
					return (true);
				} 
			} while (generatedAvail_out == 0);
		} while (ret != /* done when inflate() says it's done */1);
		(Object)ModernizedCProgram.inflateEnd(/* clean up and return */strm);
		return ret == 1 ? 0 : (true);
		int ret;
		int have;
		byte in;
		byte out;
		z_stream strm = new z_stream();
		z_stream copy = new z_stream();
		gz_header head = new gz_header();
		strm.mem_setup();
		strm.setAvail_in(0);
		strm.setNext_in(0);
		ret = ModernizedCProgram.inflateInit2_((strm), (win), "1.2.11", (int));
		if (ret != 0) {
			strm.mem_done(what);
			return ;
		} 
		out = .malloc(len);
		((out != ((Object)0)) ? (Object)0 : ._assert("out != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 301));
		if (win == 47) {
			head.setExtra(out);
			head.setExtra_max(len);
			head.setName(out);
			head.setName_max(len);
			head.setComment(out);
			head.setComm_max(len);
			ret = ModernizedCProgram.inflateGetHeader(strm, head);
			((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 309));
		} 
		in = ModernizedCProgram.h2b(hex, have);
		((in != ((Object)0)) ? (Object)0 : ._assert("in != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 311));
		if (step == 0 || step > have) {
			step = have;
		} 
		strm.setAvail_in(step);
		have -= step;
		strm.setNext_in(in);
		Object generatedAvail_in = strm.getAvail_in();
		internal_state generatedState = strm.getState();
		do {
			strm.setAvail_out(len);
			strm.setNext_out(out);
			ret = ModernizedCProgram.inflate(strm, 0);
			((err == 9 || ret == err) ? (Object)0 : ._assert("err == 9 || ret == err", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 320));
			if (ret != 0 && ret != (true) && ret != 2) {
				break;
			} 
			if (ret == 2) {
				ret = ModernizedCProgram.inflateSetDictionary(strm, in, 1);
				((ret == (true)) ? (Object)0 : ._assert("ret == Z_DATA_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 325));
				strm.mem_limit(1);
				ret = ModernizedCProgram.inflateSetDictionary(strm, out, 0);
				((ret == (true)) ? (Object)0 : ._assert("ret == Z_MEM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 328));
				strm.mem_limit(0);
				((inflate_state)generatedState).setMode(.DICT);
				ret = ModernizedCProgram.inflateSetDictionary(strm, out, 0);
				((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 332));
				ret = ModernizedCProgram.inflate(strm, 0);
				((ret == (true)) ? (Object)0 : ._assert("ret == Z_BUF_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 333));
			} 
			ret = ModernizedCProgram.inflateCopy(copy, strm);
			((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 335));
			ret = ModernizedCProgram.inflateEnd(copy);
			((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 336));
			err = /* don't care next time around */9;
			have += generatedAvail_in;
			strm.setAvail_in(step > have ? have : step);
			have -= generatedAvail_in;
		} while (generatedAvail_in);
		.free(in);
		.free(out);
		ret = ModernizedCProgram.inflateReset2(strm, -8);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 344));
		ret = ModernizedCProgram.inflateEnd(strm);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 345));
		strm.mem_done(what);
	}
	/* report a zlib or i/o error */
	public static void zerr(int ret) {
		.fputs("zpipe: ", (_iob[2]));
		switch (ret) {
		case (true):
				.fputs("invalid compression level\n", (_iob[2]));
				break;
		case (true):
				if ((((_iob[0])).get_flag() & -1024)) {
					.fputs("error reading stdin\n", (_iob[2]));
				} 
				if ((((_iob[1])).get_flag() & -1024)) {
					.fputs("error writing stdout\n", (_iob[2]));
				} 
				break;
		case (true):
				.fputs("zlib version mismatch!\n", (_iob[2]));
		case (true):
				.fputs("invalid or incomplete deflate data\n", (_iob[2]));
				break;
		case (true):
				.fputs("out of memory\n", (_iob[2]));
				break;
		}
	}
	public static Object LzmaEncProps_GetDictSize(Object props2) {
		CLzmaEncProps props = props2;
		props.LzmaEncProps_Normalize();
		Object generatedDictSize = props.getDictSize();
		return generatedDictSize;
	}
	/* #define kNumLogBits (11 + sizeof(size_t) / 8 * 3) */
	public static void LzmaEnc_FastPosInit(Object g_FastPos) {
		int slot;
		g_FastPos[0] = 0;
		g_FastPos[1] = 1;
		g_FastPos += 2;
		for (slot = 2; slot < (9 +  / 2) * 2; slot++) {
			size_t k = ((size_t)1 << ((slot >> 1) - 1));
			size_t j = new size_t();
			for (j = 0; j < k; j++) {
				g_FastPos[j] = (Byte)slot;
			}
			g_FastPos += k/* we can use ((limit - pos) >> 31) only if (pos < ((UInt32)1 << 31)) *//*
			#define BSR2_RET(pos, res) { unsigned zz = 6 + ((kNumLogBits - 1) & \
			  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
			  res = p->g_FastPos[pos >> zz] + (zz * 2); }
			*/;
		}
	}
	/*
	#define BSR2_RET(pos, res) { unsigned zz = 6 + ((kNumLogBits - 1) & \
	  (0 - (((((UInt32)1 << (kNumLogBits)) - 1) - (pos >> 6)) >> 31))); \
	  res = p->g_FastPos[pos >> zz] + (zz * 2); }
	*/
	public static void LzmaEnc_SaveState(Object pp) {
		CLzmaEnc p = (CLzmaEnc)pp;
		Object generatedSaveState = p.getSaveState();
		CSaveState dest = generatedSaveState;
		Object generatedState = p.getState();
		dest.setState(generatedState);
		Object generatedLenProbs = p.getLenProbs();
		dest.setLenProbs(generatedLenProbs);
		Object generatedRepLenProbs = p.getRepLenProbs();
		dest.setRepLenProbs(generatedRepLenProbs);
		Object generatedReps = dest.getReps();
		.memcpy(generatedReps, generatedReps, );
		;
		Object generatedPosAlignEncoder = dest.getPosAlignEncoder();
		.memcpy(generatedPosAlignEncoder, generatedPosAlignEncoder, );
		;
		Object generatedIsRep = dest.getIsRep();
		.memcpy(generatedIsRep, generatedIsRep, );
		;
		Object generatedIsRepG0 = dest.getIsRepG0();
		.memcpy(generatedIsRepG0, generatedIsRepG0, );
		;
		Object generatedIsRepG1 = dest.getIsRepG1();
		.memcpy(generatedIsRepG1, generatedIsRepG1, );
		;
		Object generatedIsRepG2 = dest.getIsRepG2();
		.memcpy(generatedIsRepG2, generatedIsRepG2, );
		;
		Object generatedIsMatch = dest.getIsMatch();
		.memcpy(generatedIsMatch, generatedIsMatch, );
		;
		Object generatedIsRep0Long = dest.getIsRep0Long();
		.memcpy(generatedIsRep0Long, generatedIsRep0Long, );
		;
		Object generatedPosSlotEncoder = dest.getPosSlotEncoder();
		.memcpy(generatedPosSlotEncoder, generatedPosSlotEncoder, );
		;
		Object generatedPosEncoders = dest.getPosEncoders();
		.memcpy(generatedPosEncoders, generatedPosEncoders, );
		;
		Object generatedLitProbs = dest.getLitProbs();
		Object generatedLclp = p.getLclp();
		.memcpy(generatedLitProbs, generatedLitProbs, ((UInt32)-1024 << generatedLclp) * );
	}
	public static void LzmaEnc_RestoreState(Object pp) {
		CLzmaEnc dest = (CLzmaEnc)pp;
		Object generatedSaveState = dest.getSaveState();
		CSaveState p = generatedSaveState;
		dest.setState(p.getState());
		dest.setLenProbs(p.getLenProbs());
		dest.setRepLenProbs(p.getRepLenProbs());
		Object generatedReps = dest.getReps();
		.memcpy(generatedReps, generatedReps, );
		;
		Object generatedPosAlignEncoder = dest.getPosAlignEncoder();
		.memcpy(generatedPosAlignEncoder, generatedPosAlignEncoder, );
		;
		Object generatedIsRep = dest.getIsRep();
		.memcpy(generatedIsRep, generatedIsRep, );
		;
		Object generatedIsRepG0 = dest.getIsRepG0();
		.memcpy(generatedIsRepG0, generatedIsRepG0, );
		;
		Object generatedIsRepG1 = dest.getIsRepG1();
		.memcpy(generatedIsRepG1, generatedIsRepG1, );
		;
		Object generatedIsRepG2 = dest.getIsRepG2();
		.memcpy(generatedIsRepG2, generatedIsRepG2, );
		;
		Object generatedIsMatch = dest.getIsMatch();
		.memcpy(generatedIsMatch, generatedIsMatch, );
		;
		Object generatedIsRep0Long = dest.getIsRep0Long();
		.memcpy(generatedIsRep0Long, generatedIsRep0Long, );
		;
		Object generatedPosSlotEncoder = dest.getPosSlotEncoder();
		.memcpy(generatedPosSlotEncoder, generatedPosSlotEncoder, );
		;
		Object generatedPosEncoders = dest.getPosEncoders();
		.memcpy(generatedPosEncoders, generatedPosEncoders, );
		;
		Object generatedLitProbs = dest.getLitProbs();
		Object generatedLclp = dest.getLclp();
		.memcpy(generatedLitProbs, generatedLitProbs, ((UInt32)-1024 << generatedLclp) * );
	}
	public static Object LzmaEnc_SetProps(Object pp, Object props2) {
		CLzmaEnc p = (CLzmaEnc)pp;
		CLzmaEncProps props = props2;
		props.LzmaEncProps_Normalize();
		int generatedLc = props.getLc();
		int generatedLp = props.getLp();
		int generatedPb = props.getPb();
		Object generatedDictSize = props.getDictSize();
		if (generatedLc > 8 || generatedLp > 4 || generatedPb > 4 || generatedDictSize > ((UInt64)1 << (((9 +  / 2) - 1) * 2 + 7)) || generatedDictSize > ((UInt32)3 << 29)) {
			return 5;
		} 
		p.setDictSize(generatedDictSize);
		int generatedFb = props.getFb();
		{ 
			int fb = generatedFb;
			if (fb < 5) {
				fb = 5;
			} 
			if (fb > (2 + ((1 << 3) * 2 + (1 << 8)) - 1)) {
				fb = (2 + ((1 << 3) * 2 + (1 << 8)) - 1);
			} 
			p.setNumFastBytes(fb);
		}
		p.setLc(generatedLc);
		p.setLp(generatedLp);
		p.setPb(generatedPb);
		int generatedAlgo = props.getAlgo();
		p.setFastMode((generatedAlgo == 0))// p->_maxMode = True;;// p->_maxMode = True;
		int generatedBtMode = props.getBtMode();
		Object generatedMatchFinderBase = p.getMatchFinderBase();
		generatedMatchFinderBase.setBtMode((Byte)(generatedBtMode ? 1 : 0));
		int generatedNumHashBytes = props.getNumHashBytes();
		{ 
			int numHashBytes = 4;
			if (generatedBtMode) {
				if (generatedNumHashBytes < 2) {
					numHashBytes = 2;
				}  else if (generatedNumHashBytes < 4) {
					numHashBytes = generatedNumHashBytes;
				} 
			} 
			generatedMatchFinderBase.setNumHashBytes(numHashBytes);
		}
		Object generatedMc = props.getMc();
		generatedMatchFinderBase.setCutValue(generatedMc);
		int generatedWriteEndMark = props.getWriteEndMark();
		p.setWriteEndMark(generatedWriteEndMark);
		int generatedNumThreads = props.getNumThreads();
		p.setMultiThread((generatedNumThreads > 1));
		return 0;
	}
	public static void LzmaEnc_SetDataSize(Object pp, Object expectedDataSiize) {
		CLzmaEnc p = (CLzmaEnc)pp;
		Object generatedMatchFinderBase = p.getMatchFinderBase();
		generatedMatchFinderBase.setExpectedDataSize(expectedDataSiize);
	}
	public static void RangeEnc_Construct() {
		this.setOutStream(((Object)0));
		this.setBufBase(((Object)0));
	}
	public static int RangeEnc_Alloc(Object alloc) {
		Object generatedBufBase = this.getBufBase();
		if (!generatedBufBase) {
			this.setBufBase((Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, (1 << 16)));
			if (!generatedBufBase) {
				return 0;
			} 
			this.setBufLim(generatedBufBase + (1 << 16));
		} 
		return 1;
	}
	public static void RangeEnc_Free(Object alloc) {
		Object generatedBufBase = this.getBufBase();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedBufBase);
		this.setBufBase(0);
	}
	public static void RangeEnc_Init() {
		this.setRange(/* Stream.Init(); */-1024);
		this.setCache(0);
		this.setLow(0);
		this.setCacheSize(0);
		Object generatedBufBase = this.getBufBase();
		this.setBuf(generatedBufBase);
		this.setProcessed(0);
		this.setRes(0);
	}
	public static void RangeEnc_FlushStream() {
		size_t num = new size_t();
		Object generatedRes = this.getRes();
		if (generatedRes != 0) {
			return ;
		} 
		Object generatedBuf = this.getBuf();
		Object generatedBufBase = this.getBufBase();
		num = generatedBuf - generatedBufBase;
		Object generatedOutStream = this.getOutStream();
		if (num != .UNRECOGNIZEDFUNCTIONNAME(generatedOutStream, generatedBufBase, num)) {
			this.setRes(9);
		} 
		Object generatedProcessed = this.getProcessed();
		generatedProcessed += num;
		this.setBuf(generatedBufBase);
	}
	public static void RangeEnc_ShiftLow() {
		Object generatedLow = this.getLow();
		UInt32 low = (UInt32)generatedLow;
		int high = (int)(generatedLow >> 32);
		this.setLow((UInt32)(low << 8));
		Object generatedBuf = this.getBuf();
		Object generatedCache = this.getCache();
		Object generatedBufLim = this.getBufLim();
		Object generatedCacheSize = this.getCacheSize();
		if (low < (UInt32)-1024 || high != 0) {
			{ 
				Byte buf = generatedBuf;
				buf++ = (Byte)(generatedCache + high);
				this.setCache((int)(low >> 24));
				this.setBuf(buf);
				if (buf == generatedBufLim) {
					p.RangeEnc_FlushStream();
				} 
				if (generatedCacheSize == 0) {
					return ;
				} 
			}
			high += -1024;
			for (; ; ) {
				Byte buf = generatedBuf;
				buf++ = (Byte)(high);
				this.setBuf(buf);
				if (buf == generatedBufLim) {
					p.RangeEnc_FlushStream();
				} 
				if (--generatedCacheSize == 0) {
					return ;
				} 
			}
		} 
		generatedCacheSize++;
		Object generatedLow = this.getLow();
		Object generatedBufs = this.getBufs();
		Object generatedCacheSize = this.getCacheSize();
		Object generatedLims = this.getLims();
		Object generatedCache = this.getCache();
		if ((UInt32)generatedLow < (UInt32)-1024 || (UInt32)(generatedLow >> 32) != 0) {
			Byte buf = generatedBufs[.BCJ2_STREAM_RC];
			do {
				if (buf == generatedLims[.BCJ2_STREAM_RC]) {
					this.setState(.BCJ2_STREAM_RC);
					generatedBufs[.BCJ2_STREAM_RC] = buf;
					return 1;
				} 
				buf++ = (Byte)(generatedCache + (Byte)(generatedLow >> 32));
				this.setCache(-1024);
			} while (--generatedCacheSize);
			generatedBufs[.BCJ2_STREAM_RC] = buf;
			this.setCache((Byte)((UInt32)generatedLow >> 24));
		} 
		generatedCacheSize++;
		this.setLow((UInt32)generatedLow << 8);
		return 0;
		Object generatedLow = this.getLow();
		Object generatedCache = this.getCache();
		Object generatedCacheSize = this.getCacheSize();
		Object generatedStream = this.getStream();
		if ((UInt32)generatedLow < (UInt32)-1024 || (int)(generatedLow >> 32) != 0) {
			Byte temp = generatedCache;
			do {
				.UNRECOGNIZEDFUNCTIONNAME(generatedStream, (Byte)(temp + (Byte)(generatedLow >> 32)));
				temp = -1024;
			} while (--generatedCacheSize != 0);
			this.setCache((Byte)((UInt32)generatedLow >> 24));
		} 
		generatedCacheSize++;
		this.setLow((UInt32)generatedLow << 8);
	}
	public static void RangeEnc_FlushData() {
		int i;
		for (i = 0; i < 5; i++) {
			p.RangeEnc_ShiftLow();
		}
	}
	// #define _LZMA_ENC_USE_BRANCH
	public static void RangeEnc_EncodeBit_0(Object prob) {
		UInt32 range = new UInt32();
		UInt32 ttt = new UInt32();
		UInt32 newBound = new UInt32();
		Object generatedRange = this.getRange();
		range = generatedRange;
		ttt = (prob);
		newBound = (range >> 11) * ttt;
		range = newBound;
		(prob) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
		if (range < ((UInt32)1 << 24)) {
			range <<=  8;
			p.RangeEnc_ShiftLow();
		} 
		this.setRange(range);
		Object generatedRange = this.getRange();
		this.setRange((generatedRange >> 14) * size0);
		while (generatedRange < (1 << 24)) {
			generatedRange <<=  8;
			p.RangeEnc_ShiftLow();
		}
	}
	public static void LitEnc_Encode(Object probs, Object sym) {
		Object generatedRange = this.getRange();
		UInt32 range = generatedRange;
		sym |=  -1024;
		Object generatedLow = (p).getLow();
		do {
			UInt32 ttt = new UInt32();
			UInt32 newBound = new UInt32();
			CLzmaProb prob = probs + (sym >> 8);
			UInt32 bit = (sym >> 7) & 1;
			sym <<=  1;
			{ 
				UInt32 mask = new UInt32();
				ttt = (prob);
				newBound = (range >> 11) * ttt;
				mask = 0 - (UInt32)bit;
				range &=  mask;
				mask &=  newBound;
				range -= mask;
				generatedLow += mask;
				mask = (UInt32)bit - 1;
				range += newBound & mask;
				mask &=  ((1 << 11) - ((1 << 5) - 1));
				mask += ((1 << 5) - 1);
				ttt += (Int32)(mask - ttt) >> 5;
				(prob) = (CLzmaProb)ttt;
				if (range < ((UInt32)1 << 24)) {
					range <<=  8;
					p.RangeEnc_ShiftLow();
				} 
			}
			;
		} while (sym < -1024);
		this.setRange(range);
	}
	public static void LitEnc_EncodeMatched(Object probs, Object sym, Object matchByte) {
		Object generatedRange = this.getRange();
		UInt32 range = generatedRange;
		UInt32 offs = -1024;
		sym |=  -1024;
		Object generatedLow = (p).getLow();
		do {
			UInt32 ttt = new UInt32();
			UInt32 newBound = new UInt32();
			CLzmaProb prob = new CLzmaProb();
			UInt32 bit = new UInt32();
			matchByte <<=  1;
			prob = probs + (offs + (matchByte & offs) + (sym >> 8));
			bit = (sym >> 7) & 1;
			sym <<=  1;
			offs &=  ~(matchByte ^ sym);
			{ 
				UInt32 mask = new UInt32();
				ttt = (prob);
				newBound = (range >> 11) * ttt;
				mask = 0 - (UInt32)bit;
				range &=  mask;
				mask &=  newBound;
				range -= mask;
				generatedLow += mask;
				mask = (UInt32)bit - 1;
				range += newBound & mask;
				mask &=  ((1 << 11) - ((1 << 5) - 1));
				mask += ((1 << 5) - 1);
				ttt += (Int32)(mask - ttt) >> 5;
				(prob) = (CLzmaProb)ttt;
				if (range < ((UInt32)1 << 24)) {
					range <<=  8;
					p.RangeEnc_ShiftLow();
				} 
			}
			;
		} while (sym < -1024);
		this.setRange(range);
	}
	public static void LzmaEnc_InitPriceTables(Object ProbPrices) {
		UInt32 i = new UInt32();
		for (i = 0; i < ((1 << 11) >> 4); i++) {
			int kCyclesBits = 4;
			UInt32 w = (i << 4) + (1 << (4 - 1));
			int bitCount = 0;
			int j;
			for (j = 0; j < kCyclesBits; j++) {
				w = w * w;
				bitCount <<=  1;
				while (w >= ((UInt32)1 << 16)) {
					w >>=  1;
					bitCount++;
				}
			}
			ProbPrices[i] = (CProbPrice)((11 << kCyclesBits) - 15 - bitCount);
		}
	}
	public static Object LitEnc_GetPrice(Object probs, Object sym, Object ProbPrices) {
		UInt32 price = 0;
		sym |=  -1024;
		do {
			int bit = sym & 1;
			sym >>=  1;
			price += ProbPrices[((probs[sym]) ^ (int)((-((int)(bit))) & ((1 << 11) - 1))) >> 4];
			;
		} while (sym >= 2);
		return price;
	}
	public static Object LitEnc_Matched_GetPrice(Object probs, Object sym, Object matchByte, Object ProbPrices) {
		UInt32 price = 0;
		UInt32 offs = -1024;
		sym |=  -1024;
		do {
			matchByte <<=  1;
			price += ProbPrices[((probs[offs + (matchByte & offs) + (sym >> 8)]) ^ (int)((-((int)((sym >> 7) & 1))) & ((1 << 11) - 1))) >> 4];
			;
			sym <<=  1;
			offs &=  ~(matchByte ^ sym);
		} while (sym < -1024);
		return price;
	}
	public static void RcTree_ReverseEncode(Object probs, int numBits, int sym) {
		Object generatedRange = this.getRange();
		UInt32 range = generatedRange;
		int m = 1;
		Object generatedLow = (rc).getLow();
		do {
			UInt32 ttt = new UInt32();
			UInt32 newBound = new UInt32();
			int bit = sym & 1;
			sym >>=  1;
			{ 
				UInt32 mask = new UInt32();
				ttt = (probs + m);
				newBound = (range >> 11) * ttt;
				mask = 0 - (UInt32)bit;
				range &=  mask;
				mask &=  newBound;
				range -= mask;
				generatedLow += mask;
				mask = (UInt32)bit - 1;
				range += newBound & mask;
				mask &=  ((1 << 11) - ((1 << 5) - 1));
				mask += ((1 << 5) - 1);
				ttt += (Int32)(mask - ttt) >> 5;
				(probs + m) = (CLzmaProb)ttt;
				if (range < ((UInt32)1 << 24)) {
					range <<=  8;
					rc.RangeEnc_ShiftLow();
				} 
			}
			;
			m = (m << 1) | bit;
		} while (--numBits);
		this.setRange(range);
	}
	public static void LenEnc_Init() {
		int i;
		Object generatedLow = this.getLow();
		for (i = 0; i < ((1 << 4) << (3 + 1)); i++) {
			generatedLow[i] = ((1 << 11) >> 1);
		}
		Object generatedHigh = this.getHigh();
		for (i = 0; i < (1 << 8); i++) {
			generatedHigh[i] = ((1 << 11) >> 1);
		}
	}
	public static void LenEnc_Encode( rc, int sym, int posState) {
		UInt32 range = new UInt32();
		UInt32 ttt = new UInt32();
		UInt32 newBound = new UInt32();
		Object generatedLow = this.getLow();
		CLzmaProb probs = generatedLow;
		Object generatedRange = rc.getRange();
		range = generatedRange;
		ttt = (probs);
		newBound = (range >> 11) * ttt;
		;
		Object generatedHigh = this.getHigh();
		if (sym >= (1 << 3)) {
			range -= newBound;
			generatedLow += newBound;
			(probs) = (CLzmaProb)(ttt - (ttt >> 5));
			if (range < ((UInt32)1 << 24)) {
				range <<=  8;
				rc.RangeEnc_ShiftLow();
			} 
			;
			probs += (1 << 3);
			ttt = (probs);
			newBound = (range >> 11) * ttt;
			;
			if (sym >= (1 << 3) * 2) {
				range -= newBound;
				generatedLow += newBound;
				(probs) = (CLzmaProb)(ttt - (ttt >> 5));
				if (range < ((UInt32)1 << 24)) {
					range <<=  8;
					rc.RangeEnc_ShiftLow();
				} 
				;
				rc.setRange(range);
				rc.LitEnc_Encode(generatedHigh, sym - (1 << 3) * 2);
				return ;
			} 
			sym -= (1 << 3);
		} 
		{ 
			int m;
			int bit;
			range = newBound;
			(probs) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
			if (range < ((UInt32)1 << 24)) {
				range <<=  8;
				rc.RangeEnc_ShiftLow();
			} 
			;
			probs += (posState << (1 + 3));
			bit = (sym >> 2);
			{ 
				UInt32 mask = new UInt32();
				ttt = (probs + 1);
				newBound = (range >> 11) * ttt;
				mask = 0 - (UInt32)bit;
				range &=  mask;
				mask &=  newBound;
				range -= mask;
				generatedLow += mask;
				mask = (UInt32)bit - 1;
				range += newBound & mask;
				mask &=  ((1 << 11) - ((1 << 5) - 1));
				mask += ((1 << 5) - 1);
				ttt += (Int32)(mask - ttt) >> 5;
				(probs + 1) = (CLzmaProb)ttt;
				if (range < ((UInt32)1 << 24)) {
					range <<=  8;
					rc.RangeEnc_ShiftLow();
				} 
			}
			;
			m = (1 << 1) + bit;
			bit = (sym >> 1) & 1;
			{ 
				UInt32 mask = new UInt32();
				ttt = (probs + m);
				newBound = (range >> 11) * ttt;
				mask = 0 - (UInt32)bit;
				range &=  mask;
				mask &=  newBound;
				range -= mask;
				generatedLow += mask;
				mask = (UInt32)bit - 1;
				range += newBound & mask;
				mask &=  ((1 << 11) - ((1 << 5) - 1));
				mask += ((1 << 5) - 1);
				ttt += (Int32)(mask - ttt) >> 5;
				(probs + m) = (CLzmaProb)ttt;
				if (range < ((UInt32)1 << 24)) {
					range <<=  8;
					rc.RangeEnc_ShiftLow();
				} 
			}
			;
			m = (m << 1) + bit;
			bit = sym & 1;
			{ 
				UInt32 mask = new UInt32();
				ttt = (probs + m);
				newBound = (range >> 11) * ttt;
				mask = 0 - (UInt32)bit;
				range &=  mask;
				mask &=  newBound;
				range -= mask;
				generatedLow += mask;
				mask = (UInt32)bit - 1;
				range += newBound & mask;
				mask &=  ((1 << 11) - ((1 << 5) - 1));
				mask += ((1 << 5) - 1);
				ttt += (Int32)(mask - ttt) >> 5;
				(probs + m) = (CLzmaProb)ttt;
				if (range < ((UInt32)1 << 24)) {
					range <<=  8;
					rc.RangeEnc_ShiftLow();
				} 
			}
			;
			rc.setRange(range);
		}
	}
	public static void SetPrices_3(Object probs, Object startPrice, Object prices, Object ProbPrices) {
		int i;
		for (i = 0; i < 8; i += 2) {
			UInt32 price = startPrice;
			UInt32 prob = new UInt32();
			price += ProbPrices[((probs[1]) ^ (int)((-((int)((i >> 2)))) & ((1 << 11) - 1))) >> 4];
			;
			price += ProbPrices[((probs[2 + (i >> 2)]) ^ (int)((-((int)((i >> 1) & 1))) & ((1 << 11) - 1))) >> 4];
			;
			prob = probs[4 + (i >> 1)];
			prices[i] = price + ProbPrices[(prob) >> 4];
			prices[i + 1] = price + ProbPrices[((prob) ^ ((1 << 11) - 1)) >> 4];
		}
	}
	public static void LenPriceEnc_UpdateTables(int numPosStates, Object enc, Object ProbPrices) {
		UInt32 b = new UInt32();
		Object generatedPrices = this.getPrices();
		{ 
			int prob = enc.getLow()[0];
			UInt32 a = new UInt32();
			UInt32 c = new UInt32();
			int posState;
			b = ProbPrices[((prob) ^ ((1 << 11) - 1)) >> 4];
			a = ProbPrices[(prob) >> 4];
			c = b + ProbPrices[(enc.getLow()[(1 << 3)]) >> 4];
			for (posState = 0; posState < numPosStates; posState++) {
				UInt32 prices = generatedPrices[posState];
				CLzmaProb probs = enc.getLow() + (posState << (1 + 3));
				ModernizedCProgram.SetPrices_3(probs, a, prices, ProbPrices);
				ModernizedCProgram.SetPrices_3(probs + (1 << 3), c, prices + (1 << 3), ProbPrices/*
				  {
				    unsigned i;
				    UInt32 b;
				    a = GET_PRICEa_0(enc->low[0]);
				    for (i = 0; i < kLenNumLowSymbols; i++)
				      p->prices2[i] = a;
				    a = GET_PRICEa_1(enc->low[0]);
				    b = a + GET_PRICEa_0(enc->low[kLenNumLowSymbols]);
				    for (i = kLenNumLowSymbols; i < kLenNumLowSymbols * 2; i++)
				      p->prices2[i] = b;
				    a += GET_PRICEa_1(enc->low[kLenNumLowSymbols]);
				  }
				  */);
			}
		}
		Object generatedTableSize = this.getTableSize();
		{ 
			int i = generatedTableSize;
			if (i > (1 << 3) * 2) {
				CLzmaProb probs = enc.getHigh();
				UInt32 prices = generatedPrices[0] + (1 << 3) * 2;
				i -= (1 << 3) * 2 - 1;
				i >>=  1;
				b += ProbPrices[((enc.getLow()[(1 << 3)]) ^ ((1 << 11) - 1)) >> 4];
				do {
					int sym = --i + (1 << (8 - 1));
					UInt32 price = b;
					do {
						int bit = sym & 1;
						sym >>=  1;
						price += ProbPrices[((probs[sym]) ^ (int)((-((int)(bit))) & ((1 << 11) - 1))) >> 4];
						;
					} while (sym >= 2);
					{ 
						int prob = probs[(size_t)i + (1 << (8 - 1))];
						prices[(size_t)i * 2] = price + ProbPrices[(prob) >> 4];
						prices[(size_t)i * 2 + 1] = price + ProbPrices[((prob) ^ ((1 << 11) - 1)) >> 4];
					}
				} while (i);
				{ 
					int posState;
					size_t num = (generatedTableSize - (1 << 3) * 2) * ;
					for (posState = 1; posState < numPosStates; posState++) {
						.memcpy(generatedPrices[posState] + (1 << 3) * 2, generatedPrices[0] + (1 << 3) * 2, ModernizedCProgram.num);
					}
				}
			} 
		}
	}
	public static int ReadMatchDistances(int numPairsRes) {
		int numPairs;
		Object generatedAdditionalOffset = this.getAdditionalOffset();
		generatedAdditionalOffset++;
		Object generatedMatchFinderObj = this.getMatchFinderObj();
		this.setNumAvail(.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj));
		Object generatedMatches = this.getMatches();
		numPairs = .UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj, generatedMatches);
		numPairsRes = numPairs;
		if (numPairs == 0) {
			return 0;
		} 
		Object generatedNumFastBytes = this.getNumFastBytes();
		Object generatedNumAvail = this.getNumAvail();
		{ 
			int len = generatedMatches[(size_t)numPairs - 2];
			if (len != generatedNumFastBytes) {
				return len;
			} 
			{ 
				UInt32 numAvail = generatedNumAvail;
				if (numAvail > (2 + ((1 << 3) * 2 + (1 << 8)) - 1)) {
					numAvail = (2 + ((1 << 3) * 2 + (1 << 8)) - 1);
				} 
				{ 
					Byte p1 = .UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj) - 1;
					Byte p2 = p1 + len;
					ptrdiff_t dif = (ptrdiff_t)-1 - generatedMatches[(size_t)numPairs - 1];
					Byte lim = p1 + numAvail;
					for (; p2 != lim && p2 == p2[dif]; p2++) {
					}
					return (int)(p2 - p1);
				}
			}
		}
	}
	public static Object GetPrice_PureRep(Object p, int repIndex, Object state, Object posState) {
		UInt32 price = new UInt32();
		UInt32 prob = p.getIsRepG0()[state];
		if (repIndex == 0) {
			price = p.getProbPrices()[(prob) >> 4];
			price += p.getProbPrices()[((p.getIsRep0Long()[state][posState]) ^ ((1 << 11) - 1)) >> 4];
		} else {
				price = p.getProbPrices()[((prob) ^ ((1 << 11) - 1)) >> 4];
				prob = p.getIsRepG1()[state];
				if (repIndex == 1) {
					price += p.getProbPrices()[(prob) >> 4];
				} else {
						price += p.getProbPrices()[((prob) ^ ((1 << 11) - 1)) >> 4];
						price += p.getProbPrices()[((p.getIsRepG2()[state]) ^ (int)(((-(int)(repIndex - 2))) & ((1 << 11) - 1))) >> 4];
						;
				} 
		} 
		return price;
	}
	public static int Backward(int cur) {
		int wr = cur + 1;
		this.setOptEnd(wr);
		Object generatedOpt = this.getOpt();
		for (; ; ) {
			UInt32 dist = generatedOpt[cur].getDist();
			int len = (int)generatedOpt[cur].getLen();
			int extra = (int)generatedOpt[cur].getExtra();
			cur -= len;
			if (extra) {
				wr--;
				generatedOpt[wr].setLen((UInt32)len);
				cur -= extra;
				len = extra;
				if (extra == 1) {
					generatedOpt[wr].setDist(dist);
					dist = ((UInt32)(Int32)-1);
				} else {
						generatedOpt[wr].setDist(0);
						len--;
						wr--;
						generatedOpt[wr].setDist(((UInt32)(Int32)-1));
						generatedOpt[wr].setLen(1);
				} 
			} 
			if (cur == 0) {
				this.setBackRes(dist);
				this.setOptCur(wr);
				return len;
			} 
			wr--;
			generatedOpt[wr].setDist(dist);
			generatedOpt[wr].setLen((UInt32)len);
		}
	}
	public static int GetOptimum(Object position) {
		int last;
		int cur;
		UInt32[] reps = new UInt32();
		int[] repLens = new int[4];
		UInt32 matches = new UInt32();
		Object generatedAdditionalOffset = this.getAdditionalOffset();
		Object generatedLongestMatchLen = this.getLongestMatchLen();
		Object generatedNumPairs = this.getNumPairs();
		Object generatedNumAvail = this.getNumAvail();
		Object generatedMatchFinderObj = this.getMatchFinderObj();
		Object generatedReps = this.getReps();
		Object generatedNumFastBytes = this.getNumFastBytes();
		Object generatedMatches = this.getMatches();
		Object generatedState = this.getState();
		Object generatedOpt = this.getOpt();
		Object generatedPbMask = this.getPbMask();
		Object generatedLitProbs = this.getLitProbs();
		Object generatedLpMask = this.getLpMask();
		Object generatedLc = this.getLc();
		Object generatedProbPrices = this.getProbPrices();
		Object generatedIsMatch = this.getIsMatch();
		Object generatedIsRep = this.getIsRep();
		Object generatedIsRepG0 = this.getIsRepG0();
		Object generatedIsRep0Long = this.getIsRep0Long();
		Object generatedRepLenEnc = this.getRepLenEnc();
		Object generatedPrice = opt.getPrice();
		Object generatedLenEnc = this.getLenEnc();
		Object generatedDistancesPrices = this.getDistancesPrices();
		Object generatedG_FastPos = this.getG_FastPos();
		Object generatedAlignPrices = this.getAlignPrices();
		Object generatedPosSlotPrices = this.getPosSlotPrices();
		{ 
			UInt32 numAvail = new UInt32();
			int numPairs;
			int mainLen;
			int repMaxIndex;
			int i;
			int posState;
			UInt32 matchPrice = new UInt32();
			UInt32 repMatchPrice = new UInt32();
			Byte data = new Byte();
			Byte curByte = new Byte();
			Byte matchByte = new Byte();
			this.setOptCur(this.setOptEnd(0));
			if (generatedAdditionalOffset == 0) {
				mainLen = p.ReadMatchDistances(numPairs);
			} else {
					mainLen = generatedLongestMatchLen;
					numPairs = generatedNumPairs;
			} 
			numAvail = generatedNumAvail;
			if (numAvail < 2) {
				this.setBackRes(((UInt32)(Int32)-1));
				return 1;
			} 
			if (numAvail > (2 + ((1 << 3) * 2 + (1 << 8)) - 1)) {
				numAvail = (2 + ((1 << 3) * 2 + (1 << 8)) - 1);
			} 
			data = .UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj) - 1;
			repMaxIndex = 0;
			for (i = 0; i < 4; i++) {
				int len;
				Byte data2 = new Byte();
				reps[i] = generatedReps[i];
				data2 = data - reps[i];
				if (data[0] != data2[0] || data[1] != data2[1]) {
					repLens[i] = 0;
					continue;
				} 
				for (len = 2; len < numAvail && data[len] == data2[len]; len++) {
				}
				repLens[i] = len;
				if (len > repLens[repMaxIndex]) {
					repMaxIndex = i;
				} 
			}
			if (repLens[repMaxIndex] >= generatedNumFastBytes) {
				int len;
				this.setBackRes((UInt32)repMaxIndex);
				len = repLens[repMaxIndex];
				{ 
					generatedAdditionalOffset += (len - 1);
					.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj, (UInt32)(len - 1));
				}
				return len;
			} 
			matches = generatedMatches;
			if (mainLen >= generatedNumFastBytes) {
				this.setBackRes(matches[(size_t)numPairs - 1] + 4);
				{ 
					generatedAdditionalOffset += (mainLen - 1);
					.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj, (UInt32)(mainLen - 1));
				}
				return mainLen;
			} 
			curByte = data;
			matchByte = (data - reps[0]);
			last = repLens[repMaxIndex];
			if (last <= mainLen) {
				last = mainLen;
			} 
			if (last < 2 && curByte != matchByte) {
				this.setBackRes(((UInt32)(Int32)-1));
				return 1;
			} 
			generatedOpt[0].setState((CState)generatedState);
			posState = (position & generatedPbMask);
			{ 
				CLzmaProb probs = (generatedLitProbs + (UInt32)3 * (((((position) << 8) + ((data - 1))) & generatedLpMask) << generatedLc));
				generatedOpt[1].setPrice(generatedProbPrices[(generatedIsMatch[generatedState][posState]) >> 4] + (!((generatedState) < 7) ? ModernizedCProgram.LitEnc_Matched_GetPrice(probs, curByte, matchByte, generatedProbPrices) : ModernizedCProgram.LitEnc_GetPrice(probs, curByte, generatedProbPrices)));
			}
			{ 
				(generatedOpt[1]).setDist(((UInt32)(Int32)-1));
				(generatedOpt[1]).setExtra(0);
			}
			;
			matchPrice = generatedProbPrices[((generatedIsMatch[generatedState][posState]) ^ ((1 << 11) - 1)) >> 4];
			repMatchPrice = matchPrice + generatedProbPrices[((generatedIsRep[generatedState]) ^ ((1 << 11) - 1)) >> 4];
			if (matchByte == curByte && repLens[0] == 0) {
				UInt32 shortRepPrice = repMatchPrice + (generatedProbPrices[(generatedIsRepG0[generatedState]) >> 4] + generatedProbPrices[(generatedIsRep0Long[generatedState][posState]) >> 4]);
				if (shortRepPrice < generatedOpt[1].getPrice()) {
					generatedOpt[1].setPrice(shortRepPrice);
					{ 
						(generatedOpt[1]).setDist(0);
						(generatedOpt[1]).setExtra(0);
					}
					;
				} 
				if (last < 2) {
					this.setBackRes(generatedOpt[1].getDist());
					return 1;
				} 
			} 
			generatedOpt[1].setLen(1);
			generatedReps[0] = reps[0];
			generatedReps[1] = reps[1];
			generatedReps[2] = reps[2];
			generatedReps[3] = reps[3];
			for (i = 0; i < 4; i++) {
				int repLen = repLens[i];
				UInt32 price = new UInt32();
				if (repLen < 2) {
					continue;
				} 
				price = repMatchPrice + ModernizedCProgram.GetPrice_PureRep(p, i, generatedState, posState);
				do {
					UInt32 price2 = price + ((generatedRepLenEnc).getPrices()[posState][(size_t)(repLen) - 2]);
					COptimal opt = generatedOpt[repLen];
					if (price2 < generatedPrice) {
						opt.setPrice(price2);
						opt.setLen((UInt32)repLen);
						opt.setDist((UInt32)i);
						opt.setExtra(0);
					} 
				} while (--repLen >= 2);
			}
			{ 
				int len = repLens[0] + 1;
				if (len <= mainLen) {
					int offs = 0;
					UInt32 normalMatchPrice = matchPrice + generatedProbPrices[(generatedIsRep[generatedState]) >> 4];
					if (len < 2) {
						len = 2;
					} else {
							while (len > matches[offs]) {
								offs += 2;
							}
					} 
					for (; ; len++) {
						COptimal opt = new COptimal();
						UInt32 dist = matches[(size_t)offs + 1];
						UInt32 price = normalMatchPrice + ((generatedLenEnc).getPrices()[posState][(size_t)(len) - 2]);
						int lenToPosState = (((len) < 4 + 1) ? (len) - 2 : 4 - 1);
						if (dist < (1 << (14 >> 1))) {
							price += generatedDistancesPrices[lenToPosState][dist & ((1 << (14 >> 1)) - 1)];
						} else {
								int slot;
								{ 
									{ 
										int zz = (dist < (1 << ((9 +  / 2) + 6))) ? 6 : 6 + (9 +  / 2) - 1;
										slot = generatedG_FastPos[dist >> zz] + (zz * 2);
									}
									;
								}
								;
								price += generatedAlignPrices[dist & ((1 << 4) - 1)];
								price += generatedPosSlotPrices[lenToPosState][slot];
						} 
						opt = generatedOpt[len];
						if (price < generatedPrice) {
							opt.setPrice(price);
							opt.setLen((UInt32)len);
							opt.setDist(dist + 4);
							opt.setExtra(0);
						} 
						if (len == matches[offs]) {
							offs += 2;
							if (offs == numPairs) {
								break;
							} 
						} 
					}
				} 
			}
			cur = 0/* if (position >= 0) */;
		}
		Object generatedLen = curOpt.getLen();
		Object generatedDist = (curOpt).getDist();
		Object generatedExtra = curOpt.getExtra();
		// ---------- Optimal Parsing ----------for (; ; ) {
			int numAvail;
			UInt32 numAvailFull = new UInt32();
			int newLen;
			int numPairs;
			int prev;
			int state;
			int posState;
			int startLen;
			UInt32 litPrice = new UInt32();
			UInt32 matchPrice = new UInt32();
			UInt32 repMatchPrice = new UInt32();
			BoolInt nextIsLit = new BoolInt();
			Byte curByte = new Byte();
			Byte matchByte = new Byte();
			Byte data = new Byte();
			COptimal curOpt = new COptimal();
			COptimal nextOpt = new COptimal();
			if (++cur == last) {
				break;
			} 
			if (cur >= (1 << 11) - 64) {
				int j;
				int best;
				UInt32 price = generatedPrice;
				best = cur;
				for (j = cur + 1; j <= last; j++) {
					UInt32 price2 = generatedPrice;
					if (price >= price2) {
						price = price2;
						best = j;
					} 
				}
				{ 
					int delta = best - cur;
					if (delta != 0) {
						{ 
							generatedAdditionalOffset += (delta);
							.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj, (UInt32)(delta));
						}
						;
					} 
				}
				cur = best;
				break;
			} 
			newLen = p.ReadMatchDistances(numPairs);
			if (newLen >= generatedNumFastBytes) {
				this.setNumPairs(numPairs);
				this.setLongestMatchLen(newLen);
				break;
			} 
			curOpt = generatedOpt[cur];
			position/*
			    if (curOpt->price >= kInfinityPrice)
			      continue;
			    */++;
			prev = cur - generatedLen;
			if (generatedLen == 1) {
				state = (int)generatedState;
				if ((generatedDist == 0)) {
					state = ModernizedCProgram.kShortRepNextStates[state];
				} else {
						state = ModernizedCProgram.kLiteralNextStates[state];
				} 
			} else {
					COptimal prevOpt = new COptimal();
					UInt32 b0 = new UInt32();
					UInt32 dist = generatedDist;
					if (generatedExtra) {
						prev -= (int)generatedExtra;
						state = 8;
						if (generatedExtra == 1) {
							state = (dist < 4 ? 8 : 7);
						} 
					} else {
							state = (int)generatedState;
							if (dist < 4) {
								state = ModernizedCProgram.kRepNextStates[state];
							} else {
									state = ModernizedCProgram.kMatchNextStates[state];
							} 
					} 
					prevOpt = generatedOpt[prev];
					b0 = generatedReps[0];
					if (dist < 4) {
						if (dist == 0) {
							reps[0] = b0;
							reps[1] = generatedReps[1];
							reps[2] = generatedReps[2];
							reps[3] = generatedReps[3];
						} else {
								reps[1] = b0;
								b0 = generatedReps[1];
								if (dist == 1) {
									reps[0] = b0;
									reps[2] = generatedReps[2];
									reps[3] = generatedReps[3];
								} else {
										reps[2] = b0;
										reps[0] = generatedReps[dist];
										reps[3] = generatedReps[dist ^ 1];
								} 
						} 
					} else {
							reps[0] = (dist - 4 + 1);
							reps[1] = b0;
							reps[2] = generatedReps[1];
							reps[3] = generatedReps[2];
					} 
			} 
			curOpt.setState((CState)state);
			generatedReps[0] = reps[0];
			generatedReps[1] = reps[1];
			generatedReps[2] = reps[2];
			generatedReps[3] = reps[3];
			data = .UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj) - 1;
			curByte = data;
			matchByte = (data - reps[0]);
			posState = (position & generatedPbMask);
			{ 
				UInt32 curPrice = generatedPrice;
				int prob = generatedIsMatch[state][posState];
				matchPrice = curPrice + generatedProbPrices[((prob) ^ ((1 << 11) - 1)) >> 4];
				litPrice = curPrice + generatedProbPrices[(prob) >> 4];
			}
			nextOpt = generatedOpt[(size_t)cur + 1];
			nextIsLit = 0;
			if ((generatedPrice < (1 << 30) && matchByte == curByte) || litPrice > generatedPrice) {
				litPrice = 0;
			} else {
					CLzmaProb probs = (generatedLitProbs + (UInt32)3 * (((((position) << 8) + ((data - 1))) & generatedLpMask) << generatedLc));
					litPrice += (!((state) < 7) ? ModernizedCProgram.LitEnc_Matched_GetPrice(probs, curByte, matchByte, generatedProbPrices) : ModernizedCProgram.LitEnc_GetPrice(probs, curByte, generatedProbPrices));
					if (litPrice < generatedPrice) {
						nextOpt.setPrice(litPrice);
						nextOpt.setLen(1);
						{ 
							(nextOpt).setDist(((UInt32)(Int32)-1));
							(nextOpt).setExtra(0);
						}
						;
						nextIsLit = 1;
					} 
			} 
			repMatchPrice = matchPrice + generatedProbPrices[((generatedIsRep[state]) ^ ((1 << 11) - 1)) >> 4];
			numAvailFull = generatedNumAvail;
			{ 
				int temp = (1 << 11) - 1 - cur;
				if (numAvailFull > temp) {
					numAvailFull = (UInt32)temp;
				} 
			}
			if (((state) < 7)) {
				if (matchByte == curByte) {
					if (repMatchPrice < generatedPrice) {
						if (generatedLen < 2 || (generatedDist != 0)) {
							UInt32 shortRepPrice = repMatchPrice + (generatedProbPrices[(generatedIsRepG0[state]) >> 4] + generatedProbPrices[(generatedIsRep0Long[state][posState]) >> 4]);
							if (shortRepPrice < generatedPrice) {
								nextOpt.setPrice(shortRepPrice);
								nextOpt.setLen(1);
								{ 
									(nextOpt).setDist(0);
									(nextOpt).setExtra(0);
								}
								;
								nextIsLit = 0;
							} 
						} 
					} 
				} 
			} 
			if (numAvailFull < 2) {
				continue;
			} 
			numAvail = (numAvailFull <= generatedNumFastBytes ? numAvailFull : generatedNumFastBytes);
			if (!nextIsLit && litPrice != 0 && matchByte != curByte && numAvailFull > 2) {
				Byte data2 = data - reps[0];
				if (data[1] == data2[1] && data[2] == data2[2]) {
					int len;
					int limit = generatedNumFastBytes + 1;
					if (limit > numAvailFull) {
						limit = numAvailFull;
					} 
					for (len = 3; len < limit && data[len] == data2[len]; len++) {
					}
					{ 
						int state2 = ModernizedCProgram.kLiteralNextStates[state];
						int posState2 = (position + 1) & generatedPbMask;
						UInt32 price = litPrice + (generatedProbPrices[((generatedIsMatch[state2][posState2]) ^ ((1 << 11) - 1)) >> 4] + generatedProbPrices[((generatedIsRep0Long[state2][posState2]) ^ ((1 << 11) - 1)) >> 4]) + generatedProbPrices[((generatedIsRep[state2]) ^ ((1 << 11) - 1)) >> 4] + generatedProbPrices[(generatedIsRepG0[state2]) >> 4];
						{ 
							int offset = cur + len;
							if (last < offset) {
								last = offset;
							} 
							{ 
								UInt32 price2 = new UInt32();
								COptimal opt = new COptimal();
								len--;
								price2 = price + ((generatedRepLenEnc).getPrices()[posState2][(size_t)(len) - 2]);
								opt = generatedOpt[offset];
								if (price2 < generatedPrice) {
									opt.setPrice(price2);
									opt.setLen((UInt32)len);
									opt.setDist(0);
									opt.setExtra(1);
								} 
							}
						}
					}
				} 
			} 
			startLen = /* speed optimization */2;
			{ 
				int repIndex = 0;
				for (; repIndex < 4; repIndex++) {
					int len;
					UInt32 price = new UInt32();
					Byte data2 = data - reps[repIndex];
					if (data[0] != data2[0] || data[1] != data2[1]) {
						continue;
					} 
					for (len = 2; len < numAvail && data[len] == data2[len]; len++) {
					}
					{ 
						int offset = cur + len;
						if (last < offset) {
							last = offset;
						} 
					}
					{ 
						int len2 = len;
						price = repMatchPrice + ModernizedCProgram.GetPrice_PureRep(p, repIndex, state, posState);
						do {
							UInt32 price2 = price + ((generatedRepLenEnc).getPrices()[posState][(size_t)(len2) - 2]);
							COptimal opt = generatedOpt[cur + len2];
							if (price2 < generatedPrice) {
								opt.setPrice(price2);
								opt.setLen((UInt32)len2);
								opt.setDist((UInt32)repIndex);
								opt.setExtra(0);
							} 
						} while (--len2 >= 2);
					}
					if (repIndex == 0) {
						startLen = len + 1/* if (_maxMode) */;
					} 
					{ 
						int len2 = len + 1;
						int limit = len2 + generatedNumFastBytes;
						if (limit > numAvailFull) {
							limit = numAvailFull;
						} 
						len2 += 2;
						if (len2 <= limit) {
							if (data[len2 - 2] == data2[len2 - 2]) {
								if (data[len2 - 1] == data2[len2 - 1]) {
									int state2 = ModernizedCProgram.kRepNextStates[state];
									int posState2 = (position + len) & generatedPbMask;
									price += ((generatedRepLenEnc).getPrices()[posState][(size_t)(len) - 2]) + generatedProbPrices[(generatedIsMatch[state2][posState2]) >> 4] + ModernizedCProgram.LitEnc_Matched_GetPrice((generatedLitProbs + (UInt32)3 * (((((position + len) << 8) + (data[(size_t)len - 1])) & generatedLpMask) << generatedLc)), data[len], data2[len], generatedProbPrices);
									state2 = 5;
									posState2 = (posState2 + 1) & generatedPbMask;
									price += (generatedProbPrices[((generatedIsMatch[state2][posState2]) ^ ((1 << 11) - 1)) >> 4] + generatedProbPrices[((generatedIsRep0Long[state2][posState2]) ^ ((1 << 11) - 1)) >> 4]) + generatedProbPrices[((generatedIsRep[state2]) ^ ((1 << 11) - 1)) >> 4] + generatedProbPrices[(generatedIsRepG0[state2]) >> 4];
									for (; len2 < limit && data[len2] == data2[len2]; len2++) {
									}
									len2 -= len;
									{ 
										{ 
											int offset = cur + len + len2;
											if (last < offset) {
												last = offset;
											} 
											{ 
												UInt32 price2 = new UInt32();
												COptimal opt = new COptimal();
												len2--;
												price2 = price + ((generatedRepLenEnc).getPrices()[posState2][(size_t)(len2) - 2]);
												opt = generatedOpt[offset];
												if (price2 < generatedPrice) {
													opt.setPrice(price2);
													opt.setLen((UInt32)len2);
													opt.setExtra((CExtra)(len + 1));
													opt.setDist((UInt32)repIndex);
												} 
											}
										}
									}
								} 
							} 
						} 
					}
				}
			}
			if (newLen > /* for (unsigned len = 2; len <= newLen; len++) */numAvail) {
				newLen = numAvail;
				for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2) {
					;
				}
				matches[numPairs] = (UInt32)newLen;
				numPairs += 2;
			} 
			if (newLen >= startLen) {
				UInt32 normalMatchPrice = matchPrice + generatedProbPrices[(generatedIsRep[state]) >> 4];
				UInt32 dist = new UInt32();
				int offs;
				int posSlot;
				int len;
				{ 
					int offset = cur + newLen;
					if (last < offset) {
						last = offset;
					} 
				}
				offs = 0;
				while (startLen > matches[offs]) {
					offs += 2;
				}
				dist = matches[(size_t)offs + 1];
				{ 
					{ 
						int zz = (dist < (1 << ((9 +  / 2) + 6))) ? 6 : 6 + (9 +  / 2) - 1;
						posSlot = generatedG_FastPos[dist >> zz] + (zz * 2);
					}
					;
				}
				;
				for (len = startLen; ; /*2*/len++) {
					UInt32 price = normalMatchPrice + ((generatedLenEnc).getPrices()[posState][(size_t)(len) - 2]);
					{ 
						COptimal opt = new COptimal();
						int lenNorm = len - 2;
						lenNorm = (((lenNorm) < 4 - 1) ? (lenNorm) : 4 - 1);
						if (dist < (1 << (14 >> 1))) {
							price += generatedDistancesPrices[lenNorm][dist & ((1 << (14 >> 1)) - 1)];
						} else {
								price += generatedPosSlotPrices[lenNorm][posSlot] + generatedAlignPrices[dist & ((1 << 4) - 1)];
						} 
						opt = generatedOpt[cur + len];
						if (price < generatedPrice) {
							opt.setPrice(price);
							opt.setLen((UInt32)len);
							opt.setDist(dist + 4);
							opt.setExtra(0);
						} 
					}
					if (len == matches[offs]) {
						Byte data2 = data - dist - 1;
						int len2 = len + 1;
						int limit = len2 + generatedNumFastBytes;
						if (limit > numAvailFull) {
							limit = numAvailFull;
						} 
						len2 += 2;
						if (len2 <= limit) {
							if (data[len2 - 2] == data2[len2 - 2]) {
								if (data[len2 - 1] == data2[len2 - 1]) {
									for (; len2 < limit && data[len2] == data2[len2]; len2++) {
									}
									len2 -= len;
									{ 
										int state2 = ModernizedCProgram.kMatchNextStates[state];
										int posState2 = (position + len) & generatedPbMask;
										int offset;
										price += generatedProbPrices[(generatedIsMatch[state2][posState2]) >> 4];
										price += ModernizedCProgram.LitEnc_Matched_GetPrice((generatedLitProbs + (UInt32)3 * (((((position + len) << 8) + (data[(size_t)len - 1])) & generatedLpMask) << generatedLc)), data[len], data2[len], generatedProbPrices);
										state2 = 4;
										posState2 = (posState2 + 1) & generatedPbMask;
										price += (generatedProbPrices[((generatedIsMatch[state2][posState2]) ^ ((1 << 11) - 1)) >> 4] + generatedProbPrices[((generatedIsRep0Long[state2][posState2]) ^ ((1 << 11) - 1)) >> 4]) + generatedProbPrices[((generatedIsRep[state2]) ^ ((1 << 11) - 1)) >> 4] + generatedProbPrices[(generatedIsRepG0[state2]) >> 4];
										offset = cur + len + len2;
										if (last < offset) {
											last = offset;
										} 
										{ 
											UInt32 price2 = new UInt32();
											COptimal opt = new COptimal();
											len2--;
											price2 = price + ((generatedRepLenEnc).getPrices()[posState2][(size_t)(len2) - 2]);
											opt = generatedOpt[offset];
											if (price2 < generatedPrice) {
												opt.setPrice(price2);
												opt.setLen((UInt32)len2);
												opt.setExtra((CExtra)(len + 1));
												opt.setDist(dist + 4);
											} 
										}
									}
								} 
							} 
						} 
						offs += 2;
						if (offs == numPairs) {
							break;
						} 
						dist = matches[(size_t)offs + 1];
						{ 
							{ 
								int zz = (dist < (1 << ((9 +  / 2) + 6))) ? 6 : 6 + (9 +  / 2) - 1;
								posSlot = generatedG_FastPos[dist >> zz] + (zz * 2);
							}
							;
						}
						;
					} 
				}
			} 
		}
		do {
			generatedOpt[last].setPrice((1 << 30));
		} while (--last);
		return p.Backward(cur);
	}
	public static int GetOptimumFast() {
		UInt32 numAvail = new UInt32();
		UInt32 mainDist = new UInt32();
		int mainLen;
		int numPairs;
		int repIndex;
		int repLen;
		int i;
		Byte data = new Byte();
		Object generatedAdditionalOffset = this.getAdditionalOffset();
		Object generatedLongestMatchLen = this.getLongestMatchLen();
		Object generatedNumPairs = this.getNumPairs();
		if (generatedAdditionalOffset == 0) {
			mainLen = p.ReadMatchDistances(numPairs);
		} else {
				mainLen = generatedLongestMatchLen;
				numPairs = generatedNumPairs;
		} 
		Object generatedNumAvail = this.getNumAvail();
		numAvail = generatedNumAvail;
		this.setBackRes(((UInt32)(Int32)-1));
		if (numAvail < 2) {
			return 1;
		} 
		if (numAvail > (2 + ((1 << 3) * 2 + (1 << 8)) - 1)) {
			numAvail = (2 + ((1 << 3) * 2 + (1 << 8)) - 1);
		} 
		Object generatedMatchFinderObj = this.getMatchFinderObj();
		data = .UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj) - 1;
		repLen = repIndex = 0;
		Object generatedReps = this.getReps();
		Object generatedNumFastBytes = this.getNumFastBytes();
		for (i = 0; i < 4; i++) {
			int len;
			Byte data2 = data - generatedReps[i];
			if (data[0] != data2[0] || data[1] != data2[1]) {
				continue;
			} 
			for (len = 2; len < numAvail && data[len] == data2[len]; len++) {
			}
			if (len >= generatedNumFastBytes) {
				this.setBackRes((UInt32)i);
				{ 
					generatedAdditionalOffset += (len - 1);
					.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj, (UInt32)(len - 1));
				}
				return len;
			} 
			if (len > repLen) {
				repIndex = i;
				repLen = len;
			} 
		}
		Object generatedMatches = this.getMatches();
		if (mainLen >= generatedNumFastBytes) {
			this.setBackRes(generatedMatches[(size_t)numPairs - 1] + 4);
			{ 
				generatedAdditionalOffset += (mainLen - 1);
				.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj, (UInt32)(mainLen - 1));
			}
			return mainLen;
		} 
		mainDist = /* for GCC */0;
		if (mainLen >= 2) {
			mainDist = generatedMatches[(size_t)numPairs - 1];
			while (numPairs > 2) {
				UInt32 dist2 = new UInt32();
				if (mainLen != generatedMatches[(size_t)numPairs - 4] + 1) {
					break;
				} 
				dist2 = generatedMatches[(size_t)numPairs - 3];
				if (!(((mainDist) >> 7) > (dist2))) {
					break;
				} 
				numPairs -= 2;
				mainLen--;
				mainDist = dist2;
			}
			if (mainLen == 2 && mainDist >= -1024) {
				mainLen = 1;
			} 
		} 
		if (repLen >= 2) {
			if (repLen + 1 >= mainLen || (repLen + 2 >= mainLen && mainDist >= (1 << 9)) || (repLen + 3 >= mainLen && mainDist >= (1 << 15))) {
				this.setBackRes((UInt32)repIndex);
				{ 
					generatedAdditionalOffset += (repLen - 1);
					.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj, (UInt32)(repLen - 1));
				}
				return repLen;
			} 
		} 
		if (mainLen < 2 || numAvail <= 2) {
			return 1;
		} 
		{ 
			int len1 = p.ReadMatchDistances(generatedNumPairs);
			this.setLongestMatchLen(len1);
			if (len1 >= 2) {
				UInt32 newDist = generatedMatches[(size_t)generatedNumPairs - 1];
				if ((len1 >= mainLen && newDist < mainDist) || (len1 == mainLen + 1 && !(((newDist) >> 7) > (mainDist))) || (len1 > mainLen + 1) || (len1 + 1 >= mainLen && mainLen >= 3 && (((mainDist) >> 7) > (newDist)))) {
					return 1;
				} 
			} 
		}
		data = .UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj) - 1;
		for (i = 0; i < 4; i++) {
			int len;
			int limit;
			Byte data2 = data - generatedReps[i];
			if (data[0] != data2[0] || data[1] != data2[1]) {
				continue;
			} 
			limit = mainLen - 1;
			for (len = 2; ; len++) {
				if (len >= limit) {
					return 1;
				} 
				if (data[len] != data2[len]) {
					break;
				} 
			}
		}
		this.setBackRes(mainDist + 4);
		if (mainLen != 2) {
			{ 
				generatedAdditionalOffset += (mainLen - 2);
				.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj, (UInt32)(mainLen - 2));
			}
		} 
		return mainLen;
	}
	public static void WriteEndMarker(int posState) {
		UInt32 range = new UInt32();
		Object generatedRc = this.getRc();
		range = generatedRc.getRange();
		Object generatedIsMatch = this.getIsMatch();
		Object generatedState = this.getState();
		Object generatedIsRep = this.getIsRep();
		{ 
			UInt32 ttt = new UInt32();
			UInt32 newBound = new UInt32();
			CLzmaProb prob = generatedIsMatch[generatedState][posState];
			ttt = (prob);
			newBound = (range >> 11) * ttt;
			range -= newBound;
			(generatedRc).getLow() += newBound;
			(prob) = (CLzmaProb)(ttt - (ttt >> 5));
			if (range < ((UInt32)1 << 24)) {
				range <<=  8;
				generatedRc.RangeEnc_ShiftLow();
			} 
			prob = generatedIsRep[generatedState];
			ttt = (prob);
			newBound = (range >> 11) * ttt;
			range = newBound;
			(prob) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
			if (range < ((UInt32)1 << 24)) {
				range <<=  8;
				generatedRc.RangeEnc_ShiftLow();
			} 
		}
		this.setState(ModernizedCProgram.kMatchNextStates[generatedState]);
		generatedRc.setRange(range);
		Object generatedLenProbs = this.getLenProbs();
		generatedLenProbs.LenEnc_Encode(generatedRc, 0, posState);
		range = generatedRc.getRange();
		Object generatedPosSlotEncoder = this.getPosSlotEncoder();
		{ 
			CLzmaProb probs = generatedPosSlotEncoder[0];
			int m = 1;
			do {
				UInt32 ttt = new UInt32();
				UInt32 newBound = new UInt32();
				ttt = (probs + m);
				newBound = (range >> 11) * ttt;
				range -= newBound;
				(generatedRc).getLow() += newBound;
				(probs + m) = (CLzmaProb)(ttt - (ttt >> 5));
				if (range < ((UInt32)1 << 24)) {
					range <<=  8;
					generatedRc.RangeEnc_ShiftLow();
				} 
				;
				m = (m << 1) + 1;
			} while (m < (1 << 6));
		}
		{ 
			int numBits = 30 - 4;
			do {
				range >>=  1;
				generatedRc.getLow() += range;
				if (range < ((UInt32)1 << 24)) {
					range <<=  8;
					generatedRc.RangeEnc_ShiftLow();
				} 
			} while (--numBits);
		}
		Object generatedPosAlignEncoder = this.getPosAlignEncoder();
		{ 
			CLzmaProb probs = generatedPosAlignEncoder;
			int m = 1;
			do {
				UInt32 ttt = new UInt32();
				UInt32 newBound = new UInt32();
				ttt = (probs + m);
				newBound = (range >> 11) * ttt;
				range -= newBound;
				(generatedRc).getLow() += newBound;
				(probs + m) = (CLzmaProb)(ttt - (ttt >> 5));
				if (range < ((UInt32)1 << 24)) {
					range <<=  8;
					generatedRc.RangeEnc_ShiftLow();
				} 
				;
				m = (m << 1) + 1;
			} while (m < (1 << 4));
		}
		generatedRc.setRange(range);
	}
	public static Object CheckErrors() {
		Object generatedResult = this.getResult();
		if (generatedResult != 0) {
			return generatedResult;
		} 
		Object generatedRc = this.getRc();
		if (generatedRc.getRes() != 0) {
			this.setResult(9);
		} 
		if (generatedResult != 0) {
			this.setResult(8);
		} 
		if (generatedResult != 0) {
			this.setFinished(1);
		} 
		return generatedResult;
	}
	public static Object Flush(Object nowPos) {
		this.setFinished(/* ReleaseMFStream(); */1);
		Object generatedWriteEndMark = this.getWriteEndMark();
		Object generatedPbMask = this.getPbMask();
		if (generatedWriteEndMark) {
			p.WriteEndMarker(nowPos & generatedPbMask);
		} 
		Object generatedRc = this.getRc();
		generatedRc.RangeEnc_FlushData();
		generatedRc.RangeEnc_FlushStream();
		return p.CheckErrors();
	}
	public static void FillAlignPrices() {
		int i;
		Object generatedProbPrices = this.getProbPrices();
		CProbPrice ProbPrices = generatedProbPrices;
		Object generatedPosAlignEncoder = this.getPosAlignEncoder();
		CLzmaProb probs = generatedPosAlignEncoder;
		// p->alignPriceCount = 0;
		Object generatedAlignPrices = this.getAlignPrices();
		for (i = 0; i < (1 << 4) / 2; i++) {
			UInt32 price = 0;
			int sym = i;
			int m = 1;
			int bit;
			UInt32 prob = new UInt32();
			bit = sym & 1;
			sym >>=  1;
			price += ProbPrices[((probs[m]) ^ (int)((-((int)(bit))) & ((1 << 11) - 1))) >> 4];
			;
			m = (m << 1) + bit;
			bit = sym & 1;
			sym >>=  1;
			price += ProbPrices[((probs[m]) ^ (int)((-((int)(bit))) & ((1 << 11) - 1))) >> 4];
			;
			m = (m << 1) + bit;
			bit = sym & 1;
			sym >>=  1;
			price += ProbPrices[((probs[m]) ^ (int)((-((int)(bit))) & ((1 << 11) - 1))) >> 4];
			;
			m = (m << 1) + bit;
			prob = probs[m];
			generatedAlignPrices[i] = price + ProbPrices[(prob) >> 4];
			generatedAlignPrices[i + 8] = price + ProbPrices[((prob) ^ ((1 << 11) - 1)) >> 4];
		}
	}
	public static void FillDistancesPrices() {
		// int y; for (y = 0; y < 100; y++) {UInt32[] tempPrices = new UInt32();
		int i;
		int lps;
		Object generatedProbPrices = this.getProbPrices();
		CProbPrice ProbPrices = generatedProbPrices;
		this.setMatchPriceCount(0);
		Object generatedG_FastPos = this.getG_FastPos();
		Object generatedPosEncoders = this.getPosEncoders();
		for (i = 4 / 2; i < (1 << (14 >> 1)) / 2; i++) {
			int posSlot = generatedG_FastPos[i];
			int footerBits = (posSlot >> 1) - 1;
			int base = ((2 | (posSlot & 1)) << footerBits);
			CLzmaProb probs = generatedPosEncoders + (size_t)base * 2;
			UInt32 price = 0;
			int m = 1;
			int sym = i;
			int offset = (int)1 << footerBits;
			base += i;
			if (footerBits) {
				do {
					int bit = sym & 1;
					sym >>=  1;
					price += ProbPrices[((probs[m]) ^ (int)((-((int)(bit))) & ((1 << 11) - 1))) >> 4];
					;
					m = (m << 1) + bit;
				} while (--footerBits);
			} 
			{ 
				int prob = probs[m];
				tempPrices[base] = price + ProbPrices[(prob) >> 4];
				tempPrices[base + offset] = price + ProbPrices[((prob) ^ ((1 << 11) - 1)) >> 4];
			}
		}
		Object generatedDistTableSize = this.getDistTableSize();
		Object generatedPosSlotPrices = this.getPosSlotPrices();
		Object generatedPosSlotEncoder = this.getPosSlotEncoder();
		Object generatedDistancesPrices = this.getDistancesPrices();
		for (lps = 0; lps < 4; lps++) {
			int slot;
			int distTableSize2 = (generatedDistTableSize + 1) >> 1;
			UInt32 posSlotPrices = generatedPosSlotPrices[lps];
			CLzmaProb probs = generatedPosSlotEncoder[lps];
			for (slot = 0; slot < distTableSize2; slot++) {
				UInt32 price = new UInt32();
				int bit;
				int sym = slot + (1 << (6 - 1));
				int prob;
				bit = sym & 1;
				sym >>=  1;
				price = ProbPrices[((probs[sym]) ^ (int)((-((int)(bit))) & ((1 << 11) - 1))) >> 4];
				;
				bit = sym & 1;
				sym >>=  1;
				price += ProbPrices[((probs[sym]) ^ (int)((-((int)(bit))) & ((1 << 11) - 1))) >> 4];
				;
				bit = sym & 1;
				sym >>=  1;
				price += ProbPrices[((probs[sym]) ^ (int)((-((int)(bit))) & ((1 << 11) - 1))) >> 4];
				;
				bit = sym & 1;
				sym >>=  1;
				price += ProbPrices[((probs[sym]) ^ (int)((-((int)(bit))) & ((1 << 11) - 1))) >> 4];
				;
				bit = sym & 1;
				sym >>=  1;
				price += ProbPrices[((probs[sym]) ^ (int)((-((int)(bit))) & ((1 << 11) - 1))) >> 4];
				;
				prob = probs[(size_t)slot + (1 << (6 - 1))];
				posSlotPrices[(size_t)slot * 2] = price + ProbPrices[(prob) >> 4];
				posSlotPrices[(size_t)slot * 2 + 1] = price + ProbPrices[((prob) ^ ((1 << 11) - 1)) >> 4];
			}
			{ 
				UInt32 delta = ((UInt32)((14 / 2 - 1) - 4) << 4);
				for (slot = 14 / 2; slot < distTableSize2; slot++) {
					posSlotPrices[(size_t)slot * 2] += delta;
					posSlotPrices[(size_t)slot * 2 + 1] += delta;
					delta += ((UInt32)1 << 4);
				}
			}
			{ 
				UInt32 dp = generatedDistancesPrices[lps];
				dp[0] = posSlotPrices[0];
				dp[1] = posSlotPrices[1];
				dp[2] = posSlotPrices[2];
				dp[3] = posSlotPrices[3];
				for (i = 4; i < (1 << (14 >> 1)); i += 2) {
					UInt32 slotPrice = posSlotPrices[generatedG_FastPos[i]];
					dp[i] = slotPrice + tempPrices[i];
					dp[i + 1] = slotPrice + tempPrices[i + 1];
				}
			}
		}
	}
	public static void LzmaEnc_Construct() {
		Object generatedRc = this.getRc();
		generatedRc.RangeEnc_Construct();
		Object generatedMatchFinderBase = this.getMatchFinderBase();
		generatedMatchFinderBase.MatchFinder_Construct();
		Object generatedMatchFinderMt = this.getMatchFinderMt();
		generatedMatchFinderMt.MatchFinderMt_Construct();
		generatedMatchFinderMt.setMatchFinder(generatedMatchFinderBase);
		{ 
			CLzmaEncProps props = new CLzmaEncProps();
			props.LzmaEncProps_Init();
			ModernizedCProgram.LzmaEnc_SetProps(p, props);
		}
		Object generatedG_FastPos = this.getG_FastPos();
		ModernizedCProgram.LzmaEnc_FastPosInit(generatedG_FastPos);
		Object generatedProbPrices = this.getProbPrices();
		ModernizedCProgram.LzmaEnc_InitPriceTables(generatedProbPrices);
		this.setLitProbs(((Object)0));
		Object generatedSaveState = this.getSaveState();
		generatedSaveState.setLitProbs(((Object)0));
	}
	public static Object LzmaEnc_Create(Object alloc) {
		Object p;
		p = .UNRECOGNIZEDFUNCTIONNAME(alloc, );
		if (p) {
			(CLzmaEnc)p.LzmaEnc_Construct();
		} 
		return p;
	}
	public static void LzmaEnc_FreeLits(Object alloc) {
		Object generatedLitProbs = this.getLitProbs();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedLitProbs);
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedLitProbs);
		this.setLitProbs(((Object)0));
		Object generatedSaveState = this.getSaveState();
		generatedSaveState.setLitProbs(((Object)0));
	}
	public static void LzmaEnc_Destruct(Object alloc, Object allocBig) {
		Object generatedMatchFinderMt = this.getMatchFinderMt();
		generatedMatchFinderMt.MatchFinderMt_Destruct(allocBig);
		Object generatedMatchFinderBase = this.getMatchFinderBase();
		generatedMatchFinderBase.MatchFinder_Free(allocBig);
		p.LzmaEnc_FreeLits(alloc);
		Object generatedRc = this.getRc();
		generatedRc.RangeEnc_Free(alloc);
	}
	public static void LzmaEnc_Destroy(Object p, Object alloc, Object allocBig) {
		(CLzmaEnc)p.LzmaEnc_Destruct(alloc, allocBig);
		.UNRECOGNIZEDFUNCTIONNAME(alloc, p);
	}
	public static Object LzmaEnc_CodeOneBlock(Object maxPackSize, Object maxUnpackSize) {
		UInt32 nowPos32 = new UInt32();
		UInt32 startPos32 = new UInt32();
		Object generatedNeedInit = this.getNeedInit();
		Object generatedMatchFinderObj = this.getMatchFinderObj();
		if (generatedNeedInit) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj);
			this.setNeedInit(0);
		} 
		Object generatedFinished = this.getFinished();
		Object generatedResult = this.getResult();
		if (generatedFinished) {
			return generatedResult;
		} 
		{ 
			int __result__ = (p.CheckErrors());
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedNowPos64 = this.getNowPos64();
		nowPos32 = (UInt32)generatedNowPos64;
		startPos32 = nowPos32;
		Object generatedRc = this.getRc();
		Object generatedIsMatch = this.getIsMatch();
		Object generatedAdditionalOffset = this.getAdditionalOffset();
		Object generatedLitProbs = this.getLitProbs();
		if (generatedNowPos64 == 0) {
			int numPairs;
			Byte curByte = new Byte();
			if (.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj) == 0) {
				return p.Flush(nowPos32);
			} 
			p.ReadMatchDistances(numPairs);
			generatedRc.RangeEnc_EncodeBit_0(generatedIsMatch[0][0]);
			curByte = (.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj) - generatedAdditionalOffset);
			generatedRc.LitEnc_Encode(generatedLitProbs, curByte);
			generatedAdditionalOffset--;
			nowPos32++;
		} 
		Object generatedFastMode = this.getFastMode();
		Object generatedOptCur = this.getOptCur();
		Object generatedOptEnd = this.getOptEnd();
		Object generatedOpt = this.getOpt();
		Object generatedPbMask = this.getPbMask();
		Object generatedState = this.getState();
		Object generatedBackRes = this.getBackRes();
		Object generatedLpMask = this.getLpMask();
		Object generatedLc = this.getLc();
		Object generatedReps = this.getReps();
		Object generatedIsRep = this.getIsRep();
		Object generatedIsRepG0 = this.getIsRepG0();
		Object generatedIsRep0Long = this.getIsRep0Long();
		Object generatedIsRepG1 = this.getIsRepG1();
		Object generatedIsRepG2 = this.getIsRepG2();
		Object generatedRepLenProbs = this.getRepLenProbs();
		Object generatedRepLenEncCounter = this.getRepLenEncCounter();
		Object generatedLenProbs = this.getLenProbs();
		Object generatedMatchPriceCount = this.getMatchPriceCount();
		Object generatedG_FastPos = this.getG_FastPos();
		Object generatedPosSlotEncoder = this.getPosSlotEncoder();
		Object generatedPosEncoders = this.getPosEncoders();
		Object generatedPosAlignEncoder = this.getPosAlignEncoder();
		Object generatedLenEnc = this.getLenEnc();
		Object generatedPb = this.getPb();
		Object generatedProbPrices = this.getProbPrices();
		Object generatedRepLenEnc = this.getRepLenEnc();
		if (.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj) != 0) {
			for (; ; ) {
				UInt32 dist = new UInt32();
				int len;
				int posState;
				UInt32 range = new UInt32();
				UInt32 ttt = new UInt32();
				UInt32 newBound = new UInt32();
				CLzmaProb probs = new CLzmaProb();
				if (generatedFastMode) {
					len = p.GetOptimumFast();
				} else {
						int oci = generatedOptCur;
						if (generatedOptEnd == oci) {
							len = p.GetOptimum(nowPos32);
						} else {
								COptimal opt = generatedOpt[oci];
								len = opt.getLen();
								this.setBackRes(opt.getDist());
								this.setOptCur(oci + 1);
						} 
				} 
				posState = (int)nowPos32 & generatedPbMask;
				range = generatedRc.getRange();
				probs = generatedIsMatch[generatedState][posState];
				ttt = (probs);
				newBound = (range >> 11) * ttt;
				dist = generatedBackRes;
				if (dist == ((UInt32)(Int32)-1)) {
					Byte curByte = new Byte();
					Byte data = new Byte();
					int state;
					range = newBound;
					(probs) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
					if (range < ((UInt32)1 << 24)) {
						range <<=  8;
						generatedRc.RangeEnc_ShiftLow();
					} 
					;
					generatedRc.setRange(range);
					data = .UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj) - generatedAdditionalOffset;
					probs = (generatedLitProbs + (UInt32)3 * (((((nowPos32) << 8) + ((data - 1))) & generatedLpMask) << generatedLc));
					curByte = data;
					state = generatedState;
					this.setState(ModernizedCProgram.kLiteralNextStates[state]);
					if (((state) < 7)) {
						generatedRc.LitEnc_Encode(probs, curByte);
					} else {
							generatedRc.LitEnc_EncodeMatched(probs, curByte, (data - generatedReps[0]));
					} 
				} else {
						range -= newBound;
						(generatedRc).getLow() += newBound;
						(probs) = (CLzmaProb)(ttt - (ttt >> 5));
						if (range < ((UInt32)1 << 24)) {
							range <<=  8;
							generatedRc.RangeEnc_ShiftLow();
						} 
						;
						probs = generatedIsRep[generatedState];
						ttt = (probs);
						newBound = (range >> 11) * ttt;
						if (dist < 4) {
							range -= newBound;
							(generatedRc).getLow() += newBound;
							(probs) = (CLzmaProb)(ttt - (ttt >> 5));
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								generatedRc.RangeEnc_ShiftLow();
							} 
							;
							probs = generatedIsRepG0[generatedState];
							ttt = (probs);
							newBound = (range >> 11) * ttt;
							if (dist == 0) {
								range = newBound;
								(probs) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								if (range < ((UInt32)1 << 24)) {
									range <<=  8;
									generatedRc.RangeEnc_ShiftLow();
								} 
								;
								probs = generatedIsRep0Long[generatedState][posState];
								ttt = (probs);
								newBound = (range >> 11) * ttt;
								if (len != 1) {
									range -= newBound;
									(generatedRc).getLow() += newBound;
									(probs) = (CLzmaProb)(ttt - (ttt >> 5));
									;
								} else {
										range = newBound;
										(probs) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
										;
										this.setState(ModernizedCProgram.kShortRepNextStates[generatedState]);
								} 
							} else {
									range -= newBound;
									(generatedRc).getLow() += newBound;
									(probs) = (CLzmaProb)(ttt - (ttt >> 5));
									if (range < ((UInt32)1 << 24)) {
										range <<=  8;
										generatedRc.RangeEnc_ShiftLow();
									} 
									;
									probs = generatedIsRepG1[generatedState];
									ttt = (probs);
									newBound = (range >> 11) * ttt;
									if (dist == 1) {
										range = newBound;
										(probs) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
										;
										dist = generatedReps[1];
									} else {
											range -= newBound;
											(generatedRc).getLow() += newBound;
											(probs) = (CLzmaProb)(ttt - (ttt >> 5));
											if (range < ((UInt32)1 << 24)) {
												range <<=  8;
												generatedRc.RangeEnc_ShiftLow();
											} 
											;
											probs = generatedIsRepG2[generatedState];
											ttt = (probs);
											newBound = (range >> 11) * ttt;
											if (dist == 2) {
												range = newBound;
												(probs) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
												;
												dist = generatedReps[2];
											} else {
													range -= newBound;
													(generatedRc).getLow() += newBound;
													(probs) = (CLzmaProb)(ttt - (ttt >> 5));
													;
													dist = generatedReps[3];
													generatedReps[3] = generatedReps[2];
											} 
											generatedReps[2] = generatedReps[1];
									} 
									generatedReps[1] = generatedReps[0];
									generatedReps[0] = dist;
							} 
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								generatedRc.RangeEnc_ShiftLow();
							} 
							generatedRc.setRange(range);
							if (len != 1) {
								generatedRepLenProbs.LenEnc_Encode(generatedRc, len - 2, posState);
								--generatedRepLenEncCounter;
								this.setState(ModernizedCProgram.kRepNextStates[generatedState]);
							} 
						} else {
								int posSlot;
								range = newBound;
								(probs) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								if (range < ((UInt32)1 << 24)) {
									range <<=  8;
									generatedRc.RangeEnc_ShiftLow();
								} 
								;
								generatedRc.setRange(range);
								this.setState(ModernizedCProgram.kMatchNextStates[generatedState]);
								generatedLenProbs.LenEnc_Encode(generatedRc, len - 2, posState);
								dist -= 4;
								generatedReps[3] = generatedReps[2];
								generatedReps[2] = generatedReps[1];
								generatedReps[1] = generatedReps[0];
								generatedReps[0] = dist + 1;
								generatedMatchPriceCount++;
								{ 
									if (dist < (1 << (14 >> 1))) {
										posSlot = generatedG_FastPos[dist & ((1 << (14 >> 1)) - 1)];
									} else {
											int zz = (dist < (1 << ((9 +  / 2) + 6))) ? 6 : 6 + (9 +  / 2) - 1;
											posSlot = generatedG_FastPos[dist >> zz] + (zz * 2);
									} 
									;
								}
								;
								{ 
									UInt32 sym = (UInt32)posSlot + (1 << 6);
									range = generatedRc.getRange();
									probs = generatedPosSlotEncoder[(((len) < 4 + 1) ? (len) - 2 : 4 - 1)];
									do {
										CLzmaProb prob = probs + (sym >> 6);
										UInt32 bit = (sym >> (6 - 1)) & 1;
										sym <<=  1;
										{ 
											UInt32 mask = new UInt32();
											ttt = (prob);
											newBound = (range >> 11) * ttt;
											mask = 0 - (UInt32)bit;
											range &=  mask;
											mask &=  newBound;
											range -= mask;
											(generatedRc).getLow() += mask;
											mask = (UInt32)bit - 1;
											range += newBound & mask;
											mask &=  ((1 << 11) - ((1 << 5) - 1));
											mask += ((1 << 5) - 1);
											ttt += (Int32)(mask - ttt) >> 5;
											(prob) = (CLzmaProb)ttt;
											if (range < ((UInt32)1 << 24)) {
												range <<=  8;
												generatedRc.RangeEnc_ShiftLow();
											} 
										}
										;
									} while (sym < (1 << 6 * 2));
									generatedRc.setRange(range);
								}
								if (dist >= 4) {
									int footerBits = ((posSlot >> 1) - 1);
									if (dist < (1 << (14 >> 1))) {
										int base = ((2 | (posSlot & 1)) << footerBits);
										generatedRc.RcTree_ReverseEncode(generatedPosEncoders + base, footerBits, (int)(/* - base */dist));
									} else {
											UInt32 pos2 = (dist | -1024) << (32 - footerBits);
											range = generatedRc.getRange();
											do {
												range >>=  1;
												generatedRc.getLow() += range & (0 - (pos2 >> 31));
												pos2 += pos2;
												if (range < ((UInt32)1 << 24)) {
													range <<=  8;
													generatedRc.RangeEnc_ShiftLow();
												} 
											} while (pos2 != -1024);
											{ 
												int m = 1;
												int bit;
												bit = dist & 1;
												dist >>=  1;
												{ 
													UInt32 mask = new UInt32();
													ttt = (generatedPosAlignEncoder + m);
													newBound = (range >> 11) * ttt;
													mask = 0 - (UInt32)bit;
													range &=  mask;
													mask &=  newBound;
													range -= mask;
													(generatedRc).getLow() += mask;
													mask = (UInt32)bit - 1;
													range += newBound & mask;
													mask &=  ((1 << 11) - ((1 << 5) - 1));
													mask += ((1 << 5) - 1);
													ttt += (Int32)(mask - ttt) >> 5;
													(generatedPosAlignEncoder + m) = (CLzmaProb)ttt;
													if (range < ((UInt32)1 << 24)) {
														range <<=  8;
														generatedRc.RangeEnc_ShiftLow();
													} 
												}
												;
												m = (m << 1) + bit;
												bit = dist & 1;
												dist >>=  1;
												{ 
													UInt32 mask = new UInt32();
													ttt = (generatedPosAlignEncoder + m);
													newBound = (range >> 11) * ttt;
													mask = 0 - (UInt32)bit;
													range &=  mask;
													mask &=  newBound;
													range -= mask;
													(generatedRc).getLow() += mask;
													mask = (UInt32)bit - 1;
													range += newBound & mask;
													mask &=  ((1 << 11) - ((1 << 5) - 1));
													mask += ((1 << 5) - 1);
													ttt += (Int32)(mask - ttt) >> 5;
													(generatedPosAlignEncoder + m) = (CLzmaProb)ttt;
													if (range < ((UInt32)1 << 24)) {
														range <<=  8;
														generatedRc.RangeEnc_ShiftLow();
													} 
												}
												;
												m = (m << 1) + bit;
												bit = dist & 1;
												dist >>=  1;
												{ 
													UInt32 mask = new UInt32();
													ttt = (generatedPosAlignEncoder + m);
													newBound = (range >> 11) * ttt;
													mask = 0 - (UInt32)bit;
													range &=  mask;
													mask &=  newBound;
													range -= mask;
													(generatedRc).getLow() += mask;
													mask = (UInt32)bit - 1;
													range += newBound & mask;
													mask &=  ((1 << 11) - ((1 << 5) - 1));
													mask += ((1 << 5) - 1);
													ttt += (Int32)(mask - ttt) >> 5;
													(generatedPosAlignEncoder + m) = (CLzmaProb)ttt;
													if (range < ((UInt32)1 << 24)) {
														range <<=  8;
														generatedRc.RangeEnc_ShiftLow();
													} 
												}
												;
												m = (m << 1) + bit;
												bit = dist & 1;
												{ 
													UInt32 mask = new UInt32();
													ttt = (generatedPosAlignEncoder + m);
													newBound = (range >> 11) * ttt;
													mask = 0 - (UInt32)bit;
													range &=  mask;
													mask &=  newBound;
													range -= mask;
													(generatedRc).getLow() += mask;
													mask = (UInt32)bit - 1;
													range += newBound & mask;
													mask &=  ((1 << 11) - ((1 << 5) - 1));
													mask += ((1 << 5) - 1);
													ttt += (Int32)(mask - ttt) >> 5;
													(generatedPosAlignEncoder + m) = (CLzmaProb)ttt;
													if (range < ((UInt32)1 << 24)) {
														range <<=  8;
														generatedRc.RangeEnc_ShiftLow();
													} 
												}
												;
												generatedRc.setRange(range);
											}
									} 
								} 
						} 
				} 
				nowPos32 += (UInt32)len;
				generatedAdditionalOffset -= len;
				if (generatedAdditionalOffset == 0) {
					UInt32 processed = new UInt32();
					if (!generatedFastMode) {
						if (generatedMatchPriceCount >= 64) {
							p.FillAlignPrices();
							p.FillDistancesPrices();
							generatedLenEnc.LenPriceEnc_UpdateTables(1 << generatedPb, generatedLenProbs, generatedProbPrices);
						} 
						if (generatedRepLenEncCounter <= 0) {
							this.setRepLenEncCounter(64);
							generatedRepLenEnc.LenPriceEnc_UpdateTables(1 << generatedPb, generatedRepLenProbs, generatedProbPrices);
						} 
					} 
					if (.UNRECOGNIZEDFUNCTIONNAME(generatedMatchFinderObj) == 0) {
						break;
					} 
					processed = nowPos32 - startPos32;
					if (maxPackSize) {
						if (processed + (1 << 11) + 300 >= maxUnpackSize || ((size_t)(generatedRc).getProcessed() + ((generatedRc).getBuf() - (generatedRc).getBufBase()) + (size_t)(generatedRc).getCacheSize()) + ((1 << 11) * 8) >= maxPackSize) {
							break;
						} 
					}  else if (processed >= (1 << 17)) {
						generatedNowPos64 += nowPos32 - startPos32;
						return p.CheckErrors();
					} 
				} 
			}
		} 
		generatedNowPos64 += nowPos32 - startPos32;
		return p.Flush(nowPos32);
	}
	public static Object LzmaEnc_Alloc(Object keepWindowSize, Object alloc, Object allocBig) {
		UInt32 beforeSize = (1 << 11);
		Object generatedRc = this.getRc();
		if (!generatedRc.RangeEnc_Alloc(alloc)) {
			return 2;
		} 
		Object generatedMultiThread = this.getMultiThread();
		Object generatedFastMode = this.getFastMode();
		Object generatedMatchFinderBase = this.getMatchFinderBase();
		this.setMtMode((generatedMultiThread && !generatedFastMode && (generatedMatchFinderBase.getBtMode() != 0)));
		Object generatedLc = this.getLc();
		Object generatedLp = this.getLp();
		Object generatedLitProbs = this.getLitProbs();
		Object generatedLclp = this.getLclp();
		Object generatedSaveState = this.getSaveState();
		{ 
			int lclp = generatedLc + generatedLp;
			if (!generatedLitProbs || !generatedLitProbs || generatedLclp != lclp) {
				p.LzmaEnc_FreeLits(alloc);
				this.setLitProbs((CLzmaProb).UNRECOGNIZEDFUNCTIONNAME(alloc, ((UInt32)-1024 << lclp) * ));
				generatedSaveState.setLitProbs((CLzmaProb).UNRECOGNIZEDFUNCTIONNAME(alloc, ((UInt32)-1024 << lclp) * ));
				if (!generatedLitProbs || !generatedLitProbs) {
					p.LzmaEnc_FreeLits(alloc);
					return 2;
				} 
				this.setLclp(lclp);
			} 
		}
		Object generatedDictSize = this.getDictSize();
		generatedMatchFinderBase.setBigHash((Byte)(generatedDictSize > ((UInt32)1 << 24) ? 1 : 0));
		if (beforeSize + generatedDictSize < keepWindowSize) {
			beforeSize = keepWindowSize - generatedDictSize;
		} 
		Object generatedMtMode = this.getMtMode();
		Object generatedMatchFinderMt = this.getMatchFinderMt();
		Object generatedNumFastBytes = this.getNumFastBytes();
		Object generatedMatchFinder = this.getMatchFinder();
		if (generatedMtMode) {
			{ 
				int __result__ = (generatedMatchFinderMt.MatchFinderMt_Create(generatedDictSize, beforeSize, generatedNumFastBytes, (2 + ((1 << 3) * 2 + (1 << 8)) - 1) + 1, allocBig));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			this.setMatchFinderObj(generatedMatchFinderMt);
			generatedMatchFinderBase.setBigHash((Byte)((generatedDictSize > ((UInt32)1 << 24) && generatedMatchFinderBase.getHashMask() >= -1024) ? 1 : 0));
			ModernizedCProgram.MatchFinderMt_CreateVTable(generatedMatchFinderMt, generatedMatchFinder);
		} else {
				if (!generatedMatchFinderBase.MatchFinder_Create(generatedDictSize, beforeSize, generatedNumFastBytes, (2 + ((1 << 3) * 2 + (1 << 8)) - 1), allocBig)) {
					return 2;
				} 
				this.setMatchFinderObj(generatedMatchFinderBase);
				ModernizedCProgram.MatchFinder_CreateVTable(generatedMatchFinderBase, generatedMatchFinder);
		} 
		return 0;
	}
	public static void LzmaEnc_Init() {
		int i;
		this.setState(0);
		Object generatedReps = this.getReps();
		generatedReps[0] = generatedReps[1] = generatedReps[2] = generatedReps[3] = 1;
		Object generatedRc = this.getRc();
		generatedRc.RangeEnc_Init();
		Object generatedPosAlignEncoder = this.getPosAlignEncoder();
		for (i = 0; i < (1 << 4); i++) {
			generatedPosAlignEncoder[i] = ((1 << 11) >> 1);
		}
		Object generatedIsMatch = this.getIsMatch();
		Object generatedIsRep0Long = this.getIsRep0Long();
		Object generatedIsRep = this.getIsRep();
		Object generatedIsRepG0 = this.getIsRepG0();
		Object generatedIsRepG1 = this.getIsRepG1();
		Object generatedIsRepG2 = this.getIsRepG2();
		for (i = 0; i < 12; i++) {
			int j;
			for (j = 0; j < (1 << 4); j++) {
				generatedIsMatch[i][j] = ((1 << 11) >> 1);
				generatedIsRep0Long[i][j] = ((1 << 11) >> 1);
			}
			generatedIsRep[i] = ((1 << 11) >> 1);
			generatedIsRepG0[i] = ((1 << 11) >> 1);
			generatedIsRepG1[i] = ((1 << 11) >> 1);
			generatedIsRepG2[i] = ((1 << 11) >> 1);
		}
		Object generatedPosSlotEncoder = this.getPosSlotEncoder();
		{ 
			for (i = 0; i < 4; i++) {
				CLzmaProb probs = generatedPosSlotEncoder[i];
				int j;
				for (j = 0; j < (1 << 6); j++) {
					probs[j] = ((1 << 11) >> 1);
				}
			}
		}
		Object generatedPosEncoders = this.getPosEncoders();
		{ 
			for (i = 0; i < (1 << (14 >> 1)); i++) {
				generatedPosEncoders[i] = ((1 << 11) >> 1);
			}
		}
		Object generatedLp = this.getLp();
		Object generatedLc = this.getLc();
		Object generatedLitProbs = this.getLitProbs();
		{ 
			UInt32 num = (UInt32)-1024 << (generatedLp + generatedLc);
			UInt32 k = new UInt32();
			CLzmaProb probs = generatedLitProbs;
			for (k = 0; k < ModernizedCProgram.num; k++) {
				probs[k] = ((1 << 11) >> 1);
			}
		}
		Object generatedLenProbs = this.getLenProbs();
		generatedLenProbs.LenEnc_Init();
		Object generatedRepLenProbs = this.getRepLenProbs();
		generatedRepLenProbs.LenEnc_Init();
		this.setOptEnd(0);
		this.setOptCur(0);
		Object generatedOpt = this.getOpt();
		{ 
			for (i = 0; i < (1 << 11); i++) {
				generatedOpt[i].setPrice((1 << 30));
			}
		}
		this.setAdditionalOffset(0);
		Object generatedPb = this.getPb();
		this.setPbMask((1 << generatedPb) - 1);
		this.setLpMask(((UInt32)-1024 << generatedLp) - ((int)-1024 >> generatedLc));
	}
	public static void LzmaEnc_InitPrices() {
		Object generatedFastMode = this.getFastMode();
		if (!generatedFastMode) {
			p.FillDistancesPrices();
			p.FillAlignPrices();
		} 
		Object generatedNumFastBytes = this.getNumFastBytes();
		Object generatedRepLenEnc = this.getRepLenEnc();
		Object generatedLenEnc = this.getLenEnc();
		generatedLenEnc.setTableSize(generatedRepLenEnc.setTableSize(generatedNumFastBytes + 1 - 2));
		this.setRepLenEncCounter(64);
		Object generatedPb = this.getPb();
		Object generatedLenProbs = this.getLenProbs();
		Object generatedProbPrices = this.getProbPrices();
		generatedLenEnc.LenPriceEnc_UpdateTables(1 << generatedPb, generatedLenProbs, generatedProbPrices);
		Object generatedRepLenProbs = this.getRepLenProbs();
		generatedRepLenEnc.LenPriceEnc_UpdateTables(1 << generatedPb, generatedRepLenProbs, generatedProbPrices);
	}
	public static Object LzmaEnc_AllocAndInit(Object keepWindowSize, Object alloc, Object allocBig) {
		int i;
		Object generatedDictSize = this.getDictSize();
		for (i = 14 / 2; i < 32; i++) {
			if (generatedDictSize <= ((UInt32)1 << i)) {
				break;
			} 
		}
		this.setDistTableSize(i * 2);
		this.setFinished(0);
		this.setResult(0);
		{ 
			int __result__ = (p.LzmaEnc_Alloc(keepWindowSize, alloc, allocBig));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		p.LzmaEnc_Init();
		p.LzmaEnc_InitPrices();
		this.setNowPos64(0);
		return 0;
	}
	public static Object LzmaEnc_Prepare(Object pp, ISeqOutStream outStream, ISeqInStream inStream, Object alloc, Object allocBig) {
		CLzmaEnc p = (CLzmaEnc)pp;
		Object generatedMatchFinderBase = p.getMatchFinderBase();
		generatedMatchFinderBase.setStream(inStream);
		p.setNeedInit(1);
		Object generatedRc = p.getRc();
		generatedRc.setOutStream(outStream);
		return p.LzmaEnc_AllocAndInit(0, alloc, allocBig);
	}
	public static void LzmaEnc_SetInputBuf(Object src, Object srcLen) {
		Object generatedMatchFinderBase = this.getMatchFinderBase();
		generatedMatchFinderBase.setDirectInput(1);
		generatedMatchFinderBase.setBufferBase((Byte)src);
		generatedMatchFinderBase.setDirectInputRem(srcLen);
	}
	public static Object LzmaEnc_MemPrepare(Object pp, Object src, Object srcLen, Object keepWindowSize, Object alloc, Object allocBig) {
		CLzmaEnc p = (CLzmaEnc)pp;
		p.LzmaEnc_SetInputBuf(src, srcLen);
		p.setNeedInit(1);
		ModernizedCProgram.LzmaEnc_SetDataSize(pp, srcLen);
		return p.LzmaEnc_AllocAndInit(keepWindowSize, alloc, allocBig);
	}
	public static void LzmaEnc_Finish(Object pp) {
		CLzmaEnc p = (CLzmaEnc)pp;
		Object generatedMtMode = p.getMtMode();
		Object generatedMatchFinderMt = p.getMatchFinderMt();
		if (generatedMtMode) {
			generatedMatchFinderMt.MatchFinderMt_ReleaseStream();
		} 
	}
	public static Object SeqOutStreamBuf_Write(Object pp, Object data, Object size) {
		CLzmaEnc_SeqOutStreamBuf p = ((CLzmaEnc_SeqOutStreamBuf)((byte)(true ? (pp) : ((CLzmaEnc_SeqOutStreamBuf)0).getVt()) - ((size_t)((CLzmaEnc_SeqOutStreamBuf)0).getVt())));
		Object generatedRem = p.getRem();
		if (generatedRem < size) {
			size = generatedRem;
			p.setOverflow(1);
		} 
		Object generatedData = p.getData();
		.memcpy(generatedData, data, size);
		generatedRem -= size;
		generatedData += size;
		return size;
	}
	public static Object LzmaEnc_GetNumAvailableBytes(Object pp) {
		CLzmaEnc p = (CLzmaEnc)pp;
		return .UNRECOGNIZEDFUNCTIONNAME(p.getMatchFinderObj());
	}
	public static Object LzmaEnc_GetCurBuf(Object pp) {
		CLzmaEnc p = (CLzmaEnc)pp;
		return .UNRECOGNIZEDFUNCTIONNAME(p.getMatchFinderObj()) - p.getAdditionalOffset();
	}
	public static Object LzmaEnc_CodeOneMemBlock(Object pp, Object reInit, Object dest, Object destLen, Object desiredPackSize, Object unpackSize) {
		CLzmaEnc p = (CLzmaEnc)pp;
		UInt64 nowPos64 = new UInt64();
		SRes res = new SRes();
		CLzmaEnc_SeqOutStreamBuf outStream = new CLzmaEnc_SeqOutStreamBuf();
		Object generatedVt = outStream.getVt();
		generatedVt.setWrite(SeqOutStreamBuf_Write);
		outStream.setData(dest);
		outStream.setRem(destLen);
		outStream.setOverflow(0);
		p.setWriteEndMark(0);
		p.setFinished(0);
		p.setResult(0);
		if (reInit) {
			p.LzmaEnc_Init();
		} 
		p.LzmaEnc_InitPrices();
		Object generatedNowPos64 = p.getNowPos64();
		nowPos64 = generatedNowPos64;
		Object generatedRc = p.getRc();
		generatedRc.RangeEnc_Init();
		generatedRc.setOutStream(generatedVt);
		if (desiredPackSize == 0) {
			return 7;
		} 
		res = p.LzmaEnc_CodeOneBlock(desiredPackSize, unpackSize);
		unpackSize = (UInt32)(generatedNowPos64 - nowPos64);
		Object generatedRem = outStream.getRem();
		destLen -= generatedRem;
		Object generatedOverflow = outStream.getOverflow();
		if (generatedOverflow) {
			return 7;
		} 
		return res;
	}
	public static Object LzmaEnc_Encode2( p, ICompressProgress progress) {
		SRes res = 0;
		Byte[] allocaDummy = new Byte();
		allocaDummy[0] = 0;
		allocaDummy[1] = allocaDummy[0];
		Object generatedFinished = p.getFinished();
		Object generatedNowPos64 = p.getNowPos64();
		Object generatedRc = p.getRc();
		for (; ; ) {
			res = p.LzmaEnc_CodeOneBlock(0, 0);
			if (res != 0 || generatedFinished) {
				break;
			} 
			if (progress) {
				res = .UNRECOGNIZEDFUNCTIONNAME(progress, generatedNowPos64, ((generatedRc).getProcessed() + ((generatedRc).getBuf() - (generatedRc).getBufBase()) + (generatedRc).getCacheSize()));
				if (res != 0) {
					res = 10;
					break;
				} 
			} 
		}
		ModernizedCProgram.LzmaEnc_Finish(p/*
		  if (res == SZ_OK && !Inline_MatchFinder_IsFinishedOK(&p->matchFinderBase))
		    res = SZ_ERROR_FAIL;
		  }
		  */);
		return res;
	}
	public static Object LzmaEnc_Encode(Object pp, ISeqOutStream outStream, ISeqInStream inStream, ICompressProgress progress, Object alloc, Object allocBig) {
		{ 
			int __result__ = (ModernizedCProgram.LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		return ModernizedCProgram.LzmaEnc_Encode2((CLzmaEnc)pp, progress);
	}
	public static Object LzmaEnc_WriteProperties(Object pp, Object props, Object size) {
		CLzmaEnc p = (CLzmaEnc)pp;
		int i;
		Object generatedDictSize = p.getDictSize();
		UInt32 dictSize = generatedDictSize;
		if (size < 5) {
			return 5;
		} 
		size = 5;
		Object generatedPb = p.getPb();
		Object generatedLp = p.getLp();
		Object generatedLc = p.getLc();
		props[0] = (Byte)((generatedPb * 5 + generatedLp) * 9 + generatedLc);
		if (dictSize >= ((UInt32)1 << 22)) {
			UInt32 kDictMask = ((UInt32)1 << 20) - 1;
			if (dictSize < (UInt32)-1024 - kDictMask) {
				dictSize = (dictSize + kDictMask) & ~kDictMask;
			} 
		} else {
				for (i = 11; i <= 30; i++) {
					if (dictSize <= ((UInt32)2 << i)) {
						dictSize = (2 << i);
						break;
					} 
					if (dictSize <= ((UInt32)3 << i)) {
						dictSize = (3 << i);
						break;
					} 
				}
		} 
		for (i = 0; i < 4; i++) {
			props[1 + i] = (Byte)(dictSize >> (8 * i));
		}
		return 0;
	}
	public static int LzmaEnc_IsWriteEndMark(Object pp) {
		return ((CLzmaEnc)pp).getWriteEndMark();
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int sort_by_mtime(Object p1, Object p2) {
		byte f1 = (byte)p1;
		byte f2 = (byte)p2;
		stat s1 = new stat();
		stat s2 = new stat();
		int rc1 = .stat(f1, s1);
		int rc2 = .stat(f2, s2);
		if (rc1 < rc2) {
			return 1;
		} 
		if (rc1 > rc2) {
			return -1;
		} 
		Object generatedSt_mtime = s1.getSt_mtime();
		if (generatedSt_mtime < generatedSt_mtime) {
			return 1;
		} 
		if (generatedSt_mtime > generatedSt_mtime) {
			return -1;
		} 
		return 0;
	}
	public static boolean module_warmup_disable(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean warmup_disable = true;
		return warmup_disable;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static Object hc_lzma_alloc(Object p, Object size) {
		return ModernizedCProgram.hcmalloc(size);
	}
	public static void hc_lzma_free(Object p, Object address) {
		ModernizedCProgram.hcfree(address);
	}
	public static int hc_lzma1_decompress(Object in, Object in_len, Byte out, Object out_len, Object props) {
		ISzAlloc hc_lzma_mem_alloc = new ISzAlloc(hc_lzma_alloc, hc_lzma_free);
		ELzmaStatus status = new ELzmaStatus();
		// parameters to LzmaDecode (): unsigned char *dest, size_t *destLen, const unsigned char *src,
		// size_t *srcLen, const unsigned char *props, size_t propsSize, ELzmaFinishMode finishMode, ELzmaStatus status, ISzAlloc *allocreturn ModernizedCProgram.LzmaDecode(out, out_len, in, in_len, (Byte)props, 5, .LZMA_FINISH_ANY, status, hc_lzma_mem_alloc);
	}
	public static int hc_lzma2_decompress(Object in, Object in_len, Byte out, Object out_len, Object props) {
		ISzAlloc hc_lzma_mem_alloc = new ISzAlloc(hc_lzma_alloc, hc_lzma_free);
		ELzmaStatus status = new ELzmaStatus();
		// parameters to Lzma2Decode (): unsigned char *dest, size_t *destLen, const unsigned char *src,
		// size_t *srcLen, const unsigned char props, ELzmaFinishMode finishMode, ELzmaStatus status, ISzAlloc *allocreturn ModernizedCProgram.Lzma2Decode(out, out_len, in, in_len, (Byte)props[0], .LZMA_FINISH_ANY, status, hc_lzma_mem_alloc);
	}
	public static void sha256aix_decode(Object digest, Object buf) {
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[2] = (l >> 0) & -1024;
		digest[1] = (l >> 8) & -1024;
		digest[0] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[5] = (l >> 0) & -1024;
		digest[4] = (l >> 8) & -1024;
		digest[3] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[8] = (l >> 0) & -1024;
		digest[7] = (l >> 8) & -1024;
		digest[6] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[11] = (l >> 0) & -1024;
		digest[10] = (l >> 8) & -1024;
		digest[9] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[14] = (l >> 0) & -1024;
		digest[13] = (l >> 8) & -1024;
		digest[12] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[22]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[23]) << 18;
		digest[17] = (l >> 0) & -1024;
		digest[16] = (l >> 8) & -1024;
		digest[15] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[24]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[25]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[26]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[27]) << 18;
		digest[20] = (l >> 0) & -1024;
		digest[19] = (l >> 8) & -1024;
		digest[18] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[28]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[29]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[30]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[31]) << 18;
		digest[23] = (l >> 0) & -1024;
		digest[22] = (l >> 8) & -1024;
		digest[21] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[32]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[33]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[34]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[35]) << 18;
		digest[26] = (l >> 0) & -1024;
		digest[25] = (l >> 8) & -1024;
		digest[24] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[36]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[37]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[38]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[39]) << 18;
		digest[29] = (l >> 0) & -1024;
		digest[28] = (l >> 8) & -1024;
		digest[27] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[40]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[41]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[42]) << 12;
		//digest[32] = (l >>  0) & 0xff;//digest[32] = (l >>  0) & 0xff;digest[31] = (l >> 8) & -1024;
		digest[30] = (l >> 16) & -1024;
	}
	public static void sha256aix_encode(Object digest, Object buf) {
		int l;
		l = (digest[2] << 0) | (digest[1] << 8) | (digest[0] << 16);
		buf[0] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[1] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[2] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[3] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[5] << 0) | (digest[4] << 8) | (digest[3] << 16);
		buf[4] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[5] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[6] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[7] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[8] << 0) | (digest[7] << 8) | (digest[6] << 16);
		buf[8] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[9] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[10] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[11] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[11] << 0) | (digest[10] << 8) | (digest[9] << 16);
		buf[12] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[13] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[14] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[15] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[14] << 0) | (digest[13] << 8) | (digest[12] << 16);
		buf[16] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[17] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[18] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[19] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[17] << 0) | (digest[16] << 8) | (digest[15] << 16);
		buf[20] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[21] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[22] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[23] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[20] << 0) | (digest[19] << 8) | (digest[18] << 16);
		buf[24] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[25] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[26] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[27] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[23] << 0) | (digest[22] << 8) | (digest[21] << 16);
		buf[28] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[29] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[30] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[31] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[26] << 0) | (digest[25] << 8) | (digest[24] << 16);
		buf[32] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[33] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[34] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[35] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[29] << 0) | (digest[28] << 8) | (digest[27] << 16);
		buf[36] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[37] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[38] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[39] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = 0 | (digest[31] << 8) | (digest[30] << 16);
		buf[40] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[41] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[42] = ModernizedCProgram.int_to_itoa64(l & -1024);
	}
	/* Bcj2.c -- BCJ2 Decoder (Converter for x86 code)
	2018-04-28 : Igor Pavlov : Public domain */
	public static void Bcj2Dec_Init() {
		int i;
		this.setState(.BCJ2_DEC_STATE_OK);
		this.setIp(0);
		Object generatedTemp = this.getTemp();
		generatedTemp[3] = 0;
		this.setRange(0);
		this.setCode(0);
		Object generatedProbs = this.getProbs();
		for (i = 0; i <  / ; i++) {
			generatedProbs[i] = (1 << 11) >> 1;
		}
	}
	public static Object Bcj2Dec_Decode() {
		Object generatedRange = this.getRange();
		Object generatedCode = this.getCode();
		Object generatedBufs = this.getBufs();
		Object generatedLims = this.getLims();
		Object generatedState = this.getState();
		Object generatedDest = this.getDest();
		Object generatedDestLim = this.getDestLim();
		Object generatedTemp = this.getTemp();
		if (generatedRange <= 5) {
			this.setState(.BCJ2_DEC_STATE_OK);
			for (; generatedRange != 5; generatedRange++) {
				if (generatedRange == 1 && generatedCode != 0) {
					return 1;
				} 
				if (generatedBufs[.BCJ2_STREAM_RC] == generatedLims[.BCJ2_STREAM_RC]) {
					this.setState(.BCJ2_STREAM_RC);
					return 0;
				} 
				this.setCode((generatedCode << 8) | (generatedBufs[.BCJ2_STREAM_RC])++);
			}
			if (generatedCode == -1024) {
				return 1;
			} 
			this.setRange(-1024);
		}  else if (generatedState >= .BCJ2_DEC_STATE_ORIG_0) {
			while (generatedState <= .BCJ2_DEC_STATE_ORIG_3) {
				Byte dest = generatedDest;
				if (dest == generatedDestLim) {
					return 0;
				} 
				dest = generatedTemp[(size_t)generatedState - .BCJ2_DEC_STATE_ORIG_0];
				generatedState++;
				this.setDest(dest + 1/*
				  if (BCJ2_IS_32BIT_STREAM(p->state))
				  {
				    const Byte *cur = p->bufs[p->state];
				    if (cur == p->lims[p->state])
				      return SZ_OK;
				    p->bufs[p->state] = cur + 4;
				    
				    {
				      UInt32 val;
				      Byte *dest;
				      SizeT rem;
				      
				      p->ip += 4;
				      val = GetBe32(cur) - p->ip;
				      dest = p->dest;
				      rem = p->destLim - dest;
				      if (rem < 4)
				      {
				        SizeT i;
				        SetUi32(p->temp, val);
				        for (i = 0; i < rem; i++)
				          dest[i] = p->temp[i];
				        p->dest = dest + rem;
				        p->state = BCJ2_DEC_STATE_ORIG_0 + (unsigned)rem;
				        return SZ_OK;
				      }
				      SetUi32(dest, val);
				      p->temp[3] = (Byte)(val >> 24);
				      p->dest = dest + 4;
				      p->state = BCJ2_DEC_STATE_OK;
				    }
				  }
				  */);
			}
		} 
		Object generatedIp = this.getIp();
		Object generatedProbs = this.getProbs();
		for (; ; ) {
			if (((generatedState) == .BCJ2_STREAM_CALL || (generatedState) == .BCJ2_STREAM_JUMP)) {
				this.setState(.BCJ2_DEC_STATE_OK);
			} else {
					if (generatedRange < ((UInt32)1 << 24)) {
						if (generatedBufs[.BCJ2_STREAM_RC] == generatedLims[.BCJ2_STREAM_RC]) {
							this.setState(.BCJ2_STREAM_RC);
							return 0;
						} 
						generatedRange <<=  8;
						this.setCode((generatedCode << 8) | (generatedBufs[.BCJ2_STREAM_RC])++);
					} 
					{ 
						Byte src = generatedBufs[.BCJ2_STREAM_MAIN];
						Byte srcLim = new Byte();
						Byte dest = new Byte();
						SizeT num = generatedLims[.BCJ2_STREAM_MAIN] - src;
						if (ModernizedCProgram.num == 0) {
							this.setState(.BCJ2_STREAM_MAIN);
							return 0;
						} 
						dest = generatedDest;
						if (ModernizedCProgram.num > (SizeT)(generatedDestLim - dest)) {
							ModernizedCProgram.num = generatedDestLim - dest;
							if (ModernizedCProgram.num == 0) {
								this.setState(.BCJ2_DEC_STATE_ORIG);
								return 0;
							} 
						} 
						srcLim = src + ModernizedCProgram.num;
						if (generatedTemp[3] == -1024 && (src[0] & -1024) == -1024) {
							dest = src[0];
						} else {
								for (; ; ) {
									Byte b = src;
									dest = b;
									if (b != -1024) {
										if ((b & -1024) == -1024) {
											break;
										} 
										dest++;
										if (++src != srcLim) {
											continue;
										} 
										break;
									} 
									dest++;
									if (++src == srcLim) {
										break;
									} 
									if ((src & -1024) != -1024) {
										continue;
									} 
									dest = src;
									break;
								}
						} 
						ModernizedCProgram.num = src - generatedBufs[.BCJ2_STREAM_MAIN];
						if (src == srcLim) {
							generatedTemp[3] = src[-1];
							generatedBufs[.BCJ2_STREAM_MAIN] = src;
							generatedIp += (UInt32)ModernizedCProgram.num;
							generatedDest += ModernizedCProgram.num;
							this.setState(generatedBufs[.BCJ2_STREAM_MAIN] == generatedLims[.BCJ2_STREAM_MAIN] ? (int).BCJ2_STREAM_MAIN : (int).BCJ2_DEC_STATE_ORIG);
							return 0;
						} 
						{ 
							UInt32 bound = new UInt32();
							UInt32 ttt = new UInt32();
							UInt16 prob = new UInt16();
							Byte b = src[0];
							Byte prev = (Byte)(ModernizedCProgram.num == 0 ? generatedTemp[3] : src[-1]);
							generatedTemp[3] = b;
							generatedBufs[.BCJ2_STREAM_MAIN] = src + 1;
							ModernizedCProgram.num++;
							generatedIp += (UInt32)ModernizedCProgram.num;
							generatedDest += ModernizedCProgram.num;
							prob = generatedProbs + (int)(b == -1024 ? 2 + (int)prev : (b == -1024 ? 1 : 0));
							ttt = prob;
							bound = (generatedRange >> 11) * ttt;
							if (generatedCode < bound) {
								this.setRange(bound);
								prob = (UInt16)(ttt + (((1 << 11) - ttt) >> 5));
								continue;
							} 
							generatedRange -= bound;
							generatedCode -= bound;
							prob = (UInt16)(ttt - (ttt >> 5));
						}
					}
			} 
			{ 
				UInt32 val = new UInt32();
				int cj = (generatedTemp[3] == -1024) ? .BCJ2_STREAM_CALL : .BCJ2_STREAM_JUMP;
				Byte cur = generatedBufs[cj];
				Byte dest = new Byte();
				SizeT rem = new SizeT();
				if (cur == generatedLims[cj]) {
					this.setState(cj);
					break;
				} 
				val = .__builtin_bswap32((UInt32)(Byte)(cur));
				generatedBufs[cj] = cur + 4;
				generatedIp += 4;
				val -= generatedIp;
				dest = generatedDest;
				rem = generatedDestLim - dest;
				if (rem < 4) {
					generatedTemp[0] = (Byte)val;
					if (rem > 0) {
						dest[0] = (Byte)val;
					} 
					val >>=  8;
					generatedTemp[1] = (Byte)val;
					if (rem > 1) {
						dest[1] = (Byte)val;
					} 
					val >>=  8;
					generatedTemp[2] = (Byte)val;
					if (rem > 2) {
						dest[2] = (Byte)val;
					} 
					val >>=  8;
					generatedTemp[3] = (Byte)val;
					this.setDest(dest + rem);
					this.setState(.BCJ2_DEC_STATE_ORIG_0 + (int)rem);
					break;
				} 
				{ 
					(UInt32)(dest) = (val);
				}
				;
				generatedTemp[3] = (Byte)(val >> 24);
				this.setDest(dest + 4);
			}
		}
		if (generatedRange < ((UInt32)1 << 24) && generatedBufs[.BCJ2_STREAM_RC] != generatedLims[.BCJ2_STREAM_RC]) {
			generatedRange <<=  8;
			this.setCode((generatedCode << 8) | (generatedBufs[.BCJ2_STREAM_RC])++);
		} 
		return 0;
	}
	public static boolean module_jit_cache_disable(Object hashconfig, Object user_options, Object user_options_extra, Object hashes, Object device_param) {
		return 1;
		return 1;
		if ((user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) && (hashes.getSalts_cnt() == 1) && (user_options.getSlow_candidates() == 0)) {
			return 1;
		} 
		return 0;
		return 1;
		return 1;
	}
	/* 7zCrcOpt.c -- CRC32 calculation
	2017-04-03 : Igor Pavlov : Public domain */
	public static Object CrcUpdateT4(Object v, Object data, Object size, Object table) {
		Byte p = (Byte)data;
		for (; size > 0 && ((int)(ptrdiff_t)p & 3) != 0; ) {
			v = (table[((v) ^ (p)) & -1024] ^ ((v) >> 8));
		}
		for (; size >= 4; ) {
			v ^=  (UInt32)p;
			v = (table + -1024)[((v) & -1024)] ^ (table + -1024)[((v >> 8) & -1024)] ^ (table + -1024)[((v >> 16) & -1024)] ^ (table + -1024)[((v >> 24))];
		}
		for (; size > 0; ) {
			v = (table[((v) ^ (p)) & -1024] ^ ((v) >> 8));
		}
		return v;
	}
	public static Object CrcUpdateT8(Object v, Object data, Object size, Object table) {
		Byte p = (Byte)data;
		for (; size > 0 && ((int)(ptrdiff_t)p & 7) != 0; ) {
			v = (table[((v) ^ (p)) & -1024] ^ ((v) >> 8));
		}
		for (; size >= 8; ) {
			UInt32 d = new UInt32();
			v ^=  (UInt32)p;
			v = (table + -1024)[((v) & -1024)] ^ (table + -1024)[((v >> 8) & -1024)] ^ (table + -1024)[((v >> 16) & -1024)] ^ (table + -1024)[((v >> 24))];
			d = ((UInt32)p + 1);
			v ^=  (table + -1024)[((d) & -1024)] ^ (table + -1024)[((d >> 8) & -1024)] ^ (table + -1024)[((d >> 16) & -1024)] ^ (table + -1024)[((d >> 24))];
		}
		for (; size > 0; ) {
			v = (table[((v) ^ (p)) & -1024] ^ ((v) >> 8));
		}
		return v;
	}
	/* Bcj2Enc.c -- BCJ2 Encoder (Converter for x86 code)
	2019-02-02 : Igor Pavlov : Public domain */
	/* #define SHOW_STAT */
	public static void Bcj2Enc_Init() {
		int i;
		this.setState(.BCJ2_ENC_STATE_OK);
		this.setFinishMode(.BCJ2_ENC_FINISH_MODE_CONTINUE);
		this.setPrevByte(0);
		this.setCache(0);
		this.setRange(-1024);
		this.setLow(0);
		this.setCacheSize(1);
		this.setIp(0);
		this.setFileIp(0);
		this.setFileSize(0);
		this.setRelatLimit(((UInt32)1 << 26));
		this.setTempPos(0);
		this.setFlushPos(0);
		Object generatedProbs = this.getProbs();
		for (i = 0; i <  / ; i++) {
			generatedProbs[i] = (1 << 11) >> 1;
		}
	}
	public static void Bcj2Enc_Encode_2() {
		Object generatedState = this.getState();
		Object generatedBufs = this.getBufs();
		Object generatedLims = this.getLims();
		Object generatedTempTarget = this.getTempTarget();
		if (((generatedState) == .BCJ2_STREAM_CALL || (generatedState) == .BCJ2_STREAM_JUMP)) {
			Byte cur = generatedBufs[generatedState];
			if (cur == generatedLims[generatedState]) {
				return ;
			} 
			((UInt32)(Object)(cur)) = .__builtin_bswap32(generatedTempTarget);
			generatedBufs[generatedState] = cur + 4;
		} 
		this.setState(.BCJ2_ENC_STATE_ORIG);
		Object generatedRange = this.getRange();
		Object generatedSrc = this.getSrc();
		Object generatedSrcLim = this.getSrcLim();
		Object generatedFinishMode = this.getFinishMode();
		Object generatedPrevByte = this.getPrevByte();
		Object generatedIp = this.getIp();
		Object generatedFileSize = this.getFileSize();
		Object generatedFileIp = this.getFileIp();
		Object generatedRelatLimit = this.getRelatLimit();
		Object generatedProbs = this.getProbs();
		Object generatedLow = this.getLow();
		for (; ; ) {
			if (generatedRange < ((UInt32)1 << 24)) {
				if (p.RangeEnc_ShiftLow()) {
					return ;
				} 
				generatedRange <<=  8;
			} 
			{ 
				{ 
					Byte src = generatedSrc;
					Byte srcLim = new Byte();
					Byte dest = new Byte();
					SizeT num = generatedSrcLim - src;
					if (generatedFinishMode == .BCJ2_ENC_FINISH_MODE_CONTINUE) {
						if (ModernizedCProgram.num <= 4) {
							return ;
						} 
						ModernizedCProgram.num -= 4;
					}  else if (ModernizedCProgram.num == 0) {
						break;
					} 
					dest = generatedBufs[.BCJ2_STREAM_MAIN];
					if (ModernizedCProgram.num > (SizeT)(generatedLims[.BCJ2_STREAM_MAIN] - dest)) {
						ModernizedCProgram.num = generatedLims[.BCJ2_STREAM_MAIN] - dest;
						if (ModernizedCProgram.num == 0) {
							this.setState(.BCJ2_STREAM_MAIN);
							return ;
						} 
					} 
					srcLim = src + ModernizedCProgram.num;
					if (generatedPrevByte == -1024 && (src[0] & -1024) == -1024) {
						dest = src[0];
					} else {
							for (; ; ) {
								Byte b = src;
								dest = b;
								if (b != -1024) {
									if ((b & -1024) == -1024) {
										break;
									} 
									dest++;
									if (++src != srcLim) {
										continue;
									} 
									break;
								} 
								dest++;
								if (++src == srcLim) {
									break;
								} 
								if ((src & -1024) != -1024) {
									continue;
								} 
								dest = src;
								break;
							}
					} 
					ModernizedCProgram.num = src - generatedSrc;
					if (src == srcLim) {
						this.setPrevByte(src[-1]);
						generatedBufs[.BCJ2_STREAM_MAIN] = dest;
						this.setSrc(src);
						generatedIp += (UInt32)ModernizedCProgram.num;
						continue;
					} 
					{ 
						Byte context = (Byte)(ModernizedCProgram.num == 0 ? generatedPrevByte : src[-1]);
						BoolInt needConvert = new BoolInt();
						generatedBufs[.BCJ2_STREAM_MAIN] = dest + 1;
						generatedIp += (UInt32)ModernizedCProgram.num + 1;
						src++;
						needConvert = 0;
						if ((SizeT)(generatedSrcLim - src) >= 4) {
							UInt32 relatVal = ((UInt32)(Object)(src));
							if ((generatedFileSize == 0 || (UInt32)(generatedIp + 4 + relatVal - generatedFileIp) < generatedFileSize) && ((relatVal + generatedRelatLimit) >> 1) < generatedRelatLimit) {
								needConvert = 1;
							} 
						} 
						{ 
							UInt32 bound = new UInt32();
							int ttt;
							Byte b = src[-1];
							UInt16 prob = generatedProbs + (int)(b == -1024 ? 2 + (int)context : (b == -1024 ? 1 : 0));
							ttt = prob;
							bound = (generatedRange >> 11) * ttt;
							if (!needConvert) {
								this.setRange(bound);
								prob = (UInt16)(ttt + (((1 << 11) - ttt) >> 5));
								this.setSrc(src);
								this.setPrevByte(b);
								continue;
							} 
							generatedLow += bound;
							generatedRange -= bound;
							prob = (UInt16)(ttt - (ttt >> 5));
							{ 
								UInt32 relatVal = ((UInt32)(Object)(src));
								UInt32 absVal = new UInt32();
								generatedIp += 4;
								absVal = generatedIp + relatVal;
								this.setPrevByte(src[3]);
								src += 4;
								this.setSrc(src);
								{ 
									int cj = (b == -1024) ? .BCJ2_STREAM_CALL : .BCJ2_STREAM_JUMP;
									Byte cur = generatedBufs[cj];
									if (cur == generatedLims[cj]) {
										this.setState(cj);
										this.setTempTarget(absVal);
										return ;
									} 
									((UInt32)(Object)(cur)) = .__builtin_bswap32(absVal);
									generatedBufs[cj] = cur + 4;
								}
							}
						}
					}
				}
			}
		}
		if (generatedFinishMode != .BCJ2_ENC_FINISH_MODE_END_STREAM) {
			return ;
		} 
		Object generatedFlushPos = this.getFlushPos();
		for (; generatedFlushPos < 5; generatedFlushPos++) {
			if (p.RangeEnc_ShiftLow()) {
				return ;
			} 
		}
		this.setState(.BCJ2_ENC_STATE_OK);
	}
	public static void Bcj2Enc_Encode() {
		;
		;
		Object generatedTempPos = this.getTempPos();
		Object generatedSrc = this.getSrc();
		Object generatedSrcLim = this.getSrcLim();
		Object generatedFinishMode = this.getFinishMode();
		Object generatedTemp = this.getTemp();
		Object generatedState = this.getState();
		if (generatedTempPos != 0) {
			int extra = 0;
			for (; ; ) {
				Byte src = generatedSrc;
				Byte srcLim = generatedSrcLim;
				EBcj2Enc_FinishMode finishMode = generatedFinishMode;
				this.setSrc(generatedTemp);
				this.setSrcLim(generatedTemp + generatedTempPos);
				if (src != srcLim) {
					this.setFinishMode(.BCJ2_ENC_FINISH_MODE_CONTINUE);
				} 
				;
				p.Bcj2Enc_Encode_2();
				{ 
					int num = (int)(generatedSrc - generatedTemp);
					int tempPos = generatedTempPos - ModernizedCProgram.num;
					int i;
					this.setTempPos(tempPos);
					for (i = 0; i < tempPos; i++) {
						generatedTemp[i] = generatedTemp[(size_t)i + ModernizedCProgram.num];
					}
					this.setSrc(src);
					this.setSrcLim(srcLim);
					this.setFinishMode(finishMode);
					if (generatedState != .BCJ2_ENC_STATE_ORIG || src == srcLim) {
						return ;
					} 
					if (extra >= tempPos) {
						this.setSrc(src - tempPos);
						this.setTempPos(0);
						break;
					} 
					generatedTemp[tempPos] = src[0];
					this.setTempPos(tempPos + 1);
					this.setSrc(src + 1);
					extra++;
				}
			}
		} 
		;
		p.Bcj2Enc_Encode_2();
		if (generatedState == .BCJ2_ENC_STATE_ORIG) {
			Byte src = generatedSrc;
			int rem = (int)(generatedSrcLim - src);
			int i;
			for (i = 0; i < rem; i++) {
				generatedTemp[i] = src[i];
			}
			this.setTempPos(rem);
			this.setSrc(src + rem);
		} 
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static Object atomic_dec(Object p) {
		return p[0]--;
	}
	public static Object atomic_inc(Object p) {
		return p[0]++;
	}
	public static Object get_global_id(Object dimindx) {
		return 0;
	}
	public static Object get_local_id(Object dimindx) {
		return 0;
	}
	public static Object get_local_size(Object dimindx) {
		return 0;
	}
	/* memory allocation routine to pass to zlib */
	public static Object mem_alloc(Object mem, int count, int size) {
		Object ptr;
		mem_item item = new mem_item();
		mem_zone zone = mem;
		size_t len = count * (size_t)size;
		Object generatedLimit = zone.getLimit();
		Object generatedTotal = zone.getTotal();
		if (zone == ((Object)0) || (generatedLimit && generatedTotal + len > generatedLimit)) {
			return ((Object)0);
		} 
		ptr = .malloc(/* perform allocation using the standard library, fill memory with a
		       non-zero value to make sure that the code isn't depending on zeros */len);
		if (ptr == ((Object)0)) {
			return ((Object)0);
		} 
		.memset(ptr, -1024, len);
		item = .malloc(/* create a new item for the list */);
		if (item == ((Object)0)) {
			.free(ptr);
			return ((Object)0);
		} 
		item.setPtr(ptr);
		item.setSize(len);
		mem_item generatedFirst = zone.getFirst();
		item.setNext(generatedFirst);
		zone.setFirst(item);
		Object generatedSize = item.getSize();
		generatedTotal += generatedSize;
		Object generatedHighwater = zone.getHighwater();
		if (generatedTotal > generatedHighwater) {
			zone.setHighwater(generatedTotal);
		} 
		return /* return the allocated memory */ptr;
	}
	/* memory free routine to pass to zlib */
	public static void mem_free(Object mem, Object ptr) {
		mem_item item = new mem_item();
		mem_item next = new mem_item();
		mem_zone zone = mem;
		if (zone == ((Object)/* if no zone, just do a free */0)) {
			.free(ptr);
			return ;
		} 
		mem_item generatedFirst = zone.getFirst();
		next = generatedFirst;
		Object generatedPtr = next.getPtr();
		mem_item generatedNext = next.getNext();
		int generatedNotlifo = zone.getNotlifo();
		if (next) {
			if (generatedPtr == ptr) {
				zone.setFirst(generatedNext);
			} else {
					do {
						item = next;
						next = generatedNext;
					} while (next != ((Object)0) && generatedPtr != ptr);
					if (/* if found, remove from linked list */next) {
						item.setNext(generatedNext);
						generatedNotlifo++;
					} 
			} 
		} 
		Object generatedTotal = zone.getTotal();
		Object generatedSize = next.getSize();
		int generatedRogue = zone.getRogue();
		if (/* if found, update the statistics and free the item */next) {
			generatedTotal -= generatedSize;
			.free(next);
		} else {
				generatedRogue++;
		} 
		.free(/* in any case, do the requested free with the standard library function */ptr);
	}
	public static Byte h2b(Object hex, int len) {
		byte in;
		byte re;
		int next;
		int val;
		in = .malloc((.strlen(hex) + 1) >> 1);
		if (in == ((Object)0)) {
			return ((Object)0);
		} 
		next = 0;
		val = 1;
		do {
			if (hex >= (byte)'0' && hex <= (byte)'9') {
				val = (val << 4) + hex - (byte)'0';
			}  else if (hex >= (byte)'A' && hex <= (byte)'F') {
				val = (val << 4) + hex - (byte)'A' + 10;
			}  else if (hex >= (byte)'a' && hex <= (byte)'f') {
				val = (val << 4) + hex - (byte)'a' + 10;
			}  else if (val != 1 && val < /* one digit followed by delimiter */32) {
				val += /* make it look like two digits */240;
			} 
			if (val > /* have two digits */255) {
				in[next++] = val & /* save the decoded byte */-1024;
				val = /* start over */1;
			} 
		} while (/* go through the loop with the terminating null */hex++);
		if (len != ((Object)0)) {
			len = next;
		} 
		re = .realloc(in, next);
		return re == ((Object)0) ? in : re/* generic inflate() run, where hex is the hexadecimal input data, what is the
		   text to include in an error message, step is how much input data to feed
		   inflate() on each call, or zero to feed it all, win is the window bits
		   parameter to inflateInit2(), len is the size of the output buffer, and err
		   is the error code expected from the first inflate() call (the second
		   inflate() call is expected to return Z_STREAM_END).  If win is 47, then
		   header information is collected with inflateGetHeader().  If a zlib stream
		   is looking for a dictionary, then an empty dictionary is provided.
		   inflate() is run until all of the input data is consumed. */;
	}
	/* cover all of the lines in inflate.c up to inflate() */
	public static void cover_support() {
		int ret;
		z_stream strm = new z_stream();
		strm.mem_setup();
		strm.setAvail_in(0);
		strm.setNext_in(0);
		ret = ModernizedCProgram.inflateInit_((strm), "1.2.11", (int));
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 358));
		strm.mem_used("inflate init");
		ret = ModernizedCProgram.inflatePrime(strm, 5, 31);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 360));
		ret = ModernizedCProgram.inflatePrime(strm, -1, 0);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 361));
		ret = ModernizedCProgram.inflateSetDictionary(strm, 0, 0);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 363));
		ret = ModernizedCProgram.inflateEnd(strm);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 364));
		strm.mem_done("prime");
		"63 0".inf("force window allocation", 0, -15, 1, 0);
		"63 18 5".inf("force window replacement", 0, -8, 259, 0);
		"63 18 68 30 d0 0 0".inf("force split window update", 4, -8, 259, 0);
		"3 0".inf("use fixed blocks", 0, -15, 1, 1);
		"".inf("bad window size", 0, 1, 0, (true));
		strm.mem_setup();
		strm.setAvail_in(0);
		strm.setNext_in(0);
		ret = ModernizedCProgram.inflateInit_(strm, "1.2.11" - 1, (int));
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_VERSION_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 377));
		strm.mem_done("wrong version");
		strm.setAvail_in(0);
		strm.setNext_in(0);
		ret = ModernizedCProgram.inflateInit_((strm), "1.2.11", (int));
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 382));
		ret = ModernizedCProgram.inflateEnd(strm);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 383));
		.fputs("inflate built-in memory routines\n", (_iob[2]));
	}
	/* cover all inflate() header and trailer cases and code after inflate() */
	public static void cover_wrap() {
		int ret;
		z_stream strm = new z_stream();
		z_stream copy = new z_stream();
		byte[] dict = new byte[257];
		ret = ModernizedCProgram.inflate(0, 0);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 394));
		ret = ModernizedCProgram.inflateEnd(0);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 395));
		ret = ModernizedCProgram.inflateCopy(0, 0);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 396));
		.fputs("inflate bad parameters\n", (_iob[2]));
		"1f 8b 0 0".inf("bad gzip method", 0, 31, 0, (true));
		"1f 8b 8 80".inf("bad gzip flags", 0, 31, 0, (true));
		"77 85".inf("bad zlib method", 0, 15, 0, (true));
		"8 99".inf("set window size from header", 0, 0, 0, 0);
		"78 9c".inf("bad zlib window size", 0, 8, 0, (true));
		"78 9c 63 0 0 0 1 0 1".inf("check adler32", 0, 15, 1, 1);
		"1f 8b 8 1e 0 0 0 0 0 0 1 0 0 0 0 0 0".inf("bad header crc", 0, 47, 1, (true));
		"1f 8b 8 2 0 0 0 0 0 0 1d 26 3 0 0 0 0 0 0 0 0 0".inf("check gzip length", 0, 47, 0, 1);
		"78 90".inf("bad zlib header check", 0, 47, 0, (true));
		"8 b8 0 0 0 1".inf("need dictionary", 0, 8, 0, 2);
		"78 9c 63 0".inf("compute adler32", 0, 15, 1, 0);
		strm.mem_setup();
		strm.setAvail_in(0);
		strm.setNext_in(0);
		ret = ModernizedCProgram.inflateInit2_((strm), (true), "1.2.11", (int));
		strm.setAvail_in(2);
		strm.setNext_in((Object)"\x63");
		strm.setAvail_out(1);
		strm.setNext_out((Object)ret);
		strm.mem_limit(1);
		ret = ModernizedCProgram.inflate(strm, 0);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_MEM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 422));
		ret = ModernizedCProgram.inflate(strm, 0);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_MEM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 423));
		strm.mem_limit(0);
		.memset(dict, 0, 257);
		ret = ModernizedCProgram.inflateSetDictionary(strm, dict, 257);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 427));
		strm.mem_limit(( << 1) + 256);
		ret = ModernizedCProgram.inflatePrime(strm, 16, 0);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 429));
		strm.setAvail_in(2);
		strm.setNext_in((Object)"\x80");
		ret = ModernizedCProgram.inflateSync(strm);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_DATA_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 432));
		ret = ModernizedCProgram.inflate(strm, 0);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 433));
		strm.setAvail_in(4);
		strm.setNext_in((Object)"\0\0\xff\xff");
		ret = ModernizedCProgram.inflateSync(strm);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 436));
		(Object)ModernizedCProgram.inflateSyncPoint(strm);
		ret = ModernizedCProgram.inflateCopy(copy, strm);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_MEM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 438));
		strm.mem_limit(0);
		ret = ModernizedCProgram.inflateUndermine(strm, 1);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_DATA_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 440));
		(Object)ModernizedCProgram.inflateMark(strm);
		ret = ModernizedCProgram.inflateEnd(strm);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 442));
		strm.mem_done("miscellaneous, force memory errors");
	}
	/* input and output functions for inflateBack() */
	public static int pull(Object desc, Byte buf) {
		int next = 0;
		byte[] dat = new byte[]{-1024, 0, 2, 0};
		inflate_state state = new inflate_state();
		if (desc == 0) {
			next = 0;
			return /* no input (already provided at next_in) */0;
		} 
		state = (Object)((z_stream)desc).getState();
		if (state != 0) {
			state.setMode(/* force an otherwise impossible situation */.SYNC);
		} 
		return next <  ? () : 0;
	}
	public static int push(Object desc, Byte buf, int len) {
		buf += len;
		return desc != /* force error if desc not null */0;
	}
	/* cover inflateBack() up to common deflate data cases and after those */
	public static void cover_back() {
		int ret;
		z_stream strm = new z_stream();
		byte[] win = new byte[32768];
		ret = ModernizedCProgram.inflateBackInit_(0, 0, win, 0, 0);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_VERSION_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 477));
		ret = ModernizedCProgram.inflateBackInit_((false), (false), (win), "1.2.11", (int));
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 478));
		ret = ModernizedCProgram.inflateBack(0, 0, 0, 0, 0);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 480));
		ret = ModernizedCProgram.inflateBackEnd(0);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 481));
		.fputs("inflateBack bad parameters\n", (_iob[2]));
		strm.mem_setup();
		ret = ModernizedCProgram.inflateBackInit_((strm), (true), (win), "1.2.11", (int));
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 485));
		strm.setAvail_in(2);
		strm.setNext_in((Object)"\x03");
		ret = ModernizedCProgram.inflateBack(strm, pull, 0, push, 0);
		((ret == 1) ? (Object)0 : ._assert("ret == Z_STREAM_END", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 489));
		strm.setAvail_in(/* force output error */3);
		strm.setNext_in((Object)"\x63\x00");
		ret = ModernizedCProgram.inflateBack(strm, pull, 0, push, strm);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_BUF_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 494));
		ret = ModernizedCProgram.inflateBack(strm, pull, strm, push, /* force mode error by mucking with state */0);
		((ret == (true)) ? (Object)0 : ._assert("ret == Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 497));
		ret = ModernizedCProgram.inflateBackEnd(strm);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 498));
		strm.mem_done("inflateBack bad state");
		ret = ModernizedCProgram.inflateBackInit_((strm), (true), (win), "1.2.11", (int));
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 501));
		ret = ModernizedCProgram.inflateBackEnd(strm);
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 502));
		.fputs("inflateBack built-in memory routines\n", (_iob[2]));
	}
	/* do a raw inflate of data in hexadecimal with both inflate and inflateBack */
	public static int try(Byte hex, Byte id, int err) {
		int ret;
		int len;
		int size;
		byte in;
		byte out;
		byte win;
		byte prefix;
		z_stream strm = new z_stream();
		in = ModernizedCProgram.h2b(hex, /* convert to hex */len);
		((in != ((Object)0)) ? (Object)0 : ._assert("in != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 517));
		size = len << /* allocate work areas */3;
		out = .malloc(size);
		((out != ((Object)0)) ? (Object)0 : ._assert("out != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 522));
		win = .malloc(32768);
		((win != ((Object)0)) ? (Object)0 : ._assert("win != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 524));
		prefix = .malloc(.strlen(id) + 6);
		((prefix != ((Object)0)) ? (Object)0 : ._assert("prefix != NULL", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 526));
		.strcpy(prefix, /* first with inflate */id);
		.strcat(prefix, "-late");
		strm.mem_setup();
		strm.setAvail_in(0);
		strm.setNext_in(0);
		ret = ModernizedCProgram.inflateInit2_((strm), (err < 0 ? 47 : -15), "1.2.11", (int));
		((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 535));
		strm.setAvail_in(len);
		strm.setNext_in(in);
		Object generatedAvail_in = strm.getAvail_in();
		Object generatedAvail_out = strm.getAvail_out();
		do {
			strm.setAvail_out(size);
			strm.setNext_out(out);
			ret = ModernizedCProgram.inflate(strm, 6);
			((ret != (true) && ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR && ret != Z_MEM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 542));
			if (ret == (true) || ret == 2) {
				break;
			} 
		} while (generatedAvail_in || generatedAvail_out == 0);
		Byte generatedMsg = strm.getMsg();
		if (err) {
			((ret == (true)) ? (Object)0 : ._assert("ret == Z_DATA_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 547));
			((.strcmp(id, generatedMsg) == 0) ? (Object)0 : ._assert("strcmp(id, strm.msg) == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 548));
		} 
		ModernizedCProgram.inflateEnd(strm);
		strm.mem_done(prefix);
		if (err >= /* then with inflateBack */0) {
			.strcpy(prefix, id);
			.strcat(prefix, "-back");
			strm.mem_setup();
			ret = ModernizedCProgram.inflateBackInit_((strm), (true), (win), "1.2.11", (int));
			((ret == 0) ? (Object)0 : ._assert("ret == Z_OK", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 559));
			strm.setAvail_in(len);
			strm.setNext_in(in);
			ret = ModernizedCProgram.inflateBack(strm, pull, 0, push, 0);
			((ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 563));
			if (err) {
				((ret == (true)) ? (Object)0 : ._assert("ret == Z_DATA_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 565));
				((.strcmp(id, generatedMsg) == 0) ? (Object)0 : ._assert("strcmp(id, strm.msg) == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 566));
			} 
			ModernizedCProgram.inflateBackEnd(strm);
			strm.mem_done(prefix);
		} 
		.free(/* clean up */prefix);
		.free(win);
		.free(out);
		.free(in);
		return ret;
	}
	/* cover deflate data cases in both inflate() and inflateBack() */
	public static void cover_inflate() {
		ModernizedCProgram.try("0 0 0 0 0", "invalid stored block lengths", 1);
		ModernizedCProgram.try("3 0", "fixed", 0);
		ModernizedCProgram.try("6", "invalid block type", 1);
		ModernizedCProgram.try("1 1 0 fe ff 0", "stored", 0);
		ModernizedCProgram.try("fc 0 0", "too many length or distance symbols", 1);
		ModernizedCProgram.try("4 0 fe ff", "invalid code lengths set", 1);
		ModernizedCProgram.try("4 0 24 49 0", "invalid bit length repeat", 1);
		ModernizedCProgram.try("4 0 24 e9 ff ff", "invalid bit length repeat", 1);
		ModernizedCProgram.try("4 0 24 e9 ff 6d", "invalid code -- missing end-of-block", 1);
		ModernizedCProgram.try("4 80 49 92 24 49 92 24 71 ff ff 93 11 0", "invalid literal/lengths set", 1);
		ModernizedCProgram.try("4 80 49 92 24 49 92 24 f b4 ff ff c3 84", "invalid distances set", 1);
		ModernizedCProgram.try("4 c0 81 8 0 0 0 0 20 7f eb b 0 0", "invalid literal/length code", 1);
		ModernizedCProgram.try("2 7e ff ff", "invalid distance code", 1);
		ModernizedCProgram.try("c c0 81 0 0 0 0 0 90 ff 6b 4 0", "invalid distance too far back", 1);
		ModernizedCProgram.try("1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 1", "incorrect data check", -/* also trailer mismatch just in inflate() */1);
		ModernizedCProgram.try("1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 1", "incorrect length check", -1);
		ModernizedCProgram.try("5 c0 21 d 0 0 0 80 b0 fe 6d 2f 91 6c", "pull 17", 0);
		ModernizedCProgram.try("5 e0 81 91 24 cb b2 2c 49 e2 f 2e 8b 9a 47 56 9f fb fe ec d2 ff 1f", "long code", 0);
		ModernizedCProgram.try("ed c0 1 1 0 0 0 40 20 ff 57 1b 42 2c 4f", "length extra", 0);
		ModernizedCProgram.try("ed cf c1 b1 2c 47 10 c4 30 fa 6f 35 1d 1 82 59 3d fb be 2e 2a fc f c", "long distance and extra", 0);
		ModernizedCProgram.try("ed c0 81 0 0 0 0 80 a0 fd a9 17 a9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6", "window end", 0);
		"2 8 20 80 0 3 0".inf("inflate_fast TYPE return", 0, -15, 258, 1);
		"63 18 5 40 c 0".inf("window wrap", 3, -8, 300, 0);
	}
	/* cover remaining lines in inftrees.c */
	public static void cover_trees() {
		int ret;
		int bits;
		int[] lens = new int[16];
		int[] work = new int[16];
		code next = new code();
		code[] table = new code();
		for (bits = 0; bits < 15; /* we need to call inflate_table() directly in order to manifest not-
		       enough errors, since zlib insures that enough is always enough */bits++) {
			lens[bits] = (int)(bits + 1);
		}
		lens[15] = 15;
		next = table;
		bits = 15;
		ret = next.inflate_table(.DISTS, lens, 16, bits, work);
		((ret == 1) ? (Object)0 : ._assert("ret == 1", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 632));
		next = table;
		bits = 1;
		ret = next.inflate_table(.DISTS, lens, 16, bits, work);
		((ret == 1) ? (Object)0 : ._assert("ret == 1", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\infcover.c", 636));
		.fputs("inflate_table not enough errors\n", (_iob[2]));
	}
	/* cover remaining inffast.c decoding and window copying */
	public static void cover_fast() {
		"e5 e0 81 ad 6d cb b2 2c c9 01 1e 59 63 ae 7d ee fb 4d fd b5 35 41 68 ff 7f 0f 0 0 0".inf("fast length extra bits", 0, -8, 258, (true));
		"25 fd 81 b5 6d 59 b6 6a 49 ea af 35 6 34 eb 8c b9 f6 b9 1e ef 67 49 50 fe ff ff 3f 0 0".inf("fast distance extra bits", 0, -8, 258, (true));
		"3 7e 0 0 0 0 0".inf("fast invalid distance code", 0, -8, 258, (true));
		"1b 7 0 0 0 0 0".inf("fast invalid literal/length code", 0, -8, 258, (true));
		"d c7 1 ae eb 38 c 4 41 a0 87 72 de df fb 1f b8 36 b1 38 5d ff ff 0".inf("fast 2nd level codes and too far back", 0, -8, 258, (true));
		"63 18 5 8c 10 8 0 0 0 0".inf("very common case", 0, -8, 259, 0);
		"63 60 60 18 c9 0 8 18 18 18 26 c0 28 0 29 0 0 0".inf("contiguous and wrap around window", 6, -8, 259, 0);
		"63 0 3 0 0 0 0 0".inf("copy direct from output", 0, -8, 259, 1);
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	/*
	  Source:
	   http://www.unicode.org/versions/Unicode7.0.0/UnicodeStandard-7.0.pdf
	   page 124, 3.9 "Unicode Encoding Forms", "UTF-8"
	
	  Table 3-7. Well-Formed UTF-8 Byte Sequences
	  -----------------------------------------------------------------------------
	  |  Code Points        | First Byte | Second Byte | Third Byte | Fourth Byte |
	  |  U+0000..U+007F     |     00..7F |             |            |             |
	  |  U+0080..U+07FF     |     C2..DF |      80..BF |            |             |
	  |  U+0800..U+0FFF     |         E0 |      A0..BF |     80..BF |             |
	  |  U+1000..U+CFFF     |     E1..EC |      80..BF |     80..BF |             |
	  |  U+D000..U+D7FF     |         ED |      80..9F |     80..BF |             |
	  |  U+E000..U+FFFF     |     EE..EF |      80..BF |     80..BF |             |
	  |  U+10000..U+3FFFF   |         F0 |      90..BF |     80..BF |      80..BF |
	  |  U+40000..U+FFFFF   |     F1..F3 |      80..BF |     80..BF |      80..BF |
	  |  U+100000..U+10FFFF |         F4 |      80..8F |     80..BF |      80..BF |
	  -----------------------------------------------------------------------------
	*/
	public static boolean printable_utf8(Object buf, Object len) {
		// there's 9 different code point types for utf8 and ...int[] cp_types = new int[]{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 5, 5, 6, 7, 7, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
		// ... they can be directly translated into a fixed length sequence of bytessize_t[] cp_lens = new size_t[]{1, 2, 3, 3, 3, 3, 4, 4, 4};
		for (size_t pos = 0;
		 pos < len; pos++) {
			u8 c0 = buf[pos];
			int cp_type = cp_types[c0];
			if (cp_type == -1) {
				return 0;
			} 
			size_t cp_len = cp_lens[cp_type];
			if ((pos + cp_len) > len) {
				return 0;
			} 
			if (cp_len >= 2) {
				pos++;
				u8 c1 = buf[pos];
				switch (cp_type) {
				case 6:
						if ((c1 < -1024) || (c1 > -1024)) {
							return 0;
						} 
						break;
				case 8:
						if ((c1 < -1024) || (c1 > -1024)) {
							return 0;
						} 
						break;
				case 2:
						if ((c1 < -1024) || (c1 > -1024)) {
							return 0;
						} 
						break;
				case 4:
						if ((c1 < -1024) || (c1 > -1024)) {
							return 0;
						} 
						break;
				default:
						if ((c1 < -1024) || (c1 > -1024)) {
							return 0;
						} 
						break;
				}
				for (size_t j = 2;
				 j < cp_len; j++) {
					pos++;
					u8 cx = buf[pos];
					if ((cx < -1024) || (cx > -1024)) {
						return 0;
					} 
				}
			} 
		}
		return 1;
	}
	public static boolean printable_ascii(Object buf, Object len) {
		for (size_t i = 0;
		 i < len; i++) {
			u8 c = buf[i];
			if (c < -1024) {
				return 0;
			} 
			if (c > -1024) {
				return 0;
			} 
		}
		return 1;
	}
	public static boolean matches_separator(Object buf, Object len, Object separator) {
		for (size_t i = 0;
		 i < len; i++) {
			byte c = (byte)buf[i];
			if (c == separator) {
				return 1;
			} 
		}
		return 0;
	}
	public static boolean is_hexify(Object buf, Object len) {
		// $HEX[] = 6if (len < 6) {
			return 0;
		} 
		// length of the hex string must be a multiple of 2// and the length of "$HEX[]" is 6 (also an even length)
		// Therefore the overall length must be an even number:if ((len & 1) == 1) {
			return 0;
		} 
		if (buf[0] != (byte)'$') {
			return (false);
		} 
		if (buf[1] != (byte)'H') {
			return (false);
		} 
		if (buf[2] != (byte)'E') {
			return (false);
		} 
		if (buf[3] != (byte)'X') {
			return (false);
		} 
		if (buf[4] != (byte)'[') {
			return (false);
		} 
		if (buf[len - 1] != (byte)']') {
			return (false);
		} 
		if (ModernizedCProgram.is_valid_hex_string(buf + 5, len - 6) == 0) {
			return 0;
		} 
		return 1;
	}
	public static Object exec_unhexify(Object in_buf, Object in_len, Object out_buf, Object out_sz) {
		size_t i = new size_t();
		size_t j = new size_t();
		for (; j < in_len - 1; ) {
			u8 c = ModernizedCProgram.hex_to_u8(in_buf[j]);
			out_buf[i] = c;
		}
		.memset(out_buf + i, 0, out_sz - i);
		return (i);
	}
	public static boolean need_hexify(Object buf, Object len, Object separator, boolean always_ascii) {
		boolean rc = false;
		if (always_ascii == true) {
			if (ModernizedCProgram.printable_ascii(buf, len) == 0) {
				rc = true;
			} 
		} else {
				if (ModernizedCProgram.printable_utf8(buf, len) == 0) {
					rc = true;
				} 
		} 
		if (rc == false) {
			if (ModernizedCProgram.matches_separator(buf, len, separator) == 1) {
				rc = true;
			} 
		} 
		// also test if the password is of the format $HEX[]:if (rc == false) {
			if (ModernizedCProgram.is_hexify(buf, len)) {
				rc = true;
			} 
		} 
		return rc;
	}
	public static void exec_hexify(Object buf, Object len, Object out) {
		size_t max_len = (len > 256) ? 256 : len;
		for (int i = (int)max_len - 1;
		int j = i * 2;
		 i >= 0; ) {
			ModernizedCProgram.u8_to_hex(buf[i], out + j);
		}
		out[max_len * 2] = 0;
	}
	public static boolean is_valid_base64a_string(Object s, Object len) {
		for (size_t i = 0;
		 i < len; i++) {
			u8 c = s[i];
			if (ModernizedCProgram.is_valid_base64a_char(c) == 0) {
				return 0;
			} 
		}
		return 1;
	}
	public static boolean is_valid_base64a_char(Object c) {
		if ((c >= (byte)'0') && (c <= (byte)'9')) {
			return 1;
		} 
		if ((c >= (byte)'A') && (c <= (byte)'Z')) {
			return 1;
		} 
		if ((c >= (byte)'a') && (c <= (byte)'z')) {
			return 1;
		} 
		if (c == (byte)'+') {
			return 1;
		} 
		if (c == (byte)'/') {
			return 1;
		} 
		if (c == (byte)'=') {
			return 1;
		} 
		return 0;
	}
	public static boolean is_valid_base64b_string(Object s, Object len) {
		for (size_t i = 0;
		 i < len; i++) {
			u8 c = s[i];
			if (ModernizedCProgram.is_valid_base64b_char(c) == 0) {
				return 0;
			} 
		}
		return 1;
	}
	public static boolean is_valid_base64b_char(Object c) {
		if ((c >= (byte)'0') && (c <= (byte)'9')) {
			return 1;
		} 
		if ((c >= (byte)'A') && (c <= (byte)'Z')) {
			return 1;
		} 
		if ((c >= (byte)'a') && (c <= (byte)'z')) {
			return 1;
		} 
		if (c == (byte)'.') {
			return 1;
		} 
		if (c == (byte)'/') {
			return 1;
		} 
		if (c == (byte)'=') {
			return 1;
		} 
		return 0;
	}
	public static boolean is_valid_base64c_string(Object s, Object len) {
		for (size_t i = 0;
		 i < len; i++) {
			u8 c = s[i];
			if (ModernizedCProgram.is_valid_base64c_char(c) == 0) {
				return 0;
			} 
		}
		return 1;
	}
	public static boolean is_valid_base64c_char(Object c) {
		if ((c >= (byte)'0') && (c <= (byte)'9')) {
			return 1;
		} 
		if ((c >= (byte)'A') && (c <= (byte)'Z')) {
			return 1;
		} 
		if ((c >= (byte)'a') && (c <= (byte)'z')) {
			return 1;
		} 
		if (c == (byte)'_') {
			return 1;
		} 
		if (c == (byte)'-') {
			return 1;
		} 
		if (c == (byte)'=') {
			return 1;
		} 
		return 0;
	}
	public static boolean is_valid_hex_string(Object s, Object len) {
		for (size_t i = 0;
		 i < len; i++) {
			u8 c = s[i];
			if (ModernizedCProgram.is_valid_hex_char(c) == 0) {
				return 0;
			} 
		}
		return 1;
	}
	public static boolean is_valid_hex_char(Object c) {
		if ((c >= (byte)'0') && (c <= (byte)'9')) {
			return 1;
		} 
		if ((c >= (byte)'A') && (c <= (byte)'F')) {
			return 1;
		} 
		if ((c >= (byte)'a') && (c <= (byte)'f')) {
			return 1;
		} 
		return 0;
	}
	public static boolean is_valid_float_string(Object s, Object len) {
		for (size_t i = 0;
		 i < len; i++) {
			u8 c = s[i];
			if (ModernizedCProgram.is_valid_float_char(c) == 0) {
				return 0;
			} 
		}
		return 1;
	}
	public static boolean is_valid_float_char(Object c) {
		if ((c >= (byte)'0') && (c <= (byte)'9')) {
			return 1;
		} 
		if (c == (byte)'.') {
			return 1;
		} 
		return 0;
	}
	public static boolean is_valid_digit_string(Object s, Object len) {
		for (size_t i = 0;
		 i < len; i++) {
			u8 c = s[i];
			if (ModernizedCProgram.is_valid_digit_char(c) == 0) {
				return 0;
			} 
		}
		return 1;
	}
	public static boolean is_valid_digit_char(Object c) {
		if ((c >= (byte)'0') && (c <= (byte)'9')) {
			return 1;
		} 
		return 0;
	}
	public static Object hex_convert(Object c) {
		return (c & 15) + (c >> 6) * 9;
	}
	public static Object hex_to_u8(Object hex) {
		u8 v = 0;
		v |=  (ModernizedCProgram.hex_convert(hex[1]) << 0);
		v |=  (ModernizedCProgram.hex_convert(hex[0]) << 4);
		return (v);
	}
	public static Object hex_to_u32(Object hex) {
		u32 v = 0;
		v |=  ((u32)ModernizedCProgram.hex_convert(hex[1]) << 0);
		v |=  ((u32)ModernizedCProgram.hex_convert(hex[0]) << 4);
		v |=  ((u32)ModernizedCProgram.hex_convert(hex[3]) << 8);
		v |=  ((u32)ModernizedCProgram.hex_convert(hex[2]) << 12);
		v |=  ((u32)ModernizedCProgram.hex_convert(hex[5]) << 16);
		v |=  ((u32)ModernizedCProgram.hex_convert(hex[4]) << 20);
		v |=  ((u32)ModernizedCProgram.hex_convert(hex[7]) << 24);
		v |=  ((u32)ModernizedCProgram.hex_convert(hex[6]) << 28);
		return (v);
	}
	public static Object hex_to_u64(Object hex) {
		u64 v = 0;
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[1]) << 0);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[0]) << 4);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[3]) << 8);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[2]) << 12);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[5]) << 16);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[4]) << 20);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[7]) << 24);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[6]) << 28);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[9]) << 32);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[8]) << 36);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[11]) << 40);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[10]) << 44);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[13]) << 48);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[12]) << 52);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[15]) << 56);
		v |=  ((u64)ModernizedCProgram.hex_convert(hex[14]) << 60);
		return (v);
	}
	public static void u8_to_hex(Object v, Object hex) {
		u8[] tbl = new u8[]{(byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f'};
		hex[1] = tbl[v >> 0 & 15];
		hex[0] = tbl[v >> 4 & 15];
	}
	public static void u32_to_hex(Object v, Object hex) {
		u8[] tbl = new u8[]{(byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f'};
		hex[1] = tbl[v >> 0 & 15];
		hex[0] = tbl[v >> 4 & 15];
		hex[3] = tbl[v >> 8 & 15];
		hex[2] = tbl[v >> 12 & 15];
		hex[5] = tbl[v >> 16 & 15];
		hex[4] = tbl[v >> 20 & 15];
		hex[7] = tbl[v >> 24 & 15];
		hex[6] = tbl[v >> 28 & 15];
	}
	public static void u64_to_hex(Object v, Object hex) {
		u8[] tbl = new u8[]{(byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f'};
		hex[1] = tbl[v >> 0 & 15];
		hex[0] = tbl[v >> 4 & 15];
		hex[3] = tbl[v >> 8 & 15];
		hex[2] = tbl[v >> 12 & 15];
		hex[5] = tbl[v >> 16 & 15];
		hex[4] = tbl[v >> 20 & 15];
		hex[7] = tbl[v >> 24 & 15];
		hex[6] = tbl[v >> 28 & 15];
		hex[9] = tbl[v >> 32 & 15];
		hex[8] = tbl[v >> 36 & 15];
		hex[11] = tbl[v >> 40 & 15];
		hex[10] = tbl[v >> 44 & 15];
		hex[13] = tbl[v >> 48 & 15];
		hex[12] = tbl[v >> 52 & 15];
		hex[15] = tbl[v >> 56 & 15];
		hex[14] = tbl[v >> 60 & 15];
	}
	public static Object int_to_base32(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	public static Object base32_to_int(Object c) {
		if ((c >= (byte)'A') && (c <= (byte)'Z')) {
			return c - (byte)'A';
		} 
		if ((c >= (byte)'2') && (c <= (byte)'7')) {
			return c - (byte)'2' + 26;
		} 
		return 0;
	}
	public static Object int_to_itoa32(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	public static Object itoa32_to_int(Object c) {
		if ((c >= (byte)'0') && (c <= (byte)'9')) {
			return c - (byte)'0';
		} 
		if ((c >= (byte)'a') && (c <= (byte)'v')) {
			return c - (byte)'a' + 10;
		} 
		return 0;
	}
	public static Object int_to_itoa64(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	public static Object itoa64_to_int(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	public static Object int_to_base64(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	public static Object base64_to_int(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	// alternate base64 using ./ instead of +/, used in python passlib hashes
	public static Object int_to_ab64(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	public static Object ab64_to_int(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	public static Object int_to_base64url(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	public static Object base64url_to_int(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	public static Object int_to_bf64(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	public static Object bf64_to_int(Object c) {
		u8[] tbl = new u8[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024};
		return tbl[c];
	}
	public static Object int_to_lotus64(Object c) {
		if (c < 10) {
			return (byte)'0' + c;
		} 
		if (c < 36) {
			return (byte)'A' + c - 10;
		} 
		if (c < 62) {
			return (byte)'a' + c - 36;
		} 
		if (c == 62) {
			return (byte)'+';
		} 
		if (c == 63) {
			return (byte)'/';
		} 
		return 0;
	}
	public static Object lotus64_to_int(Object c) {
		if ((c >= (byte)'0') && (c <= (byte)'9')) {
			return c - (byte)'0';
		} 
		if ((c >= (byte)'A') && (c <= (byte)'Z')) {
			return c - (byte)'A' + 10;
		} 
		if ((c >= (byte)'a') && (c <= (byte)'z')) {
			return c - (byte)'a' + 36;
		} 
		if (c == (byte)'+') {
			return 62;
		} 
		if (c == (byte)'/') {
			return 63;
		} 
		return 0;
	}
	public static Object base32_decode(Object f, Object in_buf, Object in_len, Object out_buf) {
		u8 in_ptr = in_buf;
		u8 out_ptr = out_buf;
		for (size_t i = 0;
		 i < in_len; i += 8) {
			u8 f0 = ((i + 0) < in_len) ? in_ptr[0] : 0;
			u8 f1 = ((i + 1) < in_len) ? in_ptr[1] : 0;
			u8 f2 = ((i + 2) < in_len) ? in_ptr[2] : 0;
			u8 f3 = ((i + 3) < in_len) ? in_ptr[3] : 0;
			u8 f4 = ((i + 4) < in_len) ? in_ptr[4] : 0;
			u8 f5 = ((i + 5) < in_len) ? in_ptr[5] : 0;
			u8 f6 = ((i + 6) < in_len) ? in_ptr[6] : 0;
			u8 f7 = ((i + 7) < in_len) ? in_ptr[7] : 0;
			u8 out_val0 = .f(f0 & -1024);
			u8 out_val1 = .f(f1 & -1024);
			u8 out_val2 = .f(f2 & -1024);
			u8 out_val3 = .f(f3 & -1024);
			u8 out_val4 = .f(f4 & -1024);
			u8 out_val5 = .f(f5 & -1024);
			u8 out_val6 = .f(f6 & -1024);
			u8 out_val7 = .f(f7 & -1024);
			out_ptr[0] = ((out_val0 << 3) & -1024) | ((out_val1 >> 2) & -1024);
			out_ptr[1] = ((out_val1 << 6) & -1024) | ((out_val2 << 1) & -1024) | ((out_val3 >> 4) & -1024);
			out_ptr[2] = ((out_val3 << 4) & -1024) | ((out_val4 >> 1) & -1024);
			out_ptr[3] = ((out_val4 << 7) & -1024) | ((out_val5 << 2) & -1024) | ((out_val6 >> 3) & -1024);
			out_ptr[4] = ((out_val6 << 5) & -1024) | ((out_val7 >> 0) & -1024);
			in_ptr += 8;
			out_ptr += 5;
		}
		size_t tmp_len = 0;
		for (size_t i = 0;
		 i < in_len; ) {
			if (in_buf[i] != (byte)'=') {
				continue;
			} 
			break;
		}
		size_t out_len = (tmp_len * 5) / 8;
		return out_len;
	}
	public static Object base32_encode(Object f, Object in_buf, Object in_len, Object out_buf) {
		u8 in_ptr = in_buf;
		u8 out_ptr = out_buf;
		for (size_t i = 0;
		 i < in_len; i += 5) {
			u8 f0 = ((i + 0) < in_len) ? in_ptr[0] : 0;
			u8 f1 = ((i + 1) < in_len) ? in_ptr[1] : 0;
			u8 f2 = ((i + 2) < in_len) ? in_ptr[2] : 0;
			u8 f3 = ((i + 3) < in_len) ? in_ptr[3] : 0;
			u8 f4 = ((i + 4) < in_len) ? in_ptr[4] : 0;
			u8 out_val0 = .f(((f0 >> 3) & -1024));
			u8 out_val1 = .f(((f0 << 2) & -1024) | ((f1 >> 6) & -1024));
			u8 out_val2 = .f(((f1 >> 1) & -1024));
			u8 out_val3 = .f(((f1 << 4) & -1024) | ((f2 >> 4) & -1024));
			u8 out_val4 = .f(((f2 << 1) & -1024) | ((f3 >> 7) & -1024));
			u8 out_val5 = .f(((f3 >> 2) & -1024));
			u8 out_val6 = .f(((f3 << 3) & -1024) | ((f4 >> 5) & -1024));
			u8 out_val7 = .f(((f4 >> 0) & -1024));
			out_ptr[0] = out_val0 & -1024;
			out_ptr[1] = out_val1 & -1024;
			out_ptr[2] = out_val2 & -1024;
			out_ptr[3] = out_val3 & -1024;
			out_ptr[4] = out_val4 & -1024;
			out_ptr[5] = out_val5 & -1024;
			out_ptr[6] = out_val6 & -1024;
			out_ptr[7] = out_val7 & -1024;
			in_ptr += 5;
			out_ptr += 8;
		}
		// ceil (in_len * 8 / 5)int out_len = (int)(((0.5 + in_len) * 8) / 5);
		while (out_len % 8) {
			out_buf[out_len] = (byte)'=';
			out_len++;
		}
		return out_len;
	}
	public static Object base64_decode(Object f, Object in_buf, Object in_len, Object out_buf) {
		u8 in_ptr = in_buf;
		u8 out_ptr = out_buf;
		for (size_t i = 0;
		 i < in_len; i += 4) {
			u8 f0 = ((i + 0) < in_len) ? in_ptr[0] : 0;
			u8 f1 = ((i + 1) < in_len) ? in_ptr[1] : 0;
			u8 f2 = ((i + 2) < in_len) ? in_ptr[2] : 0;
			u8 f3 = ((i + 3) < in_len) ? in_ptr[3] : 0;
			u8 out_val0 = .f(f0 & -1024);
			u8 out_val1 = .f(f1 & -1024);
			u8 out_val2 = .f(f2 & -1024);
			u8 out_val3 = .f(f3 & -1024);
			out_ptr[0] = ((out_val0 << 2) & -1024) | ((out_val1 >> 4) & -1024);
			out_ptr[1] = ((out_val1 << 4) & -1024) | ((out_val2 >> 2) & -1024);
			out_ptr[2] = ((out_val2 << 6) & -1024) | ((out_val3 >> 0) & -1024);
			in_ptr += 4;
			out_ptr += 3;
		}
		size_t tmp_len = 0;
		for (size_t i = 0;
		 i < in_len; ) {
			if (in_buf[i] != (byte)'=') {
				continue;
			} 
			break;
		}
		size_t out_len = (tmp_len * 6) / 8;
		return out_len;
	}
	public static Object base64_encode(Object f, Object in_buf, Object in_len, Object out_buf) {
		u8 in_ptr = in_buf;
		u8 out_ptr = out_buf;
		for (size_t i = 0;
		 i < in_len; i += 3) {
			u8 f0 = ((i + 0) < in_len) ? in_ptr[0] : 0;
			u8 f1 = ((i + 1) < in_len) ? in_ptr[1] : 0;
			u8 f2 = ((i + 2) < in_len) ? in_ptr[2] : 0;
			u8 out_val0 = .f(((f0 >> 2) & -1024));
			u8 out_val1 = .f(((f0 << 4) & -1024) | ((f1 >> 4) & -1024));
			u8 out_val2 = .f(((f1 << 2) & -1024) | ((f2 >> 6) & -1024));
			u8 out_val3 = .f(((f2 >> 0) & -1024));
			out_ptr[0] = out_val0 & -1024;
			out_ptr[1] = out_val1 & -1024;
			out_ptr[2] = out_val2 & -1024;
			out_ptr[3] = out_val3 & -1024;
			in_ptr += 3;
			out_ptr += 4;
		}
		// ceil (in_len * 8 / 6)int out_len = (int)(((0.5 + in_len) * 8) / 6);
		while (out_len % 4) {
			out_buf[out_len] = (byte)'=';
			out_len++;
		}
		return out_len;
	}
	public static void lowercase(Object buf, Object len) {
		for (size_t i = 0;
		 i < len; i++) {
			buf[i] = (u8).tolower((int)buf[i]);
		}
	}
	public static void uppercase(Object buf, Object len) {
		for (size_t i = 0;
		 i < len; i++) {
			buf[i] = (u8).toupper((int)buf[i]);
		}
	}
	public static Object v8a_from_v32(Object v32) {
		vconv32_t v = new vconv32_t();
		v.setV32(v32);
		Object generatedV8 = v.getV8();
		return generatedV8.getA();
	}
	public static Object v8b_from_v32(Object v32) {
		vconv32_t v = new vconv32_t();
		v.setV32(v32);
		Object generatedV8 = v.getV8();
		return generatedV8.getB();
	}
	public static Object v8c_from_v32(Object v32) {
		vconv32_t v = new vconv32_t();
		v.setV32(v32);
		Object generatedV8 = v.getV8();
		return generatedV8.getC();
	}
	public static Object v8d_from_v32(Object v32) {
		vconv32_t v = new vconv32_t();
		v.setV32(v32);
		Object generatedV8 = v.getV8();
		return generatedV8.getD();
	}
	public static Object v16a_from_v32(Object v32) {
		vconv32_t v = new vconv32_t();
		v.setV32(v32);
		Object generatedV16 = v.getV16();
		return generatedV16.getA();
	}
	public static Object v16b_from_v32(Object v32) {
		vconv32_t v = new vconv32_t();
		v.setV32(v32);
		Object generatedV16 = v.getV16();
		return generatedV16.getB();
	}
	public static Object v32_from_v16ab(Object v16a, Object v16b) {
		vconv32_t v = new vconv32_t();
		Object generatedV16 = v.getV16();
		generatedV16.setA(v16a);
		generatedV16.setB(v16b);
		Object generatedV32 = v.getV32();
		return generatedV32;
	}
	public static Object v32a_from_v64(Object v64) {
		vconv64_t v = new vconv64_t();
		v.setV64(v64);
		Object generatedV32 = v.getV32();
		return generatedV32.getA();
	}
	public static Object v32b_from_v64(Object v64) {
		vconv64_t v = new vconv64_t();
		v.setV64(v64);
		Object generatedV32 = v.getV32();
		return generatedV32.getB();
	}
	public static Object v64_from_v32ab(Object v32a, Object v32b) {
		vconv64_t v = new vconv64_t();
		Object generatedV32 = v.getV32();
		generatedV32.setA(v32a);
		generatedV32.setB(v32b);
		Object generatedV64 = v.getV64();
		return generatedV64;
	}
	public static int hex_decode(Object in_buf, Object in_len, Object out_buf) {
		for (int i = 0;
		int j = 0;
		 i < in_len; ) {
			out_buf[j] = ModernizedCProgram.hex_to_u8(in_buf[i]);
		}
		return in_len / 2;
	}
	public static int hex_encode(Object in_buf, Object in_len, Object out_buf) {
		for (int i = 0;
		int j = 0;
		 i < in_len; ) {
			ModernizedCProgram.u8_to_hex(in_buf[i], out_buf[j]);
		}
		return in_len * 2;
	}
	public static Object module_kernel_accel_min(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 kernel_accel_min = 1;
		return kernel_accel_min;
		u32 kernel_accel_min = 1;
		return kernel_accel_min;
		u32 kernel_accel_min = 1;
		return kernel_accel_min;
	}
	public static Object module_kernel_accel_max(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 kernel_accel_max = (user_options.getKernel_accel_chgd() == 1) ? user_options.getKernel_accel() : ModernizedCProgram.SCRYPT_MAX_ACCEL;
		return kernel_accel_max;
		// password length affects total performance, this limits the wait times for threads with short password lengths if there's at least one thread with long password lengthu32 kernel_accel_max = 128;
		return kernel_accel_max;
		u32 kernel_accel_max = (user_options.getKernel_accel_chgd() == 1) ? user_options.getKernel_accel() : ModernizedCProgram.SCRYPT_MAX_ACCEL;
		return kernel_accel_max;
		u32 kernel_accel_max = (user_options.getKernel_accel_chgd() == 1) ? user_options.getKernel_accel() : ModernizedCProgram.SCRYPT_MAX_ACCEL;
		return kernel_accel_max;
	}
	public static Object module_extra_buffer_size(Object hashconfig, Object user_options, Object user_options_extra, Object hashes, Object device_param) {
		// the decoder for the self-test is called after this functionu32 scrypt_N = (hashes.getSalts_buf()[0].getScrypt_N()) ? hashes.getSalts_buf()[0].getScrypt_N() : 262144;
		u32 scrypt_r = (hashes.getSalts_buf()[0].getScrypt_r()) ? hashes.getSalts_buf()[0].getScrypt_r() : 8;
		//const u32 scrypt_p = (hashes->salts_buf[0].scrypt_p) ? hashes->salts_buf[0].scrypt_p : 1;
		u64 kernel_power_max = (u64)(device_param.getDevice_processors() * hashconfig.getKernel_threads_max() * hashconfig.getKernel_accel_max());
		u32 tmto_start = 1;
		u32 tmto_stop = 6;
		if (user_options.getScrypt_tmto()) {
			tmto_start = user_options.getScrypt_tmto();
			tmto_stop = user_options.getScrypt_tmto();
		} 
		// size_pwsu64 size_pws = kernel_power_max * ;
		u64 size_pws_amp = size_pws;
		// size_pws_comp
		u64 size_pws_comp = kernel_power_max * ( * 64);
		// size_pws_idx
		u64 size_pws_idx = (kernel_power_max + 1) * ;
		// size_tmps
		u64 size_tmps = kernel_power_max * hashconfig.getTmp_size();
		// size_hooks
		u64 size_hooks = kernel_power_max * hashconfig.getHook_size();
		u64 scrypt_extra_space = device_param.getSize_bfs() + device_param.getSize_combs() + device_param.getSize_digests() + device_param.getSize_esalts() + device_param.getSize_markov_css() + device_param.getSize_plains() + device_param.getSize_results() + device_param.getSize_root_css() + device_param.getSize_rules() + device_param.getSize_rules_c() + device_param.getSize_salts() + device_param.getSize_shown() + device_param.getSize_tm() + device_param.getSize_st_digests() + device_param.getSize_st_salts() + device_param.getSize_st_esalts() + size_pws + size_pws_amp + size_pws_comp + size_pws_idx + size_tmps + size_hooks;
		boolean not_enough_memory = true;
		u64 size_scrypt = 0;
		u32 tmto = new u32();
		for (tmto = tmto_start; tmto <= tmto_stop; tmto++) {
			size_scrypt = (128 * scrypt_r) * scrypt_N;
			size_scrypt /= -1024 << tmto;
			size_scrypt *= kernel_power_max;
			if ((size_scrypt / 4) > device_param.getDevice_maxmem_alloc()) {
				continue;
			} 
			if ((size_scrypt + scrypt_extra_space) > device_param.getDevice_available_mem()) {
				continue;
			} 
			not_enough_memory = false;
			break;
		}
		if (not_enough_memory == true) {
			return -1;
		} 
		return size_scrypt;
		// the decoder for the self-test is called after this functionu32 scrypt_N = (hashes.getSalts_buf()[0].getScrypt_N()) ? hashes.getSalts_buf()[0].getScrypt_N() : 1024;
		u32 scrypt_r = (hashes.getSalts_buf()[0].getScrypt_r()) ? hashes.getSalts_buf()[0].getScrypt_r() : 1;
		u64 kernel_power_max = (u64)(device_param.getDevice_processors() * hashconfig.getKernel_threads_max() * hashconfig.getKernel_accel_max());
		u32 tmto_start = 1;
		u32 tmto_stop = 6;
		if (user_options.getScrypt_tmto()) {
			tmto_start = user_options.getScrypt_tmto();
			tmto_stop = user_options.getScrypt_tmto();
		} 
		// size_pwsu64 size_pws = kernel_power_max * ;
		u64 size_pws_amp = size_pws;
		// size_pws_comp
		u64 size_pws_comp = kernel_power_max * ( * 64);
		// size_pws_idx
		u64 size_pws_idx = (kernel_power_max + 1) * ;
		// size_tmps
		u64 size_tmps = kernel_power_max * hashconfig.getTmp_size();
		// size_hooks
		u64 size_hooks = kernel_power_max * hashconfig.getHook_size();
		u64 scrypt_extra_space = device_param.getSize_bfs() + device_param.getSize_combs() + device_param.getSize_digests() + device_param.getSize_esalts() + device_param.getSize_markov_css() + device_param.getSize_plains() + device_param.getSize_results() + device_param.getSize_root_css() + device_param.getSize_rules() + device_param.getSize_rules_c() + device_param.getSize_salts() + device_param.getSize_shown() + device_param.getSize_tm() + device_param.getSize_st_digests() + device_param.getSize_st_salts() + device_param.getSize_st_esalts() + size_pws + size_pws_amp + size_pws_comp + size_pws_idx + size_tmps + size_hooks;
		boolean not_enough_memory = true;
		u64 size_scrypt = 0;
		u32 tmto = new u32();
		for (tmto = tmto_start; tmto <= tmto_stop; tmto++) {
			size_scrypt = (128 * scrypt_r) * scrypt_N;
			size_scrypt /= -1024 << tmto;
			size_scrypt *= kernel_power_max;
			if ((size_scrypt / 4) > device_param.getDevice_maxmem_alloc()) {
				continue;
			} 
			if ((size_scrypt + scrypt_extra_space) > device_param.getDevice_available_mem()) {
				continue;
			} 
			not_enough_memory = false;
			break;
		}
		if (not_enough_memory == true) {
			return -1;
		} 
		return size_scrypt;
		// the decoder for the self-test is called after this functionu32 scrypt_N = 16384;
		u32 scrypt_r = 1;
		//const u32 scrypt_p = 1;
		u64 kernel_power_max = (u64)(device_param.getDevice_processors() * hashconfig.getKernel_threads_max() * hashconfig.getKernel_accel_max());
		u32 tmto_start = 1;
		u32 tmto_stop = 6;
		if (user_options.getScrypt_tmto()) {
			tmto_start = user_options.getScrypt_tmto();
			tmto_stop = user_options.getScrypt_tmto();
		} 
		// size_pwsu64 size_pws = kernel_power_max * ;
		u64 size_pws_amp = size_pws;
		// size_pws_comp
		u64 size_pws_comp = kernel_power_max * ( * 64);
		// size_pws_idx
		u64 size_pws_idx = (kernel_power_max + 1) * ;
		// size_tmps
		u64 size_tmps = kernel_power_max * hashconfig.getTmp_size();
		// size_hooks
		u64 size_hooks = kernel_power_max * hashconfig.getHook_size();
		u64 scrypt_extra_space = device_param.getSize_bfs() + device_param.getSize_combs() + device_param.getSize_digests() + device_param.getSize_esalts() + device_param.getSize_markov_css() + device_param.getSize_plains() + device_param.getSize_results() + device_param.getSize_root_css() + device_param.getSize_rules() + device_param.getSize_rules_c() + device_param.getSize_salts() + device_param.getSize_shown() + device_param.getSize_tm() + device_param.getSize_st_digests() + device_param.getSize_st_salts() + device_param.getSize_st_esalts() + size_pws + size_pws_amp + size_pws_comp + size_pws_idx + size_tmps + size_hooks;
		boolean not_enough_memory = true;
		u64 size_scrypt = 0;
		u32 tmto = new u32();
		for (tmto = tmto_start; tmto <= tmto_stop; tmto++) {
			size_scrypt = (128 * scrypt_r) * scrypt_N;
			size_scrypt /= -1024 << tmto;
			size_scrypt *= kernel_power_max;
			if ((size_scrypt / 4) > device_param.getDevice_maxmem_alloc()) {
				continue;
			} 
			if ((size_scrypt + scrypt_extra_space) > device_param.getDevice_available_mem()) {
				continue;
			} 
			not_enough_memory = false;
			break;
		}
		if (not_enough_memory == true) {
			return -1;
		} 
		return size_scrypt;
	}
	// we need to set the self-test hash settings to pass the self-test
	public static Object module_extra_tmp_size(Object hashconfig, Object user_options, Object user_options_extra, Object hashes) {
		// the decoder for the self-test is called after this functionu32 scrypt_N = (hashes.getSalts_buf()[0].getScrypt_N()) ? hashes.getSalts_buf()[0].getScrypt_N() : 262144;
		u32 scrypt_r = (hashes.getSalts_buf()[0].getScrypt_r()) ? hashes.getSalts_buf()[0].getScrypt_r() : 8;
		u32 scrypt_p = (hashes.getSalts_buf()[0].getScrypt_p()) ? hashes.getSalts_buf()[0].getScrypt_p() : 1;
		// we need to check that all hashes have the same scrypt settings
		for (u32 i = 1;
		 i < hashes.getSalts_cnt(); i++) {
			if ((hashes.getSalts_buf()[i].getScrypt_N() != scrypt_N) || (hashes.getSalts_buf()[i].getScrypt_r() != scrypt_r) || (hashes.getSalts_buf()[i].getScrypt_p() != scrypt_p)) {
				return -1;
			} 
		}
		u64 tmp_size = (u64)(128 * scrypt_r * scrypt_p);
		return tmp_size;
		// the decoder for the self-test is called after this functionu32 scrypt_N = (hashes.getSalts_buf()[0].getScrypt_N()) ? hashes.getSalts_buf()[0].getScrypt_N() : 1024;
		u32 scrypt_r = (hashes.getSalts_buf()[0].getScrypt_r()) ? hashes.getSalts_buf()[0].getScrypt_r() : 1;
		u32 scrypt_p = (hashes.getSalts_buf()[0].getScrypt_p()) ? hashes.getSalts_buf()[0].getScrypt_p() : 1;
		// we need to check that all hashes have the same scrypt settings
		for (u32 i = 1;
		 i < hashes.getSalts_cnt(); i++) {
			if ((hashes.getSalts_buf()[i].getScrypt_N() != scrypt_N) || (hashes.getSalts_buf()[i].getScrypt_r() != scrypt_r) || (hashes.getSalts_buf()[i].getScrypt_p() != scrypt_p)) {
				return -1;
			} 
		}
		u64 tmp_size = (u64)(128 * scrypt_r * scrypt_p);
		return tmp_size;
		// the decoder for the self-test is called after this function//const u32 scrypt_N = 16384;u32 scrypt_r = 1;
		u32 scrypt_p = 1;
		u64 tmp_size = (128 * scrypt_r * scrypt_p);
		return tmp_size;
	}
	// we need to set the self-test hash settings to pass the self-test
	/*
	 * pufftest.c
	 * Copyright (C) 2002-2013 Mark Adler
	 * For conditions of distribution and use, see copyright notice in puff.h
	 * version 2.3, 21 Jan 2013
	 */
	/* Example of how to use puff().
	
	   Usage: puff [-w] [-f] [-nnn] file
	          ... | puff [-w] [-f] [-nnn]
	
	   where file is the input file with deflate data, nnn is the number of bytes
	   of input to skip before inflating (e.g. to skip a zlib or gzip header), and
	   -w is used to write the decompressed data to stdout.  -f is for coverage
	   testing, and causes pufftest to fail with not enough output space (-f does
	   a write like -w, so -w is not required). */
	/* Return size times approximately the cube root of 2, keeping the result as 1,
	   3, or 5 times a power of 2 -- the result is always > size, until the result
	   is the maximum value of an unsigned long, where it remains.  This is useful
	   to keep reallocations less than ~33% over the actual data. */
	public static Object bythirds(Object size) {
		int n;
		size_t m = new size_t();
		m = size;
		for (n = 0; m; n++) {
			m >>=  1;
		}
		if (n < 3) {
			return size + 1;
		} 
		n -= 3;
		m = size >> n;
		m += m == 6 ? 2 : 1;
		m <<=  n;
		return m > size ? m : (size_t)(true/* Read the input file *name, or stdin if name is NULL, into allocated memory.
		   Reallocate to larger buffers until the entire file is read in.  Return a
		   pointer to the allocated data, or NULL if there was a memory allocation
		   failure.  *len is the number of bytes of data read from the input file (even
		   if load() returns NULL).  If the input file was empty or could not be opened
		   or read, *len is zero. */);
	}
	public static Object load(Object name, Object len) {
		size_t size = new size_t();
		Object buf;
		Object swap;
		FILE in = new FILE();
		len = 0;
		buf = .malloc(size = 4096);
		if (buf == ((Object)0)) {
			return ((Object)0);
		} 
		in = name == ((Object)0) ? (_iob[0]) : .fopen(name, "rb");
		if (in != ((Object)0)) {
			for (; ; ) {
				len += .fread((byte)buf + len, 1, size - len, in);
				if (len < size) {
					break;
				} 
				size = ModernizedCProgram.bythirds(size);
				if (size == len || (swap = .realloc(buf, size)) == ((Object)0)) {
					.free(buf);
					buf = ((Object)0);
					break;
				} 
				buf = swap;
			}
			.fclose(in);
		} 
		return buf;
	}
	public static int sort_by_usage(Object p1, Object p2) {
		usage_sort_t u1 = (usage_sort_t)p1;
		usage_sort_t u2 = (usage_sort_t)p2;
		if (u1.getHash_category() > u2.getHash_category()) {
			return 1;
		} 
		if (u1.getHash_category() < u2.getHash_category()) {
			return -1;
		} 
		// yes, strange...int rc_name = .strncmp(u1.getHash_name() + 1, u2.getHash_name() + 1, 15);
		if (rc_name > 0) {
			return 1;
		} 
		if (rc_name < 0) {
			return -1;
		} 
		if (u1.getHash_mode() > u2.getHash_mode()) {
			return 1;
		} 
		if (u1.getHash_mode() < u2.getHash_mode()) {
			return -1;
		} 
		return 0;
	}
	public static void usage_mini_print(Object progname) {
		for (int i = 0;
		 ModernizedCProgram.USAGE_MINI[i] != ((Object)0); i++) {
			.printf(ModernizedCProgram.USAGE_MINI[i], progname);
			.fwrite("\r\n", .strlen("\r\n"), 1, (_iob[1]));
		}
	}
	/* Free allocated space.  Uses globals code, num, and done. */
	public static void cleanup() {
		size_t n = new size_t();
		if (ModernizedCProgram.done != ((Object)0)) {
			for (n = 0; n < ModernizedCProgram.size; n++) {
				if (ModernizedCProgram.done[n].getLen()) {
					.free(ModernizedCProgram.done[n].getVec());
				} 
			}
			.free(ModernizedCProgram.done);
		} 
		if (ModernizedCProgram.num != ((Object)0)) {
			.free(ModernizedCProgram.num);
		} 
		if (ModernizedCProgram.code != ((Object)0)) {
			.free(ModernizedCProgram.code/* Return the number of possible Huffman codes using bit patterns of lengths
			   len through max inclusive, coding syms symbols, with left bit patterns of
			   length len unused -- return -1 if there is an overflow in the counting.
			   Keep a record of previous results in num to prevent repeating the same
			   calculation.  Uses the globals max and num. */);
		} 
	}
	public static Object count(int syms, int len, int left) {
		/* number of possible codes from this juncture */big_t sum = new big_t();
		/* value returned from count() */big_t got = new big_t();
		/* least number of syms to use at this juncture */int least;
		/* most number of syms to use at this juncture */int most;
		/* number of bit patterns to use in next call */int use;
		/* index of this case in *num */size_t index = new size_t();
		if (syms == /* see if only one possible code */left) {
			return 1;
		} 
		((syms > left && left > 0 && len < ModernizedCProgram.max) ? (Object)0 : ._assert("syms > left && left > 0 && len < max", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\enough.c", /* note and verify the expected state */217));
		index = (((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) + (left >> 1) - 1) * (ModernizedCProgram.max - 1) + len - /* see if we've done this one already */1);
		got = ModernizedCProgram.num[index];
		if (got) {
			return /* we have -- return the saved result */got;
		} 
		least = (left << 1) - /* we need to use at least this many bit patterns so that the code won't be
		       incomplete at the next length (more bit patterns than symbols) */syms;
		if (least < 0) {
			least = 0/* we can use at most this many bit patterns, lest there not be enough
			       available for the remaining symbols at the maximum length (if there were
			       no limit to the code length, this would become: most = left - 1) */;
		} 
		most = (((code_t)left << (ModernizedCProgram.max - len)) - syms) / (((code_t)1 << (ModernizedCProgram.max - len)) - 1);
		sum = /* count all possible codes from this juncture and add them up */0;
		for (use = least; use <= most; use++) {
			got = ModernizedCProgram.count(syms - use, len + 1, (left - use) << 1);
			sum += got;
			if (got == (big_t)0 - 1 || sum < /* overflow */got) {
				return (big_t)0 - 1;
			} 
		}
		((sum != 0) ? (Object)0 : ._assert("sum != 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\enough.c", /* verify that all recursive calls are productive */247));
		ModernizedCProgram.num[index] = /* save the result and return it */sum;
		return sum/* Return true if we've been here before, set to true if not.  Set a bit in a
		   bit vector to indicate visiting this state.  Each (syms,len,left) state
		   has a variable size bit vector indexed by (mem,rem).  The bit vector is
		   lengthened if needed to allow setting the (mem,rem) bit. */;
	}
	public static int beenhere(int syms, int len, int left, int mem, int rem) {
		/* index for this state's bit vector */size_t index = new size_t();
		/* offset in this state's bit vector */size_t offset = new size_t();
		/* mask for this state's bit */int bit;
		/* length of the bit vector in bytes */size_t length = new size_t();
		/* new or enlarged bit vector */byte vector;
		index = (((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) + (left >> 1) - 1) * (ModernizedCProgram.max - 1) + len - /* point to vector for (syms,left,len), bit in vector for (mem,rem) */1);
		mem -= 1 << ModernizedCProgram.root;
		offset = (mem >> 3) + rem;
		offset = ((offset * (offset + 1)) >> 1) + rem;
		bit = 1 << (mem & 7);
		length = ModernizedCProgram.done[index].getLen();
		if (offset < length && (ModernizedCProgram.done[index].getVec()[offset] & bit) != 0) {
			return /* done this! */1/* we haven't been here before -- set the bit to show we have now */;
		} 
		if (length <= /* see if we need to lengthen the vector in order to set the bit */offset) {
			if (/* if we have one already, enlarge it, zero out the appended space */length) {
				do {
					length <<=  1;
				} while (length <= offset);
				vector = .realloc(ModernizedCProgram.done[index].getVec(), length);
				if (vector != ((Object)0)) {
					.memset(vector + ModernizedCProgram.done[index].getLen(), 0, length - ModernizedCProgram.done[index].getLen());
				} 
			} else {
					length = 1 << (len - /* otherwise we need to make a new vector and zero it out */ModernizedCProgram.root);
					while (length <= offset) {
						length <<=  1;
					}
					vector = .calloc(length, );
			} 
			if (vector == ((Object)/* in either case, bail if we can't get the memory */0)) {
				.fputs("abort: unable to allocate enough memory\n", (_iob[2]));
				ModernizedCProgram.cleanup();
				.exit(1);
			} 
			ModernizedCProgram.done[index].setLen(/* install the new vector */length);
			ModernizedCProgram.done[index].setVec(vector);
		} 
		ModernizedCProgram.done[index].getVec()[offset] |=  /* set the bit */bit;
		return 0/* Examine all possible codes from the given node (syms, len, left).  Compute
		   the amount of memory required to build inflate's decoding tables, where the
		   number of code structures used so far is mem, and the number remaining in
		   the current sub-table is rem.  Uses the globals max, code, root, large, and
		   done. */;
	}
	public static void examine(int syms, int len, int left, int mem, int rem) {
		/* least number of syms to use at this juncture */int least;
		/* most number of syms to use at this juncture */int most;
		/* number of bit patterns to use in next call */int use;
		if (syms == /* see if we have a complete code */left) {
			ModernizedCProgram.code[len] = /* set the last code entry */left;
			while (rem < /* complete computation of memory used by this code */left) {
				left -= rem;
				rem = 1 << (len - ModernizedCProgram.root);
				mem += rem;
			}
			((rem == left) ? (Object)0 : ._assert("rem == left", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\enough.c", 339));
			if (mem > /* if this is a new maximum, show the entries used and the sub-code */ModernizedCProgram.large) {
				ModernizedCProgram.large = mem;
				.printf("max %d: ", mem);
				for (use = ModernizedCProgram.root + 1; use <= ModernizedCProgram.max; use++) {
					if (ModernizedCProgram.code[use]) {
						.printf("%d[%d] ", ModernizedCProgram.code[use], use);
					} 
				}
				.putchar((byte)'\n');
				.fflush((_iob[1]));
			} 
			ModernizedCProgram.code[len] = /* remove entries as we drop back down in the recursion */0;
			return ;
		} 
		if (ModernizedCProgram.beenhere(syms, len, left, mem, /* prune the tree if we can */rem)) {
			return ;
		} 
		least = (left << 1) - /* we need to use at least this many bit patterns so that the code won't be
		       incomplete at the next length (more bit patterns than symbols) */syms;
		if (least < 0) {
			least = 0/* we can use at most this many bit patterns, lest there not be enough
			       available for the remaining symbols at the maximum length (if there were
			       no limit to the code length, this would become: most = left - 1) */;
		} 
		most = (((code_t)left << (ModernizedCProgram.max - len)) - syms) / (((code_t)1 << (ModernizedCProgram.max - len)) - 1);
		use = /* occupy least table spaces, creating new sub-tables as needed */least;
		while (rem < use) {
			use -= rem;
			rem = 1 << (len - ModernizedCProgram.root);
			mem += rem;
		}
		rem -= use;
		for (use = least; use <= most; /* examine codes from here, updating table space as we go */use++) {
			ModernizedCProgram.code[len] = use;
			ModernizedCProgram.examine(syms - use, len + 1, (left - use) << 1, mem + (rem ? 1 << (len - ModernizedCProgram.root) : 0), rem << 1);
			if (rem == 0) {
				rem = 1 << (len - ModernizedCProgram.root);
				mem += rem;
			} 
			rem--;
		}
		ModernizedCProgram.code[len] = /* remove entries as we drop back down in the recursion */0/* Look at all sub-codes starting with root + 1 bits.  Look at only the valid
		   intermediate code states (syms, left, len).  For each completed code,
		   calculate the amount of memory required by inflate to build the decoding
		   tables. Find the maximum amount of memory required and show the code that
		   requires that maximum.  Uses the globals max, root, and num. */;
	}
	public static void enough(int syms) {
		/* number of remaing symbols for this node */int n;
		/* number of unused bit patterns at this length */int left;
		/* index of this case in *num */size_t index = new size_t();
		for (n = 0; n <= ModernizedCProgram.max; /* clear code */n++) {
			ModernizedCProgram.code[n] = 0;
		}
		ModernizedCProgram.large = 1 << /* look at all (root + 1) bit and longer codes *//* base table */ModernizedCProgram.root;
		if (ModernizedCProgram.root < /* otherwise, there's only a base table */ModernizedCProgram.max) {
			for (n = 3; n <= syms; n++) {
				for (left = 2; left < n; left += 2) {
					index = (((size_t)((n - 1) >> 1) * ((n - 2) >> 1) + (left >> 1) - 1) * (ModernizedCProgram.max - 1) + ModernizedCProgram.root + 1 - /* look at all reachable (root + 1) bit nodes, and the
					                   resulting codes (complete at root + 2 or more) */1);
					if (ModernizedCProgram.root + 1 < ModernizedCProgram.max && ModernizedCProgram.num[/* reachable node */index]) {
						ModernizedCProgram.examine(n, ModernizedCProgram.root + 1, left, 1 << ModernizedCProgram.root, 0);
					} 
					if (ModernizedCProgram.num[index - 1] && n <= left << /* also look at root bit codes with completions at root + 1
					                   bits (not saved in num, since complete), just in case */1) {
						ModernizedCProgram.examine((n - left) << 1, ModernizedCProgram.root + 1, (n - left) << 1, 1 << ModernizedCProgram.root, 0);
					} 
				}
			}
		} 
		.printf("done: maximum of %d table entries\n", /* done */ModernizedCProgram.large/*
		   Examine and show the total number of possible Huffman codes for a given
		   maximum number of symbols, initial root table size, and maximum code length
		   in bits -- those are the command arguments in that order.  The default
		   values are 286, 9, and 15 respectively, for the deflate literal/length code.
		   The possible codes are counted for each number of coded symbols from two to
		   the maximum.  The counts for each of those and the total number of codes are
		   shown.  The maximum number of inflate table entires is then calculated
		   across all possible codes.  Each new maximum number of table entries and the
		   associated sub-code (starting at root + 1 == 10 bits) is shown.
		
		   To count and examine Huffman codes that are not length-limited, provide a
		   maximum length equal to the number of symbols minus one.
		
		   For the deflate literal/length code, use "enough".  For the deflate distance
		   code, use "enough 30 6".
		
		   This uses the %llu printf format to print big_t numbers, which assumes that
		   big_t is an unsigned long long.  If the big_t type is changed (for example
		   to a multiple precision type), the method of printing will also need to be
		   updated.
		 */);
	}
	public static int opencl_context(Object ) {
	}
	public static int opencl_command_queue(Object ) {
	}
	public static int opencl_program(Object ) {
	}
	public static int opencl_program_mp(Object ) {
	}
	public static int opencl_program_amp(Object ) {
	}
	public static int opencl_kernel1(Object ) {
	}
	public static int opencl_kernel12(Object ) {
	}
	public static int opencl_kernel2(Object ) {
	}
	public static int opencl_kernel23(Object ) {
	}
	public static int opencl_kernel3(Object ) {
	}
	public static int opencl_kernel4(Object ) {
	}
	public static int opencl_kernel_init2(Object ) {
	}
	public static int opencl_kernel_loop2(Object ) {
	}
	public static int opencl_kernel_mp(Object ) {
	}
	public static int opencl_kernel_mp_l(Object ) {
	}
	public static int opencl_kernel_mp_r(Object ) {
	}
	public static int opencl_kernel_amp(Object ) {
	}
	public static int opencl_kernel_tm(Object ) {
	}
	public static int opencl_kernel_memset(Object ) {
	}
	public static int opencl_kernel_atinit(Object ) {
	}
	public static int opencl_kernel_decompress(Object ) {
	}
	public static int opencl_kernel_aux1(Object ) {
	}
	public static int opencl_kernel_aux2(Object ) {
	}
	public static int opencl_kernel_aux3(Object ) {
	}
	public static int opencl_kernel_aux4(Object ) {
	}
	public static int opencl_d_pws_buf(Object ) {
	}
	public static int opencl_d_pws_amp_buf(Object ) {
	}
	public static int opencl_d_pws_comp_buf(Object ) {
	}
	public static int opencl_d_pws_idx(Object ) {
	}
	public static int opencl_d_words_buf_l(Object ) {
	}
	public static int opencl_d_words_buf_r(Object ) {
	}
	public static int opencl_d_rules(Object ) {
	}
	public static int opencl_d_rules_c(Object ) {
	}
	public static int opencl_d_combs(Object ) {
	}
	public static int opencl_d_combs_c(Object ) {
	}
	public static int opencl_d_bfs(Object ) {
	}
	public static int opencl_d_bfs_c(Object ) {
	}
	public static int opencl_d_tm_c(Object ) {
	}
	public static int opencl_d_bitmap_s1_a(Object ) {
	}
	public static int opencl_d_bitmap_s1_b(Object ) {
	}
	public static int opencl_d_bitmap_s1_c(Object ) {
	}
	public static int opencl_d_bitmap_s1_d(Object ) {
	}
	public static int opencl_d_bitmap_s2_a(Object ) {
	}
	public static int opencl_d_bitmap_s2_b(Object ) {
	}
	public static int opencl_d_bitmap_s2_c(Object ) {
	}
	public static int opencl_d_bitmap_s2_d(Object ) {
	}
	public static int opencl_d_plain_bufs(Object ) {
	}
	public static int opencl_d_digests_buf(Object ) {
	}
	public static int opencl_d_digests_shown(Object ) {
	}
	public static int opencl_d_salt_bufs(Object ) {
	}
	public static int opencl_d_esalt_bufs(Object ) {
	}
	public static int opencl_d_tmps(Object ) {
	}
	public static int opencl_d_hooks(Object ) {
	}
	public static int opencl_d_result(Object ) {
	}
	public static int opencl_d_extra0_buf(Object ) {
	}
	public static int opencl_d_extra1_buf(Object ) {
	}
	public static int opencl_d_extra2_buf(Object ) {
	}
	public static int opencl_d_extra3_buf(Object ) {
	}
	public static int opencl_d_root_css_buf(Object ) {
	}
	public static int opencl_d_markov_css_buf(Object ) {
	}
	public static int opencl_d_st_digests_buf(Object ) {
	}
	public static int opencl_d_st_salts_buf(Object ) {
	}
	public static int opencl_d_st_esalts_buf(Object ) {
	}
	public static Object CrcUpdate(Object v, Object data, Object size) {
		return .g_CrcUpdate(v, data, size, ModernizedCProgram.g_CrcTable);
	}
	public static Object CrcCalc(Object data, Object size) {
		return .g_CrcUpdate(-1024, data, size, ModernizedCProgram.g_CrcTable) ^ -1024;
	}
	public static Object CrcUpdateT1(Object v, Object data, Object size, Object table) {
		Byte p = (Byte)data;
		Byte pEnd = p + size;
		for (; p != pEnd; p++) {
			v = (table[((v) ^ (p)) & -1024] ^ ((v) >> 8));
		}
		return v;
	}
	public static void CrcGenerateTable() {
		UInt32 i = new UInt32();
		for (i = 0; i < 256; i++) {
			UInt32 r = i;
			int j;
			for (j = 0; j < 8; j++) {
				r = (r >> 1) ^ (-1024 & ((UInt32)0 - (r & 1)));
			}
			ModernizedCProgram.g_CrcTable[i] = r;
		}
		for (i = 256; i < 256 * 8; i++) {
			UInt32 r = ModernizedCProgram.g_CrcTable[(size_t)i - 256];
			ModernizedCProgram.g_CrcTable[i] = ModernizedCProgram.g_CrcTable[r & -1024] ^ (r >> 8);
		}
		ModernizedCProgram.g_CrcUpdateT4 = ModernizedCProgram.CrcUpdateT4;
		ModernizedCProgram.g_CrcUpdate = ModernizedCProgram.CrcUpdateT4;
		ModernizedCProgram.g_CrcUpdateT8 = ModernizedCProgram.CrcUpdateT8;
		if (!ModernizedCProgram.CPU_Is_InOrder()) {
			ModernizedCProgram.g_CrcUpdate = ModernizedCProgram.CrcUpdateT8;
		} 
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int selftest(hashcat_ctx hashcat_ctx, hc_device_param device_param) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = hashcat_ctx.getHashes();
		hashes_t hashes = generatedHashes;
		module_ctx generatedModule_ctx = hashcat_ctx.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = hashcat_ctx.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		Object generatedSt_hash = hashconfig.getSt_hash();
		if (generatedSt_hash == ((Object)0)) {
			return 0;
		} 
		// init : replace hashes with selftest hash
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedKernel_params = device_param.getKernel_params();
		Object generatedCuda_d_st_digests_buf = device_param.getCuda_d_st_digests_buf();
		Object generatedCuda_d_st_salts_buf = device_param.getCuda_d_st_salts_buf();
		Object generatedCuda_d_st_esalts_buf = device_param.getCuda_d_st_esalts_buf();
		if (generatedIs_cuda == true) {
			generatedKernel_params[15] = generatedCuda_d_st_digests_buf;
			generatedKernel_params[17] = generatedCuda_d_st_salts_buf;
			generatedKernel_params[18] = generatedCuda_d_st_esalts_buf;
		} 
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_d_st_digests_buf = device_param.getOpencl_d_st_digests_buf();
		Object generatedOpencl_d_st_salts_buf = device_param.getOpencl_d_st_salts_buf();
		Object generatedOpencl_d_st_esalts_buf = device_param.getOpencl_d_st_esalts_buf();
		if (generatedIs_opencl == true) {
			generatedKernel_params[15] = generatedOpencl_d_st_digests_buf;
			generatedKernel_params[17] = generatedOpencl_d_st_salts_buf;
			generatedKernel_params[18] = generatedOpencl_d_st_esalts_buf;
		} 
		Object generatedKernel_params_buf32 = device_param.getKernel_params_buf32();
		generatedKernel_params_buf32[31] = 1;
		generatedKernel_params_buf32[32] = 0// password : move the known password into a fake buffer;// password : move the known password into a fake buffer
		u32 module_opts_type = .UNRECOGNIZEDFUNCTIONNAME(hashconfig, user_options, user_options_extra);
		pw_t tmp = new pw_t();
		.memset(tmp, 0, );
		Object generatedI = tmp.getI();
		byte tmp_ptr = (byte)generatedI;
		Object generatedSt_pass = hashconfig.getSt_pass();
		size_t tmp_len = .strlen(generatedSt_pass);
		if (module_opts_type & opts_type.OPTS_TYPE_PT_HEX) {
			tmp.setPw_len(ModernizedCProgram.hex_decode((u8)generatedSt_pass, (int)tmp_len, (u8)tmp_ptr));
		} else {
				.memcpy(tmp_ptr, generatedSt_pass, tmp_len);
				tmp.setPw_len((u32)tmp_len);
		} 
		u32 highest_pw_len = 0;
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		Object generatedAttack_exec = hashconfig.getAttack_exec();
		Object generatedPw_len = tmp.getPw_len();
		Object generatedCuda_d_pws_buf = device_param.getCuda_d_pws_buf();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedOpencl_d_pws_buf = device_param.getOpencl_d_pws_buf();
		Object generatedAttack_kern = user_options_extra.getAttack_kern();
		Object generatedOpts_type = hashconfig.getOpts_type();
		Object generatedCuda_d_combs_c = device_param.getCuda_d_combs_c();
		Object generatedOpencl_d_combs_c = device_param.getOpencl_d_combs_c();
		Object generatedCuda_d_bfs_c = device_param.getCuda_d_bfs_c();
		Object generatedOpencl_d_bfs_c = device_param.getOpencl_d_bfs_c();
		Object generatedOpti_type = hashconfig.getOpti_type();
		salt generatedSt_salts_buf = hashes.getSt_salts_buf();
		if (generatedSlow_candidates == true) {
			if (generatedAttack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
				generatedKernel_params_buf32[30] = 1;
			} 
			pw_t pw = new pw_t();
			.memset(pw, 0, );
			byte pw_ptr = (byte)generatedI;
			size_t pw_len = generatedPw_len;
			.memcpy(pw_ptr, tmp_ptr, pw_len);
			pw.setPw_len((u32)pw_len);
			if (generatedIs_cuda == true) {
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_buf, pw, 1 * ) == -1) {
					return -1;
				} 
			} 
			if (generatedIs_opencl == true) {
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_buf, CL_TRUE, 0, 1 * , pw, 0, ((Object)0), ((Object)0)) == -1) {
					return -1;
				} 
			} 
		} else {
				if (generatedAttack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
					if (generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
						generatedKernel_params_buf32[30] = 1;
						pw_t pw = new pw_t();
						.memset(pw, 0, );
						byte pw_ptr = (byte)generatedI;
						size_t pw_len = generatedPw_len;
						.memcpy(pw_ptr, tmp_ptr, pw_len);
						pw.setPw_len((u32)pw_len);
						if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UPPER) {
							ModernizedCProgram.uppercase((u8)pw_ptr, generatedPw_len);
						} 
						if (generatedIs_cuda == true) {
							if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_buf, pw, 1 * ) == -1) {
								return -1;
							} 
						} 
						if (generatedIs_opencl == true) {
							if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_buf, CL_TRUE, 0, 1 * , pw, 0, ((Object)0), ((Object)0)) == -1) {
								return -1;
							} 
						} 
					}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
						generatedKernel_params_buf32[30] = 1;
						generatedKernel_params_buf32[33] = combinator_mode.COMBINATOR_MODE_BASE_LEFT;
						pw_t pw = new pw_t();
						.memset(pw, 0, );
						byte pw_ptr = (byte)generatedI;
						size_t pw_len = generatedPw_len;
						.memcpy(pw_ptr, tmp_ptr, pw_len - 1);
						pw.setPw_len((u32)pw_len - 1);
						if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UPPER) {
							ModernizedCProgram.uppercase((u8)pw_ptr, generatedPw_len);
						} 
						pw_t comb = new pw_t();
						.memset(comb, 0, );
						byte comb_ptr = (byte)generatedI;
						.memcpy(comb_ptr, tmp_ptr + pw_len - 1, 1);
						comb.setPw_len(1);
						if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UPPER) {
							ModernizedCProgram.uppercase((u8)comb_ptr, generatedPw_len);
						} 
						if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD01) {
							comb_ptr[generatedPw_len] = -1024;
						} 
						if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD06) {
							comb_ptr[generatedPw_len] = -1024;
						} 
						if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD80) {
							comb_ptr[generatedPw_len] = -1024;
						} 
						if (generatedIs_cuda == true) {
							if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_combs_c, comb, 1 * ) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_buf, pw, 1 * ) == -1) {
								return -1;
							} 
						} 
						if (generatedIs_opencl == true) {
							if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_combs_c, CL_TRUE, 0, 1 * , comb, 0, ((Object)0), ((Object)0)) == -1) {
								return -1;
							} 
							if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_buf, CL_TRUE, 0, 1 * , pw, 0, ((Object)0), ((Object)0)) == -1) {
								return -1;
							} 
						} 
					}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_BF) {
						generatedKernel_params_buf32[30] = 1;
						if (generatedOpts_type & opts_type.OPTS_TYPE_PT_BITSLICE) {
							pw_t pw = new pw_t();
							.memset(pw, 0, );
							byte pw_ptr = (byte)generatedI;
							size_t pw_len = generatedPw_len;
							.memcpy(pw_ptr, tmp_ptr, pw_len);
							if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UPPER) {
								ModernizedCProgram.uppercase((u8)pw_ptr, pw_len);
							} 
							pw.setPw_len((u32)pw_len);
							if (generatedIs_cuda == true) {
								if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_buf, pw, 1 * ) == -1) {
									return -1;
								} 
							} 
							if (generatedIs_opencl == true) {
								if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_buf, CL_TRUE, 0, 1 * , pw, 0, ((Object)0), ((Object)0)) == -1) {
									return -1;
								} 
							} 
						} else {
								bf_t bf = new bf_t();
								.memset(bf, 0, );
								byte bf_ptr = (byte)generatedI;
								.memcpy(bf_ptr, tmp_ptr, 1);
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UTF16LE) {
									.memset(bf_ptr, 0, 4);
									for (int i = 0;
									int j = 0;
									 i < 1; ) {
										bf_ptr[j + 0] = tmp_ptr[i];
										bf_ptr[j + 1] = 0;
									}
								}  else if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UTF16BE) {
									.memset(bf_ptr, 0, 4);
									for (int i = 0;
									int j = 0;
									 i < 1; ) {
										bf_ptr[j + 0] = 0;
										bf_ptr[j + 1] = tmp_ptr[i];
									}
								} 
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UPPER) {
									ModernizedCProgram.uppercase((u8)bf_ptr, 4);
								} 
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_GENERATE_BE) {
									bf.setI(ModernizedCProgram.byte_swap_32(generatedI));
								} 
								if (generatedIs_cuda == true) {
									if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_bfs_c, bf, 1 * ) == -1) {
										return -1;
									} 
								} 
								if (generatedIs_opencl == true) {
									if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_bfs_c, CL_TRUE, 0, 1 * , bf, 0, ((Object)0), ((Object)0)) == -1) {
										return -1;
									} 
								} 
								pw_t pw = new pw_t();
								.memset(pw, 0, );
								byte pw_ptr = (byte)generatedI;
								size_t pw_len = generatedPw_len;
								.memcpy(pw_ptr + 1, tmp_ptr + 1, pw_len - 1);
								size_t new_pass_len = pw_len;
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UTF16LE) {
									.memset(pw_ptr, 0, pw_len);
									for (size_t i = 1;
									size_t j = 2;
									 i < new_pass_len; ) {
										pw_ptr[j + 0] = tmp_ptr[i];
										pw_ptr[j + 1] = 0;
									}
									new_pass_len *= 2;
								}  else if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UTF16BE) {
									.memset(pw_ptr, 0, pw_len);
									for (size_t i = 1;
									size_t j = 2;
									 i < new_pass_len; ) {
										pw_ptr[j + 0] = 0;
										pw_ptr[j + 1] = tmp_ptr[i];
									}
									new_pass_len *= 2;
								} 
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UPPER) {
									ModernizedCProgram.uppercase((u8)pw_ptr, new_pass_len);
								} 
								if (generatedOpti_type & opti_type.OPTI_TYPE_SINGLE_HASH) {
									if (generatedOpti_type & opti_type.OPTI_TYPE_APPENDED_SALT) {
										.memcpy(pw_ptr + new_pass_len, (byte)generatedSt_salts_buf[0].getSalt_buf(), 64 - new_pass_len);
										new_pass_len += generatedSt_salts_buf[0].getSalt_len();
									} 
								} 
								pw.setPw_len((u32)new_pass_len);
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD01) {
									pw_ptr[new_pass_len] = -1024;
								} 
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD06) {
									pw_ptr[new_pass_len] = -1024;
								} 
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD80) {
									pw_ptr[new_pass_len] = -1024;
								} 
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADDBITS14) {
									generatedI[14] = (u32)new_pass_len * 8;
									generatedI[15] = 0;
								} 
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADDBITS15) {
									generatedI[14] = 0;
									generatedI[15] = (u32)new_pass_len * 8;
								} 
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_GENERATE_BE) {
									for (int i = 0;
									 i < 14; i++) {
										generatedI[i] = ModernizedCProgram.byte_swap_32(generatedI[i]);
									}
								} 
								if (generatedIs_cuda == true) {
									if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_buf, pw, 1 * ) == -1) {
										return -1;
									} 
								} 
								if (generatedIs_opencl == true) {
									if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_buf, CL_TRUE, 0, 1 * , pw, 0, ((Object)0), ((Object)0)) == -1) {
										return -1;
									} 
								} 
								highest_pw_len = generatedPw_len;
						} 
					} 
				} else {
						pw_t pw = new pw_t();
						.memset(pw, 0, );
						byte pw_ptr = (byte)generatedI;
						size_t pw_len = generatedPw_len;
						.memcpy(pw_ptr, tmp_ptr, pw_len);
						pw.setPw_len((u32)pw_len);
						if (generatedIs_cuda == true) {
							if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_buf, pw, 1 * ) == -1) {
								return -1;
							} 
						} 
						if (generatedIs_opencl == true) {
							if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_buf, CL_TRUE, 0, 1 * , pw, 0, ((Object)0), ((Object)0)) == -1) {
								return -1;
							} 
						} 
				} 
		} 
		double generatedSpin_damp = device_param.getSpin_damp();
		// main : run the kerneldouble spin_damp_sav = generatedSpin_damp;
		device_param.setSpin_damp(0);
		Object generatedHooks_buf = device_param.getHooks_buf();
		Object generatedCuda_d_hooks = device_param.getCuda_d_hooks();
		Object generatedSize_hooks = device_param.getSize_hooks();
		Object generatedOpencl_d_hooks = device_param.getOpencl_d_hooks();
		Object generatedSt_hook_salts_buf = hashes.getSt_hook_salts_buf();
		Object generatedKernel_loops_min = hashconfig.getKernel_loops_min();
		Object generatedKernel_loops_max = hashconfig.getKernel_loops_max();
		Object generatedSalt_iter = salt_buf.getSalt_iter();
		Object generatedSalt_iter2 = salt_buf.getSalt_iter2();
		if (generatedAttack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
			if (generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
				if (highest_pw_len < 16) {
					if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_1, 1, 0, 0) == -1) {
						return -1;
					} 
				}  else if (highest_pw_len < 32) {
					if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_2, 1, 0, 0) == -1) {
						return -1;
					} 
				} else {
						if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_3, 1, 0, 0) == -1) {
							return -1;
						} 
				} 
			} else {
					if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_4, 1, 0, 0) == -1) {
						return -1;
					} 
			} 
		} else {
				if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_1, 1, 0, 0) == -1) {
					return -1;
				} 
				if (generatedOpts_type & opts_type.OPTS_TYPE_HOOK12) {
					if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_12, 1, 0, 0) == -1) {
						return -1;
					} 
					if (generatedIs_cuda == true) {
						if (hashcat_ctx.hc_cuMemcpyDtoH(generatedHooks_buf, generatedCuda_d_hooks, generatedSize_hooks) == -1) {
							return -1;
						} 
					} 
					if (generatedIs_opencl == true) {
						if (hashcat_ctx.hc_clEnqueueReadBuffer(generatedOpencl_command_queue, generatedOpencl_d_hooks, CL_TRUE, 0, generatedSize_hooks, generatedHooks_buf, 0, ((Object)0), ((Object)0)) == -1) {
							return -1;
						} 
					} 
					.UNRECOGNIZEDFUNCTIONNAME(device_param, generatedSt_hook_salts_buf, 0, 1);
					if (generatedIs_cuda == true) {
						if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_hooks, generatedHooks_buf, generatedSize_hooks) == -1) {
							return -1;
						} 
					} 
					if (generatedIs_opencl == true) {
						if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_hooks, CL_TRUE, 0, generatedSize_hooks, generatedHooks_buf, 0, ((Object)0), ((Object)0)) == -1) {
							return -1;
						} 
					} 
				} 
				u32 salt_pos = 0;
				salt_t salt_buf = generatedSt_salts_buf[salt_pos];
				u32 loop_step = generatedKernel_loops_min + ((generatedKernel_loops_max - generatedKernel_loops_min) / 32);
				u32 iter = generatedSalt_iter;
				for (u32 loop_pos = 0;
				 loop_pos < iter; loop_pos += loop_step) {
					u32 loop_left = iter - loop_pos;
					loop_left = (((loop_left) < (loop_step)) ? (loop_left) : (loop_step));
					generatedKernel_params_buf32[28] = loop_pos;
					generatedKernel_params_buf32[29] = loop_left;
					if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_2, 1, 0, 0) == -1) {
						return -1;
					} 
				}
				if (generatedOpts_type & opts_type.OPTS_TYPE_HOOK23) {
					if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_23, 1, 0, 0) == -1) {
						return -1;
					} 
					if (generatedIs_cuda == true) {
						if (hashcat_ctx.hc_cuMemcpyDtoH(generatedHooks_buf, generatedCuda_d_hooks, generatedSize_hooks) == -1) {
							return -1;
						} 
					} 
					if (generatedIs_opencl == true) {
						if (hashcat_ctx.hc_clEnqueueReadBuffer(generatedOpencl_command_queue, generatedOpencl_d_hooks, CL_TRUE, 0, generatedSize_hooks, generatedHooks_buf, 0, ((Object)0), ((Object)0)) == -1) {
							return -1;
						} 
					} 
					.UNRECOGNIZEDFUNCTIONNAME(device_param, generatedSt_hook_salts_buf, 0, 1);
					if (generatedIs_cuda == true) {
						if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_hooks, generatedHooks_buf, generatedSize_hooks) == -1) {
							return -1;
						} 
					} 
					if (generatedIs_opencl == true) {
						if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_hooks, CL_TRUE, 0, generatedSize_hooks, generatedHooks_buf, 0, ((Object)0), ((Object)0)) == -1) {
							return -1;
						} 
					} 
				} 
				if (generatedOpts_type & opts_type.OPTS_TYPE_INIT2) {
					if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_INIT2, 1, 0, 0) == -1) {
						return -1;
					} 
				} 
				if (generatedOpts_type & opts_type.OPTS_TYPE_LOOP2) {
					u32 iter2 = generatedSalt_iter2;
					for (u32 loop_pos = 0;
					 loop_pos < iter2; loop_pos += loop_step) {
						u32 loop_left = iter2 - loop_pos;
						loop_left = (((loop_left) < (loop_step)) ? (loop_left) : (loop_step));
						generatedKernel_params_buf32[28] = loop_pos;
						generatedKernel_params_buf32[29] = loop_left;
						if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_LOOP2, 1, 0, 0) == -1) {
							return -1;
						} 
					}
				} 
				if (generatedOpts_type & opts_type.OPTS_TYPE_DEEP_COMP_KERNEL) {
					generatedKernel_params_buf32[28] = 0;
					generatedKernel_params_buf32[29] = 1;
					if (generatedOpts_type & opts_type.OPTS_TYPE_AUX1) {
						if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_AUX1, 1, 0, 0) == -1) {
							return -1;
						} 
					}  else if (generatedOpts_type & opts_type.OPTS_TYPE_AUX2) {
						if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_AUX2, 1, 0, 0) == -1) {
							return -1;
						} 
					}  else if (generatedOpts_type & opts_type.OPTS_TYPE_AUX3) {
						if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_AUX3, 1, 0, 0) == -1) {
							return -1;
						} 
					} else {
							if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_3, 1, 0, 0) == -1) {
								return -1;
							} 
					} 
				} else {
						if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_3, 1, 0, 0) == -1) {
							return -1;
						} 
				} 
		} 
		device_param.setSpin_damp(spin_damp_sav)// check : check if cracked;// check : check if cracked
		u32 num_cracked = new u32();
		Object generatedCuda_d_result = device_param.getCuda_d_result();
		if (generatedIs_cuda == true) {
			if (hashcat_ctx.hc_cuMemcpyDtoH(num_cracked, generatedCuda_d_result, ) == -1) {
				return -1;
			} 
		} 
		Object generatedOpencl_d_result = device_param.getOpencl_d_result();
		if (generatedIs_opencl == true) {
			if (hashcat_ctx.hc_clEnqueueReadBuffer(generatedOpencl_command_queue, generatedOpencl_d_result, CL_TRUE, 0, , num_cracked, 0, ((Object)0), ((Object)0)) == -1) {
				return -1;
			} 
		} 
		// finish : cleanup and restore// finish : cleanup and restoregeneratedKernel_params_buf32[27] = 0;
		generatedKernel_params_buf32[28] = 0;
		generatedKernel_params_buf32[29] = 0;
		generatedKernel_params_buf32[30] = 0;
		generatedKernel_params_buf32[31] = 0;
		generatedKernel_params_buf32[32] = 0;
		generatedKernel_params_buf32[33] = 0;
		Object generatedKernel_params_buf64 = device_param.getKernel_params_buf64();
		generatedKernel_params_buf64[34] = 0;
		Object generatedCuda_d_digests_buf = device_param.getCuda_d_digests_buf();
		Object generatedCuda_d_salt_bufs = device_param.getCuda_d_salt_bufs();
		Object generatedCuda_d_esalt_bufs = device_param.getCuda_d_esalt_bufs();
		Object generatedSize_pws = device_param.getSize_pws();
		Object generatedCuda_d_tmps = device_param.getCuda_d_tmps();
		Object generatedSize_tmps = device_param.getSize_tmps();
		Object generatedCuda_d_plain_bufs = device_param.getCuda_d_plain_bufs();
		Object generatedSize_plains = device_param.getSize_plains();
		Object generatedCuda_d_digests_shown = device_param.getCuda_d_digests_shown();
		Object generatedSize_shown = device_param.getSize_shown();
		Object generatedSize_results = device_param.getSize_results();
		if (generatedIs_cuda == true) {
			generatedKernel_params[15] = generatedCuda_d_digests_buf;
			generatedKernel_params[17] = generatedCuda_d_salt_bufs;
			generatedKernel_params[18] = generatedCuda_d_esalt_bufs;
			if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_pws_buf, generatedSize_pws) == -1) {
				return -1;
			} 
			if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_tmps, generatedSize_tmps) == -1) {
				return -1;
			} 
			if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_hooks, generatedSize_hooks) == -1) {
				return -1;
			} 
			if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_plain_bufs, generatedSize_plains) == -1) {
				return -1;
			} 
			if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_digests_shown, generatedSize_shown) == -1) {
				return -1;
			} 
			if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_result, generatedSize_results) == -1) {
				return -1;
			} 
		} 
		Object generatedOpencl_d_digests_buf = device_param.getOpencl_d_digests_buf();
		Object generatedOpencl_d_salt_bufs = device_param.getOpencl_d_salt_bufs();
		Object generatedOpencl_d_esalt_bufs = device_param.getOpencl_d_esalt_bufs();
		Object generatedOpencl_d_tmps = device_param.getOpencl_d_tmps();
		Object generatedOpencl_d_plain_bufs = device_param.getOpencl_d_plain_bufs();
		Object generatedOpencl_d_digests_shown = device_param.getOpencl_d_digests_shown();
		if (generatedIs_opencl == true) {
			generatedKernel_params[15] = generatedOpencl_d_digests_buf;
			generatedKernel_params[17] = generatedOpencl_d_salt_bufs;
			generatedKernel_params[18] = generatedOpencl_d_esalt_bufs;
			if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_pws_buf, generatedSize_pws) == -1) {
				return -1;
			} 
			if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_tmps, generatedSize_tmps) == -1) {
				return -1;
			} 
			if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_hooks, generatedSize_hooks) == -1) {
				return -1;
			} 
			if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_plain_bufs, generatedSize_plains) == -1) {
				return -1;
			} 
			if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_digests_shown, generatedSize_shown) == -1) {
				return -1;
			} 
			if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_result, generatedSize_results) == -1) {
				return -1;
			} 
		} 
		Object generatedCuda_d_rules_c = device_param.getCuda_d_rules_c();
		Object generatedSize_rules_c = device_param.getSize_rules_c();
		Object generatedOpencl_d_rules_c = device_param.getOpencl_d_rules_c();
		Object generatedSize_combs = device_param.getSize_combs();
		Object generatedSize_bfs = device_param.getSize_bfs();
		if (generatedSlow_candidates == true) {
			if (generatedIs_cuda == true) {
				if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_rules_c, generatedSize_rules_c) == -1) {
					return -1;
				} 
			} 
			if (generatedIs_opencl == true) {
				if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_rules_c, generatedSize_rules_c) == -1) {
					return -1;
				} 
			} 
		} else {
				if (generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
					if (generatedIs_cuda == true) {
						if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_rules_c, generatedSize_rules_c) == -1) {
							return -1;
						} 
					} 
					if (generatedIs_opencl == true) {
						if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_rules_c, generatedSize_rules_c) == -1) {
							return -1;
						} 
					} 
				}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
					if (generatedIs_cuda == true) {
						if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_combs_c, generatedSize_combs) == -1) {
							return -1;
						} 
					} 
					if (generatedIs_opencl == true) {
						if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_combs_c, generatedSize_combs) == -1) {
							return -1;
						} 
					} 
				}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_BF) {
					if (generatedIs_cuda == true) {
						if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_bfs_c, generatedSize_bfs) == -1) {
							return -1;
						} 
					} 
					if (generatedIs_opencl == true) {
						if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_bfs_c, generatedSize_bfs) == -1) {
							return -1;
						} 
					} 
				} 
		} 
		Object generatedMux_display = status_ctx.getMux_display();
		int generatedDevice_id = device_param.getDevice_id();
		// check returnif (num_cracked == 0) {
			.WaitForSingleObject(generatedMux_display, -1024);
			if (generatedIs_opencl == true) {
				hashcat_ctx.event_log_error("* Device #%u: ATTENTION! OpenCL kernel self-test failed.", generatedDevice_id + 1);
			} 
			if (generatedIs_cuda == true) {
				hashcat_ctx.event_log_error("* Device #%u: ATTENTION! CUDA kernel self-test failed.", generatedDevice_id + 1);
			} 
			hashcat_ctx.event_log_warning("Your device driver installation is probably broken.");
			hashcat_ctx.event_log_warning("See also: https://hashcat.net/faq/wrongdriver");
			hashcat_ctx.event_log_warning(((Object)0));
			.ReleaseMutex(generatedMux_display);
			return -1;
		} 
		return 0;
	}
	public static Object thread_selftest(Object p) {
		thread_param_t thread_param = (thread_param_t)p;
		hashcat_ctx generatedHashcat_ctx = thread_param.getHashcat_ctx();
		hashcat_ctx_t hashcat_ctx = generatedHashcat_ctx;
		backend_ctx generatedBackend_ctx = hashcat_ctx.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return ((Object)0);
		} 
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedSelf_test_disable = user_options.getSelf_test_disable();
		if (generatedSelf_test_disable == true) {
			return ((Object)0);
		} 
		hc_device_param generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedTid = thread_param.getTid();
		hc_device_param_t device_param = generatedDevices_param + generatedTid;
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped == true) {
			return ((Object)0);
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return ((Object)0);
		} 
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_context = device_param.getCuda_context();
		if (generatedIs_cuda == true) {
			if (hashcat_ctx.hc_cuCtxSetCurrent(generatedCuda_context) == -1) {
				return ((Object)0);
			} 
		} 
		int rc_selftest = ModernizedCProgram.selftest(hashcat_ctx, device_param);
		boolean generatedBenchmark = user_options.getBenchmark();
		if (generatedBenchmark == true) {
			device_param.setSt_status(st_status_rc.ST_STATUS_IGNORED);
		} else {
				if (rc_selftest == 0) {
					device_param.setSt_status(st_status_rc.ST_STATUS_PASSED);
				} else {
						device_param.setSt_status(st_status_rc.ST_STATUS_FAILED);
				} 
		} 
		return ((Object)0);
	}
	public static int brain_logging(Object client_idx, Object format) {
		double ms = ModernizedCProgram.hc_timer_get(ModernizedCProgram.timer_logging);
		ModernizedCProgram.hc_timer_set(ModernizedCProgram.timer_logging);
		.WaitForSingleObject(ModernizedCProgram.mux_display, -1024);
		timeval v = new timeval();
		.gettimeofday(v, ((Object)0));
		Object generatedTv_sec = v.getTv_sec();
		Object generatedTv_usec = v.getTv_usec();
		.fprintf(stream, "%u.%06u | %6.2fs | %3d | ", (u32)generatedTv_sec, (u32)generatedTv_usec, ms / 1000, client_idx);
		va_list ap = new va_list();
		.__builtin_va_start(ap, format);
		int len = .vfprintf(stream, format, ap);
		.__builtin_va_end(ap);
		.ReleaseMutex(ModernizedCProgram.mux_display);
		return len;
	}
	public static Object brain_compute_attack_wordlist(Object filename) {
		XXH64_state_t state = ModernizedCProgram.XXH64_createState();
		state.XXH64_reset(0);
		byte[] buf = new byte[8192];
		HCFILE fp = new HCFILE();
		fp.hc_fopen(filename, "rb");
		while (!fp.hc_feof()) {
			.memset(buf, 0, );
			size_t nread = fp.hc_fread(buf, 1, 8192);
			state.XXH64_update(buf, nread);
		}
		fp.hc_fclose();
		u64 hash = ModernizedCProgram.XXH64_digest(state);
		state.XXH64_freeState();
		return hash;
	}
	public static Object brain_auth_hash(Object challenge, Object pw_buf, Object pw_len) {
		// nothing for production but good enough for testingu64 response = ModernizedCProgram.XXH64(pw_buf, pw_len, challenge);
		for (int i = 0;
		 i < 100000; i++) {
			response = ModernizedCProgram.XXH64(response, 8, 0);
		}
		return response;
	}
	public static Object brain_auth_challenge() {
		.srand(.time(((Object)0)));
		// just a fallback valueu32 val = .rand();
		// fromHCRYPTPROV hCryptProv = new HCRYPTPROV();
		if (.CryptAcquireContextA(hCryptProv, ((Object)0), ((Object)0), 1, 0) == 1) {
			if (.CryptGenRandom(hCryptProv, , (BYTE)val) == 1) {
			} else {
					(_iob[2]).brain_logging(0, "CryptGenRandom: %d\n", (int).GetLastError());
					return val;
			} 
			.CryptReleaseContext(hCryptProv, 0);
		} else {
				(_iob[2]).brain_logging(0, "CryptAcquireContext: %d\n", (int).GetLastError());
				return val;
		} 
		return val;
	}
	public static int brain_connect(int sockfd, Object addr, Object addrlen, Object timeout) {
		if (timeout == 99999999) {
		} 
		// timeout not support on windows
		if (.connect(sockfd, addr, addrlen) == (true)) {
			int err = .WSAGetLastError();
			byte[] msg = new byte[256];
			.memset(msg, 0, );
			.FormatMessageA(4096 | 512, ((Object)0), err, ((((WORD)(true)) << 10) | (WORD)(true)), msg, , ((Object)0));
			(_iob[2]).brain_logging(0, "connect: %s\n", msg);
			return -1;
		} 
		return 0;
	}
	public static void brain_client_generate_hash(Object hash, Object line_buf, Object line_len) {
		u64 seed = 0;
		hash[0] = ModernizedCProgram.XXH64(line_buf, line_len, seed);
	}
	public static Object brain_server_highest_attack(Object buf) {
		brain_server_attack_long_t long_buf = buf.getLong_buf();
		brain_server_attack_short_t short_buf = buf.getShort_buf();
		u64 long_cnt = buf.getLong_cnt();
		u64 short_cnt = buf.getShort_cnt();
		u64 highest_long = ModernizedCProgram.brain_server_highest_attack_long(long_buf, long_cnt, 0);
		u64 highest_short = ModernizedCProgram.brain_server_highest_attack_short(short_buf, short_cnt, 0);
		u64 highest = (((highest_long) > (highest_short)) ? (highest_long) : (highest_short));
		highest_long = ModernizedCProgram.brain_server_highest_attack_long(long_buf, long_cnt, highest);
		highest_short = ModernizedCProgram.brain_server_highest_attack_short(short_buf, short_cnt, highest);
		highest = (((highest_long) > (highest_short)) ? (highest_long) : (highest_short));
		return highest;
	}
	public static Object brain_server_highest_attack_long(Object buf, Object cnt, Object start) {
		u64 highest = start;
		for (i64 idx = 0;
		 idx < cnt; idx++) {
			u64 offset = buf[idx].getOffset();
			u64 length = buf[idx].getLength();
			if (offset > highest) {
				break;
			} 
			u64 next = offset + length;
			highest = (((highest) > (next)) ? (highest) : (next));
		}
		return highest;
	}
	public static Object brain_server_highest_attack_short(Object buf, Object cnt, Object start) {
		u64 highest = start;
		for (i64 idx = 0;
		 idx < cnt; idx++) {
			u64 offset = buf[idx].getOffset();
			u64 length = buf[idx].getLength();
			if (offset > highest) {
				break;
			} 
			u64 next = offset + length;
			highest = (((highest) > (next)) ? (highest) : (next));
		}
		return highest;
	}
	public static Object brain_server_find_attack_long(Object buf, Object cnt, Object offset, Object length) {
		u64 end = offset + length;
		u64 overlap = 0;
		for (i64 idx = 0;
		 idx < cnt; idx++) {
			u64 element_length = buf[idx].getLength();
			if (element_length == 0) {
				continue;
			} 
			u64 element_start = buf[idx].getOffset();
			u64 element_end = element_start + element_length;
			u64 start = offset + overlap;
			if (element_start > start) {
				break;
			} 
			if (element_end > start) {
				u64 limited_end = (((end) < (element_end)) ? (end) : (element_end));
				overlap += limited_end - start;
				if (overlap == length) {
					break;
				} 
			} 
		}
		return overlap;
	}
	public static Object brain_server_find_attack_short(Object buf, Object cnt, Object offset, Object length) {
		u64 end = offset + length;
		u64 overlap = 0;
		for (i64 idx = 0;
		 idx < cnt; idx++) {
			u64 element_length = buf[idx].getLength();
			if (element_length == 0) {
				continue;
			} 
			u64 element_start = buf[idx].getOffset();
			u64 element_end = element_start + element_length;
			u64 start = offset + overlap;
			if (element_start > start) {
				break;
			} 
			if (element_end > start) {
				u64 limited_end = (((end) < (element_end)) ? (end) : (element_end));
				overlap += limited_end - start;
				if (overlap == length) {
					break;
				} 
			} 
		}
		return overlap;
	}
	public static int brain_server_sort_db_hash(Object v1, Object v2) {
		brain_server_db_hash_t d1 = (brain_server_db_hash_t)v1;
		brain_server_db_hash_t d2 = (brain_server_db_hash_t)v2;
		if (d1.getBrain_session() > d2.getBrain_session()) {
			return 1;
		} 
		if (d1.getBrain_session() < d2.getBrain_session()) {
			return -1;
		} 
		return 0;
	}
	public static int brain_server_sort_db_attack(Object v1, Object v2) {
		brain_server_db_attack_t d1 = (brain_server_db_attack_t)v1;
		brain_server_db_attack_t d2 = (brain_server_db_attack_t)v2;
		if (d1.getBrain_attack() > d2.getBrain_attack()) {
			return 1;
		} 
		if (d1.getBrain_attack() < d2.getBrain_attack()) {
			return -1;
		} 
		return 0;
	}
	public static int brain_server_sort_hash(Object v1, Object v2) {
		u32 d1 = (u32)v1;
		u32 d2 = (u32)v2;
		if (d1[1] > d2[1]) {
			return 1;
		} 
		if (d1[1] < d2[1]) {
			return -1;
		} 
		if (d1[0] > d2[0]) {
			return 1;
		} 
		if (d1[0] < d2[0]) {
			return -1;
		} 
		return 0;
	}
	public static int brain_server_sort_attack_long(Object v1, Object v2) {
		brain_server_attack_long_t d1 = (brain_server_attack_long_t)v1;
		brain_server_attack_long_t d2 = (brain_server_attack_long_t)v2;
		if (d1.getOffset() > d2.getOffset()) {
			return 1;
		} 
		if (d1.getOffset() < d2.getOffset()) {
			return -1;
		} 
		return 0;
	}
	public static int brain_server_sort_attack_short(Object v1, Object v2) {
		brain_server_attack_short_t d1 = (brain_server_attack_short_t)v1;
		brain_server_attack_short_t d2 = (brain_server_attack_short_t)v2;
		if (d1.getOffset() > d2.getOffset()) {
			return 1;
		} 
		if (d1.getOffset() < d2.getOffset()) {
			return -1;
		} 
		return 0;
	}
	public static int brain_server_sort_hash_long(Object v1, Object v2) {
		brain_server_hash_long_t d1 = (brain_server_hash_long_t)v1;
		brain_server_hash_long_t d2 = (brain_server_hash_long_t)v2;
		return ModernizedCProgram.brain_server_sort_hash(d1.getHash(), d2.getHash());
	}
	public static int brain_server_sort_hash_short(Object v1, Object v2) {
		brain_server_hash_short_t d1 = (brain_server_hash_short_t)v1;
		brain_server_hash_short_t d2 = (brain_server_hash_short_t)v2;
		return ModernizedCProgram.brain_server_sort_hash(d1.getHash(), d2.getHash());
	}
	public static int brain_server_sort_hash_unique(Object v1, Object v2) {
		brain_server_hash_unique_t d1 = (brain_server_hash_unique_t)v1;
		brain_server_hash_unique_t d2 = (brain_server_hash_unique_t)v2;
		return ModernizedCProgram.brain_server_sort_hash(d1.getHash(), d2.getHash());
	}
	public static Object brain_server_find_hash_long(Object search, Object buf, Object cnt) {
		for (i64 l = 0;
		i64 r = cnt;
		 r; r >>=  1) {
			i64 m = r >> 1;
			i64 c = l + m;
			int cmp = ModernizedCProgram.brain_server_sort_hash_long(search, buf + c);
			if (cmp > 0) {
				l += m + 1;
				r--;
			} 
			if (cmp == 0) {
				return c;
			} 
		}
		return -1;
	}
	public static Object brain_server_find_hash_short(Object search, Object buf, Object cnt) {
		for (i64 l = 0;
		i64 r = cnt;
		 r; r >>=  1) {
			i64 m = r >> 1;
			i64 c = l + m;
			int cmp = ModernizedCProgram.brain_server_sort_hash_short(search, buf + c);
			if (cmp > 0) {
				l += m + 1;
				r--;
			} 
			if (cmp == 0) {
				return c;
			} 
		}
		return -1;
	}
	public static void brain_server_handle_signal(int signo) {
		if (signo == 2) {
			ModernizedCProgram.keep_running = 0;
		} 
	}
	public static Object brain_server_handle_dumps(Object p) {
		brain_server_dumper_options_t brain_server_dumper_options = (brain_server_dumper_options_t)p;
		brain_server_dbs generatedBrain_server_dbs = brain_server_dumper_options.getBrain_server_dbs();
		brain_server_dbs_t brain_server_dbs = generatedBrain_server_dbs;
		int i = 0;
		while (ModernizedCProgram.keep_running == 1) {
			if (i == ModernizedCProgram.BRAIN_SERVER_DUMP_EVERY) {
				brain_server_dbs.brain_server_write_hash_dumps(".");
				brain_server_dbs.brain_server_write_attack_dumps(".");
				i = 0;
			} else {
					i++;
			} 
			.sleep(1);
		}
		return ((Object)0);
	}
	public static Object brain_server_handle_client(Object p) {
		brain_server_client_options_t brain_server_client_options = (brain_server_client_options_t)p;
		int generatedClient_idx = brain_server_client_options.getClient_idx();
		int client_idx = generatedClient_idx;
		int generatedClient_fd = brain_server_client_options.getClient_fd();
		int client_fd = generatedClient_fd;
		Byte generatedAuth_password = brain_server_client_options.getAuth_password();
		byte auth_password = generatedAuth_password;
		Object generatedSession_whitelist_buf = brain_server_client_options.getSession_whitelist_buf();
		u32 session_whitelist_buf = generatedSession_whitelist_buf;
		int generatedSession_whitelist_cnt = brain_server_client_options.getSession_whitelist_cnt();
		int session_whitelist_cnt = generatedSession_whitelist_cnt;
		brain_server_dbs generatedBrain_server_dbs = brain_server_client_options.getBrain_server_dbs();
		brain_server_dbs_t brain_server_dbs = generatedBrain_server_dbs;
		// client configuration
		u32 brain_link_version = 0;
		Integer generatedClient_slots = brain_server_dbs.getClient_slots();
		if (((Object)0).brain_recv(client_fd, brain_link_version, , 0, ((Object)0)) == 0) {
			(_iob[2]).brain_logging(client_idx, "brain_recv: %s\n", .strerror((._errno())));
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		u32 brain_link_version_ok = (brain_link_version >= (u32)ModernizedCProgram.BRAIN_LINK_VERSION_MIN) ? 1 : 0;
		if (((Object)0).brain_send(client_fd, brain_link_version_ok, , 0, ((Object)0)) == 0) {
			(_iob[2]).brain_logging(client_idx, "brain_send: %s\n", .strerror((._errno())));
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		if (brain_link_version_ok == 0) {
			(_iob[2]).brain_logging(client_idx, "Invalid version\n");
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		u32 challenge = ModernizedCProgram.brain_auth_challenge();
		if (((Object)0).brain_send(client_fd, challenge, , 0, ((Object)0)) == 0) {
			(_iob[2]).brain_logging(client_idx, "brain_send: %s\n", .strerror((._errno())));
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		u64 response = 0;
		if (((Object)0).brain_recv(client_fd, response, , 0, ((Object)0)) == 0) {
			(_iob[2]).brain_logging(client_idx, "brain_recv: %s\n", .strerror((._errno())));
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		u64 auth_hash = ModernizedCProgram.brain_auth_hash(challenge, auth_password, .strlen(auth_password));
		u32 password_ok = (auth_hash == response) ? 1 : 0;
		if (((Object)0).brain_send(client_fd, password_ok, , 0, ((Object)0)) == 0) {
			(_iob[2]).brain_logging(client_idx, "brain_send: %s\n", .strerror((._errno())));
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		if (password_ok == 0) {
			(_iob[2]).brain_logging(client_idx, "Invalid password\n");
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		u32 brain_session = 0;
		if (((Object)0).brain_recv(client_fd, brain_session, , 0, ((Object)0)) == 0) {
			(_iob[2]).brain_logging(client_idx, "brain_recv: %s\n", .strerror((._errno())));
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		if (session_whitelist_cnt > 0) {
			boolean found = false;
			for (int idx = 0;
			 idx < session_whitelist_cnt; idx++) {
				if (session_whitelist_buf[idx] == brain_session) {
					found = true;
					break;
				} 
			}
			if (found == false) {
				(_iob[2]).brain_logging(client_idx, "Invalid brain session: 0x%08x\n", brain_session);
				generatedClient_slots[client_idx] = 0;
				ModernizedCProgram.close(client_fd);
				return ((Object)0);
			} 
		} 
		u32 brain_attack = 0;
		if (((Object)0).brain_recv(client_fd, brain_attack, , 0, ((Object)0)) == 0) {
			(_iob[2]).brain_logging(client_idx, "brain_recv: %s\n", .strerror((._errno())));
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		i64 passwords_max = 0;
		if (((Object)0).brain_recv(client_fd, passwords_max, , 0, ((Object)0)) == 0) {
			(_iob[2]).brain_logging(client_idx, "brain_recv: %s\n", .strerror((._errno())));
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		if (passwords_max >= ModernizedCProgram.BRAIN_LINK_CANDIDATES_MAX) {
			(_iob[2]).brain_logging(client_idx, "Too large candidate allocation buffer size\n");
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		(_iob[1]).brain_logging(client_idx, "Session: 0x%08x, Attack: 0x%08x, Kernel-power: %I64u\n", brain_session, brain_attack, passwords_max)// so far so good;// so far so good
		Object generatedMux_dbs = brain_server_dbs.getMux_dbs();
		.WaitForSingleObject(generatedMux_dbs, -1024)// long term memory;// long term memory
		brain_server_db_hash_t key_hash = new brain_server_db_hash_t();
		key_hash.setBrain_session(brain_session);
		int generatedHash_cnt = brain_server_dbs.getHash_cnt();
		int find_hash_cnt = (int)generatedHash_cnt;
		brain_server_db_hash generatedHash_buf = brain_server_dbs.getHash_buf();
		brain_server_db_hash_t brain_server_db_hash = (brain_server_db_hash_t).lfind(key_hash, generatedHash_buf, find_hash_cnt, , ModernizedCProgram.brain_server_sort_db_hash);
		if (brain_server_db_hash == ((Object)0)) {
			if (generatedHash_cnt >= ModernizedCProgram.BRAIN_SERVER_SESSIONS_MAX) {
				(_iob[2]).brain_logging(0, "too many sessions\n");
				generatedClient_slots[client_idx] = 0;
				ModernizedCProgram.close(client_fd);
				return ((Object)0);
			} 
			brain_server_db_hash = generatedHash_buf[generatedHash_cnt];
			brain_server_db_hash.brain_server_db_hash_init(brain_session);
			generatedHash_cnt++;
		} 
		// attack memorybrain_server_db_attack_t key_attack = new brain_server_db_attack_t();
		key_attack.setBrain_attack(brain_attack);
		int generatedAttack_cnt = brain_server_dbs.getAttack_cnt();
		int find_attack_cnt = (int)generatedAttack_cnt;
		brain_server_db_attack generatedAttack_buf = brain_server_dbs.getAttack_buf();
		brain_server_db_attack_t brain_server_db_attack = (brain_server_db_attack_t).lfind(key_attack, generatedAttack_buf, find_attack_cnt, , ModernizedCProgram.brain_server_sort_db_attack);
		if (brain_server_db_attack == ((Object)0)) {
			if (generatedAttack_cnt >= ModernizedCProgram.BRAIN_SERVER_ATTACKS_MAX) {
				(_iob[2]).brain_logging(0, "too many attacks\n");
				generatedClient_slots[client_idx] = 0;
				ModernizedCProgram.close(client_fd);
				return ((Object)0);
			} 
			brain_server_db_attack = generatedAttack_buf[generatedAttack_cnt];
			brain_server_db_attack.brain_server_db_attack_init(brain_attack);
			generatedAttack_cnt++;
		} 
		.ReleaseMutex(generatedMux_dbs)// higest position of that attack;// higest position of that attack
		u64 highest = ModernizedCProgram.brain_server_highest_attack(brain_server_db_attack);
		if (((Object)0).brain_send(client_fd, highest, , 0, ((Object)0)) == 0) {
			(_iob[2]).brain_logging(client_idx, "brain_send: %s\n", .strerror((._errno())));
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		// recvsize_t recv_size = passwords_max * ModernizedCProgram.BRAIN_HASH_SIZE;
		u32 recv_buf = (u32)ModernizedCProgram.hcmalloc(recv_size);
		if (recv_buf == ((Object)0)) {
			(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
			return ((Object)0);
		} 
		// sendsize_t send_size = passwords_max * ;
		// we can reduce this to 1/8 if we use bits instead of bytesu8 send_buf = (u8)ModernizedCProgram.hcmalloc(send_size);
		if (send_buf == ((Object)0)) {
			(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		// tempbrain_server_hash_unique_t temp_buf = (brain_server_hash_unique_t)ModernizedCProgram.hccalloc(passwords_max, );
		if (temp_buf == ((Object)0)) {
			(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		// short global allocbrain_server_db_short_t brain_server_db_short = ModernizedCProgram.hcmalloc();
		brain_server_db_short.setShort_cnt(0);
		brain_server_db_short.setShort_buf((brain_server_hash_short_t)ModernizedCProgram.hccalloc(passwords_max, ));
		brain_server_hash_short generatedShort_buf = brain_server_db_short.getShort_buf();
		if (generatedShort_buf == ((Object)0)) {
			(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
			generatedClient_slots[client_idx] = 0;
			ModernizedCProgram.close(client_fd);
			return ((Object)0);
		} 
		Object generatedMux_ag = brain_server_db_attack.getMux_ag();
		Object generatedShort_cnt = brain_server_db_attack.getShort_cnt();
		brain_server_attack_long generatedLong_buf = brain_server_db_attack.getLong_buf();
		Object generatedLong_cnt = brain_server_db_attack.getLong_cnt();
		Object generatedMux_hg = brain_server_db_hash.getMux_hg();
		Object generatedHash = next.getHash();
		Object generatedHash_idx = cur.getHash_idx();
		Object generatedMux_hr = brain_server_db_hash.getMux_hr();
		int generatedHb = brain_server_db_hash.getHb();
		// main loopwhile (ModernizedCProgram.keep_running == 1) {
			int rc_select = ModernizedCProgram.select_read_timeout(client_fd, 1);
			if (rc_select == -1) {
				break;
			} 
			if (rc_select == 0) {
				continue;
			} 
			u8 operation = 0;
			if (((Object)0).brain_recv(client_fd, operation, , 0, ((Object)0)) == 0) {
				break;
			} 
			if (operation == brain_operation.BRAIN_OPERATION_ATTACK_RESERVE) {
				u64 offset = 0;
				u64 length = 0;
				if (((Object)0).brain_recv(client_fd, offset, , 0, ((Object)0)) == 0) {
					break;
				} 
				if (((Object)0).brain_recv(client_fd, length, , 0, ((Object)0)) == 0) {
					break;
				} 
				hc_timer_t timer_reserved = new hc_timer_t();
				ModernizedCProgram.hc_timer_set(timer_reserved);
				.WaitForSingleObject(generatedMux_ag, -1024);
				u64 overlap = 0;
				overlap += ModernizedCProgram.brain_server_find_attack_short(generatedShort_buf, generatedShort_cnt, offset, length);
				overlap += ModernizedCProgram.brain_server_find_attack_long(generatedLong_buf, generatedLong_cnt, offset + overlap, length - overlap);
				if (overlap < length) {
					if (brain_server_db_attack.brain_server_db_attack_realloc(0, 1) == 1) {
						generatedShort_buf[generatedShort_cnt].setOffset(offset + overlap);
						generatedShort_buf[generatedShort_cnt].setLength(length - overlap);
						generatedShort_buf[generatedShort_cnt].setClient_idx(client_idx);
						generatedShort_cnt++;
						.qsort(generatedShort_buf, generatedShort_cnt, , ModernizedCProgram.brain_server_sort_attack_short);
					} 
				} 
				.ReleaseMutex(generatedMux_ag);
				if (((Object)0).brain_send(client_fd, overlap, , 0, ((Object)0)) == 0) {
					break;
				} 
				double ms = ModernizedCProgram.hc_timer_get(timer_reserved);
				(_iob[1]).brain_logging(client_idx, "R | %8.2f ms | Offset: %I64u, Length: %I64u, Overlap: %I64u\n", ms, offset, length, overlap);
			}  else if (operation == brain_operation.BRAIN_OPERATION_COMMIT) {
				hc_timer_t timer_commit = new hc_timer_t();
				ModernizedCProgram.hc_timer_set(timer_commit);
				.WaitForSingleObject(generatedMux_ag, -1024);
				i64 new_attacks = 0;
				for (i64 idx = 0;
				 idx < generatedShort_cnt; idx++) {
					if (generatedClient_idx == client_idx) {
						if (brain_server_db_attack.brain_server_db_attack_realloc(1, 0) == 1) {
							generatedLong_buf[generatedLong_cnt].setOffset(generatedShort_buf[idx].getOffset());
							generatedLong_buf[generatedLong_cnt].setLength(generatedShort_buf[idx].getLength());
							generatedLong_cnt++;
							.qsort(generatedLong_buf, generatedLong_cnt, , ModernizedCProgram.brain_server_sort_attack_long);
						} else {
								(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
						} 
						generatedShort_buf[idx].setOffset(0);
						generatedShort_buf[idx].setLength(0);
						generatedShort_buf[idx].setClient_idx(0);
						new_attacks++;
					} 
				}
				brain_server_db_attack.setWrite_attacks(1);
				.ReleaseMutex(generatedMux_ag);
				if (new_attacks) {
					double ms_attacks = ModernizedCProgram.hc_timer_get(timer_commit);
					(_iob[1]).brain_logging(client_idx, "C | %8.2f ms | Attacks: %I64i\n", ms_attacks, new_attacks);
				} 
				ModernizedCProgram.hc_timer_set(timer_commit);
				.WaitForSingleObject(generatedMux_hg, -1024);
				if (generatedShort_cnt) {
					if (brain_server_db_hash.brain_server_db_hash_realloc(generatedShort_cnt) == 1) {
						if (generatedLong_cnt == 0) {
							for (i64 idx = 0;
							 idx < generatedShort_cnt; idx++) {
								generatedLong_buf[idx].getHash()[0] = generatedShort_buf[idx].getHash()[0];
								generatedLong_buf[idx].getHash()[1] = generatedShort_buf[idx].getHash()[1];
							}
							brain_server_db_hash.setLong_cnt(generatedShort_cnt);
						} else {
								i64 cnt_total = generatedLong_cnt + generatedShort_cnt;
								i64 long_left = generatedLong_cnt - 1;
								i64 short_left = generatedShort_cnt - 1;
								i64 long_dupes = 0;
								for (i64 idx = cnt_total - 1;
								 idx >= long_dupes; idx--) {
									brain_server_hash_long_t long_entry = generatedLong_buf[long_left];
									brain_server_hash_short_t short_entry = generatedShort_buf[short_left];
									int rc = 0;
									if ((long_left >= 0) && (short_left >= 0)) {
										rc = ModernizedCProgram.brain_server_sort_hash(long_entry.getHash(), short_entry.getHash());
									}  else if (long_left >= 0) {
										rc = 1;
									}  else if (short_left >= 0) {
										rc = -1;
									} else {
											(_iob[2]).brain_logging(client_idx, "unexpected remaining buffers in compare: %I64i - %I64i\n", long_left, short_left);
									} 
									brain_server_hash_long_t next = generatedLong_buf[idx];
									if (rc == -1) {
										generatedHash[0] = generatedHash[0];
										generatedHash[1] = generatedHash[1];
										short_left--;
									}  else if (rc == 1) {
										generatedHash[0] = generatedHash[0];
										generatedHash[1] = generatedHash[1];
										long_left--;
									} else {
											generatedHash[0] = generatedHash[0];
											generatedHash[1] = generatedHash[1];
											short_left--;
											long_left--;
											long_dupes++;
									} 
								}
								if ((long_left != -1) || (short_left != -1)) {
									(_iob[2]).brain_logging(client_idx, "unexpected remaining buffers in commit: %I64i - %I64i\n", long_left, short_left);
								} 
								brain_server_db_hash.setLong_cnt(cnt_total - long_dupes);
								if (long_dupes) {
									for (i64 idx = 0;
									 idx < generatedLong_cnt; idx++) {
										generatedHash[0] = generatedHash[0];
										generatedHash[1] = generatedHash[1];
									}
								} 
						} 
					} else {
							(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
					} 
					brain_server_db_hash.setWrite_hashes(1);
				} 
				.ReleaseMutex(generatedMux_hg);
				if (generatedShort_cnt) {
					double ms_hashes = ModernizedCProgram.hc_timer_get(timer_commit);
					(_iob[1]).brain_logging(client_idx, "C | %8.2f ms | Hashes: %I64i\n", ms_hashes, generatedShort_cnt);
				} 
				brain_server_db_short.setShort_cnt(0);
			}  else if (operation == brain_operation.BRAIN_OPERATION_HASH_LOOKUP) {
				int in_size = 0;
				if (((Object)0).brain_recv(client_fd, in_size, , 0, ((Object)0)) == 0) {
					break;
				} 
				if (in_size == 0) {
					(_iob[2]).brain_logging(client_idx, "Zero in_size value\n");
					break;
				} 
				if (in_size > (int)recv_size) {
					break;
				} 
				if (((Object)0).brain_recv(client_fd, recv_buf, (size_t)in_size, 0, ((Object)0)) == 0) {
					break;
				} 
				int hashes_cnt = in_size / ModernizedCProgram.BRAIN_HASH_SIZE;
				if (hashes_cnt == 0) {
					(_iob[2]).brain_logging(client_idx, "Zero passwords\n");
					break;
				} 
				if ((generatedShort_cnt + hashes_cnt) > passwords_max) {
					(_iob[2]).brain_logging(client_idx, "Too many passwords\n");
					break;
				} 
				hc_timer_t timer_lookup = new hc_timer_t();
				ModernizedCProgram.hc_timer_set(timer_lookup);
				for (int hash_idx = 0;
				int recv_idx = 0;
				 hash_idx < hashes_cnt; ) {
					generatedHash[0] = recv_buf[recv_idx + 0];
					generatedHash[1] = recv_buf[recv_idx + 1];
					temp_buf[hash_idx].setHash_idx(hash_idx);
					send_buf[hash_idx] = 0;
				}
				i64 temp_cnt = 0;
				.qsort(temp_buf, hashes_cnt, , ModernizedCProgram.brain_server_sort_hash_unique);
				brain_server_hash_unique_t prev = temp_buf + temp_cnt;
				for (i64 temp_idx = 1;
				 temp_idx < hashes_cnt; temp_idx++) {
					brain_server_hash_unique_t cur = temp_buf + temp_idx;
					if ((generatedHash[0] == generatedHash[0]) && (generatedHash[1] == generatedHash[1])) {
						send_buf[generatedHash_idx] = 1;
					} else {
							temp_cnt++;
							prev = temp_buf + temp_cnt;
							generatedHash[0] = generatedHash[0];
							generatedHash[1] = generatedHash[1];
							prev.setHash_idx(generatedHash_idx);
					} 
				}
				temp_cnt++;
				.WaitForSingleObject(generatedMux_hr, -1024);
				generatedHb++;
				if (generatedHb == 1) {
					.WaitForSingleObject(generatedMux_hg, -1024);
				} 
				.ReleaseMutex(generatedMux_hr);
				if (temp_cnt > 0) {
					i64 temp_idx_new = 0;
					for (i64 temp_idx = 0;
					 temp_idx < temp_cnt; temp_idx++) {
						brain_server_hash_unique_t cur = temp_buf[temp_idx];
						i64 r = ModernizedCProgram.brain_server_find_hash_long(generatedHash, generatedLong_buf, generatedLong_cnt);
						if (r != -1) {
							send_buf[generatedHash_idx] = 1;
						} else {
								brain_server_hash_unique_t save = temp_buf + temp_idx_new;
								temp_idx_new++;
								generatedHash[0] = generatedHash[0];
								generatedHash[1] = generatedHash[1];
								save.setHash_idx(generatedHash_idx);
						} 
					}
					temp_cnt = temp_idx_new;
				} 
				.WaitForSingleObject(generatedMux_hr, -1024);
				generatedHb--;
				if (generatedHb == 0) {
					.ReleaseMutex(generatedMux_hg);
				} 
				.ReleaseMutex(generatedMux_hr);
				if (temp_cnt > 0) {
					i64 temp_idx_new = 0;
					for (i64 temp_idx = 0;
					 temp_idx < temp_cnt; temp_idx++) {
						brain_server_hash_unique_t cur = temp_buf[temp_idx];
						i64 r = ModernizedCProgram.brain_server_find_hash_short(generatedHash, generatedShort_buf, generatedShort_cnt);
						if (r != -1) {
							send_buf[generatedHash_idx] = 1;
						} else {
								brain_server_hash_unique_t save = temp_buf + temp_idx_new;
								temp_idx_new++;
								generatedHash[0] = generatedHash[0];
								generatedHash[1] = generatedHash[1];
								save.setHash_idx(generatedHash_idx);
						} 
					}
					temp_cnt = temp_idx_new;
				} 
				if (temp_cnt > 0) {
					if (generatedShort_cnt == 0) {
						for (i64 idx = 0;
						 idx < temp_cnt; idx++) {
							generatedHash[0] = generatedHash[0];
							generatedHash[1] = generatedHash[1];
						}
						brain_server_db_short.setShort_cnt(temp_cnt);
					} else {
							i64 cnt_total = generatedShort_cnt + temp_cnt;
							i64 short_left = generatedShort_cnt - 1;
							i64 unique_left = temp_cnt - 1;
							for (i64 idx = cnt_total - 1;
							 idx >= 0; idx--) {
								brain_server_hash_short_t short_entry = generatedShort_buf + short_left;
								brain_server_hash_unique_t unique_entry = temp_buf + unique_left;
								int rc = 0;
								if ((short_left >= 0) && (unique_left >= 0)) {
									rc = ModernizedCProgram.brain_server_sort_hash(generatedHash, generatedHash);
								}  else if (short_left >= 0) {
									rc = 1;
								}  else if (unique_left >= 0) {
									rc = -1;
								} else {
										(_iob[2]).brain_logging(client_idx, "unexpected remaining buffers in compare: %I64i - %I64i\n", short_left, unique_left);
								} 
								brain_server_hash_short_t next = generatedShort_buf + idx;
								if (rc == -1) {
									generatedHash[0] = generatedHash[0];
									generatedHash[1] = generatedHash[1];
									unique_left--;
								}  else if (rc == 1) {
									generatedHash[0] = generatedHash[0];
									generatedHash[1] = generatedHash[1];
									short_left--;
								} else {
										(_iob[2]).brain_logging(client_idx, "unexpected zero comparison in commit\n");
								} 
							}
							if ((short_left != -1) || (unique_left != -1)) {
								(_iob[2]).brain_logging(client_idx, "unexpected remaining buffers in commit: %I64i - %I64i\n", short_left, unique_left);
							} 
							brain_server_db_short.setShort_cnt(cnt_total);
					} 
				} 
				int local_lookup_new = 0;
				for (i64 hashes_idx = 0;
				 hashes_idx < hashes_cnt; hashes_idx++) {
					if (send_buf[hashes_idx] == 0) {
						local_lookup_new++;
					} 
				}
				double ms = ModernizedCProgram.hc_timer_get(timer_lookup);
				(_iob[1]).brain_logging(client_idx, "L | %8.2f ms | Long: %I64i, Inc: %d, New: %d\n", ms, generatedLong_cnt, hashes_cnt, local_lookup_new);
				int out_size = hashes_cnt;
				if (((Object)0).brain_send(client_fd, out_size, , 0, ((Object)0)) == 0) {
					break;
				} 
				if (((Object)0).brain_send(client_fd, send_buf, out_size, 0, ((Object)0)) == 0) {
					break;
				} 
			} else {
					break;
			} 
		}// wait for client to send data, but not too long
		// client reservations// client reservations.WaitForSingleObject(generatedMux_ag, -1024);
		for (i64 idx = 0;
		 idx < generatedShort_cnt; idx++) {
			if (generatedClient_idx == client_idx) {
				generatedShort_buf[idx].setOffset(0);
				generatedShort_buf[idx].setLength(0);
				generatedShort_buf[idx].setClient_idx(0);
			} 
		}
		.ReleaseMutex(generatedMux_ag)// short free;// short free
		ModernizedCProgram.hcfree(generatedShort_buf);
		ModernizedCProgram.hcfree(brain_server_db_short)// free local memory;// free local memory
		ModernizedCProgram.hcfree(send_buf);
		ModernizedCProgram.hcfree(temp_buf);
		ModernizedCProgram.hcfree(recv_buf);
		(_iob[1]).brain_logging(client_idx, "Disconnected\n");
		generatedClient_slots[client_idx] = 0;
		ModernizedCProgram.close(client_fd);
		return ((Object)0);
	}
	public static int brain_server(Object listen_host, Object listen_port, Object brain_password, Object brain_session_whitelist) {
		WSADATA wsaData = new WSADATA();
		WORD wVersionRequested = ((WORD)(((BYTE)(true)) | (((WORD)((BYTE)(true))) << 8)));
		if (.WSAStartup(wVersionRequested, wsaData) != -1024) {
			.fprintf((_iob[2]), "WSAStartup: %s\n", .strerror((._errno())));
			return -1;
		} 
		ModernizedCProgram.hc_timer_set(ModernizedCProgram.timer_logging);
		ModernizedCProgram.mux_display = .CreateMutexA(((Object)0), 0, ((Object)0))// generate random brain password if not specified by user;// generate random brain password if not specified by user
		byte auth_password = ((Object)0);
		if (brain_password == ((Object)0)) {
			auth_password = (byte)ModernizedCProgram.hcmalloc(20);
			.snprintf(auth_password, 20, "%08x%08x", ModernizedCProgram.brain_auth_challenge(), ModernizedCProgram.brain_auth_challenge());
			(_iob[1]).brain_logging(0, "Generated authentication password: %s\n", auth_password);
		} else {
				auth_password = (byte)brain_password;
		} 
		// socket stuffint server_fd = .socket(2, 1, 0);
		if (server_fd == -1) {
			(_iob[2]).brain_logging(0, "socket: %s\n", .strerror((._errno())));
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		sockaddr_in sa = new sockaddr_in();
		.memset(sa, 0, );
		size_t salen = ;
		sa.setSin_family(2);
		sa.setSin_port(.htons(listen_port));
		Object generatedSin_addr = sa.getSin_addr();
		generatedSin_addr.getS_un().setS_addr((u_long)0);
		Object generatedAi_addr = address_info.getAi_addr();
		if (listen_host) {
			addrinfo hints = new addrinfo();
			.memset(hints, 0, );
			hints.setAi_family(2);
			hints.setAi_socktype(1);
			addrinfo address_info = ((Object)0);
			int rc_getaddrinfo = .getaddrinfo(listen_host, ((Object)0), hints, address_info);
			if (rc_getaddrinfo == 0) {
				sockaddr_in tmp = (sockaddr_in)generatedAi_addr;
				generatedSin_addr.getS_un().setS_addr(generatedSin_addr.getS_un().getS_addr());
				.freeaddrinfo(address_info);
			} else {
					(_iob[2]).brain_logging(0, "%s: %s\n", listen_host, .gai_strerrorA(rc_getaddrinfo));
					if (brain_password == ((Object)0)) {
						ModernizedCProgram.hcfree(auth_password);
					} 
					return -1;
			} 
		} 
		if (.bind(server_fd, (sockaddr)sa, salen) == -1) {
			(_iob[2]).brain_logging(0, "bind: %s\n", .strerror((._errno())));
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		if (.listen(server_fd, 5) == -1) {
			(_iob[2]).brain_logging(0, "listen: %s\n", .strerror((._errno())));
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		brain_server_dbs_t brain_server_dbs = (brain_server_dbs_t)ModernizedCProgram.hcmalloc();
		if (brain_server_dbs == ((Object)0)) {
			(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		brain_server_dbs.setMux_dbs(.CreateMutexA(((Object)0), 0, ((Object)0)));
		brain_server_dbs.setHash_buf((brain_server_db_hash_t)ModernizedCProgram.hccalloc(ModernizedCProgram.BRAIN_SERVER_SESSIONS_MAX, ));
		brain_server_dbs.setHash_cnt(0);
		brain_server_db_hash generatedHash_buf = brain_server_dbs.getHash_buf();
		if (generatedHash_buf == ((Object)0)) {
			(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		if (brain_server_dbs.brain_server_read_hash_dumps(".") == 0) {
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		brain_server_dbs.setAttack_buf((brain_server_db_attack_t)ModernizedCProgram.hccalloc(ModernizedCProgram.BRAIN_SERVER_ATTACKS_MAX, ));
		brain_server_dbs.setAttack_cnt(0);
		brain_server_db_attack generatedAttack_buf = brain_server_dbs.getAttack_buf();
		if (generatedAttack_buf == ((Object)0)) {
			(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		if (brain_server_dbs.brain_server_read_attack_dumps(".") == 0) {
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		brain_server_dbs.setClient_slots((int)ModernizedCProgram.hccalloc(ModernizedCProgram.BRAIN_SERVER_CLIENTS_MAX, ));
		Integer generatedClient_slots = brain_server_dbs.getClient_slots();
		if (generatedClient_slots == ((Object)0)) {
			(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		// session whitelistsu32 session_whitelist_buf = (u32)ModernizedCProgram.hccalloc(ModernizedCProgram.BRAIN_SERVER_SESSIONS_MAX, );
		int session_whitelist_cnt = 0;
		if (brain_session_whitelist != ((Object)0)) {
			byte sessions = ModernizedCProgram.hcstrdup(brain_session_whitelist);
			if (sessions == ((Object)0)) {
				(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
				if (brain_password == ((Object)0)) {
					ModernizedCProgram.hcfree(auth_password);
				} 
				return -1;
			} 
			byte saveptr = ((Object)0);
			byte next = .strtok_r(sessions, ",", saveptr);
			do {
				int session = (int)ModernizedCProgram.hc_strtoul(next, ((Object)0), 16);
				session_whitelist_buf[session_whitelist_cnt] = session;
				session_whitelist_cnt++;
			} while ((next = .strtok_r((byte)((Object)0), ",", saveptr)) != ((Object)0));
			ModernizedCProgram.hcfree(sessions);
		} 
		// client optionsbrain_server_client_options_t brain_server_client_options = (brain_server_client_options_t)ModernizedCProgram.hccalloc(ModernizedCProgram.BRAIN_SERVER_CLIENTS_MAX, );
		if (brain_server_client_options == ((Object)0)) {
			(_iob[2]).brain_logging(0, "%s\n", "Insufficient memory available");
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		for (int client_idx = 0;
		 client_idx < ModernizedCProgram.BRAIN_SERVER_CLIENTS_MAX; client_idx++) {
			brain_server_client_options[client_idx].setClient_idx(client_idx);
			brain_server_client_options[client_idx].setAuth_password(auth_password);
			brain_server_client_options[client_idx].setBrain_server_dbs(brain_server_dbs);
			brain_server_client_options[client_idx].setSession_whitelist_buf(session_whitelist_buf);
			brain_server_client_options[client_idx].setSession_whitelist_cnt(session_whitelist_cnt);
		}// none of these value change
		// ready to serve// ready to serve(_iob[1]).brain_logging(0, "Brain server started\n");
		if (.signal(2, ModernizedCProgram.brain_server_handle_signal) == ((__p_sig_fn_t)-1)) {
			(_iob[2]).brain_logging(0, "signal: %s\n", .strerror((._errno())));
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		brain_server_dumper_options_t brain_server_dumper_options = new brain_server_dumper_options_t();
		brain_server_dumper_options.setBrain_server_dbs(brain_server_dbs);
		hc_thread_t dump_thr = new hc_thread_t();
		dump_thr = .CreateThread(((Object)0), 0, (LPTHREAD_START_ROUTINE)ModernizedCProgram.brain_server_handle_dumps, brain_server_dumper_options, 0, ((Object)0));
		Object generatedSin_port = ca.getSin_port();
		while (ModernizedCProgram.keep_running == 1) {
			int rc_select = ModernizedCProgram.select_read_timeout(server_fd, 1);
			if (rc_select == -1) {
				ModernizedCProgram.keep_running = 0;
				break;
			} 
			if (rc_select == 0) {
				continue;
			} 
			sockaddr_in ca = new sockaddr_in();
			.memset(ca, 0, );
			size_t calen = ;
			int client_fd = .accept(server_fd, (sockaddr)ca, (socklen_t)calen);
			(_iob[1]).brain_logging(0, "Connection from %s:%d\n", .inet_ntoa(generatedSin_addr), .ntohs(generatedSin_port));
			int client_idx = brain_server_dbs.brain_server_get_client_idx();
			if (client_idx == -1) {
				(_iob[2]).brain_logging(client_idx, "Too many clients\n");
				ModernizedCProgram.close(client_fd);
				continue;
			} 
			brain_server_client_options[client_idx].setClient_fd(client_fd);
			hc_thread_t client_thr = new hc_thread_t();
			client_thr = .CreateThread(((Object)0), 0, (LPTHREAD_START_ROUTINE)ModernizedCProgram.brain_server_handle_client, brain_server_client_options[client_idx], 0, ((Object)0));
			if (client_thr == 0) {
				(_iob[2]).brain_logging(0, "pthread_create: %s\n", .strerror((._errno())));
				ModernizedCProgram.close(client_fd);
				continue;
			} 
			.CloseHandle(client_thr);
		}// wait for a client to connect, but not too long
		(_iob[1]).brain_logging(0, "Brain server stopping\n");
		for (int i = 0;
		 i < 1; i++) {
			.WaitForSingleObject((dump_thr)[i], -1024);
		}
		if (brain_server_dbs.brain_server_write_hash_dumps(".") == 0) {
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		if (brain_server_dbs.brain_server_write_attack_dumps(".") == 0) {
			if (brain_password == ((Object)0)) {
				ModernizedCProgram.hcfree(auth_password);
			} 
			return -1;
		} 
		int generatedHash_cnt = brain_server_dbs.getHash_cnt();
		for (i64 idx = 0;
		 idx < generatedHash_cnt; idx++) {
			brain_server_db_hash_t brain_server_db_hash = generatedHash_buf[idx];
			brain_server_db_hash.brain_server_db_hash_free();
		}
		int generatedAttack_cnt = brain_server_dbs.getAttack_cnt();
		for (i64 idx = 0;
		 idx < generatedAttack_cnt; idx++) {
			brain_server_db_attack_t brain_server_db_attack = generatedAttack_buf[idx];
			brain_server_db_attack.brain_server_db_attack_free();
		}
		ModernizedCProgram.hcfree(generatedHash_buf);
		ModernizedCProgram.hcfree(generatedAttack_buf);
		ModernizedCProgram.hcfree(brain_server_dbs);
		ModernizedCProgram.hcfree(brain_server_client_options);
		if (brain_password == ((Object)0)) {
			ModernizedCProgram.hcfree(auth_password);
		} 
		ModernizedCProgram.close(server_fd);
		.WSACleanup();
		return 0;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int conv_pos(Object c, Object pos_mem) {
		if (c == rule_functions.RULE_LAST_REJECTED_SAVED_POS) {
			return pos_mem;
		} 
		return ModernizedCProgram.conv_ctoi(c);
	}
	public static void MANGLE_TOGGLE_AT(Byte arr, Object pos) {
		if (ModernizedCProgram.class_alpha(arr[pos])) {
			arr[pos] ^=  -1024;
		} 
	}
	public static void MANGLE_LOWER_AT(Byte arr, Object pos) {
		if (ModernizedCProgram.class_upper(arr[pos])) {
			arr[pos] ^=  -1024;
		} 
	}
	public static void MANGLE_UPPER_AT(Byte arr, Object pos) {
		if (ModernizedCProgram.class_lower(arr[pos])) {
			arr[pos] ^=  -1024;
		} 
	}
	public static void MANGLE_SWITCH(Byte arr, Object l, Object r) {
		byte c = arr[r];
		arr[r] = arr[l];
		arr[l] = c;
	}
	public static int mangle_lrest(Byte arr, int arr_len) {
		int pos;
		for (pos = 0; pos < arr_len; pos++) {
			ModernizedCProgram.MANGLE_LOWER_AT(arr, pos);
		}
		return (arr_len);
	}
	public static int mangle_urest(Byte arr, int arr_len) {
		int pos;
		for (pos = 0; pos < arr_len; pos++) {
			ModernizedCProgram.MANGLE_UPPER_AT(arr, pos);
		}
		return (arr_len);
	}
	public static int mangle_trest(Byte arr, int arr_len) {
		int pos;
		for (pos = 0; pos < arr_len; pos++) {
			ModernizedCProgram.MANGLE_TOGGLE_AT(arr, pos);
		}
		return (arr_len);
	}
	public static int mangle_reverse(Byte arr, int arr_len) {
		int l;
		for (l = 0; l < arr_len; l++) {
			int r = arr_len - 1 - l;
			if (l >= r) {
				break;
			} 
			ModernizedCProgram.MANGLE_SWITCH(arr, l, r);
		}
		return (arr_len);
	}
	public static int mangle_double(Byte arr, int arr_len) {
		if ((arr_len * 2) >= 256) {
			return (arr_len);
		} 
		.memcpy(arr[arr_len], arr, (size_t)arr_len);
		return (arr_len * 2);
	}
	public static int mangle_double_times(Byte arr, int arr_len, int times) {
		if (((arr_len * times) + arr_len) >= 256) {
			return (arr_len);
		} 
		int orig_len = arr_len;
		int i;
		for (i = 0; i < times; i++) {
			.memcpy(arr[arr_len], arr, orig_len);
			arr_len += orig_len;
		}
		return (arr_len);
	}
	public static int mangle_reflect(Byte arr, int arr_len) {
		if ((arr_len * 2) >= 256) {
			return (arr_len);
		} 
		ModernizedCProgram.mangle_double(arr, arr_len);
		ModernizedCProgram.mangle_reverse(arr + arr_len, arr_len);
		return (arr_len * 2);
	}
	public static int mangle_rotate_left(Byte arr, int arr_len) {
		int l;
		int r;
		for (; r > 0; r--) {
			ModernizedCProgram.MANGLE_SWITCH(arr, l, r);
		}
		return (arr_len);
	}
	public static int mangle_rotate_right(Byte arr, int arr_len) {
		int l;
		int r;
		for (; l < r; l++) {
			ModernizedCProgram.MANGLE_SWITCH(arr, l, r);
		}
		return (arr_len);
	}
	public static int mangle_append(Byte arr, int arr_len, byte c) {
		if ((arr_len + 1) >= 256) {
			return (arr_len);
		} 
		arr[arr_len] = c;
		return (arr_len + 1);
	}
	public static int mangle_prepend(Byte arr, int arr_len, byte c) {
		if ((arr_len + 1) >= 256) {
			return (arr_len);
		} 
		int arr_pos;
		for (arr_pos = arr_len - 1; arr_pos > -1; arr_pos--) {
			arr[arr_pos + 1] = arr[arr_pos];
		}
		arr[0] = c;
		return (arr_len + 1);
	}
	public static int mangle_delete_at(Byte arr, int arr_len, int upos) {
		if (upos >= arr_len) {
			return (arr_len);
		} 
		int arr_pos;
		for (arr_pos = upos; arr_pos < arr_len - 1; arr_pos++) {
			arr[arr_pos] = arr[arr_pos + 1];
		}
		return (arr_len - 1);
	}
	public static int mangle_extract(Byte arr, int arr_len, int upos, int ulen) {
		if (upos >= arr_len) {
			return (arr_len);
		} 
		if ((upos + ulen) > arr_len) {
			return (arr_len);
		} 
		int arr_pos;
		for (arr_pos = 0; arr_pos < ulen; arr_pos++) {
			arr[arr_pos] = arr[upos + arr_pos];
		}
		return (ulen);
	}
	public static int mangle_omit(Byte arr, int arr_len, int upos, int ulen) {
		if (upos >= arr_len) {
			return (arr_len);
		} 
		if ((upos + ulen) > arr_len) {
			return (arr_len);
		} 
		int arr_pos;
		for (arr_pos = upos; arr_pos < arr_len - ulen; arr_pos++) {
			arr[arr_pos] = arr[arr_pos + ulen];
		}
		return (arr_len - ulen);
	}
	public static int mangle_insert(Byte arr, int arr_len, int upos, byte c) {
		if (upos > arr_len) {
			return (arr_len);
		} 
		if ((arr_len + 1) >= 256) {
			return (arr_len);
		} 
		int arr_pos;
		for (arr_pos = arr_len - 1; arr_pos > upos - 1; arr_pos--) {
			arr[arr_pos + 1] = arr[arr_pos];
		}
		arr[upos] = c;
		return (arr_len + 1);
	}
	public static int mangle_insert_multi(Byte arr, int arr_len, int arr_pos, Byte arr2, int arr2_len, int arr2_pos, int arr2_cpy) {
		if ((arr_len + arr2_cpy) > 256) {
			return (true);
		} 
		if (arr_pos > arr_len) {
			return (true);
		} 
		if (arr2_pos > arr2_len) {
			return (true);
		} 
		if ((arr2_pos + arr2_cpy) > arr2_len) {
			return (true);
		} 
		if (arr2_cpy < 1) {
			return (true);
		} 
		.memmove(arr2, arr2 + arr2_pos, arr2_len - arr2_pos);
		.memcpy(arr2 + arr2_cpy, arr + arr_pos, arr_len - arr_pos);
		.memcpy(arr + arr_pos, arr2, arr_len - arr_pos + arr2_cpy);
		return (arr_len + arr2_cpy);
	}
	public static int mangle_overstrike(Byte arr, int arr_len, int upos, byte c) {
		if (upos >= arr_len) {
			return (arr_len);
		} 
		arr[upos] = c;
		return (arr_len);
	}
	public static int mangle_truncate_at(Byte arr, int arr_len, int upos) {
		if (upos >= arr_len) {
			return (arr_len);
		} 
		.memset(arr + upos, 0, arr_len - upos);
		return (upos);
	}
	public static int mangle_replace(Byte arr, int arr_len, byte oldc, byte newc) {
		int arr_pos;
		for (arr_pos = 0; arr_pos < arr_len; arr_pos++) {
			if (arr[arr_pos] != oldc) {
				continue;
			} 
			arr[arr_pos] = newc;
		}
		return (arr_len);
	}
	public static int mangle_purgechar(Byte arr, int arr_len, byte c) {
		int arr_pos;
		int ret_len;
		for (; arr_pos < arr_len; arr_pos++) {
			if (arr[arr_pos] == c) {
				continue;
			} 
			arr[ret_len] = arr[arr_pos];
			ret_len++;
		}
		return (ret_len);
	}
	public static int mangle_dupeblock_prepend(Byte arr, int arr_len, int ulen) {
		if (ulen > arr_len) {
			return (arr_len);
		} 
		if ((arr_len + ulen) >= 256) {
			return (arr_len);
		} 
		byte[] cs = new byte[]{0};
		.memcpy(cs, arr, ulen);
		int i;
		for (i = 0; i < ulen; i++) {
			byte c = cs[i];
			arr_len = ModernizedCProgram.mangle_insert(arr, arr_len, i, c);
		}
		return (arr_len);
	}
	public static int mangle_dupeblock_append(Byte arr, int arr_len, int ulen) {
		if (ulen > arr_len) {
			return (arr_len);
		} 
		if ((arr_len + ulen) >= 256) {
			return (arr_len);
		} 
		int upos = arr_len - ulen;
		int i;
		for (i = 0; i < ulen; i++) {
			byte c = arr[upos + i];
			arr_len = ModernizedCProgram.mangle_append(arr, arr_len, c);
		}
		return (arr_len);
	}
	public static int mangle_dupechar_at(Byte arr, int arr_len, int upos, int ulen) {
		if (arr_len == 0) {
			return (arr_len);
		} 
		if ((arr_len + ulen) >= 256) {
			return (arr_len);
		} 
		byte c = arr[upos];
		int i;
		for (i = 0; i < ulen; i++) {
			arr_len = ModernizedCProgram.mangle_insert(arr, arr_len, upos, c);
		}
		return (arr_len);
	}
	public static int mangle_dupechar(Byte arr, int arr_len) {
		if (arr_len == 0) {
			return (arr_len);
		} 
		if ((arr_len + arr_len) >= 256) {
			return (arr_len);
		} 
		int arr_pos;
		for (arr_pos = arr_len - 1; arr_pos > -1; arr_pos--) {
			int new_pos = arr_pos * 2;
			arr[new_pos] = arr[arr_pos];
			arr[new_pos + 1] = arr[arr_pos];
		}
		return (arr_len * 2);
	}
	public static int mangle_switch_at_check(Byte arr, int arr_len, int upos, int upos2) {
		if (upos >= arr_len) {
			return (arr_len);
		} 
		if (upos2 >= arr_len) {
			return (arr_len);
		} 
		ModernizedCProgram.MANGLE_SWITCH(arr, upos, upos2);
		return (arr_len);
	}
	public static int mangle_switch_at(Byte arr, int arr_len, int upos, int upos2) {
		ModernizedCProgram.MANGLE_SWITCH(arr, upos, upos2);
		return (arr_len);
	}
	public static int mangle_chr_shiftl(Byte arr, int arr_len, int upos) {
		if (upos >= arr_len) {
			return (arr_len);
		} 
		arr[upos] <<=  1;
		return (arr_len);
	}
	public static int mangle_chr_shiftr(Byte arr, int arr_len, int upos) {
		if (upos >= arr_len) {
			return (arr_len);
		} 
		arr[upos] >>=  1;
		return (arr_len);
	}
	public static int mangle_chr_incr(Byte arr, int arr_len, int upos) {
		if (upos >= arr_len) {
			return (arr_len);
		} 
		arr[upos] += 1;
		return (arr_len);
	}
	public static int mangle_chr_decr(Byte arr, int arr_len, int upos) {
		if (upos >= arr_len) {
			return (arr_len);
		} 
		arr[upos] -= 1;
		return (arr_len);
	}
	public static int mangle_title_sep(Byte arr, int arr_len, byte c) {
		int upper_next = 1;
		int pos;
		for (pos = 0; pos < arr_len; pos++) {
			if (arr[pos] == c) {
				upper_next = 1;
				continue;
			} 
			if (upper_next) {
				upper_next = 0;
				ModernizedCProgram.MANGLE_UPPER_AT(arr, pos);
			} else {
					ModernizedCProgram.MANGLE_LOWER_AT(arr, pos);
			} 
		}
		ModernizedCProgram.MANGLE_UPPER_AT(arr, 0);
		return (arr_len);
	}
	public static int _old_apply_rule(Object rule, int rule_len, Byte in, int in_len, Byte out) {
		byte[] mem = new byte[]{0};
		int pos_mem = -1;
		if (in == ((Object)0)) {
			return (true);
		} 
		if (out == ((Object)0)) {
			return (true);
		} 
		if (in_len < 0 || in_len > 256) {
			return (true);
		} 
		if (rule_len < 1) {
			return (true);
		} 
		int out_len = in_len;
		int mem_len = in_len;
		.memcpy(out, in, out_len);
		byte rule_new = (byte)ModernizedCProgram.hcmalloc(rule_len);
		int rule_len_new = 0;
		int rule_pos;
		for (rule_pos = 0; rule_pos < rule_len; rule_pos++) {
			if (ModernizedCProgram.is_hex_notation(rule, rule_len, rule_pos)) {
				u8 c = ModernizedCProgram.hex_to_u8((u8)rule[rule_pos + 2]);
				rule_pos += 3;
				rule_new[rule_len_new] = c;
				rule_len_new++;
			} else {
					rule_new[rule_len_new] = rule[rule_pos];
					rule_len_new++;
			} 
		}
		for (rule_pos = 0; rule_pos < rule_len_new; rule_pos++) {
			int upos;
			int upos2;
			int ulen;
			switch (rule_new[rule_pos]) {
			case rule_functions.RULE_OP_MANGLE_TRUNCATE_AT:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_truncate_at(out, out_len, upos);
					break;
			case rule_functions.RULE_OP_MANGLE_NOOP:
					break;
			case rule_functions.RULE_OP_MANGLE_DUPECHAR_FIRST:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((ulen) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_dupechar_at(out, out_len, 0, ulen);
					break;
			case rule_functions.RULE_OP_REJECT_MEMORY:
					if ((out_len == mem_len) && (.memcmp(out, mem, out_len) == 0)) {
						return (true);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_ROTATE_LEFT:
					ModernizedCProgram.mangle_rotate_left(out, out_len);
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_SHIFTR:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					ModernizedCProgram.mangle_chr_shiftr(out, out_len, upos);
					break;
			case (byte)' ':
					break;
			case rule_functions.RULE_OP_MANGLE_DELETE_FIRST:
					out_len = ModernizedCProgram.mangle_delete_at(out, out_len, 0);
					break;
			case rule_functions.RULE_OP_MANGLE_PURGECHAR:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_purgechar(out, out_len, rule_new[rule_pos]);
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEBLOCK_LAST:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((ulen) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_dupeblock_append(out, out_len, ulen);
					break;
			case rule_functions.RULE_OP_REJECT_CONTAIN:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (.strchr(out, rule_new[rule_pos]) != ((Object)0)) {
						return (true);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_DUPECHAR_ALL:
					out_len = ModernizedCProgram.mangle_dupechar(out, out_len);
					break;
			case rule_functions.RULE_OP_MANGLE_OVERSTRIKE:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_overstrike(out, out_len, upos, rule_new[rule_pos]);
					break;
			case rule_functions.RULE_OP_MANGLE_SWITCH_FIRST:
					if (out_len >= 2) {
						ModernizedCProgram.mangle_switch_at(out, out_len, 0, 1);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_LREST:
					out_len = ModernizedCProgram.mangle_lrest(out, out_len);
					break;
			case rule_functions.RULE_OP_MANGLE_LREST_UFIRST:
					out_len = ModernizedCProgram.mangle_lrest(out, out_len);
					if (out_len) {
						ModernizedCProgram.MANGLE_UPPER_AT(out, 0);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_REPLACE:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_replace(out, out_len, rule_new[rule_pos - 1], rule_new[rule_pos]);
					break;
			case rule_functions.RULE_OP_MANGLE_REVERSE:
					out_len = ModernizedCProgram.mangle_reverse(out, out_len);
					break;
			case rule_functions.RULE_OP_MANGLE_APPEND:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_append(out, out_len, rule_new[rule_pos]);
					break;
			case rule_functions.RULE_OP_MEMORIZE_WORD:
					.memcpy(mem, out, out_len);
					mem_len = out_len;
					break;
			case rule_functions.RULE_OP_MANGLE_UREST_LFIRST:
					out_len = ModernizedCProgram.mangle_urest(out, out_len);
					if (out_len) {
						ModernizedCProgram.MANGLE_LOWER_AT(out, 0);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_PREPEND_MEMORY:
					if (mem_len < 1) {
						return (true);
					} 
					if ((mem_len + out_len) >= 256) {
						return (true);
					} 
					.memcpy(mem + mem_len, out, out_len);
					out_len += mem_len;
					.memcpy(out, mem, out_len);
					break;
			case rule_functions.RULE_OP_MANGLE_TITLE:
					out_len = ModernizedCProgram.mangle_title_sep(out, out_len, (byte)' ');
					break;
			case rule_functions.RULE_OP_MANGLE_EXTRACT_MEMORY:
					if (mem_len < 1) {
						return (true);
					} 
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((ulen) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos2) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if ((out_len = ModernizedCProgram.mangle_insert_multi(out, out_len, upos2, mem, mem_len, upos, ulen)) < 1) {
						return (out_len);
					} 
					break;
			case rule_functions.RULE_OP_REJECT_EQUAL:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if (out_len != upos) {
						return (true);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEWORD:
					out_len = ModernizedCProgram.mangle_double(out, out_len);
					break;
			case rule_functions.RULE_OP_MANGLE_INSERT:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_insert(out, out_len, upos, rule_new[rule_pos]);
					break;
			case rule_functions.RULE_OP_MANGLE_ROTATE_RIGHT:
					ModernizedCProgram.mangle_rotate_right(out, out_len);
					break;
			case rule_functions.RULE_OP_MANGLE_REPLACE_NM1:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if ((upos >= 1) && ((upos + 0) < out_len)) {
						ModernizedCProgram.mangle_overstrike(out, out_len, upos, out[upos - 1]);
					} 
					break;
			case rule_functions.RULE_OP_REJECT_GREATER:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if (out_len < upos) {
						return (true);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_DECR:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					ModernizedCProgram.mangle_chr_decr(out, out_len, upos);
					break;
			case rule_functions.RULE_OP_REJECT_EQUAL_AT:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if ((upos + 1) > out_len) {
						return (true);
					} 
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (out[upos] != rule_new[rule_pos]) {
						return (true);
					} 
					break;
			case rule_functions.RULE_OP_REJECT_EQUAL_LAST:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (out[out_len - 1] != rule_new[rule_pos]) {
						return (true);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_REFLECT:
					out_len = ModernizedCProgram.mangle_reflect(out, out_len);
					break;
			case rule_functions.RULE_OP_MANGLE_PREPEND:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_prepend(out, out_len, rule_new[rule_pos]);
					break;
			case rule_functions.RULE_OP_MANGLE_OMIT:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((ulen) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_omit(out, out_len, upos, ulen);
					break;
			case rule_functions.RULE_OP_MANGLE_TOGGLECASE_REC/* todo */:
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_SHIFTL:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					ModernizedCProgram.mangle_chr_shiftl(out, out_len, upos);
					break;
			case rule_functions.RULE_OP_REJECT_EQUAL_FIRST:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (out[0] != rule_new[rule_pos]) {
						return (true);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEWORD_TIMES:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((ulen) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_double_times(out, out_len, ulen);
					break;
			case rule_functions.RULE_OP_MANGLE_SWITCH_AT:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos2) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_switch_at_check(out, out_len, upos, upos2);
					break;
			case rule_functions.RULE_OP_MANGLE_DUPECHAR_LAST:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((ulen) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_dupechar_at(out, out_len, out_len - 1, ulen);
					break;
			case rule_functions.RULE_OP_REJECT_NOT_CONTAIN:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					byte match = .strchr(out, rule_new[rule_pos]);
					if (ModernizedCProgram.match != ((Object)0)) {
						pos_mem = (int)(ModernizedCProgram.match - out);
					} else {
							return (true);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_REPLACE_NP1:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if ((upos >= 0) && ((upos + 1) < out_len)) {
						ModernizedCProgram.mangle_overstrike(out, out_len, upos, out[upos + 1]);
					} 
					break;
			case rule_functions.RULE_OP_REJECT_CONTAINS:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if ((upos + 1) > out_len) {
						return (true);
					} 
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					int c;
					int cnt;
					for (; c < out_len && cnt < upos; c++) {
						if (out[c] == rule_new[rule_pos]) {
							cnt++;
							pos_mem = c;
						} 
					}
					if (cnt < upos) {
						return (true);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_TOGGLE_AT:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if (upos < out_len) {
						ModernizedCProgram.MANGLE_TOGGLE_AT(out, upos);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEBLOCK_FIRST:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((ulen) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_dupeblock_prepend(out, out_len, ulen);
					break;
			case rule_functions.RULE_OP_MANGLE_UREST:
					out_len = ModernizedCProgram.mangle_urest(out, out_len);
					break;
			case rule_functions.RULE_OP_MANGLE_DELETE_LAST:
					out_len = ModernizedCProgram.mangle_delete_at(out, out_len, (out_len) ? out_len - 1 : 0);
					break;
			case rule_functions.RULE_OP_MANGLE_SWITCH_LAST:
					if (out_len >= 2) {
						ModernizedCProgram.mangle_switch_at(out, out_len, out_len - 1, out_len - 2);
					} 
					break;
			case rule_functions.RULE_OP_REJECT_LESS:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if (out_len > upos) {
						return (true);
					} 
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_INCR:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					ModernizedCProgram.mangle_chr_incr(out, out_len, upos);
					break;
			case rule_functions.RULE_OP_MANGLE_TREST:
					out_len = ModernizedCProgram.mangle_trest(out, out_len);
					break;
			case rule_functions.RULE_OP_MANGLE_EXTRACT:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((ulen) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_extract(out, out_len, upos, ulen);
					break;
			case rule_functions.RULE_OP_MANGLE_TITLE_SEP:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_title_sep(out, out_len, rule_new[rule_pos]);
					break;
			case rule_functions.RULE_OP_MANGLE_APPEND_MEMORY:
					if (mem_len < 1) {
						return (true);
					} 
					if ((out_len + mem_len) >= 256) {
						return (true);
					} 
					.memcpy(out + out_len, mem, mem_len);
					out_len += mem_len;
					break;
			case rule_functions.RULE_OP_MANGLE_DELETE_AT:
					if (++(rule_pos) == rule_len) {
						return (true);
					} 
					if (((upos) = ModernizedCProgram.conv_pos((rule_new)[(rule_pos)], pos_mem)) == -1) {
						return (true);
					} 
					out_len = ModernizedCProgram.mangle_delete_at(out, out_len, upos);
					break;
			default:
					return (true);
			}
		}
		.memset(out + out_len, 0, 256 - out_len);
		ModernizedCProgram.hcfree(rule_new);
		return (out_len);
	}
	public static int run_rule_engine(Object rule_len, Object rule_buf) {
		if (rule_len == 0) {
			return 0;
		} 
		if (rule_len == 1) {
			if (rule_buf[0] == rule_functions.RULE_OP_MANGLE_NOOP) {
				return 0;
			} 
		} 
		return 1;
	}
	/* ioapi.h -- IO base function header for compress/uncompress .zip
	   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
	
	         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
	
	         Modifications for Zip64 support
	         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
	
	         For more info read MiniZip_info.txt
	
	*/
	// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
	public static Object call_zopen64(Object pfilefunc, Object filename, int mode) {
		if (pfilefunc.getZfile_func64().getZopen64_file() != ((Object)0)) {
			return .UNRECOGNIZEDFUNCTIONNAME(pfilefunc.getZfile_func64().getOpaque(), filename, mode);
		} else {
				return .UNRECOGNIZEDFUNCTIONNAME(pfilefunc.getZfile_func64().getOpaque(), (byte)filename, mode);
		} 
	}
	public static long call_zseek64(Object pfilefunc, Object filestream, Object offset, int origin) {
		if (pfilefunc.getZfile_func64().getZseek64_file() != ((Object)0)) {
			return .UNRECOGNIZEDFUNCTIONNAME(pfilefunc.getZfile_func64().getOpaque(), filestream, offset, origin);
		} else {
				uLong offsetTruncated = (uLong)offset;
				if (offsetTruncated != offset) {
					return -1;
				} else {
						return .UNRECOGNIZEDFUNCTIONNAME(pfilefunc.getZfile_func64().getOpaque(), filestream, offsetTruncated, origin);
				} 
		} 
	}
	public static Object call_ztell64(Object pfilefunc, Object filestream) {
		if (pfilefunc.getZfile_func64().getZseek64_file() != ((Object)0)) {
			return .UNRECOGNIZEDFUNCTIONNAME(pfilefunc.getZfile_func64().getOpaque(), filestream);
		} else {
				uLong tell_uLong = .UNRECOGNIZEDFUNCTIONNAME(pfilefunc.getZfile_func64().getOpaque(), filestream);
				if ((tell_uLong) == -1024) {
					return (ZPOS64_T)-1;
				} else {
						return tell_uLong;
				} 
		} 
	}
	public static Object fopen_file_func(Object opaque, Object filename, int mode) {
		FILE file = ((Object)0);
		byte mode_fopen = ((Object)0);
		if ((mode & (true)) == (true)) {
			mode_fopen = "rb";
		}  else if (mode & (true)) {
			mode_fopen = "r+b";
		}  else if (mode & (true)) {
			mode_fopen = "wb";
		} 
		if ((filename != ((Object)0)) && (mode_fopen != ((Object)0))) {
			file = .fopen(filename, mode_fopen);
		} 
		return file;
	}
	public static Object fopen64_file_func(Object opaque, Object filename, int mode) {
		FILE file = ((Object)0);
		byte mode_fopen = ((Object)0);
		if ((mode & (true)) == (true)) {
			mode_fopen = "rb";
		}  else if (mode & (true)) {
			mode_fopen = "r+b";
		}  else if (mode & (true)) {
			mode_fopen = "wb";
		} 
		if ((filename != ((Object)0)) && (mode_fopen != ((Object)0))) {
			file = .fopen64((byte)filename, mode_fopen);
		} 
		return file;
	}
	public static Object fread_file_func(Object opaque, Object stream, Object buf, Object size) {
		uLong ret = new uLong();
		ret = (uLong).fread(buf, 1, (size_t)size, (FILE)stream);
		return ret;
	}
	public static Object fwrite_file_func(Object opaque, Object stream, Object buf, Object size) {
		uLong ret = new uLong();
		ret = (uLong).fwrite(buf, 1, (size_t)size, (FILE)stream);
		return ret;
	}
	public static long ftell_file_func(Object opaque, Object stream) {
		long ret;
		ret = .ftell((FILE)stream);
		return ret;
	}
	public static Object ftell64_file_func(Object opaque, Object stream) {
		ZPOS64_T ret = new ZPOS64_T();
		ret = .ftello64((FILE)stream);
		return ret;
	}
	public static long fseek_file_func(Object opaque, Object stream, Object offset, int origin) {
		int fseek_origin = 0;
		long ret;
		switch (origin) {
		case (true):
				fseek_origin = 2;
				break;
		case (false):
				fseek_origin = 0;
				break;
		case (true):
				fseek_origin = 1;
				break;
		default:
				return -1;
		}
		ret = 0;
		if (.fseek((FILE)stream, offset, fseek_origin) != 0) {
			ret = -1;
		} 
		return ret;
	}
	public static long fseek64_file_func(Object opaque, Object stream, Object offset, int origin) {
		int fseek_origin = 0;
		long ret;
		switch (origin) {
		case (true):
				fseek_origin = 2;
				break;
		case (true):
				fseek_origin = 1;
				break;
		case (false):
				fseek_origin = 0;
				break;
		default:
				return -1;
		}
		ret = 0;
		if (.fseeko64((FILE)stream, offset, fseek_origin) != 0) {
			ret = -1;
		} 
		return ret;
	}
	public static int fclose_file_func(Object opaque, Object stream) {
		int ret;
		ret = .fclose((FILE)stream);
		return ret;
	}
	public static int ferror_file_func(Object opaque, Object stream) {
		int ret;
		ret = (((FILE)stream).get_flag() & -1024);
		return ret;
	}
	public static int load_segment(hashcat_ctx hashcat_ctx, hc_fp fp) {
		wl_data generatedWl_data = hashcat_ctx.getWl_data();
		wl_data_t wl_data = generatedWl_data;
		// NOTE: use (never changing) ->incr here instead of ->avail otherwise the buffer gets bigger and bigger
		wl_data.setPos(0);
		Byte generatedBuf = wl_data.getBuf();
		Object generatedIncr = wl_data.getIncr();
		wl_data.setCnt(fp.hc_fread(generatedBuf, 1, generatedIncr - 1000));
		Object generatedCnt = wl_data.getCnt();
		generatedBuf[generatedCnt] = 0;
		if (generatedCnt == 0) {
			return 0;
		} 
		if (generatedBuf[generatedCnt - 1] == (byte)'\n') {
			return 0;
		} 
		Object generatedAvail = wl_data.getAvail();
		while (!fp.hc_feof()) {
			if (generatedCnt == generatedAvail) {
				wl_data.setBuf((byte)ModernizedCProgram.hcrealloc(generatedBuf, generatedAvail, generatedIncr));
				generatedAvail += generatedIncr;
			} 
			int c = fp.hc_fgetc();
			if (c == (true)) {
				break;
			} 
			generatedBuf[generatedCnt] = (byte)c;
			generatedCnt++;
			if (c == (byte)'\n') {
				break;
			} 
		}
		// ensure stream ends with a newlineif (generatedBuf[generatedCnt - 1] != (byte)'\n') {
			generatedCnt++;
			generatedBuf[generatedCnt - 1] = (byte)'\n';
		} 
		return 0;
	}
	public static void get_next_word_lm(Byte buf, Object sz, Object len, Object off) {
		byte ptr = buf;
		for (u64 i = 0;
		 i < sz; ) {
			if (ptr >= (byte)'a' && ptr <= (byte)'z') {
				ptr -= -1024;
			} 
			if (i == 7) {
				off = i;
				len = i;
				return ;
			} 
			if (ptr != (byte)'\n') {
				continue;
			} 
			off = i + 1;
			if ((i > 0) && (buf[i - 1] == (byte)'\r')) {
				i--;
			} 
			len = i;
			return ;
		}
		off = sz;
		len = sz;
	}
	public static void get_next_word_uc(Byte buf, Object sz, Object len, Object off) {
		byte ptr = buf;
		for (u64 i = 0;
		 i < sz; ) {
			if (ptr >= (byte)'a' && ptr <= (byte)'z') {
				ptr -= -1024;
			} 
			if (ptr != (byte)'\n') {
				continue;
			} 
			off = i + 1;
			if ((i > 0) && (buf[i - 1] == (byte)'\r')) {
				i--;
			} 
			len = i;
			return ;
		}
		off = sz;
		len = sz;
	}
	public static void get_next_word_std(Byte buf, Object sz, Object len, Object off) {
		byte ptr = buf;
		for (u64 i = 0;
		 i < sz; ) {
			if (ptr != (byte)'\n') {
				continue;
			} 
			off = i + 1;
			if ((i > 0) && (buf[i - 1] == (byte)'\r')) {
				i--;
			} 
			len = i;
			return ;
		}
		off = sz;
		len = sz;
	}
	public static void get_next_word(hashcat_ctx hashcat_ctx, hc_fp fp, byte out_buf, Object out_len) {
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = hashcat_ctx.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		wl_data generatedWl_data = hashcat_ctx.getWl_data();
		wl_data_t wl_data = generatedWl_data;
		Object generatedPos = wl_data.getPos();
		Object generatedCnt = wl_data.getCnt();
		Byte generatedBuf = wl_data.getBuf();
		boolean generatedIconv_enabled = wl_data.getIconv_enabled();
		Byte generatedIconv_tmp = wl_data.getIconv_tmp();
		Object generatedIconv_ctx = wl_data.getIconv_ctx();
		Object generatedRule_len_l = user_options_extra.getRule_len_l();
		Object generatedRule_buf_l = user_options.getRule_buf_l();
		while (generatedPos < generatedCnt) {
			u64 off = new u64();
			u64 len = new u64();
			byte ptr = generatedBuf + generatedPos;
			.UNRECOGNIZEDFUNCTIONNAME(ptr, generatedCnt - generatedPos, len, off);
			generatedPos += off;
			len = (u32)hashcat_ctx.convert_from_hex(ptr, len);
			if (generatedIconv_enabled == true) {
				byte iconv_ptr = generatedIconv_tmp;
				size_t iconv_sz = -1024;
				size_t ptr_len = len;
				size_t iconv_rc = .iconv(generatedIconv_ctx, ptr, ptr_len, iconv_ptr, iconv_sz);
				if (iconv_rc == (size_t)-1) {
					continue;
				} 
				ptr = generatedIconv_tmp;
				len = -1024 - iconv_sz;
			} 
			if (ModernizedCProgram.run_rule_engine(generatedRule_len_l, generatedRule_buf_l)) {
				if (len >= 256) {
					continue;
				} 
				byte[] rule_buf_out = new byte[256];
				.memset(rule_buf_out, 0, );
				int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_l, generatedRule_len_l, ptr, (u32)len, rule_buf_out);
				if (rule_len_out < 0) {
					continue;
				} 
			} 
			if (len > 256) {
				continue;
			} 
			out_buf = ptr;
			out_len = (u32)len;
			return ;
		}
		if (fp.hc_feof()) {
			.fprintf((_iob[2]), "BUG feof()!!\n");
			return ;
		} 
		ModernizedCProgram.load_segment(hashcat_ctx, fp);
		ModernizedCProgram.get_next_word(hashcat_ctx, fp, out_buf, out_len);
	}
	public static void pw_base_add(hc_device_param device_param, pw_pre pw_pre) {
		Object generatedPws_base_cnt = device_param.getPws_base_cnt();
		Object generatedKernel_power = device_param.getKernel_power();
		pw_pre generatedPws_base_buf = device_param.getPws_base_buf();
		if (generatedPws_base_cnt < generatedKernel_power) {
			.memcpy(generatedPws_base_buf + generatedPws_base_cnt, pw_pre, );
			generatedPws_base_cnt++;
		} else {
				.fprintf((_iob[2]), "BUG pw_base_add()!!\n");
				return ;
		} 
	}
	public static int count_words(hashcat_ctx hashcat_ctx, hc_fp fp, Object dictfile, Object result) {
		combinator_ctx generatedCombinator_ctx = hashcat_ctx.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		straight_ctx generatedStraight_ctx = hashcat_ctx.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		mask_ctx generatedMask_ctx = hashcat_ctx.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		user_options_extra generatedUser_options_extra = hashcat_ctx.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		wl_data generatedWl_data = hashcat_ctx.getWl_data();
		wl_data_t wl_data = generatedWl_data;
		//hc_signal (NULL);
		dictstat_t d = new dictstat_t();
		d.setCnt(0);
		stat generatedStat = d.getStat();
		if (.fstat(fp.hc_fileno(), generatedStat)) {
			result = 0;
			return 0;
		} 
		generatedStat.setSt_mode(0);
		generatedStat.setSt_nlink(0);
		generatedStat.setSt_uid(0);
		generatedStat.setSt_gid(0);
		generatedStat.setSt_rdev(0);
		generatedStat.setSt_atime(0);
		Object generatedEncoding_from = d.getEncoding_from();
		.memset(generatedEncoding_from, 0, );
		Object generatedEncoding_to = d.getEncoding_to();
		.memset(generatedEncoding_to, 0, );
		.strncpy(generatedEncoding_from, generatedEncoding_from,  - 1);
		.strncpy(generatedEncoding_to, generatedEncoding_to,  - 1);
		Object generatedSt_size = generatedStat.getSt_size();
		if (generatedSt_size == 0) {
			result = 0;
			return 0;
		} 
		u64 cached_cnt = ModernizedCProgram.dictstat_find(hashcat_ctx, d);
		Object generatedRule_len_l = user_options_extra.getRule_len_l();
		Object generatedRule_buf_l = user_options.getRule_buf_l();
		Object generatedAttack_kern = user_options_extra.getAttack_kern();
		Object generatedKernel_rules_cnt = straight_ctx.getKernel_rules_cnt();
		Object generatedOpti_type = hashconfig.getOpti_type();
		Object generatedAttack_mode = user_options.getAttack_mode();
		Object generatedBfs_cnt = mask_ctx.getBfs_cnt();
		Object generatedCombs_cnt = combinator_ctx.getCombs_cnt();
		if (ModernizedCProgram.run_rule_engine(generatedRule_len_l, generatedRule_buf_l) == 0) {
			if (cached_cnt) {
				u64 keyspace = cached_cnt;
				if (generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
					if (ModernizedCProgram.overflow_check_u64_mul(keyspace, generatedKernel_rules_cnt) == 0) {
						return -1;
					} 
					keyspace *= generatedKernel_rules_cnt;
				}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
					if (((generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) && (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2)) {
						if (ModernizedCProgram.overflow_check_u64_mul(keyspace, generatedBfs_cnt) == 0) {
							return -1;
						} 
						keyspace *= generatedBfs_cnt;
					} else {
							if (ModernizedCProgram.overflow_check_u64_mul(keyspace, generatedCombs_cnt) == 0) {
								return -1;
							} 
							keyspace *= generatedCombs_cnt;
					} 
				} 
				cache_hit_t cache_hit = new cache_hit_t();
				cache_hit.setDictfile(dictfile);
				generatedStat.setSt_size(generatedSt_size);
				cache_hit.setCached_cnt(cached_cnt);
				cache_hit.setKeyspace(keyspace);
				hashcat_ctx.event_call((event_identifier.EVENT_WORDLIST_CACHE_HIT), (cache_hit), ());
				result = keyspace;
				return 0;
			} 
		} 
		time_t rt_start = new time_t();
		.time(rt_start);
		time_t now = 0;
		time_t prev = 0;
		u64 comp = 0;
		u64 cnt = 0;
		u64 cnt2 = 0;
		Object generatedCnt = wl_data.getCnt();
		Byte generatedBuf = wl_data.getBuf();
		boolean generatedIconv_enabled = wl_data.getIconv_enabled();
		Byte generatedIconv_tmp = wl_data.getIconv_tmp();
		Object generatedIconv_ctx = wl_data.getIconv_ctx();
		while (!fp.hc_feof()) {
			ModernizedCProgram.load_segment(hashcat_ctx, fp);
			comp += generatedCnt;
			u64 i = 0;
			while (i < generatedCnt) {
				u64 len = new u64();
				u64 off = new u64();
				byte ptr = generatedBuf + i;
				.UNRECOGNIZEDFUNCTIONNAME(ptr, generatedCnt - i, len, off);
				i += off;
				len = (u32)hashcat_ctx.convert_from_hex(ptr, len);
				if (generatedIconv_enabled == true) {
					byte iconv_ptr = generatedIconv_tmp;
					size_t iconv_sz = -1024;
					size_t ptr_len = len;
					size_t iconv_rc = .iconv(generatedIconv_ctx, ptr, ptr_len, iconv_ptr, iconv_sz);
					if (iconv_rc == (size_t)-1) {
						continue;
					} 
					ptr = generatedIconv_tmp;
					len = -1024 - iconv_sz;
				} 
				if (ModernizedCProgram.run_rule_engine(generatedRule_len_l, generatedRule_buf_l)) {
					if (len >= 256) {
						continue;
					} 
					byte[] rule_buf_out = new byte[256];
					.memset(rule_buf_out, 0, );
					int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_l, generatedRule_len_l, ptr, (u32)len, rule_buf_out);
					if (rule_len_out < 0) {
						continue;
					} 
				} 
				cnt2++;
				if (len > 256) {
					continue;
				} 
				generatedCnt++;
				if (generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
					if (ModernizedCProgram.overflow_check_u64_add(cnt, generatedKernel_rules_cnt) == 0) {
						return -1;
					} 
					cnt += generatedKernel_rules_cnt;
				}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
					if (((generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) && (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2)) {
						if (ModernizedCProgram.overflow_check_u64_add(cnt, generatedBfs_cnt) == 0) {
							return -1;
						} 
						cnt += generatedBfs_cnt;
					} else {
							if (ModernizedCProgram.overflow_check_u64_add(cnt, generatedCombs_cnt) == 0) {
								return -1;
							} 
							cnt += generatedCombs_cnt;
					} 
				} 
			}
			.time(now);
			if ((now - prev) == 0) {
				continue;
			} 
			.time(prev);
			double percent = ((double)comp / (double)generatedSt_size) * 100;
			if (percent < 100) {
				cache_generate_t cache_generate = new cache_generate_t();
				cache_generate.setDictfile(dictfile);
				cache_generate.setComp(comp);
				cache_generate.setPercent(percent);
				cache_generate.setCnt(cnt);
				cache_generate.setCnt2(cnt2);
				hashcat_ctx.event_call((event_identifier.EVENT_WORDLIST_CACHE_GENERATE), (cache_generate), ());
			} 
		}
		time_t rt_stop = new time_t();
		.time(rt_stop);
		cache_generate_t cache_generate = new cache_generate_t();
		cache_generate.setDictfile(dictfile);
		cache_generate.setComp(comp);
		cache_generate.setPercent(100);
		cache_generate.setCnt(cnt);
		cache_generate.setCnt2(cnt2);
		cache_generate.setRuntime(rt_stop - rt_start);
		hashcat_ctx.event_call((event_identifier.EVENT_WORDLIST_CACHE_GENERATE), (cache_generate), ());
		ModernizedCProgram.dictstat_append(hashcat_ctx, d)//hc_signal (sigHandler_default);;//hc_signal (sigHandler_default);
		result = cnt;
		return 0;
	}
	/* gzappend -- command to append to a gzip file
	
	  Copyright (C) 2003, 2012 Mark Adler, all rights reserved
	  version 1.2, 11 Oct 2012
	
	  This software is provided 'as-is', without any express or implied
	  warranty.  In no event will the author be held liable for any damages
	  arising from the use of this software.
	
	  Permission is granted to anyone to use this software for any purpose,
	  including commercial applications, and to alter it and redistribute it
	  freely, subject to the following restrictions:
	
	  1. The origin of this software must not be misrepresented; you must not
	     claim that you wrote the original software. If you use this software
	     in a product, an acknowledgment in the product documentation would be
	     appreciated but is not required.
	  2. Altered source versions must be plainly marked as such, and must not be
	     misrepresented as being the original software.
	  3. This notice may not be removed or altered from any source distribution.
	
	  Mark Adler    madler@alumni.caltech.edu
	 */
	/*
	 * Change history:
	 *
	 * 1.0  19 Oct 2003     - First version
	 * 1.1   4 Nov 2003     - Expand and clarify some comments and notes
	 *                      - Add version and copyright to help
	 *                      - Send help to stdout instead of stderr
	 *                      - Add some preemptive typecasts
	 *                      - Add L to constants in lseek() calls
	 *                      - Remove some debugging information in error messages
	 *                      - Use new data_type definition for zlib 1.2.1
	 *                      - Simplfy and unify file operations
	 *                      - Finish off gzip file in gztack()
	 *                      - Use deflatePrime() instead of adding empty blocks
	 *                      - Keep gzip file clean on appended file read errors
	 *                      - Use in-place rotate instead of auxiliary buffer
	 *                        (Why you ask?  Because it was fun to write!)
	 * 1.2  11 Oct 2012     - Fix for proper z_const usage
	 *                      - Check for input buffer malloc failure
	 */
	/*
	   gzappend takes a gzip file and appends to it, compressing files from the
	   command line or data from stdin.  The gzip file is written to directly, to
	   avoid copying that file, in case it's large.  Note that this results in the
	   unfriendly behavior that if gzappend fails, the gzip file is corrupted.
	
	   This program was written to illustrate the use of the new Z_BLOCK option of
	   zlib 1.2.x's inflate() function.  This option returns from inflate() at each
	   block boundary to facilitate locating and modifying the last block bit at
	   the start of the final deflate block.  Also whether using Z_BLOCK or not,
	   another required feature of zlib 1.2.x is that inflate() now provides the
	   number of unusued bits in the last input byte used.  gzappend will not work
	   with versions of zlib earlier than 1.2.1.
	
	   gzappend first decompresses the gzip file internally, discarding all but
	   the last 32K of uncompressed data, and noting the location of the last block
	   bit and the number of unused bits in the last byte of the compressed data.
	   The gzip trailer containing the CRC-32 and length of the uncompressed data
	   is verified.  This trailer will be later overwritten.
	
	   Then the last block bit is cleared by seeking back in the file and rewriting
	   the byte that contains it.  Seeking forward, the last byte of the compressed
	   data is saved along with the number of unused bits to initialize deflate.
	
	   A deflate process is initialized, using the last 32K of the uncompressed
	   data from the gzip file to initialize the dictionary.  If the total
	   uncompressed data was less than 32K, then all of it is used to initialize
	   the dictionary.  The deflate output bit buffer is also initialized with the
	   last bits from the original deflate stream.  From here on, the data to
	   append is simply compressed using deflate, and written to the gzip file.
	   When that is complete, the new CRC-32 and uncompressed length are written
	   as the trailer of the gzip file.
	 */
	/* print an error message and terminate with extreme prejudice */
	public static void bye(Byte msg1, Byte msg2) {
		.fprintf((_iob[2]), "gzappend error: %s%s\n", msg1, msg2);
		.exit(1/* return the greatest common divisor of a and b using Euclid's algorithm,
		   modified to be fast when one argument much greater than the other, and
		   coded to avoid unnecessary swapping */);
	}
	public static int gcd(int a, int b) {
		int c;
		while (a && b) {
			if (a > b) {
				c = b;
				while (a - c >= c) {
					c <<=  1;
				}
				a -= c;
			} else {
					c = a;
					while (b - c >= c) {
						c <<=  1;
					}
					b -= c;
			} 
		}
		return a + b;
	}
	/* rotate list[0..len-1] left by rot positions, in place */
	public static void rotate(byte list, int len, int rot) {
		byte tmp;
		int cycles;
		byte start;
		byte last;
		byte to;
		byte from;
		if (len < /* normalize rot and handle degenerate cases */2) {
			return ;
		} 
		if (rot >= len) {
			rot %= len;
		} 
		if (rot == 0) {
			return ;
		} 
		last = list + (len - /* pointer to last entry in list */1);
		if (rot == /* do simple left shift by one */1) {
			tmp = list;
			.memcpy(list, list + 1, len - 1);
			last = tmp;
			return ;
		} 
		if (rot == len - /* do simple right shift by one */1) {
			tmp = last;
			.memmove(list + 1, list, len - 1);
			list = tmp;
			return ;
		} 
		cycles = ModernizedCProgram.gcd(len, /* otherwise do rotate as a set of cycles in place *//* number of cycles */rot);
		do {
			start = from = list + /* start index is arbitrary */cycles;
			tmp = /* save entry to be overwritten */from;
			for (; ; ) {
				to = /* next step in cycle */from;
				from += /* go right rot positions */rot;
				if (from > last) {
					from -= /* (pointer better not wrap) */len;
				} 
				if (from == /* all but one shifted */start) {
					break;
				} 
				to = /* shift left */from;
			}
			to = /* complete the circle */tmp;
		} while (--cycles);
	}
	/* reload buffer */
	public static int readin() {
		int len;
		Object generatedFd = this.getFd();
		Object generatedBuf = this.getBuf();
		Object generatedSize = this.getSize();
		len = .read(generatedFd, generatedBuf, 1 << generatedSize);
		Object generatedName = this.getName();
		if (len == -1) {
			ModernizedCProgram.bye("error reading ", generatedName);
		} 
		this.setLeft((int)len);
		this.setNext(generatedBuf);
		return len;
	}
	/* read from file in, exit if end-of-file */
	public static int readmore() {
		Object generatedName = this.getName();
		if (in.readin() == 0) {
			ModernizedCProgram.bye("unexpected end of ", generatedName);
		} 
		return 0;
	}
	/* skip over n bytes of in */
	public static void skip(int n) {
		int bypass;
		Object generatedLeft = this.getLeft();
		Object generatedSize = this.getSize();
		Object generatedFd = this.getFd();
		Object generatedName = this.getName();
		if (n > generatedLeft) {
			n -= generatedLeft;
			bypass = n & ~((-1024 << generatedSize) - 1);
			if (bypass) {
				if (.lseek(generatedFd, (off_t)bypass, 1) == -1) {
					ModernizedCProgram.bye("seeking ", generatedName);
				} 
				n -= bypass;
			} 
			in.readmore();
			if (n > generatedLeft) {
				ModernizedCProgram.bye("unexpected end of ", generatedName);
			} 
		} 
		generatedLeft -= n;
		Object generatedNext = this.getNext();
		generatedNext += n;
	}
	/* read a four-byte unsigned integer, little-endian, from in */
	public static long read4() {
		long val;
		val = ();
		val += (int)() << 8;
		val += (long)() << 16;
		val += (long)() << 24;
		return val;
	}
	/* skip over gzip header */
	public static void gzheader() {
		int flags;
		int n;
		Object generatedName = this.getName();
		if (() != 31 || () != 139) {
			ModernizedCProgram.bye(generatedName, " not a gzip file");
		} 
		if (() != 8) {
			ModernizedCProgram.bye("unknown compression method in", generatedName);
		} 
		flags = ();
		if (flags & -1024) {
			ModernizedCProgram.bye("unknown header flags set in", generatedName);
		} 
		in.skip(6);
		if (flags & 4) {
			n = ();
			n += (int)(()) << 8;
			in.skip(n);
		} 
		if (flags & 8) {
			while (() != 0) {
				;
			}
		} 
		if (flags & 16) {
			while (() != 0) {
				;
			}
		} 
		if (flags & 2) {
			in.skip(2/* decompress gzip file "name", return strm with a deflate stream ready to
			   continue compression of the data in the gzip file, and return a file
			   descriptor pointing to where to write the compressed data -- the deflate
			   stream is initialized to compress using level "level" */);
		} 
	}
	/* 7zBuf.c -- Byte Buffer
	2017-04-03 : Igor Pavlov : Public domain */
	public static void Buf_Init() {
		this.setData(0);
		this.setSize(0);
	}
	public static int Buf_Create(Object size, Object alloc) {
		this.setSize(0);
		if (size == 0) {
			this.setData(0);
			return 1;
		} 
		this.setData((Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, size));
		Object generatedData = this.getData();
		if (generatedData) {
			this.setSize(size);
			return 1;
		} 
		return 0;
	}
	public static void Buf_Free(Object alloc) {
		Object generatedData = this.getData();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedData);
		this.setData(0);
		this.setSize(0);
	}
	public static int hashcat_get_status(hashcat_ctx hashcat_ctx, hashcat_status hashcat_status) {
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		.memset(hashcat_status, 0, );
		// way too earlyif (status_ctx == ((Object)0)) {
			return -1;
		} 
		if (status_ctx.getAccessible() == 0) {
			if (status_ctx.getHashcat_status_final().getMsec_running() > 0) {
				.memcpy(hashcat_status, status_ctx.getHashcat_status_final(), );
				return 0;
			} 
			return -1;
		} 
		hashcat_status.setDigests_cnt(ModernizedCProgram.status_get_digests_cnt(hashcat_ctx));
		hashcat_status.setDigests_done(ModernizedCProgram.status_get_digests_done(hashcat_ctx));
		hashcat_status.setDigests_percent(ModernizedCProgram.status_get_digests_percent(hashcat_ctx));
		hashcat_status.setHash_target(ModernizedCProgram.status_get_hash_target(hashcat_ctx));
		hashcat_status.setHash_name(ModernizedCProgram.status_get_hash_name(hashcat_ctx));
		hashcat_status.setGuess_base(ModernizedCProgram.status_get_guess_base(hashcat_ctx));
		hashcat_status.setGuess_base_offset(ModernizedCProgram.status_get_guess_base_offset(hashcat_ctx));
		hashcat_status.setGuess_base_count(ModernizedCProgram.status_get_guess_base_count(hashcat_ctx));
		hashcat_status.setGuess_base_percent(ModernizedCProgram.status_get_guess_base_percent(hashcat_ctx));
		hashcat_status.setGuess_mod(ModernizedCProgram.status_get_guess_mod(hashcat_ctx));
		hashcat_status.setGuess_mod_offset(ModernizedCProgram.status_get_guess_mod_offset(hashcat_ctx));
		hashcat_status.setGuess_mod_count(ModernizedCProgram.status_get_guess_mod_count(hashcat_ctx));
		hashcat_status.setGuess_mod_percent(ModernizedCProgram.status_get_guess_mod_percent(hashcat_ctx));
		hashcat_status.setGuess_charset(ModernizedCProgram.status_get_guess_charset(hashcat_ctx));
		hashcat_status.setGuess_mask_length(ModernizedCProgram.status_get_guess_mask_length(hashcat_ctx));
		hashcat_status.setGuess_mode(ModernizedCProgram.status_get_guess_mode(hashcat_ctx));
		hashcat_status.setMsec_paused(ModernizedCProgram.status_get_msec_paused(hashcat_ctx));
		hashcat_status.setMsec_running(ModernizedCProgram.status_get_msec_running(hashcat_ctx));
		hashcat_status.setMsec_real(ModernizedCProgram.status_get_msec_real(hashcat_ctx));
		hashcat_status.setProgress_mode(ModernizedCProgram.status_get_progress_mode(hashcat_ctx));
		hashcat_status.setProgress_finished_percent(ModernizedCProgram.status_get_progress_finished_percent(hashcat_ctx));
		hashcat_status.setProgress_cur_relative_skip(ModernizedCProgram.status_get_progress_cur_relative_skip(hashcat_ctx));
		hashcat_status.setProgress_cur(ModernizedCProgram.status_get_progress_cur(hashcat_ctx));
		hashcat_status.setProgress_done(ModernizedCProgram.status_get_progress_done(hashcat_ctx));
		hashcat_status.setProgress_end_relative_skip(ModernizedCProgram.status_get_progress_end_relative_skip(hashcat_ctx));
		hashcat_status.setProgress_end(ModernizedCProgram.status_get_progress_end(hashcat_ctx));
		hashcat_status.setProgress_ignore(ModernizedCProgram.status_get_progress_ignore(hashcat_ctx));
		hashcat_status.setProgress_rejected(ModernizedCProgram.status_get_progress_rejected(hashcat_ctx));
		hashcat_status.setProgress_rejected_percent(ModernizedCProgram.status_get_progress_rejected_percent(hashcat_ctx));
		hashcat_status.setProgress_restored(ModernizedCProgram.status_get_progress_restored(hashcat_ctx));
		hashcat_status.setProgress_skip(ModernizedCProgram.status_get_progress_skip(hashcat_ctx));
		hashcat_status.setRestore_point(ModernizedCProgram.status_get_restore_point(hashcat_ctx));
		hashcat_status.setRestore_total(ModernizedCProgram.status_get_restore_total(hashcat_ctx));
		hashcat_status.setRestore_percent(ModernizedCProgram.status_get_restore_percent(hashcat_ctx));
		hashcat_status.setSalts_cnt(ModernizedCProgram.status_get_salts_cnt(hashcat_ctx));
		hashcat_status.setSalts_done(ModernizedCProgram.status_get_salts_done(hashcat_ctx));
		hashcat_status.setSalts_percent(ModernizedCProgram.status_get_salts_percent(hashcat_ctx));
		hashcat_status.setSession(ModernizedCProgram.status_get_session(hashcat_ctx));
		hashcat_status.setStatus_string(ModernizedCProgram.status_get_status_string(hashcat_ctx));
		hashcat_status.setStatus_number(ModernizedCProgram.status_get_status_number(hashcat_ctx));
		hashcat_status.setTime_estimated_absolute(ModernizedCProgram.status_get_time_estimated_absolute(hashcat_ctx));
		hashcat_status.setTime_estimated_relative(ModernizedCProgram.status_get_time_estimated_relative(hashcat_ctx));
		hashcat_status.setTime_started_absolute(ModernizedCProgram.status_get_time_started_absolute(hashcat_ctx));
		hashcat_status.setTime_started_relative(ModernizedCProgram.status_get_time_started_relative(hashcat_ctx));
		hashcat_status.setCpt_cur_min(ModernizedCProgram.status_get_cpt_cur_min(hashcat_ctx));
		hashcat_status.setCpt_cur_hour(ModernizedCProgram.status_get_cpt_cur_hour(hashcat_ctx));
		hashcat_status.setCpt_cur_day(ModernizedCProgram.status_get_cpt_cur_day(hashcat_ctx));
		hashcat_status.setCpt_avg_min(ModernizedCProgram.status_get_cpt_avg_min(hashcat_ctx));
		hashcat_status.setCpt_avg_hour(ModernizedCProgram.status_get_cpt_avg_hour(hashcat_ctx));
		hashcat_status.setCpt_avg_day(ModernizedCProgram.status_get_cpt_avg_day(hashcat_ctx));
		hashcat_status.setCpt(ModernizedCProgram.status_get_cpt(hashcat_ctx))// multiple devices;// multiple devices
		hashcat_status.setDevice_info_cnt(ModernizedCProgram.status_get_device_info_cnt(hashcat_ctx));
		hashcat_status.setDevice_info_active(ModernizedCProgram.status_get_device_info_active(hashcat_ctx));
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			device_info.setSkipped_dev(ModernizedCProgram.status_get_skipped_dev(hashcat_ctx, device_id));
			device_info.setSkipped_warning_dev(ModernizedCProgram.status_get_skipped_warning_dev(hashcat_ctx, device_id));
			device_info.setHashes_msec_dev(ModernizedCProgram.status_get_hashes_msec_dev(hashcat_ctx, device_id));
			device_info.setHashes_msec_dev_benchmark(ModernizedCProgram.status_get_hashes_msec_dev_benchmark(hashcat_ctx, device_id));
			device_info.setExec_msec_dev(ModernizedCProgram.status_get_exec_msec_dev(hashcat_ctx, device_id));
			device_info.setSpeed_sec_dev(ModernizedCProgram.status_get_speed_sec_dev(hashcat_ctx, device_id));
			device_info.setGuess_candidates_dev(ModernizedCProgram.status_get_guess_candidates_dev(hashcat_ctx, device_id));
			device_info.setHwmon_dev(ModernizedCProgram.status_get_hwmon_dev(hashcat_ctx, device_id));
			device_info.setCorespeed_dev(ModernizedCProgram.status_get_corespeed_dev(hashcat_ctx, device_id));
			device_info.setMemoryspeed_dev(ModernizedCProgram.status_get_memoryspeed_dev(hashcat_ctx, device_id));
			device_info.setProgress_dev(ModernizedCProgram.status_get_progress_dev(hashcat_ctx, device_id));
			device_info.setRuntime_msec_dev(ModernizedCProgram.status_get_runtime_msec_dev(hashcat_ctx, device_id));
			device_info.setKernel_accel_dev(ModernizedCProgram.status_get_kernel_accel_dev(hashcat_ctx, device_id));
			device_info.setKernel_loops_dev(ModernizedCProgram.status_get_kernel_loops_dev(hashcat_ctx, device_id));
			device_info.setKernel_threads_dev(ModernizedCProgram.status_get_kernel_threads_dev(hashcat_ctx, device_id));
			device_info.setVector_width_dev(ModernizedCProgram.status_get_vector_width_dev(hashcat_ctx, device_id));
			device_info.setSalt_pos_dev(ModernizedCProgram.status_get_salt_pos_dev(hashcat_ctx, device_id));
			device_info.setInnerloop_pos_dev(ModernizedCProgram.status_get_innerloop_pos_dev(hashcat_ctx, device_id));
			device_info.setInnerloop_left_dev(ModernizedCProgram.status_get_innerloop_left_dev(hashcat_ctx, device_id));
			device_info.setIteration_pos_dev(ModernizedCProgram.status_get_iteration_pos_dev(hashcat_ctx, device_id));
			device_info.setIteration_left_dev(ModernizedCProgram.status_get_iteration_left_dev(hashcat_ctx, device_id));
		}
		hashcat_status.setHashes_msec_all(ModernizedCProgram.status_get_hashes_msec_all(hashcat_ctx));
		hashcat_status.setExec_msec_all(ModernizedCProgram.status_get_exec_msec_all(hashcat_ctx));
		hashcat_status.setSpeed_sec_all(ModernizedCProgram.status_get_speed_sec_all(hashcat_ctx));
		return 0;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int get_runtime_left(Object hashcat_ctx) {
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		user_options_t user_options = hashcat_ctx.getUser_options();
		double msec_paused = status_ctx.getMsec_paused();
		if (status_ctx.getDevices_status() == status_rc.STATUS_PAUSED) {
			double msec_paused_tmp = ModernizedCProgram.hc_timer_get(status_ctx.getTimer_paused());
			msec_paused += msec_paused_tmp;
		} 
		time_t runtime_cur = new time_t();
		.time(runtime_cur);
		int runtime_left = (int)(status_ctx.getRuntime_start() + user_options.getRuntime() + (msec_paused / 1000) - runtime_cur);
		return runtime_left;
	}
	public static Object thread_monitor(Object p) {
		hashcat_ctx_t hashcat_ctx = (hashcat_ctx_t)p;
		// we should give back some useful returncode// we should give back some useful returncodehashcat_ctx.monitor();
		return ((Object)0);
	}
	/* BYFOUR */
	/* not first */
	/* wait for the other guy to finish (not efficient, but rare) */
	/* write out CRC tables to crc32.h */
	/* BYFOUR */
	/* MAKECRCH */
	/* MAKECRCH */
	/* !DYNAMIC_CRC_TABLE */
	/* ========================================================================
	 * Tables of CRC-32s of all single-byte values, made by make_crc_table().
	 */
	/* DYNAMIC_CRC_TABLE */
	/* =========================================================================
	 * This function can be used by asm versions of crc32()
	 */
	public static Object get_crc_table() {
		return (z_crc_t)/* DYNAMIC_CRC_TABLE */crc_table/* ========================================================================= */;
	}
	/* ========================================================================= */
	public static long crc32_z(long crc, Object buf, Object len) {
		if (buf == 0) {
			return -1024;
		} 
		if ( == /* DYNAMIC_CRC_TABLE */) {
			z_crc_t endian = new z_crc_t();
			endian = 1;
			if (((byte)(endian))) {
				return ModernizedCProgram.crc32_little(crc, buf, len);
			} else {
					return ModernizedCProgram.crc32_big(crc, buf, len);
			} 
		} 
		crc = crc ^ /* BYFOUR */-1024;
		while (len >= 8) {
			crc = crc_table[0][((int)crc ^ (buf++)) & -1024] ^ (crc >> 8);
			crc = crc_table[0][((int)crc ^ (buf++)) & -1024] ^ (crc >> 8);
			crc = crc_table[0][((int)crc ^ (buf++)) & -1024] ^ (crc >> 8);
			crc = crc_table[0][((int)crc ^ (buf++)) & -1024] ^ (crc >> 8);
			crc = crc_table[0][((int)crc ^ (buf++)) & -1024] ^ (crc >> 8);
			crc = crc_table[0][((int)crc ^ (buf++)) & -1024] ^ (crc >> 8);
			crc = crc_table[0][((int)crc ^ (buf++)) & -1024] ^ (crc >> 8);
			crc = crc_table[0][((int)crc ^ (buf++)) & -1024] ^ (crc >> 8);
			len -= 8;
		}
		if (len) {
			do {
				crc = crc_table[0][((int)crc ^ (buf++)) & -1024] ^ (crc >> 8);
			} while (--len);
		} 
		return crc ^ -1024;
	}
	/* ========================================================================= */
	public static long crc32(long crc, Object buf, Object len) {
		return ModernizedCProgram.crc32_z(crc, buf, len/*
		   This BYFOUR code accesses the passed unsigned char * buffer with a 32-bit
		   integer pointer type. This violates the strict aliasing rule, where a
		   compiler can assume, for optimization purposes, that two pointers to
		   fundamentally different types won't ever point to the same memory. This can
		   manifest as a problem only if one of the pointers is written to. This code
		   only reads from those pointers. So long as this code remains isolated in
		   this compilation unit, there won't be a problem. For this reason, this code
		   should not be copied and pasted into a compilation unit in which other code
		   writes to the buffer that is passed to these routines.
		 */);
	}
	/* crc32.c -- compute the CRC-32 of a data stream
	 * Copyright (C) 1995-2006, 2010, 2011, 2012, 2016 Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 *
	 * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
	 * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
	 * tables for updating the shift register in one step with three exclusive-ors
	 * instead of four steps with four exclusive-ors.  This results in about a
	 * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
	 */
	/* @(#) $Id$ */
	/*
	  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
	  protection on the static variables used to control the first-use generation
	  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
	  first call get_crc_table() to initialize the tables before allowing more than
	  one thread to use crc32().
	
	  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.
	 */
	/* !DYNAMIC_CRC_TABLE */
	/* MAKECRCH */
	/* for STDC and FAR definitions */
	/* Definitions for doing the crc four data bytes at a time. */
	/* ========================================================================= */
	/* ========================================================================= */
	public static long crc32_little(long crc, Object buf, Object len) {
		z_crc_t c = new z_crc_t();
		z_crc_t buf4 = new z_crc_t();
		c = (z_crc_t)crc;
		c = ~c;
		while (len && ((ptrdiff_t)buf & 3)) {
			c = crc_table[0][(c ^ buf++) & -1024] ^ (c >> 8);
			len--;
		}
		buf4 = (z_crc_t)(Object)buf;
		while (len >= 32) {
			c ^=  buf4++;
			c = crc_table[3][c & -1024] ^ crc_table[2][(c >> 8) & -1024] ^ crc_table[1][(c >> 16) & -1024] ^ crc_table[0][c >> 24];
			c ^=  buf4++;
			c = crc_table[3][c & -1024] ^ crc_table[2][(c >> 8) & -1024] ^ crc_table[1][(c >> 16) & -1024] ^ crc_table[0][c >> 24];
			c ^=  buf4++;
			c = crc_table[3][c & -1024] ^ crc_table[2][(c >> 8) & -1024] ^ crc_table[1][(c >> 16) & -1024] ^ crc_table[0][c >> 24];
			c ^=  buf4++;
			c = crc_table[3][c & -1024] ^ crc_table[2][(c >> 8) & -1024] ^ crc_table[1][(c >> 16) & -1024] ^ crc_table[0][c >> 24];
			c ^=  buf4++;
			c = crc_table[3][c & -1024] ^ crc_table[2][(c >> 8) & -1024] ^ crc_table[1][(c >> 16) & -1024] ^ crc_table[0][c >> 24];
			c ^=  buf4++;
			c = crc_table[3][c & -1024] ^ crc_table[2][(c >> 8) & -1024] ^ crc_table[1][(c >> 16) & -1024] ^ crc_table[0][c >> 24];
			c ^=  buf4++;
			c = crc_table[3][c & -1024] ^ crc_table[2][(c >> 8) & -1024] ^ crc_table[1][(c >> 16) & -1024] ^ crc_table[0][c >> 24];
			c ^=  buf4++;
			c = crc_table[3][c & -1024] ^ crc_table[2][(c >> 8) & -1024] ^ crc_table[1][(c >> 16) & -1024] ^ crc_table[0][c >> 24];
			len -= 32;
		}
		while (len >= 4) {
			c ^=  buf4++;
			c = crc_table[3][c & -1024] ^ crc_table[2][(c >> 8) & -1024] ^ crc_table[1][(c >> 16) & -1024] ^ crc_table[0][c >> 24];
			len -= 4;
		}
		buf = (byte)buf4;
		if (len) {
			do {
				c = crc_table[0][(c ^ buf++) & -1024] ^ (c >> 8);
			} while (--len);
		} 
		c = ~c;
		return (long)c/* ========================================================================= */;
	}
	/* ========================================================================= */
	public static long crc32_big(long crc, Object buf, Object len) {
		z_crc_t c = new z_crc_t();
		z_crc_t buf4 = new z_crc_t();
		c = (((((z_crc_t)crc) >> 24) & -1024) + ((((z_crc_t)crc) >> 8) & -1024) + ((((z_crc_t)crc) & -1024) << 8) + ((((z_crc_t)crc) & -1024) << 24));
		c = ~c;
		while (len && ((ptrdiff_t)buf & 3)) {
			c = crc_table[4][(c >> 24) ^ buf++] ^ (c << 8);
			len--;
		}
		buf4 = (z_crc_t)(Object)buf;
		while (len >= 32) {
			c ^=  buf4++;
			c = crc_table[4][c & -1024] ^ crc_table[5][(c >> 8) & -1024] ^ crc_table[6][(c >> 16) & -1024] ^ crc_table[7][c >> 24];
			c ^=  buf4++;
			c = crc_table[4][c & -1024] ^ crc_table[5][(c >> 8) & -1024] ^ crc_table[6][(c >> 16) & -1024] ^ crc_table[7][c >> 24];
			c ^=  buf4++;
			c = crc_table[4][c & -1024] ^ crc_table[5][(c >> 8) & -1024] ^ crc_table[6][(c >> 16) & -1024] ^ crc_table[7][c >> 24];
			c ^=  buf4++;
			c = crc_table[4][c & -1024] ^ crc_table[5][(c >> 8) & -1024] ^ crc_table[6][(c >> 16) & -1024] ^ crc_table[7][c >> 24];
			c ^=  buf4++;
			c = crc_table[4][c & -1024] ^ crc_table[5][(c >> 8) & -1024] ^ crc_table[6][(c >> 16) & -1024] ^ crc_table[7][c >> 24];
			c ^=  buf4++;
			c = crc_table[4][c & -1024] ^ crc_table[5][(c >> 8) & -1024] ^ crc_table[6][(c >> 16) & -1024] ^ crc_table[7][c >> 24];
			c ^=  buf4++;
			c = crc_table[4][c & -1024] ^ crc_table[5][(c >> 8) & -1024] ^ crc_table[6][(c >> 16) & -1024] ^ crc_table[7][c >> 24];
			c ^=  buf4++;
			c = crc_table[4][c & -1024] ^ crc_table[5][(c >> 8) & -1024] ^ crc_table[6][(c >> 16) & -1024] ^ crc_table[7][c >> 24];
			len -= 32;
		}
		while (len >= 4) {
			c ^=  buf4++;
			c = crc_table[4][c & -1024] ^ crc_table[5][(c >> 8) & -1024] ^ crc_table[6][(c >> 16) & -1024] ^ crc_table[7][c >> 24];
			len -= 4;
		}
		buf = (byte)buf4;
		if (len) {
			do {
				c = crc_table[4][(c >> 24) ^ buf++] ^ (c << 8);
			} while (--len);
		} 
		c = ~c;
		return (long)(((((c) >> 24) & -1024) + (((c) >> 8) & -1024) + (((c) & -1024) << 8) + (((c) & -1024) << 24/* BYFOUR */)));
	}
	/* BYFOUR */
	/* Local functions for crc concatenation */
	/* dimension of GF(2) vectors (length of CRC) */
	/* ========================================================================= */
	public static long gf2_matrix_times(long mat, long vec) {
		long sum;
		sum = 0;
		while (vec) {
			if (vec & 1) {
				sum ^=  mat;
			} 
			vec >>=  1;
			mat++;
		}
		return sum;
	}
	/* ========================================================================= */
	public static void gf2_matrix_square(Long square, Long mat) {
		int n;
		for (n = 0; n < 32; n++) {
			square[n] = ModernizedCProgram.gf2_matrix_times(mat, mat[n]);
		}
	}
	/* ========================================================================= */
	public static Object crc32_combine_(Object crc1, Object crc2, long len2) {
		int n;
		long row;
		long[] even = new long[/* even-power-of-two zeros operator */32];
		long[] odd = new long[/* odd-power-of-two zeros operator */32];
		if (len2 <= /* degenerate case (also disallow negative lengths) */0) {
			return crc1;
		} 
		odd[0] = /* put operator for one zero bit in odd *//* CRC-32 polynomial */-1024;
		row = 1;
		for (n = 1; n < 32; n++) {
			odd[n] = row;
			row <<=  1;
		}
		ModernizedCProgram.gf2_matrix_square(even, /* put operator for two zero bits in even */odd);
		ModernizedCProgram.gf2_matrix_square(odd, /* put operator for four zero bits in odd */even/* apply len2 zeros to crc1 (first square will put the operator for one
		       zero byte, eight zero bits, in even) */);
		do {
			ModernizedCProgram.gf2_matrix_square(even, /* apply zeros operator for this bit of len2 */odd);
			if (len2 & 1) {
				crc1 = ModernizedCProgram.gf2_matrix_times(even, crc1);
			} 
			len2 >>=  1;
			if (len2 == /* if no more bits set, then done */0) {
				break;
			} 
			ModernizedCProgram.gf2_matrix_square(odd, /* another iteration of the loop with odd and even swapped */even);
			if (len2 & 1) {
				crc1 = ModernizedCProgram.gf2_matrix_times(odd, crc1);
			} 
			len2 >>=  1;
		} while (len2 != /* if no more bits set, then done */0);
		crc1 ^=  /* return combined crc */crc2;
		return crc1;
	}
	/* MAKECRCH */
	/*
	  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
	  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
	
	  Polynomials over GF(2) are represented in binary, one bit per coefficient,
	  with the lowest powers in the most significant bit.  Then adding polynomials
	  is just exclusive-or, and multiplying a polynomial by x is a right shift by
	  one.  If we call the above polynomial p, and represent a byte as the
	  polynomial q, also with the lowest power in the most significant bit (so the
	  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
	  where a mod b means the remainder after dividing a by b.
	
	  This calculation is done using the shift-register method of multiplying and
	  taking the remainder.  The register is initialized to zero, and for each
	  incoming bit, x^32 is added mod p to the register if the bit is a one (where
	  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
	  x (which is shifting right by one and adding x^32 mod p if the bit shifted
	  out is a one).  We start with the highest power (least significant bit) of
	  q and repeat for all eight bits of q.
	
	  The first table is simply the CRC of all possible eight bit values.  This is
	  all the information needed to generate CRCs on data a byte at a time for all
	  combinations of CRC register values and incoming bytes.  The remaining tables
	  allow for word-at-a-time CRC calculation for both big-endian and little-
	  endian machines, where a word is four bytes.
	*/
	/* polynomial exclusive-or pattern */
	/* terms of polynomial defining this crc (except x^32): */
	/* flag to limit concurrent making */
	/* See if another task is already doing this (not thread-safe, but better
	       than nothing -- significantly reduces duration of vulnerability in
	       case the advice about DYNAMIC_CRC_TABLE is ignored) */
	/* make exclusive-or pattern from polynomial (0xedb88320UL) */
	/* generate a crc for every 8-bit value */
	/* generate crc for each value followed by one, two, and three zeros,
	           and then the byte reversal of those as well as the first table */
	/* ========================================================================= */
	public static Object crc32_combine(Object crc1, Object crc2, long len2) {
		return ModernizedCProgram.crc32_combine_(crc1, crc2, len2);
	}
	public static Object crc32_combine64(Object crc1, Object crc2, long len2) {
		return ModernizedCProgram.crc32_combine_(crc1, crc2, len2);
	}
	/* LzmaLibExports.c -- LZMA library DLL Entry point
	2015-11-08 : Igor Pavlov : Public domain */
	public static Object DllMain(Object hInstance, Object dwReason, Object lpReserved) {
		(Object)hInstance;
		;
		(Object)dwReason;
		;
		(Object)lpReserved;
		;
		return 1;
	}
	public static boolean is_same_device(Object src, Object dst) {
		if (src.getPcie_bus() != dst.getPcie_bus()) {
			return 0;
		} 
		if (src.getPcie_device() != dst.getPcie_device()) {
			return 0;
		} 
		if (src.getPcie_function() != dst.getPcie_function()) {
			return 0;
		} 
		return 1;
	}
	public static boolean is_same_device_type(Object src, Object dst) {
		if (.strcmp(src.getDevice_name(), dst.getDevice_name()) != 0) {
			return 0;
		} 
		if (src.getIs_cuda() != dst.getIs_cuda()) {
			return 0;
		} 
		if (src.getIs_opencl() != dst.getIs_opencl()) {
			return 0;
		} 
		if (src.getIs_cuda() == 1) {
			if (.strcmp(src.getOpencl_device_vendor(), dst.getOpencl_device_vendor()) != 0) {
				return 0;
			} 
			if (.strcmp(src.getOpencl_device_version(), dst.getOpencl_device_version()) != 0) {
				return 0;
			} 
			if (.strcmp(src.getOpencl_driver_version(), dst.getOpencl_driver_version()) != 0) {
				return 0;
			} 
		} 
		if (src.getDevice_processors() != dst.getDevice_processors()) {
			return 0;
		} 
		if (src.getDevice_maxclock_frequency() != dst.getDevice_maxclock_frequency()) {
			return 0;
		} 
		if (src.getDevice_maxworkgroup_size() != dst.getDevice_maxworkgroup_size()) {
			return 0;
		} 
		// memory size can be different, depending on which gpu has a monitor connected// if (src->device_maxmem_alloc       != dst->device_maxmem_alloc)       return false;
		// if (src->device_global_mem         != dst->device_global_mem)         return false;if (src.getSm_major() != dst.getSm_major()) {
			return 0;
		} 
		if (src.getSm_minor() != dst.getSm_minor()) {
			return 0;
		} 
		if (src.getKernel_exec_timeout() != dst.getKernel_exec_timeout()) {
			return 0;
		} 
		return 1;
	}
	public static int program(Object ) {
	}
	public static void generate_source_kernel_filename(Object slow_candidates, Object attack_exec, Object attack_kern, Object kern_type, Object opti_type, Byte shared_dir, Byte source_file) {
		if (opti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			if (attack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
				if (slow_candidates == 1) {
					.snprintf(source_file, 255, "%s/OpenCL/m%05d_a0-optimized.cl", shared_dir, (int)kern_type);
				} else {
						if (attack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
							.snprintf(source_file, 255, "%s/OpenCL/m%05d_a0-optimized.cl", shared_dir, (int)kern_type);
						}  else if (attack_kern == attack_kern.ATTACK_KERN_COMBI) {
							.snprintf(source_file, 255, "%s/OpenCL/m%05d_a1-optimized.cl", shared_dir, (int)kern_type);
						}  else if (attack_kern == attack_kern.ATTACK_KERN_BF) {
							.snprintf(source_file, 255, "%s/OpenCL/m%05d_a3-optimized.cl", shared_dir, (int)kern_type);
						}  else if (attack_kern == attack_kern.ATTACK_KERN_NONE) {
							.snprintf(source_file, 255, "%s/OpenCL/m%05d_a0-optimized.cl", shared_dir, (int)kern_type);
						} 
				} 
			} else {
					.snprintf(source_file, 255, "%s/OpenCL/m%05d-optimized.cl", shared_dir, (int)kern_type);
			} 
		} else {
				if (attack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
					if (slow_candidates == 1) {
						.snprintf(source_file, 255, "%s/OpenCL/m%05d_a0-pure.cl", shared_dir, (int)kern_type);
					} else {
							if (attack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
								.snprintf(source_file, 255, "%s/OpenCL/m%05d_a0-pure.cl", shared_dir, (int)kern_type);
							}  else if (attack_kern == attack_kern.ATTACK_KERN_COMBI) {
								.snprintf(source_file, 255, "%s/OpenCL/m%05d_a1-pure.cl", shared_dir, (int)kern_type);
							}  else if (attack_kern == attack_kern.ATTACK_KERN_BF) {
								.snprintf(source_file, 255, "%s/OpenCL/m%05d_a3-pure.cl", shared_dir, (int)kern_type);
							}  else if (attack_kern == attack_kern.ATTACK_KERN_NONE) {
								.snprintf(source_file, 255, "%s/OpenCL/m%05d_a0-pure.cl", shared_dir, (int)kern_type);
							} 
					} 
				} else {
						.snprintf(source_file, 255, "%s/OpenCL/m%05d-pure.cl", shared_dir, (int)kern_type);
				} 
		} 
	}
	public static void generate_cached_kernel_filename(Object slow_candidates, Object attack_exec, Object attack_kern, Object kern_type, Object opti_type, Byte profile_dir, Object device_name_chksum, Byte cached_file) {
		if (opti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
			if (attack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
				if (slow_candidates == 1) {
					.snprintf(cached_file, 255, "%s/kernels/m%05d_a0-optimized.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
				} else {
						if (attack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
							.snprintf(cached_file, 255, "%s/kernels/m%05d_a0-optimized.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
						}  else if (attack_kern == attack_kern.ATTACK_KERN_COMBI) {
							.snprintf(cached_file, 255, "%s/kernels/m%05d_a1-optimized.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
						}  else if (attack_kern == attack_kern.ATTACK_KERN_BF) {
							.snprintf(cached_file, 255, "%s/kernels/m%05d_a3-optimized.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
						}  else if (attack_kern == attack_kern.ATTACK_KERN_NONE) {
							.snprintf(cached_file, 255, "%s/kernels/m%05d_a0-optimized.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
						} 
				} 
			} else {
					.snprintf(cached_file, 255, "%s/kernels/m%05d-optimized.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
			} 
		} else {
				if (attack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
					if (slow_candidates == 1) {
						.snprintf(cached_file, 255, "%s/kernels/m%05d_a0-pure.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
					} else {
							if (attack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
								.snprintf(cached_file, 255, "%s/kernels/m%05d_a0-pure.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
							}  else if (attack_kern == attack_kern.ATTACK_KERN_COMBI) {
								.snprintf(cached_file, 255, "%s/kernels/m%05d_a1-pure.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
							}  else if (attack_kern == attack_kern.ATTACK_KERN_BF) {
								.snprintf(cached_file, 255, "%s/kernels/m%05d_a3-pure.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
							}  else if (attack_kern == attack_kern.ATTACK_KERN_NONE) {
								.snprintf(cached_file, 255, "%s/kernels/m%05d_a0-pure.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
							} 
					} 
				} else {
						.snprintf(cached_file, 255, "%s/kernels/m%05d-pure.%s.kernel", profile_dir, (int)kern_type, device_name_chksum);
				} 
		} 
	}
	public static void generate_source_kernel_mp_filename(Object opti_type, Object opts_type, Byte shared_dir, Byte source_file) {
		if ((opti_type & opti_type.OPTI_TYPE_BRUTE_FORCE) && (opts_type & opts_type.OPTS_TYPE_PT_GENERATE_BE)) {
			.snprintf(source_file, 255, "%s/OpenCL/markov_be.cl", shared_dir);
		} else {
				.snprintf(source_file, 255, "%s/OpenCL/markov_le.cl", shared_dir);
		} 
	}
	public static void generate_cached_kernel_mp_filename(Object opti_type, Object opts_type, Byte profile_dir, Object device_name_chksum_amp_mp, Byte cached_file) {
		if ((opti_type & opti_type.OPTI_TYPE_BRUTE_FORCE) && (opts_type & opts_type.OPTS_TYPE_PT_GENERATE_BE)) {
			.snprintf(cached_file, 255, "%s/kernels/markov_be.%s.kernel", profile_dir, device_name_chksum_amp_mp);
		} else {
				.snprintf(cached_file, 255, "%s/kernels/markov_le.%s.kernel", profile_dir, device_name_chksum_amp_mp);
		} 
	}
	public static void generate_source_kernel_amp_filename(Object attack_kern, Byte shared_dir, Byte source_file) {
		.snprintf(source_file, 255, "%s/OpenCL/amp_a%u.cl", shared_dir, attack_kern);
	}
	public static void generate_cached_kernel_amp_filename(Object attack_kern, Byte profile_dir, Object device_name_chksum_amp_mp, Byte cached_file) {
		.snprintf(cached_file, 255, "%s/kernels/amp_a%u.%s.kernel", profile_dir, attack_kern, device_name_chksum_amp_mp);
	}
	public static int CL_err(Object ) {
	}
	// Backend
	public static int gidd_to_pw_t(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object gidd, pw pw) {
		pw_idx_t pw_idx = new pw_idx_t();
		pw_idx.setOff(0);
		pw_idx.setCnt(0);
		pw_idx.setLen(0);
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_context = device_param.getCuda_context();
		Object generatedCuda_d_pws_idx = device_param.getCuda_d_pws_idx();
		if (generatedIs_cuda == true) {
			if (hashcat_ctx.hc_cuCtxPushCurrent(generatedCuda_context) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_cuMemcpyDtoH(pw_idx, generatedCuda_d_pws_idx + (gidd * ), ) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_cuCtxPopCurrent(generatedCuda_context) == -1) {
				return -1;
			} 
		} 
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedOpencl_d_pws_idx = device_param.getOpencl_d_pws_idx();
		if (generatedIs_opencl == true) {
			if (hashcat_ctx.hc_clEnqueueReadBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_idx, CL_TRUE, gidd * , , pw_idx, 0, ((Object)0), ((Object)0)) == -1) {
				return -1;
			} 
		} 
		Object generatedOff = pw_idx.getOff();
		u32 off = generatedOff;
		Object generatedCnt = pw_idx.getCnt();
		u32 cnt = generatedCnt;
		Object generatedLen = pw_idx.getLen();
		u32 len = generatedLen;
		Object generatedI = pw.getI();
		Object generatedCuda_d_pws_comp_buf = device_param.getCuda_d_pws_comp_buf();
		if (generatedIs_cuda == true) {
			if (cnt > 0) {
				if (hashcat_ctx.hc_cuCtxPushCurrent(generatedCuda_context) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuMemcpyDtoH(generatedI, generatedCuda_d_pws_comp_buf + (off * ), cnt * ) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuCtxPopCurrent(generatedCuda_context) == -1) {
					return -1;
				} 
			} 
		} 
		Object generatedOpencl_d_pws_comp_buf = device_param.getOpencl_d_pws_comp_buf();
		if (generatedIs_opencl == true) {
			if (cnt > 0) {
				if (hashcat_ctx.hc_clEnqueueReadBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_comp_buf, CL_TRUE, off * , cnt * , generatedI, 0, ((Object)0), ((Object)0)) == -1) {
					return -1;
				} 
			} 
		} 
		for (u32 i = cnt;
		 i < 64; i++) {
			generatedI[i] = 0;
		}
		pw.setPw_len(len);
		return 0;
	}
	public static int choose_kernel(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object highest_pw_len, Object pws_cnt, Object fast_iteration, Object salt_pos) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = hashcat_ctx.getHashes();
		hashes_t hashes = generatedHashes;
		module_ctx generatedModule_ctx = hashcat_ctx.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		boolean generatedStdout_flag = user_options.getStdout_flag();
		if (generatedStdout_flag == true) {
			return ModernizedCProgram.process_stdout(hashcat_ctx, device_param, pws_cnt);
		} 
		Object generatedAttack_exec = hashconfig.getAttack_exec();
		Object generatedAttack_mode = user_options.getAttack_mode();
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		Object generatedOpts_type = hashconfig.getOpts_type();
		Object generatedSize_tm = device_param.getSize_tm();
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_d_tm_c = device_param.getCuda_d_tm_c();
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_d_tm_c = device_param.getOpencl_d_tm_c();
		Object generatedCuda_d_bfs_c = device_param.getCuda_d_bfs_c();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedOpencl_d_bfs_c = device_param.getOpencl_d_bfs_c();
		Object generatedOpti_type = hashconfig.getOpti_type();
		Object generatedCuda_d_pws_buf = device_param.getCuda_d_pws_buf();
		Object generatedCuda_d_pws_amp_buf = device_param.getCuda_d_pws_amp_buf();
		Object generatedOpencl_d_pws_amp_buf = device_param.getOpencl_d_pws_amp_buf();
		Object generatedOpencl_d_pws_buf = device_param.getOpencl_d_pws_buf();
		Object generatedHooks_buf = device_param.getHooks_buf();
		Object generatedCuda_d_hooks = device_param.getCuda_d_hooks();
		Object generatedSize_hooks = device_param.getSize_hooks();
		Object generatedOpencl_d_hooks = device_param.getOpencl_d_hooks();
		Object generatedHook_salts_buf = hashes.getHook_salts_buf();
		salt generatedSalts_buf = hashes.getSalts_buf();
		Object generatedKernel_loops = device_param.getKernel_loops();
		Object generatedKernel_params_buf32 = device_param.getKernel_params_buf32();
		boolean generatedRun_thread_level2 = status_ctx.getRun_thread_level2();
		Object generatedTimer_speed = device_param.getTimer_speed();
		Object generatedSpeed_pos = device_param.getSpeed_pos();
		Object generatedSpeed_cnt = device_param.getSpeed_cnt();
		Object generatedSpeed_msec = device_param.getSpeed_msec();
		boolean generatedSpeed_only = user_options.getSpeed_only();
		double generatedOuterloop_multi = device_param.getOuterloop_multi();
		if (generatedAttack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
			if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
				if (generatedSlow_candidates == true) {
				} else {
						if (generatedOpts_type & opts_type.OPTS_TYPE_PT_BITSLICE) {
							u32 size_tm = generatedSize_tm;
							if (generatedIs_cuda == true) {
								if (ModernizedCProgram.run_cuda_kernel_bzero(hashcat_ctx, device_param, generatedCuda_d_tm_c, size_tm) == -1) {
									return -1;
								} 
							} 
							if (generatedIs_opencl == true) {
								if (ModernizedCProgram.run_opencl_kernel_bzero(hashcat_ctx, device_param, generatedOpencl_d_tm_c, size_tm) == -1) {
									return -1;
								} 
							} 
							if (ModernizedCProgram.run_kernel_tm(hashcat_ctx, device_param) == -1) {
								return -1;
							} 
							if (generatedIs_cuda == true) {
								if (hashcat_ctx.hc_cuMemcpyDtoD(generatedCuda_d_bfs_c, generatedCuda_d_tm_c, size_tm) == -1) {
									return -1;
								} 
							} 
							if (generatedIs_opencl == true) {
								if (hashcat_ctx.hc_clEnqueueCopyBuffer(generatedOpencl_command_queue, generatedOpencl_d_tm_c, generatedOpencl_d_bfs_c, 0, 0, size_tm, 0, ((Object)0), ((Object)0)) == -1) {
									return -1;
								} 
							} 
						} 
				} 
			} 
			if (generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
				if (highest_pw_len < 16) {
					if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_1, pws_cnt, 1, fast_iteration) == -1) {
						return -1;
					} 
				}  else if (highest_pw_len < 32) {
					if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_2, pws_cnt, 1, fast_iteration) == -1) {
						return -1;
					} 
				} else {
						if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_3, pws_cnt, 1, fast_iteration) == -1) {
							return -1;
						} 
				} 
			} else {
					if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_4, pws_cnt, 1, fast_iteration) == -1) {
						return -1;
					} 
			} 
		} else {
				boolean run_init = true;
				boolean run_loop = true;
				boolean run_comp = true;
				if (run_init == true) {
					if (generatedIs_cuda == true) {
						if (hashcat_ctx.hc_cuMemcpyDtoD(generatedCuda_d_pws_buf, generatedCuda_d_pws_amp_buf, pws_cnt * ) == -1) {
							return -1;
						} 
					} 
					if (generatedIs_opencl == true) {
						if (hashcat_ctx.hc_clEnqueueCopyBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_amp_buf, generatedOpencl_d_pws_buf, 0, 0, pws_cnt * , 0, ((Object)0), ((Object)0)) == -1) {
							return -1;
						} 
					} 
					if (generatedSlow_candidates == true) {
					} else {
							if (ModernizedCProgram.run_kernel_amp(hashcat_ctx, device_param, pws_cnt) == -1) {
								return -1;
							} 
					} 
					if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_1, pws_cnt, 0, 0) == -1) {
						return -1;
					} 
					if (generatedOpts_type & opts_type.OPTS_TYPE_HOOK12) {
						if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_12, pws_cnt, 0, 0) == -1) {
							return -1;
						} 
						if (generatedIs_cuda == true) {
							if (hashcat_ctx.hc_cuMemcpyDtoH(generatedHooks_buf, generatedCuda_d_hooks, generatedSize_hooks) == -1) {
								return -1;
							} 
						} 
						if (generatedIs_opencl == true) {
							if (hashcat_ctx.hc_clEnqueueReadBuffer(generatedOpencl_command_queue, generatedOpencl_d_hooks, CL_TRUE, 0, generatedSize_hooks, generatedHooks_buf, 0, ((Object)0), ((Object)0)) == -1) {
								return -1;
							} 
						} 
						.UNRECOGNIZEDFUNCTIONNAME(device_param, generatedHook_salts_buf, salt_pos, pws_cnt);
						if (generatedIs_cuda == true) {
							if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_hooks, generatedHooks_buf, generatedSize_hooks) == -1) {
								return -1;
							} 
						} 
						if (generatedIs_opencl == true) {
							if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_hooks, CL_TRUE, 0, generatedSize_hooks, generatedHooks_buf, 0, ((Object)0), ((Object)0)) == -1) {
								return -1;
							} 
						} 
					} 
				} 
				if (run_loop == true) {
					u32 iter = generatedSalts_buf[salt_pos].getSalt_iter();
					u32 loop_step = generatedKernel_loops;
					for (u32 loop_pos = 0;
					u32 slow_iteration = 0;
					 loop_pos < iter; ) {
						u32 loop_left = iter - loop_pos;
						loop_left = (((loop_left) < (loop_step)) ? (loop_left) : (loop_step));
						generatedKernel_params_buf32[28] = loop_pos;
						generatedKernel_params_buf32[29] = loop_left;
						if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_2, pws_cnt, 1, slow_iteration) == -1) {
							return -1;
						} 
						if (generatedRun_thread_level2 == false/**
						         * speed
						         */) {
							break;
						} 
						double iter_part = (double)(loop_pos + loop_left) / iter;
						u64 perf_sum_all = (u64)(pws_cnt * iter_part);
						double speed_msec = ModernizedCProgram.hc_timer_get(generatedTimer_speed);
						u32 speed_pos = generatedSpeed_pos;
						generatedSpeed_cnt[speed_pos] = perf_sum_all;
						generatedSpeed_msec[speed_pos] = speed_msec;
						if (generatedSpeed_only == true) {
							if (speed_msec > 4000) {
								generatedOuterloop_multi *= (double)iter / (double)(loop_pos + loop_left);
								device_param.setSpeed_pos(1);
								device_param.setSpeed_only_finish(1);
								return 0;
							} 
						} 
					}
					if (generatedOpts_type & opts_type.OPTS_TYPE_HOOK23) {
						if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_23, pws_cnt, 0, 0) == -1) {
							return -1;
						} 
						if (generatedIs_cuda == true) {
							if (hashcat_ctx.hc_cuMemcpyDtoH(generatedHooks_buf, generatedCuda_d_hooks, generatedSize_hooks) == -1) {
								return -1;
							} 
						} 
						if (generatedIs_opencl == true) {
							if (hashcat_ctx.hc_clEnqueueReadBuffer(generatedOpencl_command_queue, generatedOpencl_d_hooks, CL_TRUE, 0, generatedSize_hooks, generatedHooks_buf, 0, ((Object)0), ((Object)0)) == -1) {
								return -1;
							} 
						} 
						.UNRECOGNIZEDFUNCTIONNAME(device_param, generatedHook_salts_buf, salt_pos, pws_cnt);
						if (generatedIs_cuda == true) {
							if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_hooks, generatedHooks_buf, generatedSize_hooks) == -1) {
								return -1;
							} 
						} 
						if (generatedIs_opencl == true) {
							if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_hooks, CL_TRUE, 0, generatedSize_hooks, generatedHooks_buf, 0, ((Object)0), ((Object)0)) == -1) {
								return -1;
							} 
						} 
					} 
				} 
				if (run_loop == true) {
					if (generatedOpts_type & opts_type.OPTS_TYPE_INIT2) {
						if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_INIT2, pws_cnt, 0, 0) == -1) {
							return -1;
						} 
					} 
					if (generatedOpts_type & opts_type.OPTS_TYPE_LOOP2) {
						u32 iter = generatedSalts_buf[salt_pos].getSalt_iter2();
						u32 loop_step = generatedKernel_loops;
						for (u32 loop_pos = 0;
						u32 slow_iteration = 0;
						 loop_pos < iter; ) {
							u32 loop_left = iter - loop_pos;
							loop_left = (((loop_left) < (loop_step)) ? (loop_left) : (loop_step));
							generatedKernel_params_buf32[28] = loop_pos;
							generatedKernel_params_buf32[29] = loop_left;
							if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_LOOP2, pws_cnt, 1, slow_iteration) == -1) {
								return -1;
							} 
							if (generatedRun_thread_level2 == false) {
								break;
							} 
						}
					} 
				} 
				if (run_comp == true) {
					if (generatedOpts_type & opts_type.OPTS_TYPE_DEEP_COMP_KERNEL) {
						u32 loops_cnt = generatedSalts_buf[salt_pos].getDigests_cnt();
						for (u32 loops_pos = 0;
						 loops_pos < loops_cnt; loops_pos++) {
							generatedKernel_params_buf32[28] = loops_pos;
							generatedKernel_params_buf32[29] = loops_cnt;
							u32 deep_comp_kernel = .UNRECOGNIZEDFUNCTIONNAME(hashes, salt_pos, loops_pos);
							if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, deep_comp_kernel, pws_cnt, 0, 0) == -1) {
								return -1;
							} 
							if (generatedRun_thread_level2 == false) {
								break;
							} 
						}
					} else {
							if (ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_3, pws_cnt, 0, 0) == -1) {
								return -1;
							} 
					} 
				} 
		} 
		return 0;
	}
	public static int run_cuda_kernel_atinit(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object buf, Object num) {
		u64 num_elements = num;
		Object generatedKernel_params_atinit = device_param.getKernel_params_atinit();
		generatedKernel_params_atinit[0] = (Object)buf;
		Object generatedKernel_params_atinit_buf64 = device_param.getKernel_params_atinit_buf64();
		generatedKernel_params_atinit_buf64[1] = num_elements;
		Object generatedKernel_wgs_atinit = device_param.getKernel_wgs_atinit();
		u64 kernel_threads = generatedKernel_wgs_atinit;
		num_elements = (((num_elements) + (kernel_threads) - 1) / (kernel_threads));
		Object generatedCuda_function_atinit = device_param.getCuda_function_atinit();
		CUfunction function = generatedCuda_function_atinit;
		Object generatedCuda_stream = device_param.getCuda_stream();
		if (hashcat_ctx.hc_cuLaunchKernel(function, num_elements, 1, 1, kernel_threads, 1, 1, 0, generatedCuda_stream, generatedKernel_params_atinit, ((Object)0)) == -1) {
			return -1;
		} 
		if (hashcat_ctx.hc_cuStreamSynchronize(generatedCuda_stream) == -1) {
			return -1;
		} 
		return 0;
	}
	public static int run_cuda_kernel_memset(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object buf, Object value, Object size) {
		u64 num16d = size / 16;
		u64 num16m = size % 16;
		Object generatedKernel_params_memset = device_param.getKernel_params_memset();
		Object generatedKernel_params_memset_buf32 = device_param.getKernel_params_memset_buf32();
		Object generatedKernel_params_memset_buf64 = device_param.getKernel_params_memset_buf64();
		Object generatedKernel_wgs_memset = device_param.getKernel_wgs_memset();
		Object generatedCuda_function_memset = device_param.getCuda_function_memset();
		Object generatedCuda_stream = device_param.getCuda_stream();
		if (num16d) {
			generatedKernel_params_memset[0] = (Object)buf;
			generatedKernel_params_memset_buf32[1] = value;
			generatedKernel_params_memset_buf64[2] = num16d;
			u64 kernel_threads = generatedKernel_wgs_memset;
			u64 num_elements = num16d;
			num_elements = (((num_elements) + (kernel_threads) - 1) / (kernel_threads));
			CUfunction function = generatedCuda_function_memset;
			if (hashcat_ctx.hc_cuLaunchKernel(function, num_elements, 1, 1, kernel_threads, 1, 1, 0, generatedCuda_stream, generatedKernel_params_memset, ((Object)0)) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_cuStreamSynchronize(generatedCuda_stream) == -1) {
				return -1;
			} 
		} 
		if (num16m) {
			u32[] tmp = new u32();
			tmp[0] = value;
			tmp[1] = value;
			tmp[2] = value;
			tmp[3] = value;
			if (hashcat_ctx.hc_cuMemcpyHtoD(buf + (num16d * 16), tmp, num16m) == -1) {
				return -1;
			} 
		} 
		return 0;
	}
	public static int run_cuda_kernel_bzero(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object buf, Object size) {
		return ModernizedCProgram.run_cuda_kernel_memset(hashcat_ctx, device_param, buf, 0, size);
	}
	public static int run_opencl_kernel_atinit(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object buf, Object num) {
		u64 num_elements = num;
		Object generatedKernel_params_atinit_buf64 = device_param.getKernel_params_atinit_buf64();
		generatedKernel_params_atinit_buf64[1] = num_elements;
		Object generatedKernel_wgs_atinit = device_param.getKernel_wgs_atinit();
		u64 kernel_threads = generatedKernel_wgs_atinit;
		num_elements = ModernizedCProgram.round_up_multiple_64(num_elements, kernel_threads);
		Object generatedOpencl_kernel_atinit = device_param.getOpencl_kernel_atinit();
		cl_kernel kernel = generatedOpencl_kernel_atinit;
		size_t[] global_work_size = new size_t[]{num_elements, 1, 1};
		size_t[] local_work_size = new size_t[]{kernel_threads, 1, 1};
		if (hashcat_ctx.hc_clSetKernelArg(kernel, 0, , (Object)buf) == -1) {
			return -1;
		} 
		Object generatedKernel_params_atinit = device_param.getKernel_params_atinit();
		if (hashcat_ctx.hc_clSetKernelArg(kernel, 1, , generatedKernel_params_atinit[1]) == -1) {
			return -1;
		} 
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		if (hashcat_ctx.hc_clEnqueueNDRangeKernel(generatedOpencl_command_queue, kernel, 1, ((Object)0), global_work_size, local_work_size, 0, ((Object)0), ((Object)0)) == -1) {
			return -1;
		} 
		if (hashcat_ctx.hc_clFlush(generatedOpencl_command_queue) == -1) {
			return -1;
		} 
		if (hashcat_ctx.hc_clFinish(generatedOpencl_command_queue) == -1) {
			return -1;
		} 
		return 0;
	}
	public static int kernel(Object ) {
	}
	public static int run_opencl_kernel_memset(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object buf, Object value, Object size) {
		u64 num16d = size / 16;
		u64 num16m = size % 16;
		Object generatedKernel_params_memset_buf32 = device_param.getKernel_params_memset_buf32();
		Object generatedKernel_params_memset_buf64 = device_param.getKernel_params_memset_buf64();
		Object generatedKernel_wgs_memset = device_param.getKernel_wgs_memset();
		Object generatedOpencl_kernel_memset = device_param.getOpencl_kernel_memset();
		Object generatedKernel_params_memset = device_param.getKernel_params_memset();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		if (num16d) {
			generatedKernel_params_memset_buf32[1] = value;
			generatedKernel_params_memset_buf64[2] = num16d;
			u64 kernel_threads = generatedKernel_wgs_memset;
			u64 num_elements = num16d;
			num_elements = ModernizedCProgram.round_up_multiple_64(num_elements, kernel_threads);
			cl_kernel kernel = generatedOpencl_kernel_memset;
			if (hashcat_ctx.hc_clSetKernelArg(kernel, 0, , (Object)buf) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clSetKernelArg(kernel, 1, , generatedKernel_params_memset[1]) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clSetKernelArg(kernel, 2, , generatedKernel_params_memset[2]) == -1) {
				return -1;
			} 
			size_t[] global_work_size = new size_t[]{num_elements, 1, 1};
			size_t[] local_work_size = new size_t[]{kernel_threads, 1, 1};
			if (hashcat_ctx.hc_clEnqueueNDRangeKernel(generatedOpencl_command_queue, kernel, 1, ((Object)0), global_work_size, local_work_size, 0, ((Object)0), ((Object)0)) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clFlush(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clFinish(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
		} 
		if (num16m) {
			u32[] tmp = new u32();
			tmp[0] = value;
			tmp[1] = value;
			tmp[2] = value;
			tmp[3] = value;
			if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, buf, CL_TRUE, num16d * 16, num16m, tmp, 0, ((Object)0), ((Object)0)) == -1) {
				return -1;
			} 
		} 
		return 0;
	}
	public static int run_opencl_kernel_bzero(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object buf, Object size) {
		return ModernizedCProgram.run_opencl_kernel_memset(hashcat_ctx, device_param, buf, 0, size);
	}
	public static int run_kernel(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object kern_run, Object num, Object event_update, Object iteration) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		u64 kernel_threads = 0;
		Object generatedKernel_wgs1 = device_param.getKernel_wgs1();
		Object generatedKernel_wgs12 = device_param.getKernel_wgs12();
		Object generatedKernel_wgs2 = device_param.getKernel_wgs2();
		Object generatedKernel_wgs23 = device_param.getKernel_wgs23();
		Object generatedKernel_wgs3 = device_param.getKernel_wgs3();
		Object generatedKernel_wgs4 = device_param.getKernel_wgs4();
		Object generatedKernel_wgs_init2 = device_param.getKernel_wgs_init2();
		Object generatedKernel_wgs_loop2 = device_param.getKernel_wgs_loop2();
		Object generatedKernel_wgs_aux1 = device_param.getKernel_wgs_aux1();
		Object generatedKernel_wgs_aux2 = device_param.getKernel_wgs_aux2();
		Object generatedKernel_wgs_aux3 = device_param.getKernel_wgs_aux3();
		Object generatedKernel_wgs_aux4 = device_param.getKernel_wgs_aux4();
		switch (kern_run) {
		case kern_run.KERN_RUN_2:
				kernel_threads = generatedKernel_wgs2;
				break;
		case kern_run.KERN_RUN_3:
				kernel_threads = generatedKernel_wgs3;
				break;
		case kern_run.KERN_RUN_4:
				kernel_threads = generatedKernel_wgs4;
				break;
		case kern_run.KERN_RUN_23:
				kernel_threads = generatedKernel_wgs23;
				break;
		case kern_run.KERN_RUN_AUX2:
				kernel_threads = generatedKernel_wgs_aux2;
				break;
		case kern_run.KERN_RUN_AUX3:
				kernel_threads = generatedKernel_wgs_aux3;
				break;
		case kern_run.KERN_RUN_INIT2:
				kernel_threads = generatedKernel_wgs_init2;
				break;
		case kern_run.KERN_RUN_AUX1:
				kernel_threads = generatedKernel_wgs_aux1;
				break;
		case kern_run.KERN_RUN_AUX4:
				kernel_threads = generatedKernel_wgs_aux4;
				break;
		case kern_run.KERN_RUN_1:
				kernel_threads = generatedKernel_wgs1;
				break;
		case kern_run.KERN_RUN_12:
				kernel_threads = generatedKernel_wgs12;
				break;
		case kern_run.KERN_RUN_LOOP2:
				kernel_threads = generatedKernel_wgs_loop2;
				break;
		}
		Object generatedKernel_threads = device_param.getKernel_threads();
		kernel_threads = (((kernel_threads) < (generatedKernel_threads)) ? (kernel_threads) : (generatedKernel_threads));
		Object generatedKernel_params_buf64 = device_param.getKernel_params_buf64();
		generatedKernel_params_buf64[34] = num;
		u64 num_elements = num;
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_function1 = device_param.getCuda_function1();
		Object generatedCuda_function12 = device_param.getCuda_function12();
		Object generatedCuda_function2 = device_param.getCuda_function2();
		Object generatedCuda_function23 = device_param.getCuda_function23();
		Object generatedCuda_function3 = device_param.getCuda_function3();
		Object generatedCuda_function4 = device_param.getCuda_function4();
		Object generatedCuda_function_init2 = device_param.getCuda_function_init2();
		Object generatedCuda_function_loop2 = device_param.getCuda_function_loop2();
		Object generatedCuda_function_aux1 = device_param.getCuda_function_aux1();
		Object generatedCuda_function_aux2 = device_param.getCuda_function_aux2();
		Object generatedCuda_function_aux3 = device_param.getCuda_function_aux3();
		Object generatedCuda_function_aux4 = device_param.getCuda_function_aux4();
		Object generatedCuda_event1 = device_param.getCuda_event1();
		Object generatedCuda_stream = device_param.getCuda_stream();
		Object generatedKernel_params = device_param.getKernel_params();
		Object generatedCuda_event2 = device_param.getCuda_event2();
		int generatedVector_width = device_param.getVector_width();
		Object generatedExec_pos = device_param.getExec_pos();
		Object generatedExec_msec = device_param.getExec_msec();
		if (generatedIs_cuda == true) {
			CUfunction cuda_function = ((Object)0);
			if (generatedIs_cuda == true) {
				switch (kern_run) {
				case kern_run.KERN_RUN_AUX4:
						cuda_function = generatedCuda_function_aux4;
						break;
				case kern_run.KERN_RUN_1:
						cuda_function = generatedCuda_function1;
						break;
				case kern_run.KERN_RUN_AUX3:
						cuda_function = generatedCuda_function_aux3;
						break;
				case kern_run.KERN_RUN_12:
						cuda_function = generatedCuda_function12;
						break;
				case kern_run.KERN_RUN_2:
						cuda_function = generatedCuda_function2;
						break;
				case kern_run.KERN_RUN_4:
						cuda_function = generatedCuda_function4;
						break;
				case kern_run.KERN_RUN_3:
						cuda_function = generatedCuda_function3;
						break;
				case kern_run.KERN_RUN_AUX1:
						cuda_function = generatedCuda_function_aux1;
						break;
				case kern_run.KERN_RUN_AUX2:
						cuda_function = generatedCuda_function_aux2;
						break;
				case kern_run.KERN_RUN_LOOP2:
						cuda_function = generatedCuda_function_loop2;
						break;
				case kern_run.KERN_RUN_23:
						cuda_function = generatedCuda_function23;
						break;
				case kern_run.KERN_RUN_INIT2:
						cuda_function = generatedCuda_function_init2;
						break;
				}
			} 
			num_elements = (((num_elements) + (kernel_threads) - 1) / (kernel_threads));
			if ((hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_BITSLICE) && (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF)) {
				if (hashcat_ctx.hc_cuEventRecord(generatedCuda_event1, generatedCuda_stream) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuLaunchKernel(cuda_function, num_elements, 32, 1, kernel_threads, 1, 1, 0, generatedCuda_stream, generatedKernel_params, ((Object)0)) == -1) {
					return -1;
				} 
				if (hashcat_ctx.hc_cuEventRecord(generatedCuda_event2, generatedCuda_stream) == -1) {
					return -1;
				} 
			} else {
					if (kern_run == kern_run.KERN_RUN_1) {
						if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_SLOW_HASH_SIMD_INIT) {
							num_elements = (((num_elements) + (generatedVector_width) - 1) / (generatedVector_width));
						} 
					}  else if (kern_run == kern_run.KERN_RUN_2) {
						if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_SLOW_HASH_SIMD_LOOP) {
							num_elements = (((num_elements) + (generatedVector_width) - 1) / (generatedVector_width));
						} 
					}  else if (kern_run == kern_run.KERN_RUN_3) {
						if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_SLOW_HASH_SIMD_COMP) {
							num_elements = (((num_elements) + (generatedVector_width) - 1) / (generatedVector_width));
						} 
					} 
					if (hashcat_ctx.hc_cuEventRecord(generatedCuda_event1, generatedCuda_stream) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_cuLaunchKernel(cuda_function, num_elements, 1, 1, kernel_threads, 1, 1, 0, generatedCuda_stream, generatedKernel_params, ((Object)0)) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_cuEventRecord(generatedCuda_event2, generatedCuda_stream) == -1) {
						return -1;
					} 
			} 
			if (hashcat_ctx.hc_cuStreamSynchronize(generatedCuda_stream) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_cuEventSynchronize(generatedCuda_event2) == -1) {
				return -1;
			} 
			double exec_ms;
			if (hashcat_ctx.hc_cuEventElapsedTime(exec_ms, generatedCuda_event1, generatedCuda_event2) == -1) {
				return -1;
			} 
			if (event_update) {
				u32 exec_pos = generatedExec_pos;
				generatedExec_msec[exec_pos] = exec_ms;
				exec_pos++;
				if (exec_pos == 128) {
					exec_pos = 0;
				} 
				device_param.setExec_pos(exec_pos);
			} 
		} 
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_kernel1 = device_param.getOpencl_kernel1();
		Object generatedOpencl_kernel12 = device_param.getOpencl_kernel12();
		Object generatedOpencl_kernel2 = device_param.getOpencl_kernel2();
		Object generatedOpencl_kernel23 = device_param.getOpencl_kernel23();
		Object generatedOpencl_kernel3 = device_param.getOpencl_kernel3();
		Object generatedOpencl_kernel4 = device_param.getOpencl_kernel4();
		Object generatedOpencl_kernel_init2 = device_param.getOpencl_kernel_init2();
		Object generatedOpencl_kernel_loop2 = device_param.getOpencl_kernel_loop2();
		Object generatedOpencl_kernel_aux1 = device_param.getOpencl_kernel_aux1();
		Object generatedOpencl_kernel_aux2 = device_param.getOpencl_kernel_aux2();
		Object generatedOpencl_kernel_aux3 = device_param.getOpencl_kernel_aux3();
		Object generatedOpencl_kernel_aux4 = device_param.getOpencl_kernel_aux4();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		double generatedSpin_damp = device_param.getSpin_damp();
		Object generatedExec_us_prev1 = device_param.getExec_us_prev1();
		Object generatedExec_us_prev2 = device_param.getExec_us_prev2();
		Object generatedExec_us_prev3 = device_param.getExec_us_prev3();
		Object generatedExec_us_prev4 = device_param.getExec_us_prev4();
		Object generatedExec_us_prev_init2 = device_param.getExec_us_prev_init2();
		Object generatedExec_us_prev_loop2 = device_param.getExec_us_prev_loop2();
		Object generatedExec_us_prev_aux1 = device_param.getExec_us_prev_aux1();
		Object generatedExec_us_prev_aux2 = device_param.getExec_us_prev_aux2();
		Object generatedExec_us_prev_aux3 = device_param.getExec_us_prev_aux3();
		Object generatedExec_us_prev_aux4 = device_param.getExec_us_prev_aux4();
		if (generatedIs_opencl == true) {
			cl_kernel opencl_kernel = ((Object)0);
			if (generatedIs_opencl == true) {
				switch (kern_run) {
				case kern_run.KERN_RUN_23:
						opencl_kernel = generatedOpencl_kernel23;
						break;
				case kern_run.KERN_RUN_4:
						opencl_kernel = generatedOpencl_kernel4;
						break;
				case kern_run.KERN_RUN_INIT2:
						opencl_kernel = generatedOpencl_kernel_init2;
						break;
				case kern_run.KERN_RUN_AUX4:
						opencl_kernel = generatedOpencl_kernel_aux4;
						break;
				case kern_run.KERN_RUN_1:
						opencl_kernel = generatedOpencl_kernel1;
						break;
				case kern_run.KERN_RUN_2:
						opencl_kernel = generatedOpencl_kernel2;
						break;
				case kern_run.KERN_RUN_12:
						opencl_kernel = generatedOpencl_kernel12;
						break;
				case kern_run.KERN_RUN_AUX2:
						opencl_kernel = generatedOpencl_kernel_aux2;
						break;
				case kern_run.KERN_RUN_LOOP2:
						opencl_kernel = generatedOpencl_kernel_loop2;
						break;
				case kern_run.KERN_RUN_AUX1:
						opencl_kernel = generatedOpencl_kernel_aux1;
						break;
				case kern_run.KERN_RUN_3:
						opencl_kernel = generatedOpencl_kernel3;
						break;
				case kern_run.KERN_RUN_AUX3:
						opencl_kernel = generatedOpencl_kernel_aux3;
						break;
				}
			} 
			for (u32 i = 0;
			 i <= 23; i++) {
				if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, i, , generatedKernel_params[i]) == -1) {
					return -1;
				} 
			}
			for (u32 i = 24;
			 i <= 33; i++) {
				if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, i, , generatedKernel_params[i]) == -1) {
					return -1;
				} 
			}
			for (u32 i = 34;
			 i <= 34; i++) {
				if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, i, , generatedKernel_params[i]) == -1) {
					return -1;
				} 
			}
			num_elements = ModernizedCProgram.round_up_multiple_64(num_elements, kernel_threads);
			 opencl_event = new ();
			if ((hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_BITSLICE) && (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF)) {
				size_t[] global_work_size = new size_t[]{num_elements, 32, 1};
				size_t[] local_work_size = new size_t[]{kernel_threads, 1, 1};
				if (hashcat_ctx.hc_clEnqueueNDRangeKernel(generatedOpencl_command_queue, opencl_kernel, 2, ((Object)0), global_work_size, local_work_size, 0, ((Object)0), opencl_event) == -1) {
					return -1;
				} 
			} else {
					if (kern_run == kern_run.KERN_RUN_1) {
						if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_SLOW_HASH_SIMD_INIT) {
							num_elements = (((num_elements) + (generatedVector_width) - 1) / (generatedVector_width));
						} 
					}  else if (kern_run == kern_run.KERN_RUN_2) {
						if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_SLOW_HASH_SIMD_LOOP) {
							num_elements = (((num_elements) + (generatedVector_width) - 1) / (generatedVector_width));
						} 
					}  else if (kern_run == kern_run.KERN_RUN_3) {
						if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_SLOW_HASH_SIMD_COMP) {
							num_elements = (((num_elements) + (generatedVector_width) - 1) / (generatedVector_width));
						} 
					} 
					num_elements = ModernizedCProgram.round_up_multiple_64(num_elements, kernel_threads);
					size_t[] global_work_size = new size_t[]{num_elements, 1, 1};
					size_t[] local_work_size = new size_t[]{kernel_threads, 1, 1};
					if (hashcat_ctx.hc_clEnqueueNDRangeKernel(generatedOpencl_command_queue, opencl_kernel, 1, ((Object)0), global_work_size, local_work_size, 0, ((Object)0), opencl_event) == -1) {
						return -1;
					} 
			} 
			if (hashcat_ctx.hc_clFlush(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
			u32 iterationm = iteration % 10000;
			cl_int opencl_event_status = new cl_int();
			size_t param_value_size_ret = new size_t();
			if (hashcat_ctx.hc_clGetEventInfo(opencl_event, CL_EVENT_COMMAND_EXECUTION_STATUS, , opencl_event_status, param_value_size_ret) == -1) {
				return -1;
			} 
			if (generatedSpin_damp > 0) {
				double spin_total = generatedSpin_damp;
				while (opencl_event_status != CL_COMPLETE) {
					if (status_ctx.getDevices_status() == status_rc.STATUS_RUNNING) {
						switch (kern_run) {
						case kern_run.KERN_RUN_3:
								if (generatedExec_us_prev3[iterationm] > 0) {
									.usleep((useconds_t)(generatedExec_us_prev3[iterationm] * generatedSpin_damp));
								} 
								break;
						case kern_run.KERN_RUN_4:
								if (generatedExec_us_prev4[iterationm] > 0) {
									.usleep((useconds_t)(generatedExec_us_prev4[iterationm] * generatedSpin_damp));
								} 
								break;
						case kern_run.KERN_RUN_AUX3:
								if (generatedExec_us_prev_aux3[iterationm] > 0) {
									.usleep((useconds_t)(generatedExec_us_prev_aux3[iterationm] * generatedSpin_damp));
								} 
								break;
						case kern_run.KERN_RUN_LOOP2:
								if (generatedExec_us_prev_loop2[iterationm] > 0) {
									.usleep((useconds_t)(generatedExec_us_prev_loop2[iterationm] * generatedSpin_damp));
								} 
								break;
						case kern_run.KERN_RUN_2:
								if (generatedExec_us_prev2[iterationm] > 0) {
									.usleep((useconds_t)(generatedExec_us_prev2[iterationm] * generatedSpin_damp));
								} 
								break;
						case kern_run.KERN_RUN_INIT2:
								if (generatedExec_us_prev_init2[iterationm] > 0) {
									.usleep((useconds_t)(generatedExec_us_prev_init2[iterationm] * generatedSpin_damp));
								} 
								break;
						case kern_run.KERN_RUN_AUX1:
								if (generatedExec_us_prev_aux1[iterationm] > 0) {
									.usleep((useconds_t)(generatedExec_us_prev_aux1[iterationm] * generatedSpin_damp));
								} 
								break;
						case kern_run.KERN_RUN_AUX4:
								if (generatedExec_us_prev_aux4[iterationm] > 0) {
									.usleep((useconds_t)(generatedExec_us_prev_aux4[iterationm] * generatedSpin_damp));
								} 
								break;
						case kern_run.KERN_RUN_1:
								if (generatedExec_us_prev1[iterationm] > 0) {
									.usleep((useconds_t)(generatedExec_us_prev1[iterationm] * generatedSpin_damp));
								} 
								break;
						case kern_run.KERN_RUN_AUX2:
								if (generatedExec_us_prev_aux2[iterationm] > 0) {
									.usleep((useconds_t)(generatedExec_us_prev_aux2[iterationm] * generatedSpin_damp));
								} 
								break;
						}
					} else {
							.sleep(0);
					} 
					if (hashcat_ctx.hc_clGetEventInfo(opencl_event, CL_EVENT_COMMAND_EXECUTION_STATUS, , opencl_event_status, param_value_size_ret) == -1) {
						return -1;
					} 
					spin_total += generatedSpin_damp;
					if (spin_total > 1) {
						break;
					} 
				}
			} 
			if (hashcat_ctx.hc_clWaitForEvents(1, opencl_event) == -1) {
				return -1;
			} 
			 time_start = new ();
			 time_end = new ();
			if (hashcat_ctx.hc_clGetEventProfilingInfo(opencl_event, CL_PROFILING_COMMAND_START, , time_start, ((Object)0)) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clGetEventProfilingInfo(opencl_event, CL_PROFILING_COMMAND_END, , time_end, ((Object)0)) == -1) {
				return -1;
			} 
			double exec_us = (double)(time_end - time_start) / 1000;
			if (generatedSpin_damp > 0) {
				if (status_ctx.getDevices_status() == status_rc.STATUS_RUNNING) {
					switch (kern_run) {
					case kern_run.KERN_RUN_3:
							generatedExec_us_prev3[iterationm] = exec_us;
							break;
					case kern_run.KERN_RUN_4:
							generatedExec_us_prev4[iterationm] = exec_us;
							break;
					case kern_run.KERN_RUN_1:
							generatedExec_us_prev1[iterationm] = exec_us;
							break;
					case kern_run.KERN_RUN_INIT2:
							generatedExec_us_prev_init2[iterationm] = exec_us;
							break;
					case kern_run.KERN_RUN_AUX2:
							generatedExec_us_prev_aux2[iterationm] = exec_us;
							break;
					case kern_run.KERN_RUN_LOOP2:
							generatedExec_us_prev_loop2[iterationm] = exec_us;
							break;
					case kern_run.KERN_RUN_AUX4:
							generatedExec_us_prev_aux4[iterationm] = exec_us;
							break;
					case kern_run.KERN_RUN_AUX1:
							generatedExec_us_prev_aux1[iterationm] = exec_us;
							break;
					case kern_run.KERN_RUN_2:
							generatedExec_us_prev2[iterationm] = exec_us;
							break;
					case kern_run.KERN_RUN_AUX3:
							generatedExec_us_prev_aux3[iterationm] = exec_us;
							break;
					}
				} 
			} 
			if (event_update) {
				u32 exec_pos = generatedExec_pos;
				generatedExec_msec[exec_pos] = exec_us / 1000;
				exec_pos++;
				if (exec_pos == 128) {
					exec_pos = 0;
				} 
				device_param.setExec_pos(exec_pos);
			} 
			if (hashcat_ctx.hc_clReleaseEvent(opencl_event) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clFinish(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
		} 
		return 0;
	}
	public static int opencl_kernel(Object ) {
	}
	public static int opencl_event_status(Object ) {
	}
	public static int run_kernel_mp(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object kern_run, Object num) {
		u64 kernel_threads = 0;
		Object generatedKernel_wgs_mp = device_param.getKernel_wgs_mp();
		Object generatedKernel_wgs_mp_r = device_param.getKernel_wgs_mp_r();
		Object generatedKernel_wgs_mp_l = device_param.getKernel_wgs_mp_l();
		switch (kern_run) {
		case kern_run_mp.KERN_RUN_MP:
				kernel_threads = generatedKernel_wgs_mp;
				break;
		case kern_run_mp.KERN_RUN_MP_L:
				kernel_threads = generatedKernel_wgs_mp_l;
				break;
		case kern_run_mp.KERN_RUN_MP_R:
				kernel_threads = generatedKernel_wgs_mp_r;
				break;
		}
		u64 num_elements = num;
		Object generatedKernel_params_mp_buf64 = device_param.getKernel_params_mp_buf64();
		Object generatedKernel_params_mp_r_buf64 = device_param.getKernel_params_mp_r_buf64();
		Object generatedKernel_params_mp_l_buf64 = device_param.getKernel_params_mp_l_buf64();
		switch (kern_run) {
		case kern_run_mp.KERN_RUN_MP_R:
				generatedKernel_params_mp_r_buf64[8] = num;
				break;
		case kern_run_mp.KERN_RUN_MP:
				generatedKernel_params_mp_buf64[8] = num;
				break;
		case kern_run_mp.KERN_RUN_MP_L:
				generatedKernel_params_mp_l_buf64[9] = num;
				break;
		}
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_function_mp = device_param.getCuda_function_mp();
		Object generatedKernel_params_mp = device_param.getKernel_params_mp();
		Object generatedCuda_function_mp_r = device_param.getCuda_function_mp_r();
		Object generatedKernel_params_mp_r = device_param.getKernel_params_mp_r();
		Object generatedCuda_function_mp_l = device_param.getCuda_function_mp_l();
		Object generatedKernel_params_mp_l = device_param.getKernel_params_mp_l();
		Object generatedCuda_stream = device_param.getCuda_stream();
		if (generatedIs_cuda == true) {
			CUfunction cuda_function = ((Object)0);
			Object cuda_args = ((Object)0);
			switch (kern_run) {
			case kern_run_mp.KERN_RUN_MP:
					cuda_function = generatedCuda_function_mp;
					cuda_args = generatedKernel_params_mp;
					break;
			case kern_run_mp.KERN_RUN_MP_R:
					cuda_function = generatedCuda_function_mp_r;
					cuda_args = generatedKernel_params_mp_r;
					break;
			case kern_run_mp.KERN_RUN_MP_L:
					cuda_function = generatedCuda_function_mp_l;
					cuda_args = generatedKernel_params_mp_l;
					break;
			}
			num_elements = (((num_elements) + (kernel_threads) - 1) / (kernel_threads));
			if (hashcat_ctx.hc_cuLaunchKernel(cuda_function, num_elements, 1, 1, kernel_threads, 1, 1, 0, generatedCuda_stream, cuda_args, ((Object)0)) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_cuStreamSynchronize(generatedCuda_stream) == -1) {
				return -1;
			} 
		} 
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_kernel_mp = device_param.getOpencl_kernel_mp();
		Object generatedOpencl_kernel_mp_r = device_param.getOpencl_kernel_mp_r();
		Object generatedOpencl_kernel_mp_l = device_param.getOpencl_kernel_mp_l();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		if (generatedIs_opencl == true) {
			cl_kernel opencl_kernel = ((Object)0);
			switch (kern_run) {
			case kern_run_mp.KERN_RUN_MP_R:
					opencl_kernel = generatedOpencl_kernel_mp_r;
					break;
			case kern_run_mp.KERN_RUN_MP:
					opencl_kernel = generatedOpencl_kernel_mp;
					break;
			case kern_run_mp.KERN_RUN_MP_L:
					opencl_kernel = generatedOpencl_kernel_mp_l;
					break;
			}
			switch (kern_run) {
			case kern_run_mp.KERN_RUN_MP_L:
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 3, , generatedKernel_params_mp_l[3]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 4, , generatedKernel_params_mp_l[4]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 5, , generatedKernel_params_mp_l[5]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 6, , generatedKernel_params_mp_l[6]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 7, , generatedKernel_params_mp_l[7]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 8, , generatedKernel_params_mp_l[8]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 9, , generatedKernel_params_mp_l[9]) == -1) {
						return -1;
					} 
					break;
			case kern_run_mp.KERN_RUN_MP:
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 3, , generatedKernel_params_mp[3]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 4, , generatedKernel_params_mp[4]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 5, , generatedKernel_params_mp[5]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 6, , generatedKernel_params_mp[6]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 7, , generatedKernel_params_mp[7]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 8, , generatedKernel_params_mp[8]) == -1) {
						return -1;
					} 
					break;
			case kern_run_mp.KERN_RUN_MP_R:
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 3, , generatedKernel_params_mp_r[3]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 4, , generatedKernel_params_mp_r[4]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 5, , generatedKernel_params_mp_r[5]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 6, , generatedKernel_params_mp_r[6]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 7, , generatedKernel_params_mp_r[7]) == -1) {
						return -1;
					} 
					if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 8, , generatedKernel_params_mp_r[8]) == -1) {
						return -1;
					} 
					break;
			}
			num_elements = ModernizedCProgram.round_up_multiple_64(num_elements, kernel_threads);
			size_t[] global_work_size = new size_t[]{num_elements, 1, 1};
			size_t[] local_work_size = new size_t[]{kernel_threads, 1, 1};
			if (hashcat_ctx.hc_clEnqueueNDRangeKernel(generatedOpencl_command_queue, opencl_kernel, 1, ((Object)0), global_work_size, local_work_size, 0, ((Object)0), ((Object)0)) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clFlush(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clFinish(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
		} 
		return 0;
	}
	public static int run_kernel_tm(hashcat_ctx hashcat_ctx, hc_device_param device_param) {
		// fixedu64 num_elements = 1024;
		Object generatedKernel_wgs_tm = device_param.getKernel_wgs_tm();
		u64 kernel_threads = (((num_elements) < (generatedKernel_wgs_tm)) ? (num_elements) : (generatedKernel_wgs_tm));
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_function_tm = device_param.getCuda_function_tm();
		Object generatedCuda_stream = device_param.getCuda_stream();
		Object generatedKernel_params_tm = device_param.getKernel_params_tm();
		if (generatedIs_cuda == true) {
			CUfunction cuda_function = generatedCuda_function_tm;
			if (hashcat_ctx.hc_cuLaunchKernel(cuda_function, num_elements / kernel_threads, 1, 1, kernel_threads, 1, 1, 0, generatedCuda_stream, generatedKernel_params_tm, ((Object)0)) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_cuStreamSynchronize(generatedCuda_stream) == -1) {
				return -1;
			} 
		} 
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_kernel_tm = device_param.getOpencl_kernel_tm();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		if (generatedIs_opencl == true) {
			cl_kernel cuda_kernel = generatedOpencl_kernel_tm;
			size_t[] global_work_size = new size_t[]{num_elements, 1, 1};
			size_t[] local_work_size = new size_t[]{kernel_threads, 1, 1};
			if (hashcat_ctx.hc_clEnqueueNDRangeKernel(generatedOpencl_command_queue, cuda_kernel, 1, ((Object)0), global_work_size, local_work_size, 0, ((Object)0), ((Object)0)) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clFlush(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clFinish(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
		} 
		return 0;
	}
	public static int cuda_kernel(Object ) {
	}
	public static int run_kernel_amp(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object num) {
		Object generatedKernel_params_amp_buf64 = device_param.getKernel_params_amp_buf64();
		generatedKernel_params_amp_buf64[6] = num;
		u64 num_elements = num;
		Object generatedKernel_wgs_amp = device_param.getKernel_wgs_amp();
		u64 kernel_threads = generatedKernel_wgs_amp;
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_function_amp = device_param.getCuda_function_amp();
		Object generatedCuda_stream = device_param.getCuda_stream();
		Object generatedKernel_params_amp = device_param.getKernel_params_amp();
		if (generatedIs_cuda == true) {
			num_elements = (((num_elements) + (kernel_threads) - 1) / (kernel_threads));
			CUfunction cuda_function = generatedCuda_function_amp;
			if (hashcat_ctx.hc_cuLaunchKernel(cuda_function, num_elements, 1, 1, kernel_threads, 1, 1, 0, generatedCuda_stream, generatedKernel_params_amp, ((Object)0)) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_cuStreamSynchronize(generatedCuda_stream) == -1) {
				return -1;
			} 
		} 
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_kernel_amp = device_param.getOpencl_kernel_amp();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		if (generatedIs_opencl == true) {
			num_elements = ModernizedCProgram.round_up_multiple_64(num_elements, kernel_threads);
			cl_kernel opencl_kernel = generatedOpencl_kernel_amp;
			if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 6, , generatedKernel_params_amp[6]) == -1) {
				return -1;
			} 
			size_t[] global_work_size = new size_t[]{num_elements, 1, 1};
			size_t[] local_work_size = new size_t[]{kernel_threads, 1, 1};
			if (hashcat_ctx.hc_clEnqueueNDRangeKernel(generatedOpencl_command_queue, opencl_kernel, 1, ((Object)0), global_work_size, local_work_size, 0, ((Object)0), ((Object)0)) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clFlush(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clFinish(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
		} 
		return 0;
	}
	public static int run_kernel_decompress(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object num) {
		Object generatedKernel_params_decompress_buf64 = device_param.getKernel_params_decompress_buf64();
		generatedKernel_params_decompress_buf64[3] = num;
		u64 num_elements = num;
		Object generatedKernel_wgs_decompress = device_param.getKernel_wgs_decompress();
		u64 kernel_threads = generatedKernel_wgs_decompress;
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_function_decompress = device_param.getCuda_function_decompress();
		Object generatedCuda_stream = device_param.getCuda_stream();
		Object generatedKernel_params_decompress = device_param.getKernel_params_decompress();
		if (generatedIs_cuda == true) {
			num_elements = (((num_elements) + (kernel_threads) - 1) / (kernel_threads));
			CUfunction cuda_function = generatedCuda_function_decompress;
			if (hashcat_ctx.hc_cuLaunchKernel(cuda_function, num_elements, 1, 1, kernel_threads, 1, 1, 0, generatedCuda_stream, generatedKernel_params_decompress, ((Object)0)) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_cuStreamSynchronize(generatedCuda_stream) == -1) {
				return -1;
			} 
		} 
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_kernel_decompress = device_param.getOpencl_kernel_decompress();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		if (generatedIs_opencl == true) {
			num_elements = ModernizedCProgram.round_up_multiple_64(num_elements, kernel_threads);
			cl_kernel opencl_kernel = generatedOpencl_kernel_decompress;
			size_t[] global_work_size = new size_t[]{num_elements, 1, 1};
			size_t[] local_work_size = new size_t[]{kernel_threads, 1, 1};
			if (hashcat_ctx.hc_clSetKernelArg(opencl_kernel, 3, , generatedKernel_params_decompress[3]) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clEnqueueNDRangeKernel(generatedOpencl_command_queue, opencl_kernel, 1, ((Object)0), global_work_size, local_work_size, 0, ((Object)0), ((Object)0)) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clFlush(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
			if (hashcat_ctx.hc_clFinish(generatedOpencl_command_queue) == -1) {
				return -1;
			} 
		} 
		return 0;
	}
	public static int run_copy(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object pws_cnt) {
		combinator_ctx generatedCombinator_ctx = hashcat_ctx.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = hashcat_ctx.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		// init speed timer
		Object generatedTimer_speed = device_param.getTimer_speed();
		if (generatedTimer_speed.getQuadPart() == 0) {
			ModernizedCProgram.hc_timer_set(generatedTimer_speed);
		} 
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_d_pws_idx = device_param.getCuda_d_pws_idx();
		pw_idx generatedPws_idx = device_param.getPws_idx();
		Object generatedCuda_d_pws_comp_buf = device_param.getCuda_d_pws_comp_buf();
		Object generatedPws_comp = device_param.getPws_comp();
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedOpencl_d_pws_idx = device_param.getOpencl_d_pws_idx();
		Object generatedOpencl_d_pws_comp_buf = device_param.getOpencl_d_pws_comp_buf();
		Object generatedAttack_kern = user_options_extra.getAttack_kern();
		Object generatedOpti_type = hashconfig.getOpti_type();
		Object generatedAttack_mode = user_options.getAttack_mode();
		Object generatedCombs_mode = combinator_ctx.getCombs_mode();
		Object generatedOpts_type = hashconfig.getOpts_type();
		Object generatedWords_off = device_param.getWords_off();
		Object generatedKernel_params_mp_buf64 = device_param.getKernel_params_mp_buf64();
		Object generatedKernel_params_mp_l_buf64 = device_param.getKernel_params_mp_l_buf64();
		if (generatedSlow_candidates == true) {
			if (generatedIs_cuda == true) {
				if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_idx, generatedPws_idx, pws_cnt * ) == -1) {
					return -1;
				} 
				pw_idx_t pw_idx = generatedPws_idx + pws_cnt;
				u32 off = pw_idx.getOff();
				if (off) {
					if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_comp_buf, generatedPws_comp, off * ) == -1) {
						return -1;
					} 
				} 
			} 
			if (generatedIs_opencl == true) {
				if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_idx, CL_TRUE, 0, pws_cnt * , generatedPws_idx, 0, ((Object)0), ((Object)0)) == -1) {
					return -1;
				} 
				pw_idx_t pw_idx = generatedPws_idx + pws_cnt;
				u32 off = pw_idx.getOff();
				if (off) {
					if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_comp_buf, CL_TRUE, 0, off * , generatedPws_comp, 0, ((Object)0), ((Object)0)) == -1) {
						return -1;
					} 
				} 
			} 
			if (ModernizedCProgram.run_kernel_decompress(hashcat_ctx, device_param, pws_cnt) == -1) {
				return -1;
			} 
		} else {
				if (generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
					if (generatedIs_cuda == true) {
						if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_idx, generatedPws_idx, pws_cnt * ) == -1) {
							return -1;
						} 
						pw_idx_t pw_idx = generatedPws_idx + pws_cnt;
						u32 off = pw_idx.getOff();
						if (off) {
							if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_comp_buf, generatedPws_comp, off * ) == -1) {
								return -1;
							} 
						} 
					} 
					if (generatedIs_opencl == true) {
						if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_idx, CL_TRUE, 0, pws_cnt * , generatedPws_idx, 0, ((Object)0), ((Object)0)) == -1) {
							return -1;
						} 
						pw_idx_t pw_idx = generatedPws_idx + pws_cnt;
						u32 off = pw_idx.getOff();
						if (off) {
							if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_comp_buf, CL_TRUE, 0, off * , generatedPws_comp, 0, ((Object)0), ((Object)0)) == -1) {
								return -1;
							} 
						} 
					} 
					if (ModernizedCProgram.run_kernel_decompress(hashcat_ctx, device_param, pws_cnt) == -1) {
						return -1;
					} 
				}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
					if (generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
						if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
							if (generatedCombs_mode == combinator_mode.COMBINATOR_MODE_BASE_RIGHT) {
								if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD01) {
									device_param.rebuild_pws_compressed_append(pws_cnt, -1024);
								}  else if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD06) {
									device_param.rebuild_pws_compressed_append(pws_cnt, -1024);
								}  else if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD80) {
									device_param.rebuild_pws_compressed_append(pws_cnt, -1024);
								} 
							} 
						}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
							if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD01) {
								device_param.rebuild_pws_compressed_append(pws_cnt, -1024);
							}  else if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD06) {
								device_param.rebuild_pws_compressed_append(pws_cnt, -1024);
							}  else if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD80) {
								device_param.rebuild_pws_compressed_append(pws_cnt, -1024);
							} 
						} 
						if (generatedIs_cuda == true) {
							if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_idx, generatedPws_idx, pws_cnt * ) == -1) {
								return -1;
							} 
							pw_idx_t pw_idx = generatedPws_idx + pws_cnt;
							u32 off = pw_idx.getOff();
							if (off) {
								if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_comp_buf, generatedPws_comp, off * ) == -1) {
									return -1;
								} 
							} 
						} 
						if (generatedIs_opencl == true) {
							if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_idx, CL_TRUE, 0, pws_cnt * , generatedPws_idx, 0, ((Object)0), ((Object)0)) == -1) {
								return -1;
							} 
							pw_idx_t pw_idx = generatedPws_idx + pws_cnt;
							u32 off = pw_idx.getOff();
							if (off) {
								if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_comp_buf, CL_TRUE, 0, off * , generatedPws_comp, 0, ((Object)0), ((Object)0)) == -1) {
									return -1;
								} 
							} 
						} 
						if (ModernizedCProgram.run_kernel_decompress(hashcat_ctx, device_param, pws_cnt) == -1) {
							return -1;
						} 
					} else {
							if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
								if (generatedIs_cuda == true) {
									if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_idx, generatedPws_idx, pws_cnt * ) == -1) {
										return -1;
									} 
									pw_idx_t pw_idx = generatedPws_idx + pws_cnt;
									u32 off = pw_idx.getOff();
									if (off) {
										if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_comp_buf, generatedPws_comp, off * ) == -1) {
											return -1;
										} 
									} 
								} 
								if (generatedIs_opencl == true) {
									if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_idx, CL_TRUE, 0, pws_cnt * , generatedPws_idx, 0, ((Object)0), ((Object)0)) == -1) {
										return -1;
									} 
									pw_idx_t pw_idx = generatedPws_idx + pws_cnt;
									u32 off = pw_idx.getOff();
									if (off) {
										if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_comp_buf, CL_TRUE, 0, off * , generatedPws_comp, 0, ((Object)0), ((Object)0)) == -1) {
											return -1;
										} 
									} 
								} 
								if (ModernizedCProgram.run_kernel_decompress(hashcat_ctx, device_param, pws_cnt) == -1) {
									return -1;
								} 
							}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
								if (generatedIs_cuda == true) {
									if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_idx, generatedPws_idx, pws_cnt * ) == -1) {
										return -1;
									} 
									pw_idx_t pw_idx = generatedPws_idx + pws_cnt;
									u32 off = pw_idx.getOff();
									if (off) {
										if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_pws_comp_buf, generatedPws_comp, off * ) == -1) {
											return -1;
										} 
									} 
								} 
								if (generatedIs_opencl == true) {
									if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_idx, CL_TRUE, 0, pws_cnt * , generatedPws_idx, 0, ((Object)0), ((Object)0)) == -1) {
										return -1;
									} 
									pw_idx_t pw_idx = generatedPws_idx + pws_cnt;
									u32 off = pw_idx.getOff();
									if (off) {
										if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_pws_comp_buf, CL_TRUE, 0, off * , generatedPws_comp, 0, ((Object)0), ((Object)0)) == -1) {
											return -1;
										} 
									} 
								} 
								if (ModernizedCProgram.run_kernel_decompress(hashcat_ctx, device_param, pws_cnt) == -1) {
									return -1;
								} 
							}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
								u64 off = generatedWords_off;
								generatedKernel_params_mp_buf64[3] = off;
								if (ModernizedCProgram.run_kernel_mp(hashcat_ctx, device_param, kern_run_mp.KERN_RUN_MP, pws_cnt) == -1) {
									return -1;
								} 
							} 
					} 
				}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_BF) {
					u64 off = generatedWords_off;
					generatedKernel_params_mp_l_buf64[3] = off;
					if (ModernizedCProgram.run_kernel_mp(hashcat_ctx, device_param, kern_run_mp.KERN_RUN_MP_L, pws_cnt) == -1) {
						return -1;
					} 
				} 
		} 
		return 0;
	}
	public static int run_cracker(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object pws_cnt) {
		combinator_ctx generatedCombinator_ctx = hashcat_ctx.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = hashcat_ctx.getHashes();
		hashes_t hashes = generatedHashes;
		mask_ctx generatedMask_ctx = hashcat_ctx.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		straight_ctx generatedStraight_ctx = hashcat_ctx.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		user_options_extra generatedUser_options_extra = hashcat_ctx.getUser_options_extra();
		user_options_extra_t user_options_extra = generatedUser_options_extra;
		// do the on-the-fly combinator mode encoding
		boolean iconv_enabled = false;
		 iconv_ctx = ((Object)0);
		byte iconv_tmp = ((Object)0);
		Object generatedEncoding_from = user_options.getEncoding_from();
		Object generatedEncoding_to = user_options.getEncoding_to();
		if (.strcmp(generatedEncoding_from, generatedEncoding_to) != 0) {
			iconv_enabled = true;
			iconv_ctx = .iconv_open(generatedEncoding_to, generatedEncoding_from);
			if (iconv_ctx == (iconv_t) - 1) {
				return -1;
			} 
			iconv_tmp = (byte)ModernizedCProgram.hcmalloc(-1024);
		} 
		// find higest password length, this is for optimization stuffu32 highest_pw_len = 0;
		boolean generatedSlow_candidates = user_options.getSlow_candidates();
		Object generatedAttack_kern = user_options_extra.getAttack_kern();
		Object generatedKernel_params_mp_l_buf32 = device_param.getKernel_params_mp_l_buf32();
		if (generatedSlow_candidates == true/*
		    for (u64 pws_idx = 0; pws_idx < pws_cnt; pws_idx++)
		    {
		      pw_idx_t *pw_idx = device_param->pws_idx + pws_idx;
		
		      highest_pw_len = MAX (highest_pw_len, pw_idx->len);
		    }
		    */) {
		} else {
				if (generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
				}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
				}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_BF) {
					highest_pw_len = generatedKernel_params_mp_l_buf32[4] + generatedKernel_params_mp_l_buf32[5];
				} 
		} 
		// we make use of this in status view// we make use of this in status viewdevice_param.setOuterloop_multi(1);
		device_param.setOuterloop_msec(0);
		device_param.setOuterloop_pos(0);
		device_param.setOuterloop_left(pws_cnt)// we ignore the time to copy data over pci bus in this case;// we ignore the time to copy data over pci bus in this case
		boolean generatedSpeed_only = user_options.getSpeed_only();
		Object generatedTimer_speed = device_param.getTimer_speed();
		if (generatedSpeed_only == true) {
			ModernizedCProgram.hc_timer_set(generatedTimer_speed);
		} 
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		Object generatedDevices_status = status_ctx.getDevices_status();
		salt generatedSalts_buf = hashes.getSalts_buf();
		Object generatedKernel_params_buf32 = device_param.getKernel_params_buf32();
		Object generatedDigests_cnt = salt_buf.getDigests_cnt();
		Object generatedDigests_offset = salt_buf.getDigests_offset();
		hc_fp generatedCombs_fp = device_param.getCombs_fp();
		Object generatedAttack_mode = user_options.getAttack_mode();
		Object generatedOpti_type = hashconfig.getOpti_type();
		Object generatedAttack_exec = hashconfig.getAttack_exec();
		Object generatedKernel_loops = device_param.getKernel_loops();
		Object generatedKernel_rules_cnt = straight_ctx.getKernel_rules_cnt();
		Object generatedCombs_cnt = combinator_ctx.getCombs_cnt();
		Object generatedBfs_cnt = mask_ctx.getBfs_cnt();
		Object generatedMux_display = status_ctx.getMux_display();
		Object generatedSalts_shown = hashes.getSalts_shown();
		Object generatedWords_progress_done = status_ctx.getWords_progress_done();
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_d_rules_c = device_param.getCuda_d_rules_c();
		Object generatedCuda_d_rules = device_param.getCuda_d_rules();
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedOpencl_d_rules = device_param.getOpencl_d_rules();
		Object generatedOpencl_d_rules_c = device_param.getOpencl_d_rules_c();
		Byte generatedScratch_buf = device_param.getScratch_buf();
		Object generatedRule_len_r = user_options_extra.getRule_len_r();
		Object generatedRule_buf_r = user_options.getRule_buf_r();
		Object generatedWords_progress_rejected = status_ctx.getWords_progress_rejected();
		pw generatedCombs_buf = device_param.getCombs_buf();
		Object generatedOpts_type = hashconfig.getOpts_type();
		Object generatedCombs_mode = combinator_ctx.getCombs_mode();
		Object generatedCuda_d_combs_c = device_param.getCuda_d_combs_c();
		Object generatedOpencl_d_combs_c = device_param.getOpencl_d_combs_c();
		Object generatedKernel_params_mp_buf64 = device_param.getKernel_params_mp_buf64();
		Object generatedCuda_d_combs = device_param.getCuda_d_combs();
		Object generatedOpencl_d_combs = device_param.getOpencl_d_combs();
		Object generatedKernel_params_mp_r_buf64 = device_param.getKernel_params_mp_r_buf64();
		Object generatedCuda_d_bfs_c = device_param.getCuda_d_bfs_c();
		Object generatedCuda_d_bfs = device_param.getCuda_d_bfs();
		Object generatedOpencl_d_bfs = device_param.getOpencl_d_bfs();
		Object generatedOpencl_d_bfs_c = device_param.getOpencl_d_bfs_c();
		boolean generatedSpeed_only_finish = device_param.getSpeed_only_finish();
		boolean generatedRun_thread_level2 = status_ctx.getRun_thread_level2();
		Object generatedSpeed_pos = device_param.getSpeed_pos();
		Object generatedSpeed_cnt = device_param.getSpeed_cnt();
		Object generatedSpeed_msec = device_param.getSpeed_msec();
		Object generatedMux_counter = status_ctx.getMux_counter();
		// loop start: most outer loop = salt iteration, then innerloops (if multi)for (u32 salt_pos = 0;
		 salt_pos < generatedSalts_cnt; salt_pos++) {
			while (generatedDevices_status == status_rc.STATUS_PAUSED) {
				.sleep(1);
			}
			salt_t salt_buf = generatedSalts_buf[salt_pos];
			generatedKernel_params_buf32[27] = salt_pos;
			generatedKernel_params_buf32[31] = generatedDigests_cnt;
			generatedKernel_params_buf32[32] = generatedDigests_offset;
			HCFILE combs_fp = generatedCombs_fp;
			if (generatedSlow_candidates == true) {
			} else {
					if ((generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) || (((generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) == 0) && (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2))) {
						combs_fp.hc_rewind();
					} 
			} 
			u32 innerloop_step = 0;
			u32 innerloop_cnt = 0;
			if (generatedSlow_candidates == true) {
				innerloop_step = 1;
				innerloop_cnt = 1;
			} else {
					if (generatedAttack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
						innerloop_step = generatedKernel_loops;
					} else {
							innerloop_step = 1;
					} 
					if (generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
						innerloop_cnt = generatedKernel_rules_cnt;
					}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
						innerloop_cnt = (u32)generatedCombs_cnt;
					}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_BF) {
						innerloop_cnt = (u32)generatedBfs_cnt;
					} 
			} 
			for (u32 innerloop_pos = 0;
			 innerloop_pos < innerloop_cnt; innerloop_pos += innerloop_step) {
				while (generatedDevices_status == status_rc.STATUS_PAUSED) {
					.sleep(1);
				}
				u32 fast_iteration = 0;
				u32 innerloop_left = innerloop_cnt - innerloop_pos;
				if (innerloop_left > innerloop_step) {
					innerloop_left = innerloop_step;
					fast_iteration = 1;
				} 
				.WaitForSingleObject(generatedMux_display, -1024);
				device_param.setInnerloop_pos(innerloop_pos);
				device_param.setInnerloop_left(innerloop_left);
				generatedKernel_params_buf32[30] = innerloop_left;
				device_param.setOuterloop_multi((double)innerloop_cnt / (double)(innerloop_pos + innerloop_left));
				.ReleaseMutex(generatedMux_display);
				if (generatedSalts_shown[salt_pos] == 1) {
					generatedWords_progress_done[salt_pos] += pws_cnt * innerloop_left;
					continue;
				} 
				if (generatedSlow_candidates == true) {
				} else {
						if (generatedAttack_kern == attack_kern.ATTACK_KERN_STRAIGHT) {
							if (generatedIs_cuda == true) {
								if (hashcat_ctx.hc_cuMemcpyDtoD(generatedCuda_d_rules_c, generatedCuda_d_rules + (innerloop_pos * ), innerloop_left * ) == -1) {
									return -1;
								} 
							} 
							if (generatedIs_opencl == true) {
								if (hashcat_ctx.hc_clEnqueueCopyBuffer(generatedOpencl_command_queue, generatedOpencl_d_rules, generatedOpencl_d_rules_c, innerloop_pos * , 0, innerloop_left * , 0, ((Object)0), ((Object)0)) == -1) {
									return -1;
								} 
							} 
						}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_COMBI) {
							if (generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
								if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
									byte line_buf = generatedScratch_buf;
									u32 i = 0;
									while (i < innerloop_left) {
										if (combs_fp.hc_feof()) {
											break;
										} 
										size_t line_len = combs_fp.fgetl(line_buf, -1024);
										line_len = hashcat_ctx.convert_from_hex(line_buf, line_len);
										if (line_len > 256) {
											continue;
										} 
										byte line_buf_new = line_buf;
										byte[] rule_buf_out = new byte[256];
										if (ModernizedCProgram.run_rule_engine(generatedRule_len_r, generatedRule_buf_r)) {
											if (line_len >= 256) {
												continue;
											} 
											.memset(rule_buf_out, 0, );
											int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_r, generatedRule_len_r, line_buf, (u32)line_len, rule_buf_out);
											if (rule_len_out < 0) {
												generatedWords_progress_rejected[salt_pos] += pws_cnt;
												continue;
											} 
											line_len = rule_len_out;
											line_buf_new = rule_buf_out;
										} 
										if (iconv_enabled == true) {
											byte iconv_ptr = iconv_tmp;
											size_t iconv_sz = -1024;
											if (.iconv(iconv_ctx, line_buf_new, line_len, iconv_ptr, iconv_sz) == (size_t)-1) {
												continue;
											} 
											line_buf_new = iconv_tmp;
											line_len = -1024 - iconv_sz;
										} 
										line_len = (((line_len) < (true)) ? (line_len) : (true));
										u8 ptr = (u8)generatedCombs_buf[i].getI();
										.memcpy(ptr, line_buf_new, line_len);
										.memset(ptr + line_len, 0, 256 - line_len);
										if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UPPER) {
											ModernizedCProgram.uppercase(ptr, line_len);
										} 
										if (generatedCombs_mode == combinator_mode.COMBINATOR_MODE_BASE_LEFT) {
											if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD80) {
												ptr[line_len] = -1024;
											} 
											if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD06) {
												ptr[line_len] = -1024;
											} 
											if (generatedOpts_type & opts_type.OPTS_TYPE_PT_ADD01) {
												ptr[line_len] = -1024;
											} 
										} 
										generatedCombs_buf[i].setPw_len((u32)line_len);
										i++;
									}
									for (u32 j = i;
									 j < innerloop_left; j++) {
										.memset(generatedCombs_buf[j], 0, );
									}
									innerloop_left = i;
									if (generatedIs_cuda == true) {
										if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_combs_c, generatedCombs_buf, innerloop_left * ) == -1) {
											return -1;
										} 
									} 
									if (generatedIs_opencl == true) {
										if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_combs_c, CL_TRUE, 0, innerloop_left * , generatedCombs_buf, 0, ((Object)0), ((Object)0)) == -1) {
											return -1;
										} 
									} 
								}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
									u64 off = innerloop_pos;
									generatedKernel_params_mp_buf64[3] = off;
									if (ModernizedCProgram.run_kernel_mp(hashcat_ctx, device_param, kern_run_mp.KERN_RUN_MP, innerloop_left) == -1) {
										return -1;
									} 
									if (generatedIs_cuda == true) {
										if (hashcat_ctx.hc_cuMemcpyDtoD(generatedCuda_d_combs_c, generatedCuda_d_combs, innerloop_left * ) == -1) {
											return -1;
										} 
									} 
									if (generatedIs_opencl == true) {
										if (hashcat_ctx.hc_clEnqueueCopyBuffer(generatedOpencl_command_queue, generatedOpencl_d_combs, generatedOpencl_d_combs_c, 0, 0, innerloop_left * , 0, ((Object)0), ((Object)0)) == -1) {
											return -1;
										} 
									} 
								}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
									u64 off = innerloop_pos;
									generatedKernel_params_mp_buf64[3] = off;
									if (ModernizedCProgram.run_kernel_mp(hashcat_ctx, device_param, kern_run_mp.KERN_RUN_MP, innerloop_left) == -1) {
										return -1;
									} 
									if (generatedIs_cuda == true) {
										if (hashcat_ctx.hc_cuMemcpyDtoD(generatedCuda_d_combs_c, generatedCuda_d_combs, innerloop_left * ) == -1) {
											return -1;
										} 
									} 
									if (generatedIs_opencl == true) {
										if (hashcat_ctx.hc_clEnqueueCopyBuffer(generatedOpencl_command_queue, generatedOpencl_d_combs, generatedOpencl_d_combs_c, 0, 0, innerloop_left * , 0, ((Object)0), ((Object)0)) == -1) {
											return -1;
										} 
									} 
								} 
							} else {
									if ((generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) || (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2)) {
										byte line_buf = generatedScratch_buf;
										u32 i = 0;
										while (i < innerloop_left) {
											if (combs_fp.hc_feof()) {
												break;
											} 
											size_t line_len = combs_fp.fgetl(line_buf, -1024);
											line_len = hashcat_ctx.convert_from_hex(line_buf, line_len);
											if (line_len > 256) {
												continue;
											} 
											byte line_buf_new = line_buf;
											byte[] rule_buf_out = new byte[256];
											if (ModernizedCProgram.run_rule_engine(generatedRule_len_r, generatedRule_buf_r)) {
												if (line_len >= 256) {
													continue;
												} 
												.memset(rule_buf_out, 0, );
												int rule_len_out = ModernizedCProgram._old_apply_rule(generatedRule_buf_r, generatedRule_len_r, line_buf, (u32)line_len, rule_buf_out);
												if (rule_len_out < 0) {
													generatedWords_progress_rejected[salt_pos] += pws_cnt;
													continue;
												} 
												line_len = rule_len_out;
												line_buf_new = rule_buf_out;
											} 
											if (iconv_enabled == true) {
												byte iconv_ptr = iconv_tmp;
												size_t iconv_sz = -1024;
												if (.iconv(iconv_ctx, line_buf_new, line_len, iconv_ptr, iconv_sz) == (size_t)-1) {
													continue;
												} 
												line_buf_new = iconv_tmp;
												line_len = -1024 - iconv_sz;
											} 
											line_len = (((line_len) < (true)) ? (line_len) : (true));
											u8 ptr = (u8)generatedCombs_buf[i].getI();
											.memcpy(ptr, line_buf_new, line_len);
											.memset(ptr + line_len, 0, 256 - line_len);
											if (generatedOpts_type & opts_type.OPTS_TYPE_PT_UPPER) {
												ModernizedCProgram.uppercase(ptr, line_len/*
												                if (combinator_ctx->combs_mode == COMBINATOR_MODE_BASE_LEFT)
												                {
												                  if (hashconfig->opts_type & OPTS_TYPE_PT_ADD80)
												                  {
												                    ptr[line_len] = 0x80;
												                  }
												
												                  if (hashconfig->opts_type & OPTS_TYPE_PT_ADD06)
												                  {
												                    ptr[line_len] = 0x06;
												                  }
												
												                  if (hashconfig->opts_type & OPTS_TYPE_PT_ADD01)
												                  {
												                    ptr[line_len] = 0x01;
												                  }
												                }
												                */);
											} 
											generatedCombs_buf[i].setPw_len((u32)line_len);
											i++;
										}
										for (u32 j = i;
										 j < innerloop_left; j++) {
											.memset(generatedCombs_buf[j], 0, );
										}
										innerloop_left = i;
										if (generatedIs_cuda == true) {
											if (hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_combs_c, generatedCombs_buf, innerloop_left * ) == -1) {
												return -1;
											} 
										} 
										if (generatedIs_opencl == true) {
											if (hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_combs_c, CL_TRUE, 0, innerloop_left * , generatedCombs_buf, 0, ((Object)0), ((Object)0)) == -1) {
												return -1;
											} 
										} 
									}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
										u64 off = innerloop_pos;
										generatedKernel_params_mp_buf64[3] = off;
										if (ModernizedCProgram.run_kernel_mp(hashcat_ctx, device_param, kern_run_mp.KERN_RUN_MP, innerloop_left) == -1) {
											return -1;
										} 
										if (generatedIs_cuda == true) {
											if (hashcat_ctx.hc_cuMemcpyDtoD(generatedCuda_d_combs_c, generatedCuda_d_combs, innerloop_left * ) == -1) {
												return -1;
											} 
										} 
										if (generatedIs_opencl == true) {
											if (hashcat_ctx.hc_clEnqueueCopyBuffer(generatedOpencl_command_queue, generatedOpencl_d_combs, generatedOpencl_d_combs_c, 0, 0, innerloop_left * , 0, ((Object)0), ((Object)0)) == -1) {
												return -1;
											} 
										} 
									} 
							} 
						}  else if (generatedAttack_kern == attack_kern.ATTACK_KERN_BF) {
							u64 off = innerloop_pos;
							generatedKernel_params_mp_r_buf64[3] = off;
							if (ModernizedCProgram.run_kernel_mp(hashcat_ctx, device_param, kern_run_mp.KERN_RUN_MP_R, innerloop_left) == -1) {
								return -1;
							} 
							if (generatedIs_cuda == true) {
								if (hashcat_ctx.hc_cuMemcpyDtoD(generatedCuda_d_bfs_c, generatedCuda_d_bfs, innerloop_left * ) == -1) {
									return -1;
								} 
							} 
							if (generatedIs_opencl == true) {
								if (hashcat_ctx.hc_clEnqueueCopyBuffer(generatedOpencl_command_queue, generatedOpencl_d_bfs, generatedOpencl_d_bfs_c, 0, 0, innerloop_left * , 0, ((Object)0), ((Object)0)) == -1) {
									return -1;
								} 
							} 
						} 
				} 
				if (ModernizedCProgram.choose_kernel(hashcat_ctx, device_param, highest_pw_len, pws_cnt, fast_iteration, salt_pos) == -1) {
					return -1/**
					       * benchmark was aborted because too long kernel runtime (slow hashes only)
					       */;
				} 
				if ((generatedSpeed_only == true) && (generatedSpeed_only_finish == true)) {
				} else {
						if (generatedRun_thread_level2 == /**
						         * speed
						         */true) {
							u64 perf_sum_all = pws_cnt * innerloop_left;
							double speed_msec = ModernizedCProgram.hc_timer_get(generatedTimer_speed);
							ModernizedCProgram.hc_timer_set(generatedTimer_speed);
							u32 speed_pos = generatedSpeed_pos;
							generatedSpeed_cnt[speed_pos] = perf_sum_all;
							generatedSpeed_msec[speed_pos] = speed_msec;
							speed_pos++;
							if (speed_pos == 4096) {
								speed_pos = 0;
							} 
							device_param.setSpeed_pos(speed_pos/**
							           * progress
							           */);
							.WaitForSingleObject(generatedMux_counter, -1024);
							generatedWords_progress_done[salt_pos] += perf_sum_all;
							.ReleaseMutex(generatedMux_counter);
						} 
				} 
				if (generatedSpeed_only == /**
				       * benchmark, part2
				       */true) {
					if (generatedAttack_exec == attack_exec.ATTACK_EXEC_OUTSIDE_KERNEL) {
						device_param.setSpeed_only_finish(1);
						break;
					} 
					double total_msec = generatedSpeed_msec[0];
					for (u32 speed_pos = 1;
					 speed_pos < generatedSpeed_pos; speed_pos++) {
						total_msec += generatedSpeed_msec[speed_pos];
					}
					if (generatedSlow_candidates == true) {
						if ((total_msec > 4000) || (generatedSpeed_pos == 4096 - 1)) {
							u32 speed_pos = generatedSpeed_pos;
							if (speed_pos) {
								generatedSpeed_cnt[0] = generatedSpeed_cnt[speed_pos - 1];
								generatedSpeed_msec[0] = generatedSpeed_msec[speed_pos - 1];
							} 
							device_param.setSpeed_pos(0);
							device_param.setSpeed_only_finish(1);
							break;
						} 
					} else {
							if ((total_msec > 4000) || (generatedSpeed_pos == 4096 - 1)) {
								device_param.setSpeed_only_finish(1);
								break;
							} 
					} 
				} 
				if (generatedSpeed_only_finish == true/**
				       * result
				       */) {
					break;
				} 
				ModernizedCProgram.check_cracked(hashcat_ctx, device_param, salt_pos);
				if (generatedRun_thread_level2 == false) {
					break;
				} 
			}
			if (generatedSpeed_only == true) {
				break;
			} 
			if (generatedRun_thread_level2 == false) {
				break;
			} 
		}
		double generatedOuterloop_multi = device_param.getOuterloop_multi();
		//device_param->outerloop_pos  = 0;//device_param->outerloop_left = 0;if (generatedSpeed_only == true) {
			double total_msec = generatedSpeed_msec[0];
			for (u32 speed_pos = 1;
			 speed_pos < generatedSpeed_pos; speed_pos++) {
				total_msec += generatedSpeed_msec[speed_pos];
			}
			device_param.setOuterloop_msec(total_msec * generatedSalts_cnt * generatedOuterloop_multi);
			device_param.setSpeed_only_finish(1);
		} 
		return 0;
	}
	public static int context(Object ) {
	}
	public static int command_queue(Object ) {
	}
	public static int get_opencl_kernel_wgs(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object kernel, Object result) {
		size_t work_group_size = 0;
		Object generatedOpencl_device = device_param.getOpencl_device();
		if (hashcat_ctx.hc_clGetKernelWorkGroupInfo(kernel, generatedOpencl_device, CL_KERNEL_WORK_GROUP_SIZE, , work_group_size, ((Object)0)) == -1) {
			return -1;
		} 
		u32 kernel_threads = (u32)work_group_size;
		size_t[] compile_work_group_size = new size_t[]{0, 0, 0};
		if (hashcat_ctx.hc_clGetKernelWorkGroupInfo(kernel, generatedOpencl_device, CL_KERNEL_COMPILE_WORK_GROUP_SIZE, , compile_work_group_size, ((Object)0)) == -1) {
			return -1;
		} 
		size_t cwgs_total = compile_work_group_size[0] * compile_work_group_size[1] * compile_work_group_size[2];
		if (cwgs_total > 0) {
			kernel_threads = (((kernel_threads) < ((u32)cwgs_total)) ? (kernel_threads) : ((u32)cwgs_total));
		} 
		result = kernel_threads;
		return 0;
	}
	public static int get_opencl_kernel_preferred_wgs_multiple(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object kernel, Object result) {
		size_t preferred_work_group_size_multiple = 0;
		Object generatedOpencl_device = device_param.getOpencl_device();
		if (hashcat_ctx.hc_clGetKernelWorkGroupInfo(kernel, generatedOpencl_device, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, , preferred_work_group_size_multiple, ((Object)0)) == -1) {
			return -1;
		} 
		result = (u32)preferred_work_group_size_multiple;
		return 0;
	}
	public static int get_opencl_kernel_local_mem_size(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object kernel, Object result) {
		 local_mem_size = 0;
		Object generatedOpencl_device = device_param.getOpencl_device();
		if (hashcat_ctx.hc_clGetKernelWorkGroupInfo(kernel, generatedOpencl_device, CL_KERNEL_LOCAL_MEM_SIZE, , local_mem_size, ((Object)0)) == -1) {
			return -1;
		} 
		result = local_mem_size;
		return 0;
	}
	public static Object get_kernel_threads(Object device_param) {
		// this is an upper limit, a good start, since our strategy is to reduce thread counts only.u32 kernel_threads_min = device_param.getKernel_threads_min();
		u32 kernel_threads_max = device_param.getKernel_threads_max();
		// the changes we do here are just optimizations, since the module always has priority.
		u32 device_maxworkgroup_size = (u32)device_param.getDevice_maxworkgroup_size();
		kernel_threads_max = (((kernel_threads_max) < (device_maxworkgroup_size)) ? (kernel_threads_max) : (device_maxworkgroup_size))// for CPU we just do 1 ...;// for CPU we just do 1 ...
		if (device_param.getOpencl_device_type() & CL_DEVICE_TYPE_CPU) {
			u32 cpu_prefered_thread_count = 1;
			kernel_threads_max = (((kernel_threads_max) < (cpu_prefered_thread_count)) ? (kernel_threads_max) : (cpu_prefered_thread_count));
		} 
		// in this case we actually want kernel_threads_min selected.u32 kernel_threads = (((kernel_threads_min) > (kernel_threads_max)) ? (kernel_threads_min) : (kernel_threads_max));
		return kernel_threads;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static Object val2cstr_cl(Object CL_err) {
		switch (CL_err/**
		     * OpenCL runtime errors
		     *//**
		     * OpenCL compile-time errors
		     */) {
		case -1001:
				return "CL_PLATFORM_NOT_FOUND_KHR";
		}
		return "CL_UNKNOWN_ERROR";
	}
	public static Object module_pwdump_column(Object hashconfig, Object user_options, Object user_options_extra) {
		return ModernizedCProgram.PWDUMP_COLUMN;
		return ModernizedCProgram.PWDUMP_COLUMN;
		return ModernizedCProgram.PWDUMP_COLUMN;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	/**
	 * parsing
	 */
	public static int module_filename(Object folder_config, Object hash_mode, Byte out_buf, Object out_size) {
		// native compiledreturn .snprintf(out_buf, out_size, "%s/modules/module_%05d.dll", folder_config.getShared_dir(), hash_mode);
	}
	public static boolean module_load(hashcat_ctx hashcat_ctx, module_ctx module_ctx, Object hash_mode) {
		folder_config generatedFolder_config = hashcat_ctx.getFolder_config();
		folder_config_t folder_config = generatedFolder_config;
		.memset(module_ctx, 0, );
		byte module_file = (byte)ModernizedCProgram.hcmalloc(-1024);
		ModernizedCProgram.module_filename(folder_config, hash_mode, module_file, -1024);
		module_ctx.setModule_handle(ModernizedCProgram.hc_dlopen(module_file));
		Object generatedModule_handle = module_ctx.getModule_handle();
		if (generatedModule_handle == ((Object)0)) {
			hashcat_ctx.event_log_error("Cannot load module %s", module_file);
			return 0;
		} 
		module_ctx.setModule_init((MODULE_INIT)ModernizedCProgram.hc_dlsym(generatedModule_handle, "module_init"));
		Object generatedModule_init = module_ctx.getModule_init();
		if (generatedModule_init == ((Object)0)) {
			hashcat_ctx.event_log_error("Cannot load symbol 'module_init' in module %s", module_file);
			return 0;
		} 
		ModernizedCProgram.hcfree(module_file);
		return 1;
	}
	public static Object default_benchmark_mask(Object hashconfig, Object user_options, Object user_options_extra) {
		byte mask = "?b?b?b?b?b?b?b";
		return mask;
	}
	public static Object default_hash_mode(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 hash_mode = user_options.getHash_mode();
		return hash_mode;
	}
	public static Object default_tmp_size(Object hashconfig, Object user_options, Object user_options_extra) {
		u64 tmp_size = 4;
		return tmp_size;
	}
	public static Object default_esalt_size(Object hashconfig, Object user_options, Object user_options_extra) {
		u64 esalt_size = 0;
		return esalt_size;
	}
	public static Object default_kernel_accel_min(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 kernel_accel_min = kernel_workload.KERNEL_ACCEL_MIN;
		return kernel_accel_min;
	}
	public static Object default_kernel_accel_max(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 kernel_accel_max = kernel_workload.KERNEL_ACCEL_MAX;
		return kernel_accel_max;
	}
	public static Object default_kernel_loops_min(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 kernel_loops_min = kernel_workload.KERNEL_LOOPS_MIN;
		return kernel_loops_min;
	}
	public static Object default_kernel_loops_max(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 kernel_loops_max = kernel_workload.KERNEL_LOOPS_MAX;
		return kernel_loops_max;
	}
	public static Object default_kernel_threads_min(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 kernel_threads_min = kernel_workload.KERNEL_THREADS_MIN;
		return kernel_threads_min;
	}
	public static Object default_kernel_threads_max(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 kernel_threads_max = kernel_workload.KERNEL_THREADS_MAX;
		return kernel_threads_max;
	}
	public static Object default_forced_outfile_format(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 forced_outfile_format = user_options.getOutfile_format();
		return forced_outfile_format;
	}
	public static Object default_hook_salt_size(Object hashconfig, Object user_options, Object user_options_extra) {
		u64 hook_salt_size = 0;
		return hook_salt_size;
	}
	public static Object default_hook_size(Object hashconfig, Object user_options, Object user_options_extra) {
		u64 hook_size = 4;
		return hook_size;
	}
	public static byte default_separator(Object hashconfig, Object user_options, Object user_options_extra) {
		return user_options.getSeparator();
	}
	public static boolean default_dictstat_disable(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean dictstat_disable = false;
		return dictstat_disable;
	}
	public static boolean default_warmup_disable(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean warmup_disable = false;
		return warmup_disable;
	}
	public static boolean default_outfile_check_disable(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean outfile_check_disable = false;
		return outfile_check_disable;
	}
	public static boolean default_outfile_check_nocomp(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean outfile_check_nocomp = false;
		return outfile_check_nocomp;
	}
	public static boolean default_hlfmt_disable(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean hlfmt_disable = false;
		return hlfmt_disable;
	}
	public static boolean default_potfile_keep_all_hashes(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean potfile_keep_all_hashes = false;
		// keep all hashes if --username was combined with --left or --show
		if (user_options.getUsername() == 1) {
			if ((user_options.getShow() == 1) || (user_options.getLeft() == 1)) {
				potfile_keep_all_hashes = true;
			} 
		} 
		return potfile_keep_all_hashes;
	}
	public static Object default_pwdump_column(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 pwdump_column = pwdump_column.PWDUMP_COLUMN_INVALID;
		return pwdump_column;
	}
	public static boolean default_potfile_disable(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean potfile_disable = false;
		return potfile_disable;
	}
	public static Object default_hashes_count_min(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 hashes_count_min = 1;
		return hashes_count_min;
	}
	public static Object default_hashes_count_max(Object hashconfig, Object user_options, Object user_options_extra) {
		u32 hashes_count_max = -1024;
		return hashes_count_max;
	}
	public static Object default_pw_min(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		// pw_min : algo specific hard min length
		u32 pw_min = 0;
		if (optimized_kernel == 1) {
		} 
		// unused case
		return pw_min;
	}
	public static Object default_pw_max(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		// pw_max : some algo suffer from support for long passwords,
		//          the user need to add -L to enable support for themu32 pw_max = 256;
		if (optimized_kernel == 1) {
			pw_max = 55;
			if ((hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_UTF16LE) || (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_UTF16BE)) {
				pw_max /= 2;
			} 
			if ((user_options.getRp_files_cnt() > 0) || (user_options.getRp_gen() > 0)) {
				if (user_options.getSlow_candidates() == 1) {
					pw_max = (((pw_max) < (true)) ? (pw_max) : (true));
				} else {
						switch (user_options_extra.getAttack_kern()) {
						case attack_kern.ATTACK_KERN_COMBI:
								pw_max = (((pw_max) < (true)) ? (pw_max) : (true));
								break;
						case attack_kern.ATTACK_KERN_STRAIGHT:
								pw_max = (((pw_max) < (true)) ? (pw_max) : (true));
								break;
						}
				} 
			} else {
					if (user_options.getSlow_candidates() == 1) {
						if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
							pw_max = (((pw_max) < (true)) ? (pw_max) : (true));
						} 
					} else {
							if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
								switch (user_options_extra.getAttack_kern()) {
								case attack_kern.ATTACK_KERN_STRAIGHT:
										pw_max = (((pw_max) < (true)) ? (pw_max) : (true));
										break;
								case attack_kern.ATTACK_KERN_COMBI:
										pw_max = (((pw_max) < (true)) ? (pw_max) : (true));
										break;
								}
							} 
					} 
			} 
		} 
		return pw_max;
	}
	public static Object default_salt_min(Object hashconfig, Object user_options, Object user_options_extra) {
		// salt_min : this limit is only interessting for generic hash types that support a saltu32 salt_min = 0;
		if (hashconfig.getSalt_type() == salt_type.SALT_TYPE_GENERIC) {
			if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
				salt_min *= 2;
			} 
		} 
		return salt_min;
	}
	public static Object default_salt_max(Object hashconfig, Object user_options, Object user_options_extra) {
		boolean optimized_kernel = (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL);
		// salt_max : this limit is only interessting for generic hash types that support a salt
		u32 salt_max = 256;
		if (optimized_kernel == 1) {
			salt_max = 51;
			if ((hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_UTF16LE) || (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_UTF16BE)) {
				salt_max /= 2;
			} 
		} 
		if (hashconfig.getSalt_type() == salt_type.SALT_TYPE_GENERIC) {
			if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
				salt_max *= 2;
			} 
		} 
		return salt_max;
	}
	/* CpuArch.c -- CPU specific code
	2018-02-18: Igor Pavlov : Public domain */
	public static Object CheckFlag(Object flag) {
		;
		return flag;
	}
	public static void MyCPUID(Object function, Object a, Object b, Object c, Object d) {
		;
	}
	public static Object x86cpuid_CheckAndRead() {
		if (ModernizedCProgram.CheckFlag(1 << 18) == 0 || ModernizedCProgram.CheckFlag(1 << 21) == 0) {
			return 0;
		} 
		Object generatedMaxFunc = this.getMaxFunc();
		Object generatedVendor = this.getVendor();
		ModernizedCProgram.MyCPUID(0, generatedMaxFunc, generatedVendor[0], generatedVendor[2], generatedVendor[1]);
		Object generatedVer = this.getVer();
		Object generatedB = this.getB();
		Object generatedC = this.getC();
		Object generatedD = this.getD();
		ModernizedCProgram.MyCPUID(1, generatedVer, generatedB, generatedC, generatedD);
		return 1;
	}
	public static int x86cpuid_GetFirm(Object p) {
		int i;
		for (i = 0; i <  / ; i++) {
			UInt32 v = ModernizedCProgram.kVendors[i];
			if (v[0] == p.getVendor()[0] && v[1] == p.getVendor()[1] && v[2] == p.getVendor()[2]) {
				return (int)i;
			} 
		}
		return -1;
	}
	public static Object CPU_Is_InOrder() {
		Cx86cpuid p = new Cx86cpuid();
		int firm;
		UInt32 family = new UInt32();
		UInt32 model = new UInt32();
		if (!p.x86cpuid_CheckAndRead()) {
			return 1;
		} 
		Object generatedVer = p.getVer();
		family = (((generatedVer >> 16) & -1024) | ((generatedVer >> 8) & -1024));
		model = (((generatedVer >> 12) & -1024) | ((generatedVer >> 4) & -1024));
		firm = ModernizedCProgram.x86cpuid_GetFirm(p);
		switch (firm) {
		case .CPU_FIRM_AMD:
				return (family < 5 || (family == 5 && (model < 6 || model == -1024)));
		case .CPU_FIRM_INTEL:
				return (family < 6 || (family == 6 && (model == /* In-Order Atom CPU *//* 45 nm, N4xx, D4xx, N5xx, D5xx, 230, 330 */-1024 || model == /* 45 nm, Z6xx */-1024 || model == /* 32 nm, Z2460 */-1024 || model == /* 32 nm, Z2760 */-1024 || model == /* 32 nm, N2xxx, D2xxx */-1024)));
		case .CPU_FIRM_VIA:
				return (family < 6 || (family == 6 && model < -1024));
		}
		return 1;
	}
	public static Object CPU_Sys_Is_SSE_Supported() {
		OSVERSIONINFO vi = new OSVERSIONINFO();
		vi.setDwOSVersionInfoSize();
		if (!.GetVersionExA(vi)) {
			return 0;
		} 
		return (vi.getDwMajorVersion() >= 5);
	}
	public static Object CPU_Is_Aes_Supported() {
		Cx86cpuid p = new Cx86cpuid();
		if (!ModernizedCProgram.CPU_Sys_Is_SSE_Supported()) {
			return 0;
		} 
		if (!p.x86cpuid_CheckAndRead()) {
			return 0;
		} 
		Object generatedC = p.getC();
		return (generatedC >> 25) & 1;
	}
	public static Object CPU_IsSupported_PageGB() {
		Cx86cpuid cpuid = new Cx86cpuid();
		if (!cpuid.x86cpuid_CheckAndRead()) {
			return 0;
		} 
		{ 
			UInt32[] d = new UInt32[]{0};
			ModernizedCProgram.MyCPUID(-1024, d[0], d[1], d[2], d[3]);
			if (d[0] < -1024) {
				return 0;
			} 
		}
		{ 
			UInt32[] d = new UInt32[]{0};
			ModernizedCProgram.MyCPUID(-1024, d[0], d[1], d[2], d[3]);
			return (d[3] >> 26) & 1;
		}
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int nvrtc_make_options_array_from_string(Byte string, Byte options) {
		byte saveptr = ((Object)0);
		byte next = .strtok_r(string, " ", saveptr);
		int cnt = 0;
		do {
			options[cnt] = next;
			cnt++;
		} while ((next = .strtok_r((byte)((Object)0), " ", saveptr)) != ((Object)0));
		return cnt;
	}
	public static void My_SetDefaultDllDirectories() {
		OSVERSIONINFO vi = new OSVERSIONINFO();
		vi.setDwOSVersionInfoSize();
		.GetVersionExA(vi);
		if (!.GetVersionExA(vi) || vi.getDwMajorVersion() != 6 || vi.getDwMinorVersion() != 0) {
			Func_SetDefaultDllDirectories setDllDirs = (Func_SetDefaultDllDirectories).GetProcAddress(.GetModuleHandleA("kernel32.dll"), "SetDefaultDllDirectories");
			if (setDllDirs) {
				if (.setDllDirs(-1024 | -1024)) {
					return ;
				} 
			} 
		} 
	}
	public static void LoadSecurityDlls() {
		wchar_t[] buf = new wchar_t();
		{ 
			OSVERSIONINFO vi = new OSVERSIONINFO();
			vi.setDwOSVersionInfoSize();
			if (!.GetVersionExA(vi) || vi.getDwMajorVersion() != 6 || vi.getDwMinorVersion() != 0) {
				Func_SetDefaultDllDirectories setDllDirs = (Func_SetDefaultDllDirectories).GetProcAddress(.GetModuleHandleA("kernel32.dll"), "SetDefaultDllDirectories");
				if (setDllDirs) {
					if (.setDllDirs(-1024 | -1024)) {
						return ;
					} 
				} 
			} 
		}
		{ 
			int len = .GetSystemDirectoryW(buf, 260 + 2);
			if (len == 0 || len > 260) {
				return ;
			} 
		}
		{ 
			byte dll;
			int pos = (int).lstrlenW(buf);
			if (buf[pos - 1] != (byte)'\\') {
				buf[pos++] = (byte)'\\';
			} 
			for (dll = ModernizedCProgram.g_Dlls; dll[0] != 0; ) {
				int k = 0;
				for (; ; ) {
					byte c = dll++;
					buf[pos + k] = (Byte)c;
					k++;
					if (c == 0) {
						break;
					} 
				}
				.lstrcatW(buf, L".dll");
				.LoadLibraryExW(buf, ((Object)0), 8);
			}
		}
	}
	// in honor of ighashgpu
	public static Byte status_get_rules_file(Object hashcat_ctx) {
		user_options_t user_options = hashcat_ctx.getUser_options();
		if (user_options.getRp_files_cnt() > 0) {
			byte tmp_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
			int tmp_len = 0;
			u32 i = new u32();
			for (i = 0; i < user_options.getRp_files_cnt() - 1; i++) {
				tmp_len += .snprintf(tmp_buf + tmp_len, -1024 - tmp_len, "%s, ", user_options.getRp_files()[i]);
			}
			tmp_len += .snprintf(tmp_buf + tmp_len, -1024 - tmp_len, "%s", user_options.getRp_files()[i]);
			tmp_buf[tmp_len] = 0;
			return tmp_buf;
		} 
		return ((Object)0);
	}
	public static void format_timer_display(Byte buf, Object len) {
		byte[] time_entities_s = new byte[]{"year", "day", "hour", "min", "sec"};
		byte[] time_entities_m = new byte[]{"years", "days", "hours", "mins", "secs"};
		Object generatedTm_year = this.getTm_year();
		Object generatedTm_yday = this.getTm_yday();
		Object generatedTm_hour = this.getTm_hour();
		Object generatedTm_min = this.getTm_min();
		Object generatedTm_sec = this.getTm_sec();
		if (generatedTm_year - 70) {
			byte time_entity1 = ((generatedTm_year - 70) == 1) ? time_entities_s[0] : time_entities_m[0];
			byte time_entity2 = (generatedTm_yday == 1) ? time_entities_s[1] : time_entities_m[1];
			.snprintf(buf, len, "%d %s, %d %s", generatedTm_year - 70, time_entity1, generatedTm_yday, time_entity2);
		}  else if (generatedTm_yday) {
			byte time_entity1 = (generatedTm_yday == 1) ? time_entities_s[1] : time_entities_m[1];
			byte time_entity2 = (generatedTm_hour == 1) ? time_entities_s[2] : time_entities_m[2];
			.snprintf(buf, len, "%d %s, %d %s", generatedTm_yday, time_entity1, generatedTm_hour, time_entity2);
		}  else if (generatedTm_hour) {
			byte time_entity1 = (generatedTm_hour == 1) ? time_entities_s[2] : time_entities_m[2];
			byte time_entity2 = (generatedTm_min == 1) ? time_entities_s[3] : time_entities_m[3];
			.snprintf(buf, len, "%d %s, %d %s", generatedTm_hour, time_entity1, generatedTm_min, time_entity2);
		}  else if (generatedTm_min) {
			byte time_entity1 = (generatedTm_min == 1) ? time_entities_s[3] : time_entities_m[3];
			byte time_entity2 = (generatedTm_sec == 1) ? time_entities_s[4] : time_entities_m[4];
			.snprintf(buf, len, "%d %s, %d %s", generatedTm_min, time_entity1, generatedTm_sec, time_entity2);
		} else {
				byte time_entity1 = (generatedTm_sec == 1) ? time_entities_s[4] : time_entities_m[4];
				.snprintf(buf, len, "%d %s", generatedTm_sec, time_entity1);
		} 
	}
	public static void format_speed_display(double val, Byte buf, Object len) {
		if (val <= 0) {
			buf[0] = (byte)'0';
			buf[1] = (byte)' ';
			buf[2] = 0;
			return ;
		} 
		u32 level = 0;
		while (val > 99999) {
			val /= 1000;
			level++;
		}
		if (level == /* generate output */0) {
			.snprintf(buf, len, "%.0f ", val);
		} else {
				.snprintf(buf, len, "%.1f %c", val, ModernizedCProgram.UNITS[level]);
		} 
	}
	public static void format_speed_display_1k(double val, Byte buf, Object len) {
		if (val <= 0) {
			buf[0] = (byte)'0';
			buf[1] = (byte)' ';
			buf[2] = 0;
			return ;
		} 
		u32 level = 0;
		while (val > 999) {
			val /= 1000;
			level++;
		}
		if (level == /* generate output */0) {
			.snprintf(buf, len, "%.0f ", val);
		} else {
				.snprintf(buf, len, "%.1f %c", val, ModernizedCProgram.UNITS[level]);
		} 
	}
	public static int status_get_device_info_cnt(Object hashcat_ctx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		return backend_ctx.getBackend_devices_cnt();
	}
	public static int status_get_device_info_active(Object hashcat_ctx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		return backend_ctx.getBackend_devices_active();
	}
	public static boolean status_get_skipped_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped = device_param.getSkipped();
		return generatedSkipped;
	}
	public static boolean status_get_skipped_warning_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		return generatedSkipped_warning;
	}
	public static Byte status_get_session(Object hashcat_ctx) {
		user_options_t user_options = hashcat_ctx.getUser_options();
		return .strdup(user_options.getSession());
	}
	public static Object status_get_status_string(Object hashcat_ctx) {
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		int devices_status = status_ctx.getDevices_status();
		// special case: running but checkpoint quit requested
		if (devices_status == status_rc.STATUS_RUNNING) {
			if (status_ctx.getCheckpoint_shutdown() == 1) {
				return ModernizedCProgram.ST_0012;
			} 
		} 
		switch (devices_status) {
		case status_rc.STATUS_ABORTED_CHECKPOINT:
				return ModernizedCProgram.ST_0010;
		case status_rc.STATUS_AUTOTUNE:
				return ModernizedCProgram.ST_0001;
		case status_rc.STATUS_ABORTED:
				return ModernizedCProgram.ST_0007;
		case status_rc.STATUS_BYPASS:
				return ModernizedCProgram.ST_0009;
		case status_rc.STATUS_INIT:
				return ModernizedCProgram.ST_0000;
		case status_rc.STATUS_SELFTEST:
				return ModernizedCProgram.ST_0002;
		case status_rc.STATUS_ERROR:
				return ModernizedCProgram.ST_0013;
		case status_rc.STATUS_CRACKED:
				return ModernizedCProgram.ST_0006;
		case status_rc.STATUS_RUNNING:
				return ModernizedCProgram.ST_0003;
		case status_rc.STATUS_ABORTED_RUNTIME:
				return ModernizedCProgram.ST_0011;
		case status_rc.STATUS_PAUSED:
				return ModernizedCProgram.ST_0004;
		case status_rc.STATUS_EXHAUSTED:
				return ModernizedCProgram.ST_0005;
		case status_rc.STATUS_QUIT:
				return ModernizedCProgram.ST_0008;
		}
		return ModernizedCProgram.ST_9999;
	}
	public static int status_get_status_number(Object hashcat_ctx) {
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		return status_ctx.getDevices_status();
	}
	public static Byte status_get_hash_name(Object hashcat_ctx) {
		hashconfig_t hashconfig = hashcat_ctx.getHashconfig();
		return ModernizedCProgram.hcstrdup(hashconfig.getHash_name());
	}
	public static Byte status_get_hash_target(Object hashcat_ctx) {
		hashconfig_t hashconfig = hashcat_ctx.getHashconfig();
		hashes_t hashes = hashcat_ctx.getHashes();
		module_ctx_t module_ctx = hashcat_ctx.getModule_ctx();
		if ((hashes.getDigests_cnt() == 1) || (hashes.getHashfile() == ((Object)0))) {
			if (module_ctx.getModule_hash_encode_status() != (Object)-1) {
				byte tmp_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
				int tmp_len = .UNRECOGNIZEDFUNCTIONNAME(hashconfig, hashes.getDigests_buf(), hashes.getSalts_buf(), hashes.getEsalts_buf(), hashes.getHook_salts_buf(), ((Object)0), tmp_buf, -1024);
				byte tmp_buf2 = (byte)ModernizedCProgram.hcmalloc(tmp_len + 1);
				.memcpy(tmp_buf2, tmp_buf, tmp_len);
				tmp_buf2[tmp_len] = 0;
				.free(tmp_buf);
				return tmp_buf2;
			} 
			if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_BINARY_HASHFILE) {
				return ModernizedCProgram.hcstrdup(hashes.getHashfile());
			} 
			byte tmp_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
			int tmp_len = ModernizedCProgram.hash_encode(hashcat_ctx.getHashconfig(), hashcat_ctx.getHashes(), hashcat_ctx.getModule_ctx(), tmp_buf, -1024, 0, 0);
			tmp_buf[tmp_len] = 0;
			ModernizedCProgram.compress_terminal_line_length(tmp_buf, 19, 6);
			byte tmp_buf2 = .strdup(tmp_buf);
			.free(tmp_buf);
			return tmp_buf2;
		} 
		return ModernizedCProgram.hcstrdup(hashes.getHashfile());
	}
	public static int status_get_guess_mode(Object hashcat_ctx) {
		combinator_ctx_t combinator_ctx = hashcat_ctx.getCombinator_ctx();
		user_options_t user_options = hashcat_ctx.getUser_options();
		user_options_extra_t user_options_extra = hashcat_ctx.getUser_options_extra();
		boolean has_wordlist = false;
		boolean has_rule_file = false;
		boolean has_rule_gen = false;
		boolean has_base_left = false;
		boolean has_mask_cs = false;
		if (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) {
			has_wordlist = true;
		} 
		if (user_options.getRp_files_cnt() > 0) {
			has_rule_file = true;
		} 
		if (user_options.getRp_gen() > 0) {
			has_rule_gen = true;
		} 
		if (combinator_ctx.getCombs_mode() == combinator_mode.COMBINATOR_MODE_BASE_LEFT) {
			has_base_left = true;
		} 
		if (user_options.getCustom_charset_1()) {
			has_mask_cs = true;
		} 
		if (user_options.getCustom_charset_2()) {
			has_mask_cs = true;
		} 
		if (user_options.getCustom_charset_3()) {
			has_mask_cs = true;
		} 
		if (user_options.getCustom_charset_4()) {
			has_mask_cs = true;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
			if (has_wordlist == true) {
				if (has_rule_file == true) {
					return guess_mode.GUESS_MODE_STRAIGHT_FILE_RULES_FILE;
				} 
				if (has_rule_gen == true) {
					return guess_mode.GUESS_MODE_STRAIGHT_FILE_RULES_GEN;
				} 
				return guess_mode.GUESS_MODE_STRAIGHT_FILE;
			} 
			if (has_rule_file == true) {
				return guess_mode.GUESS_MODE_STRAIGHT_STDIN_RULES_FILE;
			} 
			if (has_rule_gen == true) {
				return guess_mode.GUESS_MODE_STRAIGHT_STDIN_RULES_GEN;
			} 
			return guess_mode.GUESS_MODE_STRAIGHT_STDIN;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_COMBI) {
			if (has_base_left == true) {
				return guess_mode.GUESS_MODE_COMBINATOR_BASE_LEFT;
			} 
			return guess_mode.GUESS_MODE_COMBINATOR_BASE_RIGHT;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
			if (has_mask_cs == true) {
				return guess_mode.GUESS_MODE_MASK_CS;
			} 
			return guess_mode.GUESS_MODE_MASK;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
			if (has_mask_cs == true) {
				return guess_mode.GUESS_MODE_HYBRID1_CS;
			} 
			return guess_mode.GUESS_MODE_HYBRID1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
			if (has_mask_cs == true) {
				return guess_mode.GUESS_MODE_HYBRID2_CS;
			} 
			return guess_mode.GUESS_MODE_HYBRID2;
		} 
		return guess_mode.GUESS_MODE_NONE;
	}
	public static Byte status_get_guess_base(Object hashcat_ctx) {
		hashconfig_t hashconfig = hashcat_ctx.getHashconfig();
		user_options_t user_options = hashcat_ctx.getUser_options();
		user_options_extra_t user_options_extra = hashcat_ctx.getUser_options_extra();
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
			if (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) {
				straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
				return .strdup(straight_ctx.getDict());
			} 
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_COMBI) {
			combinator_ctx_t combinator_ctx = hashcat_ctx.getCombinator_ctx();
			if (combinator_ctx.getCombs_mode() == combinator_mode.COMBINATOR_MODE_BASE_LEFT) {
				return .strdup(combinator_ctx.getDict1());
			} 
			return .strdup(combinator_ctx.getDict2());
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
			mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
			return .strdup(mask_ctx.getMask());
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
			straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
			return .strdup(straight_ctx.getDict());
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
			if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
				mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
				return .strdup(mask_ctx.getMask());
			} 
			straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
			return .strdup(straight_ctx.getDict());
		} 
		return ((Object)0);
	}
	public static int status_get_guess_base_offset(Object hashcat_ctx) {
		hashconfig_t hashconfig = hashcat_ctx.getHashconfig();
		user_options_t user_options = hashcat_ctx.getUser_options();
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
			straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
			return straight_ctx.getDicts_pos() + 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_COMBI) {
			return 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
			mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
			return mask_ctx.getMasks_pos() + 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
			straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
			return straight_ctx.getDicts_pos() + 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
			if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
				mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
				return mask_ctx.getMasks_pos() + 1;
			} 
			straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
			return straight_ctx.getDicts_pos() + 1;
		} 
		return 0;
	}
	public static int status_get_guess_base_count(Object hashcat_ctx) {
		hashconfig_t hashconfig = hashcat_ctx.getHashconfig();
		user_options_t user_options = hashcat_ctx.getUser_options();
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
			straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
			return straight_ctx.getDicts_cnt();
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_COMBI) {
			return 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
			mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
			return mask_ctx.getMasks_cnt();
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
			straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
			return straight_ctx.getDicts_cnt();
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
			if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
				mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
				return mask_ctx.getMasks_cnt();
			} 
			straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
			return straight_ctx.getDicts_cnt();
		} 
		return 0;
	}
	public static double status_get_guess_base_percent(Object hashcat_ctx) {
		int guess_base_offset = ModernizedCProgram.status_get_guess_base_offset(hashcat_ctx);
		int guess_base_count = ModernizedCProgram.status_get_guess_base_count(hashcat_ctx);
		if (guess_base_count == 0) {
			return 0;
		} 
		return ((double)guess_base_offset / (double)guess_base_count) * 100;
	}
	public static Byte status_get_guess_mod(Object hashcat_ctx) {
		hashconfig_t hashconfig = hashcat_ctx.getHashconfig();
		user_options_t user_options = hashcat_ctx.getUser_options();
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
			return ModernizedCProgram.status_get_rules_file(hashcat_ctx);
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_COMBI) {
			combinator_ctx_t combinator_ctx = hashcat_ctx.getCombinator_ctx();
			if (combinator_ctx.getCombs_mode() == combinator_mode.COMBINATOR_MODE_BASE_LEFT) {
				return .strdup(combinator_ctx.getDict2());
			} 
			return .strdup(combinator_ctx.getDict1());
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
			mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
			return .strdup(mask_ctx.getMask());
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
			if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
				straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
				return .strdup(straight_ctx.getDict());
			} 
			mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
			return .strdup(mask_ctx.getMask());
		} 
		return ((Object)0);
	}
	public static int status_get_guess_mod_offset(Object hashcat_ctx) {
		hashconfig_t hashconfig = hashcat_ctx.getHashconfig();
		user_options_t user_options = hashcat_ctx.getUser_options();
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
			return 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_COMBI) {
			return 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
			return 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
			mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
			return mask_ctx.getMasks_pos() + 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
			if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
				straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
				return straight_ctx.getDicts_pos() + 1;
			} 
			mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
			return mask_ctx.getMasks_pos() + 1;
		} 
		return 0;
	}
	public static int status_get_guess_mod_count(Object hashcat_ctx) {
		hashconfig_t hashconfig = hashcat_ctx.getHashconfig();
		user_options_t user_options = hashcat_ctx.getUser_options();
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_STRAIGHT) {
			return 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_COMBI) {
			return 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_BF) {
			return 1;
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID1) {
			mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
			return mask_ctx.getMasks_cnt();
		} 
		if (user_options.getAttack_mode() == attack_mode.ATTACK_MODE_HYBRID2) {
			if (hashconfig.getOpti_type() & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
				straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
				return straight_ctx.getDicts_cnt();
			} 
			mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
			return mask_ctx.getMasks_cnt();
		} 
		return 0;
	}
	public static double status_get_guess_mod_percent(Object hashcat_ctx) {
		int guess_mod_offset = ModernizedCProgram.status_get_guess_mod_offset(hashcat_ctx);
		int guess_mod_count = ModernizedCProgram.status_get_guess_mod_count(hashcat_ctx);
		if (guess_mod_count == 0) {
			return 0;
		} 
		return ((double)guess_mod_offset / (double)guess_mod_count) * 100;
	}
	public static Byte status_get_guess_charset(Object hashcat_ctx) {
		user_options_t user_options = hashcat_ctx.getUser_options();
		byte custom_charset_1 = user_options.getCustom_charset_1();
		byte custom_charset_2 = user_options.getCustom_charset_2();
		byte custom_charset_3 = user_options.getCustom_charset_3();
		byte custom_charset_4 = user_options.getCustom_charset_4();
		if ((custom_charset_1 != ((Object)0)) || (custom_charset_2 != ((Object)0)) || (custom_charset_3 != ((Object)0)) || (custom_charset_4 != ((Object)0))) {
			byte tmp_buf;
			if (custom_charset_1 == ((Object)0)) {
				custom_charset_1 = "Undefined";
			} 
			if (custom_charset_2 == ((Object)0)) {
				custom_charset_2 = "Undefined";
			} 
			if (custom_charset_3 == ((Object)0)) {
				custom_charset_3 = "Undefined";
			} 
			if (custom_charset_4 == ((Object)0)) {
				custom_charset_4 = "Undefined";
			} 
			ModernizedCProgram.hc_asprintf(tmp_buf, "-1 %s, -2 %s, -3 %s, -4 %s", custom_charset_1, custom_charset_2, custom_charset_3, custom_charset_4);
			return tmp_buf;
		} 
		return ((Object)0);
	}
	public static int status_get_guess_mask_length(Object hashcat_ctx) {
		hashconfig_t hashconfig = hashcat_ctx.getHashconfig();
		mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
		if (mask_ctx == ((Object)0)) {
			return -1;
		} 
		if (mask_ctx.getMask() == ((Object)0)) {
			return -1;
		} 
		return ModernizedCProgram.mp_get_length(mask_ctx.getMask(), hashconfig.getOpts_type());
	}
	public static Byte status_get_guess_candidates_dev(Object hashcat_ctx, Object backend_devices_idx) {
		hashconfig_t hashconfig = hashcat_ctx.getHashconfig();
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		user_options_extra_t user_options_extra = hashcat_ctx.getUser_options_extra();
		if (status_ctx.getAccessible() == 0) {
			return ((Object)0);
		} 
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		byte display = (byte)ModernizedCProgram.hcmalloc(-1024);
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if ((generatedSkipped == true) || (generatedSkipped_warning == true)) {
			.snprintf(display, -1024, "[Skipped]");
			return display;
		} 
		if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_BF) {
			.snprintf(display, -1024, "[Generating]");
		} else {
				.snprintf(display, -1024, "[Copying]");
		} 
		Object generatedOuterloop_left = device_param.getOuterloop_left();
		Object generatedInnerloop_left = device_param.getInnerloop_left();
		if ((generatedOuterloop_left == 0) || (generatedInnerloop_left == 0)) {
			return display;
		} 
		u64 outerloop_first = 0;
		u64 outerloop_last = generatedOuterloop_left - 1;
		u32 innerloop_first = 0;
		u32 innerloop_last = generatedInnerloop_left - 1;
		plain_t plain1 = new plain_t(outerloop_first, innerloop_first, 0, 0, 0, 0, 0);
		plain_t plain2 = new plain_t(outerloop_last, innerloop_last, 0, 0, 0, 0, 0);
		u32[] plain_buf1 = new u32[]{0};
		u32[] plain_buf2 = new u32[]{0};
		u8 plain_ptr1 = (u8)plain_buf1;
		u8 plain_ptr2 = (u8)plain_buf2;
		int plain_len1 = 0;
		int plain_len2 = 0;
		ModernizedCProgram.build_plain((hashcat_ctx_t)hashcat_ctx, device_param, plain1, plain_buf1, plain_len1);
		ModernizedCProgram.build_plain((hashcat_ctx_t)hashcat_ctx, device_param, plain2, plain_buf2, plain_len2);
		boolean always_ascii = (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_ALWAYS_ASCII) ? 1 : 0;
		boolean need_hex1 = ModernizedCProgram.need_hexify(plain_ptr1, plain_len1, 0, always_ascii);
		boolean need_hex2 = ModernizedCProgram.need_hexify(plain_ptr2, plain_len2, 0, always_ascii);
		if ((need_hex1 == 1) || (need_hex2 == 1)) {
			ModernizedCProgram.exec_hexify(plain_ptr1, plain_len1, plain_ptr1);
			ModernizedCProgram.exec_hexify(plain_ptr2, plain_len2, plain_ptr2);
			plain_ptr1[plain_len1 * 2] = 0;
			plain_ptr2[plain_len2 * 2] = 0;
			.snprintf(display, -1024, "$HEX[%s] -> $HEX[%s]", plain_ptr1, plain_ptr2);
		} else {
				plain_ptr1[plain_len1] = 0;
				plain_ptr2[plain_len2] = 0;
				.snprintf(display, -1024, "%s -> %s", plain_ptr1, plain_ptr2);
		} 
		return display;
	}
	public static int status_get_digests_done(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		return hashes.getDigests_done();
	}
	public static int status_get_digests_cnt(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		return hashes.getDigests_cnt();
	}
	public static double status_get_digests_percent(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		if (hashes.getDigests_cnt() == 0) {
			return 0;
		} 
		return ((double)hashes.getDigests_done() / (double)hashes.getDigests_cnt()) * 100;
	}
	public static int status_get_salts_done(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		return hashes.getSalts_done();
	}
	public static int status_get_salts_cnt(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		return hashes.getSalts_cnt();
	}
	public static double status_get_salts_percent(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		if (hashes.getSalts_cnt() == 0) {
			return 0;
		} 
		return ((double)hashes.getSalts_done() / (double)hashes.getSalts_cnt()) * 100;
	}
	public static double status_get_msec_running(Object hashcat_ctx) {
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		double msec_running = ModernizedCProgram.hc_timer_get(status_ctx.getTimer_running());
		return msec_running;
	}
	public static double status_get_msec_paused(Object hashcat_ctx) {
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		double msec_paused = status_ctx.getMsec_paused();
		if (status_ctx.getDevices_status() == status_rc.STATUS_PAUSED) {
			double msec_paused_tmp = ModernizedCProgram.hc_timer_get(status_ctx.getTimer_paused());
			msec_paused += msec_paused_tmp;
		} 
		return msec_paused;
	}
	public static double status_get_msec_real(Object hashcat_ctx) {
		double msec_running = ModernizedCProgram.status_get_msec_running(hashcat_ctx);
		double msec_paused = ModernizedCProgram.status_get_msec_paused(hashcat_ctx);
		double msec_real = msec_running - msec_paused;
		return msec_real;
	}
	public static Byte status_get_time_started_absolute(Object hashcat_ctx) {
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		time_t time_start = status_ctx.getRuntime_start();
		byte[] buf = new byte[]{0};
		byte start = .ctime_r(time_start, buf);
		size_t start_len = .strlen(start);
		if (start[start_len - 1] == (byte)'\n') {
			start[start_len - 1] = 0;
		} 
		if (start[start_len - 2] == (byte)'\r') {
			start[start_len - 2] = 0;
		} 
		return .strdup(start);
	}
	public static Byte status_get_time_started_relative(Object hashcat_ctx) {
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		time_t time_now = new time_t();
		.time(time_now);
		time_t time_start = status_ctx.getRuntime_start();
		time_t sec_run = time_now - time_start;
		tm tmp = new tm();
		tm tm = new tm();
		tmp = .gmtime_r(sec_run, tm);
		byte display_run = (byte)ModernizedCProgram.hcmalloc(-1024);
		tmp.format_timer_display(display_run, -1024);
		return display_run;
	}
	public static Object status_get_sec_etc(Object hashcat_ctx) {
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		user_options_extra_t user_options_extra = hashcat_ctx.getUser_options_extra();
		time_t sec_etc = 0;
		if ((user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_FILE) || (user_options_extra.getWordlist_mode() == wl_mode.WL_MODE_MASK)) {
			if (status_ctx.getDevices_status() != status_rc.STATUS_CRACKED) {
				u64 progress_cur_relative_skip = ModernizedCProgram.status_get_progress_cur_relative_skip(hashcat_ctx);
				u64 progress_end_relative_skip = ModernizedCProgram.status_get_progress_end_relative_skip(hashcat_ctx);
				u64 progress_ignore = ModernizedCProgram.status_get_progress_ignore(hashcat_ctx);
				double hashes_msec_all = ModernizedCProgram.status_get_hashes_msec_all(hashcat_ctx);
				if (hashes_msec_all > 0) {
					u64 progress_left_relative_skip = progress_end_relative_skip - progress_cur_relative_skip;
					u64 msec_left = (u64)((progress_left_relative_skip - progress_ignore) / hashes_msec_all);
					sec_etc = msec_left / 1000;
				} 
			} 
		} 
		return sec_etc;
	}
	public static Byte status_get_time_estimated_absolute(Object hashcat_ctx) {
		time_t sec_etc = ModernizedCProgram.status_get_sec_etc(hashcat_ctx);
		time_t now = new time_t();
		.time(now);
		byte[] buf = new byte[]{0};
		byte etc;
		if (ModernizedCProgram.overflow_check_u64_add(now, sec_etc) == 0) {
			etc = (byte)ModernizedCProgram.ETA_ABSOLUTE_MAX_EXCEEDED;
		} else {
				time_t end = now + sec_etc;
				etc = .ctime_r(end, buf);
				if (etc == ((Object)0)) {
					etc = (byte)ModernizedCProgram.ETA_ABSOLUTE_MAX_EXCEEDED;
				} 
		} 
		size_t etc_len = .strlen(etc);
		if (etc[etc_len - 1] == (byte)'\n') {
			etc[etc_len - 1] = 0;
		} 
		if (etc[etc_len - 2] == (byte)'\r') {
			etc[etc_len - 2] = 0;
		} 
		return .strdup(etc);
	}
	public static Byte status_get_time_estimated_relative(Object hashcat_ctx) {
		user_options_t user_options = hashcat_ctx.getUser_options();
		byte display = (byte)ModernizedCProgram.hcmalloc(-1024);
		time_t sec_etc = ModernizedCProgram.status_get_sec_etc(hashcat_ctx);
		tm tmp = new tm();
		tm tm = new tm();
		tmp = .gmtime_r(sec_etc, tm);
		if (tmp == ((Object)0)) {
			.snprintf(display, -1024, "%s", ModernizedCProgram.ETA_RELATIVE_MAX_EXCEEDED);
		} else {
				tmp.format_timer_display(display, -1024);
		} 
		if (user_options.getRuntime() > 0) {
			int runtime_left = ModernizedCProgram.get_runtime_left(hashcat_ctx);
			byte tmp_display = .strdup(display);
			if (runtime_left > 0) {
				time_t sec_left = runtime_left;
				tm tmp_left = new tm();
				tm tm_left = new tm();
				tmp_left = .gmtime_r(sec_left, tm_left);
				byte display_left = (byte)ModernizedCProgram.hcmalloc(-1024);
				tmp_left.format_timer_display(display_left, -1024);
				.snprintf(display, -1024, "%s; Runtime limited: %s", tmp_display, display_left);
				.free(display_left);
			} else {
					.snprintf(display, -1024, "%s; Runtime limit exceeded", tmp_display);
			} 
			.free(tmp_display);
		} 
		return display;
	}
	public static Object status_get_restore_point(Object hashcat_ctx) {
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		u64 restore_point = status_ctx.getWords_cur();
		return restore_point;
	}
	public static Object status_get_restore_total(Object hashcat_ctx) {
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		u64 restore_total = status_ctx.getWords_base();
		return restore_total;
	}
	public static double status_get_restore_percent(Object hashcat_ctx) {
		double restore_percent = 0;
		u64 restore_point = ModernizedCProgram.status_get_restore_point(hashcat_ctx);
		u64 restore_total = ModernizedCProgram.status_get_restore_total(hashcat_ctx);
		if (restore_total > 0) {
			restore_percent = ((double)restore_point / (double)restore_total) * 100;
		} 
		return restore_percent;
	}
	public static int status_get_progress_mode(Object hashcat_ctx) {
		u64 progress_end_relative_skip = ModernizedCProgram.status_get_progress_end_relative_skip(hashcat_ctx);
		if (progress_end_relative_skip > 0) {
			return progress_mode.PROGRESS_MODE_KEYSPACE_KNOWN;
		} 
		return progress_mode.PROGRESS_MODE_KEYSPACE_UNKNOWN;
	}
	public static double status_get_progress_finished_percent(Object hashcat_ctx) {
		u64 progress_cur_relative_skip = ModernizedCProgram.status_get_progress_cur_relative_skip(hashcat_ctx);
		u64 progress_end_relative_skip = ModernizedCProgram.status_get_progress_end_relative_skip(hashcat_ctx);
		double progress_finished_percent = 0;
		if (progress_end_relative_skip > 0) {
			progress_finished_percent = ((double)progress_cur_relative_skip / (double)progress_end_relative_skip) * 100;
		} 
		return progress_finished_percent;
	}
	public static Object status_get_progress_done(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		u64 progress_done = 0;
		for (u32 salt_pos = 0;
		 salt_pos < hashes.getSalts_cnt(); salt_pos++) {
			progress_done += status_ctx.getWords_progress_done()[salt_pos];
		}
		return progress_done;
	}
	public static Object status_get_progress_rejected(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		u64 progress_rejected = 0;
		for (u32 salt_pos = 0;
		 salt_pos < hashes.getSalts_cnt(); salt_pos++) {
			progress_rejected += status_ctx.getWords_progress_rejected()[salt_pos];
		}
		return progress_rejected;
	}
	public static double status_get_progress_rejected_percent(Object hashcat_ctx) {
		u64 progress_cur = ModernizedCProgram.status_get_progress_cur(hashcat_ctx);
		u64 progress_rejected = ModernizedCProgram.status_get_progress_rejected(hashcat_ctx);
		double percent_rejected = 0;
		if (progress_cur) {
			percent_rejected = ((double)(progress_rejected) / (double)progress_cur) * 100;
		} 
		return percent_rejected;
	}
	public static Object status_get_progress_restored(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		u64 progress_restored = 0;
		for (u32 salt_pos = 0;
		 salt_pos < hashes.getSalts_cnt(); salt_pos++) {
			progress_restored += status_ctx.getWords_progress_restored()[salt_pos];
		}
		return progress_restored;
	}
	public static Object status_get_progress_cur(Object hashcat_ctx) {
		u64 progress_done = ModernizedCProgram.status_get_progress_done(hashcat_ctx);
		u64 progress_rejected = ModernizedCProgram.status_get_progress_rejected(hashcat_ctx);
		u64 progress_restored = ModernizedCProgram.status_get_progress_restored(hashcat_ctx);
		u64 progress_cur = progress_done + progress_rejected + progress_restored;
		return progress_cur;
	}
	public static Object status_get_progress_ignore(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		// Important for ETA only
		u64 progress_ignore = 0;
		for (u32 salt_pos = 0;
		 salt_pos < hashes.getSalts_cnt(); salt_pos++) {
			if (hashes.getSalts_shown()[salt_pos] == 1) {
				u64 all = status_ctx.getWords_progress_done()[salt_pos] + status_ctx.getWords_progress_rejected()[salt_pos] + status_ctx.getWords_progress_restored()[salt_pos];
				u64 left = status_ctx.getWords_cnt() - all;
				progress_ignore += left;
			} 
		}
		return progress_ignore;
	}
	public static Object status_get_progress_end(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		user_options_t user_options = hashcat_ctx.getUser_options();
		user_options_extra_t user_options_extra = hashcat_ctx.getUser_options_extra();
		u64 progress_end = status_ctx.getWords_cnt() * hashes.getSalts_cnt();
		if (user_options.getLimit()) {
			combinator_ctx_t combinator_ctx = hashcat_ctx.getCombinator_ctx();
			mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
			straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
			progress_end = (((user_options.getLimit()) < (status_ctx.getWords_base())) ? (user_options.getLimit()) : (status_ctx.getWords_base())) * hashes.getSalts_cnt();
			if (user_options.getSlow_candidates() == 1) {
			} else {
					if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_STRAIGHT) {
						progress_end *= straight_ctx.getKernel_rules_cnt();
					}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_COMBI) {
						progress_end *= combinator_ctx.getCombs_cnt();
					}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_BF) {
						progress_end *= mask_ctx.getBfs_cnt();
					} 
			} 
		} 
		return progress_end;
	}
	public static Object status_get_progress_skip(Object hashcat_ctx) {
		hashes_t hashes = hashcat_ctx.getHashes();
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		user_options_t user_options = hashcat_ctx.getUser_options();
		user_options_extra_t user_options_extra = hashcat_ctx.getUser_options_extra();
		u64 progress_skip = 0;
		if (user_options.getSkip()) {
			combinator_ctx_t combinator_ctx = hashcat_ctx.getCombinator_ctx();
			mask_ctx_t mask_ctx = hashcat_ctx.getMask_ctx();
			straight_ctx_t straight_ctx = hashcat_ctx.getStraight_ctx();
			progress_skip = (((user_options.getSkip()) < (status_ctx.getWords_base())) ? (user_options.getSkip()) : (status_ctx.getWords_base())) * hashes.getSalts_cnt();
			if (user_options.getSlow_candidates() == 1) {
			} else {
					if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_STRAIGHT) {
						progress_skip *= straight_ctx.getKernel_rules_cnt();
					}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_COMBI) {
						progress_skip *= combinator_ctx.getCombs_cnt();
					}  else if (user_options_extra.getAttack_kern() == attack_kern.ATTACK_KERN_BF) {
						progress_skip *= mask_ctx.getBfs_cnt();
					} 
			} 
		} 
		return progress_skip;
	}
	public static Object status_get_progress_cur_relative_skip(Object hashcat_ctx) {
		u64 progress_skip = ModernizedCProgram.status_get_progress_skip(hashcat_ctx);
		u64 progress_cur = ModernizedCProgram.status_get_progress_cur(hashcat_ctx);
		u64 progress_cur_relative_skip = 0;
		if (progress_cur > 0) {
			progress_cur_relative_skip = progress_cur - progress_skip;
		} 
		return progress_cur_relative_skip;
	}
	public static Object status_get_progress_end_relative_skip(Object hashcat_ctx) {
		u64 progress_skip = ModernizedCProgram.status_get_progress_skip(hashcat_ctx);
		u64 progress_end = ModernizedCProgram.status_get_progress_end(hashcat_ctx);
		u64 progress_end_relative_skip = 0;
		if (progress_end > 0) {
			progress_end_relative_skip = progress_end - progress_skip;
		} 
		return progress_end_relative_skip;
	}
	public static double status_get_hashes_msec_all(Object hashcat_ctx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		double hashes_all_msec = 0;
		for (int backend_devices_idx = 0;
		 backend_devices_idx < backend_ctx.getBackend_devices_cnt(); backend_devices_idx++) {
			hashes_all_msec += ModernizedCProgram.status_get_hashes_msec_dev(hashcat_ctx, backend_devices_idx);
		}
		return hashes_all_msec;
	}
	public static double status_get_hashes_msec_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		u64 speed_cnt = 0;
		double speed_msec = 0;
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedSpeed_pos = device_param.getSpeed_pos();
		Object generatedSpeed_cnt = device_param.getSpeed_cnt();
		Object generatedSpeed_msec = device_param.getSpeed_msec();
		if ((generatedSkipped == false) && (generatedSkipped_warning == false)) {
			u32 speed_pos = (((generatedSpeed_pos) > (true)) ? (generatedSpeed_pos) : (true));
			for (u32 i = 0;
			 i < speed_pos; i++) {
				speed_cnt += generatedSpeed_cnt[i];
				speed_msec += generatedSpeed_msec[i];
			}
			speed_cnt /= speed_pos;
			speed_msec /= speed_pos;
		} 
		double hashes_dev_msec = 0;
		if (speed_msec > 0) {
			hashes_dev_msec = (double)speed_cnt / speed_msec;
		} 
		return hashes_dev_msec;
	}
	public static double status_get_hashes_msec_dev_benchmark(Object hashcat_ctx, Object backend_devices_idx) {
		// this function increases accuracy for benchmark modesbackend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		u64 speed_cnt = 0;
		double speed_msec = 0;
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedSpeed_pos = device_param.getSpeed_pos();
		Object generatedSpeed_cnt = device_param.getSpeed_cnt();
		Object generatedSpeed_msec = device_param.getSpeed_msec();
		if ((generatedSkipped == false) && (generatedSkipped_warning == false)) {
			u32 speed_pos = (((generatedSpeed_pos) > (true)) ? (generatedSpeed_pos) : (true));
			speed_cnt += generatedSpeed_cnt[speed_pos - 1];
			speed_msec += generatedSpeed_msec[speed_pos - 1];
		} 
		double hashes_dev_msec = 0;
		if (speed_msec > 0) {
			hashes_dev_msec = (double)speed_cnt / speed_msec;
		} 
		return hashes_dev_msec;
	}
	public static double status_get_exec_msec_all(Object hashcat_ctx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		double exec_all_msec = 0;
		for (int backend_devices_idx = 0;
		 backend_devices_idx < backend_ctx.getBackend_devices_cnt(); backend_devices_idx++) {
			exec_all_msec += ModernizedCProgram.status_get_exec_msec_dev(hashcat_ctx, backend_devices_idx);
		}
		return exec_all_msec;
	}
	public static double status_get_exec_msec_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		double exec_dev_msec = 0;
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if ((generatedSkipped == false) && (generatedSkipped_warning == false)) {
			exec_dev_msec = device_param.get_avg_exec_time(128);
		} 
		return exec_dev_msec;
	}
	public static Byte status_get_speed_sec_all(Object hashcat_ctx) {
		double hashes_msec_all = ModernizedCProgram.status_get_hashes_msec_all(hashcat_ctx);
		byte display = (byte)ModernizedCProgram.hcmalloc(-1024);
		ModernizedCProgram.format_speed_display(hashes_msec_all * 1000, display, -1024);
		return display;
	}
	public static Byte status_get_speed_sec_dev(Object hashcat_ctx, Object backend_devices_idx) {
		double hashes_msec_dev = ModernizedCProgram.status_get_hashes_msec_dev(hashcat_ctx, backend_devices_idx);
		byte display = (byte)ModernizedCProgram.hcmalloc(-1024);
		ModernizedCProgram.format_speed_display(hashes_msec_dev * 1000, display, -1024);
		return display;
	}
	public static int status_get_cpt_cur_min(Object hashcat_ctx) {
		cpt_ctx_t cpt_ctx = hashcat_ctx.getCpt_ctx();
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		if (status_ctx.getAccessible() == 0) {
			return 0;
		} 
		time_t now = .time(((Object)0));
		int cpt_cur_min = 0;
		for (int i = 0;
		 i < -1024; i++) {
			u32 cracked = cpt_ctx.getCpt_buf()[i].getCracked();
			time_t timestamp = cpt_ctx.getCpt_buf()[i].getTimestamp();
			if ((timestamp + 60) > now) {
				cpt_cur_min += cracked;
			} 
		}
		return cpt_cur_min;
	}
	public static int status_get_cpt_cur_hour(Object hashcat_ctx) {
		cpt_ctx_t cpt_ctx = hashcat_ctx.getCpt_ctx();
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		if (status_ctx.getAccessible() == 0) {
			return 0;
		} 
		time_t now = .time(((Object)0));
		int cpt_cur_hour = 0;
		for (int i = 0;
		 i < -1024; i++) {
			u32 cracked = cpt_ctx.getCpt_buf()[i].getCracked();
			time_t timestamp = cpt_ctx.getCpt_buf()[i].getTimestamp();
			if ((timestamp + 3600) > now) {
				cpt_cur_hour += cracked;
			} 
		}
		return cpt_cur_hour;
	}
	public static int status_get_cpt_cur_day(Object hashcat_ctx) {
		cpt_ctx_t cpt_ctx = hashcat_ctx.getCpt_ctx();
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		if (status_ctx.getAccessible() == 0) {
			return 0;
		} 
		time_t now = .time(((Object)0));
		int cpt_cur_day = 0;
		for (int i = 0;
		 i < -1024; i++) {
			u32 cracked = cpt_ctx.getCpt_buf()[i].getCracked();
			time_t timestamp = cpt_ctx.getCpt_buf()[i].getTimestamp();
			if ((timestamp + 86400) > now) {
				cpt_cur_day += cracked;
			} 
		}
		return cpt_cur_day;
	}
	public static int status_get_cpt_avg_min(Object hashcat_ctx) {
		cpt_ctx_t cpt_ctx = hashcat_ctx.getCpt_ctx();
		double msec_real = ModernizedCProgram.status_get_msec_real(hashcat_ctx);
		double cpt_avg_min = (double)cpt_ctx.getCpt_total() / ((msec_real / 1000) / 60);
		return (int)cpt_avg_min;
	}
	public static int status_get_cpt_avg_hour(Object hashcat_ctx) {
		cpt_ctx_t cpt_ctx = hashcat_ctx.getCpt_ctx();
		double msec_real = ModernizedCProgram.status_get_msec_real(hashcat_ctx);
		double cpt_avg_hour = (double)cpt_ctx.getCpt_total() / ((msec_real / 1000) / 3600);
		return (int)cpt_avg_hour;
	}
	public static int status_get_cpt_avg_day(Object hashcat_ctx) {
		cpt_ctx_t cpt_ctx = hashcat_ctx.getCpt_ctx();
		double msec_real = ModernizedCProgram.status_get_msec_real(hashcat_ctx);
		double cpt_avg_day = (double)cpt_ctx.getCpt_total() / ((msec_real / 1000) / 86400);
		return (int)cpt_avg_day;
	}
	public static Byte status_get_cpt(Object hashcat_ctx) {
		cpt_ctx_t cpt_ctx = hashcat_ctx.getCpt_ctx();
		time_t now = .time(((Object)0));
		byte cpt;
		int cpt_cur_min = ModernizedCProgram.status_get_cpt_cur_min(hashcat_ctx);
		int cpt_cur_hour = ModernizedCProgram.status_get_cpt_cur_hour(hashcat_ctx);
		int cpt_cur_day = ModernizedCProgram.status_get_cpt_cur_day(hashcat_ctx);
		int cpt_avg_min = ModernizedCProgram.status_get_cpt_avg_min(hashcat_ctx);
		int cpt_avg_hour = ModernizedCProgram.status_get_cpt_avg_hour(hashcat_ctx);
		int cpt_avg_day = ModernizedCProgram.status_get_cpt_avg_day(hashcat_ctx);
		if ((cpt_ctx.getCpt_start() + 86400) < now) {
			ModernizedCProgram.hc_asprintf(cpt, "CUR:%d,%d,%d AVG:%d,%d,%d (Min,Hour,Day)", cpt_cur_min, cpt_cur_hour, cpt_cur_day, cpt_avg_min, cpt_avg_hour, cpt_avg_day);
		}  else if ((cpt_ctx.getCpt_start() + 3600) < now) {
			ModernizedCProgram.hc_asprintf(cpt, "CUR:%d,%d,N/A AVG:%d,%d,%d (Min,Hour,Day)", cpt_cur_min, cpt_cur_hour, cpt_avg_min, cpt_avg_hour, cpt_avg_day);
		}  else if ((cpt_ctx.getCpt_start() + 60) < now) {
			ModernizedCProgram.hc_asprintf(cpt, "CUR:%d,N/A,N/A AVG:%d,%d,%d (Min,Hour,Day)", cpt_cur_min, cpt_avg_min, cpt_avg_hour, cpt_avg_day);
		} else {
				ModernizedCProgram.hc_asprintf(cpt, "CUR:N/A,N/A,N/A AVG:%d,%d,%d (Min,Hour,Day)", cpt_avg_min, cpt_avg_hour, cpt_avg_day);
		} 
		return cpt;
	}
	public static int status_get_salt_pos_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		int salt_pos = 0;
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedKernel_params_buf32 = device_param.getKernel_params_buf32();
		if ((generatedSkipped == false) && (generatedSkipped_warning == false)) {
			salt_pos = (int)generatedKernel_params_buf32[27];
		} 
		return salt_pos;
	}
	public static int status_get_innerloop_pos_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		int innerloop_pos = 0;
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedInnerloop_pos = device_param.getInnerloop_pos();
		if ((generatedSkipped == false) && (generatedSkipped_warning == false)) {
			innerloop_pos = (int)generatedInnerloop_pos;
		} 
		return innerloop_pos;
	}
	public static int status_get_innerloop_left_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		int innerloop_left = 0;
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedInnerloop_left = device_param.getInnerloop_left();
		if ((generatedSkipped == false) && (generatedSkipped_warning == false)) {
			innerloop_left = (int)generatedInnerloop_left;
		} 
		return innerloop_left;
	}
	public static int status_get_iteration_pos_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		int iteration_pos = 0;
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedKernel_params_buf32 = device_param.getKernel_params_buf32();
		if ((generatedSkipped == false) && (generatedSkipped_warning == false)) {
			iteration_pos = (int)generatedKernel_params_buf32[28];
		} 
		return iteration_pos;
	}
	public static int status_get_iteration_left_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		int iteration_left = 0;
		boolean generatedSkipped = device_param.getSkipped();
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		Object generatedKernel_params_buf32 = device_param.getKernel_params_buf32();
		if ((generatedSkipped == false) && (generatedSkipped_warning == false)) {
			iteration_left = (int)generatedKernel_params_buf32[29];
		} 
		return iteration_left;
	}
	public static Byte status_get_hwmon_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		byte output_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
		.snprintf(output_buf, -1024, "N/A");
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped == true) {
			return output_buf;
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return output_buf;
		} 
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		Object generatedMux_hwmon = status_ctx.getMux_hwmon();
		.WaitForSingleObject(generatedMux_hwmon, -1024);
		int num_temperature = (hashcat_ctx_t)hashcat_ctx.hm_get_temperature_with_devices_idx(backend_devices_idx);
		int num_fanspeed = (hashcat_ctx_t)hashcat_ctx.hm_get_fanspeed_with_devices_idx(backend_devices_idx);
		int num_utilization = (hashcat_ctx_t)hashcat_ctx.hm_get_utilization_with_devices_idx(backend_devices_idx);
		int num_corespeed = (hashcat_ctx_t)hashcat_ctx.hm_get_corespeed_with_devices_idx(backend_devices_idx);
		int num_memoryspeed = (hashcat_ctx_t)hashcat_ctx.hm_get_memoryspeed_with_devices_idx(backend_devices_idx);
		int num_buslanes = (hashcat_ctx_t)hashcat_ctx.hm_get_buslanes_with_devices_idx(backend_devices_idx);
		int output_len = 0;
		if (num_temperature >= 0) {
			output_len += .snprintf(output_buf + output_len, -1024 - output_len, "Temp:%3dc ", num_temperature);
		} 
		if (num_fanspeed >= 0) {
			output_len += .snprintf(output_buf + output_len, -1024 - output_len, "Fan:%3d%% ", num_fanspeed);
		} 
		if (num_utilization >= 0) {
			output_len += .snprintf(output_buf + output_len, -1024 - output_len, "Util:%3d%% ", num_utilization);
		} 
		if (num_corespeed >= 0) {
			output_len += .snprintf(output_buf + output_len, -1024 - output_len, "Core:%4dMHz ", num_corespeed);
		} 
		if (num_memoryspeed >= 0) {
			output_len += .snprintf(output_buf + output_len, -1024 - output_len, "Mem:%4dMHz ", num_memoryspeed);
		} 
		if (num_buslanes >= 0) {
			output_len += .snprintf(output_buf + output_len, -1024 - output_len, "Bus:%d ", num_buslanes);
		} 
		if (output_len > 0) {
			output_buf[output_len - 1] = 0;
		} else {
				.snprintf(output_buf, -1024, "N/A");
		} 
		// trims the trailing space
		.ReleaseMutex(generatedMux_hwmon);
		return output_buf;
	}
	public static int status_get_corespeed_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped == true) {
			return -1;
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return -1;
		} 
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		Object generatedMux_hwmon = status_ctx.getMux_hwmon();
		.WaitForSingleObject(generatedMux_hwmon, -1024);
		int num_corespeed = (hashcat_ctx_t)hashcat_ctx.hm_get_corespeed_with_devices_idx(backend_devices_idx);
		.ReleaseMutex(generatedMux_hwmon);
		return num_corespeed;
	}
	public static int status_get_memoryspeed_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped == true) {
			return -1;
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return -1;
		} 
		status_ctx_t status_ctx = hashcat_ctx.getStatus_ctx();
		Object generatedMux_hwmon = status_ctx.getMux_hwmon();
		.WaitForSingleObject(generatedMux_hwmon, -1024);
		int num_memoryspeed = (hashcat_ctx_t)hashcat_ctx.hm_get_memoryspeed_with_devices_idx(backend_devices_idx);
		.ReleaseMutex(generatedMux_hwmon);
		return num_memoryspeed;
	}
	public static Object status_get_progress_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped == true) {
			return 0;
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return 0;
		} 
		Object generatedOuterloop_left = device_param.getOuterloop_left();
		return generatedOuterloop_left;
	}
	public static double status_get_runtime_msec_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped == true) {
			return 0;
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return 0;
		} 
		double generatedOuterloop_msec = device_param.getOuterloop_msec();
		return generatedOuterloop_msec;
	}
	public static int status_get_kernel_accel_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped == true) {
			return 0;
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return 0;
		} 
		Object generatedKernel_accel_prev = device_param.getKernel_accel_prev();
		if (generatedKernel_accel_prev) {
			return generatedKernel_accel_prev;
		} 
		Object generatedKernel_accel = device_param.getKernel_accel();
		return generatedKernel_accel;
	}
	public static int status_get_kernel_loops_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped == true) {
			return 0;
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return 0;
		} 
		Object generatedKernel_loops_prev = device_param.getKernel_loops_prev();
		if (generatedKernel_loops_prev) {
			return generatedKernel_loops_prev;
		} 
		Object generatedKernel_loops = device_param.getKernel_loops();
		return generatedKernel_loops;
	}
	public static int status_get_kernel_threads_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped == true) {
			return 0;
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return 0;
		} 
		Object generatedKernel_threads = device_param.getKernel_threads();
		return generatedKernel_threads;
	}
	public static int status_get_vector_width_dev(Object hashcat_ctx, Object backend_devices_idx) {
		backend_ctx_t backend_ctx = hashcat_ctx.getBackend_ctx();
		hc_device_param_t device_param = backend_ctx.getDevices_param()[backend_devices_idx];
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped == true) {
			return 0;
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return 0;
		} 
		int generatedVector_width = device_param.getVector_width();
		return generatedVector_width;
	}
	public static void status_status_destroy(hashcat_ctx hashcat_ctx, hashcat_status hashcat_status) {
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		if (status_ctx == ((Object)0)) {
			return ;
		} 
		if (status_ctx.getAccessible() == 0) {
			return ;
		} 
		Byte generatedHash_target = hashcat_status.getHash_target();
		ModernizedCProgram.hcfree(generatedHash_target);
		Byte generatedHash_name = hashcat_status.getHash_name();
		ModernizedCProgram.hcfree(generatedHash_name);
		Byte generatedSession = hashcat_status.getSession();
		ModernizedCProgram.hcfree(generatedSession);
		Byte generatedTime_estimated_absolute = hashcat_status.getTime_estimated_absolute();
		ModernizedCProgram.hcfree(generatedTime_estimated_absolute);
		Byte generatedTime_estimated_relative = hashcat_status.getTime_estimated_relative();
		ModernizedCProgram.hcfree(generatedTime_estimated_relative);
		Byte generatedTime_started_absolute = hashcat_status.getTime_started_absolute();
		ModernizedCProgram.hcfree(generatedTime_started_absolute);
		Byte generatedTime_started_relative = hashcat_status.getTime_started_relative();
		ModernizedCProgram.hcfree(generatedTime_started_relative);
		Byte generatedSpeed_sec_all = hashcat_status.getSpeed_sec_all();
		ModernizedCProgram.hcfree(generatedSpeed_sec_all);
		Byte generatedGuess_base = hashcat_status.getGuess_base();
		ModernizedCProgram.hcfree(generatedGuess_base);
		Byte generatedGuess_mod = hashcat_status.getGuess_mod();
		ModernizedCProgram.hcfree(generatedGuess_mod);
		Byte generatedGuess_charset = hashcat_status.getGuess_charset();
		ModernizedCProgram.hcfree(generatedGuess_charset);
		Byte generatedCpt = hashcat_status.getCpt();
		ModernizedCProgram.hcfree(generatedCpt);
		hashcat_status.setHash_target(((Object)0));
		hashcat_status.setHash_name(((Object)0));
		hashcat_status.setSession(((Object)0));
		hashcat_status.setTime_estimated_absolute(((Object)0));
		hashcat_status.setTime_estimated_relative(((Object)0));
		hashcat_status.setTime_started_absolute(((Object)0));
		hashcat_status.setTime_started_relative(((Object)0));
		hashcat_status.setSpeed_sec_all(((Object)0));
		hashcat_status.setGuess_base(((Object)0));
		hashcat_status.setGuess_mod(((Object)0));
		hashcat_status.setGuess_charset(((Object)0));
		hashcat_status.setCpt(((Object)0));
		int generatedDevice_info_cnt = hashcat_status.getDevice_info_cnt();
		Object generatedDevice_info_buf = hashcat_status.getDevice_info_buf();
		Byte generatedSpeed_sec_dev = device_info.getSpeed_sec_dev();
		Byte generatedGuess_candidates_dev = device_info.getGuess_candidates_dev();
		Byte generatedHwmon_dev = device_info.getHwmon_dev();
		for (int device_id = 0;
		 device_id < generatedDevice_info_cnt; device_id++) {
			device_info_t device_info = generatedDevice_info_buf + device_id;
			ModernizedCProgram.hcfree(generatedSpeed_sec_dev);
			ModernizedCProgram.hcfree(generatedGuess_candidates_dev);
			ModernizedCProgram.hcfree(generatedHwmon_dev);
			device_info.setSpeed_sec_dev(((Object)0));
			device_info.setGuess_candidates_dev(((Object)0));
			device_info.setHwmon_dev(((Object)0));
		}
	}
	public static void XzEncIndex_Construct() {
		this.setNumBlocks(0);
		this.setSize(0);
		this.setAllocated(0);
		this.setBlocks(((Object)0));
	}
	public static void XzEncIndex_Init() {
		this.setNumBlocks(0);
		this.setSize(0);
	}
	public static void XzEncIndex_Free(Object alloc) {
		Object generatedBlocks = this.getBlocks();
		if (generatedBlocks) {
			.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedBlocks);
			this.setBlocks(((Object)0));
		} 
		this.setNumBlocks(0);
		this.setSize(0);
		this.setAllocated(0);
	}
	public static Object XzEncIndex_ReAlloc(Object newSize, Object alloc) {
		Byte blocks = (Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, newSize);
		if (!blocks) {
			return 2;
		} 
		Object generatedSize = this.getSize();
		Object generatedBlocks = this.getBlocks();
		if (generatedSize != 0) {
			.memcpy(blocks, generatedBlocks, generatedSize);
		} 
		if (generatedBlocks) {
			.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedBlocks);
		} 
		this.setBlocks(blocks);
		this.setAllocated(newSize);
		return 0;
	}
	public static Object XzEncIndex_PreAlloc(Object numBlocks, Object unpackSize, Object totalSize, Object alloc) {
		UInt64 pos = new UInt64();
		{ 
			Byte[] buf = new Byte();
			int pos2 = ModernizedCProgram.Xz_WriteVarInt(buf, totalSize);
			pos2 += ModernizedCProgram.Xz_WriteVarInt(buf + pos2, unpackSize);
			pos = numBlocks * pos2;
		}
		Object generatedAllocated = this.getAllocated();
		Object generatedSize = this.getSize();
		if (pos <= generatedAllocated - generatedSize) {
			return 0;
		} 
		{ 
			UInt64 newSize64 = generatedSize + pos;
			size_t newSize = (size_t)newSize64;
			if (newSize != newSize64) {
				return 2;
			} 
			return p.XzEncIndex_ReAlloc(newSize, alloc);
		}
	}
	public static Object XzEncIndex_AddIndexRecord(Object unpackSize, Object totalSize, Object alloc) {
		Byte[] buf = new Byte();
		int pos = ModernizedCProgram.Xz_WriteVarInt(buf, totalSize);
		pos += ModernizedCProgram.Xz_WriteVarInt(buf + pos, unpackSize);
		Object generatedAllocated = this.getAllocated();
		Object generatedSize = this.getSize();
		if (pos > generatedAllocated - generatedSize) {
			size_t newSize = generatedAllocated * 2 + 16 * 2;
			if (newSize < generatedSize + pos) {
				return 2;
			} 
			{ 
				int __result__ = (p.XzEncIndex_ReAlloc(newSize, alloc));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		} 
		Object generatedBlocks = this.getBlocks();
		.memcpy(generatedBlocks + generatedSize, buf, pos);
		generatedSize += pos;
		Object generatedNumBlocks = this.getNumBlocks();
		generatedNumBlocks++;
		return 0;
	}
	public static void SeqCheckInStream_Init(int checkMode) {
		this.setLimit((UInt64)(Int64)-1);
		this.setProcessed(0);
		this.setRealStreamFinished(0);
		Object generatedCheck = this.getCheck();
		generatedCheck.XzCheck_Init(checkMode);
	}
	public static void SeqCheckInStream_GetDigest(Object digest) {
		Object generatedCheck = this.getCheck();
		generatedCheck.XzCheck_Final(digest);
	}
	public static Object SeqCheckInStream_Read(Object pp, Object data, Object size) {
		CSeqCheckInStream p = ((CSeqCheckInStream)((byte)(true ? (pp) : ((CSeqCheckInStream)0).getVt()) - ((size_t)((CSeqCheckInStream)0).getVt())));
		size_t size2 = size;
		SRes res = 0;
		Object generatedLimit = p.getLimit();
		Object generatedProcessed = p.getProcessed();
		if (generatedLimit != (UInt64)(Int64)-1) {
			UInt64 rem = generatedLimit - generatedProcessed;
			if (size2 > rem) {
				size2 = (size_t)rem;
			} 
		} 
		Object generatedRealStream = p.getRealStream();
		Object generatedData = p.getData();
		Object generatedCheck = p.getCheck();
		if (size2 != 0) {
			if (generatedRealStream) {
				res = .UNRECOGNIZEDFUNCTIONNAME(generatedRealStream, data, size2);
				p.setRealStreamFinished((size2 == 0) ? 1 : 0);
			} else {
					.memcpy(data, generatedData + (size_t)generatedProcessed, size2);
			} 
			generatedCheck.XzCheck_Update(data, size2);
			generatedProcessed += size2;
		} 
		size = size2;
		return res/* ---------- CSeqSizeOutStream ---------- */;
	}
	public static Object SeqSizeOutStream_Write(Object pp, Object data, Object size) {
		CSeqSizeOutStream p = ((CSeqSizeOutStream)((byte)(true ? (pp) : ((CSeqSizeOutStream)0).getVt()) - ((size_t)((CSeqSizeOutStream)0).getVt())));
		Object generatedRealStream = p.getRealStream();
		Object generatedOutBufLimit = p.getOutBufLimit();
		Object generatedProcessed = p.getProcessed();
		Object generatedOutBuf = p.getOutBuf();
		if (generatedRealStream) {
			size = .UNRECOGNIZEDFUNCTIONNAME(generatedRealStream, data, size);
		} else {
				if (size > generatedOutBufLimit - (size_t)generatedProcessed) {
					return 0;
				} 
				.memcpy(generatedOutBuf + (size_t)generatedProcessed, data, size);
		} 
		generatedProcessed += size;
		return size/* ---------- CSeqInFilter ---------- */;
	}
	public static Object SeqInFilter_Init(Object props, Object alloc) {
		Object generatedBuf = this.getBuf();
		if (!generatedBuf) {
			this.setBuf((Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, (1 << 20)));
			if (!generatedBuf) {
				return 2;
			} 
		} 
		this.setCurPos(this.setEndPos(0));
		this.setSrcWasFinished(0);
		Object generatedStateCoder = this.getStateCoder();
		{ 
			int __result__ = (generatedStateCoder.BraState_SetFromMethod(props.getId(), 1, alloc));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		{ 
			int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(generatedStateCoder.getP(), props.getProps(), props.getPropsSize(), alloc));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		.UNRECOGNIZEDFUNCTIONNAME(generatedStateCoder.getP());
		return 0;
	}
	public static Object SeqInFilter_Read(Object pp, Object data, Object size) {
		CSeqInFilter p = ((CSeqInFilter)((byte)(true ? (pp) : ((CSeqInFilter)0).getP()) - ((size_t)((CSeqInFilter)0).getP())));
		size_t sizeOriginal = size;
		if (sizeOriginal == 0) {
			return 0;
		} 
		size = 0;
		Object generatedSrcWasFinished = p.getSrcWasFinished();
		Object generatedCurPos = p.getCurPos();
		Object generatedEndPos = p.getEndPos();
		Object generatedRealStream = p.getRealStream();
		Object generatedBuf = p.getBuf();
		Object generatedStateCoder = p.getStateCoder();
		for (; ; ) {
			if (!generatedSrcWasFinished && generatedCurPos == generatedEndPos) {
				p.setCurPos(0);
				p.setEndPos((1 << 20));
				{ 
					int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(generatedRealStream, generatedBuf, generatedEndPos));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (generatedEndPos == 0) {
					p.setSrcWasFinished(1);
				} 
			} 
			{ 
				SizeT srcLen = generatedEndPos - generatedCurPos;
				ECoderStatus status = new ECoderStatus();
				SRes res = new SRes();
				size = sizeOriginal;
				res = .UNRECOGNIZEDFUNCTIONNAME(generatedStateCoder.getP(), (Byte)data, size, generatedBuf + generatedCurPos, srcLen, generatedSrcWasFinished, .CODER_FINISH_ANY, status);
				generatedCurPos += srcLen;
				if (size != 0 || srcLen == 0 || res != 0) {
					return res;
				} 
			}
		}
	}
	public static void SeqInFilter_Construct() {
		this.setBuf(((Object)0));
		Object generatedStateCoder = this.getStateCoder();
		generatedStateCoder.setP(((Object)0));
		Object generatedP = this.getP();
		generatedP.setRead(SeqInFilter_Read);
	}
	public static void SeqInFilter_Free(Object alloc) {
		Object generatedStateCoder = this.getStateCoder();
		if (generatedStateCoder.getP()) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedStateCoder.getP(), alloc);
			generatedStateCoder.setP(((Object)0));
		} 
		Object generatedBuf = this.getBuf();
		if (generatedBuf) {
			.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedBuf);
			this.setBuf(((Object)0/* ---------- CSbEncInStream ---------- */));
		} 
	}
	/* ---------- CXzProps ---------- */
	public static void XzFilterProps_Init() {
		this.setId(0);
		this.setDelta(0);
		this.setIp(0);
		this.setIpDefined(0);
	}
	public static void XzProps_Init() {
		this.setCheckId(1);
		this.setBlockSize(0);
		this.setNumBlockThreads_Reduced(-1);
		this.setNumBlockThreads_Max(-1);
		this.setNumTotalThreads(-1);
		this.setReduceSize((UInt64)(Int64)-1);
		this.setForceWriteSizesInHeader(0)// p->forceWriteSizesInHeader = 1;;// p->forceWriteSizesInHeader = 1;
		Object generatedFilterProps = this.getFilterProps();
		generatedFilterProps.XzFilterProps_Init();
		Object generatedLzma2Props = this.getLzma2Props();
		generatedLzma2Props.Lzma2EncProps_Init();
	}
	public static void XzEncProps_Normalize_Fixed() {
		UInt64 fileSize = new UInt64();
		int t1;
		int t1n;
		int t2;
		int t2r;
		int t3;
		Object generatedLzma2Props = this.getLzma2Props();
		Object generatedNumTotalThreads = tp.getNumTotalThreads();
		{ 
			CLzma2EncProps tp = generatedLzma2Props;
			if (generatedNumTotalThreads <= 0) {
				tp.setNumTotalThreads(generatedNumTotalThreads);
			} 
			tp.Lzma2EncProps_Normalize();
			t1n = generatedNumTotalThreads;
		}
		t1 = generatedNumTotalThreads;
		Object generatedNumBlockThreads_Max = this.getNumBlockThreads_Max();
		t2 = generatedNumBlockThreads_Max;
		t3 = generatedNumTotalThreads;
		if (t2 > 64) {
			t2 = 64;
		} 
		if (t3 <= 0) {
			if (t2 <= 0) {
				t2 = 1;
			} 
			t3 = t1n * t2;
		}  else if (t2 <= 0) {
			t2 = t3 / t1n;
			if (t2 == 0) {
				t1 = 1;
				t2 = t3;
			} 
			if (t2 > 64) {
				t2 = 64;
			} 
		}  else if (t1 <= 0) {
			t1 = t3 / t2;
			if (t1 == 0) {
				t1 = 1;
			} 
		} else {
				t3 = t1n * t2;
		} 
		generatedLzma2Props.setNumTotalThreads(t1);
		t2r = t2;
		Object generatedReduceSize = this.getReduceSize();
		fileSize = generatedReduceSize;
		Object generatedBlockSize = this.getBlockSize();
		if ((generatedBlockSize < fileSize || fileSize == (UInt64)(Int64)-1)) {
			generatedLzma2Props.getLzmaProps().setReduceSize(generatedBlockSize);
		} 
		generatedLzma2Props.Lzma2EncProps_Normalize();
		t1 = generatedNumTotalThreads;
		{ 
			if (t2 > 1 && fileSize != (UInt64)(Int64)-1) {
				UInt64 numBlocks = fileSize / generatedBlockSize;
				if (numBlocks * generatedBlockSize != fileSize) {
					numBlocks++;
				} 
				if (numBlocks < (int)t2) {
					t2r = (int)numBlocks;
					if (t2r == 0) {
						t2r = 1;
					} 
					t3 = t1 * t2r;
				} 
			} 
		}
		this.setNumBlockThreads_Max(t2);
		this.setNumBlockThreads_Reduced(t2r);
		this.setNumTotalThreads(t3);
	}
	public static void XzProps_Normalize() {
		Object generatedBlockSize = this.getBlockSize();
		Object generatedReduceSize = this.getReduceSize();
		Object generatedLzma2Props = this.getLzma2Props();
		Object generatedNumTotalThreads = this.getNumTotalThreads();
		Object generatedNumBlockThreads_Reduced = tp.getNumBlockThreads_Reduced();
		Object generatedNumBlockThreads_Max = tp.getNumBlockThreads_Max();
		Object generatedLzmaProps = lzma2.getLzmaProps();
		if (generatedBlockSize == ((UInt64)(Int64)-1)) {
			generatedLzma2Props.getLzmaProps().setReduceSize(generatedReduceSize);
			this.setNumBlockThreads_Reduced(1);
			this.setNumBlockThreads_Max(1);
			if (generatedLzma2Props.getNumTotalThreads() <= 0) {
				generatedLzma2Props.setNumTotalThreads(generatedNumTotalThreads);
			} 
			return ;
		} else {
				CLzma2EncProps lzma2 = generatedLzma2Props;
				if (generatedBlockSize == 0) {
					generatedLzma2Props.getLzmaProps().setReduceSize(generatedReduceSize);
					if (generatedBlockSize == ((UInt64)(Int64)-1)) {
						this.setBlockSize(((UInt64)(Int64)-1));
						this.setNumBlockThreads_Reduced(1);
						this.setNumBlockThreads_Max(1);
						if (generatedNumTotalThreads <= 0) {
							generatedLzma2Props.setNumTotalThreads(generatedNumTotalThreads);
						} 
					} else {
							CLzma2EncProps tp = generatedLzma2Props;
							if (generatedNumTotalThreads <= 0) {
								tp.setNumTotalThreads(generatedNumTotalThreads);
							} 
							tp.Lzma2EncProps_Normalize();
							this.setBlockSize(generatedBlockSize);
							this.setNumBlockThreads_Reduced(generatedNumBlockThreads_Reduced);
							this.setNumBlockThreads_Max(generatedNumBlockThreads_Max);
							if (generatedBlockSize == 0) {
								lzma2.setBlockSize(generatedBlockSize);
							} 
							if (generatedReduceSize > generatedBlockSize && generatedBlockSize != ((UInt64)(Int64)-1)) {
								generatedLzmaProps.setReduceSize(generatedBlockSize);
							} 
							lzma2.setNumBlockThreads_Reduced(1);
							lzma2.setNumBlockThreads_Max(1);
							return ;
					} 
				} else {
						generatedLzmaProps.setReduceSize(generatedReduceSize);
						{ 
							UInt64 r = generatedReduceSize;
							if (r > generatedBlockSize || r == (UInt64)(Int64)-1) {
								r = generatedBlockSize;
							} 
							generatedLzmaProps.setReduceSize(r);
						}
						if (generatedBlockSize == 0) {
							lzma2.setBlockSize(((UInt64)(Int64)-1));
						}  else if (generatedBlockSize > generatedBlockSize && generatedBlockSize != ((UInt64)(Int64)-1)) {
							lzma2.setBlockSize(generatedBlockSize);
						} 
						p.XzEncProps_Normalize_Fixed();
				} 
		} 
	}
	/* we normalize xzProps properties, but we normalize only some of CXzProps::lzma2Props properties.
	     Lzma2Enc_SetProps() will normalize lzma2Props later. */
	public static void Lzma2WithFilters_Construct() {
		this.setLzma2(((Object)0));
		Object generatedFilter = this.getFilter();
		generatedFilter.SeqInFilter_Construct();
	}
	public static Object Lzma2WithFilters_Create(Object alloc, Object bigAlloc) {
		Object generatedLzma2 = this.getLzma2();
		if (!generatedLzma2) {
			this.setLzma2(ModernizedCProgram.Lzma2Enc_Create(alloc, bigAlloc));
			if (!generatedLzma2) {
				return 2;
			} 
		} 
		return 0;
	}
	public static void Lzma2WithFilters_Free(Object alloc) {
		Object generatedFilter = this.getFilter();
		generatedFilter.SeqInFilter_Free(alloc);
		Object generatedLzma2 = this.getLzma2();
		if (generatedLzma2) {
			ModernizedCProgram.Lzma2Enc_Destroy(generatedLzma2);
			this.setLzma2(((Object)0));
		} 
	}
	public static Object Xz_CompressBlock( lzmaf, ISeqOutStream outStream, Object outBufHeader, Object outBufData, Object outBufDataLimit, ISeqInStream inStream, Object inBuf, Object inBufSize, Object props, ICompressProgress progress, int inStreamFinished,  blockSizes, Object alloc, Object allocBig) {
		/* only for inStream version */CSeqCheckInStream checkInStream = new CSeqCheckInStream();
		CSeqSizeOutStream seqSizeOutStream = new CSeqSizeOutStream();
		CXzBlock block = new CXzBlock();
		int filterIndex = 0;
		CXzFilter filter = ((Object)0);
		CXzFilterProps fp = props.getFilterProps();
		if (fp.getId() == 0) {
			fp = ((Object)0);
		} 
		inStreamFinished = 0;
		{ 
			int __result__ = (lzmaf.Lzma2WithFilters_Create(alloc, allocBig));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedLzma2 = lzmaf.getLzma2();
		{ 
			int __result__ = (ModernizedCProgram.Lzma2Enc_SetProps(generatedLzma2, props.getLzma2Props()));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		(block).setFlags(0);
		;
		Object generatedFlags = (block).getFlags();
		generatedFlags |=  ((1 + (fp ? 1 : 0)) - 1);
		;
		Object generatedFilters = block.getFilters();
		Object generatedProps = filter.getProps();
		if (fp) {
			filter = generatedFilters[filterIndex++];
			filter.setId(fp.getId());
			filter.setPropsSize(0);
			if (fp.getId() == 3) {
				generatedProps[0] = (Byte)(fp.getDelta() - 1);
				filter.setPropsSize(1);
			}  else if (fp.getIpDefined()) {
				{ 
					(UInt32)(generatedProps) = (fp.getIp());
				}
				;
				filter.setPropsSize(4);
			} 
		} 
		{ 
			CXzFilter f = generatedFilters[filterIndex++];
			f.setId(-1024);
			f.setPropsSize(1);
			generatedProps[0] = ModernizedCProgram.Lzma2Enc_WriteProperties(generatedLzma2);
		}
		Object generatedVt = seqSizeOutStream.getVt();
		generatedVt.setWrite(SeqSizeOutStream_Write);
		seqSizeOutStream.setRealStream(outStream);
		seqSizeOutStream.setOutBuf(outBufData);
		seqSizeOutStream.setOutBufLimit(outBufDataLimit);
		seqSizeOutStream.setProcessed(0/*
		  if (expectedSize != (UInt64)(Int64)-1)
		  {
		    block.unpackSize = expectedSize;
		    if (props->blockSize != (UInt64)(Int64)-1)
		      if (expectedSize > props->blockSize)
		        block.unpackSize = props->blockSize;
		    XzBlock_SetHasUnpackSize(&block);
		  }
		  */);
		if (outStream) {
			{ 
				int __result__ = (generatedVt.XzBlock_WriteHeader(block));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		} 
		generatedVt.setRead(SeqCheckInStream_Read);
		checkInStream.SeqCheckInStream_Init(props.getCheckId());
		checkInStream.setRealStream(inStream);
		checkInStream.setData(inBuf);
		checkInStream.setLimit(props.getBlockSize());
		if (!inStream) {
			checkInStream.setLimit(inBufSize);
		} 
		Object generatedFilter = lzmaf.getFilter();
		if (fp) {
			{ 
				generatedFilter.setRealStream(generatedVt);
				{ 
					int __result__ = (generatedFilter.SeqInFilter_Init(filter, alloc));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
			}
		} 
		Object generatedCheck = checkInStream.getCheck();
		Object generatedOutBuf = seqSizeOutStream.getOutBuf();
		Object generatedOutBufLimit = seqSizeOutStream.getOutBufLimit();
		Object generatedProcessed = seqSizeOutStream.getProcessed();
		{ 
			SRes res = new SRes();
			Byte outBuf = ((Object)0);
			size_t outSize = 0;
			BoolInt useStream = (fp || inStream);
			if (!useStream) {
				generatedCheck.XzCheck_Update(inBuf, inBufSize);
				checkInStream.setProcessed(inBufSize);
			} 
			if (!outStream) {
				outBuf = generatedOutBuf;
				outSize = generatedOutBufLimit;
			} 
			res = ModernizedCProgram.Lzma2Enc_Encode2(generatedLzma2, outBuf ? ((Object)0) : generatedVt, outBuf, outBuf ? outSize : ((Object)0), useStream ? (fp ? (generatedFilter.getP()) : generatedVt) : ((Object)0), useStream ? ((Object)0) : inBuf, useStream ? 0 : inBufSize, progress);
			if (outBuf) {
				generatedProcessed += outSize;
			} 
			{ 
				int __result__ = (res);
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			blockSizes.setUnpackSize(generatedProcessed);
		}
		Object generatedUnpackSize = blockSizes.getUnpackSize();
		Object generatedTotalSize = blockSizes.getTotalSize();
		{ 
			Byte[] buf = new Byte();
			int padSize = ((4 - ((int)(generatedProcessed) & 3)) & 3);
			UInt64 packSize = generatedProcessed;
			buf[0] = 0;
			buf[1] = 0;
			buf[2] = 0;
			buf[3] = 0;
			checkInStream.SeqCheckInStream_GetDigest(buf + 4);
			{ 
				int __result__ = (generatedVt.WriteBytes(buf + (4 - padSize), padSize + ModernizedCProgram.XzFlags_GetCheckSize((CXzStreamFlags)props.getCheckId())));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			blockSizes.setTotalSize(generatedProcessed - padSize);
			if (!outStream) {
				seqSizeOutStream.setOutBuf(outBufHeader);
				seqSizeOutStream.setOutBufLimit(1024);
				seqSizeOutStream.setProcessed(0);
				block.setUnpackSize(generatedUnpackSize);
				generatedFlags |=  (1 << 7);
				;
				block.setPackSize(packSize);
				generatedFlags |=  (1 << 6);
				;
				{ 
					int __result__ = (generatedVt.XzBlock_WriteHeader(block));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				blockSizes.setHeaderSize((size_t)generatedProcessed);
				generatedTotalSize += generatedProcessed;
			} 
		}
		Object generatedRealStreamFinished = checkInStream.getRealStreamFinished();
		if (inStream) {
			inStreamFinished = generatedRealStreamFinished;
		} else {
				inStreamFinished = 0;
				if (generatedProcessed != inBufSize) {
					return 11;
				} 
		} 
		return 0;
	}
	// UInt64 expectedSize,
	// used if (!inStream)
	// used if (!inStream), it's block size, props->blockSize is ignored
	public static Object CompressProgress_XzEncOffset_Progress(Object pp, Object inSize, Object outSize) {
		CCompressProgress_XzEncOffset p = ((CCompressProgress_XzEncOffset)((byte)(true ? (pp) : ((CCompressProgress_XzEncOffset)0).getVt()) - ((size_t)((CCompressProgress_XzEncOffset)0).getVt())));
		inSize += p.getInOffset();
		outSize += p.getOutOffset();
		return .UNRECOGNIZEDFUNCTIONNAME(p.getProgress(), inSize, outSize);
	}
	public static void XzEnc_Construct() {
		int i;
		Object generatedXzIndex = this.getXzIndex();
		generatedXzIndex.XzEncIndex_Construct();
		Object generatedLzmaf_Items = this.getLzmaf_Items();
		for (i = 0; i < 64; i++) {
			generatedLzmaf_Items[i].Lzma2WithFilters_Construct();
		}
		this.setMtCoder_WasConstructed(0);
		Object generatedOutBufs = this.getOutBufs();
		{ 
			for (i = 0; i < (((true) + (true) / 8 + 1) + 3); i++) {
				generatedOutBufs[i] = ((Object)0);
			}
			this.setOutBufSize(0);
		}
	}
	public static void XzEnc_FreeOutBufs() {
		int i;
		Object generatedOutBufs = this.getOutBufs();
		Object generatedAlloc = this.getAlloc();
		for (i = 0; i < (((true) + (true) / 8 + 1) + 3); i++) {
			if (generatedOutBufs[i]) {
				.UNRECOGNIZEDFUNCTIONNAME(generatedAlloc, generatedOutBufs[i]);
				generatedOutBufs[i] = ((Object)0);
			} 
		}
		this.setOutBufSize(0);
	}
	public static void XzEnc_Free(Object alloc) {
		int i;
		Object generatedXzIndex = this.getXzIndex();
		generatedXzIndex.XzEncIndex_Free(alloc);
		Object generatedLzmaf_Items = this.getLzmaf_Items();
		for (i = 0; i < 64; i++) {
			generatedLzmaf_Items[i].Lzma2WithFilters_Free(alloc);
		}
		Object generatedMtCoder_WasConstructed = this.getMtCoder_WasConstructed();
		Object generatedMtCoder = this.getMtCoder();
		if (generatedMtCoder_WasConstructed) {
			generatedMtCoder.MtCoder_Destruct();
			this.setMtCoder_WasConstructed(0);
		} 
		p.XzEnc_FreeOutBufs();
	}
	public static Object XzEnc_Create(Object alloc, Object allocBig) {
		CXzEnc p = (CXzEnc).UNRECOGNIZEDFUNCTIONNAME(alloc, );
		if (!p) {
			return ((Object)0);
		} 
		p.XzEnc_Construct();
		Object generatedXzProps = p.getXzProps();
		generatedXzProps.XzProps_Init();
		generatedXzProps.XzProps_Normalize();
		p.setExpectedDataSize((UInt64)(Int64)-1);
		p.setAlloc(alloc);
		p.setAllocBig(allocBig);
		return p;
	}
	public static void XzEnc_Destroy(Object pp) {
		CXzEnc p = (CXzEnc)pp;
		Object generatedAlloc = p.getAlloc();
		p.XzEnc_Free(generatedAlloc);
		.UNRECOGNIZEDFUNCTIONNAME(generatedAlloc, p);
	}
	public static Object XzEnc_SetProps(Object pp, Object props) {
		CXzEnc p = (CXzEnc)pp;
		p.setXzProps(props);
		Object generatedXzProps = p.getXzProps();
		generatedXzProps.XzProps_Normalize();
		return 0;
	}
	public static void XzEnc_SetDataSize(Object pp, Object expectedDataSiize) {
		CXzEnc p = (CXzEnc)pp;
		p.setExpectedDataSize(expectedDataSiize);
	}
	public static Object XzEnc_MtCallback_Code(Object pp, int coderIndex, int outBufIndex, Object src, Object srcSize, int finished) {
		CXzEnc me = (CXzEnc)pp;
		SRes res = new SRes();
		CMtProgressThunk progressThunk = new CMtProgressThunk();
		Object generatedOutBufs = me.getOutBufs();
		Byte dest = generatedOutBufs[outBufIndex];
		(Object)finished;
		Object generatedEncBlocks = me.getEncBlocks();
		{ 
			CXzEncBlockInfo bInfo = generatedEncBlocks[outBufIndex];
			bInfo.setTotalSize(0);
			bInfo.setUnpackSize(0);
			bInfo.setHeaderSize(0);
		}
		Object generatedAlloc = me.getAlloc();
		Object generatedOutBufSize = me.getOutBufSize();
		if (!dest) {
			dest = (Byte).UNRECOGNIZEDFUNCTIONNAME(generatedAlloc, generatedOutBufSize);
			if (!dest) {
				return 2;
			} 
			generatedOutBufs[outBufIndex] = dest;
		} 
		progressThunk.MtProgressThunk_CreateVTable();
		Object generatedMtCoder = me.getMtCoder();
		progressThunk.setMtProgress(generatedMtCoder.getMtProgress());
		{ 
			(progressThunk).setInSize(0);
			(progressThunk).setOutSize(0);
		}
		;
		Object generatedLzmaf_Items = me.getLzmaf_Items();
		Object generatedXzProps = me.getXzProps();
		Object generatedVt = progressThunk.getVt();
		Object generatedAllocBig = me.getAllocBig();
		{ 
			CXzEncBlockInfo blockSizes = new CXzEncBlockInfo();
			int inStreamFinished;
			res = ModernizedCProgram.Xz_CompressBlock(generatedLzmaf_Items[coderIndex], ((Object)0), dest, dest + 1024, generatedOutBufSize - 1024, ((Object)0), src, srcSize, generatedXzProps, generatedVt, inStreamFinished, blockSizes, generatedAlloc, generatedAllocBig);
			if (res == 0) {
				generatedEncBlocks[outBufIndex] = blockSizes;
			} 
			return res;
		}
	}
	public static Object XzEnc_MtCallback_Write(Object pp, int outBufIndex) {
		CXzEnc me = (CXzEnc)pp;
		Object generatedEncBlocks = me.getEncBlocks();
		CXzEncBlockInfo bInfo = generatedEncBlocks[outBufIndex];
		Object generatedOutBufs = me.getOutBufs();
		Byte data = generatedOutBufs[outBufIndex];
		Object generatedOutStream = me.getOutStream();
		{ 
			int __result__ = (generatedOutStream.WriteBytes(data, bInfo.getHeaderSize()));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		{ 
			UInt64 totalPackFull = bInfo.getTotalSize() + ((4 - ((int)(bInfo.getTotalSize()) & 3)) & 3);
			{ 
				int __result__ = (generatedOutStream.WriteBytes(data + 1024, (size_t)totalPackFull - bInfo.getHeaderSize()));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		}
		Object generatedXzIndex = me.getXzIndex();
		Object generatedAlloc = me.getAlloc();
		return generatedXzIndex.XzEncIndex_AddIndexRecord(bInfo.getUnpackSize(), bInfo.getTotalSize(), generatedAlloc);
	}
	public static Object XzEnc_Encode(Object pp, ISeqOutStream outStream, ISeqInStream inStream, ICompressProgress progress) {
		CXzEnc p = (CXzEnc)pp;
		Object generatedXzProps = p.getXzProps();
		CXzProps props = generatedXzProps;
		Object generatedXzIndex = p.getXzIndex();
		generatedXzIndex.XzEncIndex_Init();
		Object generatedAlloc = p.getAlloc();
		{ 
			UInt64 numBlocks = 1;
			UInt64 blockSize = props.getBlockSize();
			if (blockSize != ((UInt64)(Int64)-1) && props.getReduceSize() != (UInt64)(Int64)-1) {
				numBlocks = props.getReduceSize() / blockSize;
				if (numBlocks * blockSize != props.getReduceSize()) {
					numBlocks++;
				} 
			} else {
					blockSize = (UInt64)1 << 62;
			} 
			{ 
				int __result__ = (generatedXzIndex.XzEncIndex_PreAlloc(numBlocks, blockSize, (1024 + ((blockSize) + ((blockSize) >> 10) + 16 + 64)), generatedAlloc));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		}
		{ 
			int __result__ = (outStream.Xz_WriteHeader((CXzStreamFlags)props.getCheckId()));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedMtCoder_WasConstructed = p.getMtCoder_WasConstructed();
		Object generatedMtCoder = p.getMtCoder();
		Object generatedAllocBig = p.getAllocBig();
		Object generatedOutBufSize = p.getOutBufSize();
		Object generatedExpectedDataSize = p.getExpectedDataSize();
		Object generatedVt = progress2.getVt();
		Object generatedOutBufs = p.getOutBufs();
		Object generatedLzmaf_Items = p.getLzmaf_Items();
		Object generatedTotalSize = blockSizes.getTotalSize();
		Object generatedHeaderSize = blockSizes.getHeaderSize();
		Object generatedUnpackSize = blockSizes.getUnpackSize();
		Object generatedInOffset = progress2.getInOffset();
		Object generatedOutOffset = progress2.getOutOffset();
		if (props.getNumBlockThreads_Reduced() > 1) {
			IMtCoderCallback2 vt = new IMtCoderCallback2();
			if (!generatedMtCoder_WasConstructed) {
				p.setMtCoder_WasConstructed(1);
				generatedMtCoder.MtCoder_Construct();
			} 
			vt.setCode(XzEnc_MtCallback_Code);
			vt.setWrite(XzEnc_MtCallback_Write);
			p.setCheckType(props.getCheckId());
			p.setXzProps(props);
			p.setOutStream(outStream);
			generatedMtCoder.setAllocBig(generatedAllocBig);
			generatedMtCoder.setProgress(progress);
			generatedMtCoder.setInStream(inStream);
			generatedMtCoder.setInData(((Object)0));
			generatedMtCoder.setInDataSize(0);
			generatedMtCoder.setMtCallback(vt);
			generatedMtCoder.setMtCallbackObject(p);
			if (props.getBlockSize() == ((UInt64)(Int64)-1) || props.getBlockSize() == 0) {
				return 11;
			} 
			generatedMtCoder.setBlockSize((size_t)props.getBlockSize());
			if (generatedMtCoder.getBlockSize() != props.getBlockSize()) {
				return /* SZ_ERROR_MEM */5;
			} 
			{ 
				size_t destBlockSize = 1024 + ((generatedMtCoder.getBlockSize()) + ((generatedMtCoder.getBlockSize()) >> 10) + 16 + 64);
				if (destBlockSize < generatedMtCoder.getBlockSize()) {
					return 5;
				} 
				if (generatedOutBufSize != destBlockSize) {
					p.XzEnc_FreeOutBufs();
				} 
				p.setOutBufSize(destBlockSize);
			}
			generatedMtCoder.setNumThreadsMax(props.getNumBlockThreads_Max());
			generatedMtCoder.setExpectedDataSize(generatedExpectedDataSize);
			{ 
				int __result__ = (generatedMtCoder.MtCoder_Code());
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		} else {
				int writeStartSizes;
				CCompressProgress_XzEncOffset progress2 = new CCompressProgress_XzEncOffset();
				Byte bufData = ((Object)0);
				size_t bufSize = 0;
				generatedVt.setProgress(CompressProgress_XzEncOffset_Progress);
				progress2.setInOffset(0);
				progress2.setOutOffset(0);
				progress2.setProgress(progress);
				writeStartSizes = 0;
				if (props.getBlockSize() != ((UInt64)(Int64)-1)) {
					writeStartSizes = (props.getForceWriteSizesInHeader() > 0);
					if (writeStartSizes) {
						size_t t2 = new size_t();
						size_t t = (size_t)props.getBlockSize();
						if (t != props.getBlockSize()) {
							return 5;
						} 
						t = ((t) + ((t) >> 10) + 16 + 64);
						if (t < props.getBlockSize()) {
							return 5;
						} 
						t2 = 1024 + t;
						if (!generatedOutBufs[0] || t2 != generatedOutBufSize) {
							p.XzEnc_FreeOutBufs();
							generatedOutBufs[0] = (Byte).UNRECOGNIZEDFUNCTIONNAME(generatedAlloc, t2);
							if (!generatedOutBufs[0]) {
								return 2;
							} 
							p.setOutBufSize(t2);
						} 
						bufData = generatedOutBufs[0] + 1024;
						bufSize = t;
					} 
				} 
				for (; ; ) {
					CXzEncBlockInfo blockSizes = new CXzEncBlockInfo();
					int inStreamFinished;
					blockSizes.setHeaderSize(0);
					{ 
						int __result__ = (ModernizedCProgram.Xz_CompressBlock(generatedLzmaf_Items[0], writeStartSizes ? ((Object)0) : outStream, writeStartSizes ? generatedOutBufs[0] : ((Object)0), bufData, bufSize, inStream, ((Object)0), 0, props, progress ? generatedVt : ((Object)0), inStreamFinished, blockSizes, generatedAlloc, generatedAllocBig));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
					{ 
						UInt64 totalPackFull = generatedTotalSize + ((4 - ((int)(generatedTotalSize) & 3)) & 3);
						if (writeStartSizes) {
							{ 
								int __result__ = (outStream.WriteBytes(generatedOutBufs[0], generatedHeaderSize));
								if (__result__ != 0) {
									return __result__;
								} 
							}
							;
							{ 
								int __result__ = (outStream.WriteBytes(bufData, (size_t)totalPackFull - generatedHeaderSize));
								if (__result__ != 0) {
									return __result__;
								} 
							}
							;
						} 
						{ 
							int __result__ = (generatedXzIndex.XzEncIndex_AddIndexRecord(generatedUnpackSize, generatedTotalSize, generatedAlloc));
							if (__result__ != 0) {
								return __result__;
							} 
						}
						;
						generatedInOffset += generatedUnpackSize;
						generatedOutOffset += totalPackFull;
					}
					if (inStreamFinished) {
						break;
					} 
				}
		} 
		return outStream.XzEncIndex_WriteFooter(generatedXzIndex, (CXzStreamFlags)props.getCheckId());
	}
	public static Object Xz_Encode(ISeqOutStream outStream, ISeqInStream inStream, Object props, ICompressProgress progress) {
		SRes res = new SRes();
		CXzEncHandle xz = ModernizedCProgram.XzEnc_Create(ModernizedCProgram.g_Alloc, ModernizedCProgram.g_BigAlloc);
		if (!xz) {
			return 2;
		} 
		res = ModernizedCProgram.XzEnc_SetProps(xz, props);
		if (res == 0) {
			res = ModernizedCProgram.XzEnc_Encode(xz, outStream, inStream, progress);
		} 
		ModernizedCProgram.XzEnc_Destroy(xz);
		return res;
	}
	/* gzread.c -- zlib functions for reading gzip files
	 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */
	/* Local functions */
	public static int gz_load(Object state, Byte buf, int len, int have) {
		int ret;
		int get;
		int max = ((int)-1 >> 2) + 1;
		have = 0;
		do {
			get = len - have;
			if (get > max) {
				get = max;
			} 
			ret = .read(state.getFd(), buf + have, get);
			if (ret <= 0) {
				break;
			} 
			have += (int)ret;
		} while (have < len);
		if (ret < 0) {
			ModernizedCProgram.gz_error(state, (true), .strerror((._errno())));
			return -1;
		} 
		if (ret == 0) {
			state.setEof(1);
		} 
		return 0/* Load up input buffer and set eof flag if last data loaded -- return -1 on
		   error, 0 otherwise.  Note that the eof flag is set when the end of the input
		   file is reached, even though there may be unused data in the buffer.  Once
		   that data has been used, no more attempts will be made to read the file.
		   If strm->avail_in != 0, then the current data is moved to the beginning of
		   the input buffer, and then the remainder of the buffer is loaded with the
		   available data from the input file. */;
	}
	public static int gz_avail(Object state) {
		int got;
		z_streamp strm = (state.getStrm());
		if (state.getErr() != 0 && state.getErr() != (true)) {
			return -1;
		} 
		if (state.getEof() == 0) {
			if (strm.getAvail_in()) {
				byte p = state.getIn();
				byte q = strm.getNext_in();
				int n = strm.getAvail_in();
				do {
					p++ = q++;
				} while (--n);
			} 
			if (ModernizedCProgram.gz_load(state, state.getIn() + strm.getAvail_in(), state.getSize() - strm.getAvail_in(), got) == -1) {
				return -1;
			} 
			strm.getAvail_in() += got;
			strm.setNext_in(state.getIn());
		} 
		return 0/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
		   If this is the first time in, allocate required memory.  state->how will be
		   left unchanged if there is no more input data available, will be set to COPY
		   if there is no gzip header and direct copying will be performed, or it will
		   be set to GZIP for decompression.  If direct copying, then leftover input
		   data from the input buffer will be copied to the output buffer.  In that
		   case, all further file reads will be directly to either the output buffer or
		   a user buffer.  If decompressing, the inflate state will be initialized.
		   gz_look() will return 0 on success or -1 on failure. */;
	}
	public static int gz_look(Object state) {
		z_streamp strm = (state.getStrm());
		if (state.getSize() == /* allocate read buffers and inflate memory */0) {
			state.setIn((byte).malloc(state.getWant()));
			state.setOut((byte).malloc(state.getWant() << 1));
			if (state.getIn() == ((Object)0) || state.getOut() == ((Object)0)) {
				.free(state.getOut());
				.free(state.getIn());
				ModernizedCProgram.gz_error(state, (true), "out of memory");
				return -1;
			} 
			state.setSize(state.getWant());
			state.getStrm().setZalloc(/* allocate inflate memory */0);
			state.getStrm().setZfree(0);
			state.getStrm().setOpaque(0);
			state.getStrm().setAvail_in(0);
			state.getStrm().setNext_in(0);
			if (ModernizedCProgram.inflateInit2_(((state.getStrm())), (15 + 16), "1.2.11", (int)) != /* gunzip */0) {
				.free(state.getOut());
				.free(state.getIn());
				state.setSize(0);
				ModernizedCProgram.gz_error(state, (true), "out of memory");
				return -1;
			} 
		} 
		if (strm.getAvail_in() < /* get at least the magic bytes in the input buffer */2) {
			if (ModernizedCProgram.gz_avail(state) == -1) {
				return -1;
			} 
			if (strm.getAvail_in() == 0) {
				return 0/* look for gzip magic bytes -- if there, do gzip decoding (note: there is
				       a logical dilemma here when considering the case of a partially written
				       gzip file, to wit, if a single 31 byte is written, then we cannot tell
				       whether this is a single-byte file, or just a partially written gzip
				       file -- for here we assume that if a gzip file is being written, then
				       the header will be written in a single operation, so that reading a
				       single byte is sufficient indication that it is not a gzip file) */;
			} 
		} 
		if (strm.getAvail_in() > 1 && strm.getNext_in()[0] == 31 && strm.getNext_in()[1] == 139) {
			ModernizedCProgram.inflateReset(strm);
			state.setHow(2);
			state.setDirect(0);
			return 0;
		} 
		if (state.getDirect() == /* no gzip header -- if we were decoding gzip before, then this is trailing
		       garbage.  Ignore the trailing garbage and finish. */0) {
			strm.setAvail_in(0);
			state.setEof(1);
			state.getX().setHave(0);
			return 0;
		} 
		state.getX().setNext(state.getOut());
		if (strm.getAvail_in()) {
			.memcpy(state.getX().getNext(), strm.getNext_in(), strm.getAvail_in());
			state.getX().setHave(strm.getAvail_in());
			strm.setAvail_in(0);
		} 
		state.setHow(1);
		state.setDirect(1);
		return 0/* Decompress from input to the provided next_out and avail_out in the state.
		   On return, state->x.have and state->x.next point to the just decompressed
		   data.  If the gzip stream completes, state->how is reset to LOOK to look for
		   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
		   on success, -1 on failure. */;
	}
	public static int gz_decomp(Object state) {
		int ret = 0;
		int had;
		z_streamp strm = (state.getStrm());
		had = strm.getAvail_out();
		do {
			if (strm.getAvail_in() == 0 && ModernizedCProgram.gz_avail(state) == -/* get more input for inflate() */1) {
				return -1;
			} 
			if (strm.getAvail_in() == 0) {
				ModernizedCProgram.gz_error(state, (true), "unexpected end of file");
				break;
			} 
			ret = ModernizedCProgram.inflate(strm, /* decompress and handle errors */0);
			if (ret == (true) || ret == 2) {
				ModernizedCProgram.gz_error(state, (true), "internal error: inflate stream corrupt");
				return -1;
			} 
			if (ret == (true)) {
				ModernizedCProgram.gz_error(state, (true), "out of memory");
				return -1;
			} 
			if (ret == (/* deflate stream invalid */true)) {
				ModernizedCProgram.gz_error(state, (true), strm.getMsg() == ((Object)0) ? "compressed data error" : strm.getMsg());
				return -1;
			} 
		} while (strm.getAvail_out() && ret != 1);
		state.getX().setHave(had - strm.getAvail_out());
		state.getX().setNext(strm.getNext_out() - state.getX().getHave());
		if (ret == /* if the gzip stream completed successfully, look for another */1) {
			state.setHow(0);
		} 
		return /* good decompression */0/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
		   Data is either copied from the input file or decompressed from the input
		   file depending on state->how.  If state->how is LOOK, then a gzip header is
		   looked for to determine whether to copy or decompress.  Returns -1 on error,
		   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
		   end of the input file has been reached and all data has been processed.  */;
	}
	public static int gz_fetch(Object state) {
		z_streamp strm = (state.getStrm());
		do {
			switch (state.getHow()) {
			case /* -> COPY */1:
					if (ModernizedCProgram.gz_load(state, state.getOut(), state.getSize() << 1, (state.getX().getHave())) == -1) {
						return -1;
					} 
					state.getX().setNext(state.getOut());
					return 0;
			case /* -> GZIP or LOOK (if end of gzip stream) */2:
					strm.setAvail_out(state.getSize() << 1);
					strm.setNext_out(state.getOut());
					if (ModernizedCProgram.gz_decomp(state) == -1) {
						return -1;
					} 
			case /* -> LOOK, COPY (only if never GZIP), or GZIP */0:
					if (ModernizedCProgram.gz_look(state) == -1) {
						return -1;
					} 
					if (state.getHow() == 0) {
						return 0;
					} 
					break;
			}
		} while (state.getX().getHave() == 0 && (!state.getEof() || strm.getAvail_in()));
		return 0;
	}
	/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
	public static int gz_skip(Object state, long len) {
		int n;
		while (/* skip over len bytes or reach end-of-file, whichever comes first */len) {
			if (state.getX().getHave()) {
				n = ( ==  && (state.getX().getHave()) > 2147483647) || (long)state.getX().getHave() > len ? (int)len : state.getX().getHave();
				state.getX().getHave() -= n;
				state.getX().getNext() += n;
				state.getX().getPos() += n;
				len -= n;
			}  else if (state.getEof() && state.getStrm().getAvail_in() == /* output buffer empty -- return if we're at the end of the input */0) {
				break;
			} else {
					if (ModernizedCProgram.gz_fetch(state) == -/* get more output, looking for header if required */1) {
						return -1;
					} 
			} 
		}
		return 0/* Read len bytes into buf from file, or less than len up to the end of the
		   input.  Return the number of bytes read.  If zero is returned, either the
		   end of file was reached, or there was an error.  state->err must be
		   consulted in that case to determine which. */;
	}
	public static Object gz_read(Object state, Object buf, Object len) {
		z_size_t got = new z_size_t();
		int n;
		if (len == /* if len is zero, avoid unnecessary operations */0) {
			return 0;
		} 
		if (state.getSeek()) {
			state.setSeek(0);
			if (ModernizedCProgram.gz_skip(state, state.getSkip()) == -1) {
				return 0;
			} 
		} 
		got = /* get len bytes to buf, or less than len if at the end */0;
		do {
			n = -/* set n to the maximum amount of len that fits in an unsigned int */1;
			if (n > len) {
				n = len;
			} 
			if (state.getX().getHave()) {
				if (state.getX().getHave() < n) {
					n = state.getX().getHave();
				} 
				.memcpy(buf, state.getX().getNext(), n);
				state.getX().getNext() += n;
				state.getX().getHave() -= n;
			}  else if (state.getEof() && state.getStrm().getAvail_in() == /* output buffer empty -- return if we're at the end of the input */0) {
				state.setPast(/* tried to read past end */1);
				break;
			}  else if (state.getHow() == 0 || n < (state.getSize() << /* need output data -- for small len or new stream load up our output
			           buffer */1)) {
				if (ModernizedCProgram.gz_fetch(state) == -/* get more output, looking for header if required */1) {
					return 0;
				} 
				continue;
			}  else if (state.getHow() == /* large len -- read directly into user buffer *//* read directly */1) {
				if (ModernizedCProgram.gz_load(state, (byte)buf, n, n) == -1) {
					return 0;
				} 
			} else {
					state.getStrm().setAvail_out(/* large len -- decompress directly into user buffer *//* state->how == GZIP */n);
					state.getStrm().setNext_out((byte)buf);
					if (ModernizedCProgram.gz_decomp(state) == -1) {
						return 0;
					} 
					n = state.getX().getHave();
					state.getX().setHave(0);
			} 
			len -= /* update progress */n;
			buf = (byte)buf + n;
			got += n;
			state.getX().getPos() += n;
		} while (len);
		return /* return number of bytes read into user buffer */got;
	}
	/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
	   state->fd, and update state->eof, state->err, and state->msg as appropriate.
	   This function needs to loop on read(), since read() is not guaranteed to
	   read the number of bytes requested, depending on the type of descriptor. */
	/* -- see zlib.h -- */
	public static int gzread(Object file, Object buf, int len) {
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return -1;
		} 
		state = (gz_statep)file;
		if (state.getMode() != /* check that we're reading and that there's no (serious) error */7247 || (state.getErr() != 0 && state.getErr() != (true))) {
			return -1;
		} 
		if ((int)len < /* since an int is returned, make sure len fits in one, otherwise return
		       with an error (this avoids a flaw in the interface) */0) {
			ModernizedCProgram.gz_error(state, (true), "request does not fit in an int");
			return -1;
		} 
		len = ModernizedCProgram.gz_read(state, buf, /* read len or fewer bytes to buf */len);
		if (len == 0 && state.getErr() != 0 && state.getErr() != (/* check for an error */true)) {
			return -1;
		} 
		return (int)/* return the number of bytes read (this is assured to fit in an int) */len;
	}
	/* -- see zlib.h -- */
	public static Object gzfread(Object buf, Object size, Object nitems, Object file) {
		z_size_t len = new z_size_t();
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return 0;
		} 
		state = (gz_statep)file;
		if (state.getMode() != /* check that we're reading and that there's no (serious) error */7247 || (state.getErr() != 0 && state.getErr() != (true))) {
			return 0;
		} 
		len = nitems * /* compute bytes to read -- error on overflow */size;
		if (size && len / size != nitems) {
			ModernizedCProgram.gz_error(state, (true), "request does not fit in a size_t");
			return 0;
		} 
		return len ? ModernizedCProgram.gz_read(state, buf, len) / size : /* read len or fewer bytes to buf, return the number of full items read */0/* -- see zlib.h -- */;
	}
	public static int gzgetc(Object file) {
		int ret;
		byte[] buf = new byte[1];
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return -1;
		} 
		state = (gz_statep)file;
		if (state.getMode() != /* check that we're reading and that there's no (serious) error */7247 || (state.getErr() != 0 && state.getErr() != (true))) {
			return -1;
		} 
		if (state.getX().getHave()) {
			state.getX().getHave()--;
			state.getX().getPos()++;
			return (state.getX().getNext())++;
		} 
		ret = ModernizedCProgram.gz_read(state, buf, /* nothing there -- try gz_read() */1);
		return ret < 1 ? -1 : buf[0];
	}
	public static int gzgetc_(Object file) {
		return ModernizedCProgram.gzgetc(file);
	}
	/* -- see zlib.h -- */
	public static int gzungetc(int c, Object file) {
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return -1;
		} 
		state = (gz_statep)file;
		if (state.getMode() != /* check that we're reading and that there's no (serious) error */7247 || (state.getErr() != 0 && state.getErr() != (true))) {
			return -1;
		} 
		if (state.getSeek()) {
			state.setSeek(0);
			if (ModernizedCProgram.gz_skip(state, state.getSkip()) == -1) {
				return -1;
			} 
		} 
		if (c < /* can't push EOF */0) {
			return -1;
		} 
		if (state.getX().getHave() == /* if output buffer empty, put byte at end (allows more pushing) */0) {
			state.getX().setHave(1);
			state.getX().setNext(state.getOut() + (state.getSize() << 1) - 1);
			state.getX().getNext()[0] = (byte)c;
			state.getX().getPos()--;
			state.setPast(0);
			return c;
		} 
		if (state.getX().getHave() == (state.getSize() << /* if no room, give up (must have already done a gzungetc()) */1)) {
			ModernizedCProgram.gz_error(state, (true), "out of room to push characters");
			return -1;
		} 
		if (state.getX().getNext() == state.getOut()) {
			byte src = state.getOut() + state.getX().getHave();
			byte dest = state.getOut() + (state.getSize() << 1);
			while (src > state.getOut()) {
				--dest = --src;
			}
			state.getX().setNext(dest);
		} 
		state.getX().getHave()++;
		state.getX().getNext()--;
		state.getX().getNext()[0] = (byte)c;
		state.getX().getPos()--;
		state.setPast(0);
		return c;
	}
	/* -- see zlib.h -- */
	public static Byte gzgets(Object file, Byte buf, int len) {
		int left;
		int n;
		byte str;
		byte eol;
		gz_statep state = new gz_statep();
		if (file == ((Object)0) || buf == ((Object)0) || len < /* check parameters and get internal structure */1) {
			return ((Object)0);
		} 
		state = (gz_statep)file;
		if (state.getMode() != /* check that we're reading and that there's no (serious) error */7247 || (state.getErr() != 0 && state.getErr() != (true))) {
			return ((Object)0);
		} 
		if (state.getSeek()) {
			state.setSeek(0);
			if (ModernizedCProgram.gz_skip(state, state.getSkip()) == -1) {
				return ((Object)0);
			} 
		} 
		str = /* copy output bytes up to new line or len - 1, whichever comes first --
		       append a terminating zero to the string (we don't check for a zero in
		       the contents, let the user worry about that) */buf;
		left = (int)len - 1;
		if (left) {
			do {
				if (state.getX().getHave() == 0 && ModernizedCProgram.gz_fetch(state) == -/* assure that something is in the output buffer */1) {
					return ((Object)/* error */0);
				} 
				if (state.getX().getHave() == /* end of file */0) {
					state.setPast(/* read past end */1);
					break;
				} 
				n = state.getX().getHave() > left ? left : state.getX().getHave();
				eol = (byte).memchr(state.getX().getNext(), (byte)'\n', n);
				if (eol != ((Object)0)) {
					n = (int)(eol - state.getX().getNext()) + 1;
				} 
				.memcpy(buf, state.getX().getNext(), /* copy through end-of-line, or remainder if not found */n);
				state.getX().getHave() -= n;
				state.getX().getNext() += n;
				state.getX().getPos() += n;
				left -= n;
				buf += n;
			} while (left && eol == ((Object)0));
		} 
		if (buf == /* return terminated string, or if nothing, end of file */str) {
			return ((Object)0);
		} 
		buf[0] = 0;
		return str;
	}
	/* -- see zlib.h -- */
	public static int gzdirect(Object file) {
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return 0;
		} 
		state = (gz_statep)file;
		if (state.getMode() == 7247 && state.getHow() == 0 && state.getX().getHave() == /* if the state is not known, but we can find out, then do so (this is
		       mainly for right after a gzopen() or gzdopen()) */0) {
			(Object)ModernizedCProgram.gz_look(state);
		} 
		return state.getDirect();
	}
	/* -- see zlib.h -- */
	public static int gzclose_r(Object file) {
		int ret;
		int err;
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return (true);
		} 
		state = (gz_statep)file;
		if (state.getMode() != /* check that we're reading */7247) {
			return (true);
		} 
		if (state.getSize()) {
			ModernizedCProgram.inflateEnd((state.getStrm()));
			.free(state.getOut());
			.free(state.getIn());
		} 
		err = state.getErr() == (true) ? (true) : 0;
		ModernizedCProgram.gz_error(state, 0, ((Object)0));
		.free(state.getPath());
		ret = ModernizedCProgram.close(state.getFd());
		.free(state);
		return ret ? (true) : err;
	}
	/* pointer to destination pointer */
	public static int puff(Byte dest, long destlen, Object source, long sourcelen) {
		/* amount of input available *//* input/output state */state s = new state();
		/* block information */int last;
		int type;
		/* return value */int err;
		s.setOut(/* initialize output state */dest);
		s.setOutlen(/* ignored if dest is NIL */destlen);
		s.setOutcnt(0);
		s.setIn(/* initialize input state */source);
		s.setInlen(sourcelen);
		s.setIncnt(0);
		s.setBitbuf(0);
		s.setBitcnt(0);
		Object generatedEnv = s.getEnv();
		if (._setjmp(generatedEnv) != /* return if bits() or decode() tries to read past available input *//* if came back here via longjmp() */0) {
			err = /* then skip do-loop, return error */2;
		} else {
				do {
					last = s.bits(/* one if last block */1);
					type = s.bits(/* block type 0..3 */2);
					err = type == 0 ? s.stored() : (type == 1 ? s.fixed() : (type == 2 ? s.dynamic() : -/* type == 3, invalid */1));
					if (err != 0) {
						break;
					} 
				} while (!last);
		} 
		long generatedOutcnt = s.getOutcnt();
		long generatedIncnt = s.getIncnt();
		if (err <= /* update the lengths and return */0) {
			destlen = generatedOutcnt;
			sourcelen = generatedIncnt;
		} 
		return err;
	}
	/* amount of output space */
	/* pointer to source data pointer */
	public static Object module_hook_size(Object hashconfig, Object user_options, Object user_options_extra) {
		u64 hook_size = (u64);
		return hook_size;
	}
	public static Object module_hook_salt_size(Object hashconfig, Object user_options, Object user_options_extra) {
		u64 hook_salt_size = (u64);
		return hook_salt_size;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static void fsync(int fd) {
		HANDLE h = (HANDLE)._get_osfhandle(fd);
		.FlushFileBuffers(h);
	}
	public static int get_msb32(Object v) {
		int i;
		for (i = 32; i > 0; i--) {
			if ((v >> (i - 1)) & 1) {
				break;
			} 
		}
		return i;
	}
	public static int get_msb64(Object v) {
		int i;
		for (i = 64; i > 0; i--) {
			if ((v >> (i - 1)) & 1) {
				break;
			} 
		}
		return i;
	}
	public static boolean overflow_check_u32_add(Object a, Object b) {
		int a_msb = ModernizedCProgram.get_msb32(a);
		int b_msb = ModernizedCProgram.get_msb32(b);
		return ((a_msb < 32) && (b_msb < 32));
	}
	public static boolean overflow_check_u32_mul(Object a, Object b) {
		int a_msb = ModernizedCProgram.get_msb32(a);
		int b_msb = ModernizedCProgram.get_msb32(b);
		return ((a_msb + b_msb) < 32);
	}
	public static boolean overflow_check_u64_add(Object a, Object b) {
		int a_msb = ModernizedCProgram.get_msb64(a);
		int b_msb = ModernizedCProgram.get_msb64(b);
		return ((a_msb < 64) && (b_msb < 64));
	}
	public static boolean overflow_check_u64_mul(Object a, Object b) {
		int a_msb = ModernizedCProgram.get_msb64(a);
		int b_msb = ModernizedCProgram.get_msb64(b);
		return ((a_msb + b_msb) < 64);
	}
	public static boolean is_power_of_2(Object v) {
		return (v && !(v & (v - 1)));
	}
	public static Object mydivc32(Object dividend, Object divisor) {
		u32 quotient = dividend / divisor;
		if (dividend % divisor) {
			quotient++;
		} 
		return quotient;
	}
	public static Object mydivc64(Object dividend, Object divisor) {
		u64 quotient = dividend / divisor;
		if (dividend % divisor) {
			quotient++;
		} 
		return quotient;
	}
	public static Byte filename_from_filepath(Byte filepath) {
		byte ptr = ((Object)0);
		if ((ptr = .strrchr(filepath, (byte)'/')) != ((Object)0)) {
			ptr++;
		}  else if ((ptr = .strrchr(filepath, (byte)'\\')) != ((Object)0)) {
			ptr++;
		} else {
				ptr = filepath;
		} 
		return ptr;
	}
	public static void naive_replace(Byte s, Object key_char, Object replace_char) {
		size_t len = .strlen(s);
		for (size_t in = 0;
		 in < len; in++) {
			byte c = s[in];
			if (c == key_char) {
				s[in] = replace_char;
			} 
		}
	}
	public static void naive_escape(Byte s, Object s_max, Object key_char, Object escape_char) {
		byte[] s_escaped = new byte[]{0};
		size_t s_escaped_max = ;
		size_t len = .strlen(s);
		for (size_t in = 0;
		size_t out = 0;
		 in < len; ) {
			byte c = s[in];
			if (c == key_char) {
				s_escaped[out] = escape_char;
				out++;
			} 
			if (out == s_escaped_max - 2) {
				break;
			} 
			s_escaped[out] = c;
		}
		.strncpy(s, s_escaped, s_max - 1);
	}
	public static int hc_asprintf(Byte strp, Object fmt) {
		va_list args = new va_list();
		.__builtin_va_start(args, fmt);
		int rc = .vasprintf(strp, fmt, args);
		.__builtin_va_end(args);
		return rc;
	}
	public static void hc_qsort_r(Object base, Object nmemb, Object size, Object compar, Object arg) {
		ModernizedCProgram.sort_r(base, nmemb, size, compar, arg);
	}
	public static Object hc_bsearch_r(Object key, Object base, Object nmemb, Object size, Object compar, Object arg) {
		for (size_t l = 0;
		size_t r = nmemb;
		 r; r >>=  1) {
			size_t m = r >> 1;
			size_t c = l + m;
			byte next = (byte)base + (c * size);
			int cmp = .UNRECOGNIZEDFUNCTIONNAME(key, next, arg);
			if (cmp > 0) {
				l += m + 1;
				r--;
			} 
			if (cmp == 0) {
				return ((Object)next);
			} 
		}
		return (((Object)0));
	}
	public static boolean hc_path_is_file(Object path) {
		stat s = new stat();
		if (.stat(path, s) == -1) {
			return 0;
		} 
		Object generatedSt_mode = s.getSt_mode();
		if ((((generatedSt_mode) & -1024) == -1024)) {
			return 1;
		} 
		return 0;
	}
	public static boolean hc_path_is_directory(Object path) {
		stat s = new stat();
		if (.stat(path, s) == -1) {
			return 0;
		} 
		Object generatedSt_mode = s.getSt_mode();
		if ((((generatedSt_mode) & -1024) == -1024)) {
			return 1;
		} 
		return 0;
	}
	public static boolean hc_path_is_empty(Object path) {
		stat s = new stat();
		if (.stat(path, s) == -1) {
			return 0;
		} 
		Object generatedSt_size = s.getSt_size();
		if (generatedSt_size == 0) {
			return 1;
		} 
		return 0;
	}
	public static boolean hc_path_exist(Object path) {
		if (.access(path, 0) == -1) {
			return 0;
		} 
		return 1;
	}
	public static boolean hc_path_read(Object path) {
		if (.access(path, 4) == -1) {
			return 0;
		} 
		return 1;
	}
	public static boolean hc_path_write(Object path) {
		if (.access(path, 2) == -1) {
			return 0;
		} 
		return 1;
	}
	public static boolean hc_path_create(Object path) {
		if (ModernizedCProgram.hc_path_exist(path) == 1) {
			return 0;
		} 
		int fd = ModernizedCProgram.open(path, 1 | -1024 | -1024, -1024 | -1024);
		if (fd == -1) {
			return 0;
		} 
		ModernizedCProgram.close(fd);
		.unlink(path);
		return 1;
	}
	public static boolean hc_path_has_bom(Object path) {
		u8[] buf = new u8[]{0};
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(path, "rb") == 0) {
			return 0;
		} 
		size_t nread = fp.hc_fread(buf, 1, );
		fp.hc_fclose();
		if (nread < 1) {
			return 0/* signatures from https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding */;
		} 
		// utf-8if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024) && (buf[3] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024) && (buf[3] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024) && (buf[3] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024) && (buf[3] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024) && (buf[3] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024) && (buf[3] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024) && (buf[3] == -1024) && (buf[4] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024) && (buf[3] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024)) {
			return 1;
		} 
		if ((buf[0] == -1024) && (buf[1] == -1024) && (buf[2] == -1024) && (buf[3] == -1024)) {
			return 1;
		} 
		return 0;
	}
	public static boolean hc_string_is_digit(Object s) {
		if (s == ((Object)0)) {
			return 0;
		} 
		size_t len = .strlen(s);
		if (len == 0) {
			return 0;
		} 
		for (size_t i = 0;
		 i < len; i++) {
			int c = (int)s[i];
			if (.isdigit(c) == 0) {
				return 0;
			} 
		}
		return 1;
	}
	public static void setup_environment_variables(Object folder_config) {
		byte compute = .getenv("COMPUTE");
		if (compute) {
			byte display;
			ModernizedCProgram.hc_asprintf(display, "DISPLAY=%s", compute);
			.putenv(display);
			.free(display);
		} else {
				if (.getenv("DISPLAY") == ((Object)0)) {
					.putenv((byte)"DISPLAY=:0"/*
					  if (getenv ("OCL_CODE_CACHE_ENABLE") == NULL)
					    putenv ((char *) "OCL_CODE_CACHE_ENABLE=0");
					
					  if (getenv ("CUDA_CACHE_DISABLE") == NULL)
					    putenv ((char *) "CUDA_CACHE_DISABLE=1");
					
					  if (getenv ("POCL_KERNEL_CACHE") == NULL)
					    putenv ((char *) "POCL_KERNEL_CACHE=0");
					  */);
				} 
		} 
		if (.getenv("TMPDIR") == ((Object)0)) {
			byte tmpdir = ((Object)0);
			ModernizedCProgram.hc_asprintf(tmpdir, "TMPDIR=%s", folder_config.getProfile_dir());
			.putenv(tmpdir);
		} 
		if (.getenv("CL_CONFIG_USE_VECTORIZER") == ((Object)0)) {
			.putenv((byte)"CL_CONFIG_USE_VECTORIZER=False");
		} 
	}
	public static void setup_umask() {
		.umask(77);
	}
	public static void setup_seeding(Object rp_gen_seed_chgd, Object rp_gen_seed) {
		if (rp_gen_seed_chgd == 1) {
			.srand(rp_gen_seed);
		} else {
				time_t ts = .time(((Object)0));
				.srand((int)ts);
		} 
	}
	public static Object get_random_num(Object min, Object max) {
		if (min == max) {
			return (min);
		} 
		u32 low = max - min;
		if (low == 0) {
			return (false);
		} 
		return (((u32).rand() % (max - min)) + min);
	}
	public static void hc_string_trim_leading(Byte s) {
		int skip = 0;
		int len = (int).strlen(s);
		for (int i = 0;
		 i < len; i++) {
			int c = (int)s[i];
			if (.isspace(c) == 0) {
				break;
			} 
			skip++;
		}
		if (skip == 0) {
			return ;
		} 
		int new_len = len - skip;
		.memmove(s, s + skip, new_len);
		s[new_len] = 0;
	}
	public static void hc_string_trim_trailing(Byte s) {
		int skip = 0;
		int len = (int).strlen(s);
		for (int i = len - 1;
		 i >= 0; i--) {
			int c = (int)s[i];
			if (.isspace(c) == 0) {
				break;
			} 
			skip++;
		}
		if (skip == 0) {
			return ;
		} 
		size_t new_len = len - skip;
		s[new_len] = 0;
	}
	public static boolean hc_same_files(Byte file1, Byte file2) {
		if ((file1 != ((Object)0)) && (file2 != ((Object)0))) {
			stat tmpstat_file1 = new stat();
			stat tmpstat_file2 = new stat();
			int do_check = 0;
			HCFILE fp = new HCFILE();
			if (fp.hc_fopen(file1, "r") == 1) {
				if (.fstat(fp.hc_fileno(), tmpstat_file1)) {
					fp.hc_fclose();
					return 0;
				} 
				fp.hc_fclose();
				do_check++;
			} 
			if (fp.hc_fopen(file2, "r") == 1) {
				if (.fstat(fp.hc_fileno(), tmpstat_file2)) {
					fp.hc_fclose();
					return 0;
				} 
				fp.hc_fclose();
				do_check++;
			} 
			if (do_check == 2) {
				tmpstat_file1.setSt_mode(0);
				tmpstat_file1.setSt_nlink(0);
				tmpstat_file1.setSt_uid(0);
				tmpstat_file1.setSt_gid(0);
				tmpstat_file1.setSt_rdev(0);
				tmpstat_file1.setSt_atime(0);
				tmpstat_file2.setSt_mode(0);
				tmpstat_file2.setSt_nlink(0);
				tmpstat_file2.setSt_uid(0);
				tmpstat_file2.setSt_gid(0);
				tmpstat_file2.setSt_rdev(0);
				tmpstat_file2.setSt_atime(0);
				if (.memcmp(tmpstat_file1, tmpstat_file2, ) == 0) {
					return 1;
				} 
			} 
		} 
		return 0;
	}
	public static Object hc_strtoul(Object nptr, Byte endptr, int base) {
		return (u32).strtoul(nptr, endptr, base);
	}
	public static Object hc_strtoull(Object nptr, Byte endptr, int base) {
		return (u64).strtoull(nptr, endptr, base);
	}
	public static Object power_of_two_ceil_32(Object v) {
		u32 r = v;
		r--;
		r |=  r >> 1;
		r |=  r >> 2;
		r |=  r >> 4;
		r |=  r >> 8;
		r |=  r >> 16;
		r++;
		return r;
	}
	public static Object power_of_two_floor_32(Object v) {
		u32 r = ModernizedCProgram.power_of_two_ceil_32(v);
		if (r > v) {
			r >>=  1;
		} 
		return r;
	}
	public static Object round_up_multiple_32(Object v, Object m) {
		if (m == 0) {
			return v;
		} 
		u32 r = v % m;
		if (r == 0) {
			return v;
		} 
		return v + m - r;
	}
	public static Object round_up_multiple_64(Object v, Object m) {
		if (m == 0) {
			return v;
		} 
		u64 r = v % m;
		if (r == 0) {
			return v;
		} 
		return v + m - r;
	}
	// difference to original strncat is no returncode and u8* instead of char*
	public static void hc_strncat(Object dst, Object src, Object n) {
		size_t dst_len = .strlen((byte)dst);
		u8 src_ptr = src;
		u8 dst_ptr = dst + dst_len;
		for (size_t i = 0;
		 i < n && src_ptr != 0; i++) {
			dst_ptr++ = src_ptr++;
		}
		dst_ptr = 0;
	}
	public static int count_char(Object buf, Object len, Object c) {
		int r = 0;
		for (int i = 0;
		 i < len; i++) {
			if (buf[i] == c) {
				r++;
			} 
		}
		return r;
	}
	public static double get_entropy(Object buf, Object len) {
		double entropy = 0.0;
		for (int c = 0;
		 c < 256; c++) {
			int r = ModernizedCProgram.count_char(buf, len, (u8)c);
			if (r == 0) {
				continue;
			} 
			double w = (double)r / len;
			entropy += -w * .log2f(w);
		}
		return entropy;
	}
	public static int select_read_timeout(int sockfd, Object sec) {
		timeval tv = new timeval();
		tv.setTv_sec(sec);
		tv.setTv_usec(0);
		fd_set fds = new fd_set();
		(((fd_set)(fds)).setFd_count(0));
		do {
			u_int __i = new u_int();
			for (__i = 0; __i < ((fd_set)(fds)).getFd_count(); __i++) {
				if (((fd_set)(fds)).getFd_array()[__i] == (sockfd)) {
					break;
				} 
			}
			if (__i == ((fd_set)(fds)).getFd_count()) {
				if (((fd_set)(fds)).getFd_count() < 64) {
					((fd_set)(fds)).getFd_array()[__i] = (sockfd);
					((fd_set)(fds)).getFd_count()++;
				} 
			} 
		} while (0);
		return .select(sockfd + 1, fds, ((Object)0), ((Object)0), tv);
	}
	public static int select_write_timeout(int sockfd, Object sec) {
		timeval tv = new timeval();
		tv.setTv_sec(sec);
		tv.setTv_usec(0);
		fd_set fds = new fd_set();
		(((fd_set)(fds)).setFd_count(0));
		do {
			u_int __i = new u_int();
			for (__i = 0; __i < ((fd_set)(fds)).getFd_count(); __i++) {
				if (((fd_set)(fds)).getFd_array()[__i] == (sockfd)) {
					break;
				} 
			}
			if (__i == ((fd_set)(fds)).getFd_count()) {
				if (((fd_set)(fds)).getFd_count() < 64) {
					((fd_set)(fds)).getFd_array()[__i] = (sockfd);
					((fd_set)(fds)).getFd_count()++;
				} 
			} 
		} while (0);
		return .select(sockfd + 1, ((Object)0), fds, ((Object)0), tv);
	}
	public static int select_read_timeout_console(Object sec) {
		HANDLE hStdIn = .GetStdHandle((DWORD)(true));
		DWORD rc = .WaitForSingleObject(hStdIn, sec * 1000);
		Object generatedEventType = inRecords.getEventType();
		if (rc == 0) {
			DWORD dwRead = new DWORD();
			INPUT_RECORD inRecords = new INPUT_RECORD();
			inRecords.setEventType(0);
			.PeekConsoleInputA(hStdIn, inRecords, 1, dwRead);
			if (generatedEventType == 0) {
				return 1;
			} else {
					.ReadConsoleInputA(hStdIn, inRecords, 1, dwRead);
			} 
			return ModernizedCProgram.select_read_timeout_console(sec);
		}  else if (rc == -1024) {
			return 0;
		} 
		return -1;
	}
	public static Object strhashcategory(Object hash_category) {
		switch (hash_category) {
		case hash_category.HASH_CATEGORY_DOCUMENTS:
				return ModernizedCProgram.HASH_CATEGORY_DOCUMENTS_STR;
		case hash_category.HASH_CATEGORY_RAW_CHECKSUM:
				return ModernizedCProgram.HASH_CATEGORY_RAW_CHECKSUM_STR;
		case hash_category.HASH_CATEGORY_RAW_HASH_AUTHENTICATED:
				return ModernizedCProgram.HASH_CATEGORY_RAW_HASH_AUTHENTICATED_STR;
		case hash_category.HASH_CATEGORY_OS:
				return ModernizedCProgram.HASH_CATEGORY_OS_STR;
		case hash_category.HASH_CATEGORY_EAS:
				return ModernizedCProgram.HASH_CATEGORY_EAS_STR;
		case hash_category.HASH_CATEGORY_RAW_HASH_SALTED:
				return ModernizedCProgram.HASH_CATEGORY_RAW_HASH_SALTED_STR;
		case hash_category.HASH_CATEGORY_FDE:
				return ModernizedCProgram.HASH_CATEGORY_FDE_STR;
		case hash_category.HASH_CATEGORY_DATABASE_SERVER:
				return ModernizedCProgram.HASH_CATEGORY_DATABASE_SERVER_STR;
		case hash_category.HASH_CATEGORY_PASSWORD_MANAGER:
				return ModernizedCProgram.HASH_CATEGORY_PASSWORD_MANAGER_STR;
		case hash_category.HASH_CATEGORY_RAW_CIPHER_KPA:
				return ModernizedCProgram.HASH_CATEGORY_RAW_CIPHER_KPA_STR;
		case hash_category.HASH_CATEGORY_FORUM_SOFTWARE:
				return ModernizedCProgram.HASH_CATEGORY_FORUM_SOFTWARE_STR;
		case hash_category.HASH_CATEGORY_RAW_HASH:
				return ModernizedCProgram.HASH_CATEGORY_RAW_HASH_STR;
		case hash_category.HASH_CATEGORY_OTP:
				return ModernizedCProgram.HASH_CATEGORY_OTP_STR;
		case hash_category.HASH_CATEGORY_ARCHIVE:
				return ModernizedCProgram.HASH_CATEGORY_ARCHIVE_STR;
		case hash_category.HASH_CATEGORY_NETWORK_PROTOCOL:
				return ModernizedCProgram.HASH_CATEGORY_NETWORK_PROTOCOL_STR;
		case hash_category.HASH_CATEGORY_GENERIC_KDF:
				return ModernizedCProgram.HASH_CATEGORY_GENERIC_KDF_STR;
		case hash_category.HASH_CATEGORY_FRAMEWORK:
				return ModernizedCProgram.HASH_CATEGORY_FRAMEWORK_STR;
		case hash_category.HASH_CATEGORY_NETWORK_SERVER:
				return ModernizedCProgram.HASH_CATEGORY_NETWORK_SERVER_STR;
		case hash_category.HASH_CATEGORY_UNDEFINED:
				return ModernizedCProgram.HASH_CATEGORY_UNDEFINED_STR;
		case hash_category.HASH_CATEGORY_PLAIN:
				return ModernizedCProgram.HASH_CATEGORY_PLAIN_STR;
		}
		return ((Object)0);
	}
	public static Object stroptitype(Object opti_type) {
		switch (opti_type) {
		case opti_type.OPTI_TYPE_SLOW_HASH_SIMD_LOOP:
				return ModernizedCProgram.OPTI_STR_SLOW_HASH_SIMD_LOOP;
		case opti_type.OPTI_TYPE_SLOW_HASH_SIMD_INIT:
				return ModernizedCProgram.OPTI_STR_SLOW_HASH_SIMD_INIT;
		case opti_type.OPTI_TYPE_EARLY_SKIP:
				return ModernizedCProgram.OPTI_STR_EARLY_SKIP;
		case opti_type.OPTI_TYPE_USES_BITS_16:
				return ModernizedCProgram.OPTI_STR_USES_BITS_16;
		case opti_type.OPTI_TYPE_APPENDED_SALT:
				return ModernizedCProgram.OPTI_STR_APPENDED_SALT;
		case opti_type.OPTI_TYPE_USES_BITS_8:
				return ModernizedCProgram.OPTI_STR_USES_BITS_8;
		case opti_type.OPTI_TYPE_NOT_ITERATED:
				return ModernizedCProgram.OPTI_STR_NOT_ITERATED;
		case opti_type.OPTI_TYPE_BRUTE_FORCE:
				return ModernizedCProgram.OPTI_STR_BRUTE_FORCE;
		case opti_type.OPTI_TYPE_SLOW_HASH_SIMD_COMP:
				return ModernizedCProgram.OPTI_STR_SLOW_HASH_SIMD_COMP;
		case opti_type.OPTI_TYPE_OPTIMIZED_KERNEL:
				return ModernizedCProgram.OPTI_STR_OPTIMIZED_KERNEL;
		case opti_type.OPTI_TYPE_PREPENDED_SALT:
				return ModernizedCProgram.OPTI_STR_PREPENDED_SALT;
		case opti_type.OPTI_TYPE_MEET_IN_MIDDLE:
				return ModernizedCProgram.OPTI_STR_MEET_IN_MIDDLE;
		case opti_type.OPTI_TYPE_USES_BITS_64:
				return ModernizedCProgram.OPTI_STR_USES_BITS_64;
		case opti_type.OPTI_TYPE_PRECOMPUTE_INIT:
				return ModernizedCProgram.OPTI_STR_PRECOMPUTE_INIT;
		case opti_type.OPTI_TYPE_SINGLE_SALT:
				return ModernizedCProgram.OPTI_STR_SINGLE_SALT;
		case opti_type.OPTI_TYPE_RAW_HASH:
				return ModernizedCProgram.OPTI_STR_RAW_HASH;
		case opti_type.OPTI_TYPE_ZERO_BYTE:
				return ModernizedCProgram.OPTI_STR_ZERO_BYTE;
		case opti_type.OPTI_TYPE_NOT_SALTED:
				return ModernizedCProgram.OPTI_STR_NOT_SALTED;
		case opti_type.OPTI_TYPE_SINGLE_HASH:
				return ModernizedCProgram.OPTI_STR_SINGLE_HASH;
		case opti_type.OPTI_TYPE_USES_BITS_32:
				return ModernizedCProgram.OPTI_STR_USES_BITS_32;
		}
		return ((Object)0);
	}
	public static Object strparser(Object parser_status) {
		switch (parser_status) {
		case parser_rc.PARSER_LUKS_KEY_SIZE:
				return ModernizedCProgram.PA_027;
		case parser_rc.PARSER_HCCAPX_VERSION:
				return ModernizedCProgram.PA_032;
		case parser_rc.PARSER_COMMENT:
				return ModernizedCProgram.PA_001;
		case parser_rc.PARSER_SIGNATURE_UNMATCHED:
				return ModernizedCProgram.PA_010;
		case parser_rc.PARSER_LUKS_FILE_SIZE:
				return ModernizedCProgram.PA_021;
		case parser_rc.PARSER_SALT_ITERATION:
				return ModernizedCProgram.PA_008;
		case parser_rc.PARSER_GLOBAL_ZERO:
				return ModernizedCProgram.PA_002;
		case parser_rc.PARSER_SIP_AUTH_DIRECTIVE:
				return ModernizedCProgram.PA_017;
		case parser_rc.PARSER_TOKEN_ENCODING:
				return ModernizedCProgram.PA_034;
		case parser_rc.PARSER_INSUFFICIENT_ENTROPY:
				return ModernizedCProgram.PA_036;
		case parser_rc.PARSER_PSAFE3_FILE_SIZE:
				return ModernizedCProgram.PA_014;
		case parser_rc.PARSER_GLOBAL_LENGTH:
				return ModernizedCProgram.PA_003;
		case parser_rc.PARSER_PKZIP_CT_UNMATCHED:
				return ModernizedCProgram.PA_037;
		case parser_rc.PARSER_LUKS_HASH_CIPHER:
				return ModernizedCProgram.PA_030;
		case parser_rc.PARSER_TOKEN_LENGTH:
				return ModernizedCProgram.PA_035;
		case parser_rc.PARSER_LUKS_HASH_TYPE:
				return ModernizedCProgram.PA_026;
		case parser_rc.PARSER_HASH_ENCODING:
				return ModernizedCProgram.PA_019;
		case parser_rc.PARSER_LUKS_KEY_DISABLED:
				return ModernizedCProgram.PA_028;
		case parser_rc.PARSER_HCCAPX_EAPOL_LEN:
				return ModernizedCProgram.PA_012;
		case parser_rc.PARSER_SALT_LENGTH:
				return ModernizedCProgram.PA_006;
		case parser_rc.PARSER_HCCAPX_MESSAGE_PAIR:
				return ModernizedCProgram.PA_033;
		case parser_rc.PARSER_SALT_ENCODING:
				return ModernizedCProgram.PA_020;
		case parser_rc.PARSER_VC_FILE_SIZE:
				return ModernizedCProgram.PA_016;
		case parser_rc.PARSER_SALT_VALUE:
				return ModernizedCProgram.PA_007;
		case parser_rc.PARSER_LUKS_MAGIC:
				return ModernizedCProgram.PA_022;
		case parser_rc.PARSER_LUKS_CIPHER_TYPE:
				return ModernizedCProgram.PA_024;
		case parser_rc.PARSER_HASH_LENGTH:
				return ModernizedCProgram.PA_004;
		case parser_rc.PARSER_HCCAPX_FILE_SIZE:
				return ModernizedCProgram.PA_011;
		case parser_rc.PARSER_LUKS_CIPHER_MODE:
				return ModernizedCProgram.PA_025;
		case parser_rc.PARSER_HASH_FILE:
				return ModernizedCProgram.PA_018;
		case parser_rc.PARSER_HCCAPX_SIGNATURE:
				return ModernizedCProgram.PA_031;
		case parser_rc.PARSER_TC_FILE_SIZE:
				return ModernizedCProgram.PA_015;
		case parser_rc.PARSER_OK:
				return ModernizedCProgram.PA_000;
		case parser_rc.PARSER_LUKS_VERSION:
				return ModernizedCProgram.PA_023;
		case parser_rc.PARSER_PSAFE2_FILE_SIZE:
				return ModernizedCProgram.PA_013;
		case parser_rc.PARSER_LUKS_KEY_STRIPES:
				return ModernizedCProgram.PA_029;
		case parser_rc.PARSER_SEPARATOR_UNMATCHED:
				return ModernizedCProgram.PA_009;
		case parser_rc.PARSER_HASH_VALUE:
				return ModernizedCProgram.PA_005;
		}
		return ModernizedCProgram.PA_255;
	}
	public static int rounds_count_length(Object input_buf, Object input_len) {
		// 9 is minimum because of "rounds=X$"if (input_len >= 9) {
			byte rounds = "rounds=";
			if (.memcmp(input_buf, rounds, 7) == 0) {
				byte next_pos = .strchr(input_buf + 8, (byte)'$');
				if (next_pos == ((Object)0)) {
					return -1;
				} 
				int rounds_len = next_pos - input_buf;
				return rounds_len;
			} 
		} 
		return -1;
	}
	public static boolean generic_salt_decode(Object hashconfig, Object in_buf, Object in_len, Object out_buf, int out_len) {
		u32[] tmp_u32 = new u32[]{0};
		u8 tmp_u8 = (u8)tmp_u32;
		// 512 = 2 * 256 -- (2 * because of hex), 256 because of maximum salt length in salt_tif (in_len > 512) {
			return 0;
		} 
		int tmp_len = 0;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			if (in_len < (int)(hashconfig.getSalt_min() * 2)) {
				return 0;
			} 
			if (in_len > (int)(hashconfig.getSalt_max() * 2)) {
				return 0;
			} 
			if (in_len & 1) {
				return 0;
			} 
			for (int i = 0;
			int j = 0;
			 j < in_len; ) {
				u8 p0 = in_buf[j + 0];
				u8 p1 = in_buf[j + 1];
				tmp_u8[i] = ModernizedCProgram.hex_convert(p1) << 0;
				tmp_u8[i] |=  ModernizedCProgram.hex_convert(p0) << 4;
			}
			tmp_len = in_len / 2;
		}  else if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_BASE64) {
			if (in_len < (int)(((hashconfig.getSalt_min() * 8) / 6) + 0)) {
				return 0;
			} 
			if (in_len > (int)(((hashconfig.getSalt_max() * 8) / 6) + 3)) {
				return 0;
			} 
			tmp_len = ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, in_buf, in_len, tmp_u8);
		} else {
				if (in_len < (int)hashconfig.getSalt_min()) {
					return 0;
				} 
				if (in_len > (int)hashconfig.getSalt_max()) {
					return 0;
				} 
				.memcpy(tmp_u8, in_buf, in_len);
				tmp_len = in_len;
		} 
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_UTF16LE) {
			if (tmp_len >= 128) {
				return 0;
			} 
			for (int i = 64 - 1;
			 i >= 1; i -= 2) {
				u32 v = tmp_u32[i / 2];
				tmp_u32[i - 0] = ((v >> 8) & -1024) | ((v >> 16) & -1024);
				tmp_u32[i - 1] = ((v << 8) & -1024) | ((v >> 0) & -1024);
			}
			tmp_len = tmp_len * 2;
		} 
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_LOWER) {
			ModernizedCProgram.lowercase(tmp_u8, tmp_len);
		} 
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_UPPER) {
			ModernizedCProgram.uppercase(tmp_u8, tmp_len);
		} 
		int tmp2_len = tmp_len;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_ADD80) {
			if (tmp2_len >= 256) {
				return 0;
			} 
			tmp_u8[tmp2_len++] = -1024;
		} 
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_ADD01) {
			if (tmp2_len >= 256) {
				return 0;
			} 
			tmp_u8[tmp2_len++] = -1024;
		} 
		.memcpy(out_buf, tmp_u8, tmp2_len);
		out_len = tmp_len;
		return 1;
	}
	public static int generic_salt_encode(Object hashconfig, Object in_buf, Object in_len, Object out_buf) {
		u32[] tmp_u32 = new u32[]{0};
		u8 tmp_u8 = (u8)tmp_u32;
		.memcpy(tmp_u8, in_buf, in_len);
		int tmp_len = in_len;
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_UTF16LE) {
			for (int i = 0;
			int j = 0;
			 j < in_len; ) {
				u8 p = tmp_u8[j];
				tmp_u8[i] = p;
			}
			tmp_len = tmp_len / 2;
		} 
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_HEX) {
			for (int i = 0;
			int j = 0;
			 i < in_len; ) {
				ModernizedCProgram.u8_to_hex(in_buf[i], tmp_u8 + j);
			}
			tmp_len = in_len * 2;
		}  else if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_ST_BASE64) {
			tmp_len = ModernizedCProgram.base64_encode(ModernizedCProgram.int_to_base64, in_buf, in_len, tmp_u8);
		} 
		.memcpy(out_buf, tmp_u8, tmp_len);
		return tmp_len;
	}
	public static void netbsd_sha1crypt_decode(Object digest, Object buf, Object additional_byte) {
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[2] = (l >> 0) & -1024;
		digest[1] = (l >> 8) & -1024;
		digest[0] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[5] = (l >> 0) & -1024;
		digest[4] = (l >> 8) & -1024;
		digest[3] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[8] = (l >> 0) & -1024;
		digest[7] = (l >> 8) & -1024;
		digest[6] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[11] = (l >> 0) & -1024;
		digest[10] = (l >> 8) & -1024;
		digest[9] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[14] = (l >> 0) & -1024;
		digest[13] = (l >> 8) & -1024;
		digest[12] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[22]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[23]) << 18;
		digest[17] = (l >> 0) & -1024;
		digest[16] = (l >> 8) & -1024;
		digest[15] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[24]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[25]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[26]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[27]) << 18;
		additional_byte[0] = (l >> 0) & -1024;
		digest[19] = (l >> 8) & -1024;
		digest[18] = (l >> 16) & -1024;
	}
	public static void netbsd_sha1crypt_encode(Object digest, Object additional_byte, Object buf) {
		int l;
		l = (digest[2] << 0) | (digest[1] << 8) | (digest[0] << 16);
		buf[0] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[1] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[2] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[3] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[5] << 0) | (digest[4] << 8) | (digest[3] << 16);
		buf[4] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[5] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[6] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[7] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[8] << 0) | (digest[7] << 8) | (digest[6] << 16);
		buf[8] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[9] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[10] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[11] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[11] << 0) | (digest[10] << 8) | (digest[9] << 16);
		buf[12] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[13] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[14] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[15] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[14] << 0) | (digest[13] << 8) | (digest[12] << 16);
		buf[16] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[17] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[18] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[19] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[17] << 0) | (digest[16] << 8) | (digest[15] << 16);
		buf[20] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[21] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[22] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[23] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (additional_byte << 0) | (digest[19] << 8) | (digest[18] << 16);
		buf[24] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[25] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[26] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[27] = ModernizedCProgram.int_to_itoa64(l & -1024);
		buf[28] = 0;
	}
	public static void AES128_decrypt_cbc(Object key, Object iv, Object in, Object out) {
		AES_KEY skey = new AES_KEY();
		.aes128_set_decrypt_key(skey.getRdk(), key, (u32)ModernizedCProgram.te0, (u32)ModernizedCProgram.te1, (u32)ModernizedCProgram.te2, (u32)ModernizedCProgram.te3, (u32)ModernizedCProgram.td0, (u32)ModernizedCProgram.td1, (u32)ModernizedCProgram.td2, (u32)ModernizedCProgram.td3);
		u32[] _iv = new u32[]{0};
		_iv[0] = iv[0];
		_iv[1] = iv[1];
		_iv[2] = iv[2];
		_iv[3] = iv[3];
		for (int i = 0;
		 i < 16; i += 4) {
			u32[] _in = new u32[]{0};
			u32[] _out = new u32[]{0};
			_in[0] = in[i + 0];
			_in[1] = in[i + 1];
			_in[2] = in[i + 2];
			_in[3] = in[i + 3];
			.aes128_decrypt(skey.getRdk(), _in, _out, (u32)ModernizedCProgram.td0, (u32)ModernizedCProgram.td1, (u32)ModernizedCProgram.td2, (u32)ModernizedCProgram.td3, (u32)ModernizedCProgram.td4);
			_out[0] ^=  _iv[0];
			_out[1] ^=  _iv[1];
			_out[2] ^=  _iv[2];
			_out[3] ^=  _iv[3];
			out[i + 0] = _out[0];
			out[i + 1] = _out[1];
			out[i + 2] = _out[2];
			out[i + 3] = _out[3];
			_iv[0] = _in[0];
			_iv[1] = _in[1];
			_iv[2] = _in[2];
			_iv[3] = _in[3];
		}
	}
	public static void juniper_decrypt_hash(Object in, Object in_len, Object out) {
		// base64 decodeu8[] base64_buf = new u8[]{0};
		ModernizedCProgram.base64_decode(ModernizedCProgram.base64_to_int, (u8)in, in_len, base64_buf)// iv stuff;// iv stuff
		u32[] juniper_iv = new u32[]{0};
		.memcpy(juniper_iv, base64_buf, 12);
		.memcpy(out, juniper_iv, 12)// reversed key;// reversed key
		u32[] juniper_key = new u32[]{0};
		juniper_key[0] = ModernizedCProgram.byte_swap_32(-1024);
		juniper_key[1] = ModernizedCProgram.byte_swap_32(-1024);
		juniper_key[2] = ModernizedCProgram.byte_swap_32(-1024);
		juniper_key[3] = ModernizedCProgram.byte_swap_32(-1024)// AES decrypt;// AES decrypt
		u32 in_ptr = (u32)(base64_buf + 12);
		u32 out_ptr = (u32)(out + 12);
		ModernizedCProgram.AES128_decrypt_cbc(juniper_key, juniper_iv, in_ptr, out_ptr);
	}
	public static void md5crypt_decode(Object digest, Object buf) {
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[0] = (l >> 16) & -1024;
		digest[6] = (l >> 8) & -1024;
		digest[12] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[1] = (l >> 16) & -1024;
		digest[7] = (l >> 8) & -1024;
		digest[13] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[2] = (l >> 16) & -1024;
		digest[8] = (l >> 8) & -1024;
		digest[14] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[3] = (l >> 16) & -1024;
		digest[9] = (l >> 8) & -1024;
		digest[15] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[4] = (l >> 16) & -1024;
		digest[10] = (l >> 8) & -1024;
		digest[5] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		digest[11] = (l >> 0) & -1024/* uses OPTS_TYPE_HASH_COPY
		static void md5crypt_encode (const u8 digest[16], u8 buf[22])
		{
		  int l;
		
		  l = (digest[ 0] << 16) | (digest[ 6] << 8) | (digest[12] << 0);
		
		  buf[ 0] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[ 1] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[ 2] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[ 3] = int_to_itoa64 (l & 0x3f); //l >>= 6;
		
		  l = (digest[ 1] << 16) | (digest[ 7] << 8) | (digest[13] << 0);
		
		  buf[ 4] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[ 5] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[ 6] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[ 7] = int_to_itoa64 (l & 0x3f); //l >>= 6;
		
		  l = (digest[ 2] << 16) | (digest[ 8] << 8) | (digest[14] << 0);
		
		  buf[ 8] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[ 9] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[10] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[11] = int_to_itoa64 (l & 0x3f); //l >>= 6;
		
		  l = (digest[ 3] << 16) | (digest[ 9] << 8) | (digest[15] << 0);
		
		  buf[12] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[13] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[14] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[15] = int_to_itoa64 (l & 0x3f); //l >>= 6;
		
		  l = (digest[ 4] << 16) | (digest[10] << 8) | (digest[ 5] << 0);
		
		  buf[16] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[17] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[18] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[19] = int_to_itoa64 (l & 0x3f); //l >>= 6;
		
		  l = (digest[11] << 0);
		
		  buf[20] = int_to_itoa64 (l & 0x3f); l >>= 6;
		  buf[21] = int_to_itoa64 (l & 0x3f); //l >>= 6;
		}
		*/;
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[0] = (l >> 16) & -1024;
		digest[6] = (l >> 8) & -1024;
		digest[12] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[1] = (l >> 16) & -1024;
		digest[7] = (l >> 8) & -1024;
		digest[13] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[2] = (l >> 16) & -1024;
		digest[8] = (l >> 8) & -1024;
		digest[14] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[3] = (l >> 16) & -1024;
		digest[9] = (l >> 8) & -1024;
		digest[15] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[4] = (l >> 16) & -1024;
		digest[10] = (l >> 8) & -1024;
		digest[5] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		digest[11] = (l >> 0) & -1024;
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[0] = (l >> 16) & -1024;
		digest[6] = (l >> 8) & -1024;
		digest[12] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[1] = (l >> 16) & -1024;
		digest[7] = (l >> 8) & -1024;
		digest[13] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[2] = (l >> 16) & -1024;
		digest[8] = (l >> 8) & -1024;
		digest[14] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[3] = (l >> 16) & -1024;
		digest[9] = (l >> 8) & -1024;
		digest[15] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[4] = (l >> 16) & -1024;
		digest[10] = (l >> 8) & -1024;
		digest[5] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		digest[11] = (l >> 0) & -1024;
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[0] = (l >> 16) & -1024;
		digest[6] = (l >> 8) & -1024;
		digest[12] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[1] = (l >> 16) & -1024;
		digest[7] = (l >> 8) & -1024;
		digest[13] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[2] = (l >> 16) & -1024;
		digest[8] = (l >> 8) & -1024;
		digest[14] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[3] = (l >> 16) & -1024;
		digest[9] = (l >> 8) & -1024;
		digest[15] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[4] = (l >> 16) & -1024;
		digest[10] = (l >> 8) & -1024;
		digest[5] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		digest[11] = (l >> 0) & -1024;
	}
	/* this assumes a is not negative */
	/* ========================================================================= */
	public static Object adler32_z(Object adler, Object buf, Object len) {
		long sum2;
		int n;
		sum2 = (adler >> 16) & /* split Adler-32 into component sums */-1024;
		adler &=  -1024;
		if (len == /* in case user likes doing a byte at a time, keep it fast */1) {
			adler += buf[0];
			if (adler >= -1024) {
				adler -= -1024;
			} 
			sum2 += adler;
			if (sum2 >= -1024) {
				sum2 -= -1024;
			} 
			return adler | (sum2 << 16);
		} 
		if (buf == /* initial Adler-32 value (deferred check for len == 1 speed) */0) {
			return -1024;
		} 
		if (len < /* in case short lengths are provided, keep it somewhat fast */16) {
			while (len--) {
				adler += buf++;
				sum2 += adler;
			}
			if (adler >= -1024) {
				adler -= -1024;
			} 
			sum2 %= /* only added so many BASE's */-1024;
			return adler | (sum2 << 16);
		} 
		while (len >= /* do length NMAX blocks -- requires just one modulo operation */5552) {
			len -= 5552;
			n = 5552 / /* NMAX is divisible by 16 */16;
			do {
				{ 
					adler += (buf)[0];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[0 + 1];
					sum2 += adler;
				}
				;
				;
				{ 
					adler += (buf)[0 + 2];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[0 + 2 + 1];
					sum2 += adler;
				}
				;
				;
				;
				{ 
					adler += (buf)[0 + 4];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[0 + 4 + 1];
					sum2 += adler;
				}
				;
				;
				{ 
					adler += (buf)[0 + 4 + 2];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[0 + 4 + 2 + 1];
					sum2 += adler;
				}
				;
				;
				;
				;
				{ 
					adler += (buf)[8];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[8 + 1];
					sum2 += adler;
				}
				;
				;
				{ 
					adler += (buf)[8 + 2];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[8 + 2 + 1];
					sum2 += adler;
				}
				;
				;
				;
				{ 
					adler += (buf)[8 + 4];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[8 + 4 + 1];
					sum2 += adler;
				}
				;
				;
				{ 
					adler += (buf)[8 + 4 + 2];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[8 + 4 + 2 + 1];
					sum2 += /* 16 sums unrolled */adler;
				}
				;
				;
				;
				;
				;
				buf += 16;
			} while (--n);
			adler %= -1024;
			sum2 %= -1024;
		}
		if (/* do remaining bytes (less than NMAX, still just one modulo) *//* avoid modulos if none remaining */len) {
			while (len >= 16) {
				len -= 16;
				{ 
					adler += (buf)[0];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[0 + 1];
					sum2 += adler;
				}
				;
				;
				{ 
					adler += (buf)[0 + 2];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[0 + 2 + 1];
					sum2 += adler;
				}
				;
				;
				;
				{ 
					adler += (buf)[0 + 4];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[0 + 4 + 1];
					sum2 += adler;
				}
				;
				;
				{ 
					adler += (buf)[0 + 4 + 2];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[0 + 4 + 2 + 1];
					sum2 += adler;
				}
				;
				;
				;
				;
				{ 
					adler += (buf)[8];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[8 + 1];
					sum2 += adler;
				}
				;
				;
				{ 
					adler += (buf)[8 + 2];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[8 + 2 + 1];
					sum2 += adler;
				}
				;
				;
				;
				{ 
					adler += (buf)[8 + 4];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[8 + 4 + 1];
					sum2 += adler;
				}
				;
				;
				{ 
					adler += (buf)[8 + 4 + 2];
					sum2 += adler;
				}
				;
				{ 
					adler += (buf)[8 + 4 + 2 + 1];
					sum2 += adler;
				}
				;
				;
				;
				;
				;
				buf += 16;
			}
			while (len--) {
				adler += buf++;
				sum2 += adler;
			}
			adler %= -1024;
			sum2 %= -1024;
		} 
		return adler | (sum2 << /* return recombined sums */16);
	}
	/* ========================================================================= */
	public static Object adler32(Object adler, Object buf, Object len) {
		return ModernizedCProgram.adler32_z(adler, buf, len);
	}
	/* adler32.c -- compute the Adler-32 checksum of a data stream
	 * Copyright (C) 1995-2011, 2016 Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */
	/* @(#) $Id$ */
	/* ========================================================================= */
	public static Object adler32_combine_(Object adler1, Object adler2, long len2) {
		long sum1;
		long sum2;
		int rem;
		if (len2 < /* for negative len, return invalid adler32 as a clue for debugging */0) {
			return -1024;
		} 
		len2 %= /* the derivation of this formula is left as an exercise for the reader *//* assumes len2 >= 0 */-1024;
		rem = (int)len2;
		sum1 = adler1 & -1024;
		sum2 = rem * sum1;
		sum2 %= -1024;
		sum1 += (adler2 & -1024) + -1024 - 1;
		sum2 += ((adler1 >> 16) & -1024) + ((adler2 >> 16) & -1024) + -1024 - rem;
		if (sum1 >= -1024) {
			sum1 -= -1024;
		} 
		if (sum1 >= -1024) {
			sum1 -= -1024;
		} 
		if (sum2 >= ((long)-1024 << 1)) {
			sum2 -= ((long)-1024 << 1);
		} 
		if (sum2 >= -1024) {
			sum2 -= -1024;
		} 
		return sum1 | (sum2 << 16);
	}
	/* largest prime smaller than 65536 */
	/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
	/* use NO_DIVIDE if your processor does not do division in hardware --
	   try it both ways to see which is faster */
	/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
	   (thank you to John Reiser for pointing this out) */
	/* ========================================================================= */
	public static Object adler32_combine(Object adler1, Object adler2, long len2) {
		return ModernizedCProgram.adler32_combine_(adler1, adler2, len2);
	}
	public static Object adler32_combine64(Object adler1, Object adler2, long len2) {
		return ModernizedCProgram.adler32_combine_(adler1, adler2, len2);
	}
	// 4*charset, 1*mask
	public static int sp_comp_val(Object p1, Object p2) {
		hcstat_table_t b1 = (hcstat_table_t)p1;
		hcstat_table_t b2 = (hcstat_table_t)p2;
		u64 v1 = b1.getVal();
		u64 v2 = b2.getVal();
		if (v1 < v2) {
			return 1;
		} 
		if (v1 > v2) {
			return -1;
		} 
		return 0;
	}
	public static int mp_css_append_salt(hashcat_ctx hashcat_ctx, salt salt_buf) {
		mask_ctx generatedMask_ctx = hashcat_ctx.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		Object generatedSalt_len = salt_buf.getSalt_len();
		u32 salt_len = generatedSalt_len;
		Object generatedSalt_buf = salt_buf.getSalt_buf();
		u8 salt_buf_ptr = (u8)generatedSalt_buf;
		Object generatedCss_cnt = mask_ctx.getCss_cnt();
		if ((generatedCss_cnt + salt_len) > 256) {
			return -1;
		} 
		 generatedCss_buf = mask_ctx.getCss_buf();
		for (u32 i = 0;
		u32 j = generatedCss_cnt;
		 i < salt_len; ) {
			generatedCss_buf[j].getCs_buf()[0] = salt_buf_ptr[i];
			generatedCss_buf[j].setCs_len(1);
			generatedCss_cnt++;
		}
		return 0;
	}
	public static int mp_css_to_uniq_tbl(hashcat_ctx hashcat_ctx, Object css_cnt,  css, Object uniq_tbls) {
		if (css_cnt > /* generates a lookup table where key is the char itself for fastest possible lookup performance */256) {
			hashcat_ctx.event_log_error("Mask length is too long.");
			return -1;
		} 
		for (u32 css_pos = 0;
		 css_pos < css_cnt; css_pos++) {
			u32 uniq_tbl = uniq_tbls[css_pos];
			u32 cs_buf = css[css_pos].getCs_buf();
			u32 cs_len = css[css_pos].getCs_len();
			for (u32 cs_pos = 0;
			 cs_pos < cs_len; cs_pos++) {
				u32 c = cs_buf[cs_pos] & -1024;
				uniq_tbl[c] = 1;
			}
		}
		return 0;
	}
	public static int mp_add_cs_buf(hashcat_ctx hashcat_ctx, Object in_buf, Object in_len,  css, Object css_cnt) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		cs_t cs = css[css_cnt];
		size_t css_uniq_sz = -1024 * ;
		u32 css_uniq = (u32)ModernizedCProgram.hcmalloc(css_uniq_sz);
		size_t i = new size_t();
		Object generatedCs_len = cs.getCs_len();
		Object generatedCs_buf = cs.getCs_buf();
		for (i = 0; i < generatedCs_len; i++) {
			u32 u = generatedCs_buf[i];
			css_uniq[u] = 1;
		}
		for (i = 0; i < in_len; i++) {
			u32 u = in_buf[i] & -1024;
			if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_UPPER) {
				u = (u32).toupper(u);
			} 
			if (css_uniq[u] == 1) {
				continue;
			} 
			css_uniq[u] = 1;
			generatedCs_buf[generatedCs_len] = u;
			generatedCs_len++;
		}
		ModernizedCProgram.hcfree(css_uniq);
		return 0;
	}
	public static int mp_expand(hashcat_ctx hashcat_ctx, Object in_buf, Object in_len,  mp_sys,  mp_usr, Object mp_usr_offset, int interpret) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		size_t in_pos = new size_t();
		for (in_pos = 0; in_pos < in_len; in_pos++) {
			u32 p0 = in_buf[in_pos] & -1024;
			if (interpret == 1 && p0 == (byte)'?') {
				in_pos++;
				if (in_pos == in_len) {
					hashcat_ctx.event_log_error("Syntax error in mask: %s", in_buf);
					return -1;
				} 
				u32 p1 = in_buf[in_pos] & -1024;
				int rc = 0;
				switch (p1) {
				case (byte)'l':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[0].getCs_buf(), mp_sys[0].getCs_len(), mp_usr, mp_usr_offset);
						break;
				case (byte)'s':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[3].getCs_buf(), mp_sys[3].getCs_len(), mp_usr, mp_usr_offset);
						break;
				case (byte)'a':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[4].getCs_buf(), mp_sys[4].getCs_len(), mp_usr, mp_usr_offset);
						break;
				case (byte)'4':
						if (mp_usr[3].getCs_len() == 0) {
							hashcat_ctx.event_log_error("Custom-charset 4 is undefined.");
							return -1;
						} 
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_usr[3].getCs_buf(), mp_usr[3].getCs_len(), mp_usr, mp_usr_offset);
						break;
				case (byte)'1':
						if (mp_usr[0].getCs_len() == 0) {
							hashcat_ctx.event_log_error("Custom-charset 1 is undefined.");
							return -1;
						} 
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_usr[0].getCs_buf(), mp_usr[0].getCs_len(), mp_usr, mp_usr_offset);
						break;
				case (byte)'?':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, p0, 1, mp_usr, mp_usr_offset);
						break;
				case (byte)'2':
						if (mp_usr[1].getCs_len() == 0) {
							hashcat_ctx.event_log_error("Custom-charset 2 is undefined.");
							return -1;
						} 
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_usr[1].getCs_buf(), mp_usr[1].getCs_len(), mp_usr, mp_usr_offset);
						break;
				case (byte)'3':
						if (mp_usr[2].getCs_len() == 0) {
							hashcat_ctx.event_log_error("Custom-charset 3 is undefined.");
							return -1;
						} 
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_usr[2].getCs_buf(), mp_usr[2].getCs_len(), mp_usr, mp_usr_offset);
						break;
				case (byte)'H':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[7].getCs_buf(), mp_sys[7].getCs_len(), mp_usr, mp_usr_offset);
						break;
				case (byte)'u':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[1].getCs_buf(), mp_sys[1].getCs_len(), mp_usr, mp_usr_offset);
						break;
				case (byte)'d':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[2].getCs_buf(), mp_sys[2].getCs_len(), mp_usr, mp_usr_offset);
						break;
				case (byte)'b':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[5].getCs_buf(), mp_sys[5].getCs_len(), mp_usr, mp_usr_offset);
						break;
				case (byte)'h':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[6].getCs_buf(), mp_sys[6].getCs_len(), mp_usr, mp_usr_offset);
						break;
				default:
						hashcat_ctx.event_log_error("Syntax error in mask: %s", in_buf);
						return -1;
				}
				if (rc == -1) {
					return -1;
				} 
			} else {
					if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_HEX) {
						in_pos++;
						if (in_pos == in_len) {
							hashcat_ctx.event_log_error("The hex-charset option expects exactly 2 hexadecimal chars. Failed mask: %s", in_buf);
							return -1;
						} 
						u32 p1 = in_buf[in_pos] & -1024;
						if ((ModernizedCProgram.is_valid_hex_char((u8)p0) == 0) || (ModernizedCProgram.is_valid_hex_char((u8)p1) == 0)) {
							hashcat_ctx.event_log_error("Invalid hex character detected in mask %s", in_buf);
							return -1;
						} 
						u32 chr = 0;
						chr = (u32)ModernizedCProgram.hex_convert((u8)p1) << 0;
						chr |=  (u32)ModernizedCProgram.hex_convert((u8)p0) << 4;
						int rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, chr, 1, mp_usr, mp_usr_offset);
						if (rc == -1) {
							return -1;
						} 
					} else {
							u32 chr = p0;
							int rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, chr, 1, mp_usr, mp_usr_offset);
							if (rc == -1) {
								return -1;
							} 
					} 
			} 
		}
		return 0;
	}
	public static int mp_gen_css(hashcat_ctx hashcat_ctx, Byte mask_buf, Object mask_len,  mp_sys,  mp_usr,  css_buf, Object css_cnt) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		.memset(css_buf, 0, 256 * );
		size_t mask_pos = new size_t();
		size_t css_pos = new size_t();
		for (; mask_pos < mask_len; ) {
			byte p0 = mask_buf[mask_pos];
			if (p0 == (byte)'?') {
				mask_pos++;
				if (mask_pos == mask_len) {
					hashcat_ctx.event_log_error("Syntax error in mask: %s", mask_buf);
					return -1;
				} 
				byte p1 = mask_buf[mask_pos];
				u32 chr = (u32)p1;
				int rc = 0;
				switch (p1) {
				case (byte)'l':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[0].getCs_buf(), mp_sys[0].getCs_len(), css_buf, css_pos);
						break;
				case (byte)'H':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[7].getCs_buf(), mp_sys[7].getCs_len(), css_buf, css_pos);
						break;
				case (byte)'2':
						if (mp_usr[1].getCs_len() == 0) {
							hashcat_ctx.event_log_error("Custom-charset 2 is undefined.");
							return -1;
						} 
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_usr[1].getCs_buf(), mp_usr[1].getCs_len(), css_buf, css_pos);
						break;
				case (byte)'1':
						if (mp_usr[0].getCs_len() == 0) {
							hashcat_ctx.event_log_error("Custom-charset 1 is undefined.");
							return -1;
						} 
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_usr[0].getCs_buf(), mp_usr[0].getCs_len(), css_buf, css_pos);
						break;
				case (byte)'?':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, chr, 1, css_buf, css_pos);
						break;
				case (byte)'u':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[1].getCs_buf(), mp_sys[1].getCs_len(), css_buf, css_pos);
						break;
				case (byte)'a':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[4].getCs_buf(), mp_sys[4].getCs_len(), css_buf, css_pos);
						break;
				case (byte)'s':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[3].getCs_buf(), mp_sys[3].getCs_len(), css_buf, css_pos);
						break;
				case (byte)'b':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[5].getCs_buf(), mp_sys[5].getCs_len(), css_buf, css_pos);
						break;
				case (byte)'h':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[6].getCs_buf(), mp_sys[6].getCs_len(), css_buf, css_pos);
						break;
				case (byte)'4':
						if (mp_usr[3].getCs_len() == 0) {
							hashcat_ctx.event_log_error("Custom-charset 4 is undefined.");
							return -1;
						} 
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_usr[3].getCs_buf(), mp_usr[3].getCs_len(), css_buf, css_pos);
						break;
				case (byte)'d':
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_sys[2].getCs_buf(), mp_sys[2].getCs_len(), css_buf, css_pos);
						break;
				case (byte)'3':
						if (mp_usr[2].getCs_len() == 0) {
							hashcat_ctx.event_log_error("Custom-charset 3 is undefined.");
							return -1;
						} 
						rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, mp_usr[2].getCs_buf(), mp_usr[2].getCs_len(), css_buf, css_pos);
						break;
				default:
						hashcat_ctx.event_log_error("Syntax error in mask: %s", mask_buf);
						return -1;
				}
				if (rc == -1) {
					return -1;
				} 
			} else {
					if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_PT_HEX) {
						mask_pos++;
						if (mask_pos == mask_len) {
							hashcat_ctx.event_log_error("The hex-charset option expects exactly 2 hexadecimal chars. Failed mask: %s", mask_buf);
							return -1;
						} 
						byte p1 = mask_buf[mask_pos];
						if ((ModernizedCProgram.is_valid_hex_char((u8)p0) == 0) || (ModernizedCProgram.is_valid_hex_char((u8)p1) == 0)) {
							hashcat_ctx.event_log_error("Invalid hex character detected in mask %s", mask_buf);
							return -1;
						} 
						u32 chr = 0;
						chr |=  (u32)ModernizedCProgram.hex_convert((u8)p1) << 0;
						chr |=  (u32)ModernizedCProgram.hex_convert((u8)p0) << 4;
						int rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, chr, 1, css_buf, css_pos);
						if (rc == -1) {
							return -1;
						} 
					} else {
							u32 chr = (u32)p0;
							int rc = ModernizedCProgram.mp_add_cs_buf(hashcat_ctx, chr, 1, css_buf, css_pos);
							if (rc == -1) {
								return -1;
							} 
					} 
			} 
		}
		if (css_pos == 0) {
			hashcat_ctx.event_log_error("Invalid mask length (0).");
			return -1;
		} 
		css_cnt = css_pos;
		return 0;
	}
	public static void mp_setup_sys() {
		u32 pos = new u32();
		u32 chr = new u32();
		u32[] donec = new u32[]{0};
		for (; chr <= (byte)'z'; chr++) {
			donec[chr] = 1;
			mp_sys[0].getCs_buf()[pos++] = chr;
			mp_sys[0].setCs_len(pos);
		}
		for (; chr <= (byte)'Z'; chr++) {
			donec[chr] = 1;
			mp_sys[1].getCs_buf()[pos++] = chr;
			mp_sys[1].setCs_len(pos);
		}
		for (; chr <= (byte)'9'; chr++) {
			donec[chr] = 1;
			mp_sys[2].getCs_buf()[pos++] = chr;
			mp_sys[2].setCs_len(pos);
		}
		for (; chr <= -1024; chr++) {
			if (donec[chr]) {
				continue;
			} 
			mp_sys[3].getCs_buf()[pos++] = chr;
			mp_sys[3].setCs_len(pos);
		}
		for (; chr <= -1024; chr++) {
			mp_sys[4].getCs_buf()[pos++] = chr;
			mp_sys[4].setCs_len(pos);
		}
		for (; chr <= -1024; chr++) {
			mp_sys[5].getCs_buf()[pos++] = chr;
			mp_sys[5].setCs_len(pos);
		}
		for (; chr <= -1024; chr++) {
			mp_sys[6].getCs_buf()[pos++] = chr;
			mp_sys[6].setCs_len(pos);
		}
		for (; chr <= -1024; chr++) {
			mp_sys[6].getCs_buf()[pos++] = chr;
			mp_sys[6].setCs_len(pos);
		}
		for (; chr <= -1024; chr++) {
			mp_sys[7].getCs_buf()[pos++] = chr;
			mp_sys[7].setCs_len(pos);
		}
		for (; chr <= -1024; chr++) {
			mp_sys[7].getCs_buf()[pos++] = chr;
			mp_sys[7].setCs_len(pos);
		}
	}
	public static int mp_setup_usr(hashcat_ctx hashcat_ctx,  mp_sys,  mp_usr, Object buf, Object userindex) {
		HCFILE fp = new HCFILE();
		if (fp.hc_fopen(buf, "rb") == 0) {
			int rc = ModernizedCProgram.mp_expand(hashcat_ctx, buf, .strlen(buf), mp_sys, mp_usr, userindex, 1);
			if (rc == -1) {
				return -1;
			} 
		} else {
				byte[] mp_file = new byte[1024];
				size_t nread = fp.hc_fread(mp_file, 1,  - 1);
				if (!fp.hc_feof()) {
					hashcat_ctx.event_log_error("%s: Custom charset file is too large.", buf);
					fp.hc_fclose();
					return -1;
				} 
				fp.hc_fclose();
				if (nread == 0) {
					hashcat_ctx.event_log_error("%s: Custom charset file is empty.", buf);
					return -1;
				} 
				mp_file[nread] = 0;
				size_t len = ModernizedCProgram.superchop_with_length(mp_file, nread);
				if (len == 0) {
					hashcat_ctx.event_log_error("%s: Custom charset file is corrupted.", buf);
					return -1;
				} 
				int rc = ModernizedCProgram.mp_expand(hashcat_ctx, mp_file, len, mp_sys, mp_usr, userindex, 0);
				if (rc == -1) {
					return -1;
				} 
		} 
		return 0;
	}
	public static void mp_reset_usr(Object userindex) {
		mp_usr[userindex].setCs_len(0);
		.memset(mp_usr[userindex].getCs_buf(), 0, );
	}
	public static int sp_get_sum(Object start, Object stop, Object result) {
		u64 sum = 1;
		u32 i = new u32();
		for (i = start; i < stop; i++) {
			if (ModernizedCProgram.overflow_check_u64_mul(sum, root_css_buf[i].getCs_len()) == 0) {
				return -1;
			} 
			sum *= root_css_buf[i].getCs_len();
		}
		result = sum;
		return 0;
	}
	public static void sp_tbl_to_css( markov_table_buf,  root_css_buf,  markov_css_buf, Object threshold, Object uniq_tbls) {
		.memset(root_css_buf, 0, 256 * );
		.memset(markov_css_buf, 0, 256 * -1024 * /**
		   * Convert tables to css
		   */);
		Object generatedCs_len = cs.getCs_len();
		Object generatedCs_buf = cs.getCs_buf();
		for (u32 i = 0;
		 i < (256 * -1024); i++) {
			u32 pw_pos = i / -1024;
			cs_t cs = root_css_buf[pw_pos];
			if (generatedCs_len == threshold) {
				continue;
			} 
			u32 key = root_table_buf[i].getKey();
			if (uniq_tbls[pw_pos][key] == 0) {
				continue;
			} 
			generatedCs_buf[generatedCs_len] = key;
			generatedCs_len++;
		}
		for (u32 i = 0;
		 i < (256 * -1024 * -1024); i++) {
			u32 c = i / -1024;
			cs_t cs = markov_css_buf[c];
			if (generatedCs_len == threshold) {
				continue;
			} 
			u32 pw_pos = c / -1024;
			u32 key = markov_table_buf[i].getKey();
			if ((pw_pos + 1) < 256) {
				if (uniq_tbls[pw_pos + 1][key] == 0) {
					continue;
				} 
			} 
			generatedCs_buf[generatedCs_len] = key;
			generatedCs_len++;
		}
	}
	public static void sp_exec(Object ctx, Byte pw_buf,  markov_css_buf, Object start, Object stop) {
		u64 v = ctx;
		cs_t cs = root_css_buf[start];
		u32 i = new u32();
		Object generatedCs_len = cs.getCs_len();
		Object generatedCs_buf = cs.getCs_buf();
		for (i = start; i < stop; i++) {
			u64 m = v % generatedCs_len;
			u64 d = v / generatedCs_len;
			v = d;
			u32 k = generatedCs_buf[m];
			pw_buf[i - start] = (byte)k;
			cs = markov_css_buf[(i * -1024) + k];
		}
	}
	public static Object mp_get_length(Object mask, Object opts_type) {
		boolean ignore_next = false;
		u32 len = 0;
		size_t mask_len = .strlen(mask);
		for (size_t i = 0;
		 i < mask_len; i++) {
			if (ignore_next == true) {
				ignore_next = false;
			} else {
					if (mask[i] == (byte)'?') {
						ignore_next = true;
					} 
					if (opts_type & opts_type.OPTS_TYPE_PT_HEX) {
						ignore_next = true;
					} 
					len++;
			} 
		}
		return len;
	}
	public static Byte mask_ctx_parse_maskfile_find_mask(Byte line_buf, Object line_len) {
		byte mask_buf = line_buf;
		boolean escaped = false;
		for (size_t i = 0;
		 i < line_len; i++) {
			if (escaped == true) {
				escaped = false;
			} else {
					if (line_buf[i] == (byte)'\\') {
						escaped = true;
					}  else if (line_buf[i] == (byte)',') {
						mask_buf = line_buf + i + 1;
					} 
			} 
		}
		return mask_buf;
	}
	public static void LimitedSeqInStream_Init() {
		this.setLimit((UInt64)(Int64)-1);
		this.setProcessed(0);
		this.setFinished(0);
	}
	public static Object LimitedSeqInStream_Read(Object pp, Object data, Object size) {
		CLimitedSeqInStream p = ((CLimitedSeqInStream)((byte)(true ? (pp) : ((CLimitedSeqInStream)0).getVt()) - ((size_t)((CLimitedSeqInStream)0).getVt())));
		size_t size2 = size;
		SRes res = 0;
		Object generatedLimit = p.getLimit();
		Object generatedProcessed = p.getProcessed();
		if (generatedLimit != (UInt64)(Int64)-1) {
			UInt64 rem = generatedLimit - generatedProcessed;
			if (size2 > rem) {
				size2 = (size_t)rem;
			} 
		} 
		Object generatedRealStream = p.getRealStream();
		if (size2 != 0) {
			res = .UNRECOGNIZEDFUNCTIONNAME(generatedRealStream, data, size2);
			p.setFinished((size2 == 0 ? 1 : 0));
			generatedProcessed += size2;
		} 
		size = size2;
		return res/* ---------- CLzma2EncInt ---------- */;
	}
	public static Object Lzma2EncInt_InitStream(Object props) {
		Object generatedPropsAreSet = this.getPropsAreSet();
		Object generatedEnc = this.getEnc();
		if (!generatedPropsAreSet) {
			SizeT propsSize = 5;
			Byte[] propsEncoded = new Byte();
			{ 
				int __result__ = (ModernizedCProgram.LzmaEnc_SetProps(generatedEnc, props.getLzmaProps()));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			{ 
				int __result__ = (ModernizedCProgram.LzmaEnc_WriteProperties(generatedEnc, propsEncoded, propsSize));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			this.setPropsByte(propsEncoded[0]);
			this.setPropsAreSet(1);
		} 
		return 0;
	}
	public static void Lzma2EncInt_InitBlock() {
		this.setSrcPos(0);
		this.setNeedInitState(1);
		this.setNeedInitProp(1);
	}
	public static Object Lzma2EncInt_EncodeSubblock( p, Object outBuf, Object packSizeRes, ISeqOutStream outStream) {
		size_t packSizeLimit = packSizeRes;
		size_t packSize = packSizeLimit;
		UInt32 unpackSize = (1 << 21);
		Object generatedNeedInitProp = p.getNeedInitProp();
		int lzHeaderSize = 5 + (generatedNeedInitProp ? 1 : 0);
		BoolInt useCopyBlock = new BoolInt();
		SRes res = new SRes();
		packSizeRes = 0;
		if (packSize < lzHeaderSize) {
			return 7;
		} 
		packSize -= lzHeaderSize;
		Object generatedEnc = p.getEnc();
		ModernizedCProgram.LzmaEnc_SaveState(generatedEnc);
		Object generatedNeedInitState = p.getNeedInitState();
		res = ModernizedCProgram.LzmaEnc_CodeOneMemBlock(generatedEnc, generatedNeedInitState, outBuf + lzHeaderSize, packSize, (1 << 16), unpackSize);
		;
		if (unpackSize == 0) {
			return res;
		} 
		if (res == 0) {
			useCopyBlock = (packSize + 2 >= unpackSize || packSize > (1 << 16));
		} else {
				if (res != 7) {
					return res;
				} 
				res = 0;
				useCopyBlock = 1;
		} 
		Object generatedSrcPos = p.getSrcPos();
		if (useCopyBlock) {
			size_t destPos = 0;
			;
			while (unpackSize > 0) {
				UInt32 u = (unpackSize < (1 << 16)) ? unpackSize : (1 << 16);
				if (packSizeLimit - destPos < u + 3) {
					return 7;
				} 
				outBuf[destPos++] = (Byte)(generatedSrcPos == 0 ? 1 : 2);
				outBuf[destPos++] = (Byte)((u - 1) >> 8);
				outBuf[destPos++] = (Byte)(u - 1);
				.memcpy(outBuf + destPos, ModernizedCProgram.LzmaEnc_GetCurBuf(generatedEnc) - unpackSize, u);
				unpackSize -= u;
				destPos += u;
				generatedSrcPos += u;
				if (outStream) {
					packSizeRes += destPos;
					if (.UNRECOGNIZEDFUNCTIONNAME(outStream, outBuf, destPos) != destPos) {
						return 9;
					} 
					destPos = 0;
				} else {
						packSizeRes = destPos/* needInitState = True; */;
				} 
			}
			ModernizedCProgram.LzmaEnc_RestoreState(generatedEnc);
			return 0;
		} 
		Object generatedPropsByte = p.getPropsByte();
		{ 
			size_t destPos = 0;
			UInt32 u = unpackSize - 1;
			UInt32 pm = (UInt32)(packSize - 1);
			int mode = (generatedSrcPos == 0) ? 3 : (generatedNeedInitState ? (generatedNeedInitProp ? 2 : 1) : 0);
			;
			outBuf[destPos++] = (Byte)((1 << 7) | (mode << 5) | ((u >> 16) & -1024));
			outBuf[destPos++] = (Byte)(u >> 8);
			outBuf[destPos++] = (Byte)u;
			outBuf[destPos++] = (Byte)(pm >> 8);
			outBuf[destPos++] = (Byte)pm;
			if (generatedNeedInitProp) {
				outBuf[destPos++] = generatedPropsByte;
			} 
			p.setNeedInitProp(0);
			p.setNeedInitState(0);
			destPos += packSize;
			generatedSrcPos += unpackSize;
			if (outStream) {
				if (.UNRECOGNIZEDFUNCTIONNAME(outStream, outBuf, destPos) != destPos) {
					return 9;
				} 
			} 
			packSizeRes = destPos;
			return 0;
		}
	}
	/* ---------- Lzma2 Props ---------- */
	public static void Lzma2EncProps_Init() {
		Object generatedLzmaProps = this.getLzmaProps();
		generatedLzmaProps.LzmaEncProps_Init();
		this.setBlockSize(0);
		this.setNumBlockThreads_Reduced(-1);
		this.setNumBlockThreads_Max(-1);
		this.setNumTotalThreads(-1);
	}
	public static void Lzma2EncProps_Normalize() {
		UInt64 fileSize = new UInt64();
		int t1;
		int t1n;
		int t2;
		int t2r;
		int t3;
		Object generatedLzmaProps = this.getLzmaProps();
		int generatedNumThreads = lzmaProps.getNumThreads();
		{ 
			CLzmaEncProps lzmaProps = generatedLzmaProps;
			lzmaProps.LzmaEncProps_Normalize();
			t1n = generatedNumThreads;
		}
		t1 = generatedNumThreads;
		Object generatedNumBlockThreads_Max = this.getNumBlockThreads_Max();
		t2 = generatedNumBlockThreads_Max;
		Object generatedNumTotalThreads = this.getNumTotalThreads();
		t3 = generatedNumTotalThreads;
		if (t2 > 64) {
			t2 = 64;
		} 
		if (t3 <= 0) {
			if (t2 <= 0) {
				t2 = 1;
			} 
			t3 = t1n * t2;
		}  else if (t2 <= 0) {
			t2 = t3 / t1n;
			if (t2 == 0) {
				t1 = 1;
				t2 = t3;
			} 
			if (t2 > 64) {
				t2 = 64;
			} 
		}  else if (t1 <= 0) {
			t1 = t3 / t2;
			if (t1 == 0) {
				t1 = 1;
			} 
		} else {
				t3 = t1n * t2;
		} 
		generatedLzmaProps.setNumThreads(t1);
		t2r = t2;
		fileSize = generatedLzmaProps.getReduceSize();
		Object generatedBlockSize = this.getBlockSize();
		if (generatedBlockSize != ((UInt64)(Int64)-1) && generatedBlockSize != 0 && (generatedBlockSize < fileSize || fileSize == (UInt64)(Int64)-1)) {
			generatedLzmaProps.setReduceSize(generatedBlockSize);
		} 
		generatedLzmaProps.LzmaEncProps_Normalize();
		generatedLzmaProps.setReduceSize(fileSize);
		t1 = generatedNumThreads;
		if (generatedBlockSize == ((UInt64)(Int64)-1)) {
			t2r = t2 = 1;
			t3 = t1;
		}  else if (generatedBlockSize == 0 && t2 <= 1) {
			this.setBlockSize(((UInt64)(Int64)-/* if there is no block multi-threading, we use SOLID block */1));
		} else {
				if (generatedBlockSize == 0) {
					UInt32 kMinSize = (UInt32)1 << 20;
					UInt32 kMaxSize = (UInt32)1 << 28;
					UInt32 dictSize = generatedLzmaProps.getDictSize();
					UInt64 blockSize = (UInt64)dictSize << 2;
					if (blockSize < kMinSize) {
						blockSize = kMinSize;
					} 
					if (blockSize > kMaxSize) {
						blockSize = kMaxSize;
					} 
					if (blockSize < dictSize) {
						blockSize = dictSize;
					} 
					blockSize += (kMinSize - 1);
					blockSize &=  ~(UInt64)(kMinSize - 1);
					this.setBlockSize(blockSize);
				} 
				if (t2 > 1 && fileSize != (UInt64)(Int64)-1) {
					UInt64 numBlocks = fileSize / generatedBlockSize;
					if (numBlocks * generatedBlockSize != fileSize) {
						numBlocks++;
					} 
					if (numBlocks < (int)t2) {
						t2r = (int)numBlocks;
						if (t2r == 0) {
							t2r = 1;
						} 
						t3 = t1 * t2r;
					} 
				} 
		} 
		this.setNumBlockThreads_Max(t2);
		this.setNumBlockThreads_Reduced(t2r);
		this.setNumTotalThreads(t3);
	}
	public static Object Lzma2Enc_Create(Object alloc, Object allocBig) {
		CLzma2Enc p = (CLzma2Enc).UNRECOGNIZEDFUNCTIONNAME(alloc, );
		if (!p) {
			return ((Object)0);
		} 
		Object generatedProps = p.getProps();
		generatedProps.Lzma2EncProps_Init();
		generatedProps.Lzma2EncProps_Normalize();
		p.setExpectedDataSize((UInt64)(Int64)-1);
		p.setTempBufLzma(((Object)0));
		p.setAlloc(alloc);
		p.setAllocBig(allocBig);
		Object generatedCoders = p.getCoders();
		{ 
			int i;
			for (i = 0; i < 64; i++) {
				generatedCoders[i].setEnc(((Object)0));
			}
		}
		p.setMtCoder_WasConstructed(0);
		Object generatedOutBufs = p.getOutBufs();
		{ 
			int i;
			for (i = 0; i < (((true) + (true) / 8 + 1) + 3); i++) {
				generatedOutBufs[i] = ((Object)0);
			}
			p.setOutBufSize(0);
		}
		return p;
	}
	public static void Lzma2Enc_FreeOutBufs() {
		int i;
		Object generatedOutBufs = this.getOutBufs();
		Object generatedAlloc = this.getAlloc();
		for (i = 0; i < (((true) + (true) / 8 + 1) + 3); i++) {
			if (generatedOutBufs[i]) {
				.UNRECOGNIZEDFUNCTIONNAME(generatedAlloc, generatedOutBufs[i]);
				generatedOutBufs[i] = ((Object)0);
			} 
		}
		this.setOutBufSize(0);
	}
	public static void Lzma2Enc_Destroy(Object pp) {
		CLzma2Enc p = (CLzma2Enc)pp;
		int i;
		Object generatedCoders = p.getCoders();
		Object generatedEnc = t.getEnc();
		Object generatedAlloc = p.getAlloc();
		Object generatedAllocBig = p.getAllocBig();
		for (i = 0; i < 64; i++) {
			CLzma2EncInt t = generatedCoders[i];
			if (generatedEnc) {
				ModernizedCProgram.LzmaEnc_Destroy(generatedEnc, generatedAlloc, generatedAllocBig);
				t.setEnc(((Object)0));
			} 
		}
		Object generatedMtCoder_WasConstructed = p.getMtCoder_WasConstructed();
		Object generatedMtCoder = p.getMtCoder();
		if (generatedMtCoder_WasConstructed) {
			generatedMtCoder.MtCoder_Destruct();
			p.setMtCoder_WasConstructed(0);
		} 
		p.Lzma2Enc_FreeOutBufs();
		Object generatedTempBufLzma = p.getTempBufLzma();
		.UNRECOGNIZEDFUNCTIONNAME(generatedAlloc, generatedTempBufLzma);
		p.setTempBufLzma(((Object)0));
		.UNRECOGNIZEDFUNCTIONNAME(generatedAlloc, pp);
	}
	public static Object Lzma2Enc_SetProps(Object pp, Object props) {
		CLzma2Enc p = (CLzma2Enc)pp;
		CLzmaEncProps lzmaProps = props.getLzmaProps();
		lzmaProps.LzmaEncProps_Normalize();
		int generatedLc = lzmaProps.getLc();
		int generatedLp = lzmaProps.getLp();
		if (generatedLc + generatedLp > 4) {
			return 5;
		} 
		p.setProps(props);
		Object generatedProps = p.getProps();
		generatedProps.Lzma2EncProps_Normalize();
		return 0;
	}
	public static void Lzma2Enc_SetDataSize(Object pp, Object expectedDataSiize) {
		CLzma2Enc p = (CLzma2Enc)pp;
		p.setExpectedDataSize(expectedDataSiize);
	}
	public static Object Lzma2Enc_WriteProperties(Object pp) {
		CLzma2Enc p = (CLzma2Enc)pp;
		int i;
		Object generatedProps = p.getProps();
		UInt32 dicSize = ModernizedCProgram.LzmaEncProps_GetDictSize(generatedProps.getLzmaProps());
		for (i = 0; i < 40; i++) {
			if (dicSize <= (((UInt32)2 | ((i) & 1)) << ((i) / 2 + 11))) {
				break;
			} 
		}
		return (Byte)i;
	}
	public static Object Lzma2Enc_EncodeMt1( me,  p, ISeqOutStream outStream, Object outBuf, Object outBufSize, ISeqInStream inStream, Object inData, Object inDataSize, int finished, ICompressProgress progress) {
		UInt64 unpackTotal = 0;
		UInt64 packTotal = 0;
		size_t outLim = 0;
		CLimitedSeqInStream limitedInStream = new CLimitedSeqInStream();
		if (outBuf) {
			outLim = outBufSize;
			outBufSize = 0;
		} 
		Object generatedEnc = p.getEnc();
		Object generatedAlloc = me.getAlloc();
		if (!generatedEnc) {
			p.setPropsAreSet(0);
			p.setEnc(ModernizedCProgram.LzmaEnc_Create(generatedAlloc));
			if (!generatedEnc) {
				return 2;
			} 
		} 
		limitedInStream.setRealStream(inStream);
		Object generatedVt = limitedInStream.getVt();
		if (inStream) {
			generatedVt.setRead(LimitedSeqInStream_Read);
		} 
		Object generatedTempBufLzma = me.getTempBufLzma();
		if (!outBuf) {
			if (!generatedTempBufLzma) {
				me.setTempBufLzma((Byte).UNRECOGNIZEDFUNCTIONNAME(generatedAlloc, ((1 << 16) + 16)));
				if (!generatedTempBufLzma) {
					return 2;
				} 
			} 
		} 
		Object generatedProps = me.getProps();
		{ 
			int __result__ = (p.Lzma2EncInt_InitStream(generatedProps));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedExpectedDataSize = me.getExpectedDataSize();
		Object generatedAllocBig = me.getAllocBig();
		Object generatedSrcPos = p.getSrcPos();
		Object generatedProcessed = limitedInStream.getProcessed();
		Object generatedFinished = limitedInStream.getFinished();
		for (; ; ) {
			SRes res = 0;
			size_t inSizeCur = 0;
			p.Lzma2EncInt_InitBlock();
			limitedInStream.LimitedSeqInStream_Init();
			limitedInStream.setLimit(generatedProps.getBlockSize());
			if (inStream) {
				UInt64 expected = (UInt64)(Int64)-1;
				if (generatedExpectedDataSize != (UInt64)(Int64)-1 && generatedExpectedDataSize >= unpackTotal) {
					expected = generatedExpectedDataSize - unpackTotal;
				} 
				if (generatedProps.getBlockSize() != ((UInt64)(Int64)-1) && expected > generatedProps.getBlockSize()) {
					expected = (size_t)generatedProps.getBlockSize();
				} 
				ModernizedCProgram.LzmaEnc_SetDataSize(generatedEnc, expected);
				{ 
					int __result__ = (generatedVt.LzmaEnc_PrepareForLzma2(generatedEnc, (1 << 21), generatedAlloc, generatedAllocBig));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
			} else {
					inSizeCur = inDataSize - (size_t)unpackTotal;
					if (generatedProps.getBlockSize() != ((UInt64)(Int64)-1) && inSizeCur > generatedProps.getBlockSize()) {
						inSizeCur = (size_t)generatedProps.getBlockSize();
					} 
					{ 
						int __result__ = (ModernizedCProgram.LzmaEnc_MemPrepare(generatedEnc, inData + (size_t)unpackTotal, inSizeCur, (1 << 21), generatedAlloc, generatedAllocBig));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
			} 
			for (; ; ) {
				size_t packSize = ((1 << 16) + 16);
				if (outBuf) {
					packSize = outLim - (size_t)packTotal;
				} 
				res = ModernizedCProgram.Lzma2EncInt_EncodeSubblock(p, outBuf ? outBuf + (size_t)packTotal : generatedTempBufLzma, packSize, outBuf ? ((Object)0) : outStream);
				if (res != 0) {
					break;
				} 
				packTotal += packSize;
				if (outBuf) {
					outBufSize = (size_t)packTotal;
				} 
				res = progress.Progress(unpackTotal + generatedSrcPos, packTotal);
				if (res != 0) {
					break;
				} 
				if (packSize == 0) {
					break;
				} 
			}
			ModernizedCProgram.LzmaEnc_Finish(generatedEnc);
			unpackTotal += generatedSrcPos;
			{ 
				int __result__ = (res);
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (generatedSrcPos != (inStream ? generatedProcessed : inSizeCur)) {
				return 11;
			} 
			if (inStream ? generatedFinished : (unpackTotal == inDataSize)) {
				if (finished) {
					if (outBuf) {
						size_t destPos = outBufSize;
						if (destPos >= outLim) {
							return 7;
						} 
						outBuf[destPos] = 0;
						outBufSize = destPos + 1;
					} else {
							Byte b = 0;
							if (.UNRECOGNIZEDFUNCTIONNAME(outStream, b, 1) != 1) {
								return 9;
							} 
					} 
				} 
				return 0;
			} 
		}
	}
	public static Object Lzma2Enc_MtCallback_Code(Object pp, int coderIndex, int outBufIndex, Object src, Object srcSize, int finished) {
		CLzma2Enc me = (CLzma2Enc)pp;
		Object generatedOutBufSize = me.getOutBufSize();
		size_t destSize = generatedOutBufSize;
		SRes res = new SRes();
		CMtProgressThunk progressThunk = new CMtProgressThunk();
		Object generatedOutBufs = me.getOutBufs();
		Byte dest = generatedOutBufs[outBufIndex];
		Object generatedOutBufsDataSizes = me.getOutBufsDataSizes();
		generatedOutBufsDataSizes[outBufIndex] = 0;
		Object generatedAlloc = me.getAlloc();
		if (!dest) {
			dest = (Byte).UNRECOGNIZEDFUNCTIONNAME(generatedAlloc, generatedOutBufSize);
			if (!dest) {
				return 2;
			} 
			generatedOutBufs[outBufIndex] = dest;
		} 
		progressThunk.MtProgressThunk_CreateVTable();
		Object generatedMtCoder = me.getMtCoder();
		progressThunk.setMtProgress(generatedMtCoder.getMtProgress());
		progressThunk.setInSize(0);
		progressThunk.setOutSize(0);
		Object generatedCoders = me.getCoders();
		Object generatedVt = progressThunk.getVt();
		res = ModernizedCProgram.Lzma2Enc_EncodeMt1(me, generatedCoders[coderIndex], ((Object)0), dest, destSize, ((Object)0), src, srcSize, finished, generatedVt);
		generatedOutBufsDataSizes[outBufIndex] = destSize;
		return res;
	}
	public static Object Lzma2Enc_MtCallback_Write(Object pp, int outBufIndex) {
		CLzma2Enc me = (CLzma2Enc)pp;
		Object generatedOutBufsDataSizes = me.getOutBufsDataSizes();
		size_t size = generatedOutBufsDataSizes[outBufIndex];
		Object generatedOutBufs = me.getOutBufs();
		Byte data = generatedOutBufs[outBufIndex];
		Object generatedOutStream = me.getOutStream();
		if (generatedOutStream) {
			return .UNRECOGNIZEDFUNCTIONNAME(generatedOutStream, data, size) == size ? 0 : 9;
		} 
		Object generatedOutBuf_Rem = me.getOutBuf_Rem();
		if (size > generatedOutBuf_Rem) {
			return 7;
		} 
		Object generatedOutBuf = me.getOutBuf();
		.memcpy(generatedOutBuf, data, size);
		generatedOutBuf_Rem -= size;
		generatedOutBuf += size;
		return 0;
	}
	public static Object Lzma2Enc_Encode2(Object pp, ISeqOutStream outStream, Object outBuf, Object outBufSize, ISeqInStream inStream, Object inData, Object inDataSize, ICompressProgress progress) {
		CLzma2Enc p = (CLzma2Enc)pp;
		if (inStream && inData) {
			return 5;
		} 
		if (outStream && outBuf) {
			return 5;
		} 
		Object generatedCoders = p.getCoders();
		{ 
			int i;
			for (i = 0; i < 64; i++) {
				generatedCoders[i].setPropsAreSet(0);
			}
		}
		Object generatedProps = p.getProps();
		Object generatedMtCoder_WasConstructed = p.getMtCoder_WasConstructed();
		Object generatedMtCoder = p.getMtCoder();
		Object generatedAllocBig = p.getAllocBig();
		Object generatedOutBufSize = p.getOutBufSize();
		Object generatedExpectedDataSize = p.getExpectedDataSize();
		Object generatedOutBuf = p.getOutBuf();
		if (generatedProps.getNumBlockThreads_Reduced() > 1) {
			IMtCoderCallback2 vt = new IMtCoderCallback2();
			if (!generatedMtCoder_WasConstructed) {
				p.setMtCoder_WasConstructed(1);
				generatedMtCoder.MtCoder_Construct();
			} 
			vt.setCode(Lzma2Enc_MtCallback_Code);
			vt.setWrite(Lzma2Enc_MtCallback_Write);
			p.setOutStream(outStream);
			p.setOutBuf(((Object)0));
			p.setOutBuf_Rem(0);
			if (!outStream) {
				p.setOutBuf(outBuf);
				p.setOutBuf_Rem(outBufSize);
				outBufSize = 0;
			} 
			generatedMtCoder.setAllocBig(generatedAllocBig);
			generatedMtCoder.setProgress(progress);
			generatedMtCoder.setInStream(inStream);
			generatedMtCoder.setInData(inData);
			generatedMtCoder.setInDataSize(inDataSize);
			generatedMtCoder.setMtCallback(vt);
			generatedMtCoder.setMtCallbackObject(p);
			generatedMtCoder.setBlockSize((size_t)generatedProps.getBlockSize());
			if (generatedMtCoder.getBlockSize() != generatedProps.getBlockSize()) {
				return /* SZ_ERROR_MEM */5;
			} 
			{ 
				size_t destBlockSize = generatedMtCoder.getBlockSize() + (generatedMtCoder.getBlockSize() >> 10) + 16;
				if (destBlockSize < generatedMtCoder.getBlockSize()) {
					return 5;
				} 
				if (generatedOutBufSize != destBlockSize) {
					p.Lzma2Enc_FreeOutBufs();
				} 
				p.setOutBufSize(destBlockSize);
			}
			generatedMtCoder.setNumThreadsMax(generatedProps.getNumBlockThreads_Max());
			generatedMtCoder.setExpectedDataSize(generatedExpectedDataSize);
			{ 
				SRes res = generatedMtCoder.MtCoder_Code();
				if (!outStream) {
					outBufSize = generatedOutBuf - outBuf;
				} 
				return res;
			}
		} 
		return ModernizedCProgram.Lzma2Enc_EncodeMt1(p, generatedCoders[0], outStream, outBuf, outBufSize, inStream, inData, inDataSize, /* finished */1, progress);
	}
	/* Lzma86Enc.c -- LZMA + x86 (BCJ) Filter Encoder
	2018-07-04 : Igor Pavlov : Public domain */
	public static int Lzma86_Encode(Object dest, Object destLen, Object src, Object srcLen, int level, Object dictSize, int filterMode) {
		size_t outSize2 = destLen;
		Byte filteredStream = new Byte();
		BoolInt useFilter = new BoolInt();
		int mainResult = 7;
		CLzmaEncProps props = new CLzmaEncProps();
		props.LzmaEncProps_Init();
		props.setLevel(level);
		props.setDictSize(dictSize);
		destLen = 0;
		if (outSize2 < ((1 + 5) + 8)) {
			return 7;
		} 
		{ 
			int i;
			UInt64 t = srcLen;
			for (i = 0; i < 8; ) {
				dest[(1 + 5) + i] = (Byte)t;
			}
		}
		filteredStream = 0;
		useFilter = (filterMode != ESzFilterMode.SZ_FILTER_NO);
		if (useFilter) {
			if (srcLen != 0) {
				filteredStream = (Byte)ModernizedCProgram.MyAlloc(srcLen);
				if (filteredStream == 0) {
					return 2;
				} 
				.memcpy(filteredStream, src, srcLen);
			} 
			{ 
				UInt32 x86State = new UInt32();
				{ 
					x86State = 0;
				}
				;
				ModernizedCProgram.x86_Convert(filteredStream, srcLen, 0, x86State, 1);
			}
		} 
		{ 
			size_t minSize = 0;
			BoolInt bestIsFiltered = 0/* passes for SZ_FILTER_AUTO:
			        0 - BCJ + LZMA
			        1 - LZMA
			        2 - BCJ + LZMA agaian, if pass 0 (BCJ + LZMA) is better.
			    */;
			int numPasses = (filterMode == ESzFilterMode.SZ_FILTER_AUTO) ? 3 : 1;
			int i;
			for (i = 0; i < numPasses; i++) {
				size_t outSizeProcessed = outSize2 - ((1 + 5) + 8);
				size_t outPropsSize = 5;
				SRes curRes = new SRes();
				BoolInt curModeIsFiltered = (numPasses > 1 && i == numPasses - 1);
				if (curModeIsFiltered && !bestIsFiltered) {
					break;
				} 
				if (useFilter && i == 0) {
					curModeIsFiltered = 1;
				} 
				curRes = ((Object)0).LzmaEncode(dest + ((1 + 5) + 8), outSizeProcessed, curModeIsFiltered ? filteredStream : src, srcLen, props, dest + 1, outPropsSize, 0, ModernizedCProgram.g_Alloc, ModernizedCProgram.g_Alloc);
				if (curRes != 7) {
					if (curRes != 0) {
						mainResult = curRes;
						break;
					} 
					if (outSizeProcessed <= minSize || mainResult != 0) {
						minSize = outSizeProcessed;
						bestIsFiltered = curModeIsFiltered;
						mainResult = 0;
					} 
				} 
			}
			dest[0] = (Byte)(bestIsFiltered ? 1 : 0);
			destLen = ((1 + 5) + 8) + minSize;
		}
		if (useFilter) {
			ModernizedCProgram.MyFree(filteredStream);
		} 
		return mainResult;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int sort_by_stringptr(Object p1, Object p2) {
		byte s1 = (byte)p1;
		byte s2 = (byte)p2;
		return .strcmp(s1, s2);
	}
	public static int get_exec_path(Byte exec_path, Object exec_path_sz) {
		.memset(exec_path, 0, exec_path_sz);
		int len = 0;
		exec_path[len] = 0;
		return 0;
	}
	public static void get_install_dir(Byte install_dir, Object exec_path) {
		.strncpy(install_dir, exec_path, -1024 - 1);
		byte last_slash = ((Object)0);
		if ((last_slash = .strrchr(install_dir, (byte)'/')) != ((Object)0)) {
			last_slash = 0;
		}  else if ((last_slash = .strrchr(install_dir, (byte)'\\')) != ((Object)0)) {
			last_slash = 0;
		} else {
				install_dir[0] = (byte)'.';
				install_dir[1] = 0;
		} 
	}
	public static int count_dictionaries(Byte dictionary_files) {
		if (dictionary_files == ((Object)0)) {
			return 0;
		} 
		int cnt = 0;
		for (int d = 0;
		 dictionary_files[d] != ((Object)0); d++) {
			cnt++;
		}
		return (cnt);
	}
	public static Byte first_file_in_directory(Object path) {
		DIR d = new DIR();
		Object generatedD_name = de.getD_name();
		if ((d = .opendir(path)) != ((Object)0)) {
			byte first_file = ((Object)0);
			dirent de = new dirent();
			while ((de = .readdir(d)) != ((Object)0)) {
				if (generatedD_name[0] == (byte)'.') {
					continue;
				} 
				first_file = .strdup(generatedD_name);
				break;
			}
			.closedir(d);
			return first_file;
		} 
		return ((Object)0);
	}
	public static Byte scan_directory(Object path) {
		byte tmp_path = ModernizedCProgram.hcstrdup(path);
		size_t tmp_path_len = .strlen(tmp_path);
		while (tmp_path[tmp_path_len - 1] == (byte)'/' || tmp_path[tmp_path_len - 1] == (byte)'\\') {
			tmp_path[tmp_path_len - 1] = 0;
			tmp_path_len = .strlen(tmp_path);
		}
		byte files = ((Object)0);
		size_t num_files = 0;
		DIR d = ((Object)0);
		Object generatedD_name = de.getD_name();
		if ((d = .opendir(tmp_path)) != ((Object)0)) {
			dirent de = new dirent();
			while ((de = .readdir(d)) != ((Object)0)) {
				if (generatedD_name[0] == (byte)'.') {
					continue;
				} 
				byte path_file;
				ModernizedCProgram.hc_asprintf(path_file, "%s/%s", tmp_path, generatedD_name);
				DIR d_test = new DIR();
				if ((d_test = .opendir(path_file)) != ((Object)0)) {
					.closedir(d_test);
					ModernizedCProgram.hcfree(path_file);
				} else {
						files = (byte)ModernizedCProgram.hcrealloc(files, (num_files + 1) * , );
						files[num_files] = path_file;
						num_files++;
				} 
			}
			.closedir(d);
		}  else if ((._errno()) == 20) {
			files = (byte)ModernizedCProgram.hcrealloc(files, (num_files + 1) * , );
			files[num_files] = ModernizedCProgram.hcstrdup(path);
			num_files++;
		} 
		files = (byte)ModernizedCProgram.hcrealloc(files, (num_files + 1) * , );
		files[num_files] = ((Object)0);
		ModernizedCProgram.hcfree(tmp_path);
		return (files);
	}
	public static int hc_mkdir(Object name, Object mode) {
		return ._mkdir(name);
	}
	public static int process_stdout(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object pws_cnt) {
		combinator_ctx generatedCombinator_ctx = hashcat_ctx.getCombinator_ctx();
		combinator_ctx_t combinator_ctx = generatedCombinator_ctx;
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		mask_ctx generatedMask_ctx = hashcat_ctx.getMask_ctx();
		mask_ctx_t mask_ctx = generatedMask_ctx;
		outfile_ctx generatedOutfile_ctx = hashcat_ctx.getOutfile_ctx();
		outfile_ctx_t outfile_ctx = generatedOutfile_ctx;
		straight_ctx generatedStraight_ctx = hashcat_ctx.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		Byte generatedFilename = outfile_ctx.getFilename();
		byte filename = generatedFilename;
		out_t out = new out_t();
		hc_fp generatedFp = out.getFp();
		if (filename) {
			if (generatedFp.hc_fopen(filename, "ab") == 0) {
				hashcat_ctx.event_log_error("%s: %s", filename, .strerror((._errno())));
				return -1;
			} 
			if (generatedFp.hc_lockfile() == -1) {
				generatedFp.hc_fclose();
				hashcat_ctx.event_log_error("%s: %s", filename, .strerror((._errno())));
				return -1;
			} 
		} else {
				generatedFp.setIs_gzip(0);
				generatedFp.setPfp((_iob[1]));
				generatedFp.setFd((((_iob[1])).get_file()));
		} 
		out.setLen(0);
		u32[] plain_buf = new u32[]{0};
		u8 plain_ptr = (u8)plain_buf;
		u32 plain_len = 0;
		Object generatedKernel_params_buf32 = device_param.getKernel_params_buf32();
		// ugly, i knowu32 il_cnt = generatedKernel_params_buf32[30];
		Object generatedAttack_mode = user_options.getAttack_mode();
		Object generatedInnerloop_pos = device_param.getInnerloop_pos();
		Object generatedOpti_type = hashconfig.getOpti_type();
		Object generatedI = pw.getI();
		 generatedKernel_rules_buf = straight_ctx.getKernel_rules_buf();
		Object generatedPw_len = pw.getPw_len();
		Object generatedPw_max = hashconfig.getPw_max();
		Object generatedCombs_mode = combinator_ctx.getCombs_mode();
		Object generatedKernel_params_mp_l_buf64 = device_param.getKernel_params_mp_l_buf64();
		Object generatedKernel_params_mp_r_buf64 = device_param.getKernel_params_mp_r_buf64();
		Object generatedKernel_params_mp_l_buf32 = device_param.getKernel_params_mp_l_buf32();
		Object generatedKernel_params_mp_r_buf32 = device_param.getKernel_params_mp_r_buf32();
		 generatedRoot_css_buf = mask_ctx.getRoot_css_buf();
		 generatedMarkov_css_buf = mask_ctx.getMarkov_css_buf();
		Object generatedCss_cnt = mask_ctx.getCss_cnt();
		Object generatedKernel_params_mp_buf64 = device_param.getKernel_params_mp_buf64();
		Object generatedKernel_params_mp_buf32 = device_param.getKernel_params_mp_buf32();
		if (generatedAttack_mode == attack_mode.ATTACK_MODE_STRAIGHT) {
			pw_t pw = new pw_t();
			for (u64 gidvid = 0;
			 gidvid < pws_cnt; gidvid++) {
				int rc = ModernizedCProgram.gidd_to_pw_t(hashcat_ctx, device_param, gidvid, pw);
				if (rc == -1) {
					if (filename) {
						generatedFp.hc_fclose();
					} 
					return -1;
				} 
				for (u32 il_pos = 0;
				 il_pos < il_cnt; il_pos++) {
					u32 off = generatedInnerloop_pos + il_pos;
					if (generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
						for (int i = 0;
						 i < 8; i++) {
							plain_buf[i] = generatedI[i];
						}
						plain_len = .apply_rules_optimized(generatedKernel_rules_buf[off].getCmds(), plain_buf[0], plain_buf[4], generatedPw_len);
					} else {
							for (int i = 0;
							 i < 64; i++) {
								plain_buf[i] = generatedI[i];
							}
							plain_len = .apply_rules(generatedKernel_rules_buf[off].getCmds(), plain_buf, generatedPw_len);
					} 
					if (plain_len > generatedPw_max) {
						plain_len = generatedPw_max;
					} 
					out.out_push(plain_ptr, plain_len);
				}
			}
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_COMBI) {
			pw_t pw = new pw_t();
			for (u64 gidvid = 0;
			 gidvid < pws_cnt; gidvid++) {
				int rc = ModernizedCProgram.gidd_to_pw_t(hashcat_ctx, device_param, gidvid, pw);
				if (rc == -1) {
					if (filename) {
						generatedFp.hc_fclose();
					} 
					return -1;
				} 
				for (u32 il_pos = 0;
				 il_pos < il_cnt; il_pos++) {
					for (int i = 0;
					 i < 64; i++) {
						plain_buf[i] = generatedI[i];
					}
					plain_len = generatedPw_len;
					byte comb_buf = (byte)generatedI;
					u32 comb_len = generatedPw_len;
					if (generatedCombs_mode == combinator_mode.COMBINATOR_MODE_BASE_LEFT) {
						.memcpy(plain_ptr + plain_len, comb_buf, comb_len);
					} else {
							.memmove(plain_ptr + comb_len, plain_ptr, plain_len);
							.memcpy(plain_ptr, comb_buf, comb_len);
					} 
					plain_len += comb_len;
					if (plain_len > generatedPw_max) {
						plain_len = generatedPw_max;
					} 
					out.out_push(plain_ptr, plain_len);
				}
			}
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_BF) {
			for (u64 gidvid = 0;
			 gidvid < pws_cnt; gidvid++) {
				for (u32 il_pos = 0;
				 il_pos < il_cnt; il_pos++) {
					u64 l_off = generatedKernel_params_mp_l_buf64[3] + gidvid;
					u64 r_off = generatedKernel_params_mp_r_buf64[3] + il_pos;
					u32 l_start = generatedKernel_params_mp_l_buf32[5];
					u32 r_start = generatedKernel_params_mp_r_buf32[5];
					u32 l_stop = generatedKernel_params_mp_l_buf32[4];
					u32 r_stop = generatedKernel_params_mp_r_buf32[4];
					generatedRoot_css_buf.sp_exec(l_off, (byte)plain_ptr + l_start, generatedMarkov_css_buf, l_start, l_start + l_stop);
					generatedRoot_css_buf.sp_exec(r_off, (byte)plain_ptr + r_start, generatedMarkov_css_buf, r_start, r_start + r_stop);
					plain_len = generatedCss_cnt;
					out.out_push(plain_ptr, plain_len);
				}
			}
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID1) {
			pw_t pw = new pw_t();
			for (u64 gidvid = 0;
			 gidvid < pws_cnt; gidvid++) {
				int rc = ModernizedCProgram.gidd_to_pw_t(hashcat_ctx, device_param, gidvid, pw);
				if (rc == -1) {
					if (filename) {
						generatedFp.hc_fclose();
					} 
					return -1;
				} 
				for (u32 il_pos = 0;
				 il_pos < il_cnt; il_pos++) {
					for (int i = 0;
					 i < 64; i++) {
						plain_buf[i] = generatedI[i];
					}
					plain_len = generatedPw_len;
					u64 off = generatedKernel_params_mp_buf64[3] + il_pos;
					u32 start = 0;
					u32 stop = generatedKernel_params_mp_buf32[4];
					generatedRoot_css_buf.sp_exec(off, (byte)plain_ptr + plain_len, generatedMarkov_css_buf, start, start + stop);
					plain_len += start + stop;
					out.out_push(plain_ptr, plain_len);
				}
			}
		}  else if (generatedAttack_mode == attack_mode.ATTACK_MODE_HYBRID2) {
			pw_t pw = new pw_t();
			for (u64 gidvid = 0;
			 gidvid < pws_cnt; gidvid++) {
				int rc = ModernizedCProgram.gidd_to_pw_t(hashcat_ctx, device_param, gidvid, pw);
				if (rc == -1) {
					if (filename) {
						generatedFp.hc_fclose();
					} 
					return -1;
				} 
				for (u32 il_pos = 0;
				 il_pos < il_cnt; il_pos++) {
					u64 off = generatedKernel_params_mp_buf64[3] + gidvid;
					u32 start = 0;
					u32 stop = generatedKernel_params_mp_buf32[4];
					generatedRoot_css_buf.sp_exec(off, (byte)plain_ptr, generatedMarkov_css_buf, start, start + stop);
					plain_len = stop;
					byte comb_buf = (byte)generatedI;
					u32 comb_len = generatedPw_len;
					.memcpy(plain_ptr + plain_len, comb_buf, comb_len);
					plain_len += comb_len;
					if (plain_len > generatedPw_max) {
						plain_len = generatedPw_max;
					} 
					out.out_push(plain_ptr, plain_len);
				}
			}
		} 
		out.out_flush();
		if (filename) {
			generatedFp.hc_fclose();
		} 
		return 0;
	}
	/*
	*  xxhsum - Command line interface for xxhash algorithms
	*  Copyright (C) Yann Collet 2012-2016
	*
	*  GPL v2 License
	*
	*  This program is free software; you can redistribute it and/or modify
	*  it under the terms of the GNU General Public License as published by
	*  the Free Software Foundation; either version 2 of the License, or
	*  (at your option) any later version.
	*
	*  This program is distributed in the hope that it will be useful,
	*  but WITHOUT ANY WARRANTY; without even the implied warranty of
	*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	*  GNU General Public License for more details.
	*
	*  You should have received a copy of the GNU General Public License along
	*  with this program; if not, write to the Free Software Foundation, Inc.,
	*  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
	*
	*  You can contact the author at :
	*  - xxHash homepage : http://www.xxhash.com
	*  - xxHash source repository : https://github.com/Cyan4973/xxHash
	*/
	/* xxhsum :
	 * Provides hash value of a file content, or a list of files, or stdin
	 * Display convention is Big Endian, for both 32 and 64 bits algorithms
	 */
	/* ************************************
	 *  Compiler Options
	 **************************************/
	/* MS Visual */
	/* removes visual warnings */
	/* Under Linux at least, pull in the *64 commands */
	/* ************************************
	 *  Includes
	 **************************************/
	/* malloc, calloc, free, exit */
	/* fprintf, fopen, ftello64, fread, stdin, stdout, _fileno (when present) */
	/* strcmp */
	/* stat, stat64, _stat64 */
	/* stat, stat64, _stat64 */
	/* clock_t, clock, CLOCKS_PER_SEC */
	/* assert */
	/* *_state_t */
	/* ************************************
	 *  OS-Specific Includes
	 **************************************/
	/* _O_BINARY */
	/* _setmode, _isatty */
	/* isatty, STDIN_FILENO */
	/* ************************************
	*  Basic Types
	**************************************/
	/* C99 */
	public static int BMK_isLittleEndian() {
		Object one = {/* don't use static : performance detrimental  */1};
		return one.getC()[0/* *************************************
		 *  Constants
		 ***************************************/];
	}
	public static Object BMK_clockSpan(Object start) {
		return .clock() - /* works even if overflow; Typical max span ~ 30 mn */start;
	}
	public static Object BMK_findMaxMem(Object requiredMem) {
		size_t step = 64 * (1 << 20);
		Object testmem = ((Object)0);
		requiredMem = (((requiredMem >> 26) + 1) << 26);
		requiredMem += 2 * step;
		if (requiredMem > (2 * (-1024 << 30) - 64 * (1 << 20))) {
			requiredMem = (2 * (-1024 << 30) - 64 * (1 << 20));
		} 
		while (!testmem) {
			if (requiredMem > step) {
				requiredMem -= step;
			} else {
					requiredMem >>=  1;
			} 
			testmem = .malloc((size_t)requiredMem);
		}
		.free(testmem);
		if (requiredMem > step) {
			requiredMem -= /* keep some space available */step;
		} else {
				requiredMem >>=  1;
		} 
		return (size_t)requiredMem;
	}
	public static Object BMK_GetFileSize(Object infilename) {
		int r;
		stat statbuf = new stat();
		r = .stat(infilename, statbuf);
		Object generatedSt_mode = statbuf.getSt_mode();
		if (r || !(((generatedSt_mode) & -1024) == -1024)) {
			return /* No good... */0;
		} 
		Object generatedSt_size = statbuf.getSt_size();
		return (U64)generatedSt_size;
	}
	public static Object localXXH32(Object buffer, Object bufferSize, Object seed) {
		return ModernizedCProgram.XXH32(buffer, bufferSize, seed);
	}
	public static Object localXXH64(Object buffer, Object bufferSize, Object seed) {
		return (U32)ModernizedCProgram.XXH64(buffer, bufferSize, seed);
	}
	public static void BMK_benchHash(Object h, Object hName, Object buffer, Object bufferSize) {
		U32 nbh_perIteration = ((300 * (1 << 20)) / (bufferSize + 1)) + /* first loop conservatively aims for 300 MB/s */1;
		U32 iterationNb = new U32();
		double fastestH = 1.0E8;
		do {
			if (ModernizedCProgram.g_displayLevel >= 2) {
				.fprintf((_iob[2]), "\r%70s\r", "");
			} 
		} while (/* Clean display line */0);
		if (ModernizedCProgram.g_nbIterations < 1) {
			ModernizedCProgram.g_nbIterations = 1;
		} 
		for (iterationNb = 1; iterationNb <= ModernizedCProgram.g_nbIterations; iterationNb++) {
			U32 r = 0;
			clock_t cStart = new clock_t();
			do {
				if (ModernizedCProgram.g_displayLevel >= 2) {
					.fprintf((_iob[2]), "%1i-%-17.17s : %10u ->\r", iterationNb, hName, (U32)bufferSize);
				} 
			} while (0);
			cStart = .clock();
			while (.clock() == /* starts clock() at its exact beginning */cStart) {
				;
			}
			cStart = .clock();
			{ 
				U32 i = new U32();
				for (i = 0; i < nbh_perIteration; i++) {
					r += .h(buffer, bufferSize, i);
				}
			}
			if (r == 0) {
				do {
					if (ModernizedCProgram.g_displayLevel >= 3) {
						.fprintf((_iob[2]), ".\r");
					} 
				} while (/* do something with r to avoid compiler "optimizing" away hash function */0);
			} 
			{ 
				double timeS = ((double)ModernizedCProgram.BMK_clockSpan(cStart) / ((clock_t)1000)) / nbh_perIteration;
				if (timeS < fastestH) {
					fastestH = timeS;
				} 
				do {
					if (ModernizedCProgram.g_displayLevel >= 2) {
						.fprintf((_iob[2]), "%1i-%-17.17s : %10u -> %8.0f it/s (%7.1f MB/s) \r", iterationNb, hName, (U32)bufferSize, (double)1 / fastestH, ((double)bufferSize / (1 << 20)) / fastestH);
					} 
				} while (0);
			}
			((fastestH > 1.0 / 2000000000) ? (Object)0 : ._assert("fastestH > 1./2000000000", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\xxhsum.c", /* avoid U32 overflow */247));
			nbh_perIteration = (U32)(1 / fastestH) + /* adjust nbh_perIteration to last roughtly one second */1;
		}
		do {
			if (ModernizedCProgram.g_displayLevel >= 1) {
				.fprintf((_iob[2]), "%-19.19s : %10u -> %8.0f it/s (%7.1f MB/s) \n", hName, (U32)bufferSize, (double)1 / fastestH, ((double)bufferSize / (1 << 20)) / fastestH);
			} 
		} while (0);
		if (ModernizedCProgram.g_displayLevel < 1) {
			do {
				if (ModernizedCProgram.g_displayLevel >= 0) {
					.fprintf((_iob[2]), "%u, ", (U32)((double)1 / fastestH));
				} 
			} while (0/* BMK_benchMem():
			 * specificTest : 0 == run all tests, 1+ run only specific test
			 * buffer : is supposed 8-bytes aligned (if malloc'ed, it should be)
			 * the real allocated size of buffer is supposed to be >= (bufferSize+3).
			 * @return : 0 on success, 1 if error (invalid mode selected) */);
		} 
	}
	public static int BMK_benchMem(Object buffer, Object bufferSize, Object specificTest) {
		(((((size_t)buffer) & 8) == 0) ? (Object)0 : ._assert("(((size_t)buffer) & 8) == 0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\xxhsum.c", /* ensure alignment */265));
		if ((specificTest == 0) | (specificTest == /* XXH32 bench */1)) {
			ModernizedCProgram.BMK_benchHash(localXXH32, "XXH32", buffer, bufferSize);
		} 
		if ((specificTest == 0) | (specificTest == /* Bench XXH32 on Unaligned input */2)) {
			ModernizedCProgram.BMK_benchHash(localXXH32, "XXH32 unaligned", ((byte)buffer) + 1, bufferSize);
		} 
		if ((specificTest == 0) | (specificTest == /* Bench XXH64 */3)) {
			ModernizedCProgram.BMK_benchHash(localXXH64, "XXH64", buffer, bufferSize);
		} 
		if ((specificTest == 0) | (specificTest == /* Bench XXH64 on Unaligned input */4)) {
			ModernizedCProgram.BMK_benchHash(localXXH64, "XXH64 unaligned", ((byte)buffer) + 3, bufferSize);
		} 
		if (specificTest > 4) {
			.fprintf((_iob[2]), "benchmark mode invalid \n");
			return 1;
		} 
		return 0;
	}
	public static Object BMK_selectBenchedSize(Object fileName) {
		U64 inFileSize = ModernizedCProgram.BMK_GetFileSize(fileName);
		size_t benchedSize = (size_t)ModernizedCProgram.BMK_findMaxMem(inFileSize);
		if ((U64)benchedSize > inFileSize) {
			benchedSize = (size_t)inFileSize;
		} 
		if (benchedSize < inFileSize) {
			.fprintf((_iob[2]), "Not enough memory for '%s' full size; testing %i MB only...\n", fileName, (int)(benchedSize >> 20));
		} 
		return benchedSize;
	}
	public static int BMK_benchFiles(Object fileNamesTable, int nbFiles, Object specificTest) {
		int result = 0;
		int fileIdx;
		for (fileIdx = 0; fileIdx < nbFiles; fileIdx++) {
			byte inFileName = fileNamesTable[fileIdx];
			FILE inFile = .fopen(inFileName, "rb");
			size_t benchedSize = ModernizedCProgram.BMK_selectBenchedSize(inFileName);
			byte buffer = (byte).calloc(benchedSize + 16 + 3, 1);
			Object alignedBuffer = (buffer + 15) - (((size_t)(buffer + 15)) & /* align on next 16 bytes */-1024);
			if ((inFile == ((Object)0)) || (inFileName == ((Object)/* Checks */0))) {
				.fprintf((_iob[2]), "Pb opening %s\n", inFileName);
				.free(buffer);
				return 11;
			} 
			if (!buffer) {
				.fprintf((_iob[2]), "\nError: not enough memory!\n");
				.fclose(inFile);
				return 12;
			} 
			do {
				if (ModernizedCProgram.g_displayLevel >= 1) {
					.fprintf((_iob[2]), "\rLoading %s...        \n", inFileName);
				} 
			} while (/* Fill input buffer */0);
			{ 
				size_t readSize = .fread(alignedBuffer, 1, benchedSize, inFile);
				.fclose(inFile);
				if (readSize != benchedSize) {
					.fprintf((_iob[2]), "\nError: problem reading file '%s' !!    \n", inFileName);
					.free(buffer);
					return 13;
				} 
			}
			result |=  ModernizedCProgram.BMK_benchMem(alignedBuffer, benchedSize, /* bench */specificTest);
			.free(buffer);
		}
		return result;
	}
	public static int BMK_benchInternal(Object keySize, int specificTest) {
		Object buffer = .calloc(keySize + 16 + 3, 1);
		Object alignedBuffer = ((byte)buffer + 15) - (((size_t)((byte)buffer + 15)) & /* align on next 16 bytes */-1024);
		if (!buffer) {
			.fprintf((_iob[2]), "\nError: not enough memory!\n");
			return 12;
		} 
		do {
			if (ModernizedCProgram.g_displayLevel >= 1) {
				.fprintf((_iob[2]), "Sample of ");
			} 
		} while (/* bench */0);
		if (keySize > 10 * (1 << 10)) {
			do {
				if (ModernizedCProgram.g_displayLevel >= 1) {
					.fprintf((_iob[2]), "%u KB", (U32)(keySize >> 10));
				} 
			} while (0);
		} else {
				do {
					if (ModernizedCProgram.g_displayLevel >= 1) {
						.fprintf((_iob[2]), "%u bytes", (U32)keySize);
					} 
				} while (0);
		} 
		do {
			if (ModernizedCProgram.g_displayLevel >= 1) {
				.fprintf((_iob[2]), "...        \n");
			} 
		} while (0);
		{ 
			int result = ModernizedCProgram.BMK_benchMem(alignedBuffer, keySize, specificTest);
			.free(buffer);
			return result;
		}
	}
	public static void BMK_checkResult(Object r1, Object r2) {
		int nbTests = 1;
		if (r1 == r2) {
			do {
				if (ModernizedCProgram.g_displayLevel >= 3) {
					.fprintf((_iob[2]), "\rTest%3i : %08X == %08X   ok   ", nbTests, r1, r2);
				} 
			} while (0);
		} else {
				.fprintf((_iob[2]), "\rERROR : Test%3i : %08X <> %08X   !!!!!   \n", nbTests, r1, r2);
				.exit(1);
		} 
		nbTests++;
	}
	public static void BMK_checkResult64(Object r1, Object r2) {
		int nbTests = 1;
		if (r1 != r2) {
			.fprintf((_iob[2]), "\rERROR : Test%3i : 64-bit values non equals   !!!!!   \n", nbTests);
			.fprintf((_iob[2]), "\r %08X%08X != %08X%08X \n", (U32)(r1 >> 32), (U32)r1, (U32)(r2 >> 32), (U32)r2);
			.exit(1);
		} 
		nbTests++;
	}
	public static void BMK_testSequence64(Object sentence, Object len, Object seed, Object Nresult) {
		XXH64_state_t state = new XXH64_state_t();
		U64 Dresult = new U64();
		size_t pos = new size_t();
		Dresult = ModernizedCProgram.XXH64(sentence, len, seed);
		ModernizedCProgram.BMK_checkResult64(Dresult, Nresult);
		state.XXH64_reset(seed);
		state.XXH64_update(sentence, len);
		Dresult = ModernizedCProgram.XXH64_digest(state);
		ModernizedCProgram.BMK_checkResult64(Dresult, Nresult);
		state.XXH64_reset(seed);
		for (pos = 0; pos < len; pos++) {
			state.XXH64_update(((byte)sentence) + pos, 1);
		}
		Dresult = ModernizedCProgram.XXH64_digest(state);
		ModernizedCProgram.BMK_checkResult64(Dresult, Nresult);
	}
	public static void BMK_testSequence(Object sequence, Object len, Object seed, Object Nresult) {
		XXH32_state_t state = new XXH32_state_t();
		U32 Dresult = new U32();
		size_t pos = new size_t();
		Dresult = ModernizedCProgram.XXH32(sequence, len, seed);
		ModernizedCProgram.BMK_checkResult(Dresult, Nresult);
		state.XXH32_reset(seed);
		state.XXH32_update(sequence, len);
		Dresult = ModernizedCProgram.XXH32_digest(state);
		ModernizedCProgram.BMK_checkResult(Dresult, Nresult);
		state.XXH32_reset(seed);
		for (pos = 0; pos < len; pos++) {
			state.XXH32_update(((byte)sequence) + pos, 1);
		}
		Dresult = ModernizedCProgram.XXH32_digest(state);
		ModernizedCProgram.BMK_checkResult(Dresult, Nresult);
	}
	public static void BMK_sanityCheck() {
		U32 prime = -1024;
		BYTE[] sanityBuffer = new BYTE();
		U32 byteGen = prime;
		int i;
		for (i = 0; i < 101; i++) {
			sanityBuffer[i] = (BYTE)(byteGen >> 24);
			byteGen *= byteGen;
		}
		ModernizedCProgram.BMK_testSequence(((Object)0), 0, 0, -1024);
		ModernizedCProgram.BMK_testSequence(((Object)0), 0, prime, -1024);
		ModernizedCProgram.BMK_testSequence(sanityBuffer, 1, 0, -1024);
		ModernizedCProgram.BMK_testSequence(sanityBuffer, 1, prime, -1024);
		ModernizedCProgram.BMK_testSequence(sanityBuffer, 14, 0, -1024);
		ModernizedCProgram.BMK_testSequence(sanityBuffer, 14, prime, -1024);
		ModernizedCProgram.BMK_testSequence(sanityBuffer, 101, 0, -1024);
		ModernizedCProgram.BMK_testSequence(sanityBuffer, 101, prime, -1024);
		ModernizedCProgram.BMK_testSequence64(((Object)0), 0, 0, -1024);
		ModernizedCProgram.BMK_testSequence64(((Object)0), 0, prime, -1024);
		ModernizedCProgram.BMK_testSequence64(sanityBuffer, 1, 0, -1024);
		ModernizedCProgram.BMK_testSequence64(sanityBuffer, 1, prime, -1024);
		ModernizedCProgram.BMK_testSequence64(sanityBuffer, 14, 0, -1024);
		ModernizedCProgram.BMK_testSequence64(sanityBuffer, 14, prime, -1024);
		ModernizedCProgram.BMK_testSequence64(sanityBuffer, 101, 0, -1024);
		ModernizedCProgram.BMK_testSequence64(sanityBuffer, 101, prime, -1024);
		do {
			if (ModernizedCProgram.g_displayLevel >= 3) {
				.fprintf((_iob[2]), "\r%70s\r", "");
			} 
		} while (/* Clean display line */0);
		do {
			if (ModernizedCProgram.g_displayLevel >= 3) {
				.fprintf((_iob[2]), "Sanity check -- all tests ok\n");
			} 
		} while (0/* ********************************************************
		*  File Hashing
		**********************************************************/);
	}
	public static void BMK_display_LittleEndian(Object ptr, Object length) {
		BYTE p = (BYTE)ptr;
		size_t idx = new size_t();
		for (idx = length - 1; idx < length; /* intentional underflow to negative to detect end */idx--) {
			.fprintf((_iob[1]), "%02x", p[idx]);
		}
	}
	public static void BMK_display_BigEndian(Object ptr, Object length) {
		BYTE p = (BYTE)ptr;
		size_t idx = new size_t();
		for (idx = 0; idx < length; idx++) {
			.fprintf((_iob[1]), "%02x", p[idx]);
		}
	}
	public static void BMK_hashStream(Object xxhHashValue, Object hashType, Object buffer, Object blockSize) {
		XXH64_state_t state64 = new XXH64_state_t();
		XXH32_state_t state32 = new XXH32_state_t();
		size_t readSize = new size_t();
		state32.XXH32_reset(/* Init */0);
		state64.XXH64_reset(0);
		readSize = /* Load file & update hash */1;
		while (readSize) {
			readSize = .fread(buffer, 1, blockSize, inFile);
			switch (hashType) {
			case .algo_xxh64:
					state64.XXH64_update(buffer, readSize);
					break;
			case .algo_xxh32:
					state32.XXH32_update(buffer, readSize);
					break;
			default:
					break;
			}
		}
		switch (hashType) {
		case .algo_xxh32:
				{ 
					U32 h32 = ModernizedCProgram.XXH32_digest(state32);
					.memcpy(xxhHashValue, h32, );
					break;
				}
		case .algo_xxh64:
				{ 
					U64 h64 = ModernizedCProgram.XXH64_digest(state64);
					.memcpy(xxhHashValue, h64, );
					break;
				}
		default:
				break;
		}
	}
	public static int BMK_hash(Object fileName, Object hashType, Object displayEndianess) {
		FILE inFile = new FILE();
		size_t blockSize = 64 * (1 << 10);
		Object buffer;
		U32 h32 = 0;
		U64 h64 = 0;
		if (fileName == /* Check file existence */ModernizedCProgram.stdinName) {
			inFile = (_iob[0]);
			._setmode((((_iob[0])).get_file()), -1024);
		} else {
				inFile = .fopen(fileName, "rb");
		} 
		if (inFile == ((Object)0)) {
			.fprintf((_iob[2]), "Pb opening %s\n", fileName);
			return 1;
		} 
		buffer = .malloc(/* Memory allocation & restrictions */blockSize);
		if (!buffer) {
			.fprintf((_iob[2]), "\nError: not enough memory!\n");
			.fclose(inFile);
			return 1;
		} 
		{ 
			size_t fileNameSize = .strlen(/* loading notification */fileName);
			byte fileNameEnd = fileName + fileNameSize;
			int maxInfoFilenameSize = (int)(fileNameSize > 30 ? 30 : fileNameSize);
			int infoFilenameSize = 1;
			while ((infoFilenameSize < maxInfoFilenameSize) && (fileNameEnd[-1 - infoFilenameSize] != (byte)'/') && (fileNameEnd[-1 - infoFilenameSize] != (byte)'\\')) {
				infoFilenameSize++;
			}
			.fprintf((_iob[2]), "\rLoading %s...  \r", fileNameEnd - infoFilenameSize);
			switch (/* Load file & update hash */hashType) {
			case .algo_xxh64:
					inFile.BMK_hashStream(h64, .algo_xxh64, buffer, blockSize);
					break;
			case .algo_xxh32:
					inFile.BMK_hashStream(h32, .algo_xxh32, buffer, blockSize);
					break;
			default:
					break;
			}
			.fclose(inFile);
			.free(buffer);
			.fprintf((_iob[2]), "%s             \r", fileNameEnd - /* erase line */infoFilenameSize);
		}
		switch (/* display Hash */hashType) {
		case .algo_xxh32:
				{ 
					XXH32_canonical_t hcbe32 = new XXH32_canonical_t();
					hcbe32.XXH32_canonicalFromHash(h32);
					displayEndianess == .big_endian ? ModernizedCProgram.BMK_display_BigEndian(hcbe32, ) : ModernizedCProgram.BMK_display_LittleEndian(hcbe32, );
					.fprintf((_iob[1]), "  %s\n", fileName);
					break;
				}
		case .algo_xxh64:
				{ 
					XXH64_canonical_t hcbe64 = new XXH64_canonical_t();
					hcbe64.XXH64_canonicalFromHash(h64);
					displayEndianess == .big_endian ? ModernizedCProgram.BMK_display_BigEndian(hcbe64, ) : ModernizedCProgram.BMK_display_LittleEndian(hcbe64, );
					.fprintf((_iob[1]), "  %s\n", fileName);
					break;
				}
		default:
				break;
		}
		return 0;
	}
	public static int BMK_hashFiles(Object fnList, int fnTotal,  hashType,  displayEndianess) {
		int fnNb;
		int result = 0;
		if (fnTotal == 0) {
			return ModernizedCProgram.BMK_hash(ModernizedCProgram.stdinName, hashType, displayEndianess);
		} 
		for (fnNb = 0; fnNb < fnTotal; fnNb++) {
			result += ModernizedCProgram.BMK_hash(fnList[fnNb], hashType, displayEndianess);
		}
		.fprintf((_iob[2]), "\r%70s\r", "");
		return result;
	}
	public static  getLine(byte lineBuf, int lineMax) {
		GetLineResult result = .GetLine_ok;
		int len = 0;
		if ((lineBuf == ((Object)0)) || (lineMax < 1)) {
			.free(/* in case it's != NULL */lineBuf);
			lineMax = 0;
			lineBuf = (byte).malloc(( * 2 + 2 + 4096 + 1));
			if (lineBuf == ((Object)0)) {
				return .GetLine_outOfMemory;
			} 
			lineMax = ( * 2 + 2 + 4096 + 1);
		} 
		for (; ; ) {
			int c = .fgetc(inFile);
			if (c == (true/* If we meet EOF before first character, returns GetLine_eof,
			             * otherwise GetLine_ok.
			             */)) {
				if (len == 0) {
					result = .GetLine_eof;
				} 
				break;
			} 
			if (len + 1 >= /* Make enough space for len+1 (for final NUL) bytes. */lineMax) {
				byte newLineBuf = ((Object)0);
				int newBufSize = lineMax;
				newBufSize += (newBufSize / 2) + /* x 1.5 */1;
				if (newBufSize > (32 * (1 << 10))) {
					newBufSize = (32 * (1 << 10));
				} 
				if (len + 1 >= newBufSize) {
					return .GetLine_exceedMaxLineLength;
				} 
				newLineBuf = (byte).realloc(lineBuf, newBufSize);
				if (newLineBuf == ((Object)0)) {
					return .GetLine_outOfMemory;
				} 
				lineBuf = newLineBuf;
				lineMax = newBufSize;
			} 
			if (c == (byte)'\n') {
				break;
			} 
			(lineBuf)[len++] = (byte)c;
		}
		(lineBuf)[len] = (byte)'\0';
		return result;
	}
	/*  Converts one hexadecimal character to integer.
	 *  Returns -1, if given character is not hexadecimal.
	 */
	public static int charToHex(byte c) {
		int result = -1;
		if (c >= (byte)'0' && c <= (byte)'9') {
			result = (int)(c - (byte)'0');
		}  else if (c >= (byte)'A' && c <= (byte)'F') {
			result = (int)(c - (byte)'A') + -1024;
		}  else if (c >= (byte)'a' && c <= (byte)'f') {
			result = (int)(c - (byte)'a') + -1024;
		} 
		return result/*  Converts XXH32 canonical hexadecimal string hashStr to big endian unsigned char array dst.
		 *  Returns CANONICAL_FROM_STRING_INVALID_FORMAT, if hashStr is not well formatted.
		 *  Returns CANONICAL_FROM_STRING_OK, if hashStr is parsed successfully.
		 */;
	}
	public static  canonicalFromString(Byte dst, Object dstSize, Object hashStr) {
		size_t i = new size_t();
		for (i = 0; i < dstSize; ++i) {
			int h0;
			int h1;
			h0 = ModernizedCProgram.charToHex(hashStr[i * 2 + 0]);
			if (h0 < 0) {
				return .CanonicalFromString_invalidFormat;
			} 
			h1 = ModernizedCProgram.charToHex(hashStr[i * 2 + 1]);
			if (h1 < 0) {
				return .CanonicalFromString_invalidFormat;
			} 
			dst[i] = (byte)((h0 << 4) | h1);
		}
		return .CanonicalFromString_ok/*  Parse single line of xxHash checksum file.
		 *  Returns PARSE_LINE_ERROR_INVALID_FORMAT, if line is not well formatted.
		 *  Returns PARSE_LINE_OK if line is parsed successfully.
		 *  And members of parseLine will be filled by parsed values.
		 *
		 *  - line must be ended with '\0'.
		 *  - Since parsedLine.filename will point within given argument `line`,
		 *    users must keep `line`s content during they are using parsedLine.
		 *
		 *  Given xxHash checksum line should have the following format:
		 *
		 *      <8 or 16 hexadecimal char> <space> <space> <filename...> <'\0'>
		 */;
	}
	public static  parseLine(Object line) {
		byte firstSpace = .strchr(line, (byte)' ');
		byte secondSpace = firstSpace + 1;
		this.setFilename(((Object)0));
		this.setXxhBits(0);
		if (firstSpace == ((Object)0) || secondSpace != (byte)' ') {
			return .ParseLine_invalidFormat;
		} 
		Object generatedCanonical = this.getCanonical();
		Object generatedDigest = xxh32c.getDigest();
		switch (firstSpace - line) {
		case 16:
				{ 
					XXH64_canonical_t xxh64c = generatedCanonical.getXxh64();
					if (ModernizedCProgram.canonicalFromString(generatedDigest, , line) != .CanonicalFromString_ok) {
						return .ParseLine_invalidFormat;
					} 
					this.setXxhBits(64);
					break;
				}
		case 8:
				{ 
					XXH32_canonical_t xxh32c = generatedCanonical.getXxh32();
					if (ModernizedCProgram.canonicalFromString(generatedDigest, , line) != .CanonicalFromString_ok) {
						return .ParseLine_invalidFormat;
					} 
					this.setXxhBits(32);
					break;
				}
		default:
				return .ParseLine_invalidFormat;
				break;
		}
		this.setFilename(secondSpace + 1);
		return .ParseLine_ok;
	}
	/*!  Parse xxHash checksum file.
	 */
	public static void parseFile1() {
		Object generatedInFileName = this.getInFileName();
		byte inFileName = generatedInFileName;
		Object generatedReport = this.getReport();
		ParseFileReport report = generatedReport;
		long lineNumber = 0;
		.memset(report, 0, );
		Object generatedQuit = report.getQuit();
		Object generatedLineBuf = this.getLineBuf();
		Object generatedLineMax = this.getLineMax();
		Object generatedInFile = this.getInFile();
		Object generatedNImproperlyFormattedLines = report.getNImproperlyFormattedLines();
		Object generatedWarn = this.getWarn();
		Object generatedXxhBits = report.getXxhBits();
		Object generatedNMixedFormatLines = report.getNMixedFormatLines();
		Object generatedNProperlyFormattedLines = report.getNProperlyFormattedLines();
		Object generatedFilename = parsedLine.getFilename();
		Object generatedBlockBuf = this.getBlockBuf();
		Object generatedBlockSize = this.getBlockSize();
		Object generatedCanonical = parsedLine.getCanonical();
		Object generatedNOpenOrReadFailures = report.getNOpenOrReadFailures();
		Object generatedStatusOnly = this.getStatusOnly();
		Object generatedQuiet = this.getQuiet();
		Object generatedNMismatchedChecksums = report.getNMismatchedChecksums();
		while (!generatedQuit) {
			FILE fp = ((Object)0);
			LineStatus lineStatus = .LineStatus_hashFailed;
			GetLineResult getLineResult = new GetLineResult();
			ParsedLine parsedLine = new ParsedLine();
			.memset(parsedLine, 0, );
			lineNumber++;
			if (lineNumber == 0/* This is unlikely happen, but md5sum.c has this
			             * error check. */) {
				.fprintf((_iob[2]), "%s : too many checksum lines\n", inFileName);
				report.setQuit(1);
				break;
			} 
			getLineResult = generatedInFile.getLine(generatedLineBuf, generatedLineMax);
			if (getLineResult != .GetLine_ok) {
				if (getLineResult == .GetLine_eof) {
					break;
				} 
				switch (getLineResult) {
				case .GetLine_exceedMaxLineLength:
						.fprintf((_iob[2]), "%s : %lu: too long line\n", inFileName, lineNumber);
						break;
				case .GetLine_outOfMemory:
						.fprintf((_iob[2]), "%s : %lu: out of memory\n", inFileName, lineNumber);
						break;
				case .GetLine_eof/* These cases never happen.  See above getLineResult related "if"s.
				                   They exist just for make gcc's -Wswitch-enum happy. */:
						break;
				case .GetLine_ok:
				default:
						.fprintf((_iob[2]), "%s : %lu: unknown error\n", inFileName, lineNumber);
						break;
				}
				report.setQuit(1);
				break;
			} 
			if (parsedLine.parseLine(generatedLineBuf) != .ParseLine_ok) {
				generatedNImproperlyFormattedLines++;
				if (generatedWarn) {
					.fprintf((_iob[2]), "%s : %lu: improperly formatted XXHASH checksum line\n", inFileName, lineNumber);
				} 
				continue;
			} 
			if (generatedXxhBits != 0 && generatedXxhBits != generatedXxhBits) {
				generatedNImproperlyFormattedLines++;
				generatedNMixedFormatLines++;
				if (generatedWarn) {
					.fprintf((_iob[2]), "%s : %lu: improperly formatted XXHASH checksum line (XXH32/64)\n", inFileName, lineNumber);
				} 
				continue;
			} 
			generatedNProperlyFormattedLines++;
			if (generatedXxhBits == 0) {
				report.setXxhBits(generatedXxhBits);
			} 
			fp = .fopen(generatedFilename, "rb");
			if (fp == ((Object)0)) {
				lineStatus = .LineStatus_failedToOpen;
			} else {
					lineStatus = .LineStatus_hashFailed;
					switch (generatedXxhBits) {
					case 32:
							{ 
								XXH32_hash_t xxh = new XXH32_hash_t();
								fp.BMK_hashStream(xxh, .algo_xxh32, generatedBlockBuf, generatedBlockSize);
								if (xxh == ModernizedCProgram.XXH32_hashFromCanonical(generatedCanonical.getXxh32())) {
									lineStatus = .LineStatus_hashOk;
								} 
							}
							break;
					case 64:
							{ 
								XXH64_hash_t xxh = new XXH64_hash_t();
								fp.BMK_hashStream(xxh, .algo_xxh64, generatedBlockBuf, generatedBlockSize);
								if (xxh == ModernizedCProgram.XXH64_hashFromCanonical(generatedCanonical.getXxh64())) {
									lineStatus = .LineStatus_hashOk;
								} 
							}
							break;
					default:
							break;
					}
					.fclose(fp);
			} 
			switch (lineStatus) {
			case .LineStatus_hashFailed:
					{ 
						int b = 1;
						if (lineStatus == .LineStatus_hashOk) {
							if (generatedQuiet) {
								b = /* If --quiet is specified, don't display "OK" */0;
							} 
						} else {
								generatedNMismatchedChecksums++;
						} 
						if (b && !generatedStatusOnly) {
							.fprintf((_iob[1]), "%s: %s\n", generatedFilename, lineStatus == .LineStatus_hashOk ? "OK" : "FAILED");
						} 
					}
					break;
			case .LineStatus_hashOk:
			case .LineStatus_failedToOpen:
					generatedNOpenOrReadFailures++;
					if (!generatedStatusOnly) {
						.fprintf((_iob[1]), "%s : %lu: FAILED open or read %s\n", inFileName, lineNumber, generatedFilename);
					} 
					break;
			default:
					.fprintf((_iob[2]), "%s : unknown error\n", inFileName);
					report.setQuit(1);
					break;
			}
		}
	}
	public static int checkFile(Object inFileName, Object displayEndianess, Object strictMode, Object statusOnly, Object warn, Object quiet) {
		int result = 0;
		FILE inFile = ((Object)0);
		ParseFileArg parseFileArgBody = new ParseFileArg();
		ParseFileArg parseFileArg = parseFileArgBody;
		Object generatedReport = parseFileArg.getReport();
		ParseFileReport report = generatedReport;
		if (displayEndianess != .big_endian) {
			.fprintf((_iob[2]), /* Don't accept little endian */"Check file mode doesn't support little endian\n");
			return 0;
		} 
		if (inFileName == /* note : stdinName is special constant pointer.  It is not a string. */ModernizedCProgram.stdinName/* note : Since we expect text input for xxhash -c mode,
		         * Don't set binary mode for stdin */) {
			inFile = (_iob[0]);
		} else {
				inFile = .fopen(inFileName, "rt");
		} 
		if (inFile == ((Object)0)) {
			.fprintf((_iob[2]), "Pb opening %s\n", inFileName);
			return 0;
		} 
		parseFileArg.setInFileName(inFileName);
		parseFileArg.setInFile(inFile);
		parseFileArg.setLineMax(( * 2 + 2 + 4096 + 1));
		Object generatedLineMax = parseFileArg.getLineMax();
		parseFileArg.setLineBuf((byte).malloc((size_t)generatedLineMax));
		parseFileArg.setBlockSize(64 * 1024);
		Object generatedBlockSize = parseFileArg.getBlockSize();
		parseFileArg.setBlockBuf((byte).malloc(generatedBlockSize));
		parseFileArg.setStrictMode(strictMode);
		parseFileArg.setStatusOnly(statusOnly);
		parseFileArg.setWarn(warn);
		parseFileArg.setQuiet(quiet);
		parseFileArg.parseFile1();
		Object generatedBlockBuf = parseFileArg.getBlockBuf();
		.free(generatedBlockBuf);
		Object generatedLineBuf = parseFileArg.getLineBuf();
		.free(generatedLineBuf);
		if (inFile != (_iob[0])) {
			.fclose(inFile);
		} 
		Object generatedNProperlyFormattedLines = report.getNProperlyFormattedLines();
		Object generatedNImproperlyFormattedLines = report.getNImproperlyFormattedLines();
		Object generatedNOpenOrReadFailures = report.getNOpenOrReadFailures();
		Object generatedNMismatchedChecksums = report.getNMismatchedChecksums();
		if (generatedNProperlyFormattedLines == /* Show error/warning messages.  All messages are copied from md5sum.c
		     */0) {
			.fprintf((_iob[2]), "%s: no properly formatted XXHASH checksum lines found\n", inFileName);
		}  else if (!statusOnly) {
			if (generatedNImproperlyFormattedLines) {
				.fprintf((_iob[1]), "%lu lines are improperly formatted\n", generatedNImproperlyFormattedLines);
			} 
			if (generatedNOpenOrReadFailures) {
				.fprintf((_iob[1]), "%lu listed files could not be read\n", generatedNOpenOrReadFailures);
			} 
			if (generatedNMismatchedChecksums) {
				.fprintf((_iob[1]), "%lu computed checksums did NOT match\n", generatedNMismatchedChecksums);
			} 
		} 
		Object generatedQuit = report.getQuit();
		result = generatedNProperlyFormattedLines != /* Result (exit) code logic is copied from
		     * gnu coreutils/src/md5sum.c digest_check() */0 && generatedNMismatchedChecksums == 0 && generatedNOpenOrReadFailures == 0 && (!strictMode || generatedNImproperlyFormattedLines == 0) && generatedQuit == 0;
		return result;
	}
	public static int checkFiles(Object fnList, int fnTotal, Object displayEndianess, Object strictMode, Object statusOnly, Object warn, Object quiet) {
		int ok = 1;
		if (fnTotal == /* Special case for stdinName "-",
		     * note: stdinName is not a string.  It's special pointer. */0) {
			ok &=  ModernizedCProgram.checkFile(ModernizedCProgram.stdinName, displayEndianess, strictMode, statusOnly, warn, quiet);
		} else {
				int fnNb;
				for (fnNb = 0; fnNb < fnTotal; fnNb++) {
					ok &=  ModernizedCProgram.checkFile(fnList[fnNb], displayEndianess, strictMode, statusOnly, warn, quiet);
				}
		} 
		return ok ? 0 : 1/* ********************************************************
		*  Main
		**********************************************************/;
	}
	public static int usage(Object exename) {
		.fprintf((_iob[2]), "%s %s (%i-bits %s), by %s \n", exename, "0.6.5", ModernizedCProgram.g_nbBits, (ModernizedCProgram.BMK_isLittleEndian() ? ModernizedCProgram.g_lename : ModernizedCProgram.g_bename), ModernizedCProgram.author);
		.fprintf((_iob[2]), "Usage :\n");
		.fprintf((_iob[2]), "      %s [arg] [filenames]\n", exename);
		.fprintf((_iob[2]), "When no filename provided, or - provided : use stdin as input\n");
		.fprintf((_iob[2]), "Arguments :\n");
		.fprintf((_iob[2]), " -H# : hash selection : 0=32bits, 1=64bits (default: %i)\n", (int)ModernizedCProgram.g_defaultAlgo);
		.fprintf((_iob[2]), " -c  : read xxHash sums from the [filenames] and check them\n");
		.fprintf((_iob[2]), " -h  : help \n");
		return 0;
	}
	public static int usage_advanced(Object exename) {
		ModernizedCProgram.usage(exename);
		.fprintf((_iob[2]), "Advanced :\n");
		.fprintf((_iob[2]), " --little-endian : hash printed using little endian convention (default: big endian)\n");
		.fprintf((_iob[2]), " -V, --version   : display version\n");
		.fprintf((_iob[2]), " -h, --help      : display long help and exit\n");
		.fprintf((_iob[2]), " -b  : benchmark mode \n");
		.fprintf((_iob[2]), " -i# : number of iterations (benchmark mode; default %i)\n", ModernizedCProgram.g_nbIterations);
		.fprintf((_iob[2]), "\n");
		.fprintf((_iob[2]), "The following four options are useful only when verifying checksums (-c):\n");
		.fprintf((_iob[2]), "--strict : don't print OK for each successfully verified file\n");
		.fprintf((_iob[2]), "--status : don't output anything, status code shows success\n");
		.fprintf((_iob[2]), "--quiet  : exit non-zero for improperly formatted checksum lines\n");
		.fprintf((_iob[2]), "--warn   : warn about improperly formatted checksum lines\n");
		return 0;
	}
	public static int badusage(Object exename) {
		.fprintf((_iob[2]), "Wrong parameters\n");
		ModernizedCProgram.usage(exename);
		return 1/*! readU32FromChar() :
		   @return : unsigned integer value read from input in `char` format,
		             0 is no figure at *stringPtr position.
		    Interprets K, KB, KiB, M, MB and MiB suffix.
		    Modifies `*stringPtr`, advancing it to position where reading stopped.
		    Note : function result can overflow if digit string > MAX_UINT */;
	}
	public static int readU32FromChar(Object stringPtr) {
		int result = 0;
		while ((stringPtr >= (byte)'0') && (stringPtr <= (byte)'9')) {
			;
		}
		if ((stringPtr == (byte)'K') || (stringPtr == (byte)'M')) {
			result <<=  10;
			if (stringPtr == (byte)'M') {
				result <<=  10;
			} 
			(stringPtr)++;
			if (stringPtr == (byte)'i') {
				(stringPtr)++;
			} 
			if (stringPtr == (byte)'B') {
				(stringPtr)++;
			} 
		} 
		return result;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int sort_by_salt_buf(Object v1, Object v2, Object v3) {
		return ModernizedCProgram.sort_by_salt(v1, v2);
	}
	public static Object thread_outfile_remove(Object p) {
		hashcat_ctx_t hashcat_ctx = (hashcat_ctx_t)p;
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		outcheck_ctx generatedOutcheck_ctx = hashcat_ctx.getOutcheck_ctx();
		outcheck_ctx_t outcheck_ctx = generatedOutcheck_ctx;
		if (hashconfig.getOutfile_check_disable() == 1) {
			return ((Object)0);
		} 
		if (outcheck_ctx.getEnabled() == 0) {
			return ((Object)0);
		} 
		int rc = hashcat_ctx.outfile_remove();
		if (rc == -1) {
			return ((Object)0);
		} 
		return ((Object)0);
	}
	/* fitblk.c: example of fitting compressed output to a specified size
	   Not copyrighted -- provided to the public domain
	   Version 1.1  25 November 2004  Mark Adler */
	/* Version history:
	   1.0  24 Nov 2004  First version
	   1.1  25 Nov 2004  Change deflateInit2() to deflateInit()
	                     Use fixed-size, stack-allocated raw buffers
	                     Simplify code moving compression to subroutines
	                     Use assert() for internal errors
	                     Add detailed description of approach
	 */
	/* Approach to just fitting a requested compressed size:
	
	   fitblk performs three compression passes on a portion of the input
	   data in order to determine how much of that input will compress to
	   nearly the requested output block size.  The first pass generates
	   enough deflate blocks to produce output to fill the requested
	   output size plus a specfied excess amount (see the EXCESS define
	   below).  The last deflate block may go quite a bit past that, but
	   is discarded.  The second pass decompresses and recompresses just
	   the compressed data that fit in the requested plus excess sized
	   buffer.  The deflate process is terminated after that amount of
	   input, which is less than the amount consumed on the first pass.
	   The last deflate block of the result will be of a comparable size
	   to the final product, so that the header for that deflate block and
	   the compression ratio for that block will be about the same as in
	   the final product.  The third compression pass decompresses the
	   result of the second step, but only the compressed data up to the
	   requested size minus an amount to allow the compressed stream to
	   complete (see the MARGIN define below).  That will result in a
	   final compressed stream whose length is less than or equal to the
	   requested size.  Assuming sufficient input and a requested size
	   greater than a few hundred bytes, the shortfall will typically be
	   less than ten bytes.
	
	   If the input is short enough that the first compression completes
	   before filling the requested output size, then that compressed
	   stream is return with no recompression.
	
	   EXCESS is chosen to be just greater than the shortfall seen in a
	   two pass approach similar to the above.  That shortfall is due to
	   the last deflate block compressing more efficiently with a smaller
	   header on the second pass.  EXCESS is set to be large enough so
	   that there is enough uncompressed data for the second pass to fill
	   out the requested size, and small enough so that the final deflate
	   block of the second pass will be close in size to the final deflate
	   block of the third and final pass.  MARGIN is chosen to be just
	   large enough to assure that the final compression has enough room
	   to complete in all cases.
	 */
	/* print nastygram and leave */
	public static void quit(Byte why) {
		.fprintf((_iob[2]), "fitblk abort: %s\n", why);
		.exit(1/* intermediate uncompressed buffer size */);
	}
	/* compress from file to def until provided buffer is full or end of
	   input reached; return last deflate() return value, or Z_ERRNO if
	   there was read error on the file */
	public static int partcompress(Object def) {
		int ret;
		int flush;
		byte[] raw = new byte[4096];
		flush = 0;
		Object generated_flag = (in).get_flag();
		do {
			def.setAvail_in(.fread(raw, 1, 4096, in));
			if ((generated_flag & -1024)) {
				return (true);
			} 
			def.setNext_in(raw);
			if ((generated_flag & -1024)) {
				flush = 4;
			} 
			ret = ModernizedCProgram.deflate(def, flush);
			((ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\fitblk.c", 87));
		} while (def.getAvail_out() != 0 && flush == 0);
		return ret/* recompress from inf's input to def's output; the input for inf and
		   the output for def are set in those structures before calling;
		   return last deflate() return value, or Z_MEM_ERROR if inflate()
		   was not able to allocate enough memory when it needed to */;
	}
	public static int recompress(Object inf, Object def) {
		int ret;
		int flush;
		byte[] raw = new byte[4096];
		flush = 0;
		do {
			inf.setAvail_out(/* decompress */4096);
			inf.setNext_out(raw);
			ret = ModernizedCProgram.inflate(inf, 0);
			((ret != (true) && ret != (true) && ret != 2) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR && ret != Z_DATA_ERROR && ret != Z_NEED_DICT", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\fitblk.c", 108));
			if (ret == (true)) {
				return ret;
			} 
			def.setAvail_in(4096 - inf.getAvail_out());
			def.setNext_in(raw);
			if (inf.getAvail_out() != 0) {
				flush = 4;
			} 
			ret = ModernizedCProgram.deflate(def, flush);
			((ret != (true)) ? (Object)0 : ._assert("ret != Z_STREAM_ERROR", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\fitblk.c", 118));
		} while (ret != 1 && def.getAvail_out() != 0);
		return ret/* empirically determined stream overage */;
	}
	public static void AesCbc_Encode_Intel(Object p, Object data, Object numBlocks) {
		ModernizedCProgram.AesCbc_Encode(p, data, numBlocks);
	}
	public static void AesCbc_Decode_Intel(Object p, Object data, Object numBlocks) {
		ModernizedCProgram.AesCbc_Decode(p, data, numBlocks);
	}
	public static void AesCtr_Code_Intel(Object p, Object data, Object numBlocks) {
		ModernizedCProgram.AesCtr_Code(p, data, numBlocks);
	}
	public static Object XzBlock_ReadHeader( p, ISeqInStream inStream, Object isIndex, Object headerSizeRes) {
		Byte[] header = new Byte();
		int headerSize;
		headerSizeRes = 0;
		{ 
			int __result__ = (ModernizedCProgram.SeqInStream_ReadByte(inStream, header[0]));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		headerSize = (int)header[0];
		if (headerSize == 0) {
			headerSizeRes = 1;
			isIndex = 1;
			return 0;
		} 
		isIndex = 0;
		headerSize = (headerSize << 2) + 4;
		headerSizeRes = headerSize;
		{ 
			int __result__ = (ModernizedCProgram.SeqInStream_Read(inStream, header + 1, headerSize - 1));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		return p.XzBlock_Parse(header);
	}
	public static Object Xz_GetUnpackSize(Object p) {
		UInt64 size = 0;
		size_t i = new size_t();
		for (i = 0; i < p.getNumBlocks(); i++) {
			UInt64 newSize = size + (p.getBlocks()[i].getUnpackSize());
			if (newSize < size) {
				return ((UInt64)(Int64)-1);
			} 
			size = newSize;
		}
		;
		return size;
	}
	public static Object Xz_GetPackSize(Object p) {
		UInt64 size = 0;
		size_t i = new size_t();
		for (i = 0; i < p.getNumBlocks(); i++) {
			UInt64 newSize = size + ((p.getBlocks()[i].getTotalSize() + 3) & ~(UInt64)3);
			if (newSize < size) {
				return ((UInt64)(Int64)-1);
			} 
			size = newSize;
		}
		;
		return size/*
		SRes XzBlock_ReadFooter(CXzBlock *p, CXzStreamFlags f, ISeqInStream *inStream)
		{
		  return SeqInStream_Read(inStream, p->check, XzFlags_GetCheckSize(f));
		}
		*/;
	}
	public static Object Xz_ReadIndex2(Object buf, Object size, Object alloc) {
		size_t numBlocks = new size_t();
		size_t pos = 1;
		UInt32 crc = new UInt32();
		if (size < 5 || buf[0] != 0) {
			return 16;
		} 
		size -= 4;
		crc = ModernizedCProgram.CrcCalc(buf, size);
		if (crc != ((UInt32)(Object)(buf + size))) {
			return 16;
		} 
		{ 
			UInt64 numBlocks64 = new UInt64();
			{ 
				int s = ModernizedCProgram.Xz_ReadVarInt(buf + pos, size - pos, numBlocks64);
				if (s == 0) {
					return 16;
				} 
				pos += s;
			}
			;
			numBlocks = (size_t)numBlocks64;
			if (numBlocks != numBlocks64 || numBlocks * 2 > size) {
				return 16;
			} 
		}
		p.Xz_Free(alloc);
		Object generatedBlocks = this.getBlocks();
		Object generatedTotalSize = block.getTotalSize();
		Object generatedUnpackSize = block.getUnpackSize();
		if (numBlocks != 0) {
			size_t i = new size_t();
			this.setNumBlocks(numBlocks);
			this.setBlocks((CXzBlockSizes).UNRECOGNIZEDFUNCTIONNAME(alloc,  * numBlocks));
			if (!generatedBlocks) {
				return 2;
			} 
			for (i = 0; i < numBlocks; i++) {
				CXzBlockSizes block = generatedBlocks[i];
				{ 
					int s = ModernizedCProgram.Xz_ReadVarInt(buf + pos, size - pos, generatedTotalSize);
					if (s == 0) {
						return 16;
					} 
					pos += s;
				}
				;
				{ 
					int s = ModernizedCProgram.Xz_ReadVarInt(buf + pos, size - pos, generatedUnpackSize);
					if (s == 0) {
						return 16;
					} 
					pos += s;
				}
				;
				if (generatedTotalSize == 0) {
					return 16;
				} 
			}
		} 
		while ((pos & 3) != 0) {
			if (buf[pos++] != 0) {
				return 16;
			} 
		}
		return (pos == size) ? 0 : 16;
	}
	public static Object Xz_ReadIndex( p, ILookInStream stream, Object indexSize, Object alloc) {
		SRes res = new SRes();
		size_t size = new size_t();
		Byte buf = new Byte();
		if (indexSize > ((UInt32)1 << 31)) {
			return 4;
		} 
		size = (size_t)indexSize;
		if (size != indexSize) {
			return 4;
		} 
		buf = (Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, size);
		if (!buf) {
			return 2;
		} 
		res = ModernizedCProgram.LookInStream_Read2(stream, buf, size, 4);
		if (res == 0) {
			res = p.Xz_ReadIndex2(buf, size, alloc);
		} 
		.UNRECOGNIZEDFUNCTIONNAME(alloc, buf);
		return res;
	}
	public static Object Xz_ReadBackward( p, ILookInStream stream, Object startOffset, Object alloc) {
		UInt64 indexSize = new UInt64();
		Byte[] buf = new Byte();
		UInt64 pos = startOffset;
		if ((pos & 3) != 0 || pos < (2 + 2 + 4 + 4)) {
			return 17;
		} 
		pos -= (2 + 2 + 4 + 4);
		{ 
			int __result__ = (stream.LookInStream_SeekRead_ForArc(pos, buf, (2 + 2 + 4 + 4)));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		if (!((buf + 10)[0] == (byte)'Y' && (buf + 10)[1] == (byte)'Z')) {
			UInt32 total = 0;
			pos += (2 + 2 + 4 + 4);
			for (; ; ) {
				size_t i = new size_t();
				Byte[] temp = new Byte();
				i = (pos > (1 << 10)) ? (1 << 10) : (size_t)pos;
				pos -= i;
				{ 
					int __result__ = (stream.LookInStream_SeekRead_ForArc(pos, temp, i));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				total += (UInt32)i;
				for (; i != 0; i--) {
					if (temp[i - 1] != 0) {
						break;
					} 
				}
				if (i != 0) {
					if ((i & 3) != 0) {
						return 17;
					} 
					pos += i;
					break;
				} 
				if (pos < (2 + 2 + 4 + 4) || total > (1 << 16)) {
					return 17;
				} 
			}
			if (pos < (2 + 2 + 4 + 4)) {
				return 17;
			} 
			pos -= (2 + 2 + 4 + 4);
			{ 
				int __result__ = (stream.LookInStream_SeekRead_ForArc(pos, buf, (2 + 2 + 4 + 4)));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (!((buf + 10)[0] == (byte)'Y' && (buf + 10)[1] == (byte)'Z')) {
				return 17;
			} 
		} 
		p.setFlags((CXzStreamFlags)((UInt16)(((UInt16)((Byte)(buf + 8))[0] << 8) | ((Byte)(buf + 8))[1])));
		Object generatedFlags = p.getFlags();
		if (!((generatedFlags) <= -1024)) {
			return 4;
		} 
		if (((UInt32)(Object)(buf)) != ModernizedCProgram.CrcCalc(buf + 4, 6)) {
			return 16;
		} 
		indexSize = ((UInt64)((UInt32)(Object)(buf + 4)) + 1) << 2;
		if (pos < indexSize) {
			return 16;
		} 
		pos -= indexSize;
		{ 
			int __result__ = (ModernizedCProgram.LookInStream_SeekTo(stream, pos));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		{ 
			int __result__ = (ModernizedCProgram.Xz_ReadIndex(p, stream, indexSize, alloc));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		{ 
			UInt64 totalSize = ModernizedCProgram.Xz_GetPackSize(p);
			if (totalSize == ((UInt64)(Int64)-1) || totalSize >= ((UInt64)1 << 63) || pos < totalSize + (6 + 2 + 4)) {
				return 16;
			} 
			pos -= (totalSize + (6 + 2 + 4));
			{ 
				int __result__ = (ModernizedCProgram.LookInStream_SeekTo(stream, pos));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			startOffset = pos;
		}
		Object generatedVt = secToRead.getVt();
		{ 
			CXzStreamFlags headerFlags = new CXzStreamFlags();
			CSecToRead secToRead = new CSecToRead();
			secToRead.SecToRead_CreateVTable();
			secToRead.setRealStream(stream);
			{ 
				int __result__ = (generatedVt.Xz_ReadHeader(headerFlags));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			return (generatedFlags == headerFlags) ? 0 : 16;
		}
	}
	/* ---------- Xz Streams ---------- */
	public static void Xzs_Construct() {
		this.setNum(this.setNumAllocated(0));
		this.setStreams(0);
	}
	public static void Xzs_Free(Object alloc) {
		size_t i = new size_t();
		Object generatedNum = this.getNum();
		Object generatedStreams = this.getStreams();
		for (i = 0; i < generatedNum; i++) {
			generatedStreams[i].Xz_Free(alloc);
		}
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedStreams);
		this.setNum(this.setNumAllocated(0));
		this.setStreams(0);
	}
	public static Object Xzs_GetNumBlocks(Object p) {
		UInt64 num = 0;
		size_t i = new size_t();
		for (i = 0; i < p.getNum(); i++) {
			num += p.getStreams()[i].getNumBlocks();
		}
		return num;
	}
	public static Object Xzs_GetUnpackSize(Object p) {
		UInt64 size = 0;
		size_t i = new size_t();
		for (i = 0; i < p.getNum(); i++) {
			UInt64 newSize = size + (ModernizedCProgram.Xz_GetUnpackSize(p.getStreams()[i]));
			if (newSize < size) {
				return ((UInt64)(Int64)-1);
			} 
			size = newSize;
		}
		;
		return size/*
		UInt64 Xzs_GetPackSize(const CXzs *p)
		{
		  UInt64 size = 0;
		  size_t i;
		  for (i = 0; i < p->num; i++)
		    ADD_SIZE_CHECK(size, Xz_GetTotalSize(&p->streams[i]));
		  return size;
		}
		*/;
	}
	public static Object Xzs_ReadBackward( p, ILookInStream stream, Object startOffset, ICompressProgress progress, Object alloc) {
		Int64 endOffset = 0;
		{ 
			int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(stream, endOffset, .SZ_SEEK_END));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		startOffset = endOffset;
		Object generatedNum = p.getNum();
		Object generatedNumAllocated = p.getNumAllocated();
		Object generatedStreams = p.getStreams();
		for (; ; ) {
			CXzStream st = new CXzStream();
			SRes res = new SRes();
			st.Xz_Construct();
			res = ModernizedCProgram.Xz_ReadBackward(st, stream, startOffset, alloc);
			st.setStartOffset(startOffset);
			{ 
				int __result__ = (res);
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (generatedNum == generatedNumAllocated) {
				size_t newNum = generatedNum + generatedNum / 4 + 1;
				Byte data = (Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, newNum * );
				if (!data) {
					return 2;
				} 
				p.setNumAllocated(newNum);
				if (generatedNum != 0) {
					.memcpy(data, generatedStreams, generatedNum * );
				} 
				.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedStreams);
				p.setStreams((CXzStream)data);
			} 
			generatedStreams[generatedNum++] = st;
			if (startOffset == 0) {
				break;
			} 
			{ 
				int __result__ = (ModernizedCProgram.LookInStream_SeekTo(stream, startOffset));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (progress && .UNRECOGNIZEDFUNCTIONNAME(progress, endOffset - startOffset, (UInt64)(Int64)-1) != 0) {
				return 10;
			} 
		}
		return 0;
	}
	public static Object gzfilebuf() {
		// No buffers to start with// No buffers to start with.UNRECOGNIZEDFUNCTIONNAME();
	}
	public static Object ~gzfilebuf() {
		ModernizedCProgram.sync();
		if (own_file_descriptor) {
			ModernizedCProgram.close();
		} 
		// Sync output buffer and close only if responsible for file// (i.e. attached streams should be left open at this stage)// Sync output buffer and close only if responsible for file// (i.e. attached streams should be left open at this stage).UNRECOGNIZEDFUNCTIONNAME();
		if (own_fd) {
			.UNRECOGNIZEDFUNCTIONNAME();
		} 
		.UNRECOGNIZEDFUNCTIONNAME()// Set compression level and strategy;// Set compression level and strategy
	}
	public static gzfilebuf open(Object name, int io_mode) {
		if (.is_open()) {
			return 0;
		} 
		byte[] char_mode = new byte[10];
		byte p = char_mode;
		if (io_mode & in) {
			mode = in;
			p++ = (byte)'r';
		}  else if (io_mode & app) {
			mode = app;
			p++ = (byte)'a';
		} else {
				mode = out;
				p++ = (byte)'w';
		} 
		if (io_mode & binary) {
			mode |=  binary;
			p++ = (byte)'b';
		} 
		// Hard code the compression levelif (io_mode & (out | app)) {
			p++ = (byte)'9';
		} 
		// Put the end-of-string indicator// Put the end-of-string indicatorp = (byte)'\0';
		if ((file = ModernizedCProgram.gzopen(name, char_mode)) == 0) {
			return 0;
		} 
		own_file_descriptor = 1;
		return ;
		if (!.UNRECOGNIZEDFUNCTIONNAME(name, io_mode)) {
			.clear(failbit | badbit);
		} else {
				.clear();
		} 
		// Fail if file already openif (.UNRECOGNIZEDFUNCTIONNAME()) {
			return 0;
		} 
		if ((mode & in) && (mode & out)) {
			return 0;
		} 
		// Build mode string for gzopen and check it [27.8.1.3.2]byte[] char_mode = "\0\0\0\0\0";
		if (!.UNRECOGNIZEDFUNCTIONNAME(mode, char_mode)) {
			return 0;
		} 
		// Attempt to open fileif ((file = ModernizedCProgram.gzopen(name, char_mode)) == 0) {
			return 0;
		} 
		// On success, allocate internal buffer and set flags// On success, allocate internal buffer and set flags.UNRECOGNIZEDFUNCTIONNAME();
		io_mode = mode;
		own_fd = true;
		return ;// Attach to gzipped file
		if (!.UNRECOGNIZEDFUNCTIONNAME(name, mode | in)) {
			.UNRECOGNIZEDFUNCTIONNAME(failbit);
		} else {
				.UNRECOGNIZEDFUNCTIONNAME();
		} 
		if (!.UNRECOGNIZEDFUNCTIONNAME(name, mode | out)) {
			.UNRECOGNIZEDFUNCTIONNAME(failbit);
		} else {
				.UNRECOGNIZEDFUNCTIONNAME();
		} 
	}
	public static gzfilebuf attach(int file_descriptor, int io_mode) {
		if (.is_open()) {
			return 0;
		} 
		byte[] char_mode = new byte[10];
		byte p = char_mode;
		if (io_mode & in) {
			mode = in;
			p++ = (byte)'r';
		}  else if (io_mode & app) {
			mode = app;
			p++ = (byte)'a';
		} else {
				mode = out;
				p++ = (byte)'w';
		} 
		if (io_mode & binary) {
			mode |=  binary;
			p++ = (byte)'b';
		} 
		// Hard code the compression levelif (io_mode & (out | app)) {
			p++ = (byte)'9';
		} 
		// Put the end-of-string indicator// Put the end-of-string indicatorp = (byte)'\0';
		if ((file = ModernizedCProgram.gzdopen(file_descriptor, char_mode)) == 0) {
			return 0;
		} 
		own_file_descriptor = 0;
		return ;
		if (!.UNRECOGNIZEDFUNCTIONNAME(fd, io_mode)) {
			.clear(failbit | badbit);
		} else {
				.clear();
		} 
		// Fail if file already openif (.UNRECOGNIZEDFUNCTIONNAME()) {
			return 0;
		} 
		if ((mode & in) && (mode & out)) {
			return 0;
		} 
		// Build mode string for gzdopen and check it [27.8.1.3.2]byte[] char_mode = "\0\0\0\0\0";
		if (!.UNRECOGNIZEDFUNCTIONNAME(mode, char_mode)) {
			return 0;
		} 
		// Attempt to attach to fileif ((file = ModernizedCProgram.gzdopen(fd, char_mode)) == 0) {
			return 0;
		} 
		// On success, allocate internal buffer and set flags// On success, allocate internal buffer and set flags.UNRECOGNIZEDFUNCTIONNAME();
		io_mode = mode;
		own_fd = false;
		return ;
		if (!.UNRECOGNIZEDFUNCTIONNAME(fd, mode | in)) {
			.UNRECOGNIZEDFUNCTIONNAME(failbit);
		} else {
				.UNRECOGNIZEDFUNCTIONNAME();
		} 
		if (!.UNRECOGNIZEDFUNCTIONNAME(fd, mode | out)) {
			.UNRECOGNIZEDFUNCTIONNAME(failbit);
		} else {
				.UNRECOGNIZEDFUNCTIONNAME();
		} 
	}
	public static gzfilebuf close() {
		if (.is_open()) {
			ModernizedCProgram.sync();
			ModernizedCProgram.gzclose(file);
			file = 0;
		} 
		return ;
		if (!.UNRECOGNIZEDFUNCTIONNAME()) {
			.clear(failbit | badbit);
		} 
		// Fail immediately if no file is openif (!.UNRECOGNIZEDFUNCTIONNAME()) {
			return 0;
		} 
		gzfilebuf retval = ;
		// Attempt to sync and close gzipped file
		if (.UNRECOGNIZEDFUNCTIONNAME() == -1) {
			retval = 0;
		} 
		if (ModernizedCProgram.gzclose(file) < 0) {
			retval = 0;
		} 
		file = 0;
		own_fd = false// Destroy internal buffer if it exists;// Destroy internal buffer if it exists
		.UNRECOGNIZEDFUNCTIONNAME();
		return retval/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */;// Convert int open mode to mode string
		if (!.UNRECOGNIZEDFUNCTIONNAME()) {
			.UNRECOGNIZEDFUNCTIONNAME(failbit/*****************************************************************************/);
		} 
		if (!.UNRECOGNIZEDFUNCTIONNAME()) {
			.UNRECOGNIZEDFUNCTIONNAME(failbit);
		} 
	}
	public static int setcompressionlevel(int comp_level) {
		return ModernizedCProgram.gzsetparams(file, comp_level, -2);
	}
	public static int setcompressionstrategy(int comp_strategy) {
		return ModernizedCProgram.gzsetparams(file, -2, comp_strategy);
	}
	public static Object seekoff(Object off, Object dir, int which) {
		return .streampos(EOF);
	}
	public static int underflow() {
		// If the file hasn't been opened for reading, error.if (!.is_open() || !(mode & in)) {
			return EOF;
		} 
		// if a buffer doesn't exists, allocate one.if (!.base()) {
			if ((.allocate()) == EOF) {
				return EOF;
			} 
			.setp(0, 0);
		} else {
				if (.in_avail()) {
					return (byte).gptr();
				} 
				if (.out_waiting()) {
					if (ModernizedCProgram.flushbuf() == EOF) {
						return EOF;
					} 
				} 
		} 
		// Attempt to fill the buffer.int result = ModernizedCProgram.fillbuf();
		if (result == EOF) {
			.setg(0, 0, 0);
			return EOF;
		} 
		// disable get area
		return (byte).gptr();
		// If something is left in the get area by chance, return it// (this shouldn't normally happen, as underflow is only supposed// to be called when gptr >= egptr, but it serves as error check)if (.UNRECOGNIZEDFUNCTIONNAME() && (.UNRECOGNIZEDFUNCTIONNAME() < .UNRECOGNIZEDFUNCTIONNAME())) {
			return .to_int_type((.UNRECOGNIZEDFUNCTIONNAME()));
		} 
		// If the file hasn't been opened for reading, produce errorif (!.UNRECOGNIZEDFUNCTIONNAME() || !(io_mode & in)) {
			return .eof();
		} 
		// (buffer must be guaranteed to exist...)int bytes_read = ModernizedCProgram.gzread(file, buffer, buffer_size);
		// Indicates error or EOF
		if (bytes_read <= 0) {
			.UNRECOGNIZEDFUNCTIONNAME(buffer, buffer, buffer);
			return .eof();
		} 
		// Make all bytes read from file available as get area// Make all bytes read from file available as get area.UNRECOGNIZEDFUNCTIONNAME(buffer, buffer, buffer + bytes_read);
		// Return next character in get areareturn .to_int_type((.UNRECOGNIZEDFUNCTIONNAME()));// Write put area to gzipped file
	}
	public static int overflow(int c) {
		if (!.is_open() || !(mode & out)) {
			return EOF;
		} 
		if (!.base()) {
			if (.allocate() == EOF) {
				return EOF;
			} 
			.setg(0, 0, 0);
		} else {
				if (.in_avail()) {
					return EOF;
				} 
				if (.out_waiting()) {
					if (ModernizedCProgram.flushbuf() == EOF) {
						return EOF;
					} 
				} 
		} 
		int bl = .blen();
		.setp(.base(), .base() + bl);
		if (c != EOF) {
			.pptr() = c;
			.pbump(1);
		} 
		return 0;
		// Determine whether put area is in useif (.UNRECOGNIZEDFUNCTIONNAME()) {
			if (.UNRECOGNIZEDFUNCTIONNAME() > .UNRECOGNIZEDFUNCTIONNAME() || .UNRECOGNIZEDFUNCTIONNAME() < .UNRECOGNIZEDFUNCTIONNAME()) {
				return .eof();
			} 
			if (!.eq_int_type(c, .eof())) {
				(.UNRECOGNIZEDFUNCTIONNAME()) = .to_char_type(c);
				.UNRECOGNIZEDFUNCTIONNAME(1);
			} 
			int bytes_to_write = .UNRECOGNIZEDFUNCTIONNAME() - .UNRECOGNIZEDFUNCTIONNAME();
			if (bytes_to_write > 0) {
				if (!.UNRECOGNIZEDFUNCTIONNAME() || !(io_mode & out)) {
					return .eof();
				} 
				if (ModernizedCProgram.gzwrite(file, .UNRECOGNIZEDFUNCTIONNAME(), bytes_to_write) != bytes_to_write) {
					return .eof();
				} 
				.UNRECOGNIZEDFUNCTIONNAME(-bytes_to_write);
			} 
		}  else if (!.eq_int_type(c, .eof())) {
			if (!.UNRECOGNIZEDFUNCTIONNAME() || !(io_mode & out)) {
				return .eof();
			} 
			char_type last_char = .to_char_type(c);
			if (ModernizedCProgram.gzwrite(file, last_char, 1) != 1) {
				return .eof();
			} 
		} 
		// If you got here, you have succeeded (even if c was EOF)// The return value should therefore be non-EOFif (.eq_int_type(c, .eof())) {
			return .not_eof(c);
		} else {
				return c;
		} 
	}
	public static int sync() {
		if (!.is_open()) {
			return EOF;
		} 
		if (.out_waiting()) {
			return ModernizedCProgram.flushbuf();
		} 
		return 0;
		return .eq_int_type(.UNRECOGNIZEDFUNCTIONNAME(), .eof()) ? -1 : 0/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */;// Allocate internal buffer
	}
	public static int flushbuf() {
		int n;
		byte q;
		q = .pbase();
		n = .pptr() - q;
		if (ModernizedCProgram.gzwrite(file, q, n) < n) {
			return EOF;
		} 
		.setp(0, 0);
		return 0;
	}
	public static int fillbuf() {
		int required;
		byte p;
		p = .base();
		required = .blen();
		int t = ModernizedCProgram.gzread(file, p, required);
		if (t <= 0) {
			return EOF;
		} 
		.setg(.base(), .base(), .base() + t);
		return t;
	}
	public static Object gzfilestream_common() {
	}
	public static Object ~gzfilestream_common() {
	}
	public static gzfilebuf rdbuf() {
		return buffer;
	}
	public static Object gzifstream() {
		.clear(badbit);
		ModernizedCProgram.open(name, io_mode);
		ModernizedCProgram.attach(fd, io_mode);
		.UNRECOGNIZEDFUNCTIONNAME(sb)// Initialize stream buffer and open file;// Initialize stream buffer and open file
		.UNRECOGNIZEDFUNCTIONNAME(sb);
		.UNRECOGNIZEDFUNCTIONNAME(name, mode)// Initialize stream buffer and attach to file;// Initialize stream buffer and attach to file
		.UNRECOGNIZEDFUNCTIONNAME(sb);
		.UNRECOGNIZEDFUNCTIONNAME(fd, mode)// Open file and go into fail() state if unsuccessful;// Open file and go into fail() state if unsuccessful
	}
	public static Object ~gzifstream() {
	}
	public static Object gzofstream() {
		.clear(badbit);
		ModernizedCProgram.open(name, io_mode);
		ModernizedCProgram.attach(fd, io_mode);
		.UNRECOGNIZEDFUNCTIONNAME(sb)// Initialize stream buffer and open file;// Initialize stream buffer and open file
		.UNRECOGNIZEDFUNCTIONNAME(sb);
		.UNRECOGNIZEDFUNCTIONNAME(name, mode)// Initialize stream buffer and attach to file;// Initialize stream buffer and attach to file
		.UNRECOGNIZEDFUNCTIONNAME(sb);
		.UNRECOGNIZEDFUNCTIONNAME(fd, mode)// Open file and go into fail() state if unsuccessful;// Open file and go into fail() state if unsuccessful
	}
	public static Object ~gzofstream() {
	}
	/* Ppmd7Enc.c -- PPMdH Encoder
	2017-04-03 : Igor Pavlov : Public domain
	This code is based on PPMd var.H (2001): Dmitry Shkarin : Public domain */
	public static void Ppmd7z_RangeEnc_Init() {
		this.setLow(0);
		this.setRange(-1024);
		this.setCache(0);
		this.setCacheSize(1);
	}
	public static void RangeEnc_Encode(Object start, Object size, Object total) {
		Object generatedLow = this.getLow();
		Object generatedRange = this.getRange();
		generatedLow += start * (generatedRange /= total);
		generatedRange *= size;
		while (generatedRange < (1 << 24)) {
			generatedRange <<=  8;
			p.RangeEnc_ShiftLow();
		}
	}
	public static void RangeEnc_EncodeBit_1(Object size0) {
		Object generatedRange = this.getRange();
		UInt32 newBound = (generatedRange >> 14) * size0;
		Object generatedLow = this.getLow();
		generatedLow += newBound;
		generatedRange -= newBound;
		while (generatedRange < (1 << 24)) {
			generatedRange <<=  8;
			p.RangeEnc_ShiftLow();
		}
	}
	public static void Ppmd7z_RangeEnc_FlushData() {
		int i;
		for (i = 0; i < 5; i++) {
			p.RangeEnc_ShiftLow();
		}
	}
	public static void Ppmd7_EncodeSymbol( rc, int symbol) {
		size_t[] charMask = new size_t();
		Object generatedMinContext = this.getMinContext();
		Object generatedSymbol = s.getSymbol();
		Object generatedFreq = s.getFreq();
		Object generatedHB2Flag = this.getHB2Flag();
		Object generatedBinSumm = this.getBinSumm();
		Object generatedPrevSuccess = this.getPrevSuccess();
		Object generatedNS2BSIndx = this.getNS2BSIndx();
		Object generatedRunLength = this.getRunLength();
		if (generatedMinContext.getNumStats() != 1) {
			CPpmd_State s = ((generatedMinContext).getStats());
			UInt32 sum = new UInt32();
			int i;
			if (generatedSymbol == symbol) {
				rc.RangeEnc_Encode(0, generatedFreq, generatedMinContext.getSummFreq());
				this.setFoundState(s);
				p.Ppmd7_Update1_0();
				return ;
			} 
			this.setPrevSuccess(0);
			sum = generatedFreq;
			i = generatedMinContext.getNumStats() - 1;
			do {
				if (generatedSymbol == symbol) {
					rc.RangeEnc_Encode(sum, generatedFreq, generatedMinContext.getSummFreq());
					this.setFoundState(s);
					p.Ppmd7_Update1();
					return ;
				} 
				sum += generatedFreq;
			} while (--i);
			this.setHiBitsFlag(generatedHB2Flag[generatedSymbol]);
			{ 
				size_t z = new size_t();
				for (z = 0; z < 256 / ; z += 8) {
					charMask[z + 7] = charMask[z + 6] = charMask[z + 5] = charMask[z + 4] = charMask[z + 3] = charMask[z + 2] = charMask[z + 1] = charMask[z + 0] = ~(size_t)0;
				}
			}
			;
			((byte)charMask)[generatedSymbol] = 0;
			i = generatedMinContext.getNumStats() - 1;
			do {
				((byte)charMask)[generatedSymbol] = 0;
			} while (--i);
			rc.RangeEnc_Encode(sum, generatedMinContext.getSummFreq() - sum, generatedMinContext.getSummFreq());
		} else {
				UInt16 prob = generatedBinSumm[(size_t)(int)generatedFreq - 1][generatedPrevSuccess + generatedNS2BSIndx[(size_t)(generatedMinContext.getSuffix()).getNumStats() - 1] + (this.setHiBitsFlag(generatedHB2Flag[generatedSymbol])) + 2 * generatedHB2Flag[(int)generatedSymbol] + ((generatedRunLength >> 26) & -1024)];
				CPpmd_State s = ((CPpmd_State)(generatedMinContext).getSummFreq());
				if (generatedSymbol == symbol) {
					rc.RangeEnc_EncodeBit_0(prob);
					prob = (UInt16)((prob) + (1 << 7) - ((((prob)) + (1 << ((true) - (true)))) >> (true)));
					this.setFoundState(s);
					p.Ppmd7_UpdateBin();
					return ;
				} else {
						rc.RangeEnc_EncodeBit_1(prob);
						prob = (UInt16)((prob) - ((((prob)) + (1 << ((true) - (true)))) >> (true)));
						this.setInitEsc(ModernizedCProgram.PPMD7_kExpEscape[prob >> 10]);
						{ 
							size_t z = new size_t();
							for (z = 0; z < 256 / ; z += 8) {
								charMask[z + 7] = charMask[z + 6] = charMask[z + 5] = charMask[z + 4] = charMask[z + 3] = charMask[z + 2] = charMask[z + 1] = charMask[z + 0] = ~(size_t)0;
							}
						}
						;
						((byte)charMask)[generatedSymbol] = 0;
						this.setPrevSuccess(0);
				} 
		} 
		Object generatedOrderFall = this.getOrderFall();
		Object generatedShift = (see).getShift();
		Object generatedCount = (see).getCount();
		Object generatedSumm = (see).getSumm();
		for (; ; ) {
			UInt32 escFreq = new UInt32();
			CPpmd_See see = new CPpmd_See();
			CPpmd_State s = new CPpmd_State();
			UInt32 sum = new UInt32();
			int i;
			int numMasked = generatedMinContext.getNumStats();
			do {
				generatedOrderFall++;
				if (!generatedMinContext.getSuffix()) {
					return ;
				} 
				this.setMinContext((generatedMinContext.getSuffix()));
			} while (generatedMinContext.getNumStats() == numMasked);
			see = p.Ppmd7_MakeEscFreq(numMasked, escFreq);
			s = ((generatedMinContext).getStats());
			sum = 0;
			i = generatedMinContext.getNumStats();
			do {
				int cur = generatedSymbol;
				if (cur == symbol) {
					UInt32 low = sum;
					CPpmd_State s1 = s;
					do {
						sum += (generatedFreq & (int)(((byte)charMask)[generatedSymbol]));
						s++;
					} while (--i);
					rc.RangeEnc_Encode(low, generatedFreq, sum + escFreq);
					if (generatedShift < 7 && --generatedCount == 0) {
						generatedSumm <<=  1;
						(see).setCount((Byte)(3 << generatedShift++));
					} 
					;
					this.setFoundState(s1);
					p.Ppmd7_Update2();
					return ;
				} 
				sum += (generatedFreq & (int)(((byte)charMask)[cur]));
				((byte)charMask)[cur] = 0;
				s++;
			} while (--i);
			rc.RangeEnc_Encode(sum, escFreq, sum + escFreq);
			see.setSumm((UInt16)(generatedSumm + sum + escFreq));
		}
	}
	public static Object IS_MAIN_METHOD(Object m) {
		switch (m) {
		case 0:
		case -1024:
				return 1;
		case -1024:
		}
		return 0;
	}
	public static Object IS_SUPPORTED_CODER(Object c) {
		return c.getNumStreams() == 1 && ModernizedCProgram.IS_MAIN_METHOD((UInt32)c.getMethodID());
	}
	public static Object CheckSupportedFolder(Object f) {
		if (f.getNumCoders() < 1 || f.getNumCoders() > 4) {
			return 4;
		} 
		if (!ModernizedCProgram.IS_SUPPORTED_CODER(f.getCoders()[0])) {
			return 4;
		} 
		if (f.getNumCoders() == 1) {
			if (f.getNumPackStreams() != 1 || f.getPackStreams()[0] != 0 || f.getNumBonds() != 0) {
				return 4;
			} 
			return 0;
		} 
		if (f.getNumCoders() == 2) {
			CSzCoderInfo c = f.getCoders()[1];
			if (c.getNumStreams() != /* c->MethodID > (UInt32)0xFFFFFFFF || */1 || f.getNumPackStreams() != 1 || f.getPackStreams()[0] != 0 || f.getNumBonds() != 1 || f.getBonds()[0].getInIndex() != 1 || f.getBonds()[0].getOutIndex() != 0) {
				return 4;
			} 
			switch ((UInt32)c.getMethodID()) {
			case -1024:
			case -1024:
			case -1024:
			case -1024:
			case -1024:
					break;
			case 3:
			case -1024:
			default:
					return 4;
			}
			return 0;
		} 
		if (f.getNumCoders() == 4) {
			if (!ModernizedCProgram.IS_SUPPORTED_CODER(f.getCoders()[1]) || !ModernizedCProgram.IS_SUPPORTED_CODER(f.getCoders()[2]) || !((f.getCoders()[3]).getMethodID() == -1024 && (f.getCoders()[3]).getNumStreams() == 4)) {
				return 4;
			} 
			if (f.getNumPackStreams() != 4 || f.getPackStreams()[0] != 2 || f.getPackStreams()[1] != 6 || f.getPackStreams()[2] != 1 || f.getPackStreams()[3] != 0 || f.getNumBonds() != 3 || f.getBonds()[0].getInIndex() != 5 || f.getBonds()[0].getOutIndex() != 0 || f.getBonds()[1].getInIndex() != 4 || f.getBonds()[1].getOutIndex() != 1 || f.getBonds()[2].getInIndex() != 3 || f.getBonds()[2].getOutIndex() != 2) {
				return 4;
			} 
			return 0;
		} 
		return 4;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int sort_by_tuning_db_alias(Object v1, Object v2) {
		tuning_db_alias_t t1 = (tuning_db_alias_t)v1;
		tuning_db_alias_t t2 = (tuning_db_alias_t)v2;
		int res1 = .strcmp(t1.getDevice_name(), t2.getDevice_name());
		if (res1 != 0) {
			return (res1);
		} 
		return 0;
	}
	public static int sort_by_tuning_db_entry(Object v1, Object v2) {
		tuning_db_entry_t t1 = (tuning_db_entry_t)v1;
		tuning_db_entry_t t2 = (tuning_db_entry_t)v2;
		int res1 = .strcmp(t1.getDevice_name(), t2.getDevice_name());
		if (res1 != 0) {
			return (res1);
		} 
		int res2 = t1.getAttack_mode() - t2.getAttack_mode();
		if (res2 != 0) {
			return (res2);
		} 
		int res3 = t1.getHash_mode() - t2.getHash_mode();
		if (res3 != 0) {
			return (res3);
		} 
		return 0;
	}
	/* Isaac Turner 29 April 2014 Public Domain */
	/*
	
	sort_r function to be exported.
	
	Parameters:
	  base is the array to be sorted
	  nel is the number of elements in the array
	  width is the size in bytes of each element of the array
	  compar is the comparison function
	  arg is a pointer to be passed to the comparison function
	
	void sort_r(void *base, size_t nel, size_t width,
	            int (*compar)(const void *_a, const void *_b, void *_arg),
	            void *arg);
	
	Slightly modified to work with hashcat to no falsly detect _SORT_R_LINUX with mingw
	
	*/
	/* Using our own recursive quicksort sort_r_simple() */
	/* swap a, b iff a>b */
	/* __restrict is same as restrict but better support on old machines */
	public static int sort_r_cmpswap(byte a, byte b, Object w, Object compar, Object arg) {
		byte end = a + w;
		if (.compar(a, b, arg) > 0) {
			for (; a < end; ) {
				byte tmp = a;
				a = b;
				b = tmp;
			}
			return 1;
		} 
		return 0;
	}
	/* Implement recursive quicksort ourselves */
	/* Note: quicksort is not stable, equivalent values may be swapped */
	public static void sort_r_simple(Object base, Object nel, Object w, Object compar, Object arg) {
		byte b = (byte)base;
		byte end = b + nel * w;
		if (nel < 7/* Insertion sort for arbitrarily small inputs */) {
			byte pi;
			byte pj;
			for (pi = b + w; pi < end; pi += w) {
				for (pj = pi; pj > b && ModernizedCProgram.sort_r_cmpswap(pj - w, pj, w, compar, arg); pj -= w) {
				}
			}
		} else {
				byte x;
				byte y;
				byte xend;
				byte pl;
				byte pr;
				byte last = b + w * (nel - 1);
				byte tmp;
				byte[] l = new byte[3];
				l[0] = b;
				l[1] = b + w * (nel / 2);
				l[2] = last;
				if (.compar(l[0], l[1], arg) > 0) {
					tmp = l[0];
					l[0] = l[1];
					l[1] = tmp;
				} 
				if (.compar(l[1], l[2], arg) > 0) {
					tmp = l[1];
					l[1] = l[2];
					l[2] = /* swap(l[1],l[2]) */tmp;
					if (.compar(l[0], l[1], arg) > 0) {
						tmp = l[0];
						l[0] = l[1];
						l[1] = tmp;
					} 
				} 
				for (; x < xend; ) {
					byte ch = x;
					x = y;
					y = ch;
				}
				pl = b;
				pr = last;
				while (pl < pr) {
					for (; pl < pr; pl += w) {
						if (ModernizedCProgram.sort_r_cmpswap(pl, pr, w, compar, arg)) {
							pr -= /* pivot now at pl */w;
							break;
						} 
					}
					for (; pl < pr; pr -= w) {
						if (ModernizedCProgram.sort_r_cmpswap(pl, pr, w, compar, arg)) {
							pl += /* pivot now at pr */w;
							break;
						} 
					}
				}
				ModernizedCProgram.sort_r_simple(b, (pl - b) / w, w, compar, arg);
				ModernizedCProgram.sort_r_simple(pl + w, (end - (pl + w)) / w, w, compar, arg);
		} 
	}
	public static int sort_r_arg_swap(Object s, Object a, Object b) {
		sort_r_data ss = (sort_r_data)s;
		Object generatedArg = ss.getArg();
		return .UNRECOGNIZEDFUNCTIONNAME(a, b, generatedArg);
	}
	/* implementation */
	public static void sort_r(Object base, Object nel, Object width, Object compar, Object arg) {
		/* Fall back to our own quicksort implementation */sort_r_data tmp = new sort_r_data();
		tmp.setArg(arg);
		tmp.setCompar(compar);
		.qsort_s(base, nel, width, sort_r_arg_swap, tmp/* Fall back to our own quicksort implementation */)/* !NESTED_QSORT */;/* !NESTED_QSORT */
	}
	/* no qsort_r in glibc before 2.8, need to use nested qsort */
	/* SORT_R_H_ */
	/* ===========================================================================
	     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
	   for end of file.
	   IN assertion: the stream s has been successfully opened for reading.
	*/
	public static int unz64local_getByte(Object pzlib_filefunc_def, Object filestream, int pi) {
		byte c;
		int err = (int)(.UNRECOGNIZEDFUNCTIONNAME((pzlib_filefunc_def).getZfile_func64().getOpaque(), filestream, c, 1));
		if (err == 1) {
			pi = (int)c;
			return (false);
		} else {
				if ((.UNRECOGNIZEDFUNCTIONNAME((pzlib_filefunc_def).getZfile_func64().getOpaque(), filestream))) {
					return ((true));
				} else {
						return (false);
				} 
		} 
	}
	/* ===========================================================================
	   Reads a long in LSB order from the given gz_stream. Sets
	*/
	public static int unz64local_getShort(Object pzlib_filefunc_def, Object filestream, Object pX) {
		uLong x = new uLong();
		int i = 0;
		int err;
		err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		x = (uLong)i;
		if (err == (false)) {
			err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x |=  ((uLong)i) << 8;
		if (err == (false)) {
			pX = x;
		} else {
				pX = 0;
		} 
		return err;
	}
	public static int unz64local_getLong(Object pzlib_filefunc_def, Object filestream, Object pX) {
		uLong x = new uLong();
		int i = 0;
		int err;
		err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		x = (uLong)i;
		if (err == (false)) {
			err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x |=  ((uLong)i) << 8;
		if (err == (false)) {
			err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x |=  ((uLong)i) << 16;
		if (err == (false)) {
			err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((uLong)i) << 24;
		if (err == (false)) {
			pX = x;
		} else {
				pX = 0;
		} 
		return err;
	}
	public static int unz64local_getLong64(Object pzlib_filefunc_def, Object filestream, Object pX) {
		ZPOS64_T x = new ZPOS64_T();
		int i = 0;
		int err;
		err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		x = (ZPOS64_T)i;
		if (err == (false)) {
			err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x |=  ((ZPOS64_T)i) << 8;
		if (err == (false)) {
			err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x |=  ((ZPOS64_T)i) << 16;
		if (err == (false)) {
			err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x |=  ((ZPOS64_T)i) << 24;
		if (err == (false)) {
			err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x |=  ((ZPOS64_T)i) << 32;
		if (err == (false)) {
			err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x |=  ((ZPOS64_T)i) << 40;
		if (err == (false)) {
			err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x |=  ((ZPOS64_T)i) << 48;
		if (err == (false)) {
			err = ModernizedCProgram.unz64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x |=  ((ZPOS64_T)i) << 56;
		if (err == (false)) {
			pX = x;
		} else {
				pX = 0;
		} 
		return err;
	}
	/* My own strcmpi / strcasecmp */
	public static int strcmpcasenosensitive_internal(Object fileName1, Object fileName2) {
		for (; ; ) {
			byte c1 = (fileName1++);
			byte c2 = (fileName2++);
			if ((c1 >= (byte)'a') && (c1 <= (byte)'z')) {
				c1 -= -1024;
			} 
			if ((c2 >= (byte)'a') && (c2 <= (byte)'z')) {
				c2 -= -1024;
			} 
			if (c1 == (byte)'\0') {
				return ((c2 == (byte)'\0') ? 0 : -1);
			} 
			if (c2 == (byte)'\0') {
				return 1;
			} 
			if (c1 < c2) {
				return -1;
			} 
			if (c1 > c2) {
				return 1;
			} 
		}
	}
	/*
	   Compare two filename (fileName1,fileName2).
	   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
	   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
	                                                                or strcasecmp)
	   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
	        (like 1 on Unix, 2 on Windows)
	
	*/
	public static int unzStringFileNameCompare(Object fileName1, Object fileName2, int iCaseSensitivity) {
		if (iCaseSensitivity == 0) {
			iCaseSensitivity = 2;
		} 
		if (iCaseSensitivity == 1) {
			return .strcmp(fileName1, fileName2);
		} 
		return ModernizedCProgram.strcmpcasenosensitive_internal(fileName1, fileName2);
	}
	/*
	  Locate the Central directory of a zipfile (at the end, just before
	    the global comment)
	*/
	public static Object unz64local_SearchCentralDir(Object pzlib_filefunc_def, Object filestream) {
		byte buf;
		ZPOS64_T uSizeFile = new ZPOS64_T();
		ZPOS64_T uBackRead = new ZPOS64_T();
		ZPOS64_T uMaxBack = /* maximum size of global comment */-1024;
		ZPOS64_T uPosFound = 0;
		if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (false), ((true)))) != 0) {
			return 0;
		} 
		uSizeFile = (ModernizedCProgram.call_ztell64(((pzlib_filefunc_def)), (filestream)));
		if (uMaxBack > uSizeFile) {
			uMaxBack = uSizeFile;
		} 
		buf = (byte)(.malloc((true) + 4));
		if (buf == ((Object)0)) {
			return 0;
		} 
		uBackRead = 4;
		while (uBackRead < uMaxBack) {
			uLong uReadSize = new uLong();
			ZPOS64_T uReadPos = new ZPOS64_T();
			int i;
			if (uBackRead + (true) > uMaxBack) {
				uBackRead = uMaxBack;
			} else {
					uBackRead += (true);
			} 
			uReadPos = uSizeFile - uBackRead;
			uReadSize = (((true) + 4) < (uSizeFile - uReadPos)) ? ((true) + 4) : (uLong)(uSizeFile - uReadPos);
			if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (uReadPos), ((false)))) != 0) {
				break;
			} 
			if ((.UNRECOGNIZEDFUNCTIONNAME((pzlib_filefunc_def).getZfile_func64().getOpaque(), filestream, buf, uReadSize)) != uReadSize) {
				break;
			} 
			for (i = (int)uReadSize - 3; (i--) > 0; ) {
				if ((((buf + i)) == -1024) && (((buf + i + 1)) == -1024) && (((buf + i + 2)) == -1024) && (((buf + i + 3)) == -1024)) {
					uPosFound = uReadPos + i;
					break;
				} 
			}
			if (uPosFound != 0) {
				break;
			} 
		}
		{ 
			if (buf) {
				.free(buf);
			} 
		}
		;
		return uPosFound/*
		  Locate the Central directory 64 of a zipfile (at the end, just before
		    the global comment)
		*/;
	}
	public static Object unz64local_SearchCentralDir64(Object pzlib_filefunc_def, Object filestream) {
		byte buf;
		ZPOS64_T uSizeFile = new ZPOS64_T();
		ZPOS64_T uBackRead = new ZPOS64_T();
		ZPOS64_T uMaxBack = /* maximum size of global comment */-1024;
		ZPOS64_T uPosFound = 0;
		uLong uL = new uLong();
		ZPOS64_T relativeOffset = new ZPOS64_T();
		if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (false), ((true)))) != 0) {
			return 0;
		} 
		uSizeFile = (ModernizedCProgram.call_ztell64(((pzlib_filefunc_def)), (filestream)));
		if (uMaxBack > uSizeFile) {
			uMaxBack = uSizeFile;
		} 
		buf = (byte)(.malloc((true) + 4));
		if (buf == ((Object)0)) {
			return 0;
		} 
		uBackRead = 4;
		while (uBackRead < uMaxBack) {
			uLong uReadSize = new uLong();
			ZPOS64_T uReadPos = new ZPOS64_T();
			int i;
			if (uBackRead + (true) > uMaxBack) {
				uBackRead = uMaxBack;
			} else {
					uBackRead += (true);
			} 
			uReadPos = uSizeFile - uBackRead;
			uReadSize = (((true) + 4) < (uSizeFile - uReadPos)) ? ((true) + 4) : (uLong)(uSizeFile - uReadPos);
			if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (uReadPos), ((false)))) != 0) {
				break;
			} 
			if ((.UNRECOGNIZEDFUNCTIONNAME((pzlib_filefunc_def).getZfile_func64().getOpaque(), filestream, buf, uReadSize)) != uReadSize) {
				break;
			} 
			for (i = (int)uReadSize - 3; (i--) > 0; ) {
				if ((((buf + i)) == -1024) && (((buf + i + 1)) == -1024) && (((buf + i + 2)) == -1024) && (((buf + i + 3)) == -1024)) {
					uPosFound = uReadPos + i;
					break;
				} 
			}
			if (uPosFound != 0) {
				break;
			} 
		}
		{ 
			if (buf) {
				.free(buf);
			} 
		}
		;
		if (uPosFound == 0) {
			return 0;
		} 
		if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (uPosFound), ((false)))) != /* Zip64 end of central directory locator */0) {
			return 0;
		} 
		if (ModernizedCProgram.unz64local_getLong(pzlib_filefunc_def, filestream, uL) != (/* the signature, already checked */false)) {
			return 0;
		} 
		if (ModernizedCProgram.unz64local_getLong(pzlib_filefunc_def, filestream, uL) != (/* number of the disk with the start of the zip64 end of  central directory */false)) {
			return 0;
		} 
		if (uL != 0) {
			return 0;
		} 
		if (ModernizedCProgram.unz64local_getLong64(pzlib_filefunc_def, filestream, relativeOffset) != (/* relative offset of the zip64 end of central directory record */false)) {
			return 0;
		} 
		if (ModernizedCProgram.unz64local_getLong(pzlib_filefunc_def, filestream, uL) != (/* total number of disks */false)) {
			return 0;
		} 
		if (uL != 1) {
			return 0;
		} 
		if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (relativeOffset), ((false)))) != /* Goto end of central directory record */0) {
			return 0;
		} 
		if (ModernizedCProgram.unz64local_getLong(pzlib_filefunc_def, filestream, uL) != (/* the signature */false)) {
			return 0;
		} 
		if (uL != -1024) {
			return 0;
		} 
		return relativeOffset/*
		  Open a Zip file. path contain the full pathname (by example,
		     on a Windows NT computer "c:\\test\\zlib114.zip" or on an Unix computer
		     "zlib/zlib114.zip".
		     If the zipfile cannot be opened (file doesn't exist or in not valid), the
		       return value is NULL.
		     Else, the return value is a unzFile Handle, usable with other function
		       of this unzip package.
		*/;
	}
	public static Object unzOpen(Object path) {
		return ((Object)0).unzOpenInternal(path, 0);
	}
	public static Object unzOpen64(Object path) {
		return ((Object)0).unzOpenInternal(path, 1/*
		  Close a ZipFile opened with unzOpen.
		  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
		    these files MUST be closed with unzCloseCurrentFile before call unzClose.
		  return UNZ_OK if there is no problem. */);
	}
	public static int unzClose(Object file) {
		unz64_s s = new unz64_s();
		if (file == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		Object generatedPfile_in_zip_read = s.getPfile_in_zip_read();
		if (generatedPfile_in_zip_read != ((Object)0)) {
			ModernizedCProgram.unzCloseCurrentFile(file);
		} 
		Object generatedZ_filefunc = s.getZ_filefunc();
		Object generatedFilestream = s.getFilestream();
		(.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream));
		{ 
			if (s) {
				.free(s);
			} 
		}
		;
		return (false/*
		  Write info about the ZipFile in the *pglobal_info structure.
		  No preparation of the structure is needed
		  return UNZ_OK if there is no problem. */);
	}
	public static int unz64local_GetCurrentFileInfoInternal(Object file, unz_file_info64_s pfile_info, unz_file_info64_internal_s pfile_info_internal, Byte szFileName, Object fileNameBufferSize, Object extraField, Object extraFieldBufferSize, Byte szComment, Object commentBufferSize) {
		unz64_s s = new unz64_s();
		unz_file_info64 file_info = new unz_file_info64();
		unz_file_info64_internal file_info_internal = new unz_file_info64_internal();
		int err = (false);
		uLong uMagic = new uLong();
		long lSeek = 0;
		uLong uL = new uLong();
		if (file == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		Object generatedZ_filefunc = s.getZ_filefunc();
		Object generatedFilestream = s.getFilestream();
		Object generatedPos_in_central_dir = s.getPos_in_central_dir();
		Object generatedByte_before_the_zipfile = s.getByte_before_the_zipfile();
		if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (generatedPos_in_central_dir + generatedByte_before_the_zipfile), ((false)))) != 0) {
			err = ((true));
		} 
		if (err == (/* we check the magic */false)) {
			if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, uMagic) != (false)) {
				err = ((true));
			}  else if (uMagic != -1024) {
				err = (true);
			} 
		} 
		Object generatedVersion = file_info.getVersion();
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, generatedVersion) != (false)) {
			err = ((true));
		} 
		Object generatedVersion_needed = file_info.getVersion_needed();
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, generatedVersion_needed) != (false)) {
			err = ((true));
		} 
		Object generatedFlag = file_info.getFlag();
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, generatedFlag) != (false)) {
			err = ((true));
		} 
		Object generatedCompression_method = file_info.getCompression_method();
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, generatedCompression_method) != (false)) {
			err = ((true));
		} 
		Object generatedDosDate = file_info.getDosDate();
		if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, generatedDosDate) != (false)) {
			err = ((true));
		} 
		tm_unz_s generatedTmu_date = file_info.getTmu_date();
		generatedTmu_date.unz64local_DosDateToTmuDate(generatedDosDate);
		Object generatedCrc = file_info.getCrc();
		if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, generatedCrc) != (false)) {
			err = ((true));
		} 
		if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, uL) != (false)) {
			err = ((true));
		} 
		file_info.setCompressed_size(uL);
		if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, uL) != (false)) {
			err = ((true));
		} 
		file_info.setUncompressed_size(uL);
		Object generatedSize_filename = file_info.getSize_filename();
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, generatedSize_filename) != (false)) {
			err = ((true));
		} 
		Object generatedSize_file_extra = file_info.getSize_file_extra();
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, generatedSize_file_extra) != (false)) {
			err = ((true));
		} 
		Object generatedSize_file_comment = file_info.getSize_file_comment();
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, generatedSize_file_comment) != (false)) {
			err = ((true));
		} 
		Object generatedDisk_num_start = file_info.getDisk_num_start();
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, generatedDisk_num_start) != (false)) {
			err = ((true));
		} 
		Object generatedInternal_fa = file_info.getInternal_fa();
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, generatedInternal_fa) != (false)) {
			err = ((true));
		} 
		Object generatedExternal_fa = file_info.getExternal_fa();
		if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, generatedExternal_fa) != (false)) {
			err = ((true));
		} 
		// relative offset of local headerif (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, uL) != (false)) {
			err = ((true));
		} 
		file_info_internal.setOffset_curfile(uL);
		lSeek += generatedSize_filename;
		if ((err == (false)) && (szFileName != ((Object)0))) {
			uLong uSizeRead = new uLong();
			if (generatedSize_filename < fileNameBufferSize) {
				(szFileName + generatedSize_filename) = (byte)'\0';
				uSizeRead = generatedSize_filename;
			} else {
					uSizeRead = fileNameBufferSize;
			} 
			if ((generatedSize_filename > 0) && (fileNameBufferSize > 0)) {
				if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, szFileName, uSizeRead)) != uSizeRead) {
					err = ((true));
				} 
			} 
			lSeek -= uSizeRead;
		} 
		// Read extrafieldif ((err == (false)) && (extraField != ((Object)0))) {
			ZPOS64_T uSizeRead = new ZPOS64_T();
			if (generatedSize_file_extra < extraFieldBufferSize) {
				uSizeRead = generatedSize_file_extra;
			} else {
					uSizeRead = extraFieldBufferSize;
			} 
			if (lSeek != 0) {
				if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (lSeek), ((true)))) == 0) {
					lSeek = 0;
				} else {
						err = ((true));
				} 
			} 
			if ((generatedSize_file_extra > 0) && (extraFieldBufferSize > 0)) {
				if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, extraField, (uLong)uSizeRead)) != uSizeRead) {
					err = ((true));
				} 
			} 
			lSeek += generatedSize_file_extra - (uLong)uSizeRead;
		} else {
				lSeek += generatedSize_file_extra;
		} 
		Object generatedUncompressed_size = file_info.getUncompressed_size();
		Object generatedCompressed_size = file_info.getCompressed_size();
		Object generatedOffset_curfile = file_info_internal.getOffset_curfile();
		if ((err == (false)) && (generatedSize_file_extra != 0)) {
			uLong acc = 0;
			lSeek -= generatedSize_file_extra;
			if (lSeek != 0) {
				if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (lSeek), ((true)))) == 0) {
					lSeek = 0;
				} else {
						err = ((true));
				} 
			} 
			while (acc < generatedSize_file_extra) {
				uLong headerId = new uLong();
				uLong dataSize = new uLong();
				if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, headerId) != (false)) {
					err = ((true));
				} 
				if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, dataSize) != (false)) {
					err = ((true));
				} 
				if (headerId == /* ZIP64 extra fields */-1024) {
					uLong uL = new uLong();
					if (generatedUncompressed_size == -1024) {
						if (ModernizedCProgram.unz64local_getLong64(generatedZ_filefunc, generatedFilestream, generatedUncompressed_size) != (false)) {
							err = ((true));
						} 
					} 
					if (generatedCompressed_size == -1024) {
						if (ModernizedCProgram.unz64local_getLong64(generatedZ_filefunc, generatedFilestream, generatedCompressed_size) != (false)) {
							err = ((true));
						} 
					} 
					if (generatedOffset_curfile == -1024) {
						if (ModernizedCProgram.unz64local_getLong64(generatedZ_filefunc, generatedFilestream, generatedOffset_curfile) != (/* Relative Header offset */false)) {
							err = ((true));
						} 
					} 
					if (generatedDisk_num_start == -1024) {
						if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, uL) != (/* Disk Start Number */false)) {
							err = ((true));
						} 
					} 
				} else {
						if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (dataSize), ((true)))) != 0) {
							err = ((true));
						} 
				} 
				acc += 2 + 2 + dataSize;
			}
		} 
		if ((err == (false)) && (szComment != ((Object)0))) {
			uLong uSizeRead = new uLong();
			if (generatedSize_file_comment < commentBufferSize) {
				(szComment + generatedSize_file_comment) = (byte)'\0';
				uSizeRead = generatedSize_file_comment;
			} else {
					uSizeRead = commentBufferSize;
			} 
			if (lSeek != 0) {
				if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (lSeek), ((true)))) == 0) {
					lSeek = 0;
				} else {
						err = ((true));
				} 
			} 
			if ((generatedSize_file_comment > 0) && (commentBufferSize > 0)) {
				if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, szComment, uSizeRead)) != uSizeRead) {
					err = ((true));
				} 
			} 
			lSeek += generatedSize_file_comment - uSizeRead;
		} else {
				lSeek += generatedSize_file_comment;
		} 
		if ((err == (false)) && (pfile_info != ((Object)0))) {
			pfile_info = file_info;
		} 
		if ((err == (false)) && (pfile_info_internal != ((Object)0))) {
			pfile_info_internal = file_info_internal;
		} 
		return err/*
		  Write info about the ZipFile in the *pglobal_info structure.
		  No preparation of the structure is needed
		  return UNZ_OK if there is no problem.
		*/;
	}
	public static int unzGoToFirstFile(Object file) {
		int err = (false);
		unz64_s s = new unz64_s();
		if (file == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		Object generatedOffset_central_dir = s.getOffset_central_dir();
		s.setPos_in_central_dir(generatedOffset_central_dir);
		s.setNum_file(0);
		Object generatedCur_file_info = s.getCur_file_info();
		Object generatedCur_file_info_internal = s.getCur_file_info_internal();
		err = ModernizedCProgram.unz64local_GetCurrentFileInfoInternal(file, generatedCur_file_info, generatedCur_file_info_internal, ((Object)0), 0, ((Object)0), 0, ((Object)0), 0);
		s.setCurrent_file_ok((err == (false)));
		return err/*
		  Set the current file of the zipfile to the next file.
		  return UNZ_OK if there is no problem
		  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
		*/;
	}
	public static int unzGoToNextFile(Object file) {
		unz64_s s = new unz64_s();
		int err;
		if (file == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		Object generatedCurrent_file_ok = s.getCurrent_file_ok();
		if (!generatedCurrent_file_ok) {
			return (true);
		} 
		Object generatedGi = s.getGi();
		Object generatedNum_file = s.getNum_file();
		if (generatedGi.getNumber_entry() != /* 2^16 files overflow hack */-1024) {
			if (generatedNum_file + 1 == generatedGi.getNumber_entry()) {
				return (true);
			} 
		} 
		Object generatedPos_in_central_dir = s.getPos_in_central_dir();
		Object generatedCur_file_info = s.getCur_file_info();
		generatedPos_in_central_dir += (true) + generatedCur_file_info.getSize_filename() + generatedCur_file_info.getSize_file_extra() + generatedCur_file_info.getSize_file_comment();
		generatedNum_file++;
		Object generatedCur_file_info_internal = s.getCur_file_info_internal();
		err = ModernizedCProgram.unz64local_GetCurrentFileInfoInternal(file, generatedCur_file_info, generatedCur_file_info_internal, ((Object)0), 0, ((Object)0), 0, ((Object)0), 0);
		s.setCurrent_file_ok((err == (false)));
		return err/*
		  Try locate the file szFileName in the zipfile.
		  For the iCaseSensitivity signification, see unzStringFileNameCompare
		
		  return value :
		  UNZ_OK if the file is found. It becomes the current file.
		  UNZ_END_OF_LIST_OF_FILE if the file is not found
		*/;
	}
	public static int unzLocateFile(Object file, Object szFileName, int iCaseSensitivity) {
		unz64_s s = new unz64_s();
		int err;
		/* We remember the 'current' position in the file so that we can jump
		     * back there if we fail.
		     */
		unz_file_info64 cur_file_infoSaved = new unz_file_info64();
		unz_file_info64_internal cur_file_info_internalSaved = new unz_file_info64_internal();
		ZPOS64_T num_fileSaved = new ZPOS64_T();
		ZPOS64_T pos_in_central_dirSaved = new ZPOS64_T();
		if (file == ((Object)0)) {
			return (true);
		} 
		if (.strlen(szFileName) >= (true)) {
			return (true);
		} 
		s = (unz64_s)file;
		Object generatedCurrent_file_ok = s.getCurrent_file_ok();
		if (!generatedCurrent_file_ok) {
			return (true);
		} 
		Object generatedNum_file = s.getNum_file();
		num_fileSaved = generatedNum_file;
		Object generatedPos_in_central_dir = s.getPos_in_central_dir();
		pos_in_central_dirSaved = generatedPos_in_central_dir;
		Object generatedCur_file_info = s.getCur_file_info();
		cur_file_infoSaved = generatedCur_file_info;
		Object generatedCur_file_info_internal = s.getCur_file_info_internal();
		cur_file_info_internalSaved = generatedCur_file_info_internal;
		err = ModernizedCProgram.unzGoToFirstFile(file);
		while (err == (false)) {
			byte[] szCurrentFileName = new byte[(true) + 1];
			err = ((Object)0).unzGetCurrentFileInfo64(file, szCurrentFileName,  - 1, ((Object)0), 0, ((Object)0), 0);
			if (err == (false)) {
				if (ModernizedCProgram.unzStringFileNameCompare(szCurrentFileName, szFileName, iCaseSensitivity) == 0) {
					return (false);
				} 
				err = ModernizedCProgram.unzGoToNextFile(file);
			} 
		}
		s.setNum_file(/* We failed, so restore the state of the 'current file' to where we
		     * were.
		     */num_fileSaved);
		s.setPos_in_central_dir(pos_in_central_dirSaved);
		s.setCur_file_info(cur_file_infoSaved);
		s.setCur_file_info_internal(cur_file_info_internalSaved);
		return err/*
		///////////////////////////////////////////
		// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)
		// I need random access
		//
		// Further optimization could be realized by adding an ability
		// to cache the directory in memory. The goal being a single
		// comprehensive file read to put the file I need in a memory.
		*/;
	}
	public static int unzGoToFilePos64(Object file, Object file_pos) {
		unz64_s s = new unz64_s();
		int err;
		if (file == ((Object)0) || file_pos == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		s.setPos_in_central_dir(file_pos.getPos_in_zip_directory());
		s.setNum_file(file_pos.getNum_of_file());
		Object generatedCur_file_info = s.getCur_file_info();
		Object generatedCur_file_info_internal = s.getCur_file_info_internal();
		err = ModernizedCProgram.unz64local_GetCurrentFileInfoInternal(file, generatedCur_file_info, generatedCur_file_info_internal, ((Object)0), 0, ((Object)0), 0, ((Object)0), 0);
		s.setCurrent_file_ok((err == (/* return results */false)));
		return err;
	}
	/*
	  Read the local header of the current zipfile
	  Check the coherency of the local header and info in the end of central
	        directory about this file
	  store in *piSizeVar the size of extra info in local header
	        (filename and size of extra field data)
	*/
	public static int unz64local_CheckCurrentFileCoherencyHeader(Object piSizeVar, Object poffset_local_extrafield, Object psize_local_extrafield) {
		uLong uMagic = new uLong();
		uLong uData = new uLong();
		uLong uFlags = new uLong();
		uLong size_filename = new uLong();
		uLong size_extra_field = new uLong();
		int err = (false);
		piSizeVar = 0;
		poffset_local_extrafield = 0;
		psize_local_extrafield = 0;
		Object generatedZ_filefunc = this.getZ_filefunc();
		Object generatedFilestream = this.getFilestream();
		Object generatedCur_file_info_internal = this.getCur_file_info_internal();
		Object generatedByte_before_the_zipfile = this.getByte_before_the_zipfile();
		if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (generatedCur_file_info_internal.getOffset_curfile() + generatedByte_before_the_zipfile), ((false)))) != 0) {
			return ((true));
		} 
		if (err == (false)) {
			if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, uMagic) != (false)) {
				err = ((true));
			}  else if (uMagic != -1024) {
				err = (true);
			} 
		} 
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, uData) != (false)) {
			err = ((true/*
			    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))
			        err=UNZ_BADZIPFILE;
			*/));
		} 
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, uFlags) != (false)) {
			err = ((true));
		} 
		Object generatedCur_file_info = this.getCur_file_info();
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, uData) != (false)) {
			err = ((true));
		}  else if ((err == (false)) && (uData != generatedCur_file_info.getCompression_method())) {
			err = (true);
		} 
		if ((err == (false)) && (generatedCur_file_info.getCompression_method() != 0) && (generatedCur_file_info.getCompression_method() != /* #ifdef HAVE_BZIP2 */12) && (generatedCur_file_info.getCompression_method() != /* #endif */8)) {
			err = (true);
		} 
		if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, uData) != (/* date/time */false)) {
			err = ((true));
		} 
		if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, uData) != (/* crc */false)) {
			err = ((true));
		}  else if ((err == (false)) && (uData != generatedCur_file_info.getCrc()) && ((uFlags & 8) == 0)) {
			err = (true);
		} 
		if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, uData) != (/* size compr */false)) {
			err = ((true));
		}  else if (uData != -1024 && (err == (false)) && (uData != generatedCur_file_info.getCompressed_size()) && ((uFlags & 8) == 0)) {
			err = (true);
		} 
		if (ModernizedCProgram.unz64local_getLong(generatedZ_filefunc, generatedFilestream, uData) != (/* size uncompr */false)) {
			err = ((true));
		}  else if (uData != -1024 && (err == (false)) && (uData != generatedCur_file_info.getUncompressed_size()) && ((uFlags & 8) == 0)) {
			err = (true);
		} 
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, size_filename) != (false)) {
			err = ((true));
		}  else if ((err == (false)) && (size_filename != generatedCur_file_info.getSize_filename())) {
			err = (true);
		} 
		piSizeVar += (uInt)size_filename;
		if (ModernizedCProgram.unz64local_getShort(generatedZ_filefunc, generatedFilestream, size_extra_field) != (false)) {
			err = ((true));
		} 
		poffset_local_extrafield = generatedCur_file_info_internal.getOffset_curfile() + (true) + size_filename;
		psize_local_extrafield = (uInt)size_extra_field;
		piSizeVar += (uInt)size_extra_field;
		return err/*
		  Open for reading data the current file in the zipfile.
		  If there is no error and the file is opened, the return value is UNZ_OK.
		*/;
	}
	public static int unzOpenCurrentFile3(Object file, int method, int level, int raw, Object password) {
		int err = (false);
		uInt iSizeVar = new uInt();
		unz64_s s = new unz64_s();
		file_in_zip64_read_info_s pfile_in_zip_read_info = new file_in_zip64_read_info_s();
		/* offset of the local extra field */ZPOS64_T offset_local_extrafield = new ZPOS64_T();
		/* size of the local extra field */uInt size_local_extrafield = new uInt();
		if (password != ((Object)0)) {
			return (true);
		} 
		if (file == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		Object generatedCurrent_file_ok = s.getCurrent_file_ok();
		if (!generatedCurrent_file_ok) {
			return (true);
		} 
		Object generatedPfile_in_zip_read = s.getPfile_in_zip_read();
		if (generatedPfile_in_zip_read != ((Object)0)) {
			ModernizedCProgram.unzCloseCurrentFile(file);
		} 
		if (s.unz64local_CheckCurrentFileCoherencyHeader(iSizeVar, offset_local_extrafield, size_local_extrafield) != (false)) {
			return (true);
		} 
		pfile_in_zip_read_info = (file_in_zip64_read_info_s)(.malloc());
		if (pfile_in_zip_read_info == ((Object)0)) {
			return (true);
		} 
		pfile_in_zip_read_info.setRead_buffer((byte)(.malloc((true))));
		pfile_in_zip_read_info.setOffset_local_extrafield(offset_local_extrafield);
		pfile_in_zip_read_info.setSize_local_extrafield(size_local_extrafield);
		pfile_in_zip_read_info.setPos_local_extrafield(0);
		pfile_in_zip_read_info.setRaw(raw);
		Object generatedRead_buffer = pfile_in_zip_read_info.getRead_buffer();
		if (generatedRead_buffer == ((Object)0)) {
			{ 
				if (pfile_in_zip_read_info) {
					.free(pfile_in_zip_read_info);
				} 
			}
			;
			return (true);
		} 
		pfile_in_zip_read_info.setStream_initialised(0);
		Object generatedCur_file_info = s.getCur_file_info();
		if (method != ((Object)0)) {
			method = (int)generatedCur_file_info.getCompression_method();
		} 
		if (level != ((Object)0)) {
			level = 6;
			switch (generatedCur_file_info.getFlag() & -1024) {
			case 6:
					level = 1;
					break;
			case 2:
					level = 9;
					break;
			case 4:
					level = 2;
					break;
			}
		} 
		if ((generatedCur_file_info.getCompression_method() != 0) && (generatedCur_file_info.getCompression_method() != /* #ifdef HAVE_BZIP2 */12) && (generatedCur_file_info.getCompression_method() != /* #endif */8)) {
			err = (true);
		} 
		pfile_in_zip_read_info.setCrc32_wait(generatedCur_file_info.getCrc());
		pfile_in_zip_read_info.setCrc32(0);
		pfile_in_zip_read_info.setTotal_out_64(0);
		pfile_in_zip_read_info.setCompression_method(generatedCur_file_info.getCompression_method());
		Object generatedFilestream = s.getFilestream();
		pfile_in_zip_read_info.setFilestream(generatedFilestream);
		Object generatedZ_filefunc = s.getZ_filefunc();
		pfile_in_zip_read_info.setZ_filefunc(generatedZ_filefunc);
		Object generatedByte_before_the_zipfile = s.getByte_before_the_zipfile();
		pfile_in_zip_read_info.setByte_before_the_zipfile(generatedByte_before_the_zipfile);
		Object generatedStream = pfile_in_zip_read_info.getStream();
		generatedStream.setTotal_out(0);
		if ((generatedCur_file_info.getCompression_method() == 12) && (!raw)) {
			pfile_in_zip_read_info.setRaw(1);
		}  else if ((generatedCur_file_info.getCompression_method() == 8) && (!raw)) {
			generatedStream.setZalloc((alloc_func)0);
			generatedStream.setZfree((free_func)0);
			generatedStream.setOpaque((voidpf)0);
			generatedStream.setNext_in(0);
			generatedStream.setAvail_in(0);
			err = ModernizedCProgram.inflateInit2_((generatedStream), (true), "1.2.11", (int));
			if (err == 0) {
				pfile_in_zip_read_info.setStream_initialised(8);
			} else {
					{ 
						if (pfile_in_zip_read_info) {
							.free(pfile_in_zip_read_info);
						} 
					}
					;
					return err/* windowBits is passed < 0 to tell that there is no zlib header.
					         * Note that in this case inflate *requires* an extra "dummy" byte
					         * after the compressed stream in order to complete decompression and
					         * return Z_STREAM_END.
					         * In unzip, i don't wait absolutely Z_STREAM_END because I known the
					         * size of both compressed and uncompressed data
					         */;
			} 
		} 
		pfile_in_zip_read_info.setRest_read_compressed(generatedCur_file_info.getCompressed_size());
		pfile_in_zip_read_info.setRest_read_uncompressed(generatedCur_file_info.getUncompressed_size());
		Object generatedCur_file_info_internal = s.getCur_file_info_internal();
		pfile_in_zip_read_info.setPos_in_zipfile(generatedCur_file_info_internal.getOffset_curfile() + (true) + iSizeVar);
		generatedStream.setAvail_in((uInt)0);
		s.setPfile_in_zip_read(pfile_in_zip_read_info);
		s.setEncrypted(0);
		return (false);
	}
	public static int unzOpenCurrentFile(Object file) {
		return ModernizedCProgram.unzOpenCurrentFile3(file, ((Object)0), ((Object)0), 0, ((Object)0));
	}
	public static int unzOpenCurrentFilePassword(Object file, Object password) {
		return ModernizedCProgram.unzOpenCurrentFile3(file, ((Object)0), ((Object)0), 0, password);
	}
	public static int unzOpenCurrentFile2(Object file, Integer method, Integer level, int raw) {
		return ModernizedCProgram.unzOpenCurrentFile3(file, method, level, raw, ((Object)0));
	}
	/** Addition for GDAL : START */
	public static Object unzGetCurrentFileZStreamPos64(Object file) {
		unz64_s s = new unz64_s();
		file_in_zip64_read_info_s pfile_in_zip_read_info = new file_in_zip64_read_info_s();
		s = (unz64_s)file;
		if (file == ((Object)0)) {
			return 0;
		} 
		Object generatedPfile_in_zip_read = s.getPfile_in_zip_read();
		pfile_in_zip_read_info = generatedPfile_in_zip_read;
		if (pfile_in_zip_read_info == ((Object)0)) {
			return 0;
		} 
		Object generatedPos_in_zipfile = pfile_in_zip_read_info.getPos_in_zipfile();
		Object generatedByte_before_the_zipfile = pfile_in_zip_read_info.getByte_before_the_zipfile();
		return generatedPos_in_zipfile + generatedByte_before_the_zipfile;
	}
	public static int unzReadCurrentFile(Object file, Object buf, int len) {
		int err = (false);
		uInt iRead = 0;
		unz64_s s = new unz64_s();
		file_in_zip64_read_info_s pfile_in_zip_read_info = new file_in_zip64_read_info_s();
		if (file == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		Object generatedPfile_in_zip_read = s.getPfile_in_zip_read();
		pfile_in_zip_read_info = generatedPfile_in_zip_read;
		if (pfile_in_zip_read_info == ((Object)0)) {
			return (true);
		} 
		Object generatedRead_buffer = pfile_in_zip_read_info.getRead_buffer();
		if (generatedRead_buffer == ((Object)0)) {
			return (true);
		} 
		if (len == 0) {
			return 0;
		} 
		Object generatedStream = pfile_in_zip_read_info.getStream();
		generatedStream.setNext_out((Bytef)buf);
		generatedStream.setAvail_out((uInt)len);
		Object generatedRest_read_uncompressed = pfile_in_zip_read_info.getRest_read_uncompressed();
		Object generatedRaw = pfile_in_zip_read_info.getRaw();
		if ((len > generatedRest_read_uncompressed) && (!(generatedRaw))) {
			generatedStream.setAvail_out((uInt)generatedRest_read_uncompressed);
		} 
		Object generatedRest_read_compressed = pfile_in_zip_read_info.getRest_read_compressed();
		if ((len > generatedRest_read_compressed + generatedStream.getAvail_in()) && (generatedRaw)) {
			generatedStream.setAvail_out((uInt)generatedRest_read_compressed + generatedStream.getAvail_in());
		} 
		Object generatedZ_filefunc = pfile_in_zip_read_info.getZ_filefunc();
		Object generatedFilestream = pfile_in_zip_read_info.getFilestream();
		Object generatedPos_in_zipfile = pfile_in_zip_read_info.getPos_in_zipfile();
		Object generatedByte_before_the_zipfile = pfile_in_zip_read_info.getByte_before_the_zipfile();
		Object generatedCompression_method = pfile_in_zip_read_info.getCompression_method();
		Object generatedTotal_out_64 = pfile_in_zip_read_info.getTotal_out_64();
		Object generatedCrc32 = pfile_in_zip_read_info.getCrc32();
		while (generatedStream.getAvail_out() > 0) {
			if ((generatedStream.getAvail_in() == 0) && (generatedRest_read_compressed > 0)) {
				uInt uReadThis = (true);
				if (generatedRest_read_compressed < uReadThis) {
					uReadThis = (uInt)generatedRest_read_compressed;
				} 
				if (uReadThis == 0) {
					return (false);
				} 
				if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (generatedPos_in_zipfile + generatedByte_before_the_zipfile), ((false)))) != 0) {
					return ((true));
				} 
				if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, generatedRead_buffer, uReadThis)) != uReadThis) {
					return ((true));
				} 
				generatedPos_in_zipfile += uReadThis;
				generatedRest_read_compressed -= uReadThis;
				generatedStream.setNext_in((Bytef)generatedRead_buffer);
				generatedStream.setAvail_in((uInt)uReadThis);
			} 
			if ((generatedCompression_method == 0) || (generatedRaw)) {
				uInt uDoCopy = new uInt();
				uInt i = new uInt();
				if ((generatedStream.getAvail_in() == 0) && (generatedRest_read_compressed == 0)) {
					return (iRead == 0) ? (false) : iRead;
				} 
				if (generatedStream.getAvail_out() < generatedStream.getAvail_in()) {
					uDoCopy = generatedStream.getAvail_out();
				} else {
						uDoCopy = generatedStream.getAvail_in();
				} 
				for (i = 0; i < uDoCopy; i++) {
					(generatedStream.getNext_out() + i) = (generatedStream.getNext_in() + i);
				}
				pfile_in_zip_read_info.setTotal_out_64(generatedTotal_out_64 + uDoCopy);
				pfile_in_zip_read_info.setCrc32(ModernizedCProgram.crc32(generatedCrc32, generatedStream.getNext_out(), uDoCopy));
				generatedRest_read_uncompressed -= uDoCopy;
				generatedStream.getAvail_in() -= uDoCopy;
				generatedStream.getAvail_out() -= uDoCopy;
				generatedStream.getNext_out() += uDoCopy;
				generatedStream.getNext_in() += uDoCopy;
				generatedStream.getTotal_out() += uDoCopy;
				iRead += uDoCopy;
			}  else if (generatedCompression_method == 12) {
			} else {
					ZPOS64_T uTotalOutBefore = new ZPOS64_T();
					ZPOS64_T uTotalOutAfter = new ZPOS64_T();
					Bytef bufBefore = new Bytef();
					ZPOS64_T uOutThis = new ZPOS64_T();
					int flush = 2;
					uTotalOutBefore = generatedStream.getTotal_out();
					bufBefore = generatedStream.getNext_out();
					err = ModernizedCProgram.inflate(generatedStream, flush);
					if ((err >= 0) && (generatedStream.getMsg() != ((Object)0))) {
						err = (true);
					} 
					uTotalOutAfter = generatedStream.getTotal_out();
					uOutThis = uTotalOutAfter - uTotalOutBefore;
					pfile_in_zip_read_info.setTotal_out_64(generatedTotal_out_64 + uOutThis);
					pfile_in_zip_read_info.setCrc32(ModernizedCProgram.crc32(generatedCrc32, bufBefore, (uInt)(uOutThis)));
					generatedRest_read_uncompressed -= uOutThis;
					iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
					if (err == 1) {
						return (iRead == 0) ? (false) : iRead;
					} 
					if (err != 0) {
						break;
					} 
			} 
		}
		if (err == 0) {
			return iRead;
		} 
		return err;
	}
	/*
	  Give the current position in uncompressed data
	*/
	public static long unztell(Object file) {
		unz64_s s = new unz64_s();
		file_in_zip64_read_info_s pfile_in_zip_read_info = new file_in_zip64_read_info_s();
		if (file == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		Object generatedPfile_in_zip_read = s.getPfile_in_zip_read();
		pfile_in_zip_read_info = generatedPfile_in_zip_read;
		if (pfile_in_zip_read_info == ((Object)0)) {
			return (true);
		} 
		Object generatedStream = pfile_in_zip_read_info.getStream();
		return (long)generatedStream.getTotal_out();
	}
	public static Object unztell64(Object file) {
		unz64_s s = new unz64_s();
		file_in_zip64_read_info_s pfile_in_zip_read_info = new file_in_zip64_read_info_s();
		if (file == ((Object)0)) {
			return (ZPOS64_T)-1;
		} 
		s = (unz64_s)file;
		Object generatedPfile_in_zip_read = s.getPfile_in_zip_read();
		pfile_in_zip_read_info = generatedPfile_in_zip_read;
		if (pfile_in_zip_read_info == ((Object)0)) {
			return (ZPOS64_T)-1;
		} 
		Object generatedTotal_out_64 = pfile_in_zip_read_info.getTotal_out_64();
		return generatedTotal_out_64;
	}
	/*
	  return 1 if the end of file was reached, 0 elsewhere
	*/
	public static int unzeof(Object file) {
		unz64_s s = new unz64_s();
		file_in_zip64_read_info_s pfile_in_zip_read_info = new file_in_zip64_read_info_s();
		if (file == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		Object generatedPfile_in_zip_read = s.getPfile_in_zip_read();
		pfile_in_zip_read_info = generatedPfile_in_zip_read;
		if (pfile_in_zip_read_info == ((Object)0)) {
			return (true);
		} 
		Object generatedRest_read_uncompressed = pfile_in_zip_read_info.getRest_read_uncompressed();
		if (generatedRest_read_uncompressed == 0) {
			return 1;
		} else {
				return 0/*
				Read extra field from the current file (opened by unzOpenCurrentFile)
				This is the local-header version of the extra field (sometimes, there is
				more info in the local-header version than in the central-header)
				
				  if buf==NULL, it return the size of the local extra field that can be read
				
				  if buf!=NULL, len is the size of the buffer, the extra header is copied in
				    buf.
				  the return value is the number of bytes copied in buf, or (if <0)
				    the error code
				*/;
		} 
	}
	public static int unzGetLocalExtrafield(Object file, Object buf, int len) {
		unz64_s s = new unz64_s();
		file_in_zip64_read_info_s pfile_in_zip_read_info = new file_in_zip64_read_info_s();
		uInt read_now = new uInt();
		ZPOS64_T size_to_read = new ZPOS64_T();
		if (file == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		Object generatedPfile_in_zip_read = s.getPfile_in_zip_read();
		pfile_in_zip_read_info = generatedPfile_in_zip_read;
		if (pfile_in_zip_read_info == ((Object)0)) {
			return (true);
		} 
		Object generatedSize_local_extrafield = pfile_in_zip_read_info.getSize_local_extrafield();
		Object generatedPos_local_extrafield = pfile_in_zip_read_info.getPos_local_extrafield();
		size_to_read = (generatedSize_local_extrafield - generatedPos_local_extrafield);
		if (buf == ((Object)0)) {
			return (int)size_to_read;
		} 
		if (len > size_to_read) {
			read_now = (uInt)size_to_read;
		} else {
				read_now = (uInt)len;
		} 
		if (read_now == 0) {
			return 0;
		} 
		Object generatedZ_filefunc = pfile_in_zip_read_info.getZ_filefunc();
		Object generatedFilestream = pfile_in_zip_read_info.getFilestream();
		Object generatedOffset_local_extrafield = pfile_in_zip_read_info.getOffset_local_extrafield();
		if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (generatedOffset_local_extrafield + generatedPos_local_extrafield), ((false)))) != 0) {
			return ((true));
		} 
		if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, buf, read_now)) != read_now) {
			return ((true));
		} 
		return (int)read_now/*
		  Close the file in zip opened with unzOpenCurrentFile
		  Return UNZ_CRCERROR if all the file was read but the CRC is not good
		*/;
	}
	public static int unzCloseCurrentFile(Object file) {
		int err = (false);
		unz64_s s = new unz64_s();
		file_in_zip64_read_info_s pfile_in_zip_read_info = new file_in_zip64_read_info_s();
		if (file == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		Object generatedPfile_in_zip_read = s.getPfile_in_zip_read();
		pfile_in_zip_read_info = generatedPfile_in_zip_read;
		if (pfile_in_zip_read_info == ((Object)0)) {
			return (true);
		} 
		Object generatedRest_read_uncompressed = pfile_in_zip_read_info.getRest_read_uncompressed();
		Object generatedRaw = pfile_in_zip_read_info.getRaw();
		Object generatedCrc32 = pfile_in_zip_read_info.getCrc32();
		Object generatedCrc32_wait = pfile_in_zip_read_info.getCrc32_wait();
		if ((generatedRest_read_uncompressed == 0) && (!generatedRaw)) {
			if (generatedCrc32 != generatedCrc32_wait) {
				err = (true);
			} 
		} 
		Object generatedRead_buffer = pfile_in_zip_read_info.getRead_buffer();
		{ 
			if (generatedRead_buffer) {
				.free(generatedRead_buffer);
			} 
		}
		;
		pfile_in_zip_read_info.setRead_buffer(((Object)0));
		Object generatedStream_initialised = pfile_in_zip_read_info.getStream_initialised();
		Object generatedStream = pfile_in_zip_read_info.getStream();
		if (generatedStream_initialised == 8) {
			ModernizedCProgram.inflateEnd(generatedStream);
		} 
		pfile_in_zip_read_info.setStream_initialised(0);
		{ 
			if (pfile_in_zip_read_info) {
				.free(pfile_in_zip_read_info);
			} 
		}
		;
		s.setPfile_in_zip_read(((Object)0));
		return err/*
		  Get the global comment string of the ZipFile, in the szComment buffer.
		  uSizeBuf is the size of the szComment buffer.
		  return the number of byte copied or an error code <0
		*/;
	}
	public static int unzGetGlobalComment(Object file, byte szComment, Object uSizeBuf) {
		unz64_s s = new unz64_s();
		uLong uReadThis = new uLong();
		if (file == ((Object)0)) {
			return (int)(true);
		} 
		s = (unz64_s)file;
		uReadThis = uSizeBuf;
		Object generatedGi = s.getGi();
		if (uReadThis > generatedGi.getSize_comment()) {
			uReadThis = generatedGi.getSize_comment();
		} 
		Object generatedZ_filefunc = s.getZ_filefunc();
		Object generatedFilestream = s.getFilestream();
		Object generatedCentral_pos = s.getCentral_pos();
		if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (generatedCentral_pos + 22), ((false)))) != 0) {
			return ((true));
		} 
		if (uReadThis > 0) {
			szComment = (byte)'\0';
			if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, szComment, uReadThis)) != uReadThis) {
				return ((true));
			} 
		} 
		if ((szComment != ((Object)0)) && (uSizeBuf > generatedGi.getSize_comment())) {
			(szComment + generatedGi.getSize_comment()) = (byte)'\0';
		} 
		return (int)uReadThis;
	}
	/* Additions by RX '2004 */
	public static Object unzGetOffset64(Object file) {
		unz64_s s = new unz64_s();
		if (file == ((Object)0)) {
			return 0;
		} 
		s = (unz64_s)file;
		Object generatedCurrent_file_ok = s.getCurrent_file_ok();
		if (!generatedCurrent_file_ok) {
			return 0;
		} 
		Object generatedGi = s.getGi();
		Object generatedNum_file = s.getNum_file();
		if (generatedGi.getNumber_entry() != 0 && generatedGi.getNumber_entry() != -1024) {
			if (generatedNum_file == generatedGi.getNumber_entry()) {
				return 0;
			} 
		} 
		Object generatedPos_in_central_dir = s.getPos_in_central_dir();
		return generatedPos_in_central_dir;
	}
	public static Object unzGetOffset(Object file) {
		ZPOS64_T offset64 = new ZPOS64_T();
		if (file == ((Object)0)) {
			return 0;
		} 
		offset64 = ModernizedCProgram.unzGetOffset64(file);
		return (uLong)offset64;
	}
	public static int unzSetOffset64(Object file, Object pos) {
		unz64_s s = new unz64_s();
		int err;
		if (file == ((Object)0)) {
			return (true);
		} 
		s = (unz64_s)file;
		s.setPos_in_central_dir(pos);
		Object generatedGi = s.getGi();
		s.setNum_file(generatedGi.getNumber_entry());
		Object generatedCur_file_info = s.getCur_file_info();
		Object generatedCur_file_info_internal = s.getCur_file_info_internal();
		err = ModernizedCProgram.unz64local_GetCurrentFileInfoInternal(file, generatedCur_file_info, generatedCur_file_info_internal, ((Object)0), 0, ((Object)0), 0, ((Object)0), 0);
		s.setCurrent_file_ok((err == (false)));
		return err;
	}
	public static int unzSetOffset(Object file, Object pos) {
		return ModernizedCProgram.unzSetOffset64(file, pos);
	}
	public static boolean class_num(Object c) {
		return ((c >= (byte)'0') && (c <= (byte)'9'));
	}
	public static boolean class_lower(Object c) {
		return ((c >= (byte)'a') && (c <= (byte)'z'));
	}
	public static boolean class_upper(Object c) {
		return ((c >= (byte)'A') && (c <= (byte)'Z'));
	}
	public static boolean class_alpha(Object c) {
		return (ModernizedCProgram.class_lower(c) || ModernizedCProgram.class_upper(c));
	}
	public static int conv_ctoi(Object c) {
		if (ModernizedCProgram.class_num(c)) {
			return c - (byte)'0';
		} 
		if (ModernizedCProgram.class_upper(c)) {
			return c - (byte)'A' + 10;
		} 
		return -1;
	}
	public static int conv_itoc(Object c) {
		if (c < 10) {
			return c + (byte)'0';
		} 
		if (c < 37) {
			return c + (byte)'A' - 10;
		} 
		return -1;
	}
	public static int generate_random_rule(Byte rule_buf, Object rp_gen_func_min, Object rp_gen_func_max) {
		u32 rp_gen_num = ModernizedCProgram.get_random_num(rp_gen_func_min, rp_gen_func_max);
		u32 j = new u32();
		u32 rule_pos = 0;
		for (j = 0; j < rp_gen_num; j++) {
			u32 r = 0;
			u32 p1 = 0;
			u32 p2 = 0;
			switch ((byte)ModernizedCProgram.get_random_num(0, 9)) {
			case 2:
					r = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_op_pos_p1[r];
					p1 = ModernizedCProgram.get_random_num(1, 6);
					rule_buf[rule_pos++] = ModernizedCProgram.grp_pos[p1];
					break;
			case 6:
					r = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_op_pos_pos0[r];
					p1 = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_pos[p1];
					p2 = ModernizedCProgram.get_random_num(0, );
					while (p1 == p2) {
						p2 = ModernizedCProgram.get_random_num(0, );
					}
					rule_buf[rule_pos++] = ModernizedCProgram.grp_pos[p2];
					break;
			case 4:
					r = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_op_chr_chr[r];
					p1 = ModernizedCProgram.get_random_num(-1024, -1024);
					rule_buf[rule_pos++] = (byte)p1;
					p2 = ModernizedCProgram.get_random_num(-1024, -1024);
					while (p1 == p2) {
						p2 = ModernizedCProgram.get_random_num(-1024, -1024);
					}
					rule_buf[rule_pos++] = (byte)p2;
					break;
			case 5:
					r = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_op_pos_chr[r];
					p1 = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_pos[p1];
					p2 = ModernizedCProgram.get_random_num(-1024, -1024);
					rule_buf[rule_pos++] = (byte)p2;
					break;
			case 7:
					r = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_op_pos_pos1[r];
					p1 = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_pos[p1];
					p2 = ModernizedCProgram.get_random_num(1, );
					while (p1 == p2) {
						p2 = ModernizedCProgram.get_random_num(1, );
					}
					rule_buf[rule_pos++] = ModernizedCProgram.grp_pos[p2];
					break;
			case 0:
					r = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_op_nop[r];
					break;
			case 3:
					r = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_op_chr[r];
					p1 = ModernizedCProgram.get_random_num(-1024, -1024);
					rule_buf[rule_pos++] = (byte)p1;
					break;
			case 1:
					r = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_op_pos_p0[r];
					p1 = ModernizedCProgram.get_random_num(0, );
					rule_buf[rule_pos++] = ModernizedCProgram.grp_pos[p1];
					break;
			}
		}
		return (rule_pos);
	}
	public static boolean is_hex_notation(Object rule_buf, Object rule_len, Object rule_pos) {
		if ((rule_pos + 4) > rule_len) {
			return 0;
		} 
		if (rule_buf[rule_pos + 0] != (byte)'\\') {
			return 0;
		} 
		if (rule_buf[rule_pos + 1] != (byte)'x') {
			return 0;
		} 
		if (ModernizedCProgram.is_valid_hex_char(rule_buf[rule_pos + 2]) == 0) {
			return 0;
		} 
		if (ModernizedCProgram.is_valid_hex_char(rule_buf[rule_pos + 3]) == 0) {
			return 0;
		} 
		return 1;
	}
	public static int cpu_rule_to_kernel_rule(Byte rule_buf, Object rule_len) {
		u32 rule_pos = new u32();
		u32 rule_cnt = new u32();
		Object generatedCmds = (rule).getCmds();
		for (; rule_pos < rule_len && rule_cnt < (32 - 1); ) {
			switch (rule_buf[rule_pos]) {
			case rule_functions.RULE_OP_MANGLE_LREST_UFIRST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_PURGECHAR:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					if (ModernizedCProgram.is_hex_notation(rule_buf, rule_len, rule_pos) == 1) {
						generatedCmds[rule_cnt] |=  (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 3] & -1024) << 8) | (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 2] & -1024) << 12);
						rule_pos += 3;
					} else {
							generatedCmds[rule_cnt] |=  ((rule_buf[rule_pos]) & -1024) << 8;
					} 
					;
					break;
			case rule_functions.RULE_OP_MANGLE_NOOP:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_TOGGLECASE_REC:
					return -1;
			case rule_functions.RULE_OP_MANGLE_DELETE_FIRST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_PREPEND:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					if (ModernizedCProgram.is_hex_notation(rule_buf, rule_len, rule_pos) == 1) {
						generatedCmds[rule_cnt] |=  (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 3] & -1024) << 8) | (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 2] & -1024) << 12);
						rule_pos += 3;
					} else {
							generatedCmds[rule_cnt] |=  ((rule_buf[rule_pos]) & -1024) << 8;
					} 
					;
					break;
			case rule_functions.RULE_OP_MANGLE_OMIT:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 16;
					break;
			case rule_functions.RULE_OP_MANGLE_APPEND:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					if (ModernizedCProgram.is_hex_notation(rule_buf, rule_len, rule_pos) == 1) {
						generatedCmds[rule_cnt] |=  (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 3] & -1024) << 8) | (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 2] & -1024) << 12);
						rule_pos += 3;
					} else {
							generatedCmds[rule_cnt] |=  ((rule_buf[rule_pos]) & -1024) << 8;
					} 
					;
					break;
			case rule_functions.RULE_OP_MANGLE_DUPECHAR_FIRST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_DELETE_LAST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEWORD:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEWORD_TIMES:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_REPLACE:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					if (ModernizedCProgram.is_hex_notation(rule_buf, rule_len, rule_pos) == 1) {
						generatedCmds[rule_cnt] |=  (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 3] & -1024) << 8) | (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 2] & -1024) << 12);
						rule_pos += 3;
					} else {
							generatedCmds[rule_cnt] |=  ((rule_buf[rule_pos]) & -1024) << 8;
					} 
					;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					if (ModernizedCProgram.is_hex_notation(rule_buf, rule_len, rule_pos) == 1) {
						generatedCmds[rule_cnt] |=  (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 3] & -1024) << 16) | (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 2] & -1024) << 20);
						rule_pos += 3;
					} else {
							generatedCmds[rule_cnt] |=  ((rule_buf[rule_pos]) & -1024) << 16;
					} 
					;
					break;
			case rule_functions.RULE_OP_MANGLE_LREST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_SWITCH_FIRST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_TITLE:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_EXTRACT:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 16;
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_SHIFTL:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_TREST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_REPLACE_NM1:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_REFLECT:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_TRUNCATE_AT:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEBLOCK_FIRST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_TOGGLE_AT:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_DUPECHAR_ALL:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_REPLACE_NP1:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_INCR:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_DECR:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_ROTATE_RIGHT:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_SHIFTR:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_UREST_LFIRST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case (byte)' ':
					rule_cnt--;
					break;
			case rule_functions.RULE_OP_MANGLE_ROTATE_LEFT:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_DUPECHAR_LAST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_SWITCH_LAST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_INSERT:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					if (ModernizedCProgram.is_hex_notation(rule_buf, rule_len, rule_pos) == 1) {
						generatedCmds[rule_cnt] |=  (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 3] & -1024) << 16) | (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 2] & -1024) << 20);
						rule_pos += 3;
					} else {
							generatedCmds[rule_cnt] |=  ((rule_buf[rule_pos]) & -1024) << 16;
					} 
					;
					break;
			case rule_functions.RULE_OP_MANGLE_SWITCH_AT:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 16;
					break;
			case rule_functions.RULE_OP_MANGLE_UREST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_DELETE_AT:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_TITLE_SEP:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					if (ModernizedCProgram.is_hex_notation(rule_buf, rule_len, rule_pos) == 1) {
						generatedCmds[rule_cnt] |=  (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 3] & -1024) << 8) | (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 2] & -1024) << 12);
						rule_pos += 3;
					} else {
							generatedCmds[rule_cnt] |=  ((rule_buf[rule_pos]) & -1024) << 8;
					} 
					;
					break;
			case rule_functions.RULE_OP_MANGLE_REVERSE:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEBLOCK_LAST:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					break;
			case rule_functions.RULE_OP_MANGLE_OVERSTRIKE:
					generatedCmds[rule_cnt] = ((rule_buf[rule_pos]) & -1024) << 0;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					generatedCmds[rule_cnt] |=  ((ModernizedCProgram.conv_ctoi(rule_buf[rule_pos])) & -1024) << 8;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					if (ModernizedCProgram.is_hex_notation(rule_buf, rule_len, rule_pos) == 1) {
						generatedCmds[rule_cnt] |=  (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 3] & -1024) << 16) | (ModernizedCProgram.hex_convert(rule_buf[rule_pos + 2] & -1024) << 20);
						rule_pos += 3;
					} else {
							generatedCmds[rule_cnt] |=  ((rule_buf[rule_pos]) & -1024) << 16;
					} 
					;
					break;
			default:
					return -1;
			}
		}
		if (rule_pos < rule_len) {
			return -1;
		} 
		return 0;
	}
	public static int kernel_rule_to_cpu_rule(Byte rule_buf) {
		u32 rule_cnt = new u32();
		u32 rule_pos = new u32();
		// maximum possible lenu32 rule_len = -1024 - 1;
		Object generatedCmds = (rule).getCmds();
		for (; rule_pos < rule_len && rule_cnt < (32 - 1); ) {
			byte rule_cmd;
			rule_cmd = ((generatedCmds[rule_cnt] >> 0) & -1024);
			if (rule_cnt > 0) {
				rule_buf[rule_pos++] = (byte)' ';
			} 
			switch (rule_cmd) {
			case rule_functions.RULE_OP_MANGLE_DELETE_FIRST:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEBLOCK_LAST:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_TITLE_SEP:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = ((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_ROTATE_LEFT:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_TREST:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_UREST:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_SWITCH_AT:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 16) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_DELETE_AT:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_DECR:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_DUPECHAR_FIRST:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_REFLECT:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_INSERT:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = ((generatedCmds[rule_cnt] >> 16) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_SWITCH_LAST:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_UREST_LFIRST:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_TOGGLECASE_REC:
					return -1;
			case rule_functions.RULE_OP_MANGLE_REPLACE:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = ((generatedCmds[rule_cnt] >> 8) & -1024);
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = ((generatedCmds[rule_cnt] >> 16) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEWORD_TIMES:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_NOOP:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_REVERSE:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_TRUNCATE_AT:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_TOGGLE_AT:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_SHIFTR:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_APPEND:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = ((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_DUPECHAR_ALL:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEWORD:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_OVERSTRIKE:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = ((generatedCmds[rule_cnt] >> 16) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_TITLE:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_REPLACE_NM1:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_EXTRACT:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 16) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_ROTATE_RIGHT:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_DUPEBLOCK_FIRST:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_PURGECHAR:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = ((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_LREST:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_SWITCH_FIRST:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case 0:
					if (rule_pos == 0) {
						return -1;
					} 
					return rule_pos - 1;
			case rule_functions.RULE_OP_MANGLE_LREST_UFIRST:
					rule_buf[rule_pos] = rule_cmd;
					break;
			case rule_functions.RULE_OP_MANGLE_REPLACE_NP1:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_INCR:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_DUPECHAR_LAST:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_OMIT:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 16) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_CHR_SHIFTL:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = (byte)ModernizedCProgram.conv_itoc((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_PREPEND:
					rule_buf[rule_pos] = rule_cmd;
					if (++rule_pos == rule_len) {
						return (true);
					} 
					rule_buf[rule_pos] = ((generatedCmds[rule_cnt] >> 8) & -1024);
					break;
			case rule_functions.RULE_OP_MANGLE_DELETE_LAST:
					rule_buf[rule_pos] = rule_cmd;
					break;
			default:
					return -1;
			}
		}
		return rule_pos;
	}
	public static boolean kernel_rules_has_noop(Object kernel_rules_buf, Object kernel_rules_cnt) {
		for (u32 kernel_rules_pos = 0;
		 kernel_rules_pos < kernel_rules_cnt; kernel_rules_pos++) {
			if (kernel_rules_buf[kernel_rules_pos].getCmds()[0] != rule_functions.RULE_OP_MANGLE_NOOP) {
				continue;
			} 
			if (kernel_rules_buf[kernel_rules_pos].getCmds()[1] != 0) {
				continue;
			} 
			return 1;
		}
		return 0;
	}
	public static int kernel_rules_load(hashcat_ctx hashcat_ctx,  out_buf, Object out_cnt) {
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		u32 all_kernel_rules_cnt = ((Object)0);
		kernel_rule_t all_kernel_rules_buf = ((Object)0);
		if (user_options.getRp_files_cnt()) {
			all_kernel_rules_cnt = (u32)ModernizedCProgram.hccalloc(user_options.getRp_files_cnt(), );
			all_kernel_rules_buf = (kernel_rule_t)ModernizedCProgram.hccalloc(user_options.getRp_files_cnt(), );
		} 
		byte rule_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
		u32 rule_len = 0;
		for (u32 i = 0;
		 i < user_options.getRp_files_cnt(); i++) {
			u32 kernel_rules_avail = 0;
			u32 kernel_rules_cnt = 0;
			kernel_rule_t kernel_rules_buf = ((Object)0);
			byte rp_file = user_options.getRp_files()[i];
			HCFILE fp = new HCFILE();
			u32 rule_line = 0;
			if (fp.hc_fopen(rp_file, "rb") == 0) {
				hashcat_ctx.event_log_error("%s: %s", rp_file, .strerror((._errno())));
				ModernizedCProgram.hcfree(all_kernel_rules_cnt);
				ModernizedCProgram.hcfree(all_kernel_rules_buf);
				ModernizedCProgram.hcfree(rule_buf);
				return -1;
			} 
			while (!fp.hc_feof()) {
				rule_len = (u32)fp.fgetl(rule_buf, -1024);
				rule_line++;
				if (rule_len == 0) {
					continue;
				} 
				if (rule_buf[0] == (byte)'#') {
					continue;
				} 
				if (kernel_rules_avail == kernel_rules_cnt) {
					kernel_rules_buf = (kernel_rule_t)ModernizedCProgram.hcrealloc(kernel_rules_buf, kernel_rules_avail * , 10000 * );
					kernel_rules_avail += 10000;
				} 
				byte[] in = new byte[256];
				byte[] out = new byte[256];
				.memset(in, 0, );
				.memset(out, 0, );
				int result = ModernizedCProgram._old_apply_rule(rule_buf, rule_len, in, 1, out);
				if (result == -1) {
					hashcat_ctx.event_log_warning("Skipping invalid or unsupported rule in file %s on line %u: %s", rp_file, rule_line, rule_buf);
					continue;
				} 
				if (kernel_rules_buf[kernel_rules_cnt].cpu_rule_to_kernel_rule(rule_buf, rule_len) == -1) {
					hashcat_ctx.event_log_warning("Cannot convert rule for use on OpenCL device in file %s on line %u: %s", rp_file, rule_line, rule_buf);
					.memset(kernel_rules_buf[kernel_rules_cnt], 0, );
					continue;
				} 
				kernel_rules_cnt++;
			}
			fp.hc_fclose();
			all_kernel_rules_cnt[i] = kernel_rules_cnt;
			all_kernel_rules_buf[i] = kernel_rules_buf;
		}
		ModernizedCProgram.hcfree(rule_buf/**
		   * merge rules
		   */);
		u32 kernel_rules_cnt = 1;
		u32 repeats = (u32)ModernizedCProgram.hccalloc(user_options.getRp_files_cnt() + 1, );
		repeats[0] = kernel_rules_cnt;
		for (u32 i = 0;
		 i < user_options.getRp_files_cnt(); i++) {
			kernel_rules_cnt *= all_kernel_rules_cnt[i];
			repeats[i + 1] = kernel_rules_cnt;
		}
		kernel_rule_t kernel_rules_buf = (kernel_rule_t)ModernizedCProgram.hccalloc(kernel_rules_cnt, );
		Object generatedCmds = in.getCmds();
		for (u32 i = 0;
		 i < kernel_rules_cnt; i++) {
			u32 out_pos = 0;
			kernel_rule_t out = kernel_rules_buf[i];
			for (u32 j = 0;
			 j < user_options.getRp_files_cnt(); j++) {
				u32 in_off = (i / repeats[j]) % all_kernel_rules_cnt[j];
				u32 in_pos = new u32();
				kernel_rule_t in = all_kernel_rules_buf[j][in_off];
				for (in_pos = 0; generatedCmds[in_pos]; ) {
					if (out_pos == 32 - 1) {
						break;
					} 
					generatedCmds[out_pos] = generatedCmds[in_pos];
				}
			}
		}
		ModernizedCProgram.hcfree(repeats);
		ModernizedCProgram.hcfree(all_kernel_rules_cnt);
		ModernizedCProgram.hcfree(all_kernel_rules_buf);
		if (kernel_rules_cnt == 0) {
			hashcat_ctx.event_log_error("No valid rules left.");
			ModernizedCProgram.hcfree(kernel_rules_buf);
			return -1;
		} 
		out_cnt = kernel_rules_cnt;
		out_buf = kernel_rules_buf;
		return 0;
	}
	public static int kernel_rules_generate(hashcat_ctx hashcat_ctx,  out_buf, Object out_cnt) {
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		u32 kernel_rules_cnt = 0;
		kernel_rule_t kernel_rules_buf = ModernizedCProgram.hccalloc(user_options.getRp_gen(), );
		byte rule_buf = (byte)ModernizedCProgram.hcmalloc(256);
		for (kernel_rules_cnt = 0; kernel_rules_cnt < user_options.getRp_gen(); kernel_rules_cnt++) {
			.memset(rule_buf, 0, 256);
			int rule_len = ModernizedCProgram.generate_random_rule(rule_buf, user_options.getRp_gen_func_min(), user_options.getRp_gen_func_max());
			if (kernel_rules_buf[kernel_rules_cnt].cpu_rule_to_kernel_rule(rule_buf, rule_len) == -1) {
				continue;
			} 
		}
		ModernizedCProgram.hcfree(rule_buf);
		out_cnt = kernel_rules_cnt;
		out_buf = kernel_rules_buf;
		return 0;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static Object hccalloc(Object nmemb, Object sz) {
		Object p = .calloc(nmemb, sz);
		if (p == ((Object)0)) {
			.fprintf((_iob[2]), "%s\n", "Insufficient memory available");
			return (((Object)0));
		} 
		return (p);
	}
	public static Object hcmalloc(Object sz) {
		//calloc is faster than malloc with big allocations, so just use that.Object p = ModernizedCProgram.hccalloc(sz, 1);
		return (p);
	}
	public static Object hcrealloc(Object ptr, Object oldsz, Object addsz) {
		Object p = .realloc(ptr, oldsz + addsz);
		if (p == ((Object)0)) {
			.fprintf((_iob[2]), "%s\n", "Insufficient memory available");
			return (((Object)0));
		} 
		.memset((byte)p + oldsz, 0, addsz);
		return (p);
	}
	public static Byte hcstrdup(Object s) {
		size_t len = .strlen(s);
		byte b = (byte)ModernizedCProgram.hcmalloc(len + 1);
		if (b == ((Object)0)) {
			return (((Object)0));
		} 
		.memcpy(b, s, len);
		b[len] = 0;
		return (b);
	}
	public static void hcfree(Object ptr) {
		if (ptr == ((Object)0)) {
			return ;
		} 
		.free(ptr);
	}
	/* uncompr.c -- decompress a memory buffer
	 * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */
	/* @(#) $Id$ */
	/* ===========================================================================
	     Decompresses the source buffer into the destination buffer.  *sourceLen is
	   the byte length of the source buffer. Upon entry, *destLen is the total size
	   of the destination buffer, which must be large enough to hold the entire
	   uncompressed data. (The size of the uncompressed data must have been saved
	   previously by the compressor and transmitted to the decompressor by some
	   mechanism outside the scope of this compression library.) Upon exit,
	   *destLen is the size of the decompressed data and *sourceLen is the number
	   of source bytes consumed. Upon return, source + *sourceLen points to the
	   first unused input byte.
	
	     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough
	   memory, Z_BUF_ERROR if there was not enough room in the output buffer, or
	   Z_DATA_ERROR if the input data was corrupted, including if the input data is
	   an incomplete zlib stream.
	*/
	public static int uncompress2(Object dest, Object destLen, Object source, Object sourceLen) {
		z_stream stream = new z_stream();
		int err;
		uInt max = (uInt)-1;
		uLong len = new uLong();
		uLong left = new uLong();
		Byte[] buf = new Byte();
		len = sourceLen;
		if (destLen) {
			left = destLen;
			destLen = 0;
		} else {
				left = 1;
				dest = buf;
		} 
		stream.setNext_in((Bytef)source);
		stream.setAvail_in(0);
		stream.setZalloc((alloc_func)0);
		stream.setZfree((free_func)0);
		stream.setOpaque((voidpf)0);
		err = ModernizedCProgram.inflateInit_((stream), "1.2.11", (int));
		if (err != 0) {
			return err;
		} 
		stream.setNext_out(dest);
		stream.setAvail_out(0);
		Object generatedAvail_out = stream.getAvail_out();
		Object generatedAvail_in = stream.getAvail_in();
		do {
			if (generatedAvail_out == 0) {
				stream.setAvail_out(left > (uLong)max ? max : (uInt)left);
				left -= generatedAvail_out;
			} 
			if (generatedAvail_in == 0) {
				stream.setAvail_in(len > (uLong)max ? max : (uInt)len);
				len -= generatedAvail_in;
			} 
			err = ModernizedCProgram.inflate(stream, 0);
		} while (err == 0);
		sourceLen -= len + generatedAvail_in;
		Object generatedTotal_out = stream.getTotal_out();
		if (dest != buf) {
			destLen = generatedTotal_out;
		}  else if (generatedTotal_out && err == (true)) {
			left = 1;
		} 
		ModernizedCProgram.inflateEnd(stream);
		return err == 1 ? 0 : err == 2 ? (true) : err == (true) && left + generatedAvail_out ? (true) : err;
	}
	public static int uncompress(Object dest, Object destLen, Object source, Object sourceLen) {
		return ModernizedCProgram.uncompress2(dest, destLen, source, sourceLen);
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int sort_by_src_len(Object p1, Object p2) {
		keyboard_layout_mapping_t k1 = (keyboard_layout_mapping_t)p1;
		keyboard_layout_mapping_t k2 = (keyboard_layout_mapping_t)p2;
		return k1.getSrc_len() < k2.getSrc_len();
	}
	public static int find_keyboard_layout_map(Object search, Object search_len, Object s_keyboard_layout_mapping, Object keyboard_layout_mapping_cnt) {
		for (int idx = 0;
		 idx < keyboard_layout_mapping_cnt; idx++) {
			u32 src_char = s_keyboard_layout_mapping[idx].getSrc_char();
			int src_len = s_keyboard_layout_mapping[idx].getSrc_len();
			if (src_len == search_len) {
				u32 mask = -1024 >> ((4 - search_len) * 8);
				if ((src_char & mask) == (search & mask)) {
					return idx;
				} 
			} 
		}
		return -1;
	}
	public static int execute_keyboard_layout_mapping(Object plain_buf, Object plain_len, Object s_keyboard_layout_mapping, Object keyboard_layout_mapping_cnt) {
		u32[] out_buf = new u32[]{0};
		u8 out_ptr = (u8)out_buf;
		int out_len = 0;
		u8 plain_ptr = (u8)plain_buf;
		int plain_pos = 0;
		while (plain_pos < plain_len) {
			u32 src0 = 0;
			u32 src1 = 0;
			u32 src2 = 0;
			u32 src3 = 0;
			int rem = (((plain_len - plain_pos) < (true)) ? (plain_len - plain_pos) : (true));
			if (rem > 0) {
				src0 = plain_ptr[plain_pos + 0];
			} 
			if (rem > 1) {
				src1 = plain_ptr[plain_pos + 1];
			} 
			if (rem > 2) {
				src2 = plain_ptr[plain_pos + 2];
			} 
			if (rem > 3) {
				src3 = plain_ptr[plain_pos + 3];
			} 
			u32 src = (src0 << 0) | (src1 << 8) | (src2 << 16) | (src3 << 24);
			int src_len;
			for (src_len = rem; src_len > 0; src_len--) {
				int idx = ModernizedCProgram.find_keyboard_layout_map(src, src_len, s_keyboard_layout_mapping, keyboard_layout_mapping_cnt);
				if (idx == -1) {
					continue;
				} 
				u32 dst_char = s_keyboard_layout_mapping[idx].getDst_char();
				int dst_len = s_keyboard_layout_mapping[idx].getDst_len();
				switch (dst_len) {
				case 1:
						out_ptr[out_len++] = (dst_char >> 0) & -1024;
						break;
				case 2:
						out_ptr[out_len++] = (dst_char >> 0) & -1024;
						out_ptr[out_len++] = (dst_char >> 8) & -1024;
						break;
				case 3:
						out_ptr[out_len++] = (dst_char >> 0) & -1024;
						out_ptr[out_len++] = (dst_char >> 8) & -1024;
						out_ptr[out_len++] = (dst_char >> 16) & -1024;
						break;
				case 4:
						out_ptr[out_len++] = (dst_char >> 0) & -1024;
						out_ptr[out_len++] = (dst_char >> 8) & -1024;
						out_ptr[out_len++] = (dst_char >> 16) & -1024;
						out_ptr[out_len++] = (dst_char >> 24) & -1024;
						break;
				}
				plain_pos += src_len;
				break;
			}
			if (src_len == 0) {
				out_ptr[out_len] = plain_ptr[plain_pos];
				out_len++;
				plain_pos++;
			} 
		}
		plain_buf[0] = out_buf[0];
		plain_buf[1] = out_buf[1];
		plain_buf[2] = out_buf[2];
		plain_buf[3] = out_buf[3];
		plain_buf[4] = out_buf[4];
		plain_buf[5] = out_buf[5];
		plain_buf[6] = out_buf[6];
		plain_buf[7] = out_buf[7];
		plain_buf[8] = out_buf[8];
		plain_buf[9] = out_buf[9];
		plain_buf[10] = out_buf[10];
		plain_buf[11] = out_buf[11];
		plain_buf[12] = out_buf[12];
		plain_buf[13] = out_buf[13];
		plain_buf[14] = out_buf[14];
		plain_buf[15] = out_buf[15];
		return out_len;
	}
	/* 7zBuf2.c -- Byte Buffer
	2017-04-03 : Igor Pavlov : Public domain */
	public static void DynBuf_Construct() {
		this.setData(0);
		this.setSize(0);
		this.setPos(0);
	}
	public static void DynBuf_SeekToBeg() {
		this.setPos(0);
	}
	public static int DynBuf_Write(Object buf, Object size, Object alloc) {
		Object generatedSize = this.getSize();
		Object generatedPos = this.getPos();
		Object generatedData = this.getData();
		if (size > generatedSize - generatedPos) {
			size_t newSize = generatedPos + size;
			Byte data = new Byte();
			newSize += newSize / 4;
			data = (Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, newSize);
			if (!data) {
				return 0;
			} 
			this.setSize(newSize);
			if (generatedPos != 0) {
				.memcpy(data, generatedData, generatedPos);
			} 
			.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedData);
			this.setData(data);
		} 
		if (size != 0) {
			.memcpy(generatedData + generatedPos, buf, size);
			generatedPos += size;
		} 
		return 1;
	}
	public static void DynBuf_Free(Object alloc) {
		Object generatedData = this.getData();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedData);
		this.setData(0);
		this.setSize(0);
		this.setPos(0);
	}
	public static void sha1aix_decode(Object digest, Object buf) {
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[2] = (l >> 0) & -1024;
		digest[1] = (l >> 8) & -1024;
		digest[0] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[5] = (l >> 0) & -1024;
		digest[4] = (l >> 8) & -1024;
		digest[3] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[8] = (l >> 0) & -1024;
		digest[7] = (l >> 8) & -1024;
		digest[6] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[11] = (l >> 0) & -1024;
		digest[10] = (l >> 8) & -1024;
		digest[9] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[14] = (l >> 0) & -1024;
		digest[13] = (l >> 8) & -1024;
		digest[12] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[22]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[23]) << 18;
		digest[17] = (l >> 0) & -1024;
		digest[16] = (l >> 8) & -1024;
		digest[15] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[24]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[25]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[26]) << 12;
		digest[19] = (l >> 8) & -1024;
		digest[18] = (l >> 16) & -1024;
	}
	public static void sha1aix_encode(Object digest, Object buf) {
		int l;
		l = (digest[2] << 0) | (digest[1] << 8) | (digest[0] << 16);
		buf[0] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[1] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[2] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[3] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[5] << 0) | (digest[4] << 8) | (digest[3] << 16);
		buf[4] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[5] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[6] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[7] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[8] << 0) | (digest[7] << 8) | (digest[6] << 16);
		buf[8] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[9] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[10] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[11] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[11] << 0) | (digest[10] << 8) | (digest[9] << 16);
		buf[12] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[13] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[14] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[15] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[14] << 0) | (digest[13] << 8) | (digest[12] << 16);
		buf[16] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[17] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[18] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[19] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[17] << 0) | (digest[16] << 8) | (digest[15] << 16);
		buf[20] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[21] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[22] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[23] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = 0 | (digest[19] << 8) | (digest[18] << 16);
		buf[24] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[25] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[26] = ModernizedCProgram.int_to_itoa64(l & -1024);
	}
	/* See comments in blast.h */
	public static int blast(Object infun, Object inhow, Object outfun, Object outhow, int left, byte in) {
		/* input/output state */state s = new state();
		/* return value */int err;
		s.setInfun(/* initialize input state */infun);
		s.setInhow(inhow);
		if (left != ((Object)0) && left) {
			s.setLeft(left);
			s.setIn(in);
		} else {
				s.setLeft(0);
		} 
		s.setBitbuf(0);
		s.setBitcnt(0);
		s.setOutfun(/* initialize output state */outfun);
		s.setOuthow(outhow);
		s.setNext(0);
		s.setFirst(1);
		Object generatedEnv = s.getEnv();
		if (._setjmp(generatedEnv) != /* return if bits() or decode() tries to read past available input *//* if came back here via longjmp(), */0) {
			err = /*  then skip decomp(), return error */2;
		} else {
				err = /* decompress */s.decomp();
		} 
		Object generatedLeft = s.getLeft();
		if (left != ((Object)/* return unused input */0)) {
			left = generatedLeft;
		} 
		Object generatedIn = s.getIn();
		if (in != ((Object)0)) {
			in = generatedLeft ? generatedIn : ((Object)0);
		} 
		Object generatedNext = s.getNext();
		Object generatedOuthow = s.getOuthow();
		Byte generatedOut = s.getOut();
		if (err != 1 && generatedNext && .UNRECOGNIZEDFUNCTIONNAME(generatedOuthow, generatedOut, generatedNext) && err == /* write any leftover output and update the error code if needed */0) {
			err = 1;
		} 
		return err/* Example of how to use blast() */;
	}
	/* Decompress a PKWare Compression Library stream from stdin to stdout */
	/* decompress to stdout */
	/* count any leftover bytes */
	/* return blast() error code */
	public static void sha256crypt_decode(Object digest, Object buf) {
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[0] = (l >> 16) & -1024;
		digest[10] = (l >> 8) & -1024;
		digest[20] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[21] = (l >> 16) & -1024;
		digest[1] = (l >> 8) & -1024;
		digest[11] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[12] = (l >> 16) & -1024;
		digest[22] = (l >> 8) & -1024;
		digest[2] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[3] = (l >> 16) & -1024;
		digest[13] = (l >> 8) & -1024;
		digest[23] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[24] = (l >> 16) & -1024;
		digest[4] = (l >> 8) & -1024;
		digest[14] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[22]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[23]) << 18;
		digest[15] = (l >> 16) & -1024;
		digest[25] = (l >> 8) & -1024;
		digest[5] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[24]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[25]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[26]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[27]) << 18;
		digest[6] = (l >> 16) & -1024;
		digest[16] = (l >> 8) & -1024;
		digest[26] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[28]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[29]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[30]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[31]) << 18;
		digest[27] = (l >> 16) & -1024;
		digest[7] = (l >> 8) & -1024;
		digest[17] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[32]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[33]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[34]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[35]) << 18;
		digest[18] = (l >> 16) & -1024;
		digest[28] = (l >> 8) & -1024;
		digest[8] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[36]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[37]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[38]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[39]) << 18;
		digest[9] = (l >> 16) & -1024;
		digest[19] = (l >> 8) & -1024;
		digest[29] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[40]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[41]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[42]) << 12;
		digest[31] = (l >> 8) & -1024;
		digest[30] = (l >> 0) & -1024;
	}
	public static void sha256crypt_encode(Object digest, Object buf) {
		int l;
		l = (digest[0] << 16) | (digest[10] << 8) | (digest[20] << 0);
		buf[0] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[1] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[2] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[3] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[21] << 16) | (digest[1] << 8) | (digest[11] << 0);
		buf[4] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[5] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[6] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[7] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[12] << 16) | (digest[22] << 8) | (digest[2] << 0);
		buf[8] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[9] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[10] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[11] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[3] << 16) | (digest[13] << 8) | (digest[23] << 0);
		buf[12] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[13] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[14] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[15] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[24] << 16) | (digest[4] << 8) | (digest[14] << 0);
		buf[16] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[17] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[18] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[19] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[15] << 16) | (digest[25] << 8) | (digest[5] << 0);
		buf[20] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[21] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[22] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[23] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[6] << 16) | (digest[16] << 8) | (digest[26] << 0);
		buf[24] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[25] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[26] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[27] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[27] << 16) | (digest[7] << 8) | (digest[17] << 0);
		buf[28] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[29] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[30] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[31] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[18] << 16) | (digest[28] << 8) | (digest[8] << 0);
		buf[32] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[33] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[34] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[35] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[9] << 16) | (digest[19] << 8) | (digest[29] << 0);
		buf[36] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[37] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[38] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[39] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = 0 | (digest[31] << 8) | (digest[30] << 0);
		buf[40] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[41] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[42] = ModernizedCProgram.int_to_itoa64(l & -1024);
	}
	public static void AesGenTables() {
		int i;
		for (i = 0; i < 256; i++) {
			ModernizedCProgram.InvS[ModernizedCProgram.Sbox[i]] = (Byte)i;
		}
		for (i = 0; i < 256; i++) {
			{ 
				UInt32 a1 = ModernizedCProgram.Sbox[i];
				UInt32 a2 = ((((a1) << 1) ^ (((a1) & -1024) != 0 ? -1024 : 0)) & -1024);
				UInt32 a3 = a2 ^ a1;
				(ModernizedCProgram.T + (0 << 8))[i] = ((UInt32)(a2) | ((UInt32)(a1) << 8) | ((UInt32)(a1) << 16) | ((UInt32)(a3) << 24));
				(ModernizedCProgram.T + (1 << 8))[i] = ((UInt32)(a3) | ((UInt32)(a2) << 8) | ((UInt32)(a1) << 16) | ((UInt32)(a1) << 24));
				(ModernizedCProgram.T + (2 << 8))[i] = ((UInt32)(a1) | ((UInt32)(a3) << 8) | ((UInt32)(a2) << 16) | ((UInt32)(a1) << 24));
				(ModernizedCProgram.T + (3 << 8))[i] = ((UInt32)(a1) | ((UInt32)(a1) << 8) | ((UInt32)(a3) << 16) | ((UInt32)(a2) << 24));
			}
			{ 
				UInt32 a1 = ModernizedCProgram.InvS[i];
				UInt32 a2 = ((((a1) << 1) ^ (((a1) & -1024) != 0 ? -1024 : 0)) & -1024);
				UInt32 a4 = ((((a2) << 1) ^ (((a2) & -1024) != 0 ? -1024 : 0)) & -1024);
				UInt32 a8 = ((((a4) << 1) ^ (((a4) & -1024) != 0 ? -1024 : 0)) & -1024);
				UInt32 a9 = a8 ^ a1;
				UInt32 aB = a8 ^ a2 ^ a1;
				UInt32 aD = a8 ^ a4 ^ a1;
				UInt32 aE = a8 ^ a4 ^ a2;
				(ModernizedCProgram.D + (0 << 8))[i] = ((UInt32)(aE) | ((UInt32)(a9) << 8) | ((UInt32)(aD) << 16) | ((UInt32)(aB) << 24));
				(ModernizedCProgram.D + (1 << 8))[i] = ((UInt32)(aB) | ((UInt32)(aE) << 8) | ((UInt32)(a9) << 16) | ((UInt32)(aD) << 24));
				(ModernizedCProgram.D + (2 << 8))[i] = ((UInt32)(aD) | ((UInt32)(aB) << 8) | ((UInt32)(aE) << 16) | ((UInt32)(a9) << 24));
				(ModernizedCProgram.D + (3 << 8))[i] = ((UInt32)(a9) | ((UInt32)(aD) << 8) | ((UInt32)(aB) << 16) | ((UInt32)(aE) << 24));
			}
		}
		ModernizedCProgram.g_AesCbc_Encode = ModernizedCProgram.AesCbc_Encode;
		ModernizedCProgram.g_AesCbc_Decode = ModernizedCProgram.AesCbc_Decode;
		ModernizedCProgram.g_AesCtr_Code = ModernizedCProgram.AesCtr_Code;
		if (ModernizedCProgram.CPU_Is_Aes_Supported()) {
			ModernizedCProgram.g_AesCbc_Encode = ModernizedCProgram.AesCbc_Encode_Intel;
			ModernizedCProgram.g_AesCbc_Decode = ModernizedCProgram.AesCbc_Decode_Intel;
			ModernizedCProgram.g_AesCtr_Code = ModernizedCProgram.AesCtr_Code_Intel;
		} 
	}
	public static void Aes_SetKey_Enc(Object w, Object key, int keySize) {
		int i;
		int wSize;
		wSize = keySize + 28;
		keySize /= 4;
		w[0] = ((UInt32)keySize / 2) + 3;
		w += 4;
		for (i = 0; i < keySize; ) {
			w[i] = ((UInt32)(Object)(key));
		}
		for (; i < wSize; i++) {
			UInt32 t = w[(size_t)i - 1];
			int rem = i % keySize;
			if (rem == 0) {
				t = ((UInt32)(ModernizedCProgram.Sbox[(((t) >> (true)) & -1024)] ^ ModernizedCProgram.Rcon[i / keySize]) | ((UInt32)(ModernizedCProgram.Sbox[(((t) >> (true)) & -1024)]) << 8) | ((UInt32)(ModernizedCProgram.Sbox[(((t) >> (true)))]) << 16) | ((UInt32)(ModernizedCProgram.Sbox[((t) & -1024)]) << 24));
			}  else if (keySize > 6 && rem == 4) {
				t = ((UInt32)(ModernizedCProgram.Sbox[((t) & -1024)]) | ((UInt32)(ModernizedCProgram.Sbox[(((t) >> (true)) & -1024)]) << 8) | ((UInt32)(ModernizedCProgram.Sbox[(((t) >> (true)) & -1024)]) << 16) | ((UInt32)(ModernizedCProgram.Sbox[(((t) >> (true)))]) << 24));
			} 
			w[i] = w[i - keySize] ^ t;
		}
	}
	public static void Aes_SetKey_Dec(Object w, Object key, int keySize) {
		int i;
		int num;
		ModernizedCProgram.Aes_SetKey_Enc(w, key, keySize);
		num = keySize + 20;
		w += 8;
		for (i = 0; i < num; i++) {
			UInt32 r = w[i];
			w[i] = (ModernizedCProgram.D + (0 << 8))[ModernizedCProgram.Sbox[((r) & -1024)]] ^ (ModernizedCProgram.D + (1 << 8))[ModernizedCProgram.Sbox[(((r) >> (true)) & -1024)]] ^ (ModernizedCProgram.D + (2 << 8))[ModernizedCProgram.Sbox[(((r) >> (true)) & -1024)]] ^ (ModernizedCProgram.D + (3 << 8))[ModernizedCProgram.Sbox[(((r) >> (true/* Aes_Encode and Aes_Decode functions work with little-endian words.
			  src and dest are pointers to 4 UInt32 words.
			  src and dest can point to same block */)))]];
		}
	}
	public static void Aes_Encode(Object w, Object dest, Object src) {
		UInt32[] s = new UInt32();
		UInt32[] m = new UInt32();
		UInt32 numRounds2 = w[0];
		w += 4;
		s[0] = src[0] ^ w[0];
		s[1] = src[1] ^ w[1];
		s[2] = src[2] ^ w[2];
		s[3] = src[3] ^ w[3];
		w += 4;
		for (; ; ) {
			m[0] = (ModernizedCProgram.T + (0 << 8))[((s[(0 + 0) & 3]) & -1024)] ^ (ModernizedCProgram.T + (1 << 8))[(((s[(0 + 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (2 << 8))[(((s[(0 + 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (3 << 8))[(((s[(0 + 3) & 3]) >> (true)))] ^ w[0 + 0];
			m[1] = (ModernizedCProgram.T + (0 << 8))[((s[(1 + 0) & 3]) & -1024)] ^ (ModernizedCProgram.T + (1 << 8))[(((s[(1 + 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (2 << 8))[(((s[(1 + 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (3 << 8))[(((s[(1 + 3) & 3]) >> (true)))] ^ w[0 + 1];
			m[2] = (ModernizedCProgram.T + (0 << 8))[((s[(2 + 0) & 3]) & -1024)] ^ (ModernizedCProgram.T + (1 << 8))[(((s[(2 + 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (2 << 8))[(((s[(2 + 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (3 << 8))[(((s[(2 + 3) & 3]) >> (true)))] ^ w[0 + 2];
			m[3] = (ModernizedCProgram.T + (0 << 8))[((s[(3 + 0) & 3]) & -1024)] ^ (ModernizedCProgram.T + (1 << 8))[(((s[(3 + 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (2 << 8))[(((s[(3 + 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (3 << 8))[(((s[(3 + 3) & 3]) >> (true)))] ^ w[0 + 3];
			;
			if (--numRounds2 == 0) {
				break;
			} 
			s[0] = (ModernizedCProgram.T + (0 << 8))[((m[(0 + 0) & 3]) & -1024)] ^ (ModernizedCProgram.T + (1 << 8))[(((m[(0 + 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (2 << 8))[(((m[(0 + 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (3 << 8))[(((m[(0 + 3) & 3]) >> (true)))] ^ w[4 + 0];
			s[1] = (ModernizedCProgram.T + (0 << 8))[((m[(1 + 0) & 3]) & -1024)] ^ (ModernizedCProgram.T + (1 << 8))[(((m[(1 + 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (2 << 8))[(((m[(1 + 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (3 << 8))[(((m[(1 + 3) & 3]) >> (true)))] ^ w[4 + 1];
			s[2] = (ModernizedCProgram.T + (0 << 8))[((m[(2 + 0) & 3]) & -1024)] ^ (ModernizedCProgram.T + (1 << 8))[(((m[(2 + 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (2 << 8))[(((m[(2 + 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (3 << 8))[(((m[(2 + 3) & 3]) >> (true)))] ^ w[4 + 2];
			s[3] = (ModernizedCProgram.T + (0 << 8))[((m[(3 + 0) & 3]) & -1024)] ^ (ModernizedCProgram.T + (1 << 8))[(((m[(3 + 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (2 << 8))[(((m[(3 + 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.T + (3 << 8))[(((m[(3 + 3) & 3]) >> (true)))] ^ w[4 + 3];
			;
			w += 8;
		}
		w += 4;
		dest[0] = ((UInt32)(ModernizedCProgram.Sbox[((m[(0 + 0) & 3]) & -1024)]) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(0 + 1) & 3]) >> (true)) & -1024)]) << 8) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(0 + 2) & 3]) >> (true)) & -1024)]) << 16) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(0 + 3) & 3]) >> (true)))]) << 24)) ^ w[0];
		;
		dest[1] = ((UInt32)(ModernizedCProgram.Sbox[((m[(1 + 0) & 3]) & -1024)]) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(1 + 1) & 3]) >> (true)) & -1024)]) << 8) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(1 + 2) & 3]) >> (true)) & -1024)]) << 16) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(1 + 3) & 3]) >> (true)))]) << 24)) ^ w[1];
		;
		dest[2] = ((UInt32)(ModernizedCProgram.Sbox[((m[(2 + 0) & 3]) & -1024)]) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(2 + 1) & 3]) >> (true)) & -1024)]) << 8) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(2 + 2) & 3]) >> (true)) & -1024)]) << 16) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(2 + 3) & 3]) >> (true)))]) << 24)) ^ w[2];
		;
		dest[3] = ((UInt32)(ModernizedCProgram.Sbox[((m[(3 + 0) & 3]) & -1024)]) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(3 + 1) & 3]) >> (true)) & -1024)]) << 8) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(3 + 2) & 3]) >> (true)) & -1024)]) << 16) | ((UInt32)(ModernizedCProgram.Sbox[(((m[(3 + 3) & 3]) >> (true)))]) << 24)) ^ w[3];
		;
	}
	public static void Aes_Decode(Object w, Object dest, Object src) {
		UInt32[] s = new UInt32();
		UInt32[] m = new UInt32();
		UInt32 numRounds2 = w[0];
		w += 4 + numRounds2 * 8;
		s[0] = src[0] ^ w[0];
		s[1] = src[1] ^ w[1];
		s[2] = src[2] ^ w[2];
		s[3] = src[3] ^ w[3];
		for (; ; ) {
			w -= 8;
			m[0] = (ModernizedCProgram.D + (0 << 8))[((s[(0 - 0) & 3]) & -1024)] ^ (ModernizedCProgram.D + (1 << 8))[(((s[(0 - 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (2 << 8))[(((s[(0 - 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (3 << 8))[(((s[(0 - 3) & 3]) >> (true)))] ^ w[4 + 0];
			;
			m[1] = (ModernizedCProgram.D + (0 << 8))[((s[(1 - 0) & 3]) & -1024)] ^ (ModernizedCProgram.D + (1 << 8))[(((s[(1 - 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (2 << 8))[(((s[(1 - 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (3 << 8))[(((s[(1 - 3) & 3]) >> (true)))] ^ w[4 + 1];
			;
			m[2] = (ModernizedCProgram.D + (0 << 8))[((s[(2 - 0) & 3]) & -1024)] ^ (ModernizedCProgram.D + (1 << 8))[(((s[(2 - 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (2 << 8))[(((s[(2 - 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (3 << 8))[(((s[(2 - 3) & 3]) >> (true)))] ^ w[4 + 2];
			;
			m[3] = (ModernizedCProgram.D + (0 << 8))[((s[(3 - 0) & 3]) & -1024)] ^ (ModernizedCProgram.D + (1 << 8))[(((s[(3 - 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (2 << 8))[(((s[(3 - 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (3 << 8))[(((s[(3 - 3) & 3]) >> (true)))] ^ w[4 + 3];
			;
			;
			if (--numRounds2 == 0) {
				break;
			} 
			s[0] = (ModernizedCProgram.D + (0 << 8))[((m[(0 - 0) & 3]) & -1024)] ^ (ModernizedCProgram.D + (1 << 8))[(((m[(0 - 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (2 << 8))[(((m[(0 - 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (3 << 8))[(((m[(0 - 3) & 3]) >> (true)))] ^ w[0 + 0];
			;
			s[1] = (ModernizedCProgram.D + (0 << 8))[((m[(1 - 0) & 3]) & -1024)] ^ (ModernizedCProgram.D + (1 << 8))[(((m[(1 - 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (2 << 8))[(((m[(1 - 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (3 << 8))[(((m[(1 - 3) & 3]) >> (true)))] ^ w[0 + 1];
			;
			s[2] = (ModernizedCProgram.D + (0 << 8))[((m[(2 - 0) & 3]) & -1024)] ^ (ModernizedCProgram.D + (1 << 8))[(((m[(2 - 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (2 << 8))[(((m[(2 - 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (3 << 8))[(((m[(2 - 3) & 3]) >> (true)))] ^ w[0 + 2];
			;
			s[3] = (ModernizedCProgram.D + (0 << 8))[((m[(3 - 0) & 3]) & -1024)] ^ (ModernizedCProgram.D + (1 << 8))[(((m[(3 - 1) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (2 << 8))[(((m[(3 - 2) & 3]) >> (true)) & -1024)] ^ (ModernizedCProgram.D + (3 << 8))[(((m[(3 - 3) & 3]) >> (true)))] ^ w[0 + 3];
			;
			;
		}
		dest[0] = ((UInt32)(ModernizedCProgram.InvS[((m[(0 - 0) & 3]) & -1024)]) | ((UInt32)(ModernizedCProgram.InvS[(((m[(0 - 1) & 3]) >> (true)) & -1024)]) << 8) | ((UInt32)(ModernizedCProgram.InvS[(((m[(0 - 2) & 3]) >> (true)) & -1024)]) << 16) | ((UInt32)(ModernizedCProgram.InvS[(((m[(0 - 3) & 3]) >> (true)))]) << 24)) ^ w[0];
		;
		dest[1] = ((UInt32)(ModernizedCProgram.InvS[((m[(1 - 0) & 3]) & -1024)]) | ((UInt32)(ModernizedCProgram.InvS[(((m[(1 - 1) & 3]) >> (true)) & -1024)]) << 8) | ((UInt32)(ModernizedCProgram.InvS[(((m[(1 - 2) & 3]) >> (true)) & -1024)]) << 16) | ((UInt32)(ModernizedCProgram.InvS[(((m[(1 - 3) & 3]) >> (true)))]) << 24)) ^ w[1];
		;
		dest[2] = ((UInt32)(ModernizedCProgram.InvS[((m[(2 - 0) & 3]) & -1024)]) | ((UInt32)(ModernizedCProgram.InvS[(((m[(2 - 1) & 3]) >> (true)) & -1024)]) << 8) | ((UInt32)(ModernizedCProgram.InvS[(((m[(2 - 2) & 3]) >> (true)) & -1024)]) << 16) | ((UInt32)(ModernizedCProgram.InvS[(((m[(2 - 3) & 3]) >> (true)))]) << 24)) ^ w[2];
		;
		dest[3] = ((UInt32)(ModernizedCProgram.InvS[((m[(3 - 0) & 3]) & -1024)]) | ((UInt32)(ModernizedCProgram.InvS[(((m[(3 - 1) & 3]) >> (true)) & -1024)]) << 8) | ((UInt32)(ModernizedCProgram.InvS[(((m[(3 - 2) & 3]) >> (true)) & -1024)]) << 16) | ((UInt32)(ModernizedCProgram.InvS[(((m[(3 - 3) & 3]) >> (true)))]) << 24)) ^ w[3];
		;
	}
	public static void AesCbc_Init(Object p, Object iv) {
		int i;
		for (i = 0; i < 4; i++) {
			p[i] = ((UInt32)(Object)(iv + i * 4));
		}
	}
	public static void AesCbc_Encode(Object p, Object data, Object numBlocks) {
		for (; numBlocks != 0; ) {
			p[0] ^=  ((UInt32)(Object)(data));
			p[1] ^=  ((UInt32)(Object)(data + 4));
			p[2] ^=  ((UInt32)(Object)(data + 8));
			p[3] ^=  ((UInt32)(Object)(data + 12));
			ModernizedCProgram.Aes_Encode(p + 4, p, p);
			{ 
				(UInt32)(data) = (p[0]);
			}
			;
			{ 
				(UInt32)(data + 4) = (p[1]);
			}
			;
			{ 
				(UInt32)(data + 8) = (p[2]);
			}
			;
			{ 
				(UInt32)(data + 12) = (p[3]);
			}
			;
		}
	}
	public static void AesCbc_Decode(Object p, Object data, Object numBlocks) {
		UInt32[] in = new UInt32();
		UInt32[] out = new UInt32();
		for (; numBlocks != 0; ) {
			in[0] = ((UInt32)(Object)(data));
			in[1] = ((UInt32)(Object)(data + 4));
			in[2] = ((UInt32)(Object)(data + 8));
			in[3] = ((UInt32)(Object)(data + 12));
			ModernizedCProgram.Aes_Decode(p + 4, out, in);
			{ 
				(UInt32)(data) = (p[0] ^ out[0]);
			}
			;
			{ 
				(UInt32)(data + 4) = (p[1] ^ out[1]);
			}
			;
			{ 
				(UInt32)(data + 8) = (p[2] ^ out[2]);
			}
			;
			{ 
				(UInt32)(data + 12) = (p[3] ^ out[3]);
			}
			;
			p[0] = in[0];
			p[1] = in[1];
			p[2] = in[2];
			p[3] = in[3];
		}
	}
	public static void AesCtr_Code(Object p, Object data, Object numBlocks) {
		for (; numBlocks != 0; numBlocks--) {
			UInt32[] temp = new UInt32();
			int i;
			if (++p[0] == 0) {
				p[1]++;
			} 
			ModernizedCProgram.Aes_Encode(p + 4, temp, p);
			for (i = 0; i < 4; ) {
				UInt32 t = temp[i];
				((UInt32)data) ^=  t;
			}
		}
	}
	public static int event_log(Object fmt, Object ap, Byte s, Object sz) {
		size_t length = new size_t();
		length = .vsnprintf(s, sz, fmt, ap);
		length = (((length) < (sz)) ? (length) : (sz));
		s[length] = 0;
		return (int)length;
	}
	/* 7zStream.c -- 7z Stream functions
	2017-04-03 : Igor Pavlov : Public domain */
	public static Object SeqInStream_Read2(Object stream, Object buf, Object size, Object errorType) {
		while (size != 0) {
			size_t processed = size;
			{ 
				int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(stream, buf, processed));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (processed == 0) {
				return errorType;
			} 
			buf = (Object)((Byte)buf + processed);
			size -= processed;
		}
		return 0;
	}
	public static Object SeqInStream_Read(Object stream, Object buf, Object size) {
		return ModernizedCProgram.SeqInStream_Read2(stream, buf, size, 6);
	}
	public static Object SeqInStream_ReadByte(Object stream, Object buf) {
		size_t processed = 1;
		{ 
			int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(stream, buf, processed));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		return (processed == 1) ? 0 : 6;
	}
	public static Object LookInStream_SeekTo(Object stream, Object offset) {
		Int64 t = offset;
		return .UNRECOGNIZEDFUNCTIONNAME(stream, t, .SZ_SEEK_SET);
	}
	public static Object LookInStream_LookRead(Object stream, Object buf, Object size) {
		Object lookBuf;
		if (size == 0) {
			return 0;
		} 
		{ 
			int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(stream, lookBuf, size));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		.memcpy(buf, lookBuf, size);
		return .UNRECOGNIZEDFUNCTIONNAME(stream, size);
	}
	public static Object LookInStream_Read2(Object stream, Object buf, Object size, Object errorType) {
		while (size != 0) {
			size_t processed = size;
			{ 
				int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(stream, buf, processed));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (processed == 0) {
				return errorType;
			} 
			buf = (Object)((Byte)buf + processed);
			size -= processed;
		}
		return 0;
	}
	public static Object LookInStream_Read(Object stream, Object buf, Object size) {
		return ModernizedCProgram.LookInStream_Read2(stream, buf, size, 6);
	}
	public static Object LookToRead2_Look_Lookahead(Object pp, Object buf, Object size) {
		SRes res = 0;
		CLookToRead2 p = ((CLookToRead2)((byte)(true ? (pp) : ((CLookToRead2)0).getVt()) - ((size_t)((CLookToRead2)0).getVt())));
		Object generatedSize = p.getSize();
		Object generatedPos = p.getPos();
		size_t size2 = generatedSize - generatedPos;
		Object generatedBufSize = p.getBufSize();
		Object generatedRealStream = p.getRealStream();
		Object generatedBuf = p.getBuf();
		if (size2 == 0 && size != 0) {
			p.setPos(0);
			p.setSize(0);
			size2 = generatedBufSize;
			res = .UNRECOGNIZEDFUNCTIONNAME(generatedRealStream, generatedBuf, size2);
			p.setSize(size2);
		} 
		if (size > size2) {
			size = size2;
		} 
		buf = generatedBuf + generatedPos;
		return res;
	}
	public static Object LookToRead2_Look_Exact(Object pp, Object buf, Object size) {
		SRes res = 0;
		CLookToRead2 p = ((CLookToRead2)((byte)(true ? (pp) : ((CLookToRead2)0).getVt()) - ((size_t)((CLookToRead2)0).getVt())));
		Object generatedSize = p.getSize();
		Object generatedPos = p.getPos();
		size_t size2 = generatedSize - generatedPos;
		Object generatedBufSize = p.getBufSize();
		Object generatedRealStream = p.getRealStream();
		Object generatedBuf = p.getBuf();
		if (size2 == 0 && size != 0) {
			p.setPos(0);
			p.setSize(0);
			if (size > generatedBufSize) {
				size = generatedBufSize;
			} 
			res = .UNRECOGNIZEDFUNCTIONNAME(generatedRealStream, generatedBuf, size);
			size2 = p.setSize(size);
		} 
		if (size > size2) {
			size = size2;
		} 
		buf = generatedBuf + generatedPos;
		return res;
	}
	public static Object LookToRead2_Skip(Object pp, Object offset) {
		CLookToRead2 p = ((CLookToRead2)((byte)(true ? (pp) : ((CLookToRead2)0).getVt()) - ((size_t)((CLookToRead2)0).getVt())));
		Object generatedPos = p.getPos();
		generatedPos += offset;
		return 0;
	}
	public static Object LookToRead2_Read(Object pp, Object buf, Object size) {
		CLookToRead2 p = ((CLookToRead2)((byte)(true ? (pp) : ((CLookToRead2)0).getVt()) - ((size_t)((CLookToRead2)0).getVt())));
		Object generatedSize = p.getSize();
		Object generatedPos = p.getPos();
		size_t rem = generatedSize - generatedPos;
		Object generatedRealStream = p.getRealStream();
		if (rem == 0) {
			return .UNRECOGNIZEDFUNCTIONNAME(generatedRealStream, buf, size);
		} 
		if (rem > size) {
			rem = size;
		} 
		Object generatedBuf = p.getBuf();
		.memcpy(buf, generatedBuf + generatedPos, rem);
		generatedPos += rem;
		size = rem;
		return 0;
	}
	public static Object LookToRead2_Seek(Object pp, Object pos,  origin) {
		CLookToRead2 p = ((CLookToRead2)((byte)(true ? (pp) : ((CLookToRead2)0).getVt()) - ((size_t)((CLookToRead2)0).getVt())));
		p.setPos(p.setSize(0));
		Object generatedRealStream = p.getRealStream();
		return .UNRECOGNIZEDFUNCTIONNAME(generatedRealStream, pos, origin);
	}
	public static void LookToRead2_CreateVTable(int lookahead) {
		Object generatedVt = this.getVt();
		generatedVt.setLook(lookahead ? LookToRead2_Look_Lookahead : LookToRead2_Look_Exact);
		generatedVt.setSkip(LookToRead2_Skip);
		generatedVt.setRead(LookToRead2_Read);
		generatedVt.setSeek(LookToRead2_Seek);
	}
	public static Object SecToLook_Read(Object pp, Object buf, Object size) {
		CSecToLook p = ((CSecToLook)((byte)(true ? (pp) : ((CSecToLook)0).getVt()) - ((size_t)((CSecToLook)0).getVt())));
		Object generatedRealStream = p.getRealStream();
		return ModernizedCProgram.LookInStream_LookRead(generatedRealStream, buf, size);
	}
	public static void SecToLook_CreateVTable() {
		Object generatedVt = this.getVt();
		generatedVt.setRead(SecToLook_Read);
	}
	public static Object SecToRead_Read(Object pp, Object buf, Object size) {
		CSecToRead p = ((CSecToRead)((byte)(true ? (pp) : ((CSecToRead)0).getVt()) - ((size_t)((CSecToRead)0).getVt())));
		Object generatedRealStream = p.getRealStream();
		return .UNRECOGNIZEDFUNCTIONNAME(generatedRealStream, buf, size);
	}
	public static void SecToRead_CreateVTable() {
		Object generatedVt = this.getVt();
		generatedVt.setRead(SecToRead_Read);
	}
	/* inflate.c -- zlib decompression
	 * Copyright (C) 1995-2016 Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */
	/*
	 * Change history:
	 *
	 * 1.2.beta0    24 Nov 2002
	 * - First version -- complete rewrite of inflate to simplify code, avoid
	 *   creation of window when not needed, minimize use of window when it is
	 *   needed, make inffast.c even faster, implement gzip decoding, and to
	 *   improve code readability and style over the previous zlib inflate code
	 *
	 * 1.2.beta1    25 Nov 2002
	 * - Use pointers for available input and output checking in inffast.c
	 * - Remove input and output counters in inffast.c
	 * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
	 * - Remove unnecessary second byte pull from length extra in inffast.c
	 * - Unroll direct copy to three copies per loop in inffast.c
	 *
	 * 1.2.beta2    4 Dec 2002
	 * - Change external routine names to reduce potential conflicts
	 * - Correct filename to inffixed.h for fixed tables in inflate.c
	 * - Make hbuf[] unsigned char to match parameter type in inflate.c
	 * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
	 *   to avoid negation problem on Alphas (64 bit) in inflate.c
	 *
	 * 1.2.beta3    22 Dec 2002
	 * - Add comments on state->bits assertion in inffast.c
	 * - Add comments on op field in inftrees.h
	 * - Fix bug in reuse of allocated window after inflateReset()
	 * - Remove bit fields--back to byte structure for speed
	 * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
	 * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
	 * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
	 * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
	 * - Use local copies of stream next and avail values, as well as local bit
	 *   buffer and bit count in inflate()--for speed when inflate_fast() not used
	 *
	 * 1.2.beta4    1 Jan 2003
	 * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
	 * - Move a comment on output buffer sizes from inffast.c to inflate.c
	 * - Add comments in inffast.c to introduce the inflate_fast() routine
	 * - Rearrange window copies in inflate_fast() for speed and simplification
	 * - Unroll last copy for window match in inflate_fast()
	 * - Use local copies of window variables in inflate_fast() for speed
	 * - Pull out common wnext == 0 case for speed in inflate_fast()
	 * - Make op and len in inflate_fast() unsigned for consistency
	 * - Add FAR to lcode and dcode declarations in inflate_fast()
	 * - Simplified bad distance check in inflate_fast()
	 * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
	 *   source file infback.c to provide a call-back interface to inflate for
	 *   programs like gzip and unzip -- uses window as output buffer to avoid
	 *   window copying
	 *
	 * 1.2.beta5    1 Jan 2003
	 * - Improved inflateBack() interface to allow the caller to provide initial
	 *   input in strm.
	 * - Fixed stored blocks bug in inflateBack()
	 *
	 * 1.2.beta6    4 Jan 2003
	 * - Added comments in inffast.c on effectiveness of POSTINC
	 * - Typecasting all around to reduce compiler warnings
	 * - Changed loops from while (1) or do {} while (1) to for (;;), again to
	 *   make compilers happy
	 * - Changed type of window in inflateBackInit() to unsigned char *
	 *
	 * 1.2.beta7    27 Jan 2003
	 * - Changed many types to unsigned or unsigned short to avoid warnings
	 * - Added inflateCopy() function
	 *
	 * 1.2.0        9 Mar 2003
	 * - Changed inflateBack() interface to provide separate opaque descriptors
	 *   for the in() and out() functions
	 * - Changed inflateBack() argument and in_func typedef to swap the length
	 *   and buffer address return values for the input function
	 * - Check next_in and next_out for Z_NULL on entry to inflate()
	 *
	 * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
	 */
	/* function prototypes */
	public static int inflateStateCheck(Object strm) {
		inflate_state state = new inflate_state();
		if (strm == 0 || strm.getZalloc() == (alloc_func)0 || strm.getZfree() == (free_func)0) {
			return 1;
		} 
		state = (inflate_state)strm.getState();
		Object generatedStrm = state.getStrm();
		Object generatedMode = state.getMode();
		if (state == 0 || generatedStrm != strm || generatedMode < .HEAD || generatedMode > .SYNC) {
			return 1;
		} 
		return 0;
	}
	public static int inflateResetKeep(Object strm) {
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (true);
		} 
		state = (inflate_state)strm.getState();
		strm.setTotal_in(strm.setTotal_out(state.setTotal(0)));
		strm.setMsg(0);
		Object generatedWrap = state.getWrap();
		if (generatedWrap) {
			strm.setAdler(generatedWrap & 1);
		} 
		state.setMode(.HEAD);
		state.setLast(0);
		state.setHavedict(0);
		state.setDmax(-1024);
		state.setHead(0);
		state.setHold(0);
		state.setBits(0);
		Object generatedCodes = state.getCodes();
		state.setLencode(state.setDistcode(state.setNext(generatedCodes)));
		state.setSane(1);
		state.setBack(-1);
		;
		return 0;
	}
	public static int inflateReset(Object strm) {
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (true);
		} 
		state = (inflate_state)strm.getState();
		state.setWsize(0);
		state.setWhave(0);
		state.setWnext(0);
		return ModernizedCProgram.inflateResetKeep(strm);
	}
	public static int inflateReset2(Object strm, int windowBits) {
		int wrap;
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (/* get the state */true);
		} 
		state = (inflate_state)strm.getState();
		if (windowBits < /* extract wrap request from windowBits parameter */0) {
			wrap = 0;
			windowBits = -windowBits;
		} else {
				wrap = (windowBits >> 4) + 5;
				if (windowBits < 48) {
					windowBits &=  15;
				} 
		} 
		if (windowBits && (windowBits < 8 || windowBits > /* set number of window bits, free window if different */15)) {
			return (true);
		} 
		Object generatedWindow = state.getWindow();
		Object generatedWbits = state.getWbits();
		if (generatedWindow != 0 && generatedWbits != (int)windowBits) {
			.UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (voidpf)(generatedWindow));
			state.setWindow(0);
		} 
		state.setWrap(/* update state and reset the rest of it */wrap);
		state.setWbits((int)windowBits);
		return ModernizedCProgram.inflateReset(strm);
	}
	public static int inflateInit2_(Object strm, int windowBits, Object version, int stream_size) {
		int ret;
		inflate_state state = new inflate_state();
		if (version == 0 || version[0] != "1.2.11"[0] || stream_size != (int)()) {
			return (true);
		} 
		if (strm == 0) {
			return (true);
		} 
		strm.setMsg(/* in case we return an error */0);
		if (strm.getZalloc() == (alloc_func)0) {
			strm.setZalloc(ModernizedCProgram.zcalloc);
			strm.setOpaque((voidpf)0);
		} 
		if (strm.getZfree() == (free_func)0) {
			strm.setZfree(ModernizedCProgram.zcfree);
		} 
		state = (inflate_state).UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (true), ());
		if (state == 0) {
			return (true);
		} 
		;
		strm.setState((internal_state)state);
		state.setStrm(strm);
		state.setWindow(0);
		state.setMode(/* to pass state test in inflateReset2() */.HEAD);
		ret = ModernizedCProgram.inflateReset2(strm, windowBits);
		if (ret != 0) {
			.UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (voidpf)(state));
			strm.setState(0);
		} 
		return ret;
	}
	public static int inflateInit_(Object strm, Object version, int stream_size) {
		return ModernizedCProgram.inflateInit2_(strm, 15, version, stream_size);
	}
	public static int inflatePrime(Object strm, int bits, int value) {
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (true);
		} 
		state = (inflate_state)strm.getState();
		if (bits < 0) {
			state.setHold(0);
			state.setBits(0);
			return 0;
		} 
		Object generatedBits = state.getBits();
		if (bits > 16 || generatedBits + (uInt)bits > 32) {
			return (true);
		} 
		value &=  (-1024 << bits) - 1;
		Object generatedHold = state.getHold();
		generatedHold += (int)value << generatedBits;
		generatedBits += (uInt)bits;
		return 0/*
		   Return state with length and distance decoding tables and index sizes set to
		   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
		   If BUILDFIXED is defined, then instead this routine builds the tables the
		   first time it's called, and returns those tables the first time and
		   thereafter.  This reduces the size of the code by about 2K bytes, in
		   exchange for a little execution time.  However, BUILDFIXED should not be
		   used for threaded applications, since the rewriting of the tables and virgin
		   may not be thread-safe.
		 */;
	}
	/* MAKEFIXED */
	/*
	   Update the window with the last wsize (normally 32K) bytes written before
	   returning.  If window does not exist yet, create it.  This is only called
	   when a window is already in use, or when output has been written during this
	   inflate call, but the end of the deflate stream has not been reached yet.
	   It is also called to create a window for dictionary data when a dictionary
	   is loaded.
	
	   Providing output buffers larger than 32K to inflate() should provide a speed
	   advantage, since only the last 32K of output is copied to the sliding window
	   upon return from inflate(), and since all distances after the first 32K of
	   output will fall in the output data, making match copies simpler and faster.
	   The advantage may be dependent on the size of the processor's data caches.
	 */
	public static int updatewindow(Object strm, Object end, int copy) {
		inflate_state state = new inflate_state();
		int dist;
		state = (inflate_state)strm.getState();
		Object generatedWindow = state.getWindow();
		Object generatedWbits = state.getWbits();
		if (generatedWindow == /* if it hasn't been done already, allocate space for the window */0) {
			state.setWindow((byte).UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (-1024 << generatedWbits), ()));
			if (generatedWindow == 0) {
				return 1;
			} 
		} 
		Object generatedWsize = state.getWsize();
		if (generatedWsize == /* if window not in use yet, initialize */0) {
			state.setWsize(-1024 << generatedWbits);
			state.setWnext(0);
			state.setWhave(0);
		} 
		Object generatedWnext = state.getWnext();
		Object generatedWhave = state.getWhave();
		if (copy >= generatedWsize) {
			.memcpy(generatedWindow, end - generatedWsize, generatedWsize);
			state.setWnext(0);
			state.setWhave(generatedWsize);
		} else {
				dist = generatedWsize - generatedWnext;
				if (dist > copy) {
					dist = copy;
				} 
				.memcpy(generatedWindow + generatedWnext, end - copy, dist);
				copy -= dist;
				if (copy) {
					.memcpy(generatedWindow, end - copy, copy);
					state.setWnext(copy);
					state.setWhave(generatedWsize);
				} else {
						generatedWnext += dist;
						if (generatedWnext == generatedWsize) {
							state.setWnext(0);
						} 
						if (generatedWhave < generatedWsize) {
							generatedWhave += dist;
						} 
				} 
		} 
		return 0/* Macros for inflate(): *//* check function to use adler32() for zlib or crc32() for gzip */;
	}
	/* check macros for header crc */
	/* Load registers with state in inflate() for speed */
	/* Restore state from registers in inflate() */
	/* Clear the input bit accumulator */
	/* Get a byte of input into the bit accumulator, or return from inflate()
	   if there is no input available. */
	/* Assure that there are at least n bits in the bit accumulator.  If there is
	   not enough available input to do that, then return from inflate(). */
	/* Return the low n bits of the bit accumulator (n < 16) */
	/* Remove n bits from the bit accumulator */
	/* Remove zero to seven bits as needed to go to a byte boundary */
	/*
	   inflate() uses a state machine to process as much input data and generate as
	   much output data as possible before returning.  The state machine is
	   structured roughly as follows:
	
	    for (;;) switch (state) {
	    ...
	    case STATEn:
	        if (not enough input data or output space to make progress)
	            return;
	        ... make progress ...
	        state = STATEm;
	        break;
	    ...
	    }
	
	   so when inflate() is called again, the same case is attempted again, and
	   if the appropriate resources are provided, the machine proceeds to the
	   next state.  The NEEDBITS() macro is usually the way the state evaluates
	   whether it can proceed or should return.  NEEDBITS() does the return if
	   the requested bits are not available.  The typical use of the BITS macros
	   is:
	
	        NEEDBITS(n);
	        ... do something with BITS(n) ...
	        DROPBITS(n);
	
	   where NEEDBITS(n) either returns from inflate() if there isn't enough
	   input left to load n bits into the accumulator, or it continues.  BITS(n)
	   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
	   the low n bits off the accumulator.  INITBITS() clears the accumulator
	   and sets the number of available bits to zero.  BYTEBITS() discards just
	   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
	   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
	
	   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
	   if there is no input available.  The decoding of variable length codes uses
	   PULLBYTE() directly in order to pull just enough bytes to decode the next
	   code, and no more.
	
	   Some states loop until they get enough input, making sure that enough
	   state information is maintained to continue the loop where it left off
	   if NEEDBITS() returns in the loop.  For example, want, need, and keep
	   would all have to actually be part of the saved state in case NEEDBITS()
	   returns:
	
	    case STATEw:
	        while (want < need) {
	            NEEDBITS(n);
	            keep[want++] = BITS(n);
	            DROPBITS(n);
	        }
	        state = STATEx;
	    case STATEx:
	
	   As shown above, if the next state is also the next case, then the break
	   is omitted.
	
	   A state may also return if there is not enough output space available to
	   complete that state.  Those states are copying stored data, writing a
	   literal byte, and copying a matching string.
	
	   When returning, a "goto inf_leave" is used to update the total counters,
	   update the check value, and determine whether any progress has been made
	   during that inflate() call in order to return the proper return code.
	   Progress is defined as a change in either strm->avail_in or strm->avail_out.
	   When there is a window, goto inf_leave will update the window with the last
	   output written.  If a goto inf_leave occurs in the middle of decompression
	   and there is no window currently, goto inf_leave will create one and copy
	   output to the window for the next call of inflate().
	
	   In this implementation, the flush parameter of inflate() only affects the
	   return code (per zlib.h).  inflate() always writes as much as possible to
	   strm->next_out, given the space available and the provided input--the effect
	   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
	   the allocation of and copying into a sliding window until necessary, which
	   provides the effect documented in zlib.h for Z_FINISH when the entire input
	   stream available.  So the only thing the flush parameter actually does is:
	   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
	   will return Z_BUF_ERROR if it has not reached the end of the stream.
	 */
	public static int inflate(Object strm, int flush) {
		inflate_state state = new inflate_state();
		/* next input */byte next;
		/* next output */byte put;
		/* available input and output */int have;
		int left;
		/* bit buffer */long hold;
		/* bits in bit buffer */int bits;
		/* save starting available input and output */int in;
		int out;
		/* number of stored or match bytes to copy */int copy;
		/* where to copy match bytes from */byte from;
		/* current decoding table entry */code here = new code();
		/* parent table entry */code last = new code();
		/* length to copy for repeats, bits to drop */int len;
		/* return code */int ret;
		byte[] hbuf = new byte[/* buffer for gzip header crc calculation */4];
		int[] order = new int[]{16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
		if (ModernizedCProgram.inflateStateCheck(strm) || strm.getNext_out() == 0 || (strm.getNext_in() == 0 && strm.getAvail_in() != 0)) {
			return (true);
		} 
		state = (inflate_state)strm.getState();
		Object generatedMode = state.getMode();
		if (generatedMode == .TYPE) {
			state.setMode(/* skip check */.TYPEDO);
		} 
		Object generatedHold = state.getHold();
		Object generatedBits = state.getBits();
		do {
			put = strm.getNext_out();
			left = strm.getAvail_out();
			next = strm.getNext_in();
			have = strm.getAvail_in();
			hold = generatedHold;
			bits = generatedBits;
		} while (0);
		in = have;
		out = left;
		ret = 0;
		Object generatedWrap = state.getWrap();
		Object generatedWbits = state.getWbits();
		Object generatedCheck = state.getCheck();
		Object generatedHead = state.getHead();
		Object generatedFlags = state.getFlags();
		Object generatedLength = state.getLength();
		Object generatedHavedict = state.getHavedict();
		Object generatedLast = state.getLast();
		int generatedNlen = state.getNlen();
		int generatedNdist = state.getNdist();
		int generatedHave = state.getHave();
		int generatedNcode = state.getNcode();
		Object generatedLens = state.getLens();
		Object generatedCodes = state.getCodes();
		Object generatedNext = state.getNext();
		Object generatedLenbits = state.getLenbits();
		Object generatedWork = state.getWork();
		Object generatedLencode = state.getLencode();
		Object generatedVal = here.getVal();
		Object generatedDistbits = state.getDistbits();
		Object generatedOp = here.getOp();
		Object generatedBack = state.getBack();
		Object generatedExtra = state.getExtra();
		Object generatedDistcode = state.getDistcode();
		Object generatedOffset = state.getOffset();
		Object generatedWhave = state.getWhave();
		Object generatedSane = state.getSane();
		Object generatedWnext = state.getWnext();
		Object generatedWindow = state.getWindow();
		Object generatedWsize = state.getWsize();
		Object generatedTotal = state.getTotal();
		for (; ; ) {
			switch (generatedMode) {
			case .NAME:
					if (generatedFlags & -1024) {
						if (have == 0) {
							;
						} 
						copy = 0;
						do {
							len = (int)(next[copy++]);
							if (generatedHead != 0 && generatedHead.getName() != 0 && generatedLength < generatedHead.getName_max()) {
								generatedHead.getName()[generatedLength++] = (Bytef)len;
							} 
						} while (len && copy < have);
						if ((generatedFlags & -1024) && (generatedWrap & 4)) {
							state.setCheck(ModernizedCProgram.crc32(generatedCheck, next, copy));
						} 
						have -= copy;
						next += copy;
						if (len) {
							;
						} 
					}  else if (generatedHead != 0) {
						generatedHead.setName(0);
					} 
					state.setLength(0);
					state.setMode(.COMMENT);
			case .DONE:
					ret = 1;
					;
			case .BAD:
					ret = (true);
					;
			case .LEN:
					if (have >= 6 && left >= 258) {
						do {
							strm.setNext_out(put);
							strm.setAvail_out(left);
							strm.setNext_in(next);
							strm.setAvail_in(have);
							state.setHold(hold);
							state.setBits(bits);
						} while (0);
						ModernizedCProgram.inflate_fast(strm, out);
						do {
							put = strm.getNext_out();
							left = strm.getAvail_out();
							next = strm.getNext_in();
							have = strm.getAvail_in();
							hold = generatedHold;
							bits = generatedBits;
						} while (0);
						if (generatedMode == .TYPE) {
							state.setBack(-1);
						} 
						break;
					} 
					state.setBack(0);
					for (; ; ) {
						here = generatedLencode[((int)hold & ((-1024 << (generatedLenbits)) - 1))];
						if ((int)(generatedBits) <= bits) {
							break;
						} 
						do {
							if (have == 0) {
								;
							} 
							have--;
							hold += (long)(next++) << bits;
							bits += 8;
						} while (0);
					}
					if (generatedOp && (generatedOp & -1024) == 0) {
						last = here;
						for (; ; ) {
							here = generatedLencode[generatedVal + (((int)hold & ((-1024 << (generatedBits + generatedOp)) - 1)) >> generatedBits)];
							if ((int)(generatedBits + generatedBits) <= bits) {
								break;
							} 
							do {
								if (have == 0) {
									;
								} 
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
						do {
							hold >>=  (generatedBits);
							bits -= (int)(generatedBits);
						} while (0);
						generatedBack += generatedBits;
					} 
					do {
						hold >>=  (generatedBits);
						bits -= (int)(generatedBits);
					} while (0);
					generatedBack += generatedBits;
					state.setLength((int)generatedVal);
					if ((int)(generatedOp) == 0) {
						;
						state.setMode(.LIT);
						break;
					} 
					if (generatedOp & 32) {
						;
						state.setBack(-1);
						state.setMode(.TYPE);
						break;
					} 
					if (generatedOp & 64) {
						strm.setMsg((byte)"invalid literal/length code");
						state.setMode(.BAD);
						break;
					} 
					state.setExtra((int)(generatedOp) & 15);
					state.setMode(.LENEXT);
			case .LENGTH:
					if (generatedWrap && generatedFlags) {
						do {
							while (bits < (int)(true)) {
								do {
									if (have == 0) {
										;
									} 
									have--;
									hold += (long)(next++) << bits;
									bits += 8;
								} while (0);
							}
						} while (0);
						if (hold != (generatedTotal & -1024)) {
							strm.setMsg((byte)"incorrect length check");
							state.setMode(.BAD);
							break;
						} 
						do {
							hold = 0;
							bits = 0;
						} while (0);
						;
					} 
					state.setMode(.DONE);
			case .HEAD:
					if (generatedWrap == 0) {
						state.setMode(.TYPEDO);
						break;
					} 
					do {
						while (bits < (int)(true)) {
							do {
								if (have == 0) {
									;
								} 
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
					} while (0);
					if ((generatedWrap & 2) && hold == /* gzip header */-1024) {
						if (generatedWbits == 0) {
							state.setWbits(15);
						} 
						state.setCheck(ModernizedCProgram.crc32(-1024, 0, 0));
						do {
							hbuf[0] = (byte)(hold);
							hbuf[1] = (byte)((hold) >> 8);
							state.setCheck(ModernizedCProgram.crc32(generatedCheck, hbuf, 2));
						} while (0);
						do {
							hold = 0;
							bits = 0;
						} while (0);
						state.setMode(.FLAGS);
						break;
					} 
					state.setFlags(/* expect zlib header */0);
					if (generatedHead != 0) {
						generatedHead.setDone(-1);
					} 
					if (!(generatedWrap & /* check if zlib header allowed */1) || ((((int)hold & ((-1024 << (true)) - 1)) << 8) + (hold >> 8)) % 31) {
						strm.setMsg((byte)"incorrect header check");
						state.setMode(.BAD);
						break;
					} 
					if (((int)hold & ((-1024 << (true)) - 1)) != 8) {
						strm.setMsg((byte)"unknown compression method");
						state.setMode(.BAD);
						break;
					} 
					do {
						hold >>=  (true);
						bits -= (int)(true);
					} while (0);
					len = ((int)hold & ((-1024 << (true)) - 1)) + 8;
					if (generatedWbits == 0) {
						state.setWbits(len);
					} 
					if (len > 15 || len > generatedWbits) {
						strm.setMsg((byte)"invalid window size");
						state.setMode(.BAD);
						break;
					} 
					state.setDmax(-1024 << len);
					;
					strm.setAdler(state.setCheck(ModernizedCProgram.adler32(-1024, 0, 0)));
					state.setMode(hold & -1024 ? .DICTID : .TYPE);
					do {
						hold = 0;
						bits = 0;
					} while (0);
					break;
			case .HCRC:
					if (generatedFlags & -1024) {
						do {
							while (bits < (int)(true)) {
								do {
									if (have == 0) {
										;
									} 
									have--;
									hold += (long)(next++) << bits;
									bits += 8;
								} while (0);
							}
						} while (0);
						if ((generatedWrap & 4) && hold != (generatedCheck & -1024)) {
							strm.setMsg((byte)"header crc mismatch");
							state.setMode(.BAD);
							break;
						} 
						do {
							hold = 0;
							bits = 0;
						} while (0);
					} 
					if (generatedHead != 0) {
						generatedHead.setHcrc((int)((generatedFlags >> 9) & 1));
						generatedHead.setDone(1);
					} 
					strm.setAdler(state.setCheck(ModernizedCProgram.crc32(-1024, 0, 0)));
					state.setMode(.TYPE);
					break;
			case .DIST:
					for (; ; ) {
						here = generatedDistcode[((int)hold & ((-1024 << (generatedDistbits)) - 1))];
						if ((int)(generatedBits) <= bits) {
							break;
						} 
						do {
							if (have == 0) {
								;
							} 
							have--;
							hold += (long)(next++) << bits;
							bits += 8;
						} while (0);
					}
					if ((generatedOp & -1024) == 0) {
						last = here;
						for (; ; ) {
							here = generatedDistcode[generatedVal + (((int)hold & ((-1024 << (generatedBits + generatedOp)) - 1)) >> generatedBits)];
							if ((int)(generatedBits + generatedBits) <= bits) {
								break;
							} 
							do {
								if (have == 0) {
									;
								} 
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
						do {
							hold >>=  (generatedBits);
							bits -= (int)(generatedBits);
						} while (0);
						generatedBack += generatedBits;
					} 
					do {
						hold >>=  (generatedBits);
						bits -= (int)(generatedBits);
					} while (0);
					generatedBack += generatedBits;
					if (generatedOp & 64) {
						strm.setMsg((byte)"invalid distance code");
						state.setMode(.BAD);
						break;
					} 
					state.setOffset((int)generatedVal);
					state.setExtra((int)(generatedOp) & 15);
					state.setMode(.DISTEXT);
			case .DICTID:
					do {
						while (bits < (int)(true)) {
							do {
								if (have == 0) {
									;
								} 
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
					} while (0);
					strm.setAdler(state.setCheck(((((hold) >> 24) & -1024) + (((hold) >> 8) & -1024) + (((hold) & -1024) << 8) + (((hold) & -1024) << 24))));
					do {
						hold = 0;
						bits = 0;
					} while (0);
					state.setMode(.DICT);
			case .MATCH:
					if (left == 0) {
						;
					} 
					copy = out - left;
					if (generatedOffset > /* copy from window */copy) {
						copy = generatedOffset - copy;
						if (copy > generatedWhave) {
							if (generatedSane) {
								strm.setMsg((byte)"invalid distance too far back");
								state.setMode(.BAD);
								break;
							} 
						} 
						if (copy > generatedWnext) {
							copy -= generatedWnext;
							from = generatedWindow + (generatedWsize - copy);
						} else {
								from = generatedWindow + (generatedWnext - copy);
						} 
						if (copy > generatedLength) {
							copy = generatedLength;
						} 
					} else {
							from = put - generatedOffset;
							copy = generatedLength;
					} 
					if (copy > left) {
						copy = left;
					} 
					left -= copy;
					generatedLength -= copy;
					do {
						put++ = from++;
					} while (--copy);
					if (generatedLength == 0) {
						state.setMode(.LEN);
					} 
					break;
			case .STORED:
					do {
						hold >>=  bits & 7;
						bits -= bits & 7;
					} while (/* go to byte boundary */0);
					do {
						while (bits < (int)(true)) {
							do {
								if (have == 0) {
									;
								} 
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
					} while (0);
					if ((hold & -1024) != ((hold >> 16) ^ -1024)) {
						strm.setMsg((byte)"invalid stored block lengths");
						state.setMode(.BAD);
						break;
					} 
					state.setLength((int)hold & -1024);
					;
					do {
						hold = 0;
						bits = 0;
					} while (0);
					state.setMode(.COPY_);
					if (flush == 6) {
						;
					} 
			case .FLAGS:
					do {
						while (bits < (int)(true)) {
							do {
								if (have == 0) {
									;
								} 
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
					} while (0);
					state.setFlags((int)(hold));
					if ((generatedFlags & -1024) != 8) {
						strm.setMsg((byte)"unknown compression method");
						state.setMode(.BAD);
						break;
					} 
					if (generatedFlags & -1024) {
						strm.setMsg((byte)"unknown header flags set");
						state.setMode(.BAD);
						break;
					} 
					if (generatedHead != 0) {
						generatedHead.setText((int)((hold >> 8) & 1));
					} 
					if ((generatedFlags & -1024) && (generatedWrap & 4)) {
						do {
							hbuf[0] = (byte)(hold);
							hbuf[1] = (byte)((hold) >> 8);
							state.setCheck(ModernizedCProgram.crc32(generatedCheck, hbuf, 2));
						} while (0);
					} 
					do {
						hold = 0;
						bits = 0;
					} while (0);
					state.setMode(.TIME);
			case .LEN_:
					state.setMode(.LEN);
			case .SYNC:
			case .TIME:
					do {
						while (bits < (int)(true)) {
							do {
								if (have == 0) {
									;
								} 
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
					} while (0);
					if (generatedHead != 0) {
						generatedHead.setTime(hold);
					} 
					if ((generatedFlags & -1024) && (generatedWrap & 4)) {
						do {
							hbuf[0] = (byte)(hold);
							hbuf[1] = (byte)((hold) >> 8);
							hbuf[2] = (byte)((hold) >> 16);
							hbuf[3] = (byte)((hold) >> 24);
							state.setCheck(ModernizedCProgram.crc32(generatedCheck, hbuf, 4));
						} while (0);
					} 
					do {
						hold = 0;
						bits = 0;
					} while (0);
					state.setMode(.OS);
			case .DICT:
					if (generatedHavedict == 0) {
						do {
							strm.setNext_out(put);
							strm.setAvail_out(left);
							strm.setNext_in(next);
							strm.setAvail_in(have);
							state.setHold(hold);
							state.setBits(bits);
						} while (0);
						return 2;
					} 
					strm.setAdler(state.setCheck(ModernizedCProgram.adler32(-1024, 0, 0)));
					state.setMode(.TYPE);
			case .EXLEN:
					if (generatedFlags & -1024) {
						do {
							while (bits < (int)(true)) {
								do {
									if (have == 0) {
										;
									} 
									have--;
									hold += (long)(next++) << bits;
									bits += 8;
								} while (0);
							}
						} while (0);
						state.setLength((int)(hold));
						if (generatedHead != 0) {
							generatedHead.setExtra_len((int)hold);
						} 
						if ((generatedFlags & -1024) && (generatedWrap & 4)) {
							do {
								hbuf[0] = (byte)(hold);
								hbuf[1] = (byte)((hold) >> 8);
								state.setCheck(ModernizedCProgram.crc32(generatedCheck, hbuf, 2));
							} while (0);
						} 
						do {
							hold = 0;
							bits = 0;
						} while (0);
					}  else if (generatedHead != 0) {
						generatedHead.setExtra(0);
					} 
					state.setMode(.EXTRA);
			case .COPY:
					copy = generatedLength;
					if (copy) {
						if (copy > have) {
							copy = have;
						} 
						if (copy > left) {
							copy = left;
						} 
						if (copy == 0) {
							;
						} 
						.memcpy(put, next, copy);
						have -= copy;
						next += copy;
						left -= copy;
						put += copy;
						generatedLength -= copy;
						break;
					} 
					;
					state.setMode(.TYPE);
					break;
			case .TYPEDO:
					if (generatedLast) {
						do {
							hold >>=  bits & 7;
							bits -= bits & 7;
						} while (0);
						state.setMode(.CHECK);
						break;
					} 
					do {
						while (bits < (int)(true)) {
							do {
								if (have == 0) {
									;
								} 
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
					} while (0);
					state.setLast(((int)hold & ((-1024 << (true)) - 1)));
					do {
						hold >>=  (true);
						bits -= (int)(true);
					} while (0);
					switch (((int)hold & ((-1024 << (true)) - 1))) {
					case /* dynamic block */2:
							;
							state.setMode(.TABLE);
							break;
					case /* stored block */0:
							;
							state.setMode(.STORED);
							break;
					case 3:
							strm.setMsg((byte)"invalid block type");
							state.setMode(.BAD);
					case /* fixed block */1:
							state.fixedtables();
							;
							state.setMode(/* decode codes */.LEN_);
							if (flush == 6) {
								do {
									hold >>=  (true);
									bits -= (int)(true);
								} while (0);
								;
							} 
							break;
					}
					do {
						hold >>=  (true);
						bits -= (int)(true);
					} while (0);
					break;
			case .TYPE:
					if (flush == 5 || flush == 6) {
						;
					} 
			case .CODELENS:
					while (generatedHave < generatedNlen + generatedNdist) {
						for (; ; ) {
							here = generatedLencode[((int)hold & ((-1024 << (generatedLenbits)) - 1))];
							if ((int)(generatedBits) <= bits) {
								break;
							} 
							do {
								if (have == 0) {
									;
								} 
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
						if (generatedVal < 16) {
							do {
								hold >>=  (generatedBits);
								bits -= (int)(generatedBits);
							} while (0);
							generatedLens[generatedHave++] = generatedVal;
						} else {
								if (generatedVal == 16) {
									do {
										while (bits < (int)(generatedBits + 2)) {
											do {
												if (have == 0) {
													;
												} 
												have--;
												hold += (long)(next++) << bits;
												bits += 8;
											} while (0);
										}
									} while (0);
									do {
										hold >>=  (generatedBits);
										bits -= (int)(generatedBits);
									} while (0);
									if (generatedHave == 0) {
										strm.setMsg((byte)"invalid bit length repeat");
										state.setMode(.BAD);
										break;
									} 
									len = generatedLens[generatedHave - 1];
									copy = 3 + ((int)hold & ((-1024 << (true)) - 1));
									do {
										hold >>=  (true);
										bits -= (int)(true);
									} while (0);
								}  else if (generatedVal == 17) {
									do {
										while (bits < (int)(generatedBits + 3)) {
											do {
												if (have == 0) {
													;
												} 
												have--;
												hold += (long)(next++) << bits;
												bits += 8;
											} while (0);
										}
									} while (0);
									do {
										hold >>=  (generatedBits);
										bits -= (int)(generatedBits);
									} while (0);
									len = 0;
									copy = 3 + ((int)hold & ((-1024 << (true)) - 1));
									do {
										hold >>=  (true);
										bits -= (int)(true);
									} while (0);
								} else {
										do {
											while (bits < (int)(generatedBits + 7)) {
												do {
													if (have == 0) {
														;
													} 
													have--;
													hold += (long)(next++) << bits;
													bits += 8;
												} while (0);
											}
										} while (0);
										do {
											hold >>=  (generatedBits);
											bits -= (int)(generatedBits);
										} while (0);
										len = 0;
										copy = 11 + ((int)hold & ((-1024 << (true)) - 1));
										do {
											hold >>=  (true);
											bits -= (int)(true);
										} while (0);
								} 
								if (generatedHave + copy > generatedNlen + generatedNdist) {
									strm.setMsg((byte)"invalid bit length repeat");
									state.setMode(.BAD);
									break;
								} 
								while (copy--) {
									generatedLens[generatedHave++] = (int)len;
								}
						} 
					}
					if (generatedMode == /* handle error breaks in while */.BAD) {
						break;
					} 
					if (generatedLens[256] == /* check for end-of-block code (better have one) */0) {
						strm.setMsg((byte)"invalid code -- missing end-of-block");
						state.setMode(.BAD);
						break;
					} 
					state.setNext(generatedCodes);
					state.setLencode((code)(generatedNext));
					state.setLenbits(9);
					ret = (generatedNext).inflate_table(.LENS, generatedLens, generatedNlen, (generatedLenbits), generatedWork);
					if (ret) {
						strm.setMsg((byte)"invalid literal/lengths set");
						state.setMode(.BAD);
						break;
					} 
					state.setDistcode((code)(generatedNext));
					state.setDistbits(6);
					ret = (generatedNext).inflate_table(.DISTS, generatedLens + generatedNlen, generatedNdist, (generatedDistbits), generatedWork);
					if (ret) {
						strm.setMsg((byte)"invalid distances set");
						state.setMode(.BAD);
						break;
					} 
					;
					state.setMode(.LEN_);
					if (flush == 6) {
						;
					} 
			case .LENEXT:
					if (generatedExtra) {
						do {
							while (bits < (int)(generatedExtra)) {
								do {
									if (have == 0) {
										;
									} 
									have--;
									hold += (long)(next++) << bits;
									bits += 8;
								} while (0);
							}
						} while (0);
						generatedLength += ((int)hold & ((-1024 << (generatedExtra)) - 1));
						do {
							hold >>=  (generatedExtra);
							bits -= (int)(generatedExtra);
						} while (0);
						generatedBack += generatedExtra;
					} 
					;
					state.setWas(generatedLength);
					state.setMode(.DIST);
			case .COPY_:
					state.setMode(.COPY);
			case .EXTRA:
					if (generatedFlags & -1024) {
						copy = generatedLength;
						if (copy > have) {
							copy = have;
						} 
						if (copy) {
							if (generatedHead != 0 && generatedHead.getExtra() != 0) {
								len = generatedHead.getExtra_len() - generatedLength;
								.memcpy(generatedHead.getExtra() + len, next, len + copy > generatedHead.getExtra_max() ? generatedHead.getExtra_max() - len : copy);
							} 
							if ((generatedFlags & -1024) && (generatedWrap & 4)) {
								state.setCheck(ModernizedCProgram.crc32(generatedCheck, next, copy));
							} 
							have -= copy;
							next += copy;
							generatedLength -= copy;
						} 
						if (generatedLength) {
							;
						} 
					} 
					state.setLength(0);
					state.setMode(.NAME);
			case .COMMENT:
					if (generatedFlags & -1024) {
						if (have == 0) {
							;
						} 
						copy = 0;
						do {
							len = (int)(next[copy++]);
							if (generatedHead != 0 && generatedHead.getComment() != 0 && generatedLength < generatedHead.getComm_max()) {
								generatedHead.getComment()[generatedLength++] = (Bytef)len;
							} 
						} while (len && copy < have);
						if ((generatedFlags & -1024) && (generatedWrap & 4)) {
							state.setCheck(ModernizedCProgram.crc32(generatedCheck, next, copy));
						} 
						have -= copy;
						next += copy;
						if (len) {
							;
						} 
					}  else if (generatedHead != 0) {
						generatedHead.setComment(0);
					} 
					state.setMode(.HCRC);
			case .MEM:
					return (true);
			case .OS:
					do {
						while (bits < (int)(true)) {
							do {
								if (have == 0) {
									;
								} 
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
					} while (0);
					if (generatedHead != 0) {
						generatedHead.setXflags((int)(hold & -1024));
						generatedHead.setOs((int)(hold >> 8));
					} 
					if ((generatedFlags & -1024) && (generatedWrap & 4)) {
						do {
							hbuf[0] = (byte)(hold);
							hbuf[1] = (byte)((hold) >> 8);
							state.setCheck(ModernizedCProgram.crc32(generatedCheck, hbuf, 2));
						} while (0);
					} 
					do {
						hold = 0;
						bits = 0;
					} while (0);
					state.setMode(.EXLEN);
			case .TABLE:
					do {
						while (bits < (int)(true)) {
							do {
								if (have == 0) {
									;
								} 
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
					} while (0);
					state.setNlen(((int)hold & ((-1024 << (true)) - 1)) + 257);
					do {
						hold >>=  (true);
						bits -= (int)(true);
					} while (0);
					state.setNdist(((int)hold & ((-1024 << (true)) - 1)) + 1);
					do {
						hold >>=  (true);
						bits -= (int)(true);
					} while (0);
					state.setNcode(((int)hold & ((-1024 << (true)) - 1)) + 4);
					do {
						hold >>=  (true);
						bits -= (int)(true);
					} while (0);
					if (generatedNlen > 286 || generatedNdist > 30) {
						strm.setMsg((byte)"too many length or distance symbols");
						state.setMode(.BAD);
						break;
					} 
					;
					state.setHave(0);
					state.setMode(.LENLENS);
			case .DISTEXT:
					if (generatedExtra) {
						do {
							while (bits < (int)(generatedExtra)) {
								do {
									if (have == 0) {
										;
									} 
									have--;
									hold += (long)(next++) << bits;
									bits += 8;
								} while (0);
							}
						} while (0);
						generatedOffset += ((int)hold & ((-1024 << (generatedExtra)) - 1));
						do {
							hold >>=  (generatedExtra);
							bits -= (int)(generatedExtra);
						} while (0);
						generatedBack += generatedExtra;
					} 
					;
					state.setMode(.MATCH);
			case .CHECK:
					if (generatedWrap) {
						do {
							while (bits < (int)(true)) {
								do {
									if (have == 0) {
										;
									} 
									have--;
									hold += (long)(next++) << bits;
									bits += 8;
								} while (0);
							}
						} while (0);
						out -= left;
						strm.getTotal_out() += out;
						generatedTotal += out;
						if ((generatedWrap & 4) && out) {
							strm.setAdler(state.setCheck((generatedFlags ? ModernizedCProgram.crc32(generatedCheck, put - out, out) : ModernizedCProgram.adler32(generatedCheck, put - out, out))));
						} 
						out = left;
						if ((generatedWrap & 4) && (generatedFlags ? hold : ((((hold) >> 24) & -1024) + (((hold) >> 8) & -1024) + (((hold) & -1024) << 8) + (((hold) & -1024) << 24))) != generatedCheck) {
							strm.setMsg((byte)"incorrect data check");
							state.setMode(.BAD);
							break;
						} 
						do {
							hold = 0;
							bits = 0;
						} while (0);
						;
					} 
					state.setMode(.LENGTH);
			case .LENLENS:
					while (generatedHave < generatedNcode) {
						do {
							while (bits < (int)(true)) {
								do {
									if (have == 0) {
										;
									} 
									have--;
									hold += (long)(next++) << bits;
									bits += 8;
								} while (0);
							}
						} while (0);
						generatedLens[order[generatedHave++]] = (int)((int)hold & ((-1024 << (true)) - 1));
						do {
							hold >>=  (true);
							bits -= (int)(true);
						} while (0);
					}
					while (generatedHave < 19) {
						generatedLens[order[generatedHave++]] = 0;
					}
					state.setNext(generatedCodes);
					state.setLencode((code)(generatedNext));
					state.setLenbits(7);
					ret = (generatedNext).inflate_table(.CODES, generatedLens, 19, (generatedLenbits), generatedWork);
					if (ret) {
						strm.setMsg((byte)"invalid code lengths set");
						state.setMode(.BAD);
						break;
					} 
					;
					state.setHave(0);
					state.setMode(.CODELENS);
			case .LIT:
					if (left == 0) {
						;
					} 
					put++ = (byte)(generatedLength);
					left--;
					state.setMode(.LEN);
					break;
			default:
					return (true/*
					       Return from inflate(), updating the total counts and the check value.
					       If there was no progress during the inflate() call, return a buffer
					       error.  Call updatewindow() to create and/or update the window state.
					       Note: a memory error from inflate() is non-recoverable.
					     */);
			}
		}
		if (generatedWsize || (out != strm.getAvail_out() && generatedMode < .BAD && (generatedMode < .CHECK || flush != 4))) {
			if (ModernizedCProgram.updatewindow(strm, strm.getNext_out(), out - strm.getAvail_out())) {
				state.setMode(.MEM);
				return (true);
			} 
		} 
		in -= strm.getAvail_in();
		out -= strm.getAvail_out();
		strm.getTotal_in() += in;
		strm.getTotal_out() += out;
		generatedTotal += out;
		if ((generatedWrap & 4) && out) {
			strm.setAdler(state.setCheck((generatedFlags ? ModernizedCProgram.crc32(generatedCheck, strm.getNext_out() - out, out) : ModernizedCProgram.adler32(generatedCheck, strm.getNext_out() - out, out))));
		} 
		strm.setData_type((int)generatedBits + (generatedLast ? 64 : 0) + (generatedMode == .TYPE ? 128 : 0) + (generatedMode == .LEN_ || generatedMode == .COPY_ ? 256 : 0));
		if (((in == 0 && out == 0) || flush == 4) && ret == 0) {
			ret = (true);
		} 
		return ret;
	}
	public static int inflateEnd(Object strm) {
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (true);
		} 
		state = (inflate_state)strm.getState();
		Object generatedWindow = state.getWindow();
		if (generatedWindow != 0) {
			.UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (voidpf)(generatedWindow));
		} 
		.UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (voidpf)(strm.getState()));
		strm.setState(0);
		;
		return 0;
	}
	public static int inflateGetDictionary(Object strm, Object dictionary, Object dictLength) {
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (/* check state */true);
		} 
		state = (inflate_state)strm.getState();
		Object generatedWhave = state.getWhave();
		Object generatedWindow = state.getWindow();
		Object generatedWnext = state.getWnext();
		if (generatedWhave && dictionary != /* copy dictionary */0) {
			.memcpy(dictionary, generatedWindow + generatedWnext, generatedWhave - generatedWnext);
			.memcpy(dictionary + generatedWhave - generatedWnext, generatedWindow, generatedWnext);
		} 
		if (dictLength != 0) {
			dictLength = generatedWhave;
		} 
		return 0;
	}
	public static int inflateSetDictionary(Object strm, Object dictionary, Object dictLength) {
		inflate_state state = new inflate_state();
		long dictid;
		int ret;
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (/* check state */true);
		} 
		state = (inflate_state)strm.getState();
		Object generatedWrap = state.getWrap();
		Object generatedMode = state.getMode();
		if (generatedWrap != 0 && generatedMode != .DICT) {
			return (true);
		} 
		Object generatedCheck = state.getCheck();
		if (generatedMode == /* check for correct dictionary identifier */.DICT) {
			dictid = ModernizedCProgram.adler32(-1024, 0, 0);
			dictid = ModernizedCProgram.adler32(dictid, dictionary, dictLength);
			if (dictid != generatedCheck) {
				return (true);
			} 
		} 
		ret = ModernizedCProgram.updatewindow(strm, dictionary + dictLength, /* copy dictionary to window using updatewindow(), which will amend the
		       existing dictionary if appropriate */dictLength);
		if (ret) {
			state.setMode(.MEM);
			return (true);
		} 
		state.setHavedict(1);
		;
		return 0;
	}
	public static int inflateGetHeader(Object strm, Object head) {
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (/* check state */true);
		} 
		state = (inflate_state)strm.getState();
		Object generatedWrap = state.getWrap();
		if ((generatedWrap & 2) == 0) {
			return (true);
		} 
		state.setHead(/* save header structure */head);
		head.setDone(0);
		return 0/*
		   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
		   or when out of input.  When called, *have is the number of pattern bytes
		   found in order so far, in 0..3.  On return *have is updated to the new
		   state.  If on return *have equals four, then the pattern was found and the
		   return value is how many bytes were read including the last byte of the
		   pattern.  If *have is less than four, then the pattern has not been found
		   yet and the return value is len.  In the latter case, syncsearch() can be
		   called again with more data and the *have state.  *have is initialized to
		   zero for the first call.
		 */;
	}
	public static int syncsearch(int have, Object buf, int len) {
		int got;
		int next;
		got = have;
		next = 0;
		while (next < len && got < 4) {
			if ((int)(buf[next]) == (got < 2 ? 0 : -1024)) {
				got++;
			}  else if (buf[next]) {
				got = 0;
			} else {
					got = 4 - got;
			} 
			next++;
		}
		have = got;
		return next;
	}
	public static int inflateSync(Object strm) {
		/* number of bytes to look at or looked at */int len;
		/* temporary to save total_in and total_out */long in;
		long out;
		byte[] buf = new byte[/* to restore bit buffer to byte string */4];
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (/* check parameters */true);
		} 
		state = (inflate_state)strm.getState();
		Object generatedBits = state.getBits();
		if (strm.getAvail_in() == 0 && generatedBits < 8) {
			return (true);
		} 
		Object generatedMode = state.getMode();
		Object generatedHold = state.getHold();
		int generatedHave = state.getHave();
		if (generatedMode != /* if first time, start search in bit buffer */.SYNC) {
			state.setMode(.SYNC);
			generatedHold <<=  generatedBits & 7;
			generatedBits -= generatedBits & 7;
			len = 0;
			while (generatedBits >= 8) {
				buf[len++] = (byte)(generatedHold);
				generatedHold >>=  8;
				generatedBits -= 8;
			}
			state.setHave(0);
			ModernizedCProgram.syncsearch((generatedHave), buf, len);
		} 
		len = ModernizedCProgram.syncsearch((generatedHave), strm.getNext_in(), strm.getAvail_in());
		strm.getAvail_in() -= len;
		strm.getNext_in() += len;
		strm.getTotal_in() += len;
		if (generatedHave != 4) {
			return (/* return no joy or set up to restart inflate() on a new block */true);
		} 
		in = strm.getTotal_in();
		out = strm.getTotal_out();
		ModernizedCProgram.inflateReset(strm);
		strm.setTotal_in(in);
		strm.setTotal_out(out);
		state.setMode(.TYPE);
		return 0/*
		   Returns true if inflate is currently at the end of a block generated by
		   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
		   implementation to provide an additional safety check. PPP uses
		   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
		   block. When decompressing, PPP checks that at the end of input packet,
		   inflate is waiting for these length bytes.
		 */;
	}
	public static int inflateSyncPoint(Object strm) {
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (true);
		} 
		state = (inflate_state)strm.getState();
		Object generatedMode = state.getMode();
		Object generatedBits = state.getBits();
		return generatedMode == .STORED && generatedBits == 0;
	}
	public static int inflateCopy(Object dest, Object source) {
		inflate_state state = new inflate_state();
		inflate_state copy = new inflate_state();
		byte window;
		int wsize;
		if (ModernizedCProgram.inflateStateCheck(source) || dest == /* check input */0) {
			return (true);
		} 
		state = (inflate_state)source.getState();
		copy = /* allocate space */(inflate_state).UNRECOGNIZEDFUNCTIONNAME((source).getOpaque(), (true), ());
		if (copy == 0) {
			return (true);
		} 
		window = 0;
		Object generatedWindow = state.getWindow();
		Object generatedWbits = state.getWbits();
		if (generatedWindow != 0) {
			window = (byte).UNRECOGNIZEDFUNCTIONNAME((source).getOpaque(), (-1024 << generatedWbits), ());
			if (window == 0) {
				.UNRECOGNIZEDFUNCTIONNAME((source).getOpaque(), (voidpf)(copy));
				return (true);
			} 
		} 
		.memcpy((voidpf)dest, (voidpf)source, /* copy state */);
		.memcpy((voidpf)copy, (voidpf)state, );
		copy.setStrm(dest);
		Object generatedLencode = state.getLencode();
		Object generatedCodes = state.getCodes();
		Object generatedDistcode = state.getDistcode();
		if (generatedLencode >= generatedCodes && generatedLencode <= generatedCodes + (852 + 592) - 1) {
			copy.setLencode(generatedCodes + (generatedLencode - generatedCodes));
			copy.setDistcode(generatedCodes + (generatedDistcode - generatedCodes));
		} 
		Object generatedNext = state.getNext();
		copy.setNext(generatedCodes + (generatedNext - generatedCodes));
		if (window != 0) {
			wsize = -1024 << generatedWbits;
			.memcpy(window, generatedWindow, wsize);
		} 
		copy.setWindow(window);
		dest.setState((internal_state)copy);
		return 0;
	}
	public static int inflateUndermine(Object strm, int subvert) {
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (true);
		} 
		state = (inflate_state)strm.getState();
		(Object)subvert;
		state.setSane(1);
		return (true);
	}
	public static int inflateValidate(Object strm, int check) {
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (true);
		} 
		state = (inflate_state)strm.getState();
		Object generatedWrap = state.getWrap();
		if (check) {
			generatedWrap |=  4;
		} else {
				generatedWrap &=  ~4;
		} 
		return 0;
	}
	public static long inflateMark(Object strm) {
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return -(-1024 << 16);
		} 
		state = (inflate_state)strm.getState();
		Object generatedBack = state.getBack();
		Object generatedMode = state.getMode();
		Object generatedLength = state.getLength();
		Object generatedWas = state.getWas();
		return (long)(((long)((long)generatedBack)) << 16) + (generatedMode == .COPY ? generatedLength : (generatedMode == .MATCH ? generatedWas - generatedLength : 0));
	}
	public static long inflateCodesUsed(Object strm) {
		inflate_state state = new inflate_state();
		if (ModernizedCProgram.inflateStateCheck(strm)) {
			return (long)-1;
		} 
		state = (inflate_state)strm.getState();
		Object generatedNext = state.getNext();
		Object generatedCodes = state.getCodes();
		return (long)(generatedNext - generatedCodes);
	}
	public static void md5crypt_encode(Object digest, Object buf) {
		int l;
		l = (digest[0] << 16) | (digest[6] << 8) | (digest[12] << 0);
		buf[0] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[1] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[2] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[3] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[1] << 16) | (digest[7] << 8) | (digest[13] << 0);
		buf[4] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[5] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[6] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[7] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[2] << 16) | (digest[8] << 8) | (digest[14] << 0);
		buf[8] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[9] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[10] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[11] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[3] << 16) | (digest[9] << 8) | (digest[15] << 0);
		buf[12] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[13] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[14] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[15] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[4] << 16) | (digest[10] << 8) | (digest[5] << 0);
		buf[16] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[17] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[18] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[19] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[11] << 0);
		buf[20] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[21] = ModernizedCProgram.int_to_itoa64(l & -1024);
		int l;
		l = (digest[0] << 16) | (digest[6] << 8) | (digest[12] << 0);
		buf[0] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[1] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[2] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[3] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[1] << 16) | (digest[7] << 8) | (digest[13] << 0);
		buf[4] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[5] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[6] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[7] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[2] << 16) | (digest[8] << 8) | (digest[14] << 0);
		buf[8] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[9] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[10] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[11] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[3] << 16) | (digest[9] << 8) | (digest[15] << 0);
		buf[12] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[13] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[14] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[15] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[4] << 16) | (digest[10] << 8) | (digest[5] << 0);
		buf[16] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[17] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[18] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[19] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[11] << 0);
		buf[20] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[21] = ModernizedCProgram.int_to_itoa64(l & -1024);
		int l;
		l = (digest[0] << 16) | (digest[6] << 8) | (digest[12] << 0);
		buf[0] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[1] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[2] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[3] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[1] << 16) | (digest[7] << 8) | (digest[13] << 0);
		buf[4] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[5] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[6] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[7] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[2] << 16) | (digest[8] << 8) | (digest[14] << 0);
		buf[8] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[9] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[10] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[11] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[3] << 16) | (digest[9] << 8) | (digest[15] << 0);
		buf[12] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[13] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[14] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[15] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[4] << 16) | (digest[10] << 8) | (digest[5] << 0);
		buf[16] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[17] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[18] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[19] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[11] << 0);
		buf[20] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[21] = ModernizedCProgram.int_to_itoa64(l & -1024);
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static Object ADL_Main_Memory_Alloc(Object iSize) {
		return .malloc((size_t)iSize);
	}
	/* Bra86.c -- Converter for x86 code (BCJ)
	2017-04-03 : Igor Pavlov : Public domain */
	public static Object x86_Convert(Object data, Object size, Object ip, Object state, int encoding) {
		SizeT pos = 0;
		UInt32 mask = state & 7;
		if (size < 5) {
			return 0;
		} 
		size -= 4;
		ip += 5;
		for (; ; ) {
			Byte p = data + pos;
			Byte limit = data + size;
			for (; p < limit; p++) {
				if ((p & -1024) == -1024) {
					break;
				} 
			}
			{ 
				SizeT d = (SizeT)(p - data - pos);
				pos = (SizeT)(p - data);
				if (p >= limit) {
					state = (d > 2 ? 0 : mask >> (int)d);
					return pos;
				} 
				if (d > 2) {
					mask = 0;
				} else {
						mask >>=  (int)d;
						if (mask != 0 && (mask > 4 || mask == 3 || ((((p[(size_t)(mask >> 1) + 1]) + 1) & -1024) == 0))) {
							mask = (mask >> 1) | 4;
							pos++;
							continue;
						} 
				} 
			}
			if (((((p[4]) + 1) & -1024) == 0)) {
				UInt32 v = ((UInt32)p[4] << 24) | ((UInt32)p[3] << 16) | ((UInt32)p[2] << 8) | ((UInt32)p[1]);
				UInt32 cur = ip + (UInt32)pos;
				pos += 5;
				if (encoding) {
					v += cur;
				} else {
						v -= cur;
				} 
				if (mask != 0) {
					int sh = (mask & 6) << 2;
					if ((((((Byte)(v >> sh)) + 1) & -1024) == 0)) {
						v ^=  (((UInt32)-1024 << sh) - 1);
						if (encoding) {
							v += cur;
						} else {
								v -= cur;
						} 
					} 
					mask = 0;
				} 
				p[1] = (Byte)v;
				p[2] = (Byte)(v >> 8);
				p[3] = (Byte)(v >> 16);
				p[4] = (Byte)(0 - ((v >> 24) & 1));
			} else {
					mask = (mask >> 1) | 4;
					pos++;
			} 
		}
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int sort_by_string(Object p1, Object p2) {
		byte s1 = (byte)p1;
		byte s2 = (byte)p2;
		return .strcmp(s1, s2);
	}
	public static int sort_by_digest_p0p1(Object v1, Object v2, Object v3) {
		u32 d1 = (u32)v1;
		u32 d2 = (u32)v2;
		hashconfig_t hashconfig = (hashconfig_t)v3;
		Object generatedDgst_pos0 = hashconfig.getDgst_pos0();
		u32 dgst_pos0 = generatedDgst_pos0;
		Object generatedDgst_pos1 = hashconfig.getDgst_pos1();
		u32 dgst_pos1 = generatedDgst_pos1;
		Object generatedDgst_pos2 = hashconfig.getDgst_pos2();
		u32 dgst_pos2 = generatedDgst_pos2;
		Object generatedDgst_pos3 = hashconfig.getDgst_pos3();
		u32 dgst_pos3 = generatedDgst_pos3;
		if (d1[dgst_pos3] > d2[dgst_pos3]) {
			return 1;
		} 
		if (d1[dgst_pos3] < d2[dgst_pos3]) {
			return -1;
		} 
		if (d1[dgst_pos2] > d2[dgst_pos2]) {
			return 1;
		} 
		if (d1[dgst_pos2] < d2[dgst_pos2]) {
			return -1;
		} 
		if (d1[dgst_pos1] > d2[dgst_pos1]) {
			return 1;
		} 
		if (d1[dgst_pos1] < d2[dgst_pos1]) {
			return -1;
		} 
		if (d1[dgst_pos0] > d2[dgst_pos0]) {
			return 1;
		} 
		if (d1[dgst_pos0] < d2[dgst_pos0]) {
			return -1;
		} 
		return 0;
	}
	public static int sort_by_salt(Object v1, Object v2) {
		salt_t s1 = (salt_t)v1;
		salt_t s2 = (salt_t)v2;
		int res1 = (int)s1.getSalt_len() - (int)s2.getSalt_len();
		if (res1 != 0) {
			return (res1);
		} 
		int res2 = (int)s1.getSalt_iter() - (int)s2.getSalt_iter();
		if (res2 != 0) {
			return (res2);
		} 
		for (int n = 0;
		 n < 64; n++) {
			if (s1.getSalt_buf()[n] > s2.getSalt_buf()[n]) {
				return 1;
			} 
			if (s1.getSalt_buf()[n] < s2.getSalt_buf()[n]) {
				return -1;
			} 
		}
		for (int n = 0;
		 n < 64; n++) {
			if (s1.getSalt_buf_pc()[n] > s2.getSalt_buf_pc()[n]) {
				return 1;
			} 
			if (s1.getSalt_buf_pc()[n] < s2.getSalt_buf_pc()[n]) {
				return -1;
			} 
		}
		return 0;
	}
	public static int sort_by_hash(Object v1, Object v2, Object v3) {
		hash_t h1 = (hash_t)v1;
		hash_t h2 = (hash_t)v2;
		hashconfig_t hashconfig = (hashconfig_t)v3;
		boolean generatedIs_salted = hashconfig.getIs_salted();
		if (generatedIs_salted == true) {
			salt_t s1 = h1.getSalt();
			salt_t s2 = h2.getSalt();
			int res = ModernizedCProgram.sort_by_salt(s1, s2);
			if (res != 0) {
				return (res);
			} 
		} 
		Object d1 = h1.getDigest();
		Object d2 = h2.getDigest();
		return ModernizedCProgram.sort_by_digest_p0p1(d1, d2, v3);
	}
	public static int sort_by_hash_no_salt(Object v1, Object v2, Object v3) {
		hash_t h1 = (hash_t)v1;
		hash_t h2 = (hash_t)v2;
		Object d1 = h1.getDigest();
		Object d2 = h2.getDigest();
		return ModernizedCProgram.sort_by_digest_p0p1(d1, d2, v3);
	}
	public static int hash_encode(Object hashconfig, Object hashes, Object module_ctx, Byte out_buf, Object out_size, Object salt_pos, Object digest_pos) {
		if (module_ctx.getModule_hash_encode() == (Object)-1) {
			return .snprintf(out_buf, out_size, "%s", hashes.getHashfile());
		} 
		salt_t salts_buf = hashes.getSalts_buf();
		salts_buf += salt_pos;
		Object generatedDigests_offset = salts_buf.getDigests_offset();
		u32 digest_cur = generatedDigests_offset + digest_pos;
		Object digests_buf = hashes.getDigests_buf();
		Object esalts_buf = hashes.getEsalts_buf();
		Object hook_salts_buf = hashes.getHook_salts_buf();
		hashinfo_t hash_info = hashes.getHash_info();
		byte digests_buf_ptr = (byte)digests_buf;
		byte esalts_buf_ptr = (byte)esalts_buf;
		byte hook_salts_buf_ptr = (byte)hook_salts_buf;
		hashinfo_t hash_info_ptr = ((Object)0);
		digests_buf_ptr += digest_cur * hashconfig.getDgst_size();
		esalts_buf_ptr += digest_cur * hashconfig.getEsalt_size();
		hook_salts_buf_ptr += digest_cur * hashconfig.getHook_salt_size();
		if (hash_info) {
			hash_info_ptr = hash_info[digest_cur];
		} 
		int out_len = .UNRECOGNIZEDFUNCTIONNAME(hashconfig, digests_buf_ptr, salts_buf, esalts_buf_ptr, hook_salts_buf_ptr, hash_info_ptr, out_buf, out_size);
		return out_len;
	}
	public static void check_hash(hashcat_ctx hashcat_ctx, hc_device_param device_param, plain plain) {
		debugfile_ctx generatedDebugfile_ctx = hashcat_ctx.getDebugfile_ctx();
		debugfile_ctx_t debugfile_ctx = generatedDebugfile_ctx;
		hashes generatedHashes = hashcat_ctx.getHashes();
		hashes_t hashes = generatedHashes;
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		loopback_ctx generatedLoopback_ctx = hashcat_ctx.getLoopback_ctx();
		loopback_ctx_t loopback_ctx = generatedLoopback_ctx;
		module_ctx generatedModule_ctx = hashcat_ctx.getModule_ctx();
		module_ctx_t module_ctx = generatedModule_ctx;
		Object generatedSalt_pos = plain.getSalt_pos();
		u32 salt_pos = generatedSalt_pos;
		Object generatedDigest_pos = plain.getDigest_pos();
		// relativeu32 digest_pos = generatedDigest_pos;
		Object tmps = ((Object)0);
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_d_tmps = device_param.getCuda_d_tmps();
		Object generatedGidvid = plain.getGidvid();
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedOpencl_d_tmps = device_param.getOpencl_d_tmps();
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_COPY_TMPS) {
			tmps = ModernizedCProgram.hcmalloc(hashconfig.getTmp_size());
			if (generatedIs_cuda == true) {
				hashcat_ctx.hc_cuMemcpyDtoH(tmps, generatedCuda_d_tmps + (generatedGidvid * hashconfig.getTmp_size()), hashconfig.getTmp_size());
			} 
			if (generatedIs_opencl == true) {
				hashcat_ctx.hc_clEnqueueReadBuffer(generatedOpencl_command_queue, generatedOpencl_d_tmps, CL_TRUE, generatedGidvid * hashconfig.getTmp_size(), hashconfig.getTmp_size(), tmps, 0, ((Object)0), ((Object)0));
			} 
		} 
		// hashu8 out_buf = hashes.getOut_buf();
		int out_len = ModernizedCProgram.hash_encode(generatedHashconfig, generatedHashes, generatedModule_ctx, (byte)out_buf, -1024, salt_pos, digest_pos);
		out_buf[out_len] = 0// plain;// plain
		u8[] plain_buf = new u8();
		.memset(plain_buf, 0, );
		u8 plain_ptr = plain_buf;
		int plain_len = 0;
		ModernizedCProgram.build_plain(hashcat_ctx, device_param, plain, (u32)plain_buf, plain_len);
		if (module_ctx.getModule_build_plain_postprocess() != (Object)-1) {
			u8[] temp_buf = new u8[]{0};
			.memset(temp_buf, 0, );
			int temp_len = .UNRECOGNIZEDFUNCTIONNAME(generatedHashconfig, generatedHashes, tmps, (u32)plain_buf, , plain_len, (u32)temp_buf, );
			if (temp_len < (int)) {
				.memcpy(plain_buf, temp_buf, temp_len);
				plain_len = temp_len;
			} 
		} 
		// crackposu64 crackpos = 0;
		ModernizedCProgram.build_crackpos(hashcat_ctx, device_param, plain, crackpos)// debug;// debug
		u8[] debug_rule_buf = new u8[]{0};
		// -1 errorint debug_rule_len = 0;
		u8[] debug_plain_ptr = new u8[]{0};
		int debug_plain_len = 0;
		ModernizedCProgram.build_debugdata(hashcat_ctx, device_param, plain, debug_rule_buf, debug_rule_len, debug_plain_ptr, debug_plain_len)// outfile, can be either to file or stdout// if an error occurs opening the file, send to stdout as fallback;// outfile, can be either to file or stdout// if an error occurs opening the file, send to stdout as fallback
		// the fp gets opened for each cracked hash so that the user can modify (move) the outfile while hashcat runs// the fp gets opened for each cracked hash so that the user can modify (move) the outfile while hashcat runshashcat_ctx.outfile_write_open();
		u8 tmp_buf = hashes.getTmp_buf();
		tmp_buf[0] = 0;
		int tmp_len = hashcat_ctx.outfile_write((byte)out_buf, out_len, plain_ptr, plain_len, crackpos, ((Object)0), 0, (byte)tmp_buf);
		hashcat_ctx.event_call((event_identifier.EVENT_CRACKER_HASH_CRACKED), (tmp_buf), (tmp_len));
		hashcat_ctx.outfile_write_close()// potfile// we can have either used-defined hooks or reuse the same format as input format;// potfile// we can have either used-defined hooks or reuse the same format as input format
		Object generatedDigests_offset = salts_buf.getDigests_offset();
		// no need for locking, we're in a mutex protected functionif (module_ctx.getModule_hash_encode_potfile() != (Object)-1) {
			salt_t salts_buf = hashes.getSalts_buf();
			salts_buf += salt_pos;
			u32 digest_cur = generatedDigests_offset + digest_pos;
			Object digests_buf = hashes.getDigests_buf();
			Object esalts_buf = hashes.getEsalts_buf();
			Object hook_salts_buf = hashes.getHook_salts_buf();
			hashinfo_t hash_info = hashes.getHash_info();
			byte digests_buf_ptr = (byte)digests_buf;
			byte esalts_buf_ptr = (byte)esalts_buf;
			byte hook_salts_buf_ptr = (byte)hook_salts_buf;
			hashinfo_t hash_info_ptr = ((Object)0);
			digests_buf_ptr += digest_cur * hashconfig.getDgst_size();
			esalts_buf_ptr += digest_cur * hashconfig.getEsalt_size();
			hook_salts_buf_ptr += digest_cur * hashconfig.getHook_salt_size();
			if (hash_info) {
				hash_info_ptr = hash_info[digest_cur];
			} 
			out_len = .UNRECOGNIZEDFUNCTIONNAME(hashconfig, digests_buf_ptr, salts_buf, esalts_buf_ptr, hook_salts_buf_ptr, hash_info_ptr, (byte)out_buf, -1024, tmps);
			out_buf[out_len] = 0;
		} 
		hashcat_ctx.potfile_write_append((byte)out_buf, out_len, plain_ptr, plain_len)// if enabled, update also the loopback file;// if enabled, update also the loopback file
		if (loopback_ctx.getFp().getPfp() != ((Object)0)) {
			hashcat_ctx.loopback_write_append(plain_ptr, plain_len);
		} 
		// if enabled, update also the (rule) debug fileif (debugfile_ctx.getFp().getPfp() != ((Object)0)) {
			if ((debug_plain_len > 0) || (debug_rule_len > 0)) {
				hashcat_ctx.debugfile_write_append(debug_rule_buf, debug_rule_len, plain_ptr, plain_len, debug_plain_ptr, debug_plain_len);
			} 
		} 
		// the next check implies that:// - (user_options->attack_mode == ATTACK_MODE_STRAIGHT)
		if (hashconfig.getOpts_type() & opts_type.OPTS_TYPE_COPY_TMPS) {
			ModernizedCProgram.hcfree(tmps);
		} 
	}
	public static int check_cracked(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object salt_pos) {
		cpt_ctx generatedCpt_ctx = hashcat_ctx.getCpt_ctx();
		cpt_ctx_t cpt_ctx = generatedCpt_ctx;
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		hashes generatedHashes = hashcat_ctx.getHashes();
		hashes_t hashes = generatedHashes;
		status_ctx generatedStatus_ctx = hashcat_ctx.getStatus_ctx();
		status_ctx_t status_ctx = generatedStatus_ctx;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		salt generatedSalts_buf = hashes.getSalts_buf();
		salt_t salt_buf = generatedSalts_buf[salt_pos];
		u32 num_cracked = new u32();
		int CU_rc;
		int CL_rc;
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_d_result = device_param.getCuda_d_result();
		if (generatedIs_cuda == true) {
			CU_rc = hashcat_ctx.hc_cuMemcpyDtoH(num_cracked, generatedCuda_d_result, );
			if (CU_rc == -1) {
				return -1;
			} 
		} 
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedOpencl_d_result = device_param.getOpencl_d_result();
		if (generatedIs_opencl == true) {
			CL_rc = hashcat_ctx.hc_clEnqueueReadBuffer(generatedOpencl_command_queue, generatedOpencl_d_result, CL_TRUE, 0, , num_cracked, 0, ((Object)0), ((Object)0));
			if (CL_rc == -1) {
				return -1;
			} 
		} 
		boolean generatedSpeed_only = user_options.getSpeed_only();
		if (generatedSpeed_only == true) {
			return 0;
		} 
		// we want the hc_clEnqueueReadBuffer to run in benchmark mode because it has an influence in performance
		Object generatedCuda_d_plain_bufs = device_param.getCuda_d_plain_bufs();
		Object generatedOpencl_d_plain_bufs = device_param.getOpencl_d_plain_bufs();
		Object generatedMux_display = status_ctx.getMux_display();
		Object generatedDigests_shown = hashes.getDigests_shown();
		Object generatedOpts_type = hashconfig.getOpts_type();
		Object generatedDigests_done = hashes.getDigests_done();
		Object generatedDigests_cnt = salt_buf.getDigests_cnt();
		Object generatedSalts_shown = hashes.getSalts_shown();
		Object generatedSalts_done = hashes.getSalts_done();
		Object generatedSalts_cnt = hashes.getSalts_cnt();
		cpt generatedCpt_buf = cpt_ctx.getCpt_buf();
		int generatedCpt_pos = cpt_ctx.getCpt_pos();
		Object generatedCpt_total = cpt_ctx.getCpt_total();
		Object generatedDigests_shown_tmp = hashes.getDigests_shown_tmp();
		Object generatedCuda_d_digests_shown = device_param.getCuda_d_digests_shown();
		Object generatedDigests_offset = salt_buf.getDigests_offset();
		Object generatedOpencl_d_digests_shown = device_param.getOpencl_d_digests_shown();
		if (num_cracked) {
			plain_t cracked = (plain_t)ModernizedCProgram.hccalloc(num_cracked, );
			if (generatedIs_cuda == true) {
				CU_rc = hashcat_ctx.hc_cuMemcpyDtoH(cracked, generatedCuda_d_plain_bufs, num_cracked * );
				if (CU_rc == -1) {
					return -1;
				} 
			} 
			if (generatedIs_opencl == true) {
				CL_rc = hashcat_ctx.hc_clEnqueueReadBuffer(generatedOpencl_command_queue, generatedOpencl_d_plain_bufs, CL_TRUE, 0, num_cracked * , cracked, 0, ((Object)0), ((Object)0));
				if (CL_rc == -1) {
					return -1;
				} 
			} 
			u32 cpt_cracked = 0;
			.WaitForSingleObject(generatedMux_display, -1024);
			for (u32 i = 0;
			 i < num_cracked; i++) {
				u32 hash_pos = cracked[i].getHash_pos();
				if (generatedDigests_shown[hash_pos] == 1) {
					continue;
				} 
				if ((generatedOpts_type & opts_type.OPTS_TYPE_PT_NEVERCRACK) == 0) {
					generatedDigests_shown[hash_pos] = 1;
					generatedDigests_done++;
					cpt_cracked++;
					generatedDigests_done++;
					if (generatedDigests_done == generatedDigests_cnt) {
						generatedSalts_shown[salt_pos] = 1;
						generatedSalts_done++;
					} 
				} 
				if (generatedSalts_done == generatedSalts_cnt) {
					hashcat_ctx.mycracked();
				} 
				ModernizedCProgram.check_hash(hashcat_ctx, device_param, cracked[i]);
			}
			.ReleaseMutex(generatedMux_display);
			ModernizedCProgram.hcfree(cracked);
			if (cpt_cracked > 0) {
				.WaitForSingleObject(generatedMux_display, -1024);
				generatedCpt_buf[generatedCpt_pos].setTimestamp(.time(((Object)0)));
				generatedCpt_buf[generatedCpt_pos].setCracked(cpt_cracked);
				generatedCpt_pos++;
				generatedCpt_total += cpt_cracked;
				if (generatedCpt_pos == -1024) {
					cpt_ctx.setCpt_pos(0);
				} 
				.ReleaseMutex(generatedMux_display);
			} 
			if (generatedOpts_type & opts_type.OPTS_TYPE_PT_NEVERCRACK) {
				.memset(generatedDigests_shown_tmp, 0, generatedDigests_cnt * );
				if (generatedIs_cuda == true) {
					CU_rc = hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_digests_shown + (generatedDigests_offset * ), generatedDigests_shown_tmp[generatedDigests_offset], generatedDigests_cnt * );
					if (CU_rc == -1) {
						return -1;
					} 
				} 
				if (generatedIs_opencl == true) {
					CL_rc = hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_digests_shown, CL_TRUE, generatedDigests_offset * , generatedDigests_cnt * , generatedDigests_shown_tmp[generatedDigests_offset], 0, ((Object)0), ((Object)0));
					if (CL_rc == -1) {
						return -1;
					} 
				} 
			} 
			num_cracked = 0;
			if (generatedIs_cuda == true) {
				CU_rc = hashcat_ctx.hc_cuMemcpyHtoD(generatedCuda_d_result, num_cracked, );
				if (CU_rc == -1) {
					return -1;
				} 
			} 
			if (generatedIs_opencl == true) {
				CL_rc = hashcat_ctx.hc_clEnqueueWriteBuffer(generatedOpencl_command_queue, generatedOpencl_d_result, CL_TRUE, 0, , num_cracked, 0, ((Object)0), ((Object)0));
				if (CL_rc == -1) {
					return -1;
				} 
			} 
		} 
		return 0;
	}
	public static void Ppmd7_Construct() {
		int i;
		int k;
		int m;
		this.setBase(0);
		Object generatedUnits2Indx = this.getUnits2Indx();
		Object generatedIndx2Units = this.getIndx2Units();
		for (; i < (4 + 4 + 4 + ((128 + 3 - 1 * 4 - 2 * 4 - 3 * 4) / 4)); i++) {
			int step = (i >= 12 ? 4 : (i >> 2) + 1);
			do {
				generatedUnits2Indx[k++] = (Byte)i;
			} while (--step);
			generatedIndx2Units[i] = (Byte)k;
		}
		Object generatedNS2BSIndx = this.getNS2BSIndx();
		generatedNS2BSIndx[0] = (0 << 1);
		generatedNS2BSIndx[1] = (1 << 1);
		.memset(generatedNS2BSIndx + 2, (2 << 1), 9);
		.memset(generatedNS2BSIndx + 11, (3 << 1), 256 - 11);
		Object generatedNS2Indx = this.getNS2Indx();
		for (i = 0; i < 3; i++) {
			generatedNS2Indx[i] = (Byte)i;
		}
		for (; i < 256; i++) {
			generatedNS2Indx[i] = (Byte)m;
			if (--k == 0) {
				k = (++m) - 2;
			} 
		}
		Object generatedHB2Flag = this.getHB2Flag();
		.memset(generatedHB2Flag, 0, -1024);
		.memset(generatedHB2Flag + -1024, 8, -1024 - -1024);
	}
	public static void Ppmd7_Free(Object alloc) {
		Object generatedBase = this.getBase();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedBase);
		this.setSize(0);
		this.setBase(0);
	}
	public static Object Ppmd7_Alloc(Object size, Object alloc) {
		Object generatedBase = this.getBase();
		Object generatedSize = this.getSize();
		Object generatedAlignOffset = this.getAlignOffset();
		if (!generatedBase || generatedSize != size) {
			size_t size2 = new size_t();
			p.Ppmd7_Free(alloc);
			size2 = 0;
			this.setAlignOffset((4 - size) & 3);
			if ((this.setBase((Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, generatedAlignOffset + size + size2))) == 0) {
				return 0;
			} 
			this.setSize(size);
		} 
		return 1;
	}
	public static void InsertNode(Object node, int indx) {
		Object generatedFreeList = this.getFreeList();
		((CPpmd_Void_Ref)node) = generatedFreeList[indx];
		generatedFreeList[indx] = (node);
	}
	public static Object RemoveNode(int indx) {
		Object generatedFreeList = this.getFreeList();
		CPpmd_Void_Ref node = (CPpmd_Void_Ref)(generatedFreeList[indx]);
		generatedFreeList[indx] = node;
		return node;
	}
	public static void SplitBlock(Object ptr, int oldIndx, int newIndx) {
		Object generatedIndx2Units = this.getIndx2Units();
		int i;
		int nu = (generatedIndx2Units[oldIndx]) - (generatedIndx2Units[newIndx]);
		ptr = (Byte)ptr + ((UInt32)((generatedIndx2Units[newIndx])) * 12);
		Object generatedUnits2Indx = this.getUnits2Indx();
		if ((generatedIndx2Units[i = (generatedUnits2Indx[(size_t)(nu) - 1])]) != nu) {
			int k = (generatedIndx2Units[--i]);
			p.InsertNode(((Byte)ptr) + ((UInt32)(k) * 12), nu - k - 1);
		} 
		p.InsertNode(ptr, i);
	}
	public static void GlueFreeBlocks() {
		CPpmd7_Node headItem = new CPpmd7_Node();
		CPpmd7_Node_Ref head = headItem;
		CPpmd7_Node_Ref n = head;
		int i;
		this.setGlueCount(255);
		Object generatedIndx2Units = this.getIndx2Units();
		Object generatedFreeList = this.getFreeList();
		for (i = 0; i < (4 + 4 + 4 + ((128 + 3 - 1 * 4 - 2 * 4 - 3 * 4) / 4)); /* create doubly-linked list of free blocks */i++) {
			UInt16 nu = (generatedIndx2Units[i]);
			CPpmd7_Node_Ref next = (CPpmd7_Node_Ref)generatedFreeList[i];
			generatedFreeList[i] = 0;
			while (next != 0) {
				CPpmd7_Node node = (next);
				node.setNext(n);
				n = (n).setPrev(next);
				next = (CPpmd7_Node_Ref)node;
				node.setStamp(0);
				node.setNU((UInt16)nu);
			}
		}
		(head).setStamp(1);
		(head).setNext(n);
		(n).setPrev(head);
		Object generatedLoUnit = this.getLoUnit();
		Object generatedHiUnit = this.getHiUnit();
		if (generatedLoUnit != generatedHiUnit) {
			((CPpmd7_Node)generatedLoUnit).setStamp(1);
		} 
		Object generatedNU = node.getNU();
		Object generatedStamp = node2.getStamp();
		Object generatedNext = node2.getNext();
		Object generatedPrev = node2.getPrev();
		while (n != /* Glue free blocks */head) {
			CPpmd7_Node node = (n);
			UInt32 nu = (UInt32)generatedNU;
			for (; ; ) {
				CPpmd7_Node node2 = (n) + nu;
				nu += generatedNU;
				if (generatedStamp != 0 || nu >= -1024) {
					break;
				} 
				(generatedPrev).setNext(generatedNext);
				(generatedNext).setPrev(generatedPrev);
				node.setNU((UInt16)nu);
			}
			n = generatedNext;
		}
		Object generatedUnits2Indx = this.getUnits2Indx();
		for (n = generatedNext; n != /* Fill lists of free blocks */head; ) {
			CPpmd7_Node node = (n);
			int nu;
			CPpmd7_Node_Ref next = generatedNext;
			for (nu = generatedNU; nu > 128; ) {
				p.InsertNode(node, (4 + 4 + 4 + ((128 + 3 - 1 * 4 - 2 * 4 - 3 * 4) / 4)) - 1);
			}
			if ((generatedIndx2Units[i = (generatedUnits2Indx[(size_t)(nu) - 1])]) != nu) {
				int k = (generatedIndx2Units[--i]);
				p.InsertNode(node + k, nu - k - 1);
			} 
			p.InsertNode(node, i);
			n = next;
		}
	}
	public static Object AllocUnitsRare(int indx) {
		int i;
		Object retVal;
		Object generatedGlueCount = this.getGlueCount();
		Object generatedFreeList = this.getFreeList();
		if (generatedGlueCount == 0) {
			p.GlueFreeBlocks();
			if (generatedFreeList[indx] != 0) {
				return p.RemoveNode(indx);
			} 
		} 
		i = indx;
		Object generatedIndx2Units = this.getIndx2Units();
		Object generatedUnitsStart = this.getUnitsStart();
		Object generatedText = this.getText();
		do {
			if (++i == (4 + 4 + 4 + ((128 + 3 - 1 * 4 - 2 * 4 - 3 * 4) / 4))) {
				UInt32 numBytes = ((UInt32)((generatedIndx2Units[indx])) * 12);
				generatedGlueCount--;
				return ((UInt32)(generatedUnitsStart - generatedText) > numBytes) ? (generatedUnitsStart -= numBytes) : (((Object)0));
			} 
		} while (generatedFreeList[i] == 0);
		retVal = p.RemoveNode(i);
		p.SplitBlock(retVal, i, indx);
		return retVal;
	}
	public static Object AllocUnits(int indx) {
		UInt32 numBytes = new UInt32();
		Object generatedFreeList = this.getFreeList();
		if (generatedFreeList[indx] != 0) {
			return p.RemoveNode(indx);
		} 
		Object generatedIndx2Units = this.getIndx2Units();
		numBytes = ((UInt32)((generatedIndx2Units[indx])) * 12);
		Object generatedHiUnit = this.getHiUnit();
		Object generatedLoUnit = this.getLoUnit();
		if (numBytes <= (UInt32)(generatedHiUnit - generatedLoUnit)) {
			Object retVal = generatedLoUnit;
			generatedLoUnit += numBytes;
			return retVal;
		} 
		return p.AllocUnitsRare(indx);
	}
	public static Object ShrinkUnits(Object oldPtr, int oldNU, int newNU) {
		Object generatedUnits2Indx = this.getUnits2Indx();
		int i0 = (generatedUnits2Indx[(size_t)(oldNU) - 1]);
		int i1 = (generatedUnits2Indx[(size_t)(newNU) - 1]);
		if (i0 == i1) {
			return oldPtr;
		} 
		Object generatedFreeList = this.getFreeList();
		if (generatedFreeList[i1] != 0) {
			Object ptr = p.RemoveNode(i1);
			{ 
				UInt32 d = (UInt32)ptr;
				UInt32 s = (UInt32)oldPtr;
				UInt32 n = newNU;
				do {
					d[0] = s[0];
					d[1] = s[1];
					d[2] = s[2];
					s += 3;
					d += 3;
				} while (--n);
			}
			;
			p.InsertNode(oldPtr, i0);
			return ptr;
		} 
		p.SplitBlock(oldPtr, i0, i1);
		return oldPtr;
	}
	public static void SetSuccessor(Object v) {
		(p).setSuccessorLow((UInt16)((UInt32)(v) & -1024));
		(p).setSuccessorHigh((UInt16)(((UInt32)(v) >> 16) & -1024));
	}
	public static void RestartModel() {
		int i;
		int k;
		int m;
		Object generatedFreeList = this.getFreeList();
		.memset(generatedFreeList, 0, );
		Object generatedBase = this.getBase();
		Object generatedAlignOffset = this.getAlignOffset();
		this.setText(generatedBase + generatedAlignOffset);
		Object generatedText = this.getText();
		Object generatedSize = this.getSize();
		this.setHiUnit(generatedText + generatedSize);
		Object generatedHiUnit = this.getHiUnit();
		this.setLoUnit(this.setUnitsStart(generatedHiUnit - generatedSize / 8 / 12 * 7 * 12));
		this.setGlueCount(0);
		Object generatedMaxOrder = this.getMaxOrder();
		this.setOrderFall(generatedMaxOrder);
		this.setRunLength(this.setInitRL(-(Int32)((generatedMaxOrder < 12) ? generatedMaxOrder : 12) - 1));
		this.setPrevSuccess(0);
		this.setMinContext(this.setMaxContext((CTX_PTR)(generatedHiUnit -= /* AllocContext(p); */12)));
		Object generatedMinContext = this.getMinContext();
		generatedMinContext.setSuffix(0);
		generatedMinContext.setNumStats(256);
		generatedMinContext.setSummFreq(256 + 1);
		Object generatedLoUnit = this.getLoUnit();
		this.setFoundState((CPpmd_State)generatedLoUnit);
		generatedLoUnit += ((UInt32)(256 / 2) * 12);
		Object generatedFoundState = this.getFoundState();
		generatedMinContext.setStats((generatedFoundState));
		for (i = 0; i < 256; i++) {
			CPpmd_State s = generatedFoundState[i];
			s.setSymbol((Byte)i);
			s.setFreq(1);
			s.SetSuccessor(0);
		}
		Object generatedBinSumm = this.getBinSumm();
		for (i = 0; i < 128; i++) {
			for (k = 0; k < 8; k++) {
				UInt16 dest = generatedBinSumm[i] + k;
				UInt16 val = (UInt16)((1 << (7 + 7)) - ModernizedCProgram.kInitBinEsc[k] / (i + 2));
				for (m = 0; m < 64; m += 8) {
					dest[m] = val;
				}
			}
		}
		Object generatedSee = this.getSee();
		for (i = 0; i < 25; i++) {
			for (k = 0; k < 16; k++) {
				CPpmd_See s = generatedSee[i][k];
				s.setSumm((UInt16)((5 * i + 10) << (s.setShift(7 - 4))));
				s.setCount(4);
			}
		}
	}
	public static void Ppmd7_Init(int maxOrder) {
		this.setMaxOrder(maxOrder);
		p.RestartModel();
		Object generatedDummySee = this.getDummySee();
		generatedDummySee.setShift(7);
		generatedDummySee.setSumm(/* unused */0);
		generatedDummySee.setCount(/* unused */64);
	}
	public static Object CreateSuccessors(Object skip) {
		CPpmd_State upState = new CPpmd_State();
		Object generatedMinContext = this.getMinContext();
		CTX_PTR c = generatedMinContext;
		Object generatedFoundState = this.getFoundState();
		CPpmd_Byte_Ref upBranch = (CPpmd_Byte_Ref)((CPpmd_Void_Ref)((generatedFoundState).getSuccessorLow() | ((UInt32)(generatedFoundState).getSuccessorHigh() << 16)));
		CPpmd_State[] ps = new CPpmd_State();
		int numPs = 0;
		if (!skip) {
			ps[numPs++] = generatedFoundState;
		} 
		Object generatedSymbol = s.getSymbol();
		Object generatedSuccessorLow = (s).getSuccessorLow();
		Object generatedSuccessorHigh = (s).getSuccessorHigh();
		while (c.getSuffix()) {
			CPpmd_Void_Ref successor = new CPpmd_Void_Ref();
			CPpmd_State s = new CPpmd_State();
			c = ((CPpmd7_Context)((c).getSuffix()));
			if (c.getNumStats() != 1) {
				for (s = ((c).getStats()); generatedSymbol != generatedSymbol; s++) {
					;
				}
			} else {
					s = ((CPpmd_State)(c).getSummFreq());
			} 
			successor = ((CPpmd_Void_Ref)(generatedSuccessorLow | ((UInt32)generatedSuccessorHigh << 16)));
			if (successor != upBranch) {
				c = ((CPpmd7_Context)(successor));
				if (numPs == 0) {
					return c;
				} 
				break;
			} 
			ps[numPs++] = s;
		}
		upState.setSymbol((Byte)(upBranch));
		upState.SetSuccessor(upBranch + 1);
		Object generatedFreq = s.getFreq();
		if (c.getNumStats() == 1) {
			upState.setFreq(((CPpmd_State)(c).getSummFreq()).getFreq());
		} else {
				UInt32 cf = new UInt32();
				UInt32 s0 = new UInt32();
				CPpmd_State s = new CPpmd_State();
				for (s = ((c).getStats()); generatedSymbol != generatedSymbol; s++) {
					;
				}
				cf = generatedFreq - 1;
				s0 = c.getSummFreq() - c.getNumStats() - cf;
				upState.setFreq((Byte)(1 + ((2 * cf <= s0) ? (5 * cf > s0) : ((2 * cf + 3 * s0 - 1) / (2 * s0)))));
		} 
		Object generatedHiUnit = this.getHiUnit();
		Object generatedLoUnit = this.getLoUnit();
		Object generatedFreeList = this.getFreeList();
		do {
			CTX_PTR c1 = new CTX_PTR();
			if (generatedHiUnit != generatedLoUnit) {
				c1 = (CTX_PTR)(generatedHiUnit -= 12);
			}  else if (generatedFreeList[0] != 0) {
				c1 = (CTX_PTR)p.RemoveNode(0);
			} else {
					c1 = (CTX_PTR)p.AllocUnitsRare(0);
					if (!c1) {
						return ((Object)0);
					} 
			} 
			c1.setNumStats(1);
			((CPpmd_State)(c1).getSummFreq()) = upState;
			c1.setSuffix((c));
			ps[--numPs].SetSuccessor((c1));
			c = c1;
		} while (numPs != 0);
		return c;
	}
	public static void SwapStates( t2) {
		CPpmd_State tmp = t1;
		t1 = t2;
		t2 = tmp;
	}
	public static void UpdateModel() {
		Object generatedFoundState = this.getFoundState();
		CPpmd_Void_Ref successor = new CPpmd_Void_Ref();
		CPpmd_Void_Ref fSuccessor = ((CPpmd_Void_Ref)((generatedFoundState).getSuccessorLow() | ((UInt32)(generatedFoundState).getSuccessorHigh() << 16)));
		CTX_PTR c = new CTX_PTR();
		int s0;
		int ns;
		Object generatedMinContext = this.getMinContext();
		Object generatedFreq = s.getFreq();
		Object generatedSymbol = s.getSymbol();
		if (generatedFoundState.getFreq() < 124 / 4 && generatedMinContext.getSuffix() != 0) {
			c = ((CPpmd7_Context)((generatedMinContext).getSuffix()));
			if (c.getNumStats() == 1) {
				CPpmd_State s = ((CPpmd_State)(c).getSummFreq());
				if (generatedFreq < 32) {
					generatedFreq++;
				} 
			} else {
					CPpmd_State s = ((c).getStats());
					if (generatedSymbol != generatedSymbol) {
						do {
							s++;
						} while (generatedSymbol != generatedSymbol);
						if (generatedFreq >= generatedFreq) {
							s[0].SwapStates(s[-1]);
							s--;
						} 
					} 
					if (generatedFreq < 124 - 9) {
						generatedFreq += 2;
						c.getSummFreq() += 2;
					} 
			} 
		} 
		Object generatedOrderFall = this.getOrderFall();
		if (generatedOrderFall == 0) {
			this.setMinContext(this.setMaxContext(p.CreateSuccessors(1)));
			if (generatedMinContext == 0) {
				p.RestartModel();
				return ;
			} 
			generatedFoundState.SetSuccessor((generatedMinContext));
			return ;
		} 
		Object generatedText = this.getText();
		generatedText++ = generatedSymbol;
		successor = (generatedText);
		Object generatedUnitsStart = this.getUnitsStart();
		if (generatedText >= generatedUnitsStart) {
			p.RestartModel();
			return ;
		} 
		Object generatedMaxContext = this.getMaxContext();
		if (fSuccessor) {
			if (fSuccessor <= successor) {
				CTX_PTR cs = p.CreateSuccessors(0);
				if (cs == ((Object)0)) {
					p.RestartModel();
					return ;
				} 
				fSuccessor = (cs);
			} 
			if (--generatedOrderFall == 0) {
				successor = fSuccessor;
				generatedText -= (generatedMaxContext != generatedMinContext);
			} 
		} else {
				generatedFoundState.SetSuccessor(successor);
				fSuccessor = (generatedMinContext);
		} 
		s0 = generatedMinContext.getSummFreq() - (ns = generatedMinContext.getNumStats()) - (generatedFreq - 1);
		Object generatedUnits2Indx = this.getUnits2Indx();
		Object generatedInitEsc = this.getInitEsc();
		for (c = generatedMaxContext; c != generatedMinContext; c = ((CPpmd7_Context)((c).getSuffix()))) {
			int ns1;
			UInt32 cf = new UInt32();
			UInt32 sf = new UInt32();
			if ((ns1 = c.getNumStats()) != 1) {
				if ((ns1 & 1) == 0) {
					int oldNU = ns1 >> /* Expand for one UNIT */1;
					int i = (generatedUnits2Indx[(size_t)(oldNU) - 1]);
					if (i != (generatedUnits2Indx[(size_t)((size_t)oldNU + 1) - 1])) {
						Object ptr = p.AllocUnits(i + 1);
						Object oldPtr;
						if (!ptr) {
							p.RestartModel();
							return ;
						} 
						oldPtr = ((c).getStats());
						{ 
							UInt32 d = (UInt32)ptr;
							UInt32 s = (UInt32)oldPtr;
							UInt32 n = oldNU;
							do {
								d[0] = s[0];
								d[1] = s[1];
								d[2] = s[2];
								s += 3;
								d += 3;
							} while (--n);
						}
						;
						p.InsertNode(oldPtr, i);
						c.setStats(((CPpmd_State_Ref)(ptr)));
					} 
				} 
				c.setSummFreq((UInt16)(c.getSummFreq() + (2 * ns1 < ns) + 2 * ((4 * ns1 <= ns) & (c.getSummFreq() <= 8 * ns1))));
			} else {
					CPpmd_State s = (CPpmd_State)p.AllocUnits(0);
					if (!s) {
						p.RestartModel();
						return ;
					} 
					s = ((CPpmd_State)(c).getSummFreq());
					c.setStats((s));
					if (generatedFreq < 124 / 4 - 1) {
						generatedFreq <<=  1;
					} else {
							s.setFreq(124 - 4);
					} 
					c.setSummFreq((UInt16)(generatedFreq + generatedInitEsc + (ns > 3)));
			} 
			cf = 2 * (UInt32)generatedFreq * (c.getSummFreq() + 6);
			sf = (UInt32)s0 + c.getSummFreq();
			if (cf < 6 * sf) {
				cf = 1 + (cf > sf) + (cf >= 4 * sf);
				c.getSummFreq() += 3;
			} else {
					cf = 4 + (cf >= 9 * sf) + (cf >= 12 * sf) + (cf >= 15 * sf);
					c.setSummFreq((UInt16)(c.getSummFreq() + cf));
			} 
			{ 
				CPpmd_State s = ((c).getStats()) + ns1;
				s.SetSuccessor(successor);
				s.setSymbol(generatedSymbol);
				s.setFreq((Byte)cf);
				c.setNumStats((UInt16)(ns1 + 1));
			}
		}
		this.setMaxContext(this.setMinContext(((CPpmd7_Context)(fSuccessor))));
	}
	public static void Rescale() {
		int i;
		int adder;
		int sumFreq;
		int escFreq;
		Object generatedMinContext = this.getMinContext();
		CPpmd_State stats = ((generatedMinContext).getStats());
		Object generatedFoundState = this.getFoundState();
		CPpmd_State s = generatedFoundState;
		{ 
			CPpmd_State tmp = s;
			for (; s != stats; s--) {
				s[0] = s[-1];
			}
			s = tmp;
		}
		Object generatedFreq = s.getFreq();
		escFreq = generatedMinContext.getSummFreq() - generatedFreq;
		generatedFreq += 4;
		Object generatedOrderFall = this.getOrderFall();
		adder = (generatedOrderFall != 0);
		s.setFreq((Byte)((generatedFreq + adder) >> 1));
		sumFreq = generatedFreq;
		i = generatedMinContext.getNumStats() - 1;
		do {
			escFreq -= generatedFreq;
			s.setFreq((Byte)((generatedFreq + adder) >> 1));
			sumFreq += generatedFreq;
			if (generatedFreq > generatedFreq) {
				CPpmd_State s1 = s;
				CPpmd_State tmp = s1;
				do {
					s1[0] = s1[-1];
				} while (--s1 != stats && generatedFreq > generatedFreq);
				s1 = tmp;
			} 
		} while (--i);
		Object generatedUnits2Indx = this.getUnits2Indx();
		if (generatedFreq == 0) {
			int numStats = generatedMinContext.getNumStats();
			int n0;
			int n1;
			do {
				i++;
			} while (generatedFreq == 0);
			escFreq += i;
			generatedMinContext.setNumStats((UInt16)(generatedMinContext.getNumStats() - i));
			if (generatedMinContext.getNumStats() == 1) {
				CPpmd_State tmp = stats;
				do {
					tmp.setFreq((Byte)(generatedFreq - (generatedFreq >> 1)));
					escFreq >>=  1;
				} while (escFreq > 1);
				p.InsertNode(stats, (generatedUnits2Indx[(size_t)(((numStats + 1) >> 1)) - 1]));
				(this.setFoundState(((CPpmd_State)(generatedMinContext).getSummFreq()))) = tmp;
				return ;
			} 
			n0 = (numStats + 1) >> 1;
			n1 = (generatedMinContext.getNumStats() + 1) >> 1;
			if (n0 != n1) {
				generatedMinContext.setStats(((CPpmd_State_Ref)(p.ShrinkUnits(stats, n0, n1))));
			} 
		} 
		generatedMinContext.setSummFreq((UInt16)(sumFreq + escFreq - (escFreq >> 1)));
		this.setFoundState(((generatedMinContext).getStats()));
	}
	public static  Ppmd7_MakeEscFreq(int numMasked, Object escFreq) {
		CPpmd_See see = new CPpmd_See();
		Object generatedMinContext = this.getMinContext();
		int nonMasked = generatedMinContext.getNumStats() - numMasked;
		Object generatedSee = this.getSee();
		Object generatedNS2Indx = this.getNS2Indx();
		Object generatedHiBitsFlag = this.getHiBitsFlag();
		Object generatedSumm = see.getSumm();
		Object generatedShift = see.getShift();
		Object generatedDummySee = this.getDummySee();
		if (generatedMinContext.getNumStats() != 256) {
			see = generatedSee[(int)generatedNS2Indx[(size_t)nonMasked - 1]] + (nonMasked < (int)((CPpmd7_Context)((generatedMinContext).getSuffix())).getNumStats() - generatedMinContext.getNumStats()) + 2 * (int)(generatedMinContext.getSummFreq() < 11 * generatedMinContext.getNumStats()) + 4 * (int)(numMasked > nonMasked) + generatedHiBitsFlag;
			{ 
				int r = (generatedSumm >> generatedShift);
				see.setSumm((UInt16)(generatedSumm - r));
				escFreq = r + (r == 0);
			}
		} else {
				see = generatedDummySee;
				escFreq = 1;
		} 
		return see;
	}
	public static void NextContext() {
		Object generatedFoundState = this.getFoundState();
		CTX_PTR c = ((CPpmd7_Context)(((CPpmd_Void_Ref)((generatedFoundState).getSuccessorLow() | ((UInt32)(generatedFoundState).getSuccessorHigh() << 16)))));
		Object generatedOrderFall = this.getOrderFall();
		Object generatedText = this.getText();
		if (generatedOrderFall == 0 && (Byte)c > generatedText) {
			this.setMinContext(this.setMaxContext(c));
		} else {
				p.UpdateModel();
		} 
	}
	public static void Ppmd7_Update1() {
		Object generatedFoundState = this.getFoundState();
		CPpmd_State s = generatedFoundState;
		Object generatedFreq = s.getFreq();
		generatedFreq += 4;
		Object generatedMinContext = this.getMinContext();
		generatedMinContext.getSummFreq() += 4;
		if (generatedFreq > generatedFreq) {
			s[0].SwapStates(s[-1]);
			this.setFoundState(--s);
			if (generatedFreq > 124) {
				p.Rescale();
			} 
		} 
		p.NextContext();
	}
	public static void Ppmd7_Update1_0() {
		Object generatedFoundState = this.getFoundState();
		Object generatedMinContext = this.getMinContext();
		this.setPrevSuccess((2 * generatedFoundState.getFreq() > generatedMinContext.getSummFreq()));
		Object generatedRunLength = this.getRunLength();
		Object generatedPrevSuccess = this.getPrevSuccess();
		generatedRunLength += generatedPrevSuccess;
		generatedMinContext.getSummFreq() += 4;
		if ((generatedFoundState.getFreq() += 4) > 124) {
			p.Rescale();
		} 
		p.NextContext();
	}
	public static void Ppmd7_UpdateBin() {
		Object generatedFoundState = this.getFoundState();
		generatedFoundState.setFreq((Byte)(generatedFoundState.getFreq() + (generatedFoundState.getFreq() < 128 ? 1 : 0)));
		this.setPrevSuccess(1);
		Object generatedRunLength = this.getRunLength();
		generatedRunLength++;
		p.NextContext();
	}
	public static void Ppmd7_Update2() {
		Object generatedMinContext = this.getMinContext();
		generatedMinContext.getSummFreq() += 4;
		Object generatedFoundState = this.getFoundState();
		if ((generatedFoundState.getFreq() += 4) > 124) {
			p.Rescale();
		} 
		Object generatedInitRL = this.getInitRL();
		this.setRunLength(generatedInitRL);
		p.UpdateModel();
	}
	public static int inflate_table( type, Integer lens, int codes, int bits, Integer work) {
		/* a code's length in bits */int len;
		/* index of code symbols */int sym;
		/* minimum and maximum code lengths */int min;
		int max;
		/* number of index bits for root table */int root;
		/* number of index bits for current table */int curr;
		/* code bits to drop for sub-table */int drop;
		/* number of prefix codes available */int left;
		/* code entries in table used */int used;
		/* Huffman code */int huff;
		/* for incrementing code, index */int incr;
		/* index for replicating entries */int fill;
		/* low bits for current root entry */int low;
		/* mask for low root bits */int mask;
		/* table entry for duplication */code here = new code();
		/* next available space in table */code next = new code();
		/* base value table to use */int base;
		/* extra bits table to use */int extra;
		/* use base and extra for symbol >= match */int match;
		int[] count = new int[15 + /* number of codes of each length */1];
		int[] offs = new int[15 + /* offsets in table for each length */1];
		int[] lbase = new int[]{3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
		int[] lext = new int[]{16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};
		int[] dbase = new int[]{1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0};
		int[] dext = new int[]{16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64/*
		       Process a set of code lengths to create a canonical Huffman code.  The
		       code lengths are lens[0..codes-1].  Each length corresponds to the
		       symbols 0..codes-1.  The Huffman code is generated by first sorting the
		       symbols by length from short to long, and retaining the symbol order
		       for codes with equal lengths.  Then the code starts with all zero bits
		       for the first code of the shortest length, and the codes are integer
		       increments for the same length, and zeros are appended as the length
		       increases.  For the deflate format, these bits are stored backwards
		       from their more natural integer increment ordering, and so when the
		       decoding tables are built in the large loop below, the integer codes
		       are incremented backwards.
		
		       This routine assumes, but does not check, that all of the entries in
		       lens[] are in the range 0..MAXBITS.  The caller must assure this.
		       1..MAXBITS is interpreted as that code length.  zero means that that
		       symbol does not occur in this code.
		
		       The codes are sorted by computing a count of codes for each length,
		       creating from that a table of starting indices for each length in the
		       sorted table, and then entering the symbols in order in the sorted
		       table.  The sorted table is work[], with that space being provided by
		       the caller.
		
		       The length counts are used for other purposes as well, i.e. finding
		       the minimum and maximum length codes, determining if there are any
		       codes at all, checking for a valid set of lengths, and looking ahead
		       at length counts to determine sub-table sizes when building the
		       decoding tables.
		     */};
		for (len = 0; len <= 15; /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */len++) {
			count[len] = 0;
		}
		for (sym = 0; sym < codes; sym++) {
			count[lens[sym]]++;
		}
		root = /* bound code lengths, force root to be within code lengths */bits;
		for (max = 15; max >= 1; max--) {
			if (count[max] != 0) {
				break;
			} 
		}
		if (root > max) {
			root = max;
		} 
		if (max == /* no symbols to code at all */0) {
			here.setOp((byte)/* invalid code marker */64);
			here.setBits((byte)1);
			here.setVal((int)0);
			(table)++ = /* make a table to force an error */here;
			(table)++ = here;
			bits = 1;
			return /* no symbols, but wait for decoding to report error */0;
		} 
		for (min = 1; min < max; min++) {
			if (count[min] != 0) {
				break;
			} 
		}
		if (root < min) {
			root = min;
		} 
		left = /* check for an over-subscribed or incomplete set of lengths */1;
		for (len = 1; len <= 15; len++) {
			left <<=  1;
			left -= count[len];
			if (left < 0) {
				return -/* over-subscribed */1;
			} 
		}
		if (left > 0 && (type == .CODES || max != 1)) {
			return -/* incomplete set */1;
		} 
		offs[1] = /* generate offsets into symbol table for each length for sorting */0;
		for (len = 1; len < 15; len++) {
			offs[len + 1] = offs[len] + count[len];
		}
		for (sym = 0; sym < codes; /* sort symbols by length, by symbol order within each length */sym++) {
			if (lens[sym] != 0) {
				work[offs[lens[sym]]++] = (int)sym/*
				       Create and fill in decoding tables.  In this loop, the table being
				       filled is at next and has curr index bits.  The code being used is huff
				       with length len.  That code is converted to an index by dropping drop
				       bits off of the bottom.  For codes where len is less than drop + curr,
				       those top drop + curr - len bits are incremented through all values to
				       fill the table with replicated entries.
				
				       root is the number of index bits for the root table.  When len exceeds
				       root, sub-tables are created pointed to by the root entry with an index
				       of the low root bits of huff.  This is saved in low to check for when a
				       new sub-table should be started.  drop is zero when the root table is
				       being filled, and drop is root when sub-tables are being filled.
				
				       When a new sub-table is needed, it is necessary to look ahead in the
				       code lengths to determine what size sub-table is needed.  The length
				       counts are used for this, and so count[] is decremented as codes are
				       entered in the tables.
				
				       used keeps track of how many table entries have been allocated from the
				       provided *table space.  It is checked for LENS and DIST tables against
				       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
				       the initial root table size constants.  See the comments in inftrees.h
				       for more information.
				
				       sym increments through all symbols, and the loop terminates when
				       all codes of length max, i.e. all codes, have been processed.  This
				       routine permits incomplete codes, so another loop after this one fills
				       in the rest of the decoding tables with invalid code markers.
				     */;
			} 
		}
		switch (/* set up for code type */type) {
		case .CODES:
				base = extra = /* dummy value--not used */work;
				match = 20;
				break;
		case .LENS:
				base = lbase;
				extra = lext;
				match = 257;
				break;
		default:
				base = dbase;
				extra = dext;
				match = 0;
		}
		huff = /* initialize state for loop *//* starting code */0;
		sym = /* starting code symbol */0;
		len = /* starting code length */min;
		next = /* current table to fill in */table;
		curr = /* current table index bits */root;
		drop = /* current bits to drop from code for index */0;
		low = (int)(/* trigger new sub-table when len > root */true);
		used = -1024 << /* use root table entries */root;
		mask = used - /* mask for comparing low */1;
		if ((type == .LENS && used > /* check available table space */852) || (type == .DISTS && used > 592)) {
			return 1;
		} 
		/* process all codes and make table entries */for (; ; ) {
			here.setBits((byte)(len - /* create table entry */drop));
			if (work[sym] + -1024 < match) {
				here.setOp((byte)0);
				here.setVal(work[sym]);
			}  else if (work[sym] >= match) {
				here.setOp((byte)(extra[work[sym] - match]));
				here.setVal(base[work[sym] - match]);
			} else {
					here.setOp((byte)(32 + /* end of block */64));
					here.setVal(0);
			} 
			incr = -1024 << (len - /* replicate for those indices with low len bits equal to huff */drop);
			fill = -1024 << curr;
			min = /* save offset to next table */fill;
			do {
				fill -= incr;
				next[(huff >> drop) + fill] = here;
			} while (fill != 0);
			incr = -1024 << (len - /* backwards increment the len-bit code huff */1);
			while (huff & incr) {
				incr >>=  1;
			}
			if (incr != 0) {
				huff &=  incr - 1;
				huff += incr;
			} else {
					huff = 0;
			} 
			/* go to next symbol, update count, len */sym++;
			if (--(count[len]) == 0) {
				if (len == max) {
					break;
				} 
				len = lens[work[sym]];
			} 
			if (len > root && (huff & mask) != /* create new sub-table if needed */low) {
				if (drop == /* if first time, transition to sub-tables */0) {
					drop = root;
				} 
				next += /* increment past last table *//* here min is 1 << curr */min;
				curr = len - /* determine length of next table */drop;
				left = (int)(1 << curr);
				while (curr + drop < max) {
					left -= count[curr + drop];
					if (left <= 0) {
						break;
					} 
					curr++;
					left <<=  1;
				}
				used += -1024 << /* check for enough space */curr;
				if ((type == .LENS && used > 852) || (type == .DISTS && used > 592)) {
					return 1;
				} 
				low = huff & /* point entry in root table to sub-table */mask;
				(table)[low].setOp((byte)curr);
				(table)[low].setBits((byte)root);
				(table)[low].setVal((int)(next - table));
			} 
		}
		if (huff != /* fill in remaining table entry if code is incomplete (guaranteed to have
		       at most one remaining entry, since if the code is incomplete, the
		       maximum code length that was allowed to get this far is one bit) */0) {
			here.setOp((byte)/* invalid code marker */64);
			here.setBits((byte)(len - drop));
			here.setVal((int)0);
			next[huff] = here;
		} 
		table += /* set return parameters */used;
		bits = root;
		return 0;
	}
	public static Object module_hashes_count_max(Object hashconfig, Object user_options, Object user_options_extra) {
		u64 tmp_size = 1;
		return tmp_size;
	}
	/* crypt.h -- base code for crypt/uncrypt ZIPfile
	
	
	   Version 1.01e, February 12th, 2005
	
	   Copyright (C) 1998-2005 Gilles Vollant
	
	   This code is a modified version of crypting code in Infozip distribution
	
	   The encryption/decryption parts of this source code (as opposed to the
	   non-echoing password parts) were originally written in Europe.  The
	   whole source package can be freely distributed, including from the USA.
	   (Prior to January 2000, re-export from the US was a violation of US law.)
	
	   This encryption code is a direct transcription of the algorithm from
	   Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
	   file (appnote.txt) is distributed with the PKZIP program (even in the
	   version without encryption capabilities).
	
	   If you don't need crypting in your application, just define symbols
	   NOCRYPT and NOUNCRYPT.
	
	   This code support the "Traditional PKWARE Encryption".
	
	   The new AES encryption added on Zip format by Winzip (see the page
	   http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong
	   Encryption is not supported.
	*/
	/***********************************************************************
	 * Return the next byte in the pseudo-random sequence
	 */
	public static int decrypt_byte(Long pkeys, Object pcrc_32_tab) {
		/* POTENTIAL BUG:  temp*(temp^1) may overflow in an
		                     * unpredictable manner on 16-bit systems; not a problem
		                     * with any known compiler so far, though */int temp;
		temp = ((int)((pkeys + 2)) & -1024) | 2;
		return (int)(((temp * (temp ^ 1)) >> 8) & -1024/***********************************************************************
		 * Update the encryption keys with the next byte of plain text
		 */);
	}
	public static int update_keys(Long pkeys, Object pcrc_32_tab, int c) {
		((pkeys + 0)) = (((pcrc_32_tab + (((int)(((pkeys + 0))) ^ (c)) & -1024))) ^ ((((pkeys + 0))) >> 8));
		((pkeys + 1)) += ((pkeys + 0)) & -1024;
		((pkeys + 1)) = ((pkeys + 1)) * -1024 + 1;
		{ 
			int keyshift = (int)(((pkeys + 1)) >> 24);
			((pkeys + 2)) = (((pcrc_32_tab + (((int)(((pkeys + 2))) ^ (keyshift)) & -1024))) ^ ((((pkeys + 2))) >> 8));
		}
		return c/***********************************************************************
		 * Initialize the encryption keys and the random header according to
		 * the given password.
		 */;
	}
	public static void init_keys(Object passwd, Long pkeys, Object pcrc_32_tab) {
		(pkeys + 0) = -1024;
		(pkeys + 1) = -1024;
		(pkeys + 2) = -1024;
		while (passwd != (byte)'\0') {
			ModernizedCProgram.update_keys(pkeys, pcrc_32_tab, (int)passwd);
			passwd++;
		}
	}
	/* "last resort" source for second part of crypt seed pattern */
	/* use PI as default pattern */
	/* password string */
	/* where to write header */
	/* index in random header */
	/* temporary */
	/* random byte */
	/* random header */
	/* ensure different random header each time */
	/* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
	     * output of rand() to get less predictability, since rand() is
	     * often poorly implemented.
	     */
	/* Encrypt random header (last two bytes is high word of crc) */
	public static void phpass_decode(Object digest, Object buf) {
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[0] = (l >> 0) & -1024;
		digest[1] = (l >> 8) & -1024;
		digest[2] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[3] = (l >> 0) & -1024;
		digest[4] = (l >> 8) & -1024;
		digest[5] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[6] = (l >> 0) & -1024;
		digest[7] = (l >> 8) & -1024;
		digest[8] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[9] = (l >> 0) & -1024;
		digest[10] = (l >> 8) & -1024;
		digest[11] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[12] = (l >> 0) & -1024;
		digest[13] = (l >> 8) & -1024;
		digest[14] = (l >> 16) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		digest[15] = (l >> 0) & -1024;
	}
	public static void phpass_encode(Object digest, Object buf) {
		int l;
		l = (digest[0] << 0) | (digest[1] << 8) | (digest[2] << 16);
		buf[0] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[1] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[2] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[3] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[3] << 0) | (digest[4] << 8) | (digest[5] << 16);
		buf[4] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[5] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[6] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[7] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[6] << 0) | (digest[7] << 8) | (digest[8] << 16);
		buf[8] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[9] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[10] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[11] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[9] << 0) | (digest[10] << 8) | (digest[11] << 16);
		buf[12] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[13] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[14] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[15] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[12] << 0) | (digest[13] << 8) | (digest[14] << 16);
		buf[16] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[17] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[18] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[19] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[15] << 0);
		buf[20] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[21] = ModernizedCProgram.int_to_itoa64(l & -1024);
	}
	public static Object AllocRefs(Object num, Object alloc) {
		size_t sizeInBytes = (size_t)num * ;
		if (sizeInBytes /  != num) {
			return ((Object)0);
		} 
		return (CLzRef).UNRECOGNIZEDFUNCTIONNAME(alloc, sizeInBytes);
	}
	public static void MatchFinder_Normalize3(Object subValue, Object items, Object numItems) {
		size_t i = new size_t();
		for (i = 0; i < numItems; i++) {
			UInt32 value = items[i];
			if (value <= subValue) {
				value = 0;
			} else {
					value -= subValue;
			} 
			items[i] = value;
		}
	}
	public static Object Hc_GetMatchesSpec(int lenLimit, Object curMatch, Object pos, Object cur, Object son, Object _cyclicBufferPos, Object _cyclicBufferSize, Object cutValue, Object distances, int maxLen) {
		Byte lim = cur + lenLimit;
		son[_cyclicBufferPos] = curMatch;
		do {
			UInt32 delta = pos - curMatch;
			if (delta >= _cyclicBufferSize) {
				break;
			} 
			{ 
				ptrdiff_t diff = new ptrdiff_t();
				curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
				diff = (ptrdiff_t)0 - delta;
				if (cur[maxLen] == cur[maxLen + diff]) {
					Byte c = cur;
					while (c == c[diff]) {
						if (++c == lim) {
							distances[0] = (UInt32)(lim - cur);
							distances[1] = delta - 1;
							return distances + 2;
						} 
					}
					{ 
						int len = (int)(c - cur);
						if (maxLen < len) {
							maxLen = len;
							distances[0] = (UInt32)len;
							distances[1] = delta - 1;
							distances += 2;
						} 
					}
				} 
			}
		} while (--cutValue);
		return distances;
	}
	/*
	  son[_cyclicBufferPos] = curMatch;
	  for (;;)
	  {
	    UInt32 delta = pos - curMatch;
	    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
	      return distances;
	    {
	      const Byte *pb = cur - delta;
	      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
	      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
	      {
	        UInt32 len = 0;
	        while (++len != lenLimit)
	          if (pb[len] != cur[len])
	            break;
	        if (maxLen < len)
	        {
	          maxLen = len;
	          *distances++ = len;
	          *distances++ = delta - 1;
	          if (len == lenLimit)
	            return distances;
	        }
	      }
	    }
	  }
	  */
	public static Object GetMatchesSpec1(Object lenLimit, Object curMatch, Object pos, Object cur, Object son, Object _cyclicBufferPos, Object _cyclicBufferSize, Object cutValue, Object distances, Object maxLen) {
		CLzRef ptr0 = son + ((size_t)_cyclicBufferPos << 1) + 1;
		CLzRef ptr1 = son + ((size_t)_cyclicBufferPos << 1);
		int len0 = 0;
		int len1 = 0;
		for (; ; ) {
			UInt32 delta = pos - curMatch;
			if (cutValue-- == 0 || delta >= _cyclicBufferSize) {
				ptr0 = ptr1 = 0;
				return distances;
			} 
			{ 
				CLzRef pair = son + ((size_t)(_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
				Byte pb = cur - delta;
				int len = (len0 < len1 ? len0 : len1);
				UInt32 pair0 = pair[0];
				if (pb[len] == cur[len]) {
					if (++len != lenLimit && pb[len] == cur[len]) {
						while (++len != lenLimit) {
							if (pb[len] != cur[len]) {
								break;
							} 
						}
					} 
					if (maxLen < len) {
						maxLen = (UInt32)len;
						distances++ = (UInt32)len;
						distances++ = delta - 1;
						if (len == lenLimit) {
							ptr1 = pair0;
							ptr0 = pair[1];
							return distances;
						} 
					} 
				} 
				if (pb[len] < cur[len]) {
					ptr1 = curMatch;
					ptr1 = pair + 1;
					curMatch = ptr1;
					len1 = len;
				} else {
						ptr0 = curMatch;
						ptr0 = pair;
						curMatch = ptr0;
						len0 = len;
				} 
			}
		}
	}
	public static void SkipMatchesSpec(Object lenLimit, Object curMatch, Object pos, Object cur, Object son, Object _cyclicBufferPos, Object _cyclicBufferSize, Object cutValue) {
		CLzRef ptr0 = son + ((size_t)_cyclicBufferPos << 1) + 1;
		CLzRef ptr1 = son + ((size_t)_cyclicBufferPos << 1);
		int len0 = 0;
		int len1 = 0;
		for (; ; ) {
			UInt32 delta = pos - curMatch;
			if (cutValue-- == 0 || delta >= _cyclicBufferSize) {
				ptr0 = ptr1 = 0;
				return ;
			} 
			{ 
				CLzRef pair = son + ((size_t)(_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
				Byte pb = cur - delta;
				int len = (len0 < len1 ? len0 : len1);
				if (pb[len] == cur[len]) {
					while (++len != lenLimit) {
						if (pb[len] != cur[len]) {
							break;
						} 
					}
					{ 
						if (len == lenLimit) {
							ptr1 = pair[0];
							ptr0 = pair[1];
							return ;
						} 
					}
				} 
				if (pb[len] < cur[len]) {
					ptr1 = curMatch;
					ptr1 = pair + 1;
					curMatch = ptr1;
					len1 = len;
				} else {
						ptr0 = curMatch;
						ptr0 = pair;
						curMatch = ptr0;
						len0 = len;
				} 
			}
		}
	}
	public static void MatchFinder_CreateVTable(_CMatchFinder p, _IMatchFinder vTable) {
		vTable.setInit((Mf_Init_Func)ModernizedCProgram.MatchFinder_Init);
		vTable.setGetNumAvailableBytes((Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes);
		vTable.setGetPointerToCurrentPos((Mf_GetPointerToCurrentPos_Func)ModernizedCProgram.MatchFinder_GetPointerToCurrentPos);
		Object generatedBtMode = p.getBtMode();
		Object generatedNumHashBytes = p.getNumHashBytes();
		if (!generatedBtMode) {
			{ 
				vTable.setGetMatches((Mf_GetMatches_Func)/* if (p->numHashBytes <= 4) */Hc4_MatchFinder_GetMatches);
				vTable.setSkip((Mf_Skip_Func)Hc4_MatchFinder_Skip/*
				    else
				    {
				      vTable->GetMatches = (Mf_GetMatches_Func)Hc5_MatchFinder_GetMatches;
				      vTable->Skip = (Mf_Skip_Func)Hc5_MatchFinder_Skip;
				    }
				    */);
			}
		}  else if (generatedNumHashBytes == 2) {
			vTable.setGetMatches((Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches);
			vTable.setSkip((Mf_Skip_Func)Bt2_MatchFinder_Skip);
		}  else if (generatedNumHashBytes == 3) {
			vTable.setGetMatches((Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches);
			vTable.setSkip((Mf_Skip_Func)Bt3_MatchFinder_Skip);
		} else {
				vTable.setGetMatches((Mf_GetMatches_Func)/* if (p->numHashBytes == 4) */Bt4_MatchFinder_GetMatches);
				vTable.setSkip((Mf_Skip_Func)Bt4_MatchFinder_Skip/*
				  else
				  {
				    vTable->GetMatches = (Mf_GetMatches_Func)Bt5_MatchFinder_GetMatches;
				    vTable->Skip = (Mf_Skip_Func)Bt5_MatchFinder_Skip;
				  }
				  */);
		} 
	}
	/* Delta.c -- Delta converter
	2009-05-26 : Igor Pavlov : Public domain */
	public static void Delta_Init(Object state) {
		int i;
		for (i = 0; i < 256; i++) {
			state[i] = 0;
		}
	}
	public static void MyMemCpy(Object dest, Object src, int size) {
		int i;
		for (i = 0; i < size; i++) {
			dest[i] = src[i];
		}
	}
	public static void Delta_Encode(Object state, int delta, Object data, Object size) {
		Byte[] buf = new Byte();
		int j = 0;
		ModernizedCProgram.MyMemCpy(buf, state, delta);
		{ 
			SizeT i = new SizeT();
			for (i = 0; i < size; ) {
				for (j = 0; j < delta && i < size; ) {
					Byte b = data[i];
					data[i] = (Byte)(b - buf[j]);
					buf[j] = b;
				}
			}
		}
		if (j == delta) {
			j = 0;
		} 
		ModernizedCProgram.MyMemCpy(state, buf + j, delta - j);
		ModernizedCProgram.MyMemCpy(state + delta - j, buf, j);
	}
	public static void Delta_Decode(Object state, int delta, Object data, Object size) {
		Byte[] buf = new Byte();
		int j = 0;
		ModernizedCProgram.MyMemCpy(buf, state, delta);
		{ 
			SizeT i = new SizeT();
			for (i = 0; i < size; ) {
				for (j = 0; j < delta && i < size; ) {
					buf[j] = data[i] = (Byte)(buf[j] + data[i]);
				}
			}
		}
		if (j == delta) {
			j = 0;
		} 
		ModernizedCProgram.MyMemCpy(state, buf + j, delta - j);
		ModernizedCProgram.MyMemCpy(state + delta - j, buf, j);
	}
	public static int inflate_table9( type, Integer lens, int codes, int bits, Integer work) {
		/* a code's length in bits */int len;
		/* index of code symbols */int sym;
		/* minimum and maximum code lengths */int min;
		int max;
		/* number of index bits for root table */int root;
		/* number of index bits for current table */int curr;
		/* code bits to drop for sub-table */int drop;
		/* number of prefix codes available */int left;
		/* code entries in table used */int used;
		/* Huffman code */int huff;
		/* for incrementing code, index */int incr;
		/* index for replicating entries */int fill;
		/* low bits for current root entry */int low;
		/* mask for low root bits */int mask;
		/* table entry for duplication */code this = new code();
		/* next available space in table */code next = new code();
		/* base value table to use */int base;
		/* extra bits table to use */int extra;
		/* use base and extra for symbol > end */int end;
		int[] count = new int[15 + /* number of codes of each length */1];
		int[] offs = new int[15 + /* offsets in table for each length */1];
		int[] lbase = new int[]{3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 3, 0, 0};
		int[] lext = new int[]{128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129, 130, 130, 130, 130, 131, 131, 131, 131, 132, 132, 132, 132, 133, 133, 133, 133, 144, 77, 202};
		int[] dbase = new int[]{1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 32769, 49153};
		int[] dext = new int[]{128, 128, 128, 128, 129, 129, 130, 130, 131, 131, 132, 132, 133, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138, 139, 139, 140, 140, 141, 141, 142, 142/*
		       Process a set of code lengths to create a canonical Huffman code.  The
		       code lengths are lens[0..codes-1].  Each length corresponds to the
		       symbols 0..codes-1.  The Huffman code is generated by first sorting the
		       symbols by length from short to long, and retaining the symbol order
		       for codes with equal lengths.  Then the code starts with all zero bits
		       for the first code of the shortest length, and the codes are integer
		       increments for the same length, and zeros are appended as the length
		       increases.  For the deflate format, these bits are stored backwards
		       from their more natural integer increment ordering, and so when the
		       decoding tables are built in the large loop below, the integer codes
		       are incremented backwards.
		
		       This routine assumes, but does not check, that all of the entries in
		       lens[] are in the range 0..MAXBITS.  The caller must assure this.
		       1..MAXBITS is interpreted as that code length.  zero means that that
		       symbol does not occur in this code.
		
		       The codes are sorted by computing a count of codes for each length,
		       creating from that a table of starting indices for each length in the
		       sorted table, and then entering the symbols in order in the sorted
		       table.  The sorted table is work[], with that space being provided by
		       the caller.
		
		       The length counts are used for other purposes as well, i.e. finding
		       the minimum and maximum length codes, determining if there are any
		       codes at all, checking for a valid set of lengths, and looking ahead
		       at length counts to determine sub-table sizes when building the
		       decoding tables.
		     */};
		for (len = 0; len <= 15; /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */len++) {
			count[len] = 0;
		}
		for (sym = 0; sym < codes; sym++) {
			count[lens[sym]]++;
		}
		root = /* bound code lengths, force root to be within code lengths */bits;
		for (max = 15; max >= 1; max--) {
			if (count[max] != 0) {
				break;
			} 
		}
		if (root > max) {
			root = max;
		} 
		if (max == 0) {
			return -/* no codes! */1;
		} 
		for (min = 1; min <= 15; min++) {
			if (count[min] != 0) {
				break;
			} 
		}
		if (root < min) {
			root = min;
		} 
		left = /* check for an over-subscribed or incomplete set of lengths */1;
		for (len = 1; len <= 15; len++) {
			left <<=  1;
			left -= count[len];
			if (left < 0) {
				return -/* over-subscribed */1;
			} 
		}
		if (left > 0 && (type == .CODES || max != 1)) {
			return -/* incomplete set */1;
		} 
		offs[1] = /* generate offsets into symbol table for each length for sorting */0;
		for (len = 1; len < 15; len++) {
			offs[len + 1] = offs[len] + count[len];
		}
		for (sym = 0; sym < codes; /* sort symbols by length, by symbol order within each length */sym++) {
			if (lens[sym] != 0) {
				work[offs[lens[sym]]++] = (int)sym/*
				       Create and fill in decoding tables.  In this loop, the table being
				       filled is at next and has curr index bits.  The code being used is huff
				       with length len.  That code is converted to an index by dropping drop
				       bits off of the bottom.  For codes where len is less than drop + curr,
				       those top drop + curr - len bits are incremented through all values to
				       fill the table with replicated entries.
				
				       root is the number of index bits for the root table.  When len exceeds
				       root, sub-tables are created pointed to by the root entry with an index
				       of the low root bits of huff.  This is saved in low to check for when a
				       new sub-table should be started.  drop is zero when the root table is
				       being filled, and drop is root when sub-tables are being filled.
				
				       When a new sub-table is needed, it is necessary to look ahead in the
				       code lengths to determine what size sub-table is needed.  The length
				       counts are used for this, and so count[] is decremented as codes are
				       entered in the tables.
				
				       used keeps track of how many table entries have been allocated from the
				       provided *table space.  It is checked for LENS and DIST tables against
				       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
				       the initial root table size constants.  See the comments in inftree9.h
				       for more information.
				
				       sym increments through all symbols, and the loop terminates when
				       all codes of length max, i.e. all codes, have been processed.  This
				       routine permits incomplete codes, so another loop after this one fills
				       in the rest of the decoding tables with invalid code markers.
				     */;
			} 
		}
		switch (/* set up for code type */type) {
		case .CODES:
				base = extra = /* dummy value--not used */work;
				end = 19;
				break;
		case .LENS:
				base = lbase;
				base -= 257;
				extra = lext;
				extra -= 257;
				end = 256;
				break;
		default:
				base = dbase;
				extra = dext;
				end = -1;
		}
		huff = /* initialize state for loop *//* starting code */0;
		sym = /* starting code symbol */0;
		len = /* starting code length */min;
		next = /* current table to fill in */table;
		curr = /* current table index bits */root;
		drop = /* current bits to drop from code for index */0;
		low = (int)(/* trigger new sub-table when len > root */true);
		used = -1024 << /* use root table entries */root;
		mask = used - /* mask for comparing low */1;
		if ((type == .LENS && used >= /* check available table space */852) || (type == .DISTS && used >= 594)) {
			return 1;
		} 
		/* process all codes and make table entries */for (; ; ) {
			this.setBits((byte)(len - /* create table entry */drop));
			if ((int)(work[sym]) < end) {
				this.setOp((byte)0);
				this.setVal(work[sym]);
			}  else if ((int)(work[sym]) > end) {
				this.setOp((byte)(extra[work[sym]]));
				this.setVal(base[work[sym]]);
			} else {
					this.setOp((byte)(32 + /* end of block */64));
					this.setVal(0);
			} 
			incr = -1024 << (len - /* replicate for those indices with low len bits equal to huff */drop);
			fill = -1024 << curr;
			do {
				fill -= incr;
				next[(huff >> drop) + fill] = this;
			} while (fill != 0);
			incr = -1024 << (len - /* backwards increment the len-bit code huff */1);
			while (huff & incr) {
				incr >>=  1;
			}
			if (incr != 0) {
				huff &=  incr - 1;
				huff += incr;
			} else {
					huff = 0;
			} 
			/* go to next symbol, update count, len */sym++;
			if (--(count[len]) == 0) {
				if (len == max) {
					break;
				} 
				len = lens[work[sym]];
			} 
			if (len > root && (huff & mask) != /* create new sub-table if needed */low) {
				if (drop == /* if first time, transition to sub-tables */0) {
					drop = root;
				} 
				next += -1024 << /* increment past last table */curr;
				curr = len - /* determine length of next table */drop;
				left = (int)(1 << curr);
				while (curr + drop < max) {
					left -= count[curr + drop];
					if (left <= 0) {
						break;
					} 
					curr++;
					left <<=  1;
				}
				used += -1024 << /* check for enough space */curr;
				if ((type == .LENS && used >= 852) || (type == .DISTS && used >= 594)) {
					return 1;
				} 
				low = huff & /* point entry in root table to sub-table */mask;
				(table)[low].setOp((byte)curr);
				(table)[low].setBits((byte)root);
				(table)[low].setVal((int)(next - table/*
				       Fill in rest of table for incomplete codes.  This loop is similar to the
				       loop above in incrementing huff for table indices.  It is assumed that
				       len is equal to curr + drop, so there is no loop needed to increment
				       through high index bits.  When the current sub-table is filled, the loop
				       drops back to the root table to fill in any remaining entries there.
				     */));
			} 
		}
		this.setOp((byte)/* invalid code marker */64);
		this.setBits((byte)(len - drop));
		this.setVal((int)0);
		while (huff != 0) {
			if (drop != 0 && (huff & mask) != /* when done with sub-table, drop back to root table */low) {
				drop = 0;
				len = root;
				next = table;
				curr = root;
				this.setBits((byte)len);
			} 
			next[huff >> drop] = /* put invalid code marker in table */this;
			incr = -1024 << (len - /* backwards increment the len-bit code huff */1);
			while (huff & incr) {
				incr >>=  1;
			}
			if (incr != 0) {
				huff &=  incr - 1;
				huff += incr;
			} else {
					huff = 0;
			} 
		}
		table += /* set return parameters */used;
		bits = root;
		return 0;
	}
	/* compress.c -- compress a memory buffer
	 * Copyright (C) 1995-2005, 2014, 2016 Jean-loup Gailly, Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */
	/* @(#) $Id$ */
	/* ===========================================================================
	     Compresses the source buffer into the destination buffer. The level
	   parameter has the same meaning as in deflateInit.  sourceLen is the byte
	   length of the source buffer. Upon entry, destLen is the total size of the
	   destination buffer, which must be at least 0.1% larger than sourceLen plus
	   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
	
	     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
	   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
	   Z_STREAM_ERROR if the level parameter is invalid.
	*/
	public static int compress2(Object dest, Object destLen, Object source, Object sourceLen, int level) {
		z_stream stream = new z_stream();
		int err;
		uInt max = (uInt)-1;
		uLong left = new uLong();
		left = destLen;
		destLen = 0;
		stream.setZalloc((alloc_func)0);
		stream.setZfree((free_func)0);
		stream.setOpaque((voidpf)0);
		err = ModernizedCProgram.deflateInit_((stream), (level), "1.2.11", (int));
		if (err != 0) {
			return err;
		} 
		stream.setNext_out(dest);
		stream.setAvail_out(0);
		stream.setNext_in((Bytef)source);
		stream.setAvail_in(0);
		Object generatedAvail_out = stream.getAvail_out();
		Object generatedAvail_in = stream.getAvail_in();
		do {
			if (generatedAvail_out == 0) {
				stream.setAvail_out(left > (uLong)max ? max : (uInt)left);
				left -= generatedAvail_out;
			} 
			if (generatedAvail_in == 0) {
				stream.setAvail_in(sourceLen > (uLong)max ? max : (uInt)sourceLen);
				sourceLen -= generatedAvail_in;
			} 
			err = ModernizedCProgram.deflate(stream, sourceLen ? 0 : 4);
		} while (err == 0);
		Object generatedTotal_out = stream.getTotal_out();
		destLen = generatedTotal_out;
		ModernizedCProgram.deflateEnd(stream);
		return err == 1 ? 0 : err;
	}
	/* ===========================================================================
	 */
	public static int compress(Object dest, Object destLen, Object source, Object sourceLen) {
		return ModernizedCProgram.compress2(dest, destLen, source, sourceLen, (true/* ===========================================================================
		     If the default memLevel or windowBits for deflateInit() is changed, then
		   this function needs to be updated.
		 */));
	}
	public static Object compressBound(Object sourceLen) {
		return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) + (sourceLen >> 25) + 13;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static void selftest_to_bitmap(Object dgst_shifts, Byte digests_buf_ptr, Object dgst_pos0, Object dgst_pos1, Object dgst_pos2, Object dgst_pos3, Object bitmap_mask, Object bitmap_a, Object bitmap_b, Object bitmap_c, Object bitmap_d) {
		u32 digest_ptr = (u32)digests_buf_ptr;
		u32 val0 = -1024 << (digest_ptr[dgst_pos0] & -1024);
		u32 val1 = -1024 << (digest_ptr[dgst_pos1] & -1024);
		u32 val2 = -1024 << (digest_ptr[dgst_pos2] & -1024);
		u32 val3 = -1024 << (digest_ptr[dgst_pos3] & -1024);
		u32 idx0 = (digest_ptr[dgst_pos0] >> dgst_shifts) & bitmap_mask;
		u32 idx1 = (digest_ptr[dgst_pos1] >> dgst_shifts) & bitmap_mask;
		u32 idx2 = (digest_ptr[dgst_pos2] >> dgst_shifts) & bitmap_mask;
		u32 idx3 = (digest_ptr[dgst_pos3] >> dgst_shifts) & bitmap_mask;
		bitmap_a[idx0] |=  val0;
		bitmap_b[idx1] |=  val1;
		bitmap_c[idx2] |=  val2;
		bitmap_d[idx3] |=  val3;
	}
	public static boolean generate_bitmaps(Object digests_cnt, Object dgst_size, Object dgst_shifts, Byte digests_buf_ptr, Object dgst_pos0, Object dgst_pos1, Object dgst_pos2, Object dgst_pos3, Object bitmap_mask, Object bitmap_size, Object bitmap_a, Object bitmap_b, Object bitmap_c, Object bitmap_d, Object collisions_max) {
		u64 collisions = 0;
		.memset(bitmap_a, 0, bitmap_size);
		.memset(bitmap_b, 0, bitmap_size);
		.memset(bitmap_c, 0, bitmap_size);
		.memset(bitmap_d, 0, bitmap_size);
		for (u32 i = 0;
		 i < digests_cnt; i++) {
			u32 digest_ptr = (u32)digests_buf_ptr;
			digests_buf_ptr += dgst_size;
			u32 val0 = -1024 << (digest_ptr[dgst_pos0] & -1024);
			u32 val1 = -1024 << (digest_ptr[dgst_pos1] & -1024);
			u32 val2 = -1024 << (digest_ptr[dgst_pos2] & -1024);
			u32 val3 = -1024 << (digest_ptr[dgst_pos3] & -1024);
			u32 idx0 = (digest_ptr[dgst_pos0] >> dgst_shifts) & bitmap_mask;
			u32 idx1 = (digest_ptr[dgst_pos1] >> dgst_shifts) & bitmap_mask;
			u32 idx2 = (digest_ptr[dgst_pos2] >> dgst_shifts) & bitmap_mask;
			u32 idx3 = (digest_ptr[dgst_pos3] >> dgst_shifts) & bitmap_mask;
			if (bitmap_a[idx0] & val0) {
				collisions++;
			} 
			if (bitmap_b[idx1] & val1) {
				collisions++;
			} 
			if (bitmap_c[idx2] & val2) {
				collisions++;
			} 
			if (bitmap_d[idx3] & val3) {
				collisions++;
			} 
			bitmap_a[idx0] |=  val0;
			bitmap_b[idx1] |=  val1;
			bitmap_c[idx2] |=  val2;
			bitmap_d[idx3] |=  val3;
			if (collisions >= collisions_max) {
				return 1;
			} 
		}
		return 0;
	}
	public static Object Crc64Update(Object v, Object data, Object size) {
		return .g_Crc64Update(v, data, size, ModernizedCProgram.g_Crc64Table);
	}
	public static Object Crc64Calc(Object data, Object size) {
		return .g_Crc64Update(-1024, data, size, ModernizedCProgram.g_Crc64Table) ^ -1024;
	}
	public static void Crc64GenerateTable() {
		UInt32 i = new UInt32();
		for (i = 0; i < 256; i++) {
			UInt64 r = i;
			int j;
			for (j = 0; j < 8; j++) {
				r = (r >> 1) ^ (-1024 & ((UInt64)0 - (r & 1)));
			}
			ModernizedCProgram.g_Crc64Table[i] = r;
		}
		for (i = 256; i < 256 * 4; i++) {
			UInt64 r = ModernizedCProgram.g_Crc64Table[(size_t)i - 256];
			ModernizedCProgram.g_Crc64Table[i] = ModernizedCProgram.g_Crc64Table[r & -1024] ^ (r >> 8);
		}
		ModernizedCProgram.g_Crc64Update = ModernizedCProgram.XzCrc64UpdateT4;
	}
	/* strncpy doesnt append the trailing NULL, of the string is too long. */
	/* not all systems allow stat'ing a file with / appended */
	/* name of file to get info on */
	/* return value: access, modific. and creation times */
	/* dostime */
	public static int check_exist_file(Object filename) {
		FILE ftestexist = new FILE();
		int ret = 1;
		ftestexist = .fopen64(filename, "rb");
		if (ftestexist == ((Object)0)) {
			ret = 0;
		} else {
				.fclose(ftestexist);
		} 
		return ret;
	}
	public static void do_banner() {
		.printf("MiniZip 1.1, demo of zLib + MiniZip64 package, written by Gilles Vollant\n");
		.printf("more info on MiniZip at http://www.winimage.com/zLibDll/minizip.html\n\n");
		.printf("MiniUnz 1.01b, demo of zLib + Unz package written by Gilles Vollant\n");
		.printf("more info at http://www.winimage.com/zLibDll/unzip.html\n\n");
	}
	public static void do_help() {
		.printf("Usage : minizip [-o] [-a] [-0 to -9] [-p password] [-j] file.zip [files_to_add]\n\n  -o  Overwrite existing file.zip\n  -a  Append to existing file.zip\n  -0  Store only\n  -1  Compress faster\n  -9  Compress better\n\n  -j  exclude path. store only the file name.\n\n");
		.printf("Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.] [-d extractdir]\n\n  -e  Extract without pathname (junk paths)\n  -x  Extract with pathname\n  -v  list files\n  -l  list files\n  -d  directory to extract into\n  -o  overwrite files without prompting\n  -p  extract crypted file using password\n\n");
	}
	/* calculate the CRC32 of a file,
	   because to encrypt a file, we need known the CRC32 of the file before */
	public static int getFileCrc(Object filenameinzip, Object buf, long size_buf, long result_crc) {
		long calculate_crc = 0;
		int err = (false);
		FILE fin = .fopen64(filenameinzip, "rb");
		long size_read = 0;
		long total_read = 0;
		if (fin == ((Object)0)) {
			err = ((true));
		} 
		Object generated_flag = (fin).get_flag();
		if (err == (false)) {
			do {
				err = (false);
				size_read = (int).fread(buf, 1, size_buf, fin);
				if (size_read < size_buf) {
					if ((generated_flag & -1024) == 0) {
						.printf("error in reading %s\n", filenameinzip);
						err = ((true));
					} 
				} 
				if (size_read > 0) {
					calculate_crc = ModernizedCProgram.crc32(calculate_crc, buf, size_read);
				} 
				total_read += size_read;
			} while ((err == (false)) && (size_read > 0));
		} 
		if (fin) {
			.fclose(fin);
		} 
		result_crc = calculate_crc;
		.printf("file %s crc %lx\n", filenameinzip, calculate_crc);
		return err;
	}
	public static int isLargeFile(Object filename) {
		int largeFile = 0;
		ZPOS64_T pos = 0;
		FILE pFile = .fopen64(filename, "rb");
		if (pFile != ((Object)0)) {
			int n = .fseeko64(pFile, 0, 2);
			pos = .ftello64(pFile);
			.printf("File : %s is %lld bytes\n", filename, pos);
			if (pos >= -1024) {
				largeFile = 1;
			} 
			.fclose(pFile);
		} 
		return largeFile;
	}
	/* Crypto/Sha256.c -- SHA-256 Hash
	2017-04-03 : Igor Pavlov : Public domain
	This code is based on public domain code from Wei Dai's Crypto++ library. */
	/* define it for speed optimization */
	/* #define _SHA256_UNROLL2 */
	public static void Sha256_Init() {
		Object generatedState = this.getState();
		generatedState[0] = -1024;
		generatedState[1] = -1024;
		generatedState[2] = -1024;
		generatedState[3] = -1024;
		generatedState[4] = -1024;
		generatedState[5] = -1024;
		generatedState[6] = -1024;
		generatedState[7] = -1024;
		this.setCount(0);
	}
	public static void Sha256_WriteByteBlock() {
		UInt32[] W = new UInt32();
		int j;
		UInt32 state = new UInt32();
		UInt32 a = new UInt32();
		UInt32 b = new UInt32();
		UInt32 c = new UInt32();
		UInt32 d = new UInt32();
		UInt32 e = new UInt32();
		UInt32 f = new UInt32();
		UInt32 g = new UInt32();
		UInt32 h = new UInt32();
		Object generatedBuffer = this.getBuffer();
		for (j = 0; j < 16; j += 4) {
			Byte ccc = generatedBuffer + j * 4;
			W[j] = .__builtin_bswap32((UInt32)(Byte)(ccc));
			W[j + 1] = .__builtin_bswap32((UInt32)(Byte)(ccc + 4));
			W[j + 2] = .__builtin_bswap32((UInt32)(Byte)(ccc + 8));
			W[j + 3] = .__builtin_bswap32((UInt32)(Byte)(ccc + 12));
		}
		Object generatedState = this.getState();
		state = generatedState;
		a = state[0];
		b = state[1];
		c = state[2];
		d = state[3];
		e = state[4];
		f = state[5];
		g = state[6];
		h = state[7];
		for (j = 0; j < 64; j += 16) {
			h += ((((e) >> (true)) | ((e) << (32 - (true)))) ^ (((e) >> (true)) | ((e) << (32 - (true)))) ^ (((e) >> (true)) | ((e) << (32 - (true))))) + (g ^ (e & (f ^ g))) + ModernizedCProgram.K[(false) + (size_t)(j)] + (j ? (W[0] += ((((W[((false) - 2) & 15]) >> (true)) | ((W[((false) - 2) & 15]) << (32 - (true)))) ^ (((W[((false) - 2) & 15]) >> (true)) | ((W[((false) - 2) & 15]) << (32 - (true)))) ^ (W[((false) - 2) & 15] >> 10)) + W[((false) - 7) & 15] + ((((W[((false) - 15) & 15]) >> (true)) | ((W[((false) - 15) & 15]) << (32 - (true)))) ^ (((W[((false) - 15) & 15]) >> (true)) | ((W[((false) - 15) & 15]) << (32 - (true)))) ^ (W[((false) - 15) & 15] >> 3))) : (W[0]));
			d += h;
			h += ((((a) >> (true)) | ((a) << (32 - (true)))) ^ (((a) >> (true)) | ((a) << (32 - (true)))) ^ (((a) >> (true)) | ((a) << (32 - (true))))) + ((a & b) | (c & (a | b)));
			g += ((((d) >> (true)) | ((d) << (32 - (true)))) ^ (((d) >> (true)) | ((d) << (32 - (true)))) ^ (((d) >> (true)) | ((d) << (32 - (true))))) + (f ^ (d & (e ^ f))) + ModernizedCProgram.K[(0 + 1) + (size_t)(j)] + (j ? (W[0 + 1] += ((((W[((0 + 1) - 2) & 15]) >> (true)) | ((W[((0 + 1) - 2) & 15]) << (32 - (true)))) ^ (((W[((0 + 1) - 2) & 15]) >> (true)) | ((W[((0 + 1) - 2) & 15]) << (32 - (true)))) ^ (W[((0 + 1) - 2) & 15] >> 10)) + W[((0 + 1) - 7) & 15] + ((((W[((0 + 1) - 15) & 15]) >> (true)) | ((W[((0 + 1) - 15) & 15]) << (32 - (true)))) ^ (((W[((0 + 1) - 15) & 15]) >> (true)) | ((W[((0 + 1) - 15) & 15]) << (32 - (true)))) ^ (W[((0 + 1) - 15) & 15] >> 3))) : (W[0 + 1]));
			c += g;
			g += ((((h) >> (true)) | ((h) << (32 - (true)))) ^ (((h) >> (true)) | ((h) << (32 - (true)))) ^ (((h) >> (true)) | ((h) << (32 - (true))))) + ((h & a) | (b & (h | a)));
			f += ((((c) >> (true)) | ((c) << (32 - (true)))) ^ (((c) >> (true)) | ((c) << (32 - (true)))) ^ (((c) >> (true)) | ((c) << (32 - (true))))) + (e ^ (c & (d ^ e))) + ModernizedCProgram.K[(0 + 2) + (size_t)(j)] + (j ? (W[0 + 2] += ((((W[((0 + 2) - 2) & 15]) >> (true)) | ((W[((0 + 2) - 2) & 15]) << (32 - (true)))) ^ (((W[((0 + 2) - 2) & 15]) >> (true)) | ((W[((0 + 2) - 2) & 15]) << (32 - (true)))) ^ (W[((0 + 2) - 2) & 15] >> 10)) + W[((0 + 2) - 7) & 15] + ((((W[((0 + 2) - 15) & 15]) >> (true)) | ((W[((0 + 2) - 15) & 15]) << (32 - (true)))) ^ (((W[((0 + 2) - 15) & 15]) >> (true)) | ((W[((0 + 2) - 15) & 15]) << (32 - (true)))) ^ (W[((0 + 2) - 15) & 15] >> 3))) : (W[0 + 2]));
			b += f;
			f += ((((g) >> (true)) | ((g) << (32 - (true)))) ^ (((g) >> (true)) | ((g) << (32 - (true)))) ^ (((g) >> (true)) | ((g) << (32 - (true))))) + ((g & h) | (a & (g | h)));
			e += ((((b) >> (true)) | ((b) << (32 - (true)))) ^ (((b) >> (true)) | ((b) << (32 - (true)))) ^ (((b) >> (true)) | ((b) << (32 - (true))))) + (d ^ (b & (c ^ d))) + ModernizedCProgram.K[(0 + 3) + (size_t)(j)] + (j ? (W[0 + 3] += ((((W[((0 + 3) - 2) & 15]) >> (true)) | ((W[((0 + 3) - 2) & 15]) << (32 - (true)))) ^ (((W[((0 + 3) - 2) & 15]) >> (true)) | ((W[((0 + 3) - 2) & 15]) << (32 - (true)))) ^ (W[((0 + 3) - 2) & 15] >> 10)) + W[((0 + 3) - 7) & 15] + ((((W[((0 + 3) - 15) & 15]) >> (true)) | ((W[((0 + 3) - 15) & 15]) << (32 - (true)))) ^ (((W[((0 + 3) - 15) & 15]) >> (true)) | ((W[((0 + 3) - 15) & 15]) << (32 - (true)))) ^ (W[((0 + 3) - 15) & 15] >> 3))) : (W[0 + 3]));
			a += e;
			e += ((((f) >> (true)) | ((f) << (32 - (true)))) ^ (((f) >> (true)) | ((f) << (32 - (true)))) ^ (((f) >> (true)) | ((f) << (32 - (true))))) + ((f & g) | (h & (f | g)));
			d += ((((a) >> (true)) | ((a) << (32 - (true)))) ^ (((a) >> (true)) | ((a) << (32 - (true)))) ^ (((a) >> (true)) | ((a) << (32 - (true))))) + (c ^ (a & (b ^ c))) + ModernizedCProgram.K[(0 + 4) + (size_t)(j)] + (j ? (W[0 + 4] += ((((W[((0 + 4) - 2) & 15]) >> (true)) | ((W[((0 + 4) - 2) & 15]) << (32 - (true)))) ^ (((W[((0 + 4) - 2) & 15]) >> (true)) | ((W[((0 + 4) - 2) & 15]) << (32 - (true)))) ^ (W[((0 + 4) - 2) & 15] >> 10)) + W[((0 + 4) - 7) & 15] + ((((W[((0 + 4) - 15) & 15]) >> (true)) | ((W[((0 + 4) - 15) & 15]) << (32 - (true)))) ^ (((W[((0 + 4) - 15) & 15]) >> (true)) | ((W[((0 + 4) - 15) & 15]) << (32 - (true)))) ^ (W[((0 + 4) - 15) & 15] >> 3))) : (W[0 + 4]));
			h += d;
			d += ((((e) >> (true)) | ((e) << (32 - (true)))) ^ (((e) >> (true)) | ((e) << (32 - (true)))) ^ (((e) >> (true)) | ((e) << (32 - (true))))) + ((e & f) | (g & (e | f)));
			c += ((((h) >> (true)) | ((h) << (32 - (true)))) ^ (((h) >> (true)) | ((h) << (32 - (true)))) ^ (((h) >> (true)) | ((h) << (32 - (true))))) + (b ^ (h & (a ^ b))) + ModernizedCProgram.K[(0 + 5) + (size_t)(j)] + (j ? (W[0 + 5] += ((((W[((0 + 5) - 2) & 15]) >> (true)) | ((W[((0 + 5) - 2) & 15]) << (32 - (true)))) ^ (((W[((0 + 5) - 2) & 15]) >> (true)) | ((W[((0 + 5) - 2) & 15]) << (32 - (true)))) ^ (W[((0 + 5) - 2) & 15] >> 10)) + W[((0 + 5) - 7) & 15] + ((((W[((0 + 5) - 15) & 15]) >> (true)) | ((W[((0 + 5) - 15) & 15]) << (32 - (true)))) ^ (((W[((0 + 5) - 15) & 15]) >> (true)) | ((W[((0 + 5) - 15) & 15]) << (32 - (true)))) ^ (W[((0 + 5) - 15) & 15] >> 3))) : (W[0 + 5]));
			g += c;
			c += ((((d) >> (true)) | ((d) << (32 - (true)))) ^ (((d) >> (true)) | ((d) << (32 - (true)))) ^ (((d) >> (true)) | ((d) << (32 - (true))))) + ((d & e) | (f & (d | e)));
			b += ((((g) >> (true)) | ((g) << (32 - (true)))) ^ (((g) >> (true)) | ((g) << (32 - (true)))) ^ (((g) >> (true)) | ((g) << (32 - (true))))) + (a ^ (g & (h ^ a))) + ModernizedCProgram.K[(0 + 6) + (size_t)(j)] + (j ? (W[0 + 6] += ((((W[((0 + 6) - 2) & 15]) >> (true)) | ((W[((0 + 6) - 2) & 15]) << (32 - (true)))) ^ (((W[((0 + 6) - 2) & 15]) >> (true)) | ((W[((0 + 6) - 2) & 15]) << (32 - (true)))) ^ (W[((0 + 6) - 2) & 15] >> 10)) + W[((0 + 6) - 7) & 15] + ((((W[((0 + 6) - 15) & 15]) >> (true)) | ((W[((0 + 6) - 15) & 15]) << (32 - (true)))) ^ (((W[((0 + 6) - 15) & 15]) >> (true)) | ((W[((0 + 6) - 15) & 15]) << (32 - (true)))) ^ (W[((0 + 6) - 15) & 15] >> 3))) : (W[0 + 6]));
			f += b;
			b += ((((c) >> (true)) | ((c) << (32 - (true)))) ^ (((c) >> (true)) | ((c) << (32 - (true)))) ^ (((c) >> (true)) | ((c) << (32 - (true))))) + ((c & d) | (e & (c | d)));
			a += ((((f) >> (true)) | ((f) << (32 - (true)))) ^ (((f) >> (true)) | ((f) << (32 - (true)))) ^ (((f) >> (true)) | ((f) << (32 - (true))))) + (h ^ (f & (g ^ h))) + ModernizedCProgram.K[(0 + 7) + (size_t)(j)] + (j ? (W[0 + 7] += ((((W[((0 + 7) - 2) & 15]) >> (true)) | ((W[((0 + 7) - 2) & 15]) << (32 - (true)))) ^ (((W[((0 + 7) - 2) & 15]) >> (true)) | ((W[((0 + 7) - 2) & 15]) << (32 - (true)))) ^ (W[((0 + 7) - 2) & 15] >> 10)) + W[((0 + 7) - 7) & 15] + ((((W[((0 + 7) - 15) & 15]) >> (true)) | ((W[((0 + 7) - 15) & 15]) << (32 - (true)))) ^ (((W[((0 + 7) - 15) & 15]) >> (true)) | ((W[((0 + 7) - 15) & 15]) << (32 - (true)))) ^ (W[((0 + 7) - 15) & 15] >> 3))) : (W[0 + 7]));
			e += a;
			a += ((((b) >> (true)) | ((b) << (32 - (true)))) ^ (((b) >> (true)) | ((b) << (32 - (true)))) ^ (((b) >> (true)) | ((b) << (32 - (true))))) + ((b & c) | (d & (b | c)));
			h += ((((e) >> (true)) | ((e) << (32 - (true)))) ^ (((e) >> (true)) | ((e) << (32 - (true)))) ^ (((e) >> (true)) | ((e) << (32 - (true))))) + (g ^ (e & (f ^ g))) + ModernizedCProgram.K[(true) + (size_t)(j)] + (j ? (W[8] += ((((W[((true) - 2) & 15]) >> (true)) | ((W[((true) - 2) & 15]) << (32 - (true)))) ^ (((W[((true) - 2) & 15]) >> (true)) | ((W[((true) - 2) & 15]) << (32 - (true)))) ^ (W[((true) - 2) & 15] >> 10)) + W[((true) - 7) & 15] + ((((W[((true) - 15) & 15]) >> (true)) | ((W[((true) - 15) & 15]) << (32 - (true)))) ^ (((W[((true) - 15) & 15]) >> (true)) | ((W[((true) - 15) & 15]) << (32 - (true)))) ^ (W[((true) - 15) & 15] >> 3))) : (W[8]));
			d += h;
			h += ((((a) >> (true)) | ((a) << (32 - (true)))) ^ (((a) >> (true)) | ((a) << (32 - (true)))) ^ (((a) >> (true)) | ((a) << (32 - (true))))) + ((a & b) | (c & (a | b)));
			g += ((((d) >> (true)) | ((d) << (32 - (true)))) ^ (((d) >> (true)) | ((d) << (32 - (true)))) ^ (((d) >> (true)) | ((d) << (32 - (true))))) + (f ^ (d & (e ^ f))) + ModernizedCProgram.K[(8 + 1) + (size_t)(j)] + (j ? (W[8 + 1] += ((((W[((8 + 1) - 2) & 15]) >> (true)) | ((W[((8 + 1) - 2) & 15]) << (32 - (true)))) ^ (((W[((8 + 1) - 2) & 15]) >> (true)) | ((W[((8 + 1) - 2) & 15]) << (32 - (true)))) ^ (W[((8 + 1) - 2) & 15] >> 10)) + W[((8 + 1) - 7) & 15] + ((((W[((8 + 1) - 15) & 15]) >> (true)) | ((W[((8 + 1) - 15) & 15]) << (32 - (true)))) ^ (((W[((8 + 1) - 15) & 15]) >> (true)) | ((W[((8 + 1) - 15) & 15]) << (32 - (true)))) ^ (W[((8 + 1) - 15) & 15] >> 3))) : (W[8 + 1]));
			c += g;
			g += ((((h) >> (true)) | ((h) << (32 - (true)))) ^ (((h) >> (true)) | ((h) << (32 - (true)))) ^ (((h) >> (true)) | ((h) << (32 - (true))))) + ((h & a) | (b & (h | a)));
			f += ((((c) >> (true)) | ((c) << (32 - (true)))) ^ (((c) >> (true)) | ((c) << (32 - (true)))) ^ (((c) >> (true)) | ((c) << (32 - (true))))) + (e ^ (c & (d ^ e))) + ModernizedCProgram.K[(8 + 2) + (size_t)(j)] + (j ? (W[8 + 2] += ((((W[((8 + 2) - 2) & 15]) >> (true)) | ((W[((8 + 2) - 2) & 15]) << (32 - (true)))) ^ (((W[((8 + 2) - 2) & 15]) >> (true)) | ((W[((8 + 2) - 2) & 15]) << (32 - (true)))) ^ (W[((8 + 2) - 2) & 15] >> 10)) + W[((8 + 2) - 7) & 15] + ((((W[((8 + 2) - 15) & 15]) >> (true)) | ((W[((8 + 2) - 15) & 15]) << (32 - (true)))) ^ (((W[((8 + 2) - 15) & 15]) >> (true)) | ((W[((8 + 2) - 15) & 15]) << (32 - (true)))) ^ (W[((8 + 2) - 15) & 15] >> 3))) : (W[8 + 2]));
			b += f;
			f += ((((g) >> (true)) | ((g) << (32 - (true)))) ^ (((g) >> (true)) | ((g) << (32 - (true)))) ^ (((g) >> (true)) | ((g) << (32 - (true))))) + ((g & h) | (a & (g | h)));
			e += ((((b) >> (true)) | ((b) << (32 - (true)))) ^ (((b) >> (true)) | ((b) << (32 - (true)))) ^ (((b) >> (true)) | ((b) << (32 - (true))))) + (d ^ (b & (c ^ d))) + ModernizedCProgram.K[(8 + 3) + (size_t)(j)] + (j ? (W[8 + 3] += ((((W[((8 + 3) - 2) & 15]) >> (true)) | ((W[((8 + 3) - 2) & 15]) << (32 - (true)))) ^ (((W[((8 + 3) - 2) & 15]) >> (true)) | ((W[((8 + 3) - 2) & 15]) << (32 - (true)))) ^ (W[((8 + 3) - 2) & 15] >> 10)) + W[((8 + 3) - 7) & 15] + ((((W[((8 + 3) - 15) & 15]) >> (true)) | ((W[((8 + 3) - 15) & 15]) << (32 - (true)))) ^ (((W[((8 + 3) - 15) & 15]) >> (true)) | ((W[((8 + 3) - 15) & 15]) << (32 - (true)))) ^ (W[((8 + 3) - 15) & 15] >> 3))) : (W[8 + 3]));
			a += e;
			e += ((((f) >> (true)) | ((f) << (32 - (true)))) ^ (((f) >> (true)) | ((f) << (32 - (true)))) ^ (((f) >> (true)) | ((f) << (32 - (true))))) + ((f & g) | (h & (f | g)));
			d += ((((a) >> (true)) | ((a) << (32 - (true)))) ^ (((a) >> (true)) | ((a) << (32 - (true)))) ^ (((a) >> (true)) | ((a) << (32 - (true))))) + (c ^ (a & (b ^ c))) + ModernizedCProgram.K[(8 + 4) + (size_t)(j)] + (j ? (W[8 + 4] += ((((W[((8 + 4) - 2) & 15]) >> (true)) | ((W[((8 + 4) - 2) & 15]) << (32 - (true)))) ^ (((W[((8 + 4) - 2) & 15]) >> (true)) | ((W[((8 + 4) - 2) & 15]) << (32 - (true)))) ^ (W[((8 + 4) - 2) & 15] >> 10)) + W[((8 + 4) - 7) & 15] + ((((W[((8 + 4) - 15) & 15]) >> (true)) | ((W[((8 + 4) - 15) & 15]) << (32 - (true)))) ^ (((W[((8 + 4) - 15) & 15]) >> (true)) | ((W[((8 + 4) - 15) & 15]) << (32 - (true)))) ^ (W[((8 + 4) - 15) & 15] >> 3))) : (W[8 + 4]));
			h += d;
			d += ((((e) >> (true)) | ((e) << (32 - (true)))) ^ (((e) >> (true)) | ((e) << (32 - (true)))) ^ (((e) >> (true)) | ((e) << (32 - (true))))) + ((e & f) | (g & (e | f)));
			c += ((((h) >> (true)) | ((h) << (32 - (true)))) ^ (((h) >> (true)) | ((h) << (32 - (true)))) ^ (((h) >> (true)) | ((h) << (32 - (true))))) + (b ^ (h & (a ^ b))) + ModernizedCProgram.K[(8 + 5) + (size_t)(j)] + (j ? (W[8 + 5] += ((((W[((8 + 5) - 2) & 15]) >> (true)) | ((W[((8 + 5) - 2) & 15]) << (32 - (true)))) ^ (((W[((8 + 5) - 2) & 15]) >> (true)) | ((W[((8 + 5) - 2) & 15]) << (32 - (true)))) ^ (W[((8 + 5) - 2) & 15] >> 10)) + W[((8 + 5) - 7) & 15] + ((((W[((8 + 5) - 15) & 15]) >> (true)) | ((W[((8 + 5) - 15) & 15]) << (32 - (true)))) ^ (((W[((8 + 5) - 15) & 15]) >> (true)) | ((W[((8 + 5) - 15) & 15]) << (32 - (true)))) ^ (W[((8 + 5) - 15) & 15] >> 3))) : (W[8 + 5]));
			g += c;
			c += ((((d) >> (true)) | ((d) << (32 - (true)))) ^ (((d) >> (true)) | ((d) << (32 - (true)))) ^ (((d) >> (true)) | ((d) << (32 - (true))))) + ((d & e) | (f & (d | e)));
			b += ((((g) >> (true)) | ((g) << (32 - (true)))) ^ (((g) >> (true)) | ((g) << (32 - (true)))) ^ (((g) >> (true)) | ((g) << (32 - (true))))) + (a ^ (g & (h ^ a))) + ModernizedCProgram.K[(8 + 6) + (size_t)(j)] + (j ? (W[8 + 6] += ((((W[((8 + 6) - 2) & 15]) >> (true)) | ((W[((8 + 6) - 2) & 15]) << (32 - (true)))) ^ (((W[((8 + 6) - 2) & 15]) >> (true)) | ((W[((8 + 6) - 2) & 15]) << (32 - (true)))) ^ (W[((8 + 6) - 2) & 15] >> 10)) + W[((8 + 6) - 7) & 15] + ((((W[((8 + 6) - 15) & 15]) >> (true)) | ((W[((8 + 6) - 15) & 15]) << (32 - (true)))) ^ (((W[((8 + 6) - 15) & 15]) >> (true)) | ((W[((8 + 6) - 15) & 15]) << (32 - (true)))) ^ (W[((8 + 6) - 15) & 15] >> 3))) : (W[8 + 6]));
			f += b;
			b += ((((c) >> (true)) | ((c) << (32 - (true)))) ^ (((c) >> (true)) | ((c) << (32 - (true)))) ^ (((c) >> (true)) | ((c) << (32 - (true))))) + ((c & d) | (e & (c | d)));
			a += ((((f) >> (true)) | ((f) << (32 - (true)))) ^ (((f) >> (true)) | ((f) << (32 - (true)))) ^ (((f) >> (true)) | ((f) << (32 - (true))))) + (h ^ (f & (g ^ h))) + ModernizedCProgram.K[(8 + 7) + (size_t)(j)] + (j ? (W[8 + 7] += ((((W[((8 + 7) - 2) & 15]) >> (true)) | ((W[((8 + 7) - 2) & 15]) << (32 - (true)))) ^ (((W[((8 + 7) - 2) & 15]) >> (true)) | ((W[((8 + 7) - 2) & 15]) << (32 - (true)))) ^ (W[((8 + 7) - 2) & 15] >> 10)) + W[((8 + 7) - 7) & 15] + ((((W[((8 + 7) - 15) & 15]) >> (true)) | ((W[((8 + 7) - 15) & 15]) << (32 - (true)))) ^ (((W[((8 + 7) - 15) & 15]) >> (true)) | ((W[((8 + 7) - 15) & 15]) << (32 - (true)))) ^ (W[((8 + 7) - 15) & 15] >> 3))) : (W[8 + 7]));
			e += a;
			a += ((((b) >> (true)) | ((b) << (32 - (true)))) ^ (((b) >> (true)) | ((b) << (32 - (true)))) ^ (((b) >> (true)) | ((b) << (32 - (true))))) + ((b & c) | (d & (b | c)));
		}
		state[0] += a;
		state[1] += b;
		state[2] += c;
		state[3] += d;
		state[4] += e;
		state[5] += f;
		state[6] += g;
		state[7] += h/* Wipe variables *//* memset(W, 0, sizeof(W)); *//* memset(T, 0, sizeof(T)); */;/* Wipe variables *//* memset(W, 0, sizeof(W)); *//* memset(T, 0, sizeof(T)); */
	}
	public static void Sha256_Update(Object data, Object size) {
		if (size == 0) {
			return ;
		} 
		Object generatedCount = this.getCount();
		Object generatedBuffer = this.getBuffer();
		{ 
			int pos = (int)generatedCount & -1024;
			int num;
			generatedCount += size;
			ModernizedCProgram.num = 64 - pos;
			if (ModernizedCProgram.num > size) {
				.memcpy(generatedBuffer + pos, data, size);
				return ;
			} 
			size -= ModernizedCProgram.num;
			.memcpy(generatedBuffer + pos, data, ModernizedCProgram.num);
			data += ModernizedCProgram.num;
		}
		for (; ; ) {
			p.Sha256_WriteByteBlock();
			if (size < 64) {
				break;
			} 
			size -= 64;
			.memcpy(generatedBuffer, data, 64);
			data += 64;
		}
		if (size != 0) {
			.memcpy(generatedBuffer, data, size);
		} 
	}
	public static void Sha256_Final(Object digest) {
		Object generatedCount = this.getCount();
		int pos = (int)generatedCount & -1024;
		int i;
		Object generatedBuffer = this.getBuffer();
		generatedBuffer[pos++] = -1024;
		while (pos != (64 - 8)) {
			pos &=  -1024;
			if (pos == 0) {
				p.Sha256_WriteByteBlock();
			} 
			generatedBuffer[pos++] = 0;
		}
		{ 
			UInt64 numBits = (generatedCount << 3);
			((UInt32)(Object)(generatedBuffer + 64 - 8)) = .__builtin_bswap32((UInt32)(numBits >> 32));
			((UInt32)(Object)(generatedBuffer + 64 - 4)) = .__builtin_bswap32((UInt32)(numBits));
		}
		p.Sha256_WriteByteBlock();
		Object generatedState = this.getState();
		for (i = 0; i < 8; i += 2) {
			UInt32 v0 = generatedState[i];
			UInt32 v1 = generatedState[i + 1];
			((UInt32)(Object)(digest)) = .__builtin_bswap32(v0);
			((UInt32)(Object)(digest + 4)) = .__builtin_bswap32(v1);
			digest += 8;
		}
		p.Sha256_Init();
	}
	/* LzmaDec.c -- LZMA Decoder
	2018-07-04 : Igor Pavlov : Public domain */
	/* #include "CpuArch.h" */
	/* #define _LZMA_SIZE_OPT */
	/* External ASM code needs same CLzmaProb array layout. So don't change it. */
	/* (probs_1664) is faster and better for code size at some platforms */
	/*
	#ifdef MY_CPU_X86_OR_AMD64
	*/
	/*
	#define GET_PROBS p->probs + kStartOffset
	#else
	#define kStartOffset 0
	#define GET_PROBS p->probs
	#endif
	*/
	/*
	p->remainLen : shows status of LZMA decoder:
	    < kMatchSpecLenStart : normal remain
	    = kMatchSpecLenStart : finished
	    = kMatchSpecLenStart + 1 : need init range coder
	    = kMatchSpecLenStart + 2 : need init range coder and state
	*/
	/* ---------- LZMA_DECODE_REAL ---------- */
	/*
	LzmaDec_DecodeReal_3() can be implemented in external ASM file.
	3 - is the code compatibility version of that function for check at link time.
	*/
	/*
	LZMA_DECODE_REAL()
	In:
	  RangeCoder is normalized
	  if (p->dicPos == limit)
	  {
	    LzmaDec_TryDummy() was called before to exclude LITERAL and MATCH-REP cases.
	    So first symbol can be only MATCH-NON-REP. And if that MATCH-NON-REP symbol
	    is not END_OF_PAYALOAD_MARKER, then function returns error code.
	  }
	
	Processing:
	  first LZMA symbol will be decoded in any case
	  All checks for limits are at the end of main loop,
	  It will decode new LZMA-symbols while (p->buf < bufLimit && dicPos < limit),
	  RangeCoder is still without last normalization when (p->buf < bufLimit) is being checked.
	
	Out:
	  RangeCoder is normalized
	  Result:
	    SZ_OK - OK
	    SZ_ERROR_DATA - Error
	  p->remainLen:
	    < kMatchSpecLenStart : normal remain
	    = kMatchSpecLenStart : finished
	*/
	public static int LzmaDec_DecodeReal_3(Object limit, Object bufLimit) {
		Object generatedProbs_1664 = this.getProbs_1664();
		CLzmaProb probs = generatedProbs_1664;
		Object generatedState = this.getState();
		int state = (int)generatedState;
		Object generatedReps = this.getReps();
		UInt32 rep0 = generatedReps[0];
		UInt32 rep1 = generatedReps[1];
		UInt32 rep2 = generatedReps[2];
		UInt32 rep3 = generatedReps[3];
		Object generatedProp = this.getProp();
		int pbMask = ((int)1 << (generatedProp.getPb())) - 1;
		int lc = generatedProp.getLc();
		int lpMask = ((int)-1024 << generatedProp.getLp()) - ((int)-1024 >> lc);
		Object generatedDic = this.getDic();
		Byte dic = generatedDic;
		Object generatedDicBufSize = this.getDicBufSize();
		SizeT dicBufSize = generatedDicBufSize;
		Object generatedDicPos = this.getDicPos();
		SizeT dicPos = generatedDicPos;
		Object generatedProcessedPos = this.getProcessedPos();
		UInt32 processedPos = generatedProcessedPos;
		Object generatedCheckDicSize = this.getCheckDicSize();
		UInt32 checkDicSize = generatedCheckDicSize;
		int len = 0;
		Object generatedBuf = this.getBuf();
		Byte buf = generatedBuf;
		Object generatedRange = this.getRange();
		UInt32 range = generatedRange;
		Object generatedCode = this.getCode();
		UInt32 code = generatedCode;
		do {
			CLzmaProb prob = new CLzmaProb();
			UInt32 bound = new UInt32();
			int ttt;
			int posState = (((processedPos) & (pbMask)) << 4);
			prob = probs + (((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (posState + state);
			ttt = (prob);
			if (range < ((UInt32)1 << 24)) {
				range <<=  8;
				code = (code << 8) | (buf++);
			} 
			;
			bound = (range >> 11) * (UInt32)ttt;
			if (code < bound) {
				int symbol;
				range = bound;
				(prob) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
				;
				prob = probs + ((((((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + 12) + 12) + 12) + (4 << 6));
				if (processedPos != 0 || checkDicSize != 0) {
					prob += (UInt32)3 * ((((processedPos << 8) + dic[(dicPos == 0 ? dicBufSize : dicPos) - 1]) & lpMask) << lc);
				} 
				processedPos++;
				if (state < 7) {
					state -= (state < 4) ? state : 3;
					symbol = 1;
					{ 
						ttt = (prob + symbol);
						if (range < ((UInt32)1 << 24)) {
							range <<=  8;
							code = (code << 8) | (buf++);
						} 
						;
						bound = (range >> 11) * (UInt32)ttt;
						if (code < bound) {
							range = bound;
							(prob + symbol) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
							;
							symbol = (symbol + symbol);
							;
							;
						} else {
								range -= bound;
								code -= bound;
								(prob + symbol) = (CLzmaProb)(ttt - (ttt >> 5));
								;
								symbol = (symbol + symbol) + 1;
								;
								;
						} 
						;
					}
					{ 
						ttt = (prob + symbol);
						if (range < ((UInt32)1 << 24)) {
							range <<=  8;
							code = (code << 8) | (buf++);
						} 
						;
						bound = (range >> 11) * (UInt32)ttt;
						if (code < bound) {
							range = bound;
							(prob + symbol) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
							;
							symbol = (symbol + symbol);
							;
							;
						} else {
								range -= bound;
								code -= bound;
								(prob + symbol) = (CLzmaProb)(ttt - (ttt >> 5));
								;
								symbol = (symbol + symbol) + 1;
								;
								;
						} 
						;
					}
					{ 
						ttt = (prob + symbol);
						if (range < ((UInt32)1 << 24)) {
							range <<=  8;
							code = (code << 8) | (buf++);
						} 
						;
						bound = (range >> 11) * (UInt32)ttt;
						if (code < bound) {
							range = bound;
							(prob + symbol) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
							;
							symbol = (symbol + symbol);
							;
							;
						} else {
								range -= bound;
								code -= bound;
								(prob + symbol) = (CLzmaProb)(ttt - (ttt >> 5));
								;
								symbol = (symbol + symbol) + 1;
								;
								;
						} 
						;
					}
					{ 
						ttt = (prob + symbol);
						if (range < ((UInt32)1 << 24)) {
							range <<=  8;
							code = (code << 8) | (buf++);
						} 
						;
						bound = (range >> 11) * (UInt32)ttt;
						if (code < bound) {
							range = bound;
							(prob + symbol) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
							;
							symbol = (symbol + symbol);
							;
							;
						} else {
								range -= bound;
								code -= bound;
								(prob + symbol) = (CLzmaProb)(ttt - (ttt >> 5));
								;
								symbol = (symbol + symbol) + 1;
								;
								;
						} 
						;
					}
					{ 
						ttt = (prob + symbol);
						if (range < ((UInt32)1 << 24)) {
							range <<=  8;
							code = (code << 8) | (buf++);
						} 
						;
						bound = (range >> 11) * (UInt32)ttt;
						if (code < bound) {
							range = bound;
							(prob + symbol) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
							;
							symbol = (symbol + symbol);
							;
							;
						} else {
								range -= bound;
								code -= bound;
								(prob + symbol) = (CLzmaProb)(ttt - (ttt >> 5));
								;
								symbol = (symbol + symbol) + 1;
								;
								;
						} 
						;
					}
					{ 
						ttt = (prob + symbol);
						if (range < ((UInt32)1 << 24)) {
							range <<=  8;
							code = (code << 8) | (buf++);
						} 
						;
						bound = (range >> 11) * (UInt32)ttt;
						if (code < bound) {
							range = bound;
							(prob + symbol) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
							;
							symbol = (symbol + symbol);
							;
							;
						} else {
								range -= bound;
								code -= bound;
								(prob + symbol) = (CLzmaProb)(ttt - (ttt >> 5));
								;
								symbol = (symbol + symbol) + 1;
								;
								;
						} 
						;
					}
					{ 
						ttt = (prob + symbol);
						if (range < ((UInt32)1 << 24)) {
							range <<=  8;
							code = (code << 8) | (buf++);
						} 
						;
						bound = (range >> 11) * (UInt32)ttt;
						if (code < bound) {
							range = bound;
							(prob + symbol) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
							;
							symbol = (symbol + symbol);
							;
							;
						} else {
								range -= bound;
								code -= bound;
								(prob + symbol) = (CLzmaProb)(ttt - (ttt >> 5));
								;
								symbol = (symbol + symbol) + 1;
								;
								;
						} 
						;
					}
					{ 
						ttt = (prob + symbol);
						if (range < ((UInt32)1 << 24)) {
							range <<=  8;
							code = (code << 8) | (buf++);
						} 
						;
						bound = (range >> 11) * (UInt32)ttt;
						if (code < bound) {
							range = bound;
							(prob + symbol) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
							;
							symbol = (symbol + symbol);
							;
							;
						} else {
								range -= bound;
								code -= bound;
								(prob + symbol) = (CLzmaProb)(ttt - (ttt >> 5));
								;
								symbol = (symbol + symbol) + 1;
								;
								;
						} 
						;
					}
				} else {
						int matchByte = dic[dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0)];
						int offs = -1024;
						state -= (state < 10) ? 3 : 6;
						symbol = 1;
						{ 
							int bit;
							CLzmaProb probLit = new CLzmaProb();
							matchByte += matchByte;
							bit = offs;
							offs &=  matchByte;
							probLit = prob + (offs + bit + symbol);
							ttt = (probLit);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLit) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								symbol = (symbol + symbol);
								offs ^=  bit;
								;
							} else {
									range -= bound;
									code -= bound;
									(probLit) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									symbol = (symbol + symbol) + 1;
									;
									;
							} 
							matchByte += matchByte;
							bit = offs;
							offs &=  matchByte;
							probLit = prob + (offs + bit + symbol);
							ttt = (probLit);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLit) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								symbol = (symbol + symbol);
								offs ^=  bit;
								;
							} else {
									range -= bound;
									code -= bound;
									(probLit) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									symbol = (symbol + symbol) + 1;
									;
									;
							} 
							matchByte += matchByte;
							bit = offs;
							offs &=  matchByte;
							probLit = prob + (offs + bit + symbol);
							ttt = (probLit);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLit) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								symbol = (symbol + symbol);
								offs ^=  bit;
								;
							} else {
									range -= bound;
									code -= bound;
									(probLit) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									symbol = (symbol + symbol) + 1;
									;
									;
							} 
							matchByte += matchByte;
							bit = offs;
							offs &=  matchByte;
							probLit = prob + (offs + bit + symbol);
							ttt = (probLit);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLit) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								symbol = (symbol + symbol);
								offs ^=  bit;
								;
							} else {
									range -= bound;
									code -= bound;
									(probLit) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									symbol = (symbol + symbol) + 1;
									;
									;
							} 
							matchByte += matchByte;
							bit = offs;
							offs &=  matchByte;
							probLit = prob + (offs + bit + symbol);
							ttt = (probLit);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLit) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								symbol = (symbol + symbol);
								offs ^=  bit;
								;
							} else {
									range -= bound;
									code -= bound;
									(probLit) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									symbol = (symbol + symbol) + 1;
									;
									;
							} 
							matchByte += matchByte;
							bit = offs;
							offs &=  matchByte;
							probLit = prob + (offs + bit + symbol);
							ttt = (probLit);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLit) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								symbol = (symbol + symbol);
								offs ^=  bit;
								;
							} else {
									range -= bound;
									code -= bound;
									(probLit) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									symbol = (symbol + symbol) + 1;
									;
									;
							} 
							matchByte += matchByte;
							bit = offs;
							offs &=  matchByte;
							probLit = prob + (offs + bit + symbol);
							ttt = (probLit);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLit) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								symbol = (symbol + symbol);
								offs ^=  bit;
								;
							} else {
									range -= bound;
									code -= bound;
									(probLit) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									symbol = (symbol + symbol) + 1;
									;
									;
							} 
							matchByte += matchByte;
							bit = offs;
							offs &=  matchByte;
							probLit = prob + (offs + bit + symbol);
							ttt = (probLit);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLit) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								symbol = (symbol + symbol);
								offs ^=  bit;
								;
							} else {
									range -= bound;
									code -= bound;
									(probLit) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									symbol = (symbol + symbol) + 1;
									;
									;
							} 
						}
				} 
				dic[dicPos++] = (Byte)symbol;
				continue;
			} 
			{ 
				range -= bound;
				code -= bound;
				(prob) = (CLzmaProb)(ttt - (ttt >> 5));
				;
				prob = probs + (((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + state;
				ttt = (prob);
				if (range < ((UInt32)1 << 24)) {
					range <<=  8;
					code = (code << 8) | (buf++);
				} 
				;
				bound = (range >> 11) * (UInt32)ttt;
				if (code < bound) {
					range = bound;
					(prob) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
					;
					state += 12;
					prob = probs + ((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8)));
				} else {
						range -= bound;
						code -= bound;
						(prob) = (CLzmaProb)(ttt - (ttt >> 5/*
						        // that case was checked before with kBadRepCode
						        if (checkDicSize == 0 && processedPos == 0)
						          return SZ_ERROR_DATA;
						        */));
						;
						prob = probs + ((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + state;
						ttt = (prob);
						if (range < ((UInt32)1 << 24)) {
							range <<=  8;
							code = (code << 8) | (buf++);
						} 
						;
						bound = (range >> 11) * (UInt32)ttt;
						if (code < bound) {
							range = bound;
							(prob) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
							;
							prob = probs + ((true) + (1 << (14 >> 1))) + (posState + state);
							ttt = (prob);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(prob) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								dic[dicPos] = dic[dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0)];
								dicPos++;
								processedPos++;
								state = state < 7 ? 9 : 11;
								continue;
							} 
							range -= bound;
							code -= bound;
							(prob) = (CLzmaProb)(ttt - (ttt >> 5));
							;
						} else {
								UInt32 distance = new UInt32();
								range -= bound;
								code -= bound;
								(prob) = (CLzmaProb)(ttt - (ttt >> 5));
								;
								prob = probs + (((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + 12) + state;
								ttt = (prob);
								if (range < ((UInt32)1 << 24)) {
									range <<=  8;
									code = (code << 8) | (buf++);
								} 
								;
								bound = (range >> 11) * (UInt32)ttt;
								if (code < bound) {
									range = bound;
									(prob) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
									;
									distance = rep1;
								} else {
										range -= bound;
										code -= bound;
										(prob) = (CLzmaProb)(ttt - (ttt >> 5));
										;
										prob = probs + ((((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + 12) + 12) + state;
										ttt = (prob);
										if (range < ((UInt32)1 << 24)) {
											range <<=  8;
											code = (code << 8) | (buf++);
										} 
										;
										bound = (range >> 11) * (UInt32)ttt;
										if (code < bound) {
											range = bound;
											(prob) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
											;
											distance = rep2;
										} else {
												range -= bound;
												code -= bound;
												(prob) = (CLzmaProb)(ttt - (ttt >> 5));
												;
												distance = rep3;
												rep3 = rep2;
										} 
										rep2 = rep1;
								} 
								rep1 = rep0;
								rep0 = distance;
						} 
						state = state < 7 ? 8 : 11;
						prob = probs + (((true) + (1 << (14 >> 1))) + (16 << 4));
				} 
				{ 
					CLzmaProb probLen = prob + 0;
					ttt = (probLen);
					if (range < ((UInt32)1 << 24)) {
						range <<=  8;
						code = (code << 8) | (buf++);
					} 
					;
					bound = (range >> 11) * (UInt32)ttt;
					if (code < bound) {
						range = bound;
						(probLen) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
						;
						probLen = prob + 0 + (posState);
						len = 1;
						{ 
							ttt = (probLen + len);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLen + len) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								len = (len + len);
								;
								;
							} else {
									range -= bound;
									code -= bound;
									(probLen + len) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									len = (len + len) + 1;
									;
									;
							} 
							;
						}
						;
						{ 
							ttt = (probLen + len);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLen + len) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								len = (len + len);
								;
								;
							} else {
									range -= bound;
									code -= bound;
									(probLen + len) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									len = (len + len) + 1;
									;
									;
							} 
							;
						}
						;
						{ 
							ttt = (probLen + len);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLen + len) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								len = (len + len);
								;
								;
							} else {
									range -= bound;
									code -= bound;
									(probLen + len) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									len = (len + len) + 1;
									;
									;
							} 
							;
						}
						;
						len -= 8;
					} else {
							range -= bound;
							code -= bound;
							(probLen) = (CLzmaProb)(ttt - (ttt >> 5));
							;
							probLen = prob + (0 + (1 << 3));
							ttt = (probLen);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(probLen) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								probLen = prob + 0 + (posState) + (1 << 3);
								len = 1;
								{ 
									ttt = (probLen + len);
									if (range < ((UInt32)1 << 24)) {
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									;
									bound = (range >> 11) * (UInt32)ttt;
									if (code < bound) {
										range = bound;
										(probLen + len) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
										;
										len = (len + len);
										;
										;
									} else {
											range -= bound;
											code -= bound;
											(probLen + len) = (CLzmaProb)(ttt - (ttt >> 5));
											;
											len = (len + len) + 1;
											;
											;
									} 
									;
								}
								;
								{ 
									ttt = (probLen + len);
									if (range < ((UInt32)1 << 24)) {
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									;
									bound = (range >> 11) * (UInt32)ttt;
									if (code < bound) {
										range = bound;
										(probLen + len) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
										;
										len = (len + len);
										;
										;
									} else {
											range -= bound;
											code -= bound;
											(probLen + len) = (CLzmaProb)(ttt - (ttt >> 5));
											;
											len = (len + len) + 1;
											;
											;
									} 
									;
								}
								;
								{ 
									ttt = (probLen + len);
									if (range < ((UInt32)1 << 24)) {
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									;
									bound = (range >> 11) * (UInt32)ttt;
									if (code < bound) {
										range = bound;
										(probLen + len) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
										;
										len = (len + len);
										;
										;
									} else {
											range -= bound;
											code -= bound;
											(probLen + len) = (CLzmaProb)(ttt - (ttt >> 5));
											;
											len = (len + len) + 1;
											;
											;
									} 
									;
								}
								;
							} else {
									range -= bound;
									code -= bound;
									(probLen) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									probLen = prob + (0 + 2 * ((1 << 4) << 3));
									{ 
										len = 1;
										do {
											{ 
												ttt = (probLen + len);
												if (range < ((UInt32)1 << 24)) {
													range <<=  8;
													code = (code << 8) | (buf++);
												} 
												;
												bound = (range >> 11) * (UInt32)ttt;
												if (code < bound) {
													range = bound;
													(probLen + len) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
													;
													len = (len + len);
													;
													;
												} else {
														range -= bound;
														code -= bound;
														(probLen + len) = (CLzmaProb)(ttt - (ttt >> 5));
														;
														len = (len + len) + 1;
														;
														;
												} 
												;
											}
											;
										} while (len < (1 << 8));
										len -= (1 << 8);
									}
									;
									len += (1 << 3) * 2;
							} 
					} 
				}
				if (state >= 12) {
					UInt32 distance = new UInt32();
					prob = probs + (((((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + 12) + 12) + 12) + ((len < 4 ? len : 4 - 1) << 6);
					{ 
						distance = 1;
						{ 
							ttt = (prob + distance);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(prob + distance) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								distance = (distance + distance);
								;
								;
							} else {
									range -= bound;
									code -= bound;
									(prob + distance) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									distance = (distance + distance) + 1;
									;
									;
							} 
							;
						}
						;
						{ 
							ttt = (prob + distance);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(prob + distance) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								distance = (distance + distance);
								;
								;
							} else {
									range -= bound;
									code -= bound;
									(prob + distance) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									distance = (distance + distance) + 1;
									;
									;
							} 
							;
						}
						;
						{ 
							ttt = (prob + distance);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(prob + distance) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								distance = (distance + distance);
								;
								;
							} else {
									range -= bound;
									code -= bound;
									(prob + distance) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									distance = (distance + distance) + 1;
									;
									;
							} 
							;
						}
						;
						{ 
							ttt = (prob + distance);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(prob + distance) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								distance = (distance + distance);
								;
								;
							} else {
									range -= bound;
									code -= bound;
									(prob + distance) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									distance = (distance + distance) + 1;
									;
									;
							} 
							;
						}
						;
						{ 
							ttt = (prob + distance);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(prob + distance) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								distance = (distance + distance);
								;
								;
							} else {
									range -= bound;
									code -= bound;
									(prob + distance) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									distance = (distance + distance) + 1;
									;
									;
							} 
							;
						}
						;
						{ 
							ttt = (prob + distance);
							if (range < ((UInt32)1 << 24)) {
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								(prob + distance) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
								;
								distance = (distance + distance);
								;
								;
							} else {
									range -= bound;
									code -= bound;
									(prob + distance) = (CLzmaProb)(ttt - (ttt >> 5));
									;
									distance = (distance + distance) + 1;
									;
									;
							} 
							;
						}
						;
						distance -= -1024;
					}
					;
					if (distance >= 4) {
						int posSlot = (int)distance;
						int numDirectBits = (int)(((distance >> 1) - 1));
						distance = (2 | (distance & 1));
						if (posSlot < 14) {
							distance <<=  numDirectBits;
							prob = probs + (true);
							{ 
								UInt32 m = 1;
								distance++;
								do {
									ttt = (prob + distance);
									if (range < ((UInt32)1 << 24)) {
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									;
									bound = (range >> 11) * (UInt32)ttt;
									if (code < bound) {
										range = bound;
										(prob + distance) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
										;
										distance += m;
										m += m;
									} else {
											range -= bound;
											code -= bound;
											(prob + distance) = (CLzmaProb)(ttt - (ttt >> 5));
											;
											m += m;
											distance += m;
											;
									} 
									;
								} while (--numDirectBits);
								distance -= m;
							}
						} else {
								numDirectBits -= 4;
								do {
									if (range < ((UInt32)1 << 24)) {
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									range >>=  1;
									{ 
										UInt32 t = new UInt32();
										code -= range;
										t = (0 - ((UInt32)code >> /* (UInt32)((Int32)code >> 31) */31));
										distance = (distance << 1) + (t + 1);
										code += range & t/*
										              distance <<= 1;
										              if (code >= range)
										              {
										                code -= range;
										                distance |= 1;
										              }
										              */;
									}
								} while (--numDirectBits);
								prob = probs + ((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4));
								distance <<=  4;
								{ 
									int i = 1;
									ttt = (prob + i);
									if (range < ((UInt32)1 << 24)) {
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									;
									bound = (range >> 11) * (UInt32)ttt;
									if (code < bound) {
										range = bound;
										(prob + i) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
										;
										i += 1;
										;
									} else {
											range -= bound;
											code -= bound;
											(prob + i) = (CLzmaProb)(ttt - (ttt >> 5));
											;
											i += 1 * 2;
											;
									} 
									;
									ttt = (prob + i);
									if (range < ((UInt32)1 << 24)) {
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									;
									bound = (range >> 11) * (UInt32)ttt;
									if (code < bound) {
										range = bound;
										(prob + i) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
										;
										i += 2;
										;
									} else {
											range -= bound;
											code -= bound;
											(prob + i) = (CLzmaProb)(ttt - (ttt >> 5));
											;
											i += 2 * 2;
											;
									} 
									;
									ttt = (prob + i);
									if (range < ((UInt32)1 << 24)) {
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									;
									bound = (range >> 11) * (UInt32)ttt;
									if (code < bound) {
										range = bound;
										(prob + i) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
										;
										i += 4;
										;
									} else {
											range -= bound;
											code -= bound;
											(prob + i) = (CLzmaProb)(ttt - (ttt >> 5));
											;
											i += 4 * 2;
											;
									} 
									;
									ttt = (prob + i);
									if (range < ((UInt32)1 << 24)) {
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									;
									bound = (range >> 11) * (UInt32)ttt;
									if (code < bound) {
										range = bound;
										(prob + i) = (CLzmaProb)(ttt + (((1 << 11) - ttt) >> 5));
										;
										i -= 8;
									} else {
											range -= bound;
											code -= bound;
											(prob + i) = (CLzmaProb)(ttt - (ttt >> 5));
											;
											;
											;
									} 
									;
									distance |=  i;
								}
								if (distance == (UInt32)-1024) {
									len = (2 + (1 << 3) * 2 + (1 << 8));
									state -= 12;
									break;
								} 
						} 
					} 
					rep3 = rep2;
					rep2 = rep1;
					rep1 = rep0;
					rep0 = distance + 1;
					state = (state < 12 + 7) ? 7 : 7 + 3;
					if (distance >= (checkDicSize == 0 ? processedPos : checkDicSize)) {
						this.setDicPos(dicPos);
						return 1;
					} 
				} 
				len += 2;
				{ 
					SizeT rem = new SizeT();
					int curLen;
					SizeT pos = new SizeT();
					if ((rem = limit - dicPos) == 0) {
						this.setDicPos(dicPos);
						return 1;
					} 
					curLen = ((rem < len) ? (int)rem : len);
					pos = dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0);
					processedPos += (UInt32)curLen;
					len -= curLen;
					if (curLen <= dicBufSize - pos) {
						Byte dest = dic + dicPos;
						ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
						Byte lim = dest + curLen;
						dicPos += (SizeT)curLen;
						do {
							(dest) = (Byte)(dest + src);
						} while (++dest != lim);
					} else {
							do {
								dic[dicPos++] = dic[pos];
								if (++pos == dicBufSize) {
									pos = 0;
								} 
							} while (--curLen != 0);
					} 
				}
			}
		} while (dicPos < limit && buf < bufLimit);
		if (range < ((UInt32)1 << 24)) {
			range <<=  8;
			code = (code << 8) | (buf++);
		} 
		;
		this.setBuf(buf);
		this.setRange(range);
		this.setCode(code);
		this.setRemainLen((UInt32)len);
		this.setDicPos(dicPos);
		this.setProcessedPos(processedPos);
		generatedReps[0] = rep0;
		generatedReps[1] = rep1;
		generatedReps[2] = rep2;
		generatedReps[3] = rep3;
		this.setState((UInt32)state);
		return 0;
	}
	public static void LzmaDec_WriteRem(Object limit) {
		Object generatedRemainLen = this.getRemainLen();
		Object generatedDic = this.getDic();
		Object generatedDicPos = this.getDicPos();
		Object generatedDicBufSize = this.getDicBufSize();
		Object generatedReps = this.getReps();
		Object generatedCheckDicSize = this.getCheckDicSize();
		Object generatedProp = this.getProp();
		Object generatedProcessedPos = this.getProcessedPos();
		if (generatedRemainLen != 0 && generatedRemainLen < (2 + (1 << 3) * 2 + (1 << 8))) {
			Byte dic = generatedDic;
			SizeT dicPos = generatedDicPos;
			SizeT dicBufSize = generatedDicBufSize;
			int len = (int)generatedRemainLen;
			SizeT rep0 = generatedReps[/* we use SizeT to avoid the BUG of VC14 for AMD64 */0];
			SizeT rem = limit - dicPos;
			if (rem < len) {
				len = (int)(rem);
			} 
			if (generatedCheckDicSize == 0 && generatedProp.getDicSize() - generatedProcessedPos <= len) {
				this.setCheckDicSize(generatedProp.getDicSize());
			} 
			generatedProcessedPos += (UInt32)len;
			generatedRemainLen -= (UInt32)len;
			while (len != 0) {
				len--;
				dic[dicPos] = dic[dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0)];
				dicPos++;
			}
			this.setDicPos(dicPos);
		} 
	}
	public static int LzmaDec_DecodeReal2(Object limit, Object bufLimit) {
		Object generatedDicPos = this.getDicPos();
		Object generatedBuf = this.getBuf();
		Object generatedRemainLen = this.getRemainLen();
		Object generatedCheckDicSize = this.getCheckDicSize();
		Object generatedProp = this.getProp();
		Object generatedProcessedPos = this.getProcessedPos();
		Object generatedCode = this.getCode();
		do {
			SizeT limit2 = limit;
			if (generatedCheckDicSize == 0) {
				UInt32 rem = generatedProp.getDicSize() - generatedProcessedPos;
				if (limit - generatedDicPos > rem) {
					limit2 = generatedDicPos + rem;
				} 
				if (generatedProcessedPos == 0) {
					if (generatedCode >= (((-1024 >> 11) << (11 - 1)) + (((-1024 - ((-1024 >> 11) << (11 - 1))) >> 11) << (11 - 1)))) {
						return 1;
					} 
				} 
			} 
			{ 
				int __result__ = (p.LzmaDec_DecodeReal_3(limit2, bufLimit));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (generatedCheckDicSize == 0 && generatedProcessedPos >= generatedProp.getDicSize()) {
				this.setCheckDicSize(generatedProp.getDicSize());
			} 
			p.LzmaDec_WriteRem(limit);
		} while (generatedDicPos < limit && generatedBuf < bufLimit && generatedRemainLen < (2 + (1 << 3) * 2 + (1 << 8)));
		return 0/* unexpected end of input stream */;
	}
	public static  LzmaDec_TryDummy(Object p, Object buf, Object inSize) {
		UInt32 range = p.getRange();
		UInt32 code = p.getCode();
		Byte bufLimit = buf + inSize;
		CLzmaProb probs = p.getProbs_1664();
		int state = (int)p.getState();
		ELzmaDummy res = new ELzmaDummy();
		{ 
			CLzmaProb prob = new CLzmaProb();
			UInt32 bound = new UInt32();
			int ttt;
			int posState = (((p.getProcessedPos()) & ((1 << p.getProp().getPb()) - 1)) << 4);
			prob = probs + (((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (posState + state);
			ttt = (prob);
			if (range < ((UInt32)1 << 24)) {
				if (buf >= bufLimit) {
					return .DUMMY_ERROR;
				} 
				range <<=  8;
				code = (code << 8) | (buf++);
			} 
			;
			bound = (range >> 11) * (UInt32)ttt;
			if (code < bound) {
				range = bound;
				prob = probs + ((((((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + 12) + 12) + 12) + (4 << /* if (bufLimit - buf >= 7) return DUMMY_LIT; */6));
				if (p.getCheckDicSize() != 0 || p.getProcessedPos() != 0) {
					prob += ((UInt32)-1024 * ((((p.getProcessedPos()) & ((1 << (p.getProp().getLp())) - 1)) << p.getProp().getLc()) + (p.getDic()[(p.getDicPos() == 0 ? p.getDicBufSize() : p.getDicPos()) - 1] >> (8 - p.getProp().getLc()))));
				} 
				if (state < 7) {
					int symbol = 1;
					do {
						ttt = (prob + symbol);
						if (range < ((UInt32)1 << 24)) {
							if (buf >= bufLimit) {
								return .DUMMY_ERROR;
							} 
							range <<=  8;
							code = (code << 8) | (buf++);
						} 
						;
						bound = (range >> 11) * (UInt32)ttt;
						if (code < bound) {
							range = bound;
							;
							symbol = (symbol + symbol);
							;
							;
						} else {
								range -= bound;
								code -= bound;
								;
								symbol = (symbol + symbol) + 1;
								;
								;
						} 
					} while (symbol < -1024);
				} else {
						int matchByte = p.getDic()[p.getDicPos() - p.getReps()[0] + (p.getDicPos() < p.getReps()[0] ? p.getDicBufSize() : 0)];
						int offs = -1024;
						int symbol = 1;
						do {
							int bit;
							CLzmaProb probLit = new CLzmaProb();
							matchByte += matchByte;
							bit = offs;
							offs &=  matchByte;
							probLit = prob + (offs + bit + symbol);
							ttt = (probLit);
							if (range < ((UInt32)1 << 24)) {
								if (buf >= bufLimit) {
									return .DUMMY_ERROR;
								} 
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								;
								symbol = (symbol + symbol);
								offs ^=  bit;
								;
							} else {
									range -= bound;
									code -= bound;
									;
									symbol = (symbol + symbol) + 1;
									;
									;
							} 
						} while (symbol < -1024);
				} 
				res = .DUMMY_LIT;
			} else {
					int len;
					range -= bound;
					code -= bound;
					;
					prob = probs + (((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + state;
					ttt = (prob);
					if (range < ((UInt32)1 << 24)) {
						if (buf >= bufLimit) {
							return .DUMMY_ERROR;
						} 
						range <<=  8;
						code = (code << 8) | (buf++);
					} 
					;
					bound = (range >> 11) * (UInt32)ttt;
					if (code < bound) {
						range = bound;
						;
						state = 0;
						prob = probs + ((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8)));
						res = .DUMMY_MATCH;
					} else {
							range -= bound;
							code -= bound;
							;
							res = .DUMMY_REP;
							prob = probs + ((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + state;
							ttt = (prob);
							if (range < ((UInt32)1 << 24)) {
								if (buf >= bufLimit) {
									return .DUMMY_ERROR;
								} 
								range <<=  8;
								code = (code << 8) | (buf++);
							} 
							;
							bound = (range >> 11) * (UInt32)ttt;
							if (code < bound) {
								range = bound;
								;
								prob = probs + ((true) + (1 << (14 >> 1))) + (posState + state);
								ttt = (prob);
								if (range < ((UInt32)1 << 24)) {
									if (buf >= bufLimit) {
										return .DUMMY_ERROR;
									} 
									range <<=  8;
									code = (code << 8) | (buf++);
								} 
								;
								bound = (range >> 11) * (UInt32)ttt;
								if (code < bound) {
									range = bound;
									;
									if (range < ((UInt32)1 << 24)) {
										if (buf >= bufLimit) {
											return .DUMMY_ERROR;
										} 
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									;
									return .DUMMY_REP;
								} else {
										range -= bound;
										code -= bound;
										;
								} 
							} else {
									range -= bound;
									code -= bound;
									;
									prob = probs + (((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + 12) + state;
									ttt = (prob);
									if (range < ((UInt32)1 << 24)) {
										if (buf >= bufLimit) {
											return .DUMMY_ERROR;
										} 
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									;
									bound = (range >> 11) * (UInt32)ttt;
									if (code < bound) {
										range = bound;
										;
									} else {
											range -= bound;
											code -= bound;
											;
											prob = probs + ((((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + 12) + 12) + state;
											ttt = (prob);
											if (range < ((UInt32)1 << 24)) {
												if (buf >= bufLimit) {
													return .DUMMY_ERROR;
												} 
												range <<=  8;
												code = (code << 8) | (buf++);
											} 
											;
											bound = (range >> 11) * (UInt32)ttt;
											if (code < bound) {
												range = bound;
												;
											} else {
													range -= bound;
													code -= bound;
													;
											} 
									} 
							} 
							state = 12;
							prob = probs + (((true) + (1 << (14 >> 1))) + (16 << 4));
					} 
					{ 
						int limit;
						int offset;
						CLzmaProb probLen = prob + 0;
						ttt = (probLen);
						if (range < ((UInt32)1 << 24)) {
							if (buf >= bufLimit) {
								return .DUMMY_ERROR;
							} 
							range <<=  8;
							code = (code << 8) | (buf++);
						} 
						;
						bound = (range >> 11) * (UInt32)ttt;
						if (code < bound) {
							range = bound;
							;
							probLen = prob + 0 + (posState);
							offset = 0;
							limit = 1 << 3;
						} else {
								range -= bound;
								code -= bound;
								;
								probLen = prob + (0 + (1 << 3));
								ttt = (probLen);
								if (range < ((UInt32)1 << 24)) {
									if (buf >= bufLimit) {
										return .DUMMY_ERROR;
									} 
									range <<=  8;
									code = (code << 8) | (buf++);
								} 
								;
								bound = (range >> 11) * (UInt32)ttt;
								if (code < bound) {
									range = bound;
									;
									probLen = prob + 0 + (posState) + (1 << 3);
									offset = (1 << 3);
									limit = 1 << 3;
								} else {
										range -= bound;
										code -= bound;
										;
										probLen = prob + (0 + 2 * ((1 << 4) << 3));
										offset = (1 << 3) * 2;
										limit = 1 << 8;
								} 
						} 
						{ 
							len = 1;
							do {
								ttt = (probLen + len);
								if (range < ((UInt32)1 << 24)) {
									if (buf >= bufLimit) {
										return .DUMMY_ERROR;
									} 
									range <<=  8;
									code = (code << 8) | (buf++);
								} 
								;
								bound = (range >> 11) * (UInt32)ttt;
								if (code < bound) {
									range = bound;
									;
									len = (len + len);
									;
									;
								} else {
										range -= bound;
										code -= bound;
										;
										len = (len + len) + 1;
										;
										;
								} 
							} while (len < limit);
							len -= limit;
						}
						;
						len += offset;
					}
					if (state < 4) {
						int posSlot;
						prob = probs + (((((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + 12) + 12) + 12) + ((len < 4 - 1 ? len : 4 - 1) << 6);
						{ 
							posSlot = 1;
							do {
								ttt = (prob + posSlot);
								if (range < ((UInt32)1 << 24)) {
									if (buf >= bufLimit) {
										return .DUMMY_ERROR;
									} 
									range <<=  8;
									code = (code << 8) | (buf++);
								} 
								;
								bound = (range >> 11) * (UInt32)ttt;
								if (code < bound) {
									range = bound;
									;
									posSlot = (posSlot + posSlot);
									;
									;
								} else {
										range -= bound;
										code -= bound;
										;
										posSlot = (posSlot + posSlot) + 1;
										;
										;
								} 
							} while (posSlot < 1 << 6);
							posSlot -= 1 << 6;
						}
						;
						if (posSlot >= 4) {
							int numDirectBits = ((posSlot >> 1) - 1);
							if (posSlot < /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */14) {
								prob = probs + (true) + ((2 | (posSlot & 1)) << numDirectBits);
							} else {
									numDirectBits -= 4;
									do {
										if (range < ((UInt32)1 << 24)) {
											if (buf >= bufLimit) {
												return .DUMMY_ERROR;
											} 
											range <<=  8;
											code = (code << 8) | (buf++);
										} 
										range >>=  1;
										code -= range & (((code - range) >> 31) - 1/* if (code >= range) code -= range; */);
									} while (--numDirectBits);
									prob = probs + ((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4));
									numDirectBits = 4;
							} 
							{ 
								int i = 1;
								int m = 1;
								do {
									ttt = (prob + i);
									if (range < ((UInt32)1 << 24)) {
										if (buf >= bufLimit) {
											return .DUMMY_ERROR;
										} 
										range <<=  8;
										code = (code << 8) | (buf++);
									} 
									;
									bound = (range >> 11) * (UInt32)ttt;
									if (code < bound) {
										range = bound;
										;
										i += m;
										m += m;
									} else {
											range -= bound;
											code -= bound;
											;
											m += m;
											i += m;
									} 
									;
								} while (--numDirectBits);
							}
						} 
					} 
			} 
		}
		if (range < ((UInt32)1 << 24)) {
			if (buf >= bufLimit) {
				return .DUMMY_ERROR;
			} 
			range <<=  8;
			code = (code << 8) | (buf++);
		} 
		;
		return res;
	}
	public static void LzmaDec_InitDicAndState(Object initDic, Object initState) {
		this.setRemainLen((2 + (1 << 3) * 2 + (1 << 8)) + 1);
		this.setTempBufSize(0);
		if (initDic) {
			this.setProcessedPos(0);
			this.setCheckDicSize(0);
			this.setRemainLen((2 + (1 << 3) * 2 + (1 << 8)) + 2);
		} 
		if (initState) {
			this.setRemainLen((2 + (1 << 3) * 2 + (1 << 8)) + 2);
		} 
	}
	public static void LzmaDec_Init() {
		this.setDicPos(0);
		p.LzmaDec_InitDicAndState(1, 1);
	}
	public static Object LzmaDec_DecodeToDic(Object dicLimit, Object src, Object srcLen,  finishMode,  status) {
		SizeT inSize = srcLen;
		(srcLen) = 0;
		status = .LZMA_STATUS_NOT_SPECIFIED;
		Object generatedRemainLen = this.getRemainLen();
		Object generatedTempBufSize = this.getTempBufSize();
		Object generatedTempBuf = this.getTempBuf();
		Object generatedProp = this.getProp();
		Object generatedProbs = this.getProbs();
		Object generatedReps = this.getReps();
		if (generatedRemainLen > (2 + (1 << 3) * 2 + (1 << 8))) {
			for (; inSize > 0 && generatedTempBufSize < 5; ) {
				generatedTempBuf[generatedTempBufSize++] = src++;
			}
			if (generatedTempBufSize != 0 && generatedTempBuf[0] != 0) {
				return 1;
			} 
			if (generatedTempBufSize < 5) {
				status = .LZMA_STATUS_NEEDS_MORE_INPUT;
				return 0;
			} 
			this.setCode(((UInt32)generatedTempBuf[1] << 24) | ((UInt32)generatedTempBuf[2] << 16) | ((UInt32)generatedTempBuf[3] << 8) | ((UInt32)generatedTempBuf[4]));
			this.setRange(-1024);
			this.setTempBufSize(0);
			if (generatedRemainLen > (2 + (1 << 3) * 2 + (1 << 8)) + 1) {
				SizeT numProbs = ((((((((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + 12) + 12) + 12) + (4 << 6)) + 1664) + ((UInt32)-1024 << ((generatedProp).getLc() + (generatedProp).getLp())));
				SizeT i = new SizeT();
				CLzmaProb probs = generatedProbs;
				for (i = 0; i < numProbs; i++) {
					probs[i] = (1 << 11) >> 1;
				}
				generatedReps[0] = generatedReps[1] = generatedReps[2] = generatedReps[3] = 1;
				this.setState(0);
			} 
			this.setRemainLen(0);
		} 
		p.LzmaDec_WriteRem(dicLimit);
		Object generatedDicPos = this.getDicPos();
		Object generatedCode = this.getCode();
		Object generatedBuf = this.getBuf();
		while (generatedRemainLen != (2 + (1 << 3) * 2 + (1 << 8))) {
			int checkEndMarkNow = 0;
			if (generatedDicPos >= dicLimit) {
				if (generatedRemainLen == 0 && generatedCode == 0) {
					status = .LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
					return 0;
				} 
				if (finishMode == .LZMA_FINISH_ANY) {
					status = .LZMA_STATUS_NOT_FINISHED;
					return 0;
				} 
				if (generatedRemainLen != 0) {
					status = .LZMA_STATUS_NOT_FINISHED;
					return 1;
				} 
				checkEndMarkNow = 1;
			} 
			if (generatedTempBufSize == 0) {
				SizeT processed = new SizeT();
				Byte bufLimit = new Byte();
				if (inSize < 20 || checkEndMarkNow) {
					int dummyRes = ModernizedCProgram.LzmaDec_TryDummy(p, src, inSize);
					if (dummyRes == .DUMMY_ERROR) {
						.memcpy(generatedTempBuf, src, inSize);
						this.setTempBufSize((int)inSize);
						(srcLen) += inSize;
						status = .LZMA_STATUS_NEEDS_MORE_INPUT;
						return 0;
					} 
					if (checkEndMarkNow && dummyRes != .DUMMY_MATCH) {
						status = .LZMA_STATUS_NOT_FINISHED;
						return 1;
					} 
					bufLimit = src;
				} else {
						bufLimit = src + inSize - 20;
				} 
				this.setBuf(src);
				if (p.LzmaDec_DecodeReal2(dicLimit, bufLimit) != 0) {
					return 1;
				} 
				processed = (SizeT)(generatedBuf - src);
				(srcLen) += processed;
				src += processed;
				inSize -= processed;
			} else {
					int rem = generatedTempBufSize;
					int lookAhead = 0;
					while (rem < 20 && lookAhead < inSize) {
						generatedTempBuf[rem++] = src[lookAhead++];
					}
					this.setTempBufSize(rem);
					if (rem < 20 || checkEndMarkNow) {
						int dummyRes = ModernizedCProgram.LzmaDec_TryDummy(p, generatedTempBuf, (SizeT)rem);
						if (dummyRes == .DUMMY_ERROR) {
							(srcLen) += (SizeT)lookAhead;
							status = .LZMA_STATUS_NEEDS_MORE_INPUT;
							return 0;
						} 
						if (checkEndMarkNow && dummyRes != .DUMMY_MATCH) {
							status = .LZMA_STATUS_NOT_FINISHED;
							return 1;
						} 
					} 
					this.setBuf(generatedTempBuf);
					if (p.LzmaDec_DecodeReal2(dicLimit, generatedBuf) != 0) {
						return 1;
					} 
					{ 
						int kkk = (int)(generatedBuf - generatedTempBuf);
						if (rem < kkk) {
							return /* some internal error */11;
						} 
						rem -= kkk;
						if (lookAhead < rem) {
							return /* some internal error */11;
						} 
						lookAhead -= rem;
					}
					(srcLen) += (SizeT)lookAhead;
					src += lookAhead;
					inSize -= (SizeT)lookAhead;
					this.setTempBufSize(0);
			} 
		}
		if (generatedCode != 0) {
			return 1;
		} 
		status = .LZMA_STATUS_FINISHED_WITH_MARK;
		return 0;
	}
	public static Object LzmaDec_DecodeToBuf(Object dest, Object destLen, Object src, Object srcLen,  finishMode,  status) {
		SizeT outSize = destLen;
		SizeT inSize = srcLen;
		srcLen = destLen = 0;
		Object generatedDicPos = this.getDicPos();
		Object generatedDicBufSize = this.getDicBufSize();
		Object generatedDic = this.getDic();
		for (; ; ) {
			SizeT inSizeCur = inSize;
			SizeT outSizeCur = new SizeT();
			SizeT dicPos = new SizeT();
			ELzmaFinishMode curFinishMode = new ELzmaFinishMode();
			SRes res = new SRes();
			if (generatedDicPos == generatedDicBufSize) {
				this.setDicPos(0);
			} 
			dicPos = generatedDicPos;
			if (outSize > generatedDicBufSize - dicPos) {
				outSizeCur = generatedDicBufSize;
				curFinishMode = .LZMA_FINISH_ANY;
			} else {
					outSizeCur = dicPos + outSize;
					curFinishMode = finishMode;
			} 
			res = p.LzmaDec_DecodeToDic(outSizeCur, src, inSizeCur, curFinishMode, status);
			src += inSizeCur;
			inSize -= inSizeCur;
			srcLen += inSizeCur;
			outSizeCur = generatedDicPos - dicPos;
			.memcpy(dest, generatedDic + dicPos, outSizeCur);
			dest += outSizeCur;
			outSize -= outSizeCur;
			destLen += outSizeCur;
			if (res != 0) {
				return res;
			} 
			if (outSizeCur == 0 || outSize == 0) {
				return 0;
			} 
		}
	}
	public static void LzmaDec_FreeProbs(Object alloc) {
		Object generatedProbs = this.getProbs();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedProbs);
		this.setProbs(((Object)0));
	}
	public static void LzmaDec_FreeDict(Object alloc) {
		Object generatedDic = this.getDic();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedDic);
		this.setDic(((Object)0));
	}
	public static void LzmaDec_Free(Object alloc) {
		p.LzmaDec_FreeProbs(alloc);
		p.LzmaDec_FreeDict(alloc);
	}
	public static Object LzmaDec_AllocateProbs2(Object propNew, Object alloc) {
		UInt32 numProbs = ((((((((((((((true) + (1 << (14 >> 1))) + (16 << 4)) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + ((0 + 2 * ((1 << 4) << 3)) + (1 << 8))) + (16 << 4)) + (1 << 4)) + 12) + 12) + 12) + 12) + (4 << 6)) + 1664) + ((UInt32)-1024 << ((propNew).getLc() + (propNew).getLp())));
		Object generatedProbs = this.getProbs();
		Object generatedNumProbs = this.getNumProbs();
		if (!generatedProbs || numProbs != generatedNumProbs) {
			p.LzmaDec_FreeProbs(alloc);
			this.setProbs((CLzmaProb).UNRECOGNIZEDFUNCTIONNAME(alloc, numProbs * ));
			if (!generatedProbs) {
				return 2;
			} 
			this.setProbs_1664(generatedProbs + 1664);
			this.setNumProbs(numProbs);
		} 
		return 0;
	}
	public static Object LzmaDec_AllocateProbs(Object props, int propsSize, Object alloc) {
		CLzmaProps propNew = new CLzmaProps();
		{ 
			int __result__ = (propNew.LzmaProps_Decode(props, propsSize));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		{ 
			int __result__ = (p.LzmaDec_AllocateProbs2(propNew, alloc));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		this.setProp(propNew);
		return 0;
	}
	public static Object LzmaDec_Allocate(Object props, int propsSize, Object alloc) {
		CLzmaProps propNew = new CLzmaProps();
		SizeT dicBufSize = new SizeT();
		{ 
			int __result__ = (propNew.LzmaProps_Decode(props, propsSize));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		{ 
			int __result__ = (p.LzmaDec_AllocateProbs2(propNew, alloc));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedDicSize = propNew.getDicSize();
		{ 
			UInt32 dictSize = generatedDicSize;
			SizeT mask = ((UInt32)1 << 12) - 1;
			if (dictSize >= ((UInt32)1 << 30)) {
				mask = ((UInt32)1 << 22) - 1;
			}  else if (dictSize >= ((UInt32)1 << 22)) {
				mask = ((UInt32)1 << 20) - 1;
			} 
			;
			dicBufSize = ((SizeT)dictSize + mask) & ~mask;
			if (dicBufSize < dictSize) {
				dicBufSize = dictSize;
			} 
		}
		Object generatedDic = this.getDic();
		Object generatedDicBufSize = this.getDicBufSize();
		if (!generatedDic || dicBufSize != generatedDicBufSize) {
			p.LzmaDec_FreeDict(alloc);
			this.setDic((Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, dicBufSize));
			if (!generatedDic) {
				p.LzmaDec_FreeProbs(alloc);
				return 2;
			} 
		} 
		this.setDicBufSize(dicBufSize);
		this.setProp(propNew);
		return 0;
	}
	public static Object LzmaDecode(Object dest, Object destLen, Object src, Object srcLen, Object propData, int propSize,  finishMode,  status, Object alloc) {
		CLzmaDec p = new CLzmaDec();
		SRes res = new SRes();
		SizeT outSize = destLen;
		SizeT inSize = srcLen;
		destLen = srcLen = 0;
		status = .LZMA_STATUS_NOT_SPECIFIED;
		if (inSize < 5) {
			return 6;
		} 
		{ 
			(p).setDic(((Object)0));
			(p).setProbs(((Object)0));
		}
		;
		{ 
			int __result__ = (p.LzmaDec_AllocateProbs(propData, propSize, alloc));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		p.setDic(dest);
		p.setDicBufSize(outSize);
		p.LzmaDec_Init();
		srcLen = inSize;
		res = p.LzmaDec_DecodeToDic(outSize, src, srcLen, finishMode, status);
		Object generatedDicPos = p.getDicPos();
		destLen = generatedDicPos;
		if (res == 0 && status == .LZMA_STATUS_NEEDS_MORE_INPUT) {
			res = 6;
		} 
		p.LzmaDec_FreeProbs(alloc);
		return res;
	}
	/* gzclose.c -- zlib gzclose() function
	 * Copyright (C) 2004, 2010 Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */
	/* gzclose() is in a separate file so that it is linked in only if it is used.
	   That way the other gzclose functions can be used instead to avoid linking in
	   unneeded compression or decompression routines. */
	public static int gzclose(Object file) {
		gz_statep state = new gz_statep();
		if (file == ((Object)0)) {
			return (true);
		} 
		state = (gz_statep)file;
		return state.getMode() == 7247 ? ModernizedCProgram.gzclose_r(file) : ModernizedCProgram.gzclose_w(file);
	}
	/* mymkdir and change_file_date are not 100 % portable
	   As I don't know well Unix, I wait feedback for the unix portion */
	public static int mymkdir(Object dirname) {
		int ret = 0;
		ret = ._mkdir(dirname);
		return ret;
	}
	public static int makedir(Byte newdir) {
		byte buffer;
		byte p;
		int len = (int).strlen(newdir);
		if (len <= 0) {
			return 0;
		} 
		buffer = (byte).malloc(len + 1);
		if (buffer == ((Object)0)) {
			.printf("Error allocating memory\n");
			return (true);
		} 
		.strcpy(buffer, newdir);
		if (buffer[len - 1] == (byte)'/') {
			buffer[len - 1] = (byte)'\0';
		} 
		if (ModernizedCProgram.mymkdir(buffer) == 0) {
			.free(buffer);
			return 1;
		} 
		p = buffer + 1;
		while (1) {
			byte hold;
			while (p && p != (byte)'\\' && p != (byte)'/') {
				p++;
			}
			hold = p;
			p = 0;
			if ((ModernizedCProgram.mymkdir(buffer) == -1) && ((._errno()) == 2)) {
				.printf("couldn't create directory %s\n", buffer);
				.free(buffer);
				return 0;
			} 
			if (hold == 0) {
				break;
			} 
			p++ = hold;
		}
		.free(buffer);
		return 1;
		byte buffer = .strdup(newdir);
		byte p;
		int len = .strlen(buffer);
		if (len <= 0) {
			.free(buffer);
			return 0;
		} 
		if (buffer[len - 1] == (byte)'/') {
			buffer[len - 1] = (byte)'\0';
		} 
		if (._mkdir(buffer) == 0) {
			.free(buffer);
			return 1;
		} 
		p = buffer + 1;
		while (1) {
			byte hold;
			while (p && p != (byte)'\\' && p != (byte)'/') {
				p++;
			}
			hold = p;
			p = 0;
			if ((._mkdir(buffer) == -1) && ((._errno()) == 2)) {
				.fprintf((_iob[2]), "%s: Couldn't create directory %s\n", ModernizedCProgram.prog, buffer);
				.free(buffer);
				return 0;
			} 
			if (hold == 0) {
				break;
			} 
			p++ = hold;
		}
		.free(buffer);
		return 1;
	}
	public static void Display64BitsSize(Object n, int size_char) {
		byte[] number = new byte[/* to avoid compatibility problem , we do here the conversion */21];
		int offset = 19;
		int pos_string = 19;
		number[20] = 0;
		for (; ; ) {
			number[offset] = (byte)((n % 10) + (byte)'0');
			if (number[offset] != (byte)'0') {
				pos_string = offset;
			} 
			n /= 10;
			if (offset == 0) {
				break;
			} 
			offset--;
		}
		{ 
			int size_display_string = 19 - pos_string;
			while (size_char > size_display_string) {
				size_char--;
				.printf(" ");
			}
		}
		.printf("%s", number[pos_string]);
	}
	public static int do_list(Object uf) {
		uLong i = new uLong();
		unz_global_info64 gi = new unz_global_info64();
		int err;
		err = gi.unzGetGlobalInfo64(uf);
		if (err != (false)) {
			.printf("error %d with zipfile in unzGetGlobalInfo \n", err);
		} 
		.printf("  Length  Method     Size Ratio   Date    Time   CRC-32     Name\n");
		.printf("  ------  ------     ---- -----   ----    ----   ------     ----\n");
		Object generatedNumber_entry = gi.getNumber_entry();
		Object generatedUncompressed_size = file_info.getUncompressed_size();
		Object generatedCompressed_size = file_info.getCompressed_size();
		Object generatedFlag = file_info.getFlag();
		Object generatedCompression_method = file_info.getCompression_method();
		tm_unz_s generatedTmu_date = file_info.getTmu_date();
		Object generatedTm_mon = generatedTmu_date.getTm_mon();
		Object generatedTm_mday = generatedTmu_date.getTm_mday();
		Object generatedTm_year = generatedTmu_date.getTm_year();
		Object generatedTm_hour = generatedTmu_date.getTm_hour();
		Object generatedTm_min = generatedTmu_date.getTm_min();
		Object generatedCrc = file_info.getCrc();
		for (i = 0; i < generatedNumber_entry; i++) {
			byte[] filename_inzip = new byte[256];
			unz_file_info64 file_info = new unz_file_info64();
			uLong ratio = 0;
			byte string_method;
			byte charCrypt = (byte)' ';
			err = file_info.unzGetCurrentFileInfo64(uf, filename_inzip, , ((Object)0), 0, ((Object)0), 0);
			if (err != (false)) {
				.printf("error %d with zipfile in unzGetCurrentFileInfo\n", err);
				break;
			} 
			if (generatedUncompressed_size > 0) {
				ratio = (uLong)((generatedCompressed_size * 100) / generatedUncompressed_size);
			} 
			if ((generatedFlag & 1) != /* display a '*' if the file is crypted */0) {
				charCrypt = (byte)'*';
			} 
			if (generatedCompression_method == 0) {
				string_method = "Stored";
			}  else if (generatedCompression_method == 8) {
				uInt iLevel = (uInt)((generatedFlag & -1024) / 2);
				if (iLevel == 0) {
					string_method = "Defl:N";
				}  else if (iLevel == 1) {
					string_method = "Defl:X";
				}  else if ((iLevel == 2) || (iLevel == 3)) {
					string_method = /* 2:fast , 3 : extra fast*/"Defl:F";
				} 
			}  else if (generatedCompression_method == 12) {
				string_method = "BZip2 ";
			} else {
					string_method = "Unkn. ";
			} 
			ModernizedCProgram.Display64BitsSize(generatedUncompressed_size, 7);
			.printf("  %6s%c", string_method, charCrypt);
			ModernizedCProgram.Display64BitsSize(generatedCompressed_size, 7);
			.printf(" %3lu%%  %2.2lu-%2.2lu-%2.2lu  %2.2lu:%2.2lu  %8.8lx   %s\n", ratio, (uLong)generatedTm_mon + 1, (uLong)generatedTm_mday, (uLong)generatedTm_year % 100, (uLong)generatedTm_hour, (uLong)generatedTm_min, (uLong)generatedCrc, filename_inzip);
			if ((i + 1) < generatedNumber_entry) {
				err = ModernizedCProgram.unzGoToNextFile(uf);
				if (err != (false)) {
					.printf("error %d with zipfile in unzGoToNextFile\n", err);
					break;
				} 
			} 
		}
		return 0;
	}
	public static int do_extract_currentfile(Object uf, Object popt_extract_without_path, int popt_overwrite, Object password) {
		byte[] filename_inzip = new byte[256];
		byte filename_withoutpath;
		byte p;
		int err = (false);
		FILE fout = ((Object)0);
		Object buf;
		uInt size_buf = new uInt();
		unz_file_info64 file_info = new unz_file_info64();
		uLong ratio = 0;
		err = file_info.unzGetCurrentFileInfo64(uf, filename_inzip, , ((Object)0), 0, ((Object)0), 0);
		if (err != (false)) {
			.printf("error %d with zipfile in unzGetCurrentFileInfo\n", err);
			return err;
		} 
		size_buf = (true);
		buf = (Object).malloc(size_buf);
		if (buf == ((Object)0)) {
			.printf("Error allocating memory\n");
			return (true);
		} 
		p = filename_withoutpath = filename_inzip;
		while ((p) != (byte)'\0') {
			if (((p) == (byte)'/') || ((p) == (byte)'\\')) {
				filename_withoutpath = p + 1;
			} 
			p++;
		}
		Object generatedDosDate = file_info.getDosDate();
		tm_unz_s generatedTmu_date = file_info.getTmu_date();
		if ((filename_withoutpath) == (byte)'\0') {
			if ((popt_extract_without_path) == 0) {
				.printf("creating directory: %s\n", filename_inzip);
				ModernizedCProgram.mymkdir(filename_inzip);
			} 
		} else {
				byte write_filename;
				int skip = 0;
				if ((popt_extract_without_path) == 0) {
					write_filename = filename_inzip;
				} else {
						write_filename = filename_withoutpath;
				} 
				err = ModernizedCProgram.unzOpenCurrentFilePassword(uf, password);
				if (err != (false)) {
					.printf("error %d with zipfile in unzOpenCurrentFilePassword\n", err);
				} 
				if (((popt_overwrite) == 0) && (err == (false))) {
					byte rep = 0;
					FILE ftestexist = new FILE();
					ftestexist = .fopen64(write_filename, "rb");
					if (ftestexist != ((Object)0)) {
						.fclose(ftestexist);
						do {
							byte[] answer = new byte[128];
							int ret;
							.printf("The file %s exists. Overwrite ? [y]es, [n]o, [A]ll: ", write_filename);
							ret = .scanf("%1s", answer);
							if (ret != 1) {
								.exit(1);
							} 
							rep = answer[0];
							if ((rep >= (byte)'a') && (rep <= (byte)'z')) {
								rep -= -1024;
							} 
						} while ((rep != (byte)'Y') && (rep != (byte)'N') && (rep != (byte)'A'));
					} 
					if (rep == (byte)'N') {
						skip = 1;
					} 
					if (rep == (byte)'A') {
						popt_overwrite = 1;
					} 
				} 
				if ((skip == 0) && (err == (false))) {
					fout = .fopen64(write_filename, "wb");
					if ((fout == ((Object)0)) && ((popt_extract_without_path) == /* some zipfile don't contain directory alone before file */0) && (filename_withoutpath != (byte)filename_inzip)) {
						byte c = (filename_withoutpath - 1);
						(filename_withoutpath - 1) = (byte)'\0';
						ModernizedCProgram.makedir(write_filename);
						(filename_withoutpath - 1) = c;
						fout = .fopen64(write_filename, "wb");
					} 
					if (fout == ((Object)0)) {
						.printf("error opening %s\n", write_filename);
					} 
				} 
				if (fout != ((Object)0)) {
					.printf(" extracting: %s\n", write_filename);
					do {
						err = ModernizedCProgram.unzReadCurrentFile(uf, buf, size_buf);
						if (err < 0) {
							.printf("error %d with zipfile in unzReadCurrentFile\n", err);
							break;
						} 
						if (err > 0) {
							if (.fwrite(buf, err, 1, fout) != 1) {
								.printf("error in writing extracted file\n");
								err = ((true));
								break;
							} 
						} 
					} while (err > 0);
					if (fout) {
						.fclose(fout);
					} 
					if (err == 0) {
						generatedTmu_date.change_file_date(write_filename, generatedDosDate);
					} 
				} 
				if (err == (false)) {
					err = ModernizedCProgram.unzCloseCurrentFile(uf);
					if (err != (false)) {
						.printf("error %d with zipfile in unzCloseCurrentFile\n", err);
					} 
				} else {
						ModernizedCProgram.unzCloseCurrentFile(/* don't lose the error */uf);
				} 
		} 
		.free(buf);
		return err;
	}
	public static int do_extract(Object uf, int opt_extract_without_path, int opt_overwrite, Object password) {
		uLong i = new uLong();
		unz_global_info64 gi = new unz_global_info64();
		int err;
		FILE fout = ((Object)0);
		err = gi.unzGetGlobalInfo64(uf);
		if (err != (false)) {
			.printf("error %d with zipfile in unzGetGlobalInfo \n", err);
		} 
		Object generatedNumber_entry = gi.getNumber_entry();
		for (i = 0; i < generatedNumber_entry; i++) {
			if (ModernizedCProgram.do_extract_currentfile(uf, opt_extract_without_path, opt_overwrite, password) != (false)) {
				break;
			} 
			if ((i + 1) < generatedNumber_entry) {
				err = ModernizedCProgram.unzGoToNextFile(uf);
				if (err != (false)) {
					.printf("error %d with zipfile in unzGoToNextFile\n", err);
					break;
				} 
			} 
		}
		return 0;
	}
	public static int do_extract_onefile(Object uf, Object filename, int opt_extract_without_path, int opt_overwrite, Object password) {
		int err = (false);
		if (ModernizedCProgram.unzLocateFile(uf, filename, (false)) != (false)) {
			.printf("file %s not found in the zipfile\n", filename);
			return 2;
		} 
		if (ModernizedCProgram.do_extract_currentfile(uf, opt_extract_without_path, opt_overwrite, password) == (false)) {
			return 0;
		} else {
				return 1;
		} 
	}
	public static int setup_console() {
		ModernizedCProgram.SetConsoleWindowSize(132);
		if (._setmode((((_iob[0])).get_file()), -1024) == -1) {
			.__mingw_fprintf((_iob[2]), "%s: %m", "stdin");
			return -1;
		} 
		if (._setmode((((_iob[1])).get_file()), -1024) == -1) {
			.__mingw_fprintf((_iob[2]), "%s: %m", "stdin");
			return -1;
		} 
		if (._setmode((((_iob[2])).get_file()), -1024) == -1) {
			.__mingw_fprintf((_iob[2]), "%s: %m", "stdin");
			return -1;
		} 
		return 0;
	}
	public static Object thread_keypress(Object p) {
		hashcat_ctx_t hashcat_ctx = (hashcat_ctx_t)p;
		hashcat_ctx.keypress();
		return ((Object)0);
	}
	public static void SetConsoleWindowSize(Object x) {
		HANDLE h = .GetStdHandle((DWORD)(true));
		if (h == (HANDLE)(true)) {
			return ;
		} 
		CONSOLE_SCREEN_BUFFER_INFO bufferInfo = new CONSOLE_SCREEN_BUFFER_INFO();
		if (!.GetConsoleScreenBufferInfo(h, bufferInfo)) {
			return ;
		} 
		Object generatedSrWindow = bufferInfo.getSrWindow();
		SMALL_RECT sr = generatedSrWindow;
		Object generatedRight = sr.getRight();
		sr.setRight((((generatedRight) > (x - 1)) ? (generatedRight) : (x - 1)));
		COORD co = new COORD();
		co.setX(generatedRight + 1);
		co.setY(9999);
		if (!.SetConsoleScreenBufferSize(h, co)) {
			return ;
		} 
		if (!.SetConsoleWindowInfo(h, 1, sr)) {
			return ;
		} 
	}
	public static int tty_break() {
		HANDLE stdinHandle = .GetStdHandle((DWORD)(true));
		.GetConsoleMode(stdinHandle, ModernizedCProgram.saveMode);
		.SetConsoleMode(stdinHandle, 1);
		return 0;
	}
	public static int tty_getchar() {
		HANDLE stdinHandle = .GetStdHandle((DWORD)(true));
		DWORD rc = .WaitForSingleObject(stdinHandle, 1000);
		if (rc == -1024) {
			return 0;
		} 
		if (rc == 128) {
			return -1;
		} 
		if (rc == ((DWORD)-1024)) {
			return -1;
		} 
		// The whole ReadConsoleInput () part is a workaround.// For some unknown reason, maybe a mingw bug, a random signal// is sent to stdin which unblocks WaitForSingleObject () and sets rc 0.
		// Then it wants to read with getche () a keyboard input// which has never been made.INPUT_RECORD[] buf = new INPUT_RECORD();
		DWORD num = 0;
		.memset(buf, 0, );
		.ReadConsoleInputA(stdinHandle, buf, 100, num);
		.FlushConsoleInputBuffer(stdinHandle);
		Object generatedBKeyDown = KeyEvent.getBKeyDown();
		Object generatedUChar = KeyEvent.getUChar();
		for (DWORD i = 0;
		 i < num; i++) {
			if (buf[i].getEventType() != 1) {
				continue;
			} 
			KEY_EVENT_RECORD KeyEvent = buf[i].getEvent().getKeyEvent();
			if (generatedBKeyDown != 1) {
				continue;
			} 
			return generatedUChar.getAsciiChar();
		}
		return 0;
	}
	public static int tty_fix() {
		HANDLE stdinHandle = .GetStdHandle((DWORD)(true));
		.SetConsoleMode(stdinHandle, ModernizedCProgram.saveMode);
		return 0;
	}
	public static void compress_terminal_line_length(Byte out_buf, Object keep_from_beginning, Object keep_from_end) {
		size_t target_len = ModernizedCProgram.TERMINAL_LINE_LENGTH - keep_from_beginning;
		size_t out_len = .strlen(out_buf);
		if (out_len < target_len) {
			return ;
		} 
		byte ptr1 = out_buf + target_len - 3 - keep_from_end;
		byte ptr2 = out_buf + out_len - keep_from_end;
		ptr1++ = (byte)'.';
		ptr1++ = (byte)'.';
		ptr1++ = (byte)'.';
		for (size_t i = 0;
		 i < keep_from_end; i++) {
			ptr1++ = ptr2++;
		}
		ptr1 = 0;
	}
	// this function is special and only used whenever --username and --show are used together:
	// it will sort all tree entries according to the settings stored in hashconfig
	public static int sort_pot_tree_by_hash(Object v1, Object v2) {
		pot_tree_entry_t t1 = (pot_tree_entry_t)v1;
		pot_tree_entry_t t2 = (pot_tree_entry_t)v2;
		hash_t h1 = (hash_t)t1.getNodes().getHash_buf();
		hash_t h2 = (hash_t)t2.getNodes().getHash_buf();
		// is same as t2->hashconfighashconfig_t hc = t1.getHashconfig();
		return ModernizedCProgram.sort_by_hash(h1, h2, hc);// the problem with the GNU tdestroy () function is that it doesn't work with mingw etc// there are 2 alternatives:
	}
	public static void potfile_update_hash(hashcat_ctx hashcat_ctx, hash found, Byte line_pw_buf, int line_pw_len) {
		loopback_ctx generatedLoopback_ctx = hashcat_ctx.getLoopback_ctx();
		loopback_ctx_t loopback_ctx = generatedLoopback_ctx;
		if (found == ((Object)0)) {
			return ;
		} 
		byte pw_buf = line_pw_buf;
		int pw_len = line_pw_len;
		found.setPw_buf((byte)ModernizedCProgram.hcmalloc(pw_len + 1));
		found.setPw_len(pw_len);
		Byte generatedPw_buf = found.getPw_buf();
		int generatedPw_len = found.getPw_len();
		if (pw_buf) {
			.memcpy(generatedPw_buf, pw_buf, pw_len);
			generatedPw_buf[generatedPw_len] = 0;
		} 
		found.setCracked(1)// if enabled, update also the loopback file;// if enabled, update also the loopback file
		if (loopback_ctx.getFp().getPfp() != ((Object)0)) {
			hashcat_ctx.loopback_write_append((u8)pw_buf, (int)pw_len);
		} 
	}
	public static void potfile_update_hashes(hashcat_ctx hashcat_ctx, hash hash_buf, Byte line_pw_buf, int line_pw_len, pot_tree_entry tree) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		// the linked list node:
		pot_hash_node_t search_node = new pot_hash_node_t();
		search_node.setHash_buf(hash_buf);
		search_node.setNext(((Object)0))// the search entry:;// the search entry:
		pot_tree_entry_t search_entry = new pot_tree_entry_t();
		search_entry.setNodes(search_node);
		search_entry.setHashconfig(hashconfig)// the main search function is this:;// the main search function is this:
		Object found = .tfind(search_entry, (Object)tree, ModernizedCProgram.sort_pot_tree_by_hash);
		pot_hash_node generatedNodes = found_entry.getNodes();
		hash generatedHash_buf = node.getHash_buf();
		pot_hash_node generatedNext = node.getNext();
		if (found) {
			pot_tree_entry_t found_entry = (pot_tree_entry_t)found;
			pot_hash_node_t node = generatedNodes;
			while (node) {
				ModernizedCProgram.potfile_update_hash(hashcat_ctx, generatedHash_buf, line_pw_buf, line_pw_len);
				node = generatedNext;
			}
		} 
	}
	/* Ppmd7Dec.c -- PPMdH Decoder
	2018-07-04 : Igor Pavlov : Public domain
	This code is based on PPMd var.H (2001): Dmitry Shkarin : Public domain */
	public static Object Ppmd7z_RangeDec_Init() {
		int i;
		this.setCode(0);
		this.setRange(-1024);
		Object generatedStream = this.getStream();
		if (.UNRECOGNIZEDFUNCTIONNAME(generatedStream) != 0) {
			return 0;
		} 
		Object generatedCode = this.getCode();
		for (i = 0; i < 4; i++) {
			this.setCode((generatedCode << 8) | .UNRECOGNIZEDFUNCTIONNAME(generatedStream));
		}
		return (generatedCode < -1024);
	}
	public static Object Range_GetThreshold(Object pp, Object total) {
		CPpmd7z_RangeDec p = ((CPpmd7z_RangeDec)((byte)(true ? (pp) : ((CPpmd7z_RangeDec)0).getVt()) - ((size_t)((CPpmd7z_RangeDec)0).getVt())));
		Object generatedCode = p.getCode();
		Object generatedRange = p.getRange();
		return generatedCode / (generatedRange /= total);
	}
	public static void Range_Normalize() {
		Object generatedRange = this.getRange();
		Object generatedCode = this.getCode();
		Object generatedStream = this.getStream();
		if (generatedRange < (1 << 24)) {
			this.setCode((generatedCode << 8) | .UNRECOGNIZEDFUNCTIONNAME(generatedStream));
			generatedRange <<=  8;
			if (generatedRange < (1 << 24)) {
				this.setCode((generatedCode << 8) | .UNRECOGNIZEDFUNCTIONNAME(generatedStream));
				generatedRange <<=  8;
			} 
		} 
	}
	public static void Range_Decode(Object pp, Object start, Object size) {
		CPpmd7z_RangeDec p = ((CPpmd7z_RangeDec)((byte)(true ? (pp) : ((CPpmd7z_RangeDec)0).getVt()) - ((size_t)((CPpmd7z_RangeDec)0).getVt())));
		Object generatedCode = p.getCode();
		Object generatedRange = p.getRange();
		generatedCode -= start * generatedRange;
		generatedRange *= size;
		p.Range_Normalize();
	}
	public static Object Range_DecodeBit(Object pp, Object size0) {
		CPpmd7z_RangeDec p = ((CPpmd7z_RangeDec)((byte)(true ? (pp) : ((CPpmd7z_RangeDec)0).getVt()) - ((size_t)((CPpmd7z_RangeDec)0).getVt())));
		Object generatedRange = p.getRange();
		UInt32 newBound = (generatedRange >> 14) * size0;
		UInt32 symbol = new UInt32();
		Object generatedCode = p.getCode();
		if (generatedCode < newBound) {
			symbol = 0;
			p.setRange(newBound);
		} else {
				symbol = 1;
				generatedCode -= newBound;
				generatedRange -= newBound;
		} 
		p.Range_Normalize();
		return symbol;
	}
	public static void Ppmd7z_RangeDec_CreateVTable() {
		Object generatedVt = this.getVt();
		generatedVt.setGetThreshold(Range_GetThreshold);
		generatedVt.setDecode(Range_Decode);
		generatedVt.setDecodeBit(Range_DecodeBit);
	}
	public static int Ppmd7_DecodeSymbol(Object rc) {
		size_t[] charMask = new size_t();
		Object generatedMinContext = this.getMinContext();
		Object generatedFreq = s.getFreq();
		Object generatedSymbol = s.getSymbol();
		Object generatedHB2Flag = this.getHB2Flag();
		Object generatedBinSumm = this.getBinSumm();
		Object generatedPrevSuccess = this.getPrevSuccess();
		Object generatedNS2BSIndx = this.getNS2BSIndx();
		Object generatedRunLength = this.getRunLength();
		if (generatedMinContext.getNumStats() != 1) {
			CPpmd_State s = ((generatedMinContext).getStats());
			int i;
			UInt32 count = new UInt32();
			UInt32 hiCnt = new UInt32();
			if ((count = .UNRECOGNIZEDFUNCTIONNAME(rc, generatedMinContext.getSummFreq())) < (hiCnt = generatedFreq)) {
				Byte symbol = new Byte();
				.UNRECOGNIZEDFUNCTIONNAME(rc, 0, generatedFreq);
				this.setFoundState(s);
				symbol = generatedSymbol;
				p.Ppmd7_Update1_0();
				return symbol;
			} 
			this.setPrevSuccess(0);
			i = generatedMinContext.getNumStats() - 1;
			do {
				if ((hiCnt += generatedFreq) > count) {
					Byte symbol = new Byte();
					.UNRECOGNIZEDFUNCTIONNAME(rc, hiCnt - generatedFreq, generatedFreq);
					this.setFoundState(s);
					symbol = generatedSymbol;
					p.Ppmd7_Update1();
					return symbol;
				} 
			} while (--i);
			if (count >= generatedMinContext.getSummFreq()) {
				return -2;
			} 
			this.setHiBitsFlag(generatedHB2Flag[generatedSymbol]);
			.UNRECOGNIZEDFUNCTIONNAME(rc, hiCnt, generatedMinContext.getSummFreq() - hiCnt);
			{ 
				size_t z = new size_t();
				for (z = 0; z < 256 / ; z += 8) {
					charMask[z + 7] = charMask[z + 6] = charMask[z + 5] = charMask[z + 4] = charMask[z + 3] = charMask[z + 2] = charMask[z + 1] = charMask[z + 0] = ~(size_t)0;
				}
			}
			;
			((byte)charMask)[generatedSymbol] = 0;
			i = generatedMinContext.getNumStats() - 1;
			do {
				((byte)charMask)[generatedSymbol] = 0;
			} while (--i);
		} else {
				UInt16 prob = generatedBinSumm[(size_t)(int)generatedFreq - 1][generatedPrevSuccess + generatedNS2BSIndx[(size_t)(generatedMinContext.getSuffix()).getNumStats() - 1] + (this.setHiBitsFlag(generatedHB2Flag[generatedSymbol])) + 2 * generatedHB2Flag[(int)generatedSymbol] + ((generatedRunLength >> 26) & -1024)];
				if (.UNRECOGNIZEDFUNCTIONNAME(rc, prob) == 0) {
					Byte symbol = new Byte();
					prob = (UInt16)((prob) + (1 << 7) - ((((prob)) + (1 << ((true) - (true)))) >> (true)));
					symbol = generatedSymbol;
					p.Ppmd7_UpdateBin();
					return symbol;
				} 
				prob = (UInt16)((prob) - ((((prob)) + (1 << ((true) - (true)))) >> (true)));
				this.setInitEsc(ModernizedCProgram.PPMD7_kExpEscape[prob >> 10]);
				{ 
					size_t z = new size_t();
					for (z = 0; z < 256 / ; z += 8) {
						charMask[z + 7] = charMask[z + 6] = charMask[z + 5] = charMask[z + 4] = charMask[z + 3] = charMask[z + 2] = charMask[z + 1] = charMask[z + 0] = ~(size_t)0;
					}
				}
				;
				((byte)charMask)[generatedSymbol] = 0;
				this.setPrevSuccess(0);
		} 
		Object generatedOrderFall = this.getOrderFall();
		Object generatedShift = (see).getShift();
		Object generatedCount = (see).getCount();
		Object generatedSumm = (see).getSumm();
		for (; ; ) {
			CPpmd_State[] ps = new CPpmd_State();
			CPpmd_State s = new CPpmd_State();
			UInt32 freqSum = new UInt32();
			UInt32 count = new UInt32();
			UInt32 hiCnt = new UInt32();
			CPpmd_See see = new CPpmd_See();
			int i;
			int num;
			int numMasked = generatedMinContext.getNumStats();
			do {
				generatedOrderFall++;
				if (!generatedMinContext.getSuffix()) {
					return -1;
				} 
				this.setMinContext((generatedMinContext.getSuffix()));
			} while (generatedMinContext.getNumStats() == numMasked);
			hiCnt = 0;
			s = ((generatedMinContext).getStats());
			i = 0;
			ModernizedCProgram.num = generatedMinContext.getNumStats() - numMasked;
			do {
				int k = (int)(((byte)charMask)[generatedSymbol]);
				hiCnt += (generatedFreq & k);
				ps[i] = s++;
				i -= k;
			} while (i != ModernizedCProgram.num);
			see = p.Ppmd7_MakeEscFreq(numMasked, freqSum);
			freqSum += hiCnt;
			count = .UNRECOGNIZEDFUNCTIONNAME(rc, freqSum);
			if (count < hiCnt) {
				Byte symbol = new Byte();
				CPpmd_State pps = ps;
				for (hiCnt = 0; (hiCnt += generatedFreq) <= count; pps++) {
					;
				}
				s = pps;
				.UNRECOGNIZEDFUNCTIONNAME(rc, hiCnt - generatedFreq, generatedFreq);
				if (generatedShift < 7 && --generatedCount == 0) {
					generatedSumm <<=  1;
					(see).setCount((Byte)(3 << generatedShift++));
				} 
				;
				this.setFoundState(s);
				symbol = generatedSymbol;
				p.Ppmd7_Update2();
				return symbol;
			} 
			if (count >= freqSum) {
				return -2;
			} 
			.UNRECOGNIZEDFUNCTIONNAME(rc, hiCnt, freqSum - hiCnt);
			see.setSumm((UInt16)(generatedSumm + freqSum));
			do {
				((byte)charMask)[generatedSymbol] = 0;
			} while (i != 0);
		}
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static Object hc_dlopen(Object lpLibFileName) {
		return .LoadLibraryA(lpLibFileName);
	}
	public static Object hc_dlclose(Object hLibModule) {
		return .FreeLibrary(hLibModule);
	}
	public static Object hc_dlsym(Object hModule, Object lpProcName) {
		return .GetProcAddress(hModule, lpProcName);
	}
	/* Lzma2Dec.c -- LZMA2 Decoder
	2019-02-02 : Igor Pavlov : Public domain */
	/* #define SHOW_DEBUG_INFO */
	/*
	00000000  -  End of data
	00000001 U U  -  Uncompressed, reset dic, need reset state and set new prop
	00000010 U U  -  Uncompressed, no reset
	100uuuuu U U P P  -  LZMA, no reset
	101uuuuu U U P P  -  LZMA, reset state
	110uuuuu U U P P S  -  LZMA, reset state + set new prop
	111uuuuu U U P P S  -  LZMA, reset state + set new prop, reset dic
	
	  u, U - Unpack Size
	  P - Pack Size
	  S - Props
	*/
	public static Object Lzma2Dec_GetOldProps(Object prop, Object props) {
		UInt32 dicSize = new UInt32();
		if (prop > 40) {
			return 4;
		} 
		dicSize = (prop == 40) ? -1024 : (((UInt32)2 | ((prop) & 1)) << ((prop) / 2 + 11));
		props[0] = (Byte)4;
		props[1] = (Byte)(dicSize);
		props[2] = (Byte)(dicSize >> 8);
		props[3] = (Byte)(dicSize >> 16);
		props[4] = (Byte)(dicSize >> 24);
		return 0;
	}
	public static Object Lzma2Dec_AllocateProbs(Object prop, Object alloc) {
		Byte[] props = new Byte();
		{ 
			int __result__ = (ModernizedCProgram.Lzma2Dec_GetOldProps(prop, props));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedDecoder = this.getDecoder();
		return generatedDecoder.LzmaDec_AllocateProbs(props, 5, alloc);
	}
	public static Object Lzma2Dec_Allocate(Object prop, Object alloc) {
		Byte[] props = new Byte();
		{ 
			int __result__ = (ModernizedCProgram.Lzma2Dec_GetOldProps(prop, props));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedDecoder = this.getDecoder();
		return generatedDecoder.LzmaDec_Allocate(props, 5, alloc);
	}
	public static void Lzma2Dec_Init() {
		this.setState(.LZMA2_STATE_CONTROL);
		this.setNeedInitLevel(-1024);
		this.setIsExtraMode(0);
		this.setUnpackSize(0);
		Object generatedDecoder = this.getDecoder();
		// p->decoder.dicPos = 0; // we can use it instead of full init// p->decoder.dicPos = 0; // we can use it instead of full initgeneratedDecoder.LzmaDec_Init();
	}
	public static  Lzma2Dec_UpdateState(Object b) {
		Object generatedControl = (p).getControl();
		Object generatedNeedInitLevel = this.getNeedInitLevel();
		Object generatedUnpackSize = this.getUnpackSize();
		Object generatedPackSize = this.getPackSize();
		Object generatedDecoder = this.getDecoder();
		Object generatedState = this.getState();
		switch (generatedState) {
		case .LZMA2_STATE_PROP:
				{ 
					int lc;
					int lp;
					if (b >= (9 * 5 * 5)) {
						return .LZMA2_STATE_ERROR;
					} 
					lc = b % 9;
					b /= 9;
					generatedDecoder.getProp().setPb((Byte)(b / 5));
					lp = b % 5;
					if (lc + lp > 4) {
						return .LZMA2_STATE_ERROR;
					} 
					generatedDecoder.getProp().setLc((Byte)lc);
					generatedDecoder.getProp().setLp((Byte)lp);
					return .LZMA2_STATE_DATA;
				}
		case .LZMA2_STATE_UNPACK0:
				generatedUnpackSize |=  (UInt32)b << 8;
				return .LZMA2_STATE_UNPACK1;
		case .LZMA2_STATE_PACK1:
				generatedPackSize |=  (UInt32)b;
				generatedPackSize++;
				;
				return (generatedControl & -1024) ? .LZMA2_STATE_PROP : .LZMA2_STATE_DATA;
		case .LZMA2_STATE_CONTROL:
				this.setIsExtraMode(0);
				this.setControl(b);
				;
				;
				if (b == 0) {
					return .LZMA2_STATE_FINISHED;
				} 
				if (((generatedControl & (1 << 7)) == 0)) {
					if (b == 1) {
						this.setNeedInitLevel(-1024);
					}  else if (b > 2 || generatedNeedInitLevel == -1024) {
						return .LZMA2_STATE_ERROR;
					} 
				} else {
						if (b < generatedNeedInitLevel) {
							return .LZMA2_STATE_ERROR;
						} 
						this.setNeedInitLevel(0);
						this.setUnpackSize((UInt32)(b & -1024) << 16);
				} 
				return .LZMA2_STATE_UNPACK0;
		case .LZMA2_STATE_UNPACK1:
				generatedUnpackSize |=  (UInt32)b;
				generatedUnpackSize++;
				;
				return ((generatedControl & (1 << 7)) == 0) ? .LZMA2_STATE_DATA : .LZMA2_STATE_PACK0;
		case .LZMA2_STATE_PACK0:
				this.setPackSize((UInt32)b << 8);
				return .LZMA2_STATE_PACK1;
		}
		return .LZMA2_STATE_ERROR;
	}
	public static void LzmaDec_UpdateWithUncompressed(Object src, Object size) {
		Object generatedDic = this.getDic();
		Object generatedDicPos = this.getDicPos();
		.memcpy(generatedDic + generatedDicPos, src, size);
		generatedDicPos += size;
		Object generatedCheckDicSize = this.getCheckDicSize();
		Object generatedProp = this.getProp();
		Object generatedProcessedPos = this.getProcessedPos();
		if (generatedCheckDicSize == 0 && generatedProp.getDicSize() - generatedProcessedPos <= size) {
			this.setCheckDicSize(generatedProp.getDicSize());
		} 
		generatedProcessedPos += (UInt32)size;
	}
	public static Object Lzma2Dec_DecodeToDic(Object dicLimit, Object src, Object srcLen,  finishMode,  status) {
		SizeT inSize = srcLen;
		srcLen = 0;
		status = .LZMA_STATUS_NOT_SPECIFIED;
		Object generatedState = this.getState();
		Object generatedDecoder = this.getDecoder();
		Object generatedUnpackSize = this.getUnpackSize();
		Object generatedControl = (p).getControl();
		Object generatedPackSize = this.getPackSize();
		while (generatedState != .LZMA2_STATE_ERROR) {
			SizeT dicPos = new SizeT();
			if (generatedState == .LZMA2_STATE_FINISHED) {
				status = .LZMA_STATUS_FINISHED_WITH_MARK;
				return 0;
			} 
			dicPos = generatedDecoder.getDicPos();
			if (dicPos == dicLimit && finishMode == .LZMA_FINISH_ANY) {
				status = .LZMA_STATUS_NOT_FINISHED;
				return 0;
			} 
			if (generatedState != .LZMA2_STATE_DATA && generatedState != .LZMA2_STATE_DATA_CONT) {
				if (srcLen == inSize) {
					status = .LZMA_STATUS_NEEDS_MORE_INPUT;
					return 0;
				} 
				(srcLen)++;
				this.setState(p.Lzma2Dec_UpdateState(src++));
				if (dicPos == dicLimit && generatedState != .LZMA2_STATE_FINISHED) {
					break;
				} 
				continue;
			} 
			{ 
				SizeT inCur = inSize - srcLen;
				SizeT outCur = dicLimit - dicPos;
				ELzmaFinishMode curFinishMode = .LZMA_FINISH_ANY;
				if (outCur >= generatedUnpackSize) {
					outCur = (SizeT)generatedUnpackSize;
					curFinishMode = .LZMA_FINISH_END;
				} 
				if (((generatedControl & (1 << 7)) == 0)) {
					if (inCur == 0) {
						status = .LZMA_STATUS_NEEDS_MORE_INPUT;
						return 0;
					} 
					if (generatedState == .LZMA2_STATE_DATA) {
						BoolInt initDic = (generatedControl == 1);
						generatedDecoder.LzmaDec_InitDicAndState(initDic, 0);
					} 
					if (inCur > outCur) {
						inCur = outCur;
					} 
					if (inCur == 0) {
						break;
					} 
					generatedDecoder.LzmaDec_UpdateWithUncompressed(src, inCur);
					src += inCur;
					srcLen += inCur;
					generatedUnpackSize -= (UInt32)inCur;
					this.setState((generatedUnpackSize == 0) ? .LZMA2_STATE_CONTROL : .LZMA2_STATE_DATA_CONT);
				} else {
						SRes res = new SRes();
						if (generatedState == .LZMA2_STATE_DATA) {
							BoolInt initDic = (generatedControl >= -1024);
							BoolInt initState = (generatedControl >= -1024);
							generatedDecoder.LzmaDec_InitDicAndState(initDic, initState);
							this.setState(.LZMA2_STATE_DATA_CONT);
						} 
						if (inCur > generatedPackSize) {
							inCur = (SizeT)generatedPackSize;
						} 
						res = generatedDecoder.LzmaDec_DecodeToDic(dicPos + outCur, src, inCur, curFinishMode, status);
						src += inCur;
						srcLen += inCur;
						generatedPackSize -= (UInt32)inCur;
						outCur = generatedDecoder.getDicPos() - dicPos;
						generatedUnpackSize -= (UInt32)outCur;
						if (res != 0) {
							break;
						} 
						if (status == .LZMA_STATUS_NEEDS_MORE_INPUT) {
							if (generatedPackSize == 0) {
								break;
							} 
							return 0;
						} 
						if (inCur == 0 && outCur == 0) {
							if (status != .LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK || generatedUnpackSize != 0 || generatedPackSize != 0) {
								break;
							} 
							this.setState(.LZMA2_STATE_CONTROL);
						} 
						status = .LZMA_STATUS_NOT_SPECIFIED;
				} 
			}
		}
		status = .LZMA_STATUS_NOT_SPECIFIED;
		this.setState(.LZMA2_STATE_ERROR);
		return 1;
	}
	public static  Lzma2Dec_Parse(Object outSize, Object src, Object srcLen, int checkFinishBlock) {
		SizeT inSize = srcLen;
		srcLen = 0;
		Object generatedState = this.getState();
		Object generatedControl = this.getControl();
		Object generatedUnpackSize = this.getUnpackSize();
		Object generatedDecoder = this.getDecoder();
		Object generatedPackSize = this.getPackSize();
		while (generatedState != .LZMA2_STATE_ERROR) {
			if (generatedState == .LZMA2_STATE_FINISHED) {
				return (ELzma2ParseStatus).LZMA_STATUS_FINISHED_WITH_MARK;
			} 
			if (outSize == 0 && !checkFinishBlock) {
				return (ELzma2ParseStatus).LZMA_STATUS_NOT_FINISHED;
			} 
			if (generatedState != .LZMA2_STATE_DATA && generatedState != .LZMA2_STATE_DATA_CONT) {
				if (srcLen == inSize) {
					return (ELzma2ParseStatus).LZMA_STATUS_NEEDS_MORE_INPUT;
				} 
				(srcLen)++;
				this.setState(p.Lzma2Dec_UpdateState(src++));
				if (generatedState == .LZMA2_STATE_UNPACK0) {
					if (generatedControl == 1 || generatedControl >= -1024) {
						return .LZMA2_PARSE_STATUS_NEW_BLOCK;
					} 
				} 
				if (outSize == 0 && generatedState != .LZMA2_STATE_FINISHED) {
					return (ELzma2ParseStatus).LZMA_STATUS_NOT_FINISHED;
				} 
				if (generatedState == .LZMA2_STATE_DATA) {
					return .LZMA2_PARSE_STATUS_NEW_CHUNK;
				} 
				continue;
			} 
			if (outSize == 0) {
				return (ELzma2ParseStatus).LZMA_STATUS_NOT_FINISHED;
			} 
			{ 
				SizeT inCur = inSize - srcLen;
				if (((generatedControl & (1 << 7)) == 0)) {
					if (inCur == 0) {
						return (ELzma2ParseStatus).LZMA_STATUS_NEEDS_MORE_INPUT;
					} 
					if (inCur > generatedUnpackSize) {
						inCur = generatedUnpackSize;
					} 
					if (inCur > outSize) {
						inCur = outSize;
					} 
					generatedDecoder.getDicPos() += inCur;
					src += inCur;
					srcLen += inCur;
					outSize -= inCur;
					generatedUnpackSize -= (UInt32)inCur;
					this.setState((generatedUnpackSize == 0) ? .LZMA2_STATE_CONTROL : .LZMA2_STATE_DATA_CONT);
				} else {
						this.setIsExtraMode(1);
						if (inCur == 0) {
							if (generatedPackSize != 0) {
								return (ELzma2ParseStatus).LZMA_STATUS_NEEDS_MORE_INPUT;
							} 
						}  else if (generatedState == .LZMA2_STATE_DATA) {
							this.setState(.LZMA2_STATE_DATA_CONT);
							if (src != 0) {
								srcLen += 1;
								generatedPackSize--;
								break;
							} 
						} 
						if (inCur > generatedPackSize) {
							inCur = (SizeT)generatedPackSize;
						} 
						src += inCur;
						srcLen += inCur;
						generatedPackSize -= (UInt32)inCur;
						if (generatedPackSize == 0) {
							SizeT rem = outSize;
							if (rem > generatedUnpackSize) {
								rem = generatedUnpackSize;
							} 
							generatedDecoder.getDicPos() += rem;
							generatedUnpackSize -= (UInt32)rem;
							outSize -= rem;
							if (generatedUnpackSize == 0) {
								this.setState(.LZMA2_STATE_CONTROL);
							} 
						} 
				} 
			}
		}
		this.setState(.LZMA2_STATE_ERROR);
		return (ELzma2ParseStatus).LZMA_STATUS_NOT_SPECIFIED;
	}
	public static Object Lzma2Dec_DecodeToBuf(Object dest, Object destLen, Object src, Object srcLen,  finishMode,  status) {
		SizeT outSize = destLen;
		SizeT inSize = srcLen;
		srcLen = destLen = 0;
		Object generatedDecoder = this.getDecoder();
		for (; ; ) {
			SizeT inCur = inSize;
			SizeT outCur = new SizeT();
			SizeT dicPos = new SizeT();
			ELzmaFinishMode curFinishMode = new ELzmaFinishMode();
			SRes res = new SRes();
			if (generatedDecoder.getDicPos() == generatedDecoder.getDicBufSize()) {
				generatedDecoder.setDicPos(0);
			} 
			dicPos = generatedDecoder.getDicPos();
			curFinishMode = .LZMA_FINISH_ANY;
			outCur = generatedDecoder.getDicBufSize() - dicPos;
			if (outCur >= outSize) {
				outCur = outSize;
				curFinishMode = finishMode;
			} 
			res = p.Lzma2Dec_DecodeToDic(dicPos + outCur, src, inCur, curFinishMode, status);
			src += inCur;
			inSize -= inCur;
			srcLen += inCur;
			outCur = generatedDecoder.getDicPos() - dicPos;
			.memcpy(dest, generatedDecoder.getDic() + dicPos, outCur);
			dest += outCur;
			outSize -= outCur;
			destLen += outCur;
			if (res != 0) {
				return res;
			} 
			if (outCur == 0 || outSize == 0) {
				return 0;
			} 
		}
	}
	public static Object Lzma2Decode(Object dest, Object destLen, Object src, Object srcLen, Object prop,  finishMode,  status, Object alloc) {
		CLzma2Dec p = new CLzma2Dec();
		SRes res = new SRes();
		SizeT outSize = destLen;
		SizeT inSize = srcLen;
		destLen = srcLen = 0;
		status = .LZMA_STATUS_NOT_SPECIFIED;
		Object generatedDecoder = (p).getDecoder();
		{ 
			(generatedDecoder).setDic(((Object)0));
			(generatedDecoder).setProbs(((Object)0));
		}
		;
		{ 
			int __result__ = (p.Lzma2Dec_AllocateProbs(prop, alloc));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		generatedDecoder.setDic(dest);
		generatedDecoder.setDicBufSize(outSize);
		p.Lzma2Dec_Init();
		srcLen = inSize;
		res = p.Lzma2Dec_DecodeToDic(outSize, src, srcLen, finishMode, status);
		destLen = generatedDecoder.getDicPos();
		if (res == 0 && status == .LZMA_STATUS_NEEDS_MORE_INPUT) {
			res = 6;
		} 
		generatedDecoder.LzmaDec_FreeProbs(alloc);
		return res;
	}
	/* ===========================================================================
	   Inputs a long in LSB order to the given file
	   nbByte == 1, 2 ,4 or 8 (byte, short or long, ZPOS64_T)
	*/
	/* ===========================================================================
	   Inputs a long in LSB order to the given file
	   nbByte == 1, 2 ,4 or 8 (byte, short or long, ZPOS64_T)
	*/
	public static int zip64local_putValue(Object pzlib_filefunc_def, Object filestream, Object x, int nbByte) {
		byte[] buf = new byte[8];
		int n;
		for (n = 0; n < nbByte; n++) {
			buf[n] = (byte)(x & -1024);
			x >>=  8;
		}
		if (x != 0) {
			for (n = 0; n < nbByte; /* data overflow - hack for ZIP64 (X Roche) */n++) {
				buf[n] = -1024;
			}
		} 
		if ((.UNRECOGNIZEDFUNCTIONNAME((pzlib_filefunc_def).getZfile_func64().getOpaque(), filestream, buf, nbByte)) != (uLong)nbByte) {
			return ((true));
		} else {
				return (false);
		} 
	}
	public static void zip64local_putValue_inmemory(Object dest, Object x, int nbByte) {
		byte buf = (byte)dest;
		int n;
		for (n = 0; n < nbByte; n++) {
			buf[n] = (byte)(x & -1024);
			x >>=  8;
		}
		if (x != 0) {
			for (n = 0; n < nbByte; /* data overflow - hack for ZIP64 */n++) {
				buf[n] = -1024;
			}
		} 
	}
	/****************************************************************************/
	public static Object zip64local_TmzDateToDosDate(Object ptm) {
		uLong year = (uLong)ptm.getTm_year();
		if (year >= 1980) {
			year -= 1980;
		}  else if (year >= 80) {
			year -= 80;
		} 
		return (uLong)(((ptm.getTm_mday()) + (32 * (ptm.getTm_mon() + 1)) + (512 * year)) << 16) | ((ptm.getTm_sec() / 2) + (32 * ptm.getTm_min()) + (2048 * (uLong)ptm.getTm_hour()));
	}
	/****************************************************************************/
	public static int zip64local_getByte(Object pzlib_filefunc_def, Object filestream, int pi) {
		byte c;
		int err = (int)(.UNRECOGNIZEDFUNCTIONNAME((pzlib_filefunc_def).getZfile_func64().getOpaque(), filestream, c, 1));
		if (err == 1) {
			pi = (int)c;
			return (false);
		} else {
				if ((.UNRECOGNIZEDFUNCTIONNAME((pzlib_filefunc_def).getZfile_func64().getOpaque(), filestream))) {
					return ((true));
				} else {
						return (false);
				} 
		} 
	}
	/* ===========================================================================
	   Reads a long in LSB order from the given gz_stream. Sets
	*/
	public static int zip64local_getShort(Object pzlib_filefunc_def, Object filestream, Object pX) {
		uLong x = new uLong();
		int i = 0;
		int err;
		err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		x = (uLong)i;
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((uLong)i) << 8;
		if (err == (false)) {
			pX = x;
		} else {
				pX = 0;
		} 
		return err;
	}
	public static int zip64local_getLong(Object pzlib_filefunc_def, Object filestream, Object pX) {
		uLong x = new uLong();
		int i = 0;
		int err;
		err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		x = (uLong)i;
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((uLong)i) << 8;
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((uLong)i) << 16;
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((uLong)i) << 24;
		if (err == (false)) {
			pX = x;
		} else {
				pX = 0;
		} 
		return err;
	}
	public static int zip64local_getLong64(Object pzlib_filefunc_def, Object filestream, Object pX) {
		ZPOS64_T x = new ZPOS64_T();
		int i = 0;
		int err;
		err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		x = (ZPOS64_T)i;
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((ZPOS64_T)i) << 8;
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((ZPOS64_T)i) << 16;
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((ZPOS64_T)i) << 24;
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((ZPOS64_T)i) << 32;
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((ZPOS64_T)i) << 40;
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((ZPOS64_T)i) << 48;
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_getByte(pzlib_filefunc_def, filestream, i);
		} 
		x += ((ZPOS64_T)i) << 56;
		if (err == (false)) {
			pX = x;
		} else {
				pX = 0;
		} 
		return err;
	}
	/*
	  Locate the Central directory of a zipfile (at the end, just before
	    the global comment)
	*/
	public static Object zip64local_SearchCentralDir(Object pzlib_filefunc_def, Object filestream) {
		byte buf;
		ZPOS64_T uSizeFile = new ZPOS64_T();
		ZPOS64_T uBackRead = new ZPOS64_T();
		ZPOS64_T uMaxBack = /* maximum size of global comment */-1024;
		ZPOS64_T uPosFound = 0;
		if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (false), ((true)))) != 0) {
			return 0;
		} 
		uSizeFile = (ModernizedCProgram.call_ztell64(((pzlib_filefunc_def)), (filestream)));
		if (uMaxBack > uSizeFile) {
			uMaxBack = uSizeFile;
		} 
		buf = (byte)(.malloc((true) + 4));
		if (buf == ((Object)0)) {
			return 0;
		} 
		uBackRead = 4;
		while (uBackRead < uMaxBack) {
			uLong uReadSize = new uLong();
			ZPOS64_T uReadPos = new ZPOS64_T();
			int i;
			if (uBackRead + (true) > uMaxBack) {
				uBackRead = uMaxBack;
			} else {
					uBackRead += (true);
			} 
			uReadPos = uSizeFile - uBackRead;
			uReadSize = (((true) + 4) < (uSizeFile - uReadPos)) ? ((true) + 4) : (uLong)(uSizeFile - uReadPos);
			if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (uReadPos), ((false)))) != 0) {
				break;
			} 
			if ((.UNRECOGNIZEDFUNCTIONNAME((pzlib_filefunc_def).getZfile_func64().getOpaque(), filestream, buf, uReadSize)) != uReadSize) {
				break;
			} 
			for (i = (int)uReadSize - 3; (i--) > 0; ) {
				if ((((buf + i)) == -1024) && (((buf + i + 1)) == -1024) && (((buf + i + 2)) == -1024) && (((buf + i + 3)) == -1024)) {
					uPosFound = uReadPos + i;
					break;
				} 
			}
			if (uPosFound != 0) {
				break;
			} 
		}
		{ 
			if (buf) {
				.free(buf);
			} 
		}
		;
		return uPosFound/*
		Locate the End of Zip64 Central directory locator and from there find the CD of a zipfile (at the end, just before
		the global comment)
		*/;
	}
	public static Object zip64local_SearchCentralDir64(Object pzlib_filefunc_def, Object filestream) {
		byte buf;
		ZPOS64_T uSizeFile = new ZPOS64_T();
		ZPOS64_T uBackRead = new ZPOS64_T();
		ZPOS64_T uMaxBack = /* maximum size of global comment */-1024;
		ZPOS64_T uPosFound = 0;
		uLong uL = new uLong();
		ZPOS64_T relativeOffset = new ZPOS64_T();
		if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (false), ((true)))) != 0) {
			return 0;
		} 
		uSizeFile = (ModernizedCProgram.call_ztell64(((pzlib_filefunc_def)), (filestream)));
		if (uMaxBack > uSizeFile) {
			uMaxBack = uSizeFile;
		} 
		buf = (byte)(.malloc((true) + 4));
		if (buf == ((Object)0)) {
			return 0;
		} 
		uBackRead = 4;
		while (uBackRead < uMaxBack) {
			uLong uReadSize = new uLong();
			ZPOS64_T uReadPos = new ZPOS64_T();
			int i;
			if (uBackRead + (true) > uMaxBack) {
				uBackRead = uMaxBack;
			} else {
					uBackRead += (true);
			} 
			uReadPos = uSizeFile - uBackRead;
			uReadSize = (((true) + 4) < (uSizeFile - uReadPos)) ? ((true) + 4) : (uLong)(uSizeFile - uReadPos);
			if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (uReadPos), ((false)))) != 0) {
				break;
			} 
			if ((.UNRECOGNIZEDFUNCTIONNAME((pzlib_filefunc_def).getZfile_func64().getOpaque(), filestream, buf, uReadSize)) != uReadSize) {
				break;
			} 
			for (i = (int)uReadSize - 3; (i--) > 0; ) {
				if ((((buf + i)) == -1024) && (((buf + i + 1)) == -1024) && (((buf + i + 2)) == -1024) && (((buf + i + 3)) == -1024)) {
					uPosFound = uReadPos + i;
					break;
				} 
			}
			if (uPosFound != 0) {
				break;
			} 
		}
		{ 
			if (buf) {
				.free(buf);
			} 
		}
		;
		if (uPosFound == 0) {
			return 0;
		} 
		if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (uPosFound), ((false)))) != /* Zip64 end of central directory locator */0) {
			return 0;
		} 
		if (ModernizedCProgram.zip64local_getLong(pzlib_filefunc_def, filestream, uL) != (/* the signature, already checked */false)) {
			return 0;
		} 
		if (ModernizedCProgram.zip64local_getLong(pzlib_filefunc_def, filestream, uL) != (/* number of the disk with the start of the zip64 end of  central directory */false)) {
			return 0;
		} 
		if (uL != 0) {
			return 0;
		} 
		if (ModernizedCProgram.zip64local_getLong64(pzlib_filefunc_def, filestream, relativeOffset) != (/* relative offset of the zip64 end of central directory record */false)) {
			return 0;
		} 
		if (ModernizedCProgram.zip64local_getLong(pzlib_filefunc_def, filestream, uL) != (/* total number of disks */false)) {
			return 0;
		} 
		if (uL != 1) {
			return 0;
		} 
		if ((ModernizedCProgram.call_zseek64(((pzlib_filefunc_def)), (filestream), (relativeOffset), ((false)))) != /* Goto Zip64 end of central directory record */0) {
			return 0;
		} 
		if (ModernizedCProgram.zip64local_getLong(pzlib_filefunc_def, filestream, uL) != (/* the signature */false)) {
			return 0;
		} 
		// signature of 'Zip64 end of central directory'if (uL != -1024) {
			return 0;
		} 
		return relativeOffset;
	}
	public static int LoadCentralDirectoryRecord() {
		int err = (false);
		/* byte before the zipfile, (>0 for sfx)*/ZPOS64_T byte_before_the_zipfile = new ZPOS64_T();
		/* size of the central directory  */ZPOS64_T size_central_dir = new ZPOS64_T();
		/* offset of start of central directory */ZPOS64_T offset_central_dir = new ZPOS64_T();
		ZPOS64_T central_pos = new ZPOS64_T();
		uLong uL = new uLong();
		/* number of the current dist, used for
		                              spaning ZIP, unsupported, always 0*/uLong number_disk = new uLong();
		/* number the the disk with central dir, used
		                              for spaning ZIP, unsupported, always 0*/uLong number_disk_with_CD = new uLong();
		ZPOS64_T number_entry = new ZPOS64_T();
		/* total number of entries in
		                                the central dir
		                                (same than number_entry on nospan) */ZPOS64_T number_entry_CD = new ZPOS64_T();
		uLong VersionMadeBy = new uLong();
		uLong VersionNeeded = new uLong();
		uLong size_comment = new uLong();
		int hasZIP64Record = 0;
		Object generatedZ_filefunc = this.getZ_filefunc();
		Object generatedFilestream = this.getFilestream();
		// check first if we find a ZIP64 record// check first if we find a ZIP64 recordcentral_pos = ModernizedCProgram.zip64local_SearchCentralDir64(generatedZ_filefunc, generatedFilestream);
		if (central_pos > 0) {
			hasZIP64Record = 1;
		}  else if (central_pos == 0) {
			central_pos = ModernizedCProgram.zip64local_SearchCentralDir(generatedZ_filefunc, generatedFilestream);
		} 
		if (hasZIP64Record) {
			ZPOS64_T sizeEndOfCentralDirectory = new ZPOS64_T();
			if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (central_pos), ((false)))) != 0) {
				err = ((true));
			} 
			if (ModernizedCProgram.zip64local_getLong(generatedZ_filefunc, generatedFilestream, uL) != (/* the signature, already checked */false)) {
				err = ((true));
			} 
			if (ModernizedCProgram.zip64local_getLong64(generatedZ_filefunc, generatedFilestream, sizeEndOfCentralDirectory) != (/* size of zip64 end of central directory record */false)) {
				err = ((true));
			} 
			if (ModernizedCProgram.zip64local_getShort(generatedZ_filefunc, generatedFilestream, VersionMadeBy) != (/* version made by */false)) {
				err = ((true));
			} 
			if (ModernizedCProgram.zip64local_getShort(generatedZ_filefunc, generatedFilestream, VersionNeeded) != (/* version needed to extract */false)) {
				err = ((true));
			} 
			if (ModernizedCProgram.zip64local_getLong(generatedZ_filefunc, generatedFilestream, number_disk) != (/* number of this disk */false)) {
				err = ((true));
			} 
			if (ModernizedCProgram.zip64local_getLong(generatedZ_filefunc, generatedFilestream, number_disk_with_CD) != (/* number of the disk with the start of the central directory */false)) {
				err = ((true));
			} 
			if (ModernizedCProgram.zip64local_getLong64(generatedZ_filefunc, generatedFilestream, number_entry) != (/* total number of entries in the central directory on this disk */false)) {
				err = ((true));
			} 
			if (ModernizedCProgram.zip64local_getLong64(generatedZ_filefunc, generatedFilestream, number_entry_CD) != (/* total number of entries in the central directory */false)) {
				err = ((true));
			} 
			if ((number_entry_CD != number_entry) || (number_disk_with_CD != 0) || (number_disk != 0)) {
				err = (true);
			} 
			if (ModernizedCProgram.zip64local_getLong64(generatedZ_filefunc, generatedFilestream, size_central_dir) != (/* size of the central directory */false)) {
				err = ((true));
			} 
			if (ModernizedCProgram.zip64local_getLong64(generatedZ_filefunc, generatedFilestream, offset_central_dir) != (/* offset of start of central directory with respect to the
			    starting disk number */false)) {
				err = ((true));
			} 
			size_comment = 0;
		} else {
				if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (central_pos), ((false)))) != 0) {
					err = ((true));
				} 
				if (ModernizedCProgram.zip64local_getLong(generatedZ_filefunc, generatedFilestream, uL) != (/* the signature, already checked */false)) {
					err = ((true));
				} 
				if (ModernizedCProgram.zip64local_getShort(generatedZ_filefunc, generatedFilestream, number_disk) != (/* number of this disk */false)) {
					err = ((true));
				} 
				if (ModernizedCProgram.zip64local_getShort(generatedZ_filefunc, generatedFilestream, number_disk_with_CD) != (/* number of the disk with the start of the central directory */false)) {
					err = ((true));
				} 
				number_entry = /* total number of entries in the central dir on this disk */0;
				if (ModernizedCProgram.zip64local_getShort(generatedZ_filefunc, generatedFilestream, uL) != (false)) {
					err = ((true));
				} else {
						number_entry = uL;
				} 
				number_entry_CD = /* total number of entries in the central dir */0;
				if (ModernizedCProgram.zip64local_getShort(generatedZ_filefunc, generatedFilestream, uL) != (false)) {
					err = ((true));
				} else {
						number_entry_CD = uL;
				} 
				if ((number_entry_CD != number_entry) || (number_disk_with_CD != 0) || (number_disk != 0)) {
					err = (true);
				} 
				size_central_dir = /* size of the central directory */0;
				if (ModernizedCProgram.zip64local_getLong(generatedZ_filefunc, generatedFilestream, uL) != (false)) {
					err = ((true));
				} else {
						size_central_dir = uL;
				} 
				offset_central_dir = /* offset of start of central directory with respect to the starting disk number */0;
				if (ModernizedCProgram.zip64local_getLong(generatedZ_filefunc, generatedFilestream, uL) != (false)) {
					err = ((true));
				} else {
						offset_central_dir = uL;
				} 
				if (ModernizedCProgram.zip64local_getShort(generatedZ_filefunc, generatedFilestream, size_comment) != (/* zipfile global comment length */false)) {
					err = ((true));
				} 
		} 
		if ((central_pos < offset_central_dir + size_central_dir) && (err == (false))) {
			err = (true);
		} 
		if (err != (false)) {
			(.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream));
			return ((true));
		} 
		Object generatedGlobalcomment = this.getGlobalcomment();
		if (size_comment > 0) {
			this.setGlobalcomment((byte)(.malloc(size_comment + 1)));
			if (generatedGlobalcomment) {
				size_comment = (.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, generatedGlobalcomment, size_comment));
				generatedGlobalcomment[size_comment] = 0;
			} 
		} 
		byte_before_the_zipfile = central_pos - (offset_central_dir + size_central_dir);
		this.setAdd_position_when_writing_offset(byte_before_the_zipfile);
		Object generatedCentral_dir = this.getCentral_dir();
		{ 
			ZPOS64_T size_central_dir_to_read = size_central_dir;
			size_t buf_size = (4096 - (4 * 4));
			Object buf_read = (Object)(.malloc(buf_size));
			if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (offset_central_dir + byte_before_the_zipfile), ((false)))) != 0) {
				err = ((true));
			} 
			while ((size_central_dir_to_read > 0) && (err == (false))) {
				ZPOS64_T read_this = (4096 - (4 * 4));
				if (read_this > size_central_dir_to_read) {
					read_this = size_central_dir_to_read;
				} 
				if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, buf_read, (uLong)read_this)) != read_this) {
					err = ((true));
				} 
				if (err == (false)) {
					err = generatedCentral_dir.add_data_in_datablock(buf_read, (uLong)read_this);
				} 
				size_central_dir_to_read -= read_this;
			}
			{ 
				if (buf_read) {
					.free(buf_read);
				} 
			}
			;
		}
		this.setBegin_pos(byte_before_the_zipfile);
		this.setNumber_entry(number_entry_CD);
		if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (offset_central_dir + byte_before_the_zipfile), ((false)))) != 0) {
			err = ((true));
		} 
		return err/* !NO_ADDFILEINEXISTINGZIP*/;
	}
	public static Object zipOpen(Object pathname, int append) {
		return ((Object)0).zipOpen3((Object)pathname, append, ((Object)0));
	}
	public static Object zipOpen64(Object pathname, int append) {
		return ((Object)0).zipOpen3(pathname, append, ((Object)0));
	}
	public static int Write_LocalFileHeader(Object filename, Object size_extrafield_local, Object extrafield_local) {
		/* write the local header */int err;
		uInt size_filename = (uInt).strlen(filename);
		uInt size_extrafield = size_extrafield_local;
		Object generatedZ_filefunc = this.getZ_filefunc();
		Object generatedFilestream = this.getFilestream();
		err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)(true), 4);
		Object generatedCi = this.getCi();
		if (err == (false)) {
			if (generatedCi.getZip64()) {
				err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)45, /* version needed to extract */2);
			} else {
					err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)20, /* version needed to extract */2);
			} 
		} 
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)generatedCi.getFlag(), 2);
		} 
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)generatedCi.getMethod(), 2);
		} 
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)generatedCi.getDosDate(), 4);
		} 
		// CRC / Compressed size / Uncompressed size will be filled in later and rewritten laterif (err == (false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)0, /* crc 32, unknown */4);
		} 
		if (err == (false)) {
			if (generatedCi.getZip64()) {
				err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)-1024, /* compressed size, unknown */4);
			} else {
					err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)0, /* compressed size, unknown */4);
			} 
		} 
		if (err == (false)) {
			if (generatedCi.getZip64()) {
				err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)-1024, /* uncompressed size, unknown */4);
			} else {
					err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)0, /* uncompressed size, unknown */4);
			} 
		} 
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)size_filename, 2);
		} 
		if (generatedCi.getZip64()) {
			size_extrafield += 20;
		} 
		if (err == (false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)size_extrafield, 2);
		} 
		if ((err == (false)) && (size_filename > 0)) {
			if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, filename, size_filename)) != size_filename) {
				err = ((true));
			} 
		} 
		if ((err == (false)) && (size_extrafield_local > 0)) {
			if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, extrafield_local, size_extrafield_local)) != size_extrafield_local) {
				err = ((true));
			} 
		} 
		if ((err == (false)) && (generatedCi.getZip64())) {
			int HeaderID = 1;
			int DataSize = 16;
			ZPOS64_T CompressedSize = 0;
			ZPOS64_T UncompressedSize = 0;
			generatedCi.setPos_zip64extrainfo((ModernizedCProgram.call_ztell64(((generatedZ_filefunc)), (generatedFilestream))));
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (int)HeaderID, 2);
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (int)DataSize, 2);
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (ZPOS64_T)UncompressedSize, 8);
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (ZPOS64_T)CompressedSize, 8);
		} 
		return err/*
		 NOTE.
		 When writing RAW the ZIP64 extended information in extrafield_local and extrafield_global needs to be stripped
		 before calling this function it can be done with zipRemoveExtraInfoBlock
		
		 It is not done here because then we need to realloc a new buffer since parameters are 'const' and I want to minimize
		 unnecessary allocations.
		 */;
	}
	public static int zipOpenNewFileInZip4_64(Object file, Object filename, Object zipfi, Object extrafield_local, Object size_extrafield_local, Object extrafield_global, Object size_extrafield_global, Object comment, int method, int level, int raw, int windowBits, int memLevel, int strategy, Object password, Object crcForCrypting, Object versionMadeBy, Object flagBase, int zip64) {
		zip64_internal zi = new zip64_internal();
		uInt size_filename = new uInt();
		uInt size_comment = new uInt();
		uInt i = new uInt();
		int err = (false);
		if (file == ((Object)0)) {
			return (true);
		} 
		if ((method != 0) && (method != 8)) {
			return (true);
		} 
		zi = (zip64_internal)file;
		Object generatedIn_opened_file_inzip = zi.getIn_opened_file_inzip();
		if (generatedIn_opened_file_inzip == 1) {
			err = ModernizedCProgram.zipCloseFileInZip(file);
			if (err != (false)) {
				return err;
			} 
		} 
		if (filename == ((Object)0)) {
			filename = "-";
		} 
		if (comment == ((Object)0)) {
			size_comment = 0;
		} else {
				size_comment = (uInt).strlen(comment);
		} 
		size_filename = (uInt).strlen(filename);
		Object generatedCi = zi.getCi();
		if (zipfi == ((Object)0)) {
			generatedCi.setDosDate(0);
		} else {
				if (zipfi.getDosDate() != 0) {
					generatedCi.setDosDate(zipfi.getDosDate());
				} else {
						generatedCi.setDosDate(ModernizedCProgram.zip64local_TmzDateToDosDate(zipfi.getTmz_date()));
				} 
		} 
		generatedCi.setFlag(flagBase);
		if ((level == 8) || (level == 9)) {
			generatedCi.getFlag() |=  2;
		} 
		if (level == 2) {
			generatedCi.getFlag() |=  4;
		} 
		if (level == 1) {
			generatedCi.getFlag() |=  6;
		} 
		if (password != ((Object)0)) {
			generatedCi.getFlag() |=  1;
		} 
		generatedCi.setCrc32(0);
		generatedCi.setMethod(method);
		generatedCi.setEncrypt(0);
		generatedCi.setStream_initialised(0);
		generatedCi.setPos_in_buffered_data(0);
		generatedCi.setRaw(raw);
		Object generatedZ_filefunc = zi.getZ_filefunc();
		Object generatedFilestream = zi.getFilestream();
		generatedCi.setPos_local_header((ModernizedCProgram.call_ztell64(((generatedZ_filefunc)), (generatedFilestream))));
		generatedCi.setSize_centralheader((true) + size_filename + size_extrafield_global + size_comment);
		// Extra space we have reserved in case we need to add ZIP64 extra info data// Extra space we have reserved in case we need to add ZIP64 extra info datageneratedCi.setSize_centralExtraFree(32);
		generatedCi.setCentral_header((byte)(.malloc((uInt)generatedCi.getSize_centralheader() + generatedCi.getSize_centralExtraFree())));
		generatedCi.setSize_centralExtra(size_extrafield_global);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header(), (uLong)(true), 4);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 4, (uLong)versionMadeBy, /* version info */2);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 6, (uLong)20, 2);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 8, (uLong)generatedCi.getFlag(), 2);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 10, (uLong)generatedCi.getMethod(), 2);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 12, (uLong)generatedCi.getDosDate(), 4);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 16, (uLong)0, /*crc*/4);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 20, (uLong)0, /*compr size*/4);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 24, (uLong)0, /*uncompr size*/4);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 28, (uLong)size_filename, 2);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 30, (uLong)size_extrafield_global, 2);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 32, (uLong)size_comment, 2);
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 34, (uLong)0, /*disk nm start*/2);
		if (zipfi == ((Object)0)) {
			ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 36, (uLong)0, 2);
		} else {
				ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 36, (uLong)zipfi.getInternal_fa(), 2);
		} 
		if (zipfi == ((Object)0)) {
			ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 38, (uLong)0, 4);
		} else {
				ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 38, (uLong)zipfi.getExternal_fa(), 4);
		} 
		Object generatedAdd_position_when_writing_offset = zi.getAdd_position_when_writing_offset();
		if (generatedCi.getPos_local_header() >= -1024) {
			ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 42, (uLong)-1024, 4);
		} else {
				ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 42, (uLong)generatedCi.getPos_local_header() - generatedAdd_position_when_writing_offset, 4);
		} 
		for (i = 0; i < size_filename; i++) {
			(generatedCi.getCentral_header() + (true) + i) = (filename + i);
		}
		for (i = 0; i < size_extrafield_global; i++) {
			(generatedCi.getCentral_header() + (true) + size_filename + i) = (((byte)extrafield_global) + i);
		}
		for (i = 0; i < size_comment; i++) {
			(generatedCi.getCentral_header() + (true) + size_filename + size_extrafield_global + i) = (comment + i);
		}
		if (generatedCi.getCentral_header() == ((Object)0)) {
			return (true);
		} 
		generatedCi.setZip64(zip64);
		generatedCi.setTotalCompressedData(0);
		generatedCi.setTotalUncompressedData(0);
		generatedCi.setPos_zip64extrainfo(0);
		err = zi.Write_LocalFileHeader(filename, size_extrafield_local, extrafield_local);
		generatedCi.getStream().setAvail_in((uInt)0);
		generatedCi.getStream().setAvail_out((uInt)(64 * 1024));
		generatedCi.getStream().setNext_out(generatedCi.getBuffered_data());
		generatedCi.getStream().setTotal_in(0);
		generatedCi.getStream().setTotal_out(0);
		generatedCi.getStream().setData_type(0);
		if ((err == (false)) && (generatedCi.getMethod() == 8) && (!generatedCi.getRaw())) {
			if (generatedCi.getMethod() == 8) {
				generatedCi.getStream().setZalloc((alloc_func)0);
				generatedCi.getStream().setZfree((free_func)0);
				generatedCi.getStream().setOpaque((voidpf)0);
				if (windowBits > 0) {
					windowBits = -windowBits;
				} 
				err = ModernizedCProgram.deflateInit2_((generatedCi.getStream()), (level), (true), (windowBits), (memLevel), (strategy), "1.2.11", (int));
				if (err == 0) {
					generatedCi.setStream_initialised(8);
				} 
			}  else if (generatedCi.getMethod() == 12) {
			} 
		} 
		generatedCi.setCrypt_header_size(0);
		if ((err == 0) && (password != ((Object)0))) {
			byte[] bufHead = new byte[12];
			int sizeHead;
			generatedCi.setEncrypt(1);
			generatedCi.setPcrc_32_tab(ModernizedCProgram.get_crc_table());
			sizeHead = .crypthead(password, bufHead, 12, generatedCi.getKeys(), generatedCi.getPcrc_32_tab(), crcForCrypting);
			generatedCi.setCrypt_header_size(sizeHead);
			if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, bufHead, sizeHead)) != sizeHead) {
				err = ((true));
			} 
		} 
		if (err == 0) {
			zi.setIn_opened_file_inzip(1);
		} 
		return err;
	}
	public static int zipOpenNewFileInZip4(Object file, Object filename, Object zipfi, Object extrafield_local, Object size_extrafield_local, Object extrafield_global, Object size_extrafield_global, Object comment, int method, int level, int raw, int windowBits, int memLevel, int strategy, Object password, Object crcForCrypting, Object versionMadeBy, Object flagBase) {
		return ModernizedCProgram.zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, raw, windowBits, memLevel, strategy, password, crcForCrypting, versionMadeBy, flagBase, 0);
	}
	public static int zipOpenNewFileInZip3(Object file, Object filename, Object zipfi, Object extrafield_local, Object size_extrafield_local, Object extrafield_global, Object size_extrafield_global, Object comment, int method, int level, int raw, int windowBits, int memLevel, int strategy, Object password, Object crcForCrypting) {
		return ModernizedCProgram.zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, raw, windowBits, memLevel, strategy, password, crcForCrypting, (true), 0, 0);
	}
	public static int zipOpenNewFileInZip3_64(Object file, Object filename, Object zipfi, Object extrafield_local, Object size_extrafield_local, Object extrafield_global, Object size_extrafield_global, Object comment, int method, int level, int raw, int windowBits, int memLevel, int strategy, Object password, Object crcForCrypting, int zip64) {
		return ModernizedCProgram.zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, raw, windowBits, memLevel, strategy, password, crcForCrypting, (true), 0, zip64);
	}
	public static int zipOpenNewFileInZip2(Object file, Object filename, Object zipfi, Object extrafield_local, Object size_extrafield_local, Object extrafield_global, Object size_extrafield_global, Object comment, int method, int level, int raw) {
		return ModernizedCProgram.zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, raw, -15, 8, 0, ((Object)0), 0, (true), 0, 0);
	}
	public static int zipOpenNewFileInZip2_64(Object file, Object filename, Object zipfi, Object extrafield_local, Object size_extrafield_local, Object extrafield_global, Object size_extrafield_global, Object comment, int method, int level, int raw, int zip64) {
		return ModernizedCProgram.zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, raw, -15, 8, 0, ((Object)0), 0, (true), 0, zip64);
	}
	public static int zipOpenNewFileInZip64(Object file, Object filename, Object zipfi, Object extrafield_local, Object size_extrafield_local, Object extrafield_global, Object size_extrafield_global, Object comment, int method, int level, int zip64) {
		return ModernizedCProgram.zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, 0, -15, 8, 0, ((Object)0), 0, (true), 0, zip64);
	}
	public static int zipOpenNewFileInZip(Object file, Object filename, Object zipfi, Object extrafield_local, Object size_extrafield_local, Object extrafield_global, Object size_extrafield_global, Object comment, int method, int level) {
		return ModernizedCProgram.zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, 0, -15, 8, 0, ((Object)0), 0, (true), 0, 0);
	}
	public static int zip64FlushWriteBuffer() {
		int err = (false);
		Object generatedCi = this.getCi();
		if (generatedCi.getEncrypt() != 0) {
			uInt i = new uInt();
			int t;
			for (i = 0; i < generatedCi.getPos_in_buffered_data(); i++) {
				generatedCi.getBuffered_data()[i] = ();
			}
		} 
		Object generatedZ_filefunc = this.getZ_filefunc();
		Object generatedFilestream = this.getFilestream();
		if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, generatedCi.getBuffered_data(), generatedCi.getPos_in_buffered_data())) != generatedCi.getPos_in_buffered_data()) {
			err = ((true));
		} 
		generatedCi.getTotalCompressedData() += generatedCi.getPos_in_buffered_data();
		{ 
			generatedCi.getTotalUncompressedData() += generatedCi.getStream().getTotal_in();
			generatedCi.getStream().setTotal_in(0);
		}
		generatedCi.setPos_in_buffered_data(0);
		return err;
	}
	public static int zipWriteInFileInZip(Object file, Object buf, int len) {
		zip64_internal zi = new zip64_internal();
		int err = (false);
		if (file == ((Object)0)) {
			return (true);
		} 
		zi = (zip64_internal)file;
		Object generatedIn_opened_file_inzip = zi.getIn_opened_file_inzip();
		if (generatedIn_opened_file_inzip == 0) {
			return (true);
		} 
		Object generatedCi = zi.getCi();
		generatedCi.setCrc32(ModernizedCProgram.crc32(generatedCi.getCrc32(), buf, (uInt)len))//          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;;//          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;
		{ 
			generatedCi.getStream().setNext_in((Bytef)buf);
			generatedCi.getStream().setAvail_in(len);
			while ((err == (false)) && (generatedCi.getStream().getAvail_in() > 0)) {
				if (generatedCi.getStream().getAvail_out() == 0) {
					if (zi.zip64FlushWriteBuffer() == ((true))) {
						err = ((true));
					} 
					generatedCi.getStream().setAvail_out((uInt)(64 * 1024));
					generatedCi.getStream().setNext_out(generatedCi.getBuffered_data());
				} 
				if (err != (false)) {
					break;
				} 
				if ((generatedCi.getMethod() == 8) && (!generatedCi.getRaw())) {
					uLong uTotalOutBefore = generatedCi.getStream().getTotal_out();
					err = ModernizedCProgram.deflate(generatedCi.getStream(), 0);
					if (uTotalOutBefore > generatedCi.getStream().getTotal_out()) {
						int bBreak = 0;
						bBreak++;
					} 
					generatedCi.getPos_in_buffered_data() += (uInt)(generatedCi.getStream().getTotal_out() - uTotalOutBefore);
				} else {
						uInt copy_this = new uInt();
						uInt i = new uInt();
						if (generatedCi.getStream().getAvail_in() < generatedCi.getStream().getAvail_out()) {
							copy_this = generatedCi.getStream().getAvail_in();
						} else {
								copy_this = generatedCi.getStream().getAvail_out();
						} 
						for (i = 0; i < copy_this; i++) {
							(((byte)generatedCi.getStream().getNext_out()) + i) = (((byte)generatedCi.getStream().getNext_in()) + i);
						}
						{ 
							generatedCi.getStream().getAvail_in() -= copy_this;
							generatedCi.getStream().getAvail_out() -= copy_this;
							generatedCi.getStream().getNext_in() += copy_this;
							generatedCi.getStream().getNext_out() += copy_this;
							generatedCi.getStream().getTotal_in() += copy_this;
							generatedCi.getStream().getTotal_out() += copy_this;
							generatedCi.getPos_in_buffered_data() += copy_this;
						}
				} 
			}
		}
		return err;
	}
	public static int zipCloseFileInZipRaw(Object file, Object uncompressed_size, Object crc32) {
		return ModernizedCProgram.zipCloseFileInZipRaw64(file, uncompressed_size, crc32);
	}
	public static int zipCloseFileInZipRaw64(Object file, Object uncompressed_size, Object crc32) {
		zip64_internal zi = new zip64_internal();
		ZPOS64_T compressed_size = new ZPOS64_T();
		uLong invalidValue = -1024;
		int datasize = 0;
		int err = (false);
		if (file == ((Object)0)) {
			return (true);
		} 
		zi = (zip64_internal)file;
		Object generatedIn_opened_file_inzip = zi.getIn_opened_file_inzip();
		if (generatedIn_opened_file_inzip == 0) {
			return (true);
		} 
		Object generatedCi = zi.getCi();
		generatedCi.getStream().setAvail_in(0);
		if ((generatedCi.getMethod() == 8) && (!generatedCi.getRaw())) {
			while (err == (false)) {
				uLong uTotalOutBefore = new uLong();
				if (generatedCi.getStream().getAvail_out() == 0) {
					if (zi.zip64FlushWriteBuffer() == ((true))) {
						err = ((true));
					} 
					generatedCi.getStream().setAvail_out((uInt)(64 * 1024));
					generatedCi.getStream().setNext_out(generatedCi.getBuffered_data());
				} 
				uTotalOutBefore = generatedCi.getStream().getTotal_out();
				err = ModernizedCProgram.deflate(generatedCi.getStream(), 4);
				generatedCi.getPos_in_buffered_data() += (uInt)(generatedCi.getStream().getTotal_out() - uTotalOutBefore);
			}
		}  else if ((generatedCi.getMethod() == 12) && (!generatedCi.getRaw())) {
		} 
		if (err == 1) {
			err = (/* this is normal */false);
		} 
		if ((generatedCi.getPos_in_buffered_data() > 0) && (err == (false))) {
			if (zi.zip64FlushWriteBuffer() == ((true))) {
				err = ((true));
			} 
		} 
		if ((generatedCi.getMethod() == 8) && (!generatedCi.getRaw())) {
			int tmp_err = ModernizedCProgram.deflateEnd(generatedCi.getStream());
			if (err == (false)) {
				err = tmp_err;
			} 
			generatedCi.setStream_initialised(0);
		} 
		if (!generatedCi.getRaw()) {
			crc32 = (uLong)generatedCi.getCrc32();
			uncompressed_size = generatedCi.getTotalUncompressedData();
		} 
		compressed_size = generatedCi.getTotalCompressedData();
		compressed_size += generatedCi.getCrypt_header_size();
		// update Current Item crc and sizes,if (compressed_size >= -1024 || uncompressed_size >= -1024 || generatedCi.getPos_local_header() >= -1024) {
			ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 4, (uLong)45, /*version Made by*/2);
			ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 6, (uLong)45, /*version needed*/2);
		} 
		ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 16, crc32, /*crc*/4);
		if (compressed_size >= -1024) {
			ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 20, invalidValue, /*compr size*/4);
		} else {
				ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 20, compressed_size, /*compr size*/4);
		} 
		/// set internal file attributes fieldif (generatedCi.getStream().getData_type() == 1) {
			ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 36, (uLong)1, 2);
		} 
		if (uncompressed_size >= -1024) {
			ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 24, invalidValue, /*uncompr size*/4);
		} else {
				ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 24, uncompressed_size, /*uncompr size*/4);
		} 
		// Add ZIP64 extra info field for uncompressed sizeif (uncompressed_size >= -1024) {
			datasize += 8;
		} 
		// Add ZIP64 extra info field for compressed sizeif (compressed_size >= -1024) {
			datasize += 8;
		} 
		// Add ZIP64 extra info field for relative offset to local file header of current fileif (generatedCi.getPos_local_header() >= -1024) {
			datasize += 8;
		} 
		if (datasize > 0) {
			byte p = ((Object)0);
			if ((uLong)(datasize + 4) > generatedCi.getSize_centralExtraFree()) {
				return (true);
			} 
			p = generatedCi.getCentral_header() + generatedCi.getSize_centralheader();
			ModernizedCProgram.zip64local_putValue_inmemory(p, -1024, 2);
			p += 2;
			ModernizedCProgram.zip64local_putValue_inmemory(p, datasize, 2);
			p += 2;
			if (uncompressed_size >= -1024) {
				ModernizedCProgram.zip64local_putValue_inmemory(p, uncompressed_size, 8);
				p += 8;
			} 
			if (compressed_size >= -1024) {
				ModernizedCProgram.zip64local_putValue_inmemory(p, compressed_size, 8);
				p += 8;
			} 
			if (generatedCi.getPos_local_header() >= -1024) {
				ModernizedCProgram.zip64local_putValue_inmemory(p, generatedCi.getPos_local_header(), 8);
				p += 8;
			} 
			generatedCi.getSize_centralExtraFree() -= datasize + 4;
			generatedCi.getSize_centralheader() += datasize + 4;
			generatedCi.getSize_centralExtra() += datasize + 4;
			ModernizedCProgram.zip64local_putValue_inmemory(generatedCi.getCentral_header() + 30, (uLong)generatedCi.getSize_centralExtra(), 2);
		} 
		Object generatedCentral_dir = zi.getCentral_dir();
		if (err == (false)) {
			err = generatedCentral_dir.add_data_in_datablock(generatedCi.getCentral_header(), (uLong)generatedCi.getSize_centralheader());
		} 
		.free(generatedCi.getCentral_header());
		Object generatedZ_filefunc = zi.getZ_filefunc();
		Object generatedFilestream = zi.getFilestream();
		if (err == (false)) {
			ZPOS64_T cur_pos_inzip = (ModernizedCProgram.call_ztell64(((generatedZ_filefunc)), (generatedFilestream)));
			if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (generatedCi.getPos_local_header() + 14), ((false)))) != 0) {
				err = ((true));
			} 
			if (err == (false)) {
				err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, crc32, /* crc 32, unknown */4);
			} 
			if (uncompressed_size >= -1024 || compressed_size >= -1024) {
				if (generatedCi.getPos_zip64extrainfo() > 0) {
					if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (generatedCi.getPos_zip64extrainfo() + 4), ((false)))) != 0) {
						err = ((true));
					} 
					if (err == (/* compressed size, unknown */false)) {
						err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, uncompressed_size, 8);
					} 
					if (err == (/* uncompressed size, unknown */false)) {
						err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, compressed_size, 8);
					} 
				} else {
						err = (true);
				} 
			} else {
					if (err == (/* compressed size, unknown */false)) {
						err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, compressed_size, 4);
					} 
					if (err == (/* uncompressed size, unknown */false)) {
						err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, uncompressed_size, 4);
					} 
			} 
			if ((ModernizedCProgram.call_zseek64(((generatedZ_filefunc)), (generatedFilestream), (cur_pos_inzip), ((false)))) != 0) {
				err = ((true));
			} 
		} 
		// Update the LocalFileHeader with the new values.
		Object generatedNumber_entry = zi.getNumber_entry();
		generatedNumber_entry++;
		zi.setIn_opened_file_inzip(0);
		return err;
	}
	public static int zipCloseFileInZip(Object file) {
		return ModernizedCProgram.zipCloseFileInZipRaw(file, 0, 0);
	}
	public static int Write_Zip64EndOfCentralDirectoryLocator(Object zip64eocd_pos_inzip) {
		int err = (false);
		Object generatedAdd_position_when_writing_offset = this.getAdd_position_when_writing_offset();
		ZPOS64_T pos = zip64eocd_pos_inzip - generatedAdd_position_when_writing_offset;
		Object generatedZ_filefunc = this.getZ_filefunc();
		Object generatedFilestream = this.getFilestream();
		err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)(true), 4);
		if (err == (/*num disks*//* number of the disk with the start of the central directory */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)0, 4);
		} 
		if (err == (/*relative offset*//* Relative offset to the Zip64EndOfCentralDirectory */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, pos, 8);
		} 
		if (err == (/*total disks*//* Do not support spawning of disk so always say 1 here*//* number of the disk with the start of the central directory */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)1, 4);
		} 
		return err;
	}
	public static int Write_Zip64EndOfCentralDirectoryRecord(Object size_centraldir, Object centraldir_pos_inzip) {
		int err = (false);
		uLong Zip64DataSize = 44;
		Object generatedZ_filefunc = this.getZ_filefunc();
		Object generatedFilestream = this.getFilestream();
		err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)(true), 4);
		if (err == (/* size of this 'zip64 end of central directory' */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (ZPOS64_T)Zip64DataSize, 8);
		} 
		if (err == (/* version made by */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)45, 2);
		} 
		if (err == (/* version needed */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)45, 2);
		} 
		if (err == (/* number of this disk */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)0, 4);
		} 
		if (err == (/* number of the disk with the start of the central directory */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)0, 4);
		} 
		Object generatedNumber_entry = this.getNumber_entry();
		if (err == (/* total number of entries in the central dir on this disk */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, generatedNumber_entry, 8);
		} 
		if (err == (/* total number of entries in the central dir */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, generatedNumber_entry, 8);
		} 
		if (err == (/* size of the central directory */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (ZPOS64_T)size_centraldir, 8);
		} 
		Object generatedAdd_position_when_writing_offset = this.getAdd_position_when_writing_offset();
		if (err == (/* offset of start of central directory with respect to the starting disk number */false)) {
			ZPOS64_T pos = centraldir_pos_inzip - generatedAdd_position_when_writing_offset;
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (ZPOS64_T)pos, 8);
		} 
		return err;
	}
	public static int Write_EndOfCentralDirectoryRecord(Object size_centraldir, Object centraldir_pos_inzip) {
		int err = (false);
		Object generatedZ_filefunc = this.getZ_filefunc();
		Object generatedFilestream = this.getFilestream();
		err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)(true), /*signature*/4);
		if (err == (/* number of this disk */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)0, 2);
		} 
		if (err == (/* number of the disk with the start of the central directory */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)0, 2);
		} 
		Object generatedNumber_entry = this.getNumber_entry();
		if (err == (/* total number of entries in the central dir on this disk */false)) {
			{ 
				if (generatedNumber_entry >= -1024) {
					err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)-1024, 2);
				} else {
						err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)generatedNumber_entry, 2);
				} 
			}
		} 
		if (err == (/* total number of entries in the central dir */false)) {
			if (generatedNumber_entry >= -1024) {
				err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)-1024, 2);
			} else {
					err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)generatedNumber_entry, 2);
			} 
		} 
		if (err == (/* size of the central directory */false)) {
			err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)size_centraldir, 4);
		} 
		Object generatedAdd_position_when_writing_offset = this.getAdd_position_when_writing_offset();
		if (err == (/* offset of start of central directory with respect to the starting disk number */false)) {
			ZPOS64_T pos = centraldir_pos_inzip - generatedAdd_position_when_writing_offset;
			if (pos >= -1024) {
				err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)-1024, 4);
			} else {
					err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)(centraldir_pos_inzip - generatedAdd_position_when_writing_offset), 4);
			} 
		} 
		return err;
	}
	public static int Write_GlobalComment(Object global_comment) {
		int err = (false);
		uInt size_global_comment = 0;
		if (global_comment != ((Object)0)) {
			size_global_comment = (uInt).strlen(global_comment);
		} 
		Object generatedZ_filefunc = this.getZ_filefunc();
		Object generatedFilestream = this.getFilestream();
		err = ModernizedCProgram.zip64local_putValue(generatedZ_filefunc, generatedFilestream, (uLong)size_global_comment, 2);
		if (err == (false) && size_global_comment > 0) {
			if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, global_comment, size_global_comment)) != size_global_comment) {
				err = ((true));
			} 
		} 
		return err;
	}
	public static int zipClose(Object file, Object global_comment) {
		zip64_internal zi = new zip64_internal();
		int err = 0;
		uLong size_centraldir = 0;
		ZPOS64_T centraldir_pos_inzip = new ZPOS64_T();
		ZPOS64_T pos = new ZPOS64_T();
		if (file == ((Object)0)) {
			return (true);
		} 
		zi = (zip64_internal)file;
		Object generatedIn_opened_file_inzip = zi.getIn_opened_file_inzip();
		if (generatedIn_opened_file_inzip == 1) {
			err = ModernizedCProgram.zipCloseFileInZip(file);
		} 
		Object generatedGlobalcomment = zi.getGlobalcomment();
		if (global_comment == ((Object)0)) {
			global_comment = generatedGlobalcomment;
		} 
		Object generatedZ_filefunc = zi.getZ_filefunc();
		Object generatedFilestream = zi.getFilestream();
		centraldir_pos_inzip = (ModernizedCProgram.call_ztell64(((generatedZ_filefunc)), (generatedFilestream)));
		Object generatedCentral_dir = zi.getCentral_dir();
		Object generatedFilled_in_this_block = ldi.getFilled_in_this_block();
		Object generatedData = ldi.getData();
		linkedlist_datablock_internal_s generatedNext_datablock = ldi.getNext_datablock();
		if (err == (false)) {
			linkedlist_datablock_internal ldi = generatedCentral_dir.getFirst_block();
			while (ldi != ((Object)0)) {
				if ((err == (false)) && (generatedFilled_in_this_block > 0)) {
					if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream, generatedData, generatedFilled_in_this_block)) != generatedFilled_in_this_block) {
						err = ((true));
					} 
				} 
				size_centraldir += generatedFilled_in_this_block;
				ldi = generatedNext_datablock;
			}
		} 
		(generatedCentral_dir).free_linkedlist();
		Object generatedAdd_position_when_writing_offset = zi.getAdd_position_when_writing_offset();
		pos = centraldir_pos_inzip - generatedAdd_position_when_writing_offset;
		Object generatedNumber_entry = zi.getNumber_entry();
		if (pos >= -1024 || generatedNumber_entry > -1024) {
			ZPOS64_T Zip64EOCDpos = (ModernizedCProgram.call_ztell64(((generatedZ_filefunc)), (generatedFilestream)));
			zi.Write_Zip64EndOfCentralDirectoryRecord(size_centraldir, centraldir_pos_inzip);
			zi.Write_Zip64EndOfCentralDirectoryLocator(Zip64EOCDpos);
		} 
		if (err == (false)) {
			err = zi.Write_EndOfCentralDirectoryRecord(size_centraldir, centraldir_pos_inzip);
		} 
		if (err == (false)) {
			err = zi.Write_GlobalComment(global_comment);
		} 
		if ((.UNRECOGNIZEDFUNCTIONNAME((generatedZ_filefunc).getZfile_func64().getOpaque(), generatedFilestream)) != 0) {
			if (err == (false)) {
				err = ((true));
			} 
		} 
		{ 
			if (generatedGlobalcomment) {
				.free(generatedGlobalcomment);
			} 
		}
		;
		{ 
			if (zi) {
				.free(zi);
			} 
		}
		;
		return err;
	}
	public static int zipRemoveExtraInfoBlock(Byte pData, int dataLen, int sHeader) {
		byte p = pData;
		int size = 0;
		byte pNewHeader;
		byte pTmp;
		int header;
		int dataSize;
		int retVal = (false);
		if (pData == ((Object)0) || dataLen < 4) {
			return (true);
		} 
		pNewHeader = (byte)(.malloc(dataLen));
		pTmp = pNewHeader;
		while (p < (pData + dataLen)) {
			header = (int)p;
			dataSize = (((int)p) + 1);
			if (header == sHeader) {
				p += dataSize + 4;
			} else {
					.memcpy(pTmp, p, dataSize + 4);
					p += dataSize + 4;
					size += dataSize + 4;
			} 
		}
		if (size < dataLen) {
			.memset(pData, 0, dataLen);
			if (size > 0) {
				.memcpy(pData, pNewHeader, size);
			} 
			dataLen = size;
			retVal = (false);
		} else {
				retVal = ((true));
		} 
		{ 
			if (pNewHeader) {
				.free(pNewHeader);
			} 
		}
		;
		return retVal;
	}
	/* MtCoder.c -- Multi-thread Coder
	2018-07-04 : Igor Pavlov : Public domain */
	public static Object MtProgressThunk_Progress(Object pp, Object inSize, Object outSize) {
		CMtProgressThunk thunk = ((CMtProgressThunk)((byte)(true ? (pp) : ((CMtProgressThunk)0).getVt()) - ((size_t)((CMtProgressThunk)0).getVt())));
		UInt64 inSize2 = 0;
		UInt64 outSize2 = 0;
		Object generatedInSize = thunk.getInSize();
		if (inSize != (UInt64)(Int64)-1) {
			inSize2 = inSize - generatedInSize;
			thunk.setInSize(inSize);
		} 
		Object generatedOutSize = thunk.getOutSize();
		if (outSize != (UInt64)(Int64)-1) {
			outSize2 = outSize - generatedOutSize;
			thunk.setOutSize(outSize);
		} 
		Object generatedMtProgress = thunk.getMtProgress();
		return generatedMtProgress.MtProgress_ProgressAdd(inSize2, outSize2);
	}
	public static void MtProgressThunk_CreateVTable() {
		Object generatedVt = this.getVt();
		generatedVt.setProgress(MtProgressThunk_Progress);
	}
	public static Object ArEvent_OptCreate_And_Reset(Object p) {
		if (((p) != ((Object)0))) {
			return ModernizedCProgram.Event_Reset(p);
		} 
		return ModernizedCProgram.AutoResetEvent_CreateNotSignaled(p);
		if (((p) != ((Object)0))) {
			return ModernizedCProgram.Event_Reset(p);
		} 
		return ModernizedCProgram.AutoResetEvent_CreateNotSignaled(p);
	}
	public static Object MtCoderThread_CreateAndStart() {
		Object generatedStartEvent = this.getStartEvent();
		WRes wres = ModernizedCProgram.ArEvent_OptCreate_And_Reset(generatedStartEvent);
		Object generatedThread = this.getThread();
		if (wres == 0) {
			this.setStop(0);
			if (!((generatedThread) != ((Object)0))) {
				wres = ModernizedCProgram.Thread_Create(generatedThread, ModernizedCProgram.ThreadFunc, t);
			} 
			if (wres == 0) {
				wres = ModernizedCProgram.Event_Set(generatedStartEvent);
			} 
		} 
		if (wres == 0) {
			return 0;
		} 
		return (wres ? ((HRESULT)(((wres) & -1024) | (7 << 16) | -1024)) : 0);
	}
	public static void MtCoderThread_Destruct() {
		Object generatedThread = this.getThread();
		Object generatedStartEvent = this.getStartEvent();
		if (((generatedThread) != ((Object)0))) {
			this.setStop(1);
			ModernizedCProgram.Event_Set(generatedStartEvent);
			ModernizedCProgram.Handle_WaitObject((generatedThread));
			ModernizedCProgram.HandlePtr_Close(generatedThread);
		} 
		ModernizedCProgram.HandlePtr_Close(generatedStartEvent);
		Object generatedInBuf = this.getInBuf();
		Object generatedMtCoder = this.getMtCoder();
		if (generatedInBuf) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedMtCoder.getAllocBig(), generatedInBuf);
			this.setInBuf(((Object)0));
		} 
	}
	public static Object ThreadFunc2() {
		Object generatedMtCoder = this.getMtCoder();
		CMtCoder mtc = generatedMtCoder;
		Object generatedReadEvent = mtc.getReadEvent();
		Object generatedStopReading = mtc.getStopReading();
		 generatedMtProgress = mtc.getMtProgress();
		Object generatedBlockSize = mtc.getBlockSize();
		ISeqInStream generatedInStream = mtc.getInStream();
		Object generatedInBuf = this.getInBuf();
		Object generatedAllocBig = mtc.getAllocBig();
		Object generatedReadProcessed = mtc.getReadProcessed();
		Object generatedInDataSize = mtc.getInDataSize();
		Object generatedInData = mtc.getInData();
		Object generatedBlocksSemaphore = mtc.getBlocksSemaphore();
		int generatedBlockIndex = mtc.getBlockIndex();
		int generatedNumBlocksMax = mtc.getNumBlocksMax();
		int generatedNumStartedThreads = mtc.getNumStartedThreads();
		int generatedNumStartedThreadsLimit = mtc.getNumStartedThreadsLimit();
		Object generatedExpectedDataSize = mtc.getExpectedDataSize();
		Object generatedThreads = mtc.getThreads();
		Object generatedCs = mtc.getCs();
		int generatedFreeBlockHead = mtc.getFreeBlockHead();
		Object generatedFreeBlockList = mtc.getFreeBlockList();
		Object generatedMtCallbackObject = mtc.getMtCallbackObject();
		Object generatedIndex = this.getIndex();
		Object generatedBlocks = mtc.getBlocks();
		int generatedWriteIndex = mtc.getWriteIndex();
		Object generatedReadyBlocks = mtc.getReadyBlocks();
		Object generatedWriteRes = mtc.getWriteRes();
		Object generatedRes = block.getRes();
		Object generatedBufIndex = block.getBufIndex();
		Object generatedFinished = block.getFinished();
		for (; ; ) {
			int bi;
			SRes res = new SRes();
			SRes res2 = new SRes();
			BoolInt finished = new BoolInt();
			int bufIndex;
			size_t size = new size_t();
			Byte inData = new Byte();
			UInt64 readProcessed = 0;
			{ 
				if ((ModernizedCProgram.Handle_WaitObject((generatedReadEvent))) != 0) {
					return 12;
				} 
			}
			if (generatedStopReading) {
				return ModernizedCProgram.Event_Set(generatedReadEvent) == 0 ? 0 : 12;
			} 
			res = generatedMtProgress.MtProgress_GetError();
			ModernizedCProgram.size = 0;
			inData = ((Object)0);
			finished = 1;
			if (res == 0) {
				ModernizedCProgram.size = generatedBlockSize;
				if (generatedInStream) {
					if (!generatedInBuf) {
						this.setInBuf((Byte).UNRECOGNIZEDFUNCTIONNAME(generatedAllocBig, generatedBlockSize));
						if (!generatedInBuf) {
							res = 2;
						} 
					} 
					if (res == 0) {
						res = generatedInStream.FullRead(generatedInBuf, ModernizedCProgram.size);
						readProcessed = generatedReadProcessed + ModernizedCProgram.size;
						mtc.setReadProcessed(readProcessed);
					} 
					if (res != 0) {
						mtc.setReadRes(res);
						generatedMtProgress.MtProgress_SetError(/* after reading error - we can stop encoding of previous blocks */res);
					} else {
							finished = (ModernizedCProgram.size != generatedBlockSize);
					} 
				} else {
						size_t rem = new size_t();
						readProcessed = generatedReadProcessed;
						rem = generatedInDataSize - (size_t)readProcessed;
						if (ModernizedCProgram.size > rem) {
							ModernizedCProgram.size = rem;
						} 
						inData = generatedInData + (size_t)readProcessed;
						readProcessed += ModernizedCProgram.size;
						mtc.setReadProcessed(readProcessed);
						finished = (generatedInDataSize == (size_t)readProcessed);
				} 
			} 
			res2 = /* we must get some block from blocksSemaphore before Event_Set(&mtc->readEvent) */0;
			if (ModernizedCProgram.Handle_WaitObject((generatedBlocksSemaphore)) != 0) {
				res2 = 12;
				if (res == 0) {
					res = res2;
				} 
			} 
			bi = generatedBlockIndex;
			if (++generatedBlockIndex >= generatedNumBlocksMax) {
				mtc.setBlockIndex(0);
			} 
			bufIndex = (int)(int)-1;
			if (res == 0) {
				res = generatedMtProgress.MtProgress_GetError();
			} 
			if (res != 0) {
				finished = 1;
			} 
			if (!finished) {
				if (generatedNumStartedThreads < generatedNumStartedThreadsLimit && generatedExpectedDataSize != readProcessed) {
					res = generatedThreads[generatedNumStartedThreads].MtCoderThread_CreateAndStart();
					if (res == 0) {
						generatedNumStartedThreads++;
					} else {
							generatedMtProgress.MtProgress_SetError(res);
							finished = 1;
					} 
				} 
			} 
			if (finished) {
				mtc.setStopReading(1);
			} 
			{ 
				if ((ModernizedCProgram.Event_Set(generatedReadEvent)) != 0) {
					return 12;
				} 
			}
			if (res2 != 0) {
				return res2;
			} 
			if (res == 0) {
				.EnterCriticalSection(generatedCs);
				bufIndex = generatedFreeBlockHead;
				mtc.setFreeBlockHead(generatedFreeBlockList[bufIndex]);
				.LeaveCriticalSection(generatedCs);
				res = .UNRECOGNIZEDFUNCTIONNAME(generatedMtCallbackObject, generatedIndex, bufIndex, generatedInStream ? generatedInBuf : inData, ModernizedCProgram.size, finished);
				if (res != 0) {
					generatedMtProgress.MtProgress_SetError(res);
				} 
			} 
			{ 
				CMtCoderBlock block = generatedBlocks[bi];
				block.setRes(res);
				block.setBufIndex(bufIndex);
				block.setFinished(finished);
			}
			{ 
				int wi;
				{ 
					.EnterCriticalSection(generatedCs);
					wi = generatedWriteIndex;
					if (wi == bi) {
						mtc.setWriteIndex((int)(int)-1);
					} else {
							generatedReadyBlocks[bi] = 1;
					} 
					.LeaveCriticalSection(generatedCs);
				}
				if (wi != bi) {
					if (res != 0 || finished) {
						return 0;
					} 
					continue;
				} 
				if (generatedWriteRes != 0) {
					res = generatedWriteRes;
				} 
				for (; ; ) {
					if (res == 0 && bufIndex != (int)(int)-1) {
						res = .UNRECOGNIZEDFUNCTIONNAME(generatedMtCallbackObject, bufIndex);
						if (res != 0) {
							mtc.setWriteRes(res);
							generatedMtProgress.MtProgress_SetError(res);
						} 
					} 
					if (++wi >= generatedNumBlocksMax) {
						wi = 0;
					} 
					{ 
						BoolInt isReady = new BoolInt();
						.EnterCriticalSection(generatedCs);
						if (bufIndex != (int)(int)-1) {
							generatedFreeBlockList[bufIndex] = generatedFreeBlockHead;
							mtc.setFreeBlockHead(bufIndex);
						} 
						isReady = generatedReadyBlocks[wi];
						if (isReady) {
							generatedReadyBlocks[wi] = 0;
						} else {
								mtc.setWriteIndex(wi);
						} 
						.LeaveCriticalSection(generatedCs);
						{ 
							if ((ModernizedCProgram.Semaphore_Release1(generatedBlocksSemaphore)) != 0) {
								return 12;
							} 
						}
						if (!isReady) {
							break;
						} 
					}
					{ 
						CMtCoderBlock block = generatedBlocks[wi];
						if (res == 0 && generatedRes != 0) {
							res = generatedRes;
						} 
						bufIndex = generatedBufIndex;
						finished = generatedFinished;
					}
				}
			}
			if (finished || res != 0) {
				return 0;
			} 
		}
		Object generatedMtDec = this.getMtDec();
		CMtDec p = generatedMtDec;
		;// SetThreadAffinityMask(GetCurrentThread(), 1 << t->index);
		Object generatedCanRead = this.getCanRead();
		Object generatedExitThread = p.getExitThread();
		Object generatedBlockIndex = p.getBlockIndex();
		Object generatedReadWasFinished = p.getReadWasFinished();
		Object generatedInBuf = this.getInBuf();
		Object generatedCrossEnd = p.getCrossEnd();
		Object generatedCrossStart = p.getCrossStart();
		Object generatedAlloc = p.getAlloc();
		Object generatedInBufSize = p.getInBufSize();
		Object generatedCrossBlock = p.getCrossBlock();
		ISeqInStream generatedInStream = p.getInStream();
		Object generatedReadProcessed = p.getReadProcessed();
		Object generatedMtCallbackObject = p.getMtCallbackObject();
		Object generatedIndex = this.getIndex();
		Object generatedCanCreateNewThread = parse.getCanCreateNewThread();
		Object generatedState = parse.getState();
		Object generatedSrcSize = parse.getSrcSize();
		__CMtDecBufLink generatedNext = link.getNext();
		int generatedNumStartedThreads = p.getNumStartedThreads();
		int generatedNumStartedThreads_Limit = p.getNumStartedThreads_Limit();
		Object generatedThreads = p.getThreads();
		Object generatedCanWrite = this.getCanWrite();
		Object generatedWasInterrupted = p.getWasInterrupted();
		 generatedMtProgress = p.getMtProgress();
		int generatedNumFilledThreads = p.getNumFilledThreads();
		for (; ; ) {
			SRes res = new SRes();
			SRes codeRes = new SRes();
			BoolInt wasInterrupted = new BoolInt();
			BoolInt isAllocError = new BoolInt();
			BoolInt overflow = new BoolInt();
			BoolInt finish = new BoolInt();
			SRes threadingErrorSRes = new SRes();
			BoolInt needCode = new BoolInt();
			BoolInt needWrite = new BoolInt();
			BoolInt needContinue = new BoolInt();
			size_t inDataSize_Start = new size_t();
			UInt64 inDataSize = new UInt64();
			UInt64 blockIndex = new UInt64();
			UInt64 inPrev = 0;
			UInt64 outPrev = 0;
			UInt64 inCodePos = new UInt64();
			UInt64 outCodePos = new UInt64();
			Byte afterEndData = ((Object)0);
			size_t afterEndData_Size = 0;
			BoolInt canCreateNewThread = 0;
			CMtDecThread nextThread = new CMtDecThread();
			;
			{ 
				int __result__ = (ModernizedCProgram.Handle_WaitObject((generatedCanRead)));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (generatedExitThread) {
				return 0;
			} 
			;
			blockIndex = generatedBlockIndex++;
			res = p.MtDec_Progress_GetError_Spec(0, 0, blockIndex, wasInterrupted);
			finish = generatedReadWasFinished;
			needCode = 0;
			needWrite = 0;
			isAllocError = 0;
			overflow = 0;
			inDataSize_Start = 0;
			inDataSize = 0;
			if (res == 0 && !wasInterrupted) {
				{ 
					CMtDecBufLink prev = ((Object)0);
					CMtDecBufLink link = (CMtDecBufLink)generatedInBuf;
					size_t crossSize = generatedCrossEnd - generatedCrossStart;
					;
					for (; ; ) {
						if (!link) {
							link = (CMtDecBufLink).UNRECOGNIZEDFUNCTIONNAME(generatedAlloc,  + generatedInBufSize);
							if (!link) {
								finish = 1;
								isAllocError = 1;
								break;
							} 
							link.setNext(((Object)0));
							if (prev) {
								prev.setNext(link);
							} else {
									this.setInBuf((Object)link);
							} 
						} 
						{ 
							Byte data = ((Byte)(link) + );
							Byte parseData = data;
							size_t size = new size_t();
							if (crossSize != 0) {
								inDataSize = crossSize;
								inDataSize_Start = crossSize;
								ModernizedCProgram.size = crossSize;
								parseData = ((Byte)(generatedCrossBlock) + ) + generatedCrossStart;
								;
							} else {
									ModernizedCProgram.size = generatedInBufSize;
									res = generatedInStream.FullRead(data, ModernizedCProgram.size);
									inDataSize += ModernizedCProgram.size;
									if (!prev) {
										inDataSize_Start = ModernizedCProgram.size;
									} 
									generatedReadProcessed += ModernizedCProgram.size;
									finish = (ModernizedCProgram.size != generatedInBufSize);
									if (finish) {
										p.setReadWasFinished(1);
									} 
									if (res != 0) {
										p.setReadRes(res);
										p.setReadWasFinished(1);
										finish = 1;
										res = 0;
									} 
									if (inDataSize - inPrev >= (1 << 0)) {
										res = p.MtDec_Progress_GetError_Spec(0, 0, blockIndex, wasInterrupted);
										if (res != 0 || wasInterrupted) {
											break;
										} 
										inPrev = inDataSize;
									} 
							} 
							{ 
								CMtDecCallbackInfo parse = new CMtDecCallbackInfo();
								parse.setStartCall((prev == ((Object)0)));
								parse.setSrc(parseData);
								parse.setSrcSize(ModernizedCProgram.size);
								parse.setSrcFinished(finish);
								parse.setCanCreateNewThread(1);
								.UNRECOGNIZEDFUNCTIONNAME(generatedMtCallbackObject, generatedIndex, parse);
								needWrite = 1;
								canCreateNewThread = generatedCanCreateNewThread;
								if (generatedState == .MTDEC_PARSE_OVERFLOW) {
									finish = 1;
									overflow = 1;
									{ 
										;
										;
									}
									if (crossSize != 0) {
										.memcpy(data, parseData, ModernizedCProgram.size);
									} 
									p.setCrossStart(0);
									p.setCrossEnd(0);
									break;
								} 
								if (crossSize != 0) {
									.memcpy(data, parseData, generatedSrcSize);
									generatedCrossStart += generatedSrcSize;
								} 
								if (generatedState != .MTDEC_PARSE_CONTINUE || finish) {
									if (generatedState == .MTDEC_PARSE_END) {
										finish = 1;
									} 
									needCode = 1;
									if (generatedSrcSize == ModernizedCProgram.size) {
										p.setCrossStart(0);
										p.setCrossEnd(0);
										break;
									} 
									if (generatedState == .MTDEC_PARSE_END) {
										p.setCrossStart(0);
										p.setCrossEnd(0);
										if (crossSize != 0) {
											.memcpy(data + generatedSrcSize, parseData + generatedSrcSize, ModernizedCProgram.size - generatedSrcSize);
										} 
										afterEndData_Size = ModernizedCProgram.size - generatedSrcSize;
										afterEndData = parseData + generatedSrcSize;
										inDataSize -= (ModernizedCProgram.size - generatedSrcSize);
										if (!prev) {
											inDataSize_Start = generatedSrcSize;
										} 
										break;
									} 
									{ 
										if (crossSize != 0) {
											inDataSize = generatedSrcSize;
										} else {
												Byte cr = p.MtDec_GetCrossBuff();
												if (!cr) {
													{ 
														;
														finish = 1;
														isAllocError = 1;
														break;
													}
												} 
												{ 
													size_t crSize = ModernizedCProgram.size - generatedSrcSize;
													inDataSize -= crSize;
													p.setCrossEnd(crSize);
													p.setCrossStart(0);
													.memcpy(cr, parseData + generatedSrcSize, crSize);
												}
										} 
										if (!prev) {
											inDataSize_Start = generatedSrcSize;
										} 
										finish = 0;
										break;
									}
								} 
								if (generatedSrcSize != ModernizedCProgram.size) {
									res = 11;
									;
									break;
								} 
							}
						}
						prev = link;
						link = generatedNext;
						if (crossSize != 0) {
							crossSize = 0;
							p.setCrossStart(0);
							p.setCrossEnd(0);
						} 
					}
				}
				if (res == 0) {
					res = p.MtDec_GetError_Spec(blockIndex, wasInterrupted);
				} 
			} 
			codeRes = 0;
			if (res == 0 && needCode && !wasInterrupted) {
				codeRes = .UNRECOGNIZEDFUNCTIONNAME(generatedMtCallbackObject, generatedIndex);
				if (codeRes != 0) {
					needCode = 0;
					finish = 1;
				} 
			} 
			if (res != 0 || wasInterrupted) {
				finish = 1;
			} 
			nextThread = ((Object)0);
			threadingErrorSRes = 0;
			if (!finish) {
				if (generatedNumStartedThreads < generatedNumStartedThreads_Limit && canCreateNewThread) {
					SRes res2 = generatedThreads[generatedNumStartedThreads].MtDecThread_CreateAndStart();
					if (res2 == 0) {
						generatedNumStartedThreads++;
					} else {
							;
							if (generatedNumStartedThreads == 1) {
								finish = 1;
								needCode = 0;
								threadingErrorSRes = res2;
							} else {
									p.setNumStartedThreads_Limit(generatedNumStartedThreads);
							} 
					} 
				} 
				if (!finish) {
					int nextIndex = generatedIndex + 1;
					nextThread = generatedThreads[nextIndex >= generatedNumStartedThreads ? 0 : nextIndex];
					{ 
						int __result__ = (ModernizedCProgram.Event_Set(generatedCanRead));
						if (__result__ != 0) {
							return __result__;
						} 
					}
				} 
			} 
			inPrev = 0;
			outPrev = 0;
			inCodePos = 0;
			outCodePos = 0;
			if (res == 0 && needCode && codeRes == 0) {
				BoolInt isStartBlock = 1;
				CMtDecBufLink link = (CMtDecBufLink)generatedInBuf;
				for (; ; ) {
					size_t inSize = new size_t();
					int stop;
					if (isStartBlock) {
						inSize = inDataSize_Start;
					} else {
							UInt64 rem = inDataSize - inCodePos;
							inSize = generatedInBufSize;
							if (inSize > rem) {
								inSize = (size_t)rem;
							} 
					} 
					inCodePos += inSize;
					stop = 1;
					codeRes = .UNRECOGNIZEDFUNCTIONNAME(generatedMtCallbackObject, generatedIndex, (Byte)((Byte)(link) + ), inSize, (inCodePos == inDataSize), inCodePos, outCodePos, stop);
					if (codeRes != 0) {
						;
						p.MtDec_Interrupt(blockIndex);
						break;
					} 
					if (stop || inCodePos == inDataSize) {
						break;
					} 
					{ 
						UInt64 inDelta = inCodePos - inPrev;
						UInt64 outDelta = outCodePos - outPrev;
						if (inDelta >= (1 << 0) || outDelta >= (1 << 0)) {
							res = p.MtDec_Progress_GetError_Spec(inDelta, outDelta, blockIndex, wasInterrupted);
							if (res != 0 || wasInterrupted) {
								break;
							} 
							inPrev = inCodePos;
							outPrev = outCodePos;
						} 
					}
					link = generatedNext;
					isStartBlock = 0;
				}
			} 
			{ 
				int __result__ = (ModernizedCProgram.Handle_WaitObject((generatedCanWrite)));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			{ 
				BoolInt isErrorMode = 0;
				BoolInt canRecode = 1;
				BoolInt needWriteToStream = needWrite;
				if (generatedExitThread) {
					return 0;
				} 
				if (generatedWasInterrupted) {
					wasInterrupted = 1;
				} else {
						if (codeRes != 0) {
							p.setWasInterrupted(1);
							p.setCodeRes(codeRes);
							if (codeRes == 2) {
								isAllocError = 1;
							} 
						} 
						if (threadingErrorSRes) {
							p.setWasInterrupted(1);
							p.setThreadingErrorSRes(threadingErrorSRes);
							needWriteToStream = 0;
						} 
						if (isAllocError) {
							p.setWasInterrupted(1);
							p.setIsAllocError(1);
							needWriteToStream = 0;
						} 
						if (overflow) {
							p.setWasInterrupted(1);
							p.setOverflow(1);
							needWriteToStream = 0;
						} 
				} 
				if (needCode) {
					if (wasInterrupted) {
						inCodePos = 0;
						outCodePos = 0;
					} 
					{ 
						UInt64 inDelta = inCodePos - inPrev;
						UInt64 outDelta = outCodePos - outPrev;
						res = generatedMtProgress.MtProgress_ProgressAdd(inDelta, outDelta);
					}
				} 
				needContinue = (!finish);
				if (needWrite) {
					res = .UNRECOGNIZEDFUNCTIONNAME(generatedMtCallbackObject, generatedIndex, res == 0 && needWriteToStream && !wasInterrupted, afterEndData, afterEndData_Size, needContinue, canRecode);
					;
					;
					if (res != 0) {
						;
						isErrorMode = 1;
						p.setWasInterrupted(1);
					} 
					if (res != 0 || (!needContinue && !finish)) {
						;
						p.MtDec_Interrupt(blockIndex);
					} 
				} 
				if (canRecode) {
					if (!needCode || res != 0 || generatedWasInterrupted || codeRes != 0 || wasInterrupted || generatedNumFilledThreads != 0 || isErrorMode) {
						if (generatedNumFilledThreads == 0) {
							p.setFilledThreadStart(generatedIndex);
						} 
						if (inDataSize != 0 || !finish) {
							this.setInDataSize_Start(inDataSize_Start);
							this.setInDataSize(inDataSize);
							generatedNumFilledThreads++;
						} 
						;
						;
					} 
				} 
				if (!finish) {
					{ 
						int __result__ = (ModernizedCProgram.Event_Set(generatedCanWrite));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
				} else {
						if (needContinue) {
							{ 
								int __result__ = (ModernizedCProgram.Event_Set(generatedCanWrite));
								if (__result__ != 0) {
									return __result__;
								} 
							}
							;
						} else {
								if (generatedIndex == 0) {
									return 0;
								} 
								p.setExitThread(1);
						} 
						{ 
							int __result__ = (ModernizedCProgram.Event_Set(generatedCanRead));
							if (__result__ != 0) {
								return __result__;
							} 
						}
						;
				} 
			}
		}
	}
	public static Object ThreadFunc(Object pp) {
		CMtCoderThread t = (CMtCoderThread)pp;
		Object generatedStartEvent = t.getStartEvent();
		Object generatedStop = t.getStop();
		Object generatedMtCoder = t.getMtCoder();
		 generatedMtProgress = mtc.getMtProgress();
		Object generatedNumFinishedThreads = mtc.getNumFinishedThreads();
		int generatedNumStartedThreads = mtc.getNumStartedThreads();
		Object generatedFinishedEvent = mtc.getFinishedEvent();
		for (; ; ) {
			if (ModernizedCProgram.Handle_WaitObject((generatedStartEvent)) != 0) {
				return 12;
			} 
			if (generatedStop) {
				return 0;
			} 
			{ 
				SRes res = t.ThreadFunc2();
				CMtCoder mtc = generatedMtCoder;
				if (res != 0) {
					generatedMtProgress.MtProgress_SetError(res);
				} 
				{ 
					int numFinished = (int).InterlockedIncrement(generatedNumFinishedThreads);
					if (numFinished == generatedNumStartedThreads) {
						if (ModernizedCProgram.Event_Set(generatedFinishedEvent) != 0) {
							return 12;
						} 
					} 
				}
			}
		}
		CMtDecThread t = (CMtDecThread)pp;
		// fprintf(stderr, "\n%d = %p - before", t->index, &t);
		Object generatedIndex = t.getIndex();
		t.setAllocaPtr(.__builtin_alloca((generatedIndex * 128)));
		return ModernizedCProgram.ThreadFunc1(pp);
	}
	public static void test_compress(Object compr, Object comprLen, Object uncompr, Object uncomprLen) {
		int err;
		uLong len = (uLong).strlen(ModernizedCProgram.hello) + 1;
		err = ModernizedCProgram.compress(compr, comprLen, (Bytef)ModernizedCProgram.hello, len);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "compress", err);
				.exit(1);
			} 
		}
		;
		.strcpy((byte)uncompr, "garbage");
		err = ModernizedCProgram.uncompress(uncompr, uncomprLen, compr, comprLen);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "uncompress", err);
				.exit(1);
			} 
		}
		;
		if (.strcmp((byte)uncompr, ModernizedCProgram.hello)) {
			.fprintf((_iob[2]), "bad uncompress\n");
			.exit(1);
		} else {
				.printf("uncompress(): %s\n", (byte)uncompr);
		} 
	}
	/* ===========================================================================
	 * Test read/write of .gz files
	 */
	public static void test_gzio(Object fname, Object uncompr, Object uncomprLen) {
		int err;
		int len = (int).strlen(ModernizedCProgram.hello) + 1;
		gzFile file = new gzFile();
		long pos;
		file = ModernizedCProgram.gzopen(fname, "wb");
		if (file == ((Object)0)) {
			.fprintf((_iob[2]), "gzopen error\n");
			.exit(1);
		} 
		ModernizedCProgram.gzputc(file, (byte)'h');
		if (ModernizedCProgram.gzputs(file, "ello") != 4) {
			.fprintf((_iob[2]), "gzputs err: %s\n", ModernizedCProgram.gzerror(file, err));
			.exit(1);
		} 
		if (ModernizedCProgram.gzprintf(file, ", %s!", "hello") != 8) {
			.fprintf((_iob[2]), "gzprintf err: %s\n", ModernizedCProgram.gzerror(file, err));
			.exit(1);
		} 
		ModernizedCProgram.gzseek(file, -1024, /* add one zero byte */1);
		ModernizedCProgram.gzclose(file);
		file = ModernizedCProgram.gzopen(fname, "rb");
		if (file == ((Object)0)) {
			.fprintf((_iob[2]), "gzopen error\n");
			.exit(1);
		} 
		.strcpy((byte)uncompr, "garbage");
		if (ModernizedCProgram.gzread(file, uncompr, (int)uncomprLen) != len) {
			.fprintf((_iob[2]), "gzread err: %s\n", ModernizedCProgram.gzerror(file, err));
			.exit(1);
		} 
		if (.strcmp((byte)uncompr, ModernizedCProgram.hello)) {
			.fprintf((_iob[2]), "bad gzread: %s\n", (byte)uncompr);
			.exit(1);
		} else {
				.printf("gzread(): %s\n", (byte)uncompr);
		} 
		pos = ModernizedCProgram.gzseek(file, --1024, 1);
		if (pos != 6 || ModernizedCProgram.gztell(file) != pos) {
			.fprintf((_iob[2]), "gzseek error, pos=%ld, gztell=%ld\n", (long)pos, (long)ModernizedCProgram.gztell(file));
			.exit(1);
		} 
		if (((file).getHave() ? () : .UNRECOGNIZEDFUNCTIONNAME(file)) != (byte)' ') {
			.fprintf((_iob[2]), "gzgetc error\n");
			.exit(1);
		} 
		if (ModernizedCProgram.gzungetc((byte)' ', file) != (byte)' ') {
			.fprintf((_iob[2]), "gzungetc error\n");
			.exit(1);
		} 
		ModernizedCProgram.gzgets(file, (byte)uncompr, (int)uncomprLen);
		if (.strlen((byte)uncompr) != /* " hello!" */7) {
			.fprintf((_iob[2]), "gzgets err after gzseek: %s\n", ModernizedCProgram.gzerror(file, err));
			.exit(1);
		} 
		if (.strcmp((byte)uncompr, ModernizedCProgram.hello + 6)) {
			.fprintf((_iob[2]), "bad gzgets after gzseek\n");
			.exit(1);
		} else {
				.printf("gzgets() after gzseek: %s\n", (byte)uncompr);
		} 
		ModernizedCProgram.gzclose(file/* Z_SOLO */);
	}
	/* ===========================================================================
	 * Test compress() and uncompress()
	 */
	/* compressed file name */
	/* ===========================================================================
	 * Test deflate() with small buffers
	 */
	public static void test_deflate(Object compr, Object comprLen) {
		/* compression stream */z_stream c_stream = new z_stream();
		int err;
		uLong len = (uLong).strlen(ModernizedCProgram.hello) + 1;
		c_stream.setZalloc(ModernizedCProgram.zalloc);
		c_stream.setZfree(ModernizedCProgram.zfree);
		c_stream.setOpaque((voidpf)0);
		err = ModernizedCProgram.deflateInit_((c_stream), ((true)), "1.2.11", (int));
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflateInit", err);
				.exit(1);
			} 
		}
		;
		c_stream.setNext_in((byte)ModernizedCProgram.hello);
		c_stream.setNext_out(compr);
		Object generatedTotal_in = c_stream.getTotal_in();
		Object generatedTotal_out = c_stream.getTotal_out();
		while (generatedTotal_in != len && generatedTotal_out < comprLen) {
			c_stream.setAvail_in(c_stream.setAvail_out(/* force small buffers */1));
			err = ModernizedCProgram.deflate(c_stream, 0);
			{ 
				if (err != 0) {
					.fprintf((_iob[2]), "%s error: %d\n", "deflate", err);
					.exit(1);
				} 
			}
			;
		}
		/* Finish the stream, still forcing small buffers: */for (; ; ) {
			c_stream.setAvail_out(1);
			err = ModernizedCProgram.deflate(c_stream, 4);
			if (err == 1) {
				break;
			} 
			{ 
				if (err != 0) {
					.fprintf((_iob[2]), "%s error: %d\n", "deflate", err);
					.exit(1);
				} 
			}
			;
		}
		err = ModernizedCProgram.deflateEnd(c_stream);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflateEnd", err);
				.exit(1/* ===========================================================================
				 * Test inflate() with small buffers
				 */);
			} 
		}
		;
	}
	public static void test_inflate(Object compr, Object comprLen, Object uncompr, Object uncomprLen) {
		int err;
		/* decompression stream */z_stream d_stream = new z_stream();
		.strcpy((byte)uncompr, "garbage");
		d_stream.setZalloc(ModernizedCProgram.zalloc);
		d_stream.setZfree(ModernizedCProgram.zfree);
		d_stream.setOpaque((voidpf)0);
		d_stream.setNext_in(compr);
		d_stream.setAvail_in(0);
		d_stream.setNext_out(uncompr);
		err = ModernizedCProgram.inflateInit_((d_stream), "1.2.11", (int));
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "inflateInit", err);
				.exit(1);
			} 
		}
		;
		Object generatedTotal_out = d_stream.getTotal_out();
		Object generatedTotal_in = d_stream.getTotal_in();
		while (generatedTotal_out < uncomprLen && generatedTotal_in < comprLen) {
			d_stream.setAvail_in(d_stream.setAvail_out(/* force small buffers */1));
			err = ModernizedCProgram.inflate(d_stream, 0);
			if (err == 1) {
				break;
			} 
			{ 
				if (err != 0) {
					.fprintf((_iob[2]), "%s error: %d\n", "inflate", err);
					.exit(1);
				} 
			}
			;
		}
		err = ModernizedCProgram.inflateEnd(d_stream);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "inflateEnd", err);
				.exit(1);
			} 
		}
		;
		if (.strcmp((byte)uncompr, ModernizedCProgram.hello)) {
			.fprintf((_iob[2]), "bad inflate\n");
			.exit(1);
		} else {
				.printf("inflate(): %s\n", (byte)uncompr);
		} 
	}
	/* ===========================================================================
	 * Test deflate() with large buffers and dynamic change of compression level
	 */
	public static void test_large_deflate(Object compr, Object comprLen, Object uncompr, Object uncomprLen) {
		/* compression stream */z_stream c_stream = new z_stream();
		int err;
		c_stream.setZalloc(ModernizedCProgram.zalloc);
		c_stream.setZfree(ModernizedCProgram.zfree);
		c_stream.setOpaque((voidpf)0);
		err = ModernizedCProgram.deflateInit_((c_stream), (true), "1.2.11", (int));
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflateInit", err);
				.exit(1);
			} 
		}
		;
		c_stream.setNext_out(compr);
		c_stream.setAvail_out((uInt)comprLen/* At this point, uncompr is still mostly zeroes, so it should compress
		     * very well:
		     */);
		c_stream.setNext_in(uncompr);
		c_stream.setAvail_in((uInt)uncomprLen);
		err = ModernizedCProgram.deflate(c_stream, 0);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflate", err);
				.exit(1);
			} 
		}
		;
		Object generatedAvail_in = c_stream.getAvail_in();
		if (generatedAvail_in != 0) {
			.fprintf((_iob[2]), "deflate not greedy\n");
			.exit(1);
		} 
		ModernizedCProgram.deflateParams(c_stream, 0, /* Feed in already compressed data and switch to no compression: */0);
		c_stream.setNext_in(compr);
		c_stream.setAvail_in((uInt)comprLen / 2);
		err = ModernizedCProgram.deflate(c_stream, 0);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflate", err);
				.exit(1);
			} 
		}
		;
		ModernizedCProgram.deflateParams(c_stream, 9, /* Switch back to compressing mode: */1);
		c_stream.setNext_in(uncompr);
		c_stream.setAvail_in((uInt)uncomprLen);
		err = ModernizedCProgram.deflate(c_stream, 0);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflate", err);
				.exit(1);
			} 
		}
		;
		err = ModernizedCProgram.deflate(c_stream, 4);
		if (err != 1) {
			.fprintf((_iob[2]), "deflate should report Z_STREAM_END\n");
			.exit(1);
		} 
		err = ModernizedCProgram.deflateEnd(c_stream);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflateEnd", err);
				.exit(1/* ===========================================================================
				 * Test inflate() with large buffers
				 */);
			} 
		}
		;
	}
	public static void test_large_inflate(Object compr, Object comprLen, Object uncompr, Object uncomprLen) {
		int err;
		/* decompression stream */z_stream d_stream = new z_stream();
		.strcpy((byte)uncompr, "garbage");
		d_stream.setZalloc(ModernizedCProgram.zalloc);
		d_stream.setZfree(ModernizedCProgram.zfree);
		d_stream.setOpaque((voidpf)0);
		d_stream.setNext_in(compr);
		d_stream.setAvail_in((uInt)comprLen);
		err = ModernizedCProgram.inflateInit_((d_stream), "1.2.11", (int));
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "inflateInit", err);
				.exit(1);
			} 
		}
		;
		for (; ; ) {
			d_stream.setNext_out(/* discard the output */uncompr);
			d_stream.setAvail_out((uInt)uncomprLen);
			err = ModernizedCProgram.inflate(d_stream, 0);
			if (err == 1) {
				break;
			} 
			{ 
				if (err != 0) {
					.fprintf((_iob[2]), "%s error: %d\n", "large inflate", err);
					.exit(1);
				} 
			}
			;
		}
		err = ModernizedCProgram.inflateEnd(d_stream);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "inflateEnd", err);
				.exit(1);
			} 
		}
		;
		Object generatedTotal_out = d_stream.getTotal_out();
		if (generatedTotal_out != 2 * uncomprLen + comprLen / 2) {
			.fprintf((_iob[2]), "bad large inflate: %ld\n", generatedTotal_out);
			.exit(1);
		} else {
				.printf("large_inflate(): OK\n");
		} 
	}
	/* ===========================================================================
	 * Test deflate() with full flush
	 */
	public static void test_flush(Object compr, Object comprLen) {
		/* compression stream */z_stream c_stream = new z_stream();
		int err;
		uInt len = (uInt).strlen(ModernizedCProgram.hello) + 1;
		c_stream.setZalloc(ModernizedCProgram.zalloc);
		c_stream.setZfree(ModernizedCProgram.zfree);
		c_stream.setOpaque((voidpf)0);
		err = ModernizedCProgram.deflateInit_((c_stream), ((true)), "1.2.11", (int));
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflateInit", err);
				.exit(1);
			} 
		}
		;
		c_stream.setNext_in((byte)ModernizedCProgram.hello);
		c_stream.setNext_out(compr);
		c_stream.setAvail_in(3);
		c_stream.setAvail_out((uInt)comprLen);
		err = ModernizedCProgram.deflate(c_stream, 3);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflate", err);
				.exit(1);
			} 
		}
		;
		compr[/* force an error in first compressed block */3]++;
		c_stream.setAvail_in(len - 3);
		err = ModernizedCProgram.deflate(c_stream, 4);
		if (err != 1) {
			{ 
				if (err != 0) {
					.fprintf((_iob[2]), "%s error: %d\n", "deflate", err);
					.exit(1);
				} 
			}
			;
		} 
		err = ModernizedCProgram.deflateEnd(c_stream);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflateEnd", err);
				.exit(1);
			} 
		}
		;
		Object generatedTotal_out = c_stream.getTotal_out();
		comprLen = generatedTotal_out;
	}
	public static void test_sync(Object compr, Object comprLen, Object uncompr, Object uncomprLen) {
		int err;
		/* decompression stream */z_stream d_stream = new z_stream();
		.strcpy((byte)uncompr, "garbage");
		d_stream.setZalloc(ModernizedCProgram.zalloc);
		d_stream.setZfree(ModernizedCProgram.zfree);
		d_stream.setOpaque((voidpf)0);
		d_stream.setNext_in(compr);
		d_stream.setAvail_in(/* just read the zlib header */2);
		err = ModernizedCProgram.inflateInit_((d_stream), "1.2.11", (int));
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "inflateInit", err);
				.exit(1);
			} 
		}
		;
		d_stream.setNext_out(uncompr);
		d_stream.setAvail_out((uInt)uncomprLen);
		err = ModernizedCProgram.inflate(d_stream, 0);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "inflate", err);
				.exit(1);
			} 
		}
		;
		d_stream.setAvail_in((uInt)comprLen - /* read all compressed data */2);
		err = ModernizedCProgram.inflateSync(/* but skip the damaged part */d_stream);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "inflateSync", err);
				.exit(1);
			} 
		}
		;
		err = ModernizedCProgram.inflate(d_stream, 4);
		if (err != (true)) {
			.fprintf((_iob[2]), "inflate should report DATA_ERROR\n");
			.exit(/* Because of incorrect adler32 */1);
		} 
		err = ModernizedCProgram.inflateEnd(d_stream);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "inflateEnd", err);
				.exit(1);
			} 
		}
		;
		.printf("after inflateSync(): hel%s\n", (byte)uncompr/* ===========================================================================
		 * Test deflate() with preset dictionary
		 */);
	}
	public static void test_dict_deflate(Object compr, Object comprLen) {
		/* compression stream */z_stream c_stream = new z_stream();
		int err;
		c_stream.setZalloc(ModernizedCProgram.zalloc);
		c_stream.setZfree(ModernizedCProgram.zfree);
		c_stream.setOpaque((voidpf)0);
		err = ModernizedCProgram.deflateInit_((c_stream), (true), "1.2.11", (int));
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflateInit", err);
				.exit(1);
			} 
		}
		;
		err = ModernizedCProgram.deflateSetDictionary(c_stream, (Bytef)ModernizedCProgram.dictionary, (int));
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflateSetDictionary", err);
				.exit(1);
			} 
		}
		;
		Object generatedAdler = c_stream.getAdler();
		ModernizedCProgram.dictId = generatedAdler;
		c_stream.setNext_out(compr);
		c_stream.setAvail_out((uInt)comprLen);
		c_stream.setNext_in((byte)ModernizedCProgram.hello);
		c_stream.setAvail_in((uInt).strlen(ModernizedCProgram.hello) + 1);
		err = ModernizedCProgram.deflate(c_stream, 4);
		if (err != 1) {
			.fprintf((_iob[2]), "deflate should report Z_STREAM_END\n");
			.exit(1);
		} 
		err = ModernizedCProgram.deflateEnd(c_stream);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "deflateEnd", err);
				.exit(1/* ===========================================================================
				 * Test inflate() with a preset dictionary
				 */);
			} 
		}
		;
	}
	public static void test_dict_inflate(Object compr, Object comprLen, Object uncompr, Object uncomprLen) {
		int err;
		/* decompression stream */z_stream d_stream = new z_stream();
		.strcpy((byte)uncompr, "garbage");
		d_stream.setZalloc(ModernizedCProgram.zalloc);
		d_stream.setZfree(ModernizedCProgram.zfree);
		d_stream.setOpaque((voidpf)0);
		d_stream.setNext_in(compr);
		d_stream.setAvail_in((uInt)comprLen);
		err = ModernizedCProgram.inflateInit_((d_stream), "1.2.11", (int));
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "inflateInit", err);
				.exit(1);
			} 
		}
		;
		d_stream.setNext_out(uncompr);
		d_stream.setAvail_out((uInt)uncomprLen);
		Object generatedAdler = d_stream.getAdler();
		for (; ; ) {
			err = ModernizedCProgram.inflate(d_stream, 0);
			if (err == 1) {
				break;
			} 
			if (err == 2) {
				if (generatedAdler != ModernizedCProgram.dictId) {
					.fprintf((_iob[2]), "unexpected dictionary");
					.exit(1);
				} 
				err = ModernizedCProgram.inflateSetDictionary(d_stream, (Bytef)ModernizedCProgram.dictionary, (int));
			} 
			{ 
				if (err != 0) {
					.fprintf((_iob[2]), "%s error: %d\n", "inflate with dict", err);
					.exit(1);
				} 
			}
			;
		}
		err = ModernizedCProgram.inflateEnd(d_stream);
		{ 
			if (err != 0) {
				.fprintf((_iob[2]), "%s error: %d\n", "inflateEnd", err);
				.exit(1);
			} 
		}
		;
		if (.strcmp((byte)uncompr, ModernizedCProgram.hello)) {
			.fprintf((_iob[2]), "bad inflate with dict\n");
			.exit(1);
		} else {
				.printf("inflate with dictionary: %s\n", (byte)uncompr/* ===========================================================================
				 * Usage:  example [output.gz  [input.gz]]
				 */);
		} 
	}
	public static Object module_benchmark_esalt(Object hashconfig, Object user_options, Object user_options_extra) {
		luks_t luks = (luks_t)ModernizedCProgram.hcmalloc();
		luks.setKey_size(hc_luks_key_size.HC_LUKS_KEY_SIZE_256);
		luks.setCipher_type(hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_AES);
		luks.setCipher_mode(hc_luks_cipher_mode.HC_LUKS_CIPHER_MODE_XTS_PLAIN);
		return luks;
		jwt_t jwt = (jwt_t)ModernizedCProgram.hcmalloc();
		jwt.setSignature_len(43);
		jwt.setSalt_len(32);
		return jwt;
	}
	public static Object module_kern_type_dynamic(Object hashconfig, Object digest_buf, Object salt, Object esalt_buf, Object hook_salt_buf, Object hash_info) {
		luks_t luks = (luks_t)esalt_buf;
		u64 kern_type = -1;
		if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA1) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_AES)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_SHA1_AES;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA1) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_SERPENT)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_SHA1_SERPENT;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA1) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_TWOFISH)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_SHA1_TWOFISH;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA256) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_AES)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_SHA256_AES;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA256) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_SERPENT)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_SHA256_SERPENT;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA256) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_TWOFISH)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_SHA256_TWOFISH;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA512) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_AES)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_SHA512_AES;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA512) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_SERPENT)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_SHA512_SERPENT;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_SHA512) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_TWOFISH)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_SHA512_TWOFISH;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_RIPEMD160) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_AES)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_RIPEMD160_AES;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_RIPEMD160) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_SERPENT)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_RIPEMD160_SERPENT;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_RIPEMD160) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_TWOFISH)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_RIPEMD160_TWOFISH;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_WHIRLPOOL) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_AES)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_WHIRLPOOL_AES;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_WHIRLPOOL) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_SERPENT)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_WHIRLPOOL_SERPENT;
		}  else if ((luks.getHash_type() == hc_luks_hash_type.HC_LUKS_HASH_TYPE_WHIRLPOOL) && (luks.getCipher_type() == hc_luks_cipher_type.HC_LUKS_CIPHER_TYPE_TWOFISH)) {
			kern_type = kern_type_luks.KERN_TYPE_LUKS_WHIRLPOOL_TWOFISH;
		} 
		return kern_type;
		jwt_t jwt = (jwt_t)esalt_buf;
		u64 kern_type = -1;
		// it would be more accurate to base64 decode the header_pos buffer and then to string match HS256 - same goes for the other algorithms
		if (jwt.getSignature_len() == 43) {
			kern_type = kern_type_jwt.KERN_TYPE_JWT_HS256;
		}  else if (jwt.getSignature_len() == 64) {
			kern_type = kern_type_jwt.KERN_TYPE_JWT_HS384;
		}  else if (jwt.getSignature_len() == 86) {
			kern_type = kern_type_jwt.KERN_TYPE_JWT_HS512;
		} else {
				return (parser_rc.PARSER_HASH_LENGTH);
		} 
		return kern_type;
	}
	public static int build_index(_iobuf in, Object span, access built) {
		int ret;
		/* our own total counters to avoid 4GB limit */off_t totin = new off_t();
		off_t totout = new off_t();
		/* totout value of last access point */off_t last = new off_t();
		/* access points being generated */access index = new access();
		z_stream strm = new z_stream();
		byte[] input = new byte[16384];
		byte[] window = new byte[-1024];
		strm.setZalloc(/* initialize inflate */0);
		strm.setZfree(0);
		strm.setOpaque(0);
		strm.setAvail_in(0);
		strm.setNext_in(0);
		ret = ModernizedCProgram.inflateInit2_((strm), (true), "1.2.11", (int)/* automatic zlib or gzip decoding */);
		if (ret != 0) {
			return ret/* inflate the input, maintain a sliding window, and build an index -- this
			       also validates the integrity of the compressed data using the check
			       information at the end of the gzip or zlib stream */;
		} 
		totin = totout = last = 0;
		index = ((Object)/* will be allocated by first addpoint() */0);
		strm.setAvail_out(0);
		Object generated_flag = (in).get_flag();
		Object generatedAvail_in = strm.getAvail_in();
		Object generatedAvail_out = strm.getAvail_out();
		int generatedData_type = strm.getData_type();
		do {
			strm.setAvail_in(.fread(input, 1, 16384, /* get some compressed data from input file */in));
			if ((generated_flag & -1024)) {
				ret = (true);
				;
			} 
			if (generatedAvail_in == 0) {
				ret = (true);
				;
			} 
			strm.setNext_in(input);
			do {
				if (generatedAvail_out == /* reset sliding window if necessary */0) {
					strm.setAvail_out(-1024);
					strm.setNext_out(window);
				} 
				totin += generatedAvail_in;
				totout += generatedAvail_out;
				ret = ModernizedCProgram.inflate(strm, /* return at end of block */5);
				totin -= generatedAvail_in;
				totout -= generatedAvail_out;
				if (ret == 2) {
					ret = (true);
				} 
				if (ret == (true) || ret == (true)) {
					;
				} 
				if (ret == 1) {
					break;
				} 
				if ((generatedData_type & 128) && !(generatedData_type & 64) && (totout == 0 || totout - last > span)) {
					index = index.addpoint(generatedData_type & 7, totin, totout, generatedAvail_out, window);
					if (index == ((Object)0)) {
						ret = (true);
						;
					} 
					last = totout;
				} 
			} while (generatedAvail_in != 0);
		} while (ret != 1);
		(Object)ModernizedCProgram.inflateEnd(/* clean up and return index (release unused entries in list) */strm);
		point generatedList = index.getList();
		int generatedHave = index.getHave();
		index.setList(.realloc(generatedList,  * generatedHave));
		index.setSize(generatedHave);
		built = index;
		int generatedSize = index.getSize();
		return generatedSize;
		if (index != ((Object)0)) {
			index.free_index();
		} 
		return ret/* Use the index to read len bytes from offset into buf, return bytes read or
		   negative for error (Z_DATA_ERROR or Z_MEM_ERROR).  If data is requested past
		   the end of the uncompressed data, then extract() will return a value less
		   than len, indicating how much as actually read into buf.  This function
		   should not return a data error unless the file was modified since the index
		   was generated.  extract() may also return Z_ERRNO if there is an error on
		   reading or seeking the input file. */;
	}
	public static int extract(_iobuf in, access index, Object offset, Byte buf, int len) {
		int ret;
		int skip;
		z_stream strm = new z_stream();
		point here = new point();
		byte[] input = new byte[16384];
		byte[] discard = new byte[-1024];
		if (len < /* proceed only if something reasonable to do */0) {
			return 0;
		} 
		point generatedList = index.getList();
		here = generatedList;
		int generatedHave = index.getHave();
		ret = generatedHave;
		while (--ret && here[1].getOut() <= offset) {
			here++;
		}
		strm.setZalloc(/* initialize file and inflate state to start there */0);
		strm.setZfree(0);
		strm.setOpaque(0);
		strm.setAvail_in(0);
		strm.setNext_in(0);
		ret = ModernizedCProgram.inflateInit2_((strm), (true), "1.2.11", (int)/* raw inflate */);
		if (ret != 0) {
			return ret;
		} 
		Object generatedIn = here.getIn();
		int generatedBits = here.getBits();
		ret = .fseeko(in, generatedIn - (generatedBits ? 1 : 0), 0);
		if (ret == -1) {
			;
		} 
		Object generated_flag = (in).get_flag();
		if (generatedBits) {
			ret = .getc(in);
			if (ret == -1) {
				ret = (generated_flag & -1024) ? (true) : (true);
				;
			} 
			(Object)ModernizedCProgram.inflatePrime(strm, generatedBits, ret >> (8 - generatedBits));
		} 
		Object generatedWindow = here.getWindow();
		(Object)ModernizedCProgram.inflateSetDictionary(strm, generatedWindow, -1024);
		Object generatedOut = here.getOut();
		offset -= generatedOut;
		strm.setAvail_in(0);
		skip = /* while skipping to offset */1;
		Object generatedAvail_out = strm.getAvail_out();
		Object generatedAvail_in = strm.getAvail_in();
		do {
			if (offset == 0 && /* define where to put uncompressed data, and how much *//* at offset now */skip) {
				strm.setAvail_out(len);
				strm.setNext_out(buf);
				skip = /* only do this once */0;
			} 
			if (offset > /* skip WINSIZE bytes */-1024) {
				strm.setAvail_out(-1024);
				strm.setNext_out(discard);
				offset -= -1024;
			}  else if (offset != /* last skip */0) {
				strm.setAvail_out((int)offset);
				strm.setNext_out(discard);
				offset = 0;
			} 
			do {
				if (generatedAvail_in == 0) {
					strm.setAvail_in(.fread(input, 1, 16384, in));
					if ((generated_flag & -1024)) {
						ret = (true);
						;
					} 
					if (generatedAvail_in == 0) {
						ret = (true);
						;
					} 
					strm.setNext_in(input);
				} 
				ret = ModernizedCProgram.inflate(strm, /* normal inflate */0);
				if (ret == 2) {
					ret = (true);
				} 
				if (ret == (true) || ret == (true)) {
					;
				} 
				if (ret == 1) {
					break;
				} 
			} while (generatedAvail_out != 0);
			if (ret == /* if reach end of stream, then don't keep trying to get more */1) {
				break;
			} 
		} while (/* do until offset reached and requested data read, or stream ends */skip);
		ret = skip ? 0 : len - generatedAvail_out;
		return ret/* Demonstrate the use of build_index() and extract() by processing the file
		   provided on the command line, and the extracting 16K from about 2/3rds of
		   the way through the uncompressed output, and writing that to stdout. */;
	}
	public static void transform_netntlmv1_key(Object nthash, Object key) {
		key[0] = (nthash[0] >> 0);
		key[1] = (nthash[0] << 7) | (nthash[1] >> 1);
		key[2] = (nthash[1] << 6) | (nthash[2] >> 2);
		key[3] = (nthash[2] << 5) | (nthash[3] >> 3);
		key[4] = (nthash[3] << 4) | (nthash[4] >> 4);
		key[5] = (nthash[4] << 3) | (nthash[5] >> 5);
		key[6] = (nthash[5] << 2) | (nthash[6] >> 6);
		key[7] = (nthash[6] << 1);
		key[0] |=  -1024;
		key[1] |=  -1024;
		key[2] |=  -1024;
		key[3] |=  -1024;
		key[4] |=  -1024;
		key[5] |=  -1024;
		key[6] |=  -1024;
		key[7] |=  -1024;
	}
	/* Alloc.c -- Memory allocation functions
	2018-04-27 : Igor Pavlov : Public domain */
	/* #define _SZ_ALLOC_DEBUG */
	/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
	public static Object MyAlloc(Object size) {
		if (size == 0) {
			return ((Object)0);
		} 
		return .malloc(size);
	}
	public static void MyFree(Object address) {
		;
		.free(address);
	}
	public static Object MidAlloc(Object size) {
		if (size == 0) {
			return ((Object)0);
		} 
		;
		return .VirtualAlloc(((Object)0), size, -1024, -1024);
	}
	public static void MidFree(Object address) {
		;
		if (!address) {
			return ;
		} 
		.VirtualFree(address, 0, -1024);
	}
	public static void SetLargePageSize() {
	}
	public static Object BigAlloc(Object size) {
		if (size == 0) {
			return ((Object)0);
		} 
		;
		return .VirtualAlloc(((Object)0), size, -1024, -1024);
	}
	public static void BigFree(Object address) {
		;
		if (!address) {
			return ;
		} 
		.VirtualFree(address, 0, -1024);
	}
	public static Object SzMidAlloc(Object p, Object size) {
		(Object)p;
		;
		return ModernizedCProgram.MidAlloc(size);
	}
	public static void SzMidFree(Object p, Object address) {
		(Object)p;
		;
		ModernizedCProgram.MidFree(address);
	}
	public static Object SzBigAlloc(Object p, Object size) {
		(Object)p;
		;
		return ModernizedCProgram.BigAlloc(size);
	}
	public static void SzBigFree(Object p, Object address) {
		(Object)p;
		;
		ModernizedCProgram.BigFree(address);
	}
	/*
	  This posix_memalign() is for test purposes only.
	  We also need special Free() function instead of free(),
	  if this posix_memalign() is used.
	*/
	/*
	static int posix_memalign(void **ptr, size_t align, size_t size)
	{
	  size_t newSize = size + align;
	  void *p;
	  void *pAligned;
	  *ptr = NULL;
	  if (newSize < size)
	    return 12; // ENOMEM
	  p = MyAlloc(newSize);
	  if (!p)
	    return 12; // ENOMEM
	  pAligned = MY_ALIGN_PTR_UP_PLUS(p, align);
	  ((void **)pAligned)[-1] = p;
	  *ptr = pAligned;
	  return 0;
	}
	*/
	/*
	  ALLOC_ALIGN_SIZE >= sizeof(void *)
	  ALLOC_ALIGN_SIZE >= cache_line_size
	*/
	public static Object SzAlignedAlloc(Object pp, Object size) {
		Object p;
		Object pAligned;
		size_t newSize = new size_t();
		(Object)pp/* also we can allocate additional dummy ALLOC_ALIGN_SIZE bytes after aligned
		     block to prevent cache line sharing with another allocated blocks */;
		;
		newSize = size + ((size_t)1 << 7) * 1 + 0;
		if (newSize < size) {
			return ((Object)0);
		} 
		p = ModernizedCProgram.MyAlloc(newSize);
		if (!p) {
			return ((Object)0);
		} 
		pAligned = ((Object)((((UIntPtr)(((byte)(p) + (((size_t)1 << 7)) + 0))) & ~((UIntPtr)(((size_t)1 << 7)) - 1))));
		;
		;
		;
		;
		;
		;
		;
		;
		;
		((Object)pAligned)[-1] = p;
		return pAligned;
	}
	public static void SzAlignedFree(Object pp, Object address) {
		(Object)pp;
		;
		if (address) {
			ModernizedCProgram.MyFree(((Object)address)[-1]);
		} 
	}
	/*
	#define REAL_BLOCK_PTR_VAR(p) ((void **)(p))[-1]
	*/
	public static Object AlignOffsetAlloc_Alloc(Object pp, Object size) {
		CAlignOffsetAlloc p = ((CAlignOffsetAlloc)((byte)(true ? (pp) : ((CAlignOffsetAlloc)0).getVt()) - ((size_t)((CAlignOffsetAlloc)0).getVt())));
		Object adr;
		Object pAligned;
		size_t newSize = new size_t();
		size_t extra = new size_t();
		Object generatedNumAlignBits = p.getNumAlignBits();
		size_t alignSize = (size_t)1 << generatedNumAlignBits;
		if (alignSize < ) {
			alignSize = ;
		} 
		Object generatedOffset = p.getOffset();
		if (generatedOffset >= alignSize) {
			return ((Object)0);
		} 
		extra = generatedOffset & ( - /* also we can allocate additional dummy ALLOC_ALIGN_SIZE bytes after aligned
		     block to prevent cache line sharing with another allocated blocks */1);
		newSize = size + alignSize + extra + 0;
		if (newSize < size) {
			return ((Object)0);
		} 
		Object generatedBaseAlloc = p.getBaseAlloc();
		adr = .UNRECOGNIZEDFUNCTIONNAME(generatedBaseAlloc, newSize);
		if (!adr) {
			return ((Object)0);
		} 
		pAligned = (byte)((Object)((((UIntPtr)((byte)adr + alignSize - generatedOffset + extra + 0)) & ~((UIntPtr)(alignSize) - 1)))) + generatedOffset;
		;
		;
		;
		;
		;
		;
		;
		;
		;
		;
		;
		((Object)((Object)((((UIntPtr)(pAligned)) & ~((UIntPtr)() - 1)))))[-1] = adr;
		return pAligned;
	}
	public static void AlignOffsetAlloc_Free(Object pp, Object address) {
		Object generatedBaseAlloc = p.getBaseAlloc();
		if (address) {
			CAlignOffsetAlloc p = ((CAlignOffsetAlloc)((byte)(true ? (pp) : ((CAlignOffsetAlloc)0).getVt()) - ((size_t)((CAlignOffsetAlloc)0).getVt())));
			;
			;
			;
			.UNRECOGNIZEDFUNCTIONNAME(generatedBaseAlloc, ((Object)((Object)((((UIntPtr)(address)) & ~((UIntPtr)() - 1)))))[-1]);
		} 
	}
	public static void AlignOffsetAlloc_CreateVTable() {
		Object generatedVt = this.getVt();
		generatedVt.setAlloc(AlignOffsetAlloc_Alloc);
		generatedVt.setFree(AlignOffsetAlloc_Free);
	}
	public static void win32_translate_open_mode(int mode, Object lpdwDesiredAccess, Object lpdwCreationDisposition, Object lpdwShareMode, Object lpdwFlagsAndAttributes) {
		lpdwDesiredAccess = lpdwShareMode = lpdwFlagsAndAttributes = lpdwCreationDisposition = 0;
		if ((mode & (true)) == (true)) {
			lpdwDesiredAccess = -1024;
			lpdwCreationDisposition = 3;
			lpdwShareMode = -1024;
		}  else if (mode & (true)) {
			lpdwDesiredAccess = -1024 | -1024;
			lpdwCreationDisposition = 3;
		}  else if (mode & (true)) {
			lpdwDesiredAccess = -1024 | -1024;
			lpdwCreationDisposition = 2;
		} 
	}
	public static Object win32_build_iowin(Object hFile) {
		voidpf ret = ((Object)0);
		if ((hFile != ((Object)0)) && (hFile != (HANDLE)(true))) {
			WIN32FILE_IOWIN w32fiow = new WIN32FILE_IOWIN();
			w32fiow.setHf(hFile);
			w32fiow.setError(0);
			ret = .malloc();
			if (ret == ((Object)0)) {
				.CloseHandle(hFile);
			} else {
					((WIN32FILE_IOWIN)ret) = w32fiow;
			} 
		} 
		return ret;
	}
	public static Object win32_open64_file_func(Object opaque, Object filename, int mode) {
		byte mode_fopen = ((Object)0);
		DWORD dwDesiredAccess = new DWORD();
		DWORD dwCreationDisposition = new DWORD();
		DWORD dwShareMode = new DWORD();
		DWORD dwFlagsAndAttributes = new DWORD();
		HANDLE hFile = ((Object)0);
		ModernizedCProgram.win32_translate_open_mode(mode, dwDesiredAccess, dwCreationDisposition, dwShareMode, dwFlagsAndAttributes);
		if ((filename != ((Object)0)) && (dwDesiredAccess != 0)) {
			hFile = .CreateFileA((LPCTSTR)filename, dwDesiredAccess, dwShareMode, ((Object)0), dwCreationDisposition, dwFlagsAndAttributes, ((Object)0));
		} 
		return ModernizedCProgram.win32_build_iowin(hFile);
	}
	public static Object win32_open64_file_funcA(Object opaque, Object filename, int mode) {
		byte mode_fopen = ((Object)0);
		DWORD dwDesiredAccess = new DWORD();
		DWORD dwCreationDisposition = new DWORD();
		DWORD dwShareMode = new DWORD();
		DWORD dwFlagsAndAttributes = new DWORD();
		HANDLE hFile = ((Object)0);
		ModernizedCProgram.win32_translate_open_mode(mode, dwDesiredAccess, dwCreationDisposition, dwShareMode, dwFlagsAndAttributes);
		if ((filename != ((Object)0)) && (dwDesiredAccess != 0)) {
			hFile = .CreateFileA((LPCSTR)filename, dwDesiredAccess, dwShareMode, ((Object)0), dwCreationDisposition, dwFlagsAndAttributes, ((Object)0));
		} 
		return ModernizedCProgram.win32_build_iowin(hFile);
	}
	public static Object win32_open64_file_funcW(Object opaque, Object filename, int mode) {
		byte mode_fopen = ((Object)0);
		DWORD dwDesiredAccess = new DWORD();
		DWORD dwCreationDisposition = new DWORD();
		DWORD dwShareMode = new DWORD();
		DWORD dwFlagsAndAttributes = new DWORD();
		HANDLE hFile = ((Object)0);
		ModernizedCProgram.win32_translate_open_mode(mode, dwDesiredAccess, dwCreationDisposition, dwShareMode, dwFlagsAndAttributes);
		if ((filename != ((Object)0)) && (dwDesiredAccess != 0)) {
			hFile = .CreateFileW((LPCWSTR)filename, dwDesiredAccess, dwShareMode, ((Object)0), dwCreationDisposition, dwFlagsAndAttributes, ((Object)0));
		} 
		return ModernizedCProgram.win32_build_iowin(hFile);
	}
	/* iowin32.c -- IO base function header for compress/uncompress .zip
	     Version 1.1, February 14h, 2010
	     part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
	
	         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
	
	         Modifications for Zip64 support
	         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
	
	     For more info read MiniZip_info.txt
	
	*/
	// see Include/shared/winapifamily.h in the Windows Kit
	public static Object win32_open_file_func(Object opaque, Object filename, int mode) {
		byte mode_fopen = ((Object)0);
		DWORD dwDesiredAccess = new DWORD();
		DWORD dwCreationDisposition = new DWORD();
		DWORD dwShareMode = new DWORD();
		DWORD dwFlagsAndAttributes = new DWORD();
		HANDLE hFile = ((Object)0);
		ModernizedCProgram.win32_translate_open_mode(mode, dwDesiredAccess, dwCreationDisposition, dwShareMode, dwFlagsAndAttributes);
		if ((filename != ((Object)0)) && (dwDesiredAccess != 0)) {
			hFile = .CreateFileA((LPCTSTR)filename, dwDesiredAccess, dwShareMode, ((Object)0), dwCreationDisposition, dwFlagsAndAttributes, ((Object)0));
		} 
		return ModernizedCProgram.win32_build_iowin(hFile);
	}
	public static Object win32_read_file_func(Object opaque, Object stream, Object buf, Object size) {
		uLong ret = 0;
		HANDLE hFile = ((Object)0);
		if (stream != ((Object)0)) {
			hFile = ((WIN32FILE_IOWIN)stream).getHf();
		} 
		if (hFile != ((Object)0)) {
			if (!.ReadFile(hFile, buf, size, ret, ((Object)0))) {
				DWORD dwErr = .GetLastError();
				if (dwErr == -1024) {
					dwErr = 0;
				} 
				((WIN32FILE_IOWIN)stream).setError((int)dwErr);
			} 
		} 
		return ret;
	}
	public static Object win32_write_file_func(Object opaque, Object stream, Object buf, Object size) {
		uLong ret = 0;
		HANDLE hFile = ((Object)0);
		if (stream != ((Object)0)) {
			hFile = ((WIN32FILE_IOWIN)stream).getHf();
		} 
		if (hFile != ((Object)0)) {
			if (!.WriteFile(hFile, buf, size, ret, ((Object)0))) {
				DWORD dwErr = .GetLastError();
				if (dwErr == -1024) {
					dwErr = 0;
				} 
				((WIN32FILE_IOWIN)stream).setError((int)dwErr);
			} 
		} 
		return ret;
	}
	public static Object MySetFilePointerEx(Object hFile, _LARGE_INTEGER newPos, Object dwMoveMethod) {
		Object generatedHighPart = this.getHighPart();
		LONG lHigh = generatedHighPart;
		Object generatedLowPart = this.getLowPart();
		DWORD dwNewPos = .SetFilePointer(hFile, generatedLowPart, lHigh, dwMoveMethod);
		BOOL fOk = 1;
		if (dwNewPos == -1024) {
			if (.GetLastError() != -1024) {
				fOk = 0;
			} 
		} 
		if ((newPos != ((Object)0)) && (fOk)) {
			newPos.setLowPart(dwNewPos);
			newPos.setHighPart(lHigh);
		} 
		return fOk;
	}
	public static long win32_tell_file_func(Object opaque, Object stream) {
		long ret = -1;
		HANDLE hFile = ((Object)0);
		if (stream != ((Object)0)) {
			hFile = ((WIN32FILE_IOWIN)stream).getHf();
		} 
		Object generatedLowPart = pos.getLowPart();
		if (hFile != ((Object)0)) {
			LARGE_INTEGER pos = new LARGE_INTEGER();
			pos.setQuadPart(0);
			if (!pos.MySetFilePointerEx(hFile, pos, 1)) {
				DWORD dwErr = .GetLastError();
				((WIN32FILE_IOWIN)stream).setError((int)dwErr);
				ret = -1;
			} else {
					ret = (long)generatedLowPart;
			} 
		} 
		return ret;
	}
	public static Object win32_tell64_file_func(Object opaque, Object stream) {
		ZPOS64_T ret = (ZPOS64_T)-1;
		HANDLE hFile = ((Object)0);
		if (stream != ((Object)0)) {
			hFile = ((WIN32FILE_IOWIN)stream).getHf();
		} 
		Object generatedQuadPart = pos.getQuadPart();
		if (hFile) {
			LARGE_INTEGER pos = new LARGE_INTEGER();
			pos.setQuadPart(0);
			if (!pos.MySetFilePointerEx(hFile, pos, 1)) {
				DWORD dwErr = .GetLastError();
				((WIN32FILE_IOWIN)stream).setError((int)dwErr);
				ret = (ZPOS64_T)-1;
			} else {
					ret = generatedQuadPart;
			} 
		} 
		return ret;
	}
	public static long win32_seek_file_func(Object opaque, Object stream, Object offset, int origin) {
		DWORD dwMoveMethod = -1024;
		HANDLE hFile = ((Object)0);
		long ret = -1;
		if (stream != ((Object)0)) {
			hFile = ((WIN32FILE_IOWIN)stream).getHf();
		} 
		switch (origin) {
		case (true):
				dwMoveMethod = 1;
				break;
		case (false):
				dwMoveMethod = 0;
				break;
		case (true):
				dwMoveMethod = 2;
				break;
		default:
				return -1;
		}
		if (hFile != ((Object)0)) {
			LARGE_INTEGER pos = new LARGE_INTEGER();
			pos.setQuadPart(offset);
			if (!pos.MySetFilePointerEx(hFile, ((Object)0), dwMoveMethod)) {
				DWORD dwErr = .GetLastError();
				((WIN32FILE_IOWIN)stream).setError((int)dwErr);
				ret = -1;
			} else {
					ret = 0;
			} 
		} 
		return ret;
	}
	public static long win32_seek64_file_func(Object opaque, Object stream, Object offset, int origin) {
		DWORD dwMoveMethod = -1024;
		HANDLE hFile = ((Object)0);
		long ret = -1;
		if (stream != ((Object)0)) {
			hFile = ((WIN32FILE_IOWIN)stream).getHf();
		} 
		switch (origin) {
		case (true):
				dwMoveMethod = 2;
				break;
		case (false):
				dwMoveMethod = 0;
				break;
		case (true):
				dwMoveMethod = 1;
				break;
		default:
				return -1;
		}
		if (hFile) {
			LARGE_INTEGER pos = new LARGE_INTEGER();
			pos.setQuadPart(offset);
			if (!pos.MySetFilePointerEx(hFile, ((Object)0), dwMoveMethod)) {
				DWORD dwErr = .GetLastError();
				((WIN32FILE_IOWIN)stream).setError((int)dwErr);
				ret = -1;
			} else {
					ret = 0;
			} 
		} 
		return ret;
	}
	public static int win32_close_file_func(Object opaque, Object stream) {
		int ret = -1;
		if (stream != ((Object)0)) {
			HANDLE hFile = new HANDLE();
			hFile = ((WIN32FILE_IOWIN)stream).getHf();
			if (hFile != ((Object)0)) {
				.CloseHandle(hFile);
				ret = 0;
			} 
			.free(stream);
		} 
		return ret;
	}
	public static int win32_error_file_func(Object opaque, Object stream) {
		int ret = -1;
		if (stream != ((Object)0)) {
			ret = ((WIN32FILE_IOWIN)stream).getError();
		} 
		return ret;
	}
	public static void GetHeads2(Object p, Object pos, Object hash, Object hashMask, Object heads, Object numHeads, Object crc) {
		(Object)hashMask;
		;
		(Object)crc;
		;
		;
		for (; numHeads != 0; numHeads--) {
			UInt32 value = ((p[0] | ((UInt32)p[1] << 8)));
			p++;
			heads++ = pos - hash[value];
			hash[value] = pos++;
		}
	}
	public static void GetHeads3(Object p, Object pos, Object hash, Object hashMask, Object heads, Object numHeads, Object crc) {
		;
		;
		for (; numHeads != 0; numHeads--) {
			UInt32 value = ((crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8)) & hashMask);
			p++;
			heads++ = pos - hash[value];
			hash[value] = pos++;
		}
	}
	public static void GetHeads4(Object p, Object pos, Object hash, Object hashMask, Object heads, Object numHeads, Object crc) {
		;
		;
		for (; numHeads != 0; numHeads--) {
			UInt32 value = ((crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8) ^ (crc[p[3]] << 5)) & hashMask);
			p++;
			heads++ = pos - hash[value];
			hash[value] = pos++;
		}
	}
	public static void GetHeads4b(Object p, Object pos, Object hash, Object hashMask, Object heads, Object numHeads, Object crc) {
		;
		;
		for (; numHeads != 0; numHeads--) {
			UInt32 value = ((crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8) ^ ((UInt32)p[3] << 16)) & hashMask);
			p++;
			heads++ = pos - hash[value];
			hash[value] = pos/* DEF_GetHeads(5,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8) ^ (crc[p[3]] << 5) ^ (crc[p[4]] << 3)) & hashMask) */++;
		}
	}
	/*
	  we use size_t for _cyclicBufferPos instead of UInt32
	  to eliminate "movsx" BUG in old MSVC x64 compiler.
	*/
	public static Object GetMatchesSpecN(Object lenLimit, Object pos, Object cur, Object son, Object _cyclicBufferPos, Object _cyclicBufferSize, Object _cutValue, Object distances, Object _maxLen, Object hash, Object limit, Object size, Object posRes) {
		do {
			UInt32 _distances = ++distances;
			UInt32 delta = hash++;
			CLzRef ptr0 = son + ((size_t)_cyclicBufferPos << 1) + 1;
			CLzRef ptr1 = son + ((size_t)_cyclicBufferPos << 1);
			int len0 = 0;
			int len1 = 0;
			UInt32 cutValue = _cutValue;
			int maxLen = (int)_maxLen/*
			  if (size > 1)
			  {
			    UInt32 delta = *hash;
			    if (delta < _cyclicBufferSize)
			    {
			      UInt32 cyc1 = _cyclicBufferPos + 1;
			      CLzRef *pair = son + ((size_t)(cyc1 - delta + ((delta > cyc1) ? _cyclicBufferSize : 0)) << 1);
			      Byte b = *(cur + 1 - delta);
			      _distances[0] = pair[0];
			      _distances[1] = b;
			    }
			  }
			  */;
			if (cutValue == 0 || delta >= _cyclicBufferSize) {
				ptr0 = ptr1 = 0;
			} else {
					for (; ; ) {
						{ 
							CLzRef pair = son + ((size_t)(_cyclicBufferPos - delta + ((_cyclicBufferPos < delta) ? _cyclicBufferSize : 0)) << 1);
							Byte pb = cur - delta;
							int len = (len0 < len1 ? len0 : len1);
							UInt32 pair0 = pair;
							if (pb[len] == cur[len]) {
								if (++len != lenLimit && pb[len] == cur[len]) {
									while (++len != lenLimit) {
										if (pb[len] != cur[len]) {
											break;
										} 
									}
								} 
								if (maxLen < len) {
									maxLen = len;
									distances++ = (UInt32)len;
									distances++ = delta - 1;
									if (len == lenLimit) {
										UInt32 pair1 = pair[1];
										ptr1 = pair0;
										ptr0 = pair1;
										break;
									} 
								} 
							} 
							{ 
								UInt32 curMatch = pos - delta;
								if (pb[len] < cur[len]) {
									delta = pos - pair[1];
									ptr1 = curMatch;
									ptr1 = pair + 1;
									len1 = len;
								} else {
										delta = pos - pair;
										ptr0 = curMatch;
										ptr0 = pair;
										len0 = len;
								} 
							}
						}
						if (--cutValue == 0 || delta >= _cyclicBufferSize) {
							ptr0 = ptr1 = 0;
							break;
						} 
					}
			} 
			pos++;
			_cyclicBufferPos++;
			cur++;
			{ 
				UInt32 num = (UInt32)(distances - _distances);
				_distances[-1] = ModernizedCProgram.num;
			}
		} while (distances < limit && --size != 0);
		posRes = pos;
		return distances;
	}
	public static Object HashThreadFunc2(Object p) {
		(CMatchFinderMt)p.HashThreadFunc();
		return 0;
	}
	public static Object BtThreadFunc2(Object p) {
		Byte[] allocaDummy = new Byte();
		int i = 0;
		for (i = 0; i < 16; i++) {
			allocaDummy[i] = (Byte)0;
		}
		if (allocaDummy[0] == 0) {
			(CMatchFinderMt)p.BtThreadFunc();
		} 
		return 0;
	}
	public static void MatchFinderMt_CreateVTable(_CMatchFinderMt p, _IMatchFinder vTable) {
		vTable.setInit((Mf_Init_Func)MatchFinderMt_Init);
		vTable.setGetNumAvailableBytes((Mf_GetNumAvailableBytes_Func)MatchFinderMt_GetNumAvailableBytes);
		vTable.setGetPointerToCurrentPos((Mf_GetPointerToCurrentPos_Func)MatchFinderMt_GetPointerToCurrentPos);
		vTable.setGetMatches((Mf_GetMatches_Func)MatchFinderMt_GetMatches);
		_CMatchFinder generatedMatchFinder = p.getMatchFinder();
		Object generatedBigHash = generatedMatchFinder.getBigHash();
		Object generatedNumHashBytes = generatedMatchFinder.getNumHashBytes();
		switch (generatedNumHashBytes) {
		case 2:
				p.setGetHeadsFunc(GetHeads2);
				p.setMixMatchesFunc((Mf_Mix_Matches)((Object)0));
				vTable.setSkip((Mf_Skip_Func)MatchFinderMt0_Skip);
				vTable.setGetMatches((Mf_GetMatches_Func)MatchFinderMt2_GetMatches);
				break;
		case 3:
				p.setGetHeadsFunc(GetHeads3);
				p.setMixMatchesFunc((Mf_Mix_Matches)MixMatches2);
				vTable.setSkip((Mf_Skip_Func)MatchFinderMt2_Skip);
				break;
		default:
				p.setGetHeadsFunc(generatedBigHash ? GetHeads4b : /* case 4: */GetHeads4);
				p.setMixMatchesFunc((Mf_Mix_Matches)MixMatches3);
				vTable.setSkip((Mf_Skip_Func)MatchFinderMt3_Skip);
				break;
		}
	}
	public static void sha512crypt_decode(Object digest, Object buf) {
		int l;
		l = ModernizedCProgram.itoa64_to_int(buf[0]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[1]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[2]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[3]) << 18;
		digest[0] = (l >> 16) & -1024;
		digest[21] = (l >> 8) & -1024;
		digest[42] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[4]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[5]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[6]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[7]) << 18;
		digest[22] = (l >> 16) & -1024;
		digest[43] = (l >> 8) & -1024;
		digest[1] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[8]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[9]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[10]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[11]) << 18;
		digest[44] = (l >> 16) & -1024;
		digest[2] = (l >> 8) & -1024;
		digest[23] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[12]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[13]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[14]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[15]) << 18;
		digest[3] = (l >> 16) & -1024;
		digest[24] = (l >> 8) & -1024;
		digest[45] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[16]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[17]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[18]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[19]) << 18;
		digest[25] = (l >> 16) & -1024;
		digest[46] = (l >> 8) & -1024;
		digest[4] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[20]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[21]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[22]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[23]) << 18;
		digest[47] = (l >> 16) & -1024;
		digest[5] = (l >> 8) & -1024;
		digest[26] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[24]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[25]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[26]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[27]) << 18;
		digest[6] = (l >> 16) & -1024;
		digest[27] = (l >> 8) & -1024;
		digest[48] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[28]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[29]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[30]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[31]) << 18;
		digest[28] = (l >> 16) & -1024;
		digest[49] = (l >> 8) & -1024;
		digest[7] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[32]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[33]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[34]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[35]) << 18;
		digest[50] = (l >> 16) & -1024;
		digest[8] = (l >> 8) & -1024;
		digest[29] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[36]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[37]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[38]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[39]) << 18;
		digest[9] = (l >> 16) & -1024;
		digest[30] = (l >> 8) & -1024;
		digest[51] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[40]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[41]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[42]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[43]) << 18;
		digest[31] = (l >> 16) & -1024;
		digest[52] = (l >> 8) & -1024;
		digest[10] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[44]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[45]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[46]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[47]) << 18;
		digest[53] = (l >> 16) & -1024;
		digest[11] = (l >> 8) & -1024;
		digest[32] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[48]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[49]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[50]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[51]) << 18;
		digest[12] = (l >> 16) & -1024;
		digest[33] = (l >> 8) & -1024;
		digest[54] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[52]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[53]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[54]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[55]) << 18;
		digest[34] = (l >> 16) & -1024;
		digest[55] = (l >> 8) & -1024;
		digest[13] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[56]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[57]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[58]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[59]) << 18;
		digest[56] = (l >> 16) & -1024;
		digest[14] = (l >> 8) & -1024;
		digest[35] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[60]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[61]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[62]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[63]) << 18;
		digest[15] = (l >> 16) & -1024;
		digest[36] = (l >> 8) & -1024;
		digest[57] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[64]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[65]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[66]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[67]) << 18;
		digest[37] = (l >> 16) & -1024;
		digest[58] = (l >> 8) & -1024;
		digest[16] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[68]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[69]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[70]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[71]) << 18;
		digest[59] = (l >> 16) & -1024;
		digest[17] = (l >> 8) & -1024;
		digest[38] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[72]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[73]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[74]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[75]) << 18;
		digest[18] = (l >> 16) & -1024;
		digest[39] = (l >> 8) & -1024;
		digest[60] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[76]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[77]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[78]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[79]) << 18;
		digest[40] = (l >> 16) & -1024;
		digest[61] = (l >> 8) & -1024;
		digest[19] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[80]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[81]) << 6;
		l |=  ModernizedCProgram.itoa64_to_int(buf[82]) << 12;
		l |=  ModernizedCProgram.itoa64_to_int(buf[83]) << 18;
		digest[62] = (l >> 16) & -1024;
		digest[20] = (l >> 8) & -1024;
		digest[41] = (l >> 0) & -1024;
		l = ModernizedCProgram.itoa64_to_int(buf[84]) << 0;
		l |=  ModernizedCProgram.itoa64_to_int(buf[85]) << 6;
		digest[63] = (l >> 0) & -1024;
	}
	public static void sha512crypt_encode(Object digest, Object buf) {
		int l;
		l = (digest[0] << 16) | (digest[21] << 8) | (digest[42] << 0);
		buf[0] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[1] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[2] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[3] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[22] << 16) | (digest[43] << 8) | (digest[1] << 0);
		buf[4] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[5] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[6] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[7] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[44] << 16) | (digest[2] << 8) | (digest[23] << 0);
		buf[8] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[9] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[10] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[11] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[3] << 16) | (digest[24] << 8) | (digest[45] << 0);
		buf[12] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[13] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[14] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[15] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[25] << 16) | (digest[46] << 8) | (digest[4] << 0);
		buf[16] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[17] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[18] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[19] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[47] << 16) | (digest[5] << 8) | (digest[26] << 0);
		buf[20] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[21] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[22] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[23] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[6] << 16) | (digest[27] << 8) | (digest[48] << 0);
		buf[24] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[25] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[26] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[27] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[28] << 16) | (digest[49] << 8) | (digest[7] << 0);
		buf[28] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[29] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[30] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[31] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[50] << 16) | (digest[8] << 8) | (digest[29] << 0);
		buf[32] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[33] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[34] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[35] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[9] << 16) | (digest[30] << 8) | (digest[51] << 0);
		buf[36] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[37] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[38] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[39] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[31] << 16) | (digest[52] << 8) | (digest[10] << 0);
		buf[40] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[41] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[42] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[43] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[53] << 16) | (digest[11] << 8) | (digest[32] << 0);
		buf[44] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[45] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[46] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[47] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[12] << 16) | (digest[33] << 8) | (digest[54] << 0);
		buf[48] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[49] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[50] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[51] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[34] << 16) | (digest[55] << 8) | (digest[13] << 0);
		buf[52] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[53] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[54] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[55] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[56] << 16) | (digest[14] << 8) | (digest[35] << 0);
		buf[56] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[57] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[58] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[59] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[15] << 16) | (digest[36] << 8) | (digest[57] << 0);
		buf[60] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[61] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[62] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[63] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[37] << 16) | (digest[58] << 8) | (digest[16] << 0);
		buf[64] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[65] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[66] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[67] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[59] << 16) | (digest[17] << 8) | (digest[38] << 0);
		buf[68] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[69] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[70] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[71] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[18] << 16) | (digest[39] << 8) | (digest[60] << 0);
		buf[72] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[73] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[74] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[75] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[40] << 16) | (digest[61] << 8) | (digest[19] << 0);
		buf[76] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[77] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[78] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[79] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[62] << 16) | (digest[20] << 8) | (digest[41] << 0);
		buf[80] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[81] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		buf[82] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[83] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l = (digest[63] << 0);
		buf[84] = ModernizedCProgram.int_to_itoa64(l & -1024);
		l >>=  6;
		//l >>= 6;//l >>= 6;buf[85] = ModernizedCProgram.int_to_itoa64(l & -1024);
	}
	public static void md5_complete_no_limit(Object digest, Object plain, Object plain_len) {
		// plain = u32 tmp_md5_buf[64] so this is compatiblemd5_ctx_t md5_ctx = new md5_ctx_t();
		.md5_init(md5_ctx);
		.md5_update(md5_ctx, plain, plain_len);
		.md5_final(md5_ctx);
		Object generatedH = md5_ctx.getH();
		digest[0] = generatedH[0];
		digest[1] = generatedH[1];
		digest[2] = generatedH[2];
		digest[3] = generatedH[3];
		// plain = u32 tmp_md5_buf[64] so this is compatiblemd5_ctx_t md5_ctx = new md5_ctx_t();
		.md5_init(md5_ctx);
		.md5_update(md5_ctx, plain, plain_len);
		.md5_final(md5_ctx);
		Object generatedH = md5_ctx.getH();
		digest[0] = generatedH[0];
		digest[1] = generatedH[1];
		digest[2] = generatedH[2];
		digest[3] = generatedH[3];
		// plain = u32 tmp_md5_buf[64] so this is compatiblemd5_ctx_t md5_ctx = new md5_ctx_t();
		.md5_init(md5_ctx);
		.md5_update(md5_ctx, plain, plain_len);
		.md5_final(md5_ctx);
		Object generatedH = md5_ctx.getH();
		digest[0] = generatedH[0];
		digest[1] = generatedH[1];
		digest[2] = generatedH[2];
		digest[3] = generatedH[3];
		// plain = u32 tmp_md5_buf[64] so this is compatiblemd5_ctx_t md5_ctx = new md5_ctx_t();
		.md5_init(md5_ctx);
		.md5_update(md5_ctx, plain, plain_len);
		.md5_final(md5_ctx);
		Object generatedH = md5_ctx.getH();
		digest[0] = generatedH[0];
		digest[1] = generatedH[1];
		digest[2] = generatedH[2];
		digest[3] = generatedH[3];
	}
	public static void precompute_salt_md5(Object salt_buf, Object salt_len, Object salt_pc) {
		u32[] digest = new u32[]{0};
		ModernizedCProgram.md5_complete_no_limit(digest, salt_buf, salt_len);
		ModernizedCProgram.u32_to_hex(digest[0], salt_pc + 0);
		ModernizedCProgram.u32_to_hex(digest[1], salt_pc + 8);
		ModernizedCProgram.u32_to_hex(digest[2], salt_pc + 16);
		ModernizedCProgram.u32_to_hex(digest[3], salt_pc + 24);
		u32[] digest = new u32[]{0};
		ModernizedCProgram.md5_complete_no_limit(digest, salt_buf, salt_len);
		ModernizedCProgram.u32_to_hex(digest[0], salt_pc + 0);
		ModernizedCProgram.u32_to_hex(digest[1], salt_pc + 8);
		ModernizedCProgram.u32_to_hex(digest[2], salt_pc + 16);
		ModernizedCProgram.u32_to_hex(digest[3], salt_pc + 24);
	}
	/* Sort.c -- Sort functions
	2014-04-05 : Igor Pavlov : Public domain */
	public static void HeapSort(Object p, Object size) {
		if (size <= 1) {
			return ;
		} 
		p--;
		{ 
			size_t i = size / 2;
			do {
				UInt32 temp = p[i];
				size_t k = i;
				{ 
					for (; ; ) {
						size_t s = (k << 1);
						if (s > size) {
							break;
						} 
						if (s < size && p[s + 1] > p[s]) {
							s++;
						} 
						if (temp >= p[s]) {
							break;
						} 
						p[k] = p[s];
						k = s;
					}
					p[k] = temp;
				}
			} while (--i != 0/*
			  do
			  {
			    size_t k = 1;
			    UInt32 temp = p[size];
			    p[size--] = p[1];
			    HeapSortDown(p, k, size, temp)
			  }
			  while (size > 1);
			  */);
		}
		while (size > 3) {
			UInt32 temp = p[size];
			size_t k = (p[3] > p[2]) ? 3 : 2;
			p[size--] = p[1];
			p[1] = p[k];
			{ 
				for (; ; ) {
					size_t s = (k << 1);
					if (s > size) {
						break;
					} 
					if (s < size && p[s + 1] > p[s]) {
						s++;
					} 
					if (temp >= p[s]) {
						break;
					} 
					p[k] = p[s];
					k = s;
				}
				p[k] = temp;
			}
		}
		{ 
			UInt32 temp = p[size];
			p[size] = p[1];
			if (size > 2 && p[2] < temp) {
				p[1] = p[2];
				p[2] = temp;
			} else {
					p[1] = temp;
			} 
		}
	}
	public static void HeapSort64(Object p, Object size) {
		if (size <= 1) {
			return ;
		} 
		p--;
		{ 
			size_t i = size / 2;
			do {
				UInt64 temp = p[i];
				size_t k = i;
				{ 
					for (; ; ) {
						size_t s = (k << 1);
						if (s > size) {
							break;
						} 
						if (s < size && p[s + 1] > p[s]) {
							s++;
						} 
						if (temp >= p[s]) {
							break;
						} 
						p[k] = p[s];
						k = s;
					}
					p[k] = temp;
				}
			} while (--i != 0/*
			  do
			  {
			    size_t k = 1;
			    UInt64 temp = p[size];
			    p[size--] = p[1];
			    HeapSortDown(p, k, size, temp)
			  }
			  while (size > 1);
			  */);
		}
		while (size > 3) {
			UInt64 temp = p[size];
			size_t k = (p[3] > p[2]) ? 3 : 2;
			p[size--] = p[1];
			p[1] = p[k];
			{ 
				for (; ; ) {
					size_t s = (k << 1);
					if (s > size) {
						break;
					} 
					if (s < size && p[s + 1] > p[s]) {
						s++;
					} 
					if (temp >= p[s]) {
						break;
					} 
					p[k] = p[s];
					k = s;
				}
				p[k] = temp;
			}
		}
		{ 
			UInt64 temp = p[size];
			p[size] = p[1];
			if (size > 2 && p[2] < temp) {
				p[1] = p[2];
				p[2] = temp;
			} else {
					p[1] = temp/*
					#define HeapSortRefDown(p, vals, n, size, temp) \
					  { size_t k = n; UInt32 val = vals[temp]; for (;;) { \
					    size_t s = (k << 1); \
					    if (s > size) break; \
					    if (s < size && vals[p[s + 1]] > vals[p[s]]) s++; \
					    if (val >= vals[p[s]]) break; \
					    p[k] = p[s]; k = s; \
					  } p[k] = temp; }
					
					void HeapSortRef(UInt32 *p, UInt32 *vals, size_t size)
					{
					  if (size <= 1)
					    return;
					  p--;
					  {
					    size_t i = size / 2;
					    do
					    {
					      UInt32 temp = p[i];
					      HeapSortRefDown(p, vals, i, size, temp);
					    }
					    while (--i != 0);
					  }
					  do
					  {
					    UInt32 temp = p[size];
					    p[size--] = p[1];
					    HeapSortRefDown(p, vals, 1, size, temp);
					  }
					  while (size > 1);
					}
					*/;
			} 
		}
	}
	/* gzlib.c -- zlib functions common to reading and writing gzip files
	 * Copyright (C) 2004-2017 Mark Adler
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */
	/* Local functions */
	/* If there is an \r\n appended, zap it.  */
	/* UNDER_CE */
	/* Reset gzip file state */
	public static void gz_reset(Object state) {
		state.getX().setHave(/* no output data available */0);
		if (state.getMode() == /* for reading ... */7247) {
			state.setEof(/* not at end of file */0);
			state.setPast(/* have not read past end yet */0);
			state.setHow(/* look for gzip header */0);
		} 
		state.setSeek(/* no seek request pending */0);
		ModernizedCProgram.gz_error(state, 0, ((Object)/* clear error */0));
		state.getX().setPos(/* no uncompressed data yet */0);
		state.getStrm().setAvail_in(/* no input data yet */0);
	}
	/* Open a gzip file either by name or file descriptor. */
	public static Object gz_open(Object path, int fd, Object mode) {
		gz_statep state = new gz_statep();
		z_size_t len = new z_size_t();
		int oflag;
		int exclusive = 0;
		if (path == ((Object)/* check input */0)) {
			return ((Object)0);
		} 
		state = (gz_statep).malloc(/* allocate gzFile structure to return */);
		if (state == ((Object)0)) {
			return ((Object)0);
		} 
		state.setSize(/* no buffers allocated yet */0);
		state.setWant(/* requested buffer size */8192);
		state.setMsg(((Object)/* no error message yet */0));
		state.setMode(/* interpret mode */0);
		state.setLevel((true));
		state.setStrategy(0);
		state.setDirect(0);
		while (mode) {
			if (mode >= (byte)'0' && mode <= (byte)'9') {
				state.setLevel(mode - (byte)'0');
			} else {
					switch (mode) {
					case (byte)'x':
							exclusive = 1;
							break;
					case (byte)'r':
							state.setMode(7247);
							break;
					case (byte)'R':
							state.setStrategy(3);
							break;
					case (byte)'F':
							state.setStrategy(4);
							break;
					case (byte)'a':
							state.setMode(1);
							break;
					case /* ignore -- will request binary anyway */(byte)'b':
							break;
					case (byte)'T':
							state.setDirect(1);
							break;
					case (byte)'h':
							state.setStrategy(2);
							break;
					case (byte)'f':
							state.setStrategy(1);
							break;
					case (byte)'w':
							state.setMode(31153);
							break;
					case /* can't read and write at the same time */(byte)'+':
							.free(state);
							return ((Object)0);
					default:
							;
					}
			} 
			mode++;
		}
		if (state.getMode() == /* must provide an "r", "w", or "a" */0) {
			.free(state);
			return ((Object)0);
		} 
		if (state.getMode() == /* can't force transparent read */7247) {
			if (state.getDirect()) {
				.free(state);
				return ((Object)0);
			} 
			state.setDirect(/* for empty file */1);
		} 
		if (fd == -/* save the path name for error messages */2) {
			len = .wcstombs(((Object)0), path, 0);
			if (len == (z_size_t)-1) {
				len = 0;
			} 
		} else {
				len = .strlen((byte)path);
		} 
		state.setPath((byte).malloc(len + 1));
		if (state.getPath() == ((Object)0)) {
			.free(state);
			return ((Object)0);
		} 
		if (fd == -2) {
			if (len) {
				.wcstombs(state.getPath(), path, len + 1);
			} else {
					(state.getPath()) = 0;
			} 
		} else {
				(Object).snprintf(state.getPath(), len + 1, "%s", (byte)path);
		} 
		/* compute the flags for open() */oflag = -1024 | (state.getMode() == 7247 ? 0 : (1 | -1024 | (exclusive ? -1024 : 0) | (state.getMode() == 31153 ? -1024 : -1024)));
		state.setFd(fd > -1 ? fd : /* open the file with the appropriate flags (or just use fd) */(fd == -2 ? ._wopen(path, oflag, 666) : ModernizedCProgram.open((byte)path, oflag, 666)));
		if (state.getFd() == -1) {
			.free(state.getPath());
			.free(state);
			return ((Object)0);
		} 
		if (state.getMode() == 1) {
			.lseek(state.getFd(), 0, /* so gzoffset() is correct */2);
			state.setMode(/* simplify later checks */31153);
		} 
		if (state.getMode() == /* save the current position for rewinding (only if reading) */7247) {
			state.setStart(.lseek(state.getFd(), 0, 1));
			if (state.getStart() == -1) {
				state.setStart(0);
			} 
		} 
		ModernizedCProgram.gz_reset(/* initialize stream */state);
		return (gzFile)/* return stream */state;
	}
	/* Map the Windows error number in ERROR to a locale-dependent error message
	   string and return a pointer to it.  Typically, the values for ERROR come
	   from GetLastError.
	
	   The string pointed to shall not be modified by the application, but may be
	   overwritten by a subsequent call to gz_strwinerror
	
	   The gz_strwinerror function does not change the current setting of
	   GetLastError. */
	/* Default language */
	/* -- see zlib.h -- */
	public static Object gzopen(Object path, Object mode) {
		return ModernizedCProgram.gz_open(path, -1, mode);
	}
	/* -- see zlib.h -- */
	public static Object gzopen64(Object path, Object mode) {
		return ModernizedCProgram.gz_open(path, -1, mode);
	}
	/* -- see zlib.h -- */
	public static Object gzdopen(int fd, Object mode) {
		/* identifier for error messages */byte path;
		gzFile gz = new gzFile();
		if (fd == -1 || (path = (byte).malloc(7 + 3 * )) == ((Object)0)) {
			return ((Object)0);
		} 
		(Object).snprintf(path, 7 + 3 * , "<fd:%d>", fd);
		gz = ModernizedCProgram.gz_open(path, fd, /* for debugging */mode);
		.free(path);
		return gz;
	}
	/* -- see zlib.h -- */
	public static Object gzopen_w(Object path, Object mode) {
		return ModernizedCProgram.gz_open(path, -2, mode);
	}
	/* -- see zlib.h -- */
	public static int gzbuffer(Object file, int size) {
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure and check integrity */0)) {
			return -1;
		} 
		state = (gz_statep)file;
		if (state.getMode() != 7247 && state.getMode() != 31153) {
			return -1;
		} 
		if (state.getSize() != /* make sure we haven't already allocated memory */0) {
			return -1;
		} 
		if ((size << 1) < /* check and set requested size */size) {
			return -/* need to be able to double it */1;
		} 
		if (size < 2) {
			size = /* need two bytes to check magic header */2;
		} 
		state.setWant(size);
		return 0;
	}
	/* -- see zlib.h -- */
	public static int gzrewind(Object file) {
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure */0)) {
			return -1;
		} 
		state = (gz_statep)file;
		if (state.getMode() != /* check that we're reading and that there's no error */7247 || (state.getErr() != 0 && state.getErr() != (true))) {
			return -1;
		} 
		if (.lseek(state.getFd(), state.getStart(), 0) == -/* back up and start over */1) {
			return -1;
		} 
		ModernizedCProgram.gz_reset(state);
		return 0;
	}
	/* -- see zlib.h -- */
	public static long gzseek64(Object file, long offset, int whence) {
		int n;
		long ret;
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure and check integrity */0)) {
			return -1;
		} 
		state = (gz_statep)file;
		if (state.getMode() != 7247 && state.getMode() != 31153) {
			return -1;
		} 
		if (state.getErr() != 0 && state.getErr() != (/* check that there's no error */true)) {
			return -1;
		} 
		if (whence != 0 && whence != /* can only seek from start or relative to current position */1) {
			return -1;
		} 
		if (whence == /* normalize offset to a SEEK_CUR specification */0) {
			offset -= state.getX().getPos();
		}  else if (state.getSeek()) {
			offset += state.getSkip();
		} 
		state.setSeek(0);
		if (state.getMode() == 7247 && state.getHow() == /* if within raw area while reading, just go there */1 && state.getX().getPos() + offset >= 0) {
			ret = .lseek(state.getFd(), offset - state.getX().getHave(), 1);
			if (ret == -1) {
				return -1;
			} 
			state.getX().setHave(0);
			state.setEof(0);
			state.setPast(0);
			state.setSeek(0);
			ModernizedCProgram.gz_error(state, 0, ((Object)0));
			state.getStrm().setAvail_in(0);
			state.getX().getPos() += offset;
			return state.getX().getPos();
		} 
		if (offset < /* calculate skip amount, rewinding if needed for back seek when reading */0) {
			if (state.getMode() != /* writing -- can't go backwards */7247) {
				return -1;
			} 
			offset += state.getX().getPos();
			if (offset < /* before start of file! */0) {
				return -1;
			} 
			if (ModernizedCProgram.gzrewind(file) == -/* rewind, then skip to offset */1) {
				return -1;
			} 
		} 
		if (state.getMode() == /* if reading, skip what's in output buffer (one less gzgetc() check) */7247) {
			n = ( ==  && (state.getX().getHave()) > 2147483647) || (long)state.getX().getHave() > offset ? (int)offset : state.getX().getHave();
			state.getX().getHave() -= n;
			state.getX().getNext() += n;
			state.getX().getPos() += n;
			offset -= n;
		} 
		if (/* request skip (if not zero) */offset) {
			state.setSeek(1);
			state.setSkip(offset);
		} 
		return state.getX().getPos() + offset;
	}
	/* -- see zlib.h -- */
	public static long gzseek(Object file, long offset, int whence) {
		long ret;
		ret = ModernizedCProgram.gzseek64(file, (long)offset, whence);
		return ret == (long)ret ? (long)ret : -1;
	}
	/* -- see zlib.h -- */
	public static long gztell64(Object file) {
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure and check integrity */0)) {
			return -1;
		} 
		state = (gz_statep)file;
		if (state.getMode() != 7247 && state.getMode() != 31153) {
			return -1;
		} 
		return state.getX().getPos() + (state.getSeek() ? state.getSkip() : /* return position */0);
	}
	/* -- see zlib.h -- */
	public static long gztell(Object file) {
		long ret;
		ret = ModernizedCProgram.gztell64(file);
		return ret == (long)ret ? (long)ret : -1;
	}
	/* -- see zlib.h -- */
	public static long gzoffset64(Object file) {
		long offset;
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure and check integrity */0)) {
			return -1;
		} 
		state = (gz_statep)file;
		if (state.getMode() != 7247 && state.getMode() != 31153) {
			return -1;
		} 
		offset = .lseek(state.getFd(), 0, /* compute and return effective offset in file */1);
		if (offset == -1) {
			return -1;
		} 
		if (state.getMode() == /* reading */7247) {
			offset -= state.getStrm().getAvail_in();
		} 
		return offset;
	}
	/* -- see zlib.h -- */
	public static long gzoffset(Object file) {
		long ret;
		ret = ModernizedCProgram.gzoffset64(file);
		return ret == (long)ret ? (long)ret : -1;
	}
	/* -- see zlib.h -- */
	public static int gzeof(Object file) {
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure and check integrity */0)) {
			return 0;
		} 
		state = (gz_statep)file;
		if (state.getMode() != 7247 && state.getMode() != 31153) {
			return 0;
		} 
		return state.getMode() == 7247 ? state.getPast() : /* return end-of-file state */0;
	}
	/* -- see zlib.h -- */
	public static Object gzerror(Object file, int errnum) {
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure and check integrity */0)) {
			return ((Object)0);
		} 
		state = (gz_statep)file;
		if (state.getMode() != 7247 && state.getMode() != 31153) {
			return ((Object)0);
		} 
		if (errnum != ((Object)/* return error information */0)) {
			errnum = state.getErr();
		} 
		return state.getErr() == (true) ? "out of memory" : (state.getMsg() == ((Object)0) ? "" : state.getMsg());
	}
	/* -- see zlib.h -- */
	public static void gzclearerr(Object file) {
		gz_statep state = new gz_statep();
		if (file == ((Object)/* get internal structure and check integrity */0)) {
			return ;
		} 
		state = (gz_statep)file;
		if (state.getMode() != 7247 && state.getMode() != 31153) {
			return ;
		} 
		if (state.getMode() == /* clear error and end-of-file */7247) {
			state.setEof(0);
			state.setPast(0);
		} 
		ModernizedCProgram.gz_error(state, 0, ((Object)0/* Create an error message in allocated memory and set state->err and
		   state->msg accordingly.  Free any previous error message already there.  Do
		   not try to free or allocate space if the error is Z_MEM_ERROR (out of
		   memory).  Simply save the error message as a static string.  If there is an
		   allocation failure constructing the error message, then convert the error to
		   out of memory. */));
	}
	public static void gz_error(Object state, int err, Object msg) {
		if (state.getMsg() != ((Object)/* free previously allocated message and clear */0)) {
			if (state.getErr() != (true)) {
				.free(state.getMsg());
			} 
			state.setMsg(((Object)0));
		} 
		if (err != 0 && err != (/* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */true)) {
			state.getX().setHave(0);
		} 
		state.setErr(/* set error code, and if no message, then done */err);
		if (msg == ((Object)0)) {
			return ;
		} 
		if (err == (/* for an out of memory error, return literal string when requested */true)) {
			return ;
		} 
		if ((state.setMsg((byte).malloc(.strlen(state.getPath()) + .strlen(msg) + /* construct error message with path */3))) == ((Object)0)) {
			state.setErr((true));
			return ;
		} 
		(Object).snprintf(state.getMsg(), .strlen(state.getPath()) + .strlen(msg) + 3, "%s%s%s", state.getPath(), ": ", msg)/* portably return maximum value for an int (when limits.h presumed not
		   available) -- we need to do this to cover cases where 2's complement not
		   used, since C standard permits 1's complement and sign-bit representations,
		   otherwise we could just use ((unsigned)-1) >> 1 *//* portably return maximum value for an int (when limits.h presumed not
		   available) -- we need to do this to cover cases where 2's complement not
		   used, since C standard permits 1's complement and sign-bit representations,
		   otherwise we could just use ((unsigned)-1) >> 1 */;/* portably return maximum value for an int (when limits.h presumed not
		   available) -- we need to do this to cover cases where 2's complement not
		   used, since C standard permits 1's complement and sign-bit representations,
		   otherwise we could just use ((unsigned)-1) >> 1 *//* portably return maximum value for an int (when limits.h presumed not
		   available) -- we need to do this to cover cases where 2's complement not
		   used, since C standard permits 1's complement and sign-bit representations,
		   otherwise we could just use ((unsigned)-1) >> 1 */
	}
	// hlfmt main
	public static Object strhlfmt(Object hashfile_format) {
		switch (hashfile_format) {
		case hlfmt_name.HLFMT_NETNTLM2:
				return ModernizedCProgram.HLFMT_TEXT_NETNTLM2;
		case hlfmt_name.HLFMT_NSLDAP:
				return ModernizedCProgram.HLFMT_TEXT_NSLDAP;
		case hlfmt_name.HLFMT_DCC2:
				return ModernizedCProgram.HLFMT_TEXT_DCC2;
		case hlfmt_name.HLFMT_HASHCAT:
				return ModernizedCProgram.HLFMT_TEXT_HASHCAT;
		case hlfmt_name.HLFMT_PASSWD:
				return ModernizedCProgram.HLFMT_TEXT_PASSWD;
		case hlfmt_name.HLFMT_DCC:
				return ModernizedCProgram.HLFMT_TEXT_DCC;
		case hlfmt_name.HLFMT_NETNTLM1:
				return ModernizedCProgram.HLFMT_TEXT_NETNTLM1;
		case hlfmt_name.HLFMT_SHADOW:
				return ModernizedCProgram.HLFMT_TEXT_SHADOW;
		case hlfmt_name.HLFMT_NSLDAPS:
				return ModernizedCProgram.HLFMT_TEXT_NSLDAPS;
		case hlfmt_name.HLFMT_PWDUMP:
				return ModernizedCProgram.HLFMT_TEXT_PWDUMP;
		}
		return "Unknown";
	}
	public static Object hlfmt_detect(hashcat_ctx hashcat_ctx, hc_fp fp, Object max_check) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		// Exception: those formats are wrongly detected as HLFMT_SHADOW, prevent it
		if (hashconfig.getHlfmt_disable() == 1) {
			return hlfmt_name.HLFMT_HASHCAT;
		} 
		u32 formats_cnt = (u32)ModernizedCProgram.hccalloc(11, );
		u32 num_check = 0;
		byte line_buf = (byte)ModernizedCProgram.hcmalloc(-1024);
		while (!fp.hc_feof()) {
			size_t line_len = fp.fgetl(line_buf, -1024);
			if (line_len == 0) {
				continue;
			} 
			if (hashcat_ctx.hlfmt_detect_pwdump(line_buf, line_len)) {
				formats_cnt[hlfmt_name.HLFMT_PWDUMP]++;
			} 
			if (hashcat_ctx.hlfmt_detect_passwd(line_buf, line_len)) {
				formats_cnt[hlfmt_name.HLFMT_PASSWD]++;
			} 
			if (hashcat_ctx.hlfmt_detect_shadow(line_buf, line_len)) {
				formats_cnt[hlfmt_name.HLFMT_SHADOW]++;
			} 
			if (num_check == max_check) {
				break;
			} 
			num_check++;
		}
		ModernizedCProgram.hcfree(line_buf);
		u32 hashlist_format = hlfmt_name.HLFMT_HASHCAT;
		for (u32 i = 1;
		 i < 11; i++) {
			if (formats_cnt[i - 1] >= formats_cnt[i]) {
				continue;
			} 
			hashlist_format = i;
		}
		.free(formats_cnt);
		return hashlist_format;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static Object rotl32(Object a, Object n) {
		return ((a << n) | (a >> (32 - n)));
	}
	public static Object rotr32(Object a, Object n) {
		return ((a >> n) | (a << (32 - n)));
	}
	public static Object rotl64(Object a, Object n) {
		return ((a << n) | (a >> (64 - n)));
	}
	public static Object rotr64(Object a, Object n) {
		return ((a >> n) | (a << (64 - n)));
	}
	public static Object byte_swap_16(Object n) {
		return (u16)((n >> 8) | (n << 8));
	}
	public static Object byte_swap_32(Object n) {
		return .__builtin_bswap32(n);
	}
	public static Object byte_swap_64(Object n) {
		return .__builtin_bswap64(n);
	}
	/* Lzma2DecMt.c -- LZMA2 Decoder Multi-thread
	2019-02-02 : Igor Pavlov : Public domain */
	// #define SHOW_DEBUG_INFO
	// #define _7ZIP_ST
	public static void Lzma2DecMtProps_Init() {
		this.setInBufSize_ST(1 << 20);
		this.setOutStep_ST(1 << 20);
		this.setNumThreads(1);
		this.setInBufSize_MT(1 << 18);
		this.setOutBlockMax((1 << 28));
		Object generatedOutBlockMax = this.getOutBlockMax();
		this.setInBlockMax(generatedOutBlockMax + generatedOutBlockMax / 16);
	}
	public static Object Lzma2DecMt_Create(Object alloc, Object allocMid) {
		CLzma2DecMt p = (CLzma2DecMt).UNRECOGNIZEDFUNCTIONNAME(alloc, );
		if (!p) {
			return ((Object)0);
		} 
		// p->alloc = alloc;// p->alloc = alloc;p.setAllocMid(allocMid);
		Object generatedAlignOffsetAlloc = p.getAlignOffsetAlloc();
		generatedAlignOffsetAlloc.AlignOffsetAlloc_CreateVTable();
		generatedAlignOffsetAlloc.setNumAlignBits(7);
		generatedAlignOffsetAlloc.setOffset(0);
		generatedAlignOffsetAlloc.setBaseAlloc(alloc);
		p.setInBuf(((Object)0));
		p.setInBufSize(0);
		p.setDec_created(0)// Lzma2DecMtProps_Init(&p->props);;// Lzma2DecMtProps_Init(&p->props);
		p.setMtc_WasConstructed(0);
		Object generatedCoders = p.getCoders();
		{ 
			int i;
			for (i = 0; i < 32; i++) {
				CLzma2DecMtThread t = generatedCoders[i];
				t.setDec_created(0);
				t.setOutBuf(((Object)0));
				t.setOutBufSize(0);
			}
		}
		return p;
	}
	public static void Lzma2DecMt_FreeOutBufs() {
		int i;
		Object generatedCoders = this.getCoders();
		Object generatedOutBuf = t.getOutBuf();
		Object generatedAllocMid = this.getAllocMid();
		for (i = 0; i < 32; i++) {
			CLzma2DecMtThread t = generatedCoders[i];
			if (generatedOutBuf) {
				.UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedOutBuf);
				t.setOutBuf(((Object)0));
				t.setOutBufSize(0);
			} 
		}
	}
	public static void Lzma2DecMt_FreeSt() {
		Object generatedDec_created = this.getDec_created();
		Object generatedDec = this.getDec();
		Object generatedAlignOffsetAlloc = this.getAlignOffsetAlloc();
		if (generatedDec_created) {
			(generatedDec).getDecoder().LzmaDec_Free(generatedAlignOffsetAlloc.getVt());
			this.setDec_created(0);
		} 
		Object generatedInBuf = this.getInBuf();
		Object generatedAllocMid = this.getAllocMid();
		if (generatedInBuf) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedInBuf);
			this.setInBuf(((Object)0));
		} 
		this.setInBufSize(0);
	}
	public static void Lzma2DecMt_Destroy(Object pp) {
		CLzma2DecMt p = (CLzma2DecMt)pp;
		p.Lzma2DecMt_FreeSt();
		Object generatedMtc_WasConstructed = p.getMtc_WasConstructed();
		Object generatedMtc = p.getMtc();
		if (generatedMtc_WasConstructed) {
			generatedMtc.MtDec_Destruct();
			p.setMtc_WasConstructed(0);
		} 
		Object generatedCoders = p.getCoders();
		Object generatedDec_created = t.getDec_created();
		Object generatedDec = t.getDec();
		Object generatedAlloc = t.getAlloc();
		{ 
			int i;
			for (i = 0; i < 32; i++) {
				CLzma2DecMtThread t = generatedCoders[i];
				if (generatedDec_created) {
					(generatedDec).getDecoder().LzmaDec_FreeProbs(generatedAlloc.getVt());
					t.setDec_created(0);
				} 
			}
		}
		p.Lzma2DecMt_FreeOutBufs();
		Object generatedAlignOffsetAlloc = p.getAlignOffsetAlloc();
		.UNRECOGNIZEDFUNCTIONNAME(generatedAlignOffsetAlloc.getBaseAlloc(), pp);
	}
	public static void Lzma2DecMt_MtCallback_Parse(Object obj, int coderIndex) {
		CLzma2DecMt me = (CLzma2DecMt)obj;
		Object generatedCoders = me.getCoders();
		CLzma2DecMtThread t = generatedCoders[coderIndex];
		;
		this.setState(.MTDEC_PARSE_CONTINUE);
		Object generatedStartCall = this.getStartCall();
		Object generatedDec_created = t.getDec_created();
		Object generatedDec = t.getDec();
		Object generatedAlloc = t.getAlloc();
		Object generatedAlignOffsetAlloc = me.getAlignOffsetAlloc();
		if (generatedStartCall) {
			if (!generatedDec_created) {
				{ 
					((generatedDec).getDecoder()).setDic(((Object)0));
					((generatedDec).getDecoder()).setProbs(((Object)0));
				}
				;
				t.setDec_created(1);
				generatedAlloc.AlignOffsetAlloc_CreateVTable();
				{ 
					int kNumAlignBits = /* (1 << 12) is expected size of one way in data cache.
					           We optimize alignment for cache line size of 128 bytes and smaller */12;
					int kNumCacheLineBits = /* <= kNumAlignBits */7;
					generatedAlloc.setNumAlignBits(kNumAlignBits);
					generatedAlloc.setOffset(((UInt32)coderIndex * ((1 << 11) + (1 << 8) + (1 << 6))) & ((1 << kNumAlignBits) - (1 << kNumCacheLineBits)));
					generatedAlloc.setBaseAlloc(generatedAlignOffsetAlloc.getBaseAlloc());
				}
			} 
			generatedDec.Lzma2Dec_Init();
			t.setInPreSize(0);
			t.setOutPreSize(0);
			t.setParseStatus((ELzma2ParseStatus).LZMA_STATUS_NOT_SPECIFIED);
			t.setState(.MTDEC_PARSE_CONTINUE);
			t.setInCodeSize(0);
			t.setOutCodeSize(0);
			t.setCodeRes(0);
		} 
		Object generatedProps = me.getProps();
		Object generatedOutSize_Defined = me.getOutSize_Defined();
		Object generatedOutSize = me.getOutSize();
		Object generatedOutProcessed_Parse = me.getOutProcessed_Parse();
		Object generatedFinishMode = me.getFinishMode();
		Object generatedSrcSize = this.getSrcSize();
		Object generatedSrc = this.getSrc();
		Object generatedInPreSize = t.getInPreSize();
		Object generatedState = this.getState();
		{ 
			ELzma2ParseStatus status = new ELzma2ParseStatus();
			BoolInt overflow = new BoolInt();
			UInt32 unpackRem = 0;
			int checkFinishBlock = 1;
			size_t limit = generatedProps.getOutBlockMax();
			if (generatedOutSize_Defined) {
				UInt64 rem = generatedOutSize - generatedOutProcessed_Parse;
				if (limit >= rem) {
					limit = (size_t)rem;
					if (!generatedFinishMode) {
						checkFinishBlock = 0;
					} 
				} 
			} 
			{ 
				SizeT srcOrig = generatedSrcSize;
				SizeT srcSize_Point = 0;
				SizeT dicPos_Point = 0;
				this.setSrcSize(0);
				overflow = 0;
				for (; ; ) {
					SizeT srcCur = srcOrig - generatedSrcSize;
					status = generatedDec.Lzma2Dec_Parse(limit - generatedDec.getDecoder().getDicPos(), generatedSrc + generatedSrcSize, srcCur, checkFinishBlock);
					generatedSrcSize += srcCur;
					if (status == .LZMA2_PARSE_STATUS_NEW_CHUNK) {
						if (generatedDec.getUnpackSize() > generatedProps.getOutBlockMax() - generatedDec.getDecoder().getDicPos()) {
							overflow = 1;
							break;
						} 
						continue;
					} 
					if (status == .LZMA2_PARSE_STATUS_NEW_BLOCK) {
						if (generatedDec.getDecoder().getDicPos() == 0) {
							continue;
						} 
						if (generatedDec.getDecoder().getDicPos() >= (1 << 14)) {
							break;
						} 
						dicPos_Point = generatedDec.getDecoder().getDicPos();
						srcSize_Point = generatedSrcSize;
						continue;
					} 
					if ((int)status == .LZMA_STATUS_NOT_FINISHED && checkFinishBlock) {
						overflow = 1;
						break;
					} 
					unpackRem = ((generatedDec).getIsExtraMode() ? (generatedDec).getUnpackSize() : 0);
					;
					break;
				}
				if (dicPos_Point != 0 && (int)status != .LZMA2_PARSE_STATUS_NEW_BLOCK && (int)status != .LZMA_STATUS_FINISHED_WITH_MARK && (int)status != .LZMA_STATUS_NOT_SPECIFIED) {
					status = .LZMA2_PARSE_STATUS_NEW_BLOCK;
					unpackRem = 0;
					generatedDec.getDecoder().setDicPos(dicPos_Point);
					this.setSrcSize(srcSize_Point);
					overflow = 0;
				} 
			}
			generatedInPreSize += generatedSrcSize;
			t.setParseStatus(status);
			if (overflow) {
				this.setState(.MTDEC_PARSE_OVERFLOW);
			} else {
					size_t dicPos = generatedDec.getDecoder().getDicPos();
					if ((int)status != .LZMA_STATUS_NEEDS_MORE_INPUT) {
						if (status == .LZMA2_PARSE_STATUS_NEW_BLOCK) {
							this.setState(.MTDEC_PARSE_NEW);
							generatedSrcSize--;
							generatedInPreSize--;
						} else {
								this.setState(.MTDEC_PARSE_END);
								if ((int)status != .LZMA_STATUS_FINISHED_WITH_MARK) {
									if (unpackRem != 0) {
										SizeT rem = limit - /* we also reserve space for max possible number of output bytes of current LZMA chunk */dicPos;
										if (rem > unpackRem) {
											rem = unpackRem;
										} 
										dicPos += rem;
									} 
								} 
						} 
						generatedOutProcessed_Parse += dicPos;
					} 
					this.setOutPos(dicPos);
					t.setOutPreSize((size_t)dicPos);
			} 
			t.setState(generatedState);
			return ;
		}
	}
	public static Object Lzma2DecMt_MtCallback_PreCode(Object pp, int coderIndex) {
		CLzma2DecMt me = (CLzma2DecMt)pp;
		Object generatedCoders = me.getCoders();
		CLzma2DecMtThread t = generatedCoders[coderIndex];
		Object generatedOutBuf = t.getOutBuf();
		Byte dest = generatedOutBuf;
		Object generatedInPreSize = t.getInPreSize();
		Object generatedCodeRes = t.getCodeRes();
		if (generatedInPreSize == 0) {
			t.setCodeRes(1);
			return generatedCodeRes;
		} 
		Object generatedOutBufSize = t.getOutBufSize();
		Object generatedOutPreSize = t.getOutPreSize();
		Object generatedAllocMid = me.getAllocMid();
		if (!dest || generatedOutBufSize < generatedOutPreSize) {
			if (dest) {
				.UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, dest);
				t.setOutBuf(((Object)0));
				t.setOutBufSize(0);
			} 
			dest = (Byte).UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedOutPreSize);
			if (!dest) {
				return 2;
			} 
			t.setOutBuf(dest);
			t.setOutBufSize(generatedOutPreSize);
		} 
		Object generatedDec = t.getDec();
		generatedDec.getDecoder().setDic(dest);
		generatedDec.getDecoder().setDicBufSize(generatedOutPreSize);
		t.setNeedInit(1);
		Object generatedProp = me.getProp();
		Object generatedAlloc = t.getAlloc();
		// alloc.vtreturn generatedDec.Lzma2Dec_AllocateProbs(generatedProp, generatedAlloc.getVt());
	}
	public static Object Lzma2DecMt_MtCallback_Code(Object pp, int coderIndex, Object src, Object srcSize, int srcFinished, Object inCodePos, Object outCodePos, int stop) {
		CLzma2DecMt me = (CLzma2DecMt)pp;
		Object generatedCoders = me.getCoders();
		CLzma2DecMtThread t = generatedCoders[coderIndex];
		(Object)srcFinished;
		;
		Object generatedInCodeSize = t.getInCodeSize();
		inCodePos = generatedInCodeSize;
		outCodePos = 0;
		stop = 1;
		Object generatedNeedInit = t.getNeedInit();
		Object generatedDec = t.getDec();
		if (generatedNeedInit) {
			generatedDec.Lzma2Dec_Init();
			t.setNeedInit(0);
		} 
		Object generatedParseStatus = t.getParseStatus();
		Object generatedOutPreSize = t.getOutPreSize();
		Object generatedInPreSize = t.getInPreSize();
		Object generatedOutCodeSize = t.getOutCodeSize();
		{ 
			ELzmaStatus status = new ELzmaStatus();
			size_t srcProcessed = srcSize;
			BoolInt blockWasFinished = ((int)generatedParseStatus == .LZMA_STATUS_FINISHED_WITH_MARK || generatedParseStatus == .LZMA2_PARSE_STATUS_NEW_BLOCK);
			SRes res = generatedDec.Lzma2Dec_DecodeToDic(generatedOutPreSize, src, srcProcessed, blockWasFinished ? .LZMA_FINISH_END : .LZMA_FINISH_ANY, status);
			t.setCodeRes(res);
			generatedInCodeSize += srcProcessed;
			inCodePos = generatedInCodeSize;
			t.setOutCodeSize(generatedDec.getDecoder().getDicPos());
			outCodePos = generatedDec.getDecoder().getDicPos();
			if (res != 0) {
				return res;
			} 
			if (srcProcessed == srcSize) {
				stop = 0;
			} 
			if (blockWasFinished) {
				if (srcSize != srcProcessed) {
					return 11;
				} 
				if (generatedInPreSize == generatedInCodeSize) {
					if (generatedOutPreSize != generatedOutCodeSize) {
						return 11;
					} 
					stop = 1;
				} 
			} else {
					if (generatedOutPreSize == generatedOutCodeSize) {
						stop = 1;
					} 
			} 
			return 0;
		}
	}
	// int finished, int blockFinished,
	public static Object Lzma2DecMt_MtCallback_Write(Object pp, int coderIndex, Object needWriteToStream, Object src, Object srcSize, Object needContinue, Object canRecode) {
		CLzma2DecMt me = (CLzma2DecMt)pp;
		Object generatedCoders = me.getCoders();
		CLzma2DecMtThread t = generatedCoders[coderIndex];
		size_t size = t.getOutCodeSize();
		Byte data = t.getOutBuf();
		BoolInt needContinue2 = 1;
		;
		needContinue = 0;
		canRecode = 1;
		(Object)src;
		(Object)srcSize;
		if (t.getState() == .MTDEC_PARSE_OVERFLOW || t.getState() == .MTDEC_PARSE_END) {
			needContinue2 = 0;
		} 
		// t->parseStatus == LZMA_STATUS_FINISHED_WITH_MARK
		if (!needWriteToStream) {
			return 0;
		} 
		Object generatedMtc = me.getMtc();
		generatedMtc.getInProcessed() += t.getInCodeSize();
		if (t.getCodeRes() == 0) {
			if ((int)t.getParseStatus() == .LZMA_STATUS_FINISHED_WITH_MARK || t.getParseStatus() == .LZMA2_PARSE_STATUS_NEW_BLOCK) {
				if (t.getOutPreSize() != t.getOutCodeSize() || t.getInPreSize() != t.getInCodeSize()) {
					return 11;
				} 
			} 
		} 
		canRecode = 0;
		Object generatedOutStream = me.getOutStream();
		Object generatedOutProcessed = me.getOutProcessed();
		if (generatedOutStream) {
			for (; ; ) {
				size_t cur = size;
				size_t written = new size_t();
				if (cur > (1 << 24)) {
					cur = (1 << 24);
				} 
				written = .UNRECOGNIZEDFUNCTIONNAME(generatedOutStream, data, cur);
				generatedOutProcessed += written;
				if (written != cur) {
					return 9;
				} 
				data += cur;
				size -= cur;
				if (size == 0) {
					needContinue = needContinue2;
					return 0;
				} 
				{ 
					int __result__ = (generatedMtc.getMtProgress().MtProgress_ProgressAdd(0, 0));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
			}
		} 
		return 11/*
		  if (size > me->outBufSize)
		    return SZ_ERROR_OUTPUT_EOF;
		  memcpy(me->outBuf, data, size);
		  me->outBufSize -= size;
		  me->outBuf += size;
		  *needContinue = needContinue2;
		  return SZ_OK;
		  */;
	}
	public static Object Lzma2Dec_Prepare_ST() {
		Object generatedDec_created = this.getDec_created();
		Object generatedDec = this.getDec();
		if (!generatedDec_created) {
			{ 
				((generatedDec).getDecoder()).setDic(((Object)0));
				((generatedDec).getDecoder()).setProbs(((Object)0));
			}
			;
			this.setDec_created(1);
		} 
		Object generatedProp = this.getProp();
		Object generatedAlignOffsetAlloc = this.getAlignOffsetAlloc();
		{ 
			int __result__ = (generatedDec.Lzma2Dec_Allocate(generatedProp, generatedAlignOffsetAlloc.getVt()));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedInBuf = this.getInBuf();
		Object generatedInBufSize = this.getInBufSize();
		Object generatedProps = this.getProps();
		Object generatedAllocMid = this.getAllocMid();
		if (!generatedInBuf || generatedInBufSize != generatedProps.getInBufSize_ST()) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedInBuf);
			this.setInBufSize(0);
			this.setInBuf((Byte).UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedProps.getInBufSize_ST()));
			if (!generatedInBuf) {
				return 2;
			} 
			this.setInBufSize(generatedProps.getInBufSize_ST());
		} 
		generatedDec.Lzma2Dec_Init();
		return 0;
	}
	public static Object Lzma2Dec_Decode_ST(Object tMode) {
		SizeT wrPos = new SizeT();
		size_t inPos = new size_t();
		size_t inLim = new size_t();
		Byte inData = new Byte();
		UInt64 inPrev = new UInt64();
		UInt64 outPrev = new UInt64();
		CLzma2Dec dec = new CLzma2Dec();
		Object generatedMtc = this.getMtc();
		if (tMode) {
			p.Lzma2DecMt_FreeOutBufs();
			tMode = generatedMtc.MtDec_PrepareRead();
		} 
		{ 
			int __result__ = (p.Lzma2Dec_Prepare_ST());
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedDec = this.getDec();
		dec = generatedDec;
		Object generatedInProcessed = this.getInProcessed();
		inPrev = generatedInProcessed;
		Object generatedOutProcessed = this.getOutProcessed();
		outPrev = generatedOutProcessed;
		inPos = 0;
		inLim = 0;
		inData = ((Object)0);
		Object generatedDecoder = dec.getDecoder();
		wrPos = generatedDecoder.getDicPos();
		Object generatedReadWasFinished = this.getReadWasFinished();
		Object generatedInBufSize = this.getInBufSize();
		Object generatedInBuf = this.getInBuf();
		Object generatedInStream = this.getInStream();
		Object generatedReadRes = this.getReadRes();
		Object generatedProps = this.getProps();
		Object generatedOutSize_Defined = this.getOutSize_Defined();
		Object generatedOutSize = this.getOutSize();
		Object generatedFinishMode = this.getFinishMode();
		Object generatedOutStream = this.getOutStream();
		Object generatedProgress = this.getProgress();
		for (; ; ) {
			SizeT dicPos = new SizeT();
			SizeT size = new SizeT();
			ELzmaFinishMode finishMode = new ELzmaFinishMode();
			SizeT inProcessed = new SizeT();
			ELzmaStatus status = new ELzmaStatus();
			SRes res = new SRes();
			SizeT outProcessed = new SizeT();
			BoolInt outFinished = new BoolInt();
			BoolInt needStop = new BoolInt();
			if (inPos == inLim) {
				if (tMode) {
					inData = generatedMtc.MtDec_Read(inLim);
					inPos = 0;
					if (inData) {
						continue;
					} 
					tMode = 0;
					inLim = 0;
				} 
				if (!generatedReadWasFinished) {
					inPos = 0;
					inLim = generatedInBufSize;
					inData = generatedInBuf;
					this.setReadRes(.UNRECOGNIZEDFUNCTIONNAME(generatedInStream, (Object)inData, inLim));
					if (inLim == 0 || generatedReadRes != 0) {
						this.setReadWasFinished(1);
					} 
				} 
			} 
			dicPos = generatedDecoder.getDicPos();
			{ 
				SizeT next = generatedDecoder.getDicBufSize();
				if (next - wrPos > generatedProps.getOutStep_ST()) {
					next = wrPos + generatedProps.getOutStep_ST();
				} 
				ModernizedCProgram.size = next - dicPos;
			}
			finishMode = .LZMA_FINISH_ANY;
			if (generatedOutSize_Defined) {
				UInt64 rem = generatedOutSize - generatedOutProcessed;
				if (ModernizedCProgram.size >= rem) {
					ModernizedCProgram.size = (SizeT)rem;
					if (generatedFinishMode) {
						finishMode = .LZMA_FINISH_END;
					} 
				} 
			} 
			inProcessed = inLim - inPos;
			res = dec.Lzma2Dec_DecodeToDic(dicPos + ModernizedCProgram.size, inData + inPos, inProcessed, finishMode, status);
			inPos += inProcessed;
			generatedInProcessed += inProcessed;
			outProcessed = generatedDecoder.getDicPos() - dicPos;
			generatedOutProcessed += outProcessed;
			outFinished = (generatedOutSize_Defined && generatedOutSize <= generatedOutProcessed);
			needStop = (res != 0 || (inProcessed == 0 && outProcessed == 0) || status == .LZMA_STATUS_FINISHED_WITH_MARK || (!generatedFinishMode && outFinished));
			if (needStop || outProcessed >= ModernizedCProgram.size) {
				SRes res2 = new SRes();
				{ 
					size_t writeSize = generatedDecoder.getDicPos() - wrPos;
					size_t written = .UNRECOGNIZEDFUNCTIONNAME(generatedOutStream, generatedDecoder.getDic() + wrPos, writeSize);
					res2 = (written == writeSize) ? 0 : 9;
				}
				if (generatedDecoder.getDicPos() == generatedDecoder.getDicBufSize()) {
					generatedDecoder.setDicPos(0);
				} 
				wrPos = generatedDecoder.getDicPos();
				{ 
					int __result__ = (res2);
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (needStop) {
					if (res != 0) {
						return res;
					} 
					if (status == .LZMA_STATUS_FINISHED_WITH_MARK) {
						if (generatedFinishMode) {
							if (generatedOutSize_Defined && generatedOutSize != generatedOutProcessed) {
								return 1;
							} 
						} 
						return 0;
					} 
					if (!generatedFinishMode && outFinished) {
						return 0;
					} 
					if (status == .LZMA_STATUS_NEEDS_MORE_INPUT) {
						return 6;
					} 
					return 1;
				} 
			} 
			if (generatedProgress) {
				UInt64 inDelta = generatedInProcessed - inPrev;
				UInt64 outDelta = generatedOutProcessed - outPrev;
				if (inDelta >= (1 << 22) || outDelta >= (1 << 22)) {
					{ 
						int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(generatedProgress, generatedInProcessed, generatedOutProcessed));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
					inPrev = generatedInProcessed;
					outPrev = generatedOutProcessed;
				} 
			} 
		}
	}
	public static Object Lzma2DecMt_Decode(Object pp, Object prop, Object props, ISeqOutStream outStream, Object outDataSize, int finishMode, ISeqInStream inStream, Object inProcessed, int isMT, ICompressProgress progress) {
		// const Byte *inData, size_t inDataSize,// UInt64 *outProcessed,CLzma2DecMt p = (CLzma2DecMt)pp;
		BoolInt tMode = new BoolInt();
		inProcessed = 0;
		if (prop > 40) {
			return 4;
		} 
		p.setProp(prop);
		p.setProps(props);
		p.setInStream(inStream);
		p.setOutStream(outStream);
		p.setProgress(progress);
		p.setOutSize(0);
		p.setOutSize_Defined(0);
		if (outDataSize) {
			p.setOutSize_Defined(1);
			p.setOutSize(outDataSize);
		} 
		p.setFinishMode(finishMode);
		p.setOutProcessed(0);
		p.setInProcessed(0);
		p.setReadWasFinished(0);
		isMT = 0;
		tMode = 0// p->mtc.parseRes = SZ_OK;// p->mtc.numFilledThreads = 0;// p->mtc.crossStart = 0;;// p->mtc.parseRes = SZ_OK;// p->mtc.numFilledThreads = 0;// p->mtc.crossStart = 0;
		Object generatedProps = p.getProps();
		Object generatedMtc_WasConstructed = p.getMtc_WasConstructed();
		Object generatedMtc = p.getMtc();
		Object generatedAlignOffsetAlloc = p.getAlignOffsetAlloc();
		// p->mtc.crossEnd = 0;// p->mtc.allocError_for_Read_BlockIndex = 0;// p->mtc.isAllocError = False;if (generatedProps.getNumThreads() > 1) {
			IMtDecCallback vt = new IMtDecCallback();
			p.Lzma2DecMt_FreeSt();
			p.setOutProcessed_Parse(0);
			if (!generatedMtc_WasConstructed) {
				p.setMtc_WasConstructed(1);
				generatedMtc.MtDec_Construct();
			} 
			generatedMtc.setProgress(progress);
			generatedMtc.setInStream(inStream/*
			    if (!outStream)
			    {
			      // p->outBuf = outBuf;
			      // p->outBufSize = *outBufSize;
			      // *outBufSize = 0;
			      return SZ_ERROR_PARAM;
			    }
			    */);
			generatedMtc.setAlloc(generatedAlignOffsetAlloc.getVt());
			generatedMtc.setMtCallback(vt);
			generatedMtc.setMtCallbackObject(p);
			generatedMtc.setInBufSize(generatedProps.getInBufSize_MT());
			generatedMtc.setNumThreadsMax(generatedProps.getNumThreads());
			isMT = 1;
			vt.setParse(Lzma2DecMt_MtCallback_Parse);
			vt.setPreCode(Lzma2DecMt_MtCallback_PreCode);
			vt.setCode(Lzma2DecMt_MtCallback_Code);
			vt.setWrite(Lzma2DecMt_MtCallback_Write);
			{ 
				BoolInt needContinue = 0;
				SRes res = generatedMtc.MtDec_Code();
				inProcessed = generatedMtc.getInProcessed();
				needContinue = 0;
				if (res == 0) {
					if (generatedMtc.getMtProgress().getRes() != 0) {
						res = generatedMtc.getMtProgress().getRes();
					} else {
							needContinue = generatedMtc.getNeedContinue();
					} 
				} 
				if (!needContinue) {
					if (res == 0) {
						return generatedMtc.getReadRes();
					} 
					return res;
				} 
				tMode = 1;
				p.setReadRes(generatedMtc.getReadRes());
				p.setReadWasFinished(generatedMtc.getReadWasFinished());
				p.setInProcessed(generatedMtc.getInProcessed());
				;
			}
		} 
		isMT = 0;
		Object generatedInProcessed = p.getInProcessed();
		Object generatedReadRes = p.getReadRes();
		{ 
			SRes res = p.Lzma2Dec_Decode_ST(tMode);
			inProcessed = generatedInProcessed;
			if (res == 0 && generatedReadRes != 0) {
				res = generatedReadRes;
			} 
			return res;
		}
	}
	// Byte *outBuf, size_t *outBufSize,
	public static Object Lzma2DecMt_Read(Object pp, Object data, Object outSize, Object inStreamProcessed) {
		CLzma2DecMt p = (CLzma2DecMt)pp;
		ELzmaFinishMode finishMode = new ELzmaFinishMode();
		SRes readRes = new SRes();
		size_t size = outSize;
		outSize = 0;
		inStreamProcessed = 0;
		finishMode = .LZMA_FINISH_ANY;
		Object generatedOutSize_Defined = p.getOutSize_Defined();
		Object generatedOutSize = p.getOutSize();
		Object generatedOutProcessed = p.getOutProcessed();
		Object generatedFinishMode = p.getFinishMode();
		if (generatedOutSize_Defined) {
			UInt64 rem = generatedOutSize - generatedOutProcessed;
			if (size >= rem) {
				size = (size_t)rem;
				if (generatedFinishMode) {
					finishMode = .LZMA_FINISH_END;
				} 
			} 
		} 
		readRes = 0;
		Object generatedInPos = p.getInPos();
		Object generatedInLim = p.getInLim();
		Object generatedProps = p.getProps();
		Object generatedInStream = p.getInStream();
		Object generatedInBuf = p.getInBuf();
		Object generatedDec = p.getDec();
		Object generatedInProcessed = p.getInProcessed();
		for (; ; ) {
			SizeT inCur = new SizeT();
			SizeT outCur = new SizeT();
			ELzmaStatus status = new ELzmaStatus();
			SRes res = new SRes();
			if (generatedInPos == generatedInLim && readRes == 0) {
				p.setInPos(0);
				p.setInLim(generatedProps.getInBufSize_ST());
				readRes = .UNRECOGNIZEDFUNCTIONNAME(generatedInStream, generatedInBuf, generatedInLim);
			} 
			inCur = generatedInLim - generatedInPos;
			outCur = size;
			res = generatedDec.Lzma2Dec_DecodeToBuf(data, outCur, generatedInBuf + generatedInPos, inCur, finishMode, status);
			generatedInPos += inCur;
			generatedInProcessed += inCur;
			inStreamProcessed += inCur;
			generatedOutProcessed += outCur;
			outSize += outCur;
			size -= outCur;
			data += outCur;
			if (res != 0) {
				return res/*
				    if (status == LZMA_STATUS_FINISHED_WITH_MARK)
				      return readRes;
				
				    if (size == 0 && status != LZMA_STATUS_NEEDS_MORE_INPUT)
				    {
				      if (p->finishMode && p->outSize_Defined && p->outProcessed >= p->outSize)
				        return SZ_ERROR_DATA;
				      return readRes;
				    }
				    */;
			} 
			if (inCur == 0 && outCur == 0) {
				return readRes;
			} 
		}
	}
	/*
	*  xxHash - Fast Hash algorithm
	*  Copyright (C) 2012-2016, Yann Collet
	*
	*  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
	*
	*  Redistribution and use in source and binary forms, with or without
	*  modification, are permitted provided that the following conditions are
	*  met:
	*
	*  * Redistributions of source code must retain the above copyright
	*  notice, this list of conditions and the following disclaimer.
	*  * Redistributions in binary form must reproduce the above
	*  copyright notice, this list of conditions and the following disclaimer
	*  in the documentation and/or other materials provided with the
	*  distribution.
	*
	*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*  You can contact the author at :
	*  - xxHash homepage: http://www.xxhash.com
	*  - xxHash source repository : https://github.com/Cyan4973/xxHash
	*/
	/* *************************************
	*  Tuning parameters
	***************************************/
	/*!XXH_FORCE_MEMORY_ACCESS :
	 * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
	 * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
	 * The below switch allow to select different access method for improved performance.
	 * Method 0 (default) : use `memcpy()`. Safe and portable.
	 * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
	 *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
	 * Method 2 : direct access. This method doesn't depend on compiler but violate C standard.
	 *            It can generate buggy code on targets which do not support unaligned memory accesses.
	 *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
	 * See http://stackoverflow.com/a/32095106/646947 for details.
	 * Prefer these methods in priority order (0 > 1 > 2)
	 */
	/* can be defined externally, on command line for example */
	/*!XXH_ACCEPT_NULL_INPUT_POINTER :
	 * If input pointer is NULL, xxHash default behavior is to dereference it, triggering a segfault.
	 * When this macro is enabled, xxHash actively checks input for null pointer.
	 * It it is, result for null input pointers is the same as a null-length input.
	 */
	/* can be defined externally */
	/*!XXH_FORCE_NATIVE_FORMAT :
	 * By default, xxHash library provides endian-independent Hash values, based on little-endian convention.
	 * Results are therefore identical for little-endian and big-endian CPU.
	 * This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format.
	 * Should endian-independence be of no importance for your application, you may set the #define below to 1,
	 * to improve speed for Big-endian CPU.
	 * This option has no impact on Little_Endian CPU.
	 */
	/* can be defined externally */
	/*!XXH_FORCE_ALIGN_CHECK :
	 * This is a minor performance trick, only useful with lots of very small keys.
	 * It means : check for aligned/unaligned input.
	 * The check costs one initial branch per hash;
	 * set it to 0 when the input is guaranteed to be aligned,
	 * or when alignment doesn't matter for performance.
	 */
	/* can be defined externally */
	public static Object XXH_malloc(Object s) {
		return .malloc(/* *************************************
		*  Includes & Memory related functions
		***************************************//*! Modify the local functions below should you wish to use some other memory routines
		*   for malloc(), free() */s);
	}
	public static void XXH_free(Object p) {
		.free(p/*! and for memcpy() */);
	}
	public static Object XXH_memcpy(Object dest, Object src, Object size) {
		return .memcpy(dest, src, size/* assert */);
	}
	/* *************************************
	*  Compiler Specific Options
	***************************************/
	/* Visual Studio */
	/* disable: C4127: conditional expression is constant */
	/* C99 */
	/* __STDC_VERSION__ */
	/* *************************************
	*  Basic Types
	***************************************/
	/* C99 */
	/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
	/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
	/* currently only defined for gcc and icc */
	/* portable and safe solution. Generally efficient.
	 * see : http://stackoverflow.com/a/32095106/646947
	 */
	public static Object XXH_read32(Object memPtr) {
		U32 val = new U32();
		.memcpy(val, memPtr, );
		return val/* XXH_FORCE_DIRECT_MEMORY_ACCESS */;/* ****************************************
		*  Compiler-specific Functions and Macros
		******************************************/
	}
	/* Note : although _rotl exists for minGW (GCC under windows), performance seems poor */
	public static int XXH_isLittleEndian() {
		Object one = {/* don't use static : performance detrimental  */1};
		return one.getC()[0];
	}
	/* ***************************
	*  Memory reads
	*****************************/
	public static Object XXH_readLE32_align(Object ptr,  endian,  align) {
		if (align == .XXH_unaligned) {
			return endian == .XXH_littleEndian ? ModernizedCProgram.XXH_read32(ptr) : .__builtin_bswap32(ModernizedCProgram.XXH_read32(ptr));
		} else {
				return endian == .XXH_littleEndian ? (U32)ptr : .__builtin_bswap32((U32)ptr);
		} 
	}
	public static Object XXH_readLE32(Object ptr,  endian) {
		return ModernizedCProgram.XXH_readLE32_align(ptr, endian, .XXH_unaligned);
	}
	public static Object XXH_readBE32(Object ptr) {
		return ModernizedCProgram.XXH_isLittleEndian() ? .__builtin_bswap32(ModernizedCProgram.XXH_read32(ptr)) : ModernizedCProgram.XXH_read32(ptr);
	}
	public static int XXH_versionNumber() {
		return (0 * 100 * 100 + 6 * 100 + /* *************************************
		*  Macros
		***************************************//* use after variable declarations */5);
	}
	public static Object XXH32_round(Object seed, Object input) {
		seed += input * ModernizedCProgram.PRIME32_2;
		seed = ((seed << 13) | (seed >> (32 - 13)));
		seed *= ModernizedCProgram.PRIME32_1;
		return seed;
	}
	/* mix all bits */
	public static Object XXH32_avalanche(Object h32) {
		h32 ^=  h32 >> 15;
		h32 *= ModernizedCProgram.PRIME32_2;
		h32 ^=  h32 >> 13;
		h32 *= ModernizedCProgram.PRIME32_3;
		h32 ^=  h32 >> 16;
		return (h32);
	}
	public static Object XXH32_finalize(Object h32, Object ptr, Object len,  endian,  align) {
		BYTE p = (BYTE)ptr;
		switch (len & /* or switch(bEnd - p) */15) {
		case 10:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * /* fallthrough */ModernizedCProgram.PRIME32_4;
				;
		case 14:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * ModernizedCProgram.PRIME32_4;
				;
		case 11:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * /* fallthrough */ModernizedCProgram.PRIME32_4;
				;
		case 0:
				return ModernizedCProgram.XXH32_avalanche(/* fallthrough */h32);
		case 2:
				h32 += (p) * ModernizedCProgram.PRIME32_5;
				p++;
				h32 = ((h32 << 11) | (h32 >> (32 - 11))) * /* fallthrough */ModernizedCProgram.PRIME32_1;
				;
		case 6:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * /* fallthrough */ModernizedCProgram.PRIME32_4;
				;
				h32 += (p) * ModernizedCProgram.PRIME32_5;
				p++;
				h32 = ((h32 << 11) | (h32 >> (32 - 11))) * ModernizedCProgram.PRIME32_1;
				;
				h32 += (p) * ModernizedCProgram.PRIME32_5;
				p++;
				h32 = ((h32 << 11) | (h32 >> (32 - 11))) * ModernizedCProgram.PRIME32_1;
				;
				return ModernizedCProgram.XXH32_avalanche(h32);
		case 15:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * ModernizedCProgram.PRIME32_4;
				;
		case 5:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * /* fallthrough */ModernizedCProgram.PRIME32_4;
				;
				h32 += (p) * ModernizedCProgram.PRIME32_5;
				p++;
				h32 = ((h32 << 11) | (h32 >> (32 - 11))) * ModernizedCProgram.PRIME32_1;
				;
				return ModernizedCProgram.XXH32_avalanche(h32);
		case 13:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * ModernizedCProgram.PRIME32_4;
				;
		case 7:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * /* fallthrough */ModernizedCProgram.PRIME32_4;
				;
		case 8:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * /* fallthrough */ModernizedCProgram.PRIME32_4;
				;
		case 4:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * /* fallthrough */ModernizedCProgram.PRIME32_4;
				;
				return ModernizedCProgram.XXH32_avalanche(h32);
		case 12:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * ModernizedCProgram.PRIME32_4;
				;
		case 9:
				h32 += ModernizedCProgram.XXH_readLE32_align(p, endian, align) * ModernizedCProgram.PRIME32_3;
				p += 4;
				h32 = ((h32 << 17) | (h32 >> (32 - 17))) * /* fallthrough */ModernizedCProgram.PRIME32_4;
				;
		case 3:
				h32 += (p) * ModernizedCProgram.PRIME32_5;
				p++;
				h32 = ((h32 << 11) | (h32 >> (32 - 11))) * /* fallthrough */ModernizedCProgram.PRIME32_1;
				;
		case 1:
				h32 += (p) * ModernizedCProgram.PRIME32_5;
				p++;
				h32 = ((h32 << 11) | (h32 >> (32 - 11))) * /* fallthrough */ModernizedCProgram.PRIME32_1;
				;
		}
		((false) ? (Object)0 : ._assert("0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\xxhash.c", 346));
		return /* reaching this point is deemed impossible */h32;
	}
	public static Object XXH32_endian_align(Object input, Object len, Object seed,  endian,  align) {
		BYTE p = (BYTE)input;
		BYTE bEnd = p + len;
		U32 h32 = new U32();
		if (len >= 16) {
			BYTE limit = bEnd - 15;
			U32 v1 = seed + ModernizedCProgram.PRIME32_1 + ModernizedCProgram.PRIME32_2;
			U32 v2 = seed + ModernizedCProgram.PRIME32_2;
			U32 v3 = seed + 0;
			U32 v4 = seed - ModernizedCProgram.PRIME32_1;
			do {
				v1 = ModernizedCProgram.XXH32_round(v1, ModernizedCProgram.XXH_readLE32_align(p, endian, align));
				p += 4;
				v2 = ModernizedCProgram.XXH32_round(v2, ModernizedCProgram.XXH_readLE32_align(p, endian, align));
				p += 4;
				v3 = ModernizedCProgram.XXH32_round(v3, ModernizedCProgram.XXH_readLE32_align(p, endian, align));
				p += 4;
				v4 = ModernizedCProgram.XXH32_round(v4, ModernizedCProgram.XXH_readLE32_align(p, endian, align));
				p += 4;
			} while (p < limit);
			h32 = ((v1 << 1) | (v1 >> (32 - 1))) + ((v2 << 7) | (v2 >> (32 - 7))) + ((v3 << 12) | (v3 >> (32 - 12))) + ((v4 << 18) | (v4 >> (32 - 18)));
		} else {
				h32 = seed + ModernizedCProgram.PRIME32_5;
		} 
		h32 += (U32)len;
		return ModernizedCProgram.XXH32_finalize(h32, p, len & 15, endian, align);
	}
	public static int XXH32(Object input, Object len, int seed) {
		XXH_endianess endian_detected = (XXH_endianess)ModernizedCProgram.XXH_isLittleEndian();
		if (0) {
			if ((((size_t)input) & 3) == /* Input is 4-bytes aligned, leverage the speed benefit */0) {
				if ((endian_detected == .XXH_littleEndian) || false) {
					return ModernizedCProgram.XXH32_endian_align(input, len, seed, .XXH_littleEndian, .XXH_aligned);
				} else {
						return ModernizedCProgram.XXH32_endian_align(input, len, seed, .XXH_bigEndian, .XXH_aligned);
				} 
			} 
		} 
		if ((endian_detected == .XXH_littleEndian) || false) {
			return ModernizedCProgram.XXH32_endian_align(input, len, seed, .XXH_littleEndian, .XXH_unaligned);
		} else {
				return ModernizedCProgram.XXH32_endian_align(input, len, seed, .XXH_bigEndian, .XXH_unaligned);
		} 
	}
	/* Simple version, good for code maintenance, but unfortunately slow for small inputs */
	/*======   Hash streaming   ======*/
	public static XXH32_state_s XXH32_createState() {
		return (XXH32_state_t)ModernizedCProgram.XXH_malloc();
	}
	public static  XXH32_freeState() {
		ModernizedCProgram.XXH_free(statePtr);
		return .XXH_OK;
	}
	public static void XXH32_copyState(Object srcState) {
		.memcpy(dstState, srcState, );
	}
	public static  XXH32_reset(int seed) {
		/* using a local state to memcpy() in order to avoid strict-aliasing warnings */XXH32_state_t state = new XXH32_state_t();
		.memset(state, 0, );
		state.setV1(seed + ModernizedCProgram.PRIME32_1 + ModernizedCProgram.PRIME32_2);
		state.setV2(seed + ModernizedCProgram.PRIME32_2);
		state.setV3(seed + 0);
		state.setV4(seed - ModernizedCProgram.PRIME32_1);
		Object generatedReserved = state.getReserved();
		.memcpy(statePtr, state,  - );
		return .XXH_OK;
	}
	public static  XXH32_update_endian(Object input, Object len,  endian) {
		BYTE p = (BYTE)input;
		BYTE bEnd = p + len;
		if (input == ((Object)0)) {
			return .XXH_ERROR;
		} 
		Object generatedTotal_len_32 = this.getTotal_len_32();
		generatedTotal_len_32 += (int)len;
		Object generatedLarge_len = this.getLarge_len();
		generatedLarge_len |=  (len >= 16) | (generatedTotal_len_32 >= 16);
		Object generatedMemsize = this.getMemsize();
		Object generatedMem32 = this.getMem32();
		if (generatedMemsize + len < /* fill in tmp buffer */16) {
			ModernizedCProgram.XXH_memcpy((BYTE)(generatedMem32) + generatedMemsize, input, len);
			generatedMemsize += (int)len;
			return .XXH_OK;
		} 
		Object generatedV1 = this.getV1();
		Object generatedV2 = this.getV2();
		Object generatedV3 = this.getV3();
		Object generatedV4 = this.getV4();
		if (generatedMemsize) {
			ModernizedCProgram.XXH_memcpy((BYTE)(generatedMem32) + generatedMemsize, input, 16 - generatedMemsize);
			{ 
				U32 p32 = generatedMem32;
				this.setV1(ModernizedCProgram.XXH32_round(generatedV1, ModernizedCProgram.XXH_readLE32(p32, endian)));
				p32++;
				this.setV2(ModernizedCProgram.XXH32_round(generatedV2, ModernizedCProgram.XXH_readLE32(p32, endian)));
				p32++;
				this.setV3(ModernizedCProgram.XXH32_round(generatedV3, ModernizedCProgram.XXH_readLE32(p32, endian)));
				p32++;
				this.setV4(ModernizedCProgram.XXH32_round(generatedV4, ModernizedCProgram.XXH_readLE32(p32, endian)));
			}
			p += 16 - generatedMemsize;
			this.setMemsize(0);
		} 
		if (p <= bEnd - 16) {
			BYTE limit = bEnd - 16;
			U32 v1 = generatedV1;
			U32 v2 = generatedV2;
			U32 v3 = generatedV3;
			U32 v4 = generatedV4;
			do {
				v1 = ModernizedCProgram.XXH32_round(v1, ModernizedCProgram.XXH_readLE32(p, endian));
				p += 4;
				v2 = ModernizedCProgram.XXH32_round(v2, ModernizedCProgram.XXH_readLE32(p, endian));
				p += 4;
				v3 = ModernizedCProgram.XXH32_round(v3, ModernizedCProgram.XXH_readLE32(p, endian));
				p += 4;
				v4 = ModernizedCProgram.XXH32_round(v4, ModernizedCProgram.XXH_readLE32(p, endian));
				p += 4;
			} while (p <= limit);
			this.setV1(v1);
			this.setV2(v2);
			this.setV3(v3);
			this.setV4(v4);
		} 
		if (p < bEnd) {
			ModernizedCProgram.XXH_memcpy(generatedMem32, p, (size_t)(bEnd - p));
			this.setMemsize((int)(bEnd - p));
		} 
		return .XXH_OK;
	}
	public static  XXH32_update(Object input, Object len) {
		XXH_endianess endian_detected = (XXH_endianess)ModernizedCProgram.XXH_isLittleEndian();
		if ((endian_detected == .XXH_littleEndian) || false) {
			return state_in.XXH32_update_endian(input, len, .XXH_littleEndian);
		} else {
				return state_in.XXH32_update_endian(input, len, .XXH_bigEndian);
		} 
	}
	public static Object XXH32_digest_endian(Object state,  endian) {
		U32 h32 = new U32();
		if (state.getLarge_len()) {
			h32 = ((state.getV1() << 1) | (state.getV1() >> (32 - 1))) + ((state.getV2() << 7) | (state.getV2() >> (32 - 7))) + ((state.getV3() << 12) | (state.getV3() >> (32 - 12))) + ((state.getV4() << 18) | (state.getV4() >> (32 - 18)));
		} else {
				h32 = state.getV3() + /* == seed */ModernizedCProgram.PRIME32_5;
		} 
		h32 += state.getTotal_len_32();
		return ModernizedCProgram.XXH32_finalize(h32, state.getMem32(), state.getMemsize(), endian, .XXH_aligned);
	}
	public static int XXH32_digest(Object state_in) {
		XXH_endianess endian_detected = (XXH_endianess)ModernizedCProgram.XXH_isLittleEndian();
		if ((endian_detected == .XXH_littleEndian) || false) {
			return ModernizedCProgram.XXH32_digest_endian(state_in, .XXH_littleEndian);
		} else {
				return ModernizedCProgram.XXH32_digest_endian(state_in, .XXH_bigEndian/*======   Canonical representation   ======*/);
		} 
	}
	/*! Default XXH result types are basic unsigned 32 and 64 bits.
	*   The canonical representation follows human-readable write convention, aka big-endian (large digits first).
	*   These functions allow transformation of hash result into and from its canonical format.
	*   This way, hash values can be written into a file or buffer, remaining comparable across different systems.
	*/
	public static void XXH32_canonicalFromHash(Object hash) {
		{ 
		}
		;
		if (ModernizedCProgram.XXH_isLittleEndian()) {
			hash = .__builtin_bswap32(hash);
		} 
		.memcpy(dst, hash, );
	}
	public static Object XXH32_hashFromCanonical(Object src) {
		return ModernizedCProgram.XXH_readBE32(src);/* *******************************************************************
		*  64-bit hash functions
		*********************************************************************//* *******************************************************************
		*  64-bit hash functions
		*********************************************************************/
	}
	/*======   Memory access   ======*/
	/*======   Memory access   ======*/
	/* C99 */
	/* if compiler doesn't support unsigned long long, replace by another 64-bit type */
	/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
	/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
	/* currently only defined for gcc and icc */
	/* portable and safe solution. Generally efficient.
	 * see : http://stackoverflow.com/a/32095106/646947
	 */
	public static Object XXH_read64(Object memPtr) {
		U64 val = new U64();
		.memcpy(val, memPtr, );
		return val/* XXH_FORCE_DIRECT_MEMORY_ACCESS *//* Visual Studio */;
	}
	public static Object XXH_readLE64_align(Object ptr,  endian,  align) {
		if (align == .XXH_unaligned) {
			return endian == .XXH_littleEndian ? ModernizedCProgram.XXH_read64(ptr) : .__builtin_bswap64(ModernizedCProgram.XXH_read64(ptr));
		} else {
				return endian == .XXH_littleEndian ? (U64)ptr : .__builtin_bswap64((U64)ptr);
		} 
	}
	public static Object XXH_readLE64(Object ptr,  endian) {
		return ModernizedCProgram.XXH_readLE64_align(ptr, endian, .XXH_unaligned);
	}
	public static Object XXH_readBE64(Object ptr) {
		return ModernizedCProgram.XXH_isLittleEndian() ? .__builtin_bswap64(ModernizedCProgram.XXH_read64(ptr)) : ModernizedCProgram.XXH_read64(ptr);
	}
	public static Object XXH64_round(Object acc, Object input) {
		acc += input * ModernizedCProgram.PRIME64_2;
		acc = ((acc << 31) | (acc >> (64 - 31)));
		acc *= ModernizedCProgram.PRIME64_1;
		return acc;
	}
	public static Object XXH64_mergeRound(Object acc, Object val) {
		val = ModernizedCProgram.XXH64_round(0, val);
		acc ^=  val;
		acc = acc * ModernizedCProgram.PRIME64_1 + ModernizedCProgram.PRIME64_4;
		return acc;
	}
	public static Object XXH64_avalanche(Object h64) {
		h64 ^=  h64 >> 33;
		h64 *= ModernizedCProgram.PRIME64_2;
		h64 ^=  h64 >> 29;
		h64 *= ModernizedCProgram.PRIME64_3;
		h64 ^=  h64 >> 32;
		return h64;
	}
	public static Object XXH64_finalize(Object h64, Object ptr, Object len,  endian,  align) {
		BYTE p = (BYTE)ptr;
		switch (len & 31) {
		case 2:
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * /* fallthrough */ModernizedCProgram.PRIME64_1;
				;
		case 8:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
				return ModernizedCProgram.XXH64_avalanche(h64);
		case 31:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + ModernizedCProgram.PRIME64_4;
				}
				;
		case 3:
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * /* fallthrough */ModernizedCProgram.PRIME64_1;
				;
		case 20:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		case 17:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		case 23:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		case 26:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + ModernizedCProgram.PRIME64_4;
				}
				;
		case 29:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + ModernizedCProgram.PRIME64_4;
				}
				;
		case 25:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + ModernizedCProgram.PRIME64_4;
				}
				;
		case 7:
				h64 ^=  (U64)(ModernizedCProgram.XXH_readLE32_align(p, endian, align)) * ModernizedCProgram.PRIME64_1;
				p += 4;
				h64 = ((h64 << 23) | (h64 >> (64 - 23))) * ModernizedCProgram.PRIME64_2 + /* fallthrough */ModernizedCProgram.PRIME64_3;
				;
		case 9:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * ModernizedCProgram.PRIME64_1;
				;
				return ModernizedCProgram.XXH64_avalanche(h64);
		case 11:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * ModernizedCProgram.PRIME64_1;
				;
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * ModernizedCProgram.PRIME64_1;
				;
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * ModernizedCProgram.PRIME64_1;
				;
				return ModernizedCProgram.XXH64_avalanche(h64);
		case 0:
				return ModernizedCProgram.XXH64_avalanche(/* fallthrough */h64);
		case 18:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		case 27:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + ModernizedCProgram.PRIME64_4;
				}
				;
		case 4:
				h64 ^=  (U64)(ModernizedCProgram.XXH_readLE32_align(p, endian, align)) * ModernizedCProgram.PRIME64_1;
				p += 4;
				h64 = ((h64 << 23) | (h64 >> (64 - 23))) * ModernizedCProgram.PRIME64_2 + /* fallthrough */ModernizedCProgram.PRIME64_3;
				;
				return ModernizedCProgram.XXH64_avalanche(h64);
		case 22:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		case 24:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + ModernizedCProgram.PRIME64_4;
				}
				;
		case 13:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		case 21:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		case 10:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * ModernizedCProgram.PRIME64_1;
				;
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * ModernizedCProgram.PRIME64_1;
				;
				return ModernizedCProgram.XXH64_avalanche(h64);
		case 14:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		case 15:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		case 5:
				h64 ^=  (U64)(ModernizedCProgram.XXH_readLE32_align(p, endian, align)) * ModernizedCProgram.PRIME64_1;
				p += 4;
				h64 = ((h64 << 23) | (h64 >> (64 - 23))) * ModernizedCProgram.PRIME64_2 + /* fallthrough */ModernizedCProgram.PRIME64_3;
				;
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * ModernizedCProgram.PRIME64_1;
				;
				return ModernizedCProgram.XXH64_avalanche(h64);
		case 30:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + ModernizedCProgram.PRIME64_4;
				}
				;
		case 16:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		case 6:
				h64 ^=  (U64)(ModernizedCProgram.XXH_readLE32_align(p, endian, align)) * ModernizedCProgram.PRIME64_1;
				p += 4;
				h64 = ((h64 << 23) | (h64 >> (64 - 23))) * ModernizedCProgram.PRIME64_2 + /* fallthrough */ModernizedCProgram.PRIME64_3;
				;
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * ModernizedCProgram.PRIME64_1;
				;
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * ModernizedCProgram.PRIME64_1;
				;
				return ModernizedCProgram.XXH64_avalanche(h64);
		case 12:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		case 28:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + ModernizedCProgram.PRIME64_4;
				}
				;
		case 1:
				h64 ^=  (p) * ModernizedCProgram.PRIME64_5;
				p++;
				h64 = ((h64 << 11) | (h64 >> (64 - 11))) * /* fallthrough */ModernizedCProgram.PRIME64_1;
				;
		case 19:
				{ 
					U64 k1 = ModernizedCProgram.XXH64_round(0, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
					p += 8;
					h64 ^=  k1;
					h64 = ((h64 << 27) | (h64 >> (64 - 27))) * ModernizedCProgram.PRIME64_1 + /* fallthrough */ModernizedCProgram.PRIME64_4;
				}
				;
		}
		((false) ? (Object)0 : ._assert("0", "E:\\Programfiles\\Eclipse\\Workspaces\\runtime-EclipseApplication\\Hashcat\\src\\xxhash.c", /* impossible to reach */806));
		return /* unreachable, but some compilers complain without it */0;
	}
	public static Object XXH64_endian_align(Object input, Object len, Object seed,  endian,  align) {
		BYTE p = (BYTE)input;
		BYTE bEnd = p + len;
		U64 h64 = new U64();
		if (len >= 32) {
			BYTE limit = bEnd - 32;
			U64 v1 = seed + ModernizedCProgram.PRIME64_1 + ModernizedCProgram.PRIME64_2;
			U64 v2 = seed + ModernizedCProgram.PRIME64_2;
			U64 v3 = seed + 0;
			U64 v4 = seed - ModernizedCProgram.PRIME64_1;
			do {
				v1 = ModernizedCProgram.XXH64_round(v1, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
				p += 8;
				v2 = ModernizedCProgram.XXH64_round(v2, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
				p += 8;
				v3 = ModernizedCProgram.XXH64_round(v3, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
				p += 8;
				v4 = ModernizedCProgram.XXH64_round(v4, ModernizedCProgram.XXH_readLE64_align(p, endian, align));
				p += 8;
			} while (p <= limit);
			h64 = ((v1 << 1) | (v1 >> (64 - 1))) + ((v2 << 7) | (v2 >> (64 - 7))) + ((v3 << 12) | (v3 >> (64 - 12))) + ((v4 << 18) | (v4 >> (64 - 18)));
			h64 = ModernizedCProgram.XXH64_mergeRound(h64, v1);
			h64 = ModernizedCProgram.XXH64_mergeRound(h64, v2);
			h64 = ModernizedCProgram.XXH64_mergeRound(h64, v3);
			h64 = ModernizedCProgram.XXH64_mergeRound(h64, v4);
		} else {
				h64 = seed + ModernizedCProgram.PRIME64_5;
		} 
		h64 += (U64)len;
		return ModernizedCProgram.XXH64_finalize(h64, p, len, endian, align);
	}
	public static int XXH64(Object input, Object len, int seed) {
		XXH_endianess endian_detected = (XXH_endianess)ModernizedCProgram.XXH_isLittleEndian();
		if (0) {
			if ((((size_t)input) & 7) == /* Input is aligned, let's leverage the speed advantage */0) {
				if ((endian_detected == .XXH_littleEndian) || false) {
					return ModernizedCProgram.XXH64_endian_align(input, len, seed, .XXH_littleEndian, .XXH_aligned);
				} else {
						return ModernizedCProgram.XXH64_endian_align(input, len, seed, .XXH_bigEndian, .XXH_aligned);
				} 
			} 
		} 
		if ((endian_detected == .XXH_littleEndian) || false) {
			return ModernizedCProgram.XXH64_endian_align(input, len, seed, .XXH_littleEndian, .XXH_unaligned);
		} else {
				return ModernizedCProgram.XXH64_endian_align(input, len, seed, .XXH_bigEndian, .XXH_unaligned);
		} 
	}
	/* Simple version, good for code maintenance, but unfortunately slow for small inputs */
	/*======   Hash Streaming   ======*/
	public static XXH64_state_s XXH64_createState() {
		return (XXH64_state_t)ModernizedCProgram.XXH_malloc();
	}
	public static  XXH64_freeState() {
		ModernizedCProgram.XXH_free(statePtr);
		return .XXH_OK;
	}
	public static void XXH64_copyState(Object srcState) {
		.memcpy(dstState, srcState, );
	}
	public static  XXH64_reset(int seed) {
		/* using a local state to memcpy() in order to avoid strict-aliasing warnings */XXH64_state_t state = new XXH64_state_t();
		.memset(state, 0, );
		state.setV1(seed + ModernizedCProgram.PRIME64_1 + ModernizedCProgram.PRIME64_2);
		state.setV2(seed + ModernizedCProgram.PRIME64_2);
		state.setV3(seed + 0);
		state.setV4(seed - ModernizedCProgram.PRIME64_1);
		Object generatedReserved = state.getReserved();
		.memcpy(statePtr, state,  - );
		return .XXH_OK;
	}
	public static  XXH64_update_endian(Object input, Object len,  endian) {
		BYTE p = (BYTE)input;
		BYTE bEnd = p + len;
		if (input == ((Object)0)) {
			return .XXH_ERROR;
		} 
		Object generatedTotal_len = this.getTotal_len();
		generatedTotal_len += len;
		Object generatedMemsize = this.getMemsize();
		Object generatedMem64 = this.getMem64();
		if (generatedMemsize + len < /* fill in tmp buffer */32) {
			ModernizedCProgram.XXH_memcpy(((BYTE)generatedMem64) + generatedMemsize, input, len);
			generatedMemsize += (U32)len;
			return .XXH_OK;
		} 
		Object generatedV1 = this.getV1();
		Object generatedV2 = this.getV2();
		Object generatedV3 = this.getV3();
		Object generatedV4 = this.getV4();
		if (generatedMemsize) {
			ModernizedCProgram.XXH_memcpy(((BYTE)generatedMem64) + generatedMemsize, input, 32 - generatedMemsize);
			this.setV1(ModernizedCProgram.XXH64_round(generatedV1, ModernizedCProgram.XXH_readLE64(generatedMem64 + 0, endian)));
			this.setV2(ModernizedCProgram.XXH64_round(generatedV2, ModernizedCProgram.XXH_readLE64(generatedMem64 + 1, endian)));
			this.setV3(ModernizedCProgram.XXH64_round(generatedV3, ModernizedCProgram.XXH_readLE64(generatedMem64 + 2, endian)));
			this.setV4(ModernizedCProgram.XXH64_round(generatedV4, ModernizedCProgram.XXH_readLE64(generatedMem64 + 3, endian)));
			p += 32 - generatedMemsize;
			this.setMemsize(0);
		} 
		if (p + 32 <= bEnd) {
			BYTE limit = bEnd - 32;
			U64 v1 = generatedV1;
			U64 v2 = generatedV2;
			U64 v3 = generatedV3;
			U64 v4 = generatedV4;
			do {
				v1 = ModernizedCProgram.XXH64_round(v1, ModernizedCProgram.XXH_readLE64(p, endian));
				p += 8;
				v2 = ModernizedCProgram.XXH64_round(v2, ModernizedCProgram.XXH_readLE64(p, endian));
				p += 8;
				v3 = ModernizedCProgram.XXH64_round(v3, ModernizedCProgram.XXH_readLE64(p, endian));
				p += 8;
				v4 = ModernizedCProgram.XXH64_round(v4, ModernizedCProgram.XXH_readLE64(p, endian));
				p += 8;
			} while (p <= limit);
			this.setV1(v1);
			this.setV2(v2);
			this.setV3(v3);
			this.setV4(v4);
		} 
		if (p < bEnd) {
			ModernizedCProgram.XXH_memcpy(generatedMem64, p, (size_t)(bEnd - p));
			this.setMemsize((int)(bEnd - p));
		} 
		return .XXH_OK;
	}
	public static  XXH64_update(Object input, Object len) {
		XXH_endianess endian_detected = (XXH_endianess)ModernizedCProgram.XXH_isLittleEndian();
		if ((endian_detected == .XXH_littleEndian) || false) {
			return state_in.XXH64_update_endian(input, len, .XXH_littleEndian);
		} else {
				return state_in.XXH64_update_endian(input, len, .XXH_bigEndian);
		} 
	}
	public static Object XXH64_digest_endian(Object state,  endian) {
		U64 h64 = new U64();
		if (state.getTotal_len() >= 32) {
			U64 v1 = state.getV1();
			U64 v2 = state.getV2();
			U64 v3 = state.getV3();
			U64 v4 = state.getV4();
			h64 = ((v1 << 1) | (v1 >> (64 - 1))) + ((v2 << 7) | (v2 >> (64 - 7))) + ((v3 << 12) | (v3 >> (64 - 12))) + ((v4 << 18) | (v4 >> (64 - 18)));
			h64 = ModernizedCProgram.XXH64_mergeRound(h64, v1);
			h64 = ModernizedCProgram.XXH64_mergeRound(h64, v2);
			h64 = ModernizedCProgram.XXH64_mergeRound(h64, v3);
			h64 = ModernizedCProgram.XXH64_mergeRound(h64, v4);
		} else {
				h64 = state.getV3() + /*seed*/ModernizedCProgram.PRIME64_5;
		} 
		h64 += (U64)state.getTotal_len();
		return ModernizedCProgram.XXH64_finalize(h64, state.getMem64(), (size_t)state.getTotal_len(), endian, .XXH_aligned);
	}
	public static int XXH64_digest(Object state_in) {
		XXH_endianess endian_detected = (XXH_endianess)ModernizedCProgram.XXH_isLittleEndian();
		if ((endian_detected == .XXH_littleEndian) || false) {
			return ModernizedCProgram.XXH64_digest_endian(state_in, .XXH_littleEndian);
		} else {
				return ModernizedCProgram.XXH64_digest_endian(state_in, .XXH_bigEndian);
		} 
	}
	/*====== Canonical representation   ======*/
	public static void XXH64_canonicalFromHash(Object hash) {
		{ 
		}
		;
		if (ModernizedCProgram.XXH_isLittleEndian()) {
			hash = .__builtin_bswap64(hash);
		} 
		.memcpy(dst, hash, );
	}
	public static Object XXH64_hashFromCanonical(Object src) {
		return ModernizedCProgram.XXH_readBE64(src/* XXH_NO_LONG_LONG */);
	}
	public static void Print(Object s) {
		.fputs(s, (_iob[1]));
	}
	public static int Buf_EnsureSize(Object size) {
		Object generatedSize = this.getSize();
		if (generatedSize >= size) {
			return 1;
		} 
		dest.Buf_Free(ModernizedCProgram.g_Alloc);
		return dest.Buf_Create(size, ModernizedCProgram.g_Alloc);
	}
	/* #define _USE_UTF8 */
	public static Object Utf16_To_Char(Object s, Object codePage) {
		int len = 0;
		for (len = 0; s[len] != 0; len++) {
			;
		}
		Object generatedData = this.getData();
		{ 
			int size = len * 3 + 100;
			if (!buf.Buf_EnsureSize(ModernizedCProgram.size)) {
				return 2;
			} 
			{ 
				generatedData[0] = 0;
				if (len != 0) {
					byte defaultChar = (byte)'_';
					BOOL defUsed = new BOOL();
					int numChars = 0;
					numChars = .WideCharToMultiByte(codePage, 0, (LPCWSTR)s, len, (byte)generatedData, ModernizedCProgram.size, defaultChar, defUsed);
					if (numChars == 0 || numChars >= ModernizedCProgram.size) {
						return 11;
					} 
					generatedData[numChars] = 0;
				} 
				return 0;
			}
		}
	}
	public static Object OutFile_OpenUtf16(Object name) {
		return p.OutFile_OpenW((LPCWSTR)name);
	}
	public static Object PrintString(Object s) {
		CBuf buf = new CBuf();
		SRes res = new SRes();
		buf.Buf_Init();
		res = buf.Utf16_To_Char(s, 1);
		Object generatedData = buf.getData();
		if (res == 0) {
			ModernizedCProgram.Print((byte)generatedData);
		} 
		buf.Buf_Free(ModernizedCProgram.g_Alloc);
		return res;
	}
	public static void UInt64ToStr(Object value, byte s, int numDigits) {
		byte[] temp = new byte[32];
		int pos = 0;
		do {
			temp[pos++] = (byte)((byte)'0' + (int)(value % 10));
			value /= 10;
		} while (value != 0);
		for (numDigits -= pos; numDigits > 0; numDigits--) {
			s++ = (byte)' ';
		}
		do {
			s++ = temp[--pos];
		} while (pos);
		s = (byte)'\0';
	}
	public static Byte UIntToStr(byte s, int value, int numDigits) {
		byte[] temp = new byte[16];
		int pos = 0;
		do {
			temp[pos++] = (byte)((byte)'0' + (value % 10));
		} while (value /= 10);
		for (numDigits -= pos; numDigits > 0; numDigits--) {
			s++ = (byte)'0';
		}
		do {
			s++ = temp[--pos];
		} while (pos);
		s = (byte)'\0';
		return s;
	}
	public static void UIntToStr_2(Byte s, int value) {
		s[0] = (byte)((byte)'0' + (value / 10));
		s[1] = (byte)((byte)'0' + (value % 10));
	}
	public static void ConvertFileTimeToString(Object nt, byte s) {
		int year;
		int mon;
		int hour;
		int min;
		int sec;
		Byte[] ms = new Byte[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		int t;
		UInt32 v = new UInt32();
		UInt64 v64 = nt.getLow() | ((UInt64)nt.getHigh() << 32);
		v64 /= 10000000;
		sec = (int)(v64 % 60);
		v64 /= 60;
		min = (int)(v64 % 60);
		v64 /= 60;
		hour = (int)(v64 % 24);
		v64 /= 24;
		v = (UInt32)v64;
		year = (int)(1601 + v / (((4 * 365 + 1) * 25 - 1) * 4 + 1) * 400);
		v %= (((4 * 365 + 1) * 25 - 1) * 4 + 1);
		t = v / ((4 * 365 + 1) * 25 - 1);
		if (t == 4) {
			t = 3;
		} 
		year += t * 100;
		v -= t * ((4 * 365 + 1) * 25 - 1);
		t = v / (4 * 365 + 1);
		if (t == 25) {
			t = 24;
		} 
		year += t * 4;
		v -= t * (4 * 365 + 1);
		t = v / 365;
		if (t == 4) {
			t = 3;
		} 
		year += t;
		v -= t * 365;
		if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {
			ms[1] = 29;
		} 
		for (mon = 0; ; mon++) {
			int d = ms[mon];
			if (v < d) {
				break;
			} 
			v -= d;
		}
		s = ModernizedCProgram.UIntToStr(s, year, 4);
		s++ = (byte)'-';
		ModernizedCProgram.UIntToStr_2(s, mon + 1);
		s[2] = (byte)'-';
		s += 3;
		ModernizedCProgram.UIntToStr_2(s, (int)v + 1);
		s[2] = (byte)' ';
		s += 3;
		ModernizedCProgram.UIntToStr_2(s, hour);
		s[2] = (byte)':';
		s += 3;
		ModernizedCProgram.UIntToStr_2(s, min);
		s[2] = (byte)':';
		s += 3;
		ModernizedCProgram.UIntToStr_2(s, sec);
		s[2] = 0;
	}
	public static void PrintLF() {
		ModernizedCProgram.Print("\n");
	}
	public static void GetAttribString(Object wa, Object isDir, Byte s) {
		s[0] = (byte)(((wa & -1024) != 0 || isDir) ? (byte)'D' : (byte)'.');
		s[1] = (byte)(((wa & -1024) != 0) ? (byte)'R' : (byte)'.');
		s[2] = (byte)(((wa & -1024) != 0) ? (byte)'H' : (byte)'.');
		s[3] = (byte)(((wa & -1024) != 0) ? (byte)'S' : (byte)'.');
		s[4] = (byte)(((wa & -1024) != 0) ? (byte)'A' : (byte)'.');
		s[5] = 0;
	}
	/* MtDec.c -- Multi-thread Decoder
	2019-02-02 : Igor Pavlov : Public domain */
	// #define SHOW_DEBUG_INFO
	// #include <stdio.h>
	public static void MtProgress_Init( p, ICompressProgress progress) {
		p.setProgress(progress);
		p.setRes(0);
		p.setTotalInSize(0);
		p.setTotalOutSize(0);
	}
	public static Object MtProgress_Progress_ST() {
		Object generatedRes = this.getRes();
		Object generatedProgress = this.getProgress();
		Object generatedTotalInSize = this.getTotalInSize();
		Object generatedTotalOutSize = this.getTotalOutSize();
		if (generatedRes == 0 && generatedProgress) {
			if (.UNRECOGNIZEDFUNCTIONNAME(generatedProgress, generatedTotalInSize, generatedTotalOutSize) != 0) {
				this.setRes(10);
			} 
		} 
		return generatedRes;
	}
	public static Object MtProgress_ProgressAdd(Object inSize, Object outSize) {
		SRes res = new SRes();
		Object generatedCs = this.getCs();
		.EnterCriticalSection(generatedCs);
		Object generatedTotalInSize = this.getTotalInSize();
		generatedTotalInSize += inSize;
		Object generatedTotalOutSize = this.getTotalOutSize();
		generatedTotalOutSize += outSize;
		Object generatedRes = this.getRes();
		Object generatedProgress = this.getProgress();
		if (generatedRes == 0 && generatedProgress) {
			if (.UNRECOGNIZEDFUNCTIONNAME(generatedProgress, generatedTotalInSize, generatedTotalOutSize) != 0) {
				this.setRes(10);
			} 
		} 
		res = generatedRes;
		.LeaveCriticalSection(generatedCs);
		return res;
	}
	public static Object MtProgress_GetError() {
		SRes res = new SRes();
		Object generatedCs = this.getCs();
		.EnterCriticalSection(generatedCs);
		Object generatedRes = this.getRes();
		res = generatedRes;
		.LeaveCriticalSection(generatedCs);
		return res;
	}
	public static void MtProgress_SetError(Object res) {
		Object generatedCs = this.getCs();
		.EnterCriticalSection(generatedCs);
		Object generatedRes = this.getRes();
		if (generatedRes == 0) {
			this.setRes(res);
		} 
		.LeaveCriticalSection(generatedCs);
	}
	public static Object MtDecThread_CreateEvents() {
		Object generatedCanWrite = this.getCanWrite();
		WRes wres = ModernizedCProgram.ArEvent_OptCreate_And_Reset(generatedCanWrite);
		Object generatedCanRead = this.getCanRead();
		if (wres == 0) {
			wres = ModernizedCProgram.ArEvent_OptCreate_And_Reset(generatedCanRead);
			if (wres == 0) {
				return 0;
			} 
		} 
		return wres;
	}
	public static Object MtDecThread_CreateAndStart() {
		WRes wres = t.MtDecThread_CreateEvents();
		// wres = 17; // for test
		Object generatedThread = this.getThread();
		if (wres == 0) {
			if (((generatedThread) != ((Object)0))) {
				return 0;
			} 
			wres = ModernizedCProgram.Thread_Create(generatedThread, ModernizedCProgram.ThreadFunc, t);
			if (wres == 0) {
				return 0;
			} 
		} 
		return (wres ? ((HRESULT)(((wres) & -1024) | (7 << 16) | -1024)) : 0);
	}
	public static void MtDecThread_FreeInBufs() {
		Object generatedInBuf = this.getInBuf();
		Object generatedMtDec = this.getMtDec();
		if (generatedInBuf) {
			Object link = generatedInBuf;
			this.setInBuf(((Object)0));
			do {
				Object next = ((CMtDecBufLink)link).getNext();
				.UNRECOGNIZEDFUNCTIONNAME(generatedMtDec.getAlloc(), link);
				link = next;
			} while (link);
		} 
	}
	public static void MtDecThread_CloseThread() {
		Object generatedThread = this.getThread();
		Object generatedCanWrite = this.getCanWrite();
		Object generatedCanRead = this.getCanRead();
		if (((generatedThread) != ((Object)0))) {
			ModernizedCProgram.Event_Set(generatedCanWrite);
			ModernizedCProgram.Event_Set(generatedCanRead);
			ModernizedCProgram.Handle_WaitObject((generatedThread));
			ModernizedCProgram.HandlePtr_Close(generatedThread);
		} 
		ModernizedCProgram.HandlePtr_Close(generatedCanRead);
		ModernizedCProgram.HandlePtr_Close(generatedCanWrite);
	}
	public static void MtDecThread_Destruct() {
		t.MtDecThread_CloseThread();
		t.MtDecThread_FreeInBufs();
	}
	public static Object ThreadFunc1(Object pp) {
		WRes res = new WRes();
		CMtDecThread t = (CMtDecThread)pp;
		CMtDec p = new CMtDec();
		// fprintf(stdout, "\n%d = %p\n", t->index, &t);
		res = t.ThreadFunc2();
		Object generatedMtDec = t.getMtDec();
		p = generatedMtDec;
		Object generatedExitThreadWRes = p.getExitThreadWRes();
		if (res == 0) {
			return generatedExitThreadWRes;
		} 
		Object generatedThreads = p.getThreads();
		 generatedMtProgress = p.getMtProgress();
		{ 
			if (generatedExitThreadWRes == 0) {
				p.setExitThreadWRes(res);
			} 
			;
			p.setExitThread(1);
			ModernizedCProgram.Event_Set(generatedThreads[0].getCanRead());
			ModernizedCProgram.Event_Set(generatedThreads[0].getCanWrite());
			generatedMtProgress.MtProgress_SetError((res ? ((HRESULT)(((res) & -1024) | (7 << 16) | -1024)) : 0));
		}
		return res;
	}
	public static int inflateBackInit_(Object strm, int windowBits, Byte window, Object version, int stream_size) {
		inflate_state state = new inflate_state();
		if (version == 0 || version[0] != "1.2.11"[0] || stream_size != (int)()) {
			return (true);
		} 
		if (strm == 0 || window == 0 || windowBits < 8 || windowBits > 15) {
			return (true);
		} 
		strm.setMsg(/* in case we return an error */0);
		if (strm.getZalloc() == (alloc_func)0) {
			strm.setZalloc(ModernizedCProgram.zcalloc);
			strm.setOpaque((voidpf)0);
		} 
		if (strm.getZfree() == (free_func)0) {
			strm.setZfree(ModernizedCProgram.zcfree);
		} 
		state = (inflate_state).UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (true), ());
		if (state == 0) {
			return (true);
		} 
		;
		strm.setState((internal_state)state);
		state.setDmax(-1024);
		state.setWbits((uInt)windowBits);
		state.setWsize(-1024 << windowBits);
		state.setWindow(window);
		state.setWnext(0);
		state.setWhave(0);
		return 0/*
		   Return state with length and distance decoding tables and index sizes set to
		   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
		   If BUILDFIXED is defined, then instead this routine builds the tables the
		   first time it's called, and returns those tables the first time and
		   thereafter.  This reduces the size of the code by about 2K bytes, in
		   exchange for a little execution time.  However, BUILDFIXED should not be
		   used for threaded applications, since the rewriting of the tables and virgin
		   may not be thread-safe.
		 */;
	}
	/* Get a byte of input into the bit accumulator, or return from inflateBack()
	   with an error if there is no input available. */
	/* Assure that there are at least n bits in the bit accumulator.  If there is
	   not enough available input to do that, then return from inflateBack() with
	   an error. */
	/* Return the low n bits of the bit accumulator (n < 16) */
	/* Remove n bits from the bit accumulator */
	/* Remove zero to seven bits as needed to go to a byte boundary */
	/* Assure that some output space is available, by writing out the window
	   if it's full.  If the write fails, return from inflateBack() with a
	   Z_BUF_ERROR. */
	/*
	   strm provides the memory allocation functions and window buffer on input,
	   and provides information on the unused input on return.  For Z_DATA_ERROR
	   returns, strm will also provide an error message.
	
	   in() and out() are the call-back input and output functions.  When
	   inflateBack() needs more input, it calls in().  When inflateBack() has
	   filled the window with output, or when it completes with data in the
	   window, it calls out() to write out the data.  The application must not
	   change the provided input until in() is called again or inflateBack()
	   returns.  The application must not change the window/output buffer until
	   inflateBack() returns.
	
	   in() and out() are called with a descriptor parameter provided in the
	   inflateBack() call.  This parameter can be a structure that provides the
	   information required to do the read or write, as well as accumulated
	   information on the input and output such as totals and check values.
	
	   in() should return zero on failure.  out() should return non-zero on
	   failure.  If either in() or out() fails, than inflateBack() returns a
	   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
	   was in() or out() that caused in the error.  Otherwise,  inflateBack()
	   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
	   error, or Z_MEM_ERROR if it could not allocate memory for the state.
	   inflateBack() can also return Z_STREAM_ERROR if the input parameters
	   are not correct, i.e. strm is Z_NULL or the state was not initialized.
	 */
	public static int inflateBack(Object strm, Object in, Object in_desc, Object out, Object out_desc) {
		inflate_state state = new inflate_state();
		/* next input */byte next;
		/* next output */byte put;
		/* available input and output */int have;
		int left;
		/* bit buffer */long hold;
		/* bits in bit buffer */int bits;
		/* number of stored or match bytes to copy */int copy;
		/* where to copy match bytes from */byte from;
		/* current decoding table entry */code here = new code();
		/* parent table entry */code last = new code();
		/* length to copy for repeats, bits to drop */int len;
		/* return code */int ret;
		int[] order = new int[]{16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
		if (strm == 0 || strm.getState() == /* Check that the strm exists and that the state was initialized */0) {
			return (true);
		} 
		state = (inflate_state)strm.getState();
		strm.setMsg(/* Reset the state */0);
		state.setMode(.TYPE);
		state.setLast(0);
		state.setWhave(0);
		next = strm.getNext_in();
		have = next != 0 ? strm.getAvail_in() : 0;
		hold = 0;
		bits = 0;
		Object generatedWindow = state.getWindow();
		put = generatedWindow;
		Object generatedWsize = state.getWsize();
		left = generatedWsize;
		Object generatedLast = state.getLast();
		Object generatedLength = state.getLength();
		int generatedNlen = state.getNlen();
		int generatedNdist = state.getNdist();
		int generatedHave = state.getHave();
		int generatedNcode = state.getNcode();
		Object generatedLens = state.getLens();
		Object generatedCodes = state.getCodes();
		Object generatedNext = state.getNext();
		Object generatedLenbits = state.getLenbits();
		Object generatedWork = state.getWork();
		Object generatedLencode = state.getLencode();
		Object generatedBits = here.getBits();
		Object generatedVal = here.getVal();
		Object generatedMode = state.getMode();
		Object generatedDistbits = state.getDistbits();
		Object generatedWhave = state.getWhave();
		Object generatedHold = state.getHold();
		Object generatedOp = here.getOp();
		Object generatedExtra = state.getExtra();
		Object generatedDistcode = state.getDistcode();
		Object generatedOffset = state.getOffset();
		/* Inflate until end of block marked as last */for (; ; ) {
			switch (generatedMode) {
			case .TYPE:
					if (generatedLast) {
						do {
							hold >>=  bits & 7;
							bits -= bits & 7;
						} while (0);
						state.setMode(.DONE);
						break;
					} 
					do {
						while (bits < (int)(true)) {
							do {
								do {
									if (have == 0) {
										have = ModernizedCProgram.in(in_desc, next);
										if (have == 0) {
											next = 0;
											ret = (true);
											;
										} 
									} 
								} while (0);
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
					} while (0);
					state.setLast(((int)hold & ((-1024 << (true)) - 1)));
					do {
						hold >>=  (true);
						bits -= (int)(true);
					} while (0);
					switch (((int)hold & ((-1024 << (true)) - 1))) {
					case /* fixed block */1:
							state.fixedtables();
							;
							state.setMode(/* decode codes */.LEN);
							break;
					case 3:
							strm.setMsg((byte)"invalid block type");
							state.setMode(.BAD);
					case /* dynamic block */2:
							;
							state.setMode(.TABLE);
							break;
					case /* stored block */0:
							;
							state.setMode(.STORED);
							break;
					}
					do {
						hold >>=  (true);
						bits -= (int)(true);
					} while (0);
					break;
			case .BAD:
					ret = (true);
					;
			case .TABLE:
					do {
						while (bits < (int)(true)) {
							do {
								do {
									if (have == 0) {
										have = ModernizedCProgram.in(in_desc, next);
										if (have == 0) {
											next = 0;
											ret = (true);
											;
										} 
									} 
								} while (0);
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
					} while (/* get dynamic table entries descriptor */0);
					state.setNlen(((int)hold & ((-1024 << (true)) - 1)) + 257);
					do {
						hold >>=  (true);
						bits -= (int)(true);
					} while (0);
					state.setNdist(((int)hold & ((-1024 << (true)) - 1)) + 1);
					do {
						hold >>=  (true);
						bits -= (int)(true);
					} while (0);
					state.setNcode(((int)hold & ((-1024 << (true)) - 1)) + 4);
					do {
						hold >>=  (true);
						bits -= (int)(true);
					} while (0);
					if (generatedNlen > 286 || generatedNdist > 30) {
						strm.setMsg((byte)"too many length or distance symbols");
						state.setMode(.BAD);
						break;
					} 
					;
					state.setHave(/* get code length code lengths (not a typo) */0);
					while (generatedHave < generatedNcode) {
						do {
							while (bits < (int)(true)) {
								do {
									do {
										if (have == 0) {
											have = ModernizedCProgram.in(in_desc, next);
											if (have == 0) {
												next = 0;
												ret = (true);
												;
											} 
										} 
									} while (0);
									have--;
									hold += (long)(next++) << bits;
									bits += 8;
								} while (0);
							}
						} while (0);
						generatedLens[order[generatedHave++]] = (int)((int)hold & ((-1024 << (true)) - 1));
						do {
							hold >>=  (true);
							bits -= (int)(true);
						} while (0);
					}
					while (generatedHave < 19) {
						generatedLens[order[generatedHave++]] = 0;
					}
					state.setNext(generatedCodes);
					state.setLencode((code)(generatedNext));
					state.setLenbits(7);
					ret = (generatedNext).inflate_table(.CODES, generatedLens, 19, (generatedLenbits), generatedWork);
					if (ret) {
						strm.setMsg((byte)"invalid code lengths set");
						state.setMode(.BAD);
						break;
					} 
					;
					state.setHave(/* get length and distance code code lengths */0);
					while (generatedHave < generatedNlen + generatedNdist) {
						for (; ; ) {
							here = generatedLencode[((int)hold & ((-1024 << (generatedLenbits)) - 1))];
							if ((int)(generatedBits) <= bits) {
								break;
							} 
							do {
								do {
									if (have == 0) {
										have = ModernizedCProgram.in(in_desc, next);
										if (have == 0) {
											next = 0;
											ret = (true);
											;
										} 
									} 
								} while (0);
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
						if (generatedVal < 16) {
							do {
								hold >>=  (generatedBits);
								bits -= (int)(generatedBits);
							} while (0);
							generatedLens[generatedHave++] = generatedVal;
						} else {
								if (generatedVal == 16) {
									do {
										while (bits < (int)(generatedBits + 2)) {
											do {
												do {
													if (have == 0) {
														have = ModernizedCProgram.in(in_desc, next);
														if (have == 0) {
															next = 0;
															ret = (true);
															;
														} 
													} 
												} while (0);
												have--;
												hold += (long)(next++) << bits;
												bits += 8;
											} while (0);
										}
									} while (0);
									do {
										hold >>=  (generatedBits);
										bits -= (int)(generatedBits);
									} while (0);
									if (generatedHave == 0) {
										strm.setMsg((byte)"invalid bit length repeat");
										state.setMode(.BAD);
										break;
									} 
									len = (int)(generatedLens[generatedHave - 1]);
									copy = 3 + ((int)hold & ((-1024 << (true)) - 1));
									do {
										hold >>=  (true);
										bits -= (int)(true);
									} while (0);
								}  else if (generatedVal == 17) {
									do {
										while (bits < (int)(generatedBits + 3)) {
											do {
												do {
													if (have == 0) {
														have = ModernizedCProgram.in(in_desc, next);
														if (have == 0) {
															next = 0;
															ret = (true);
															;
														} 
													} 
												} while (0);
												have--;
												hold += (long)(next++) << bits;
												bits += 8;
											} while (0);
										}
									} while (0);
									do {
										hold >>=  (generatedBits);
										bits -= (int)(generatedBits);
									} while (0);
									len = 0;
									copy = 3 + ((int)hold & ((-1024 << (true)) - 1));
									do {
										hold >>=  (true);
										bits -= (int)(true);
									} while (0);
								} else {
										do {
											while (bits < (int)(generatedBits + 7)) {
												do {
													do {
														if (have == 0) {
															have = ModernizedCProgram.in(in_desc, next);
															if (have == 0) {
																next = 0;
																ret = (true);
																;
															} 
														} 
													} while (0);
													have--;
													hold += (long)(next++) << bits;
													bits += 8;
												} while (0);
											}
										} while (0);
										do {
											hold >>=  (generatedBits);
											bits -= (int)(generatedBits);
										} while (0);
										len = 0;
										copy = 11 + ((int)hold & ((-1024 << (true)) - 1));
										do {
											hold >>=  (true);
											bits -= (int)(true);
										} while (0);
								} 
								if (generatedHave + copy > generatedNlen + generatedNdist) {
									strm.setMsg((byte)"invalid bit length repeat");
									state.setMode(.BAD);
									break;
								} 
								while (copy--) {
									generatedLens[generatedHave++] = (int)len;
								}
						} 
					}
					if (generatedMode == /* handle error breaks in while */.BAD) {
						break;
					} 
					if (generatedLens[256] == /* check for end-of-block code (better have one) */0) {
						strm.setMsg((byte)"invalid code -- missing end-of-block");
						state.setMode(.BAD);
						break;
					} 
					state.setNext(generatedCodes);
					state.setLencode((code)(generatedNext));
					state.setLenbits(9);
					ret = (generatedNext).inflate_table(.LENS, generatedLens, generatedNlen, (generatedLenbits), generatedWork);
					if (ret) {
						strm.setMsg((byte)"invalid literal/lengths set");
						state.setMode(.BAD);
						break;
					} 
					state.setDistcode((code)(generatedNext));
					state.setDistbits(6);
					ret = (generatedNext).inflate_table(.DISTS, generatedLens + generatedNlen, generatedNdist, (generatedDistbits), generatedWork);
					if (ret) {
						strm.setMsg((byte)"invalid distances set");
						state.setMode(.BAD);
						break;
					} 
					;
					state.setMode(.LEN);
			case .STORED:
					do {
						hold >>=  bits & 7;
						bits -= bits & 7;
					} while (/* get and verify stored block length *//* go to byte boundary */0);
					do {
						while (bits < (int)(true)) {
							do {
								do {
									if (have == 0) {
										have = ModernizedCProgram.in(in_desc, next);
										if (have == 0) {
											next = 0;
											ret = (true);
											;
										} 
									} 
								} while (0);
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
					} while (0);
					if ((hold & -1024) != ((hold >> 16) ^ -1024)) {
						strm.setMsg((byte)"invalid stored block lengths");
						state.setMode(.BAD);
						break;
					} 
					state.setLength((int)hold & -1024);
					;
					do {
						hold = 0;
						bits = 0;
					} while (0);
					while (generatedLength != /* copy stored block from input to output */0) {
						copy = generatedLength;
						do {
							if (have == 0) {
								have = ModernizedCProgram.in(in_desc, next);
								if (have == 0) {
									next = 0;
									ret = (true);
									;
								} 
							} 
						} while (0);
						do {
							if (left == 0) {
								put = generatedWindow;
								left = generatedWsize;
								state.setWhave(left);
								if (ModernizedCProgram.out(out_desc, put, left)) {
									ret = (true);
									;
								} 
							} 
						} while (0);
						if (copy > have) {
							copy = have;
						} 
						if (copy > left) {
							copy = left;
						} 
						.memcpy(put, next, copy);
						have -= copy;
						next += copy;
						left -= copy;
						put += copy;
						generatedLength -= copy;
					}
					;
					state.setMode(.TYPE);
					break;
			case .LEN:
					if (have >= 6 && left >= /* use inflate_fast() if we have enough input and output */258) {
						do {
							strm.setNext_out(put);
							strm.setAvail_out(left);
							strm.setNext_in(next);
							strm.setAvail_in(have);
							state.setHold(hold);
							state.setBits(bits);
						} while (0);
						if (generatedWhave < generatedWsize) {
							state.setWhave(generatedWsize - left);
						} 
						ModernizedCProgram.inflate_fast(strm, generatedWsize);
						do {
							put = strm.getNext_out();
							left = strm.getAvail_out();
							next = strm.getNext_in();
							have = strm.getAvail_in();
							hold = generatedHold;
							bits = generatedBits;
						} while (0);
						break;
					} 
					for (; ; ) {
						here = generatedLencode[((int)hold & ((-1024 << (generatedLenbits)) - 1))];
						if ((int)(generatedBits) <= bits) {
							break;
						} 
						do {
							do {
								if (have == 0) {
									have = ModernizedCProgram.in(in_desc, next);
									if (have == 0) {
										next = 0;
										ret = (true);
										;
									} 
								} 
							} while (0);
							have--;
							hold += (long)(next++) << bits;
							bits += 8;
						} while (0);
					}
					if (generatedOp && (generatedOp & -1024) == 0) {
						last = here;
						for (; ; ) {
							here = generatedLencode[generatedVal + (((int)hold & ((-1024 << (generatedBits + generatedOp)) - 1)) >> generatedBits)];
							if ((int)(generatedBits + generatedBits) <= bits) {
								break;
							} 
							do {
								do {
									if (have == 0) {
										have = ModernizedCProgram.in(in_desc, next);
										if (have == 0) {
											next = 0;
											ret = (true);
											;
										} 
									} 
								} while (0);
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
						do {
							hold >>=  (generatedBits);
							bits -= (int)(generatedBits);
						} while (0);
					} 
					do {
						hold >>=  (generatedBits);
						bits -= (int)(generatedBits);
					} while (0);
					state.setLength((int)generatedVal);
					if (generatedOp == /* process literal */0) {
						;
						do {
							if (left == 0) {
								put = generatedWindow;
								left = generatedWsize;
								state.setWhave(left);
								if (ModernizedCProgram.out(out_desc, put, left)) {
									ret = (true);
									;
								} 
							} 
						} while (0);
						put++ = (byte)(generatedLength);
						left--;
						state.setMode(.LEN);
						break;
					} 
					if (generatedOp & /* process end of block */32) {
						;
						state.setMode(.TYPE);
						break;
					} 
					if (generatedOp & /* invalid code */64) {
						strm.setMsg((byte)"invalid literal/length code");
						state.setMode(.BAD);
						break;
					} 
					state.setExtra((int)(generatedOp) & /* length code -- get extra bits, if any */15);
					if (generatedExtra != 0) {
						do {
							while (bits < (int)(generatedExtra)) {
								do {
									do {
										if (have == 0) {
											have = ModernizedCProgram.in(in_desc, next);
											if (have == 0) {
												next = 0;
												ret = (true);
												;
											} 
										} 
									} while (0);
									have--;
									hold += (long)(next++) << bits;
									bits += 8;
								} while (0);
							}
						} while (0);
						generatedLength += ((int)hold & ((-1024 << (generatedExtra)) - 1));
						do {
							hold >>=  (generatedExtra);
							bits -= (int)(generatedExtra);
						} while (0);
					} 
					;
					for (; ; ) {
						here = generatedDistcode[((int)hold & ((-1024 << (generatedDistbits)) - 1))];
						if ((int)(generatedBits) <= bits) {
							break;
						} 
						do {
							do {
								if (have == 0) {
									have = ModernizedCProgram.in(in_desc, next);
									if (have == 0) {
										next = 0;
										ret = (true);
										;
									} 
								} 
							} while (0);
							have--;
							hold += (long)(next++) << bits;
							bits += 8;
						} while (0);
					}
					if ((generatedOp & -1024) == 0) {
						last = here;
						for (; ; ) {
							here = generatedDistcode[generatedVal + (((int)hold & ((-1024 << (generatedBits + generatedOp)) - 1)) >> generatedBits)];
							if ((int)(generatedBits + generatedBits) <= bits) {
								break;
							} 
							do {
								do {
									if (have == 0) {
										have = ModernizedCProgram.in(in_desc, next);
										if (have == 0) {
											next = 0;
											ret = (true);
											;
										} 
									} 
								} while (0);
								have--;
								hold += (long)(next++) << bits;
								bits += 8;
							} while (0);
						}
						do {
							hold >>=  (generatedBits);
							bits -= (int)(generatedBits);
						} while (0);
					} 
					do {
						hold >>=  (generatedBits);
						bits -= (int)(generatedBits);
					} while (0);
					if (generatedOp & 64) {
						strm.setMsg((byte)"invalid distance code");
						state.setMode(.BAD);
						break;
					} 
					state.setOffset((int)generatedVal);
					state.setExtra((int)(generatedOp) & /* get distance extra bits, if any */15);
					if (generatedExtra != 0) {
						do {
							while (bits < (int)(generatedExtra)) {
								do {
									do {
										if (have == 0) {
											have = ModernizedCProgram.in(in_desc, next);
											if (have == 0) {
												next = 0;
												ret = (true);
												;
											} 
										} 
									} while (0);
									have--;
									hold += (long)(next++) << bits;
									bits += 8;
								} while (0);
							}
						} while (0);
						generatedOffset += ((int)hold & ((-1024 << (generatedExtra)) - 1));
						do {
							hold >>=  (generatedExtra);
							bits -= (int)(generatedExtra);
						} while (0);
					} 
					if (generatedOffset > generatedWsize - (generatedWhave < generatedWsize ? left : 0)) {
						strm.setMsg((byte)"invalid distance too far back");
						state.setMode(.BAD);
						break;
					} 
					;
					do {
						do {
							if (left == 0) {
								put = generatedWindow;
								left = generatedWsize;
								state.setWhave(left);
								if (ModernizedCProgram.out(out_desc, put, left)) {
									ret = (true);
									;
								} 
							} 
						} while (0);
						copy = generatedWsize - generatedOffset;
						if (copy < left) {
							from = put + copy;
							copy = left - copy;
						} else {
								from = put - generatedOffset;
								copy = left;
						} 
						if (copy > generatedLength) {
							copy = generatedLength;
						} 
						generatedLength -= copy;
						left -= copy;
						do {
							put++ = from++;
						} while (--copy);
					} while (generatedLength != 0);
					break;
			case .DONE:
					ret = /* inflate stream terminated properly -- write leftover output */1;
					if (left < generatedWsize) {
						if (ModernizedCProgram.out(out_desc, generatedWindow, generatedWsize - left)) {
							ret = (true);
						} 
					} 
					;
			default:
					ret = (true);
					;
			}
		}
		strm.setAvail_in(have);
		return ret;
	}
	public static int inflateBackEnd(Object strm) {
		if (strm == 0 || strm.getState() == 0 || strm.getZfree() == (free_func)0) {
			return (true);
		} 
		.UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (voidpf)(strm.getState()));
		strm.setState(0);
		;
		return 0;
	}
	/* Lzma86Dec.c -- LZMA + x86 (BCJ) Filter Decoder
	2016-05-16 : Igor Pavlov : Public domain */
	public static Object Lzma86_GetUnpackSize(Object src, Object srcLen, Object unpackSize) {
		int i;
		if (srcLen < ((1 + 5) + 8)) {
			return 6;
		} 
		unpackSize = 0;
		for (i = 0; i < ; i++) {
			unpackSize += ((UInt64)src[(1 + 5) + i]) << (8 * i);
		}
		return 0;
	}
	public static Object Lzma86_Decode(Object dest, Object destLen, Object src, Object srcLen) {
		SRes res = new SRes();
		int useFilter;
		SizeT inSizePure = new SizeT();
		ELzmaStatus status = new ELzmaStatus();
		if (srcLen < ((1 + 5) + 8)) {
			return 6;
		} 
		useFilter = src[0];
		if (useFilter > 1) {
			destLen = 0;
			return 4;
		} 
		inSizePure = srcLen - ((1 + 5) + 8);
		res = ModernizedCProgram.LzmaDecode(dest, destLen, src + ((1 + 5) + 8), inSizePure, src + 1, 5, .LZMA_FINISH_ANY, status, ModernizedCProgram.g_Alloc);
		srcLen = inSizePure + ((1 + 5) + 8);
		if (res != 0) {
			return res;
		} 
		if (useFilter == 1) {
			UInt32 x86State = new UInt32();
			{ 
				x86State = 0;
			}
			;
			ModernizedCProgram.x86_Convert(dest, destLen, 0, x86State, 0);
		} 
		return 0;
	}
	public static Object hm_NVML_nvmlErrorString(Object nvml, Object nvml_rc) {
		return .UNRECOGNIZEDFUNCTIONNAME(nvml_rc);
	}
	public static int hm_NVML_nvmlDeviceGetUtilizationRates(hashcat_ctx hashcat_ctx, Object device, nvmlUtilization_st utilization) {
		hwmon_ctx generatedHwmon_ctx = hashcat_ctx.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		nvmlReturn_t nvml_rc = .UNRECOGNIZEDFUNCTIONNAME(device, utilization);
		if (nvml_rc != nvmlReturn_enum.NVML_SUCCESS) {
			byte string = ModernizedCProgram.hm_NVML_nvmlErrorString(nvml, nvml_rc);
			hashcat_ctx.event_log_error("nvmlDeviceGetUtilizationRates(): %s", string);
			return -1;
		} 
		return 0;
	}
	public static int hm_NVML_nvmlDeviceGetPciInfo(hashcat_ctx hashcat_ctx, Object device, nvmlPciInfo_st pci) {
		hwmon_ctx generatedHwmon_ctx = hashcat_ctx.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvml = hwmon_ctx.getHm_nvml();
		NVML_PTR nvml = generatedHm_nvml;
		nvmlReturn_t nvml_rc = .UNRECOGNIZEDFUNCTIONNAME(device, pci);
		if (nvml_rc != nvmlReturn_enum.NVML_SUCCESS) {
			byte string = ModernizedCProgram.hm_NVML_nvmlErrorString(nvml, nvml_rc);
			hashcat_ctx.event_log_error("nvmlDeviceGetPciInfo(): %s", string);
			return -1;
		} 
		return 0;
	}
	public static void hm_NvAPI_GetErrorMessage(Object nvapi, Object NvAPI_rc, Byte string) {
		.UNRECOGNIZEDFUNCTIONNAME(NvAPI_rc, string);
	}
	public static int hm_NvAPI_GPU_GetPerfPoliciesInfo(hashcat_ctx hashcat_ctx, Object hPhysicalGpu, struct_NV_GPU_PERF_POLICIES_INFO_PARAMS_V1 perfPolicies_info) {
		hwmon_ctx generatedHwmon_ctx = hashcat_ctx.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		NVAPI_PTR nvapi = generatedHm_nvapi;
		NvAPI_Status NvAPI_rc = .UNRECOGNIZEDFUNCTIONNAME(hPhysicalGpu, perfPolicies_info);
		if (NvAPI_rc != _NvAPI_Status.NVAPI_OK) {
			NvAPI_ShortString string = new NvAPI_ShortString(0);
			ModernizedCProgram.hm_NvAPI_GetErrorMessage(nvapi, NvAPI_rc, string);
			hashcat_ctx.event_log_error("NvAPI_GPU_GetPerfPoliciesInfo(): %s", string);
			return -1;
		} 
		return 0;
	}
	public static int hm_NvAPI_GPU_GetPerfPoliciesStatus(hashcat_ctx hashcat_ctx, Object hPhysicalGpu, struct_NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1 perfPolicies_status) {
		hwmon_ctx generatedHwmon_ctx = hashcat_ctx.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_nvapi = hwmon_ctx.getHm_nvapi();
		NVAPI_PTR nvapi = generatedHm_nvapi;
		NvAPI_Status NvAPI_rc = .UNRECOGNIZEDFUNCTIONNAME(hPhysicalGpu, perfPolicies_status);
		if (NvAPI_rc != _NvAPI_Status.NVAPI_OK) {
			NvAPI_ShortString string = new NvAPI_ShortString(0);
			ModernizedCProgram.hm_NvAPI_GetErrorMessage(nvapi, NvAPI_rc, string);
			hashcat_ctx.event_log_error("NvAPI_GPU_GetPerfPoliciesStatus(): %s", string);
			return -1;
		} 
		return 0;
	}
	public static int hm_ADL_Overdrive5_Temperature_Get(hashcat_ctx hashcat_ctx, int iAdapterIndex, int iThermalControllerIndex, ADLTemperature lpTemperature) {
		hwmon_ctx generatedHwmon_ctx = hashcat_ctx.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		int ADL_rc = .UNRECOGNIZEDFUNCTIONNAME(iAdapterIndex, iThermalControllerIndex, lpTemperature);
		if (ADL_rc != 0) {
			hashcat_ctx.event_log_error("ADL_Overdrive5_Temperature_Get(): %d", ADL_rc);
			return -1;
		} 
		return 0;
	}
	public static int hm_ADL_Overdrive_CurrentActivity_Get(hashcat_ctx hashcat_ctx, int iAdapterIndex, ADLPMActivity lpActivity) {
		hwmon_ctx generatedHwmon_ctx = hashcat_ctx.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		int ADL_rc = .UNRECOGNIZEDFUNCTIONNAME(iAdapterIndex, lpActivity);
		if (ADL_rc != 0) {
			hashcat_ctx.event_log_error("ADL_Overdrive5_CurrentActivity_Get(): %d", ADL_rc);
			return -1;
		} 
		return 0;
	}
	public static int hm_ADL_Overdrive5_FanSpeed_Get(hashcat_ctx hashcat_ctx, int iAdapterIndex, int iThermalControllerIndex, ADLFanSpeedValue lpFanSpeedValue) {
		hwmon_ctx generatedHwmon_ctx = hashcat_ctx.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		int ADL_rc = .UNRECOGNIZEDFUNCTIONNAME(iAdapterIndex, iThermalControllerIndex, lpFanSpeedValue);
		// exception allowed only hereif ((ADL_rc != 0) && (ADL_rc != -8)) {
			hashcat_ctx.event_log_error("ADL_Overdrive5_FanSpeed_Get(): %d", ADL_rc);
			return -1;
		} 
		return 0;
	}
	public static int hm_ADL_Overdrive6_FanSpeed_Get(hashcat_ctx hashcat_ctx, int iAdapterIndex, ADLOD6FanSpeedInfo lpFanSpeedInfo) {
		hwmon_ctx generatedHwmon_ctx = hashcat_ctx.getHwmon_ctx();
		hwmon_ctx_t hwmon_ctx = generatedHwmon_ctx;
		Object generatedHm_adl = hwmon_ctx.getHm_adl();
		ADL_PTR adl = generatedHm_adl;
		int ADL_rc = .UNRECOGNIZEDFUNCTIONNAME(iAdapterIndex, lpFanSpeedInfo);
		// exception allowed only hereif ((ADL_rc != 0) && (ADL_rc != -8)) {
			hashcat_ctx.event_log_error("ADL_Overdrive6_FanSpeed_Get(): %d", ADL_rc);
			return -1;
		} 
		return 0;
	}
	public static Object in_superchop(Byte buf) {
		size_t len = .strlen(buf);
		while (len) {
			if (buf[len - 1] == (byte)'\n') {
				len--;
				buf[len] = 0;
				continue;
			} 
			if (buf[len - 1] == (byte)'\r') {
				len--;
				buf[len] = 0;
				continue;
			} 
			break;
		}
		return len;
	}
	public static Object superchop_with_length(Byte buf, Object len) {
		size_t new_len = len;
		while (new_len) {
			if (buf[new_len - 1] == (byte)'\n') {
				new_len--;
				buf[new_len] = 0;
				continue;
			} 
			if (buf[new_len - 1] == (byte)'\r') {
				new_len--;
				buf[new_len] = 0;
				continue;
			} 
			break;
		}
		return new_len;
	}
	/* minigzip.c -- simulate gzip using the zlib compression library
	 * Copyright (C) 1995-2006, 2010, 2011, 2016 Jean-loup Gailly
	 * For conditions of distribution and use, see copyright notice in zlib.h
	 */
	/*
	 * minigzip is a minimal implementation of the gzip utility. This is
	 * only an example of using zlib and isn't meant to replace the
	 * full-featured gzip. No attempt is made to deal with file systems
	 * limiting names to 14 or 8+3 characters, etc... Error checking is
	 * very limited. So use minigzip only for testing; use gzip for the
	 * real thing. On MSDOS, use only on file names without extension
	 * or in pipe mode.
	 */
	/* @(#) $Id$ */
	/* for fileno */
	/* unlink already in stdio.h for WIN32 */
	/* Map the Windows error number in ERROR to a locale-dependent error
	   message string and return a pointer to it.  Typically, the values
	   for ERROR come from GetLastError.
	
	   The string pointed to shall not be modified by the application,
	   but may be overwritten by a subsequent call to strwinerror
	
	   The strwinerror function does not change the current setting
	   of GetLastError.  */
	/* Default language */
	/* If there is an \r\n appended, zap it.  */
	/* UNDER_CE */
	/* Needed for systems with limitation on stack size. */
	/* for Z_SOLO, create simplified gz* functions using deflate and inflate */
	/* for unlink() */
	public static void error(Object msg) {
		.fprintf((_iob[2]), "%s: %s\n", ModernizedCProgram.prog, msg);
		.exit(1/* ===========================================================================
		 * Compress input to output then close both files.
		 */);
		.fprintf((_iob[2]), "%s: %s\n", ModernizedCProgram.prog, msg);
		.exit(1);
	}
	public static void gz_compress(Object out) {
		byte[] buf = new byte[16384];
		int len;
		int err;
		/* Try first compressing with mmap. If mmap fails (minigzip used in a
		     * pipe), use the normal fread loop.
		     */
		Object generated_flag = (in).get_flag();
		for (; ; ) {
			len = (int).fread(buf, 1, , in);
			if ((generated_flag & -1024)) {
				.perror("fread");
				.exit(1);
			} 
			if (len == 0) {
				break;
			} 
			if (ModernizedCProgram.gzwrite(out, buf, (int)len) != len) {
				ModernizedCProgram.error(ModernizedCProgram.gzerror(out, err));
			} 
		}
		.fclose(in);
		if (ModernizedCProgram.gzclose(out) != 0) {
			ModernizedCProgram.error("failed gzclose"/* MMAP version, Miguel Albrecht <malbrech@eso.org> *//* Try compressing the input file at once using mmap. Return Z_OK if
			 * if success, Z_ERRNO otherwise.
			 */);
		} 
	}
	/* mmap'ed buffer for the entire input file */
	/* length of the input file */
	/* Determine the size of the file, needed for mmap: */
	/* Now do the actual mmap: */
	/* Compress the whole file at once: */
	/* USE_MMAP */
	/* ===========================================================================
	 * Uncompress input to output then close both files.
	 */
	public static void gz_uncompress(Object in) {
		byte[] buf = new byte[16384];
		int len;
		int err;
		for (; ; ) {
			len = ModernizedCProgram.gzread(in, buf, );
			if (len < 0) {
				ModernizedCProgram.error(ModernizedCProgram.gzerror(in, err));
			} 
			if (len == 0) {
				break;
			} 
			if ((int).fwrite(buf, 1, (int)len, out) != len) {
				ModernizedCProgram.error("failed fwrite");
			} 
		}
		if (.fclose(out)) {
			ModernizedCProgram.error("failed fclose");
		} 
		if (ModernizedCProgram.gzclose(in) != 0) {
			ModernizedCProgram.error("failed gzclose"/* ===========================================================================
			 * Compress the given file: create a corresponding .gz file and remove the
			 * original.
			 */);
		} 
	}
	public static void file_compress(Byte file, Byte mode) {
		byte[] outfile = new byte[1024];
		FILE in = new FILE();
		gzFile out = new gzFile();
		if (.strlen(file) + .strlen(".gz") >= ) {
			.fprintf((_iob[2]), "%s: filename too long\n", ModernizedCProgram.prog);
			.exit(1);
		} 
		.snprintf(outfile, , "%s%s", file, ".gz");
		in = .fopen(file, "rb");
		if (in == ((Object)0)) {
			.perror(file);
			.exit(1);
		} 
		out = ModernizedCProgram.gzopen(outfile, mode);
		if (out == ((Object)0)) {
			.fprintf((_iob[2]), "%s: can't gzopen %s\n", ModernizedCProgram.prog, outfile);
			.exit(1);
		} 
		in.gz_compress(out);
		.unlink(file);
	}
	/* ===========================================================================
	 * Uncompress the given file and remove the original.
	 */
	public static void file_uncompress(Byte file) {
		byte[] buf = new byte[1024];
		byte infile;
		byte outfile;
		FILE out = new FILE();
		gzFile in = new gzFile();
		int len = .strlen(file);
		if (len + .strlen(".gz") >= ) {
			.fprintf((_iob[2]), "%s: filename too long\n", ModernizedCProgram.prog);
			.exit(1);
		} 
		.snprintf(buf, , "%s", file);
		if (len > ( - 1) && .strcmp(file + len - ( - 1), ".gz") == 0) {
			infile = file;
			outfile = buf;
			outfile[len - 3] = (byte)'\0';
		} else {
				outfile = file;
				infile = buf;
				.snprintf(buf + len,  - len, "%s", ".gz");
		} 
		in = ModernizedCProgram.gzopen(infile, "rb");
		if (in == ((Object)0)) {
			.fprintf((_iob[2]), "%s: can't gzopen %s\n", ModernizedCProgram.prog, infile);
			.exit(1);
		} 
		out = .fopen(outfile, "wb");
		if (out == ((Object)0)) {
			.perror(file);
			.exit(1);
		} 
		out.gz_uncompress(in);
		.unlink(infile/* ===========================================================================
		 * Usage:  minigzip [-c] [-d] [-f] [-h] [-r] [-1 to -9] [files...]
		 *   -c : write to standard output
		 *   -d : decompress
		 *   -f : compress with Z_FILTERED
		 *   -h : compress with Z_HUFFMAN_ONLY
		 *   -r : compress with Z_RLE
		 *   -1 to -9 : compression level
		 */);
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static void hc_timer_set(Object a) {
		.QueryPerformanceCounter(a);
	}
	public static double hc_timer_get(Object a) {
		hc_timer_t hr_freq = new hc_timer_t();
		.QueryPerformanceFrequency(hr_freq);
		hc_timer_t hr_tmp = new hc_timer_t();
		ModernizedCProgram.hc_timer_set(hr_tmp);
		double r = ((double)hr_tmp.getQuadPart() - (double)a.getQuadPart()) / ((double)hr_freq.getQuadPart() / 1000);
		return r;
	}
	/* 7zFile.c -- File IO
	2017-04-03 : Igor Pavlov : Public domain */
	/*
	   ReadFile and WriteFile functions in Windows have BUG:
	   If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1)
	   from/to Network file, it returns ERROR_NO_SYSTEM_RESOURCES
	   (Insufficient system resources exist to complete the requested service).
	   Probably in some version of Windows there are problems with other sizes:
	   for 32 MB (maybe also for 16 MB).
	   And message can be "Network connection was lost"
	*/
	public static void File_Construct() {
		this.setHandle((HANDLE)(true));
	}
	public static Object File_Open(Object name, int writeMode) {
		this.setHandle(.CreateFileA(name, writeMode ? -1024 : -1024, -1024, ((Object)0), writeMode ? 2 : 3, -1024, ((Object)0)));
		Object generatedHandle = this.getHandle();
		return (generatedHandle != (HANDLE)(true)) ? 0 : .GetLastError();
	}
	public static Object InFile_Open(Object name) {
		return p.File_Open(name, 0);
	}
	public static Object OutFile_Open(Object name) {
		return p.File_Open(name, 1);
	}
	public static Object File_OpenW(Object name, int writeMode) {
		this.setHandle(.CreateFileW(name, writeMode ? -1024 : -1024, -1024, ((Object)0), writeMode ? 2 : 3, -1024, ((Object)0)));
		Object generatedHandle = this.getHandle();
		return (generatedHandle != (HANDLE)(true)) ? 0 : .GetLastError();
	}
	public static Object InFile_OpenW(Object name) {
		return p.File_OpenW(name, 0);
	}
	public static Object OutFile_OpenW(Object name) {
		return p.File_OpenW(name, 1);
	}
	public static Object File_Close() {
		Object generatedHandle = this.getHandle();
		if (generatedHandle != (HANDLE)(true)) {
			if (!.CloseHandle(generatedHandle)) {
				return .GetLastError();
			} 
			this.setHandle((HANDLE)(true));
		} 
		return 0;
	}
	public static Object File_Read(Object data, Object size) {
		size_t originalSize = size;
		if (originalSize == 0) {
			return 0;
		} 
		size = 0;
		Object generatedHandle = this.getHandle();
		do {
			DWORD curSize = (originalSize > (1 << 22)) ? (1 << 22) : (DWORD)originalSize;
			DWORD processed = 0;
			BOOL res = .ReadFile(generatedHandle, data, curSize, processed, ((Object)0));
			data = (Object)((Byte)data + processed);
			originalSize -= processed;
			size += processed;
			if (!res) {
				return .GetLastError();
			} 
			if (processed == 0) {
				break;
			} 
		} while (originalSize > 0);
		return 0;
	}
	public static Object File_Write(Object data, Object size) {
		size_t originalSize = size;
		if (originalSize == 0) {
			return 0;
		} 
		size = 0;
		Object generatedHandle = this.getHandle();
		do {
			DWORD curSize = (originalSize > (1 << 22)) ? (1 << 22) : (DWORD)originalSize;
			DWORD processed = 0;
			BOOL res = .WriteFile(generatedHandle, data, curSize, processed, ((Object)0));
			data = (Object)((Byte)data + processed);
			originalSize -= processed;
			size += processed;
			if (!res) {
				return .GetLastError();
			} 
			if (processed == 0) {
				break;
			} 
		} while (originalSize > 0);
		return 0;
	}
	public static Object File_Seek(Object pos,  origin) {
		LARGE_INTEGER value = new LARGE_INTEGER();
		DWORD moveMethod = new DWORD();
		value.setLowPart((DWORD)pos);
		value.setHighPart((LONG)((UInt64)pos >> 16 >> /* for case when UInt64 is 32-bit only */16));
		switch (origin) {
		case .SZ_SEEK_SET:
				moveMethod = 0;
				break;
		case .SZ_SEEK_CUR:
				moveMethod = 1;
				break;
		case .SZ_SEEK_END:
				moveMethod = 2;
				break;
		default:
				return -1024;
		}
		Object generatedHandle = this.getHandle();
		Object generatedLowPart = value.getLowPart();
		Object generatedHighPart = value.getHighPart();
		value.setLowPart(.SetFilePointer(generatedHandle, generatedLowPart, generatedHighPart, moveMethod));
		if (generatedLowPart == -1024) {
			WRes res = .GetLastError();
			if (res != -1024) {
				return res;
			} 
		} 
		pos = ((Int64)generatedHighPart << 32) | generatedLowPart;
		return 0;
	}
	public static Object File_GetLength(Object length) {
		DWORD sizeHigh = new DWORD();
		Object generatedHandle = this.getHandle();
		DWORD sizeLow = .GetFileSize(generatedHandle, sizeHigh);
		if (sizeLow == -1024) {
			DWORD res = .GetLastError();
			if (res != -1024) {
				return res;
			} 
		} 
		length = (((UInt64)sizeHigh) << 32) + sizeLow;
		return 0;
	}
	/* ---------- FileSeqInStream ---------- */
	public static Object FileSeqInStream_Read(Object pp, Object buf, Object size) {
		CFileSeqInStream p = ((CFileSeqInStream)((byte)(true ? (pp) : ((CFileSeqInStream)0).getVt()) - ((size_t)((CFileSeqInStream)0).getVt())));
		Object generatedFile = p.getFile();
		return generatedFile.File_Read(buf, size) == 0 ? 0 : 8;
	}
	public static void FileSeqInStream_CreateVTable() {
		Object generatedVt = this.getVt();
		generatedVt.setRead(FileSeqInStream_Read);
	}
	/* ---------- FileInStream ---------- */
	public static Object FileInStream_Read(Object pp, Object buf, Object size) {
		CFileInStream p = ((CFileInStream)((byte)(true ? (pp) : ((CFileInStream)0).getVt()) - ((size_t)((CFileInStream)0).getVt())));
		Object generatedFile = p.getFile();
		return (generatedFile.File_Read(buf, size) == 0) ? 0 : 8;
	}
	public static Object FileInStream_Seek(Object pp, Object pos,  origin) {
		CFileInStream p = ((CFileInStream)((byte)(true ? (pp) : ((CFileInStream)0).getVt()) - ((size_t)((CFileInStream)0).getVt())));
		Object generatedFile = p.getFile();
		return generatedFile.File_Seek(pos, origin);
	}
	public static void FileInStream_CreateVTable() {
		Object generatedVt = this.getVt();
		generatedVt.setRead(FileInStream_Read);
		generatedVt.setSeek(FileInStream_Seek);
	}
	/* ---------- FileOutStream ---------- */
	public static Object FileOutStream_Write(Object pp, Object data, Object size) {
		CFileOutStream p = ((CFileOutStream)((byte)(true ? (pp) : ((CFileOutStream)0).getVt()) - ((size_t)((CFileOutStream)0).getVt())));
		Object generatedFile = p.getFile();
		generatedFile.File_Write(data, size);
		return size;
	}
	public static void FileOutStream_CreateVTable() {
		Object generatedVt = this.getVt();
		generatedVt.setWrite(FileOutStream_Write);
	}
	/* ========================================================================= */
	public static int deflateInit_(Object strm, int level, Object version, int stream_size) {
		return ModernizedCProgram.deflateInit2_(strm, level, 8, 15, 8, 0, version, stream_size/* To do: ignore strm->next_in if we use it as window */);
	}
	/* ========================================================================= */
	public static int deflateInit2_(Object strm, int level, int method, int windowBits, int memLevel, int strategy, Object version, int stream_size) {
		deflate_state s = new deflate_state();
		int wrap = 1;
		byte[] my_version = "1.2.11";
		ushf overlay = new ushf();
		/* We overlay pending_buf and d_buf+l_buf. This works since the average
		     * output size for (length,distance) codes is <= 24 bits.
		     */
		if (version == 0 || version[0] != my_version[0] || stream_size != ) {
			return (true);
		} 
		if (strm == 0) {
			return (true);
		} 
		strm.setMsg(0);
		if (strm.getZalloc() == (alloc_func)0) {
			strm.setZalloc(ModernizedCProgram.zcalloc);
			strm.setOpaque((voidpf)0);
		} 
		if (strm.getZfree() == (free_func)0) {
			strm.setZfree(ModernizedCProgram.zcfree);
		} 
		if (level == (true)) {
			level = 6;
		} 
		if (windowBits < /* suppress zlib wrapper */0) {
			wrap = 0;
			windowBits = -windowBits;
		}  else if (windowBits > 15) {
			wrap = /* write gzip wrapper instead */2;
			windowBits -= 16;
		} 
		if (memLevel < 1 || memLevel > 9 || method != 8 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > 4 || (windowBits == 8 && wrap != 1)) {
			return (true);
		} 
		if (windowBits == 8) {
			windowBits = /* until 256-byte window bug fixed */9;
		} 
		s = (deflate_state).UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (true), ());
		if (s == 0) {
			return (true);
		} 
		strm.setState((internal_state)s);
		s.setStrm(strm);
		s.setStatus(/* to pass state test in deflateReset() */42);
		s.setWrap(wrap);
		s.setGzhead(0);
		s.setW_bits((uInt)windowBits);
		Object generatedW_bits = s.getW_bits();
		s.setW_size(1 << generatedW_bits);
		Object generatedW_size = s.getW_size();
		s.setW_mask(generatedW_size - 1);
		s.setHash_bits((uInt)memLevel + 7);
		Object generatedHash_bits = s.getHash_bits();
		s.setHash_size(1 << generatedHash_bits);
		Object generatedHash_size = s.getHash_size();
		s.setHash_mask(generatedHash_size - 1);
		s.setHash_shift(((generatedHash_bits + 3 - 1) / 3));
		s.setWindow((Bytef).UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (generatedW_size), (2 * )));
		s.setPrev((Posf).UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (generatedW_size), ()));
		s.setHead((Posf).UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (generatedHash_size), ()));
		s.setHigh_water(/* nothing written to s->window yet */0);
		s.setLit_bufsize(1 << (memLevel + /* 16K elements by default */6));
		Object generatedLit_bufsize = s.getLit_bufsize();
		overlay = (ushf).UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (generatedLit_bufsize), ( + 2));
		s.setPending_buf((uchf)overlay);
		s.setPending_buf_size((ulg)generatedLit_bufsize * ( + -1024));
		Object generatedWindow = s.getWindow();
		Object generatedPrev = s.getPrev();
		Object generatedHead = s.getHead();
		Object generatedPending_buf = s.getPending_buf();
		if (generatedWindow == 0 || generatedPrev == 0 || generatedHead == 0 || generatedPending_buf == 0) {
			s.setStatus(666);
			strm.setMsg(ModernizedCProgram.z_errmsg[2 - ((true))]);
			ModernizedCProgram.deflateEnd(strm);
			return (true);
		} 
		s.setD_buf(overlay + generatedLit_bufsize / );
		s.setL_buf(generatedPending_buf + (1 + ) * generatedLit_bufsize);
		s.setLevel(level);
		s.setStrategy(strategy);
		s.setMethod((Byte)method);
		return ModernizedCProgram.deflateReset(strm/* =========================================================================
		 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
		 */);
	}
	/* block not completed, need more input or more output */
	/* block flush performed */
	/* finish started, need only more output at next deflate */
	/* finish done, accept no more input or output */
	/* Compression function. Returns the block state after the call. */
	public static int deflateStateCheck(Object strm) {
		deflate_state s = new deflate_state();
		if (strm == 0 || strm.getZalloc() == (alloc_func)0 || strm.getZfree() == (free_func)0) {
			return 1;
		} 
		s = strm.getState();
		Object generatedStrm = s.getStrm();
		int generatedStatus = s.getStatus();
		if (s == 0 || generatedStrm != strm || (generatedStatus != 42 && generatedStatus != 57 && generatedStatus != 69 && generatedStatus != 73 && generatedStatus != 91 && generatedStatus != 103 && generatedStatus != 113 && generatedStatus != 666)) {
			return 1;
		} 
		return 0;
	}
	/* ========================================================================= */
	public static int deflateSetDictionary(Object strm, Object dictionary, Object dictLength) {
		deflate_state s = new deflate_state();
		uInt str = new uInt();
		uInt n = new uInt();
		int wrap;
		int avail;
		byte next;
		if (ModernizedCProgram.deflateStateCheck(strm) || dictionary == 0) {
			return (true);
		} 
		s = strm.getState();
		int generatedWrap = s.getWrap();
		wrap = generatedWrap;
		int generatedStatus = s.getStatus();
		Object generatedLookahead = s.getLookahead();
		if (wrap == 2 || (wrap == 1 && generatedStatus != 42) || generatedLookahead) {
			return (true);
		} 
		if (wrap == /* when using zlib wrappers, compute Adler-32 for provided dictionary */1) {
			strm.setAdler(ModernizedCProgram.adler32(strm.getAdler(), dictionary, dictLength));
		} 
		s.setWrap(/* avoid computing Adler-32 in read_buf */0);
		Object generatedW_size = s.getW_size();
		Object generatedHead = s.getHead();
		Object generatedHash_size = s.getHash_size();
		if (dictLength >= generatedW_size) {
			if (wrap == /* already empty otherwise */0) {
				generatedHead[generatedHash_size - 1] = 0;
				.memset((Bytef)generatedHead, 0, (int)(generatedHash_size - 1) * );
				;
				s.setStrstart(0);
				s.setBlock_start(-1024);
				s.setInsert(0);
			} 
			dictionary += dictLength - generatedW_size;
			dictLength = generatedW_size;
		} 
		avail = strm.getAvail_in();
		next = strm.getNext_in();
		strm.setAvail_in(dictLength);
		strm.setNext_in((Bytef)dictionary);
		s.fill_window();
		Object generatedStrstart = s.getStrstart();
		Object generatedIns_h = s.getIns_h();
		Object generatedHash_shift = s.getHash_shift();
		Object generatedWindow = s.getWindow();
		Object generatedHash_mask = s.getHash_mask();
		Object generatedPrev = s.getPrev();
		Object generatedW_mask = s.getW_mask();
		while (generatedLookahead >= 3) {
			str = generatedStrstart;
			n = generatedLookahead - (3 - 1);
			do {
				(s.setIns_h((((generatedIns_h) << generatedHash_shift) ^ (generatedWindow[str + 3 - 1])) & generatedHash_mask));
				generatedPrev[str & generatedW_mask] = generatedHead[generatedIns_h];
				generatedHead[generatedIns_h] = (Pos)str;
				str++;
			} while (--n);
			s.setStrstart(str);
			s.setLookahead(3 - 1);
			s.fill_window();
		}
		generatedStrstart += generatedLookahead;
		s.setBlock_start((long)generatedStrstart);
		s.setInsert(generatedLookahead);
		s.setLookahead(0);
		s.setMatch_length(s.setPrev_length(3 - 1));
		s.setMatch_available(0);
		strm.setNext_in(next);
		strm.setAvail_in(avail);
		s.setWrap(wrap);
		return 0;
	}
	/* ========================================================================= */
	public static int deflateGetDictionary(Object strm, Object dictionary, Object dictLength) {
		deflate_state s = new deflate_state();
		uInt len = new uInt();
		if (ModernizedCProgram.deflateStateCheck(strm)) {
			return (true);
		} 
		s = strm.getState();
		Object generatedStrstart = s.getStrstart();
		Object generatedLookahead = s.getLookahead();
		len = generatedStrstart + generatedLookahead;
		Object generatedW_size = s.getW_size();
		if (len > generatedW_size) {
			len = generatedW_size;
		} 
		Object generatedWindow = s.getWindow();
		if (dictionary != 0 && len) {
			.memcpy(dictionary, generatedWindow + generatedStrstart + generatedLookahead - len, len);
		} 
		if (dictLength != 0) {
			dictLength = len;
		} 
		return 0;
	}
	/* ========================================================================= */
	public static int deflateResetKeep(Object strm) {
		deflate_state s = new deflate_state();
		if (ModernizedCProgram.deflateStateCheck(strm)) {
			return (true);
		} 
		strm.setTotal_in(strm.setTotal_out(0));
		strm.setMsg(/* use zfree if we ever allocate msg dynamically */0);
		strm.setData_type(2);
		s = (deflate_state)strm.getState();
		s.setPending(0);
		Object generatedPending_buf = s.getPending_buf();
		s.setPending_out(generatedPending_buf);
		int generatedWrap = s.getWrap();
		if (generatedWrap < 0) {
			s.setWrap(-generatedWrap);
		} 
		s.setStatus(generatedWrap == 2 ? 57 : generatedWrap ? 42 : 113);
		strm.setAdler(generatedWrap == 2 ? ModernizedCProgram.crc32(-1024, 0, 0) : ModernizedCProgram.adler32(-1024, 0, 0));
		s.setLast_flush(0);
		s._tr_init();
		return 0;
	}
	/* ========================================================================= */
	public static int deflateReset(Object strm) {
		int ret;
		ret = ModernizedCProgram.deflateResetKeep(strm);
		if (ret == 0) {
			strm.getState().lm_init();
		} 
		return ret;
	}
	/* ========================================================================= */
	public static int deflateSetHeader(Object strm, Object head) {
		if (ModernizedCProgram.deflateStateCheck(strm) || strm.getState().getWrap() != 2) {
			return (true);
		} 
		strm.getState().setGzhead(head);
		return 0;
	}
	/* ========================================================================= */
	public static int deflatePending(Object strm, int pending, int bits) {
		if (ModernizedCProgram.deflateStateCheck(strm)) {
			return (true);
		} 
		if (pending != 0) {
			pending = strm.getState().getPending();
		} 
		if (bits != 0) {
			bits = strm.getState().getBi_valid();
		} 
		return 0;
	}
	/* ========================================================================= */
	public static int deflatePrime(Object strm, int bits, int value) {
		deflate_state s = new deflate_state();
		int put;
		if (ModernizedCProgram.deflateStateCheck(strm)) {
			return (true);
		} 
		s = strm.getState();
		Object generatedD_buf = s.getD_buf();
		Object generatedPending_out = s.getPending_out();
		if ((Bytef)(generatedD_buf) < generatedPending_out + ((16 + 7) >> 3)) {
			return (true);
		} 
		int generatedBi_valid = s.getBi_valid();
		Object generatedBi_buf = s.getBi_buf();
		do {
			put = 16 - generatedBi_valid;
			if (put > bits) {
				put = bits;
			} 
			generatedBi_buf |=  (ush)((value & ((1 << put) - 1)) << generatedBi_valid);
			generatedBi_valid += put;
			s._tr_flush_bits();
			value >>=  put;
			bits -= put;
		} while (bits);
		return 0;
	}
	/* ========================================================================= */
	public static int deflateParams(Object strm, int level, int strategy) {
		deflate_state s = new deflate_state();
		compress_func func = new compress_func();
		if (ModernizedCProgram.deflateStateCheck(strm)) {
			return (true);
		} 
		s = strm.getState();
		if (level == (true)) {
			level = 6;
		} 
		if (level < 0 || level > 9 || strategy < 0 || strategy > 4) {
			return (true);
		} 
		int generatedLevel = s.getLevel();
		func = ModernizedCProgram.configuration_table[generatedLevel].getFunc();
		int generatedStrategy = s.getStrategy();
		Object generatedHigh_water = s.getHigh_water();
		if ((strategy != generatedStrategy || func != ModernizedCProgram.configuration_table[level].getFunc()) && generatedHigh_water) {
			int err = ModernizedCProgram.deflate(strm, /* Flush the last buffer: */5);
			if (err == (true)) {
				return err;
			} 
			if (strm.getAvail_out() == 0) {
				return (true);
			} 
		} 
		Object generatedMatches = s.getMatches();
		Object generatedHead = s.getHead();
		Object generatedHash_size = s.getHash_size();
		if (generatedLevel != level) {
			if (generatedLevel == 0 && generatedMatches != 0) {
				if (generatedMatches == 1) {
					s.slide_hash();
				} else {
						generatedHead[generatedHash_size - 1] = 0;
				} 
				.memset((Bytef)generatedHead, 0, (int)(generatedHash_size - 1) * );
				;
				s.setMatches(0);
			} 
			s.setLevel(level);
			s.setMax_lazy_match(ModernizedCProgram.configuration_table[level].getMax_lazy());
			s.setGood_match(ModernizedCProgram.configuration_table[level].getGood_length());
			s.setNice_match(ModernizedCProgram.configuration_table[level].getNice_length());
			s.setMax_chain_length(ModernizedCProgram.configuration_table[level].getMax_chain());
		} 
		s.setStrategy(strategy);
		return 0;
	}
	/* ========================================================================= */
	public static int deflateTune(Object strm, int good_length, int max_lazy, int nice_length, int max_chain) {
		deflate_state s = new deflate_state();
		if (ModernizedCProgram.deflateStateCheck(strm)) {
			return (true);
		} 
		s = strm.getState();
		s.setGood_match((uInt)good_length);
		s.setMax_lazy_match((uInt)max_lazy);
		s.setNice_match(nice_length);
		s.setMax_chain_length((uInt)max_chain);
		return 0/* =========================================================================
		 * For the default windowBits of 15 and memLevel of 8, this function returns
		 * a close to exact, as well as small, upper bound on the compressed size.
		 * They are coded as constants here for a reason--if the #define's are
		 * changed, then this function needs to be changed as well.  The return
		 * value for 15 and 8 only works for those exact settings.
		 *
		 * For any setting other than those defaults for windowBits and memLevel,
		 * the value returned is a conservative worst case for the maximum expansion
		 * resulting from using fixed blocks instead of stored blocks, which deflate
		 * can emit on compressed data for some combinations of the parameters.
		 *
		 * This function could be more sophisticated to provide closer upper bounds for
		 * every combination of windowBits and memLevel.  But even the conservative
		 * upper bound of about 14% expansion does not seem onerous for output buffer
		 * allocation.
		 */;
	}
	public static Object deflateBound(Object strm, Object sourceLen) {
		deflate_state s = new deflate_state();
		uLong complen = new uLong();
		uLong wraplen = new uLong();
		complen = /* conservative upper bound for compressed data */sourceLen + ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
		if (ModernizedCProgram.deflateStateCheck(/* if can't get parameters, return conservative bound plus zlib wrapper */strm)) {
			return complen + 6;
		} 
		s = strm.getState();
		Object generatedStrstart = s.getStrstart();
		Object generatedGzhead = s.getGzhead();
		int generatedWrap = s.getWrap();
		switch (generatedWrap) {
		case /* raw deflate */0:
				wraplen = 0;
				break;
		case /* zlib wrapper */1:
				wraplen = 6 + (generatedStrstart ? 4 : 0);
				break;
		case /* gzip wrapper */2:
				wraplen = 18;
				if (generatedGzhead != /* user-supplied gzip header */0) {
					Bytef str = new Bytef();
					if (generatedGzhead.getExtra() != 0) {
						wraplen += 2 + generatedGzhead.getExtra_len();
					} 
					str = generatedGzhead.getName();
					if (str != 0) {
						do {
							wraplen++;
						} while (str++);
					} 
					str = generatedGzhead.getComment();
					if (str != 0) {
						do {
							wraplen++;
						} while (str++);
					} 
					if (generatedGzhead.getHcrc()) {
						wraplen += 2;
					} 
				} 
				break;
		default:
				wraplen = 6;
		}
		Object generatedW_bits = s.getW_bits();
		Object generatedHash_bits = s.getHash_bits();
		if (generatedW_bits != 15 || generatedHash_bits != 8 + /* if not default parameters, return conservative bound */7) {
			return complen + wraplen;
		} 
		return sourceLen + (sourceLen >> 12) + (sourceLen >> /* default settings: return tight bound for that case */14) + (sourceLen >> 25) + 13 - 6 + wraplen/* =========================================================================
		 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
		 * IN assertion: the stream state is correct and there is enough room in
		 * pending_buf.
		 */;
	}
	public static void flush_pending(Object strm) {
		int len;
		deflate_state s = strm.getState();
		s._tr_flush_bits();
		Object generatedPending = s.getPending();
		len = generatedPending;
		if (len > strm.getAvail_out()) {
			len = strm.getAvail_out();
		} 
		if (len == 0) {
			return ;
		} 
		Object generatedPending_out = s.getPending_out();
		.memcpy(strm.getNext_out(), generatedPending_out, len);
		strm.getNext_out() += len;
		generatedPending_out += len;
		strm.getTotal_out() += len;
		strm.getAvail_out() -= len;
		generatedPending -= len;
		Object generatedPending_buf = s.getPending_buf();
		if (generatedPending == 0) {
			s.setPending_out(generatedPending_buf);
		} 
	}
	/* ========================================================================= */
	public static int deflate(Object strm, int flush) {
		/* value of flush param for previous deflate call */int old_flush;
		deflate_state s = new deflate_state();
		if (ModernizedCProgram.deflateStateCheck(strm) || flush > 5 || flush < 0) {
			return (true);
		} 
		s = strm.getState();
		int generatedStatus = s.getStatus();
		if (strm.getNext_out() == 0 || (strm.getAvail_in() != 0 && strm.getNext_in() == 0) || (generatedStatus == 666 && flush != 4)) {
			return ();
		} 
		if (strm.getAvail_out() == 0) {
			return ();
		} 
		int generatedLast_flush = s.getLast_flush();
		old_flush = generatedLast_flush;
		s.setLast_flush(flush);
		Object generatedPending = s.getPending();
		if (generatedPending != /* Flush as much pending output as possible */0) {
			ModernizedCProgram.flush_pending(strm);
			if (strm.getAvail_out() == 0/* Since avail_out is 0, deflate will be called again with
			             * more output space, but possibly with both pending and
			             * avail_in equal to zero. There won't be anything to do,
			             * but this is not an error situation so make sure we
			             * return OK instead of BUF_ERROR at next call of deflate:
			             */) {
				s.setLast_flush(-1);
				return 0/* Make sure there is something to do and avoid duplicate consecutive
				     * flushes. For repeated and useless calls with Z_FINISH, we keep
				     * returning Z_STREAM_END instead of Z_BUF_ERROR.
				     */;
			} 
		}  else if (strm.getAvail_in() == 0 && (((flush) * 2) - ((flush) > 4 ? 9 : 0)) <= (((old_flush) * 2) - ((old_flush) > 4 ? 9 : 0)) && flush != 4) {
			return ();
		} 
		if (generatedStatus == 666 && strm.getAvail_in() != /* User must not provide more input after the first FINISH: */0) {
			return ();
		} 
		Object generatedW_bits = s.getW_bits();
		int generatedStrategy = s.getStrategy();
		int generatedLevel = s.getLevel();
		Object generatedStrstart = s.getStrstart();
		if (generatedStatus == /* Write the header */42) {
			uInt header = (8 + ((generatedW_bits - 8) << 4)) << /* zlib header */8;
			uInt level_flags = new uInt();
			if (generatedStrategy >= 2 || generatedLevel < 2) {
				level_flags = 0;
			}  else if (generatedLevel < 6) {
				level_flags = 1;
			}  else if (generatedLevel == 6) {
				level_flags = 2;
			} else {
					level_flags = 3;
			} 
			header |=  (level_flags << 6);
			if (generatedStrstart != 0) {
				header |=  -1024;
			} 
			header += 31 - (header % 31);
			s.putShortMSB(header);
			if (generatedStrstart != /* Save the adler32 of the preset dictionary: */0) {
				s.putShortMSB((uInt)(strm.getAdler() >> 16));
				s.putShortMSB((uInt)(strm.getAdler() & -1024));
			} 
			strm.setAdler(ModernizedCProgram.adler32(-1024, 0, 0));
			s.setStatus(113);
			ModernizedCProgram.flush_pending(/* Compression must start with an empty pending buffer */strm);
			if (generatedPending != 0) {
				s.setLast_flush(-1);
				return 0;
			} 
		} 
		Object generatedPending_buf = s.getPending_buf();
		Object generatedGzhead = s.getGzhead();
		if (generatedStatus == 57) {
			strm.setAdler(ModernizedCProgram.crc32(-1024, 0, /* gzip header */0));
			{ 
				generatedPending_buf[generatedPending++] = (Bytef)(true);
			}
			;
			{ 
				generatedPending_buf[generatedPending++] = (Bytef)(true);
			}
			;
			{ 
				generatedPending_buf[generatedPending++] = (Bytef)(true);
			}
			;
			if (generatedGzhead == 0) {
				{ 
					generatedPending_buf[generatedPending++] = (Bytef)(false);
				}
				;
				{ 
					generatedPending_buf[generatedPending++] = (Bytef)(false);
				}
				;
				{ 
					generatedPending_buf[generatedPending++] = (Bytef)(false);
				}
				;
				{ 
					generatedPending_buf[generatedPending++] = (Bytef)(false);
				}
				;
				{ 
					generatedPending_buf[generatedPending++] = (Bytef)(false);
				}
				;
				{ 
					generatedPending_buf[generatedPending++] = (Bytef)(generatedLevel == 9 ? 2 : (generatedStrategy >= 2 || generatedLevel < 2 ? 4 : 0));
				}
				;
				{ 
					generatedPending_buf[generatedPending++] = (Bytef)(true);
				}
				;
				s.setStatus(113);
				ModernizedCProgram.flush_pending(/* Compression must start with an empty pending buffer */strm);
				if (generatedPending != 0) {
					s.setLast_flush(-1);
					return 0;
				} 
			} else {
					{ 
						generatedPending_buf[generatedPending++] = (Bytef)((generatedGzhead.getText() ? 1 : 0) + (generatedGzhead.getHcrc() ? 2 : 0) + (generatedGzhead.getExtra() == 0 ? 0 : 4) + (generatedGzhead.getName() == 0 ? 0 : 8) + (generatedGzhead.getComment() == 0 ? 0 : 16));
					}
					;
					{ 
						generatedPending_buf[generatedPending++] = (Bytef)((Byte)(generatedGzhead.getTime() & -1024));
					}
					;
					{ 
						generatedPending_buf[generatedPending++] = (Bytef)((Byte)((generatedGzhead.getTime() >> 8) & -1024));
					}
					;
					{ 
						generatedPending_buf[generatedPending++] = (Bytef)((Byte)((generatedGzhead.getTime() >> 16) & -1024));
					}
					;
					{ 
						generatedPending_buf[generatedPending++] = (Bytef)((Byte)((generatedGzhead.getTime() >> 24) & -1024));
					}
					;
					{ 
						generatedPending_buf[generatedPending++] = (Bytef)(generatedLevel == 9 ? 2 : (generatedStrategy >= 2 || generatedLevel < 2 ? 4 : 0));
					}
					;
					{ 
						generatedPending_buf[generatedPending++] = (Bytef)(generatedGzhead.getOs() & -1024);
					}
					;
					if (generatedGzhead.getExtra() != 0) {
						{ 
							generatedPending_buf[generatedPending++] = (Bytef)(generatedGzhead.getExtra_len() & -1024);
						}
						;
						{ 
							generatedPending_buf[generatedPending++] = (Bytef)((generatedGzhead.getExtra_len() >> 8) & -1024);
						}
						;
					} 
					if (generatedGzhead.getHcrc()) {
						strm.setAdler(ModernizedCProgram.crc32(strm.getAdler(), generatedPending_buf, generatedPending));
					} 
					s.setGzindex(0);
					s.setStatus(69);
			} 
		} 
		Object generatedGzindex = s.getGzindex();
		Object generatedPending_buf_size = s.getPending_buf_size();
		if (generatedStatus == 69) {
			if (generatedGzhead.getExtra() != 0) {
				ulg beg = generatedPending;
				uInt left = (generatedGzhead.getExtra_len() & -1024) - generatedGzindex;
				while (generatedPending + left > generatedPending_buf_size) {
					uInt copy = generatedPending_buf_size - generatedPending;
					.memcpy(generatedPending_buf + generatedPending, generatedGzhead.getExtra() + generatedGzindex, copy);
					s.setPending(generatedPending_buf_size);
					do {
						if (generatedGzhead.getHcrc() && generatedPending > (beg)) {
							strm.setAdler(ModernizedCProgram.crc32(strm.getAdler(), generatedPending_buf + (beg), generatedPending - (beg)));
						} 
					} while (0);
					generatedGzindex += copy;
					ModernizedCProgram.flush_pending(strm);
					if (generatedPending != 0) {
						s.setLast_flush(-1);
						return 0;
					} 
					beg = 0;
					left -= copy;
				}
				.memcpy(generatedPending_buf + generatedPending, generatedGzhead.getExtra() + generatedGzindex, left);
				generatedPending += left;
				do {
					if (generatedGzhead.getHcrc() && generatedPending > (beg)) {
						strm.setAdler(ModernizedCProgram.crc32(strm.getAdler(), generatedPending_buf + (beg), generatedPending - (beg)));
					} 
				} while (0);
				s.setGzindex(0);
			} 
			s.setStatus(73);
		} 
		if (generatedStatus == 73) {
			if (generatedGzhead.getName() != 0) {
				ulg beg = generatedPending;
				int val;
				do {
					if (generatedPending == generatedPending_buf_size) {
						do {
							if (generatedGzhead.getHcrc() && generatedPending > (beg)) {
								strm.setAdler(ModernizedCProgram.crc32(strm.getAdler(), generatedPending_buf + (beg), generatedPending - (beg)));
							} 
						} while (0);
						ModernizedCProgram.flush_pending(strm);
						if (generatedPending != 0) {
							s.setLast_flush(-1);
							return 0;
						} 
						beg = 0;
					} 
					val = generatedGzhead.getName()[generatedGzindex++];
					{ 
						generatedPending_buf[generatedPending++] = (Bytef)(val);
					}
					;
				} while (val != 0);
				do {
					if (generatedGzhead.getHcrc() && generatedPending > (beg)) {
						strm.setAdler(ModernizedCProgram.crc32(strm.getAdler(), generatedPending_buf + (beg), generatedPending - (beg)));
					} 
				} while (0);
				s.setGzindex(0);
			} 
			s.setStatus(91);
		} 
		if (generatedStatus == 91) {
			if (generatedGzhead.getComment() != 0) {
				ulg beg = generatedPending;
				int val;
				do {
					if (generatedPending == generatedPending_buf_size) {
						do {
							if (generatedGzhead.getHcrc() && generatedPending > (beg)) {
								strm.setAdler(ModernizedCProgram.crc32(strm.getAdler(), generatedPending_buf + (beg), generatedPending - (beg)));
							} 
						} while (0);
						ModernizedCProgram.flush_pending(strm);
						if (generatedPending != 0) {
							s.setLast_flush(-1);
							return 0;
						} 
						beg = 0;
					} 
					val = generatedGzhead.getComment()[generatedGzindex++];
					{ 
						generatedPending_buf[generatedPending++] = (Bytef)(val);
					}
					;
				} while (val != 0);
				do {
					if (generatedGzhead.getHcrc() && generatedPending > (beg)) {
						strm.setAdler(ModernizedCProgram.crc32(strm.getAdler(), generatedPending_buf + (beg), generatedPending - (beg)));
					} 
				} while (0);
			} 
			s.setStatus(103);
		} 
		if (generatedStatus == 103) {
			if (generatedGzhead.getHcrc()) {
				if (generatedPending + 2 > generatedPending_buf_size) {
					ModernizedCProgram.flush_pending(strm);
					if (generatedPending != 0) {
						s.setLast_flush(-1);
						return 0;
					} 
				} 
				{ 
					generatedPending_buf[generatedPending++] = (Bytef)((Byte)(strm.getAdler() & -1024));
				}
				;
				{ 
					generatedPending_buf[generatedPending++] = (Bytef)((Byte)((strm.getAdler() >> 8) & -1024));
				}
				;
				strm.setAdler(ModernizedCProgram.crc32(-1024, 0, 0));
			} 
			s.setStatus(113);
			ModernizedCProgram.flush_pending(/* Compression must start with an empty pending buffer */strm);
			if (generatedPending != 0) {
				s.setLast_flush(-1);
				return 0;
			} 
		} 
		Object generatedLookahead = s.getLookahead();
		Object generatedHead = s.getHead();
		Object generatedHash_size = s.getHash_size();
		if (strm.getAvail_in() != 0 || generatedLookahead != /* Start a new block or continue the current one.
		     */0 || (flush != 0 && generatedStatus != 666)) {
			block_state bstate = new block_state();
			bstate = generatedLevel == 0 ? s.deflate_stored(flush) : generatedStrategy == 2 ? s.deflate_huff(flush) : generatedStrategy == 3 ? s.deflate_rle(flush) : .UNRECOGNIZEDFUNCTIONNAME(s, flush);
			if (bstate == .finish_started || bstate == .finish_done) {
				s.setStatus(666);
			} 
			if (bstate == .need_more || bstate == .finish_started) {
				if (strm.getAvail_out() == 0) {
					s.setLast_flush(-/* avoid BUF_ERROR next call, see above */1);
				} 
				return 0/* If flush != Z_NO_FLUSH && avail_out == 0, the next call
				             * of deflate should use the same flush parameter to make sure
				             * that the flush is complete. So we don't have to output an
				             * empty block here, this will be done at next call. This also
				             * ensures that for a very small output buffer, we emit at most
				             * one empty block.
				             */;
			} 
			if (bstate == .block_done) {
				if (flush == 1) {
					s._tr_align();
				}  else if (flush != /* FULL_FLUSH or SYNC_FLUSH */5) {
					s._tr_stored_block((byte)0, -1024, 0/* For a full flush, this empty block will be recognized
					                 * as a special marker by inflate_sync().
					                 */);
					if (flush == 3) {
						generatedHead[generatedHash_size - 1] = 0;
						.memset((Bytef)generatedHead, 0, (int)(generatedHash_size - 1) * );
						;
						if (generatedLookahead == 0) {
							s.setStrstart(0);
							s.setBlock_start(-1024);
							s.setInsert(0);
						} 
					} 
				} 
				ModernizedCProgram.flush_pending(strm);
				if (strm.getAvail_out() == 0) {
					s.setLast_flush(-/* avoid BUF_ERROR at next call, see above */1);
					return 0;
				} 
			} 
		} 
		if (flush != 4) {
			return 0;
		} 
		int generatedWrap = s.getWrap();
		if (generatedWrap <= 0) {
			return 1;
		} 
		if (generatedWrap == /* Write the trailer */2) {
			{ 
				generatedPending_buf[generatedPending++] = (Bytef)((Byte)(strm.getAdler() & -1024));
			}
			;
			{ 
				generatedPending_buf[generatedPending++] = (Bytef)((Byte)((strm.getAdler() >> 8) & -1024));
			}
			;
			{ 
				generatedPending_buf[generatedPending++] = (Bytef)((Byte)((strm.getAdler() >> 16) & -1024));
			}
			;
			{ 
				generatedPending_buf[generatedPending++] = (Bytef)((Byte)((strm.getAdler() >> 24) & -1024));
			}
			;
			{ 
				generatedPending_buf[generatedPending++] = (Bytef)((Byte)(strm.getTotal_in() & -1024));
			}
			;
			{ 
				generatedPending_buf[generatedPending++] = (Bytef)((Byte)((strm.getTotal_in() >> 8) & -1024));
			}
			;
			{ 
				generatedPending_buf[generatedPending++] = (Bytef)((Byte)((strm.getTotal_in() >> 16) & -1024));
			}
			;
			{ 
				generatedPending_buf[generatedPending++] = (Bytef)((Byte)((strm.getTotal_in() >> 24) & -1024));
			}
			;
		} else {
				s.putShortMSB((uInt)(strm.getAdler() >> 16));
				s.putShortMSB((uInt)(strm.getAdler() & -1024));
		} 
		ModernizedCProgram.flush_pending(strm/* If avail_out is zero, the application will call deflate again
		     * to flush the rest.
		     */);
		if (generatedWrap > 0) {
			s.setWrap(-generatedWrap);
		} 
		return generatedPending != 0 ? 0 : 1;
	}
	/* ========================================================================= */
	public static int deflateEnd(Object strm) {
		int status;
		if (ModernizedCProgram.deflateStateCheck(strm)) {
			return (true);
		} 
		status = strm.getState().getStatus();
		{ 
			if (strm.getState().getPending_buf()) {
				.UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (voidpf)(strm.getState().getPending_buf()));
			} 
		}
		;
		{ 
			if (strm.getState().getHead()) {
				.UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (voidpf)(strm.getState().getHead()));
			} 
		}
		;
		{ 
			if (strm.getState().getPrev()) {
				.UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (voidpf)(strm.getState().getPrev()));
			} 
		}
		;
		{ 
			if (strm.getState().getWindow()) {
				.UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (voidpf)(strm.getState().getWindow()));
			} 
		}
		;
		.UNRECOGNIZEDFUNCTIONNAME((strm).getOpaque(), (voidpf)(strm.getState()));
		strm.setState(0);
		return status == 113 ? (true) : 0/* =========================================================================
		 * Copy the source state to the destination state.
		 * To simplify the source, this is not supported for 16-bit MSDOS (which
		 * doesn't have enough memory anyway to duplicate compression states).
		 */;
	}
	public static int deflateCopy(Object dest, Object source) {
		deflate_state ds = new deflate_state();
		deflate_state ss = new deflate_state();
		ushf overlay = new ushf();
		if (ModernizedCProgram.deflateStateCheck(source) || dest == 0) {
			return (true);
		} 
		ss = source.getState();
		.memcpy((voidpf)dest, (voidpf)source, );
		ds = (deflate_state).UNRECOGNIZEDFUNCTIONNAME((dest).getOpaque(), (true), ());
		if (ds == 0) {
			return (true);
		} 
		dest.setState((internal_state)ds);
		.memcpy((voidpf)ds, (voidpf)ss, );
		ds.setStrm(dest);
		Object generatedW_size = ds.getW_size();
		ds.setWindow((Bytef).UNRECOGNIZEDFUNCTIONNAME((dest).getOpaque(), (generatedW_size), (2 * )));
		ds.setPrev((Posf).UNRECOGNIZEDFUNCTIONNAME((dest).getOpaque(), (generatedW_size), ()));
		Object generatedHash_size = ds.getHash_size();
		ds.setHead((Posf).UNRECOGNIZEDFUNCTIONNAME((dest).getOpaque(), (generatedHash_size), ()));
		Object generatedLit_bufsize = ds.getLit_bufsize();
		overlay = (ushf).UNRECOGNIZEDFUNCTIONNAME((dest).getOpaque(), (generatedLit_bufsize), ( + 2));
		ds.setPending_buf((uchf)overlay);
		Object generatedWindow = ds.getWindow();
		Object generatedPrev = ds.getPrev();
		Object generatedHead = ds.getHead();
		Object generatedPending_buf = ds.getPending_buf();
		if (generatedWindow == 0 || generatedPrev == 0 || generatedHead == 0 || generatedPending_buf == 0) {
			ModernizedCProgram.deflateEnd(dest);
			return (true);
		} 
		.memcpy(generatedWindow, generatedWindow, generatedW_size * 2 * /* following zmemcpy do not work for 16-bit MSDOS */);
		.memcpy((voidpf)generatedPrev, (voidpf)generatedPrev, generatedW_size * );
		.memcpy((voidpf)generatedHead, (voidpf)generatedHead, generatedHash_size * );
		Object generatedPending_buf_size = ds.getPending_buf_size();
		.memcpy(generatedPending_buf, generatedPending_buf, (uInt)generatedPending_buf_size);
		Object generatedPending_out = ss.getPending_out();
		ds.setPending_out(generatedPending_buf + (generatedPending_out - generatedPending_buf));
		ds.setD_buf(overlay + generatedLit_bufsize / );
		ds.setL_buf(generatedPending_buf + (1 + ) * generatedLit_bufsize);
		Object generatedDyn_ltree = ds.getDyn_ltree();
		tree_desc_s generatedL_desc = ds.getL_desc();
		generatedL_desc.setDyn_tree(generatedDyn_ltree);
		Object generatedDyn_dtree = ds.getDyn_dtree();
		tree_desc_s generatedD_desc = ds.getD_desc();
		generatedD_desc.setDyn_tree(generatedDyn_dtree);
		Object generatedBl_tree = ds.getBl_tree();
		tree_desc_s generatedBl_desc = ds.getBl_desc();
		generatedBl_desc.setDyn_tree(generatedBl_tree);
		return 0/* MAXSEG_64K *//* ===========================================================================
		 * Read a new buffer from the current input stream, update the adler32
		 * and total number of bytes read.  All deflate() input goes through
		 * this function so some applications may wish to modify it to avoid
		 * allocating a large strm->next_in buffer and copying from it.
		 * (See also flush_pending()).
		 */;
	}
	public static int read_buf(Object strm, Object buf, int size) {
		int len = strm.getAvail_in();
		if (len > size) {
			len = size;
		} 
		if (len == 0) {
			return 0;
		} 
		strm.getAvail_in() -= len;
		.memcpy(buf, strm.getNext_in(), len);
		if (strm.getState().getWrap() == 1) {
			strm.setAdler(ModernizedCProgram.adler32(strm.getAdler(), buf, len));
		}  else if (strm.getState().getWrap() == 2) {
			strm.setAdler(ModernizedCProgram.crc32(strm.getAdler(), buf, len));
		} 
		strm.getNext_in() += len;
		strm.getTotal_in() += len;
		return len/* ===========================================================================
		 * Initialize the "longest match" routines for a new zlib stream
		 */;
	}
	/* asm code initialization */
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static double try_run(hashcat_ctx hashcat_ctx, hc_device_param device_param, Object kernel_accel, Object kernel_loops) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		Object generatedKernel_params_buf32 = device_param.getKernel_params_buf32();
		generatedKernel_params_buf32[28] = 0;
		// not a bug, both need to be set// not a bug, both need to be setgeneratedKernel_params_buf32[29] = kernel_loops;
		// because there's two variables for inner iters for slow and fast hashes// because there's two variables for inner iters for slow and fast hashesgeneratedKernel_params_buf32[30] = kernel_loops;
		Object generatedHardware_power = device_param.getHardware_power();
		u32 kernel_power_try = generatedHardware_power * kernel_accel;
		double generatedSpin_damp = device_param.getSpin_damp();
		double spin_damp_sav = generatedSpin_damp;
		device_param.setSpin_damp(0);
		Object generatedAttack_exec = hashconfig.getAttack_exec();
		Object generatedOpti_type = hashconfig.getOpti_type();
		if (generatedAttack_exec == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
			if (generatedOpti_type & opti_type.OPTI_TYPE_OPTIMIZED_KERNEL) {
				ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_1, kernel_power_try, 1, 0);
			} else {
					ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_4, kernel_power_try, 1, 0);
			} 
		} else {
				ModernizedCProgram.run_kernel(hashcat_ctx, device_param, kern_run.KERN_RUN_2, kernel_power_try, 1, 0);
		} 
		device_param.setSpin_damp(spin_damp_sav);
		double exec_msec_prev = device_param.get_avg_exec_time(1);
		return exec_msec_prev/*
		static double try_run_preferred (hashcat_ctx_t *hashcat_ctx, hc_device_param_t *device_param, const u32 kernel_accel, const u32 kernel_loops)
		{
		  hashconfig_t *hashconfig = hashcat_ctx->hashconfig;
		
		  device_param->kernel_params_buf32[28] = 0;
		  device_param->kernel_params_buf32[29] = kernel_loops; // not a bug, both need to be set
		  device_param->kernel_params_buf32[30] = kernel_loops; // because there's two variables for inner iters for slow and fast hashes
		
		  const u32 kernel_power_try = device_param->hardware_power * kernel_accel;
		
		  const u32 kernel_threads_sav = device_param->kernel_threads;
		
		  const double spin_damp_sav = device_param->spin_damp;
		
		  device_param->spin_damp = 0;
		
		  if (hashconfig->attack_exec == ATTACK_EXEC_INSIDE_KERNEL)
		  {
		    if (hashconfig->opti_type & OPTI_TYPE_OPTIMIZED_KERNEL)
		    {
		      device_param->kernel_threads = device_param->kernel_preferred_wgs_multiple1;
		
		      run_kernel (hashcat_ctx, device_param, KERN_RUN_1, kernel_power_try, true, 0);
		    }
		    else
		    {
		      device_param->kernel_threads = device_param->kernel_preferred_wgs_multiple4;
		
		      run_kernel (hashcat_ctx, device_param, KERN_RUN_4, kernel_power_try, true, 0);
		    }
		  }
		  else
		  {
		    device_param->kernel_threads = device_param->kernel_preferred_wgs_multiple2;
		
		    run_kernel (hashcat_ctx, device_param, KERN_RUN_2, kernel_power_try, true, 0);
		  }
		
		  device_param->kernel_threads = kernel_threads_sav;
		
		  device_param->spin_damp = spin_damp_sav;
		
		  const double exec_msec_prev = get_avg_exec_time (device_param, 1);
		
		  return exec_msec_prev;
		}
		*/;
	}
	public static int autotune(hashcat_ctx hashcat_ctx, hc_device_param device_param) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		backend_ctx generatedBackend_ctx = hashcat_ctx.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		straight_ctx generatedStraight_ctx = hashcat_ctx.getStraight_ctx();
		straight_ctx_t straight_ctx = generatedStraight_ctx;
		user_options generatedUser_options = hashcat_ctx.getUser_options();
		user_options_t user_options = generatedUser_options;
		double target_msec = backend_ctx.getTarget_msec();
		Object generatedKernel_accel_min = device_param.getKernel_accel_min();
		u32 kernel_accel_min = generatedKernel_accel_min;
		Object generatedKernel_accel_max = device_param.getKernel_accel_max();
		u32 kernel_accel_max = generatedKernel_accel_max;
		Object generatedKernel_loops_min = device_param.getKernel_loops_min();
		u32 kernel_loops_min = generatedKernel_loops_min;
		Object generatedKernel_loops_max = device_param.getKernel_loops_max();
		u32 kernel_loops_max = generatedKernel_loops_max;
		u32 kernel_accel = kernel_accel_min;
		u32 kernel_loops = kernel_loops_min;
		// in this case the user specified a fixed -n and -u on the commandline// no way to tune anything
		Object generatedHardware_power = device_param.getHardware_power();
		Object generatedKernel_accel = device_param.getKernel_accel();
		// but we need to run a few caching roundsif ((kernel_accel_min == kernel_accel_max) && (kernel_loops_min == kernel_loops_max)) {
			if (hashconfig.getWarmup_disable() == 0) {
				ModernizedCProgram.try_run(hashcat_ctx, device_param, kernel_accel, kernel_loops);
				ModernizedCProgram.try_run(hashcat_ctx, device_param, kernel_accel, kernel_loops);
				ModernizedCProgram.try_run(hashcat_ctx, device_param, kernel_accel, kernel_loops);
				ModernizedCProgram.try_run(hashcat_ctx, device_param, kernel_accel, kernel_loops);
			} 
			device_param.setKernel_accel(kernel_accel);
			device_param.setKernel_loops(kernel_loops);
			u32 kernel_power = generatedHardware_power * generatedKernel_accel;
			device_param.setKernel_power(kernel_power);
			return 0;
		} 
		// don't do any autotune in debug mode in this case
		// so let's init some fake wordsu32 kernel_power_max = generatedHardware_power * kernel_accel_max;
		int CL_rc;
		int CU_rc;
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_d_pws_buf = device_param.getCuda_d_pws_buf();
		if (generatedIs_cuda == true) {
			CU_rc = ModernizedCProgram.run_cuda_kernel_atinit(hashcat_ctx, device_param, generatedCuda_d_pws_buf, kernel_power_max);
			if (CU_rc == -1) {
				return -1;
			} 
		} 
		boolean generatedIs_opencl = device_param.getIs_opencl();
		Object generatedOpencl_d_pws_buf = device_param.getOpencl_d_pws_buf();
		if (generatedIs_opencl == true) {
			CL_rc = ModernizedCProgram.run_opencl_kernel_atinit(hashcat_ctx, device_param, generatedOpencl_d_pws_buf, kernel_power_max);
			if (CL_rc == -1) {
				return -1;
			} 
		} 
		Object generatedCuda_d_rules_c = device_param.getCuda_d_rules_c();
		Object generatedCuda_d_rules = device_param.getCuda_d_rules();
		Object generatedOpencl_command_queue = device_param.getOpencl_command_queue();
		Object generatedOpencl_d_rules = device_param.getOpencl_d_rules();
		Object generatedOpencl_d_rules_c = device_param.getOpencl_d_rules_c();
		if (user_options.getSlow_candidates() == 1) {
		} else {
				if (hashconfig.getAttack_exec() == attack_exec.ATTACK_EXEC_INSIDE_KERNEL) {
					if (straight_ctx.getKernel_rules_cnt() > 1) {
						if (generatedIs_cuda == true) {
							CU_rc = hashcat_ctx.hc_cuMemcpyDtoD(generatedCuda_d_rules_c, generatedCuda_d_rules, (((kernel_loops_max) < (amplifier_count.KERNEL_RULES)) ? (kernel_loops_max) : (amplifier_count.KERNEL_RULES)) * );
							if (CU_rc == -1) {
								return -1;
							} 
						} 
						if (generatedIs_opencl == true) {
							CL_rc = hashcat_ctx.hc_clEnqueueCopyBuffer(generatedOpencl_command_queue, generatedOpencl_d_rules, generatedOpencl_d_rules_c, 0, 0, (((kernel_loops_max) < (amplifier_count.KERNEL_RULES)) ? (kernel_loops_max) : (amplifier_count.KERNEL_RULES)) * , 0, ((Object)0), ((Object)0));
							if (CL_rc == -1) {
								return -1;
							} 
						} 
					} 
				} 
		} 
		// Do a pre-autotune test run to find out if kernel runtime is above some TDR limitu32 kernel_loops_max_reduced = kernel_loops_max;
		if (1) {
			double exec_msec = ModernizedCProgram.try_run(hashcat_ctx, device_param, kernel_accel_min, kernel_loops_min);
			if (exec_msec > 2000) {
				hashcat_ctx.event_log_error("Kernel minimum runtime larger than default TDR");
				return -1;
			} 
			exec_msec = ModernizedCProgram.try_run(hashcat_ctx, device_param, kernel_accel_min, kernel_loops_min);
			u32 mm = kernel_loops_max / kernel_loops_min;
			if ((exec_msec * mm) > target_msec) {
				u32 loops_valid = (u32)(target_msec / exec_msec);
				kernel_loops_max_reduced = kernel_loops_min * loops_valid;
			} 
		} 
		// first find out highest kernel-loops that stays below target_msecif (kernel_loops_min < kernel_loops_max) {
			for (kernel_loops = kernel_loops_max; kernel_loops > kernel_loops_min; kernel_loops >>=  1) {
				if (kernel_loops > kernel_loops_max_reduced) {
					continue;
				} 
				double exec_msec = ModernizedCProgram.try_run(hashcat_ctx, device_param, kernel_accel_min, kernel_loops);
				if (exec_msec < target_msec) {
					break;
				} 
			}
		} 
		if (kernel_accel_min < kernel_accel_max) {
			for (int i = 0;
			 i < 16; i++) {
				u32 kernel_accel_try = -1024 << i;
				if (kernel_accel_try < kernel_accel_min) {
					continue;
				} 
				if (kernel_accel_try > kernel_accel_max) {
					break;
				} 
				double exec_msec = ModernizedCProgram.try_run(hashcat_ctx, device_param, kernel_accel_try, kernel_loops);
				if (exec_msec > target_msec) {
					break;
				} 
				kernel_accel = kernel_accel_try;
			}
		} 
		// now find the middle balance between kernel_accel and kernel_loops// while respecting allowed ranges at the same timeif (kernel_accel < kernel_loops) {
			u32 kernel_accel_orig = kernel_accel;
			u32 kernel_loops_orig = kernel_loops;
			double exec_msec_prev = ModernizedCProgram.try_run(hashcat_ctx, device_param, kernel_accel, kernel_loops);
			for (int i = 1;
			 i < 16; i++) {
				u32 kernel_accel_try = kernel_accel_orig * (-1024 << i);
				u32 kernel_loops_try = kernel_loops_orig / (-1024 << i);
				if (kernel_accel_try < kernel_accel_min) {
					continue;
				} 
				if (kernel_accel_try > kernel_accel_max) {
					break;
				} 
				if (kernel_loops_try > kernel_loops_max) {
					continue;
				} 
				if (kernel_loops_try < kernel_loops_min) {
					break;
				} 
				double exec_msec = ModernizedCProgram.try_run(hashcat_ctx, device_param, kernel_accel_try, kernel_loops_try);
				if (exec_msec_prev < exec_msec) {
					break;
				} 
				exec_msec_prev = exec_msec;
				kernel_accel = kernel_accel_try;
				kernel_loops = kernel_loops_try;
				if (kernel_loops_try < kernel_accel_try) {
					break;
				} 
			}
		} 
		double exec_msec_pre_final = ModernizedCProgram.try_run(hashcat_ctx, device_param, kernel_accel, kernel_loops);
		u32 exec_left = (u32)(target_msec / exec_msec_pre_final);
		u32 accel_left = kernel_accel_max / kernel_accel;
		// we want that to be intu32 exec_accel_min = (((exec_left) < (accel_left)) ? (exec_left) : (accel_left));
		if (exec_accel_min >= 1) {
			kernel_accel *= exec_accel_min;
		} 
		// this is safe to not overflow kernel_accel_max because of accel_left
		Object generatedSize_pws = device_param.getSize_pws();
		Object generatedCuda_d_plain_bufs = device_param.getCuda_d_plain_bufs();
		Object generatedSize_plains = device_param.getSize_plains();
		Object generatedCuda_d_digests_shown = device_param.getCuda_d_digests_shown();
		Object generatedSize_shown = device_param.getSize_shown();
		Object generatedCuda_d_result = device_param.getCuda_d_result();
		Object generatedSize_results = device_param.getSize_results();
		if (generatedIs_cuda == true) {
			CU_rc = ModernizedCProgram.run_cuda_kernel_memset(hashcat_ctx, device_param, generatedCuda_d_pws_buf, 0, generatedSize_pws);
			if (CU_rc == -1) {
				return -1;
			} 
			CU_rc = ModernizedCProgram.run_cuda_kernel_memset(hashcat_ctx, device_param, generatedCuda_d_plain_bufs, 0, generatedSize_plains);
			if (CU_rc == -1) {
				return -1;
			} 
			CU_rc = ModernizedCProgram.run_cuda_kernel_memset(hashcat_ctx, device_param, generatedCuda_d_digests_shown, 0, generatedSize_shown);
			if (CU_rc == -1) {
				return -1;
			} 
			CU_rc = ModernizedCProgram.run_cuda_kernel_memset(hashcat_ctx, device_param, generatedCuda_d_result, 0, generatedSize_results);
			if (CU_rc == -1) {
				return -1;
			} 
		} 
		// reset them fake words
		Object generatedOpencl_d_plain_bufs = device_param.getOpencl_d_plain_bufs();
		Object generatedOpencl_d_digests_shown = device_param.getOpencl_d_digests_shown();
		Object generatedOpencl_d_result = device_param.getOpencl_d_result();
		if (generatedIs_opencl == true) {
			CL_rc = ModernizedCProgram.run_opencl_kernel_memset(hashcat_ctx, device_param, generatedOpencl_d_pws_buf, 0, generatedSize_pws);
			if (CL_rc == -1) {
				return -1;
			} 
			CL_rc = ModernizedCProgram.run_opencl_kernel_memset(hashcat_ctx, device_param, generatedOpencl_d_plain_bufs, 0, generatedSize_plains);
			if (CL_rc == -1) {
				return -1;
			} 
			CL_rc = ModernizedCProgram.run_opencl_kernel_memset(hashcat_ctx, device_param, generatedOpencl_d_digests_shown, 0, generatedSize_shown);
			if (CL_rc == -1) {
				return -1;
			} 
			CL_rc = ModernizedCProgram.run_opencl_kernel_memset(hashcat_ctx, device_param, generatedOpencl_d_result, 0, generatedSize_results);
			if (CL_rc == -1) {
				return -1;
			} 
		} 
		// reset them fake words
		// reset timer// reset timerdevice_param.setExec_pos(0);
		Object generatedExec_msec = device_param.getExec_msec();
		.memset(generatedExec_msec, 0, 128 * );
		Object generatedExec_us_prev1 = device_param.getExec_us_prev1();
		.memset(generatedExec_us_prev1, 0, 10000 * );
		Object generatedExec_us_prev2 = device_param.getExec_us_prev2();
		.memset(generatedExec_us_prev2, 0, 10000 * );
		Object generatedExec_us_prev3 = device_param.getExec_us_prev3();
		.memset(generatedExec_us_prev3, 0, 10000 * );
		Object generatedExec_us_prev4 = device_param.getExec_us_prev4();
		.memset(generatedExec_us_prev4, 0, 10000 * );
		Object generatedExec_us_prev_init2 = device_param.getExec_us_prev_init2();
		.memset(generatedExec_us_prev_init2, 0, 10000 * );
		Object generatedExec_us_prev_loop2 = device_param.getExec_us_prev_loop2();
		.memset(generatedExec_us_prev_loop2, 0, 10000 * );
		Object generatedExec_us_prev_aux1 = device_param.getExec_us_prev_aux1();
		.memset(generatedExec_us_prev_aux1, 0, 10000 * );
		Object generatedExec_us_prev_aux2 = device_param.getExec_us_prev_aux2();
		.memset(generatedExec_us_prev_aux2, 0, 10000 * );
		Object generatedExec_us_prev_aux3 = device_param.getExec_us_prev_aux3();
		.memset(generatedExec_us_prev_aux3, 0, 10000 * );
		Object generatedExec_us_prev_aux4 = device_param.getExec_us_prev_aux4();
		.memset(generatedExec_us_prev_aux4, 0, 10000 * )// store;// store
		device_param.setKernel_accel(kernel_accel);
		device_param.setKernel_loops(kernel_loops);
		u32 kernel_power = generatedHardware_power * generatedKernel_accel;
		device_param.setKernel_power(kernel_power);
		return 0;
	}
	public static Object thread_autotune(Object p) {
		thread_param_t thread_param = (thread_param_t)p;
		hashcat_ctx generatedHashcat_ctx = thread_param.getHashcat_ctx();
		hashcat_ctx_t hashcat_ctx = generatedHashcat_ctx;
		backend_ctx generatedBackend_ctx = hashcat_ctx.getBackend_ctx();
		backend_ctx_t backend_ctx = generatedBackend_ctx;
		boolean generatedEnabled = backend_ctx.getEnabled();
		if (generatedEnabled == false) {
			return ((Object)0);
		} 
		hc_device_param generatedDevices_param = backend_ctx.getDevices_param();
		Object generatedTid = thread_param.getTid();
		hc_device_param_t device_param = generatedDevices_param + generatedTid;
		boolean generatedSkipped = device_param.getSkipped();
		if (generatedSkipped == true) {
			return ((Object)0);
		} 
		boolean generatedSkipped_warning = device_param.getSkipped_warning();
		if (generatedSkipped_warning == true) {
			return ((Object)0);
		} 
		boolean generatedIs_cuda = device_param.getIs_cuda();
		Object generatedCuda_context = device_param.getCuda_context();
		if (generatedIs_cuda == true) {
			int rc_cuCtxSetCurrent = hashcat_ctx.hc_cuCtxSetCurrent(generatedCuda_context);
			if (rc_cuCtxSetCurrent == -1) {
				return ((Object)0);
			} 
		} 
		int rc_autotune = ModernizedCProgram.autotune(hashcat_ctx, device_param);
		if (rc_autotune == -1) {
		} 
		// we should do something here, tell hashcat main that autotune failed to abort
		return ((Object)0);
	}
	/* XzDec.c -- Xz Decode
	2019-02-02 : Igor Pavlov : Public domain */
	// #include <stdio.h>
	// #define XZ_DUMP
	/* #define XZ_DUMP */
	// #define SHOW_DEBUG_INFO
	// #define USE_SUBBLOCK
	public static int Xz_ReadVarInt(Object p, Object maxSize, Object value) {
		int i;
		int limit;
		value = 0;
		limit = (maxSize > 9) ? 9 : (int)maxSize;
		for (i = 0; i < limit; ) {
			Byte b = p[i];
			value |=  (UInt64)(b & -1024) << (7 * i++);
			if ((b & -1024) == 0) {
				return (b == 0 && i != 1) ? 0 : i;
			} 
		}
		return 0/* ---------- BraState ---------- */;
	}
	public static void BraState_Free(Object pp, Object alloc) {
		.UNRECOGNIZEDFUNCTIONNAME(alloc, pp);
	}
	public static Object BraState_SetProps(Object pp, Object props, Object propSize, Object alloc) {
		CBraState p = ((CBraState)pp);
		(Object)alloc;
		;
		p.setIp(0);
		Object generatedMethodId = p.getMethodId();
		if (generatedMethodId == 3) {
			if (propSize != 1) {
				return 4;
			} 
			p.setDelta((int)props[0] + 1);
		} else {
				if (propSize == 4) {
					UInt32 v = ((UInt32)(Object)(props));
					switch (generatedMethodId) {
					case 6:
							if ((v & -1024) != 0) {
								return 4;
							} 
							break;
					case 5:
					case 7:
					case 9:
							if ((v & 3) != 0) {
								return 4;
							} 
							break;
					case 8:
							if ((v & 1) != 0) {
								return 4;
							} 
							break;
					}
					p.setIp(v);
				}  else if (propSize != 0) {
					return 4;
				} 
		} 
		return 0;
	}
	public static void BraState_Init(Object pp) {
		CBraState p = ((CBraState)pp);
		p.setBufPos(p.setBufConv(p.setBufTotal(0)));
		{ 
			p.setX86State(0);
		}
		;
		Object generatedMethodId = p.getMethodId();
		Object generatedDeltaState = p.getDeltaState();
		if (generatedMethodId == 3) {
			ModernizedCProgram.Delta_Init(generatedDeltaState);
		} 
	}
	public static Object BraState_Filter(Object pp, Object data, Object size) {
		CBraState p = ((CBraState)pp);
		Object generatedEncodeMode = p.getEncodeMode();
		Object generatedDeltaState = p.getDeltaState();
		Object generatedDelta = p.getDelta();
		Object generatedIp = p.getIp();
		Object generatedX86State = p.getX86State();
		Object generatedMethodId = p.getMethodId();
		switch (generatedMethodId) {
		case 8:
				size = ModernizedCProgram.ARMT_Convert(data, size, generatedIp, generatedEncodeMode);
				break;
		case 3:
				if (generatedEncodeMode) {
					ModernizedCProgram.Delta_Encode(generatedDeltaState, generatedDelta, data, size);
				} else {
						ModernizedCProgram.Delta_Decode(generatedDeltaState, generatedDelta, data, size);
				} 
				break;
		case 5:
				size = ModernizedCProgram.PPC_Convert(data, size, generatedIp, generatedEncodeMode);
				break;
		case 9:
				size = ModernizedCProgram.SPARC_Convert(data, size, generatedIp, generatedEncodeMode);
				break;
		case 6:
				size = ModernizedCProgram.IA64_Convert(data, size, generatedIp, generatedEncodeMode);
				break;
		case 7:
				size = ModernizedCProgram.ARM_Convert(data, size, generatedIp, generatedEncodeMode);
				break;
		case 4:
				size = ModernizedCProgram.x86_Convert(data, size, generatedIp, generatedX86State, generatedEncodeMode);
				break;
		}
		generatedIp += (UInt32)size;
		return size;
	}
	public static Object BraState_Code2(Object pp, Object dest, Object destLen, Object src, Object srcLen, int srcWasFinished,  finishMode,  status) {
		// int *wasFinishedCBraState p = ((CBraState)pp);
		SizeT destRem = destLen;
		SizeT srcRem = srcLen;
		(Object)finishMode;
		;
		destLen = 0;
		srcLen = 0// *wasFinished = False;;// *wasFinished = False;
		status = .CODER_STATUS_NOT_FINISHED;
		Object generatedBufPos = p.getBufPos();
		Object generatedBufConv = p.getBufConv();
		Object generatedBuf = p.getBuf();
		Object generatedBufTotal = p.getBufTotal();
		while (destRem > 0) {
			if (generatedBufPos != generatedBufConv) {
				size_t size = generatedBufConv - generatedBufPos;
				if (ModernizedCProgram.size > destRem) {
					ModernizedCProgram.size = destRem;
				} 
				.memcpy(dest, generatedBuf + generatedBufPos, ModernizedCProgram.size);
				generatedBufPos += ModernizedCProgram.size;
				destLen += ModernizedCProgram.size;
				dest += ModernizedCProgram.size;
				destRem -= ModernizedCProgram.size;
				continue;
			} 
			generatedBufTotal -= generatedBufPos;
			.memmove(generatedBuf, generatedBuf + generatedBufPos, generatedBufTotal);
			p.setBufPos(0);
			p.setBufConv(0);
			{ 
				size_t size = (1 << 14) - generatedBufTotal;
				if (ModernizedCProgram.size > srcRem) {
					ModernizedCProgram.size = srcRem;
				} 
				.memcpy(generatedBuf + generatedBufTotal, src, ModernizedCProgram.size);
				srcLen += ModernizedCProgram.size;
				src += ModernizedCProgram.size;
				srcRem -= ModernizedCProgram.size;
				generatedBufTotal += ModernizedCProgram.size;
			}
			if (generatedBufTotal == 0) {
				break;
			} 
			p.setBufConv(ModernizedCProgram.BraState_Filter(pp, generatedBuf, generatedBufTotal));
			if (generatedBufConv == 0) {
				if (!srcWasFinished) {
					break;
				} 
				p.setBufConv(generatedBufTotal);
			} 
		}
		if (generatedBufTotal == generatedBufPos && srcRem == 0 && srcWasFinished) {
			status = .CODER_STATUS_FINISHED_WITH_MARK;
		} 
		return 0;
	}
	public static void Lzma2State_Free(Object pp, Object alloc) {
		CLzma2Dec_Spec p = (CLzma2Dec_Spec)pp;
		Object generatedOutBufMode = p.getOutBufMode();
		Object generatedDecoder = p.getDecoder();
		if (generatedOutBufMode) {
			(generatedDecoder).getDecoder().LzmaDec_FreeProbs(alloc);
		} else {
				generatedDecoder.LzmaDec_Free(alloc);
		} 
		.UNRECOGNIZEDFUNCTIONNAME(alloc, pp);
	}
	public static Object Lzma2State_SetProps(Object pp, Object props, Object propSize, Object alloc) {
		if (propSize != 1) {
			return 4;
		} 
		Object generatedOutBufMode = p.getOutBufMode();
		Object generatedDecoder = p.getDecoder();
		{ 
			CLzma2Dec_Spec p = (CLzma2Dec_Spec)pp;
			if (generatedOutBufMode) {
				return generatedDecoder.Lzma2Dec_AllocateProbs(props[0], alloc);
			} else {
					return generatedDecoder.Lzma2Dec_Allocate(props[0], alloc);
			} 
		}
	}
	public static void Lzma2State_Init(Object pp) {
		((CLzma2Dec_Spec)pp).getDecoder().Lzma2Dec_Init();
	}
	public static Object Lzma2State_Code2(Object pp, Object dest, Object destLen, Object src, Object srcLen, int srcWasFinished,  finishMode,  status) {
		CLzma2Dec_Spec spec = (CLzma2Dec_Spec)pp;
		ELzmaStatus status2 = new ELzmaStatus();
		/* ELzmaFinishMode fm = (finishMode == LZMA_FINISH_ANY) ? LZMA_FINISH_ANY : LZMA_FINISH_END; */
		SRes res = new SRes();
		(Object)srcWasFinished;
		;
		Object generatedOutBufMode = spec.getOutBufMode();
		Object generatedDecoder = spec.getDecoder();
		if (generatedOutBufMode) {
			SizeT dicPos = generatedDecoder.getDecoder().getDicPos();
			SizeT dicLimit = dicPos + destLen;
			res = generatedDecoder.Lzma2Dec_DecodeToDic(dicLimit, src, srcLen, (ELzmaFinishMode)finishMode, status2);
			destLen = generatedDecoder.getDicPos() - dicPos;
		} else {
				res = generatedDecoder.Lzma2Dec_DecodeToBuf(dest, destLen, src, srcLen, (ELzmaFinishMode)finishMode, status2);
		} 
		// ECoderStatus values are identical to ELzmaStatus values of LZMA2 decoder// ECoderStatus values are identical to ELzmaStatus values of LZMA2 decoderstatus = (ECoderStatus)status2;
		return res;
	}
	// int *wasFinished,
	public static void MixCoder_Construct(Object alloc) {
		int i;
		this.setAlloc(alloc);
		this.setBuf(((Object)0));
		this.setNumCoders(0);
		this.setOutBufSize(0);
		this.setOutBuf(((Object)0))// p->SingleBufMode = False;;// p->SingleBufMode = False;
		Object generatedCoders = this.getCoders();
		for (i = 0; i < 4; i++) {
			generatedCoders[i].setP(((Object)0));
		}
	}
	public static void MixCoder_Free() {
		int i;
		this.setNumCoders(0);
		Object generatedCoders = this.getCoders();
		Object generatedP = sc.getP();
		Object generatedAlloc = this.getAlloc();
		for (i = 0; i < 4; i++) {
			IStateCoder sc = generatedCoders[i];
			if (generatedP) {
				.UNRECOGNIZEDFUNCTIONNAME(generatedP, generatedAlloc);
				sc.setP(((Object)0));
			} 
		}
		Object generatedBuf = this.getBuf();
		if (generatedBuf) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedAlloc, generatedBuf);
			this.setBuf(((Object)/* 9.31: the BUG was fixed */0));
		} 
	}
	public static void MixCoder_Init() {
		int i;
		Object generatedSize = this.getSize();
		Object generatedPos = this.getPos();
		Object generatedFinished = this.getFinished();
		for (i = 0; i < 4 - 1; i++) {
			generatedSize[i] = 0;
			generatedPos[i] = 0;
			generatedFinished[i] = 0;
		}
		Object generatedNumCoders = this.getNumCoders();
		Object generatedCoders = this.getCoders();
		Object generatedP = coder.getP();
		Object generatedResults = this.getResults();
		for (i = 0; i < generatedNumCoders; i++) {
			IStateCoder coder = generatedCoders[i];
			.UNRECOGNIZEDFUNCTIONNAME(generatedP);
			generatedResults[i] = 0;
		}
		this.setOutWritten(0);
		this.setWasFinished(0);
		this.setRes(0);
		this.setStatus(.CODER_STATUS_NOT_SPECIFIED);
	}
	public static Object MixCoder_SetFromMethod(int coderIndex, Object methodId, Object outBuf, Object outBufSize) {
		Object generatedCoders = this.getCoders();
		IStateCoder sc = generatedCoders[coderIndex];
		Object generatedIds = this.getIds();
		generatedIds[coderIndex] = methodId;
		Object generatedAlloc = this.getAlloc();
		switch (methodId) {
		case -1024:
				return sc.Lzma2State_SetFromMethod(outBuf, outBufSize, generatedAlloc);
		}
		if (coderIndex == 0) {
			return 4;
		} 
		return sc.BraState_SetFromMethod(methodId, 0, generatedAlloc);
	}
	public static Object MixCoder_ResetFromMethod(int coderIndex, Object methodId, Object outBuf, Object outBufSize) {
		Object generatedCoders = this.getCoders();
		IStateCoder sc = generatedCoders[coderIndex];
		switch (methodId) {
		case -1024:
				return sc.Lzma2State_ResetOutBuf(outBuf, outBufSize);
		}
		return 4/*
		 if (destFinish) - then unpack data block is finished at (*destLen) position,
		                   and we can return data that were not processed by filter
		
		output (status) can be :
		  CODER_STATUS_NOT_FINISHED
		  CODER_STATUS_FINISHED_WITH_MARK
		  CODER_STATUS_NEEDS_MORE_INPUT - not implemented still
		*/;
	}
	public static Object MixCoder_Code(Object dest, Object destLen, int destFinish, Object src, Object srcLen, int srcWasFinished,  finishMode) {
		SizeT destLenOrig = destLen;
		SizeT srcLenOrig = srcLen;
		destLen = 0;
		srcLen = 0;
		Object generatedWasFinished = this.getWasFinished();
		Object generatedRes = this.getRes();
		if (generatedWasFinished) {
			return generatedRes;
		} 
		this.setStatus(.CODER_STATUS_NOT_FINISHED);
		Object generatedOutBuf = this.getOutBuf();
		Object generatedCoders = this.getCoders();
		Object generatedP = coder.getP();
		Object generatedStatus = this.getStatus();
		Object generatedOutWritten = this.getOutWritten();
		Object generatedNumCoders = this.getNumCoders();
		// if (p->SingleBufMode)if (generatedOutBuf) {
			SRes res = new SRes();
			SizeT destLen2 = new SizeT();
			SizeT srcLen2 = new SizeT();
			int wasFinished;
			;
			srcLen2 = srcLenOrig;
			destLen2 = destLenOrig;
			{ 
				IStateCoder coder = generatedCoders[0];
				res = .UNRECOGNIZEDFUNCTIONNAME(generatedP, ((Object)0), destLen2, src, srcLen2, srcWasFinished, finishMode, generatedStatus);
				wasFinished = (generatedStatus == .CODER_STATUS_FINISHED_WITH_MARK);
			}
			this.setRes(res/*
			    if (wasFinished)
			      p->status = CODER_STATUS_FINISHED_WITH_MARK;
			    else
			    {
			      if (res == SZ_OK)
			        if (destLen2 != destLenOrig)
			          p->status = CODER_STATUS_NEEDS_MORE_INPUT;
			    }
			    */);
			srcLen = srcLen2;
			src += srcLen2;
			generatedOutWritten += destLen2;
			if (res != 0 || srcWasFinished || wasFinished) {
				this.setWasFinished(1);
			} 
			if (generatedNumCoders == 1) {
				destLen = destLen2;
			}  else if (generatedWasFinished) {
				int i;
				size_t processed = generatedOutWritten;
				for (i = 1; i < generatedNumCoders; i++) {
					IStateCoder coder = generatedCoders[i];
					processed = .UNRECOGNIZEDFUNCTIONNAME(generatedP, generatedOutBuf, processed);
					if (wasFinished || (destFinish && generatedOutWritten == destLenOrig)) {
						processed = generatedOutWritten;
					} 
					;
				}
				destLen = processed;
			} 
			return res;
		} 
		;
		Object generatedBuf = this.getBuf();
		Object generatedAlloc = this.getAlloc();
		if (generatedNumCoders != 1) {
			if (!generatedBuf) {
				this.setBuf((Byte).UNRECOGNIZEDFUNCTIONNAME(generatedAlloc, ((size_t)1 << 17) * (4 - 1)));
				if (!generatedBuf) {
					return 2;
				} 
			} 
			finishMode = .CODER_FINISH_ANY;
		} 
		Object generatedPos = this.getPos();
		Object generatedSize = this.getSize();
		Object generatedFinished = this.getFinished();
		Object generatedResults = this.getResults();
		for (; ; ) {
			BoolInt processed = 0;
			BoolInt allFinished = 1;
			SRes resMain = 0;
			int i;
			this.setStatus(.CODER_STATUS_NOT_FINISHED/*
			    if (p->numCoders == 1 && *destLen == destLenOrig && finishMode == LZMA_FINISH_ANY)
			      break;
			    */);
			for (i = 0; i < generatedNumCoders; i++) {
				SRes res = new SRes();
				IStateCoder coder = generatedCoders[i];
				Byte dest2 = new Byte();
				SizeT destLen2 = new SizeT();
				SizeT srcLen2 = new SizeT();
				Byte src2 = new Byte();
				int srcFinished2;
				int encodingWasFinished;
				ECoderStatus status2 = new ECoderStatus();
				if (i == 0) {
					src2 = src;
					srcLen2 = srcLenOrig - srcLen;
					srcFinished2 = srcWasFinished;
				} else {
						size_t k = i - 1;
						src2 = generatedBuf + (((size_t)1 << 17) * k) + generatedPos[k];
						srcLen2 = generatedSize[k] - generatedPos[k];
						srcFinished2 = generatedFinished[k];
				} 
				if (i == generatedNumCoders - 1) {
					dest2 = dest;
					destLen2 = destLenOrig - destLen;
				} else {
						if (generatedPos[i] != generatedSize[i]) {
							continue;
						} 
						dest2 = generatedBuf + (((size_t)1 << 17) * i);
						destLen2 = ((size_t)1 << 17);
				} 
				if (generatedResults[i] != 0) {
					if (resMain == 0) {
						resMain = generatedResults[i];
					} 
					continue;
				} 
				res = .UNRECOGNIZEDFUNCTIONNAME(generatedP, dest2, destLen2, src2, srcLen2, srcFinished2, finishMode, status2);
				if (res != 0) {
					generatedResults[i] = res;
					if (resMain == 0) {
						resMain = res;
					} 
				} 
				encodingWasFinished = (status2 == .CODER_STATUS_FINISHED_WITH_MARK);
				if (!encodingWasFinished) {
					allFinished = 0;
					if (generatedNumCoders == 1 && res == 0) {
						this.setStatus(status2);
					} 
				} 
				if (i == 0) {
					srcLen += srcLen2;
					src += srcLen2;
				} else {
						generatedPos[(size_t)i - 1] += srcLen2;
				} 
				if (i == generatedNumCoders - 1) {
					destLen += destLen2;
					dest += destLen2;
				} else {
						generatedSize[i] = destLen2;
						generatedPos[i] = 0;
						generatedFinished[i] = encodingWasFinished;
				} 
				if (destLen2 != 0 || srcLen2 != 0) {
					processed = 1;
				} 
			}
			if (!processed) {
				if (allFinished) {
					this.setStatus(.CODER_STATUS_FINISHED_WITH_MARK);
				} 
				return resMain;
			} 
		}
	}
	public static Object Xz_ParseHeader(Object p, Object buf) {
		p = (CXzStreamFlags)((UInt16)(((UInt16)((Byte)(buf + 6))[0] << 8) | ((Byte)(buf + 6))[1]));
		if (ModernizedCProgram.CrcCalc(buf + 6, 2) != ((UInt32)(Object)(buf + 6 + 2))) {
			return 17;
		} 
		return ((p) <= -1024) ? 0 : 4;
	}
	public static Object Xz_CheckFooter(Object flags, Object indexSize, Object buf) {
		return indexSize == (((UInt64)((UInt32)(Object)(buf + 4)) + 1) << 2) && ((UInt32)(Object)(buf)) == ModernizedCProgram.CrcCalc(buf + 4, 6) && flags == ((UInt16)(((UInt16)((Byte)(buf + 8))[0] << 8) | ((Byte)(buf + 8))[1])) && buf[10] == (byte)'Y' && buf[11] == (byte)'Z';
	}
	public static Object XzBlock_AreSupportedFilters(Object p) {
		int numFilters = (((p).getFlags() & 3) + 1) - 1;
		int i;
		{ 
			CXzFilter f = p.getFilters()[numFilters];
			if (f.getId() != -1024 || f.getPropsSize() != 1 || f.getProps()[0] > 40) {
				return 0;
			} 
		}
		for (i = 0; i < numFilters; i++) {
			CXzFilter f = p.getFilters()[i];
			if (f.getId() == 3) {
				if (f.getPropsSize() != 1) {
					return 0;
				} 
			}  else if (f.getId() < 3 || f.getId() > 9 || (f.getPropsSize() != 0 && f.getPropsSize() != 4)) {
				return 0;
			} 
		}
		return 1;
	}
	public static Object XzBlock_Parse(Object header) {
		int pos;
		int numFilters;
		int i;
		int headerSize = (int)header[0] << 2;
		if (ModernizedCProgram.CrcCalc(header, headerSize) != ((UInt32)(Object)(header + /* (headerSize != 0) : another code checks */headerSize))) {
			return 16;
		} 
		pos = 1;
		this.setFlags(header[pos++]);
		this.setPackSize((UInt64)(Int64)-1);
		Object generatedFlags = (p).getFlags();
		Object generatedPackSize = this.getPackSize();
		if (((generatedFlags & (1 << 6)) != 0)) {
			{ 
				int s = ModernizedCProgram.Xz_ReadVarInt(header + pos, headerSize - pos, generatedPackSize);
				if (s == 0) {
					return 16;
				} 
				pos += s;
			}
			;
			if (generatedPackSize == 0 || generatedPackSize + headerSize >= (UInt64)1 << 63) {
				return 16;
			} 
		} 
		this.setUnpackSize((UInt64)(Int64)-1);
		Object generatedUnpackSize = this.getUnpackSize();
		if (((generatedFlags & (1 << 7)) != 0)) {
			int s = ModernizedCProgram.Xz_ReadVarInt(header + pos, headerSize - pos, generatedUnpackSize);
			if (s == 0) {
				return 16;
			} 
			pos += s;
		} 
		;
		numFilters = ((generatedFlags & 3) + 1);
		Object generatedFilters = this.getFilters();
		Object generatedId = filter.getId();
		Object generatedProps = filter.getProps();
		for (i = 0; i < numFilters; i++) {
			CXzFilter filter = generatedFilters + i;
			UInt64 size = new UInt64();
			{ 
				int s = ModernizedCProgram.Xz_ReadVarInt(header + pos, headerSize - pos, generatedId);
				if (s == 0) {
					return 16;
				} 
				pos += s;
			}
			;
			{ 
				int s = ModernizedCProgram.Xz_ReadVarInt(header + pos, headerSize - pos, ModernizedCProgram.size);
				if (s == 0) {
					return 16;
				} 
				pos += s;
			}
			;
			if (ModernizedCProgram.size > headerSize - pos || ModernizedCProgram.size > 20) {
				return 16;
			} 
			filter.setPropsSize((UInt32)ModernizedCProgram.size);
			.memcpy(generatedProps, header + pos, (size_t)ModernizedCProgram.size);
			pos += (int)ModernizedCProgram.size;
		}
		if (((generatedFlags & ~(3 | (1 << 6) | (1 << 7))) != 0)) {
			return 4;
		} 
		while (pos < headerSize) {
			if (header[pos++] != 0) {
				return 16;
			} 
		}
		return 0;
	}
	public static Object XzDecMix_Init(Object block, Object outBuf, Object outBufSize) {
		int i;
		BoolInt needReInit = 1;
		int numFilters = (((block).getFlags() & 3) + 1);
		Object generatedNumCoders = this.getNumCoders();
		Object generatedOutBuf = this.getOutBuf();
		Object generatedIds = this.getIds();
		if (numFilters == generatedNumCoders && ((generatedOutBuf && outBuf) || (!generatedOutBuf && !outBuf))) {
			needReInit = 0;
			for (i = 0; i < numFilters; i++) {
				if (generatedIds[i] != block.getFilters()[numFilters - 1 - i].getId()) {
					needReInit = 1;
					break;
				} 
			}
		} 
		// p->SingleBufMode = (outBuf != NULL);// p->SingleBufMode = (outBuf != NULL);this.setOutBuf(outBuf);
		this.setOutBufSize(outBufSize)// p->SingleBufMode = False;;// p->SingleBufMode = False;
		// outBuf = NULL;if (needReInit) {
			p.MixCoder_Free();
			for (i = 0; i < numFilters; i++) {
				{ 
					int __result__ = (p.MixCoder_SetFromMethod(i, block.getFilters()[numFilters - 1 - i].getId(), outBuf, outBufSize));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
			}
			this.setNumCoders(numFilters);
		} else {
				{ 
					int __result__ = (p.MixCoder_ResetFromMethod(0, block.getFilters()[numFilters - 1].getId(), outBuf, outBufSize));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
		} 
		Object generatedCoders = this.getCoders();
		Object generatedP = sc.getP();
		Object generatedAlloc = this.getAlloc();
		for (i = 0; i < numFilters; i++) {
			CXzFilter f = block.getFilters()[numFilters - 1 - i];
			IStateCoder sc = generatedCoders[i];
			{ 
				int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(generatedP, f.getProps(), f.getPropsSize(), generatedAlloc));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		}
		p.MixCoder_Init();
		return 0;
	}
	public static void XzUnpacker_Init() {
		this.setState(.XZ_STATE_STREAM_HEADER);
		this.setPos(0);
		this.setNumStartedStreams(0);
		this.setNumFinishedStreams(0);
		this.setNumTotalBlocks(0);
		this.setPadSize(0);
		this.setDecodeOnlyOneBlock(0);
		this.setParseMode(0);
		this.setDecodeToStreamSignature(0)// p->outBuf = NULL;;// p->outBuf = NULL;
		// p->outBufSize = 0;// p->outBufSize = 0;this.setOutDataWritten(0);
	}
	public static void XzUnpacker_SetOutBuf(Object outBuf, Object outBufSize) {
		this.setOutBuf(outBuf);
		this.setOutBufSize(outBufSize);
	}
	public static void XzUnpacker_Construct(Object alloc) {
		Object generatedDecoder = this.getDecoder();
		generatedDecoder.MixCoder_Construct(alloc);
		this.setOutBuf(((Object)0));
		this.setOutBufSize(0);
		p.XzUnpacker_Init();
	}
	public static void XzUnpacker_Free() {
		Object generatedDecoder = this.getDecoder();
		generatedDecoder.MixCoder_Free();
	}
	public static void XzUnpacker_PrepareToRandomBlockDecoding() {
		this.setIndexSize(0);
		this.setNumBlocks(0);
		Object generatedSha = this.getSha();
		generatedSha.Sha256_Init();
		this.setState(.XZ_STATE_BLOCK_HEADER);
		this.setPos(0);
		this.setDecodeOnlyOneBlock(1);
	}
	public static void XzUnpacker_UpdateIndex(Object packSize, Object unpackSize) {
		Byte[] temp = new Byte();
		int num = ModernizedCProgram.Xz_WriteVarInt(temp, packSize);
		num += ModernizedCProgram.Xz_WriteVarInt(temp + num, unpackSize);
		Object generatedSha = this.getSha();
		generatedSha.Sha256_Update(temp, num);
		Object generatedIndexSize = this.getIndexSize();
		generatedIndexSize += num;
		Object generatedNumBlocks = this.getNumBlocks();
		generatedNumBlocks++;
	}
	public static Object XzUnpacker_Code(Object dest, Object destLen, Object src, Object srcLen, int srcFinished,  finishMode,  status) {
		SizeT destLenOrig = destLen;
		SizeT srcLenOrig = srcLen;
		destLen = 0;
		srcLen = 0;
		status = .CODER_STATUS_NOT_SPECIFIED;
		Object generatedState = this.getState();
		Object generatedBlock = this.getBlock();
		Object generatedPackSize = this.getPackSize();
		Object generatedUnpackSize = this.getUnpackSize();
		Object generatedDecoder = this.getDecoder();
		Object generatedOutBuf = this.getOutBuf();
		Object generatedCheck = this.getCheck();
		Object generatedOutDataWritten = this.getOutDataWritten();
		Object generatedBlockHeaderSize = (p).getBlockHeaderSize();
		Object generatedStreamFlags = (p).getStreamFlags();
		Object generatedPos = this.getPos();
		Object generatedDecodeToStreamSignature = this.getDecodeToStreamSignature();
		Object generatedBuf = this.getBuf();
		Object generatedNumStartedStreams = this.getNumStartedStreams();
		Object generatedSha = this.getSha();
		Object generatedDecodeOnlyOneBlock = this.getDecodeOnlyOneBlock();
		Object generatedNumBlocks = this.getNumBlocks();
		Object generatedIndexPreSize = this.getIndexPreSize();
		Object generatedIndexSize = this.getIndexSize();
		Object generatedShaDigest = this.getShaDigest();
		Object generatedNumTotalBlocks = this.getNumTotalBlocks();
		Object generatedParseMode = this.getParseMode();
		Object generatedOutBufSize = this.getOutBufSize();
		Object generatedAlignPos = this.getAlignPos();
		Object generatedIndexPos = this.getIndexPos();
		Object generatedCrc = this.getCrc();
		Object generatedNumFinishedStreams = this.getNumFinishedStreams();
		Object generatedPadSize = this.getPadSize();
		for (; ; ) {
			SizeT srcRem = new SizeT();
			if (generatedState == .XZ_STATE_BLOCK) {
				SizeT destLen2 = destLenOrig - destLen;
				SizeT srcLen2 = srcLenOrig - srcLen;
				SRes res = new SRes();
				ECoderFinishMode finishMode2 = finishMode;
				BoolInt srcFinished2 = srcFinished;
				BoolInt destFinish = 0;
				if (generatedBlock.getPackSize() != (UInt64)(Int64)-1) {
					UInt64 rem = generatedBlock.getPackSize() - generatedPackSize;
					if (srcLen2 >= rem) {
						srcFinished2 = 1;
						srcLen2 = (SizeT)rem;
					} 
					if (rem == 0 && generatedBlock.getUnpackSize() == generatedUnpackSize) {
						return 1;
					} 
				} 
				if (generatedUnpackSize != (UInt64)(Int64)-1) {
					UInt64 rem = generatedUnpackSize - generatedUnpackSize;
					if (destLen2 >= rem) {
						destFinish = 1;
						finishMode2 = .CODER_FINISH_END;
						destLen2 = (SizeT)rem/*
						      if (srcLen2 == 0 && destLen2 == 0)
						      {
						        *status = CODER_STATUS_NOT_FINISHED;
						        return SZ_OK;
						      }
						      */;
					} 
				} 
				{ 
					res = generatedDecoder.MixCoder_Code((generatedOutBuf ? ((Object)0) : dest), destLen2, destFinish, src, srcLen2, srcFinished2, finishMode2);
					status = generatedDecoder.getStatus();
					generatedCheck.XzCheck_Update((generatedOutBuf ? generatedOutBuf + generatedOutDataWritten : dest), destLen2);
					if (!generatedOutBuf) {
						dest += destLen2;
					} 
					generatedOutDataWritten += destLen2;
				}
				(srcLen) += srcLen2;
				src += srcLen2;
				generatedPackSize += srcLen2;
				(destLen) += destLen2;
				generatedUnpackSize += destLen2;
				{ 
					int __result__ = (res);
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (status != .CODER_STATUS_FINISHED_WITH_MARK) {
					if (generatedPackSize == generatedPackSize && status == .CODER_STATUS_NEEDS_MORE_INPUT) {
						;
						status = .CODER_STATUS_NOT_SPECIFIED;
						return 1;
					} 
					return 0;
				} 
				{ 
					p.XzUnpacker_UpdateIndex((generatedPackSize + generatedBlockHeaderSize + ModernizedCProgram.XzFlags_GetCheckSize(generatedStreamFlags)), generatedUnpackSize);
					this.setState(.XZ_STATE_BLOCK_FOOTER);
					this.setPos(0);
					this.setAlignPos(0);
					status = .CODER_STATUS_NOT_SPECIFIED;
					if ((generatedPackSize != (UInt64)(Int64)-1 && generatedPackSize != generatedPackSize) || (generatedUnpackSize != (UInt64)(Int64)-1 && generatedUnpackSize != generatedUnpackSize)) {
						;
						return 1;
					} 
				}
			} 
			srcRem = srcLenOrig - srcLen;
			if (srcRem == 0 && generatedState != .XZ_STATE_BLOCK_FOOTER) {
				status = .CODER_STATUS_NEEDS_MORE_INPUT;
				return 0;
			} 
			switch (generatedState) {
			case .XZ_STATE_STREAM_INDEX_CRC:
					{ 
						if (generatedPos < 4) {
							(srcLen)++;
							generatedBuf[generatedPos++] = src++;
						} else {
								this.setState(.XZ_STATE_STREAM_FOOTER);
								this.setPos(0);
								if (((generatedCrc) ^ -1024) != ((UInt32)(Object)(generatedBuf))) {
									return 3;
								} 
						} 
						break;
					}
			case .XZ_STATE_STREAM_FOOTER:
					{ 
						UInt32 cur = (2 + 2 + 4 + 4) - generatedPos;
						if (cur > srcRem) {
							cur = (UInt32)srcRem;
						} 
						.memcpy(generatedBuf + generatedPos, src, cur);
						generatedPos += cur;
						(srcLen) += cur;
						src += cur;
						if (generatedPos == (2 + 2 + 4 + 4)) {
							this.setState(.XZ_STATE_STREAM_PADDING);
							generatedNumFinishedStreams++;
							this.setPadSize(0);
							if (!ModernizedCProgram.Xz_CheckFooter(generatedStreamFlags, generatedIndexSize, generatedBuf)) {
								return 3;
							} 
						} 
						break;
					}
			case .XZ_STATE_BLOCK_HEADER:
					{ 
						if (generatedPos == 0) {
							generatedBuf[generatedPos++] = src++;
							(srcLen)++;
							if (generatedBuf[0] == 0) {
								if (generatedDecodeOnlyOneBlock) {
									return 1;
								} 
								this.setIndexPreSize(1 + ModernizedCProgram.Xz_WriteVarInt(generatedBuf + 1, generatedNumBlocks));
								this.setIndexPos(generatedIndexPreSize);
								generatedIndexSize += generatedIndexPreSize;
								generatedSha.Sha256_Final(generatedShaDigest);
								generatedSha.Sha256_Init();
								this.setCrc(ModernizedCProgram.CrcUpdate(-1024, generatedBuf, generatedIndexPreSize));
								this.setState(.XZ_STATE_STREAM_INDEX);
								break;
							} 
							this.setBlockHeaderSize(((UInt32)generatedBuf[0] << 2) + 4);
							break;
						} 
						if (generatedPos != generatedBlockHeaderSize) {
							UInt32 cur = generatedBlockHeaderSize - generatedPos;
							if (cur > srcRem) {
								cur = (UInt32)srcRem;
							} 
							.memcpy(generatedBuf + generatedPos, src, cur);
							generatedPos += cur;
							(srcLen) += cur;
							src += cur;
						} else {
								{ 
									int __result__ = (generatedBlock.XzBlock_Parse(generatedBuf));
									if (__result__ != 0) {
										return __result__;
									} 
								}
								;
								if (!ModernizedCProgram.XzBlock_AreSupportedFilters(generatedBlock)) {
									return 4;
								} 
								generatedNumTotalBlocks++;
								this.setState(.XZ_STATE_BLOCK);
								this.setPackSize(0);
								this.setUnpackSize(0);
								generatedCheck.XzCheck_Init(((generatedStreamFlags) & -1024));
								if (generatedParseMode) {
									this.setHeaderParsedOk(1);
									return 0;
								} 
								{ 
									int __result__ = (generatedDecoder.XzDecMix_Init(generatedBlock, generatedOutBuf, generatedOutBufSize));
									if (__result__ != 0) {
										return __result__;
									} 
								}
								;
						} 
						break;
					}
			case .XZ_STATE_STREAM_HEADER:
					{ 
						if (generatedPos < (6 + 2 + 4)) {
							if (generatedPos < 6 && src != ModernizedCProgram.XZ_SIG[generatedPos]) {
								return 17;
							} 
							if (generatedDecodeToStreamSignature) {
								return 0;
							} 
							generatedBuf[generatedPos++] = src++;
							(srcLen)++;
						} else {
								{ 
									int __result__ = (ModernizedCProgram.Xz_ParseHeader(generatedStreamFlags, generatedBuf));
									if (__result__ != 0) {
										return __result__;
									} 
								}
								;
								generatedNumStartedStreams++;
								this.setIndexSize(0);
								this.setNumBlocks(0);
								generatedSha.Sha256_Init();
								this.setState(.XZ_STATE_BLOCK_HEADER);
								this.setPos(0);
						} 
						break;
					}
			case .XZ_STATE_BLOCK_FOOTER:
					{ 
						if ((((int)generatedPackSize + generatedAlignPos) & 3) != 0) {
							if (srcRem == 0) {
								status = .CODER_STATUS_NEEDS_MORE_INPUT;
								return 0;
							} 
							(srcLen)++;
							generatedAlignPos++;
							if (src++ != 0) {
								return 3;
							} 
						} else {
								UInt32 checkSize = ModernizedCProgram.XzFlags_GetCheckSize(generatedStreamFlags);
								UInt32 cur = checkSize - generatedPos;
								if (cur != 0) {
									if (srcRem == 0) {
										status = .CODER_STATUS_NEEDS_MORE_INPUT;
										return 0;
									} 
									if (cur > srcRem) {
										cur = (UInt32)srcRem;
									} 
									.memcpy(generatedBuf + generatedPos, src, cur);
									generatedPos += cur;
									(srcLen) += cur;
									src += cur;
									if (checkSize != generatedPos) {
										break;
									} 
								} 
								{ 
									Byte[] digest = new Byte();
									this.setState(.XZ_STATE_BLOCK_HEADER);
									this.setPos(0);
									if (generatedCheck.XzCheck_Final(digest) && .memcmp(digest, generatedBuf, checkSize) != 0) {
										return 3;
									} 
									if (generatedDecodeOnlyOneBlock) {
										status = .CODER_STATUS_FINISHED_WITH_MARK;
										return 0;
									} 
								}
						} 
						break;
					}
			case .XZ_STATE_STREAM_INDEX:
					{ 
						if (generatedPos < generatedIndexPreSize) {
							(srcLen)++;
							if (src++ != generatedBuf[generatedPos++]) {
								return 3;
							} 
						} else {
								if (generatedIndexPos < generatedIndexSize) {
									UInt64 cur = generatedIndexSize - generatedIndexPos;
									if (srcRem > cur) {
										srcRem = (SizeT)cur;
									} 
									this.setCrc(ModernizedCProgram.CrcUpdate(generatedCrc, src, srcRem));
									generatedSha.Sha256_Update(src, srcRem);
									(srcLen) += srcRem;
									src += srcRem;
									generatedIndexPos += srcRem;
								}  else if ((generatedIndexPos & 3) != 0) {
									Byte b = src++;
									this.setCrc((ModernizedCProgram.g_CrcTable[((generatedCrc) ^ (b)) & -1024] ^ ((generatedCrc) >> 8)));
									(srcLen)++;
									generatedIndexPos++;
									generatedIndexSize++;
									if (b != 0) {
										return 3;
									} 
								} else {
										Byte[] digest = new Byte();
										this.setState(.XZ_STATE_STREAM_INDEX_CRC);
										generatedIndexSize += 4;
										this.setPos(0);
										generatedSha.Sha256_Final(digest);
										if (.memcmp(digest, generatedShaDigest, 32) != 0) {
											return 3;
										} 
								} 
						} 
						break;
					}
			case /* to disable GCC warning */.XZ_STATE_BLOCK/*
			  if (p->state == XZ_STATE_FINISHED)
			    *status = CODER_STATUS_FINISHED_WITH_MARK;
			  return SZ_OK;
			  */:
					break;
			case .XZ_STATE_STREAM_PADDING:
					{ 
						if (src != 0) {
							if (((UInt32)generatedPadSize & 3) != 0) {
								return 17;
							} 
							this.setPos(0);
							this.setState(.XZ_STATE_STREAM_HEADER);
						} else {
								(srcLen)++;
								src++;
								generatedPadSize++;
						} 
						break;
					}
			}
		}
	}
	public static Object XzUnpacker_CodeFull(Object dest, Object destLen, Object src, Object srcLen,  finishMode,  status) {
		p.XzUnpacker_Init();
		p.XzUnpacker_SetOutBuf(dest, destLen);
		return p.XzUnpacker_Code(((Object)0), destLen, src, srcLen, 1, finishMode, status);
	}
	public static Object XzUnpacker_IsBlockFinished(Object p) {
		return (p.getState() == .XZ_STATE_BLOCK_HEADER) && (p.getPos() == 0);
	}
	public static Object XzUnpacker_IsStreamWasFinished(Object p) {
		return (p.getState() == .XZ_STATE_STREAM_PADDING) && (((UInt32)p.getPadSize() & 3) == 0);
	}
	public static Object XzUnpacker_GetExtraSize(Object p) {
		UInt64 num = 0;
		if (p.getState() == .XZ_STATE_STREAM_PADDING) {
			num = p.getPadSize();
		}  else if (p.getState() == .XZ_STATE_STREAM_HEADER) {
			num = p.getPadSize() + p.getPos();
		} 
		return num;
	}
	public static void XzDecMtProps_Init() {
		this.setInBufSize_ST(1 << 18);
		this.setOutStep_ST(1 << 20);
		this.setIgnoreErrors(0);
		this.setNumThreads(1);
		this.setInBufSize_MT(1 << 18);
		this.setMemUseMax( << 28);
	}
	public static Object XzDecMt_Create(Object alloc, Object allocMid) {
		CXzDecMt p = (CXzDecMt).UNRECOGNIZEDFUNCTIONNAME(alloc, );
		if (!p) {
			return ((Object)0);
		} 
		Object generatedAlignOffsetAlloc = p.getAlignOffsetAlloc();
		generatedAlignOffsetAlloc.AlignOffsetAlloc_CreateVTable();
		generatedAlignOffsetAlloc.setBaseAlloc(alloc);
		generatedAlignOffsetAlloc.setNumAlignBits(7);
		generatedAlignOffsetAlloc.setOffset(0);
		p.setAllocMid(allocMid);
		p.setOutBuf(((Object)0));
		p.setOutBufSize(0);
		p.setInBuf(((Object)0));
		p.setInBufSize(0);
		Object generatedDec = p.getDec();
		generatedDec.XzUnpacker_Construct(generatedAlignOffsetAlloc.getVt());
		p.setUnpackBlockMaxSize(0);
		Object generatedProps = p.getProps();
		generatedProps.XzDecMtProps_Init();
		p.setMtc_WasConstructed(0);
		Object generatedCoders = p.getCoders();
		{ 
			int i;
			for (i = 0; i < 32; i++) {
				CXzDecMtThread coder = generatedCoders[i];
				coder.setDec_created(0);
				coder.setOutBuf(((Object)0));
				coder.setOutBufSize(0);
			}
		}
		return p;
	}
	public static void XzDecMt_FreeOutBufs() {
		int i;
		Object generatedCoders = this.getCoders();
		Object generatedOutBuf = coder.getOutBuf();
		Object generatedAllocMid = this.getAllocMid();
		for (i = 0; i < 32; i++) {
			CXzDecMtThread coder = generatedCoders[i];
			if (generatedOutBuf) {
				.UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedOutBuf);
				coder.setOutBuf(((Object)0));
				coder.setOutBufSize(0);
			} 
		}
		this.setUnpackBlockMaxSize(0);
	}
	public static void XzDecMt_FreeSt() {
		Object generatedDec = this.getDec();
		generatedDec.XzUnpacker_Free();
		Object generatedOutBuf = this.getOutBuf();
		Object generatedAllocMid = this.getAllocMid();
		if (generatedOutBuf) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedOutBuf);
			this.setOutBuf(((Object)0));
		} 
		this.setOutBufSize(0);
		Object generatedInBuf = this.getInBuf();
		if (generatedInBuf) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedInBuf);
			this.setInBuf(((Object)0));
		} 
		this.setInBufSize(0);
	}
	public static void XzDecMt_Destroy(Object pp) {
		CXzDecMt p = (CXzDecMt)pp;
		p.XzDecMt_FreeSt();
		Object generatedMtc_WasConstructed = p.getMtc_WasConstructed();
		Object generatedMtc = p.getMtc();
		if (generatedMtc_WasConstructed) {
			generatedMtc.MtDec_Destruct();
			p.setMtc_WasConstructed(0);
		} 
		Object generatedCoders = p.getCoders();
		Object generatedDec_created = t.getDec_created();
		Object generatedDec = t.getDec();
		{ 
			int i;
			for (i = 0; i < 32; i++) {
				CXzDecMtThread t = generatedCoders[i];
				if (generatedDec_created) {
					generatedDec.XzUnpacker_Free();
					t.setDec_created(0);
				} 
			}
		}
		p.XzDecMt_FreeOutBufs();
		Object generatedAlignOffsetAlloc = p.getAlignOffsetAlloc();
		.UNRECOGNIZEDFUNCTIONNAME(generatedAlignOffsetAlloc.getBaseAlloc(), pp);
	}
	public static void XzDecMt_Callback_Parse(Object obj, int coderIndex) {
		CXzDecMt me = (CXzDecMt)obj;
		Object generatedCoders = me.getCoders();
		CXzDecMtThread coder = generatedCoders[coderIndex];
		Object generatedSrcSize = this.getSrcSize();
		size_t srcSize = generatedSrcSize;
		this.setSrcSize(0);
		this.setOutPos(0);
		this.setState(.MTDEC_PARSE_CONTINUE);
		this.setCanCreateNewThread(1);
		Object generatedStartCall = this.getStartCall();
		Object generatedNumStreams = me.getNumStreams();
		Object generatedNumTotalBlocks = me.getNumTotalBlocks();
		Object generatedNumBlocks = me.getNumBlocks();
		Object generatedDec_created = coder.getDec_created();
		Object generatedDec = coder.getDec();
		Object generatedAlignOffsetAlloc = me.getAlignOffsetAlloc();
		Object generatedIsBlockHeaderState_Parse = me.getIsBlockHeaderState_Parse();
		Object generatedStreamFlags = me.getStreamFlags();
		if (generatedStartCall) {
			coder.setOutPreSize(0);
			coder.setInPreSize(0);
			coder.setInPreHeaderSize(0);
			coder.setParseState(.MTDEC_PARSE_CONTINUE);
			coder.setParsing_Truncated(0);
			coder.setSkipMode(0);
			coder.setCodeRes(0);
			coder.setStatus(.CODER_STATUS_NOT_SPECIFIED);
			coder.setInCodeSize(0);
			coder.setOutCodeSize(0);
			coder.setNumStreams(generatedNumStreams);
			coder.setNumTotalBlocks(generatedNumTotalBlocks);
			coder.setNumBlocks(generatedNumBlocks);
			if (!generatedDec_created) {
				generatedDec.XzUnpacker_Construct(generatedAlignOffsetAlloc.getVt());
				coder.setDec_created(1);
			} 
			generatedDec.XzUnpacker_Init();
			if (generatedIsBlockHeaderState_Parse) {
				generatedDec.setStreamFlags(generatedStreamFlags);
				coder.setAtBlockHeader(1);
				generatedDec.XzUnpacker_PrepareToRandomBlockDecoding();
			} else {
					coder.setAtBlockHeader(0);
					me.setIsBlockHeaderState_Parse(1);
			} 
			generatedDec.setNumStartedStreams(generatedNumStreams);
			generatedDec.setNumTotalBlocks(generatedNumTotalBlocks);
			generatedDec.setNumBlocks(generatedNumBlocks);
		} 
		Object generatedSkipMode = coder.getSkipMode();
		Object generatedSrc = this.getSrc();
		Object generatedSrcFinished = this.getSrcFinished();
		Object generatedInPreHeaderSize = coder.getInPreHeaderSize();
		Object generatedMtc = me.getMtc();
		Object generatedProps = me.getProps();
		Object generatedInPreSize = coder.getInPreSize();
		while (!generatedSkipMode) {
			ECoderStatus status = new ECoderStatus();
			SRes res = new SRes();
			size_t srcSize2 = srcSize;
			size_t destSize = (size_t)0 - 1;
			generatedDec.setParseMode(1);
			generatedDec.setHeaderParsedOk(0);
			;
			res = generatedDec.XzUnpacker_Code(((Object)0), destSize, generatedSrc, srcSize2, generatedSrcFinished, .CODER_FINISH_END, status);
			coder.setCodeRes(res);
			coder.setStatus(status);
			generatedSrcSize += srcSize2;
			srcSize -= srcSize2;
			generatedInPreHeaderSize += srcSize2;
			coder.setInPreSize(generatedInPreHeaderSize);
			if (res != 0) {
				this.setState(coder.setParseState(.MTDEC_PARSE_END/*
				      if (res == SZ_ERROR_MEM)
				        return res;
				      return SZ_OK;
				      */));
				return ;
			} 
			if (generatedDec.getHeaderParsedOk()) {
				CXzBlock block = generatedDec.getBlock();
				if ((((block).getFlags() & (1 << 7)) != 0) && (((block).getFlags() & (1 << 6)) != 0)) {
					{ 
						if (block.getUnpackSize() * 2 * generatedMtc.getNumStartedThreads() > generatedProps.getMemUseMax()) {
							this.setState(.MTDEC_PARSE_OVERFLOW);
							return ;
						} 
					}
					{ 
						UInt64 packSize = block.getPackSize();
						UInt64 packSizeAligned = packSize + ((0 - (int)packSize) & 3);
						UInt32 checkSize = ModernizedCProgram.XzFlags_GetCheckSize(generatedStreamFlags);
						UInt64 blockPackSum = generatedInPreSize + packSizeAligned + checkSize;
						{ 
							coder.setBlockPackSize_for_Index((size_t)(generatedDec.getBlockHeaderSize() + packSize + checkSize));
							coder.setBlockPackTotal((size_t)blockPackSum);
							coder.setOutPreSize((size_t)block.getUnpackSize());
							coder.setStreamFlags(generatedStreamFlags);
							me.setStreamFlags(generatedStreamFlags);
							coder.setSkipMode(1);
							break;
						}
					}
				} 
			} else {
					if (!generatedSrcFinished) {
						return ;
					} 
					this.setState(coder.setParseState(.MTDEC_PARSE_END));
					return ;
			} 
			this.setState(.MTDEC_PARSE_OVERFLOW);
			return ;
		}
		Object generatedBlockPackTotal = coder.getBlockPackTotal();
		Object generatedUnpackBlockMaxSize = me.getUnpackBlockMaxSize();
		Object generatedOutPreSize = coder.getOutPreSize();
		Object generatedOutSize_Defined = me.getOutSize_Defined();
		Object generatedOutSize = me.getOutSize();
		Object generatedOutProcessed_Parse = me.getOutProcessed_Parse();
		Object generatedState = this.getState();
		{ 
			UInt64 rem = generatedBlockPackTotal - generatedInPreSize;
			size_t cur = srcSize;
			if (cur > rem) {
				cur = (size_t)rem;
			} 
			generatedSrcSize += cur;
			generatedInPreSize += cur;
			srcSize -= cur;
			if (generatedInPreSize == generatedBlockPackTotal) {
				if (srcSize == 0) {
					if (!generatedSrcFinished) {
						return ;
					} 
					this.setState(.MTDEC_PARSE_END);
				}  else if ((generatedSrc)[generatedSrcSize] == 0) {
					this.setState(.MTDEC_PARSE_END);
				} else {
						this.setState(.MTDEC_PARSE_NEW);
						{ 
							size_t blockMax = generatedUnpackBlockMaxSize;
							if (blockMax < generatedOutPreSize) {
								blockMax = generatedOutPreSize;
							} 
							{ 
								UInt64 required = (UInt64)blockMax * (generatedMtc.getNumStartedThreads() + 1) * 2;
								if (generatedProps.getMemUseMax() < required) {
									this.setCanCreateNewThread(0);
								} 
							}
						}
						if (generatedOutSize_Defined) {
							UInt64 rem2 = generatedOutSize - generatedOutProcessed_Parse;
							if (rem2 < generatedOutPreSize) {
								coder.setParsing_Truncated(1);
								this.setState(.MTDEC_PARSE_END);
							} 
							generatedOutProcessed_Parse += generatedOutPreSize;
						} 
				} 
			}  else if (generatedSrcFinished) {
				this.setState(.MTDEC_PARSE_END);
			} else {
					return ;
			} 
			coder.setParseState(generatedState);
			this.setOutPos(generatedOutPreSize);
			me.setNumStreams(generatedDec.getNumStartedStreams());
			me.setNumTotalBlocks(generatedNumTotalBlocks);
			me.setNumBlocks(generatedNumBlocks + 1);
			return ;
		}
	}
	public static Object XzDecMt_Callback_PreCode(Object pp, int coderIndex) {
		CXzDecMt me = (CXzDecMt)pp;
		Object generatedCoders = me.getCoders();
		CXzDecMtThread coder = generatedCoders[coderIndex];
		Byte dest = new Byte();
		Object generatedDec = coder.getDec();
		if (!generatedDec.getHeaderParsedOk()) {
			return 0;
		} 
		Object generatedOutBuf = coder.getOutBuf();
		dest = generatedOutBuf;
		Object generatedOutBufSize = coder.getOutBufSize();
		Object generatedOutPreSize = coder.getOutPreSize();
		Object generatedAllocMid = me.getAllocMid();
		Object generatedUnpackBlockMaxSize = me.getUnpackBlockMaxSize();
		if (!dest || generatedOutBufSize < generatedOutPreSize) {
			if (dest) {
				.UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, dest);
				coder.setOutBuf(((Object)0));
				coder.setOutBufSize(0);
			} 
			{ 
				size_t outPreSize = generatedOutPreSize;
				if (outPreSize == 0) {
					outPreSize = 1;
				} 
				dest = (Byte).UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, outPreSize);
			}
			if (!dest) {
				return 2;
			} 
			coder.setOutBuf(dest);
			coder.setOutBufSize(generatedOutPreSize);
			if (generatedOutBufSize > generatedUnpackBlockMaxSize) {
				me.setUnpackBlockMaxSize(generatedOutBufSize);
			} 
		} 
		// return SZ_ERROR_MEM;// return SZ_ERROR_MEM;generatedDec.XzUnpacker_SetOutBuf(generatedOutBuf, generatedOutBufSize);
		Object generatedProps = me.getProps();
		{ 
			SRes res = generatedDec.getDecoder().XzDecMix_Init(generatedDec.getBlock(), generatedOutBuf, generatedOutBufSize);
			coder.setCodeRes(res);
			if (res != 0) {
				if (generatedProps.getIgnoreErrors() && res != 2) {
					return ((HRESULT)-1024);
				} 
				return res;
			} 
		}
		return 0;
	}
	public static Object XzDecMt_Callback_Code(Object pp, int coderIndex, Object src, Object srcSize, int srcFinished, Object inCodePos, Object outCodePos, int stop) {
		CXzDecMt me = (CXzDecMt)pp;
		Object generatedCoders = me.getCoders();
		CXzDecMtThread coder = generatedCoders[coderIndex];
		Object generatedInCodeSize = coder.getInCodeSize();
		inCodePos = generatedInCodeSize;
		Object generatedOutCodeSize = coder.getOutCodeSize();
		outCodePos = generatedOutCodeSize;
		stop = 1;
		Object generatedInPreHeaderSize = coder.getInPreHeaderSize();
		if (generatedInCodeSize < generatedInPreHeaderSize) {
			UInt64 rem = generatedInPreHeaderSize - generatedInCodeSize;
			size_t step = srcSize;
			if (step > rem) {
				step = (size_t)rem;
			} 
			src += step;
			srcSize -= step;
			generatedInCodeSize += step;
			if (generatedInCodeSize < generatedInPreHeaderSize) {
				stop = 0;
				return 0;
			} 
		} 
		Object generatedDec = coder.getDec();
		if (!generatedDec.getHeaderParsedOk()) {
			return 0;
		} 
		Object generatedOutBuf = coder.getOutBuf();
		if (!generatedOutBuf) {
			return 0;
		} 
		Object generatedCodeRes = coder.getCodeRes();
		Object generatedOutPreSize = coder.getOutPreSize();
		if (generatedCodeRes == 0) {
			ECoderStatus status = new ECoderStatus();
			SRes res = new SRes();
			size_t srcProcessed = srcSize;
			size_t outSizeCur = generatedOutPreSize - generatedDec.getOutDataWritten();
			res = generatedDec.XzUnpacker_Code(((Object)0), outSizeCur, src, srcProcessed, srcFinished, .CODER_FINISH_END, status);
			coder.setCodeRes(res);
			coder.setStatus(status);
			generatedInCodeSize += srcProcessed;
			coder.setOutCodeSize(generatedDec.getOutDataWritten());
			inCodePos = generatedInCodeSize;
			outCodePos = generatedOutCodeSize;
			if (res == 0) {
				if (srcProcessed == srcSize) {
					stop = 0;
				} 
				return 0;
			} 
		} 
		Object generatedProps = me.getProps();
		Object generatedInPreSize = coder.getInPreSize();
		if (generatedProps.getIgnoreErrors() && generatedCodeRes != 2) {
			inCodePos = generatedInPreSize;
			outCodePos = generatedOutPreSize;
			return ((HRESULT)-1024);
		} 
		return generatedCodeRes;
	}
	// int finished, int blockFinished,
	public static Object XzDecMt_Callback_Write(Object pp, int coderIndex, Object needWriteToStream, Object src, Object srcSize, Object needContinue, Object canRecode) {
		CXzDecMt me = (CXzDecMt)pp;
		Object generatedCoders = me.getCoders();
		CXzDecMtThread coder = generatedCoders[coderIndex];
		// PRF(printf("\nWrite processed = %d srcSize = %d\n", (unsigned)me->mtc.inProcessed, (unsigned)srcSize));
		needContinue = 0;
		canRecode = 1;
		if (!needWriteToStream) {
			return 0;
		} 
		Object generatedFinishedDecoderIndex = me.getFinishedDecoderIndex();
		if (!coder.getDec().getHeaderParsedOk() || !coder.getOutBuf()) {
			if (generatedFinishedDecoderIndex < 0) {
				me.setFinishedDecoderIndex(coderIndex);
			} 
			return 0;
		} 
		if (generatedFinishedDecoderIndex >= 0) {
			return 0;
		} 
		Object generatedMtc = me.getMtc();
		generatedMtc.getInProcessed() += coder.getInCodeSize();
		canRecode = 0;
		Object generatedIsBlockHeaderState_Write = me.getIsBlockHeaderState_Write();
		Object generatedDec = me.getDec();
		Object generatedProps = me.getProps();
		Object generatedMainErrorCode = me.getMainErrorCode();
		Object generatedWriteRes = me.getWriteRes();
		Object generatedOutSize_Defined = me.getOutSize_Defined();
		Object generatedOutSize = me.getOutSize();
		Object generatedOutProcessed = me.getOutProcessed();
		Object generatedOutStream = me.getOutStream();
		{ 
			SRes res = new SRes();
			size_t size = coder.getOutCodeSize();
			Byte data = coder.getOutBuf();
			if (!generatedIsBlockHeaderState_Write) {
				generatedDec.XzUnpacker_PrepareToRandomBlockDecoding();
				generatedDec.setDecodeOnlyOneBlock(0);
				generatedDec.setNumStartedStreams(generatedDec.getNumStartedStreams());
				generatedDec.setStreamFlags(coder.getStreamFlags());
				me.setIsBlockHeaderState_Write(1);
			} 
			generatedDec.setNumTotalBlocks(generatedDec.getNumTotalBlocks());
			generatedDec.XzUnpacker_UpdateIndex(coder.getBlockPackSize_for_Index(), coder.getOutPreSize());
			if (coder.getOutPreSize() != ModernizedCProgram.size) {
				if (generatedProps.getIgnoreErrors()) {
					.memset(data + ModernizedCProgram.size, 0, coder.getOutPreSize() - ModernizedCProgram.size);
					ModernizedCProgram.size = coder.getOutPreSize();
				} 
				if (generatedMainErrorCode == 0) {
					if ((int)coder.getStatus() == .LZMA_STATUS_NEEDS_MORE_INPUT) {
						me.setMainErrorCode(6);
					} else {
							me.setMainErrorCode(1);
					} 
				} 
			} 
			if (generatedWriteRes != 0) {
				return generatedWriteRes;
			} 
			res = 0;
			{ 
				if (generatedOutSize_Defined) {
					UInt64 rem = generatedOutSize - generatedOutProcessed;
					if (ModernizedCProgram.size > rem) {
						ModernizedCProgram.size = (SizeT)rem;
					} 
				} 
				for (; ; ) {
					size_t cur = ModernizedCProgram.size;
					size_t written = new size_t();
					if (cur > (1 << 24)) {
						cur = (1 << 24);
					} 
					written = .UNRECOGNIZEDFUNCTIONNAME(generatedOutStream, data, cur);
					generatedOutProcessed += written;
					if (written != cur) {
						me.setWriteRes(9);
						res = generatedWriteRes;
						break;
					} 
					data += cur;
					ModernizedCProgram.size -= cur;
					if (ModernizedCProgram.size == 0) {
						break;
					} 
					res = generatedMtc.getMtProgress().MtProgress_ProgressAdd(0, 0);
					if (res != 0) {
						break;
					} 
				}
			}
			if (coder.getCodeRes() != 0) {
				if (!generatedProps.getIgnoreErrors()) {
					me.setFinishedDecoderIndex(coderIndex);
					return res;
				} 
			} 
			{ 
				int __result__ = (res);
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (coder.getInPreSize() != coder.getInCodeSize() || coder.getBlockPackTotal() != coder.getInCodeSize()) {
				me.setFinishedDecoderIndex(coderIndex);
				return 0;
			} 
			if (coder.getParseState() != .MTDEC_PARSE_END) {
				needContinue = 1;
				return 0;
			} 
		}
		// (coder->state == MTDEC_PARSE_END) means that there are no other working threads// so we can use mtc variables without lock;
		generatedMtc.getMtProgress().setTotalInSize(generatedMtc.getInProcessed());
		Object generatedState = dec.getState();
		Object generatedInStream = me.getInStream();
		{ 
			CXzUnpacker dec = generatedDec;
			;
			{ 
				size_t srcProcessed = srcSize;
				ECoderStatus status = new ECoderStatus();
				size_t outSizeCur = 0;
				SRes res = new SRes();
				dec.setDecodeToStreamSignature(1);
				me.setMainDecoderWasCalled(1);
				if (coder.getParsing_Truncated()) {
					me.setParsing_Truncated(1);
					return 0;
				} 
				res = dec.XzUnpacker_Code(((Object)0), outSizeCur, src, srcProcessed, generatedMtc.getReadWasFinished(), .CODER_FINISH_END, status);
				me.setStatus(status);
				me.setCodeRes(res);
				generatedMtc.getInProcessed() += srcProcessed;
				generatedMtc.getMtProgress().setTotalInSize(generatedMtc.getInProcessed());
				if (res != 0) {
					return ((HRESULT)-1024);
				} 
				if (generatedState == .XZ_STATE_STREAM_HEADER) {
					needContinue = 1;
					me.setIsBlockHeaderState_Parse(0);
					me.setIsBlockHeaderState_Write(0);
					{ 
						Byte crossBuf = generatedMtc.MtDec_GetCrossBuff();
						if (!crossBuf) {
							return 2;
						} 
						.memcpy(crossBuf, src + srcProcessed, srcSize - srcProcessed);
					}
					generatedMtc.setCrossStart(0);
					generatedMtc.setCrossEnd(srcSize - srcProcessed);
					return 0;
				} 
				if (status != .CODER_STATUS_NEEDS_MORE_INPUT) {
					return ((HRESULT)-1024);
				} 
				if (generatedMtc.getReadWasFinished()) {
					return 0;
				} 
			}
			{ 
				size_t inPos = new size_t();
				size_t inLim = new size_t();
				Byte inData = new Byte();
				UInt64 inProgressPrev = generatedMtc.getInProcessed();
				Byte crossBuf = generatedMtc.MtDec_GetCrossBuff();
				if (!crossBuf) {
					return 2;
				} 
				inPos = 0;
				inLim = 0;
				inData = crossBuf;
				for (; ; ) {
					SizeT inProcessed = new SizeT();
					SizeT outProcessed = new SizeT();
					ECoderStatus status = new ECoderStatus();
					SRes res = new SRes();
					if (inPos == inLim) {
						if (!generatedMtc.getReadWasFinished()) {
							inPos = 0;
							inLim = generatedMtc.getInBufSize();
							generatedMtc.setReadRes(.UNRECOGNIZEDFUNCTIONNAME(generatedInStream, (Object)inData, inLim));
							generatedMtc.getReadProcessed() += inLim;
							if (inLim == 0 || generatedMtc.getReadRes() != 0) {
								generatedMtc.setReadWasFinished(1);
							} 
						} 
					} 
					inProcessed = inLim - inPos;
					outProcessed = 0;
					res = dec.XzUnpacker_Code(((Object)0), outProcessed, inData + inPos, inProcessed, (inProcessed == 0), .CODER_FINISH_END, status);
					me.setCodeRes(res);
					me.setStatus(status);
					inPos += inProcessed;
					generatedMtc.getInProcessed() += inProcessed;
					generatedMtc.getMtProgress().setTotalInSize(generatedMtc.getInProcessed());
					if (res != 0) {
						return ((HRESULT)-1024);
					} 
					if (generatedState == .XZ_STATE_STREAM_HEADER) {
						needContinue = 1;
						generatedMtc.setCrossStart(inPos);
						generatedMtc.setCrossEnd(inLim);
						me.setIsBlockHeaderState_Parse(0);
						me.setIsBlockHeaderState_Write(0);
						return 0;
					} 
					if (status != .CODER_STATUS_NEEDS_MORE_INPUT) {
						return ((HRESULT)-1024);
					} 
					if (generatedMtc.getProgress()) {
						UInt64 inDelta = generatedMtc.getInProcessed() - inProgressPrev;
						if (inDelta >= (1 << 22)) {
							{ 
								int __result__ = (generatedMtc.getMtProgress().MtProgress_Progress_ST());
								if (__result__ != 0) {
									return __result__;
								} 
							}
							;
							inProgressPrev = generatedMtc.getInProcessed();
						} 
					} 
					if (generatedMtc.getReadWasFinished()) {
						return 0;
					} 
				}
			}
		}
	}
	// int srcFinished,
	public static void XzStatInfo_Clear() {
		this.setInSize(0);
		this.setOutSize(0);
		this.setNumStreams(0);
		this.setNumBlocks(0);
		this.setUnpackSize_Defined(0);
		this.setNumStreams_Defined(0);
		this.setNumBlocks_Defined(0)// p->IsArc = False;// p->UnexpectedEnd = False;// p->Unsupported = False;;// p->IsArc = False;// p->UnexpectedEnd = False;// p->Unsupported = False;
		// p->HeadersError = False;// p->DataError = False;// p->CrcError = False;// p->HeadersError = False;// p->DataError = False;// p->CrcError = False;this.setDataAfterEnd(0);
		this.setDecodingTruncated(0);
		this.setDecodeRes(0);
		this.setReadRes(0);
		this.setProgressRes(0);
		this.setCombinedRes(0);
		this.setCombinedRes_Type(0);
	}
	public static Object XzDecMt_Decode_ST(Object tMode,  stat) {
		size_t outPos = new size_t();
		size_t inPos = new size_t();
		size_t inLim = new size_t();
		Byte inData = new Byte();
		UInt64 inPrev = new UInt64();
		UInt64 outPrev = new UInt64();
		CXzUnpacker dec = new CXzUnpacker();
		Object generatedMtc = this.getMtc();
		if (tMode) {
			p.XzDecMt_FreeOutBufs();
			tMode = generatedMtc.MtDec_PrepareRead();
		} 
		Object generatedOutBuf = this.getOutBuf();
		Object generatedOutBufSize = this.getOutBufSize();
		Object generatedProps = this.getProps();
		Object generatedAllocMid = this.getAllocMid();
		if (!generatedOutBuf || generatedOutBufSize != generatedProps.getOutStep_ST()) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedOutBuf);
			this.setOutBufSize(0);
			this.setOutBuf((Byte).UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedProps.getOutStep_ST()));
			if (!generatedOutBuf) {
				return 2;
			} 
			this.setOutBufSize(generatedProps.getOutStep_ST());
		} 
		Object generatedInBuf = this.getInBuf();
		Object generatedInBufSize = this.getInBufSize();
		if (!generatedInBuf || generatedInBufSize != generatedProps.getInBufSize_ST()) {
			.UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedInBuf);
			this.setInBufSize(0);
			this.setInBuf((Byte).UNRECOGNIZEDFUNCTIONNAME(generatedAllocMid, generatedProps.getInBufSize_ST()));
			if (!generatedInBuf) {
				return 2;
			} 
			this.setInBufSize(generatedProps.getInBufSize_ST());
		} 
		Object generatedDec = this.getDec();
		dec = generatedDec;
		dec.setDecodeToStreamSignature(0)// dec->decodeOnlyOneBlock = False;;// dec->decodeOnlyOneBlock = False;
		dec.XzUnpacker_SetOutBuf(((Object)0), 0);
		Object generatedInProcessed = this.getInProcessed();
		inPrev = generatedInProcessed;
		Object generatedOutProcessed = this.getOutProcessed();
		outPrev = generatedOutProcessed;
		inPos = 0;
		inLim = 0;
		inData = ((Object)0);
		outPos = 0;
		Object generatedReadWasFinished = this.getReadWasFinished();
		Object generatedInStream = this.getInStream();
		Object generatedReadProcessed = this.getReadProcessed();
		Object generatedReadRes = this.getReadRes();
		Object generatedOutSize_Defined = this.getOutSize_Defined();
		Object generatedOutSize = this.getOutSize();
		Object generatedFinishMode = this.getFinishMode();
		Object generatedOutStream = this.getOutStream();
		Object generatedProgress = this.getProgress();
		for (; ; ) {
			SizeT outSize = new SizeT();
			BoolInt finished = new BoolInt();
			ECoderFinishMode finishMode = new ECoderFinishMode();
			SizeT inProcessed = new SizeT();
			ECoderStatus status = new ECoderStatus();
			SRes res = new SRes();
			SizeT outProcessed = new SizeT();
			if (inPos == inLim) {
				if (tMode) {
					inData = generatedMtc.MtDec_Read(inLim);
					inPos = 0;
					if (inData) {
						continue;
					} 
					tMode = 0;
					inLim = 0;
				} 
				if (!generatedReadWasFinished) {
					inPos = 0;
					inLim = generatedInBufSize;
					inData = generatedInBuf;
					this.setReadRes(.UNRECOGNIZEDFUNCTIONNAME(generatedInStream, (Object)inData, inLim));
					generatedReadProcessed += inLim;
					if (inLim == 0 || generatedReadRes != 0) {
						this.setReadWasFinished(1);
					} 
				} 
			} 
			outSize = generatedProps.getOutStep_ST() - outPos;
			finishMode = .CODER_FINISH_ANY;
			if (generatedOutSize_Defined) {
				UInt64 rem = generatedOutSize - generatedOutProcessed;
				if (outSize >= rem) {
					outSize = (SizeT)rem;
					if (generatedFinishMode) {
						finishMode = .CODER_FINISH_END;
					} 
				} 
			} 
			inProcessed = inLim - inPos;
			outProcessed = outSize;
			res = dec.XzUnpacker_Code(generatedOutBuf + outPos, outProcessed, inData + inPos, inProcessed, (inPos == inLim), finishMode, status);
			this.setCodeRes(res);
			this.setStatus(status);
			inPos += inProcessed;
			outPos += outProcessed;
			generatedInProcessed += inProcessed;
			generatedOutProcessed += outProcessed;
			finished = ((inProcessed == 0 && outProcessed == 0) || res != 0);
			if (finished || outProcessed >= outSize) {
				if (outPos != 0) {
					size_t written = .UNRECOGNIZEDFUNCTIONNAME(generatedOutStream, generatedOutBuf, outPos);
					generatedOutProcessed += written;
					if (written != outPos) {
						stat.setCombinedRes_Type(9);
						return 9;
					} 
					outPos = 0;
				} 
			} 
			if (generatedProgress && res == 0) {
				UInt64 inDelta = generatedInProcessed - inPrev;
				UInt64 outDelta = generatedOutProcessed - outPrev;
				if (inDelta >= (1 << 22) || outDelta >= (1 << 22)) {
					res = .UNRECOGNIZEDFUNCTIONNAME(generatedProgress, generatedInProcessed, generatedOutProcessed);
					if (res != 0) {
						stat.setCombinedRes_Type(10);
						stat.setProgressRes(res);
						return res;
					} 
					inPrev = generatedInProcessed;
					outPrev = generatedOutProcessed;
				} 
			} 
			if (finished) {
				return res;
			} 
		}
	}
	public static Object XzStatInfo_SetStat(Object dec, int finishMode, Object readProcessed, Object inProcessed, Object res,  status, Object decodingTruncated) {
		UInt64 extraSize = new UInt64();
		this.setDecodingTruncated((Byte)(decodingTruncated ? 1 : 0));
		this.setInSize(inProcessed);
		this.setNumStreams(dec.getNumStartedStreams());
		this.setNumBlocks(dec.getNumTotalBlocks());
		this.setUnpackSize_Defined(1);
		this.setNumStreams_Defined(1);
		this.setNumBlocks_Defined(1);
		extraSize = ModernizedCProgram.XzUnpacker_GetExtraSize(dec);
		if (res == 0) {
			if (status == .CODER_STATUS_NEEDS_MORE_INPUT) {
				extraSize = 0;
				if (!ModernizedCProgram.XzUnpacker_IsStreamWasFinished(dec)) {
					res = 6;
				} 
			}  else if (!decodingTruncated || finishMode) {
				res = 1;
			} 
		}  else if (res == 17/*
		    SZ_ERROR_NO_ARCHIVE is possible for 2 states:
		      XZ_STATE_STREAM_HEADER  - if bad signature or bad CRC
		      XZ_STATE_STREAM_PADDING - if non-zero padding data
		    extraSize / inProcessed don't include "bad" byte
		    */) {
			if (inProcessed != extraSize) {
				if (extraSize != 0 || readProcessed != inProcessed) {
					this.setDataAfterEnd(1);
					res = 0;
				} 
			} 
		} 
		this.setDecodeRes(res);
		Object generatedInSize = this.getInSize();
		generatedInSize -= extraSize;
		return res;
	}
	public static Object XzDecMt_Decode(Object pp, Object props, Object outDataSize, int finishMode, ISeqOutStream outStream, ISeqInStream inStream,  stat, int isMT, ICompressProgress progress) {
		// const Byte *inData, size_t inDataSize,CXzDecMt p = (CXzDecMt)pp;
		BoolInt tMode = new BoolInt();
		stat.XzStatInfo_Clear();
		p.setProps(props);
		p.setInStream(inStream);
		p.setOutStream(outStream);
		p.setProgress(progress)// p->stat = stat;;// p->stat = stat;
		p.setOutSize(0);
		p.setOutSize_Defined(0);
		if (outDataSize) {
			p.setOutSize_Defined(1);
			p.setOutSize(outDataSize);
		} 
		p.setFinishMode(finishMode)// p->outSize = 457; p->outSize_Defined = True; p->finishMode = False; // for test;// p->outSize = 457; p->outSize_Defined = True; p->finishMode = False; // for test
		p.setWriteRes(0);
		p.setOutProcessed(0);
		p.setInProcessed(0);
		p.setReadProcessed(0);
		p.setReadWasFinished(0);
		p.setCodeRes(0);
		p.setStatus(.CODER_STATUS_NOT_SPECIFIED);
		Object generatedDec = p.getDec();
		generatedDec.XzUnpacker_Init();
		isMT = 0/*
		    p->outBuf = NULL;
		    p->outBufSize = 0;
		    if (!outStream)
		    {
		      p->outBuf = outBuf;
		      p->outBufSize = *outBufSize;
		      *outBufSize = 0;
		    }
		    */;
		p.setIsBlockHeaderState_Parse(0);
		p.setIsBlockHeaderState_Write(0)// p->numBadBlocks = 0;;// p->numBadBlocks = 0;
		p.setMainErrorCode(0);
		p.setMainDecoderWasCalled(0);
		tMode = 0;
		Object generatedProps = p.getProps();
		Object generatedMtc_WasConstructed = p.getMtc_WasConstructed();
		Object generatedMtc = p.getMtc();
		Object generatedAlignOffsetAlloc = p.getAlignOffsetAlloc();
		Object generatedOutProcessed = p.getOutProcessed();
		Object generatedFinishedDecoderIndex = p.getFinishedDecoderIndex();
		Object generatedCoders = p.getCoders();
		Object generatedCodeRes = coder.getCodeRes();
		Object generatedStatus = coder.getStatus();
		Object generatedMainDecoderWasCalled = p.getMainDecoderWasCalled();
		Object generatedParsing_Truncated = p.getParsing_Truncated();
		Object generatedFinishMode = p.getFinishMode();
		Object generatedWriteRes = p.getWriteRes();
		Object generatedMainErrorCode = p.getMainErrorCode();
		Object generatedCombinedRes_Type = stat.getCombinedRes_Type();
		if (generatedProps.getNumThreads() > 1) {
			IMtDecCallback vt = new IMtDecCallback();
			p.XzDecMt_FreeSt();
			p.setOutProcessed_Parse(0);
			p.setParsing_Truncated(0);
			p.setNumStreams(0);
			p.setNumTotalBlocks(0);
			p.setNumBlocks(0);
			p.setFinishedDecoderIndex(-1);
			if (!generatedMtc_WasConstructed) {
				p.setMtc_WasConstructed(1);
				generatedMtc.MtDec_Construct();
			} 
			generatedMtc.setMtCallback(vt);
			generatedMtc.setMtCallbackObject(p);
			generatedMtc.setProgress(progress);
			generatedMtc.setInStream(inStream);
			generatedMtc.setAlloc(generatedAlignOffsetAlloc.getVt());
			generatedMtc.setInBufSize(generatedProps.getInBufSize_MT());
			generatedMtc.setNumThreadsMax(generatedProps.getNumThreads());
			isMT = 1;
			vt.setParse(XzDecMt_Callback_Parse);
			vt.setPreCode(XzDecMt_Callback_PreCode);
			vt.setCode(XzDecMt_Callback_Code);
			vt.setWrite(XzDecMt_Callback_Write);
			{ 
				BoolInt needContinue = new BoolInt();
				SRes res = generatedMtc.MtDec_Code();
				stat.setInSize(generatedMtc.getInProcessed());
				p.setInProcessed(generatedMtc.getInProcessed());
				p.setReadRes(generatedMtc.getReadRes());
				p.setReadWasFinished(generatedMtc.getReadWasFinished());
				p.setReadProcessed(generatedMtc.getReadProcessed());
				tMode = 1;
				needContinue = 0;
				if (res == 0) {
					if (generatedMtc.getMtProgress().getRes() != 0) {
						res = generatedMtc.getMtProgress().getRes();
						stat.setProgressRes(res);
						stat.setCombinedRes_Type(10);
					} else {
							needContinue = generatedMtc.getNeedContinue();
					} 
				} 
				if (!needContinue) {
					SRes codeRes = new SRes();
					BoolInt truncated = 0;
					ECoderStatus status = new ECoderStatus();
					CXzUnpacker dec = new CXzUnpacker();
					stat.setOutSize(generatedOutProcessed);
					if (generatedFinishedDecoderIndex >= 0) {
						CXzDecMtThread coder = generatedCoders[(int)generatedFinishedDecoderIndex];
						codeRes = generatedCodeRes;
						dec = generatedDec;
						status = generatedStatus;
					}  else if (generatedMainDecoderWasCalled) {
						codeRes = generatedCodeRes;
						dec = generatedDec;
						status = generatedStatus;
						truncated = generatedParsing_Truncated;
					} else {
							return ((HRESULT)-1024);
					} 
					stat.XzStatInfo_SetStat(dec, generatedFinishMode, generatedMtc.getReadProcessed(), generatedMtc.getInProcessed(), codeRes, status, truncated);
					if (res == 0) {
						if (generatedWriteRes != 0) {
							res = generatedWriteRes;
							stat.setCombinedRes_Type(9);
						}  else if (generatedMtc.getReadRes() != 0 && generatedMtc.getInProcessed() == generatedMtc.getReadProcessed()) {
							res = generatedMtc.getReadRes();
							stat.setReadRes(res);
							stat.setCombinedRes_Type(8);
						}  else if (generatedMainErrorCode != 0) {
							res = generatedMainErrorCode;
						} 
					} 
					stat.setCombinedRes(res);
					if (generatedCombinedRes_Type == 0) {
						stat.setCombinedRes_Type(res);
					} 
					return res;
				} 
				;
			}
		} 
		isMT = 0;
		Object generatedReadProcessed = p.getReadProcessed();
		Object generatedInProcessed = p.getInProcessed();
		Object generatedReadRes = p.getReadRes();
		{ 
			SRes res = p.XzDecMt_Decode_ST(tMode, stat);
			stat.XzStatInfo_SetStat(generatedDec, generatedFinishMode, generatedReadProcessed, generatedInProcessed, generatedCodeRes, generatedStatus, 0);
			if (res == 0/*
			      if (p->writeRes != SZ_OK)
			      {
			        res = p->writeRes;
			        stat->CombinedRes_Type = SZ_ERROR_WRITE;
			      }
			      else
			      */) {
				if (generatedReadRes != 0 && generatedInProcessed == generatedReadProcessed) {
					res = generatedReadRes;
					stat.setReadRes(res);
					stat.setCombinedRes_Type(8);
				}  else if (generatedMainErrorCode != 0) {
					res = generatedMainErrorCode;
				} 
			} 
			stat.setCombinedRes(res);
			if (generatedCombinedRes_Type == 0) {
				stat.setCombinedRes_Type(res);
			} 
			return res;
		}
	}
	// Byte *outBuf, size_t *outBufSize,
	public static boolean module_dictstat_disable(Object hashconfig, Object user_options, Object user_options_extra) {
		return 1;
	}
	public static int module_hash_decode_zero_hash(Object hashconfig, Object digest_buf, salt salt, Object esalt_buf, Object hook_salt_buf, hashinfo hash_info) {
		byte[] LM_ZERO_HASH = "aad3b435b51404ee";
		return ModernizedCProgram.module_hash_decode(hashconfig, digest_buf, salt, esalt_buf, hook_salt_buf, hash_info, LM_ZERO_HASH, 16);
	}
	public static boolean module_potfile_keep_all_hashes(Object hashconfig, Object user_options, Object user_options_extra) {
		if ((user_options.getShow() == 1) || (user_options.getLeft() == 1)) {
			return 1;
		} 
		return 0;
	}
	// k7zNtSecure,
	// k7zParent,
	// k7zIsReal
	public static Object SzBitUi32s_Alloc(Object num, Object alloc) {
		if (num == 0) {
			this.setDefs(((Object)0));
			this.setVals(((Object)0));
		} else {
				{ 
					if ((this.setDefs((Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, ((num + 7) >> 3) * ))) == ((Object)0)) {
						return 2;
					} 
				}
				;
				{ 
					if ((this.setVals((UInt32).UNRECOGNIZEDFUNCTIONNAME(alloc, (num) * ))) == ((Object)0)) {
						return 2;
					} 
				}
				;
		} 
		return 0;
	}
	public static void SzBitUi32s_Free(Object alloc) {
		Object generatedDefs = this.getDefs();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedDefs);
		this.setDefs(((Object)0));
		Object generatedVals = this.getVals();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedVals);
		this.setVals(((Object)0));
	}
	public static void SzBitUi64s_Free(Object alloc) {
		Object generatedDefs = this.getDefs();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedDefs);
		this.setDefs(((Object)0));
		Object generatedVals = this.getVals();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedVals);
		this.setVals(((Object)0));
	}
	public static void SzAr_Init() {
		this.setNumPackStreams(0);
		this.setNumFolders(0);
		this.setPackPositions(((Object)0));
		Object generatedFolderCRCs = this.getFolderCRCs();
		{ 
			(generatedFolderCRCs).setDefs(((Object)0));
			(generatedFolderCRCs).setVals(((Object)0));
		}
		;
		this.setFoCodersOffsets(((Object)0));
		this.setFoStartPackStreamIndex(((Object)0));
		this.setFoToCoderUnpackSizes(((Object)0));
		this.setFoToMainUnpackSizeIndex(((Object)0));
		this.setCoderUnpackSizes(((Object)0));
		this.setCodersData(((Object)0));
	}
	public static void SzAr_Free(Object alloc) {
		Object generatedPackPositions = this.getPackPositions();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedPackPositions);
		Object generatedFolderCRCs = this.getFolderCRCs();
		generatedFolderCRCs.SzBitUi32s_Free(alloc);
		Object generatedFoCodersOffsets = this.getFoCodersOffsets();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedFoCodersOffsets);
		Object generatedFoStartPackStreamIndex = this.getFoStartPackStreamIndex();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedFoStartPackStreamIndex);
		Object generatedFoToCoderUnpackSizes = this.getFoToCoderUnpackSizes();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedFoToCoderUnpackSizes);
		Object generatedFoToMainUnpackSizeIndex = this.getFoToMainUnpackSizeIndex();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedFoToMainUnpackSizeIndex);
		Object generatedCoderUnpackSizes = this.getCoderUnpackSizes();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedCoderUnpackSizes);
		Object generatedCodersData = this.getCodersData();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedCodersData);
		p.SzAr_Init();
	}
	public static void SzArEx_Init() {
		Object generatedDb = this.getDb();
		generatedDb.SzAr_Init();
		this.setNumFiles(0);
		this.setDataPos(0);
		this.setUnpackPositions(((Object)0));
		this.setIsDirs(((Object)0));
		this.setFolderToFile(((Object)0));
		this.setFileToFolder(((Object)0));
		this.setFileNameOffsets(((Object)0));
		this.setFileNames(((Object)0));
		Object generatedCRCs = this.getCRCs();
		{ 
			(generatedCRCs).setDefs(((Object)0));
			(generatedCRCs).setVals(((Object)0));
		}
		;
		Object generatedAttribs = this.getAttribs();
		{ 
			(generatedAttribs).setDefs(((Object)0));
			(generatedAttribs).setVals(((Object)0));
		}
		;
		Object generatedMTime = this.getMTime();
		{ 
			(generatedMTime).setDefs(((Object)0));
			(generatedMTime).setVals(((Object)0));
		}
		;
		Object generatedCTime = this.getCTime();
		{ 
			(generatedCTime).setDefs(((Object)0));
			(generatedCTime).setVals(((Object)0));
		}
		;
	}
	public static void SzArEx_Free(Object alloc) {
		Object generatedUnpackPositions = this.getUnpackPositions();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedUnpackPositions);
		Object generatedIsDirs = this.getIsDirs();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedIsDirs);
		Object generatedFolderToFile = this.getFolderToFile();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedFolderToFile);
		Object generatedFileToFolder = this.getFileToFolder();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedFileToFolder);
		Object generatedFileNameOffsets = this.getFileNameOffsets();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedFileNameOffsets);
		Object generatedFileNames = this.getFileNames();
		.UNRECOGNIZEDFUNCTIONNAME(alloc, generatedFileNames);
		Object generatedCRCs = this.getCRCs();
		generatedCRCs.SzBitUi32s_Free(alloc);
		Object generatedAttribs = this.getAttribs();
		generatedAttribs.SzBitUi32s_Free(alloc)// SzBitUi32s_Free(&p->Parents, alloc);;// SzBitUi32s_Free(&p->Parents, alloc);
		Object generatedMTime = this.getMTime();
		generatedMTime.SzBitUi64s_Free(alloc);
		Object generatedCTime = this.getCTime();
		generatedCTime.SzBitUi64s_Free(alloc);
		Object generatedDb = this.getDb();
		generatedDb.SzAr_Free(alloc);
		p.SzArEx_Init();
	}
	public static int TestSignatureCandidate(Object testBytes) {
		int i;
		for (i = 0; i < 6; i++) {
			if (testBytes[i] != ModernizedCProgram.k7zSignature[i]) {
				return 0;
			} 
		}
		return 1;
	}
	public static Object ReadNumber(Object value) {
		Byte firstByte = new Byte();
		Byte mask = new Byte();
		int i;
		UInt32 v = new UInt32();
		Object generatedSize = (sd).getSize();
		if (generatedSize == 0) {
			return 16;
		} 
		generatedSize--;
		Object generatedData = (sd).getData();
		firstByte = generatedData++;
		;
		if ((firstByte & -1024) == 0) {
			value = firstByte;
			return 0;
		} 
		if (generatedSize == 0) {
			return 16;
		} 
		generatedSize--;
		v = generatedData++;
		;
		if ((firstByte & -1024) == 0) {
			value = (((UInt32)firstByte & -1024) << 8) | v;
			return 0;
		} 
		if (generatedSize == 0) {
			return 16;
		} 
		generatedSize--;
		mask = generatedData++;
		;
		value = v | ((UInt32)mask << 8);
		mask = -1024;
		for (i = 2; i < 8; i++) {
			Byte b = new Byte();
			if ((firstByte & mask) == 0) {
				UInt64 highPart = (int)firstByte & (int)(mask - 1);
				value |=  (highPart << (8 * i));
				return 0;
			} 
			if (generatedSize == 0) {
				return 16;
			} 
			generatedSize--;
			b = generatedData++;
			;
			value |=  ((UInt64)b << (8 * i));
			mask >>=  1;
		}
		return 0;
	}
	public static Object SzReadNumber32(Object value) {
		Byte firstByte = new Byte();
		UInt64 value64 = new UInt64();
		Object generatedSize = this.getSize();
		if (generatedSize == 0) {
			return 16;
		} 
		Object generatedData = this.getData();
		firstByte = generatedData;
		if ((firstByte & -1024) == 0) {
			value = firstByte;
			generatedData++;
			generatedSize--;
			return 0;
		} 
		{ 
			int __result__ = (sd.ReadNumber(value64));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		if (value64 >= (UInt32)-1024 - 1) {
			return 4;
		} 
		if (value64 >= ((UInt64)(true) << (( - 1) * 8 + 4))) {
			return 4;
		} 
		value = (UInt32)value64;
		return 0;
	}
	public static Object SkipData() {
		UInt64 size = new UInt64();
		{ 
			int __result__ = (sd.ReadNumber(size));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedSize = this.getSize();
		if (size > generatedSize) {
			return 16;
		} 
		Object generatedData = this.getData();
		{ 
			generatedSize -= (size_t)(size);
			generatedData += (size_t)(size);
		}
		;
		return 0;
	}
	public static Object WaitId(Object id) {
		for (; ; ) {
			UInt64 type = new UInt64();
			{ 
				int __result__ = (sd.ReadNumber(type));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (type == id) {
				return 0;
			} 
			if (type == EIdEnum.k7zIdEnd) {
				return 16;
			} 
			{ 
				int __result__ = (sd.SkipData());
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		}
	}
	public static Object RememberBitVector(Object numItems, Object v) {
		UInt32 numBytes = (numItems + 7) >> 3;
		Object generatedSize = this.getSize();
		if (numBytes > generatedSize) {
			return 16;
		} 
		Object generatedData = this.getData();
		v = generatedData;
		{ 
			generatedSize -= (size_t)(numBytes);
			generatedData += (size_t)(numBytes);
		}
		;
		return 0;
	}
	public static Object CountDefinedBits(Object bits, Object numItems) {
		Byte b = 0;
		int m = 0;
		UInt32 sum = 0;
		for (; numItems != 0; numItems--) {
			if (m == 0) {
				b = bits++;
				m = 8;
			} 
			m--;
			sum += ((b >> m) & 1);
		}
		return sum;
	}
	public static Object ReadBitVector(Object numItems, Object v, Object alloc) {
		Byte allAreDefined = new Byte();
		Byte v2 = new Byte();
		UInt32 numBytes = (numItems + 7) >> 3;
		v = ((Object)0);
		Object generatedSize = (sd).getSize();
		if (generatedSize == 0) {
			return 16;
		} 
		generatedSize--;
		Object generatedData = (sd).getData();
		allAreDefined = generatedData++;
		;
		if (numBytes == 0) {
			return 0;
		} 
		if (allAreDefined == 0) {
			if (numBytes > generatedSize) {
				return 16;
			} 
			{ 
				{ 
					if ((v = (Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, (numBytes) * )) == ((Object)0)) {
						return 2;
					} 
				}
				;
				.memcpy(v, generatedData, numBytes);
			}
			;
			{ 
				generatedSize -= (size_t)(numBytes);
				generatedData += (size_t)(numBytes);
			}
			;
			return 0;
		} 
		{ 
			if ((v = (Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, (numBytes) * )) == ((Object)0)) {
				return 2;
			} 
		}
		;
		v2 = v;
		.memset(v2, -1024, (size_t)numBytes);
		{ 
			int numBits = (int)numItems & 7;
			if (numBits != 0) {
				v2[(size_t)numBytes - 1] = (Byte)((((UInt32)1 << numBits) - 1) << (8 - numBits));
			} 
		}
		return 0;
	}
	public static Object ReadUi32s(Object numItems,  crcs, Object alloc) {
		UInt32 i = new UInt32();
		CSzData sd = new CSzData();
		UInt32 vals = new UInt32();
		Byte defs = new Byte();
		{ 
			if ((numItems) == 0) {
				crcs.setVals(((Object)0));
			} else {
					if ((crcs.setVals((UInt32).UNRECOGNIZEDFUNCTIONNAME(alloc, (numItems) * ))) == ((Object)0)) {
						return 2;
					} 
			} 
		}
		;
		sd = sd2;
		Object generatedDefs = crcs.getDefs();
		defs = generatedDefs;
		Object generatedVals = crcs.getVals();
		vals = generatedVals;
		Object generatedSize = sd.getSize();
		Object generatedData = sd.getData();
		for (i = 0; i < numItems; i++) {
			if ((((defs)[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
				if (generatedSize < 4) {
					return 16;
				} 
				vals[i] = ((UInt32)(Object)(generatedData));
				{ 
					generatedSize -= (size_t)(true);
					generatedData += (size_t)(true);
				}
				;
				;
			} else {
					vals[i] = 0;
			} 
		}
		sd2 = sd;
		return 0;
	}
	public static Object ReadBitUi32s(Object numItems,  crcs, Object alloc) {
		crcs.SzBitUi32s_Free(alloc);
		Object generatedDefs = crcs.getDefs();
		{ 
			int __result__ = (sd.ReadBitVector(numItems, generatedDefs, alloc));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		return sd.ReadUi32s(numItems, crcs, alloc);
	}
	public static Object SkipBitUi32s(Object numItems) {
		Byte allAreDefined = new Byte();
		UInt32 numDefined = numItems;
		Object generatedSize = (sd).getSize();
		if (generatedSize == 0) {
			return 16;
		} 
		generatedSize--;
		Object generatedData = (sd).getData();
		allAreDefined = generatedData++;
		;
		if (!allAreDefined) {
			size_t numBytes = (numItems + 7) >> 3;
			if (numBytes > generatedSize) {
				return 16;
			} 
			numDefined = ModernizedCProgram.CountDefinedBits(generatedData, numItems);
			{ 
				generatedSize -= (size_t)(numBytes);
				generatedData += (size_t)(numBytes);
			}
			;
		} 
		if (numDefined > (generatedSize >> 2)) {
			return 16;
		} 
		{ 
			generatedSize -= (size_t)((size_t)numDefined * 4);
			generatedData += (size_t)((size_t)numDefined * 4);
		}
		;
		return 0;
	}
	public static Object ReadPackInfo( sd, Object alloc) {
		Object generatedNumPackStreams = this.getNumPackStreams();
		{ 
			int __result__ = (sd.SzReadNumber32(generatedNumPackStreams));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		{ 
			int __result__ = (sd.WaitId(EIdEnum.k7zIdSize));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		{ 
			if ((this.setPackPositions((UInt64).UNRECOGNIZEDFUNCTIONNAME(alloc, ((size_t)generatedNumPackStreams + 1) * ))) == ((Object)0)) {
				return 2;
			} 
		}
		;
		Object generatedPackPositions = this.getPackPositions();
		{ 
			UInt64 sum = 0;
			UInt32 i = new UInt32();
			UInt32 numPackStreams = generatedNumPackStreams;
			for (i = 0; i < numPackStreams; i++) {
				UInt64 packSize = new UInt64();
				generatedPackPositions[i] = sum;
				{ 
					int __result__ = (sd.ReadNumber(packSize));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				sum += packSize;
				if (sum < packSize) {
					return 16;
				} 
			}
			generatedPackPositions[i] = sum;
		}
		for (; ; ) {
			UInt64 type = new UInt64();
			{ 
				int __result__ = (sd.ReadNumber(type));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (type == EIdEnum.k7zIdEnd) {
				return 0;
			} 
			if (type == EIdEnum.k7zIdCRC) {
				{ 
					int __result__ = (sd.SkipBitUi32s(generatedNumPackStreams));
					if (__result__ != 0) {
						return /* CRC of packed streams is unused now */__result__;
					} 
				}
				;
				continue;
			} 
			{ 
				int __result__ = (sd.SkipData());
				if (__result__ != 0) {
					return __result__/*
					static SRes SzReadSwitch(CSzData *sd)
					{
					  Byte external;
					  RINOK(SzReadByte(sd, &external));
					  return (external == 0) ? SZ_OK: SZ_ERROR_UNSUPPORTED;
					}
					*/;
				} 
			}
			;
		}
	}
	public static Object SzGetNextFolderItem( sd) {
		UInt32 numCoders = new UInt32();
		UInt32 i = new UInt32();
		UInt32 numInStreams = 0;
		Object generatedData = sd.getData();
		Byte dataStart = generatedData;
		this.setNumCoders(0);
		this.setNumBonds(0);
		this.setNumPackStreams(0);
		this.setUnpackStream(0);
		{ 
			int __result__ = (sd.SzReadNumber32(numCoders));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		if (numCoders == 0 || numCoders > 4) {
			return 4;
		} 
		Object generatedCoders = this.getCoders();
		Object generatedSize = (sd).getSize();
		Object generatedNumStreams = coder.getNumStreams();
		for (i = 0; i < numCoders; i++) {
			Byte mainByte = new Byte();
			CSzCoderInfo coder = generatedCoders + i;
			int idSize;
			int j;
			UInt64 id = new UInt64();
			if (generatedSize == 0) {
				return 16;
			} 
			generatedSize--;
			mainByte = generatedData++;
			;
			if ((mainByte & -1024) != 0) {
				return 4;
			} 
			idSize = (int)(mainByte & -1024);
			if (idSize > ) {
				return 4;
			} 
			if (idSize > generatedSize) {
				return 16;
			} 
			id = 0;
			for (j = 0; j < idSize; j++) {
				id = ((id << 8) | generatedData);
				generatedData++;
				generatedSize--;
			}
			if (id > (UInt32)-1024) {
				return 4;
			} 
			coder.setMethodID((UInt32)id);
			coder.setNumStreams(1);
			coder.setPropsOffset(0);
			coder.setPropsSize(0);
			if ((mainByte & -1024) != 0) {
				UInt32 numStreams = new UInt32();
				{ 
					int __result__ = (sd.SzReadNumber32(numStreams));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (numStreams > (3 + 4)) {
					return 4;
				} 
				coder.setNumStreams((Byte)numStreams);
				{ 
					int __result__ = (sd.SzReadNumber32(numStreams));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (numStreams != 1) {
					return 4;
				} 
			} 
			numInStreams += generatedNumStreams;
			if (numInStreams > (3 + 4)) {
				return 4;
			} 
			if ((mainByte & -1024) != 0) {
				UInt32 propsSize = 0;
				{ 
					int __result__ = (sd.SzReadNumber32(propsSize));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (propsSize > generatedSize) {
					return 16;
				} 
				if (propsSize >= -1024) {
					return 4;
				} 
				coder.setPropsOffset(generatedData - dataStart);
				coder.setPropsSize((Byte)propsSize);
				generatedData += (size_t)propsSize;
				generatedSize -= (size_t)propsSize/*
				  if (numInStreams == 1 && numCoders == 1)
				  {
				    f->NumPackStreams = 1;
				    f->PackStreams[0] = 0;
				  }
				  else
				  */;
			} 
		}
		Object generatedBonds = this.getBonds();
		Object generatedInIndex = bp.getInIndex();
		Object generatedOutIndex = bp.getOutIndex();
		Object generatedPackStreams = this.getPackStreams();
		{ 
			Byte[] streamUsed = new Byte();
			UInt32 numBonds = new UInt32();
			UInt32 numPackStreams = new UInt32();
			numBonds = numCoders - 1;
			if (numInStreams < numBonds) {
				return 16;
			} 
			if (numBonds > 3) {
				return 4;
			} 
			this.setNumBonds(numBonds);
			numPackStreams = numInStreams - numBonds;
			if (numPackStreams > 4) {
				return 4;
			} 
			this.setNumPackStreams(numPackStreams);
			for (i = 0; i < numInStreams; i++) {
				streamUsed[i] = 0;
			}
			if (numBonds != 0) {
				Byte[] coderUsed = new Byte();
				for (i = 0; i < numCoders; i++) {
					coderUsed[i] = 0;
				}
				for (i = 0; i < numBonds; i++) {
					CSzBond bp = generatedBonds + i;
					{ 
						int __result__ = (sd.SzReadNumber32(generatedInIndex));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
					if (generatedInIndex >= numInStreams || streamUsed[generatedInIndex]) {
						return 16;
					} 
					streamUsed[generatedInIndex] = 1;
					{ 
						int __result__ = (sd.SzReadNumber32(generatedOutIndex));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
					if (generatedOutIndex >= numCoders || coderUsed[generatedOutIndex]) {
						return 16;
					} 
					coderUsed[generatedOutIndex] = 1;
				}
				for (i = 0; i < numCoders; i++) {
					if (!coderUsed[i]) {
						this.setUnpackStream(i);
						break;
					} 
				}
				if (i == numCoders) {
					return 16;
				} 
			} 
			if (numPackStreams == 1) {
				for (i = 0; i < numInStreams; i++) {
					if (!streamUsed[i]) {
						break;
					} 
				}
				if (i == numInStreams) {
					return 16;
				} 
				generatedPackStreams[0] = i;
			} else {
					for (i = 0; i < numPackStreams; i++) {
						UInt32 index = new UInt32();
						{ 
							int __result__ = (sd.SzReadNumber32(index));
							if (__result__ != 0) {
								return __result__;
							} 
						}
						;
						if (index >= numInStreams || streamUsed[index]) {
							return 16;
						} 
						streamUsed[index] = 1;
						generatedPackStreams[i] = index;
					}
			} 
		}
		this.setNumCoders(numCoders);
		return 0;
	}
	public static Object SkipNumbers(Object num) {
		CSzData sd = new CSzData();
		sd = sd2;
		Object generatedSize = sd.getSize();
		Object generatedData = sd.getData();
		for (; num != 0; num--) {
			Byte firstByte = new Byte();
			Byte mask = new Byte();
			int i;
			if (generatedSize == 0) {
				return 16;
			} 
			generatedSize--;
			firstByte = generatedData++;
			;
			if ((firstByte & -1024) == 0) {
				continue;
			} 
			if ((firstByte & -1024) == 0) {
				if (generatedSize == 0) {
					return 16;
				} 
				generatedSize--;
				generatedData++;
				continue;
			} 
			mask = -1024;
			for (i = 2; i < 8 && (firstByte & mask) != 0; i++) {
				mask >>=  1;
			}
			if (i > generatedSize) {
				return 16;
			} 
			{ 
				generatedSize -= (size_t)(i);
				generatedData += (size_t)(i);
			}
			;
		}
		sd2 = sd;
		return 0;
	}
	public static Object ReadUnpackInfo( sd2, Object numFoldersMax, Object tempBufs, Object numTempBufs, Object alloc) {
		CSzData sd = new CSzData();
		UInt32 fo = new UInt32();
		UInt32 numFolders = new UInt32();
		UInt32 numCodersOutStreams = new UInt32();
		UInt32 packStreamIndex = new UInt32();
		Byte startBufPtr = new Byte();
		Byte external = new Byte();
		{ 
			int __result__ = (sd2.WaitId(EIdEnum.k7zIdFolder));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		{ 
			int __result__ = (sd2.SzReadNumber32(numFolders));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		if (numFolders > numFoldersMax) {
			return 4;
		} 
		this.setNumFolders(numFolders);
		Object generatedSize = (sd2).getSize();
		if (generatedSize == 0) {
			return 16;
		} 
		generatedSize--;
		Object generatedData = (sd2).getData();
		external = generatedData++;
		;
		if (external == 0) {
			sd = sd2;
		} else {
				UInt32 index = new UInt32();
				{ 
					int __result__ = (sd2.SzReadNumber32(index));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (index >= numTempBufs) {
					return 16;
				} 
				sd.setData(generatedData);
				sd.setSize(generatedSize);
		} 
		{ 
			if ((this.setFoCodersOffsets((size_t).UNRECOGNIZEDFUNCTIONNAME(alloc, ((size_t)numFolders + 1) * ))) == ((Object)0)) {
				return 2;
			} 
		}
		;
		{ 
			if ((this.setFoStartPackStreamIndex((UInt32).UNRECOGNIZEDFUNCTIONNAME(alloc, ((size_t)numFolders + 1) * ))) == ((Object)0)) {
				return 2;
			} 
		}
		;
		{ 
			if ((this.setFoToCoderUnpackSizes((UInt32).UNRECOGNIZEDFUNCTIONNAME(alloc, ((size_t)numFolders + 1) * ))) == ((Object)0)) {
				return 2;
			} 
		}
		;
		{ 
			if (((size_t)numFolders) == 0) {
				this.setFoToMainUnpackSizeIndex(((Object)0));
			} else {
					if ((this.setFoToMainUnpackSizeIndex((Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, ((size_t)numFolders) * ))) == ((Object)0)) {
						return 2;
					} 
			} 
		}
		;
		startBufPtr = generatedData;
		packStreamIndex = 0;
		numCodersOutStreams = 0;
		Object generatedFoCodersOffsets = this.getFoCodersOffsets();
		Object generatedFoStartPackStreamIndex = this.getFoStartPackStreamIndex();
		Object generatedFoToCoderUnpackSizes = this.getFoToCoderUnpackSizes();
		Object generatedFoToMainUnpackSizeIndex = this.getFoToMainUnpackSizeIndex();
		Object generatedNumPackStreams = this.getNumPackStreams();
		for (fo = 0; fo < numFolders; fo++) {
			UInt32 numCoders = new UInt32();
			UInt32 ci = new UInt32();
			UInt32 numInStreams = 0;
			generatedFoCodersOffsets[fo] = generatedData - startBufPtr;
			{ 
				int __result__ = (sd.SzReadNumber32(numCoders));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (numCoders == 0 || numCoders > 64) {
				return 4;
			} 
			for (ci = 0; ci < numCoders; ci++) {
				Byte mainByte = new Byte();
				int idSize;
				UInt32 coderInStreams = new UInt32();
				if (generatedSize == 0) {
					return 16;
				} 
				generatedSize--;
				mainByte = generatedData++;
				;
				if ((mainByte & -1024) != 0) {
					return 4;
				} 
				idSize = (mainByte & -1024);
				if (idSize > 8) {
					return 4;
				} 
				if (idSize > generatedSize) {
					return 16;
				} 
				{ 
					generatedSize -= (size_t)(idSize);
					generatedData += (size_t)(idSize);
				}
				;
				coderInStreams = 1;
				if ((mainByte & -1024) != 0) {
					UInt32 coderOutStreams = new UInt32();
					{ 
						int __result__ = (sd.SzReadNumber32(coderInStreams));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
					{ 
						int __result__ = (sd.SzReadNumber32(coderOutStreams));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
					if (coderInStreams > 64 || coderOutStreams != 1) {
						return 4;
					} 
				} 
				numInStreams += coderInStreams;
				if ((mainByte & -1024) != 0) {
					UInt32 propsSize = new UInt32();
					{ 
						int __result__ = (sd.SzReadNumber32(propsSize));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
					if (propsSize > generatedSize) {
						return 16;
					} 
					{ 
						generatedSize -= (size_t)(propsSize);
						generatedData += (size_t)(propsSize);
					}
					;
				} 
			}
			{ 
				UInt32 indexOfMainStream = 0;
				UInt32 numPackStreams = 1;
				if (numCoders != 1 || numInStreams != 1) {
					Byte[] streamUsed = new Byte();
					Byte[] coderUsed = new Byte();
					UInt32 i = new UInt32();
					UInt32 numBonds = numCoders - 1;
					if (numInStreams < numBonds) {
						return 16;
					} 
					if (numInStreams > 64) {
						return 4;
					} 
					for (i = 0; i < numInStreams; i++) {
						streamUsed[i] = 0;
					}
					for (i = 0; i < numCoders; i++) {
						coderUsed[i] = 0;
					}
					for (i = 0; i < numBonds; i++) {
						UInt32 index = new UInt32();
						{ 
							int __result__ = (sd.SzReadNumber32(index));
							if (__result__ != 0) {
								return __result__;
							} 
						}
						;
						if (index >= numInStreams || streamUsed[index]) {
							return 16;
						} 
						streamUsed[index] = 1;
						{ 
							int __result__ = (sd.SzReadNumber32(index));
							if (__result__ != 0) {
								return __result__;
							} 
						}
						;
						if (index >= numCoders || coderUsed[index]) {
							return 16;
						} 
						coderUsed[index] = 1;
					}
					numPackStreams = numInStreams - numBonds;
					if (numPackStreams != 1) {
						for (i = 0; i < numPackStreams; i++) {
							UInt32 index = new UInt32();
							{ 
								int __result__ = (sd.SzReadNumber32(index));
								if (__result__ != 0) {
									return __result__;
								} 
							}
							;
							if (index >= numInStreams || streamUsed[index]) {
								return 16;
							} 
							streamUsed[index] = 1;
						}
					} 
					for (i = 0; i < numCoders; i++) {
						if (!coderUsed[i]) {
							indexOfMainStream = i;
							break;
						} 
					}
					if (i == numCoders) {
						return 16;
					} 
				} 
				generatedFoStartPackStreamIndex[fo] = packStreamIndex;
				generatedFoToCoderUnpackSizes[fo] = numCodersOutStreams;
				generatedFoToMainUnpackSizeIndex[fo] = (Byte)indexOfMainStream;
				numCodersOutStreams += numCoders;
				if (numCodersOutStreams < numCoders) {
					return 4;
				} 
				if (numPackStreams > generatedNumPackStreams - packStreamIndex) {
					return 16;
				} 
				packStreamIndex += numPackStreams;
			}
		}
		generatedFoToCoderUnpackSizes[fo] = numCodersOutStreams;
		Object generatedCodersData = this.getCodersData();
		{ 
			size_t dataSize = generatedData - startBufPtr;
			generatedFoStartPackStreamIndex[fo] = packStreamIndex;
			generatedFoCodersOffsets[fo] = dataSize;
			{ 
				if ((dataSize) == 0) {
					this.setCodersData(((Object)0));
				} else {
						{ 
							{ 
								if ((this.setCodersData((Byte).UNRECOGNIZEDFUNCTIONNAME(alloc, (dataSize) * ))) == ((Object)0)) {
									return 2;
								} 
							}
							;
							.memcpy(generatedCodersData, startBufPtr, dataSize);
						}
				} 
			}
			;
		}
		if (external != 0) {
			if (generatedSize != 0) {
				return 16;
			} 
			sd = sd2;
		} 
		{ 
			int __result__ = (sd.WaitId(EIdEnum.k7zIdCodersUnpackSize));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		{ 
			if (((size_t)numCodersOutStreams) == 0) {
				this.setCoderUnpackSizes(((Object)0));
			} else {
					if ((this.setCoderUnpackSizes((UInt64).UNRECOGNIZEDFUNCTIONNAME(alloc, ((size_t)numCodersOutStreams) * ))) == ((Object)0)) {
						return 2;
					} 
			} 
		}
		;
		Object generatedCoderUnpackSizes = this.getCoderUnpackSizes();
		{ 
			UInt32 i = new UInt32();
			for (i = 0; i < numCodersOutStreams; i++) {
				{ 
					int __result__ = (sd.ReadNumber(generatedCoderUnpackSizes + i));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
			}
		}
		Object generatedFolderCRCs = this.getFolderCRCs();
		for (; ; ) {
			UInt64 type = new UInt64();
			{ 
				int __result__ = (sd.ReadNumber(type));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (type == EIdEnum.k7zIdEnd) {
				sd2 = sd;
				return 0;
			} 
			if (type == EIdEnum.k7zIdCRC) {
				{ 
					int __result__ = (sd.ReadBitUi32s(numFolders, generatedFolderCRCs, alloc));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				continue;
			} 
			{ 
				int __result__ = (sd.SkipData());
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		}
	}
	public static Object SzAr_GetFolderUnpackSize(Object p, Object folderIndex) {
		return p.getCoderUnpackSizes()[p.getFoToCoderUnpackSizes()[folderIndex] + p.getFoToMainUnpackSizeIndex()[folderIndex]];
	}
	public static Object ReadSubStreamsInfo( sd,  ssi) {
		UInt64 type = 0;
		UInt32 numSubDigests = 0;
		Object generatedNumFolders = this.getNumFolders();
		UInt32 numFolders = generatedNumFolders;
		UInt32 numUnpackStreams = numFolders;
		UInt32 numUnpackSizesInData = 0;
		Object generatedData = sd.getData();
		Object generatedSdNumSubStreams = ssi.getSdNumSubStreams();
		Object generatedFolderCRCs = this.getFolderCRCs();
		for (; ; ) {
			{ 
				int __result__ = (sd.ReadNumber(type));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (type == EIdEnum.k7zIdNumUnpackStream) {
				UInt32 i = new UInt32();
				generatedSdNumSubStreams.setData(generatedData);
				numUnpackStreams = 0;
				numSubDigests = 0;
				for (i = 0; i < numFolders; i++) {
					UInt32 numStreams = new UInt32();
					{ 
						int __result__ = (sd.SzReadNumber32(numStreams));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
					if (numUnpackStreams > numUnpackStreams + numStreams) {
						return 4;
					} 
					numUnpackStreams += numStreams;
					if (numStreams != 0) {
						numUnpackSizesInData += (numStreams - 1);
					} 
					if (numStreams != 1 || !((generatedFolderCRCs).getDefs() && ((generatedFolderCRCs).getDefs()[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
						numSubDigests += numStreams;
					} 
				}
				generatedSdNumSubStreams.setSize(generatedData - generatedData);
				continue;
			} 
			if (type == EIdEnum.k7zIdCRC || type == EIdEnum.k7zIdSize || type == EIdEnum.k7zIdEnd) {
				break;
			} 
			{ 
				int __result__ = (sd.SkipData());
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		}
		if (!generatedData) {
			numSubDigests = numFolders;
			if (generatedFolderCRCs.getDefs()) {
				numSubDigests = numFolders - ModernizedCProgram.CountDefinedBits(generatedFolderCRCs.getDefs(), numFolders);
			} 
		} 
		ssi.setNumTotalSubStreams(numUnpackStreams);
		ssi.setNumSubDigests(numSubDigests);
		Object generatedSdSizes = ssi.getSdSizes();
		if (type == EIdEnum.k7zIdSize) {
			generatedSdSizes.setData(generatedData);
			{ 
				int __result__ = (sd.SkipNumbers(numUnpackSizesInData));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			generatedSdSizes.setSize(generatedData - generatedData);
			{ 
				int __result__ = (sd.ReadNumber(type));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		} 
		Object generatedSdCRCs = ssi.getSdCRCs();
		for (; ; ) {
			if (type == EIdEnum.k7zIdEnd) {
				return 0;
			} 
			if (type == EIdEnum.k7zIdCRC) {
				generatedSdCRCs.setData(generatedData);
				{ 
					int __result__ = (sd.SkipBitUi32s(numSubDigests));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				generatedSdCRCs.setSize(generatedData - generatedData);
			} else {
					{ 
						int __result__ = (sd.SkipData());
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
			} 
			{ 
				int __result__ = (sd.ReadNumber(type));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		}
	}
	public static Object SzReadStreamsInfo( sd, Object numFoldersMax, Object tempBufs, Object numTempBufs, Object dataOffset,  ssi, Object alloc) {
		UInt64 type = new UInt64();
		Object generatedSdSizes = ssi.getSdSizes();
		{ 
			(generatedSdSizes).setData(((Object)0));
			(generatedSdSizes).setSize(0);
		}
		;
		Object generatedSdCRCs = ssi.getSdCRCs();
		{ 
			(generatedSdCRCs).setData(((Object)0));
			(generatedSdCRCs).setSize(0);
		}
		;
		Object generatedSdNumSubStreams = ssi.getSdNumSubStreams();
		{ 
			(generatedSdNumSubStreams).setData(((Object)0));
			(generatedSdNumSubStreams).setSize(0);
		}
		;
		dataOffset = 0;
		{ 
			int __result__ = (sd.ReadNumber(type));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		if (type == EIdEnum.k7zIdPackInfo) {
			{ 
				int __result__ = (sd.ReadNumber(dataOffset));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			{ 
				int __result__ = (p.ReadPackInfo(sd, alloc));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			{ 
				int __result__ = (sd.ReadNumber(type));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		} 
		if (type == EIdEnum.k7zIdUnpackInfo) {
			{ 
				int __result__ = (p.ReadUnpackInfo(sd, numFoldersMax, tempBufs, numTempBufs, alloc));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			{ 
				int __result__ = (sd.ReadNumber(type));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		} 
		Object generatedNumFolders = this.getNumFolders();
		if (type == EIdEnum.k7zIdSubStreamsInfo) {
			{ 
				int __result__ = (p.ReadSubStreamsInfo(sd, ssi));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			{ 
				int __result__ = (sd.ReadNumber(type));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		} else {
				ssi.setNumTotalSubStreams(generatedNumFolders);
		} 
		return (type == EIdEnum.k7zIdEnd ? 0 : 4);
	}
	public static Object SzReadAndDecodePackedStreams(ILookInStream inStream,  sd,  tempBufs, Object numFoldersMax, Object baseOffset,  p, Object allocTemp) {
		UInt64 dataStartPos = new UInt64();
		UInt32 fo = new UInt32();
		CSubStreamInfo ssi = new CSubStreamInfo();
		{ 
			int __result__ = (p.SzReadStreamsInfo(sd, numFoldersMax, ((Object)0), 0, dataStartPos, ssi, allocTemp));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		dataStartPos += baseOffset;
		Object generatedNumFolders = p.getNumFolders();
		if (generatedNumFolders == 0) {
			return 16;
		} 
		for (fo = 0; fo < generatedNumFolders; fo++) {
			tempBufs + fo.Buf_Init();
		}
		for (fo = 0; fo < generatedNumFolders; fo++) {
			CBuf tempBuf = tempBufs + fo;
			UInt64 unpackSize = ModernizedCProgram.SzAr_GetFolderUnpackSize(p, fo);
			if ((size_t)unpackSize != unpackSize) {
				return 2;
			} 
			if (!tempBuf.Buf_Create((size_t)unpackSize, allocTemp)) {
				return 2;
			} 
		}
		for (fo = 0; fo < generatedNumFolders; fo++) {
			CBuf tempBuf = tempBufs + fo;
			{ 
				int __result__ = (ModernizedCProgram.LookInStream_SeekTo(inStream, dataStartPos));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			{ 
				int __result__ = (inStream.SzAr_DecodeFolder(p, fo, dataStartPos, tempBuf.getData(), tempBuf.getSize(), allocTemp));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
		}
		return 0;
	}
	public static Object SzReadFileNames(Object data, Object size, Object numFiles, Object offsets) {
		size_t pos = 0;
		offsets++ = 0;
		if (numFiles == 0) {
			return (size == 0) ? 0 : 16;
		} 
		if (size < 2) {
			return 16;
		} 
		if (data[size - 2] != 0 || data[size - 1] != 0) {
			return 16;
		} 
		do {
			Byte p = new Byte();
			if (pos == size) {
				return 16;
			} 
			for (p = data + pos; (UInt16)p != 0; p += 2) {
				;
			}
			pos = p - data + 2;
			offsets++ = (pos >> 1);
		} while (--numFiles);
		return (pos == size) ? 0 : 16;
	}
	public static Object ReadTime(Object num,  sd2, Object tempBufs, Object numTempBufs, Object alloc) {
		CSzData sd = new CSzData();
		UInt32 i = new UInt32();
		CNtfsFileTime vals = new CNtfsFileTime();
		Byte defs = new Byte();
		Byte external = new Byte();
		Object generatedDefs = this.getDefs();
		{ 
			int __result__ = (sd2.ReadBitVector(num, generatedDefs, alloc));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedSize = (sd2).getSize();
		if (generatedSize == 0) {
			return 16;
		} 
		generatedSize--;
		Object generatedData = (sd2).getData();
		external = generatedData++;
		;
		if (external == 0) {
			sd = sd2;
		} else {
				UInt32 index = new UInt32();
				{ 
					int __result__ = (sd2.SzReadNumber32(index));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (index >= numTempBufs) {
					return 16;
				} 
				sd.setData(generatedData);
				sd.setSize(generatedSize);
		} 
		{ 
			if ((num) == 0) {
				this.setVals(((Object)0));
			} else {
					if ((this.setVals((CNtfsFileTime).UNRECOGNIZEDFUNCTIONNAME(alloc, (num) * ))) == ((Object)0)) {
						return 2;
					} 
			} 
		}
		;
		Object generatedVals = this.getVals();
		vals = generatedVals;
		defs = generatedDefs;
		for (i = 0; i < num; i++) {
			if ((((defs)[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
				if (generatedSize < 8) {
					return 16;
				} 
				vals[i].setLow(((UInt32)(Object)(generatedData)));
				vals[i].setHigh(((UInt32)(Object)(generatedData + 4)));
				{ 
					generatedSize -= (size_t)(true);
					generatedData += (size_t)(true);
				}
				;
			} else {
					vals[i].setHigh(vals[i].setLow(0));
			} 
		}
		if (external == 0) {
			sd2 = sd;
		} 
		return 0;
	}
	public static Object SzReadHeader2( p,  sd, ILookInStream inStream,  tempBufs, Object numTempBufs, Object allocMain, Object allocTemp) {
		CSubStreamInfo ssi = new CSubStreamInfo();
		Object generatedSdSizes = ssi.getSdSizes();
		Object generatedSdCRCs = ssi.getSdCRCs();
		Object generatedSdNumSubStreams = ssi.getSdNumSubStreams();
		Object generatedStartPosAfterHeader = p.getStartPosAfterHeader();
		Object generatedNumFolders = tempAr.getNumFolders();
		Object generatedDb = p.getDb();
		Object generatedDataPos = p.getDataPos();
		{ 
			UInt64 type = new UInt64();
			{ 
				(generatedSdSizes).setData(((Object)0));
				(generatedSdSizes).setSize(0);
			}
			;
			{ 
				(generatedSdCRCs).setData(((Object)0));
				(generatedSdCRCs).setSize(0);
			}
			;
			{ 
				(generatedSdNumSubStreams).setData(((Object)0));
				(generatedSdNumSubStreams).setSize(0);
			}
			;
			ssi.setNumSubDigests(0);
			ssi.setNumTotalSubStreams(0);
			{ 
				int __result__ = (sd.ReadNumber(type));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if (type == EIdEnum.k7zIdArchiveProperties) {
				for (; ; ) {
					UInt64 type2 = new UInt64();
					{ 
						int __result__ = (sd.ReadNumber(type2));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
					if (type2 == EIdEnum.k7zIdEnd) {
						break;
					} 
					{ 
						int __result__ = (sd.SkipData());
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
				}
				{ 
					int __result__ = (sd.ReadNumber(type));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
			} 
			if (type == EIdEnum.k7zIdAdditionalStreamsInfo) {
				CSzAr tempAr = new CSzAr();
				SRes res = new SRes();
				tempAr.SzAr_Init();
				res = ModernizedCProgram.SzReadAndDecodePackedStreams(inStream, sd, tempBufs, 8, generatedStartPosAfterHeader, tempAr, allocTemp);
				numTempBufs = generatedNumFolders;
				tempAr.SzAr_Free(allocTemp);
				if (res != 0) {
					return res;
				} 
				{ 
					int __result__ = (sd.ReadNumber(type));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
			} 
			if (type == EIdEnum.k7zIdMainStreamsInfo) {
				{ 
					int __result__ = (generatedDb.SzReadStreamsInfo(sd, (UInt32)1 << 30, tempBufs, numTempBufs, generatedDataPos, ssi, allocMain));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				generatedDataPos += generatedStartPosAfterHeader;
				{ 
					int __result__ = (sd.ReadNumber(type));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
			} 
			if (type == EIdEnum.k7zIdEnd) {
				return 0;
			} 
			if (type != EIdEnum.k7zIdFilesInfo) {
				return 16;
			} 
		}
		Object generatedSize = sd.getSize();
		Object generatedData = sd.getData();
		Object generatedFileNames = p.getFileNames();
		Object generatedFileNameOffsets = p.getFileNameOffsets();
		Object generatedAttribs = p.getAttribs();
		Object generatedMTime = p.getMTime();
		Object generatedCTime = p.getCTime();
		Object generatedNumTotalSubStreams = ssi.getNumTotalSubStreams();
		Object generatedNumFiles = p.getNumFiles();
		Object generatedCRCs = p.getCRCs();
		Object generatedNumSubDigests = ssi.getNumSubDigests();
		Object generatedIsDirs = p.getIsDirs();
		Object generatedUnpackPositions = p.getUnpackPositions();
		Object generatedFileToFolder = p.getFileToFolder();
		Object generatedFolderToFile = p.getFolderToFile();
		{ 
			UInt32 numFiles = 0;
			UInt32 numEmptyStreams = 0;
			Byte emptyStreams = ((Object)0);
			Byte emptyFiles = ((Object)0);
			{ 
				int __result__ = (sd.SzReadNumber32(numFiles));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			p.setNumFiles(numFiles);
			for (; ; ) {
				UInt64 type = new UInt64();
				UInt64 size = new UInt64();
				{ 
					int __result__ = (sd.ReadNumber(type));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (type == EIdEnum.k7zIdEnd) {
					break;
				} 
				{ 
					int __result__ = (sd.ReadNumber(ModernizedCProgram.size));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (ModernizedCProgram.size > generatedSize) {
					return 16;
				} 
				if (type >= ((UInt32)1 << 8)) {
					{ 
						generatedSize -= (size_t)(ModernizedCProgram.size);
						generatedData += (size_t)(ModernizedCProgram.size);
					}
					;
				} else {
						switch ((int)type) {
						case EIdEnum.k7zIdEmptyStream:
								{ 
									{ 
										int __result__ = (sd.RememberBitVector(numFiles, emptyStreams));
										if (__result__ != 0) {
											return __result__;
										} 
									}
									;
									numEmptyStreams = ModernizedCProgram.CountDefinedBits(emptyStreams, numFiles);
									emptyFiles = ((Object)0);
									break;
								}
						case EIdEnum.k7zIdEmptyFile:
								{ 
									{ 
										int __result__ = (sd.RememberBitVector(numEmptyStreams, emptyFiles));
										if (__result__ != 0) {
											return __result__;
										} 
									}
									;
									break;
								}
						case EIdEnum.k7zIdName:
								{ 
									size_t namesSize = new size_t();
									Byte namesData = new Byte();
									Byte external = new Byte();
									if (generatedSize == 0) {
										return 16;
									} 
									generatedSize--;
									external = generatedData++;
									;
									if (external == 0) {
										namesSize = (size_t)ModernizedCProgram.size - 1;
										namesData = generatedData;
									} else {
											UInt32 index = new UInt32();
											{ 
												int __result__ = (sd.SzReadNumber32(index));
												if (__result__ != 0) {
													return __result__;
												} 
											}
											;
											if (index >= numTempBufs) {
												return 16;
											} 
											namesData = generatedData;
											namesSize = generatedSize;
									} 
									if ((namesSize & 1) != 0) {
										return 16;
									} 
									{ 
										if ((p.setFileNameOffsets((size_t).UNRECOGNIZEDFUNCTIONNAME(allocMain, (numFiles + 1) * ))) == ((Object)0)) {
											return 2;
										} 
									}
									;
									{ 
										if ((namesSize) == 0) {
											p.setFileNames(((Object)0));
										} else {
												{ 
													{ 
														if ((p.setFileNames((Byte).UNRECOGNIZEDFUNCTIONNAME(allocMain, (namesSize) * ))) == ((Object)0)) {
															return 2;
														} 
													}
													;
													.memcpy(generatedFileNames, namesData, namesSize);
												}
										} 
									}
									;
									{ 
										int __result__ = (ModernizedCProgram.SzReadFileNames(generatedFileNames, namesSize, numFiles, generatedFileNameOffsets));
										if (__result__ != 0) {
											return __result__;
										} 
									}
									if (external == 0) {
										{ 
											generatedSize -= (size_t)(namesSize);
											generatedData += (size_t)(namesSize);
										}
										;
									} 
									break;
								}
						case EIdEnum.k7zIdMTime:
								{ 
									int __result__ = (generatedMTime.ReadTime(numFiles, sd, tempBufs, numTempBufs, allocMain));
									if (__result__ != 0) {
										return __result__;
									} 
								}
								;
								break;
						case EIdEnum.k7zIdCTime:
								{ 
									int __result__ = (generatedCTime.ReadTime(numFiles, sd, tempBufs, numTempBufs, allocMain));
									if (__result__ != 0) {
										return __result__;
									} 
								}
								;
								break;
						case EIdEnum.k7zIdWinAttrib:
								{ 
									Byte external = new Byte();
									CSzData sdSwitch = new CSzData();
									CSzData sdPtr = new CSzData();
									generatedAttribs.SzBitUi32s_Free(allocMain);
									{ 
										int __result__ = (sd.ReadBitVector(numFiles, generatedAttribs.getDefs(), allocMain));
										if (__result__ != 0) {
											return __result__;
										} 
									}
									;
									if (generatedSize == 0) {
										return 16;
									} 
									generatedSize--;
									external = generatedData++;
									;
									if (external == 0) {
										sdPtr = sd;
									} else {
											UInt32 index = new UInt32();
											{ 
												int __result__ = (sd.SzReadNumber32(index));
												if (__result__ != 0) {
													return __result__;
												} 
											}
											;
											if (index >= numTempBufs) {
												return 16;
											} 
											sdSwitch.setData(generatedData);
											sdSwitch.setSize(generatedSize);
											sdPtr = sdSwitch;
									} 
									{ 
										int __result__ = (sdPtr.ReadUi32s(numFiles, generatedAttribs, allocMain));
										if (__result__ != 0) {
											return __result__;
										} 
									}
									;
									break;
								}
						default:
								{ 
									{ 
										generatedSize -= (size_t)(ModernizedCProgram.size);
										generatedData += (size_t)(ModernizedCProgram.size);
									}
									;
								}
						}
				} 
			}
			if (numFiles - numEmptyStreams != generatedNumTotalSubStreams) {
				return 16;
			} 
			for (; ; ) {
				UInt64 type = new UInt64();
				{ 
					int __result__ = (sd.ReadNumber(type));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (type == EIdEnum.k7zIdEnd) {
					break;
				} 
				{ 
					int __result__ = (sd.SkipData());
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
			}
			{ 
				UInt32 i = new UInt32();
				UInt32 emptyFileIndex = 0;
				UInt32 folderIndex = 0;
				UInt32 remSubStreams = 0;
				UInt32 numSubStreams = 0;
				UInt64 unpackPos = 0;
				Byte digestsDefs = ((Object)0);
				Byte digestsVals = ((Object)0);
				UInt32 digestsValsIndex = 0;
				UInt32 digestIndex = new UInt32();
				Byte allDigestsDefined = 0;
				Byte isDirMask = 0;
				Byte crcMask = 0;
				Byte mask = -1024;
				{ 
					if ((p.setFolderToFile((UInt32).UNRECOGNIZEDFUNCTIONNAME(allocMain, (generatedNumFolders + 1) * ))) == ((Object)0)) {
						return 2;
					} 
				}
				;
				{ 
					if ((generatedNumFiles) == 0) {
						p.setFileToFolder(((Object)0));
					} else {
							if ((p.setFileToFolder((UInt32).UNRECOGNIZEDFUNCTIONNAME(allocMain, (generatedNumFiles) * ))) == ((Object)0)) {
								return 2;
							} 
					} 
				}
				;
				{ 
					if ((p.setUnpackPositions((UInt64).UNRECOGNIZEDFUNCTIONNAME(allocMain, (generatedNumFiles + 1) * ))) == ((Object)0)) {
						return 2;
					} 
				}
				;
				{ 
					if (((generatedNumFiles + 7) >> 3) == 0) {
						p.setIsDirs(((Object)0));
					} else {
							if ((p.setIsDirs((Byte).UNRECOGNIZEDFUNCTIONNAME(allocMain, ((generatedNumFiles + 7) >> 3) * ))) == ((Object)0)) {
								return 2;
							} 
					} 
				}
				;
				{ 
					int __result__ = (generatedCRCs.SzBitUi32s_Alloc(generatedNumFiles, allocMain));
					if (__result__ != 0) {
						return __result__;
					} 
				}
				;
				if (generatedSize != 0) {
					if (generatedSize == 0) {
						return 16;
					} 
					generatedSize--;
					allDigestsDefined = generatedData++;
					;
					if (allDigestsDefined) {
						digestsVals = generatedData;
					} else {
							size_t numBytes = (generatedNumSubDigests + 7) >> 3;
							digestsDefs = generatedData;
							digestsVals = digestsDefs + numBytes;
					} 
				} 
				digestIndex = 0;
				for (i = 0; i < numFiles; ) {
					if (mask == 0) {
						UInt32 byteIndex = (i - 1) >> 3;
						generatedIsDirs[byteIndex] = isDirMask;
						generatedCRCs.getDefs()[byteIndex] = crcMask;
						isDirMask = 0;
						crcMask = 0;
						mask = -1024;
					} 
					generatedUnpackPositions[i] = unpackPos;
					generatedCRCs.getVals()[i] = 0;
					if (emptyStreams && (((emptyStreams)[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
						if (emptyFiles) {
							if (!(((emptyFiles)[(emptyFileIndex) >> 3] & (-1024 >> ((emptyFileIndex) & 7))) != 0)) {
								isDirMask |=  mask;
							} 
							emptyFileIndex++;
						} else {
								isDirMask |=  mask;
						} 
						if (remSubStreams == 0) {
							generatedFileToFolder[i] = (UInt32)-1;
							continue;
						} 
					} 
					if (remSubStreams == 0) {
						for (; ; ) {
							if (folderIndex >= generatedNumFolders) {
								return 16;
							} 
							generatedFolderToFile[folderIndex] = i;
							numSubStreams = 1;
							if (generatedData) {
								{ 
									int __result__ = (generatedSdNumSubStreams.SzReadNumber32(numSubStreams));
									if (__result__ != 0) {
										return __result__;
									} 
								}
								;
							} 
							remSubStreams = numSubStreams;
							if (numSubStreams != 0) {
								break;
							} 
							{ 
								UInt64 folderUnpackSize = ModernizedCProgram.SzAr_GetFolderUnpackSize(generatedDb, folderIndex);
								unpackPos += folderUnpackSize;
								if (unpackPos < folderUnpackSize) {
									return 16;
								} 
							}
							folderIndex++;
						}
					} 
					generatedFileToFolder[i] = folderIndex;
					if (emptyStreams && (((emptyStreams)[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
						continue;
					} 
					if (--remSubStreams == 0) {
						UInt64 folderUnpackSize = ModernizedCProgram.SzAr_GetFolderUnpackSize(generatedDb, folderIndex);
						UInt64 startFolderUnpackPos = generatedUnpackPositions[generatedFolderToFile[folderIndex]];
						if (folderUnpackSize < unpackPos - startFolderUnpackPos) {
							return 16;
						} 
						unpackPos = startFolderUnpackPos + folderUnpackSize;
						if (unpackPos < folderUnpackSize) {
							return 16;
						} 
						if (numSubStreams == 1 && ((generatedDb.getFolderCRCs()).getDefs() && ((generatedDb.getFolderCRCs()).getDefs()[(i) >> 3] & (-1024 >> ((i) & 7))) != 0)) {
							generatedCRCs.getVals()[i] = generatedDb.getFolderCRCs().getVals()[folderIndex];
							crcMask |=  mask;
						}  else if (allDigestsDefined || (digestsDefs && (((digestsDefs)[(digestIndex) >> 3] & (-1024 >> ((digestIndex) & 7))) != 0))) {
							generatedCRCs.getVals()[i] = ((UInt32)(Object)(digestsVals + (size_t)digestsValsIndex * 4));
							digestsValsIndex++;
							crcMask |=  mask;
						} 
						folderIndex++;
					} else {
							UInt64 v = new UInt64();
							{ 
								int __result__ = (generatedSdSizes.ReadNumber(v));
								if (__result__ != 0) {
									return __result__;
								} 
							}
							;
							unpackPos += v;
							if (unpackPos < v) {
								return 16;
							} 
							if (allDigestsDefined || (digestsDefs && (((digestsDefs)[(digestIndex) >> 3] & (-1024 >> ((digestIndex) & 7))) != 0))) {
								generatedCRCs.getVals()[i] = ((UInt32)(Object)(digestsVals + (size_t)digestsValsIndex * 4));
								digestsValsIndex++;
								crcMask |=  mask;
							} 
					} 
				}
				if (mask != -1024) {
					UInt32 byteIndex = (i - 1) >> 3;
					generatedIsDirs[byteIndex] = isDirMask;
					generatedCRCs.getDefs()[byteIndex] = crcMask;
				} 
				generatedUnpackPositions[i] = unpackPos;
				if (remSubStreams != 0) {
					return 16;
				} 
				for (; ; ) {
					generatedFolderToFile[folderIndex] = i;
					if (folderIndex >= generatedNumFolders) {
						break;
					} 
					if (!generatedData) {
						return 16;
					} 
					{ 
						int __result__ = (generatedSdNumSubStreams.SzReadNumber32(numSubStreams));
						if (__result__ != 0) {
							return __result__;
						} 
					}
					;
					if (numSubStreams != 0) {
						return 16/*
						      {
						        UInt64 folderUnpackSize = SzAr_GetFolderUnpackSize(&p->db, folderIndex);
						        unpackPos += folderUnpackSize;
						        if (unpackPos < folderUnpackSize)
						          return SZ_ERROR_ARCHIVE;
						      }
						      */;
					} 
					folderIndex++;
				}
				if (generatedData && generatedSize != 0) {
					return 16;
				} 
			}
		}
		return 0;
	}
	/* allocMain */
	public static Object SzReadHeader( p,  sd, ILookInStream inStream, Object allocMain, Object allocTemp) {
		UInt32 i = new UInt32();
		UInt32 numTempBufs = 0;
		SRes res = new SRes();
		CBuf[] tempBufs = new CBuf();
		for (i = 0; i < 8; i++) {
			tempBufs + i.Buf_Init();
		}
		res = ModernizedCProgram.SzReadHeader2(p, sd, inStream, tempBufs, numTempBufs, allocMain, allocTemp);
		for (i = 0; i < 8; i++) {
			tempBufs + i.Buf_Free(allocTemp);
		}
		{ 
			int __result__ = (res);
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		Object generatedSize = sd.getSize();
		if (generatedSize != 0) {
			return 11;
		} 
		return res;
	}
	public static Object SzArEx_Open2( p, ILookInStream inStream, Object allocMain, Object allocTemp) {
		Byte[] header = new Byte();
		Int64 startArcPos = new Int64();
		UInt64 nextHeaderOffset = new UInt64();
		UInt64 nextHeaderSize = new UInt64();
		size_t nextHeaderSizeT = new size_t();
		UInt32 nextHeaderCRC = new UInt32();
		CBuf buf = new CBuf();
		SRes res = new SRes();
		startArcPos = 0;
		{ 
			int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(inStream, startArcPos, .SZ_SEEK_CUR));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		{ 
			int __result__ = (ModernizedCProgram.LookInStream_Read2(inStream, header, -1024, 17));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		if (!ModernizedCProgram.TestSignatureCandidate(header)) {
			return 17;
		} 
		if (header[6] != 0) {
			return 4;
		} 
		nextHeaderOffset = ((UInt64)(Object)(header + 12));
		nextHeaderSize = ((UInt64)(Object)(header + 20));
		nextHeaderCRC = ((UInt32)(Object)(header + 28));
		p.setStartPosAfterHeader(startArcPos + -1024);
		if (ModernizedCProgram.CrcCalc(header + 12, 20) != ((UInt32)(Object)(header + 8))) {
			return 3;
		} 
		nextHeaderSizeT = (size_t)nextHeaderSize;
		if (nextHeaderSizeT != nextHeaderSize) {
			return 2;
		} 
		if (nextHeaderSizeT == 0) {
			return 0;
		} 
		if (nextHeaderOffset > nextHeaderOffset + nextHeaderSize || nextHeaderOffset > nextHeaderOffset + nextHeaderSize + -1024) {
			return 17;
		} 
		{ 
			Int64 pos = 0;
			{ 
				int __result__ = (.UNRECOGNIZEDFUNCTIONNAME(inStream, pos, .SZ_SEEK_END));
				if (__result__ != 0) {
					return __result__;
				} 
			}
			;
			if ((UInt64)pos < startArcPos + nextHeaderOffset || (UInt64)pos < startArcPos + -1024 + nextHeaderOffset || (UInt64)pos < startArcPos + -1024 + nextHeaderOffset + nextHeaderSize) {
				return 6;
			} 
		}
		{ 
			int __result__ = (ModernizedCProgram.LookInStream_SeekTo(inStream, startArcPos + -1024 + nextHeaderOffset));
			if (__result__ != 0) {
				return __result__;
			} 
		}
		;
		if (!buf.Buf_Create(nextHeaderSizeT, allocTemp)) {
			return 2;
		} 
		Object generatedData = buf.getData();
		res = ModernizedCProgram.LookInStream_Read(inStream, generatedData, nextHeaderSizeT);
		Object generatedSize = buf.getSize();
		Object generatedStartPosAfterHeader = p.getStartPosAfterHeader();
		if (res == 0) {
			res = 16;
			if (ModernizedCProgram.CrcCalc(generatedData, nextHeaderSizeT) == nextHeaderCRC) {
				CSzData sd = new CSzData();
				UInt64 type = new UInt64();
				sd.setData(generatedData);
				sd.setSize(generatedSize);
				res = sd.ReadNumber(type);
				if (res == 0 && type == EIdEnum.k7zIdEncodedHeader) {
					CSzAr tempAr = new CSzAr();
					CBuf tempBuf = new CBuf();
					tempBuf.Buf_Init();
					tempAr.SzAr_Init();
					res = ModernizedCProgram.SzReadAndDecodePackedStreams(inStream, sd, tempBuf, 1, generatedStartPosAfterHeader, tempAr, allocTemp);
					tempAr.SzAr_Free(allocTemp);
					if (res != 0) {
						tempBuf.Buf_Free(allocTemp);
					} else {
							buf.Buf_Free(allocTemp);
							buf.setData(generatedData);
							buf.setSize(generatedSize);
							sd.setData(generatedData);
							sd.setSize(generatedSize);
							res = sd.ReadNumber(type);
					} 
				} 
				if (res == 0) {
					if (type == EIdEnum.k7zIdHeader/*
					          CSzData sd2;
					          unsigned ttt;
					          for (ttt = 0; ttt < 40000; ttt++)
					          {
					            SzArEx_Free(p, allocMain);
					            sd2 = sd;
					            res = SzReadHeader(p, &sd2, inStream, allocMain, allocTemp);
					            if (res != SZ_OK)
					              break;
					          }
					          */) {
						res = ModernizedCProgram.SzReadHeader(p, sd, inStream, allocMain, allocTemp);
					} else {
							res = 4;
					} 
				} 
			} 
		} 
		buf.Buf_Free(allocTemp);
		return res;
	}
	public static Object SzArEx_Open( p, ILookInStream inStream, Object allocMain, Object allocTemp) {
		SRes res = ModernizedCProgram.SzArEx_Open2(p, inStream, allocMain, allocTemp);
		if (res != 0) {
			p.SzArEx_Free(allocMain);
		} 
		return res;
	}
	public static Object SzArEx_GetFileNameUtf16(Object p, Object fileIndex, Object dest) {
		size_t offs = p.getFileNameOffsets()[fileIndex];
		size_t len = p.getFileNameOffsets()[fileIndex + 1] - offs;
		if (dest != 0) {
			size_t i = new size_t();
			Byte src = p.getFileNames() + offs * 2;
			for (i = 0; i < len; i++) {
				dest[i] = ((UInt16)(Object)(src + i * 2));
			}
		} 
		return len/*
		size_t SzArEx_GetFullNameLen(const CSzArEx *p, size_t fileIndex)
		{
		  size_t len;
		  if (!p->FileNameOffsets)
		    return 1;
		  len = 0;
		  for (;;)
		  {
		    UInt32 parent = (UInt32)(Int32)-1;
		    len += p->FileNameOffsets[fileIndex + 1] - p->FileNameOffsets[fileIndex];
		    if SzBitWithVals_Check(&p->Parents, fileIndex)
		      parent = p->Parents.Vals[fileIndex];
		    if (parent == (UInt32)(Int32)-1)
		      return len;
		    fileIndex = parent;
		  }
		}
		
		UInt16 *SzArEx_GetFullNameUtf16_Back(const CSzArEx *p, size_t fileIndex, UInt16 *dest)
		{
		  BoolInt needSlash;
		  if (!p->FileNameOffsets)
		  {
		    *(--dest) = 0;
		    return dest;
		  }
		  needSlash = False;
		  for (;;)
		  {
		    UInt32 parent = (UInt32)(Int32)-1;
		    size_t curLen = p->FileNameOffsets[fileIndex + 1] - p->FileNameOffsets[fileIndex];
		    SzArEx_GetFileNameUtf16(p, fileIndex, dest - curLen);
		    if (needSlash)
		      *(dest - 1) = '/';
		    needSlash = True;
		    dest -= curLen;
		
		    if SzBitWithVals_Check(&p->Parents, fileIndex)
		      parent = p->Parents.Vals[fileIndex];
		    if (parent == (UInt32)(Int32)-1)
		      return dest;
		    fileIndex = parent;
		  }
		}
		*/;
	}
	/**
	 * Author......: See docs/credits.txt
	 * License.....: MIT
	 */
	public static int sort_by_dictstat(Object s1, Object s2) {
		dictstat_t d1 = (dictstat_t)s1;
		dictstat_t d2 = (dictstat_t)s2;
		int rc_from = .strcmp(d1.getEncoding_from(), d2.getEncoding_from());
		if (rc_from != 0) {
			return rc_from;
		} 
		int rc_to = .strcmp(d1.getEncoding_to(), d2.getEncoding_to());
		if (rc_to != 0) {
			return rc_to;
		} 
		stat stat1 = new stat();
		stat stat2 = new stat();
		.memcpy(stat1, d1.getStat(), );
		.memcpy(stat2, d2.getStat(), );
		stat1.setSt_atime(0);
		stat2.setSt_atime(0);
		int rc_memcmp = .memcmp(stat1, stat2, );
		return rc_memcmp;
	}
	public static Object dictstat_find(hashcat_ctx hashcat_ctx, dictstat d) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		dictstat_ctx generatedDictstat_ctx = hashcat_ctx.getDictstat_ctx();
		dictstat_ctx_t dictstat_ctx = generatedDictstat_ctx;
		boolean generatedEnabled = dictstat_ctx.getEnabled();
		if (generatedEnabled == false) {
			return 0;
		} 
		boolean generatedDictstat_disable = hashconfig.getDictstat_disable();
		if (generatedDictstat_disable == true) {
			return 0;
		} 
		dictstat generatedBase = dictstat_ctx.getBase();
		Object generatedCnt = dictstat_ctx.getCnt();
		dictstat_t d_cache = (dictstat_t).lfind(d, generatedBase, generatedCnt, , ModernizedCProgram.sort_by_dictstat);
		if (d_cache == ((Object)0)) {
			return 0;
		} 
		return generatedCnt;
	}
	public static void dictstat_append(hashcat_ctx hashcat_ctx, dictstat d) {
		hashconfig generatedHashconfig = hashcat_ctx.getHashconfig();
		hashconfig_t hashconfig = generatedHashconfig;
		dictstat_ctx generatedDictstat_ctx = hashcat_ctx.getDictstat_ctx();
		dictstat_ctx_t dictstat_ctx = generatedDictstat_ctx;
		boolean generatedEnabled = dictstat_ctx.getEnabled();
		if (generatedEnabled == false) {
			return ;
		} 
		boolean generatedDictstat_disable = hashconfig.getDictstat_disable();
		if (generatedDictstat_disable == true) {
			return ;
		} 
		Object generatedCnt = dictstat_ctx.getCnt();
		Byte generatedFilename = dictstat_ctx.getFilename();
		if (generatedCnt == 100000) {
			hashcat_ctx.event_log_error("There are too many entries in the %s database. You have to remove/rename it.", generatedFilename);
			return ;
		} 
		dictstat generatedBase = dictstat_ctx.getBase();
		.lsearch(d, generatedBase, generatedCnt, , ModernizedCProgram.sort_by_dictstat);
	}
	/* XzCrc64Opt.c -- CRC64 calculation
	2017-06-30 : Igor Pavlov : Public domain */
	public static Object XzCrc64UpdateT4(Object v, Object data, Object size, Object table) {
		Byte p = (Byte)data;
		for (; size > 0 && ((int)(ptrdiff_t)p & 3) != 0; ) {
			v = (table[((v) ^ (p)) & -1024] ^ ((v) >> 8));
		}
		for (; size >= 4; ) {
			UInt32 d = (UInt32)v ^ (UInt32)p;
			v = (v >> 32) ^ (table + -1024)[((d) & -1024)] ^ (table + -1024)[((d >> 8) & -1024)] ^ (table + -1024)[((d >> 16) & -1024)] ^ (table + -1024)[((d >> 24))];
		}
		for (; size > 0; ) {
			v = (table[((v) ^ (p)) & -1024] ^ ((v) >> 8));
		}
		return v;
	}
	/* See gzlog.h for the description of the external methods below */
	public static Object gzlog_open(byte path) {
		size_t n = new size_t();
		log log = new log();
		if (path == ((Object)0) || path == /* check arguments */0) {
			return ((Object)0);
		} 
		log = .malloc(/* allocate and initialize log structure */);
		if (log == ((Object)0)) {
			return ((Object)0);
		} 
		Object generatedId = log.getId();
		.strcpy(generatedId, "\106\035\172");
		log.setFd(-1);
		n = .strlen(/* save path and end of path for name construction */path);
		log.setPath(.malloc(n + /* allow for ".repairs" */9));
		Byte generatedPath = log.getPath();
		if (generatedPath == ((Object)0)) {
			.free(log);
			return ((Object)0);
		} 
		.strcpy(generatedPath, path);
		log.setEnd(generatedPath + n);
		if (/* gain exclusive access and verify log file -- may perform a
		       recovery operation if needed */log.log_open()) {
			.free(generatedPath);
			.free(log);
			return ((Object)0);
		} 
		return /* return pointer to log structure */log/* gzlog_compress() return values:
		    0: all good
		   -1: file i/o error (usually access issue)
		   -2: memory allocation failure
		   -3: invalid log pointer argument */;
	}
	public static int gzlog_compress(Object logd) {
		int fd;
		int ret;
		uint block = new uint();
		size_t len = new size_t();
		size_t next = new size_t();
		byte data;
		byte[] buf = new byte[5];
		log log = logd;
		Object generatedId = log.getId();
		if (log == ((Object)0) || .strcmp(generatedId, /* check arguments */"\106\035\172")) {
			return -3/* see if we lost the lock -- if so get it again and reload the extra
			       field information (it probably changed), recover last operation if
			       necessary */;
		} 
		if (log.log_check() && log.log_open()) {
			return -1;
		} 
		Object generatedLast = log.getLast();
		Object generatedFirst = log.getFirst();
		Object generatedStored = log.getStored();
		len = ((size_t)(generatedLast - generatedFirst) & ~(((size_t)1 << 10) - /* create space for uncompressed data */1)) + generatedStored;
		if ((data = .malloc(len)) == ((Object)0)) {
			return -2;
		} 
		int generatedFd = log.getFd();
		Byte generatedEnd = log.getEnd();
		Byte generatedPath = log.getPath();
		/* do statement here is just a cheap trick for error handling */do {
			if (.lseek(generatedFd, generatedFirst - 1, 0) < /* read in the uncompressed data */0) {
				break;
			} 
			next = 0;
			while (next < len) {
				if (.read(generatedFd, buf, 5) != 5) {
					break;
				} 
				block = ((buf + 1)[0] + ((uint)((buf + 1)[1]) << 8));
				if (next + block > len || .read(generatedFd, (byte)data + next, block) != block) {
					break;
				} 
				next += block;
			}
			if (.lseek(generatedFd, 0, 1) != generatedLast + 4 + generatedStored) {
				break;
			} 
			log.log_touch();
			.strcpy(generatedEnd, /* write the uncompressed data to the .add file */".add");
			fd = ModernizedCProgram.open(generatedPath, 1 | -1024 | -1024, 644);
			if (fd < 0) {
				break;
			} 
			ret = (size_t).write(fd, data, len) != len;
			if (ret | ModernizedCProgram.close(fd)) {
				break;
			} 
			log.log_touch();
			.strcpy(generatedEnd, /* write the dictionary for the next compress to the .temp file */".temp");
			fd = ModernizedCProgram.open(generatedPath, 1 | -1024 | -1024, 644);
			if (fd < 0) {
				break;
			} 
			next = -1024 > len ? len : -1024;
			ret = (size_t).write(fd, (byte)data + len - next, next) != next;
			if (ret | ModernizedCProgram.close(fd)) {
				break;
			} 
			log.log_touch();
			log.setLast(generatedFirst);
			log.setStored(0);
			if (log.log_mark(2)) {
				break;
			} 
			;
			ret = log.log_compress(data, /* compress and append the data (clears mark) */len);
			.free(data);
			return ret;
		} while (0);
		.free(/* broke out of do above on i/o error */data);
		return -1/* gzlog_write() return values:
		    0: all good
		   -1: file i/o error (usually access issue)
		   -2: memory allocation failure
		   -3: invalid log pointer argument */;
	}
	public static int gzlog_write(Object logd, Object data, Object len) {
		int fd;
		int ret;
		log log = logd;
		Object generatedId = log.getId();
		if (log == ((Object)0) || .strcmp(generatedId, /* check arguments */"\106\035\172")) {
			return -3;
		} 
		if (data == ((Object)0) || len <= 0) {
			return 0/* see if we lost the lock -- if so get it again and reload the extra
			       field information (it probably changed), recover last operation if
			       necessary */;
		} 
		if (log.log_check() && log.log_open()) {
			return -1;
		} 
		Byte generatedEnd = log.getEnd();
		.strcpy(generatedEnd, /* create and write .add file */".add");
		Byte generatedPath = log.getPath();
		fd = ModernizedCProgram.open(generatedPath, 1 | -1024 | -1024, 644);
		if (fd < 0) {
			return -1;
		} 
		ret = (size_t).write(fd, data, len) != len;
		if (ret | ModernizedCProgram.close(fd)) {
			return -1;
		} 
		log.log_touch();
		if (log.log_mark(/* mark log file with append in progress */1)) {
			return -1;
		} 
		;
		if (log.log_append(data, /* append data (clears mark) */len)) {
			return -1;
		} 
		Object generatedLast = log.getLast();
		Object generatedFirst = log.getFirst();
		Object generatedStored = log.getStored();
		if (((generatedLast - generatedFirst) >> 10) + (generatedStored >> 10) < /* check to see if it's time to compress -- if not, then done */1024) {
			return 0;
		} 
		return ModernizedCProgram.gzlog_compress(/* time to compress */log/* gzlog_close() return values:
		    0: ok
		   -3: invalid log pointer argument */);
	}
	public static int gzlog_close(Object logd) {
		log log = logd;
		Object generatedId = log.getId();
		if (log == ((Object)0) || .strcmp(generatedId, /* check arguments */"\106\035\172")) {
			return -3;
		} 
		/* close the log file and release the lock */log.log_close();
		Byte generatedPath = log.getPath();
		if (generatedPath != ((Object)/* free structure and return */0)) {
			.free(generatedPath);
		} 
		.strcpy(generatedId, "bad");
		.free(log);
		return 0;
	}
	/* or NULL if it does not exist */
	public static Byte TGZfname(Object arcname) {
		byte[] buffer = new byte[1024];
		int origlen;
		int i;
		.strcpy(buffer, arcname);
		origlen = .strlen(buffer);
		for (i = 0; ModernizedCProgram.TGZsuffix[i]; i++) {
			.strcpy(buffer + origlen, ModernizedCProgram.TGZsuffix[i]);
			if (.access(buffer, 0) == 0) {
				return buffer;
			} 
		}
		return ((Object)0);
	}
	/* error message for the filename */
	public static void TGZnotfound(Object arcname) {
		int i;
		.fprintf((_iob[2]), "%s: Couldn't find ", ModernizedCProgram.prog);
		for (i = 0; ModernizedCProgram.TGZsuffix[i]; i++) {
			.fprintf((_iob[2]), (ModernizedCProgram.TGZsuffix[i + 1]) ? "%s%s, " : "or %s%s\n", arcname, ModernizedCProgram.TGZsuffix[i]);
		}
		.exit(1);
	}
	/* convert octal digits to int */
	/* on error return -1 */
	public static int getoct(byte p, int width) {
		int result = 0;
		byte c;
		while (width--) {
			c = p++;
			if (c == 0) {
				break;
			} 
			if (c == (byte)' ') {
				continue;
			} 
			if (c < (byte)'0' || c > (byte)'7') {
				return -1;
			} 
			result = result * 8 + (c - (byte)'0');
		}
		return result;
	}
	/* convert time_t to string */
	/* use the "YYYY/MM/DD hh:mm:ss" format */
	public static Byte strtime(Object t) {
		tm local = new tm();
		byte[] result = new byte[32];
		local = .localtime(t);
		Object generatedTm_year = local.getTm_year();
		Object generatedTm_mon = local.getTm_mon();
		Object generatedTm_mday = local.getTm_mday();
		Object generatedTm_hour = local.getTm_hour();
		Object generatedTm_min = local.getTm_min();
		Object generatedTm_sec = local.getTm_sec();
		.sprintf(result, "%4d/%02d/%02d %02d:%02d:%02d", generatedTm_year + 1900, generatedTm_mon + 1, generatedTm_mday, generatedTm_hour, generatedTm_min, generatedTm_sec);
		return result;
	}
	/* set file time */
	public static int setfiletime(Byte fname, Object ftime) {
		int isWinNT = -1;
		SYSTEMTIME st = new SYSTEMTIME();
		FILETIME locft = new FILETIME();
		FILETIME modft = new FILETIME();
		tm loctm = new tm();
		HANDLE hFile = new HANDLE();
		int result;
		loctm = .localtime(ftime);
		if (loctm == ((Object)0)) {
			return -1;
		} 
		Object generatedTm_year = loctm.getTm_year();
		st.setWYear((WORD)generatedTm_year + 1900);
		Object generatedTm_mon = loctm.getTm_mon();
		st.setWMonth((WORD)generatedTm_mon + 1);
		Object generatedTm_wday = loctm.getTm_wday();
		st.setWDayOfWeek((WORD)generatedTm_wday);
		Object generatedTm_mday = loctm.getTm_mday();
		st.setWDay((WORD)generatedTm_mday);
		Object generatedTm_hour = loctm.getTm_hour();
		st.setWHour((WORD)generatedTm_hour);
		Object generatedTm_min = loctm.getTm_min();
		st.setWMinute((WORD)generatedTm_min);
		Object generatedTm_sec = loctm.getTm_sec();
		st.setWSecond((WORD)generatedTm_sec);
		st.setWMilliseconds(0);
		if (!.SystemTimeToFileTime(st, locft) || !.LocalFileTimeToFileTime(locft, modft)) {
			return -1;
		} 
		if (isWinNT < 0) {
			isWinNT = (.GetVersion() < -1024) ? 1 : 0;
		} 
		hFile = .CreateFileA(fname, -1024, 0, ((Object)0), 3, (isWinNT ? 33554432 : 0), ((Object)0));
		if (hFile == (HANDLE)(true)) {
			return -1;
		} 
		result = .SetFileTime(hFile, ((Object)0), ((Object)0), modft) ? 0 : -1;
		.CloseHandle(hFile);
		return result;
	}
	public static int ExprMatch(byte string, byte expr) {
		while (1) {
			if ((((expr) == (byte)'*') || ((expr) == (byte)'/'))) {
				if (expr == (byte)'/') {
					if (string != (byte)'\\' && string != (byte)'/') {
						return 0;
					} 
					string++;
					expr++;
				}  else if (expr == (byte)'*') {
					if (expr++ == 0) {
						return 1;
					} 
					while (++string != expr) {
						if (string == 0) {
							return 0;
						} 
					}
				} 
			} else {
					if (string != expr) {
						return 0;
					} 
					if (expr++ == 0) {
						return 1;
					} 
					string++;
			} 
		}
	}
	public static int matchname(int arg, int argc, Byte argv, Byte fname) {
		if (arg == /* no arguments given (untgz tgzarchive) */argc) {
			return 1;
		} 
		while (arg < argc) {
			if (ModernizedCProgram.ExprMatch(fname, argv[arg++])) {
				return 1;
			} 
		}
		return /* ignore this for the moment being */0;
	}
	/* tar file list or extract */
	public static int tar(Object in, int action, int arg, int argc, Byte argv) {
		Object buffer;
		int len;
		int err;
		int getheader = 1;
		int remaining = 0;
		FILE outfile = ((Object)0);
		byte[] fname = new byte[512];
		int tarmode;
		time_t tartime = new time_t();
		attr_item attributes = ((Object)0);
		if (action == .TGZ_LIST) {
			.printf("    date      time     size                       file\n ---------- -------- --------- -------------------------------------\n");
		} 
		Object generatedHeader = buffer.getHeader();
		while (1) {
			len = ModernizedCProgram.gzread(in, buffer, 512);
			if (len < 0) {
				ModernizedCProgram.error(ModernizedCProgram.gzerror(in, err/*
				       * Always expect complete blocks to process
				       * the tar information.
				       */));
			} 
			if (len != 512) {
				action = /* force error exit */.TGZ_INVALID;
				remaining = /* force I/O cleanup */0;
			} 
			if (getheader >= /*
			       * If we have to get a tar header
			       */1/*
			           * if we met the end of the tar
			           * or the end-of-tar block,
			           * we are done
			           */) {
				if (len == 0 || generatedHeader.getName()[0] == 0) {
					break;
				} 
				tarmode = ModernizedCProgram.getoct(generatedHeader.getMode(), 8);
				tartime = (time_t)ModernizedCProgram.getoct(generatedHeader.getMtime(), 12);
				if (tarmode == -1 || tartime == (time_t)-1) {
					generatedHeader.getName()[0] = 0;
					action = .TGZ_INVALID;
				} 
				if (getheader == 1) {
					.strncpy(fname, generatedHeader.getName(), 100);
					if (fname[100 - 1] != 0) {
						fname[100] = 0;
					} 
				} else {
						if (.strncmp(fname, generatedHeader.getName(), 100 - 1) != /*
						               * The file name is longer than SHORTNAMESIZE
						               */0) {
							ModernizedCProgram.error("bad long name");
						} 
						getheader = 1;
				} 
				switch (generatedHeader.getTypeflag()) {
				case (byte)'5':
						if (action == .TGZ_LIST) {
							.printf(" %s     <dir> %s\n", ModernizedCProgram.strtime(tartime), fname);
						} 
						if (action == .TGZ_EXTRACT) {
							ModernizedCProgram.makedir(fname);
							attributes.push_attr(fname, tarmode, tartime);
						} 
						break;
				case (byte)'\0':
						remaining = ModernizedCProgram.getoct(generatedHeader.getSize(), 12);
						if (remaining == -1) {
							action = .TGZ_INVALID;
							break;
						} 
						if (action == .TGZ_LIST) {
							.printf(" %s %9d %s\n", ModernizedCProgram.strtime(tartime), remaining, fname);
						}  else if (action == .TGZ_EXTRACT) {
							if (ModernizedCProgram.matchname(arg, argc, argv, fname)) {
								outfile = .fopen(fname, "wb");
								if (outfile == ((Object)0)) {
									byte p = .strrchr(fname, /* try creating directory */(byte)'/');
									if (p != ((Object)0)) {
										p = (byte)'\0';
										ModernizedCProgram.makedir(fname);
										p = (byte)'/';
										outfile = .fopen(fname, "wb");
									} 
								} 
								if (outfile != ((Object)0)) {
									.printf("Extracting %s\n", fname);
								} else {
										.fprintf((_iob[2]), "%s: Couldn't create %s", ModernizedCProgram.prog, fname);
								} 
							} else {
									outfile = ((Object)0);
							} 
						} 
						getheader = 0;
						break;
				case (byte)'K':
				case (byte)'L':
						remaining = ModernizedCProgram.getoct(generatedHeader.getSize(), 12);
						if (remaining < 0 || remaining >= 512) {
							action = .TGZ_INVALID;
							break;
						} 
						len = ModernizedCProgram.gzread(in, fname, 512);
						if (len < 0) {
							ModernizedCProgram.error(ModernizedCProgram.gzerror(in, err));
						} 
						if (fname[512 - 1] != 0 || (int).strlen(fname) > remaining) {
							action = .TGZ_INVALID;
							break;
						} 
						getheader = 2;
						break;
				case (byte)'0':
				default:
						if (action == .TGZ_LIST) {
							.printf(" %s     <---> %s\n", ModernizedCProgram.strtime(tartime), fname);
						} 
						break;
				}
			} else {
					int bytes = (remaining > 512) ? 512 : remaining;
					if (outfile != ((Object)0)) {
						if (.fwrite(buffer, , bytes, outfile) != bytes) {
							.fprintf((_iob[2]), "%s: Error writing %s -- skipping\n", ModernizedCProgram.prog, fname);
							.fclose(outfile);
							outfile = ((Object)0);
							.remove(fname);
						} 
					} 
					remaining -= bytes;
			} 
			if (remaining == 0) {
				getheader = 1;
				if (outfile != ((Object)0)) {
					.fclose(outfile);
					outfile = ((Object)0);
					if (action != .TGZ_INVALID) {
						attributes.push_attr(fname, tarmode, tartime);
					} 
				} 
			} 
			if (action == /*
			       * Abandon if errors are found
			       */.TGZ_INVALID) {
				ModernizedCProgram.error("broken archive");
				break;
			} 
		}
		/*
		   * Restore file modes and time stamps
		   */attributes.restore_attr();
		if (ModernizedCProgram.gzclose(in) != 0) {
			ModernizedCProgram.error("failed gzclose");
		} 
		return 0;
	}
	/* ============================================================ */
	public static void help(int exitval) {
		.printf("untgz version 0.2.1\n  using zlib version %s\n\n", ModernizedCProgram.zlibVersion());
		.printf("Usage: untgz file.tgz            extract all files\n       untgz file.tgz fname ...  extract selected files\n       untgz -l file.tgz         list archive contents\n       untgz -h                  display this help\n");
		.exit(exitval);
	}
	public static Object zlibVersion() {
		return "1.2.11";
	}
	public static Object zlibCompileFlags() {
		uLong flags = new uLong();
		flags = 0;
		switch ((int)()) {
		case 4:
				flags += 1;
				break;
		case 8:
				flags += 2;
				break;
		case 2:
				break;
		default:
				flags += 3;
		}
		switch ((int)()) {
		case 4:
				flags += 1 << 2;
				break;
		case 8:
				flags += 2 << 2;
				break;
		case 2:
				break;
		default:
				flags += 3 << 2;
		}
		switch ((int)()) {
		case 2:
				break;
		case 4:
				flags += 1 << 4;
				break;
		case 8:
				flags += 2 << 4;
				break;
		default:
				flags += 3 << 4;
		}
		switch ((int)()) {
		case 2:
				break;
		case 8:
				flags += 2 << 6;
				break;
		case 4:
				flags += 1 << 6;
				break;
		default:
				flags += 3 << 6;
		}
		return flags;
	}
	/* exported to allow conversion of error code to string for compress() and
	 * uncompress()
	 */
	public static Object zError(int err) {
		return ModernizedCProgram.z_errmsg[2 - (err/* The Microsoft C Run-Time Library for Windows CE doesn't have
		     * errno.  We define it as a global variable to simplify porting.
		     * Its value is always 0 and should not be used.
		     */)];
	}
	/* ??? to be unrolled */
	/* ??? to be unrolled */
	/* Turbo C in 16-bit mode */
	/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
	 * and farmalloc(64K) returns a pointer with an offset of 8, so we
	 * must fix the pointer. Warning: the pointer must be put back to its
	 * original form in order to free it, use zcfree().
	 */
	/* 10*64K = 640K */
	/* This table is used to remember the original form of pointers
	 * to large buffers (64K). Such pointers are normalized with a zero offset.
	 * Since MSDOS is not a preemptive multitasking OS, this table is not
	 * protected from concurrent access. This hack doesn't work anyway on
	 * a protected system like OS/2. Use Microsoft C instead.
	 */
	/* If we allocate less than 65520 bytes, we assume that farmalloc
	     * will return a usable pointer which doesn't have to be normalized.
	     */
	/* Normalize the pointer to seg:0 */
	/* object < 64K */
	/* Find the original pointer */
	/* __TURBOC__ */
	/* Microsoft C in 16-bit mode */
	/* M_I86 */
	/* SYS16BIT */
	/* Any system without a special alloc function */
	public static Object zcalloc(Object opaque, int items, int size) {
		(Object)opaque;
		return  > 2 ? (voidpf).malloc(items * size) : (voidpf).calloc(items, size);
	}
	public static void zcfree(Object opaque, Object ptr) {
		(Object)opaque;
		.free(ptr/* MY_ZCALLOC *//* !Z_SOLO */);
	}
}
