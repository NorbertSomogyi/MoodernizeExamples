package application;

public class ModernizedCProgram {
	public static CURLcode Curl_getformdata = new CURLcode();
	public static byte Curl_checkheaders;
	public static Object Curl_init_CONNECT;
	public static  Curl_pretransfer = new ();
	public static  Curl_posttransfer = new ();
	public static  Curl_follow = new ();
	public static  Curl_readwrite = new ();
	public static int Curl_single_getsock;
	public static  Curl_readrewind = new ();
	public static  Curl_fillreadbuffer = new ();
	public static  Curl_retry_request = new ();
	public static  Curl_meets_timecondition = new ();
	public static  Curl_get_upload_buffer = new ();
	public static  Curl_done_sending = new ();
	public static Object Curl_setup_transfer;
	public static Object curl_llist_dtor;
	public static Object Curl_llist_init;
	public static Object Curl_llist_insert_next;
	public static Object Curl_llist_remove;
	public static size_t Curl_llist_count = new size_t();
	public static Object Curl_llist_destroy;
	public static Object Curl_llist_move;
	public static Object Curl_updatesocket;
	public static Object Curl_expire;
	public static Object Curl_expire_clear;
	public static Object Curl_expire_done;
	public static Object Curl_update_timer;
	public static Object Curl_attach_connnection;
	public static  Curl_multiplex_wanted = new ();
	public static Object Curl_set_in_callback;
	public static  Curl_is_in_callback = new ();
	public static Curl_multi Curl_multi_handle = new Curl_multi();
	public static  Curl_multi_max_host_connections = new ();
	public static  Curl_multi_max_total_connections = new ();
	public static Object Curl_multiuse_state;
	public static Object Curl_multi_closed;
	public static  Curl_multi_add_perform = new ();
	public static  Curl_multi_max_concurrent_streams = new ();
	public static byte decc$getenv;
	public static passwd decc$getpwuid = new passwd();
	public static passwd vms_passwd_cache = new passwd();
	public static int Curl_gethostname;
	public static curl_hash Curl_global_host_cache_init = new curl_hash();
	public static int Curl_resolv;
	public static int Curl_resolv_timeout;
	public static bool Curl_ipvalid = new bool();
	public static Curl_addrinfo Curl_getaddrinfo = new Curl_addrinfo();
	public static Object Curl_resolv_unlock;
	public static int Curl_mk_dnscache;
	public static Object Curl_hostcache_prune;
	public static int Curl_num_addresses;
	public static Curl_addrinfo Curl_ipv4_resolve_r = new Curl_addrinfo();
	public static CURLcode Curl_once_resolved = new CURLcode();
	public static CURLcode Curl_addrinfo_callback = new CURLcode();
	public static byte Curl_printable_address;
	public static Curl_dns_entry Curl_fetch_addr = new Curl_dns_entry();
	public static Curl_dns_entry Curl_cache_addr = new Curl_dns_entry();
	public static CURLcode Curl_set_dns_servers = new CURLcode();
	public static CURLcode Curl_set_dns_interface = new CURLcode();
	public static CURLcode Curl_set_dns_local_ip4 = new CURLcode();
	public static CURLcode Curl_set_dns_local_ip6 = new CURLcode();
	public static Object Curl_hostcache_clean;
	public static CURLcode Curl_loadhostpairs = new CURLcode();
	public static CURLcode Curl_resolv_check = new CURLcode();
	public static int Curl_resolv_getsock;
	public static CURLcode Curl_input_digest = new CURLcode();
	public static CURLcode Curl_output_digest = new CURLcode();
	public static Object Curl_http_auth_cleanup_digest;
	public static Object tool_go_sleep;
	public static slist_wc easysrc_decl = ((Object)/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* use our own printf() functions *//* keep this as LAST include *//* global variable definitions, for easy-interface source code generation *//* Variable declarations */0);
	public static slist_wc easysrc_data = ((Object)/* Build slists, forms etc. */0);
	public static slist_wc easysrc_code = ((Object)/* Setopt calls */0);
	public static slist_wc easysrc_toohard = ((Object)/* Unconvertible setopt */0);
	public static slist_wc easysrc_clean = ((Object)/* Clean up allocated data */0);
	public static int easysrc_mime_count = 0;
	public static int easysrc_slist_count = 0;
	public static byte[] srchead = new byte[]{"/********* Sample code generated by the curl command line tool **********", " * All curl_easy_setopt() options are documented at:", " * https://curl.haxx.se/libcurl/c/curl_easy_setopt.html", " ************************************************************************/", "#include <curl/curl.h>", "", "int main(int argc, char *argv[])", "{", "  CURLcode ret;", "  CURL *hnd;", ((Object)0/* easysrc_decl declarations come here */)};
	public static byte[] srchard = new byte[]{/* easysrc_data initialisations come here *//* easysrc_code statements come here */"/* Here is a list of options the curl code used that cannot get generated", "   as source easily. You may select to either not use them or implement", "   them yourself.", "", ((Object)0)};
	public static byte[] srcend = new byte[]{"", "  return (int)ret;", "}", "/**** End of sample code ****/", ((Object)0)};
	public static CURLcode Curl_input_ntlm = new CURLcode();
	public static CURLcode Curl_output_ntlm = new CURLcode();
	public static Object Curl_http_auth_cleanup_ntlm;
	public static SANITIZEcode sanitize_file_name = new SANITIZEcode();
	public static CURLcode FindWin32CACert = new CURLcode();
	public static curl_slist GetLoadedModulePaths = new curl_slist();
	public static Curl_handler Curl_handler_gopher = new Curl_handler();
	public static Cookie Curl_cookie_add = new Cookie();
	public static Cookie Curl_cookie_getlist = new Cookie();
	public static Object Curl_cookie_freelist;
	public static Object Curl_cookie_clearall;
	public static Object Curl_cookie_clearsess;
	public static Object Curl_flush_cookies;
	public static Object Curl_cookie_cleanup;
	public static CookieInfo Curl_cookie_init = new CookieInfo();
	public static curl_slist Curl_cookie_list = new curl_slist();
	public static Object Curl_cookie_loadfiles;
	public static Object destroy_async_data;
	public static bool init_resolve_thread = new bool();
	public static NameValue[] setopt_nv_CURLPROXY = new NameValue[]{new NameValue("CURLPROXY_HTTP", /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* use our own printf() functions *//* keep this as LAST include *//* Lookup tables for converting setopt values back to symbols *//* For enums, values may be in any order. *//* For bit masks, put combinations first, then single bits, *//* and finally any "NONE" value. *//* sentinel to mark end of list */.CURLPROXY_HTTP), new NameValue("CURLPROXY_HTTP_1_0", .CURLPROXY_HTTP_1_0), new NameValue("CURLPROXY_HTTPS", .CURLPROXY_HTTPS), new NameValue("CURLPROXY_SOCKS4", .CURLPROXY_SOCKS4), new NameValue("CURLPROXY_SOCKS5", .CURLPROXY_SOCKS5), new NameValue("CURLPROXY_SOCKS4A", .CURLPROXY_SOCKS4A), new NameValue("CURLPROXY_SOCKS5_HOSTNAME", .CURLPROXY_SOCKS5_HOSTNAME), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURL_SOCKS_PROXY = new NameValue[]{new NameValue("CURLPROXY_SOCKS4", .CURLPROXY_SOCKS4), new NameValue("CURLPROXY_SOCKS5", .CURLPROXY_SOCKS5), new NameValue("CURLPROXY_SOCKS4A", .CURLPROXY_SOCKS4A), new NameValue("CURLPROXY_SOCKS5_HOSTNAME", .CURLPROXY_SOCKS5_HOSTNAME), new NameValue(((Object)0), 0)};
	public static NameValueUnsigned[] setopt_nv_CURLAUTH = new NameValueUnsigned[]{new NameValueUnsigned("CURLAUTH_ANY", (~(((long)1) << /* combination */4))), new NameValueUnsigned("CURLAUTH_ANYSAFE", (~((((long)1) << 0) | (((long)1) << /* combination */4)))), new NameValueUnsigned("CURLAUTH_BASIC", (((long)1) << 0)), new NameValueUnsigned("CURLAUTH_DIGEST", (((long)1) << 1)), new NameValueUnsigned("CURLAUTH_GSSNEGOTIATE", (((long)1) << 2)), new NameValueUnsigned("CURLAUTH_NTLM", (((long)1) << 3)), new NameValueUnsigned("CURLAUTH_DIGEST_IE", (((long)1) << 4)), new NameValueUnsigned("CURLAUTH_NTLM_WB", (((long)1) << 5)), new NameValueUnsigned("CURLAUTH_ONLY", (((long)1) << 31)), new NameValueUnsigned("CURLAUTH_NONE", ((long)0)), new NameValueUnsigned(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURL_HTTP_VERSION = new NameValue[]{new NameValue("CURL_HTTP_VERSION_NONE", .CURL_HTTP_VERSION_NONE), new NameValue("CURL_HTTP_VERSION_1_0", .CURL_HTTP_VERSION_1_0), new NameValue("CURL_HTTP_VERSION_1_1", .CURL_HTTP_VERSION_1_1), new NameValue("CURL_HTTP_VERSION_2_0", .CURL_HTTP_VERSION_2_0), new NameValue("CURL_HTTP_VERSION_2TLS", .CURL_HTTP_VERSION_2TLS), new NameValue("CURL_HTTP_VERSION_3", .CURL_HTTP_VERSION_3), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURL_SSLVERSION = new NameValue[]{new NameValue("CURL_SSLVERSION_DEFAULT", .CURL_SSLVERSION_DEFAULT), new NameValue("CURL_SSLVERSION_TLSv1", .CURL_SSLVERSION_TLSv1), new NameValue("CURL_SSLVERSION_SSLv2", .CURL_SSLVERSION_SSLv2), new NameValue("CURL_SSLVERSION_SSLv3", .CURL_SSLVERSION_SSLv3), new NameValue("CURL_SSLVERSION_TLSv1_0", .CURL_SSLVERSION_TLSv1_0), new NameValue("CURL_SSLVERSION_TLSv1_1", .CURL_SSLVERSION_TLSv1_1), new NameValue("CURL_SSLVERSION_TLSv1_2", .CURL_SSLVERSION_TLSv1_2), new NameValue("CURL_SSLVERSION_TLSv1_3", .CURL_SSLVERSION_TLSv1_3), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURL_TIMECOND = new NameValue[]{new NameValue("CURL_TIMECOND_IFMODSINCE", .CURL_TIMECOND_IFMODSINCE), new NameValue("CURL_TIMECOND_IFUNMODSINCE", .CURL_TIMECOND_IFUNMODSINCE), new NameValue("CURL_TIMECOND_LASTMOD", .CURL_TIMECOND_LASTMOD), new NameValue("CURL_TIMECOND_NONE", .CURL_TIMECOND_NONE), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURLFTPSSL_CCC = new NameValue[]{new NameValue("CURLFTPSSL_CCC_NONE", .CURLFTPSSL_CCC_NONE), new NameValue("CURLFTPSSL_CCC_PASSIVE", .CURLFTPSSL_CCC_PASSIVE), new NameValue("CURLFTPSSL_CCC_ACTIVE", .CURLFTPSSL_CCC_ACTIVE), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURLUSESSL = new NameValue[]{new NameValue("CURLUSESSL_NONE", .CURLUSESSL_NONE), new NameValue("CURLUSESSL_TRY", .CURLUSESSL_TRY), new NameValue("CURLUSESSL_CONTROL", .CURLUSESSL_CONTROL), new NameValue("CURLUSESSL_ALL", .CURLUSESSL_ALL), new NameValue(((Object)0), 0)};
	public static NameValueUnsigned[] setopt_nv_CURLSSLOPT = new NameValueUnsigned[]{new NameValueUnsigned("CURLSSLOPT_ALLOW_BEAST", (1 << 0)), new NameValueUnsigned("CURLSSLOPT_NO_REVOKE", (1 << 1)), new NameValueUnsigned(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURL_NETRC = new NameValue[]{new NameValue("CURL_NETRC_IGNORED", CURL_NETRC_OPTION.CURL_NETRC_IGNORED), new NameValue("CURL_NETRC_OPTIONAL", CURL_NETRC_OPTION.CURL_NETRC_OPTIONAL), new NameValue("CURL_NETRC_REQUIRED", CURL_NETRC_OPTION.CURL_NETRC_REQUIRED), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURLPROTO = new NameValue[]{new NameValue("CURLPROTO_ALL", (~/* These mappings essentially triplicated - see
	 * tool_libinfo.c and tool_paramhlp.c *//* combination */0)), new NameValue("CURLPROTO_DICT", (1 << 9)), new NameValue("CURLPROTO_FILE", (1 << 10)), new NameValue("CURLPROTO_FTP", (1 << 2)), new NameValue("CURLPROTO_FTPS", (1 << 3)), new NameValue("CURLPROTO_GOPHER", (1 << 25)), new NameValue("CURLPROTO_HTTP", (1 << 0)), new NameValue("CURLPROTO_HTTPS", (1 << 1)), new NameValue("CURLPROTO_IMAP", (1 << 12)), new NameValue("CURLPROTO_IMAPS", (1 << 13)), new NameValue("CURLPROTO_LDAP", (1 << 7)), new NameValue("CURLPROTO_LDAPS", (1 << 8)), new NameValue("CURLPROTO_POP3", (1 << 14)), new NameValue("CURLPROTO_POP3S", (1 << 15)), new NameValue("CURLPROTO_RTSP", (1 << 18)), new NameValue("CURLPROTO_SCP", (1 << 4)), new NameValue("CURLPROTO_SFTP", (1 << 5)), new NameValue("CURLPROTO_SMB", (1 << 26)), new NameValue("CURLPROTO_SMBS", (1 << 27)), new NameValue("CURLPROTO_SMTP", (1 << 16)), new NameValue("CURLPROTO_SMTPS", (1 << 17)), new NameValue("CURLPROTO_TELNET", (1 << 6)), new NameValue("CURLPROTO_TFTP", (1 << 11)), new NameValue(((Object)0), 0)};
	public static NameValue[] setopt_nv_CURLNONZERODEFAULTS = new NameValue[]{new NameValue("CURLOPT_SSL_VERIFYPEER", (/* These options have non-zero default values. */true)), new NameValue("CURLOPT_SSL_VERIFYHOST", (true)), new NameValue("CURLOPT_SSL_ENABLE_NPN", (true)), new NameValue("CURLOPT_SSL_ENABLE_ALPN", (true)), new NameValue("CURLOPT_TCP_NODELAY", (true)), new NameValue("CURLOPT_PROXY_SSL_VERIFYPEER", (true)), new NameValue("CURLOPT_PROXY_SSL_VERIFYHOST", (true)), new NameValue("CURLOPT_SOCKS5_AUTH", (true)), new NameValue(((Object)0), 0/* Format and add code; jump to nomem on malloc error */)};
	public static CURLcode libcurl_generate_mime = new CURLcode();
	public static byte[] ascii = new byte[]{(1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5) | (1 << 3), (1 << 5) | (1 << 3), (1 << 5) | (1 << 3), (1 << 5) | (1 << 3), (1 << 5) | (1 << 3), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 5), (1 << 3) | (1 << 7), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 2), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 0) | (1 << 6), (1 << 0) | (1 << 6), (1 << 0) | (1 << 6), (1 << 0) | (1 << 6), (1 << 0) | (1 << 6), (1 << 0) | (1 << 6), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 0), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 1) | (1 << 6), (1 << 1) | (1 << 6), (1 << 1) | (1 << 6), (1 << 1) | (1 << 6), (1 << 1) | (1 << 6), (1 << 1) | (1 << 6), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 1), (1 << 4), (1 << 4), (1 << 4), (1 << 4), (1 << 5)};
	public static Curl_handler Curl_handler_imap = new Curl_handler();
	public static Curl_handler Curl_handler_imaps = new Curl_handler();
	public static byte unslashquote;
	public static byte my_get_line;
	public static int Curl_resolver_global_init;
	public static Object Curl_resolver_global_cleanup;
	public static CURLcode Curl_resolver_init = new CURLcode();
	public static Object Curl_resolver_cleanup;
	public static CURLcode Curl_resolver_duphandle = new CURLcode();
	public static Object Curl_resolver_cancel;
	public static Object Curl_resolver_kill;
	public static int Curl_resolver_getsock;
	public static CURLcode Curl_resolver_is_resolved = new CURLcode();
	public static CURLcode Curl_resolver_wait_resolv = new CURLcode();
	public static Curl_addrinfo Curl_resolver_getaddrinfo = new Curl_addrinfo();
	public static int Curl_parsenetrc;
	public static Object Curl_memrchr;
	public static byte param2text;
	public static int SetHTTPrequest;
	public static Object customrequest_helper;
	public static int Curl_socketpair;
	public static int Curl_cert_hostcheck;
	public static LARGE_INTEGER Curl_freq = new LARGE_INTEGER();
	public static bool Curl_isVistaOrGreater = new bool();
	public static HMODULE s_hIpHlpApiDll = ((Object)/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2016 - 2019, Steve Holme, <steve_holme@hotmail.com>.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* The last #include files should be: *//* Handle of iphlpapp.dll */0);
	public static IF_NAMETOINDEX_FN Curl_if_nametoindex = ((Object)/* Pointer to the if_nametoindex function */0);
	public static HMODULE LOADLIBRARYEX_FN = new HMODULE();
	public static timeval tvnow = new timeval();
	public static long tvdiff;
	public static byte Curl_strtok_r;
	public static byte[] base64 = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* Base64 encoding/decoding *//* for the Curl_easy definition *//* The last 3 #include files should be in this order *//* ---- Base64 Encoding/Decoding Table --- */"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"/* The Base 64 encoding with an URL and filename safe alphabet, RFC 4648
	   section 5 */;
	public static byte[] base64url = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
	public static Curl_handler Curl_handler_smtp = new Curl_handler();
	public static Curl_handler Curl_handler_smtps = new Curl_handler();
	public static CURLcode Curl_smtp_escape_eob = new CURLcode();
	public static Object Curl_version_init;
	public static byte[] protocols = new byte[]{"dict", "file", "ftp", "gopher", "http", "imap", "ldap", "ldaps", "pop3", "rtsp", "smb", "smtp", "telnet", "tftp", ((Object)0)};
	public static curl_version_info_data version_info = new curl_version_info_data(.CURLVERSION_SIXTH, "7.67.0-DEV", -1024, /* as found by configure or set by hand at build-time */"i386-pc-win32", /* features is 0 by default */0 | (1 << 4) | (1 << 7) | (1 << 9), ((Object)/* ssl_version */0), /* ssl_version_num, this is kept at zero */0, ((Object)/* zlib_version */0), protocols, ((Object)/* c-ares version */0), /* c-ares version numerical */0, ((Object)/* libidn version */0), /* iconv version */0, ((Object)/* ssh lib version */0), /* brotli_ver_num */0, ((Object)/* brotli version */0), /* nghttp2 version number */0, ((Object)/* nghttp2 version string */0), ((Object)/* quic library string */0));
	public static CURLcode Curl_sendf = new CURLcode();
	public static Object Curl_infof;
	public static Object Curl_failf;
	public static CURLcode Curl_client_write = new CURLcode();
	public static bool Curl_recv_has_postponed_data = new bool();
	public static CURLcode Curl_read_plain = new CURLcode();
	public static ssize_t Curl_recv_plain = new ssize_t();
	public static ssize_t Curl_send_plain = new ssize_t();
	public static CURLcode Curl_read = new CURLcode();
	public static CURLcode Curl_write = new CURLcode();
	public static CURLcode Curl_write_plain = new CURLcode();
	public static int Curl_debug;
	public static Object curl_malloc_callback;
	public static Object curl_free_callback;
	public static Object curl_realloc_callback;
	public static byte curl_strdup_callback;
	public static Object curl_calloc_callback;
	public static curl_malloc_callback Curl_cmalloc = new curl_malloc_callback();
	public static curl_free_callback Curl_cfree = new curl_free_callback();
	public static curl_realloc_callback Curl_crealloc = new curl_realloc_callback();
	public static curl_strdup_callback Curl_cstrdup = new curl_strdup_callback();
	public static curl_calloc_callback Curl_ccalloc = new curl_calloc_callback();
	public static int Curl_isspace;
	public static int Curl_isdigit;
	public static int Curl_isalnum;
	public static int Curl_isxdigit;
	public static int Curl_isgraph;
	public static int Curl_isprint;
	public static int Curl_isalpha;
	public static int Curl_isupper;
	public static int Curl_islower;
	public static int Curl_iscntrl;
	public static CURLcode operate = new CURLcode();
	public static per_transfer transfers = new per_transfer();
	public static int parseconfig;
	public static CURLSHcode Curl_share_lock = new CURLSHcode();
	public static CURLSHcode Curl_share_unlock = new CURLSHcode();
	public static CURLcode smtp_regular_transfer = new CURLcode();
	public static CURLcode smtp_do = new CURLcode();
	public static CURLcode smtp_done = new CURLcode();
	public static CURLcode smtp_connect = new CURLcode();
	public static CURLcode smtp_disconnect = new CURLcode();
	public static CURLcode smtp_multi_statemach = new CURLcode();
	public static int smtp_getsock;
	public static CURLcode smtp_doing = new CURLcode();
	public static CURLcode smtp_setup_connection = new CURLcode();
	public static CURLcode smtp_parse_url_options = new CURLcode();
	public static CURLcode smtp_parse_url_path = new CURLcode();
	public static CURLcode smtp_parse_custom_request = new CURLcode();
	public static CURLcode smtp_perform_auth = new CURLcode();
	public static CURLcode smtp_continue_auth = new CURLcode();
	public static Object smtp_get_message;
	public static SASLproto saslsmtp = new SASLproto(/* The service name */"smtp", /* Code received when continuation is expected */334, /* Code to receive upon authentication success */235, 512 - /* Maximum initial response length (no max) */8, /* Send authentication command */smtp_perform_auth, /* Send authentication continuation */smtp_continue_auth, /* Get SASL response message */smtp_get_message/* Change the connection handler *//* Set the connection's upgraded to TLS flag */);
	public static helptxt[] helptext = new helptxt[]{new helptxt("    --abstract-unix-socket <path>", "Connect via abstract Unix domain socket"), new helptxt("    --alt-svc <file name>", "Enable alt-svc with this cache file"), new helptxt("    --anyauth", "Pick any authentication method"), new helptxt("-a, --append", "Append to target file when uploading"), new helptxt("    --basic", "Use HTTP Basic Authentication"), new helptxt("    --cacert <file>", "CA certificate to verify peer against"), new helptxt("    --capath <dir>", "CA directory to verify peer against"), new helptxt("-E, --cert <certificate[:password]>", "Client certificate file and password"), new helptxt("    --cert-status", "Verify the status of the server certificate"), new helptxt("    --cert-type <type>", "Certificate file type (DER/PEM/ENG)"), new helptxt("    --ciphers <list of ciphers>", "SSL ciphers to use"), new helptxt("    --compressed", "Request compressed response"), new helptxt("    --compressed-ssh", "Enable SSH compression"), new helptxt("-K, --config <file>", "Read config from a file"), new helptxt("    --connect-timeout <seconds>", "Maximum time allowed for connection"), new helptxt("    --connect-to <HOST1:PORT1:HOST2:PORT2>", "Connect to host"), new helptxt("-C, --continue-at <offset>", "Resumed transfer offset"), new helptxt("-b, --cookie <data|filename>", "Send cookies from string/file"), new helptxt("-c, --cookie-jar <filename>", "Write cookies to <filename> after operation"), new helptxt("    --create-dirs", "Create necessary local directory hierarchy"), new helptxt("    --crlf", "Convert LF to CRLF in upload"), new helptxt("    --crlfile <file>", "Get a CRL list in PEM format from the given file"), new helptxt("-d, --data <data>", "HTTP POST data"), new helptxt("    --data-ascii <data>", "HTTP POST ASCII data"), new helptxt("    --data-binary <data>", "HTTP POST binary data"), new helptxt("    --data-raw <data>", "HTTP POST data, '@' allowed"), new helptxt("    --data-urlencode <data>", "HTTP POST data url encoded"), new helptxt("    --delegation <LEVEL>", "GSS-API delegation permission"), new helptxt("    --digest", "Use HTTP Digest Authentication"), new helptxt("-q, --disable", "Disable .curlrc"), new helptxt("    --disable-eprt", "Inhibit using EPRT or LPRT"), new helptxt("    --disable-epsv", "Inhibit using EPSV"), new helptxt("    --disallow-username-in-url", "Disallow username in url"), new helptxt("    --dns-interface <interface>", "Interface to use for DNS requests"), new helptxt("    --dns-ipv4-addr <address>", "IPv4 address to use for DNS requests"), new helptxt("    --dns-ipv6-addr <address>", "IPv6 address to use for DNS requests"), new helptxt("    --dns-servers <addresses>", "DNS server addrs to use"), new helptxt("    --doh-url <URL>", "Resolve host names over DOH"), new helptxt("-D, --dump-header <filename>", "Write the received headers to <filename>"), new helptxt("    --egd-file <file>", "EGD socket path for random data"), new helptxt("    --engine <name>", "Crypto engine to use"), new helptxt("    --expect100-timeout <seconds>", "How long to wait for 100-continue"), new helptxt("-f, --fail", "Fail silently (no output at all) on HTTP errors"), new helptxt("    --fail-early", "Fail on first transfer error, do not continue"), new helptxt("    --false-start", "Enable TLS False Start"), new helptxt("-F, --form <name=content>", "Specify multipart MIME data"), new helptxt("    --form-string <name=string>", "Specify multipart MIME data"), new helptxt("    --ftp-account <data>", "Account data string"), new helptxt("    --ftp-alternative-to-user <command>", "String to replace USER [name]"), new helptxt("    --ftp-create-dirs", "Create the remote dirs if not present"), new helptxt("    --ftp-method <method>", "Control CWD usage"), new helptxt("    --ftp-pasv", "Use PASV/EPSV instead of PORT"), new helptxt("-P, --ftp-port <address>", "Use PORT instead of PASV"), new helptxt("    --ftp-pret", "Send PRET before PASV"), new helptxt("    --ftp-skip-pasv-ip", "Skip the IP address for PASV"), new helptxt("    --ftp-ssl-ccc", "Send CCC after authenticating"), new helptxt("    --ftp-ssl-ccc-mode <active/passive>", "Set CCC mode"), new helptxt("    --ftp-ssl-control", "Require SSL/TLS for FTP login, clear for transfer"), new helptxt("-G, --get", "Put the post data in the URL and use GET"), new helptxt("-g, --globoff", "Disable URL sequences and ranges using {} and []"), new helptxt("    --happy-eyeballs-timeout-ms <milliseconds>", "How long to wait in milliseconds for IPv6 before trying IPv4"), new helptxt("    --haproxy-protocol", "Send HAProxy PROXY protocol v1 header"), new helptxt("-I, --head", "Show document info only"), new helptxt("-H, --header <header/@file>", "Pass custom header(s) to server"), new helptxt("-h, --help", "This help text"), new helptxt("    --hostpubmd5 <md5>", "Acceptable MD5 hash of the host public key"), new helptxt("    --http0.9", "Allow HTTP 0.9 responses"), new helptxt("-0, --http1.0", "Use HTTP 1.0"), new helptxt("    --http1.1", "Use HTTP 1.1"), new helptxt("    --http2", "Use HTTP 2"), new helptxt("    --http2-prior-knowledge", "Use HTTP 2 without HTTP/1.1 Upgrade"), new helptxt("    --http3", "Use HTTP v3"), new helptxt("    --ignore-content-length", "Ignore the size of the remote resource"), new helptxt("-i, --include", "Include protocol response headers in the output"), new helptxt("-k, --insecure", "Allow insecure server connections when using SSL"), new helptxt("    --interface <name>", "Use network INTERFACE (or address)"), new helptxt("-4, --ipv4", "Resolve names to IPv4 addresses"), new helptxt("-6, --ipv6", "Resolve names to IPv6 addresses"), new helptxt("-j, --junk-session-cookies", "Ignore session cookies read from file"), new helptxt("    --keepalive-time <seconds>", "Interval time for keepalive probes"), new helptxt("    --key <key>", "Private key file name"), new helptxt("    --key-type <type>", "Private key file type (DER/PEM/ENG)"), new helptxt("    --krb <level>", "Enable Kerberos with security <level>"), new helptxt("    --libcurl <file>", "Dump libcurl equivalent code of this command line"), new helptxt("    --limit-rate <speed>", "Limit transfer speed to RATE"), new helptxt("-l, --list-only", "List only mode"), new helptxt("    --local-port <num/range>", "Force use of RANGE for local port numbers"), new helptxt("-L, --location", "Follow redirects"), new helptxt("    --location-trusted", "Like --location, and send auth to other hosts"), new helptxt("    --login-options <options>", "Server login options"), new helptxt("    --mail-auth <address>", "Originator address of the original email"), new helptxt("    --mail-from <address>", "Mail from this address"), new helptxt("    --mail-rcpt <address>", "Mail to this address"), new helptxt("-M, --manual", "Display the full manual"), new helptxt("    --max-filesize <bytes>", "Maximum file size to download"), new helptxt("    --max-redirs <num>", "Maximum number of redirects allowed"), new helptxt("-m, --max-time <seconds>", "Maximum time allowed for the transfer"), new helptxt("    --metalink", "Process given URLs as metalink XML file"), new helptxt("    --negotiate", "Use HTTP Negotiate (SPNEGO) authentication"), new helptxt("-n, --netrc", "Must read .netrc for user name and password"), new helptxt("    --netrc-file <filename>", "Specify FILE for netrc"), new helptxt("    --netrc-optional", "Use either .netrc or URL"), new helptxt("-:, --next", "Make next URL use its separate set of options"), new helptxt("    --no-alpn", "Disable the ALPN TLS extension"), new helptxt("-N, --no-buffer", "Disable buffering of the output stream"), new helptxt("    --no-keepalive", "Disable TCP keepalive on the connection"), new helptxt("    --no-npn", "Disable the NPN TLS extension"), new helptxt("    --no-progress-meter", "Do not show the progress meter"), new helptxt("    --no-sessionid", "Disable SSL session-ID reusing"), new helptxt("    --noproxy <no-proxy-list>", "List of hosts which do not use proxy"), new helptxt("    --ntlm", "Use HTTP NTLM authentication"), new helptxt("    --ntlm-wb", "Use HTTP NTLM authentication with winbind"), new helptxt("    --oauth2-bearer <token>", "OAuth 2 Bearer Token"), new helptxt("-o, --output <file>", "Write to file instead of stdout"), new helptxt("-Z, --parallel", "Perform transfers in parallel"), new helptxt("    --parallel-max", "Maximum concurrency for parallel transfers"), new helptxt("    --pass <phrase>", "Pass phrase for the private key"), new helptxt("    --path-as-is", "Do not squash .. sequences in URL path"), new helptxt("    --pinnedpubkey <hashes>", "FILE/HASHES Public key to verify peer against"), new helptxt("    --post301", "Do not switch to GET after following a 301"), new helptxt("    --post302", "Do not switch to GET after following a 302"), new helptxt("    --post303", "Do not switch to GET after following a 303"), new helptxt("    --preproxy [protocol://]host[:port]", "Use this proxy first"), new helptxt("-#, --progress-bar", "Display transfer progress as a bar"), new helptxt("    --proto <protocols>", "Enable/disable PROTOCOLS"), new helptxt("    --proto-default <protocol>", "Use PROTOCOL for any URL missing a scheme"), new helptxt("    --proto-redir <protocols>", "Enable/disable PROTOCOLS on redirect"), new helptxt("-x, --proxy [protocol://]host[:port]", "Use this proxy"), new helptxt("    --proxy-anyauth", "Pick any proxy authentication method"), new helptxt("    --proxy-basic", "Use Basic authentication on the proxy"), new helptxt("    --proxy-cacert <file>", "CA certificate to verify peer against for proxy"), new helptxt("    --proxy-capath <dir>", "CA directory to verify peer against for proxy"), new helptxt("    --proxy-cert <cert[:passwd]>", "Set client certificate for proxy"), new helptxt("    --proxy-cert-type <type>", "Client certificate type for HTTPS proxy"), new helptxt("    --proxy-ciphers <list>", "SSL ciphers to use for proxy"), new helptxt("    --proxy-crlfile <file>", "Set a CRL list for proxy"), new helptxt("    --proxy-digest", "Use Digest authentication on the proxy"), new helptxt("    --proxy-header <header/@file>", "Pass custom header(s) to proxy"), new helptxt("    --proxy-insecure", "Do HTTPS proxy connections without verifying the proxy"), new helptxt("    --proxy-key <key>", "Private key for HTTPS proxy"), new helptxt("    --proxy-key-type <type>", "Private key file type for proxy"), new helptxt("    --proxy-negotiate", "Use HTTP Negotiate (SPNEGO) authentication on the proxy"), new helptxt("    --proxy-ntlm", "Use NTLM authentication on the proxy"), new helptxt("    --proxy-pass <phrase>", "Pass phrase for the private key for HTTPS proxy"), new helptxt("    --proxy-pinnedpubkey <hashes>", "FILE/HASHES public key to verify proxy with"), new helptxt("    --proxy-service-name <name>", "SPNEGO proxy service name"), new helptxt("    --proxy-ssl-allow-beast", "Allow security flaw for interop for HTTPS proxy"), new helptxt("    --proxy-tls13-ciphers <list>", "TLS 1.3 ciphersuites for proxy (OpenSSL)"), new helptxt("    --proxy-tlsauthtype <type>", "TLS authentication type for HTTPS proxy"), new helptxt("    --proxy-tlspassword <string>", "TLS password for HTTPS proxy"), new helptxt("    --proxy-tlsuser <name>", "TLS username for HTTPS proxy"), new helptxt("    --proxy-tlsv1", "Use TLSv1 for HTTPS proxy"), new helptxt("-U, --proxy-user <user:password>", "Proxy user and password"), new helptxt("    --proxy1.0 <host[:port]>", "Use HTTP/1.0 proxy on given port"), new helptxt("-p, --proxytunnel", "Operate through an HTTP proxy tunnel (using CONNECT)"), new helptxt("    --pubkey <key>", "SSH Public key file name"), new helptxt("-Q, --quote", "Send command(s) to server before transfer"), new helptxt("    --random-file <file>", "File for reading random data from"), new helptxt("-r, --range <range>", "Retrieve only the bytes within RANGE"), new helptxt("    --raw", "Do HTTP \"raw\"; no transfer decoding"), new helptxt("-e, --referer <URL>", "Referrer URL"), new helptxt("-J, --remote-header-name", "Use the header-provided filename"), new helptxt("-O, --remote-name", "Write output to a file named as the remote file"), new helptxt("    --remote-name-all", "Use the remote file name for all URLs"), new helptxt("-R, --remote-time", "Set the remote file's time on the local output"), new helptxt("-X, --request <command>", "Specify request command to use"), new helptxt("    --request-target", "Specify the target for this request"), new helptxt("    --resolve <host:port:address[,address]...>", "Resolve the host+port to this address"), new helptxt("    --retry <num>", "Retry request if transient problems occur"), new helptxt("    --retry-connrefused", "Retry on connection refused (use with --retry)"), new helptxt("    --retry-delay <seconds>", "Wait time between retries"), new helptxt("    --retry-max-time <seconds>", "Retry only within this period"), new helptxt("    --sasl-authzid <identity> ", "Use this identity to act as during SASL PLAIN authentication"), new helptxt("    --sasl-ir", "Enable initial response in SASL authentication"), new helptxt("    --service-name <name>", "SPNEGO service name"), new helptxt("-S, --show-error", "Show error even when -s is used"), new helptxt("-s, --silent", "Silent mode"), new helptxt("    --socks4 <host[:port]>", "SOCKS4 proxy on given host + port"), new helptxt("    --socks4a <host[:port]>", "SOCKS4a proxy on given host + port"), new helptxt("    --socks5 <host[:port]>", "SOCKS5 proxy on given host + port"), new helptxt("    --socks5-basic", "Enable username/password auth for SOCKS5 proxies"), new helptxt("    --socks5-gssapi", "Enable GSS-API auth for SOCKS5 proxies"), new helptxt("    --socks5-gssapi-nec", "Compatibility with NEC SOCKS5 server"), new helptxt("    --socks5-gssapi-service <name>", "SOCKS5 proxy service name for GSS-API"), new helptxt("    --socks5-hostname <host[:port]>", "SOCKS5 proxy, pass host name to proxy"), new helptxt("-Y, --speed-limit <speed>", "Stop transfers slower than this"), new helptxt("-y, --speed-time <seconds>", "Trigger 'speed-limit' abort after this time"), new helptxt("    --ssl", "Try SSL/TLS"), new helptxt("    --ssl-allow-beast", "Allow security flaw to improve interop"), new helptxt("    --ssl-no-revoke", "Disable cert revocation checks (Schannel)"), new helptxt("    --ssl-reqd", "Require SSL/TLS"), new helptxt("-2, --sslv2", "Use SSLv2"), new helptxt("-3, --sslv3", "Use SSLv3"), new helptxt("    --stderr", "Where to redirect stderr"), new helptxt("    --styled-output", "Enable styled output for HTTP headers"), new helptxt("    --suppress-connect-headers", "Suppress proxy CONNECT response headers"), new helptxt("    --tcp-fastopen", "Use TCP Fast Open"), new helptxt("    --tcp-nodelay", "Use the TCP_NODELAY option"), new helptxt("-t, --telnet-option <opt=val>", "Set telnet option"), new helptxt("    --tftp-blksize <value>", "Set TFTP BLKSIZE option"), new helptxt("    --tftp-no-options", "Do not send any TFTP options"), new helptxt("-z, --time-cond <time>", "Transfer based on a time condition"), new helptxt("    --tls-max <VERSION>", "Set maximum allowed TLS version"), new helptxt("    --tls13-ciphers <list>", "TLS 1.3 ciphersuites (OpenSSL)"), new helptxt("    --tlsauthtype <type>", "TLS authentication type"), new helptxt("    --tlspassword", "TLS password"), new helptxt("    --tlsuser <name>", "TLS user name"), new helptxt("-1, --tlsv1", "Use TLSv1.0 or greater"), new helptxt("    --tlsv1.0", "Use TLSv1.0 or greater"), new helptxt("    --tlsv1.1", "Use TLSv1.1 or greater"), new helptxt("    --tlsv1.2", "Use TLSv1.2 or greater"), new helptxt("    --tlsv1.3", "Use TLSv1.3 or greater"), new helptxt("    --tr-encoding", "Request compressed transfer encoding"), new helptxt("    --trace <file>", "Write a debug trace to FILE"), new helptxt("    --trace-ascii <file>", "Like --trace, but without hex output"), new helptxt("    --trace-time", "Add time stamps to trace/verbose output"), new helptxt("    --unix-socket <path>", "Connect through this Unix domain socket"), new helptxt("-T, --upload-file <file>", "Transfer local FILE to destination"), new helptxt("    --url <url>", "URL to work with"), new helptxt("-B, --use-ascii", "Use ASCII/text transfer"), new helptxt("-u, --user <user:password>", "Server user and password"), new helptxt("-A, --user-agent <name>", "Send User-Agent <name> to server"), new helptxt("-v, --verbose", "Make the operation more talkative"), new helptxt("-V, --version", "Show version number and quit"), new helptxt("-w, --write-out <format>", "Use output FORMAT after completion"), new helptxt("    --xattr", "Store metadata in extended file attributes"), new helptxt(((Object)0), ((Object)0))};
	public static feat[] feats = new feat[]{new feat("AsynchDNS", (1 << 7)), new feat("Debug", (1 << 6)), new feat("TrackMemory", (1 << 13)), new feat("IDN", (1 << 10)), new feat("IPv6", (1 << 0)), new feat("Largefile", (1 << 9)), new feat("SSPI", (1 << 11)), new feat("GSS-API", (1 << 17)), new feat("Kerberos", (1 << 18)), new feat("SPNEGO", (1 << 8)), new feat("NTLM", (1 << 4)), new feat("NTLM_WB", (1 << 15)), new feat("SSL", (1 << 2)), new feat("libz", (1 << 3)), new feat("brotli", (1 << 23)), new feat("CharConv", (1 << 12)), new feat("TLS-SRP", (1 << 14)), new feat("HTTP2", (1 << 16)), new feat("HTTP3", (1 << 25)), new feat("UnixSockets", (1 << 19)), new feat("HTTPS-proxy", (1 << 21)), new feat("MultiSSL", (1 << 22)), new feat("PSL", (1 << 20)), new feat("alt-svc", (1 << 24)), new feat("ESNI", (1 << 26))};
	public static  Curl_getinfo = new ();
	public static  Curl_initinfo = new ();
	public static byte[] lower_digits = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1999 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 *
	 * Purpose:
	 *  A merge of Bjorn Reese's format() function and Daniel's dsprintf()
	 *  1.0. A full blooded printf() clone with full support for <num>$
	 *  everywhere (parameters, widths and precisions) including variabled
	 *  sized parameters (like doubles, long longs, long doubles and even
	 *  void * in 64-bit architectures).
	 *
	 * Current restrictions:
	 * - Max 128 parameters
	 * - No 'long double' support.
	 *
	 * If you ever want truly portable and good *printf() clones, the project that
	 * took on from here is named 'Trio' and you find more details on the trio web
	 * page at https://daniel.haxx.se/projects/trio/
	 *//* The last #include file should be: *//*
	 * If SIZEOF_SIZE_T has not been defined, default to the size of long.
	 *//*
	 * Non-ANSI integer extensions
	 *//*
	 * Max integer data types that mprintf.c is capable
	 *//* buffer for long-to-str and float-to-str calcs, should
	                        fit negative DBL_MAX (317 letters) *//* lame static limit *//* Lower-case digits.  */"0123456789abcdefghijklmnopqrstuvwxyz";
	public static byte[] upper_digits = /* Upper-case digits.  */"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	public static byte Curl_get_line;
	public static Object tool_help;
	public static Object tool_list_engines;
	public static Object tool_version_info;
	public static Object Curl_ntlm_core_lm_resp;
	public static CURLcode Curl_ntlm_core_mk_lm_hash = new CURLcode();
	public static CURLcode Curl_ntlm_core_mk_nt_hash = new CURLcode();
	public static CURLcode Curl_hmac_md5 = new CURLcode();
	public static CURLcode Curl_ntlm_core_mk_ntlmv2_hash = new CURLcode();
	public static CURLcode Curl_ntlm_core_mk_ntlmv2_resp = new CURLcode();
	public static CURLcode Curl_ntlm_core_mk_lmv2_resp = new CURLcode();
	public static CURLcode Curl_init_do = new CURLcode();
	public static CURLcode Curl_open = new CURLcode();
	public static CURLcode Curl_init_userdefined = new CURLcode();
	public static Object Curl_freeset;
	public static CURLcode Curl_uc_to_curlcode = new CURLcode();
	public static CURLcode Curl_close = new CURLcode();
	public static CURLcode Curl_connect = new CURLcode();
	public static CURLcode Curl_disconnect = new CURLcode();
	public static CURLcode Curl_setup_conn = new CURLcode();
	public static Object Curl_free_request_state;
	public static CURLcode Curl_parse_login_details = new CURLcode();
	public static Curl_handler Curl_builtin_scheme = new Curl_handler();
	public static Object Curl_verboseconnect;
	public static int _ldap_url_parse;
	public static Object _ldap_free_urldesc;
	public static CURLcode Curl_ldap = new CURLcode();
	public static Curl_handler Curl_handler_ldap = new Curl_handler(/* scheme */"LDAP", /* setup_connection */0, /* do_it */Curl_ldap, /* done */0, /* do_more */0, /* connect_it */0, /* connecting */0, /* doing */0, /* proto_getsock */0, /* doing_getsock */0, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */0, /* readwrite */0, /* connection_check */0, /* defport */389, (1 << /* protocol */7), /* flags */0/*
	 * LDAPS protocol handler.
	 */);
	public static Curl_handler Curl_handler_ldaps = new Curl_handler(/* scheme */"LDAPS", /* setup_connection */0, /* do_it */Curl_ldap, /* done */0, /* do_more */0, /* connect_it */0, /* connecting */0, /* doing */0, /* proto_getsock */0, /* doing_getsock */0, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */0, /* readwrite */0, /* connection_check */0, /* defport */636, (1 << /* protocol */8), (1 << /* flags */0));
	public static Curl_handler Curl_handler_file = new Curl_handler();
	public static Object Curl_speedinit;
	public static CURLcode Curl_speedcheck = new CURLcode();
	public static Curl_handler Curl_handler_telnet = new Curl_handler();
	public static CURLcode smb_setup_connection = new CURLcode();
	public static CURLcode smb_connect = new CURLcode();
	public static CURLcode smb_connection_state = new CURLcode();
	public static CURLcode smb_do = new CURLcode();
	public static CURLcode smb_request_state = new CURLcode();
	public static CURLcode smb_done = new CURLcode();
	public static CURLcode smb_disconnect = new CURLcode();
	public static int smb_getsock;
	public static CURLcode smb_parse_url_path = new CURLcode();
	public static Curl_handler Curl_handler_smb = new Curl_handler(/* scheme */"SMB", /* setup_connection */smb_setup_connection, /* do_it */smb_do, /* done */smb_done, /* do_more */0, /* connect_it */smb_connect, /* connecting */smb_connection_state, /* doing */smb_request_state, /* proto_getsock */smb_getsock, /* doing_getsock */smb_getsock, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */smb_disconnect, /* readwrite */0, /* connection_check */0, /* defport */445, (1 << /* protocol */26), /* flags */0/*
	 * SMBS handler interface
	 *//* scheme *//* setup_connection *//* do_it *//* done *//* do_more *//* connect_it *//* connecting *//* doing *//* proto_getsock *//* doing_getsock *//* domore_getsock *//* perform_getsock *//* disconnect *//* readwrite *//* connection_check *//* defport *//* protocol *//* flags *//* Append a string to an SMB message */);
	public static Object _state;
	public static CURLcode ftp_sendquote = new CURLcode();
	public static CURLcode ftp_quit = new CURLcode();
	public static CURLcode ftp_parse_url_path = new CURLcode();
	public static CURLcode ftp_regular_transfer = new CURLcode();
	public static Object ftp_pasv_verbose;
	public static CURLcode ftp_state_prepare_transfer = new CURLcode();
	public static CURLcode ftp_state_mdtm = new CURLcode();
	public static CURLcode ftp_state_quote = new CURLcode();
	public static CURLcode ftp_nb_type = new CURLcode();
	public static int ftp_need_type;
	public static CURLcode ftp_do = new CURLcode();
	public static CURLcode ftp_done = new CURLcode();
	public static CURLcode ftp_connect = new CURLcode();
	public static CURLcode ftp_disconnect = new CURLcode();
	public static CURLcode ftp_do_more = new CURLcode();
	public static CURLcode ftp_multi_statemach = new CURLcode();
	public static int ftp_getsock;
	public static int ftp_domore_getsock;
	public static CURLcode ftp_doing = new CURLcode();
	public static CURLcode ftp_setup_connection = new CURLcode();
	public static CURLcode init_wc_data = new CURLcode();
	public static CURLcode wc_statemach = new CURLcode();
	public static Object wc_data_dtor;
	public static CURLcode ftp_state_retr = new CURLcode();
	public static CURLcode ftp_readresp = new CURLcode();
	public static CURLcode ftp_dophase_done = new CURLcode();
	public static Curl_handler Curl_handler_ftp = new Curl_handler(/* scheme */"FTP", /* setup_connection */ftp_setup_connection, /* do_it */ftp_do, /* done */ftp_done, /* do_more */ftp_do_more, /* connect_it */ftp_connect, /* connecting */ftp_multi_statemach, /* doing */ftp_doing, /* proto_getsock */ftp_getsock, /* doing_getsock */ftp_getsock, /* domore_getsock */ftp_domore_getsock, /* perform_getsock */0, /* disconnect */ftp_disconnect, /* readwrite */0, /* connection_check */0, /* defport */21, (1 << /* protocol */2), (1 << 1) | (1 << 2) | (1 << 5) | (1 << 6) | (1 << 11) | (1 << /* flags */12/*
	 * FTPS protocol handler.
	 *//* scheme *//* setup_connection *//* do_it *//* done *//* do_more *//* connect_it *//* connecting */));
	public static long u_int32_t;
	public static int Curl_getaddrinfo_a;
	public static int Curl_getnameinfo_a;
	public static int Curl_gsk_environment_open;
	public static int Curl_gsk_secure_soc_open;
	public static int Curl_gsk_environment_close;
	public static int Curl_gsk_secure_soc_close;
	public static int Curl_gsk_environment_init;
	public static int Curl_gsk_secure_soc_init;
	public static int Curl_gsk_attribute_set_buffer_a;
	public static int Curl_gsk_attribute_set_enum;
	public static int Curl_gsk_attribute_set_numeric_value;
	public static int Curl_gsk_attribute_set_callback;
	public static int Curl_gsk_attribute_get_buffer_a;
	public static int Curl_gsk_attribute_get_enum;
	public static int Curl_gsk_attribute_get_numeric_value;
	public static int Curl_gsk_attribute_get_cert_info;
	public static int Curl_gsk_secure_soc_misc;
	public static int Curl_gsk_secure_soc_read;
	public static int Curl_gsk_secure_soc_write;
	public static byte Curl_gsk_strerror_a;
	public static int Curl_gsk_secure_soc_startInit;
	public static  Curl_gss_import_name_a = new ();
	public static  Curl_gss_display_status_a = new ();
	public static  Curl_gss_init_sec_context_a = new ();
	public static  Curl_gss_delete_sec_context_a = new ();
	public static int Curl_os400_connect;
	public static int Curl_os400_bind;
	public static int Curl_os400_sendto;
	public static int Curl_os400_recvfrom;
	public static int Curl_os400_getpeername;
	public static int Curl_os400_getsockname;
	public static int inet_pton4;
	public static Curl_handler Curl_handler_pop3 = new Curl_handler();
	public static Curl_handler Curl_handler_pop3s = new Curl_handler();
	public static CURLcode Curl_pop3_write = new CURLcode();
	public static long[] K = new long[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024/* Various logical functions */};
	public static int Curl_pgrsDone;
	public static Object Curl_pgrsStartNow;
	public static Object Curl_pgrsSetDownloadSize;
	public static Object Curl_pgrsSetUploadSize;
	public static Object Curl_pgrsSetDownloadCounter;
	public static Object Curl_pgrsSetUploadCounter;
	public static Object Curl_ratelimit;
	public static int Curl_pgrsUpdate;
	public static Object Curl_pgrsResetTransferSizes;
	public static Object Curl_pgrsTime;
	public static timediff_t Curl_pgrsLimitWaitTime = new timediff_t();
	public static Object config_init;
	public static Object config_free;
	public static LongShort[] aliases = new LongShort[]{new LongShort("*@", "url", .ARG_STRING), new LongShort("*4", "dns-ipv4-addr", .ARG_STRING), new LongShort("*6", "dns-ipv6-addr", .ARG_STRING), new LongShort("*a", "random-file", .ARG_FILENAME), new LongShort("*b", "egd-file", .ARG_STRING), new LongShort("*B", "oauth2-bearer", .ARG_STRING), new LongShort("*c", "connect-timeout", .ARG_STRING), new LongShort("*C", "doh-url", .ARG_STRING), new LongShort("*d", "ciphers", .ARG_STRING), new LongShort("*D", "dns-interface", .ARG_STRING), new LongShort("*e", "disable-epsv", .ARG_BOOL), new LongShort("*f", "disallow-username-in-url", .ARG_BOOL), new LongShort("*E", "epsv", .ARG_BOOL/* 'epsv' made like this to make --no-epsv and --epsv to work
	             although --disable-epsv is the documented option */), new LongShort("*F", "dns-servers", .ARG_STRING), new LongShort("*g", "trace", .ARG_FILENAME), new LongShort("*G", "npn", .ARG_BOOL), new LongShort("*h", "trace-ascii", .ARG_FILENAME), new LongShort("*H", "alpn", .ARG_BOOL), new LongShort("*i", "limit-rate", .ARG_STRING), new LongShort("*j", "compressed", .ARG_BOOL), new LongShort("*J", "tr-encoding", .ARG_BOOL), new LongShort("*k", "digest", .ARG_BOOL), new LongShort("*l", "negotiate", .ARG_BOOL), new LongShort("*m", "ntlm", .ARG_BOOL), new LongShort("*M", "ntlm-wb", .ARG_BOOL), new LongShort("*n", "basic", .ARG_BOOL), new LongShort("*o", "anyauth", .ARG_BOOL), new LongShort("*q", "ftp-create-dirs", .ARG_BOOL), new LongShort("*r", "create-dirs", .ARG_BOOL), new LongShort("*s", "max-redirs", .ARG_STRING), new LongShort("*t", "proxy-ntlm", .ARG_BOOL), new LongShort("*u", "crlf", .ARG_BOOL), new LongShort("*v", "stderr", .ARG_FILENAME), new LongShort("*w", "interface", .ARG_STRING), new LongShort("*x", "krb", .ARG_STRING), new LongShort("*x", "krb4", .ARG_STRING), new LongShort("*X", "haproxy-protocol", /* 'krb4' is the previous name */.ARG_BOOL), new LongShort("*y", "max-filesize", .ARG_STRING), new LongShort("*z", "disable-eprt", .ARG_BOOL), new LongShort("*Z", "eprt", .ARG_BOOL/* 'eprt' made like this to make --no-eprt and --eprt to work
	             although --disable-eprt is the documented option */), new LongShort("*~", "xattr", .ARG_BOOL), new LongShort("$a", "ftp-ssl", .ARG_BOOL), new LongShort("$a", "ssl", /* 'ftp-ssl' deprecated name since 7.20.0 */.ARG_BOOL), new LongShort("$b", "ftp-pasv", /* 'ssl' new option name in 7.20.0, previously this was ftp-ssl */.ARG_BOOL), new LongShort("$c", "socks5", .ARG_STRING), new LongShort("$d", "tcp-nodelay", .ARG_BOOL), new LongShort("$e", "proxy-digest", .ARG_BOOL), new LongShort("$f", "proxy-basic", .ARG_BOOL), new LongShort("$g", "retry", .ARG_STRING), new LongShort("$V", "retry-connrefused", .ARG_BOOL), new LongShort("$h", "retry-delay", .ARG_STRING), new LongShort("$i", "retry-max-time", .ARG_STRING), new LongShort("$k", "proxy-negotiate", .ARG_BOOL), new LongShort("$m", "ftp-account", .ARG_STRING), new LongShort("$n", "proxy-anyauth", .ARG_BOOL), new LongShort("$o", "trace-time", .ARG_BOOL), new LongShort("$p", "ignore-content-length", .ARG_BOOL), new LongShort("$q", "ftp-skip-pasv-ip", .ARG_BOOL), new LongShort("$r", "ftp-method", .ARG_STRING), new LongShort("$s", "local-port", .ARG_STRING), new LongShort("$t", "socks4", .ARG_STRING), new LongShort("$T", "socks4a", .ARG_STRING), new LongShort("$u", "ftp-alternative-to-user", .ARG_STRING), new LongShort("$v", "ftp-ssl-reqd", .ARG_BOOL), new LongShort("$v", "ssl-reqd", /* 'ftp-ssl-reqd' deprecated name since 7.20.0 */.ARG_BOOL), new LongShort("$w", "sessionid", /* 'ssl-reqd' new in 7.20.0, previously this was ftp-ssl-reqd */.ARG_BOOL), new LongShort("$x", "ftp-ssl-control", /* 'sessionid' listed as --no-sessionid in the help */.ARG_BOOL), new LongShort("$y", "ftp-ssl-ccc", .ARG_BOOL), new LongShort("$j", "ftp-ssl-ccc-mode", .ARG_STRING), new LongShort("$z", "libcurl", .ARG_STRING), new LongShort("$#", "raw", .ARG_BOOL), new LongShort("$0", "post301", .ARG_BOOL), new LongShort("$1", "keepalive", .ARG_BOOL), new LongShort("$2", "socks5-hostname", /* 'keepalive' listed as --no-keepalive in the help */.ARG_STRING), new LongShort("$3", "keepalive-time", .ARG_STRING), new LongShort("$4", "post302", .ARG_BOOL), new LongShort("$5", "noproxy", .ARG_STRING), new LongShort("$7", "socks5-gssapi-nec", .ARG_BOOL), new LongShort("$8", "proxy1.0", .ARG_STRING), new LongShort("$9", "tftp-blksize", .ARG_STRING), new LongShort("$A", "mail-from", .ARG_STRING), new LongShort("$B", "mail-rcpt", .ARG_STRING), new LongShort("$C", "ftp-pret", .ARG_BOOL), new LongShort("$D", "proto", .ARG_STRING), new LongShort("$E", "proto-redir", .ARG_STRING), new LongShort("$F", "resolve", .ARG_STRING), new LongShort("$G", "delegation", .ARG_STRING), new LongShort("$H", "mail-auth", .ARG_STRING), new LongShort("$I", "post303", .ARG_BOOL), new LongShort("$J", "metalink", .ARG_BOOL), new LongShort("$6", "sasl-authzid", .ARG_STRING), new LongShort("$K", "sasl-ir", .ARG_BOOL), new LongShort("$L", "test-event", .ARG_BOOL), new LongShort("$M", "unix-socket", .ARG_FILENAME), new LongShort("$N", "path-as-is", .ARG_BOOL), new LongShort("$O", "socks5-gssapi-service", .ARG_STRING/* 'socks5-gssapi-service' merged with'proxy-service-name' and
	            deprecated since 7.49.0 */), new LongShort("$O", "proxy-service-name", .ARG_STRING), new LongShort("$P", "service-name", .ARG_STRING), new LongShort("$Q", "proto-default", .ARG_STRING), new LongShort("$R", "expect100-timeout", .ARG_STRING), new LongShort("$S", "tftp-no-options", .ARG_BOOL), new LongShort("$U", "connect-to", .ARG_STRING), new LongShort("$W", "abstract-unix-socket", .ARG_FILENAME), new LongShort("$X", "tls-max", .ARG_STRING), new LongShort("$Y", "suppress-connect-headers", .ARG_BOOL), new LongShort("$Z", "compressed-ssh", .ARG_BOOL), new LongShort("$~", "happy-eyeballs-timeout-ms", .ARG_STRING), new LongShort("0", "http1.0", .ARG_NONE), new LongShort("01", "http1.1", .ARG_NONE), new LongShort("02", "http2", .ARG_NONE), new LongShort("03", "http2-prior-knowledge", .ARG_NONE), new LongShort("04", "http3", .ARG_NONE), new LongShort("09", "http0.9", .ARG_BOOL), new LongShort("1", "tlsv1", .ARG_NONE), new LongShort("10", "tlsv1.0", .ARG_NONE), new LongShort("11", "tlsv1.1", .ARG_NONE), new LongShort("12", "tlsv1.2", .ARG_NONE), new LongShort("13", "tlsv1.3", .ARG_NONE), new LongShort("1A", "tls13-ciphers", .ARG_STRING), new LongShort("1B", "proxy-tls13-ciphers", .ARG_STRING), new LongShort("2", "sslv2", .ARG_NONE), new LongShort("3", "sslv3", .ARG_NONE), new LongShort("4", "ipv4", .ARG_NONE), new LongShort("6", "ipv6", .ARG_NONE), new LongShort("a", "append", .ARG_BOOL), new LongShort("A", "user-agent", .ARG_STRING), new LongShort("b", "cookie", .ARG_STRING), new LongShort("ba", "alt-svc", .ARG_STRING), new LongShort("B", "use-ascii", .ARG_BOOL), new LongShort("c", "cookie-jar", .ARG_STRING), new LongShort("C", "continue-at", .ARG_STRING), new LongShort("d", "data", .ARG_STRING), new LongShort("dr", "data-raw", .ARG_STRING), new LongShort("da", "data-ascii", .ARG_STRING), new LongShort("db", "data-binary", .ARG_STRING), new LongShort("de", "data-urlencode", .ARG_STRING), new LongShort("D", "dump-header", .ARG_FILENAME), new LongShort("e", "referer", .ARG_STRING), new LongShort("E", "cert", .ARG_FILENAME), new LongShort("Ea", "cacert", .ARG_FILENAME), new LongShort("Eb", "cert-type", .ARG_STRING), new LongShort("Ec", "key", .ARG_FILENAME), new LongShort("Ed", "key-type", .ARG_STRING), new LongShort("Ee", "pass", .ARG_STRING), new LongShort("Ef", "engine", .ARG_STRING), new LongShort("Eg", "capath", .ARG_FILENAME), new LongShort("Eh", "pubkey", .ARG_STRING), new LongShort("Ei", "hostpubmd5", .ARG_STRING), new LongShort("Ej", "crlfile", .ARG_FILENAME), new LongShort("Ek", "tlsuser", .ARG_STRING), new LongShort("El", "tlspassword", .ARG_STRING), new LongShort("Em", "tlsauthtype", .ARG_STRING), new LongShort("En", "ssl-allow-beast", .ARG_BOOL), new LongShort("Ep", "pinnedpubkey", /* Eo */.ARG_STRING), new LongShort("EP", "proxy-pinnedpubkey", .ARG_STRING), new LongShort("Eq", "cert-status", .ARG_BOOL), new LongShort("Er", "false-start", .ARG_BOOL), new LongShort("Es", "ssl-no-revoke", .ARG_BOOL), new LongShort("Et", "tcp-fastopen", .ARG_BOOL), new LongShort("Eu", "proxy-tlsuser", .ARG_STRING), new LongShort("Ev", "proxy-tlspassword", .ARG_STRING), new LongShort("Ew", "proxy-tlsauthtype", .ARG_STRING), new LongShort("Ex", "proxy-cert", .ARG_FILENAME), new LongShort("Ey", "proxy-cert-type", .ARG_STRING), new LongShort("Ez", "proxy-key", .ARG_FILENAME), new LongShort("E0", "proxy-key-type", .ARG_STRING), new LongShort("E1", "proxy-pass", .ARG_STRING), new LongShort("E2", "proxy-ciphers", .ARG_STRING), new LongShort("E3", "proxy-crlfile", .ARG_FILENAME), new LongShort("E4", "proxy-ssl-allow-beast", .ARG_BOOL), new LongShort("E5", "login-options", .ARG_STRING), new LongShort("E6", "proxy-cacert", .ARG_FILENAME), new LongShort("E7", "proxy-capath", .ARG_FILENAME), new LongShort("E8", "proxy-insecure", .ARG_BOOL), new LongShort("E9", "proxy-tlsv1", .ARG_NONE), new LongShort("EA", "socks5-basic", .ARG_BOOL), new LongShort("EB", "socks5-gssapi", .ARG_BOOL), new LongShort("f", "fail", .ARG_BOOL), new LongShort("fa", "fail-early", .ARG_BOOL), new LongShort("fb", "styled-output", .ARG_BOOL), new LongShort("F", "form", .ARG_STRING), new LongShort("Fs", "form-string", .ARG_STRING), new LongShort("g", "globoff", .ARG_BOOL), new LongShort("G", "get", .ARG_NONE), new LongShort("Ga", "request-target", .ARG_STRING), new LongShort("h", "help", .ARG_BOOL), new LongShort("H", "header", .ARG_STRING), new LongShort("Hp", "proxy-header", .ARG_STRING), new LongShort("i", "include", .ARG_BOOL), new LongShort("I", "head", .ARG_BOOL), new LongShort("j", "junk-session-cookies", .ARG_BOOL), new LongShort("J", "remote-header-name", .ARG_BOOL), new LongShort("k", "insecure", .ARG_BOOL), new LongShort("K", "config", .ARG_FILENAME), new LongShort("l", "list-only", .ARG_BOOL), new LongShort("L", "location", .ARG_BOOL), new LongShort("Lt", "location-trusted", .ARG_BOOL), new LongShort("m", "max-time", .ARG_STRING), new LongShort("M", "manual", .ARG_BOOL), new LongShort("n", "netrc", .ARG_BOOL), new LongShort("no", "netrc-optional", .ARG_BOOL), new LongShort("ne", "netrc-file", .ARG_FILENAME), new LongShort("N", "buffer", .ARG_BOOL), new LongShort("o", "output", /* 'buffer' listed as --no-buffer in the help */.ARG_FILENAME), new LongShort("O", "remote-name", .ARG_NONE), new LongShort("Oa", "remote-name-all", .ARG_BOOL), new LongShort("p", "proxytunnel", .ARG_BOOL), new LongShort("P", "ftp-port", .ARG_STRING), new LongShort("q", "disable", .ARG_BOOL), new LongShort("Q", "quote", .ARG_STRING), new LongShort("r", "range", .ARG_STRING), new LongShort("R", "remote-time", .ARG_BOOL), new LongShort("s", "silent", .ARG_BOOL), new LongShort("S", "show-error", .ARG_BOOL), new LongShort("t", "telnet-option", .ARG_STRING), new LongShort("T", "upload-file", .ARG_FILENAME), new LongShort("u", "user", .ARG_STRING), new LongShort("U", "proxy-user", .ARG_STRING), new LongShort("v", "verbose", .ARG_BOOL), new LongShort("V", "version", .ARG_BOOL), new LongShort("w", "write-out", .ARG_STRING), new LongShort("x", "proxy", .ARG_STRING), new LongShort("xa", "preproxy", .ARG_STRING), new LongShort("X", "request", .ARG_STRING), new LongShort("Y", "speed-limit", .ARG_STRING), new LongShort("y", "speed-time", .ARG_STRING), new LongShort("z", "time-cond", .ARG_STRING), new LongShort("Z", "parallel", .ARG_BOOL), new LongShort("Zb", "parallel-max", .ARG_STRING), new LongShort("#", "progress-bar", .ARG_BOOL), new LongShort("#m", "progress-meter", .ARG_BOOL), new LongShort(":", "next", .ARG_NONE/* Split the argument of -E to 'certname' and 'passphrase' separated by colon.
	 * We allow ':' and '\' to be escaped by '\' so that we can use certificate
	 * nicknames containing ':'.  See <https://sourceforge.net/p/curl/bugs/1196/>
	 * for details. */)};
	public static Curl_handler Curl_handler_http = new Curl_handler();
	public static bool Curl_compareheader = new bool();
	public static byte Curl_copy_header_value;
	public static byte Curl_checkProxyheaders;
	public static Curl_send_buffer Curl_send_buffer = new Curl_send_buffer();
	public static Curl_send_buffer Curl_add_buffer_init = new Curl_send_buffer();
	public static Object Curl_add_buffer_free;
	public static CURLcode Curl_add_bufferf = new CURLcode();
	public static CURLcode Curl_add_buffer = new CURLcode();
	public static CURLcode Curl_add_buffer_send = new CURLcode();
	public static CURLcode Curl_add_timecondition = new CURLcode();
	public static CURLcode Curl_add_custom_headers = new CURLcode();
	public static CURLcode Curl_http_compile_trailers = new CURLcode();
	public static CURLcode Curl_http = new CURLcode();
	public static CURLcode Curl_http_done = new CURLcode();
	public static CURLcode Curl_http_connect = new CURLcode();
	public static CURLcode Curl_http_input_auth = new CURLcode();
	public static CURLcode Curl_http_auth_act = new CURLcode();
	public static CURLcode Curl_http_readwrite_headers = new CURLcode();
	public static CURLcode Curl_http_output_auth = new CURLcode();
	public static int curlx_nonblock;
	public static CURLcode Curl_win32_init = new CURLcode();
	public static Object Curl_win32_cleanup;
	public static int IF_NAMETOINDEX_FN;
	public static bool Curl_verify_windows_version = new bool();
	public static HMODULE Curl_load_library = new HMODULE();
	public static CURLcode dict_do = new CURLcode();
	public static Curl_handler Curl_handler_dict = new Curl_handler(/* scheme */"DICT", /* setup_connection */0, /* do_it */dict_do, /* done */0, /* do_more */0, /* connect_it */0, /* connecting */0, /* doing */0, /* proto_getsock */0, /* doing_getsock */0, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */0, /* readwrite */0, /* connection_check */0, /* defport */2628, (1 << /* protocol */9), 0 | (1 << /* flags */6));
	public static tool_mime tool_mime = new tool_mime();
	public static size_t tool_mime_stdin_read = new size_t();
	public static int tool_mime_stdin_seek;
	public static int formparse;
	public static CURLcode tool2curlmime = new CURLcode();
	public static Object tool_mime_free;
	public static Object conn_free;
	public static Object free_idnconverted_hostname;
	public static int get_protocol_family;
	public static Curl_handler Curl_handler_dummy = new Curl_handler(/* scheme */"<no protocol>", /* setup_connection */0, /* do_it */0, /* done */0, /* do_more */0, /* connect_it */0, /* connecting */0, /* doing */0, /* proto_getsock */0, /* doing_getsock */0, /* domore_getsock */0, /* perform_getsock */0, /* disconnect */0, /* readwrite */0, /* connection_check */0, /* defport */0, /* protocol */0, /* flags */0);
	public static Object Curl_sha256it;
	public static CURLcode Curl_ftpsend = new CURLcode();
	public static CURLcode Curl_GetFTPResponse = new CURLcode();
	public static Curl_handler Curl_handler_rtsp = new Curl_handler();
	public static  Curl_rtsp_parseheader = new ();
	public static int stat;
	public static byte getpass_r;
	public static int[] sinus = new int[]{5157, 5313, 5470, 5626, 5782, 5936, 6090, 6243, 6394, 6545, 6693, 6840, /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* use our own printf() functions *//* keep this as LAST include *//* 200 values generated by this perl code:
	
	   my $pi = 3.1415;
	   foreach my $i (1 .. 200) {
	     printf "%d, ", sin($i/200 * 2 * $pi) * 5000 + 5000;
	   }
	*/6985, 7128, 7269, 7408, 7545, 7679, 7810, 7938, 8064, 8187, 8306, 8422, 8535, 8644, 8750, 8852, 8950, 9045, 9135, 9221, 9303, 9381, 9454, 9524, 9588, 9648, 9704, 9755, 9801, 9842, 9879, 9911, 9938, 9960, 9977, 9990, 9997, 9999, 9997, 9990, 9977, 9960, 9938, 9911, 9879, 9842, 9801, 9755, 9704, 9648, 9588, 9524, 9455, 9381, 9303, 9221, 9135, 9045, 8950, 8852, 8750, 8645, 8535, 8422, 8306, 8187, 8064, 7939, 7810, 7679, 7545, 7409, 7270, 7129, 6986, 6841, 6694, 6545, 6395, 6243, 6091, 5937, 5782, 5627, 5470, 5314, 5157, 5000, 4843, 4686, 4529, 4373, 4218, 4063, 3909, 3757, 3605, 3455, 3306, 3159, 3014, 2871, 2730, 2591, 2455, 2321, 2190, 2061, 1935, 1813, 1693, 1577, 1464, 1355, 1249, 1147, 1049, 955, 864, 778, 696, 618, 545, 476, 411, 351, 295, 244, 198, 157, 120, 88, 61, 39, 22, 9, 2, 0, 2, 9, 22, 39, 61, 88, 120, 156, 198, 244, 295, 350, 410, 475, 544, 618, 695, 777, 864, 954, 1048, 1146, 1248, 1354, 1463, 1576, 1692, 1812, 1934, 2060, 2188, 2320, 2454, 2590, 2729, 2870, 3013, 3158, 3305, 3454, 3604, 3755, 3908, 4062, 4216, 4372, 4528, 4685, 4842, 4999};
	public static CURLcode Curl_range = new CURLcode();
	public static CURLMcode singlesocket = new CURLMcode();
	public static CURLMcode add_next_timeout = new CURLMcode();
	public static CURLMcode multi_timeout = new CURLMcode();
	public static Object process_pending_handles;
	public static Object detach_connnection;
	public static Object init_multistate_func;
	public static int Curl_ack_eintr = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* BeOS has FD_SET defined in socket.h *//* delay() *//* bzero() in FD_SET *//* Convenience local macros */0/*
	 * Internal function used for waiting a specific amount of ms
	 * in Curl_socket_check() and Curl_poll() when no file descriptor
	 * is provided to wait on, just being used to delay execution.
	 * WinSock select() and poll() timeout mechanisms need a valid
	 * socket descriptor in a not null file descriptor set to work.
	 * Waiting indefinitely with this function is not allowed, a
	 * zero or negative timeout value will return immediately.
	 * Timeout resolution, accuracy, as well as maximum supported
	 * value is system dependent, neither factor is a citical issue
	 * for the intended use of this function in the library.
	 *
	 * Return values:
	 *   -1 = system call error, invalid timeout value, or interrupted
	 *    0 = specified timeout has elapsed
	 */;
	public static byte Curl_strerror;
	public static CURLcode pop3_regular_transfer = new CURLcode();
	public static CURLcode pop3_do = new CURLcode();
	public static CURLcode pop3_done = new CURLcode();
	public static CURLcode pop3_connect = new CURLcode();
	public static CURLcode pop3_disconnect = new CURLcode();
	public static CURLcode pop3_multi_statemach = new CURLcode();
	public static int pop3_getsock;
	public static CURLcode pop3_doing = new CURLcode();
	public static CURLcode pop3_setup_connection = new CURLcode();
	public static CURLcode pop3_parse_url_options = new CURLcode();
	public static CURLcode pop3_parse_url_path = new CURLcode();
	public static CURLcode pop3_parse_custom_request = new CURLcode();
	public static CURLcode pop3_perform_auth = new CURLcode();
	public static CURLcode pop3_continue_auth = new CURLcode();
	public static Object pop3_get_message;
	public static SASLproto saslpop3 = new SASLproto(/* The service name */"pop", /* Code received when continuation is expected */(byte)'*', /* Code to receive upon authentication success */(byte)'+', 255 - /* Maximum initial response length (no max) */8, /* Send authentication command */pop3_perform_auth, /* Send authentication continuation */pop3_continue_auth, /* Get SASL response message */pop3_get_message/* Change the connection handler *//* Set the connection's upgraded to TLS flag */);
	public static int fwrite_xattr;
	public static HMAC_params[] Curl_HMAC_MD5 = new HMAC_params[]{new HMAC_params((HMAC_hinit_func)(Object)(/* Round 3 *//* Round 4 *//* CRYPTO LIBS *//* Hash initialization function. */MD5_Init), (HMAC_hupdate_func)(Object)(/* Hash update function. */MD5_Update), (HMAC_hfinal_func)(Object)(/* Hash computation end function. */MD5_Final), /* Size of hash context structure. */, /* Maximum key length. */64, /* Result size. */16)};
	public static MD5_params[] Curl_DIGEST_MD5 = new MD5_params[]{new MD5_params((Curl_MD5_init_func)(Object)(/* Digest initialization function */MD5_Init), (Curl_MD5_update_func)(Object)(/* Digest update function */MD5_Update), (Curl_MD5_final_func)(Object)(/* Digest computation end function */MD5_Final), /* Size of digest context struct */, /* Result size */16)};
	public static Object ourWriteOut;
	public static Object set_binmode;
	public static int Curl_strcasecompare;
	public static int Curl_safe_strcasecompare;
	public static int Curl_strncasecompare;
	public static byte Curl_raw_toupper;
	public static byte Curl_raw_tolower;
	public static Object Curl_strntoupper;
	public static Object Curl_strntolower;
	public static getout new_getout = new getout();
	public static  file2string = new ();
	public static  file2memory = new ();
	public static Object cleanarg;
	public static  str2num = new ();
	public static  str2unum = new ();
	public static  str2unummax = new ();
	public static  str2udouble = new ();
	public static long proto2num;
	public static int check_protocol;
	public static  str2offset = new ();
	public static CURLcode get_args = new CURLcode();
	public static  add2list = new ();
	public static int ftpfilemethod;
	public static int ftpcccmethod;
	public static long delegation;
	public static  str2tls_max = new ();
	public static  Curl_setstropt = new ();
	public static  Curl_vsetopt = new ();
	public static CURLcode easysrc_init = new CURLcode();
	public static CURLcode easysrc_add = new CURLcode();
	public static CURLcode easysrc_addf = new CURLcode();
	public static CURLcode easysrc_perform = new CURLcode();
	public static CURLcode easysrc_cleanup = new CURLcode();
	public static Object dumpeasysrc;
	public static Object Curl_memdup;
	public static Object Curl_saferealloc;
	public static CURLcode single_transfer = new CURLcode();
	public static CURLcode create_transfer = new CURLcode();
	public static per_transfer transfersl = new per_transfer();
	public static long all_added;
	public static Object Curl_MD5_init_func;
	public static Object Curl_MD5_update_func;
	public static Object Curl_MD5_final_func;
	public static Object Curl_md5it;
	public static MD5_context Curl_MD5_init = new MD5_context();
	public static  Curl_MD5_update = new ();
	public static  Curl_MD5_final = new ();
	public static Curl_handler Curl_handler_tftp = new Curl_handler();
	public static int Curl_digest_init_func;
	public static Object Curl_digest_update_func;
	public static Object Curl_digest_final_func;
	public static digest_context Curl_digest_init = new digest_context();
	public static int Curl_digest_update;
	public static int Curl_digest_final;
	public static ParameterError getparameter = new ParameterError();
	public static ParameterError parse_args = new ParameterError();
	public static contenc_writer_s contenc_writer = new contenc_writer_s();
	public static content_encoding_s content_encoding = new content_encoding_s();
	public static CURLcode Curl_build_unencoding_stack = new CURLcode();
	public static CURLcode Curl_unencode_write = new CURLcode();
	public static Object Curl_unencode_cleanup;
	public static byte Curl_all_content_encodings;
	public static int http_getsock_do;
	public static int http_should_fail;
	public static CURLcode add_haproxy_protocol_header = new CURLcode();
	public static CURLcode http_setup_conn = new CURLcode();
	public static fileinfo Curl_fileinfo_alloc = new fileinfo();
	public static Object Curl_fileinfo_cleanup;
	public static int _CRT_glob = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* use our own printf() functions *//*
	 * This is low-level hard-hacking memory leak tracking and similar. Using
	 * the library level code from this client-side is ugly, but we do this
	 * anyway for convenience.
	 *//* keep this as LAST include *//*
	 * vms_show is a global variable, used in main() as parameter for
	 * function vms_special_exit() to allow proper curl tool exiting.
	 * Its value may be set in other tool_*.c source files thanks to
	 * forward declaration present in tool_vms.h
	 *//*
	 * There seems to be no way to escape "*" in command-line arguments with MinGW
	 * when command-line argument globbing is enabled under the MSYS shell, so turn
	 * it off.
	 */0/* __MINGW32__ *//* if we build a static library for unit tests, there is no main() function *//*
	 * Ensure that file descriptors 0, 1 and 2 (stdin, stdout, stderr) are
	 * open before starting to run.  Otherwise, the first three network
	 * sockets opened by curl could be used for input sources, downloaded data
	 * or error logs as they will effectively be stdin, stdout and/or stderr.
	 *//*
	 * Ensure that file descriptors 0, 1 and 2 (stdin, stdout, stderr) are
	 * open before starting to run.  Otherwise, the first three network
	 * sockets opened by curl could be used for input sources, downloaded data
	 * or error logs as they will effectively be stdin, stdout and/or stderr.
	 */;
	public static size_t hash_function = new size_t();
	public static size_t comp_function = new size_t();
	public static Object curl_hash_dtor;
	public static int Curl_hash_init;
	public static Object Curl_hash_add;
	public static int Curl_hash_delete;
	public static Object Curl_hash_pick;
	public static Object Curl_hash_apply;
	public static Object Curl_hash_destroy;
	public static Object Curl_hash_clean;
	public static Object Curl_hash_clean_with_criterium;
	public static size_t Curl_hash_str = new size_t();
	public static size_t Curl_str_key_compare = new size_t();
	public static Object Curl_hash_start_iterate;
	public static curl_hash_element Curl_hash_next_element = new curl_hash_element();
	public static Object Curl_hash_print;
	public static Object progressbarinit;
	public static int tool_progress_cb;
	public static size_t tool_write_cb = new size_t();
	public static bool tool_create_output_file = new bool();
	public static curl_off_t getfiletime = new curl_off_t();
	public static Object setfiletime;
	public static size_t Curl_ftp_parselist = new size_t();
	public static CURLcode Curl_ftp_parselist_geterror = new CURLcode();
	public static ftp_parselist_data Curl_ftp_parselist_data_alloc = new ftp_parselist_data();
	public static Object Curl_ftp_parselist_data_free;
	public static Object warnf;
	public static Object notef;
	public static Object helpf;
	public static byte Curl_inet_ntop;
	public static CURLcode gopher_do = new CURLcode();
	public static curl_off_t all_dltotal = 0;
	public static curl_off_t all_ultotal = 0;
	public static curl_off_t all_dlalready = 0;
	public static curl_off_t all_ulalready = 0;
	public static curl_off_t all_xfers = /* current total */0;
	public static int speedindex;
	public static bool indexwrapped = new bool();
	public static speedcount[] speedstore = new speedcount();
	public static  Curl_rand = new ();
	public static  Curl_rand_hex = new ();
	public static curl_off_t timediff_t = new curl_off_t();
	public static curltime Curl_now = new curltime();
	public static timediff_t Curl_timediff = new timediff_t();
	public static timediff_t Curl_timediff_us = new timediff_t();
	public static variable[] replacements = new variable[]{new variable("url_effective", .VAR_EFFECTIVE_URL), new variable("http_code", .VAR_HTTP_CODE), new variable("response_code", .VAR_HTTP_CODE), new variable("http_connect", .VAR_HTTP_CODE_PROXY), new variable("time_total", .VAR_TOTAL_TIME), new variable("time_namelookup", .VAR_NAMELOOKUP_TIME), new variable("time_connect", .VAR_CONNECT_TIME), new variable("time_appconnect", .VAR_APPCONNECT_TIME), new variable("time_pretransfer", .VAR_PRETRANSFER_TIME), new variable("time_starttransfer", .VAR_STARTTRANSFER_TIME), new variable("size_header", .VAR_HEADER_SIZE), new variable("size_request", .VAR_REQUEST_SIZE), new variable("size_download", .VAR_SIZE_DOWNLOAD), new variable("size_upload", .VAR_SIZE_UPLOAD), new variable("speed_download", .VAR_SPEED_DOWNLOAD), new variable("speed_upload", .VAR_SPEED_UPLOAD), new variable("content_type", .VAR_CONTENT_TYPE), new variable("num_connects", .VAR_NUM_CONNECTS), new variable("time_redirect", .VAR_REDIRECT_TIME), new variable("num_redirects", .VAR_REDIRECT_COUNT), new variable("ftp_entry_path", .VAR_FTP_ENTRY_PATH), new variable("redirect_url", .VAR_REDIRECT_URL), new variable("ssl_verify_result", .VAR_SSL_VERIFY_RESULT), new variable("proxy_ssl_verify_result", .VAR_PROXY_SSL_VERIFY_RESULT), new variable("filename_effective", .VAR_EFFECTIVE_FILENAME), new variable("remote_ip", .VAR_PRIMARY_IP), new variable("remote_port", .VAR_PRIMARY_PORT), new variable("local_ip", .VAR_LOCAL_IP), new variable("local_port", .VAR_LOCAL_PORT), new variable("http_version", .VAR_HTTP_VERSION), new variable("scheme", .VAR_SCHEME), new variable("stdout", .VAR_STDOUT), new variable("stderr", .VAR_STDERR), new variable(((Object)0), .VAR_NONE)};
	public static CURLofft curlx_strtoofft = new CURLofft();
	public static Object Curl_sasl_cleanup;
	public static int Curl_sasl_decode_mech;
	public static CURLcode Curl_sasl_parse_url_auth_option = new CURLcode();
	public static Object Curl_sasl_init;
	public static  Curl_sasl_can_authenticate = new ();
	public static CURLcode Curl_sasl_start = new CURLcode();
	public static CURLcode Curl_sasl_continue = new CURLcode();
	public static SANITIZEcode truncate_dryrun = new SANITIZEcode();
	public static SANITIZEcode rename_if_reserved_dos_device_name = new SANITIZEcode();
	public static size_t tool_header_cb = new size_t();
	public static int Curl_ipv6_scope;
	public static if2ip_result_t Curl_if2ip = new if2ip_result_t();
	public static int Curl_conncache_init;
	public static Object Curl_conncache_destroy;
	public static connectbundle Curl_conncache_find_bundle = new connectbundle();
	public static Object Curl_conncache_unlock;
	public static  Curl_conncache_size = new ();
	public static  Curl_conncache_bundle_size = new ();
	public static  Curl_conncache_return_conn = new ();
	public static  Curl_conncache_add_conn = new ();
	public static int WARN_UNUSED_RESULT;
	public static Object Curl_conncache_remove_conn;
	public static  Curl_conncache_foreach = new ();
	public static connectdata Curl_conncache_find_first_connection = new connectdata();
	public static connectdata Curl_conncache_extract_bundle = new connectdata();
	public static connectdata Curl_conncache_extract_oldest = new connectdata();
	public static Object Curl_conncache_close_all_connections;
	public static Object Curl_conncache_print;
	public static CURLcode file_do = new CURLcode();
	public static CURLcode file_done = new CURLcode();
	public static CURLcode file_connect = new CURLcode();
	public static CURLcode file_disconnect = new CURLcode();
	public static CURLcode file_setup_connection = new CURLcode();
	public static bool verifyconnect = new bool();
	public static CURLcode singleipconnect = new CURLcode();
	public static byte homedir;
	public static byte tool_basename;
	public static CURLcode Curl_mime_add_header = new CURLcode();
	public static Object Curl_mime_initpart;
	public static Object Curl_mime_cleanpart;
	public static CURLcode Curl_mime_duppart = new CURLcode();
	public static CURLcode Curl_mime_set_subparts = new CURLcode();
	public static CURLcode Curl_mime_prepare_headers = new CURLcode();
	public static curl_off_t Curl_mime_size = new curl_off_t();
	public static size_t Curl_mime_read = new size_t();
	public static CURLcode Curl_mime_rewind = new CURLcode();
	public static byte Curl_mime_contenttype;
	public static Curl_addrinfo Curl_addrinfo = new Curl_addrinfo();
	public static Object Curl_freeaddrinfo;
	public static Curl_addrinfo Curl_he2ai = new Curl_addrinfo();
	public static Curl_addrinfo Curl_ip2addr = new Curl_addrinfo();
	public static Curl_addrinfo Curl_str2addr = new Curl_addrinfo();
	public static content_encoding identity_encoding = new content_encoding("identity", "none", identity_init_writer, identity_unencode_write, identity_close_writer, 0);
	public static content_encoding[] encodings = new content_encoding[]{/* supported content encodings table. */identity_encoding, ((Object)0)};
	public static content_encoding client_encoding = new content_encoding(((Object)0), ((Object)0), client_init_writer, client_unencode_write, client_close_writer, 0);
	public static content_encoding error_encoding = new content_encoding(((Object)0), ((Object)0), error_init_writer, error_unencode_write, error_close_writer, 0);
	public static int Curl_inet_pton;
	public static bool tool_setopt_skip = new bool();
	public static CURLcode tool_setopt_enum = new CURLcode();
	public static CURLcode tool_setopt_flags = new CURLcode();
	public static CURLcode tool_setopt_bitmask = new CURLcode();
	public static CURLcode tool_setopt_mimepost = new CURLcode();
	public static CURLcode tool_setopt_slist = new CURLcode();
	public static CURLcode tool_setopt = new CURLcode();
	public static Object HMAC_hinit_func;
	public static Object HMAC_hupdate_func;
	public static Object HMAC_hfinal_func;
	public static HMAC_context Curl_HMAC_init = new HMAC_context();
	public static int Curl_HMAC_update;
	public static int Curl_HMAC_final;
	public static Object hugehelp;
	public static Object curl_wildcard_dtor;
	public static CURLcode Curl_wildcard_init = new CURLcode();
	public static Object Curl_wildcard_dtor;
	public static int parsedate;
	public static byte[] Curl_wkday = new byte[]{"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", /* These names are also used by FTP and FILE code */"Sun"};
	public static byte[] Curl_month = new byte[]{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
	public static byte[] weekday = new byte[]{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
	public static tzinfo[] tz = new tzinfo[]{new tzinfo("GMT", /* Greenwich Mean */0), new tzinfo("UT", /* Universal Time */0), new tzinfo("UTC", /* Universal (Coordinated) */0), new tzinfo("WET", /* Western European */0), new tzinfo("BST", 0 - /* British Summer */60), new tzinfo("WAT", /* West Africa */60), new tzinfo("AST", /* Atlantic Standard */240), new tzinfo("ADT", 240 - /* Atlantic Daylight */60), new tzinfo("EST", /* Eastern Standard */300), new tzinfo("EDT", 300 - /* Eastern Daylight */60), new tzinfo("CST", /* Central Standard */360), new tzinfo("CDT", 360 - /* Central Daylight */60), new tzinfo("MST", /* Mountain Standard */420), new tzinfo("MDT", 420 - /* Mountain Daylight */60), new tzinfo("PST", /* Pacific Standard */480), new tzinfo("PDT", 480 - /* Pacific Daylight */60), new tzinfo("YST", /* Yukon Standard */540), new tzinfo("YDT", 540 - /* Yukon Daylight */60), new tzinfo("HST", /* Hawaii Standard */600), new tzinfo("HDT", 600 - /* Hawaii Daylight */60), new tzinfo("CAT", /* Central Alaska */600), new tzinfo("AHST", /* Alaska-Hawaii Standard */600), new tzinfo("NT", /* Nome */660), new tzinfo("IDLW", /* International Date Line West */720), new tzinfo("CET", -/* Central European */60), new tzinfo("MET", -/* Middle European */60), new tzinfo("MEWT", -/* Middle European Winter */60), new tzinfo("MEST", -60 - /* Middle European Summer */60), new tzinfo("CEST", -60 - /* Central European Summer */60), new tzinfo("MESZ", -60 - /* Middle European Summer */60), new tzinfo("FWT", -/* French Winter */60), new tzinfo("FST", -60 - /* French Summer */60), new tzinfo("EET", -/* Eastern Europe, USSR Zone 1 */120), new tzinfo("WAST", -/* West Australian Standard */420), new tzinfo("WADT", -420 - /* West Australian Daylight */60), new tzinfo("CCT", -/* China Coast, USSR Zone 7 */480), new tzinfo("JST", -/* Japan Standard, USSR Zone 8 */540), new tzinfo("EAST", -/* Eastern Australian Standard */600), new tzinfo("EADT", -600 - /* Eastern Australian Daylight */60), new tzinfo("GST", -/* Guam Standard, USSR Zone 9 */600), new tzinfo("NZT", -/* New Zealand */720), new tzinfo("NZST", -/* New Zealand Standard */720), new tzinfo("NZDT", -720 - /* New Zealand Daylight */60), new tzinfo("IDLE", -/* International Date Line East */720/* Next up: Military timezone names. RFC822 allowed these, but (as noted in
	     RFC 1123) had their signs wrong. Here we use the correct signs to match
	     actual military usage.
	   */), new tzinfo("A", 1 * /* Alpha */60), new tzinfo("B", 2 * /* Bravo */60), new tzinfo("C", 3 * /* Charlie */60), new tzinfo("D", 4 * /* Delta */60), new tzinfo("E", 5 * /* Echo */60), new tzinfo("F", 6 * /* Foxtrot */60), new tzinfo("G", 7 * /* Golf */60), new tzinfo("H", 8 * /* Hotel */60), new tzinfo("I", 9 * /* India */60/* "J", Juliet is not used as a timezone, to indicate the observer's local
	     time */), new tzinfo("K", 10 * /* Kilo */60), new tzinfo("L", 11 * /* Lima */60), new tzinfo("M", 12 * /* Mike */60), new tzinfo("N", -1 * /* November */60), new tzinfo("O", -2 * /* Oscar */60), new tzinfo("P", -3 * /* Papa */60), new tzinfo("Q", -4 * /* Quebec */60), new tzinfo("R", -5 * /* Romeo */60), new tzinfo("S", -6 * /* Sierra */60), new tzinfo("T", -7 * /* Tango */60), new tzinfo("U", -8 * /* Uniform */60), new tzinfo("V", -9 * /* Victor */60), new tzinfo("W", -10 * /* Whiskey */60), new tzinfo("X", -11 * /* X-ray */60), new tzinfo("Y", -12 * /* Yankee */60), new tzinfo("Z", /* Zulu, zero meridian, a.k.a. UTC */0/* returns:
	   -1 no day
	   0 monday - 6 sunday
	*/)};
	public static Object freednsentry;
	public static CURLcode Curl_shuffle_addr = new CURLcode();
	public static curl_version_info_data curlinfo = ((Object)/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* use our own printf() functions *//* keep this as LAST include *//* global variable definitions, for libcurl run-time info */0);
	public static long built_in_protos = 0/*
	 * libcurl_info_init: retrieves run-time information about libcurl,
	 * setting a global pointer 'curlinfo' to libcurl's run-time info
	 * struct, and a global bit pattern 'built_in_protos' composed of
	 * CURLPROTO_* bits indicating which protocols are actually built
	 * into library being used.
	 */;
	public static ssize_t Curl_send = new ssize_t();
	public static ssize_t Curl_recv = new ssize_t();
	public static int bit;
	public static CURLcode Curl_do_more_func = new CURLcode();
	public static CURLcode Curl_done_func = new CURLcode();
	public static int multidone_func;
	public static int curlx_ultous;
	public static byte curlx_ultouc;
	public static int curlx_ultosi;
	public static int curlx_uztosi;
	public static  curlx_uztoso = new ();
	public static long curlx_uztoul;
	public static int curlx_uztoui;
	public static int curlx_sltosi;
	public static int curlx_sltoui;
	public static int curlx_sltous;
	public static  curlx_uztosz = new ();
	public static  curlx_sotouz = new ();
	public static int curlx_sztosi;
	public static int curlx_uitous;
	public static  curlx_sitouz = new ();
	public static  curlx_read = new ();
	public static  curlx_write = new ();
	public static curl_slist Curl_slist_duplicate = new curl_slist();
	public static curl_slist Curl_slist_append_nodup = new curl_slist();
	public static byte hmac_ipad = /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 * RFC2104 Keyed-Hashing for Message Authentication
	 *
	 ***************************************************************************//* The last #include file should be: *//*
	 * Generic HMAC algorithm.
	 *
	 *   This module computes HMAC digests based on any hash function. Parameters
	 * and computing procedures are set-up dynamically at HMAC computation
	 * context initialisation.
	 */-1024;
	public static byte hmac_opad = -1024;
	public static Object clean_getout;
	public static bool output_expected = new bool();
	public static bool stdin_upload = new bool();
	public static byte add_file_name_to_url;
	public static CURLcode get_url_file_name = new CURLcode();
	public static int tool_ftruncate64;
	public static int tool_seek_cb;
	public static int xferinfo_cb;
	public static bool progress_meter = new bool();
	public static Object progress_finalize;
	public static Object Curl_md4it;
	public static bool Curl_is_absolute_url = new bool();
	public static int Curl_read16_le;
	public static int Curl_read32_le;
	public static int Curl_read16_be;
	public static slist_wc slist_wc_append = new slist_wc();
	public static Object slist_wc_free_all;
	public static CURLcode Curl_getworkingpath = new CURLcode();
	public static CURLcode Curl_get_pathname = new CURLcode();
	public static byte parse_filename;
	public static byte Curl_dedotdotify;
	public static int tool_debug_cb;
	public static int Curl_fnmatch;
	public static CURLcode tftp_rx = new CURLcode();
	public static CURLcode tftp_tx = new CURLcode();
	public static CURLcode tftp_connect = new CURLcode();
	public static CURLcode tftp_disconnect = new CURLcode();
	public static CURLcode tftp_do = new CURLcode();
	public static CURLcode tftp_done = new CURLcode();
	public static CURLcode tftp_setup_connection = new CURLcode();
	public static CURLcode tftp_multi_statemach = new CURLcode();
	public static CURLcode tftp_doing = new CURLcode();
	public static int tftp_getsock;
	public static CURLcode tftp_translate_code = new CURLcode();
	public static CURLcode Curl_is_connected = new CURLcode();
	public static CURLcode Curl_connecthost = new CURLcode();
	public static timediff_t Curl_timeleft = new timediff_t();
	public static curl_socket_t Curl_getconnectinfo = new curl_socket_t();
	public static bool Curl_addr2string = new bool();
	public static bool Curl_connalive = new bool();
	public static Object Curl_sndbufset;
	public static Object Curl_updateconninfo;
	public static Object Curl_persistconninfo;
	public static int Curl_closesocket;
	public static CURLcode Curl_socket = new CURLcode();
	public static Object Curl_conncontrol;
	public static bool Curl_conn_data_pending = new bool();
	public static CURLcode Curl_proxyCONNECT = new CURLcode();
	public static CURLcode Curl_proxy_connect = new CURLcode();
	public static bool Curl_connect_complete = new bool();
	public static bool Curl_connect_ongoing = new bool();
	public static Object Curl_connect_free;
	public static CURLcode get_libcurl_info = new CURLcode();
	public static Object Curl_des_set_odd_parity;
	public static CURLcode create_dir_hierarchy = new CURLcode();
	public static int initialized;
	public static long init_flags;
	public static CURLcode Curl_pp_statemach = new CURLcode();
	public static Object Curl_pp_init;
	public static time_t Curl_pp_state_timeout = new time_t();
	public static CURLcode Curl_pp_sendf = new CURLcode();
	public static CURLcode Curl_pp_vsendf = new CURLcode();
	public static CURLcode Curl_pp_readresp = new CURLcode();
	public static CURLcode Curl_pp_flushsend = new CURLcode();
	public static CURLcode Curl_pp_disconnect = new CURLcode();
	public static int Curl_pp_getsock;
	public static bool Curl_pp_moredata = new bool();
	public static CURLcode glob_url = new CURLcode();
	public static CURLcode glob_next_url = new CURLcode();
	public static CURLcode glob_match_url = new CURLcode();
	public static Object glob_cleanup;
	public static  Curl_isunreserved = new ();
	public static  Curl_urldecode = new ();
	public static byte[] telnetoptions = new byte[]{"BINARY", "ECHO", "RCP", /***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//*
	 * Telnet option defines. Add more here if in need.
	 *//*
	 * Telnet option defines. Add more here if in need.
	 *//* binary 8bit data *//* just echo! *//* Suppress Go Ahead *//* EXtended OPtions List *//* Terminal TYPE *//* Negotiate About Window Size *//* X DISPlay LOCation *//* NEW ENVIRONment variables *//*
	 * The telnet options represented as strings
	 *//*
	 * The telnet options represented as strings
	 */"SUPPRESS GO AHEAD", "NAME", "STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP", "NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS", "NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO", "DE TERMINAL", "SUPDUP", "SUPDUP OUTPUT", "SEND LOCATION", "TERM TYPE", "END OF RECORD", "TACACS UID", "OUTPUT MARKING", "TTYLOC", "3270 REGIME", "X3 PAD", "NAWS", "TERM SPEED", "LFLOW", "LINEMODE", "XDISPLOC", "OLD-ENVIRON", "AUTHENTICATION", "ENCRYPT", "NEW-ENVIRON"/*
	 * First some defines
	 *//* End Of File *//* Sub negotiation End */};
	public static byte[] telnetcmds = new byte[]{"EOF", "SUSP", "ABORT", "EOR", /* No OPeration *//* Data Mark *//* Go Ahead, reverse the line *//* SuBnegotiation *//* Our side WILL use this option *//* Our side WON'T use this option *//* DO use this option! *//* DON'T use this option! *//* Interpret As Command *//*
	 * Then those numbers represented as strings:
	 *//*
	 * Then those numbers represented as strings:
	 */"SE", "NOP", "DMARK", "BRK", "IP", "AO", "AYT", "EC", "EL", "GA", "SB", "WILL", "WONT", "DO", "DONT", "IAC"/* the first one *//* surprise, 255 is the last one! ;-) *//* CURL_DISABLE_TELNET *//* HEADER_CURL_ARPA_TELNET_H */};
	public static byte Curl_chunked_strerror;
	public static Object Curl_httpchunk_init;
	public static CHUNKcode Curl_httpchunk_read = new CHUNKcode();
	public static size_t encoder_nop_read = new size_t();
	public static curl_off_t encoder_nop_size = new curl_off_t();
	public static size_t encoder_7bit_read = new size_t();
	public static size_t encoder_base64_read = new size_t();
	public static curl_off_t encoder_base64_size = new curl_off_t();
	public static size_t encoder_qp_read = new size_t();
	public static curl_off_t encoder_qp_size = new curl_off_t();
	public static mime_encoder[] encoders = new mime_encoder[]{new mime_encoder("binary", encoder_nop_read, encoder_nop_size), new mime_encoder("8bit", encoder_nop_read, encoder_nop_size), new mime_encoder("7bit", encoder_7bit_read, encoder_nop_size), new mime_encoder("base64", encoder_base64_read, encoder_base64_size), new mime_encoder("quoted-printable", encoder_qp_read, encoder_qp_size), new mime_encoder(0, 0, 0)};
	public static byte[] qp_class = new byte[]{0, 0, 0, 0, 0, 0, 0, /* Can be represented by itself. *//* Space or tab. *//* Carriage return. *//* Line-feed. *//* 00 - 07 */0, 0, 2, 4, 0, 0, 3, 0, /* 08 - 0F */0, 0, 0, 0, 0, 0, 0, 0, /* 10 - 17 */0, 0, 0, 0, 0, 0, 0, 0, /* 18 - 1F */0, 2, 1, 1, 1, 1, 1, 1, /* 20 - 27 */1, 1, 1, 1, 1, 1, 1, 1, /* 28 - 2F */1, 1, 1, 1, 1, 1, 1, 1, /* 30 - 37 */1, 1, 1, 1, 1, 1, 0, 1, /* 38 - 3F */1, 1, 1, 1, 1, 1, 1, 1, /* 40 - 47 */1, 1, 1, 1, 1, 1, 1, 1, /* 48 - 4F */1, 1, 1, 1, 1, 1, 1, 1, /* 50 - 57 */1, 1, 1, 1, 1, 1, 1, 1, /* 58 - 5F */1, 1, 1, 1, 1, 1, 1, 1, /* 60 - 67 */1, 1, 1, 1, 1, 1, 1, 1, /* 68 - 6F */1, 1, 1, 1, 1, 1, 1, 1, /* 70 - 77 */1, 1, 1, 1, 1, 1, 1, 1, /* 78 - 7F */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 80 - 8F */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 90 - 9F */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* A0 - AF */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* B0 - BF */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* C0 - CF */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* D0 - DF */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* E0 - EF */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* F0 - FF */0};
	public static byte[] aschex = /* Binary --> hexadecimal ASCII table. */"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45\x46"/*
	 * get_vms_file_size does what it takes to get the real size of the file
	 *
	 * For fixed files, find out the size of the EOF block and adjust.
	 *
	 * For all others, have to read the entire file in, discarding the contents.
	 * Most posted text files will be small, and binary files like zlib archives
	 * and CD/DVD images should be either a STREAM_LF format or a fixed format.
	 *
	 *//* VMS *//*
	 *
	 *  VmsSpecialSize checks to see if the stat st_size can be trusted and
	 *  if not to call a routine to get the correct size.
	 *
	 */;
	public static HANDLE Curl_thread_create = new HANDLE();
	public static Object Curl_thread_destroy;
	public static int Curl_thread_join;
	public static  Missing_definition_of_macro_sread = new ();
	public static  Missing_definition_of_macro_swrite = new ();
	public static Object dump;
	public static int Curl_socket_check;
	public static int Curl_poll;
	public static int Curl_wait_ms;
	public static CURLcode rtsp_do = new CURLcode();
	public static CURLcode rtsp_done = new CURLcode();
	public static CURLcode rtsp_connect = new CURLcode();
	public static CURLcode rtsp_disconnect = new CURLcode();
	public static int rtsp_getsock_do;
	public static CURLcode rtsp_rtp_readwrite = new CURLcode();
	public static CURLcode rtsp_setup_connection = new CURLcode();
	public static int rtsp_conncheck;
	public static CURLcode rtp_client_write = new CURLcode();
	public static CURLcode imap_regular_transfer = new CURLcode();
	public static CURLcode imap_do = new CURLcode();
	public static CURLcode imap_done = new CURLcode();
	public static CURLcode imap_connect = new CURLcode();
	public static CURLcode imap_disconnect = new CURLcode();
	public static CURLcode imap_multi_statemach = new CURLcode();
	public static int imap_getsock;
	public static CURLcode imap_doing = new CURLcode();
	public static CURLcode imap_setup_connection = new CURLcode();
	public static byte imap_atom;
	public static CURLcode imap_sendf = new CURLcode();
	public static CURLcode imap_parse_url_options = new CURLcode();
	public static CURLcode imap_parse_url_path = new CURLcode();
	public static CURLcode imap_parse_custom_request = new CURLcode();
	public static CURLcode imap_perform_authenticate = new CURLcode();
	public static CURLcode imap_continue_authenticate = new CURLcode();
	public static Object imap_get_message;
	public static SASLproto saslimap = new SASLproto(/* The service name */"imap", /* Code received when continuation is expected */(byte)'+', /* Code to receive upon authentication success */1, /* Maximum initial response length (no max) */0, /* Send authentication command */imap_perform_authenticate, /* Send authentication continuation */imap_continue_authenticate, /* Get SASL response message */imap_get_message/* Change the connection handler *//* Set the connection's upgraded to TLS flag */);
	public static HANDLE WSOCK2_EVENT = new HANDLE();
	public static FARPROC WSOCK2_FUNC = new FARPROC();
	public static CURLcode check_wsock2 = new CURLcode();
	public static CURLcode telrcv = new CURLcode();
	public static Object printoption;
	public static Object negotiate;
	public static Object send_negotiation;
	public static Object set_local_option;
	public static Object set_remote_option;
	public static Object printsub;
	public static Object suboption;
	public static Object sendsuboption;
	public static CURLcode telnet_do = new CURLcode();
	public static CURLcode telnet_done = new CURLcode();
	public static CURLcode send_telnet_data = new CURLcode();
	public static  Curl_base64_encode = new ();
	public static  Curl_base64url_encode = new ();
	public static  Curl_base64_decode = new ();
	public static int Curl_blockread_all;
	public static CURLcode Curl_SOCKS4 = new CURLcode();
	public static CURLcode Curl_SOCKS5 = new CURLcode();
	public static Curl_addrinfo Curl_doh = new Curl_addrinfo();
	public static CURLcode Curl_doh_is_resolved = new CURLcode();
	public static int Curl_doh_getsock;
	public static byte[] errors = new byte[]{/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2018 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************//* The last 3 #include files should be in this order *//* bytes */"", "Bad label", "Out of range", "Label loop", "Too small", "Out of memory", "RDATA length", "Malformat", "Bad RCODE", "Unexpected TYPE", "Unexpected CLASS", "No content", "Bad ID"};
	public static size_t tool_read_cb = new size_t();
	public static Curl_tree Curl_splay = new Curl_tree();
	public static Curl_tree Curl_splayinsert = new Curl_tree();
	public static Curl_tree Curl_splaygetbest = new Curl_tree();
	public static int Curl_splayremovebyaddr;
	public static  Curl_gmtime = new ();
	
	
	/* We can not translate it, so return the original string */
	/* VMS translate path is actually not needed on the current 64 bit */
	/* VMS platforms, so instead of figuring out the pointer settings */
	/* Change it to a noop */
	public static Object vms_getenv(Object envvar) {
		byte result;
		byte vms_path;
		result = .decc$getenv(/* first use the DECC getenv() function */envvar);
		if (result == ((Object)0)) {
			return result;
		} 
		vms_path = result;
		result = .vms_translate_path(vms_path/* note that if you backport this to use VAX C RTL, that the VAX C RTL *//* may do a malloc(2048) for each call to getenv(), so you will need   */);
		return /* to add a free(vms_path) *//* Do not do a free() for DEC C RTL builds, which should be used for *//* VMS 5.5-2 and later, even if using GCC */result;
	}
	public static Object vms_getpwuid(Object uid) {
		passwd my_passwd = new passwd();
		/* Hack needed to support 64 bit builds, decc_getpwnam is 32 bit only */
		byte unix_path;
		my_passwd = .decc$getpwuid(uid);
		if (my_passwd == ((Object)0)) {
			return my_passwd;
		} 
		unix_path = .vms_translate_path(my_passwd.getPasswd());
		if ((long)unix_path <= 0) {
			return /* We can not translate it, so return the original string */my_passwd;
		} 
		if (unix_path == my_passwd.getPasswd()) {
			return my_passwd;
		} 
		ModernizedCProgram.vms_passwd_cache.setPasswd(my_passwd.getPasswd());
		ModernizedCProgram.vms_passwd_cache.setPasswd(my_passwd.getPasswd());
		ModernizedCProgram.vms_passwd_cache.setPasswd(my_passwd.getPasswd());
		ModernizedCProgram.vms_passwd_cache.setPasswd(unix_path);
		ModernizedCProgram.vms_passwd_cache.setPasswd(my_passwd.getPasswd());
		return ModernizedCProgram.vms_passwd_cache/* Bug - VMS OpenSSL and Kerberos universal symbols are in uppercase only *//* VMS libraries should have universal symbols in exact and uppercase *//* Ancient OpenSSL on VAX/VMS missing this constant *//* AI_NUMERICHOST needed for IP V6 support in Curl *//* VAX symbols are always in uppercase *//* Older VAX OpenSSL port defines these as Macros *//* Need to include the headers first and then redefine *//* that way a newer port will also work if some one has one *//* Curl defines these to lower case and VAX needs them in upper case *//* So we need static routines *//* Need this to stop a macro redefinition error *//* HEADER_CURL_SETUP_VMS_H */;
	}
	public static Object new_getout(Object config) {
		getout node = .calloc(1, );
		getout last = config.getUrl_last();
		if (node) {
			if (/* append this new node last in the list */last) {
				last.setNext(node);
			} else {
					config.setUrl_list(/* first node */node);
			} 
			config.setUrl_last(/* move the last pointer */node);
			node.setFlags(config.getDefault_node_flags());
		} 
		return node;
	}
	public static  file2string(Object bufp, Object file) {
		byte string = ((Object)0);
		if (file) {
			byte ptr;
			size_t alloc = 512;
			size_t alloc_needed = new size_t();
			byte[] buffer = new byte[256];
			size_t stringlen = 0;
			string = .malloc(alloc);
			if (!string) {
				return .PARAM_NO_MEM;
			} 
			while (.fgets(buffer, , file)) {
				size_t buflen = new size_t();
				ptr = .strchr(buffer, (byte)'\r');
				if (ptr) {
					ptr = (byte)'\0';
				} 
				ptr = .strchr(buffer, (byte)'\n');
				if (ptr) {
					ptr = (byte)'\0';
				} 
				buflen = .strlen(buffer);
				alloc_needed = stringlen + buflen + 1;
				if (alloc < alloc_needed) {
					if (alloc >= (size_t)-1024 / 2) {
						do {
							.free((string));
							(string) = ((Object)0);
						} while (0);
						return .PARAM_NO_MEM;
					} 
					alloc *= /* doubling is enough since the string to add is always max 256 bytes
					           and the alloc size start at 512 */2;
					ptr = .realloc(string, alloc);
					if (!ptr) {
						do {
							.free((string));
							(string) = ((Object)0);
						} while (0);
						return .PARAM_NO_MEM;
					} 
					string = ptr;
				} 
				.strcpy(string + stringlen, buffer);
				stringlen += buflen;
			}
		} 
		bufp = string;
		return .PARAM_OK;
	}
	public static  file2memory(Object bufp, Object size, Object file) {
		byte newbuf;
		byte buffer = ((Object)0);
		size_t nused = 0;
		if (file) {
			size_t nread = new size_t();
			size_t alloc = 512;
			do {
				if (!buffer || (alloc == nused)) {
					if (alloc + 1 > ((size_t)-1) / /* size_t overflow detection for huge files */2) {
						do {
							.free((buffer));
							(buffer) = ((Object)0);
						} while (0);
						return .PARAM_NO_MEM;
					} 
					alloc *= 2;
					newbuf = .realloc(buffer, alloc + /* allocate an extra char, reserved space, for null termination */1);
					if (!newbuf) {
						do {
							.free((buffer));
							(buffer) = ((Object)0);
						} while (0);
						return .PARAM_NO_MEM;
					} 
					buffer = newbuf;
				} 
				nread = .fread(buffer + nused, 1, alloc - nused, file);
				nused += nread;
			} while (nread);
			buffer[nused] = /* null terminate the buffer in case it's used as a string later */(byte)'\0';
			if (alloc != /* free trailing slack space, if possible */nused) {
				newbuf = .realloc(buffer, nused + 1);
				if (!newbuf) {
					do {
						.free((buffer));
						(buffer) = ((Object)0);
					} while (0);
					return .PARAM_NO_MEM;
				} 
				buffer = newbuf;
			} 
			if (!/* discard buffer if nothing was read */nused) {
				do {
					.free((buffer));
					(buffer) = ((Object)0);
				} while (/* no string */0);
			} 
		} 
		size = nused;
		bufp = buffer;
		return .PARAM_OK;
	}
	public static void cleanarg(Object str) {
		(Object)str/*
		 * Parse the string and write the long in the given address. Return PARAM_OK
		 * on success, otherwise a parameter specific error enum.
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	/* now that GetStr has copied the contents of nextarg, wipe the next
	   * argument out so that the username:password isn't displayed in the
	   * system process list */
	public static  str2num(Object val, Object str) {
		if (str) {
			byte endptr;
			long num;
			(._errno()) = 0;
			num = .strtol(str, endptr, 10);
			if ((._errno()) == 34) {
				return .PARAM_NUMBER_TOO_LARGE;
			} 
			if ((endptr != str) && (endptr == str + .strlen(str))) {
				val = num;
				return /* Ok */.PARAM_OK;
			} 
		} 
		return /* badness */.PARAM_BAD_NUMERIC/*
		 * Parse the string and write the long in the given address. Return PARAM_OK
		 * on success, otherwise a parameter error enum. ONLY ACCEPTS POSITIVE NUMBERS!
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	public static  str2unum(Object val, Object str) {
		ParameterError result = ModernizedCProgram.str2num(val, str);
		if (result != .PARAM_OK) {
			return result;
		} 
		if (val < 0) {
			return .PARAM_NEGATIVE_NUMERIC;
		} 
		return .PARAM_OK/*
		 * Parse the string and write the long in the given address if it is below the
		 * maximum allowed value. Return PARAM_OK on success, otherwise a parameter
		 * error enum. ONLY ACCEPTS POSITIVE NUMBERS!
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	public static  str2unummax(Object val, Object str, long max) {
		ParameterError result = ModernizedCProgram.str2unum(val, str);
		if (result != .PARAM_OK) {
			return result;
		} 
		if (val > max) {
			return .PARAM_NUMBER_TOO_LARGE;
		} 
		return .PARAM_OK/*
		 * Parse the string and write the double in the given address. Return PARAM_OK
		 * on success, otherwise a parameter specific error enum.
		 *
		 * The 'max' argument is the maximum value allowed, as the numbers are often
		 * multiplied when later used.
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	public static  str2double(Object val, Object str, long max) {
		if (str) {
			byte endptr;
			double num;
			(._errno()) = 0;
			num = .strtod(str, endptr);
			if ((._errno()) == 34) {
				return .PARAM_NUMBER_TOO_LARGE;
			} 
			if (num > max) {
				return /* too large */.PARAM_NUMBER_TOO_LARGE;
			} 
			if ((endptr != str) && (endptr == str + .strlen(str))) {
				val = num;
				return /* Ok */.PARAM_OK;
			} 
		} 
		return /* badness */.PARAM_BAD_NUMERIC/*
		 * Parse the string and write the double in the given address. Return PARAM_OK
		 * on success, otherwise a parameter error enum. ONLY ACCEPTS POSITIVE NUMBERS!
		 *
		 * The 'max' argument is the maximum value allowed, as the numbers are often
		 * multiplied when later used.
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	public static  str2udouble(Object valp, Object str, long max) {
		double value;
		ParameterError result = ModernizedCProgram.str2double(value, str, max);
		if (result != .PARAM_OK) {
			return result;
		} 
		if (value < 0) {
			return .PARAM_NEGATIVE_NUMERIC;
		} 
		valp = value;
		return .PARAM_OK/*
		 * Parse the string and modify the long in the given address. Return
		 * non-zero on failure, zero on success.
		 *
		 * The string is a list of protocols
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	public static long proto2num(Object config, Object val, Object str) {
		byte buffer;
		byte sep = ",";
		byte token;
		Object[] protos = new Object[]{{"all", (~0)}, {"http", (1 << 0)}, {"https", (1 << 1)}, {"ftp", (1 << 2)}, {"ftps", (1 << 3)}, {"scp", (1 << 4)}, {"sftp", (1 << 5)}, {"telnet", (1 << 6)}, {"ldap", (1 << 7)}, {"ldaps", (1 << 8)}, {"dict", (1 << 9)}, {"file", (1 << 10)}, {"tftp", (1 << 11)}, {"imap", (1 << 12)}, {"imaps", (1 << 13)}, {"pop3", (1 << 14)}, {"pop3s", (1 << 15)}, {"smtp", (1 << 16)}, {"smtps", (1 << 17)}, {"rtsp", (1 << 18)}, {"gopher", (1 << 25)}, {"smb", (1 << 26)}, {"smbs", (1 << 27)}, {((Object)0), 0}};
		if (!str) {
			return 1;
		} 
		buffer = .strdup(/* because strtok corrupts it */str);
		if (!buffer) {
			return 1;
		} 
		for (token = .strtok(buffer, /* Allow strtok() here since this isn't used threaded *//* !checksrc! disable BANNEDFUNC 2 */sep); token; token = .strtok(((Object)0), sep)) {
			Object action = e_action.allow;
			sprotos pp = new sprotos();
			while (!(ModernizedCProgram.Curl_isalnum((int)((byte)/* Process token modifiers *//* may be NULL if token is all modifiers */token)))) {
				switch (token++) {
				case (byte)'=':
						e_action.action = e_action.set;
						break;
				case (byte)'+':
						e_action.action = e_action.allow;
						break;
				case (byte)'-':
						e_action.action = e_action.deny;
						break;
				default:
						do {
							.free((buffer));
							(buffer) = ((Object)0);
						} while (0);
						return 1;
				}
			}
			for (pp = protos; pp.getName(); pp++) {
				if (ModernizedCProgram.curl_strequal(token, pp.getName())) {
					switch (e_action.action) {
					case e_action.allow:
							val |=  pp.getBit();
							break;
					case e_action.deny:
							val &=  ~(pp.getBit());
							break;
					case e_action.set:
							val = pp.getBit();
							break;
					}
					break;
				} 
			}
			if (!(pp.getName())) {
				if (e_action.action == e_action.set) {
					val = 0;
				} 
				ModernizedCProgram.warnf(config.getGlobal(), "unrecognized protocol '%s'\n", token);
			} 
		}
		do {
			.free((buffer));
			(buffer) = ((Object)0);
		} while (0);
		return 0/**
		 * Check if the given string is a protocol supported by libcurl
		 *
		 * @param str  the protocol name
		 * @return PARAM_OK  protocol supported
		 * @return PARAM_LIBCURL_UNSUPPORTED_PROTOCOL  protocol not supported
		 * @return PARAM_REQUIRES_PARAMETER   missing parameter
		 */;
	}
	public static int check_protocol(Object str) {
		byte pp;
		curl_version_info_data curlinfo = ModernizedCProgram.curl_version_info(.CURLVERSION_SIXTH);
		if (!str) {
			return .PARAM_REQUIRES_PARAMETER;
		} 
		for (pp = curlinfo.getProtocols(); pp; pp++) {
			if (ModernizedCProgram.curl_strequal(pp, str)) {
				return .PARAM_OK;
			} 
		}
		return .PARAM_LIBCURL_UNSUPPORTED_PROTOCOL/**
		 * Parses the given string looking for an offset (which may be a
		 * larger-than-integer value). The offset CANNOT be negative!
		 *
		 * @param val  the offset to populate
		 * @param str  the buffer containing the offset
		 * @return PARAM_OK if successful, a parameter specific error enum if failure.
		 */;
	}
	public static  str2offset(Object val, Object str) {
		byte endptr;
		if (str[0] == (byte)'-') {
			return /* offsets aren't negative, this indicates weird input */.PARAM_NEGATIVE_NUMERIC;
		} 
		{ 
			CURLofft offt = ModernizedCProgram.curlx_strtoofft(str, endptr, 0, val);
			if (.CURL_OFFT_FLOW == offt) {
				return .PARAM_NUMBER_TOO_LARGE;
			}  else if (.CURL_OFFT_INVAL == offt) {
				return .PARAM_BAD_NUMERIC;
			} 
		}
		if ((endptr != str) && (endptr == str + .strlen(str))) {
			return .PARAM_OK;
		} 
		return .PARAM_BAD_NUMERIC;
	}
	/* for what purpose */
	public static  checkpasswd(Object kind, Object i, Object last, Object userpwd) {
		/* pointer to allocated string */byte psep;
		byte osep;
		if (!userpwd) {
			return .CURLE_OK;
		} 
		psep = .strchr(userpwd, /* Attempt to find the password separator */(byte)':');
		osep = .strchr(userpwd, /* Attempt to find the options separator */(byte)';');
		if (!psep && userpwd != (byte)';') {
			byte[] passwd = /* no password present, prompt for one */"";
			byte[] prompt = new byte[256];
			size_t passwdlen = new size_t();
			size_t userlen = .strlen(userpwd);
			byte passptr;
			if (osep) {
				osep = (byte)'\0';
			} 
			if (!i && /* build a nice-looking prompt */last) {
				ModernizedCProgram.curl_msnprintf(prompt, , "Enter %s password for user '%s':", kind, userpwd);
			} else {
					ModernizedCProgram.curl_msnprintf(prompt, , "Enter %s password for user '%s' on URL #%zu:", kind, userpwd, i + 1);
			} 
			ModernizedCProgram.getpass_r(prompt, passwd, );
			passwdlen = .strlen(passwd);
			if (osep) {
				osep = (byte)';';
			} 
			passptr = .realloc(/* extend the allocated memory area to fit the password too */userpwd, passwdlen + /* an extra for the colon */1 + userlen + /* an extra for the zero */1);
			if (!passptr) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			passptr[userlen] = /* append the password separated with a colon */(byte)':';
			.memcpy(passptr[userlen + 1], passwd, passwdlen + 1);
			userpwd = passptr;
		} 
		return .CURLE_OK;
	}
	/* operation index */
	/* TRUE if last operation */
	public static  add2list(Object list, Object ptr) {
		curl_slist newlist = ModernizedCProgram.curl_slist_append(list, ptr);
		if (newlist) {
			list = newlist;
		} else {
				return .PARAM_NO_MEM;
		} 
		return .PARAM_OK;
	}
	public static int ftpfilemethod(Object config, Object str) {
		if (ModernizedCProgram.curl_strequal("singlecwd", str)) {
			return .CURLFTPMETHOD_SINGLECWD;
		} 
		if (ModernizedCProgram.curl_strequal("nocwd", str)) {
			return .CURLFTPMETHOD_NOCWD;
		} 
		if (ModernizedCProgram.curl_strequal("multicwd", str)) {
			return .CURLFTPMETHOD_MULTICWD;
		} 
		ModernizedCProgram.warnf(config.getGlobal(), "unrecognized ftp file method '%s', using default\n", str);
		return .CURLFTPMETHOD_MULTICWD;
	}
	public static int ftpcccmethod(Object config, Object str) {
		if (ModernizedCProgram.curl_strequal("passive", str)) {
			return .CURLFTPSSL_CCC_PASSIVE;
		} 
		if (ModernizedCProgram.curl_strequal("active", str)) {
			return .CURLFTPSSL_CCC_ACTIVE;
		} 
		ModernizedCProgram.warnf(config.getGlobal(), "unrecognized ftp CCC method '%s', using default\n", str);
		return .CURLFTPSSL_CCC_PASSIVE;
	}
	public static long delegation(Object config, Object str) {
		if (ModernizedCProgram.curl_strequal("none", str)) {
			return 0;
		} 
		if (ModernizedCProgram.curl_strequal("policy", str)) {
			return (1 << 0);
		} 
		if (ModernizedCProgram.curl_strequal("always", str)) {
			return (1 << 1);
		} 
		ModernizedCProgram.warnf(config.getGlobal(), "unrecognized delegation method '%s', using none\n", str);
		return 0/*
		 * my_useragent: returns allocated string with default user agent
		 */;
	}
	public static Object my_useragent() {
		return .strdup("curl/7.67.0-DEV");
	}
	public static  get_args(Object config, Object i) {
		CURLcode result = .CURLE_OK;
		bool last = (config.getNext() ? 0 : 1);
		if (config.getUserpwd() && !config.getOauth_bearer()) {
			result = ModernizedCProgram.checkpasswd("host", i, last, config.getUserpwd());
			if (result) {
				return result;
			} 
		} 
		if (config.getProxyuserpwd()) {
			result = ModernizedCProgram.checkpasswd("proxy", i, last, config.getProxyuserpwd());
			if (result) {
				return result;
			} 
		} 
		if (!config.getUseragent()) {
			config.setUseragent(ModernizedCProgram.my_useragent());
			if (!config.getUseragent()) {
				ModernizedCProgram.helpf(config.getGlobal().getErrors(), "out of memory\n");
				result = .CURLE_OUT_OF_MEMORY;
			} 
		} 
		return result/*
		 * Parse the string and modify ssl_version in the val argument. Return PARAM_OK
		 * on success, otherwise a parameter error enum. ONLY ACCEPTS POSITIVE NUMBERS!
		 *
		 * Since this function gets called with the 'nextarg' pointer from within the
		 * getparameter a lot, we must check it for NULL before accessing the str
		 * data.
		 */;
	}
	public static  str2tls_max(Object val, Object str) {
		Object[] tls_max_array = new Object[]{{"default", .CURL_SSLVERSION_MAX_DEFAULT}, {"1.0", .CURL_SSLVERSION_MAX_TLSv1_0}, {"1.1", .CURL_SSLVERSION_MAX_TLSv1_1}, {"1.2", .CURL_SSLVERSION_MAX_TLSv1_2}, {"1.3", .CURL_SSLVERSION_MAX_TLSv1_3}};
		size_t i = 0;
		if (!str) {
			return .PARAM_REQUIRES_PARAMETER;
		} 
		for (i = 0; i <  / ; i++) {
			if (!.strcmp(str, tls_max_array[i].getTls_max_str())) {
				val = tls_max_array[i].getTls_max();
				return .PARAM_OK;
			} 
		}
		return .PARAM_BAD_USE;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/***************************************************************************
	 *
	 * Curl_memdup(source, length)
	 *
	 * Copies the 'source' data to a newly allocated buffer (that is
	 * returned). Copies 'length' bytes.
	 *
	 * Returns the new pointer or NULL on failure.
	 *
	 ***************************************************************************/
	public static Object Curl_memdup(Object src, Object length) {
		Object buffer = .Curl_cmalloc(length);
		if (!buffer) {
			return ((Object)/* fail */0);
		} 
		.memcpy(buffer, src, length);
		return buffer/***************************************************************************
		 *
		 * Curl_saferealloc(ptr, size)
		 *
		 * Does a normal realloc(), but will free the data pointer if the realloc
		 * fails. If 'size' is non-zero, it will free the data and return a failure.
		 *
		 * This convenience function is provided and used to help us avoid a common
		 * mistake pattern when we could pass in a zero, catch the NULL return and end
		 * up free'ing the memory twice.
		 *
		 * Returns the new pointer or NULL on failure.
		 *
		 ***************************************************************************/;
	}
	public static Object Curl_saferealloc(Object ptr, Object size) {
		Object datap = .Curl_crealloc(ptr, size);
		if (size && !datap) {
			.Curl_cfree(/* only free 'ptr' if size was non-zero */ptr);
		} 
		return datap;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * Curl_gethostname() is a wrapper around gethostname() which allows
	 * overriding the host name that the function would normally return.
	 * This capability is used by the test suite to verify exact matching
	 * of NTLM authentication, which exercises libcurl's MD4 and DES code
	 * as well as by the SMTP module when a hostname is not provided.
	 *
	 * For libcurl debug enabled builds host name overriding takes place
	 * when environment variable CURL_GETHOSTNAME is set, using the value
	 * held by the variable to override returned host name.
	 *
	 * Note: The function always returns the un-qualified hostname rather
	 * than being provider dependent.
	 *
	 * For libcurl shared library release builds the test suite preloads
	 * another shared library named libhostname using the LD_PRELOAD
	 * mechanism which intercepts, and might override, the gethostname()
	 * function call. In this case a given platform must support the
	 * LD_PRELOAD mechanism and additionally have environment variable
	 * CURL_GETHOSTNAME set in order to override the returned host name.
	 *
	 * For libcurl static library release builds no overriding takes place.
	 */
	public static int Curl_gethostname(Object name, int namelen) {
		int err;
		byte dot;
		/* Override host name when environment variable CURL_GETHOSTNAME is set */
		name[0] = /* DEBUGBUILD *//* The call to system's gethostname() might get intercepted by the
		     libhostname library when libcurl is built as a non-debug shared
		     library when running the test suite. */(byte)'\0';
		err = .gethostname(name, namelen);
		name[namelen - 1] = (byte)'\0';
		if (err) {
			return err;
		} 
		dot = .strchr(name, /* Truncate domain, leave only machine name */(byte)'.');
		if (dot) {
			dot = (byte)'\0';
		} 
		return 0;
	}
	/* Allow compilation and return failure when unavailable */
	/* Allow compilation and return failure when unavailable */
	/* Clean up all source code if we run out of memory */
	public static void easysrc_free() {
		ModernizedCProgram.slist_wc_free_all(ModernizedCProgram.easysrc_decl);
		ModernizedCProgram.easysrc_decl = ((Object)0);
		ModernizedCProgram.slist_wc_free_all(ModernizedCProgram.easysrc_data);
		ModernizedCProgram.easysrc_data = ((Object)0);
		ModernizedCProgram.slist_wc_free_all(ModernizedCProgram.easysrc_code);
		ModernizedCProgram.easysrc_code = ((Object)0);
		ModernizedCProgram.slist_wc_free_all(ModernizedCProgram.easysrc_toohard);
		ModernizedCProgram.easysrc_toohard = ((Object)0);
		ModernizedCProgram.slist_wc_free_all(ModernizedCProgram.easysrc_clean);
		ModernizedCProgram.easysrc_clean = ((Object)0);
	}
	/* Add a source line to the main code or remarks */
	public static  easysrc_add(Object plist, Object line) {
		CURLcode ret = .CURLE_OK;
		slist_wc list = ModernizedCProgram.slist_wc_append(plist, line);
		if (!list) {
			ModernizedCProgram.easysrc_free();
			ret = .CURLE_OUT_OF_MEMORY;
		} else {
				plist = list;
		} 
		return ret;
	}
	public static  easysrc_addf(Object plist, Object fmt) {
		CURLcode ret = new CURLcode();
		byte bufp;
		va_list ap = new va_list();
		.__builtin_va_start(ap, fmt);
		bufp = ModernizedCProgram.curl_mvaprintf(fmt, ap);
		.__builtin_va_end(ap);
		if (!bufp) {
			ret = .CURLE_OUT_OF_MEMORY;
		} else {
				ret = ModernizedCProgram.easysrc_add(plist, bufp);
				ModernizedCProgram.curl_free(bufp);
		} 
		return ret;
	}
	public static  easysrc_init() {
		do {
			CURLcode ret = (ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, "hnd = curl_easy_init();"));
			if (ret) {
				return ret;
			} 
		} while (0);
		return .CURLE_OK;
	}
	public static  easysrc_perform() {
		if (/* Note any setopt calls which we could not convert */ModernizedCProgram.easysrc_toohard) {
			int i;
			curl_slist ptr = new curl_slist();
			byte c;
			do {
				CURLcode ret = (ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, ""));
				if (ret) {
					return ret;
				} 
			} while (0);
			for (i = 0; ((c = ModernizedCProgram.srchard[i]) != ((Object)0)); /* Preamble comment */i++) {
				do {
					CURLcode ret = (ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, c));
					if (ret) {
						return ret;
					} 
				} while (0);
			}
			if (/* Each unconverted option */ModernizedCProgram.easysrc_toohard) {
				for (ptr = ModernizedCProgram.easysrc_toohard.getFirst(); ptr; ptr = ptr.getNext()) {
					do {
						CURLcode ret = (ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, ptr.getData()));
						if (ret) {
							return ret;
						} 
					} while (0);
				}
			} 
			do {
				CURLcode ret = (ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, ""));
				if (ret) {
					return ret;
				} 
			} while (0);
			do {
				CURLcode ret = (ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, "*/"));
				if (ret) {
					return ret;
				} 
			} while (0);
			ModernizedCProgram.slist_wc_free_all(ModernizedCProgram.easysrc_toohard);
			ModernizedCProgram.easysrc_toohard = ((Object)0);
		} 
		do {
			CURLcode ret = (ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, ""));
			if (ret) {
				return ret;
			} 
		} while (0);
		do {
			CURLcode ret = (ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, "ret = curl_easy_perform(hnd);"));
			if (ret) {
				return ret;
			} 
		} while (0);
		do {
			CURLcode ret = (ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, ""));
			if (ret) {
				return ret;
			} 
		} while (0);
		return .CURLE_OK;
	}
	public static  easysrc_cleanup() {
		do {
			CURLcode ret = (ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, "curl_easy_cleanup(hnd);"));
			if (ret) {
				return ret;
			} 
		} while (0);
		do {
			CURLcode ret = (ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, "hnd = NULL;"));
			if (ret) {
				return ret;
			} 
		} while (0);
		return .CURLE_OK;
	}
	public static void dumpeasysrc(Object config) {
		curl_slist ptr = new curl_slist();
		byte o = config.getLibcurl();
		FILE out = new FILE();
		bool fopened = 0;
		if (.strcmp(o, "-")) {
			out = .fopen(o, "wt");
			fopened = 1;
		} else {
				out = (_iob[1]);
		} 
		if (!out) {
			ModernizedCProgram.warnf(config, "Failed to open %s to write libcurl code!\n", o);
		} else {
				int i;
				byte c;
				for (i = 0; ((c = ModernizedCProgram.srchead[i]) != ((Object)0)); i++) {
					ModernizedCProgram.curl_mfprintf(out, "%s\n", c);
				}
				if (/* Declare variables used for complex setopt values */ModernizedCProgram.easysrc_decl) {
					for (ptr = ModernizedCProgram.easysrc_decl.getFirst(); ptr; ptr = ptr.getNext()) {
						ModernizedCProgram.curl_mfprintf(out, "  %s\n", ptr.getData());
					}
				} 
				if (/* Set up complex values for setopt calls */ModernizedCProgram.easysrc_data) {
					ModernizedCProgram.curl_mfprintf(out, "\n");
					for (ptr = ModernizedCProgram.easysrc_data.getFirst(); ptr; ptr = ptr.getNext()) {
						ModernizedCProgram.curl_mfprintf(out, "  %s\n", ptr.getData());
					}
				} 
				ModernizedCProgram.curl_mfprintf(out, "\n");
				if (ModernizedCProgram.easysrc_code) {
					for (ptr = ModernizedCProgram.easysrc_code.getFirst(); ptr; ptr = ptr.getNext()) {
						if (ptr.getData()[0]) {
							ModernizedCProgram.curl_mfprintf(out, "  %s\n", ptr.getData());
						} else {
								ModernizedCProgram.curl_mfprintf(out, "\n");
						} 
					}
				} 
				if (ModernizedCProgram.easysrc_clean) {
					for (ptr = ModernizedCProgram.easysrc_clean.getFirst(); ptr; ptr = ptr.getNext()) {
						ModernizedCProgram.curl_mfprintf(out, "  %s\n", ptr.getData());
					}
				} 
				for (i = 0; ((c = ModernizedCProgram.srcend[i]) != ((Object)0)); i++) {
					ModernizedCProgram.curl_mfprintf(out, "%s\n", c);
				}
				if (fopened) {
					.fclose(out);
				} 
		} 
		ModernizedCProgram.easysrc_free();
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	public static  glob_fixed(Object glob, Object fixed, Object len) {
		URLPattern pat = glob.getPattern()[glob.getSize()];
		pat.setType(.UPTSet);
		pat.getContent().getSet().setSize(1);
		pat.getContent().getSet().setPtr_s(0);
		pat.setGlobindex(-1);
		pat.getContent().getSet().setElements(.malloc());
		if (!pat.getContent().getSet().getElements()) {
			return ;
		} 
		pat.getContent().getSet().getElements()[0] = .malloc(len + 1);
		if (!pat.getContent().getSet().getElements()[0]) {
			return ;
		} 
		.memcpy(pat.getContent().getSet().getElements()[0], fixed, len);
		pat.getContent().getSet().getElements()[0][len] = 0;
		return .CURLE_OK/* multiply
		 *
		 * Multiplies and checks for overflow.
		 */;
	}
	public static int multiply(Object amount, long with) {
		long sum = amount * with;
		if (!with) {
			amount = 0;
			return 0;
		} 
		if (sum / with != amount) {
			return /* didn't fit, bail out */1;
		} 
		amount = sum;
		return 0;
	}
	public static  glob_set(Object glob, Object patternp, Object posp, Object amount, int globindex) {
		/* processes a set expression with the point behind the opening '{'
		     ','-separated elements are collected until the next closing '}'
		  */URLPattern pat = new URLPattern();
		bool done = 0;
		byte buf = glob.getGlob_buffer();
		byte pattern = patternp;
		byte opattern = pattern;
		size_t opos = posp - 1;
		pat = glob.getPattern()[glob.getSize()];
		pat.setType(/* patterns 0,1,2,... correspond to size=1,3,5,... */.UPTSet);
		pat.getContent().getSet().setSize(0);
		pat.getContent().getSet().setPtr_s(0);
		pat.getContent().getSet().setElements(((Object)0));
		pat.setGlobindex(globindex);
		while (!done) {
			switch (pattern) {
			case /* FALLTHROUGH */(byte)',':
					buf = (byte)'\0';
					if (pat.getContent().getSet().getElements()) {
						byte new_arr = .realloc(pat.getContent().getSet().getElements(), (pat.getContent().getSet().getSize() + 1) * );
						if (!new_arr) {
							return ;
						} 
						pat.getContent().getSet().setElements(new_arr);
					} else {
							pat.getContent().getSet().setElements(.malloc());
					} 
					if (!pat.getContent().getSet().getElements()) {
						return ;
					} 
					pat.getContent().getSet().getElements()[pat.getContent().getSet().getSize()] = .strdup(glob.getGlob_buffer());
					if (!pat.getContent().getSet().getElements()[pat.getContent().getSet().getSize()]) {
						return ;
					} 
					++pat.getContent().getSet().getSize();
					if (pattern == (byte)'}') {
						/* pass the closing brace */pattern++;
						done = 1;
						continue;
					} 
					buf = glob.getGlob_buffer();
					++pattern;
					++(posp);
					break;
			case /* illegal closing bracket */(byte)']':
					return ;
			case (byte)'{':
			case /* escaped character, skip '\' */(byte)'\\':
					if (pattern[1]) {
						++pattern;
						++(posp);
					} 
			case /* no nested expressions at this time */(byte)'[':
					return ;
			case /* URL ended while set was still open */(byte)'\0':
					return ;
			case /* set element completed */(byte)'}':
					if (opattern == pattern) {
						return ;
					} 
					if (ModernizedCProgram.multiply(amount, pat.getContent().getSet().getSize() + /* add 1 to size since it'll be incremented below */1)) {
						return ;
					} 
			default:
					buf++ = /* copy character to set element */pattern++;
					++(posp);
			}
		}
		patternp = /* return with the new position */pattern;
		return .CURLE_OK;
	}
	public static  glob_range(Object glob, Object patternp, Object posp, Object amount, int globindex) {
		URLPattern pat = new URLPattern();
		int rc;
		byte pattern = patternp;
		byte c;
		pat = glob.getPattern()[glob.getSize()];
		pat.setGlobindex(globindex);
		patternp = pattern;
		return .CURLE_OK;
	}
	/* processes a range expression with the point behind the opening '['
	     - char range: e.g. "a-z]", "B-Q]"
	     - num range: e.g. "0-9]", "17-2000]"
	     - num range with leading zeros: e.g. "001-999]"
	     expression is checked for well-formedness and collected until the next ']'
	  */
	public static  peek_ipv6(Object str, Object skip) {
		size_t i = 0;
		size_t colons = 0;
		if (str[i++] != (byte)'[') {
			return 0;
		} 
		for (; ; ) {
			byte c = str[i++];
			if ((ModernizedCProgram.Curl_isalnum((int)((byte)c))) || c == (byte)'.' || c == (byte)'%'/* ok */) {
			}  else if (c == (byte)':') {
				colons++;
			}  else if (c == (byte)']') {
				skip = i;
				return colons >= 2 ? 1 : 0;
			} else {
					return 0;
			} 
		}
	}
	/*
	   * Scan for a potential IPv6 literal.
	   * - Valid globs contain a hyphen and <= 1 colon.
	   * - IPv6 literals contain no hyphens and >= 2 colons.
	   */
	public static  glob_parse(Object glob, Object pattern, Object pos, Object amount) {
		CURLcode res = /* processes a literal string component of a URL
		     special characters '{' and '[' branch to set/range processing functions
		   */.CURLE_OK;
		int globindex = /* count "actual" globs */0;
		amount = 1;
		while (pattern && !res) {
			byte buf = glob.getGlob_buffer();
			size_t sublen = 0;
			while (pattern && pattern != (byte)'{') {
				if (pattern == (byte)'[') {
					size_t skip = /* skip over IPv6 literals and [] */0;
					if (!ModernizedCProgram.peek_ipv6(pattern, skip) && (pattern[1] == (byte)']')) {
						skip = 2;
					} 
					if (skip) {
						.memcpy(buf, pattern, skip);
						buf += skip;
						pattern += skip;
						sublen += skip;
						continue;
					} 
					break;
				} 
				if (pattern == (byte)'}' || pattern == (byte)']') {
					return ;
				} 
				if (pattern == /* only allow \ to escape known "special letters" */(byte)'\\' && ((pattern + 1) == (byte)'{' || (pattern + 1) == (byte)'[' || (pattern + 1) == (byte)'}' || (pattern + 1) == (byte)']')) {
					++/* escape character, skip '\' */pattern;
					++pos;
				} 
				buf++ = /* copy character to literal */pattern++;
				++pos;
				sublen++;
			}
			if (sublen) {
				buf = /* we got a literal string, add it as a single-item list */(byte)'\0';
				res = ModernizedCProgram.glob_fixed(glob, glob.getGlob_buffer(), sublen);
			} else {
					switch (pattern) {
					case (byte)'[':
							/* process range pattern */pattern++;
							pos++;
							res = ModernizedCProgram.glob_range(glob, pattern, pos, amount, globindex++);
							break;
					case (byte)'{':
							/* process set pattern */pattern++;
							pos++;
							res = ModernizedCProgram.glob_set(glob, pattern, pos, amount, globindex++);
							break;
					case /* done  */(byte)'\0':
							break;
					}
			} 
			if (++glob.getSize() >= 100) {
				return ;
			} 
		}
		return res;
	}
	public static  glob_url(Object glob, Object url, Object urlnum, Object error) {
		URLGlob glob_expand = new URLGlob();
		long amount = 0;
		byte glob_buffer;
		CURLcode res = new CURLcode();
		glob = ((Object)0);
		glob_buffer = .malloc(.strlen(url) + 1);
		if (!glob_buffer) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		glob_buffer[0] = 0;
		glob_expand = .calloc(1, );
		if (!glob_expand) {
			do {
				.free((glob_buffer));
				(glob_buffer) = ((Object)0);
			} while (0);
			return .CURLE_OUT_OF_MEMORY;
		} 
		glob_expand.setUrllen(.strlen(url));
		glob_expand.setGlob_buffer(glob_buffer);
		res = ModernizedCProgram.glob_parse(glob_expand, url, 1, amount);
		if (!res) {
			urlnum = amount;
		} else {
				if (error && glob_expand.getError()) {
					byte[] text = new byte[512];
					byte t;
					if (glob_expand.getPos()) {
						ModernizedCProgram.curl_msnprintf(text, , "%s in URL position %zu:\n%s\n%*s^", glob_expand.getError(), glob_expand.getPos(), url, glob_expand.getPos() - 1, " ");
						t = text;
					} else {
							t = glob_expand.getError();
					} 
					ModernizedCProgram.curl_mfprintf(error, "curl: (%d) %s\n", res, /* send error description to the error-stream */t);
				} 
				ModernizedCProgram.glob_cleanup(/* it failed, we cleanup */glob_expand);
				urlnum = 1;
				return res;
		} 
		glob = glob_expand;
		return .CURLE_OK;
	}
	/*
	   * We can deal with any-size, just make a buffer with the same length
	   * as the specified URL!
	   */
	public static void glob_cleanup(Object glob) {
		size_t i = new size_t();
		int elem;
		if (!glob) {
			return ;
		} 
		for (i = 0; i < glob.getSize(); i++) {
			if ((glob.getPattern()[i].getType() == .UPTSet) && (glob.getPattern()[i].getContent().getSet().getElements())) {
				for (elem = glob.getPattern()[i].getContent().getSet().getSize() - 1; elem >= 0; --elem) {
					do {
						.free((glob.getPattern()[i].getContent().getSet().getElements()[elem]));
						(glob.getPattern()[i].getContent().getSet().getElements()[elem]) = ((Object)0);
					} while (0);
				}
				do {
					.free((glob.getPattern()[i].getContent().getSet().getElements()));
					(glob.getPattern()[i].getContent().getSet().getElements()) = ((Object)0);
				} while (0);
			} 
		}
		do {
			.free((glob.getGlob_buffer()));
			(glob.getGlob_buffer()) = ((Object)0);
		} while (0);
		do {
			.free((glob));
			(glob) = ((Object)0);
		} while (0);
	}
	public static  glob_next_url(Object globbed, Object glob) {
		URLPattern pat = new URLPattern();
		size_t i = new size_t();
		size_t len = new size_t();
		size_t buflen = glob.getUrllen() + 1;
		byte buf = glob.getGlob_buffer();
		globbed = ((Object)0);
		if (!glob.getBeenhere()) {
			glob.setBeenhere(1);
		} else {
				bool carry = 1;
				for (i = 0; carry && (i < glob.getSize()); /* implement a counter over the index ranges of all patterns, starting
				       with the rightmost pattern */i++) {
					carry = 0;
					pat = glob.getPattern()[glob.getSize() - 1 - i];
					switch (pat.getType()) {
					case .UPTCharRange:
							pat.getContent().getCharRange().setPtr_c((byte)(pat.getContent().getCharRange().getStep() + (int)((byte)pat.getContent().getCharRange().getPtr_c())));
							if (pat.getContent().getCharRange().getPtr_c() > pat.getContent().getCharRange().getMax_c()) {
								pat.getContent().getCharRange().setPtr_c(pat.getContent().getCharRange().getMin_c());
								carry = 1;
							} 
							break;
					case .UPTNumRange:
							pat.getContent().getNumRange().getPtr_n() += pat.getContent().getNumRange().getStep();
							if (pat.getContent().getNumRange().getPtr_n() > pat.getContent().getNumRange().getMax_n()) {
								pat.getContent().getNumRange().setPtr_n(pat.getContent().getNumRange().getMin_n());
								carry = 1;
							} 
							break;
					case .UPTSet:
							if ((pat.getContent().getSet().getElements()) && (++pat.getContent().getSet().getPtr_s() == pat.getContent().getSet().getSize())) {
								pat.getContent().getSet().setPtr_s(0);
								carry = 1;
							} 
							break;
					default:
							ModernizedCProgram.curl_mprintf("internal error: invalid pattern type (%d)\n", (int)pat.getType());
							return .CURLE_FAILED_INIT;
					}
				}
				if (/* first pattern ptr has run into overflow, done! */carry) {
					return .CURLE_OK;
				} 
		} 
		for (i = 0; i < glob.getSize(); ++i) {
			pat = glob.getPattern()[i];
			switch (pat.getType()) {
			case .UPTCharRange:
					if (buflen) {
						buf++ = pat.getContent().getCharRange().getPtr_c();
						buf = (byte)'\0';
						buflen--;
					} 
					break;
			case .UPTSet:
					if (pat.getContent().getSet().getElements()) {
						ModernizedCProgram.curl_msnprintf(buf, buflen, "%s", pat.getContent().getSet().getElements()[pat.getContent().getSet().getPtr_s()]);
						len = .strlen(buf);
						buf += len;
						buflen -= len;
					} 
					break;
			case .UPTNumRange:
					ModernizedCProgram.curl_msnprintf(buf, buflen, "%0*lu", pat.getContent().getNumRange().getPadlength(), pat.getContent().getNumRange().getPtr_n());
					len = .strlen(buf);
					buf += len;
					buflen -= len;
					break;
			default:
					ModernizedCProgram.curl_mprintf("internal error: invalid pattern type (%d)\n", (int)pat.getType());
					return .CURLE_FAILED_INIT;
			}
		}
		globbed = .strdup(glob.getGlob_buffer());
		if (!globbed) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		return .CURLE_OK;
	}
	public static  glob_match_url(Object result, Object filename, Object glob) {
		byte target;
		size_t allocsize = new size_t();
		byte[] numbuf = new byte[18];
		byte appendthis = (byte)"";
		size_t appendlen = 0;
		size_t stringlen = 0;
		result = ((Object)0/* We cannot use the glob_buffer for storage here since the filename may
		   * be longer than the URL we use. We allocate a good start size, then
		   * we need to realloc in case of need.
		   */);
		allocsize = .strlen(filename) + /* make it at least one byte to store the
		                                       trailing zero */1;
		target = .malloc(allocsize);
		if (!target) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		while (filename) {
			if (filename == (byte)'#' && (ModernizedCProgram.Curl_isdigit((int)((byte)filename[1])))) {
				byte ptr = filename;
				long num = .strtoul(filename[1], filename, 10);
				URLPattern pat = ((Object)0);
				if (num < glob.getSize()) {
					long i;
					/* make it zero based */num--;
					for (i = 0; i < glob.getSize(); /* find the correct glob entry */i++) {
						if (glob.getPattern()[i].getGlobindex() == (int)num) {
							pat = glob.getPattern()[i];
							break;
						} 
					}
				} 
				if (pat) {
					switch (pat.getType()) {
					case .UPTCharRange:
							numbuf[0] = pat.getContent().getCharRange().getPtr_c();
							numbuf[1] = 0;
							appendthis = numbuf;
							appendlen = 1;
							break;
					case .UPTNumRange:
							ModernizedCProgram.curl_msnprintf(numbuf, , "%0*lu", pat.getContent().getNumRange().getPadlength(), pat.getContent().getNumRange().getPtr_n());
							appendthis = numbuf;
							appendlen = .strlen(numbuf);
							break;
					case .UPTSet:
							if (pat.getContent().getSet().getElements()) {
								appendthis = pat.getContent().getSet().getElements()[pat.getContent().getSet().getPtr_s()];
								appendlen = .strlen(pat.getContent().getSet().getElements()[pat.getContent().getSet().getPtr_s()]);
							} 
							break;
					default:
							ModernizedCProgram.curl_mfprintf((_iob[2]), "internal error: invalid pattern type (%d)\n", (int)pat.getType());
							do {
								.free((target));
								(target) = ((Object)0);
							} while (0);
							return .CURLE_FAILED_INIT;
					}
				} else {
						filename = /* #[num] out of range, use the #[num] in the output */ptr;
						appendthis = filename++;
						appendlen = 1;
				} 
			} else {
					appendthis = filename++;
					appendlen = 1;
			} 
			if (appendlen + stringlen >= allocsize) {
				byte newstr;
				allocsize = (appendlen + stringlen) * 2;
				newstr = .realloc(target, allocsize + 1);
				if (!newstr) {
					do {
						.free((target));
						(target) = ((Object)0);
					} while (0);
					return .CURLE_OUT_OF_MEMORY;
				} 
				target = newstr;
			} 
			.memcpy(target[stringlen], appendthis, appendlen);
			stringlen += appendlen;
		}
		target[stringlen] = (byte)'\0';
		{ 
			byte sanitized;
			SANITIZEcode sc = ModernizedCProgram.sanitize_file_name(sanitized, target, ((1 << 1) | (1 << 2)));
			do {
				.free((target));
				(target) = ((Object)0);
			} while (0);
			if (sc) {
				return .CURLE_URL_MALFORMAT;
			} 
			target = sanitized;
		}
		result = /* MSDOS || WIN32 */target;
		return .CURLE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/*
	** Helper functions that are used from more than one source file.
	*/
	public static Object param2text(int res) {
		ParameterError error = (ParameterError)res;
		switch (error) {
		case .PARAM_NUMBER_TOO_LARGE:
				return "too large number";
		case .PARAM_NEGATIVE_NUMERIC:
				return "expected a positive numerical parameter";
		case .PARAM_OPTION_UNKNOWN:
				return "is unknown";
		case .PARAM_NO_NOT_BOOLEAN:
				return "used '--no-' for option that isn't a boolean";
		case .PARAM_BAD_NUMERIC:
				return "expected a proper numerical parameter";
		case .PARAM_NO_PREFIX:
				return "the given option can't be reversed with a --no- prefix";
		case .PARAM_LIBCURL_DOESNT_SUPPORT:
				return "the installed libcurl version doesn't support this";
		case .PARAM_LIBCURL_UNSUPPORTED_PROTOCOL:
				return "a specified protocol is unsupported by libcurl";
		case .PARAM_BAD_USE:
				return "is badly used here";
		case .PARAM_REQUIRES_PARAMETER:
				return "requires parameter";
		case .PARAM_OPTION_AMBIGUOUS:
				return "is ambiguous";
		case .PARAM_NO_MEM:
				return "out of memory";
		case .PARAM_GOT_EXTRA_PARAMETER:
				return "had unsupported trailing garbage";
		default:
				return "unknown error";
		}
	}
	public static int SetHTTPrequest(Object config,  req, Object store) {
		/* this mirrors the HttpReq enum in tool_sdecls.h */byte[] reqname = new byte[]{/* unspec */"", "GET (-G, --get)", "HEAD (-I, --head)", "multipart formpost (-F, --form)", "POST (-d, --data)"};
		if ((store == .HTTPREQ_UNSPEC) || (store == req)) {
			store = req;
			return 0;
		} 
		ModernizedCProgram.warnf(config.getGlobal(), "You can only select one HTTP request method! You asked for both %s and %s.\n", reqname[req], reqname[store]);
		return 1;
	}
	public static void customrequest_helper(Object config,  req, Object method) {
		/* this mirrors the HttpReq enum in tool_sdecls.h */byte[] dflt = new byte[]{"GET", "GET", "HEAD", "POST", "POST"};
		if (!method) {
			;
		}  else if (ModernizedCProgram.curl_strequal(method, dflt[req])) {
			ModernizedCProgram.notef(config.getGlobal(), "Unnecessary use of -X or --request, %s is already inferred.\n", dflt[req]);
		}  else if (ModernizedCProgram.curl_strequal(method, "head")) {
			ModernizedCProgram.warnf(config.getGlobal(), "Setting custom HTTP method to HEAD with -X/--request may not work the way you want. Consider using -I/--head instead.\n");
		} 
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * This is a socketpair() implementation for Windows.
	 */
	/* IPPROTO_TCP */
	/* !INADDR_LOOPBACK */
	/* !WIN32 */
	/* The last 3 #include files should be in this order */
	public static int Curl_socketpair(int domain, int type, int protocol, Object socks) {
		Object a;
		curl_socket_t listener = new curl_socket_t();
		Object generatedInaddr = a.getInaddr();
		curl_socklen_t addrlen = ;
		int reuse = 1;
		byte[][] data = new byte[2][12];
		ssize_t dlen = new ssize_t();
		(Object)domain;
		(Object)type;
		(Object)protocol;
		listener = .socket(2, 1, 6);
		if (listener == (SOCKET)(~0)) {
			return -1;
		} 
		.memset(a, 0, );
		generatedInaddr.setSin_family(2);
		generatedInaddr.getSin_addr().getS_un().setS_addr(.htonl(-1024));
		generatedInaddr.setSin_port(0);
		socks[0] = socks[1] = (SOCKET)(~0);
		if (.setsockopt(listener, -1024, 4, (byte)reuse, (curl_socklen_t)) == -1) {
			;
		} 
		Object generatedAddr = a.getAddr();
		if (.bind(listener, generatedAddr, ) == -1) {
			;
		} 
		if (.getsockname(listener, generatedAddr, addrlen) == -1) {
			;
		} 
		if (.listen(listener, 1) == -1) {
			;
		} 
		socks[0] = .socket(2, 1, 0);
		if (socks[0] == (SOCKET)(~0)) {
			;
		} 
		if (.connect(socks[0], generatedAddr, ) == -1) {
			;
		} 
		socks[1] = .accept(listener, ((Object)0), ((Object)0));
		if (socks[1] == (SOCKET)(~0)) {
			;
		} 
		ModernizedCProgram.curl_msnprintf(data[0], , "%p", /* verify that nothing else connected */socks);
		dlen = .strlen(data[0]);
		if ((ssize_t).send((SOCKET)(socks[0]), (byte)(data[0]), (int)(dlen), (int)(false)) != dlen) {
			;
		} 
		if ((ssize_t).recv((SOCKET)(socks[1]), (byte)(data[1]), (int)(), (int)(false)) != dlen) {
			;
		} 
		if (.memcmp(data[0], data[1], dlen)) {
			;
		} 
		.closesocket((listener));
		return 0;
		.closesocket((socks[0]));
		.closesocket((socks[1]));
		return -1/* ! HAVE_SOCKETPAIR */;
	}
	public static int Curl_resolver_global_init() {
		return .CURLE_OK/*
		 * Curl_resolver_global_cleanup()
		 * Called from curl_global_cleanup() to destroy global resolver environment.
		 * Does nothing here.
		 */;
	}
	public static void Curl_resolver_global_cleanup() {
	}
	/*
	 * Curl_resolver_init()
	 * Called from curl_easy_init() -> Curl_open() to initialize resolver
	 * URL-state specific environment ('resolver' member of the UrlState
	 * structure).
	 */
	public static  Curl_resolver_init(Object easy, Object resolver) {
		(Object)easy;
		resolver = .Curl_ccalloc(1, );
		if (!resolver) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		return .CURLE_OK/*
		 * Curl_resolver_cleanup()
		 * Called from curl_easy_cleanup() -> Curl_close() to cleanup resolver
		 * URL-state specific environment ('resolver' member of the UrlState
		 * structure).
		 */;
	}
	public static void Curl_resolver_cleanup(Object resolver) {
		.Curl_cfree(resolver/*
		 * Curl_resolver_duphandle()
		 * Called from curl_easy_duphandle() to duplicate resolver URL state-specific
		 * environment ('resolver' member of the UrlState structure).
		 */);
	}
	public static  Curl_resolver_duphandle(Object easy, Object to, Object from) {
		(Object)from;
		return ModernizedCProgram.Curl_resolver_init(easy, to);
	}
	public static void Curl_resolver_cancel(Object conn) {
		ModernizedCProgram.destroy_async_data(conn.getAsync());
	}
	public static Object conn_thread_sync_data(Object conn) {
		return (((thread_data)conn.getAsync().getOs_specific()).getTsd());
	}
	/* Destroy resolver thread synchronization data */
	public static void destroy_thread_sync_data(Object tsd) {
		if (tsd.getMtx()) {
			.DeleteCriticalSection(tsd.getMtx());
			.Curl_cfree(tsd.getMtx());
		} 
		.Curl_cfree(tsd.getHostname());
		if (tsd.getRes()) {
			ModernizedCProgram.Curl_freeaddrinfo(tsd.getRes());
		} 
		if (tsd.getSock_pair()[1] != (SOCKET)(~0)) {
			.closesocket((tsd.getSock_pair()[1]));
		} 
		.memset(tsd, 0, );
	}
	/* Initialize resolver thread synchronization data */
	public static int init_thread_sync_data(Object td, Object hostname, int port, Object hints) {
		thread_sync_data tsd = td.getTsd();
		.memset(tsd, 0, );
		tsd.setTd(td);
		tsd.setPort(port/* Treat the request as done until the thread actually starts so any early
		   * cleanup gets done properly.
		   */);
		tsd.setDone(1);
		(Object)hints;
		tsd.setMtx(.Curl_cmalloc());
		if (tsd.getMtx() == ((Object)0)) {
			;
		} 
		.InitializeCriticalSection(tsd.getMtx());
		if (ModernizedCProgram.Curl_socketpair(1, 1, 0, tsd.getSock_pair()[0]) < /* create socket pair, avoid AF_LOCAL since it doesn't build on Solaris */0) {
			tsd.getSock_pair()[0] = (SOCKET)(~0);
			tsd.getSock_pair()[1] = (SOCKET)(~0);
			;
		} 
		tsd.setSock_error(.CURLE_OK/* Copying hostname string because original can be destroyed by parent
		   * thread during gethostbyname execution.
		   */);
		tsd.setHostname(.Curl_cstrdup(hostname));
		if (!tsd.getHostname()) {
			;
		} 
		return 1;
		return 0;
	}
	public static int getaddrinfo_complete(Object conn) {
		thread_sync_data tsd = ModernizedCProgram.conn_thread_sync_data(conn);
		int rc;
		rc = ModernizedCProgram.Curl_addrinfo_callback(conn, tsd.getSock_error(), tsd.getRes());
		tsd.setRes(((Object)0));
		return rc/*
		 * getaddrinfo_thread() resolves a name and then exits.
		 *
		 * For builds without ARES, but with ENABLE_IPV6, create a resolver thread
		 * and wait on it.
		 */;
	}
	/* too late, gotta clean up the mess */
	/* DNS has been resolved, signal client task */
	/* update sock_erro to errno */
	/* HAVE_GETADDRINFO */
	/*
	 * gethostbyname_thread() resolves a name and then exits.
	 */
	public static int gethostbyname_thread(Object arg) {
		thread_sync_data tsd = (thread_sync_data)arg;
		thread_data td = tsd.getTd();
		tsd.setRes(ModernizedCProgram.Curl_ipv4_resolve_r(tsd.getHostname(), tsd.getPort()));
		if (!tsd.getRes()) {
			tsd.setSock_error(((int).WSAGetLastError()));
			if (tsd.getSock_error() == 0) {
				tsd.setSock_error(12);
			} 
		} 
		.EnterCriticalSection(tsd.getMtx());
		if (tsd.getDone()) {
			.LeaveCriticalSection(tsd.getMtx());
			ModernizedCProgram.destroy_thread_sync_data(tsd);
			.Curl_cfree(td);
		} else {
				tsd.setDone(1);
				.LeaveCriticalSection(tsd.getMtx());
		} 
		return 0/* HAVE_GETADDRINFO */;
	}
	/*
	 * destroy_async_data() cleans up async resolver data and thread handle.
	 */
	public static void destroy_async_data(Object async) {
		if (async.getOs_specific()) {
			thread_data td = (thread_data)async.getOs_specific();
			int done;
			curl_socket_t sock_rd = td.getTsd().getSock_pair()[0];
			connectdata conn = td.getTsd().getConn();
			.EnterCriticalSection(td.getTsd().getMtx());
			done = td.getTsd().getDone();
			td.getTsd().setDone(1);
			.LeaveCriticalSection(td.getTsd().getMtx());
			if (!done) {
				ModernizedCProgram.Curl_thread_destroy(td.getThread_hnd());
			} else {
					if (td.getThread_hnd() != (HANDLE)0) {
						ModernizedCProgram.Curl_thread_join(td.getThread_hnd());
					} 
					ModernizedCProgram.destroy_thread_sync_data(td.getTsd());
					.Curl_cfree(async.getOs_specific());
			} 
			if (conn) {
				ModernizedCProgram.Curl_multi_closed(conn.getData(), sock_rd);
			} 
			.closesocket((sock_rd));
		} 
		async.setOs_specific(((Object)0));
		.Curl_cfree(async.getHostname());
		async.setHostname(((Object)0/*
		 * init_resolve_thread() starts a new thread that performs the actual
		 * resolve. This function returns before the resolve is done.
		 *
		 * Returns FALSE in case of failure, otherwise TRUE.
		 */));
	}
	/*
	 * Cancel all possibly still on-going resolves for this connection.
	 */
	/* This function is used to init a threaded resolve */
	public static  init_resolve_thread(Object conn, Object hostname, int port, Object hints) {
		thread_data td = .Curl_ccalloc(1, );
		int err = 12;
		conn.getAsync().setOs_specific((Object)td);
		if (!td) {
			;
		} 
		conn.getAsync().setPort(port);
		conn.getAsync().setDone(0);
		conn.getAsync().setStatus(0);
		conn.getAsync().setDns(((Object)0));
		td.setThread_hnd((HANDLE)0);
		if (!ModernizedCProgram.init_thread_sync_data(td, hostname, port, hints)) {
			conn.getAsync().setOs_specific(((Object)0));
			.Curl_cfree(td);
			;
		} 
		.Curl_cfree(conn.getAsync().getHostname());
		conn.getAsync().setHostname(.Curl_cstrdup(hostname));
		if (!conn.getAsync().getHostname()) {
			;
		} 
		td.getTsd().setDone(/* The thread will set this to 1 when complete. */0);
		td.setThread_hnd(ModernizedCProgram.Curl_thread_create(gethostbyname_thread, td.getTsd()));
		if (!td.getThread_hnd()) {
			td.getTsd().setDone(/* The thread never started, so mark it as done here for proper cleanup. */1);
			err = (._errno());
			;
		} 
		return 1;
		return 0/*
		 * resolver_error() calls failf() with the appropriate message after a resolve
		 * error
		 */;
	}
	public static  resolver_error(Object conn) {
		byte host_or_proxy;
		CURLcode result = new CURLcode();
		if (conn.getBits().getHttpproxy()) {
			host_or_proxy = "proxy";
			result = .CURLE_COULDNT_RESOLVE_PROXY;
		} else {
				host_or_proxy = "host";
				result = .CURLE_COULDNT_RESOLVE_HOST;
		} 
		ModernizedCProgram.Curl_failf(conn.getData(), "Could not resolve %s: %s", host_or_proxy, conn.getAsync().getHostname());
		return result;
	}
	public static  thread_wait_resolv(Object conn, Object entry,  report) {
		thread_data td = (thread_data)conn.getAsync().getOs_specific();
		CURLcode result = .CURLE_OK;
		do {
		} while (0);
		do {
		} while (0);
		if (ModernizedCProgram.Curl_thread_join(td.getThread_hnd())) {
			if (entry) {
				result = ModernizedCProgram.getaddrinfo_complete(conn);
			} 
		} else {
				do {
				} while (0);
		} 
		conn.getAsync().setDone(1);
		if (entry) {
			entry = conn.getAsync().getDns();
		} 
		if (!conn.getAsync().getDns() && report) {
			result = ModernizedCProgram.resolver_error(/* a name was not resolved, report error */conn);
		} 
		ModernizedCProgram.destroy_async_data(conn.getAsync());
		if (!conn.getAsync().getDns() && report) {
			ModernizedCProgram.Curl_conncontrol(conn, 1);
		} 
		return result/*
		 * Until we gain a way to signal the resolver threads to stop early, we must
		 * simply wait for them and ignore their results.
		 */;
	}
	public static void Curl_resolver_kill(Object conn) {
		thread_data td = (thread_data)conn.getAsync().getOs_specific();
		if (td && td.getThread_hnd() != (HANDLE)0) {
			(Object)ModernizedCProgram.thread_wait_resolv(conn, ((Object)0), 0);
		} else {
				ModernizedCProgram.Curl_resolver_cancel(conn/*
				 * Curl_resolver_wait_resolv()
				 *
				 * Waits for a resolve to finish. This function should be avoided since using
				 * this risk getting the multi interface to "hang".
				 *
				 * If 'entry' is non-NULL, make it point to the resolved dns entry
				 *
				 * Returns CURLE_COULDNT_RESOLVE_HOST if the host was not resolved,
				 * CURLE_OPERATION_TIMEDOUT if a time-out occurred, or other errors.
				 *
				 * This is the version for resolves-in-a-thread.
				 */);
		} 
	}
	public static  Curl_resolver_wait_resolv(Object conn, Object entry) {
		return ModernizedCProgram.thread_wait_resolv(conn, entry, 1/*
		 * Curl_resolver_is_resolved() is called repeatedly to check if a previous
		 * name resolve request has completed. It should also make sure to time-out if
		 * the operation seems to take too long.
		 */);
	}
	public static  Curl_resolver_is_resolved(Object conn, Object entry) {
		Curl_easy data = conn.getData();
		thread_data td = (thread_data)conn.getAsync().getOs_specific();
		int done = 0;
		entry = ((Object)0);
		if (!td) {
			do {
			} while (0);
			return .CURLE_COULDNT_RESOLVE_HOST;
		} 
		.EnterCriticalSection(td.getTsd().getMtx());
		done = td.getTsd().getDone();
		.LeaveCriticalSection(td.getTsd().getMtx());
		curltime curltime = new curltime();
		if (done) {
			ModernizedCProgram.getaddrinfo_complete(conn);
			if (!conn.getAsync().getDns()) {
				CURLcode result = ModernizedCProgram.resolver_error(conn);
				ModernizedCProgram.destroy_async_data(conn.getAsync());
				return result;
			} 
			ModernizedCProgram.destroy_async_data(conn.getAsync());
			entry = conn.getAsync().getDns();
		} else {
				time_t elapsed = (time_t)curltime.Curl_now().Curl_timediff(data.getProgress().getT_startsingle());
				if (elapsed < 0) {
					elapsed = 0;
				} 
				if (td.getPoll_interval() == 0) {
					td.setPoll_interval(/* Start at 1ms poll interval */1);
				}  else if (elapsed >= td.getInterval_end()) {
					td.getPoll_interval() *= /* Back-off exponentially if last interval expired  */2;
				} 
				if (td.getPoll_interval() > 250) {
					td.setPoll_interval(250);
				} 
				td.setInterval_end(elapsed + td.getPoll_interval());
				ModernizedCProgram.Curl_expire(conn.getData(), td.getPoll_interval(), .EXPIRE_ASYNC_NAME);
		} 
		return .CURLE_OK;
	}
	public static int Curl_resolver_getsock(Object conn, Object socks) {
		int ret_val = 0;
		time_t milli = new time_t();
		timediff_t ms = new timediff_t();
		Curl_easy data = conn.getData();
		resdata reslv = (resdata)data.getState().getResolver();
		thread_data td = (thread_data)conn.getAsync().getOs_specific();
		curltime curltime = new curltime();
		if (td) {
			socks[0] = td.getTsd().getSock_pair()[/* return read fd to client for polling the DNS resolution status */0];
			do {
			} while (0);
			td.getTsd().setConn(conn);
			ret_val = (1 << (false));
		} else {
				ms = curltime.Curl_now().Curl_timediff(reslv.getStart());
				if (ms < 3) {
					milli = 0;
				}  else if (ms <= 50) {
					milli = (time_t)ms / 3;
				}  else if (ms <= 250) {
					milli = 50;
				} else {
						milli = 200;
				} 
				ModernizedCProgram.Curl_expire(data, milli, .EXPIRE_ASYNC_NAME);
		} 
		return ret_val;
	}
	/*
	 * Curl_getaddrinfo() - for platforms without getaddrinfo
	 */
	/*
	 * Curl_getaddrinfo() - for platforms without getaddrinfo
	 */
	public static Object Curl_resolver_getaddrinfo(Object conn, Object hostname, int port, Object waitp) {
		in_addr in = new in_addr();
		Curl_easy data = conn.getData();
		resdata reslv = (resdata)data.getState().getResolver();
		waitp = /* default to synchronous response */0;
		if (ModernizedCProgram.Curl_inet_pton(2, hostname, in) > 0) {
			return ModernizedCProgram.Curl_ip2addr(2, in, hostname, /* This is a dotted IP address 123.123.123.123-style */port);
		} 
		curltime curltime = new curltime();
		reslv.setStart(curltime.Curl_now());
		if (ModernizedCProgram.init_resolve_thread(conn, hostname, port, ((Object)/* fire up a new resolver thread! */0))) {
			waitp = /* expect asynchronous response */1;
			return ((Object)0);
		} 
		ModernizedCProgram.Curl_failf(conn.getData(), "getaddrinfo() thread failed\n");
		return ((Object)0/* !HAVE_GETADDRINFO *//*
		 * Curl_resolver_getaddrinfo() - for getaddrinfo
		 *//* default to synchronous response *//* First check if this is an IPv4 address string *//* This is a dotted IP address 123.123.123.123-style *//* check if this is an IPv6 address string *//* This is an IPv6 address literal *//* CURLRES_IPV6 *//* !USE_RESOLVE_ON_IPS *//*
		   * Check if a limited name resolve has been requested.
		   */);
	}
	/* The stack seems to be a non-IPv6 one */
	/* CURLRES_IPV6 */
	/* fire up a new resolver thread! */
	/* expect asynchronous response */
	/* !HAVE_GETADDRINFO */
	public static  Curl_set_dns_servers(Object data, Object servers) {
		(Object)data;
		(Object)servers;
		return .CURLE_NOT_BUILT_IN;
	}
	public static  Curl_set_dns_interface(Object data, Object interf) {
		(Object)data;
		(Object)interf;
		return .CURLE_NOT_BUILT_IN;
	}
	public static  Curl_set_dns_local_ip4(Object data, Object local_ip4) {
		(Object)data;
		(Object)local_ip4;
		return .CURLE_NOT_BUILT_IN;
	}
	public static  Curl_set_dns_local_ip6(Object data, Object local_ip6) {
		(Object)data;
		(Object)local_ip6;
		return .CURLE_NOT_BUILT_IN/* CURLRES_THREADED */;
	}
	/* Escape string to C string syntax.  Return NULL if out of memory.
	 * Is this correct for those wacky EBCDIC guys? */
	public static Object c_escape(Object str, Object len) {
		byte s;
		byte c;
		byte escaped;
		byte e;
		if (len == ((size_t)-1)) {
			len = .strlen(str);
		} 
		if (len > (~(size_t)0) / /* Check for possible overflow. */4) {
			return ((Object)0);
		} 
		escaped = .malloc(4 * len + /* Allocate space based on worst-case */1);
		if (!escaped) {
			return ((Object)0);
		} 
		e = escaped;
		for (s = str; (c = s) != (byte)'\0'; s++) {
			if (c == (byte)'\n') {
				.strcpy(e, "\\n");
				e += 2;
			}  else if (c == (byte)'\r') {
				.strcpy(e, "\\r");
				e += 2;
			}  else if (c == (byte)'\t') {
				.strcpy(e, "\\t");
				e += 2;
			}  else if (c == (byte)'\\') {
				.strcpy(e, "\\\\");
				e += 2;
			}  else if (c == (byte)'"') {
				.strcpy(e, "\\\"");
				e += 2;
			}  else if (!.isprint(c)) {
				ModernizedCProgram.curl_msnprintf(e, 5, "\\%03o", (int)c);
				e += 4;
			} else {
					e++ = c;
			} 
		}
		e = (byte)'\0';
		return escaped;
	}
	/* setopt wrapper for enum types */
	public static  tool_setopt_enum(Object curl, Object config, Object name,  tag, Object nvlist, long lval) {
		CURLcode ret = .CURLE_OK;
		bool skip = 0;
		ret = ;
		if (!lval) {
			skip = 1;
		} 
		if (config.getLibcurl() && !skip && !ret) {
			NameValue nv = ((Object)/* we only use this for real if --libcurl was used */0);
			for (nv = nvlist; nv.getName(); nv++) {
				if (nv.getValue() == /* found it */lval) {
					break;
				} 
			}
			if (!nv.getName()) {
				do {
					ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_easy_setopt(hnd, %s, %ldL);", name, lval);
					if (ret) {
						;
					} 
				} while (0);
			} else {
					do {
						ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_easy_setopt(hnd, %s, (long)%s);", name, nv.getName());
						if (ret) {
							;
						} 
					} while (0);
			} 
		} 
	}
	/* setopt wrapper for flags */
	public static  tool_setopt_flags(Object curl, Object config, Object name,  tag, Object nvlist, long lval) {
		CURLcode ret = .CURLE_OK;
		bool skip = 0;
		ret = ;
		if (!lval) {
			skip = 1;
		} 
		if (config.getLibcurl() && !skip && !ret) {
			byte[] preamble = new byte[/* we only use this for real if --libcurl was used *//* should accommodate any symbol name */80];
			long rest = /* bits not handled yet */lval;
			NameValue nv = ((Object)0);
			ModernizedCProgram.curl_msnprintf(preamble, , "curl_easy_setopt(hnd, %s, ", name);
			for (nv = nvlist; nv.getName(); nv++) {
				if ((nv.getValue() & ~rest) == 0) {
					rest &=  ~nv.getValue();
					do {
						ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "%s(long)%s%s", preamble, nv.getName(), rest ? " |" : ");");
						if (ret) {
							;
						} 
					} while (0);
					if (!rest) {
						break;
					} 
					ModernizedCProgram.curl_msnprintf(preamble, , "%*s", .strlen(preamble), /* replace with all spaces for continuation line */"");
				} 
			}
			if (/* If any bits have no definition, output an explicit value.
			     * This could happen if new bits are defined and used
			     * but the NameValue list is not updated. */rest) {
				do {
					ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "%s%ldL);", preamble, rest);
					if (ret) {
						;
					} 
				} while (0);
			} 
		} 
	}
	/* setopt wrapper for bitmasks */
	public static  tool_setopt_bitmask(Object curl, Object config, Object name,  tag, Object nvlist, long lval) {
		CURLcode ret = .CURLE_OK;
		bool skip = 0;
		ret = ;
		if (!lval) {
			skip = 1;
		} 
		if (config.getLibcurl() && !skip && !ret) {
			byte[] preamble = new byte[/* we only use this for real if --libcurl was used */80];
			long rest = (long)lval;
			NameValueUnsigned nv = ((Object)0);
			ModernizedCProgram.curl_msnprintf(preamble, , "curl_easy_setopt(hnd, %s, ", name);
			for (nv = nvlist; nv.getName(); nv++) {
				if ((nv.getValue() & ~rest) == 0) {
					rest &=  ~nv.getValue();
					do {
						ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "%s(long)%s%s", preamble, nv.getName(), rest ? " |" : ");");
						if (ret) {
							;
						} 
					} while (0);
					if (!rest) {
						break;
					} 
					ModernizedCProgram.curl_msnprintf(preamble, , "%*s", .strlen(preamble), /* replace with all spaces for continuation line */"");
				} 
			}
			if (/* If any bits have no definition, output an explicit value.
			     * This could happen if new bits are defined and used
			     * but the NameValue list is not updated. */rest) {
				do {
					ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "%s%luUL);", preamble, rest);
					if (ret) {
						;
					} 
				} while (0);
			} 
		} 
	}
	/* Generate code for a struct curl_slist. */
	public static  libcurl_generate_slist(Object slist, Object slistno) {
		CURLcode ret = .CURLE_OK;
		byte escaped = ((Object)0);
		slistno = ++/* May need several slist variables, so invent name */ModernizedCProgram.easysrc_slist_count;
		do {
			ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_decl, "struct curl_slist *slist%d;", slistno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_data, "slist%d = NULL;", slistno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_clean, "curl_slist_free_all(slist%d);", slistno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_clean, "slist%d = NULL;", slistno);
			if (ret) {
				;
			} 
		} while (0);
		for (; slist; slist = slist.getNext()) {
			do {
				.free((escaped));
				(escaped) = ((Object)0);
			} while (0);
			escaped = ModernizedCProgram.c_escape(slist.getData(), ((size_t)-1));
			if (!escaped) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			do {
				ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_data, "slist%d = curl_slist_append(slist%d, \"%s\");", slistno, slistno, escaped);
				if (ret) {
					;
				} 
			} while (0);
		}
		return ret;
	}
	/* Wrapper to generate source code for a mime part. */
	public static  libcurl_generate_mime_part(Object curl, Object config, Object part, int mimeno) {
		CURLcode ret = .CURLE_OK;
		int submimeno = 0;
		byte escaped = ((Object)0);
		byte data = ((Object)0);
		byte filename = part.getFilename();
		if (part.getPrev()) {
			ret = ModernizedCProgram.libcurl_generate_mime_part(curl, config, part.getPrev(), mimeno);
			if (ret) {
				return ret;
			} 
		} 
		do {
			ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "part%d = curl_mime_addpart(mime%d);", mimeno, mimeno);
			if (ret) {
				;
			} 
		} while (/* Create the part. */0);
		switch (part.getKind()) {
		case /* FALLTHROUGH */.TOOLMIME_STDINDATA:
				do {
					ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_mime_data_cb(part%d, -1, (curl_read_callback) fread, \\", mimeno);
					if (ret) {
						;
					} 
				} while (/* Can only be reading stdin in the current context. */0);
				do {
					ret = ModernizedCProgram.easysrc_add(ModernizedCProgram.easysrc_code, "                  (curl_seek_callback) fseek, NULL, stdin);");
					if (ret) {
						;
					} 
				} while (0);
				break;
		case .TOOLMIME_PARTS:
				ret = ModernizedCProgram.libcurl_generate_mime(curl, config, part, submimeno);
				if (!ret) {
					do {
						ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_mime_subparts(part%d, mime%d);", mimeno, submimeno);
						if (ret) {
							;
						} 
					} while (0);
					do {
						ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "mime%d = NULL;", submimeno);
						if (ret) {
							;
						} 
					} while (/* Avoid freeing in CLEAN. */0);
				} 
				break;
		case .TOOLMIME_STDIN:
				if (!filename) {
					filename = "-";
				} 
		case .TOOLMIME_FILE:
		case .TOOLMIME_DATA/* Data will be set in ASCII, thus issue a comment with clear text. *//* Our data is always textual: convert it to ASCII. */:
				data = part.getData();
				if (!ret) {
					do {
						.free((escaped));
						(escaped) = ((Object)0);
					} while (0);
					escaped = ModernizedCProgram.c_escape(data, ((size_t)-1));
					do {
						if (!escaped) {
							ret = .CURLE_OUT_OF_MEMORY;
							;
						} 
					} while (0);
					do {
						ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_mime_data(part%d, \"%s\", CURL_ZERO_TERMINATED);", mimeno, escaped);
						if (ret) {
							;
						} 
					} while (0);
				} 
				break;
		case .TOOLMIME_FILEDATA:
				escaped = ModernizedCProgram.c_escape(part.getData(), ((size_t)-1));
				do {
					if (!escaped) {
						ret = .CURLE_OUT_OF_MEMORY;
						;
					} 
				} while (0);
				do {
					ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_mime_filedata(part%d, \"%s\");", mimeno, escaped);
					if (ret) {
						;
					} 
				} while (0);
				if (part.getKind() == .TOOLMIME_FILEDATA && !filename) {
					do {
						ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_mime_filename(part%d, NULL);", mimeno);
						if (ret) {
							;
						} 
					} while (0);
				} 
				break;
		default:
				break;
		}
		if (!ret && part.getEncoder()) {
			do {
				.free((escaped));
				(escaped) = ((Object)0);
			} while (0);
			escaped = ModernizedCProgram.c_escape(part.getEncoder(), ((size_t)-1));
			do {
				if (!escaped) {
					ret = .CURLE_OUT_OF_MEMORY;
					;
				} 
			} while (0);
			do {
				ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_mime_encoder(part%d, \"%s\");", mimeno, escaped);
				if (ret) {
					;
				} 
			} while (0);
		} 
		if (!ret && filename) {
			do {
				.free((escaped));
				(escaped) = ((Object)0);
			} while (0);
			escaped = ModernizedCProgram.c_escape(filename, ((size_t)-1));
			do {
				if (!escaped) {
					ret = .CURLE_OUT_OF_MEMORY;
					;
				} 
			} while (0);
			do {
				ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_mime_filename(part%d, \"%s\");", mimeno, escaped);
				if (ret) {
					;
				} 
			} while (0);
		} 
		if (!ret && part.getName()) {
			do {
				.free((escaped));
				(escaped) = ((Object)0);
			} while (0);
			escaped = ModernizedCProgram.c_escape(part.getName(), ((size_t)-1));
			do {
				if (!escaped) {
					ret = .CURLE_OUT_OF_MEMORY;
					;
				} 
			} while (0);
			do {
				ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_mime_name(part%d, \"%s\");", mimeno, escaped);
				if (ret) {
					;
				} 
			} while (0);
		} 
		if (!ret && part.getType()) {
			do {
				.free((escaped));
				(escaped) = ((Object)0);
			} while (0);
			escaped = ModernizedCProgram.c_escape(part.getType(), ((size_t)-1));
			do {
				if (!escaped) {
					ret = .CURLE_OUT_OF_MEMORY;
					;
				} 
			} while (0);
			do {
				ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_mime_type(part%d, \"%s\");", mimeno, escaped);
				if (ret) {
					;
				} 
			} while (0);
		} 
		if (!ret && part.getHeaders()) {
			int slistno;
			ret = ModernizedCProgram.libcurl_generate_slist(part.getHeaders(), slistno);
			if (!ret) {
				do {
					ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_mime_headers(part%d, slist%d, 1);", mimeno, slistno);
					if (ret) {
						;
					} 
				} while (0);
				do {
					ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "slist%d = NULL;", slistno);
					if (ret) {
						;
					} 
				} while (/* Prevent CLEANing. */0);
			} 
		} 
		return ret;
	}
	/* Wrapper to generate source code for a mime structure. */
	public static  libcurl_generate_mime(Object curl, Object config, Object toolmime, Object mimeno) {
		CURLcode ret = .CURLE_OK;
		mimeno = ++/* May need several mime variables, so invent name. */ModernizedCProgram.easysrc_mime_count;
		do {
			ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_decl, "curl_mime *mime%d;", mimeno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_data, "mime%d = NULL;", mimeno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "mime%d = curl_mime_init(hnd);", mimeno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_clean, "curl_mime_free(mime%d);", mimeno);
			if (ret) {
				;
			} 
		} while (0);
		do {
			ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_clean, "mime%d = NULL;", mimeno);
			if (ret) {
				;
			} 
		} while (0);
		if (toolmime.getSubparts()) {
			do {
				ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_decl, "curl_mimepart *part%d;", mimeno);
				if (ret) {
					;
				} 
			} while (0);
			ret = ModernizedCProgram.libcurl_generate_mime_part(curl, config, toolmime.getSubparts(), mimeno);
		} 
	}
	/* setopt wrapper for CURLOPT_MIMEPOST */
	public static  tool_setopt_mimepost(Object curl, Object config, Object name,  tag, Object mimepost) {
		CURLcode ret = ;
		int mimeno = 0;
		if (!ret && config.getLibcurl()) {
			ret = ModernizedCProgram.libcurl_generate_mime(curl, config, config.getCurrent().getMimeroot(), mimeno);
			if (!ret) {
				do {
					ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_easy_setopt(hnd, %s, mime%d);", name, mimeno);
					if (ret) {
						;
					} 
				} while (0);
			} 
		} 
	}
	/* setopt wrapper for curl_slist options */
	public static  tool_setopt_slist(Object curl, Object config, Object name,  tag, Object list) {
		CURLcode ret = .CURLE_OK;
		ret = ;
		if (config.getLibcurl() && list && !ret) {
			int i;
			ret = ModernizedCProgram.libcurl_generate_slist(list, i);
			if (!ret) {
				do {
					ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_easy_setopt(hnd, %s, slist%d);", name, i);
					if (ret) {
						;
					} 
				} while (0);
			} 
		} 
	}
	/* generic setopt wrapper for all other options.
	 * Some type information is encoded in the tag value. */
	public static  tool_setopt(Object curl,  str, Object config, Object name,  tag) {
		va_list arg = new va_list();
		byte[] buf = new byte[256];
		byte value = ((Object)0);
		bool remark = 0;
		bool skip = 0;
		bool escape = 0;
		byte escaped = ((Object)0);
		CURLcode ret = .CURLE_OK;
		.__builtin_va_start(arg, tag);
		if (tag < 10000) {
			long lval = (int)/* Value is expected to be a long */arg;
			long defval = -1024;
			NameValue nv = ((Object)0);
			for (nv = ModernizedCProgram.setopt_nv_CURLNONZERODEFAULTS; nv.getName(); nv++) {
				if (!.strcmp(name, nv.getName())) {
					defval = nv.getValue();
					break;
				} 
			}
			ModernizedCProgram.curl_msnprintf(buf, , "%ldL", lval);
			value = buf;
			ret = ;
			if (lval == defval) {
				skip = 1;
			} 
		}  else if (tag < 30000) {
			Object pval = (int)/* Value is some sort of object pointer */arg;
			if (tag >= /* function pointers are never printable */20000) {
				if (pval) {
					value = "functionpointer";
					remark = 1;
				} else {
						skip = 1;
				} 
			}  else if (pval && str) {
				value = (byte)pval;
				escape = 1;
			}  else if (pval) {
				value = "objectpointer";
				remark = 1;
			} else {
					skip = 1;
			} 
			ret = ;
		} else {
				curl_off_t oval = (int)/* Value is expected to be curl_off_t */arg;
				ModernizedCProgram.curl_msnprintf(buf, , "(curl_off_t)%I64d", oval);
				value = buf;
				ret = ;
				if (!oval) {
					skip = 1;
				} 
		} 
		.__builtin_va_end(arg);
		if (config.getLibcurl() && !skip && !ret/* we only use this for real if --libcurl was used */) {
			if (remark) {
				do {
					ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_toohard, "%s set to a %s", name, value);
					if (ret) {
						;
					} 
				} while (0);
			} else {
					if (escape) {
						escaped = ModernizedCProgram.c_escape(value, ((size_t)-1));
						do {
							if (!escaped) {
								ret = .CURLE_OUT_OF_MEMORY;
								;
							} 
						} while (0);
						do {
							ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_easy_setopt(hnd, %s, \"%s\");", name, escaped);
							if (ret) {
								;
							} 
						} while (0);
					} else {
							do {
								ret = ModernizedCProgram.easysrc_addf(ModernizedCProgram.easysrc_code, "curl_easy_setopt(hnd, %s, %s);", name, value);
								if (ret) {
									;
								} 
							} while (0);
					} 
			} 
		} 
		return ret/* CURL_DISABLE_LIBCURL_OPTION */;
	}
	/* CURL_DISABLE_LIBCURL_OPTION */
	/*
	 * tool_setopt_skip() allows the curl tool code to avoid setopt options that
	 * are explicitly disabled in the build.
	 */
	public static  tool_setopt_skip( tag) {
		(Object)tag;
		return 0;
	}
	public static int Curl_isspace(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & (1 << 3));
	}
	public static int Curl_isdigit(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & (1 << 2));
	}
	public static int Curl_isalnum(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 2) | (1 << 0) | (1 << 1)));
	}
	public static int Curl_isxdigit(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 2) | (1 << 6)));
	}
	public static int Curl_isgraph(int c) {
		if ((c < 0) || (c >= -1024) || (c == (byte)' ')) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 2) | (1 << 6) | (1 << 0) | (1 << 1) | (1 << 4) | (1 << 3)));
	}
	public static int Curl_isprint(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 2) | (1 << 6) | (1 << 0) | (1 << 1) | (1 << 4) | (1 << 3)));
	}
	public static int Curl_isalpha(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 0) | (1 << 1)));
	}
	public static int Curl_isupper(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 0)));
	}
	public static int Curl_islower(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 1)));
	}
	public static int Curl_iscntrl(int c) {
		if ((c < 0) || (c >= -1024)) {
			return 0;
		} 
		return (ModernizedCProgram.ascii[c] & ((1 << 5/* !CURL_DOES_CONVERSIONS */)));
	}
	public static Object execpath(Object filename) {
		byte[] filebuffer = new byte[512/* Get the filename of our executable. GetModuleFileName is already declared
		   * via inclusions done in setup header file.  We assume that we are using
		   * the ASCII version here.
		   */];
		long len = .GetModuleFileNameA(0, filebuffer, );
		if (len > 0 && len < ) {
			byte lastdirchar = .strrchr(filebuffer, /* We got a valid filename - get the directory part */(byte)'\\');
			if (lastdirchar) {
				size_t remaining = new size_t();
				lastdirchar = 0;
				remaining =  - .strlen(/* If we have enough space, build the RC filename */filebuffer);
				if (.strlen(filename) < remaining - 1) {
					ModernizedCProgram.curl_msnprintf(lastdirchar, remaining, "%s%s", "\\", filename);
					return .fopen(filebuffer, "rt");
				} 
			} 
		} 
		return ((Object)0);
	}
	/* return 0 on everything-is-fine, and non-zero otherwise */
	public static int parseconfig(Object filename, Object global) {
		FILE file = ((Object)0);
		bool usedarg = 0;
		int rc = 0;
		OperationConfig operation = global.getFirst();
		byte pathalloc = ((Object)0);
		if (!filename || !filename/* NULL or no file name attempts to load .curlrc from the homedir! */) {
			byte home = ModernizedCProgram.homedir();
			if (/* out of memory *//* Windows */home) {
				int i = 0;
				byte prefix = (byte)'.';
				do {
					pathalloc = ModernizedCProgram.curl_maprintf("%s%s%ccurlrc", home, "\\", /* check for .curlrc then _curlrc in the home dir */prefix);
					if (!pathalloc) {
						.free(home);
						return /* out of memory */1;
					} 
					file = .fopen(pathalloc, /* Check if the file exists - if not, try _curlrc */"rt");
					if (file) {
						filename = pathalloc;
						break;
					} 
					prefix = (byte)'_';
				} while (++i < 2);
			} 
			if (!filename) {
				file = ModernizedCProgram.execpath(/* check for .curlrc then _curlrc in the dir of the executable */".curlrc");
				if (!file) {
					file = ModernizedCProgram.execpath("_curlrc");
				} 
			} 
			do {
				.free((home));
				(home) = ((Object)0);
			} while (/* we've used it, now free it */0);
		} 
		if (!file && /* no need to fopen() again */filename) {
			if (.strcmp(filename, "-")) {
				file = .fopen(filename, "rt");
			} else {
					file = (_iob[0]);
			} 
		} 
		if (file) {
			byte line;
			byte aline;
			byte option;
			byte param;
			int lineno = 0;
			bool dashed_option = new bool();
			while (((Object)0) != (aline = ModernizedCProgram.my_get_line(file))) {
				int res;
				bool alloced_param = 0;
				lineno++;
				line = aline;
				while (line && (ModernizedCProgram.Curl_isspace((int)((byte)/* line with # in the first non-blank column is a comment! */line)))) {
					line++;
				}
				switch (line) {
				case (byte)'/':
				case (byte)'#':
				case (byte)'\r':
				case (byte)'\n':
				case (byte)'*':
				case (byte)'\0':
						do {
							.free((aline));
							(aline) = ((Object)0);
						} while (0);
						continue;
				}
				option = /* the option keywords starts here */line;
				dashed_option = option[0] == (byte)'-' ? 1 : /* the option starts with a dash? */0;
				while (line && !(ModernizedCProgram.Curl_isspace((int)((byte)line))) && !(!dashed_option && (((line) == (byte)'=') || ((line) == (byte)':')))) {
					line/* ... and has ended here */++;
				}
				if (line) {
					line++ = /* zero terminate, we have a local copy of the data */(byte)'\0';
				} 
				while (line && ((ModernizedCProgram.Curl_isspace((int)((byte)line))) || (!dashed_option && (((line) == (byte)'=') || ((line) == /* pass spaces and separator(s) */(byte)':'))))) {
					line++;
				}
				if (line == /* the parameter starts here (unless quoted) */(byte)'\"') {
					/* quoted parameter, do the quote dance */line++;
					param = .malloc(.strlen(line) + /* parameter */1);
					if (!param) {
						do {
							.free((aline));
							(aline) = ((Object)0);
						} while (/* out of memory */0);
						rc = 1;
						break;
					} 
					alloced_param = 1;
					(Object)ModernizedCProgram.unslashquote(line, param);
				} else {
						param = /* parameter starts here */line;
						while (line && !(ModernizedCProgram.Curl_isspace((int)((byte)line)))) {
							line++;
						}
						if (line) {
							line = /* zero terminate */(byte)'\0';
							/* to detect mistakes better, see if there's data following */line++;
							while (line && (ModernizedCProgram.Curl_isspace((int)((byte)/* pass all spaces */line)))) {
								line++;
							}
							switch (line) {
							case (byte)'\r':
							case (byte)'\n':
							case (byte)'\0':
							case /* comment */(byte)'#':
									break;
							default:
									ModernizedCProgram.warnf(operation.getGlobal(), "%s:%d: warning: '%s' uses unquoted white space in the line that may cause side-effects!\n", filename, lineno, option);
							}
						} 
						if (!param/* do this so getparameter can check for required parameters.
						             Otherwise it always thinks there's a parameter. */) {
							param = ((Object)0);
						} 
				} 
				res = ModernizedCProgram.getparameter(option, param, usedarg, global, operation);
				if (!res && param && param && !usedarg) {
					res = /* we passed in a parameter that wasn't used! */.PARAM_GOT_EXTRA_PARAMETER;
				} 
				if (res == .PARAM_NEXT_OPERATION) {
					if (operation.getUrl_list() && operation.getUrl_list().getUrl()) {
						operation.setNext(.malloc(/* Allocate the next config */));
						if (operation.getNext()) {
							ModernizedCProgram.config_init(operation.getNext());
							operation.getNext().setGlobal(/* Set the global config pointer */global);
							global.setLast(operation.getNext());
							operation.getNext().setPrev(/* Move onto the new config */operation);
							operation = operation.getNext();
						} else {
								res = .PARAM_NO_MEM;
						} 
					} 
				} 
				if (res != .PARAM_OK && res != .PARAM_NEXT_OPERATION) {
					if (!.strcmp(filename, /* the help request isn't really an error */"-")) {
						filename = "<stdin>";
					} 
					if (res != .PARAM_HELP_REQUESTED && res != .PARAM_MANUAL_REQUESTED && res != .PARAM_VERSION_INFO_REQUESTED && res != .PARAM_ENGINES_REQUESTED) {
						byte reason = ModernizedCProgram.param2text(res);
						ModernizedCProgram.warnf(operation.getGlobal(), "%s:%d: warning: '%s' %s\n", filename, lineno, option, reason);
					} 
				} 
				if (alloced_param) {
					do {
						.free((param));
						(param) = ((Object)0);
					} while (0);
				} 
				do {
					.free((aline));
					(aline) = ((Object)0);
				} while (0);
			}
			if (file != (_iob[0])) {
				.fclose(file);
			} 
		} else {
				rc = /* couldn't open the file */1;
		} 
		.free(pathalloc);
		return rc/*
		 * Copies the string from line to the buffer at param, unquoting
		 * backslash-quoted characters and NUL-terminating the output string.
		 * Stops at the first non-backslash-quoted double quote character or the
		 * end of the input string. param must be at least as long as the input
		 * string.  Returns the pointer after the last handled input character.
		 */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/* only acknowledge colon or equals as separators if the option was not
	   specified with an initial dash! */
	public static Object unslashquote(Object line, Object param) {
		while (line && (line != (byte)'\"')) {
			if (line == (byte)'\\') {
				byte out;
				line++;
				switch (out = /* default is to output the letter after the backslash */line) {
				case (byte)'v':
						out = (byte)'\v';
						break;
				case (byte)'t':
						out = (byte)'\t';
						break;
				case (byte)'\0':
						continue;
				case (byte)'n':
						out = (byte)'\n';
						break;
				case (byte)'r':
						out = (byte)'\r';
						break;
				}
				param++ = out;
				line++;
			} else {
					param++ = line++;
			} 
		}
		param = /* always zero terminate */(byte)'\0';
		return line/*
		 * Reads a line from the given file, ensuring is NUL terminated.
		 * The pointer must be freed by the caller.
		 * NULL is returned on an out of memory condition.
		 */;
	}
	public static Object my_get_line(Object fp) {
		byte[] buf = new byte[4096];
		byte nl = ((Object)0);
		byte line = ((Object)0);
		do {
			if (((Object)0) == .fgets(buf, , fp)) {
				break;
			} 
			if (!line) {
				line = .strdup(buf);
				if (!line) {
					return ((Object)0);
				} 
			} else {
					byte ptr;
					size_t linelen = .strlen(line);
					ptr = .realloc(line, linelen + .strlen(buf) + 1);
					if (!ptr) {
						do {
							.free((line));
							(line) = ((Object)0);
						} while (0);
						return ((Object)0);
					} 
					line = ptr;
					.strcpy(line[linelen], buf);
			} 
			nl = .strchr(line, (byte)'\n');
		} while (!nl);
		if (nl) {
			nl = (byte)'\0';
		} 
		return line;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/* !checksrc! disable SPACEBEFOREPAREN 1 */
	public static Object Curl_thread_create(Object func, Object arg) {
		long curl_win_thread_handle_t;
		HANDLE t = new HANDLE();
		curl_win_thread_handle_t thread_handle = new curl_win_thread_handle_t();
		thread_handle = ._beginthreadex(((Object)0), 0, func, arg, 0, ((Object)0));
		t = (HANDLE)thread_handle;
		if ((t == 0) || (t == ((HANDLE)(LONG_PTR)(true)))) {
			return (HANDLE)0;
		} 
		return t;
	}
	public static void Curl_thread_destroy(Object hnd) {
		.CloseHandle(hnd);
	}
	public static int Curl_thread_join(Object hnd) {
		int ret = (.WaitForSingleObject(hnd, -1024) == 0);
		ModernizedCProgram.Curl_thread_destroy(hnd);
		hnd = (HANDLE)0;
		return ret/* USE_THREADS_* */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	public static void show_dir_errno(Object errors, Object name) {
		switch ((._errno())) {
		case -1024:
				ModernizedCProgram.curl_mfprintf(errors, "Cannot create directory %s because you exceeded your quota.\n", name);
				break;
		case 13:
				ModernizedCProgram.curl_mfprintf(errors, "You don't have permission to create %s.\n", name);
				break;
		case 28:
				ModernizedCProgram.curl_mfprintf(errors, "No space left on the file system that will contain the directory %s.\n", name);
				break;
		case 38:
				ModernizedCProgram.curl_mfprintf(errors, "The directory name %s is too long.\n", name);
				break;
		case 30:
				ModernizedCProgram.curl_mfprintf(errors, "%s resides on a read-only file system.\n", name);
				break;
		default:
				ModernizedCProgram.curl_mfprintf(errors, "Error creating directory %s.\n", name);
				break;
		}
	}
	/* systems that may use either or when specifying a path */
	public static  create_dir_hierarchy(Object outfile, Object errors) {
		byte tempdir;
		byte tempdir2;
		byte outdup;
		byte dirbuildup;
		CURLcode result = .CURLE_OK;
		size_t outlen = new size_t();
		outlen = .strlen(outfile);
		outdup = .strdup(outfile);
		if (!outdup) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		dirbuildup = .malloc(outlen + 1);
		if (!dirbuildup) {
			do {
				.free((outdup));
				(outdup) = ((Object)0);
			} while (0);
			return .CURLE_OUT_OF_MEMORY;
		} 
		dirbuildup[0] = (byte)'\0';
		tempdir = .strtok(outdup, /* Allow strtok() here since this isn't used threaded *//* !checksrc! disable BANNEDFUNC 2 */"\\/");
		while (tempdir != ((Object)0)) {
			tempdir2 = .strtok(((Object)0), "\\/"/* since strtok returns a token for the last word even
			       if not ending with DIR_CHAR, we need to prune it */);
			if (tempdir2 != ((Object)0)) {
				size_t dlen = .strlen(dirbuildup);
				if (dlen) {
					ModernizedCProgram.curl_msnprintf(dirbuildup[dlen], outlen - dlen, "%s%s", "\\", tempdir);
				} else {
						if (outdup == tempdir) {
							.strcpy(dirbuildup, /* the output string doesn't start with a separator */tempdir);
						} else {
								ModernizedCProgram.curl_msnprintf(dirbuildup, outlen, "%s%s", "\\", tempdir);
						} 
				} 
				if ((-1 == .UNRECOGNIZEDFUNCTIONNAME((dirbuildup))) && ((._errno()) != 17)) {
					ModernizedCProgram.show_dir_errno(errors, dirbuildup);
					result = .CURLE_WRITE_ERROR;
					break;
				} 
			} 
			tempdir = tempdir2;
		}
		do {
			.free((dirbuildup));
			(dirbuildup) = ((Object)0);
		} while (0);
		do {
			.free((outdup));
			(outdup) = ((Object)0);
		} while (0);
		return result;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* keep this as LAST include */
	public static void config_init(Object config) {
		.memset(config, 0, );
		config.setPostfieldsize(-1);
		config.setUse_httpget(0);
		config.setCreate_dirs(0);
		config.setMaxredirs(-1024);
		config.setProto((~0));
		config.setProto_present(0);
		config.setProto_redir((~/* All except FILE, SCP and SMB */0) & ~((1 << 10) | (1 << 4) | (1 << 26) | (1 << 27)));
		config.setProto_redir_present(0);
		config.setProto_default(((Object)0));
		config.setTcp_nodelay(/* enabled by default */1);
		config.setHappy_eyeballs_timeout_ms(-1024);
		config.setHttp09_allowed(0);
	}
	public static void free_config_fields(Object config) {
		getout urlnode = new getout();
		do {
			.free((config.getRandom_file()));
			(config.getRandom_file()) = ((Object)0);
		} while (0);
		do {
			.free((config.getEgd_file()));
			(config.getEgd_file()) = ((Object)0);
		} while (0);
		do {
			.free((config.getUseragent()));
			(config.getUseragent()) = ((Object)0);
		} while (0);
		do {
			.free((config.getAltsvc()));
			(config.getAltsvc()) = ((Object)0);
		} while (0);
		do {
			.free((config.getCookie()));
			(config.getCookie()) = ((Object)0);
		} while (0);
		do {
			.free((config.getCookiejar()));
			(config.getCookiejar()) = ((Object)0);
		} while (0);
		do {
			.free((config.getCookiefile()));
			(config.getCookiefile()) = ((Object)0);
		} while (0);
		do {
			.free((config.getPostfields()));
			(config.getPostfields()) = ((Object)0);
		} while (0);
		do {
			.free((config.getReferer()));
			(config.getReferer()) = ((Object)0);
		} while (0);
		do {
			.free((config.getHeaderfile()));
			(config.getHeaderfile()) = ((Object)0);
		} while (0);
		do {
			.free((config.getFtpport()));
			(config.getFtpport()) = ((Object)0);
		} while (0);
		do {
			.free((config.getIface()));
			(config.getIface()) = ((Object)0);
		} while (0);
		do {
			.free((config.getRange()));
			(config.getRange()) = ((Object)0);
		} while (0);
		do {
			.free((config.getUserpwd()));
			(config.getUserpwd()) = ((Object)0);
		} while (0);
		do {
			.free((config.getTls_username()));
			(config.getTls_username()) = ((Object)0);
		} while (0);
		do {
			.free((config.getTls_password()));
			(config.getTls_password()) = ((Object)0);
		} while (0);
		do {
			.free((config.getTls_authtype()));
			(config.getTls_authtype()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_tls_username()));
			(config.getProxy_tls_username()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_tls_password()));
			(config.getProxy_tls_password()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_tls_authtype()));
			(config.getProxy_tls_authtype()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxyuserpwd()));
			(config.getProxyuserpwd()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy()));
			(config.getProxy()) = ((Object)0);
		} while (0);
		do {
			.free((config.getDns_ipv6_addr()));
			(config.getDns_ipv6_addr()) = ((Object)0);
		} while (0);
		do {
			.free((config.getDns_ipv4_addr()));
			(config.getDns_ipv4_addr()) = ((Object)0);
		} while (0);
		do {
			.free((config.getDns_interface()));
			(config.getDns_interface()) = ((Object)0);
		} while (0);
		do {
			.free((config.getDns_servers()));
			(config.getDns_servers()) = ((Object)0);
		} while (0);
		do {
			.free((config.getNoproxy()));
			(config.getNoproxy()) = ((Object)0);
		} while (0);
		do {
			.free((config.getMail_from()));
			(config.getMail_from()) = ((Object)0);
		} while (0);
		ModernizedCProgram.curl_slist_free_all(config.getMail_rcpt());
		do {
			.free((config.getMail_auth()));
			(config.getMail_auth()) = ((Object)0);
		} while (0);
		do {
			.free((config.getNetrc_file()));
			(config.getNetrc_file()) = ((Object)0);
		} while (0);
		urlnode = config.getUrl_list();
		while (urlnode) {
			getout next = urlnode.getNext();
			do {
				.free((urlnode.getUrl()));
				(urlnode.getUrl()) = ((Object)0);
			} while (0);
			do {
				.free((urlnode.getOutfile()));
				(urlnode.getOutfile()) = ((Object)0);
			} while (0);
			do {
				.free((urlnode.getInfile()));
				(urlnode.getInfile()) = ((Object)0);
			} while (0);
			do {
				.free((urlnode));
				(urlnode) = ((Object)0);
			} while (0);
			urlnode = next;
		}
		config.setUrl_list(((Object)0));
		config.setUrl_last(((Object)0));
		config.setUrl_get(((Object)0));
		config.setUrl_out(((Object)0));
		do {
			.free((config.getDoh_url()));
			(config.getDoh_url()) = ((Object)0);
		} while (0);
		do {
			.free((config.getCipher_list()));
			(config.getCipher_list()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_cipher_list()));
			(config.getProxy_cipher_list()) = ((Object)0);
		} while (0);
		do {
			.free((config.getCert()));
			(config.getCert()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_cert()));
			(config.getProxy_cert()) = ((Object)0);
		} while (0);
		do {
			.free((config.getCert_type()));
			(config.getCert_type()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_cert_type()));
			(config.getProxy_cert_type()) = ((Object)0);
		} while (0);
		do {
			.free((config.getCacert()));
			(config.getCacert()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_cacert()));
			(config.getProxy_cacert()) = ((Object)0);
		} while (0);
		do {
			.free((config.getCapath()));
			(config.getCapath()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_capath()));
			(config.getProxy_capath()) = ((Object)0);
		} while (0);
		do {
			.free((config.getCrlfile()));
			(config.getCrlfile()) = ((Object)0);
		} while (0);
		do {
			.free((config.getPinnedpubkey()));
			(config.getPinnedpubkey()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_pinnedpubkey()));
			(config.getProxy_pinnedpubkey()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_crlfile()));
			(config.getProxy_crlfile()) = ((Object)0);
		} while (0);
		do {
			.free((config.getKey()));
			(config.getKey()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_key()));
			(config.getProxy_key()) = ((Object)0);
		} while (0);
		do {
			.free((config.getKey_type()));
			(config.getKey_type()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_key_type()));
			(config.getProxy_key_type()) = ((Object)0);
		} while (0);
		do {
			.free((config.getKey_passwd()));
			(config.getKey_passwd()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_key_passwd()));
			(config.getProxy_key_passwd()) = ((Object)0);
		} while (0);
		do {
			.free((config.getPubkey()));
			(config.getPubkey()) = ((Object)0);
		} while (0);
		do {
			.free((config.getHostpubmd5()));
			(config.getHostpubmd5()) = ((Object)0);
		} while (0);
		do {
			.free((config.getEngine()));
			(config.getEngine()) = ((Object)0);
		} while (0);
		do {
			.free((config.getRequest_target()));
			(config.getRequest_target()) = ((Object)0);
		} while (0);
		do {
			.free((config.getCustomrequest()));
			(config.getCustomrequest()) = ((Object)0);
		} while (0);
		do {
			.free((config.getKrblevel()));
			(config.getKrblevel()) = ((Object)0);
		} while (0);
		do {
			.free((config.getOauth_bearer()));
			(config.getOauth_bearer()) = ((Object)0);
		} while (0);
		do {
			.free((config.getSasl_authzid()));
			(config.getSasl_authzid()) = ((Object)0);
		} while (0);
		do {
			.free((config.getUnix_socket_path()));
			(config.getUnix_socket_path()) = ((Object)0);
		} while (0);
		do {
			.free((config.getWriteout()));
			(config.getWriteout()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProto_default()));
			(config.getProto_default()) = ((Object)0);
		} while (0);
		ModernizedCProgram.curl_slist_free_all(config.getQuote());
		ModernizedCProgram.curl_slist_free_all(config.getPostquote());
		ModernizedCProgram.curl_slist_free_all(config.getPrequote());
		ModernizedCProgram.curl_slist_free_all(config.getHeaders());
		ModernizedCProgram.curl_slist_free_all(config.getProxyheaders());
		ModernizedCProgram.curl_mime_free(config.getMimepost());
		config.setMimepost(((Object)0));
		ModernizedCProgram.tool_mime_free(config.getMimeroot());
		config.setMimeroot(((Object)0));
		config.setMimecurrent(((Object)0));
		ModernizedCProgram.curl_slist_free_all(config.getTelnet_options());
		ModernizedCProgram.curl_slist_free_all(config.getResolve());
		ModernizedCProgram.curl_slist_free_all(config.getConnect_to());
		do {
			.free((config.getPreproxy()));
			(config.getPreproxy()) = ((Object)0);
		} while (0);
		do {
			.free((config.getProxy_service_name()));
			(config.getProxy_service_name()) = ((Object)0);
		} while (0);
		do {
			.free((config.getService_name()));
			(config.getService_name()) = ((Object)0);
		} while (0);
		do {
			.free((config.getFtp_account()));
			(config.getFtp_account()) = ((Object)0);
		} while (0);
		do {
			.free((config.getFtp_alternative_to_user()));
			(config.getFtp_alternative_to_user()) = ((Object)0);
		} while (0);
	}
	public static void config_free(Object config) {
		OperationConfig last = config;
		while (/* Free each of the structures in reverse order */last) {
			OperationConfig prev = last.getPrev();
			ModernizedCProgram.free_config_fields(last);
			.free(last);
			last = prev;
		}
	}
	/* Curl_win32_init() performs win32 global initialization */
	public static  Curl_win32_init(long flags) {
		Object generatedWVersion = wsaData.getWVersion();
		if (flags & (1 << 1)) {
			WORD wVersionRequested = new WORD();
			WSADATA wsaData = new WSADATA();
			int res;
			wVersionRequested = ((WORD)(((BYTE)(true)) | (((WORD)((BYTE)(true))) << 8)));
			res = .WSAStartup(wVersionRequested, wsaData);
			if (res != 0/* Tell the user that we couldn't find a usable */) {
				return /* winsock.dll.     */.CURLE_FAILED_INIT/* Confirm that the Windows Sockets DLL supports what we need.*//* Note that if the DLL supports versions greater */;
			} 
			if (((BYTE)(generatedWVersion)) != ((BYTE)(/* than wVersionRequested, it will still return *//* wVersionRequested in wVersion. wHighVersion contains the *//* highest supported version. */wVersionRequested)) || ((BYTE)(((WORD)(generatedWVersion) >> 8) & -1024)) != ((BYTE)(((WORD)(wVersionRequested) >> 8) & -1024/* Tell the user that we couldn't find a usable */))) {
				.WSACleanup();
				return .CURLE_FAILED_INIT/* The Windows Sockets DLL is acceptable. Proceed. *//* CURL_GLOBAL_WIN32 */;
			} 
		} 
		ModernizedCProgram.s_hIpHlpApiDll = ModernizedCProgram.Curl_load_library("iphlpapi.dll");
		if (ModernizedCProgram.s_hIpHlpApiDll/* Get the address of the if_nametoindex function */) {
			IF_NAMETOINDEX_FN pIfNameToIndex = (IF_NAMETOINDEX_FN)(Object)((.GetProcAddress(ModernizedCProgram.s_hIpHlpApiDll, "if_nametoindex")));
			if (pIfNameToIndex) {
				ModernizedCProgram.Curl_if_nametoindex = pIfNameToIndex;
			} 
		} 
		if (ModernizedCProgram.Curl_verify_windows_version(6, 0, .PLATFORM_WINNT, .VERSION_GREATER_THAN_EQUAL)) {
			ModernizedCProgram.Curl_isVistaOrGreater = 1;
			.QueryPerformanceFrequency(ModernizedCProgram.Curl_freq);
		} else {
				ModernizedCProgram.Curl_isVistaOrGreater = 0;
		} 
		return .CURLE_OK;
	}
	/* CURL_GLOBAL_WIN32 controls the *optional* part of the initialization which
	     is just for Winsock at the moment. Any required win32 initialization
	     should take place after this block. */
	/* Curl_win32_cleanup() is the opposite of Curl_win32_init() */
	public static void Curl_win32_cleanup(long init_flags) {
		if (ModernizedCProgram.s_hIpHlpApiDll) {
			.FreeLibrary(ModernizedCProgram.s_hIpHlpApiDll);
			ModernizedCProgram.s_hIpHlpApiDll = ((Object)0);
			ModernizedCProgram.Curl_if_nametoindex = ((Object)0);
		} 
		if (init_flags & (1 << 1)) {
			.WSACleanup();
		} 
	}
	/*
	 * Curl_verify_windows_version()
	 *
	 * This is used to verify if we are running on a specific windows version.
	 *
	 * Parameters:
	 *
	 * majorVersion [in] - The major version number.
	 * minorVersion [in] - The minor version number.
	 * platform     [in] - The optional platform identifier.
	 * condition    [in] - The test condition used to specifier whether we are
	 *                     checking a version less then, equal to or greater than
	 *                     what is specified in the major and minor version
	 *                     numbers.
	 *
	 * Returns TRUE if matched; otherwise FALSE.
	 */
	public static  Curl_verify_windows_version(Object majorVersion, Object minorVersion, Object platform, Object condition) {
		bool matched = 0/* We have no way to determine the Windows version from Windows apps,
		     so let's assume we're running on the target Windows version. */;
		/* we're always running on PLATFORM_WINNT */OSVERSIONINFO osver = new OSVERSIONINFO();
		.memset(osver, 0, );
		osver.setDwOSVersionInfoSize();
		if (.GetVersionExA(/* Find out Windows version */osver)) {
			switch (/* Verify the Operating System version number */condition) {
			case .VERSION_GREATER_THAN:
					if (osver.getDwMajorVersion() > majorVersion || (osver.getDwMajorVersion() == majorVersion && osver.getDwMinorVersion() > minorVersion)) {
						matched = 1;
					} 
					break;
			case .VERSION_GREATER_THAN_EQUAL:
					if (osver.getDwMajorVersion() > majorVersion || (osver.getDwMajorVersion() == majorVersion && osver.getDwMinorVersion() >= minorVersion)) {
						matched = 1;
					} 
					break;
			case .VERSION_LESS_THAN:
					if (osver.getDwMajorVersion() < majorVersion || (osver.getDwMajorVersion() == majorVersion && osver.getDwMinorVersion() < minorVersion)) {
						matched = 1;
					} 
					break;
			case .VERSION_EQUAL:
					if (osver.getDwMajorVersion() == majorVersion && osver.getDwMinorVersion() == minorVersion) {
						matched = 1;
					} 
					break;
			case .VERSION_LESS_THAN_EQUAL:
					if (osver.getDwMajorVersion() < majorVersion || (osver.getDwMajorVersion() == majorVersion && osver.getDwMinorVersion() <= minorVersion)) {
						matched = 1;
					} 
					break;
			}
			if (/* Verify the platform identifier (if necessary) */matched) {
				switch (platform) {
				case .PLATFORM_WINDOWS:
						if (osver.getDwPlatformId() != 1) {
							matched = 0;
						} 
						break;
				case .PLATFORM_WINNT:
						if (osver.getDwPlatformId() != 2) {
							matched = 0;
						} 
				default:
						break;
				}
			} 
		} 
		return matched/*
		 * Curl_load_library()
		 *
		 * This is used to dynamically load DLLs using the most secure method available
		 * for the version of Windows that we are running on.
		 *
		 * Parameters:
		 *
		 * filename  [in] - The filename or full path of the DLL to load. If only the
		 *                  filename is passed then the DLL will be loaded from the
		 *                  Windows system directory.
		 *
		 * Returns the handle of the module on success; otherwise NULL.
		 */;
	}
	public static Object Curl_load_library(Object filename) {
		HMODULE hModule = ((Object)0);
		LOADLIBRARYEX_FN pLoadLibraryEx = ((Object)0);
		HMODULE hKernel32 = .GetModuleHandleA(/* Get a handle to kernel32 so we can access it's functions at runtime */"kernel32");
		if (!hKernel32) {
			return ((Object)0);
		} 
		/* Attempt to find LoadLibraryEx() which is only available on Windows 2000
		     and above */pLoadLibraryEx = (LOADLIBRARYEX_FN)(Object)((.GetProcAddress(hKernel32, "LoadLibraryExA"/* Detect if there's already a path in the filename and load the library if
		     there is. Note: Both back slashes and forward slashes have been supported
		     since the earlier days of DOS at an API level although they are not
		     supported by command prompt */)));
		if (.strpbrk(filename, "\\/")) {
			hModule = /** !checksrc! disable BANNEDFUNC 1 **/pLoadLibraryEx ? .pLoadLibraryEx(filename, ((Object)0), 8) : .LoadLibraryA(filename/* Detect if KB2533623 is installed, as LOAD_LIBARY_SEARCH_SYSTEM32 is only
			     supported on Windows Vista, Windows Server 2008, Windows 7 and Windows
			     Server 2008 R2 with this patch or natively on Windows 8 and above */);
		}  else if (pLoadLibraryEx && .GetProcAddress(hKernel32, "AddDllDirectory")) {
			hModule = .pLoadLibraryEx(filename, ((Object)0), /* Load the DLL from the Windows system directory */-1024);
		} else {
				UINT systemdirlen = .GetSystemDirectoryA(((Object)0), /* Attempt to get the Windows system path */0);
				if (systemdirlen/* Allocate space for the full DLL path (Room for the null terminator
				         is included in systemdirlen) */) {
					size_t filenamelen = .strlen(filename);
					TCHAR path = .Curl_cmalloc( * (systemdirlen + 1 + filenamelen));
					if (path && .GetSystemDirectoryA(path, systemdirlen)) {
						.strcpy(path + .strlen(path), /* Calculate the full DLL path */"\\");
						.strcpy(path + .strlen(path), filename);
						hModule = /* Load the DLL from the Windows system directory *//** !checksrc! disable BANNEDFUNC 1 **/pLoadLibraryEx ? .pLoadLibraryEx(path, ((Object)0), 8) : .LoadLibraryA(path);
					} 
					.Curl_cfree(path);
				} 
		} 
		return hModule/* the Universal Windows Platform (UWP) can't do this *//* WIN32 */;
	}
	public static Object decodeQuantum(Object dest, Object src) {
		size_t padding = 0;
		byte s;
		byte p;
		long i;
		long x = 0;
		for (; i < 4; ) {
			if (s == (byte)'=') {
				x = (x << 6);
				padding++;
			} else {
					long v = 0;
					p = ModernizedCProgram.base64;
					while (p && (p != s)) {
						v++;
						p++;
					}
					if (p == s) {
						x = (x << 6) + v;
					} else {
							return 0;
					} 
			} 
		}
		if (padding < 1) {
			dest[2] = ModernizedCProgram.curlx_ultouc(x & -1024);
		} 
		x >>=  8;
		if (padding < 2) {
			dest[1] = ModernizedCProgram.curlx_ultouc(x & -1024);
		} 
		x >>=  8;
		dest[0] = ModernizedCProgram.curlx_ultouc(x & -1024);
		return 3 - padding/*
		 * Curl_base64_decode()
		 *
		 * Given a base64 NUL-terminated string at src, decode it and return a
		 * pointer in *outptr to a newly allocated memory area holding decoded
		 * data. Size of decoded data is returned in variable pointed by outlen.
		 *
		 * Returns CURLE_OK on success, otherwise specific error code. Function
		 * output shall not be considered valid unless CURLE_OK is returned.
		 *
		 * When decoded data length is 0, returns NULL in *outptr.
		 *
		 * @unittest: 1302
		 */;
	}
	public static  Curl_base64_decode(Object src, Object outptr, Object outlen) {
		size_t srclen = 0;
		size_t length = 0;
		size_t padding = 0;
		size_t i = new size_t();
		size_t numQuantums = new size_t();
		size_t rawlen = 0;
		byte pos;
		byte newstr;
		outptr = ((Object)0);
		outlen = 0;
		srclen = .strlen(src);
		if (!srclen || srclen % /* Check the length of the input string is valid */4) {
			return .CURLE_BAD_CONTENT_ENCODING;
		} 
		while ((src[length] != (byte)'=') && src[/* Find the position of any = padding characters */length]) {
			length++;
		}
		if (src[length] == /* A maximum of two = padding characters is allowed */(byte)'=') {
			padding++;
			if (src[length + 1] == (byte)'=') {
				padding++;
			} 
		} 
		if (length + padding != /* Check the = padding characters weren't part way through the input */srclen) {
			return .CURLE_BAD_CONTENT_ENCODING;
		} 
		numQuantums = srclen / /* Calculate the number of quantums */4;
		rawlen = (numQuantums * 3) - /* Calculate the size of the decoded string */padding;
		newstr = .Curl_cmalloc(rawlen + /* Allocate our buffer including room for a zero terminator */1);
		if (!newstr) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		pos = newstr;
		for (i = 0; i < numQuantums; /* Decode the quantums */i++) {
			size_t result = ModernizedCProgram.decodeQuantum(pos, src);
			if (!result) {
				.Curl_cfree(newstr);
				return .CURLE_BAD_CONTENT_ENCODING;
			} 
			pos += result;
			src += 4;
		}
		pos = /* Zero terminate */(byte)'\0';
		outptr = /* Return the decoded data */newstr;
		outlen = rawlen;
		return .CURLE_OK;
	}
	public static  base64_encode(Object table64, Object data, Object inputbuff, Object insize, Object outptr, Object outlen) {
		CURLcode result = new CURLcode();
		byte[] ibuf = new byte[3];
		byte[] obuf = new byte[4];
		int i;
		int inputparts;
		byte output;
		byte base64data;
		byte convbuf = ((Object)0);
		byte indata = inputbuff;
		outptr = ((Object)0);
		outlen = 0;
		if (!insize) {
			insize = .strlen(indata);
		} 
		if (insize > -1024 / 4) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		base64data = output = .Curl_cmalloc(insize * 4 / 3 + 4);
		if (!output) {
			return .CURLE_OUT_OF_MEMORY/*
			   * The base64 data needs to be created using the network encoding
			   * not the host encoding.  And we can't change the actual input
			   * so we copy it to a buffer, translate it, and use that instead.
			   */;
		} 
		result = ();
		if (result) {
			.Curl_cfree(output);
			return result;
		} 
		if (convbuf) {
			indata = (byte)convbuf;
		} 
		while (insize > 0) {
			for (i = inputparts = 0; i < 3; i++) {
				if (insize > 0) {
					inputparts++;
					ibuf[i] = (byte)indata;
					indata++;
					insize--;
				} else {
						ibuf[i] = 0;
				} 
			}
			obuf[0] = (byte)((ibuf[0] & -1024) >> 2);
			obuf[1] = (byte)(((ibuf[0] & -1024) << 4) | ((ibuf[1] & -1024) >> 4));
			obuf[2] = (byte)(((ibuf[1] & -1024) << 2) | ((ibuf[2] & -1024) >> 6));
			obuf[3] = (byte)(ibuf[2] & -1024);
			switch (inputparts) {
			case /* only one byte read */1:
					ModernizedCProgram.curl_msnprintf(output, 5, "%c%c==", table64[obuf[0]], table64[obuf[1]]);
					break;
			case /* two bytes read */2:
					ModernizedCProgram.curl_msnprintf(output, 5, "%c%c%c=", table64[obuf[0]], table64[obuf[1]], table64[obuf[2]]);
					break;
			default:
					ModernizedCProgram.curl_msnprintf(output, 5, "%c%c%c%c", table64[obuf[0]], table64[obuf[1]], table64[obuf[2]], table64[obuf[3]]);
					break;
			}
			output += 4;
		}
		output = /* Zero terminate */(byte)'\0';
		outptr = /* Return the pointer to the new data (allocated memory) */base64data;
		.Curl_cfree(convbuf);
		outlen = .strlen(/* Return the length of the new data */base64data);
		return .CURLE_OK/*
		 * Curl_base64_encode()
		 *
		 * Given a pointer to an input buffer and an input size, encode it and
		 * return a pointer in *outptr to a newly allocated memory area holding
		 * encoded data. Size of encoded data is returned in variable pointed by
		 * outlen.
		 *
		 * Input length of 0 indicates input buffer holds a NUL-terminated string.
		 *
		 * Returns CURLE_OK on success, otherwise specific error code. Function
		 * output shall not be considered valid unless CURLE_OK is returned.
		 *
		 * When encoded data length is 0, returns NULL in *outptr.
		 *
		 * @unittest: 1302
		 */;
	}
	public static  Curl_base64_encode(Object data, Object inputbuff, Object insize, Object outptr, Object outlen) {
		return ModernizedCProgram.base64_encode(ModernizedCProgram.base64, data, inputbuff, insize, outptr, outlen/*
		 * Curl_base64url_encode()
		 *
		 * Given a pointer to an input buffer and an input size, encode it and
		 * return a pointer in *outptr to a newly allocated memory area holding
		 * encoded data. Size of encoded data is returned in variable pointed by
		 * outlen.
		 *
		 * Input length of 0 indicates input buffer holds a NUL-terminated string.
		 *
		 * Returns CURLE_OK on success, otherwise specific error code. Function
		 * output shall not be considered valid unless CURLE_OK is returned.
		 *
		 * When encoded data length is 0, returns NULL in *outptr.
		 *
		 * @unittest: 1302
		 */);
	}
	public static  Curl_base64url_encode(Object data, Object inputbuff, Object insize, Object outptr, Object outlen) {
		return ModernizedCProgram.base64_encode(ModernizedCProgram.base64url, data, inputbuff, insize, outptr, outlen/* no users so disabled */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* zlib pollutes the namespace with this definition */
	public static void Curl_version_init() {
		ModernizedCProgram.curl_version();
		ModernizedCProgram.curl_version_info(.CURLVERSION_SIXTH);
	}
	/* For thread safety purposes this function is called by global_init so that
	   the static data in both version functions is initialized. */
	public static Object curl_version() {
		bool initialized = new bool();
		byte[] version = new byte[250];
		byte ptr = version;
		size_t len = new size_t();
		size_t left = ;
		if (initialized) {
			return version;
		} 
		.strcpy(ptr, "libcurl/7.67.0-DEV");
		len = .strlen(ptr);
		left -= len;
		ptr += len;
		len = 0;
		if (len > 0) {
			ptr = (byte)' ';
			left -= ++len;
			ptr += len/* this function is only present in c-ares, not in the original ares *//* version unknown *//* _LIBICONV_VERSION */;
		} 
		(Object)/*
		  If another lib version is added below this one, this code would
		  also have to do:
		
		    len = what msnprintf() returned
		
		    left -= len;
		    ptr += len;
		*//* Silent scan-build even if librtmp is not enabled. */left;
		(Object)ptr;
		initialized = .bool_true;
		return version/* data for curl_version_info
		
		   Keep the list sorted alphabetically. It is also written so that each
		   protocol line has its own #if line to make things easier on the eye.
		 */;
	}
	public static Object curl_version_info( stamp) {
		bool initialized = new bool();
		if (initialized) {
			return ModernizedCProgram.version_info/* libz left NULL if non-existing *//* This returns a version string if we use the given version or later,
			     otherwise it returns NULL */;
		} 
		(Object)/* version unknown *//* _LIBICONV_VERSION *//* avoid compiler warnings, we don't use this */stamp;
		initialized = .bool_true;
		return ModernizedCProgram.version_info;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/*
	 * "Remove Dot Segments"
	 * https://tools.ietf.org/html/rfc3986#section-5.2.4
	 */
	/*
	 * Curl_dedotdotify()
	 * @unittest: 1395
	 *
	 * This function gets a zero-terminated path with dot and dotdot sequences
	 * passed in and strips them off according to the rules in RFC 3986 section
	 * 5.2.4.
	 *
	 * The function handles a query part ('?' + stuff) appended but it expects
	 * that fragments ('#' + stuff) have already been cut off.
	 *
	 * RETURNS
	 *
	 * an allocated dedotdotified output string
	 */
	public static Object Curl_dedotdotify(Object input) {
		size_t inlen = .strlen(input);
		byte clone;
		size_t clen = /* the length of the cloned input */inlen;
		byte out = .Curl_cmalloc(inlen + 1);
		byte outptr;
		byte orgclone;
		byte queryp;
		if (!out) {
			return ((Object)/* out of memory */0);
		} 
		out = /* zero terminates, for inputs like "./" */0;
		clone = .Curl_cstrdup(/* get a cloned copy of the input */input);
		if (!clone) {
			.Curl_cfree(out);
			return ((Object)0);
		} 
		orgclone = clone;
		outptr = out;
		if (!clone) {
			.Curl_cfree(/* zero length string, return that */out);
			return clone/*
			   * To handle query-parts properly, we must find it and remove it during the
			   * dotdot-operation and then append it again at the end to the output
			   * string.
			   */;
		} 
		queryp = .strchr(clone, (byte)'?');
		if (queryp) {
			queryp = 0;
		} 
		do {
			if (!.strncmp("./", clone, 2)) {
				clone += 2;
				clen -= 2;
			}  else if (!.strncmp("../", clone, 3)) {
				clone += 3;
				clen -= 3;
			}  else if (!.strncmp("/./", clone, /*  B.  if the input buffer begins with a prefix of "/./" or "/.", where
			        "."  is a complete path segment, then replace that prefix with "/" in
			        the input buffer; otherwise, */3)) {
				clone += 2;
				clen -= 2;
			}  else if (!.strcmp("/.", clone)) {
				clone[1] = (byte)'/';
				clone++;
				clen -= 1/*  C.  if the input buffer begins with a prefix of "/../" or "/..", where
				        ".." is a complete path segment, then replace that prefix with "/" in
				        the input buffer and remove the last segment and its preceding "/" (if
				        any) from the output buffer; otherwise, */;
			}  else if (!.strncmp("/../", clone, 4)) {
				clone += 3;
				clen -= 3;
				while (outptr > /* remove the last segment from the output buffer */out) {
					outptr--;
					if (outptr == (byte)'/') {
						break;
					} 
				}
				outptr = /* zero-terminate where it stops */0;
			}  else if (!.strcmp("/..", clone)) {
				clone[2] = (byte)'/';
				clone += 2;
				clen -= 2;
				while (outptr > /* remove the last segment from the output buffer */out) {
					outptr--;
					if (outptr == (byte)'/') {
						break;
					} 
				}
				outptr = /* zero-terminate where it stops */0;
			}  else if (!.strcmp(".", clone) || !.strcmp("..", /*  D.  if the input buffer consists only of "." or "..", then remove
			        that from the input buffer; otherwise, */clone)) {
				clone = 0;
				out = 0/*  E.  move the first path segment in the input buffer to the end of
				          the output buffer, including the initial "/" character (if any) and
				          any subsequent characters up to, but not including, the next "/"
				          character or the end of the input buffer. */;
			} else {
					do {
						outptr++ = clone++;
						clen--;
					} while (clone && (clone != (byte)'/'));
					outptr = 0;
			} 
		} while (clone);/*  A.  If the input buffer begins with a prefix of "../" or "./", then
		        remove that prefix from the input buffer; otherwise, */
		if (queryp) {
			size_t qlen = new size_t();
			size_t oindex = queryp - orgclone;
			qlen = .strlen(input[oindex]);
			.memcpy(outptr, input[oindex], qlen + /* include the end zero byte */1);
		} 
		.Curl_cfree(orgclone);
		return out;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * NOTE:
	 *
	 * In the ISO C standard (IEEE Std 1003.1), there is a strtoimax() function we
	 * could use in case strtoll() doesn't exist...  See
	 * https://www.opengroup.org/onlinepubs/009695399/functions/strtoimax.html
	 */
	/* Range tests can be used for alphanum decoding if characters are consecutive,
	   like in ASCII. Else an array is scanned. Determine this condition now. */
	/**
	 * Custom version of the strtooff function.  This extracts a curl_off_t
	 * value from the given input string and returns it.
	 */
	/* Skip leading whitespace. */
	/* Handle the sign, if any. */
	/* We had nothing but perhaps some whitespace -- there was no number. */
	/* Handle special beginnings, if present and allowed. */
	/* Matching strtol, if the base is 0 and it doesn't look like
	   * the number is octal or hex, we assume it's base 10.
	   */
	/* Loop handling digits. */
	/* We've overflowed. */
	/* Fix the sign. */
	/**
	 * Returns the value of c in the given base, or -1 if c cannot
	 * be interpreted properly in that base (i.e., is out of range,
	 * is a null, etc.).
	 *
	 * @param c     the character to interpret according to base
	 * @param base  the base in which to interpret c
	 *
	 * @return  the value of c in base, or -1 if c isn't in range
	 */
	/* Lowercase. */
	/* Only present if we need strtoll, but don't have it. */
	/*
	 * Parse a *positive* up to 64 bit number written in ascii.
	 */
	public static  curlx_strtoofft(Object str, Object endp, int base, Object num) {
		byte end;
		curl_off_t number = new curl_off_t();
		(._errno()) = 0;
		num = /* clear by default */0;
		while (str && (ModernizedCProgram.Curl_isspace((int)((byte)str)))) {
			str++;
		}
		if ((byte)'-' == str) {
			if (endp) {
				endp = (byte)/* didn't actually move */str;
			} 
			return /* nothing parsed */.CURL_OFFT_INVAL;
		} 
		number = .strtoll(str, end, base);
		if (endp) {
			endp = end;
		} 
		if ((._errno()) == 34) {
			return /* overflow/underflow */.CURL_OFFT_FLOW;
		}  else if (str == end) {
			return /* nothing parsed */.CURL_OFFT_INVAL;
		} 
		num = number;
		return .CURL_OFFT_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/* Macros to free const pointers. */
	/* tool_mime functions. */
	public static Object tool_mime_new(Object parent,  kind) {
		tool_mime m = (tool_mime).calloc(1, );
		if (m) {
			m.setKind(kind);
			m.setParent(parent);
			if (parent) {
				m.setPrev(parent.getSubparts());
				parent.setSubparts(m);
			} 
		} 
		return m;
	}
	public static Object tool_mime_new_parts(Object parent) {
		return ModernizedCProgram.tool_mime_new(parent, .TOOLMIME_PARTS);
	}
	public static Object tool_mime_new_data(Object parent, Object data) {
		tool_mime m = ((Object)0);
		data = .strdup(data);
		if (data) {
			m = ModernizedCProgram.tool_mime_new(parent, .TOOLMIME_DATA);
			if (!m) {
				.free((Object)(data));
			} else {
					m.setData(data);
			} 
		} 
		return m;
	}
	public static Object tool_mime_new_filedata(Object parent, Object filename,  isremotefile, Object errcode) {
		CURLcode result = .CURLE_OK;
		tool_mime m = ((Object)0);
		errcode = .CURLE_OUT_OF_MEMORY;
		Object generatedSt_mode = sbuf.getSt_mode();
		Object generatedSt_size = sbuf.getSt_size();
		if (.strcmp(filename, "-")) {
			filename = .strdup(/* This is a normal file. */filename);
			if (filename) {
				m = ModernizedCProgram.tool_mime_new(parent, .TOOLMIME_FILE);
				if (!m) {
					.free((Object)(filename));
				} else {
						m.setData(filename);
						if (!isremotefile) {
							m.setKind(.TOOLMIME_FILEDATA);
						} 
						errcode = .CURLE_OK;
				} 
			} 
		} else {
				int fd = (((_iob[0])).get_file());
				byte data = ((Object)0);
				curl_off_t size = new curl_off_t();
				curl_off_t origin = new curl_off_t();
				_stati64 sbuf = new _stati64();
				ModernizedCProgram.set_binmode((_iob[0]));
				origin = .ftell((_iob[0/* If stdin is a regular file, do not buffer data but read it
				       when needed. */]));
				if (fd >= 0 && origin >= 0 && !._fstati64(fd, sbuf) && (((generatedSt_mode) & -1024) == -1024)) {
					size = generatedSt_size - origin;
					if (size < 0) {
						size = 0;
					} 
				} else {
						size_t stdinsize = /* Not suitable for direct use, buffer stdin data. */0;
						if (ModernizedCProgram.file2memory(data, stdinsize, (_iob[0])) != .PARAM_OK) {
							return /* Out of memory. */m;
						} 
						if ((((_iob[0])).get_flag() & -1024)) {
							result = .CURLE_READ_ERROR;
							do {
								.free((data));
								(data) = ((Object)0);
							} while (0);
							data = ((Object)0);
						}  else if (!stdinsize) {
							data = .strdup(/* Zero-length data has been freed. Re-create it. */"");
							if (!data) {
								return m;
							} 
						} 
						size = ModernizedCProgram.curlx_uztoso(stdinsize);
						origin = 0;
				} 
				m = ModernizedCProgram.tool_mime_new(parent, .TOOLMIME_STDIN);
				if (!m) {
					do {
						.free((data));
						(data) = ((Object)0);
					} while (0);
				} else {
						m.setData(data);
						m.setOrigin(origin);
						m.setSize(size);
						m.setCurpos(0);
						if (!isremotefile) {
							m.setKind(.TOOLMIME_STDINDATA);
						} 
						errcode = result;
				} 
		} 
		return m;
	}
	public static void tool_mime_free(Object mime) {
		if (mime) {
			if (mime.getSubparts()) {
				ModernizedCProgram.tool_mime_free(mime.getSubparts());
			} 
			if (mime.getPrev()) {
				ModernizedCProgram.tool_mime_free(mime.getPrev());
			} 
			do {
				.free((((Object)(mime.getName()))));
				(((Object)(mime.getName()))) = ((Object)0);
			} while (0);
			do {
				.free((((Object)(mime.getFilename()))));
				(((Object)(mime.getFilename()))) = ((Object)0);
			} while (0);
			do {
				.free((((Object)(mime.getType()))));
				(((Object)(mime.getType()))) = ((Object)0);
			} while (0);
			do {
				.free((((Object)(mime.getEncoder()))));
				(((Object)(mime.getEncoder()))) = ((Object)0);
			} while (0);
			do {
				.free((((Object)(mime.getData()))));
				(((Object)(mime.getData()))) = ((Object)0);
			} while (0);
			ModernizedCProgram.curl_slist_free_all(mime.getHeaders());
			.free(mime);
		} 
	}
	/* Mime part callbacks for stdin. */
	public static Object tool_mime_stdin_read(Object buffer, Object size, Object nitems, Object arg) {
		tool_mime sip = (tool_mime)arg;
		curl_off_t bytesleft = new curl_off_t();
		(Object)/* Always 1: ignored. */size;
		if (sip.getSize() >= 0) {
			if (sip.getCurpos() >= sip.getSize()) {
				return /* At eof. */0;
			} 
			bytesleft = sip.getSize() - sip.getCurpos();
			if (ModernizedCProgram.curlx_uztoso(nitems) > bytesleft) {
				nitems = ModernizedCProgram.curlx_sotouz(bytesleft);
			} 
		} 
		if (nitems) {
			if (sip.getData()) {
				.memcpy(buffer, sip.getData() + ModernizedCProgram.curlx_sotouz(sip.getCurpos()), /* Return data from memory. */nitems);
			} else {
					nitems = .fread(buffer, 1, nitems, (_iob[/* Read from stdin. */0]));
					if ((((_iob[0])).get_flag() & -1024)) {
						if (sip.getConfig()) {
							ModernizedCProgram.warnf(sip.getConfig(), "stdin: %s\n", .strerror((._errno())));
							sip.setConfig(((Object)0));
						} 
						return -1024;
					} 
			} 
			sip.getCurpos() += ModernizedCProgram.curlx_uztoso(nitems);
		} 
		return nitems;
	}
	public static int tool_mime_stdin_seek(Object instream, Object offset, int whence) {
		tool_mime sip = (tool_mime)instream;
		switch (whence) {
		case 1:
				offset += sip.getCurpos();
				break;
		case 2:
				offset += sip.getSize();
				break;
		}
		if (offset < 0) {
			return 2;
		} 
		if (!sip.getData()) {
			if (.fseek((_iob[0]), (long)(offset + sip.getOrigin()), 0)) {
				return 2;
			} 
		} 
		sip.setCurpos(offset);
		return 0;
	}
	/* Translate an internal mime tree into a libcurl mime tree. */
	public static  tool2curlparts(Object curl, Object m, Object mime) {
		CURLcode ret = .CURLE_OK;
		curl_mimepart part = ((Object)0);
		curl_mime submime = ((Object)0);
		byte filename = ((Object)0);
		if (m) {
			ret = ModernizedCProgram.tool2curlparts(curl, m.getPrev(), mime);
			if (!ret) {
				part = ModernizedCProgram.curl_mime_addpart(mime);
				if (!part) {
					ret = .CURLE_OUT_OF_MEMORY;
				} 
			} 
			if (!ret) {
				filename = m.getFilename();
				switch (m.getKind()) {
				case .TOOLMIME_PARTS:
						ret = ModernizedCProgram.tool2curlmime(curl, m, submime);
						if (!ret) {
							ret = ModernizedCProgram.curl_mime_subparts(part, submime);
							if (ret) {
								ModernizedCProgram.curl_mime_free(submime);
							} 
						} 
						break;
				case .TOOLMIME_FILE:
				case .TOOLMIME_DATA/* Our data is always textual: convert it to ASCII. */:
						ret = ModernizedCProgram.curl_mime_data(part, m.getData(), ((size_t)-1));
						break;
				case /* FALLTHROUGH */.TOOLMIME_STDINDATA:
						ret = ModernizedCProgram.curl_mime_data_cb(part, m.getSize(), (curl_read_callback)ModernizedCProgram.tool_mime_stdin_read, (curl_seek_callback)ModernizedCProgram.tool_mime_stdin_seek, ((Object)0), m);
						break;
				case .TOOLMIME_STDIN:
						if (!filename) {
							filename = "-";
						} 
				case .TOOLMIME_FILEDATA:
						ret = ModernizedCProgram.curl_mime_filedata(part, m.getData());
						if (!ret && m.getKind() == .TOOLMIME_FILEDATA && !filename) {
							ret = ModernizedCProgram.curl_mime_filename(part, ((Object)0));
						} 
						break;
				default:
						break;
				}
			} 
			if (!ret && filename) {
				ret = ModernizedCProgram.curl_mime_filename(part, filename);
			} 
			if (!ret) {
				ret = ModernizedCProgram.curl_mime_type(part, m.getType());
			} 
			if (!ret) {
				ret = ModernizedCProgram.curl_mime_headers(part, m.getHeaders(), 0);
			} 
			if (!ret) {
				ret = ModernizedCProgram.curl_mime_encoder(part, m.getEncoder());
			} 
			if (!ret) {
				ret = ModernizedCProgram.curl_mime_name(part, m.getName());
			} 
		} 
		return ret;
	}
	public static  tool2curlmime(Object curl, Object m, Object mime) {
		CURLcode ret = .CURLE_OK;
		mime = ModernizedCProgram.curl_mime_init(curl);
		if (!mime) {
			ret = .CURLE_OUT_OF_MEMORY;
		} else {
				ret = ModernizedCProgram.tool2curlparts(curl, m.getSubparts(), mime);
		} 
		if (ret) {
			ModernizedCProgram.curl_mime_free(mime);
			mime = ((Object)0);
		} 
		return ret/*
		 * helper function to get a word from form param
		 * after call get_parm_word, str either point to string end
		 * or point to any of end chars.
		 */;
	}
	public static Object get_param_word(Object str, Object end_pos, byte endchar) {
		byte ptr = str;
		byte word_begin = /* the first non-space char is here */ptr;
		byte ptr2;
		byte escape = ((Object)0);
		if (ptr == (byte)'"') {
			++ptr;
			while (ptr) {
				if (ptr == (byte)'\\') {
					if (ptr[1] == (byte)'\\' || ptr[1] == (byte)'"') {
						if (!/* remember the first escape position */escape) {
							escape = ptr;
						} 
						ptr += /* skip escape of back-slash or double-quote */2;
						continue;
					} 
				} 
				if (ptr == (byte)'"') {
					end_pos = ptr;
					if (escape) {
						ptr = ptr2 = /* has escape, we restore the unescaped string here */escape;
						do {
							if (ptr == (byte)'\\' && (ptr[1] == (byte)'\\' || ptr[1] == (byte)'"')) {
								++ptr;
							} 
							ptr2++ = ptr++;
						} while (ptr < end_pos);
						end_pos = ptr2;
					} 
					while (ptr && ptr != (byte)';' && ptr != endchar) {
						++ptr;
					}
					str = ptr;
					return word_begin + 1;
				} 
				++ptr;
			}
			ptr = /* end quote is missing, treat it as non-quoted. */word_begin;
		} 
		while (ptr && ptr != (byte)';' && ptr != endchar) {
			++ptr;
		}
		str = end_pos = ptr;
		return word_begin;
	}
	/* Append slist item and return -1 if failed. */
	public static int slist_append(Object plist, Object data) {
		curl_slist s = ModernizedCProgram.curl_slist_append(plist, data);
		if (!s) {
			return -1;
		} 
		plist = s;
		return 0;
	}
	/* Read headers from a file and append to list. */
	public static int read_field_headers(Object config, Object filename, Object fp, Object pheaders) {
		size_t hdrlen = 0;
		size_t pos = 0;
		bool incomment = 0;
		int lineno = 1;
		byte[] hdrbuf = new byte[/* Max. header length + 1. */999];
		for (; ; ) {
			int c = .getc(fp);
			if (c == (true) || (!pos && !(ModernizedCProgram.Curl_isspace((int)((byte)c))))) {
				while (hdrlen && (ModernizedCProgram.Curl_isspace((int)((byte)hdrbuf[hdrlen - /* Strip and flush the current header. */1])))) {
					hdrlen--;
				}
				if (hdrlen) {
					hdrbuf[hdrlen] = (byte)'\0';
					if (ModernizedCProgram.slist_append(pheaders, hdrbuf)) {
						ModernizedCProgram.curl_mfprintf(config.getGlobal().getErrors(), "Out of memory for field headers!\n");
						return -1;
					} 
					hdrlen = 0;
				} 
			} 
			switch (c) {
			case (true):
					if (((fp).get_flag() & -1024)) {
						ModernizedCProgram.curl_mfprintf(config.getGlobal().getErrors(), "Header file %s read error: %s\n", filename, .strerror((._errno())));
						return -1;
					} 
					return /* Done. */0;
			case (byte)'#':
					if (!pos) {
						incomment = 1;
					} 
					break;
			case (byte)'\n':
					pos = 0;
					incomment = 0;
					lineno++;
					continue;
			case (byte)'\r':
					continue;
			}
			pos++;
			if (!incomment) {
				if (hdrlen ==  - 1) {
					ModernizedCProgram.warnf(config.getGlobal(), "File %s line %d: header too long (truncated)\n", filename, lineno);
					c = (byte)' ';
				} 
				if (hdrlen <=  - 1) {
					hdrbuf[hdrlen++] = (byte)c/* NOTREACHED */;
				} 
			} 
		}
	}
	public static int get_param_part(Object config, byte endchar, Object str, Object pdata, Object ptype, Object pfilename, Object pencoder, Object pheaders) {
		byte p = str;
		byte type = ((Object)0);
		byte filename = ((Object)0);
		byte encoder = ((Object)0);
		byte endpos;
		byte tp;
		byte sep;
		byte[] type_major = "";
		byte[] type_minor = "";
		byte endct = ((Object)0);
		curl_slist headers = ((Object)0);
		if (ptype) {
			ptype = ((Object)0);
		} 
		if (pfilename) {
			pfilename = ((Object)0);
		} 
		if (pheaders) {
			pheaders = ((Object)0);
		} 
		if (pencoder) {
			pencoder = ((Object)0);
		} 
		while ((ModernizedCProgram.Curl_isspace((int)((byte)p)))) {
			p++;
		}
		tp = p;
		pdata = ModernizedCProgram.get_param_word(p, endpos, endchar);
		if (pdata == /* If not quoted, strip trailing spaces. */tp) {
			while (endpos > pdata && (ModernizedCProgram.Curl_isspace((int)((byte)endpos[-1])))) {
				endpos--;
			}
		} 
		sep = p;
		endpos = (byte)'\0';
		while (sep == (byte)';') {
			while ((ModernizedCProgram.Curl_isspace((int)((byte)++p)))) {
				;
			}
			if (!endct && ModernizedCProgram.curl_strnequal("type=", p, .strlen("type="))) {
				for (p += 5; (ModernizedCProgram.Curl_isspace((int)((byte)p))); p++) {
					;
				}
				type = /* set type pointer */p;
				if (2 != .sscanf(type, "%127[^/ ]/%127[^;, \n]", type_major, /* verify that this is a fine type specifier */type_minor)) {
					ModernizedCProgram.warnf(config.getGlobal(), "Illegally formatted content-type field!\n");
					ModernizedCProgram.curl_slist_free_all(headers);
					return -/* illegal content-type syntax! */1;
				} 
				p = type + .strlen(type_major) + .strlen(type_minor) + /* now point beyond the content-type specifier */1;
				for (endct = p; p && p != (byte)';' && p != endchar; p++) {
					if (!(ModernizedCProgram.Curl_isspace((int)((byte)p)))) {
						endct = p + 1;
					} 
				}
				sep = p;
			}  else if (ModernizedCProgram.curl_strnequal("filename=", p, .strlen("filename="))) {
				if (endct) {
					endct = (byte)'\0';
					endct = ((Object)0);
				} 
				for (p += 9; (ModernizedCProgram.Curl_isspace((int)((byte)p))); p++) {
					;
				}
				tp = p;
				filename = ModernizedCProgram.get_param_word(p, endpos, endchar);
				if (filename == /* If not quoted, strip trailing spaces. */tp) {
					while (endpos > filename && (ModernizedCProgram.Curl_isspace((int)((byte)endpos[-1])))) {
						endpos--;
					}
				} 
				sep = p;
				endpos = (byte)'\0';
			}  else if (ModernizedCProgram.curl_strnequal("headers=", p, .strlen("headers="))) {
				if (endct) {
					endct = (byte)'\0';
					endct = ((Object)0);
				} 
				p += 8;
				if (p == (byte)'@' || p == (byte)'<') {
					byte hdrfile;
					FILE fp = new FILE();
					do {
						p++;
					} while ((ModernizedCProgram.Curl_isspace((int)((byte)p))));
					tp = p;
					hdrfile = ModernizedCProgram.get_param_word(p, endpos, endchar);
					if (hdrfile == /* If not quoted, strip trailing spaces. */tp) {
						while (endpos > hdrfile && (ModernizedCProgram.Curl_isspace((int)((byte)endpos[-1])))) {
							endpos--;
						}
					} 
					sep = p;
					endpos = (byte)'\0';
					fp = .fopen(hdrfile, "rt");
					if (!fp) {
						ModernizedCProgram.warnf(config.getGlobal(), "Cannot read from %s: %s\n", hdrfile, .strerror((._errno())));
					} else {
							int i = ModernizedCProgram.read_field_headers(config, hdrfile, fp, headers);
							.fclose(fp);
							if (i) {
								ModernizedCProgram.curl_slist_free_all(headers);
								return -1;
							} 
					} 
				} else {
						byte hdr;
						while ((ModernizedCProgram.Curl_isspace((int)((byte)p)))) {
							p++;
						}
						tp = p;
						hdr = ModernizedCProgram.get_param_word(p, endpos, endchar);
						if (hdr == /* If not quoted, strip trailing spaces. */tp) {
							while (endpos > hdr && (ModernizedCProgram.Curl_isspace((int)((byte)endpos[-1])))) {
								endpos--;
							}
						} 
						sep = p;
						endpos = (byte)'\0';
						if (ModernizedCProgram.slist_append(headers, hdr)) {
							ModernizedCProgram.curl_mfprintf(config.getGlobal().getErrors(), "Out of memory for field header!\n");
							ModernizedCProgram.curl_slist_free_all(headers);
							return -1;
						} 
				} 
			}  else if (ModernizedCProgram.curl_strnequal("encoder=", p, .strlen("encoder="))) {
				if (endct) {
					endct = (byte)'\0';
					endct = ((Object)0);
				} 
				for (p += 8; (ModernizedCProgram.Curl_isspace((int)((byte)p))); p++) {
					;
				}
				tp = p;
				encoder = ModernizedCProgram.get_param_word(p, endpos, endchar);
				if (encoder == /* If not quoted, strip trailing spaces. */tp) {
					while (endpos > encoder && (ModernizedCProgram.Curl_isspace((int)((byte)endpos[-1])))) {
						endpos--;
					}
				} 
				sep = p;
				endpos = (byte)'\0';
			}  else if (endct) {
				for (endct = p; p && p != (byte)';' && p != endchar; /* This is part of content type. */p++) {
					if (!(ModernizedCProgram.Curl_isspace((int)((byte)p)))) {
						endct = p + 1;
					} 
				}
				sep = p;
			} else {
					byte unknown = ModernizedCProgram.get_param_word(p, endpos, /* unknown prefix, skip to next block */endchar);
					sep = p;
					endpos = (byte)'\0';
					if (unknown) {
						ModernizedCProgram.warnf(config.getGlobal(), "skip unknown form field: %s\n", unknown);
					} 
			} 
		}
		if (/* Terminate content type. */endct) {
			endct = (byte)'\0';
		} 
		if (ptype) {
			ptype = type;
		}  else if (type) {
			ModernizedCProgram.warnf(config.getGlobal(), "Field content type not allowed here: %s\n", type);
		} 
		if (pfilename) {
			pfilename = filename;
		}  else if (filename) {
			ModernizedCProgram.warnf(config.getGlobal(), "Field file name not allowed here: %s\n", filename);
		} 
		if (pencoder) {
			pencoder = encoder;
		}  else if (encoder) {
			ModernizedCProgram.warnf(config.getGlobal(), "Field encoder not allowed here: %s\n", encoder);
		} 
		if (pheaders) {
			pheaders = headers;
		}  else if (headers) {
			ModernizedCProgram.warnf(config.getGlobal(), "Field headers not allowed here: %s\n", headers.getData());
			ModernizedCProgram.curl_slist_free_all(headers);
		} 
		str = p;
		return sep & -1024/***************************************************************************
		 *
		 * formparse()
		 *
		 * Reads a 'name=value' parameter and builds the appropriate linked list.
		 *
		 * If the value is of the form '<filename', field data is read from the
		 * given file.
		
		 * Specify files to upload with 'name=@filename', or 'name=@"filename"'
		 * in case the filename contain ',' or ';'. Supports specified
		 * given Content-Type of the files. Such as ';type=<content-type>'.
		 *
		 * If literal_value is set, any initial '@' or '<' in the value string
		 * loses its special meaning, as does any embedded ';type='.
		 *
		 * You may specify more than one file for a single name (field). Specify
		 * multiple files by writing it like:
		 *
		 * 'name=@filename,filename2,filename3'
		 *
		 * or use double-quotes quote the filename:
		 *
		 * 'name=@"filename","filename2","filename3"'
		 *
		 * If you want content-types specified for each too, write them like:
		 *
		 * 'name=@filename;type=image/gif,filename2,filename3'
		 *
		 * If you want custom headers added for a single part, write them in a separate
		 * file and do like this:
		 *
		 * 'name=foo;headers=@headerfile' or why not
		 * 'name=@filemame;headers=@headerfile'
		 *
		 * To upload a file, but to fake the file name that will be included in the
		 * formpost, do like this:
		 *
		 * 'name=@filename;filename=/dev/null' or quote the faked filename like:
		 * 'name=@filename;filename="play, play, and play.txt"'
		 *
		 * If filename/path contains ',' or ';', it must be quoted by double-quotes,
		 * else curl will fail to figure out the correct filename. if the filename
		 * tobe quoted contains '"' or '\', '"' and '\' must be escaped by backslash.
		 *
		 ***************************************************************************/;
	}
	/* Convenience macros for null pointer check. */
	public static int formparse(Object config, Object input, Object mimeroot, Object mimecurrent,  literal_value) {
		byte name = ((Object)/* input MUST be a string in the format 'name=contents' and we'll
		     build a linked list with the info */0);
		byte contents = ((Object)0);
		byte contp;
		byte data;
		byte type = ((Object)0);
		byte filename = ((Object)0);
		byte encoder = ((Object)0);
		curl_slist headers = ((Object)0);
		tool_mime part = ((Object)0);
		CURLcode res = new CURLcode();
		if (!/* Allocate the main mime structure if needed. */mimecurrent) {
			{ 
				(mimeroot) = (ModernizedCProgram.tool_mime_new_parts(((Object)0)));
				if (!(mimeroot)) {
					ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
					ModernizedCProgram.curl_slist_free_all(headers);
					do {
						.free((contents));
						(contents) = ((Object)0);
					} while (0);
					return 1;
				} 
			}
			;
			mimecurrent = mimeroot;
		} 
		{ 
			(contents) = (.strdup(input));
			if (!(contents)) {
				ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
				ModernizedCProgram.curl_slist_free_all(headers);
				do {
					.free((contents));
					(contents) = ((Object)0);
				} while (0);
				return /* Make a copy we can overwrite. */2;
			} 
		}
		;
		contp = .strchr(contents, /* Scan for the end of the name. */(byte)'=');
		if (contp) {
			int sep = (byte)'\0';
			if (contp > contents) {
				name = contents;
			} 
			contp++ = (byte)'\0';
			if (contp == (byte)'(' && !literal_value) {
				sep = ModernizedCProgram.get_param_part(config, /* Starting a multipart. */(byte)'\0', contp, data, type, ((Object)0), ((Object)0), headers);
				if (sep < 0) {
					do {
						.free((contents));
						(contents) = ((Object)0);
					} while (0);
					return 3;
				} 
				{ 
					(part) = (ModernizedCProgram.tool_mime_new_parts(mimecurrent));
					if (!(part)) {
						ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
						ModernizedCProgram.curl_slist_free_all(headers);
						do {
							.free((contents));
							(contents) = ((Object)0);
						} while (0);
						return 4;
					} 
				}
				;
				mimecurrent = part;
				part.setHeaders(headers);
				headers = ((Object)0);
				{ 
					if (type) {
						((part).getType()) = (.strdup(type));
						if (!((part).getType())) {
							ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
							ModernizedCProgram.curl_slist_free_all(headers);
							do {
								.free((contents));
								(contents) = ((Object)0);
							} while (0);
							return 5;
						} 
					} 
					;
				}
				;
			}  else if (!name && !.strcmp(contp, ")") && !literal_value) {
				if (mimecurrent == /* Ending a multipart. */mimeroot) {
					ModernizedCProgram.warnf(config.getGlobal(), "no multipart to terminate!\n");
					do {
						.free((contents));
						(contents) = ((Object)0);
					} while (0);
					return 6;
				} 
				mimecurrent = (mimecurrent).getParent();
			}  else if ((byte)'@' == contp[0] && !literal_value) {
				tool_mime subparts = ((Object)/* we use the @-letter to indicate file name(s) */0);
				do {
					++contp;
					sep = ModernizedCProgram.get_param_part(config, (byte)',', contp, data, type, filename, encoder, headers);
					if (sep < 0) {
						do {
							.free((contents));
							(contents) = ((Object)0);
						} while (0);
						return 7;
					} 
					if (!/* now contp point to comma or string end.
					           If more files to come, make sure we have multiparts. */subparts) {
						if (sep != /* If there is a single file. */(byte)',') {
							subparts = mimecurrent;
						} else {
								(subparts) = (ModernizedCProgram.tool_mime_new_parts(mimecurrent));
								if (!(subparts)) {
									ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
									ModernizedCProgram.curl_slist_free_all(headers);
									do {
										.free((contents));
										(contents) = ((Object)0);
									} while (0);
									return 8;
								} 
						} 
						;
					} 
					{ 
						(part) = (ModernizedCProgram.tool_mime_new_filedata(subparts, data, 1, res));
						if (!(part)) {
							ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
							ModernizedCProgram.curl_slist_free_all(headers);
							do {
								.free((contents));
								(contents) = ((Object)0);
							} while (0);
							return /* Store that file in a part. */9;
						} 
					}
					;
					part.setHeaders(headers);
					headers = ((Object)0);
					part.setConfig(config.getGlobal());
					if (res == .CURLE_READ_ERROR/* An error occurred while reading stdin: if read has started,
					               issue the error now. Else, delay it until processed by
					               libcurl. */) {
						if (part.getSize() > 0) {
							ModernizedCProgram.warnf(config.getGlobal(), "error while reading standard input\n");
							do {
								.free((contents));
								(contents) = ((Object)0);
							} while (0);
							return 10;
						} 
						do {
							.free((((Object)(part.getData()))));
							(((Object)(part.getData()))) = ((Object)0);
						} while (0);
						part.setData(((Object)0));
						part.setSize(-1);
						res = .CURLE_OK;
					} 
					{ 
						if (filename) {
							((part).getFilename()) = (.strdup(filename));
							if (!((part).getFilename())) {
								ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
								ModernizedCProgram.curl_slist_free_all(headers);
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 11;
							} 
						} 
						;
					}
					;
					{ 
						if (type) {
							((part).getType()) = (.strdup(type));
							if (!((part).getType())) {
								ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
								ModernizedCProgram.curl_slist_free_all(headers);
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 12;
							} 
						} 
						;
					}
					;
					{ 
						if (encoder) {
							((part).getEncoder()) = (.strdup(encoder));
							if (!((part).getEncoder())) {
								ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
								ModernizedCProgram.curl_slist_free_all(headers);
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 13;
							} 
						} 
						;
					}
					;
				} while (/* *contp could be '\0', so we just check with the delimiter *//* loop if there's another file name */sep);
				part = (mimecurrent).getSubparts();
			} else {
					if (contp == (byte)'<' && !literal_value) {
						++contp;
						sep = ModernizedCProgram.get_param_part(config, (byte)'\0', contp, data, type, ((Object)0), encoder, headers);
						if (sep < 0) {
							do {
								.free((contents));
								(contents) = ((Object)0);
							} while (0);
							return 14;
						} 
						{ 
							(part) = (ModernizedCProgram.tool_mime_new_filedata(mimecurrent, data, 0, res));
							if (!(part)) {
								ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
								ModernizedCProgram.curl_slist_free_all(headers);
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 15;
							} 
						}
						;
						part.setHeaders(headers);
						headers = ((Object)0);
						part.setConfig(config.getGlobal());
						if (res == .CURLE_READ_ERROR/* An error occurred while reading stdin: if read has started,
						               issue the error now. Else, delay it until processed by
						               libcurl. */) {
							if (part.getSize() > 0) {
								ModernizedCProgram.warnf(config.getGlobal(), "error while reading standard input\n");
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 16;
							} 
							do {
								.free((((Object)(part.getData()))));
								(((Object)(part.getData()))) = ((Object)0);
							} while (0);
							part.setData(((Object)0));
							part.setSize(-1);
							res = .CURLE_OK;
						} 
					} else {
							if (literal_value) {
								data = contp;
							} else {
									sep = ModernizedCProgram.get_param_part(config, (byte)'\0', contp, data, type, filename, encoder, headers);
									if (sep < 0) {
										do {
											.free((contents));
											(contents) = ((Object)0);
										} while (0);
										return 17;
									} 
							} 
							{ 
								(part) = (ModernizedCProgram.tool_mime_new_data(mimecurrent, data));
								if (!(part)) {
									ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
									ModernizedCProgram.curl_slist_free_all(headers);
									do {
										.free((contents));
										(contents) = ((Object)0);
									} while (0);
									return 18;
								} 
							}
							;
							part.setHeaders(headers);
							headers = ((Object)0);
					} 
					{ 
						if (filename) {
							((part).getFilename()) = (.strdup(filename));
							if (!((part).getFilename())) {
								ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
								ModernizedCProgram.curl_slist_free_all(headers);
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 19;
							} 
						} 
						;
					}
					;
					{ 
						if (type) {
							((part).getType()) = (.strdup(type));
							if (!((part).getType())) {
								ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
								ModernizedCProgram.curl_slist_free_all(headers);
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 20;
							} 
						} 
						;
					}
					;
					{ 
						if (encoder) {
							((part).getEncoder()) = (.strdup(encoder));
							if (!((part).getEncoder())) {
								ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
								ModernizedCProgram.curl_slist_free_all(headers);
								do {
									.free((contents));
									(contents) = ((Object)0);
								} while (0);
								return 21;
							} 
						} 
						;
					}
					;
					if (sep) {
						contp = (byte)sep;
						ModernizedCProgram.warnf(config.getGlobal(), "garbage at end of field specification: %s\n", contp);
					} 
			} 
			{ 
				if (name) {
					((part).getName()) = (.strdup(name));
					if (!((part).getName())) {
						ModernizedCProgram.warnf(config.getGlobal(), "out of memory!\n");
						ModernizedCProgram.curl_slist_free_all(headers);
						do {
							.free((contents));
							(contents) = ((Object)0);
						} while (0);
						return /* Set part name. */22;
					} 
				} 
				;
			}
			;
		} else {
				ModernizedCProgram.warnf(config.getGlobal(), "Illegally formatted input field!\n");
				do {
					.free((contents));
					(contents) = ((Object)0);
				} while (0);
				return 23;
		} 
		do {
			.free((contents));
			(contents) = ((Object)0);
		} while (0);
		return 0;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* Curl_getconnectinfo() */
	/* The last #include files should be: */
	/*
	 * Initialize statistical and informational data.
	 *
	 * This function is called in curl_easy_reset, curl_easy_duphandle and at the
	 * beginning of a perform session. It must reset the session-info variables,
	 * in particular all variables in struct PureInfo.
	 */
	public static  Curl_initinfo(Object data) {
		Progress pro = data.getProgress();
		PureInfo info = data.getInfo();
		pro.setT_nslookup(0);
		pro.setT_connect(0);
		pro.setT_appconnect(0);
		pro.setT_pretransfer(0);
		pro.setT_starttransfer(0);
		pro.setTimespent(0);
		pro.setT_redirect(0);
		pro.setIs_t_startransfer_set(.bool_false);
		info.setHttpcode(0);
		info.setHttpproxycode(0);
		info.setHttpversion(0);
		info.setFiletime(-/* -1 is an illegal time and thus means unknown */1);
		info.setTimecond(0);
		info.setHeader_size(0);
		info.setRequest_size(0);
		info.setProxyauthavail(0);
		info.setHttpauthavail(0);
		info.setNumconnects(0);
		.Curl_cfree(info.getContenttype());
		info.setContenttype(((Object)0));
		.Curl_cfree(info.getWouldredirect());
		info.setWouldredirect(((Object)0));
		info.getConn_primary_ip()[0] = (byte)'\0';
		info.getConn_local_ip()[0] = (byte)'\0';
		info.setConn_primary_port(0);
		info.setConn_local_port(0);
		info.setConn_scheme(0);
		info.setConn_protocol(0);
		return .CURLE_OK;
	}
	public static  getinfo_char(Object data,  info, Object param_charp) {
		switch (info) {
		case .CURLINFO_CONTENT_TYPE:
				param_charp = data.getInfo().getContenttype();
				break;
		case .CURLINFO_LOCAL_IP/* Return the source/local ip address of the most recent (primary)
		       connection */:
				param_charp = data.getInfo().getConn_local_ip();
				break;
		case .CURLINFO_FTP_ENTRY_PATH/* Return the entrypath string from the most recent connection.
		       This pointer was copied from the connectdata structure by FTP.
		       The actual string may be free()ed by subsequent libcurl calls so
		       it must be copied to a safer area before the next libcurl call.
		       Callers must never free it themselves. */:
				param_charp = data.getState().getMost_recent_ftp_entrypath();
				break;
		case .CURLINFO_REDIRECT_URL/* Return the URL this request would have been redirected to if that
		       option had been enabled! */:
				param_charp = data.getInfo().getWouldredirect();
				break;
		case .CURLINFO_PRIVATE:
				param_charp = (byte)data.getSet().getPrivate_data();
				break;
		case .CURLINFO_RTSP_SESSION_ID:
				param_charp = data.getSet().getStr()[dupstring.STRING_RTSP_SESSION_ID];
				break;
		case .CURLINFO_SCHEME:
				param_charp = data.getInfo().getConn_scheme();
				break;
		case .CURLINFO_EFFECTIVE_URL:
				param_charp = data.getChange().getUrl() ? data.getChange().getUrl() : (byte)"";
				break;
		case .CURLINFO_PRIMARY_IP:
				param_charp = data.getInfo().getConn_primary_ip();
				break;
		default:
				return .CURLE_UNKNOWN_OPTION;
		}
		return .CURLE_OK;
	}
	public static  getinfo_long(Object data,  info, Object param_longp) {
		curl_socket_t sockfd = new curl_socket_t();
		Object lptr;
		Object generatedTo_ulong = lptr.getTo_ulong();
		switch (info) {
		case .CURLINFO_REQUEST_SIZE:
				param_longp = (long)data.getInfo().getRequest_size();
				break;
		case .CURLINFO_LASTSOCKET:
				sockfd = ModernizedCProgram.Curl_getconnectinfo(data, ((Object)0));
				if (sockfd != (SOCKET)(~/* note: this is not a good conversion for systems with 64 bit sockets and
				       32 bit longs */0)) {
					param_longp = (long)sockfd;
				} else {
						param_longp = -/* this interface is documented to return -1 in case of badness, which
						         may not be the same as the CURL_SOCKET_BAD value */1;
				} 
				break;
		case .CURLINFO_FILETIME:
				if (data.getInfo().getFiletime() > -1024) {
					param_longp = -1024;
				}  else if (data.getInfo().getFiletime() < (--1024 - 1)) {
					param_longp = (--1024 - 1);
				} else {
						param_longp = (long)data.getInfo().getFiletime();
				} 
				break;
		case .CURLINFO_RTSP_SERVER_CSEQ:
				param_longp = data.getState().getRtsp_next_server_CSeq();
				break;
		case .CURLINFO_LOCAL_PORT:
				param_longp = data.getInfo().getConn_local_port();
				break;
		case .CURLINFO_RTSP_CSEQ_RECV:
				param_longp = data.getState().getRtsp_CSeq_recv();
				break;
		case .CURLINFO_HTTPAUTH_AVAIL:
				lptr.setTo_long(param_longp);
				generatedTo_ulong = data.getInfo().getHttpauthavail();
				break;
		case .CURLINFO_PROXYAUTH_AVAIL:
				lptr.setTo_long(param_longp);
				generatedTo_ulong = data.getInfo().getProxyauthavail();
				break;
		case .CURLINFO_RESPONSE_CODE:
				param_longp = data.getInfo().getHttpcode();
				break;
		case .CURLINFO_CONDITION_UNMET:
				param_longp = data.getInfo().getTimecond() ? -1024 : /* return if the condition prevented the document to get transferred */-1024;
				break;
		case .CURLINFO_PROTOCOL:
				param_longp = data.getInfo().getConn_protocol();
				break;
		case .CURLINFO_REDIRECT_COUNT:
				param_longp = data.getSet().getFollowlocation();
				break;
		case .CURLINFO_HEADER_SIZE:
				param_longp = (long)data.getInfo().getHeader_size();
				break;
		case .CURLINFO_HTTP_CONNECTCODE:
				param_longp = data.getInfo().getHttpproxycode();
				break;
		case .CURLINFO_RTSP_CLIENT_CSEQ:
				param_longp = data.getState().getRtsp_next_client_CSeq();
				break;
		case .CURLINFO_HTTP_VERSION:
				switch (data.getInfo().getHttpversion()) {
				case 10:
						param_longp = .CURL_HTTP_VERSION_1_0;
						break;
				case 11:
						param_longp = .CURL_HTTP_VERSION_1_1;
						break;
				case 30:
						param_longp = .CURL_HTTP_VERSION_3;
						break;
				case 20:
						param_longp = .CURL_HTTP_VERSION_2_0;
						break;
				default:
						param_longp = .CURL_HTTP_VERSION_NONE;
						break;
				}
				break;
		case .CURLINFO_SSL_VERIFYRESULT:
				param_longp = data.getSet().getSsl().getCertverifyresult();
				break;
		case .CURLINFO_OS_ERRNO:
				param_longp = data.getState().getOs_errno();
				break;
		case .CURLINFO_NUM_CONNECTS:
				param_longp = data.getInfo().getNumconnects();
				break;
		case .CURLINFO_PRIMARY_PORT:
				param_longp = data.getInfo().getConn_primary_port();
				break;
		case .CURLINFO_PROXY_SSL_VERIFYRESULT:
				param_longp = data.getSet().getProxy_ssl().getCertverifyresult();
				break;
		default:
				return .CURLE_UNKNOWN_OPTION;
		}
		return .CURLE_OK;
	}
	public static  getinfo_offt(Object data,  info, Object param_offt) {
		switch (info) {
		case .CURLINFO_FILETIME_T:
				param_offt = (curl_off_t)data.getInfo().getFiletime();
				break;
		case .CURLINFO_APPCONNECT_TIME_T:
				param_offt = data.getProgress().getT_appconnect();
				break;
		case .CURLINFO_STARTTRANSFER_TIME_T:
				param_offt = data.getProgress().getT_starttransfer();
				break;
		case .CURLINFO_SIZE_UPLOAD_T:
				param_offt = data.getProgress().getUploaded();
				break;
		case .CURLINFO_NAMELOOKUP_TIME_T:
				param_offt = data.getProgress().getT_nslookup();
				break;
		case .CURLINFO_SPEED_UPLOAD_T:
				param_offt = data.getProgress().getUlspeed();
				break;
		case .CURLINFO_CONNECT_TIME_T:
				param_offt = data.getProgress().getT_connect();
				break;
		case .CURLINFO_SIZE_DOWNLOAD_T:
				param_offt = data.getProgress().getDownloaded();
				break;
		case .CURLINFO_CONTENT_LENGTH_DOWNLOAD_T:
				param_offt = (data.getProgress().getFlags() & (1 << 6)) ? data.getProgress().getSize_dl() : -1;
				break;
		case .CURLINFO_TOTAL_TIME_T:
				param_offt = data.getProgress().getTimespent();
				break;
		case .CURLINFO_REDIRECT_TIME_T:
				param_offt = data.getProgress().getT_redirect();
				break;
		case .CURLINFO_SPEED_DOWNLOAD_T:
				param_offt = data.getProgress().getDlspeed();
				break;
		case .CURLINFO_RETRY_AFTER:
				param_offt = data.getInfo().getRetry_after();
				break;
		case .CURLINFO_PRETRANSFER_TIME_T:
				param_offt = data.getProgress().getT_pretransfer();
				break;
		case .CURLINFO_CONTENT_LENGTH_UPLOAD_T:
				param_offt = (data.getProgress().getFlags() & (1 << 5)) ? data.getProgress().getSize_ul() : -1;
				break;
		default:
				return .CURLE_UNKNOWN_OPTION;
		}
		return .CURLE_OK;
	}
	public static  getinfo_double(Object data,  info, Object param_doublep) {
		switch (info) {
		case .CURLINFO_TOTAL_TIME:
				param_doublep = (double)(data.getProgress().getTimespent()) / 1000000;
				break;
		case .CURLINFO_NAMELOOKUP_TIME:
				param_doublep = (double)(data.getProgress().getT_nslookup()) / 1000000;
				break;
		case .CURLINFO_SIZE_UPLOAD:
				param_doublep = (double)data.getProgress().getUploaded();
				break;
		case .CURLINFO_SIZE_DOWNLOAD:
				param_doublep = (double)data.getProgress().getDownloaded();
				break;
		case .CURLINFO_CONTENT_LENGTH_DOWNLOAD:
				param_doublep = (data.getProgress().getFlags() & (1 << 6)) ? (double)data.getProgress().getSize_dl() : -1;
				break;
		case .CURLINFO_SPEED_UPLOAD:
				param_doublep = (double)data.getProgress().getUlspeed();
				break;
		case .CURLINFO_REDIRECT_TIME:
				param_doublep = (double)(data.getProgress().getT_redirect()) / 1000000;
				break;
		case .CURLINFO_APPCONNECT_TIME:
				param_doublep = (double)(data.getProgress().getT_appconnect()) / 1000000;
				break;
		case .CURLINFO_STARTTRANSFER_TIME:
				param_doublep = (double)(data.getProgress().getT_starttransfer()) / 1000000;
				break;
		case .CURLINFO_CONNECT_TIME:
				param_doublep = (double)(data.getProgress().getT_connect()) / 1000000;
				break;
		case .CURLINFO_PRETRANSFER_TIME:
				param_doublep = (double)(data.getProgress().getT_pretransfer()) / 1000000;
				break;
		case .CURLINFO_CONTENT_LENGTH_UPLOAD:
				param_doublep = (data.getProgress().getFlags() & (1 << 5)) ? (double)data.getProgress().getSize_ul() : -1;
				break;
		case .CURLINFO_SPEED_DOWNLOAD:
				param_doublep = (double)data.getProgress().getDlspeed();
				break;
		default:
				return .CURLE_UNKNOWN_OPTION;
		}
		return .CURLE_OK;
	}
	public static  getinfo_slist(Object data,  info, Object param_slistp) {
		Object ptr;
		Object generatedTo_slist = ptr.getTo_slist();
		switch (info) {
		case .CURLINFO_COOKIELIST:
				param_slistp = ModernizedCProgram.Curl_cookie_list(data);
				break;
		case .CURLINFO_SSL_ENGINES:
				param_slistp = ((Object)0);
				break;
		case .CURLINFO_TLS_SESSION:
		case .CURLINFO_CERTINFO/* Return the a pointer to the certinfo struct. Not really an slist
		       pointer but we can pretend it is here */:
				ptr.setTo_certinfo(data.getInfo().getCerts());
				param_slistp = generatedTo_slist;
				break;
		case .CURLINFO_TLS_SSL_PTR:
				{ 
					curl_tlssessioninfo tsip = (curl_tlssessioninfo)param_slistp;
					curl_tlssessioninfo tsi = data.getTsi();
					tsip = tsi;
					tsi.setBackend(.Curl_ssl_backend());
					tsi.setInternals(((Object)0));
				}
				break;
		default:
				return .CURLE_UNKNOWN_OPTION;
		}
		return .CURLE_OK;
	}
	public static  getinfo_socket(Object data,  info, Object param_socketp) {
		switch (info) {
		case .CURLINFO_ACTIVESOCKET:
				param_socketp = ModernizedCProgram.Curl_getconnectinfo(data, ((Object)0));
				break;
		default:
				return .CURLE_UNKNOWN_OPTION;
		}
		return .CURLE_OK;
	}
	public static  Curl_getinfo(Object data,  info) {
		va_list arg = new va_list();
		long param_longp = ((Object)0);
		double param_doublep = ((Object)0);
		curl_off_t param_offt = ((Object)0);
		byte param_charp = ((Object)0);
		curl_slist param_slistp = ((Object)0);
		curl_socket_t param_socketp = ((Object)0);
		int type;
		CURLcode result = .CURLE_UNKNOWN_OPTION;
		if (!data) {
			return result;
		} 
		.__builtin_va_start(arg, info);
		type = -1024 & (int)info;
		switch (type) {
		case -1024:
				param_doublep = (int)arg;
				if (param_doublep) {
					result = ModernizedCProgram.getinfo_double(data, info, param_doublep);
				} 
				break;
		case -1024:
				param_longp = (int)arg;
				if (param_longp) {
					result = ModernizedCProgram.getinfo_long(data, info, param_longp);
				} 
				break;
		case -1024:
				param_offt = (int)arg;
				if (param_offt) {
					result = ModernizedCProgram.getinfo_offt(data, info, param_offt);
				} 
				break;
		case -1024:
				param_socketp = (int)arg;
				if (param_socketp) {
					result = ModernizedCProgram.getinfo_socket(data, info, param_socketp);
				} 
				break;
		case -1024:
				param_charp = (int)arg;
				if (param_charp) {
					result = ModernizedCProgram.getinfo_char(data, info, param_charp);
				} 
				break;
		case -1024:
				param_slistp = (int)arg;
				if (param_slistp) {
					result = ModernizedCProgram.getinfo_slist(data, info, param_slistp);
				} 
				break;
		default:
				break;
		}
		.__builtin_va_end(arg);
		return result;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	public static Object Curl_strtok_r(Object ptr, Object sep, Object end) {
		if (!ptr) {
			ptr = /* we got NULL input so then we get our last position instead */end;
		} 
		while (ptr && .strchr(sep, /* pass all letters that are including in the separator string */ptr)) {
			++ptr;
		}
		if (ptr) {
			byte start = /* so this is where the next piece of string starts */ptr;
			end = start + /* set the end pointer to the first byte after the start */1;
			while (end && !.strchr(sep, /* scan through the string to find where it ends, it ends on a
			       null byte or a character that exists in the separator string */end)) {
				++end;
			}
			if (end) {
				end = /* the end is not a null byte *//* zero terminate it! */(byte)'\0';
				++/* advance the last pointer to beyond the null byte */end;
			} 
			return /* return the position where the string starts */start;
		} 
		return ((Object)/* we ended up on a null byte, there are no more strings to find! */0/* this was only compiled if strtok_r wasn't present */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* check rate limits within this many recent milliseconds, at minimum. */
	/* Provide a string that is 2 + 1 + 2 + 1 + 2 = 8 letters long (plus the zero
	   byte) */
	/* Provide a string that is 2 + 1 + 2 + 1 + 2 = 8 letters long (plus the zero
	   byte) */
	public static void time2str(Object r, Object seconds) {
		curl_off_t h = new curl_off_t();
		if (seconds <= 0) {
			.strcpy(r, "--:--:--");
			return ;
		} 
		h = seconds / -1024;
		if (h <= -1024) {
			curl_off_t m = (seconds - (h * -1024)) / -1024;
			curl_off_t s = (seconds - (h * -1024)) - (m * -1024);
			ModernizedCProgram.curl_msnprintf(r, 9, "%2I64d:%02I64d:%02I64d", h, m, s);
		} else {
				curl_off_t d = seconds / /* this equals to more than 99 hours, switch to a more suitable output
				       format to fit within the limits. */-1024;
				h = (seconds - (d * -1024)) / -1024;
				if (d <= -1024) {
					ModernizedCProgram.curl_msnprintf(r, 9, "%3I64dd %02I64dh", d, h);
				} else {
						ModernizedCProgram.curl_msnprintf(r, 9, "%7I64dd", d);
				} 
		} 
		curl_off_t h = new curl_off_t();
		if (seconds <= 0) {
			.strcpy(r, "--:--:--");
			return ;
		} 
		h = seconds / -1024;
		if (h <= -1024) {
			curl_off_t m = (seconds - (h * -1024)) / -1024;
			curl_off_t s = (seconds - (h * -1024)) - (m * -1024);
			ModernizedCProgram.curl_msnprintf(r, 9, "%2I64d:%02I64d:%02I64d", h, m, s);
		} else {
				curl_off_t d = seconds / /* this equals to more than 99 hours, switch to a more suitable output
				       format to fit within the limits. */-1024;
				h = (seconds - (d * -1024)) / -1024;
				if (d <= -1024) {
					ModernizedCProgram.curl_msnprintf(r, 9, "%3I64dd %02I64dh", d, h);
				} else {
						ModernizedCProgram.curl_msnprintf(r, 9, "%7I64dd", d);
				} 
		} 
	}
	/* The point of this function would be to return a string of the input data,
	   but never longer than 5 columns (+ one zero byte).
	   Add suffix k, M, G when suitable... */
	public static Object max5data(Object bytes, Object max5) {
		if (bytes < -1024) {
			ModernizedCProgram.curl_msnprintf(max5, 6, "%5I64d", bytes);
		}  else if (bytes < -1024 * -1024) {
			ModernizedCProgram.curl_msnprintf(max5, 6, "%4I64dk", bytes / -1024);
		}  else if (bytes < -1024 * (-1024 * -1024)) {
			ModernizedCProgram.curl_msnprintf(max5, 6, /* 'XX.XM' is good as long as we're less than 100 megs */"%2I64d.%0I64dM", bytes / (-1024 * -1024), (bytes % (-1024 * -1024)) / ((-1024 * -1024) / -1024));
		}  else if (bytes < -1024 * (-1024 * -1024)) {
			ModernizedCProgram.curl_msnprintf(max5, 6, "%4I64dM", bytes / (-1024 * /* 'XXXXM' is good until we're at 10000MB or above */-1024));
		}  else if (bytes < -1024 * (-1024 * (-1024 * -1024))) {
			ModernizedCProgram.curl_msnprintf(max5, 6, /* 10000 MB - 100 GB, we show it as XX.XG */"%2I64d.%0I64dG", bytes / (-1024 * (-1024 * -1024)), (bytes % (-1024 * (-1024 * -1024))) / ((-1024 * (-1024 * -1024)) / -1024));
		}  else if (bytes < -1024 * (-1024 * (-1024 * -1024))) {
			ModernizedCProgram.curl_msnprintf(max5, 6, "%4I64dG", bytes / (-1024 * (-1024 * /* up to 10000GB, display without decimal: XXXXG */-1024)));
		}  else if (bytes < -1024 * (-1024 * (-1024 * (-1024 * -1024)))) {
			ModernizedCProgram.curl_msnprintf(max5, 6, "%4I64dT", bytes / (-1024 * (-1024 * (-1024 * /* up to 10000TB, display without decimal: XXXXT */-1024))));
		} else {
				ModernizedCProgram.curl_msnprintf(max5, 6, "%4I64dP", bytes / (-1024 * (-1024 * (-1024 * (-1024 * /* up to 10000PB, display without decimal: XXXXP */-1024/* 16384 petabytes (16 exabytes) is the maximum a 64 bit unsigned number
				       can hold, but our data type is signed so 8192PB will be the maximum. */)))));
		} 
		return max5/*
		
		   New proposed interface, 9th of February 2000:
		
		   pgrsStartNow() - sets start time
		   pgrsSetDownloadSize(x) - known expected download size
		   pgrsSetUploadSize(x) - known expected upload size
		   pgrsSetDownloadCounter() - amount of data currently downloaded
		   pgrsSetUploadCounter() - amount of data currently uploaded
		   pgrsUpdate() - show progress
		   pgrsDone() - transfer complete
		
		*/;
		if (bytes < -1024) {
			ModernizedCProgram.curl_msnprintf(max5, 6, "%5I64d", bytes);
		}  else if (bytes < -1024 * -1024) {
			ModernizedCProgram.curl_msnprintf(max5, 6, "%4I64dk", bytes / -1024);
		}  else if (bytes < -1024 * (-1024 * -1024)) {
			ModernizedCProgram.curl_msnprintf(max5, 6, /* 'XX.XM' is good as long as we're less than 100 megs */"%2I64d.%0I64dM", bytes / (-1024 * -1024), (bytes % (-1024 * -1024)) / ((-1024 * -1024) / -1024));
		}  else if (bytes < -1024 * (-1024 * -1024)) {
			ModernizedCProgram.curl_msnprintf(max5, 6, "%4I64dM", bytes / (-1024 * /* 'XXXXM' is good until we're at 10000MB or above */-1024));
		}  else if (bytes < -1024 * (-1024 * (-1024 * -1024))) {
			ModernizedCProgram.curl_msnprintf(max5, 6, /* 10000 MB - 100 GB, we show it as XX.XG */"%2I64d.%0I64dG", bytes / (-1024 * (-1024 * -1024)), (bytes % (-1024 * (-1024 * -1024))) / ((-1024 * (-1024 * -1024)) / -1024));
		}  else if (bytes < -1024 * (-1024 * (-1024 * -1024))) {
			ModernizedCProgram.curl_msnprintf(max5, 6, "%4I64dG", bytes / (-1024 * (-1024 * /* up to 10000GB, display without decimal: XXXXG */-1024)));
		}  else if (bytes < -1024 * (-1024 * (-1024 * (-1024 * -1024)))) {
			ModernizedCProgram.curl_msnprintf(max5, 6, "%4I64dT", bytes / (-1024 * (-1024 * (-1024 * /* up to 10000TB, display without decimal: XXXXT */-1024))));
		} else {
				ModernizedCProgram.curl_msnprintf(max5, 6, "%4I64dP", bytes / (-1024 * (-1024 * (-1024 * (-1024 * /* up to 10000PB, display without decimal: XXXXP */-1024/* 16384 petabytes (16 exabytes) is the maximum a 64 bit unsigned number
				       can hold, but our data type is signed so 8192PB will be the maximum. */)))));
		} 
		return max5;
	}
	public static int Curl_pgrsDone(Object conn) {
		int rc;
		Curl_easy data = conn.getData();
		data.getProgress().setLastshow(0);
		rc = ModernizedCProgram.Curl_pgrsUpdate(/* the final (forced) update */conn);
		if (rc) {
			return rc;
		} 
		if (!(data.getProgress().getFlags() & (1 << 4)) && !data.getProgress().getCallback()) {
			ModernizedCProgram.curl_mfprintf(data.getSet().getErr(), "\n");
		} 
		data.getProgress().setSpeeder_c(/* reset the progress meter display */0);
		return 0;
	}
	/* reset the known transfer sizes */
	public static void Curl_pgrsResetTransferSizes(Object data) {
		ModernizedCProgram.Curl_pgrsSetDownloadSize(data, -1);
		ModernizedCProgram.Curl_pgrsSetUploadSize(data, -1/*
		 * @unittest: 1399
		 */);
	}
	public static void Curl_pgrsTime(Object data,  timer) {
		curltime curltime = new curltime();
		curltime now = curltime.Curl_now();
		timediff_t delta = ((Object)0);
		switch (timer) {
		case .TIMER_NONE/* mistake filter */:
				break;
		case .TIMER_STARTOP:
				data.getProgress().setT_startop(/* This is set at the start of a transfer */now);
				break;
		case .TIMER_APPCONNECT:
				delta = data.getProgress().getT_appconnect();
				break;
		case .TIMER_PRETRANSFER:
				delta = data.getProgress().getT_pretransfer();
				break;
		case .TIMER_STARTSINGLE:
				data.getProgress().setT_startsingle(/* This is set at the start of each single fetch */now);
				data.getProgress().setIs_t_startransfer_set(.bool_false);
				break;
		case .TIMER_POSTRANSFER/* this is the normal end-of-transfer thing */:
				break;
		case .TIMER_STARTACCEPT:
				data.getProgress().setT_acceptdata(now);
				break;
		case .TIMER_NAMELOOKUP:
				delta = data.getProgress().getT_nslookup();
				break;
		case .TIMER_STARTTRANSFER:
				delta = data.getProgress().getT_starttransfer();
				if (data.getProgress().getIs_t_startransfer_set()) {
					return ;
				} else {
						data.getProgress().setIs_t_startransfer_set(.bool_true);
						break;
				} 
		case .TIMER_CONNECT:
				delta = data.getProgress().getT_connect();
				break;
		case .TIMER_REDIRECT:
				data.getProgress().setT_redirect(now.Curl_timediff_us(data.getProgress().getStart()));
				break;
		default:
		}
		if (delta) {
			timediff_t us = now.Curl_timediff_us(data.getProgress().getT_startsingle());
			if (us < 1) {
				us = /* make sure at least one microsecond passed */1;
			} 
			delta += us;
		} 
	}
	public static void Curl_pgrsStartNow(Object data) {
		data.getProgress().setSpeeder_c(/* reset the progress meter display */0);
		curltime curltime = new curltime();
		data.getProgress().setStart(curltime.Curl_now());
		data.getProgress().setIs_t_startransfer_set(.bool_false);
		data.getProgress().getUl_limit_start().setTv_sec(0);
		data.getProgress().getUl_limit_start().setTv_usec(0);
		data.getProgress().getDl_limit_start().setTv_sec(0);
		data.getProgress().getDl_limit_start().setTv_usec(0);
		data.getProgress().setDownloaded(0);
		data.getProgress().setUploaded(0);
		data.getProgress().getFlags() &=  (1 << 4) | (1 << /* clear all bits except HIDE and HEADERS_OUT */7);
		data.getProgress().getStart().Curl_ratelimit(data);
	}
	public static void Curl_pgrsSetDownloadCounter(Object data, Object size) {
		data.getProgress().setDownloaded(size/*
		 * Update the timestamp and sizestamp to use for rate limit calculations.
		 */);
	}
	/*
	 * Set the number of uploaded bytes so far.
	 */
	public static void Curl_pgrsSetUploadCounter(Object data, Object size) {
		data.getProgress().setUploaded(size);
	}
	public static void Curl_pgrsSetDownloadSize(Object data, Object size) {
		if (size >= 0) {
			data.getProgress().setSize_dl(size);
			data.getProgress().getFlags() |=  (1 << 6);
		} else {
				data.getProgress().setSize_dl(0);
				data.getProgress().getFlags() &=  ~(1 << 6);
		} 
	}
	public static void Curl_pgrsSetUploadSize(Object data, Object size) {
		if (size >= 0) {
			data.getProgress().setSize_ul(size);
			data.getProgress().getFlags() |=  (1 << 5);
		} else {
				data.getProgress().setSize_ul(0);
				data.getProgress().getFlags() &=  ~(1 << 5);
		} 
	}
	public static void progress_meter(Object conn) {
		Curl_easy data = conn.getData();
		byte[][] max5 = new byte[6][10];
		curl_off_t dlpercen = 0;
		curl_off_t ulpercen = 0;
		curl_off_t total_percen = 0;
		curl_off_t total_transfer = new curl_off_t();
		curl_off_t total_expected_transfer = new curl_off_t();
		byte[] time_left = new byte[10];
		byte[] time_total = new byte[10];
		byte[] time_spent = new byte[10];
		curl_off_t ulestimate = 0;
		curl_off_t dlestimate = 0;
		curl_off_t total_estimate = new curl_off_t();
		curl_off_t timespent = (curl_off_t)data.getProgress().getTimespent() / /* seconds */1000000;
		if (!(data.getProgress().getFlags() & (1 << 7))) {
			if (data.getState().getResume_from()) {
				ModernizedCProgram.curl_mfprintf(data.getSet().getErr(), "** Resuming transfer from byte position %I64d\n", data.getState().getResume_from());
			} 
			ModernizedCProgram.curl_mfprintf(data.getSet().getErr(), "  %% Total    %% Received %% Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n");
			data.getProgress().getFlags() |=  (1 << /* headers are shown */7);
		} 
		if ((data.getProgress().getFlags() & (1 << /* Figure out the estimated time of arrival for the upload */5)) && (data.getProgress().getUlspeed() > -1024)) {
			ulestimate = data.getProgress().getSize_ul() / data.getProgress().getUlspeed();
			if (data.getProgress().getSize_ul() > -1024) {
				ulpercen = data.getProgress().getUploaded() / (data.getProgress().getSize_ul() / -1024);
			}  else if (data.getProgress().getSize_ul() > -1024) {
				ulpercen = (data.getProgress().getUploaded() * 100) / data.getProgress().getSize_ul();
			} 
		} 
		if ((data.getProgress().getFlags() & (1 << /* ... and the download */6)) && (data.getProgress().getDlspeed() > -1024)) {
			dlestimate = data.getProgress().getSize_dl() / data.getProgress().getDlspeed();
			if (data.getProgress().getSize_dl() > -1024) {
				dlpercen = data.getProgress().getDownloaded() / (data.getProgress().getSize_dl() / -1024);
			}  else if (data.getProgress().getSize_dl() > -1024) {
				dlpercen = (data.getProgress().getDownloaded() * 100) / data.getProgress().getSize_dl();
			} 
		} 
		total_estimate = ulestimate > dlestimate ? ulestimate : /* Now figure out which of them is slower and use that one for the
		     total estimate! */dlestimate;
		ModernizedCProgram.time2str(time_left, total_estimate > 0 ? (total_estimate - timespent) : /* create the three time strings */0);
		ModernizedCProgram.time2str(time_total, total_estimate);
		ModernizedCProgram.time2str(time_spent, timespent);
		/* Get the total amount of data expected to get transferred */total_expected_transfer = ((data.getProgress().getFlags() & (1 << 5)) ? data.getProgress().getSize_ul() : data.getProgress().getUploaded()) + ((data.getProgress().getFlags() & (1 << 6)) ? data.getProgress().getSize_dl() : data.getProgress().getDownloaded());
		total_transfer = data.getProgress().getDownloaded() + data.getProgress().getUploaded();
		if (total_expected_transfer > /* Get the percentage of data transferred so far */-1024) {
			total_percen = total_transfer / (total_expected_transfer / -1024);
		}  else if (total_expected_transfer > -1024) {
			total_percen = (total_transfer * 100) / total_expected_transfer;
		} 
		ModernizedCProgram.curl_mfprintf(data.getSet().getErr(), "\r%3I64d %s  %3I64d %s  %3I64d %s  %s  %s %s %s %s %s", /* 3 letters *//* total % */total_percen, ModernizedCProgram.max5data(total_expected_transfer, max5[/* total size */2]), /* 3 letters *//* rcvd % */dlpercen, ModernizedCProgram.max5data(data.getProgress().getDownloaded(), max5[/* rcvd size */0]), /* 3 letters *//* xfer % */ulpercen, ModernizedCProgram.max5data(data.getProgress().getUploaded(), max5[/* xfer size */1]), ModernizedCProgram.max5data(data.getProgress().getDlspeed(), max5[/* avrg dl speed */3]), ModernizedCProgram.max5data(data.getProgress().getUlspeed(), max5[/* avrg ul speed */4]), /* 8 letters *//* total time */time_total, /* 8 letters *//* time spent */time_spent, /* 8 letters *//* time left */time_left, ModernizedCProgram.max5data(data.getProgress().getCurrent_speed(), max5[5]));
		.fflush(data.getSet().getErr());
		timeval stamp = new timeval();
		bool header = 0;
		timeval now = new timeval();
		long diff;
		if (global.getNoprogress()) {
			return 0;
		} 
		timeval timeval = new timeval();
		now = timeval.tvnow();
		diff = now.tvdiff(stamp);
		if (!header) {
			header = 1;
			.fputs("DL% UL%  Dled  Uled  Xfers  Live   Qd Total     Current  Left    Speed\n", global.getErrors());
		} 
		if (final || (diff > 500)) {
			byte[] time_left = new byte[10];
			byte[] time_total = new byte[10];
			byte[] time_spent = new byte[10];
			byte[][] buffer = new byte[3][6];
			curl_off_t spent = now.tvdiff(start) / 1000;
			byte[] dlpercen = "--";
			byte[] ulpercen = "--";
			per_transfer per = new per_transfer();
			curl_off_t all_dlnow = 0;
			curl_off_t all_ulnow = 0;
			bool dlknown = 1;
			bool ulknown = 1;
			curl_off_t all_running = /* in progress */0;
			curl_off_t all_queued = /* pending */0;
			curl_off_t speed = 0;
			int i;
			stamp = now;
			all_dlnow += /* first add the amounts of the already completed transfers */ModernizedCProgram.all_dlalready;
			all_ulnow += ModernizedCProgram.all_ulalready;
			for (per = ModernizedCProgram.transfers; per; per = per.getNext()) {
				all_dlnow += per.getDlnow();
				all_ulnow += per.getUlnow();
				if (!per.getDltotal()) {
					dlknown = 0;
				}  else if (!per.getDltotal_added()) {
					ModernizedCProgram.all_dltotal += per.getDltotal();
					per.setDltotal_added(1);
				} 
				if (!per.getUltotal()) {
					ulknown = 0;
				}  else if (!per.getUltotal_added()) {
					ModernizedCProgram.all_ultotal += per.getUltotal();
					per.setUltotal_added(1);
				} 
				if (!per.getAdded()) {
					all_queued++;
				} else {
						all_running++;
				} 
			}
			if (dlknown && ModernizedCProgram.all_dltotal) {
				ModernizedCProgram.curl_msnprintf(dlpercen, , /* TODO: handle integer overflow */"%3d", all_dlnow * 100 / ModernizedCProgram.all_dltotal);
			} 
			if (ulknown && ModernizedCProgram.all_ultotal) {
				ModernizedCProgram.curl_msnprintf(ulpercen, , /* TODO: handle integer overflow */"%3d", all_ulnow * 100 / ModernizedCProgram.all_ultotal);
			} 
			i = /* get the transfer speed, the higher of the two */ModernizedCProgram.speedindex;
			ModernizedCProgram.speedstore[i].setDl(all_dlnow);
			ModernizedCProgram.speedstore[i].setUl(all_ulnow);
			ModernizedCProgram.speedstore[i].setStamp(now);
			if (++ModernizedCProgram.speedindex >= 10) {
				ModernizedCProgram.indexwrapped = 1;
				ModernizedCProgram.speedindex = 0;
			} 
			{ 
				long deltams;
				curl_off_t dl = new curl_off_t();
				curl_off_t ul = new curl_off_t();
				curl_off_t dls = new curl_off_t();
				curl_off_t uls = new curl_off_t();
				if (ModernizedCProgram.indexwrapped) {
					deltams = now.tvdiff(ModernizedCProgram.speedstore[ModernizedCProgram.speedindex].getStamp());
					dl = all_dlnow - ModernizedCProgram.speedstore[ModernizedCProgram.speedindex].getDl();
					ul = all_ulnow - ModernizedCProgram.speedstore[ModernizedCProgram.speedindex].getUl();
				} else {
						deltams = now.tvdiff(/* since the beginning */start);
						dl = all_dlnow;
						ul = all_ulnow;
				} 
				dls = (curl_off_t)((double)dl / ((double)deltams / 1000.0));
				uls = (curl_off_t)((double)ul / ((double)deltams / 1000.0));
				speed = dls > uls ? dls : uls;
			}
			if (dlknown && speed) {
				curl_off_t est = ModernizedCProgram.all_dltotal / speed;
				curl_off_t left = (ModernizedCProgram.all_dltotal - all_dlnow) / speed;
				ModernizedCProgram.time2str(time_left, left);
				ModernizedCProgram.time2str(time_total, est);
			} else {
					ModernizedCProgram.time2str(time_left, 0);
					ModernizedCProgram.time2str(time_total, 0);
			} 
			ModernizedCProgram.time2str(time_spent, spent);
			ModernizedCProgram.curl_mfprintf(global.getErrors(), "\r%-3s %-3s %s %s %5I64d %5I64d %5I64d %s %s %s %s %5s"/* percent downloaded *//* percent uploaded *//* Dled *//* Uled *//* Xfers *//* Live */, /* Queued *//* Total time *//* Current time *//* Time left *//* Speed *//* final newline *//* 3 letters */dlpercen, /* 3 letters */ulpercen, ModernizedCProgram.max5data(all_dlnow, buffer[0]), ModernizedCProgram.max5data(all_ulnow, buffer[1]), ModernizedCProgram.all_xfers, all_running, all_queued, time_total, time_spent, time_left, ModernizedCProgram.max5data(speed, buffer[/* speed */2]), final ? "\n" : "");
			return 1;
		} 
		return 0;
	}
	/*
	 * Curl_pgrsUpdate() returns 0 for success or the value returned by the
	 * progress callback!
	 */
	public static int Curl_pgrsUpdate(Object conn) {
		Curl_easy data = conn.getData();
		curltime curltime = new curltime();
		curltime now = curltime.Curl_now();
		bool showprogress = now.progress_calc(conn);
		if (!(data.getProgress().getFlags() & (1 << 4))) {
			if (data.getSet().getFxferinfo()) {
				int result;
				ModernizedCProgram.Curl_set_in_callback(data, /* There's a callback set, call that */.bool_true);
				result = .UNRECOGNIZEDFUNCTIONNAME(data.getSet().getProgress_client(), data.getProgress().getSize_dl(), data.getProgress().getDownloaded(), data.getProgress().getSize_ul(), data.getProgress().getUploaded());
				ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
				if (result) {
					ModernizedCProgram.Curl_failf(data, "Callback aborted");
				} 
				return result;
			} 
			if (data.getSet().getFprogress()) {
				int result;
				ModernizedCProgram.Curl_set_in_callback(data, /* The older deprecated callback is set, call that */.bool_true);
				result = .UNRECOGNIZEDFUNCTIONNAME(data.getSet().getProgress_client(), (double)data.getProgress().getSize_dl(), (double)data.getProgress().getDownloaded(), (double)data.getProgress().getSize_ul(), (double)data.getProgress().getUploaded());
				ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
				if (result) {
					ModernizedCProgram.Curl_failf(data, "Callback aborted");
				} 
				return result;
			} 
			if (showprogress) {
				ModernizedCProgram.progress_meter(conn);
			} 
		} 
		return 0;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2012, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* keep this as LAST include */
	public static Object tool_basename(Object path) {
		byte s1;
		byte s2;
		s1 = .strrchr(path, (byte)'/');
		s2 = .strrchr(path, (byte)'\\');
		if (s1 && s2) {
			path = (s1 > s2) ? s1 + 1 : s2 + 1;
		}  else if (s1) {
			path = s1 + 1;
		}  else if (s2) {
			path = s2 + 1;
		} 
		return path/* HAVE_BASENAME */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* Test example headers:
	
	WWW-Authenticate: Digest realm="testrealm", nonce="1053604598"
	Proxy-Authenticate: Digest realm="testrealm", nonce="1053604598"
	
	*/
	public static  Curl_input_digest(Object conn,  proxy, Object header) {
		Curl_easy data = conn.getData();
		/* Point to the correct struct with this */digestdata digest = new digestdata();
		if (proxy) {
			digest = data.getState().getProxydigest();
		} else {
				digest = data.getState().getDigest();
		} 
		if (!ModernizedCProgram.curl_strnequal("Digest", header, .strlen("Digest"))) {
			return .CURLE_BAD_CONTENT_ENCODING;
		} 
		header += .strlen("Digest");
		while (header && (ModernizedCProgram.Curl_isspace((int)((byte)header)))) {
			header++;
		}
		return .Curl_auth_decode_digest_http_message(header, digest);
	}
	/* rest of the *-authenticate:
	                                                  header */
	public static  Curl_output_digest(Object conn,  proxy, Object request, Object uripath) {
		CURLcode result = new CURLcode();
		Curl_easy data = conn.getData();
		byte path = ((Object)0);
		byte tmp = ((Object)0);
		byte response;
		size_t len = new size_t();
		bool have_chlg = new bool();
		/* Point to the address of the pointer that holds the string to send to the
		     server, which is for a plain host or for a HTTP proxy */
		byte allocuserpwd;
		/* Point to the name and password for this */byte userp;
		byte passwdp;
		/* Point to the correct struct with this */digestdata digest = new digestdata();
		auth authp = new auth();
		if (proxy) {
			digest = data.getState().getProxydigest();
			allocuserpwd = conn.getAllocptr().getProxyuserpwd();
			userp = conn.getHttp_proxy().getUser();
			passwdp = conn.getHttp_proxy().getPasswd();
			authp = data.getState().getAuthproxy();
		} else {
				digest = data.getState().getDigest();
				allocuserpwd = conn.getAllocptr().getUserpwd();
				userp = conn.getUser();
				passwdp = conn.getPasswd();
				authp = data.getState().getAuthhost();
		} 
		do {
			.Curl_cfree((allocuserpwd));
			(allocuserpwd) = ((Object)0);
		} while (0);
		if (!/* not set means empty */userp) {
			userp = "";
		} 
		if (!passwdp) {
			passwdp = "";
		} 
		have_chlg = digest.getNonce() ? 1 : 0;
		if (!have_chlg) {
			authp.setDone(0);
			return .CURLE_OK/* So IE browsers < v7 cut off the URI part at the query part when they
			     evaluate the MD5 and some (IIS?) servers work with them so we may need to
			     do the Digest IE-style. Note that the different ways cause different MD5
			     sums to get sent.
			
			     Apache servers can be set to do the Digest IE-style automatically using
			     the BrowserMatch feature:
			     https://httpd.apache.org/docs/2.2/mod/mod_auth_digest.html#msie
			
			     Further details on Digest implementation differences:
			     http://www.fngtps.com/2006/09/http-authentication
			  */;
		} 
		if (authp.getIestyle()) {
			tmp = .strchr((byte)uripath, (byte)'?');
			if (tmp) {
				size_t urilen = tmp - (byte)uripath;
				path = (byte)ModernizedCProgram.curl_maprintf("%.*s", urilen, uripath);
			} 
		} 
		if (!tmp) {
			path = (byte).Curl_cstrdup((byte)uripath);
		} 
		if (!path) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		result = .Curl_auth_create_digest_http_message(data, userp, passwdp, request, path, digest, response, len);
		.Curl_cfree(path);
		if (result) {
			return result;
		} 
		allocuserpwd = ModernizedCProgram.curl_maprintf("%sAuthorization: Digest %s\r\n", proxy ? "Proxy-" : "", response);
		.Curl_cfree(response);
		if (!allocuserpwd) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		authp.setDone(1);
		return .CURLE_OK;
	}
	public static void Curl_http_auth_cleanup_digest(Object data) {
		.Curl_auth_digest_cleanup(data.getState().getDigest());
		.Curl_auth_digest_cleanup(data.getState().getProxydigest());
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/*
	 * Helper read-from-socket functions. Does the same as Curl_read() but it
	 * blocks until all bytes amount of buffersize will be read. No more, no less.
	 *
	 * This is STUPID BLOCKING behaviour which we frown upon, but right now this
	 * is what we have...
	 */
	/* connection data */
	public static int Curl_blockread_all(Object conn, Object sockfd, Object buf, Object buffersize, Object n) {
		ssize_t nread = /* max amount to read *//* amount bytes read */0;
		ssize_t allread = 0;
		int result;
		n = 0;
		for (; ; ) {
			timediff_t timeleft = ModernizedCProgram.Curl_timeleft(conn.getData(), ((Object)0), 1);
			if (timeleft < 0) {
				result = /* we already got the timeout */.CURLE_OPERATION_TIMEDOUT;
				break;
			} 
			if (ModernizedCProgram.Curl_socket_check(sockfd, (SOCKET)(~0), (SOCKET)(~0), (time_t)timeleft) <= 0) {
				result = ~.CURLE_OK;
				break;
			} 
			result = ModernizedCProgram.Curl_read_plain(sockfd, buf, buffersize, nread);
			if (.CURLE_AGAIN == result) {
				continue;
			} 
			if (result) {
				break;
			} 
			if (buffersize == nread) {
				allread += nread;
				n = allread;
				result = .CURLE_OK;
				break;
			} 
			if (!nread) {
				result = ~.CURLE_OK;
				break;
			} 
			buffersize -= nread;
			buf += nread;
			allread += nread;
		}
		return result/*
		* This function logs in to a SOCKS4 proxy and sends the specifics to the final
		* destination server.
		*
		* Reference :
		*   https://www.openssh.com/txt/socks4.protocol
		*
		* Note :
		*   Set protocol4a=true for  "SOCKS 4A (Simple Extension to SOCKS 4 Protocol)"
		*   Nonsupport "Identification Protocol (RFC1413)"
		*/;
	}
	/* read from this socket */
	/* store read data here */
	public static  Curl_SOCKS4(Object proxy_user, Object hostname, int remote_port, int sockindex, Object conn) {
		bool protocol4a = (conn.getSocks_proxy().getProxytype() == .CURLPROXY_SOCKS4A) ? 1 : 0;
		byte[] socksreq = new byte[/* room for SOCKS4 request incl. user
		                                           id */262];
		CURLcode code = new CURLcode();
		curl_socket_t sock = conn.getSock()[sockindex];
		Curl_easy data = conn.getData();
		if (ModernizedCProgram.Curl_timeleft(data, ((Object)0), 1) < 0) {
			ModernizedCProgram.Curl_failf(data, /* time-out, bail out, go home */"Connection time-out");
			return .CURLE_OPERATION_TIMEDOUT;
		} 
		if (conn.getBits().getHttpproxy()) {
			ModernizedCProgram.Curl_infof(conn.getData(), "SOCKS4%s: connecting to HTTP proxy %s port %d\n", protocol4a ? "a" : "", hostname, remote_port);
		} 
		(Object)ModernizedCProgram.curlx_nonblock(sock, 0);
		ModernizedCProgram.Curl_infof(data, "SOCKS4 communication to %s:%d\n", hostname, remote_port/*
		   * Compose socks4 request
		   *
		   * Request format
		   *
		   *     +----+----+----+----+----+----+----+----+----+----+....+----+
		   *     | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|
		   *     +----+----+----+----+----+----+----+----+----+----+....+----+
		   * # of bytes:  1    1      2              4           variable       1
		   */);
		socksreq[0] = /* version (SOCKS4) */4;
		socksreq[1] = /* connect */1;
		socksreq[2] = (byte)((remote_port >> 8) & /* PORT MSB */-1024);
		socksreq[3] = (byte)(remote_port & /* PORT LSB */-1024);
		if (!/* DNS resolve only for SOCKS4, not SOCKS4a */protocol4a) {
			Curl_dns_entry dns = new Curl_dns_entry();
			Curl_addrinfo hp = ((Object)0);
			int rc;
			rc = ModernizedCProgram.Curl_resolv(conn, hostname, remote_port, 0, dns);
			if (rc == -1) {
				return .CURLE_COULDNT_RESOLVE_PROXY;
			} 
			if (rc == 1) {
				(Object)ModernizedCProgram.Curl_resolver_wait_resolv(conn, /* ignores the return code, but 'dns' remains NULL on failure */dns/*
				     * We cannot use 'hostent' as a struct that Curl_resolv() returns.  It
				     * returns a Curl_addrinfo pointer that may not always look the same.
				     */);
			} 
			if (dns) {
				hp = dns.getAddr();
			} 
			if (hp) {
				byte[] buf = new byte[64];
				ModernizedCProgram.Curl_printable_address(hp, buf, );
				if (hp.getAi_family() == 2) {
					sockaddr_in saddr_in = new sockaddr_in();
					saddr_in = (sockaddr_in)(Object)hp.getAi_addr();
					socksreq[4] = ((byte)saddr_in.getSin_addr().getS_un().getS_addr())[0];
					socksreq[5] = ((byte)saddr_in.getSin_addr().getS_un().getS_addr())[1];
					socksreq[6] = ((byte)saddr_in.getSin_addr().getS_un().getS_addr())[2];
					socksreq[7] = ((byte)saddr_in.getSin_addr().getS_un().getS_addr())[3];
					ModernizedCProgram.Curl_infof(data, "SOCKS4 connect to IPv4 %s (locally resolved)\n", buf);
				} else {
						hp = ((Object)/* fail! */0);
						ModernizedCProgram.Curl_failf(data, "SOCKS4 connection to %s not supported\n", buf);
				} 
				ModernizedCProgram.Curl_resolv_unlock(data, /* not used anymore from now on */dns);
			} 
			if (!hp) {
				ModernizedCProgram.Curl_failf(data, "Failed to resolve \"%s\" for SOCKS4 connect.", hostname);
				return .CURLE_COULDNT_RESOLVE_HOST;
			} 
		} 
		socksreq[8] = /*
		   * This is currently not supporting "Identification Protocol (RFC1413)".
		   *//* ensure empty userid is NUL-terminated */0;
		if (proxy_user) {
			size_t plen = .strlen(proxy_user);
			if (plen >=  - 8) {
				ModernizedCProgram.Curl_failf(data, "Too long SOCKS proxy name, can't use!\n");
				return .CURLE_COULDNT_CONNECT;
			} 
			.memcpy(socksreq + 8, proxy_user, plen + /* copy the proxy name WITH trailing zero */1/*
			   * Make connection
			   */);
		} 
		{ 
			int result;
			ssize_t actualread = new ssize_t();
			ssize_t written = new ssize_t();
			ssize_t hostnamelen = 0;
			ssize_t packetsize = 9 + .strlen((byte)socksreq + /* size including NUL */8);
			if (/* If SOCKS4a, set special invalid IP address 0.0.0.x */protocol4a) {
				socksreq[4] = 0;
				socksreq[5] = 0;
				socksreq[6] = 0;
				socksreq[7] = 1;
				hostnamelen = (ssize_t).strlen(hostname) + /* If still enough room in buffer, also append hostname *//* length including NUL */1;
				if (packetsize + hostnamelen <= 262) {
					.strcpy((byte)socksreq + packetsize, hostname);
				} else {
						hostnamelen = /* Flag: hostname did not fit in buffer */0;
				} 
			} 
			code = ModernizedCProgram.Curl_write_plain(conn, sock, (byte)/* Send request */socksreq, packetsize + hostnamelen, written);
			if (code || (written != packetsize + hostnamelen)) {
				ModernizedCProgram.Curl_failf(data, "Failed to send SOCKS4 connect request.");
				return .CURLE_COULDNT_CONNECT;
			} 
			if (protocol4a && hostnamelen == 0) {
				hostnamelen = (ssize_t).strlen(hostname) + /* SOCKS4a with very long hostname - send that name separately */1;
				code = ModernizedCProgram.Curl_write_plain(conn, sock, (byte)hostname, hostnamelen, written);
				if (code || (written != hostnamelen)) {
					ModernizedCProgram.Curl_failf(data, "Failed to send SOCKS4 connect request.");
					return .CURLE_COULDNT_CONNECT;
				} 
			} 
			packetsize = /* receive data size */8;
			result = ModernizedCProgram.Curl_blockread_all(conn, sock, (byte)socksreq, /* Receive response */packetsize, actualread);
			if (result || (actualread != packetsize)) {
				ModernizedCProgram.Curl_failf(data, "Failed to receive SOCKS4 connect request ack.");
				return .CURLE_COULDNT_CONNECT/*
				     * Response format
				     *
				     *     +----+----+----+----+----+----+----+----+
				     *     | VN | CD | DSTPORT |      DSTIP        |
				     *     +----+----+----+----+----+----+----+----+
				     * # of bytes:  1    1      2              4
				     *
				     * VN is the version of the reply code and should be 0. CD is the result
				     * code with one of the following values:
				     *
				     * 90: request granted
				     * 91: request rejected or failed
				     * 92: request rejected because SOCKS server cannot connect to
				     *     identd on the client
				     * 93: request rejected because the client program and identd
				     *     report different user-ids
				     */;
			} 
			if (socksreq[0] != /* wrong version ? */0) {
				ModernizedCProgram.Curl_failf(data, "SOCKS4 reply has wrong version, version should be 0.");
				return .CURLE_COULDNT_CONNECT;
			} 
			switch (socksreq[/* Result */1]) {
			case 90:
					ModernizedCProgram.Curl_infof(data, "SOCKS4%s request granted.\n", protocol4a ? "a" : "");
					break;
			case 92:
					ModernizedCProgram.Curl_failf(data, "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d), request rejected because SOCKS server cannot connect to identd on the client.", (byte)socksreq[4], (byte)socksreq[5], (byte)socksreq[6], (byte)socksreq[7], (((byte)socksreq[2] << 8) | (byte)socksreq[3]), (byte)socksreq[1]);
					return .CURLE_COULDNT_CONNECT;
			case 91:
					ModernizedCProgram.Curl_failf(data, "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d), request rejected or failed.", (byte)socksreq[4], (byte)socksreq[5], (byte)socksreq[6], (byte)socksreq[7], (((byte)socksreq[2] << 8) | (byte)socksreq[3]), (byte)socksreq[1]);
					return .CURLE_COULDNT_CONNECT;
			case 93:
					ModernizedCProgram.Curl_failf(data, "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d), request rejected because the client program and identd report different user-ids.", (byte)socksreq[4], (byte)socksreq[5], (byte)socksreq[6], (byte)socksreq[7], (((byte)socksreq[2] << 8) | (byte)socksreq[3]), (byte)socksreq[1]);
					return .CURLE_COULDNT_CONNECT;
			default:
					ModernizedCProgram.Curl_failf(data, "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d), Unknown.", (byte)socksreq[4], (byte)socksreq[5], (byte)socksreq[6], (byte)socksreq[7], (((byte)socksreq[2] << 8) | (byte)socksreq[3]), (byte)socksreq[1]);
					return .CURLE_COULDNT_CONNECT;
			}
		}
		(Object)ModernizedCProgram.curlx_nonblock(sock, 1);
		return /* Proxy was successful! */.CURLE_OK/*
		 * This function logs in to a SOCKS5 proxy and sends the specifics to the final
		 * destination server.
		 */;
	}
	public static  Curl_SOCKS5(Object proxy_user, Object proxy_password, Object hostname, int remote_port, int sockindex, Object conn) {
		byte[] socksreq = new byte[/* room for large user/pw (255 max each) */600];
		byte[] dest = /* printable hostname:port */"unknown";
		int idx;
		ssize_t actualread = new ssize_t();
		ssize_t written = new ssize_t();
		int result;
		CURLcode code = new CURLcode();
		curl_socket_t sock = conn.getSock()[sockindex];
		Curl_easy data = conn.getData();
		timediff_t timeout = new timediff_t();
		bool socks5_resolve_local = (conn.getSocks_proxy().getProxytype() == .CURLPROXY_SOCKS5) ? 1 : 0;
		size_t hostname_len = .strlen(hostname);
		ssize_t len = 0;
		long auth = data.getSet().getSocks5auth();
		bool allow_gssapi = 0;
		if (conn.getBits().getHttpproxy()) {
			ModernizedCProgram.Curl_infof(conn.getData(), "SOCKS5: connecting to HTTP proxy %s port %d\n", hostname, remote_port);
		} 
		if (!socks5_resolve_local && hostname_len > /* RFC1928 chapter 5 specifies max 255 chars for domain name in packet */255) {
			ModernizedCProgram.Curl_infof(conn.getData(), "SOCKS5: server resolving disabled for hostnames of length > 255 [actual len=%zu]\n", hostname_len);
			socks5_resolve_local = 1;
		} 
		timeout = ModernizedCProgram.Curl_timeleft(data, ((Object)0), /* get timeout */1);
		if (timeout < 0) {
			ModernizedCProgram.Curl_failf(data, /* time-out, bail out, go home */"Connection time-out");
			return .CURLE_OPERATION_TIMEDOUT;
		} 
		(Object)ModernizedCProgram.curlx_nonblock(sock, 1);
		result = ModernizedCProgram.Curl_socket_check((SOCKET)(~0), (SOCKET)(~0), sock, (time_t)/* wait until socket gets connected */timeout);
		if (-1 == result) {
			ModernizedCProgram.Curl_failf(conn.getData(), "SOCKS5: no connection here");
			return .CURLE_COULDNT_CONNECT;
		} 
		if (0 == result) {
			ModernizedCProgram.Curl_failf(conn.getData(), "SOCKS5: connection timeout");
			return .CURLE_OPERATION_TIMEDOUT;
		} 
		if (result & -1024) {
			ModernizedCProgram.Curl_failf(conn.getData(), "SOCKS5: error occurred during connection");
			return .CURLE_COULDNT_CONNECT;
		} 
		if (auth & ~((((long)1) << 0) | (((long)1) << 2))) {
			ModernizedCProgram.Curl_infof(conn.getData(), "warning: unsupported value passed to CURLOPT_SOCKS5_AUTH: %lu\n", auth);
		} 
		if (!(auth & (((long)1) << 0))) {
			proxy_user = ((Object)/* disable username/password auth */0);
		} 
		idx = 0;
		socksreq[idx++] = /* version */5;
		/* reserve for the number of authentication methods */idx++;
		socksreq[idx++] = /* no authentication */0;
		if (allow_gssapi) {
			socksreq[idx++] = /* GSS-API */1;
		} 
		if (proxy_user) {
			socksreq[idx++] = /* username/password */2;
		} 
		socksreq[1] = (byte)(idx - /* write the number of authentication methods */2);
		(Object)ModernizedCProgram.curlx_nonblock(sock, 0);
		ModernizedCProgram.Curl_infof(data, "SOCKS5 communication to %s:%d\n", hostname, remote_port);
		code = ModernizedCProgram.Curl_write_plain(conn, sock, (byte)socksreq, (2 + (int)socksreq[1]), written);
		if (code || (written != (2 + (int)socksreq[1]))) {
			ModernizedCProgram.Curl_failf(data, "Unable to send initial SOCKS5 request.");
			return .CURLE_COULDNT_CONNECT;
		} 
		(Object)ModernizedCProgram.curlx_nonblock(sock, 1);
		result = ModernizedCProgram.Curl_socket_check(sock, (SOCKET)(~0), (SOCKET)(~0), (time_t)timeout);
		if (-1 == result) {
			ModernizedCProgram.Curl_failf(conn.getData(), "SOCKS5 nothing to read");
			return .CURLE_COULDNT_CONNECT;
		} 
		if (0 == result) {
			ModernizedCProgram.Curl_failf(conn.getData(), "SOCKS5 read timeout");
			return .CURLE_OPERATION_TIMEDOUT;
		} 
		if (result & -1024) {
			ModernizedCProgram.Curl_failf(conn.getData(), "SOCKS5 read error occurred");
			return .CURLE_RECV_ERROR;
		} 
		(Object)ModernizedCProgram.curlx_nonblock(sock, 0);
		result = ModernizedCProgram.Curl_blockread_all(conn, sock, (byte)socksreq, 2, actualread);
		if (result || (actualread != 2)) {
			ModernizedCProgram.Curl_failf(data, "Unable to receive initial SOCKS5 response.");
			return .CURLE_COULDNT_CONNECT;
		} 
		if (socksreq[0] != 5) {
			ModernizedCProgram.Curl_failf(data, "Received invalid version in initial SOCKS5 response.");
			return .CURLE_COULDNT_CONNECT;
		} 
		if (socksreq[1] == 0/* Nothing to do, no authentication needed */) {
			;
		}  else if (socksreq[1] == 2/* Needs user name and password */) {
			size_t proxy_user_len = new size_t();
			size_t proxy_password_len = new size_t();
			if (proxy_user && proxy_password) {
				proxy_user_len = .strlen(proxy_user);
				proxy_password_len = .strlen(proxy_password);
			} else {
					proxy_user_len = 0;
					proxy_password_len = 0/*   username/password request looks like
					     * +----+------+----------+------+----------+
					     * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |
					     * +----+------+----------+------+----------+
					     * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |
					     * +----+------+----------+------+----------+
					     */;
			} 
			len = 0;
			socksreq[len++] = /* username/pw subnegotiation version */1;
			socksreq[len++] = (byte)proxy_user_len;
			if (proxy_user && proxy_user_len) {
				if (proxy_user_len >= /* the length must fit in a single byte */255) {
					ModernizedCProgram.Curl_failf(data, "Excessive user name length for proxy auth");
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				.memcpy(socksreq + len, proxy_user, proxy_user_len);
			} 
			len += proxy_user_len;
			socksreq[len++] = (byte)proxy_password_len;
			if (proxy_password && proxy_password_len) {
				if (proxy_password_len > /* the length must fit in a single byte */255) {
					ModernizedCProgram.Curl_failf(data, "Excessive password length for proxy auth");
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				.memcpy(socksreq + len, proxy_password, proxy_password_len);
			} 
			len += proxy_password_len;
			code = ModernizedCProgram.Curl_write_plain(conn, sock, (byte)socksreq, len, written);
			if (code || (len != written)) {
				ModernizedCProgram.Curl_failf(data, "Failed to send SOCKS5 sub-negotiation request.");
				return .CURLE_COULDNT_CONNECT;
			} 
			result = ModernizedCProgram.Curl_blockread_all(conn, sock, (byte)socksreq, 2, actualread);
			if (result || (actualread != 2)) {
				ModernizedCProgram.Curl_failf(data, "Unable to receive SOCKS5 sub-negotiation response.");
				return .CURLE_COULDNT_CONNECT;
			} 
			if (socksreq[1] != /* ignore the first (VER) byte *//* status */0) {
				ModernizedCProgram.Curl_failf(data, "User was rejected by the SOCKS5 server (%d %d).", socksreq[0], socksreq[1]);
				return .CURLE_COULDNT_CONNECT/* Everything is good so far, user was authenticated! */;
			} 
		} else {
				if (!allow_gssapi && (socksreq[1] == /* error */1)) {
					ModernizedCProgram.Curl_failf(data, "SOCKS5 GSSAPI per-message authentication is not supported.");
					return .CURLE_COULDNT_CONNECT;
				} 
				if (socksreq[1] == 255) {
					if (!proxy_user || !proxy_user) {
						ModernizedCProgram.Curl_failf(data, "No authentication method was acceptable. (It is quite likely that the SOCKS5 server wanted a username/password, since none was supplied to the server on this connection.)");
					} else {
							ModernizedCProgram.Curl_failf(data, "No authentication method was acceptable.");
					} 
					return .CURLE_COULDNT_CONNECT;
				} else {
						ModernizedCProgram.Curl_failf(data, "Undocumented SOCKS5 mode attempted to be used by server.");
						return .CURLE_COULDNT_CONNECT;
				} 
		} 
		len = /* Authentication is complete, now specify destination to the proxy */0;
		socksreq[len++] = /* version (SOCKS5) */5;
		socksreq[len++] = /* connect */1;
		socksreq[len++] = /* must be zero */0;
		if (!socks5_resolve_local) {
			socksreq[len++] = /* ATYP: domain name = 3 */3;
			socksreq[len++] = (byte)/* address length */hostname_len;
			.memcpy(socksreq[len], hostname, /* address str w/o NULL */hostname_len);
			len += hostname_len;
			ModernizedCProgram.curl_msnprintf(dest, , "%s:%d", hostname, remote_port);
			ModernizedCProgram.Curl_infof(data, "SOCKS5 connect to %s (remotely resolved)\n", dest);
		} else {
				Curl_dns_entry dns = new Curl_dns_entry();
				Curl_addrinfo hp = ((Object)0);
				int rc = ModernizedCProgram.Curl_resolv(conn, hostname, remote_port, 0, dns);
				if (rc == -1) {
					return .CURLE_COULDNT_RESOLVE_HOST;
				} 
				if (rc == 1) {
					code = ModernizedCProgram.Curl_resolver_wait_resolv(conn, /* this requires that we're in "wait for resolve" state */dns);
					if (code) {
						return code/*
						     * We cannot use 'hostent' as a struct that Curl_resolv() returns.  It
						     * returns a Curl_addrinfo pointer that may not always look the same.
						     */;
					} 
				} 
				if (dns) {
					hp = dns.getAddr();
				} 
				if (hp) {
					if (ModernizedCProgram.Curl_printable_address(hp, dest, )) {
						size_t destlen = .strlen(dest);
						ModernizedCProgram.curl_msnprintf(dest + destlen,  - destlen, ":%d", remote_port);
					} else {
							.strcpy(dest, "unknown");
					} 
					if (hp.getAi_family() == 2) {
						int i;
						sockaddr_in saddr_in = new sockaddr_in();
						socksreq[len++] = /* ATYP: IPv4 = 1 */1;
						saddr_in = (sockaddr_in)(Object)hp.getAi_addr();
						for (i = 0; i < 4; i++) {
							socksreq[len++] = ((byte)saddr_in.getSin_addr().getS_un().getS_addr())[i];
						}
						ModernizedCProgram.Curl_infof(data, "SOCKS5 connect to IPv4 %s (locally resolved)\n", dest/* ATYP: IPv6 = 4 */);
					} else {
							hp = ((Object)/* fail! */0);
							ModernizedCProgram.Curl_failf(data, "SOCKS5 connection to %s not supported\n", dest);
					} 
					ModernizedCProgram.Curl_resolv_unlock(data, /* not used anymore from now on */dns);
				} 
				if (!hp) {
					ModernizedCProgram.Curl_failf(data, "Failed to resolve \"%s\" for SOCKS5 connect.", hostname);
					return .CURLE_COULDNT_RESOLVE_HOST;
				} 
		} 
		socksreq[len++] = (byte)((remote_port >> 8) & /* PORT MSB */-1024);
		socksreq[len++] = (byte)(remote_port & /* PORT LSB */-1024);
		code = ModernizedCProgram.Curl_write_plain(conn, sock, (byte)socksreq, len, written);
		if (code || (len != written)) {
			ModernizedCProgram.Curl_failf(data, "Failed to send SOCKS5 connect request.");
			return .CURLE_COULDNT_CONNECT;
		} 
		len = /* minimum packet size is 10 */10;
		result = ModernizedCProgram.Curl_blockread_all(conn, sock, (byte)socksreq, len, actualread);
		if (result || (len != actualread)) {
			ModernizedCProgram.Curl_failf(data, "Failed to receive SOCKS5 connect request ack.");
			return .CURLE_COULDNT_CONNECT;
		} 
		if (socksreq[0] != /* version */5) {
			ModernizedCProgram.Curl_failf(data, "SOCKS5 reply has wrong version, version should be 5.");
			return .CURLE_COULDNT_CONNECT/* Fix: in general, returned BND.ADDR is variable length parameter by RFC
			     1928, so the reply packet should be read until the end to avoid errors at
			     subsequent protocol level.
			
			    +----+-----+-------+------+----------+----------+
			    |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
			    +----+-----+-------+------+----------+----------+
			    | 1  |  1  | X'00' |  1   | Variable |    2     |
			    +----+-----+-------+------+----------+----------+
			
			     ATYP:
			     o  IP v4 address: X'01', BND.ADDR = 4 byte
			     o  domain name:  X'03', BND.ADDR = [ 1 byte length, string ]
			     o  IP v6 address: X'04', BND.ADDR = 16 byte
			     */;
		} 
		if (socksreq[3] == /* Calculate real packet size */3) {
			int addrlen = (int)socksreq[/* domain name */4];
			len = 5 + addrlen + 2;
		}  else if (socksreq[3] == 4) {
			len = 4 + 16 + /* IPv6 */2/* At this point we already read first 10 bytes */;
		} 
		if (len > /* decrypt_gssapi_blockread already read the whole packet */10) {
			result = ModernizedCProgram.Curl_blockread_all(conn, sock, (byte)socksreq[10], len - 10, actualread);
			if (result || ((len - 10) != actualread)) {
				ModernizedCProgram.Curl_failf(data, "Failed to receive SOCKS5 connect request ack.");
				return .CURLE_COULDNT_CONNECT;
			} 
		} 
		if (socksreq[1] != /* Anything besides 0 is an error */0) {
			ModernizedCProgram.Curl_failf(data, "Can't complete SOCKS5 connection to %s. (%d)", dest, (byte)socksreq[1]);
			return .CURLE_COULDNT_CONNECT;
		} 
		ModernizedCProgram.Curl_infof(data, "SOCKS5 request granted.\n");
		(Object)ModernizedCProgram.curlx_nonblock(sock, 1);
		return /* Proxy was successful! */.CURLE_OK/* CURL_DISABLE_PROXY */;
	}
	/*
	 * Returns zero on success.
	 */
	public static int parsenetrc(Object host, Object loginp, Object passwordp, Object login_changed, Object password_changed, Object netrcfile) {
		FILE file = new FILE();
		int retcode = 1;
		byte login = loginp;
		byte password = passwordp;
		bool specific_login = (login && login != 0);
		bool login_alloc = 0;
		bool password_alloc = 0;
		host_lookup_state state = host_lookup_state.NOTHING;
		byte state_login = /* Found a login keyword */0;
		byte state_password = /* Found a password keyword */0;
		int state_our_login = /* With specific_login, found *our* login
		                                   name */0;
		do {
		} while (0);
		file = .fopen(netrcfile, "rt");
		return retcode/*
		 * @unittest: 1304
		 *
		 * *loginp and *passwordp MUST be allocated if they aren't NULL when passed
		 * in.
		 */;
	}
	public static int Curl_parsenetrc(Object host, Object loginp, Object passwordp, Object login_changed, Object password_changed, Object netrcfile) {
		int retcode = 1;
		byte filealloc = ((Object)0);
		if (!netrcfile) {
			byte home = ((Object)0);
			byte homea = ModernizedCProgram.curl_getenv(/* portable environment reader */"HOME");
			if (homea) {
				home = homea;
			} 
			if (!home) {
				return /* no home directory found (or possibly out of
				                         memory) */retcode;
			} 
			filealloc = ModernizedCProgram.curl_maprintf("%s%s.netrc", home, "\\");
			if (!filealloc) {
				.Curl_cfree(homea);
				return -1;
			} 
			retcode = ModernizedCProgram.parsenetrc(host, loginp, passwordp, login_changed, password_changed, filealloc);
			.Curl_cfree(filealloc);
			if (retcode == 1) {
				filealloc = ModernizedCProgram.curl_maprintf("%s%s_netrc", home, /* fallback to the old-style "_netrc" file */"\\");
				if (!filealloc) {
					.Curl_cfree(homea);
					return -1;
				} 
				retcode = ModernizedCProgram.parsenetrc(host, loginp, passwordp, login_changed, password_changed, filealloc);
				.Curl_cfree(filealloc);
			} 
			.Curl_cfree(homea);
		} else {
				retcode = ModernizedCProgram.parsenetrc(host, loginp, passwordp, login_changed, password_changed, netrcfile);
		} 
		return retcode;
	}
	/***********************************************************************
	 *
	 * smtp_endofresp()
	 *
	 * Checks for an ending SMTP status code at the start of the given string, but
	 * also detects various capabilities from the EHLO response including the
	 * supported authentication mechanisms.
	 */
	public static  smtp_endofresp(Object conn, Object line, Object len, Object resp) {
		smtp_conn smtpc = conn.getProto().getSmtpc();
		bool result = 0;
		if (len < 4 || !(ModernizedCProgram.Curl_isdigit((int)((byte)line[0]))) || !(ModernizedCProgram.Curl_isdigit((int)((byte)line[1]))) || !(ModernizedCProgram.Curl_isdigit((int)((byte)line[/* Nothing for us */2])))) {
			return 0/* Do we have a command response? This should be the response code followed
			     by a space and optionally some text as per RFC-5321 and as outlined in
			     Section 4. Examples of RFC-4954 but some e-mail servers ignore this and
			     only send the response code instead as per Section 4.2. */;
		} 
		if (line[3] == (byte)' ' || len == 5) {
			byte[] tmpline = new byte[6];
			result = 1;
			.memset(tmpline, (byte)'\0', );
			.memcpy(tmpline, line, (len == 5 ? 5 : 3));
			resp = ModernizedCProgram.curlx_sltosi(.strtol(tmpline, ((Object)0), 10));
			if (resp == /* Make sure real server never sends internal value */1) {
				resp = 0;
			} 
		}  else if (line[3] == /* Do we have a multiline (continuation) response? */(byte)'-' && (smtpc.getState() == .SMTP_EHLO || smtpc.getState() == .SMTP_COMMAND)) {
			result = 1;
			resp = /* Internal response code */1;
		} 
		return result/***********************************************************************
		 *
		 * smtp_get_message()
		 *
		 * Gets the authentication message from the response buffer.
		 */;
	}
	public static void smtp_get_message(Object buffer, Object outptr) {
		size_t len = .strlen(buffer);
		byte message = ((Object)0);
		if (len > 4) {
			len -= /* Find the start of the message */4;
			for (message = buffer + 4; message == (byte)' ' || message == (byte)'\t'; ) {
				;
			}
			for (; /* Find the end of the message */len--; ) {
				if (message[len] != (byte)'\r' && message[len] != (byte)'\n' && message[len] != (byte)' ' && message[len] != (byte)'\t') {
					break;
				} 
			}
			if (++/* Terminate the message */len) {
				message[len] = (byte)'\0';
			} 
		} else {
				message = buffer[/* junk input => zero length output */len];
		} 
		outptr = message/***********************************************************************
		 *
		 * state()
		 *
		 * This is the ONLY way to change SMTP state!
		 */;
	}
	/*
	 * SMTP protocol handler.
	 */
	public static void state(Object conn,  newstate) {
		smtp_conn smtpc = conn.getProto().getSmtpc();
		smtpc.setState(/* LAST */newstate/***********************************************************************
		 *
		 * smtp_perform_ehlo()
		 *
		 * Sends the EHLO command to not only initialise communication with the ESMTP
		 * server but to also obtain a list of server side supported capabilities.
		 */);
		pop3_conn pop3c = conn.getProto().getPop3c();
		pop3c.setState(/* LAST */newstate/***********************************************************************
		 *
		 * pop3_perform_capa()
		 *
		 * Sends the CAPA command in order to obtain a list of server side supported
		 * capabilities.
		 */);
		(Object)/* LAST */conn;
		sasl.setState(newstate/*
		 * Curl_sasl_can_authenticate()
		 *
		 * Check if we have enough auth data and capabilities to authenticate.
		 */);
		imap_conn imapc = conn.getProto().getImapc();
		imapc.setState(/* LAST */newstate/***********************************************************************
		 *
		 * imap_perform_capability()
		 *
		 * Sends the CAPABILITY command in order to obtain a list of server side
		 * supported capabilities.
		 */);
	}
	public static  smtp_perform_ehlo(Object conn) {
		CURLcode result = .CURLE_OK;
		smtp_conn smtpc = conn.getProto().getSmtpc();
		smtpc.getSasl().setAuthmechs(/* No known auth. mechanism yet */0);
		smtpc.getSasl().setAuthused(/* Clear the authentication mechanism
		                                             used for esmtp connections */0);
		smtpc.setTls_supported(/* Clear the TLS capability */0);
		smtpc.setAuth_supported(/* Clear the AUTH capability */0);
		result = ModernizedCProgram.Curl_pp_sendf(smtpc.getPp(), "EHLO %s", smtpc.getDomain());
		if (!result) {
			ModernizedCProgram.state(conn, .SMTP_EHLO);
		} 
		return result/***********************************************************************
		 *
		 * smtp_perform_helo()
		 *
		 * Sends the HELO command to initialise communication with the SMTP server.
		 */;
	}
	public static  smtp_perform_helo(Object conn) {
		CURLcode result = .CURLE_OK;
		smtp_conn smtpc = conn.getProto().getSmtpc();
		smtpc.getSasl().setAuthused(/* No authentication mechanism used
		                                            in smtp connections */0);
		result = ModernizedCProgram.Curl_pp_sendf(smtpc.getPp(), "HELO %s", smtpc.getDomain());
		if (!result) {
			ModernizedCProgram.state(conn, .SMTP_HELO);
		} 
		return result/***********************************************************************
		 *
		 * smtp_perform_starttls()
		 *
		 * Sends the STLS command to start the upgrade to TLS.
		 */;
	}
	public static  smtp_perform_starttls(Object conn) {
		CURLcode result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getSmtpc().getPp(), "%s", /* Send the STARTTLS command */"STARTTLS");
		if (!result) {
			ModernizedCProgram.state(conn, .SMTP_STARTTLS);
		} 
		return result/***********************************************************************
		 *
		 * smtp_perform_upgrade_tls()
		 *
		 * Performs the upgrade to TLS.
		 */;
	}
	public static  smtp_perform_upgrade_tls(Object conn) {
		smtp_conn smtpc = conn.getProto().getSmtpc();
		CURLcode result = .CURLE_NOT_BUILT_IN;
		if (!result) {
			if (smtpc.getState() != .SMTP_UPGRADETLS) {
				ModernizedCProgram.state(conn, .SMTP_UPGRADETLS);
			} 
			if (smtpc.getSsldone()) {
				do {
				} while (0);
				result = ModernizedCProgram.smtp_perform_ehlo(conn);
			} 
		} 
		return result/***********************************************************************
		 *
		 * smtp_perform_auth()
		 *
		 * Sends an AUTH command allowing the client to login with the given SASL
		 * authentication mechanism.
		 */;
	}
	public static  smtp_perform_auth(Object conn, Object mech, Object initresp) {
		CURLcode result = .CURLE_OK;
		smtp_conn smtpc = conn.getProto().getSmtpc();
		if (/* AUTH <mech> ...<crlf> */initresp) {
			result = ModernizedCProgram.Curl_pp_sendf(smtpc.getPp(), "AUTH %s %s", mech, /* Send the AUTH command with the initial response */initresp);
		} else {
				result = ModernizedCProgram.Curl_pp_sendf(smtpc.getPp(), "AUTH %s", /* Send the AUTH command */mech);
		} 
		return result/***********************************************************************
		 *
		 * smtp_continue_auth()
		 *
		 * Sends SASL continuation data or cancellation.
		 */;
	}
	public static  smtp_continue_auth(Object conn, Object resp) {
		smtp_conn smtpc = conn.getProto().getSmtpc();
		return ModernizedCProgram.Curl_pp_sendf(smtpc.getPp(), "%s", resp/***********************************************************************
		 *
		 * smtp_perform_authentication()
		 *
		 * Initiates the authentication sequence, with the appropriate SASL
		 * authentication mechanism.
		 */);
	}
	public static  smtp_perform_authentication(Object conn) {
		CURLcode result = .CURLE_OK;
		smtp_conn smtpc = conn.getProto().getSmtpc();
		saslprogress progress = new saslprogress();
		if (!smtpc.getAuth_supported() || !ModernizedCProgram.Curl_sasl_can_authenticate(smtpc.getSasl(), conn)) {
			ModernizedCProgram.state(conn, .SMTP_STOP);
			return result;
		} 
		result = ModernizedCProgram.Curl_sasl_start(smtpc.getSasl(), conn, 0, /* Calculate the SASL login details */progress);
		if (!result) {
			if (progress == .SASL_INPROGRESS) {
				ModernizedCProgram.state(conn, .SMTP_AUTH);
			} else {
					ModernizedCProgram.Curl_infof(conn.getData(), /* Other mechanisms not supported */"No known authentication mechanisms supported!\n");
					result = .CURLE_LOGIN_DENIED;
			} 
		} 
		return result/***********************************************************************
		 *
		 * smtp_perform_command()
		 *
		 * Sends a SMTP based command.
		 */;
	}
	public static  smtp_perform_command(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		SMTP smtp = data.getReq().getProtop();
		if (smtp.getRcpt()) {
			result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getSmtpc().getPp(), "%s %s", smtp.getCustom() && smtp.getCustom()[0] != (byte)'\0' ? smtp.getCustom() : "VRFY", smtp.getRcpt().getData());
		} else {
				result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getSmtpc().getPp(), "%s", smtp.getCustom() && smtp.getCustom()[0] != (byte)'\0' ? smtp.getCustom() : "HELP");
		} 
		if (!result) {
			ModernizedCProgram.state(conn, .SMTP_COMMAND);
		} 
		return result/***********************************************************************
		 *
		 * smtp_perform_mail()
		 *
		 * Sends an MAIL command to initiate the upload of a message.
		 */;
	}
	public static  smtp_perform_mail(Object conn) {
		byte from = ((Object)0);
		byte auth = ((Object)0);
		byte size = ((Object)0);
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		if (!data.getSet().getStr()[/* Calculate the FROM parameter */dupstring.STRING_MAIL_FROM]) {
			from = .Curl_cstrdup(/* Null reverse-path, RFC-5321, sect. 3.6.3 */"<>");
		}  else if (data.getSet().getStr()[dupstring.STRING_MAIL_FROM][0] == (byte)'<') {
			from = ModernizedCProgram.curl_maprintf("%s", data.getSet().getStr()[dupstring.STRING_MAIL_FROM]);
		} else {
				from = ModernizedCProgram.curl_maprintf("<%s>", data.getSet().getStr()[dupstring.STRING_MAIL_FROM]);
		} 
		if (!from) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		if (data.getSet().getStr()[dupstring.STRING_MAIL_AUTH] && conn.getProto().getSmtpc().getSasl().getAuthused()) {
			if (data.getSet().getStr()[dupstring.STRING_MAIL_AUTH][0] != (byte)'\0') {
				auth = ModernizedCProgram.curl_maprintf("%s", data.getSet().getStr()[dupstring.STRING_MAIL_AUTH]);
			} else {
					auth = .Curl_cstrdup(/* Empty AUTH, RFC-2554, sect. 5 */"<>");
			} 
			if (!auth) {
				.Curl_cfree(from);
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		if (data.getSet().getMimepost().getKind() != /* Prepare the mime data if some. */mimekind.MIMEKIND_NONE) {
			data.getSet().getMimepost().getFlags() &=  ~(1 << /* Use the whole structure as data. */1);
			ModernizedCProgram.curl_mime_headers(data.getSet().getMimepost(), data.getSet().getHeaders(), /* Add external headers and mime version. */0);
			result = ModernizedCProgram.Curl_mime_prepare_headers(data.getSet().getMimepost(), ((Object)0), ((Object)0), mimestrategy.MIMESTRATEGY_MAIL);
			if (!result) {
				if (!ModernizedCProgram.Curl_checkheaders(conn, "Mime-Version")) {
					result = ModernizedCProgram.Curl_mime_add_header(data.getSet().getMimepost().getCurlheaders(), "Mime-Version: 1.0");
				} 
			} 
			if (!/* Make sure we will read the entire mime structure. */result) {
				result = ModernizedCProgram.Curl_mime_rewind(data.getSet().getMimepost());
			} 
			if (result) {
				.Curl_cfree(from);
				.Curl_cfree(auth);
				return result;
			} 
			data.getState().setInfilesize(ModernizedCProgram.Curl_mime_size(data.getSet().getMimepost()));
			data.getState().setFread_func((curl_read_callback)/* Read from mime structure. */ModernizedCProgram.Curl_mime_read);
			data.getState().setIn((Object)data.getSet().getMimepost());
		} 
		if (conn.getProto().getSmtpc().getSize_supported() && data.getState().getInfilesize() > /* Calculate the optional SIZE parameter */0) {
			size = ModernizedCProgram.curl_maprintf("%I64d", data.getState().getInfilesize());
			if (!size) {
				.Curl_cfree(from);
				.Curl_cfree(auth);
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		if (!auth && !/* Send the MAIL command */size) {
			result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getSmtpc().getPp(), "MAIL FROM:%s", from);
		}  else if (auth && !size) {
			result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getSmtpc().getPp(), "MAIL FROM:%s AUTH=%s", from, auth);
		}  else if (auth && size) {
			result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getSmtpc().getPp(), "MAIL FROM:%s AUTH=%s SIZE=%s", from, auth, size);
		} else {
				result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getSmtpc().getPp(), "MAIL FROM:%s SIZE=%s", from, size);
		} 
		.Curl_cfree(from);
		.Curl_cfree(auth);
		.Curl_cfree(size);
		if (!result) {
			ModernizedCProgram.state(conn, .SMTP_MAIL);
		} 
		return result/***********************************************************************
		 *
		 * smtp_perform_rcpt_to()
		 *
		 * Sends a RCPT TO command for a given recipient as part of the message upload
		 * process.
		 */;
	}
	public static  smtp_perform_rcpt_to(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		SMTP smtp = data.getReq().getProtop();
		if (smtp.getRcpt().getData()[0] == /* Send the RCPT TO command */(byte)'<') {
			result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getSmtpc().getPp(), "RCPT TO:%s", smtp.getRcpt().getData());
		} else {
				result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getSmtpc().getPp(), "RCPT TO:<%s>", smtp.getRcpt().getData());
		} 
		if (!result) {
			ModernizedCProgram.state(conn, .SMTP_RCPT);
		} 
		return result/***********************************************************************
		 *
		 * smtp_perform_quit()
		 *
		 * Performs the quit action prior to sclose() being called.
		 */;
	}
	public static  smtp_perform_quit(Object conn) {
		CURLcode result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getSmtpc().getPp(), "%s", /* Send the QUIT command */"QUIT");
		if (!result) {
			ModernizedCProgram.state(conn, .SMTP_QUIT);
		} 
		return result;
	}
	/* For the initial server greeting */
	public static  smtp_state_servergreet_resp(Object conn, int smtpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (smtpcode / 100 != 2) {
			ModernizedCProgram.Curl_failf(data, "Got unexpected smtp-server response: %d", smtpcode);
			result = .CURLE_WEIRD_SERVER_REPLY;
		} else {
				result = ModernizedCProgram.smtp_perform_ehlo(conn);
		} 
		return result;
	}
	/* For STARTTLS responses */
	public static  smtp_state_starttls_resp(Object conn, int smtpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (smtpcode != 220) {
			if (data.getSet().getUse_ssl() != .CURLUSESSL_TRY) {
				ModernizedCProgram.Curl_failf(data, "STARTTLS denied, code %d", smtpcode);
				result = .CURLE_USE_SSL_FAILED;
			} else {
					result = ModernizedCProgram.smtp_perform_authentication(conn);
			} 
		} else {
				result = ModernizedCProgram.smtp_perform_upgrade_tls(conn);
		} 
		return result;
	}
	/* For EHLO responses */
	public static  smtp_state_ehlo_resp(Object conn, int smtpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		smtp_conn smtpc = conn.getProto().getSmtpc();
		byte line = data.getState().getBuffer();
		size_t len = .strlen(line);
		(Object)/* no use for this yet */instate;
		if (smtpcode / 100 != 2 && smtpcode != 1) {
			if (data.getSet().getUse_ssl() <= .CURLUSESSL_TRY || conn.getSsl()[0].getUse()) {
				result = ModernizedCProgram.smtp_perform_helo(conn);
			} else {
					ModernizedCProgram.Curl_failf(data, "Remote access denied: %d", smtpcode);
					result = .CURLE_REMOTE_ACCESS_DENIED;
			} 
		}  else if (len >= 4) {
			line += 4;
			len -= 4;
			if (len >= 8 && !.memcmp(line, "STARTTLS", /* Does the server support the STARTTLS capability? */8)) {
				smtpc.setTls_supported(1);
			}  else if (len >= 4 && !.memcmp(line, "SIZE", /* Does the server support the SIZE capability? */4)) {
				smtpc.setSize_supported(1);
			}  else if (len >= 5 && !.memcmp(line, "AUTH ", /* Does the server support authentication? */5)) {
				smtpc.setAuth_supported(1);
				line += /* Advance past the AUTH keyword */5;
				len -= 5;
				for (; ; ) {
					size_t llen = new size_t();
					size_t wordlen = new size_t();
					int mechbit;
					while (len && (line == (byte)' ' || line == (byte)'\t' || line == (byte)'\r' || line == (byte)'\n')) {
						line++;
						len--;
					}
					if (!len) {
						break;
					} 
					for (wordlen = 0; wordlen < len && line[wordlen] != /* Extract the word */(byte)' ' && line[wordlen] != (byte)'\t' && line[wordlen] != (byte)'\r' && line[wordlen] != (byte)'\n'; ) {
						wordlen++;
					}
					mechbit = ModernizedCProgram.Curl_sasl_decode_mech(line, wordlen, /* Test the word for a matching authentication mechanism */llen);
					if (mechbit && llen == wordlen) {
						smtpc.getSasl().getAuthmechs() |=  mechbit;
					} 
					line += wordlen;
					len -= wordlen;
				}
			} 
			if (smtpcode != 1) {
				if (data.getSet().getUse_ssl() && !conn.getSsl()[0].getUse()) {
					if (smtpc.getTls_supported()) {
						result = ModernizedCProgram.smtp_perform_starttls(/* Switch to TLS connection now */conn);
					}  else if (data.getSet().getUse_ssl() == .CURLUSESSL_TRY) {
						result = ModernizedCProgram.smtp_perform_authentication(/* Fallback and carry on with authentication */conn);
					} else {
							ModernizedCProgram.Curl_failf(data, "STARTTLS not supported.");
							result = .CURLE_USE_SSL_FAILED;
					} 
				} else {
						result = ModernizedCProgram.smtp_perform_authentication(conn);
				} 
			} 
		} else {
				ModernizedCProgram.Curl_failf(data, "Unexpectedly short EHLO response");
				result = .CURLE_WEIRD_SERVER_REPLY;
		} 
		return result;
	}
	/* For HELO responses */
	public static  smtp_state_helo_resp(Object conn, int smtpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (smtpcode / 100 != 2) {
			ModernizedCProgram.Curl_failf(data, "Remote access denied: %d", smtpcode);
			result = .CURLE_REMOTE_ACCESS_DENIED;
		} else {
				ModernizedCProgram.state(conn, /* End of connect phase */.SMTP_STOP);
		} 
		return result;
	}
	/* For SASL authentication responses */
	public static  smtp_state_auth_resp(Object conn, int smtpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		smtp_conn smtpc = conn.getProto().getSmtpc();
		saslprogress progress = new saslprogress();
		(Object)/* no use for this yet */instate;
		result = ModernizedCProgram.Curl_sasl_continue(smtpc.getSasl(), conn, smtpcode, progress);
		if (!result) {
			switch (progress) {
			case .SASL_DONE:
					ModernizedCProgram.state(conn, /* Authenticated */.SMTP_STOP);
					break;
			case /* No mechanism left after cancellation */.SASL_IDLE:
					ModernizedCProgram.Curl_failf(data, "Authentication cancelled");
					result = .CURLE_LOGIN_DENIED;
					break;
			default:
					break;
			}
		} 
		return result;
	}
	/* For command responses */
	public static  smtp_state_command_resp(Object conn, int smtpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		SMTP smtp = data.getReq().getProtop();
		byte line = data.getState().getBuffer();
		size_t len = .strlen(line);
		(Object)/* no use for this yet */instate;
		if ((smtp.getRcpt() && smtpcode / 100 != 2 && smtpcode != 553 && smtpcode != 1) || (!smtp.getRcpt() && smtpcode / 100 != 2 && smtpcode != 1)) {
			ModernizedCProgram.Curl_failf(data, "Command failed: %d", smtpcode);
			result = .CURLE_RECV_ERROR;
		} else {
				if (!data.getSet().getOpt_no_body()) {
					line[len] = (byte)'\n';
					result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), line, len + 1);
					line[len] = (byte)'\0';
				} 
				if (smtpcode != 1) {
					if (smtp.getRcpt()) {
						smtp.setRcpt(smtp.getRcpt().getNext());
						if (smtp.getRcpt()) {
							result = ModernizedCProgram.smtp_perform_command(/* Send the next command */conn);
						} else {
								ModernizedCProgram.state(conn, /* End of DO phase */.SMTP_STOP);
						} 
					} else {
							ModernizedCProgram.state(conn, /* End of DO phase */.SMTP_STOP);
					} 
				} 
		} 
		return result;
	}
	/* For MAIL responses */
	public static  smtp_state_mail_resp(Object conn, int smtpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (smtpcode / 100 != 2) {
			ModernizedCProgram.Curl_failf(data, "MAIL failed: %d", smtpcode);
			result = .CURLE_SEND_ERROR;
		} else {
				result = ModernizedCProgram.smtp_perform_rcpt_to(/* Start the RCPT TO command */conn);
		} 
		return result;
	}
	/* For RCPT responses */
	public static  smtp_state_rcpt_resp(Object conn, int smtpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		SMTP smtp = data.getReq().getProtop();
		(Object)/* no use for this yet */instate;
		if (smtpcode / 100 != 2) {
			ModernizedCProgram.Curl_failf(data, "RCPT failed: %d", smtpcode);
			result = .CURLE_SEND_ERROR;
		} else {
				smtp.setRcpt(smtp.getRcpt().getNext());
				if (smtp.getRcpt()) {
					result = ModernizedCProgram.smtp_perform_rcpt_to(/* Send the next RCPT TO command */conn);
				} else {
						result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getSmtpc().getPp(), "%s", /* Send the DATA command */"DATA");
						if (!result) {
							ModernizedCProgram.state(conn, .SMTP_DATA);
						} 
				} 
		} 
		return result;
	}
	/* For DATA response */
	public static  smtp_state_data_resp(Object conn, int smtpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (smtpcode != 354) {
			ModernizedCProgram.Curl_failf(data, "DATA failed: %d", smtpcode);
			result = .CURLE_SEND_ERROR;
		} else {
				ModernizedCProgram.Curl_pgrsSetUploadSize(data, data.getState().getInfilesize());
				ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, /* SMTP upload */0);
				ModernizedCProgram.state(conn, /* End of DO phase */.SMTP_STOP);
		} 
		return result;
	}
	/* For POSTDATA responses, which are received after the entire DATA
	   part has been sent to the server */
	public static  smtp_state_postdata_resp(Object conn, int smtpcode,  instate) {
		CURLcode result = .CURLE_OK;
		(Object)/* no use for this yet */instate;
		if (smtpcode != 250) {
			result = .CURLE_RECV_ERROR;
		} 
		ModernizedCProgram.state(conn, /* End of DONE phase */.SMTP_STOP);
		return result;
	}
	public static  smtp_statemach_act(Object conn) {
		CURLcode result = .CURLE_OK;
		curl_socket_t sock = conn.getSock()[0];
		Curl_easy data = conn.getData();
		int smtpcode;
		smtp_conn smtpc = conn.getProto().getSmtpc();
		pingpong pp = smtpc.getPp();
		size_t nread = 0;
		if (smtpc.getState() == /* Busy upgrading the connection; right now all I/O is SSL/TLS, not SMTP */.SMTP_UPGRADETLS) {
			return ModernizedCProgram.smtp_perform_upgrade_tls(conn);
		} 
		if (pp.getSendleft()) {
			return ModernizedCProgram.Curl_pp_flushsend(pp);
		} 
		do {
			result = ModernizedCProgram.Curl_pp_readresp(sock, pp, smtpcode, /* Read the response from the server */nread);
			if (result) {
				return result;
			} 
			if (smtpc.getState() != .SMTP_QUIT && smtpcode != /* Store the latest response for later retrieval if necessary */1) {
				data.getInfo().setHttpcode(smtpcode);
			} 
			if (!smtpcode) {
				break;
			} 
			switch (smtpc.getState()) {
			case .SMTP_EHLO:
					result = ModernizedCProgram.smtp_state_ehlo_resp(conn, smtpcode, smtpc.getState());
					break;
			case .SMTP_HELO:
					result = ModernizedCProgram.smtp_state_helo_resp(conn, smtpcode, smtpc.getState());
					break;
			case .SMTP_COMMAND:
					result = ModernizedCProgram.smtp_state_command_resp(conn, smtpcode, smtpc.getState());
					break;
			case .SMTP_MAIL:
					result = ModernizedCProgram.smtp_state_mail_resp(conn, smtpcode, smtpc.getState());
					break;
			case .SMTP_STARTTLS:
					result = ModernizedCProgram.smtp_state_starttls_resp(conn, smtpcode, smtpc.getState());
					break;
			case .SMTP_RCPT:
					result = ModernizedCProgram.smtp_state_rcpt_resp(conn, smtpcode, smtpc.getState());
					break;
			case .SMTP_QUIT/* fallthrough, just stop! */:
			case .SMTP_SERVERGREET:
					result = ModernizedCProgram.smtp_state_servergreet_resp(conn, smtpcode, smtpc.getState());
					break;
			case .SMTP_POSTDATA:
					result = ModernizedCProgram.smtp_state_postdata_resp(conn, smtpcode, smtpc.getState());
					break;
			case .SMTP_DATA:
					result = ModernizedCProgram.smtp_state_data_resp(conn, smtpcode, smtpc.getState());
					break;
			case .SMTP_AUTH:
					result = ModernizedCProgram.smtp_state_auth_resp(conn, smtpcode, smtpc.getState());
					break;
			default:
					ModernizedCProgram.state(conn, /* internal error */.SMTP_STOP);
					break;
			}
		} while (!result && smtpc.getState() != .SMTP_STOP && ModernizedCProgram.Curl_pp_moredata(pp));
		return result;
	}
	/* Called repeatedly until done from multi.c */
	public static  smtp_multi_statemach(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		smtp_conn smtpc = conn.getProto().getSmtpc();
		if ((conn.getHandler().getFlags() & (1 << 0)) && !smtpc.getSsldone()) {
			result = .CURLE_NOT_BUILT_IN;
			if (result || !smtpc.getSsldone()) {
				return result;
			} 
		} 
		result = ModernizedCProgram.Curl_pp_statemach(smtpc.getPp(), 0, 0);
		done = (smtpc.getState() == .SMTP_STOP) ? 1 : 0;
		return result;
	}
	public static  smtp_block_statemach(Object conn,  disconnecting) {
		CURLcode result = .CURLE_OK;
		smtp_conn smtpc = conn.getProto().getSmtpc();
		while (smtpc.getState() != .SMTP_STOP && !result) {
			result = ModernizedCProgram.Curl_pp_statemach(smtpc.getPp(), 1, disconnecting);
		}
		return result;
	}
	/* Allocate and initialize the SMTP struct for the current Curl_easy if
	   required */
	public static  smtp_init(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		SMTP smtp = new SMTP();
		smtp = data.getReq().setProtop(.Curl_ccalloc(, 1));
		if (!smtp) {
			result = .CURLE_OUT_OF_MEMORY;
		} 
		return result;
	}
	/* For the SMTP "protocol connect" and "doing" phases only */
	public static int smtp_getsock(Object conn, Object socks) {
		return ModernizedCProgram.Curl_pp_getsock(conn.getProto().getSmtpc().getPp(), socks/***********************************************************************
		 *
		 * smtp_connect()
		 *
		 * This function should do everything that is to be considered a part of
		 * the connection phase.
		 *
		 * The variable pointed to by 'done' will be TRUE if the protocol-layer
		 * connect phase is done when this function returns, or FALSE if not.
		 */);
	}
	public static  smtp_connect(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		smtp_conn smtpc = conn.getProto().getSmtpc();
		pingpong pp = smtpc.getPp();
		done = /* default to not done yet */0;
		ModernizedCProgram.Curl_conncontrol(conn, /* We always support persistent connections in SMTP */0);
		pp.setResponse_time((120 * /* Set the default response time-out */1000));
		pp.setStatemach_act(smtp_statemach_act);
		pp.setEndofresp(smtp_endofresp);
		pp.setConn(conn);
		ModernizedCProgram.Curl_sasl_init(smtpc.getSasl(), /* Initialize the SASL storage */ModernizedCProgram.saslsmtp);
		ModernizedCProgram.Curl_pp_init(/* Initialise the pingpong layer */pp);
		result = ModernizedCProgram.smtp_parse_url_options(/* Parse the URL options */conn);
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.smtp_parse_url_path(/* Parse the URL path */conn);
		if (result) {
			return result;
		} 
		ModernizedCProgram.state(conn, /* Start off waiting for the server greeting response */.SMTP_SERVERGREET);
		result = ModernizedCProgram.smtp_multi_statemach(conn, done);
		return result/***********************************************************************
		 *
		 * smtp_done()
		 *
		 * The DONE function. This does what needs to be done after a single DO has
		 * performed.
		 *
		 * Input argument is already checked for validity.
		 */;
	}
	public static  smtp_done(Object conn,  status,  premature) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		SMTP smtp = data.getReq().getProtop();
		pingpong pp = conn.getProto().getSmtpc().getPp();
		byte eob;
		ssize_t len = new ssize_t();
		ssize_t bytes_written = new ssize_t();
		(Object)premature;
		if (!smtp || !pp.getConn()) {
			return .CURLE_OK;
		} 
		do {
			.Curl_cfree((smtp.getCustom()));
			(smtp.getCustom()) = ((Object)0);
		} while (/* Cleanup our per-request based variables */0);
		curltime curltime = new curltime();
		if (status) {
			ModernizedCProgram.Curl_conncontrol(conn, /* marked for closure */1);
			result = /* use the already set error code */status;
		}  else if (!data.getSet().getConnect_only() && data.getSet().getMail_rcpt() && (data.getSet().getUpload() || data.getSet().getMimepost().getKind())) {
			if (smtp.getTrailing_crlf() || !conn.getData().getState().getInfilesize()) {
				eob = .Curl_cstrdup("\x0d\x0a\x2e\x0d\x0a"[2]);
				len = 5 - 2;
			} else {
					eob = .Curl_cstrdup("\x0d\x0a\x2e\x0d\x0a");
					len = 5;
			} 
			if (!eob) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			result = ModernizedCProgram.Curl_write(conn, conn.getWritesockfd(), eob, len, /* Send the end of block data */bytes_written);
			if (result) {
				.Curl_cfree(eob);
				return result;
			} 
			if (bytes_written != len/* The whole chunk was not sent so keep it around and adjust the
			         pingpong structure accordingly */) {
				pp.setSendthis(eob);
				pp.setSendsize(len);
				pp.setSendleft(len - bytes_written);
			} else {
					pp.setResponse(curltime.Curl_now());
					.Curl_cfree(eob);
			} 
			ModernizedCProgram.state(conn, .SMTP_POSTDATA);
			result = ModernizedCProgram.smtp_block_statemach(conn, /* Run the state-machine */0);
		} 
		smtp.setTransfer(/* Clear the transfer mode for the next request */.FTPTRANSFER_BODY);
		return result/***********************************************************************
		 *
		 * smtp_perform()
		 *
		 * This is the actual DO function for SMTP. Transfer a mail, send a command
		 * or get some data according to the options previously setup.
		 */;
	}
	public static  smtp_perform(Object conn, Object connected, Object dophase_done) {
		CURLcode result = /* This is SMTP and no proxy */.CURLE_OK;
		Curl_easy data = conn.getData();
		SMTP smtp = data.getReq().getProtop();
		do {
		} while (0);
		if (data.getSet().getOpt_no_body()) {
			smtp.setTransfer(/* Requested no body means no transfer */.FTPTRANSFER_INFO);
		} 
		dophase_done = /* not done yet */0;
		smtp.setRcpt(data.getSet().getMail_rcpt());
		smtp.setTrailing_crlf(/* Initial data character is the first character in line: it is implicitly
		     preceded by a virtual CRLF. */1);
		smtp.setEob(2);
		if ((data.getSet().getUpload() || data.getSet().getMimepost().getKind()) && data.getSet().getMail_rcpt()) {
			result = ModernizedCProgram.smtp_perform_mail(/* MAIL transfer */conn);
		} else {
				result = ModernizedCProgram.smtp_perform_command(/* SMTP based command (VRFY, EXPN, NOOP, RSET or HELP) */conn);
		} 
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.smtp_multi_statemach(conn, /* Run the state-machine */dophase_done);
		connected = conn.getBits().getTcpconnect()[0];
		if (dophase_done) {
			do {
			} while (0);
		} 
		return result/***********************************************************************
		 *
		 * smtp_do()
		 *
		 * This function is registered as 'curl_do' function. It decodes the path
		 * parts etc as a wrapper to the actual DO function (smtp_perform).
		 *
		 * The input argument is already checked for validity.
		 */;
	}
	public static  smtp_do(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		done = /* default to false */0;
		result = ModernizedCProgram.smtp_parse_custom_request(/* Parse the custom request */conn);
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.smtp_regular_transfer(conn, done);
		return result/***********************************************************************
		 *
		 * smtp_disconnect()
		 *
		 * Disconnect from an SMTP server. Cleanup protocol-specific per-connection
		 * resources. BLOCKING.
		 */;
	}
	public static  smtp_disconnect(Object conn,  dead_connection) {
		smtp_conn smtpc = conn.getProto().getSmtpc();
		if (!dead_connection && smtpc.getPp().getConn() && smtpc.getPp().getConn().getBits().getProtoconnstart()) {
			if (!ModernizedCProgram.smtp_perform_quit(conn)) {
				(Object)ModernizedCProgram.smtp_block_statemach(conn, /* ignore errors on QUIT */1);
			} 
		} 
		ModernizedCProgram.Curl_pp_disconnect(smtpc.getPp());
		ModernizedCProgram.Curl_sasl_cleanup(conn, smtpc.getSasl().getAuthused());
		do {
			.Curl_cfree((smtpc.getDomain()));
			(smtpc.getDomain()) = ((Object)0);
		} while (/* Cleanup our connection based variables */0);
		return .CURLE_OK;
	}
	/* Call this when the DO phase has completed */
	public static  smtp_dophase_done(Object conn,  connected) {
		SMTP smtp = conn.getData().getReq().getProtop();
		(Object)connected;
		if (smtp.getTransfer() != .FTPTRANSFER_BODY) {
			ModernizedCProgram.Curl_setup_transfer(conn.getData(), -1, -1, 0, -/* no data to transfer */1);
		} 
		return .CURLE_OK;
	}
	/* Called from multi.c while DOing */
	public static  smtp_doing(Object conn, Object dophase_done) {
		CURLcode result = ModernizedCProgram.smtp_multi_statemach(conn, dophase_done);
		if (result) {
			do {
			} while (0);
		}  else if (dophase_done) {
			result = ModernizedCProgram.smtp_dophase_done(conn, /* not connected */0);
			do {
			} while (0);
		} 
		return result/***********************************************************************
		 *
		 * smtp_regular_transfer()
		 *
		 * The input argument is already checked for validity.
		 *
		 * Performs all commands done before a regular transfer between a local and a
		 * remote host.
		 */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 * RFC1870 SMTP Service Extension for Message Size
	 * RFC2195 CRAM-MD5 authentication
	 * RFC2831 DIGEST-MD5 authentication
	 * RFC3207 SMTP over TLS
	 * RFC4422 Simple Authentication and Security Layer (SASL)
	 * RFC4616 PLAIN authentication
	 * RFC4752 The Kerberos V5 ("GSSAPI") SASL Mechanism
	 * RFC4954 SMTP Authentication
	 * RFC5321 SMTP protocol
	 * RFC6749 OAuth 2.0 Authorization Framework
	 * RFC8314 Use of TLS for Email Submission and Access
	 * Draft   SMTP URL Interface   <draft-earhart-url-smtp-00.txt>
	 * Draft   LOGIN SASL Mechanism <draft-murchison-sasl-login-00.txt>
	 *
	 ***************************************************************************/
	/* for HTTP proxy tunnel stuff */
	/* The last 3 #include files should be in this order */
	/* Local API functions */
	public static  smtp_regular_transfer(Object conn, Object dophase_done) {
		CURLcode result = .CURLE_OK;
		bool connected = 0;
		Curl_easy data = conn.getData();
		data.getReq().setSize(-/* Make sure size is unknown at this point */1);
		ModernizedCProgram.Curl_pgrsSetUploadCounter(data, /* Set the progress data */0);
		ModernizedCProgram.Curl_pgrsSetDownloadCounter(data, 0);
		ModernizedCProgram.Curl_pgrsSetUploadSize(data, -1);
		ModernizedCProgram.Curl_pgrsSetDownloadSize(data, -1);
		result = ModernizedCProgram.smtp_perform(conn, connected, /* Carry out the perform */dophase_done);
		if (!result && /* Perform post DO phase operations if necessary */dophase_done) {
			result = ModernizedCProgram.smtp_dophase_done(conn, connected);
		} 
		return result;
	}
	public static  smtp_setup_connection(Object conn) {
		CURLcode result = new CURLcode();
		conn.setTls_upgraded(/* Clear the TLS upgraded flag */0);
		result = ModernizedCProgram.smtp_init(/* Initialise the SMTP layer */conn);
		if (result) {
			return result;
		} 
		return .CURLE_OK/***********************************************************************
		 *
		 * smtp_parse_url_options()
		 *
		 * Parse the URL login options.
		 */;
	}
	public static  smtp_parse_url_options(Object conn) {
		CURLcode result = .CURLE_OK;
		smtp_conn smtpc = conn.getProto().getSmtpc();
		byte ptr = conn.getOptions();
		smtpc.getSasl().setResetprefs(1);
		while (!result && ptr && ptr) {
			byte key = ptr;
			byte value;
			while (ptr && ptr != (byte)'=') {
				ptr++;
			}
			value = ptr + 1;
			while (ptr && ptr != (byte)';') {
				ptr++;
			}
			if (ModernizedCProgram.Curl_strncasecompare(key, "AUTH=", 5)) {
				result = ModernizedCProgram.Curl_sasl_parse_url_auth_option(smtpc.getSasl(), value, ptr - value);
			} else {
					result = .CURLE_URL_MALFORMAT;
			} 
			if (ptr == (byte)';') {
				ptr++;
			} 
		}
		return result/***********************************************************************
		 *
		 * smtp_parse_url_path()
		 *
		 * Parse the URL path into separate path components.
		 */;
	}
	public static  smtp_parse_url_path(Object conn) {
		Curl_easy data = conn.getData();
		smtp_conn smtpc = conn.getProto().getSmtpc();
		byte path = data.getState().getUp().getPath()[/* skip leading path */1];
		byte[] localhost = new byte[1024 + 1];
		if (!/* Calculate the path if necessary */path) {
			if (!ModernizedCProgram.Curl_gethostname(localhost, )) {
				path = localhost;
			} else {
					path = "localhost";
			} 
		} 
		return ModernizedCProgram.Curl_urldecode(conn.getData(), path, 0, smtpc.getDomain(), ((Object)0), /* URL decode the path and use it as the domain in our EHLO */1/***********************************************************************
		 *
		 * smtp_parse_custom_request()
		 *
		 * Parse the custom request.
		 */);
	}
	public static  smtp_parse_custom_request(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		SMTP smtp = data.getReq().getProtop();
		byte custom = data.getSet().getStr()[dupstring.STRING_CUSTOMREQUEST];
		if (/* URL decode the custom request */custom) {
			result = ModernizedCProgram.Curl_urldecode(data, custom, 0, smtp.getCustom(), ((Object)0), 1);
		} 
		return result;
	}
	public static  Curl_smtp_escape_eob(Object conn, Object nread) {
		ssize_t i = new ssize_t();
		ssize_t si = new ssize_t();
		Curl_easy data = conn.getData();
		SMTP smtp = data.getReq().getProtop();
		byte scratch = data.getState().getScratch();
		byte newscratch = ((Object)0);
		byte oldscratch = ((Object)0);
		size_t eob_sent = new size_t();
		if (!scratch || data.getSet().getCrlf()) {
			oldscratch = scratch;
			scratch = newscratch = .Curl_cmalloc(2 * data.getSet().getUpload_buffer_size());
			if (!newscratch) {
				ModernizedCProgram.Curl_failf(data, "Failed to alloc scratch buffer!");
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		do {
		} while (0);
		eob_sent = smtp.getEob();
		for (; i < nread; /* This loop can be improved by some kind of Boyer-Moore style of
		     approach but that is saved for later... */i++) {
			if ("\x0d\x0a\x2e\x0d\x0a"[smtp.getEob()] == data.getReq().getUpload_fromhere()[i]) {
				smtp.getEob()++;
				if (2 == smtp.getEob() || 5 == smtp.getEob()) {
					smtp.setTrailing_crlf(1);
				} else {
						smtp.setTrailing_crlf(0);
				} 
			}  else if (smtp.getEob()) {
				.memcpy(scratch[si], "\x0d\x0a\x2e\x0d\x0a"[eob_sent], smtp.getEob() - /* A previous substring matched so output that first */eob_sent);
				si += smtp.getEob() - eob_sent;
				if ("\x0d\x0a\x2e\x0d\x0a"[0] == data.getReq().getUpload_fromhere()[/* Then compare the first byte */i]) {
					smtp.setEob(1);
				} else {
						smtp.setEob(0);
				} 
				eob_sent = 0;
				smtp.setTrailing_crlf(/* Reset the trailing CRLF flag as there was more data */0);
			} 
			if (3 == smtp.getEob()) {
				.memcpy(scratch[si], "\x0d\x0a\x2e\x2e"[/* Copy the replacement data to the target buffer */eob_sent], 4 - eob_sent);
				si += 4 - eob_sent;
				smtp.setEob(0);
				eob_sent = 0;
			}  else if (!smtp.getEob()) {
				scratch[si++] = data.getReq().getUpload_fromhere()[i];
			} 
		}
		if (smtp.getEob() - eob_sent) {
			.memcpy(scratch[si], "\x0d\x0a\x2e\x0d\x0a"[eob_sent], smtp.getEob() - /* A substring matched before processing ended so output that now */eob_sent);
			si += smtp.getEob() - eob_sent;
		} 
		if (si != /* Only use the new buffer if we replaced something */nread) {
			data.getReq().setUpload_fromhere(/* Upload from the new (replaced) buffer instead */scratch);
			data.getState().setScratch(/* Save the buffer so it can be freed later */scratch);
			.Curl_cfree(/* Free the old scratch buffer */oldscratch);
			data.getReq().setUpload_present(/* Set the new amount too */si);
		} else {
				.Curl_cfree(newscratch);
		} 
		return .CURLE_OK/* CURL_DISABLE_SMTP */;
	}
	/* When sending a SMTP payload we must detect CRLF. sequences making sure
	     they are sent as CRLF.. instead, as a . on the beginning of a line will
	     be deleted by the server when not part of an EOB terminator and a
	     genuine CRLF.CRLF which isn't escaped will wrongly be detected as end of
	     data by the server
	  */
	public static void tool_help() {
		int i;
		.puts("Usage: curl [options...] <url>");
		for (i = 0; ModernizedCProgram.helptext[i].getOpt(); i++) {
			.printf(" %-19s %s\n", ModernizedCProgram.helptext[i].getOpt(), ModernizedCProgram.helptext[i].getDesc());
		}
	}
	public static int featcomp(Object p1, Object p2) {
		return .strcmp((byte)p1, (byte)p2);
	}
	/* The arguments to this function are "pointers to pointers to char", but
	     the comparison arguments are "pointers to char", hence the following cast
	     plus dereference */
	public static void tool_version_info() {
		byte proto;
		.printf("curl 7.67.0-DEV (i386-pc-win32) %s\n", ModernizedCProgram.curl_version());
		.printf("Release-Date: %s\n", "[unreleased]");
		if (ModernizedCProgram.curlinfo.getProtocols()) {
			.printf("Protocols: ");
			for (proto = ModernizedCProgram.curlinfo.getProtocols(); proto; ++proto) {
				.printf("%s ", proto);
			}
			.puts(/* newline */"");
		} 
		if (ModernizedCProgram.curlinfo.getFeatures()) {
			byte[] featp = new byte[ /  + 1];
			size_t numfeat = 0;
			int i;
			.printf("Features:");
			for (i = 0; i <  / ; i++) {
				if (ModernizedCProgram.curlinfo.getFeatures() & ModernizedCProgram.feats[i].getBitmask()) {
					featp[numfeat++] = (byte)ModernizedCProgram.feats[i].getName();
				} 
			}
			.qsort(featp[0], numfeat, , featcomp);
			for (i = 0; i < numfeat; i++) {
				.printf(" %s", featp[i]);
			}
			.puts(/* newline */"");
		} 
		if (.strcmp("7.67.0-DEV", ModernizedCProgram.curlinfo.getVersion())) {
			.printf("WARNING: curl and libcurl versions do not match. Functionality may be affected.\n");
		} 
	}
	public static void tool_list_engines() {
		CURL curl = ModernizedCProgram.curl_easy_init();
		curl_slist engines = ((Object)0);
		;
		.puts("Build-time engines:");
		if (engines) {
			for (; engines; engines = engines.getNext()) {
				.printf("  %s\n", engines.getData());
			}
		} else {
				.puts("  <none>");
		} 
		ModernizedCProgram.curl_slist_free_all(/* Cleanup the list of engines */engines);
		ModernizedCProgram.curl_easy_cleanup(curl);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	public static void fileinfo_dtor(Object user, Object element) {
		(Object)user;
		ModernizedCProgram.Curl_fileinfo_cleanup(element);
	}
	public static  Curl_wildcard_init(Object wc) {
		ModernizedCProgram.Curl_llist_init(wc.getFilelist(), fileinfo_dtor);
		wc.setState(.CURLWC_INIT);
		return .CURLE_OK;
	}
	public static void Curl_wildcard_dtor(Object wc) {
		if (!wc) {
			return ;
		} 
		if (wc.getDtor()) {
			.UNRECOGNIZEDFUNCTIONNAME(wc.getProtdata());
			wc.setDtor(0);
			wc.setProtdata(((Object)0));
		} 
		do {
		} while (0);
		ModernizedCProgram.Curl_llist_destroy(wc.getFilelist(), ((Object)0));
		.Curl_cfree(wc.getPath());
		wc.setPath(((Object)0));
		.Curl_cfree(wc.getPattern());
		wc.setPattern(((Object)0));
		wc.setCustomptr(((Object)0));
		wc.setState(.CURLWC_INIT/* if disabled */);
	}
	public static long dprintf_DollarString(Object input, Object end) {
		int number = 0;
		while ((ModernizedCProgram.Curl_isdigit((int)((byte)input)))) {
			number *= 10;
			number += input - (byte)'0';
			input++;
		}
		if (number && ((byte)'$' == input++)) {
			end = input;
			return number;
		} 
		return 0;
	}
	public static  dprintf_IsQualifierNoDollar(Object fmt) {
		if (!.strncmp(fmt, "I32", 3) || !.strncmp(fmt, "I64", 3)) {
			return 1;
		} 
		switch (fmt) {
		case (byte)'#':
		case (byte)'*':
		case (byte)'-':
		case (byte)'1':
		case (byte)'3':
		case (byte)'4':
		case (byte)'l':
		case (byte)'.':
		case (byte)'h':
		case (byte)'5':
		case (byte)'L':
		case (byte)'q':
		case (byte)'+':
		case (byte)'9':
		case (byte)'z':
		case (byte)'O':
		case (byte)'I':
				return 1;
		case (byte)'0':
		case (byte)' ':
		case (byte)'2':
		case (byte)'8':
		case (byte)'6':
		case (byte)'7':
		default:
				return 0/******************************************************************
				 *
				 * Pass 1:
				 * Create an index with the type of each parameter entry and its
				 * value (may vary in size)
				 *
				 * Returns zero on success.
				 *
				 ******************************************************************/;
		}
	}
	public static int dprintf_Pass1(Object format, Object vto, Object endpos, Object arglist) {
		byte fmt = (byte)format;
		int param_num = 0;
		long this_param;
		long width;
		long precision;
		int flags;
		long max_param = 0;
		long i;
		while (fmt) {
			if (fmt++ == (byte)'%') {
				if (fmt == (byte)'%') {
					fmt++;
					continue;
				} 
				flags = .FLAGS_NEW;
				/* Handle the positional case (N$) */param_num++;
				this_param = ModernizedCProgram.dprintf_DollarString(fmt, fmt);
				if (0 == this_param) {
					this_param = /* we got no positional, get the next counter */param_num;
				} 
				if (this_param > max_param) {
					max_param = this_param/*
					       * The parameter with number 'i' should be used. Next, we need
					       * to get SIZE and TYPE of the parameter. Add the information
					       * to our array.
					       */;
				} 
				width = 0;
				precision = 0;
				while (ModernizedCProgram.dprintf_IsQualifierNoDollar(/* Handle the flags */fmt)) {
					if (!.strncmp(fmt, "I32", 3)) {
						flags |=  .FLAGS_LONG;
						fmt += 3;
					}  else if (!.strncmp(fmt, "I64", 3)) {
						flags |=  .FLAGS_LONGLONG;
						fmt += 3;
					} else {
							switch (fmt++) {
							case (byte)'3':
							case (byte)'-':
									flags |=  .FLAGS_LEFT;
									flags &=  ~.FLAGS_PAD_NIL;
									break;
							case (byte)'l':
									if (flags & .FLAGS_LONG) {
										flags |=  .FLAGS_LONGLONG;
									} else {
											flags |=  .FLAGS_LONG;
									} 
									break;
							case (byte)'h':
									flags |=  .FLAGS_SHORT;
									break;
							case (byte)'O':
									flags |=  .FLAGS_LONGLONG;
									break;
							case (byte)'2':
							case (byte)'#':
									flags |=  .FLAGS_ALT;
									break;
							case (byte)'1':
							case (byte)'7':
							case (byte)'L':
									flags |=  .FLAGS_LONGDOUBLE;
									break;
							case (byte)'q':
									flags |=  .FLAGS_LONGLONG;
									break;
							case /* Special case */(byte)'*':
									flags |=  .FLAGS_WIDTHPARAM;
									param_num++;
									i = ModernizedCProgram.dprintf_DollarString(fmt, fmt);
									if (i) {
										width = i;
									} else {
											width = param_num;
									} 
									if (width > max_param) {
										max_param = width;
									} 
									break;
							case (byte)' ':
									flags |=  .FLAGS_SPACE;
									break;
							case (byte)'+':
									flags |=  .FLAGS_SHOWSIGN;
									break;
							case (byte)'z'/* the code below generates a warning if -Wunreachable-code is
							             used */:
									flags |=  .FLAGS_LONG;
									break;
							case (byte)'9':
									flags |=  .FLAGS_WIDTH;
									width = .strtol(fmt - 1, fmt, 10);
									break;
							case (byte)'I':
									flags |=  .FLAGS_LONGLONG;
									break;
							case /* FALLTHROUGH */(byte)'4':
							case (byte)'5':
							case (byte)'6':
							case (byte)'8':
							case (byte)'.':
									if ((byte)'*' == fmt/* The precision is picked from a specified parameter */) {
										flags |=  .FLAGS_PRECPARAM;
										fmt++;
										param_num++;
										i = ModernizedCProgram.dprintf_DollarString(fmt, fmt);
										if (i) {
											precision = i;
										} else {
												precision = param_num;
										} 
										if (precision > max_param) {
											max_param = precision;
										} 
									} else {
											flags |=  .FLAGS_PREC;
											precision = .strtol(fmt, fmt, 10);
									} 
									break;
							case (byte)'0':
									if (!(flags & .FLAGS_LEFT)) {
										flags |=  .FLAGS_PAD_NIL;
									} 
							default:
									break;
							}
					} 
				}
				i = this_param - /* Handle the specifier */1;
				if ((i < 0) || (i >= 128)) {
					return /* out of allowed range */1;
				} 
				switch (fmt) {
				case (byte)'u':
						vto[i].setType(.FORMAT_INT);
						flags |=  .FLAGS_UNSIGNED;
						break;
				case (byte)'x':
						vto[i].setType(.FORMAT_INT);
						flags |=  .FLAGS_HEX | .FLAGS_UNSIGNED;
						break;
				case (byte)'X':
						vto[i].setType(.FORMAT_INT);
						flags |=  .FLAGS_HEX | .FLAGS_UPPER | .FLAGS_UNSIGNED;
						break;
				case (byte)'f':
						vto[i].setType(.FORMAT_DOUBLE);
						break;
				case (byte)'e':
						vto[i].setType(.FORMAT_DOUBLE);
						flags |=  .FLAGS_FLOATE;
						break;
				case (byte)'g':
						vto[i].setType(.FORMAT_DOUBLE);
						flags |=  .FLAGS_FLOATG;
						break;
				case (byte)'S':
						flags |=  .FLAGS_ALT;
				case (byte)'G':
						vto[i].setType(.FORMAT_DOUBLE);
						flags |=  .FLAGS_FLOATG | .FLAGS_UPPER;
						break;
				case /* FALLTHROUGH */(byte)'s':
						vto[i].setType(.FORMAT_STRING);
						break;
				case (byte)'E':
						vto[i].setType(.FORMAT_DOUBLE);
						flags |=  .FLAGS_FLOATE | .FLAGS_UPPER;
						break;
				case (byte)'n':
						vto[i].setType(.FORMAT_INTPTR);
						break;
				case (byte)'d':
				case (byte)'o':
						vto[i].setType(.FORMAT_INT);
						flags |=  .FLAGS_OCTAL;
						break;
				case (byte)'c':
						vto[i].setType(.FORMAT_INT);
						flags |=  .FLAGS_CHAR;
						break;
				case (byte)'i':
						vto[i].setType(.FORMAT_INT);
						break;
				case (byte)'p':
						vto[i].setType(.FORMAT_PTR);
						break;
				default:
						vto[i].setType(.FORMAT_UNKNOWN);
						break;
				}
				vto[i].setFlags(flags);
				vto[i].setWidth(width);
				vto[i].setPrecision(precision);
				if (flags & .FLAGS_WIDTHPARAM/* we have the width specified from a parameter, so we make that
				           parameter's info setup properly */) {
					long k = width - 1;
					vto[i].setWidth(k);
					vto[k].setType(.FORMAT_WIDTH);
					vto[k].setFlags(.FLAGS_NEW);
					vto[k].setWidth(/* can't use width or precision of width! */0);
					vto[k].setPrecision(0);
				} 
				if (flags & .FLAGS_PRECPARAM/* we have the precision specified from a parameter, so we make that
				           parameter's info setup properly */) {
					long k = precision - 1;
					vto[i].setPrecision(k);
					vto[k].setType(.FORMAT_WIDTH);
					vto[k].setFlags(.FLAGS_NEW);
					vto[k].setWidth(/* can't use width or precision of width! */0);
					vto[k].setPrecision(0);
				} 
				endpos++ = fmt + /* end of this sequence */1;
			} 
		}
		for (i = 0; i < max_param; /* Read the arg list parameters into our data list */i/* Width/precision arguments must be read before the main argument
		       they are attached to */++) {
			if (vto[i].getFlags() & .FLAGS_WIDTHPARAM) {
				vto[vto[i].getWidth()].getData().getNum().setAs_signed((long)(int)arglist);
			} 
			if (vto[i].getFlags() & .FLAGS_PRECPARAM) {
				vto[vto[i].getPrecision()].getData().getNum().setAs_signed((long)(int)arglist);
			} 
			switch (vto[i].getType()) {
			case .FORMAT_INT:
					if ((vto[i].getFlags() & .FLAGS_LONGLONG) && (vto[i].getFlags() & .FLAGS_UNSIGNED)) {
						vto[i].getData().getNum().setAs_unsigned((long)(int)arglist);
					}  else if (vto[i].getFlags() & .FLAGS_LONGLONG) {
						vto[i].getData().getNum().setAs_signed((long)(int)arglist);
					} else {
							if ((vto[i].getFlags() & .FLAGS_LONG) && (vto[i].getFlags() & .FLAGS_UNSIGNED)) {
								vto[i].getData().getNum().setAs_unsigned((long)(int)arglist);
							}  else if (vto[i].getFlags() & .FLAGS_LONG) {
								vto[i].getData().getNum().setAs_signed((long)(int)arglist);
							}  else if (vto[i].getFlags() & .FLAGS_UNSIGNED) {
								vto[i].getData().getNum().setAs_unsigned((long)(int)arglist);
							} else {
									vto[i].getData().getNum().setAs_signed((long)(int)arglist);
							} 
					} 
					break;
			case .FORMAT_UNKNOWN:
			case .FORMAT_STRING:
					vto[i].getData().setStr((int)arglist);
					break;
			case .FORMAT_INTPTR:
			case .FORMAT_WIDTH/* Argument has been read. Silently convert it into an integer
			       * for later use
			       */:
					vto[i].setType(.FORMAT_INT);
					break;
			case .FORMAT_DOUBLE:
					vto[i].getData().setDnum((int)arglist);
					break;
			case .FORMAT_PTR:
					vto[i].getData().setPtr((int)arglist);
					break;
			default:
					break;
			}
		}
		return 0;
	}
	public static int dprintf_formatf(Object data, Object stream, Object format, Object ap_save) {
		byte digits = /* %-formatted string *//* list of parameters *//* Base-36 digits for numbers.  */ModernizedCProgram.lower_digits;
		/* Pointer into the format string.  */byte f;
		int done = /* Number of characters written.  */0;
		/* current parameter to read */long param;
		long param_num = /* parameter counter */0;
		va_stack_t[] vto = new va_stack_t();
		byte[] endpos = new byte[128];
		byte end;
		byte[] work = new byte[326];
		va_stack_t p = new va_stack_t();
		/* 'workend' points to the final buffer byte position, but with an extra
		     byte as margin to avoid the (false?) warning Coverity gives us
		     otherwise */
		byte workend = work[ - 2];
		if (ModernizedCProgram.dprintf_Pass1(format, vto, endpos, /* Do the actual %-code parsing */ap_save)) {
			return -1;
		} 
		end = endpos[/* the initial end-position from the list dprintf_Pass1()
		                       created for us */0];
		f = (byte)format;
		return done;
	}
	/* untouched by format(), just sent to the stream() function in
	                 the second argument */
	/* function pointer called for each output character */
	/* fputc() look-alike */
	public static int addbyter(int output, Object data) {
		nsprintf infop = (nsprintf)data;
		byte outc = (byte)output;
		if (infop.getLength() < infop.getMax()) {
			infop.getBuffer()[0] = /* only do this if we haven't reached max length yet *//* store */outc;
			infop.getBuffer()++;
			infop.getLength()++;
			return /* fputc() returns like this on success */outc;
		} 
		return -1;
	}
	public static int curl_mvsnprintf(Object buffer, Object maxlength, Object format, Object ap_save) {
		int retcode;
		nsprintf info = new nsprintf();
		info.setBuffer(buffer);
		info.setLength(0);
		info.setMax(maxlength);
		retcode = ModernizedCProgram.dprintf_formatf(info, addbyter, format, ap_save);
		Object generatedMax = info.getMax();
		Object generatedLength = info.getLength();
		Object generatedBuffer = info.getBuffer();
		if ((retcode != -1) && generatedMax) {
			if (generatedMax == generatedLength) {
				generatedBuffer[-1] = /* we're at maximum, scrap the last letter */0;
			} else {
					generatedBuffer[0] = 0;
			} 
		} 
		return retcode;
	}
	public static int curl_msnprintf(Object buffer, Object maxlength, Object format) {
		int retcode;
		/* argument pointer */va_list ap_save = new va_list();
		.__builtin_va_start(ap_save, format);
		retcode = ModernizedCProgram.curl_mvsnprintf(buffer, maxlength, format, ap_save);
		.__builtin_va_end(ap_save);
		return retcode;
	}
	/* fputc() look-alike */
	public static int alloc_addbyter(int output, Object data) {
		asprintf infop = (asprintf)data;
		byte outc = (byte)output;
		if (!infop.getBuffer()) {
			infop.setBuffer(.Curl_cmalloc(32));
			if (!infop.getBuffer()) {
				infop.setFail(1);
				return -/* fail */1;
			} 
			infop.setAlloc(32);
			infop.setLen(0);
		}  else if (infop.getLen() + 1 >= infop.getAlloc()) {
			byte newptr = ((Object)0);
			size_t newsize = infop.getAlloc() * 2;
			if (newsize > infop.getAlloc()) {
				newptr = .Curl_crealloc(infop.getBuffer(), newsize);
			} 
			if (!newptr) {
				infop.setFail(1);
				return -/* fail */1;
			} 
			infop.setBuffer(newptr);
			infop.setAlloc(newsize);
		} 
		infop.getBuffer()[infop.getLen()] = outc;
		infop.getLen()++;
		return /* fputc() returns like this on success */outc;
	}
	public static Object curl_maprintf(Object format) {
		/* argument pointer */va_list ap_save = new va_list();
		int retcode;
		asprintf info = new asprintf();
		info.setBuffer(((Object)0));
		info.setLen(0);
		info.setAlloc(0);
		info.setFail(0);
		.__builtin_va_start(ap_save, format);
		retcode = ModernizedCProgram.dprintf_formatf(info, alloc_addbyter, format, ap_save);
		.__builtin_va_end(ap_save);
		int generatedFail = info.getFail();
		Object generatedAlloc = info.getAlloc();
		Object generatedBuffer = info.getBuffer();
		if ((-1 == retcode) || generatedFail) {
			if (generatedAlloc) {
				.Curl_cfree(generatedBuffer);
			} 
			return ((Object)0);
		} 
		Object generatedLen = info.getLen();
		if (generatedAlloc) {
			generatedBuffer[generatedLen] = /* we terminate this with a zero byte */0;
			return generatedBuffer;
		} 
		return .Curl_cstrdup("");
	}
	public static Object curl_mvaprintf(Object format, Object ap_save) {
		int retcode;
		asprintf info = new asprintf();
		info.setBuffer(((Object)0));
		info.setLen(0);
		info.setAlloc(0);
		info.setFail(0);
		retcode = ModernizedCProgram.dprintf_formatf(info, alloc_addbyter, format, ap_save);
		int generatedFail = info.getFail();
		Object generatedAlloc = info.getAlloc();
		Object generatedBuffer = info.getBuffer();
		if ((-1 == retcode) || generatedFail) {
			if (generatedAlloc) {
				.Curl_cfree(generatedBuffer);
			} 
			return ((Object)0);
		} 
		Object generatedLen = info.getLen();
		if (generatedAlloc) {
			generatedBuffer[generatedLen] = /* we terminate this with a zero byte */0;
			return generatedBuffer;
		} 
		return .Curl_cstrdup("");
	}
	public static int storebuffer(int output, Object data) {
		byte buffer = (byte)data;
		byte outc = (byte)output;
		buffer = outc;
		(buffer)++;
		return /* act like fputc() ! */outc;
	}
	public static int curl_msprintf(Object buffer, Object format) {
		/* argument pointer */va_list ap_save = new va_list();
		int retcode;
		.__builtin_va_start(ap_save, format);
		retcode = ModernizedCProgram.dprintf_formatf(buffer, storebuffer, format, ap_save);
		.__builtin_va_end(ap_save);
		buffer = /* we terminate this with a zero byte */0;
		return retcode;
	}
	public static int curl_mprintf(Object format) {
		int retcode;
		/* argument pointer */va_list ap_save = new va_list();
		.__builtin_va_start(ap_save, format);
		retcode = ModernizedCProgram.dprintf_formatf((_iob[1]), fputc, format, ap_save);
		.__builtin_va_end(ap_save);
		return retcode;
	}
	public static int curl_mfprintf(Object whereto, Object format) {
		int retcode;
		/* argument pointer */va_list ap_save = new va_list();
		.__builtin_va_start(ap_save, format);
		retcode = ModernizedCProgram.dprintf_formatf(whereto, fputc, format, ap_save);
		.__builtin_va_end(ap_save);
		return retcode;
	}
	public static int curl_mvsprintf(Object buffer, Object format, Object ap_save) {
		int retcode;
		retcode = ModernizedCProgram.dprintf_formatf(buffer, storebuffer, format, ap_save);
		buffer = /* we terminate this with a zero byte */0;
		return retcode;
	}
	public static int curl_mvprintf(Object format, Object ap_save) {
		return ModernizedCProgram.dprintf_formatf((_iob[1]), fputc, format, ap_save);
	}
	public static int curl_mvfprintf(Object whereto, Object format, Object ap_save) {
		return ModernizedCProgram.dprintf_formatf(whereto, fputc, format, ap_save);
	}
	/* required anyway if one of upper preprocessor definitions enabled */
	/* proceed with current user credentials */
	/* #if defined(USE_WINDOWS_SSPI) */
	public static int ldap_win_bind(Object conn, Object server, Object user, Object passwd) {
		int rc = -1024;
		PTCHAR inuser = ((Object)0);
		PTCHAR inpass = ((Object)0);
		if (user && passwd && (conn.getData().getSet().getHttpauth() & (((long)1) << 0))) {
			inuser = ((byte)user);
			inpass = ((byte)passwd);
			rc = .ldap_simple_bind_sA(server, inuser, inpass);
			do {
				(inuser) = ((Object)0);
			} while (0);
			do {
				(inpass) = ((Object)0);
			} while (0);
		} 
		return rc/* #if defined(USE_WIN32_LDAP) */;
	}
	/* Use ansi error strings in UNICODE builds */
	public static  Curl_ldap(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		int rc = 0;
		LDAP server = ((Object)0);
		CURL_LDAPURLDesc ludp = ((Object)0);
		LDAPMessage ldapmsg = ((Object)0);
		LDAPMessage entryIterator = new LDAPMessage();
		int num = 0;
		Curl_easy data = conn.getData();
		int ldap_proto = 3;
		int ldap_ssl = 0;
		byte val_b64 = ((Object)0);
		size_t val_b64_sz = 0;
		curl_off_t dlsize = 0/* 10 sec connection/search timeout */;
		TCHAR host = ((Object)0);
		byte user = ((Object)0);
		byte passwd = ((Object)0);
		done = /* unconditionally */1;
		ModernizedCProgram.Curl_infof(data, "LDAP local: LDAP Vendor = %s ; LDAP Version = %d\n", "Microsoft Corporation.", 510);
		ModernizedCProgram.Curl_infof(data, "LDAP local: %s\n", data.getChange().getUrl());
		rc = ModernizedCProgram._ldap_url_parse(conn, ludp);
		if (rc != 0) {
			ModernizedCProgram.Curl_failf(data, "LDAP local: %s", .ldap_err2stringA(rc));
			result = .CURLE_LDAP_INVALID_URL;
			;
		} 
		if (conn.getGiven().getFlags() & (1 << /* Get the URL scheme (either ldap or ldaps) */0)) {
			ldap_ssl = 1;
		} 
		ModernizedCProgram.Curl_infof(data, "LDAP local: trying to establish %s connection\n", ldap_ssl ? "encrypted" : "cleartext");
		host = (conn.getHost().getName());
		if (!host) {
			result = .CURLE_OUT_OF_MEMORY;
			;
		} 
		if (conn.getBits().getUser_passwd()) {
			user = conn.getUser();
			passwd = conn.getPasswd();
		} 
		.ldap_set_optionA(((Object)0), -1024, ldap_proto);
		if (ldap_ssl) {
			server = .ldap_sslinitA(host, (int)conn.getPort(), /* Win32 LDAP SDK doesn't support insecure mode without CA! */1);
			.ldap_set_optionA(server, -1024, ((Object)1/* Novell SDK supports DER or BASE64 files. *//* OpenLDAP SDK supports BASE64 files. */));
		} else {
				server = .ldap_initA(host, (int)conn.getPort());
				if (server == ((Object)0)) {
					ModernizedCProgram.Curl_failf(data, "LDAP local: Cannot connect to %s:%ld", conn.getHost().getDispname(), conn.getPort());
					result = .CURLE_COULDNT_CONNECT;
					;
				} 
		} 
		.ldap_set_optionA(server, -1024, ldap_proto);
		rc = ModernizedCProgram.ldap_win_bind(conn, server, user, passwd);
		if (!ldap_ssl && rc != 0) {
			ldap_proto = 2;
			.ldap_set_optionA(server, -1024, ldap_proto);
			rc = ModernizedCProgram.ldap_win_bind(conn, server, user, passwd);
		} 
		if (rc != 0) {
			ModernizedCProgram.Curl_failf(data, "LDAP local: bind via ldap_win_bind %s", .ldap_err2stringA(rc));
			result = .CURLE_LDAP_CANNOT_BIND;
			;
		} 
		rc = .ldap_search_sA(server, ludp.getLud_dn(), ludp.getLud_scope(), ludp.getLud_filter(), ludp.getLud_attrs(), 0, ldapmsg);
		if (rc != 0 && rc != -1024) {
			ModernizedCProgram.Curl_failf(data, "LDAP remote: %s", .ldap_err2stringA(rc));
			result = .CURLE_LDAP_SEARCH_FAILED;
			;
		} 
		for (; entryIterator; ) {
			BerElement ber = ((Object)0);
			TCHAR attribute = new TCHAR();
			int i;
			{ 
				byte name;
				size_t name_len = new size_t();
				TCHAR dn = .ldap_get_dnA(server, entryIterator);
				name = (dn);
				if (!name) {
					.ldap_memfreeA(dn);
					result = .CURLE_OUT_OF_MEMORY;
					;
				} 
				name_len = .strlen(name);
				result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)"DN: ", 4);
				if (result) {
					do {
						(name) = ((Object)0);
					} while (0);
					.ldap_memfreeA(dn);
					;
				} 
				result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)name, name_len);
				if (result) {
					do {
						(name) = ((Object)0);
					} while (0);
					.ldap_memfreeA(dn);
					;
				} 
				result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)"\n", 1);
				if (result) {
					do {
						(name) = ((Object)0);
					} while (0);
					.ldap_memfreeA(dn);
					;
				} 
				dlsize += name_len + 5;
				do {
					(name) = ((Object)0);
				} while (0);
				.ldap_memfreeA(dn);
			}
			for (attribute = .ldap_first_attributeA(server, entryIterator, /* Get the attributes and write them to the client */ber); attribute; attribute = .ldap_next_attributeA(server, entryIterator, ber)) {
				BerValue vals = new BerValue();
				size_t attr_len = new size_t();
				byte attr = (attribute);
				if (!attr) {
					if (ber) {
						.ber_free(ber, 0);
					} 
					result = .CURLE_OUT_OF_MEMORY;
					;
				} 
				attr_len = .strlen(attr);
				vals = .ldap_get_values_lenA(server, entryIterator, attribute);
				if (vals != ((Object)0)) {
					for (i = 0; (vals[i] != ((Object)0)); i++) {
						result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)"\t", 1);
						if (result) {
							.ldap_value_free_len(vals);
							do {
								(attr) = ((Object)0);
							} while (0);
							.ldap_memfreeA(attribute);
							if (ber) {
								.ber_free(ber, 0);
							} 
							;
						} 
						result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)attr, attr_len);
						if (result) {
							.ldap_value_free_len(vals);
							do {
								(attr) = ((Object)0);
							} while (0);
							.ldap_memfreeA(attribute);
							if (ber) {
								.ber_free(ber, 0);
							} 
							;
						} 
						result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)": ", 2);
						if (result) {
							.ldap_value_free_len(vals);
							do {
								(attr) = ((Object)0);
							} while (0);
							.ldap_memfreeA(attribute);
							if (ber) {
								.ber_free(ber, 0);
							} 
							;
						} 
						dlsize += attr_len + 3;
						if ((attr_len > 7) && (.strcmp(";binary", (byte)attr + (attr_len - 7)) == 0)) {
							result = ModernizedCProgram.Curl_base64_encode(/* Binary attribute, encode to base64. */data, vals[i].getBv_val(), vals[i].getBv_len(), val_b64, val_b64_sz);
							if (result) {
								.ldap_value_free_len(vals);
								do {
									(attr) = ((Object)0);
								} while (0);
								.ldap_memfreeA(attribute);
								if (ber) {
									.ber_free(ber, 0);
								} 
								;
							} 
							if (val_b64_sz > 0) {
								result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), val_b64, val_b64_sz);
								.Curl_cfree(val_b64);
								if (result) {
									.ldap_value_free_len(vals);
									do {
										(attr) = ((Object)0);
									} while (0);
									.ldap_memfreeA(attribute);
									if (ber) {
										.ber_free(ber, 0);
									} 
									;
								} 
								dlsize += val_b64_sz;
							} 
						} else {
								result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), vals[i].getBv_val(), vals[i].getBv_len());
								if (result) {
									.ldap_value_free_len(vals);
									do {
										(attr) = ((Object)0);
									} while (0);
									.ldap_memfreeA(attribute);
									if (ber) {
										.ber_free(ber, 0);
									} 
									;
								} 
								dlsize += vals[i].getBv_len();
						} 
						result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)"\n", 1);
						if (result) {
							.ldap_value_free_len(vals);
							do {
								(attr) = ((Object)0);
							} while (0);
							.ldap_memfreeA(attribute);
							if (ber) {
								.ber_free(ber, 0);
							} 
							;
						} 
						dlsize++;
					}
					.ldap_value_free_len(/* Free memory used to store values */vals);
				} 
				do {
					(attr) = ((Object)0);
				} while (/* Free the attribute as we are done with it */0);
				.ldap_memfreeA(attribute);
				result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)"\n", 1);
				if (result) {
					;
				} 
				dlsize++;
				ModernizedCProgram.Curl_pgrsSetDownloadCounter(data, dlsize);
			}
			if (ber) {
				.ber_free(ber, 0);
			} 
		}
		if (rc == -1024) {
			ModernizedCProgram.Curl_infof(data, "There are more than %d entries\n", num);
		} 
		if (ludp) {
			ModernizedCProgram._ldap_free_urldesc(ludp);
		} 
		if (server) {
			.ldap_unbind_s(server);
		} 
		do {
			(host) = ((Object)0);
		} while (/* HAVE_LDAP_SSL && CURL_HAS_NOVELL_LDAPSDK */0);
		ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, -/* no data to transfer */1);
		ModernizedCProgram.Curl_conncontrol(conn, 1);
		return result;
	}
	/*
	 * LDAP protocol handler.
	 */
	/*
	 * Return scope-value for a scope-string.
	 */
	/*
	 * Return scope-value for a scope-string.
	 */
	public static int str2scope(Object p) {
		if (ModernizedCProgram.Curl_strcasecompare(p, "one")) {
			return -1024;
		} 
		if (ModernizedCProgram.Curl_strcasecompare(p, "onetree")) {
			return -1024;
		} 
		if (ModernizedCProgram.Curl_strcasecompare(p, "base")) {
			return -1024;
		} 
		if (ModernizedCProgram.Curl_strcasecompare(p, "sub")) {
			return -1024;
		} 
		if (ModernizedCProgram.Curl_strcasecompare(p, "subtree")) {
			return -1024;
		} 
		return (true/*
		 * Split 'str' into strings separated by commas.
		 * Note: out[] points into 'str'.
		 */);
	}
	public static  split_str(Object str, Object out, Object count) {
		byte res;
		byte lasts;
		byte s;
		size_t i = new size_t();
		size_t items = 1;
		s = .strchr(str, (byte)',');
		while (s) {
			items++;
			s = .strchr(++s, (byte)',');
		}
		res = .Curl_ccalloc(items, );
		if (!res) {
			return 0;
		} 
		for (; s && i < items; ) {
			res[i] = s;
		}
		out = res;
		count = items;
		return 1/*
		 * Break apart the pieces of an LDAP URL.
		 * Syntax:
		 *   ldap://<hostname>:<port>/<base_dn>?<attributes>?<scope>?<filter>?<ext>
		 *
		 * <hostname> already known from 'conn->host.name'.
		 * <port>     already known from 'conn->remote_port'.
		 * extract the rest from 'conn->data->state.path+1'. All fields are optional.
		 * e.g.
		 *   ldap://<hostname>:<port>/?<attributes>?<scope>?<filter>
		 * yields ludp->lud_dn = "".
		 *
		 * Defined in RFC4516 section 2.
		 */;
	}
	public static int _ldap_url_parse2(Object conn, Object ludp) {
		int rc = -1024;
		byte p;
		byte path;
		byte q = ((Object)0);
		byte query = ((Object)0);
		size_t i = new size_t();
		if (!conn.getData() || !conn.getData().getState().getUp().getPath() || conn.getData().getState().getUp().getPath()[0] != (byte)'/' || !ModernizedCProgram.Curl_strncasecompare("LDAP", conn.getData().getState().getUp().getScheme(), 4)) {
			return -1024;
		} 
		ludp.setLud_scope(-1024);
		ludp.setLud_port(conn.getRemote_port());
		ludp.setLud_host(conn.getHost().getName());
		p = path = .Curl_cstrdup(conn.getData().getState().getUp().getPath() + /* Duplicate the path */1);
		if (!path) {
			return -1024;
		} 
		if (conn.getData().getState().getUp().getQuery()) {
			q = query = .Curl_cstrdup(conn.getData().getState().getUp().getQuery());
			if (!query) {
				.Curl_cfree(path);
				return -1024;
			} 
		} 
		if (/* Parse the DN (Distinguished Name) */p) {
			byte dn = p;
			byte unescaped;
			CURLcode result = new CURLcode();
			do {
			} while (0);
			result = ModernizedCProgram.Curl_urldecode(conn.getData(), dn, 0, unescaped, ((Object)0), /* Unescape the DN */0);
			if (result) {
				rc = -1024;
				;
			} 
			ludp.setLud_dn((/* Convert the unescaped string to a tchar */unescaped));
			do {
				(unescaped) = ((Object)0);
			} while (/* Free the unescaped string as we are done with it */0);
			if (!ludp.getLud_dn()) {
				rc = -1024;
				;
			} 
		} 
		p = q;
		if (!p) {
			;
		} 
		q = .strchr(p, /* Parse the attributes. skip "??" */(byte)'?');
		if (q) {
			q++ = (byte)'\0';
		} 
		if (p) {
			byte attributes;
			size_t count = 0;
			if (!ModernizedCProgram.split_str(p, attributes, /* Split the string into an array of attributes */count)) {
				rc = -1024;
				;
			} 
			ludp.setLud_attrs(.Curl_ccalloc(count + 1, /* Allocate our array (+1 for the NULL entry) */));
			if (!ludp.getLud_attrs()) {
				.Curl_cfree(attributes);
				rc = -1024;
				;
			} 
			for (i = 0; i < count; i++) {
				byte unescaped;
				CURLcode result = new CURLcode();
				do {
				} while (0);
				result = ModernizedCProgram.Curl_urldecode(conn.getData(), attributes[i], 0, unescaped, ((Object)/* Unescape the attribute */0), 0);
				if (result) {
					.Curl_cfree(attributes);
					rc = -1024;
					;
				} 
				ludp.getLud_attrs()[i] = (/* Convert the unescaped string to a tchar */unescaped);
				do {
					(unescaped) = ((Object)0);
				} while (/* Free the unescaped string as we are done with it */0);
				if (!ludp.getLud_attrs()[i]) {
					.Curl_cfree(attributes);
					rc = -1024;
					;
				} 
				ludp.getLud_attrs_dups()++;
			}
			.Curl_cfree(attributes);
		} 
		p = q;
		if (!p) {
			;
		} 
		q = .strchr(p, /* Parse the scope. skip "??" */(byte)'?');
		if (q) {
			q++ = (byte)'\0';
		} 
		if (p) {
			ludp.setLud_scope(ModernizedCProgram.str2scope(p));
			if (ludp.getLud_scope() == -1) {
				rc = -1024;
				;
			} 
			do {
			} while (0);
		} 
		p = q;
		if (!p) {
			;
		} 
		q = .strchr(p, /* Parse the filter */(byte)'?');
		if (q) {
			q++ = (byte)'\0';
		} 
		if (p) {
			byte filter = p;
			byte unescaped;
			CURLcode result = new CURLcode();
			do {
			} while (0);
			result = ModernizedCProgram.Curl_urldecode(conn.getData(), filter, 0, unescaped, ((Object)0), /* Unescape the filter */0);
			if (result) {
				rc = -1024;
				;
			} 
			ludp.setLud_filter((/* Convert the unescaped string to a tchar */unescaped));
			do {
				(unescaped) = ((Object)0);
			} while (/* Free the unescaped string as we are done with it */0);
			if (!ludp.getLud_filter()) {
				rc = -1024;
				;
			} 
		} 
		p = q;
		if (p && !p) {
			rc = -1024;
			;
		} 
		.Curl_cfree(query);
		return rc;
	}
	public static int _ldap_url_parse(Object conn, Object ludpp) {
		CURL_LDAPURLDesc ludp = .Curl_ccalloc(1, );
		int rc;
		ludpp = ((Object)0);
		if (!ludp) {
			return -1024;
		} 
		rc = ModernizedCProgram._ldap_url_parse2(conn, ludp);
		if (rc != -1024) {
			ModernizedCProgram._ldap_free_urldesc(ludp);
			ludp = ((Object)0);
		} 
		ludpp = ludp;
		return (rc);
	}
	public static void _ldap_free_urldesc(Object ludp) {
		if (!ludp) {
			return ;
		} 
		.Curl_cfree(ludp.getLud_dn());
		.Curl_cfree(ludp.getLud_filter());
		if (ludp.getLud_attrs()) {
			size_t i = new size_t();
			for (i = 0; i < ludp.getLud_attrs_dups(); i++) {
				.Curl_cfree(ludp.getLud_attrs()[i]);
			}
			.Curl_cfree(ludp.getLud_attrs());
		} 
		.Curl_cfree(ludp/* !HAVE_LDAP_URL_PARSE *//* !CURL_DISABLE_LDAP && !USE_OPENLDAP */);
	}
	public static void conn_state(Object conn, smb_conn_state newstate) {
		smb_conn smbc = conn.getProto().getSmbc();
		smbc.setState(/* LAST */smb_conn_state.newstate);
	}
	public static void request_state(Object conn, smb_req_state newstate) {
		smb_request req = conn.getData().getReq().getProtop();
		req.setState(/* LAST */smb_req_state.newstate);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2014, Bill Nagel <wnagel@tycoint.com>, Exacq Technologies
	 * Copyright (C) 2016-2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include files should be: */
	/* Local API functions */
	/* this should setup things in the connection, not in the easy
	   handle */
	public static  smb_setup_connection(Object conn) {
		smb_request req = new smb_request();
		conn.getData().getReq().setProtop(req = .Curl_ccalloc(1, /* Initialize the request state */));
		if (!req) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		return ModernizedCProgram.smb_parse_url_path(/* Parse the URL path */conn);
	}
	public static  smb_connect(Object conn, Object done) {
		smb_conn smbc = conn.getProto().getSmbc();
		byte slash;
		(Object)done;
		if (!conn.getBits().getUser_passwd()) {
			return .CURLE_LOGIN_DENIED;
		} 
		smbc.setState(/* Initialize the connection state */smb_conn_state.SMB_CONNECTING);
		smbc.setRecv_buf(.Curl_cmalloc((-1024 + -1024)));
		if (!smbc.getRecv_buf()) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.Curl_conncontrol(conn, /* Multiple requests are allowed with this connection */0);
		slash = .strchr(conn.getUser(), /* Parse the username, domain, and password */(byte)'/');
		if (!slash) {
			slash = .strchr(conn.getUser(), (byte)'\\');
		} 
		if (slash) {
			smbc.setUser(slash + 1);
			smbc.setDomain(.Curl_cstrdup(conn.getUser()));
			if (!smbc.getDomain()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			smbc.getDomain()[slash - conn.getUser()] = 0;
		} else {
				smbc.setUser(conn.getUser());
				smbc.setDomain(.Curl_cstrdup(conn.getHost().getName()));
				if (!smbc.getDomain()) {
					return .CURLE_OUT_OF_MEMORY;
				} 
		} 
		return .CURLE_OK;
	}
	public static  smb_recv_message(Object conn, Object msg) {
		smb_conn smbc = conn.getProto().getSmbc();
		byte buf = smbc.getRecv_buf();
		ssize_t bytes_read = new ssize_t();
		size_t nbt_size = new size_t();
		size_t msg_size = new size_t();
		size_t len = (-1024 + -1024) - smbc.getGot();
		CURLcode result = new CURLcode();
		result = ModernizedCProgram.Curl_read(conn, 0, buf + smbc.getGot(), len, bytes_read);
		if (result) {
			return result;
		} 
		if (!bytes_read) {
			return .CURLE_OK;
		} 
		smbc.getGot() += bytes_read;
		if (smbc.getGot() < /* Check for a 32-bit nbt header */) {
			return .CURLE_OK;
		} 
		nbt_size = ModernizedCProgram.Curl_read16_be((byte)(buf + )) + ;
		if (smbc.getGot() < nbt_size) {
			return .CURLE_OK;
		} 
		msg_size = ;
		if (nbt_size >= msg_size + 1) {
			msg_size += 1 + ((byte)buf[msg_size]) * /* Add the word count */;
			if (nbt_size >= msg_size + ) {
				msg_size += /* Add the byte count */ + ModernizedCProgram.Curl_read16_le((byte)buf[msg_size]);
				if (nbt_size < msg_size) {
					return .CURLE_READ_ERROR;
				} 
			} 
		} 
		msg = buf;
		return .CURLE_OK;
	}
	public static void smb_pop_message(Object conn) {
		smb_conn smbc = conn.getProto().getSmbc();
		smbc.setGot(0);
	}
	public static void smb_format_message(Object conn, Object h, byte cmd, Object len) {
		smb_conn smbc = conn.getProto().getSmbc();
		smb_request req = conn.getData().getReq().getProtop();
		int pid;
		.memset(h, 0, );
		h.setNbt_length(.htons((int)( -  + len)));
		.memcpy((byte)h.getMagic(), "\xffSMB", 4);
		h.setCommand(cmd);
		h.setFlags(-1024 | -1024);
		h.setFlags2((-1024 | -1024));
		h.setUid((smbc.getUid()));
		h.setTid((req.getTid()));
		pid = ._getpid();
		h.setPid_high(((int)(pid >> 16)));
		h.setPid(((int)pid));
	}
	public static  smb_send(Object conn, Object len, Object upload_size) {
		smb_conn smbc = conn.getProto().getSmbc();
		ssize_t bytes_written = new ssize_t();
		CURLcode result = new CURLcode();
		result = ModernizedCProgram.Curl_write(conn, 0, conn.getData().getState().getUlbuf(), len, bytes_written);
		if (result) {
			return result;
		} 
		if (bytes_written != len) {
			smbc.setSend_size(len);
			smbc.setSent(bytes_written);
		} 
		smbc.setUpload_size(upload_size);
		return .CURLE_OK;
	}
	public static  smb_flush(Object conn) {
		smb_conn smbc = conn.getProto().getSmbc();
		ssize_t bytes_written = new ssize_t();
		ssize_t len = smbc.getSend_size() - smbc.getSent();
		CURLcode result = new CURLcode();
		if (!smbc.getSend_size()) {
			return .CURLE_OK;
		} 
		result = ModernizedCProgram.Curl_write(conn, 0, conn.getData().getState().getUlbuf() + smbc.getSent(), len, bytes_written);
		if (result) {
			return result;
		} 
		if (bytes_written != len) {
			smbc.getSent() += bytes_written;
		} else {
				smbc.setSend_size(0);
		} 
		return .CURLE_OK;
	}
	public static  smb_send_message(Object conn, byte cmd, Object msg, Object msg_len) {
		CURLcode result = ModernizedCProgram.Curl_get_upload_buffer(conn.getData());
		if (result) {
			return result;
		} 
		ModernizedCProgram.smb_format_message(conn, (smb_header)conn.getData().getState().getUlbuf(), cmd, msg_len);
		.memcpy(conn.getData().getState().getUlbuf() + , msg, msg_len);
		return ModernizedCProgram.smb_send(conn,  + msg_len, 0);
	}
	public static  smb_send_negotiate(Object conn) {
		byte msg = "\x00\x0c\x00\x02NT LM 0.12";
		return ModernizedCProgram.smb_send_message(conn, -1024, msg, 15);
	}
	public static  smb_send_setup(Object conn) {
		smb_conn smbc = conn.getProto().getSmbc();
		smb_setup msg = new smb_setup();
		Object generatedBytes = msg.getBytes();
		byte p = generatedBytes;
		byte[] lm_hash = new byte[21];
		byte[] lm = new byte[24];
		byte[] nt_hash = new byte[21];
		byte[] nt = new byte[24];
		size_t byte_count =  + ;
		byte_count += .strlen(smbc.getUser()) + .strlen(smbc.getDomain());
		byte_count += .strlen("i386-pc-win32") + .strlen("curl") + /* 4 null chars */4;
		if (byte_count > ) {
			return .CURLE_FILESIZE_EXCEEDED;
		} 
		ModernizedCProgram.Curl_ntlm_core_mk_lm_hash(conn.getData(), conn.getPasswd(), lm_hash);
		ModernizedCProgram.Curl_ntlm_core_lm_resp(lm_hash, smbc.getChallenge(), lm);
		ModernizedCProgram.Curl_ntlm_core_mk_nt_hash(conn.getData(), conn.getPasswd(), nt_hash);
		ModernizedCProgram.Curl_ntlm_core_lm_resp(nt_hash, smbc.getChallenge(), nt);
		.memset(msg, 0, );
		msg.setWord_count(-1024);
		Object generatedAndx = msg.getAndx();
		generatedAndx.setCommand(-1024);
		msg.setMax_buffer_size(((-1024 + -1024)));
		msg.setMax_mpx_count((true));
		msg.setVc_number((true));
		msg.setSession_key((smbc.getSession_key()));
		msg.setCapabilities((true));
		Object generatedLengths = msg.getLengths();
		generatedLengths[0] = ();
		generatedLengths[1] = ();
		.memcpy(p, lm, );
		p += ;
		.memcpy(p, nt, );
		p += ;
		.strcpy(p, (smbc.getUser()));
		p += .strlen(smbc.getUser()) + 1;
		;
		.strcpy(p, (smbc.getDomain()));
		p += .strlen(smbc.getDomain()) + 1;
		;
		.strcpy(p, ("i386-pc-win32"));
		p += .strlen("i386-pc-win32") + 1;
		;
		.strcpy(p, ("curl"));
		p += .strlen("curl") + 1;
		;
		byte_count = p - generatedBytes;
		msg.setByte_count(((int)byte_count));
		return ModernizedCProgram.smb_send_message(conn, -1024, msg,  -  + byte_count);
	}
	public static  smb_send_tree_connect(Object conn) {
		smb_tree_connect msg = new smb_tree_connect();
		smb_conn smbc = conn.getProto().getSmbc();
		Object generatedBytes = msg.getBytes();
		byte p = generatedBytes;
		size_t byte_count = .strlen(conn.getHost().getName()) + .strlen(smbc.getShare());
		byte_count += .strlen("?????") + /* 2 nulls and 3 backslashes */5;
		if (byte_count > ) {
			return .CURLE_FILESIZE_EXCEEDED;
		} 
		.memset(msg, 0, );
		msg.setWord_count(-1024);
		Object generatedAndx = msg.getAndx();
		generatedAndx.setCommand(-1024);
		msg.setPw_len(0);
		.strcpy(p, ("\\\\"));
		p += .strlen("\\\\");
		;
		.strcpy(p, (conn.getHost().getName()));
		p += .strlen(conn.getHost().getName());
		;
		.strcpy(p, ("\\"));
		p += .strlen("\\");
		;
		.strcpy(p, (smbc.getShare()));
		p += .strlen(smbc.getShare()) + 1;
		;
		.strcpy(p, ("?????"));
		p += .strlen("?????") + /* Match any type of service */1;
		;
		byte_count = p - generatedBytes;
		msg.setByte_count(((int)byte_count));
		return ModernizedCProgram.smb_send_message(conn, -1024, msg,  -  + byte_count);
	}
	public static  smb_send_open(Object conn) {
		smb_request req = conn.getData().getReq().getProtop();
		smb_nt_create msg = new smb_nt_create();
		size_t byte_count = new size_t();
		Object generatedBytes = msg.getBytes();
		if ((.strlen(req.getPath()) + 1) > ) {
			return .CURLE_FILESIZE_EXCEEDED;
		} 
		.memset(msg, 0, );
		msg.setWord_count(-1024);
		Object generatedAndx = msg.getAndx();
		generatedAndx.setCommand(-1024);
		byte_count = .strlen(req.getPath());
		msg.setName_length(((int)byte_count));
		msg.setShare_access((true));
		if (conn.getData().getSet().getUpload()) {
			msg.setAccess((-1024 | -1024));
			msg.setCreate_disposition((true));
		} else {
				msg.setAccess((true));
				msg.setCreate_disposition((true));
		} 
		msg.setByte_count(((int)++byte_count));
		.strcpy(generatedBytes, req.getPath());
		return ModernizedCProgram.smb_send_message(conn, -1024, msg,  -  + byte_count);
	}
	public static  smb_send_close(Object conn) {
		smb_request req = conn.getData().getReq().getProtop();
		smb_close msg = new smb_close();
		.memset(msg, 0, );
		msg.setWord_count(-1024);
		msg.setFid((req.getFid()));
		return ModernizedCProgram.smb_send_message(conn, -1024, msg, );
	}
	public static  smb_send_tree_disconnect(Object conn) {
		smb_tree_disconnect msg = new smb_tree_disconnect();
		.memset(msg, 0, );
		return ModernizedCProgram.smb_send_message(conn, -1024, msg, );
	}
	public static  smb_send_read(Object conn) {
		smb_request req = conn.getData().getReq().getProtop();
		curl_off_t offset = conn.getData().getReq().getOffset();
		smb_read msg = new smb_read();
		.memset(msg, 0, );
		msg.setWord_count(-1024);
		Object generatedAndx = msg.getAndx();
		generatedAndx.setCommand(-1024);
		msg.setFid((req.getFid()));
		msg.setOffset(((int)offset));
		msg.setOffset_high(((int)(offset >> 32)));
		msg.setMin_bytes((true));
		msg.setMax_bytes((true));
		return ModernizedCProgram.smb_send_message(conn, -1024, msg, );
	}
	public static  smb_send_write(Object conn) {
		smb_write msg = new smb_write();
		smb_request req = conn.getData().getReq().getProtop();
		curl_off_t offset = conn.getData().getReq().getOffset();
		curl_off_t upload_size = conn.getData().getReq().getSize() - conn.getData().getReq().getBytecount();
		CURLcode result = ModernizedCProgram.Curl_get_upload_buffer(conn.getData());
		if (result) {
			return result;
		} 
		msg = (smb_write)conn.getData().getState().getUlbuf();
		if (upload_size >= -1024 - /* There is one byte of padding */1) {
			upload_size = -1024 - 1;
		} 
		.memset(msg, 0, );
		msg.setWord_count(-1024);
		msg.getAndx().setCommand(-1024);
		msg.setFid((req.getFid()));
		msg.setOffset(((int)offset));
		msg.setOffset_high(((int)(offset >> 32)));
		msg.setData_length(((int)upload_size));
		msg.setData_offset(( - ));
		msg.setByte_count(((int)(upload_size + 1)));
		ModernizedCProgram.smb_format_message(conn, msg.getH(), -1024,  -  + (size_t)upload_size);
		return ModernizedCProgram.smb_send(conn, , (size_t)upload_size);
	}
	public static  smb_send_and_recv(Object conn, Object msg) {
		smb_conn smbc = conn.getProto().getSmbc();
		CURLcode result = new CURLcode();
		msg = ((Object)/* if it returns early */0);
		if (!smbc.getSend_size() && smbc.getUpload_size()) {
			size_t nread = smbc.getUpload_size() > conn.getData().getSet().getUpload_buffer_size() ? conn.getData().getSet().getUpload_buffer_size() : smbc.getUpload_size();
			conn.getData().getReq().setUpload_fromhere(conn.getData().getState().getUlbuf());
			result = ModernizedCProgram.Curl_fillreadbuffer(conn, nread, nread);
			if (result && result != .CURLE_AGAIN) {
				return result;
			} 
			if (!nread) {
				return .CURLE_OK;
			} 
			smbc.getUpload_size() -= nread;
			smbc.setSend_size(nread);
			smbc.setSent(0);
		} 
		if (smbc.getSend_size()) {
			result = ModernizedCProgram.smb_flush(conn);
			if (result) {
				return result;
			} 
		} 
		if (smbc.getSend_size() || smbc.getUpload_size()) {
			return .CURLE_AGAIN;
		} 
		return ModernizedCProgram.smb_recv_message(conn, msg);
	}
	public static  smb_connection_state(Object conn, Object done) {
		smb_conn smbc = conn.getProto().getSmbc();
		smb_negotiate_response nrsp = new smb_negotiate_response();
		smb_header h = new smb_header();
		CURLcode result = new CURLcode();
		Object msg = ((Object)0);
		if (smbc.getState() == smb_conn_state.SMB_CONNECTING) {
			result = ModernizedCProgram.smb_send_negotiate(conn);
			if (result) {
				ModernizedCProgram.Curl_conncontrol(conn, 1);
				return result;
			} 
			ModernizedCProgram.conn_state(conn, smb_conn_state.SMB_NEGOTIATE);
		} 
		result = ModernizedCProgram.smb_send_and_recv(conn, /* Send the previous message and check for a response */msg);
		if (result && result != .CURLE_AGAIN) {
			ModernizedCProgram.Curl_conncontrol(conn, 1);
			return result;
		} 
		if (!msg) {
			return .CURLE_OK;
		} 
		h = msg;
		switch (smbc.getState()) {
		case smb_conn_state.SMB_NEGOTIATE:
				if ((smbc.getGot() <  +  - 1) || h.getStatus()) {
					ModernizedCProgram.Curl_conncontrol(conn, 1);
					return .CURLE_COULDNT_CONNECT;
				} 
				nrsp = msg;
				.memcpy(smbc.getChallenge(), nrsp.getBytes(), );
				smbc.setSession_key((nrsp.getSession_key()));
				result = ModernizedCProgram.smb_send_setup(conn);
				if (result) {
					ModernizedCProgram.Curl_conncontrol(conn, 1);
					return result;
				} 
				ModernizedCProgram.conn_state(conn, smb_conn_state.SMB_SETUP);
				break;
		case smb_conn_state.SMB_SETUP:
				if (h.getStatus()) {
					ModernizedCProgram.Curl_conncontrol(conn, 1);
					return .CURLE_LOGIN_DENIED;
				} 
				smbc.setUid((h.getUid()));
				ModernizedCProgram.conn_state(conn, smb_conn_state.SMB_CONNECTED);
				done = .bool_true;
				break;
		default:
				ModernizedCProgram.smb_pop_message(conn);
				return /* ignore */.CURLE_OK;
		}
		ModernizedCProgram.smb_pop_message(conn);
		return .CURLE_OK/*
		 * Convert a timestamp from the Windows world (100 nsec units from 1 Jan 1601)
		 * to Posix time. Cap the output to fit within a time_t.
		 */;
	}
	public static void get_posix_time(Object out, Object timestamp) {
		timestamp -= -1024;
		timestamp /= 10000000;
		if (timestamp > 2147483647) {
			out = 2147483647;
		}  else if (timestamp < (-2147483647 - 1)) {
			out = (-2147483647 - 1);
		} else {
				out = (time_t)timestamp;
		} 
	}
	public static  smb_request_state(Object conn, Object done) {
		smb_request req = conn.getData().getReq().getProtop();
		smb_header h = new smb_header();
		smb_conn smbc = conn.getProto().getSmbc();
		smb_req_state next_state = smb_req_state.SMB_DONE;
		int len;
		int off;
		CURLcode result = new CURLcode();
		Object msg = ((Object)0);
		smb_nt_create_response smb_m = new smb_nt_create_response();
		if (req.getState() == /* Start the request */smb_req_state.SMB_REQUESTING) {
			result = ModernizedCProgram.smb_send_tree_connect(conn);
			if (result) {
				ModernizedCProgram.Curl_conncontrol(conn, 1);
				return result;
			} 
			ModernizedCProgram.request_state(conn, smb_req_state.SMB_TREE_CONNECT);
		} 
		result = ModernizedCProgram.smb_send_and_recv(conn, /* Send the previous message and check for a response */msg);
		if (result && result != .CURLE_AGAIN) {
			ModernizedCProgram.Curl_conncontrol(conn, 1);
			return result;
		} 
		if (!msg) {
			return .CURLE_OK;
		} 
		h = msg;
		switch (req.getState()) {
		case smb_req_state.SMB_TREE_CONNECT:
				if (h.getStatus()) {
					req.setResult(.CURLE_REMOTE_FILE_NOT_FOUND);
					if (h.getStatus() == (true)) {
						req.setResult(.CURLE_REMOTE_ACCESS_DENIED);
					} 
					break;
				} 
				req.setTid((h.getTid()));
				smb_req_state.next_state = smb_req_state.SMB_OPEN;
				break;
		case smb_req_state.SMB_UPLOAD:
				if (h.getStatus() || smbc.getGot() <  + 6) {
					req.setResult(.CURLE_UPLOAD_FAILED);
					smb_req_state.next_state = smb_req_state.SMB_CLOSE;
					break;
				} 
				len = ModernizedCProgram.Curl_read16_le(((byte)msg) +  + 5);
				conn.getData().getReq().getBytecount() += len;
				conn.getData().getReq().getOffset() += len;
				ModernizedCProgram.Curl_pgrsSetUploadCounter(conn.getData(), conn.getData().getReq().getBytecount());
				if (conn.getData().getReq().getBytecount() >= conn.getData().getReq().getSize()) {
					smb_req_state.next_state = smb_req_state.SMB_CLOSE;
				} else {
						smb_req_state.next_state = smb_req_state.SMB_UPLOAD;
				} 
				break;
		case smb_req_state.SMB_CLOSE:
				smb_req_state.next_state = /* We don't care if the close failed, proceed to tree disconnect anyway */smb_req_state.SMB_TREE_DISCONNECT;
				break;
		case smb_req_state.SMB_DOWNLOAD:
				if (h.getStatus() || smbc.getGot() <  + 14) {
					req.setResult(.CURLE_RECV_ERROR);
					smb_req_state.next_state = smb_req_state.SMB_CLOSE;
					break;
				} 
				len = ModernizedCProgram.Curl_read16_le(((byte)msg) +  + 11);
				off = ModernizedCProgram.Curl_read16_le(((byte)msg) +  + 13);
				if (len > 0) {
					if (off +  + len > smbc.getGot()) {
						ModernizedCProgram.Curl_failf(conn.getData(), "Invalid input packet");
						result = .CURLE_RECV_ERROR;
					} else {
							result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)msg + off + , len);
					} 
					if (result) {
						req.setResult(result);
						smb_req_state.next_state = smb_req_state.SMB_CLOSE;
						break;
					} 
				} 
				conn.getData().getReq().getBytecount() += len;
				conn.getData().getReq().getOffset() += len;
				ModernizedCProgram.Curl_pgrsSetDownloadCounter(conn.getData(), conn.getData().getReq().getBytecount());
				smb_req_state.next_state = (len < -1024) ? smb_req_state.SMB_CLOSE : smb_req_state.SMB_DOWNLOAD;
				break;
		case smb_req_state.SMB_TREE_DISCONNECT:
				smb_req_state.next_state = smb_req_state.SMB_DONE;
				break;
		case smb_req_state.SMB_OPEN:
				if (h.getStatus() || smbc.getGot() < ) {
					req.setResult(.CURLE_REMOTE_FILE_NOT_FOUND);
					if (h.getStatus() == (true)) {
						req.setResult(.CURLE_REMOTE_ACCESS_DENIED);
					} 
					smb_req_state.next_state = smb_req_state.SMB_TREE_DISCONNECT;
					break;
				} 
				smb_m = (smb_nt_create_response)msg;
				req.setFid((smb_m.getFid()));
				conn.getData().getReq().setOffset(0);
				if (conn.getData().getSet().getUpload()) {
					conn.getData().getReq().setSize(conn.getData().getState().getInfilesize());
					ModernizedCProgram.Curl_pgrsSetUploadSize(conn.getData(), conn.getData().getReq().getSize());
					smb_req_state.next_state = smb_req_state.SMB_UPLOAD;
				} else {
						smb_m = (smb_nt_create_response)msg;
						conn.getData().getReq().setSize((smb_m.getEnd_of_file()));
						if (conn.getData().getReq().getSize() < 0) {
							req.setResult(.CURLE_WEIRD_SERVER_REPLY);
							smb_req_state.next_state = smb_req_state.SMB_CLOSE;
						} else {
								ModernizedCProgram.Curl_pgrsSetDownloadSize(conn.getData(), conn.getData().getReq().getSize());
								if (conn.getData().getSet().getGet_filetime()) {
									ModernizedCProgram.get_posix_time(conn.getData().getInfo().getFiletime(), smb_m.getLast_change_time());
								} 
								smb_req_state.next_state = smb_req_state.SMB_DOWNLOAD;
						} 
				} 
				break;
		default:
				ModernizedCProgram.smb_pop_message(conn);
				return /* ignore */.CURLE_OK;
		}
		ModernizedCProgram.smb_pop_message(conn);
		switch (smb_req_state.next_state) {
		case smb_req_state.SMB_DOWNLOAD:
				result = ModernizedCProgram.smb_send_read(conn);
				break;
		case smb_req_state.SMB_TREE_DISCONNECT:
				result = ModernizedCProgram.smb_send_tree_disconnect(conn);
				break;
		case smb_req_state.SMB_CLOSE:
				result = ModernizedCProgram.smb_send_close(conn);
				break;
		case smb_req_state.SMB_UPLOAD:
				result = ModernizedCProgram.smb_send_write(conn);
				break;
		case smb_req_state.SMB_DONE:
				result = req.getResult();
				done = .bool_true;
				break;
		case smb_req_state.SMB_OPEN:
				result = ModernizedCProgram.smb_send_open(conn);
				break;
		default:
				break;
		}
		if (result) {
			ModernizedCProgram.Curl_conncontrol(conn, 1);
			return result;
		} 
		ModernizedCProgram.request_state(conn, smb_req_state.next_state);
		return .CURLE_OK;
	}
	public static  smb_done(Object conn,  status,  premature) {
		(Object)premature;
		do {
			.Curl_cfree((conn.getData().getReq().getProtop()));
			(conn.getData().getReq().getProtop()) = ((Object)0);
		} while (0);
		return status;
	}
	public static  smb_disconnect(Object conn,  dead) {
		smb_conn smbc = conn.getProto().getSmbc();
		(Object)dead;
		do {
			.Curl_cfree((smbc.getShare()));
			(smbc.getShare()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((smbc.getDomain()));
			(smbc.getDomain()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((smbc.getRecv_buf()));
			(smbc.getRecv_buf()) = ((Object)0);
		} while (0);
		return .CURLE_OK;
	}
	public static int smb_getsock(Object conn, Object socks) {
		socks[0] = conn.getSock()[0];
		return (1 << (false)) | (1 << (16 + (false)));
	}
	public static  smb_do(Object conn, Object done) {
		smb_conn smbc = conn.getProto().getSmbc();
		done = 0;
		if (smbc.getShare()) {
			return .CURLE_OK;
		} 
		return .CURLE_URL_MALFORMAT;
	}
	public static  smb_parse_url_path(Object conn) {
		Curl_easy data = conn.getData();
		smb_request req = data.getReq().getProtop();
		smb_conn smbc = conn.getProto().getSmbc();
		byte path;
		byte slash;
		CURLcode result = ModernizedCProgram.Curl_urldecode(data, data.getState().getUp().getPath(), 0, path, ((Object)/* URL decode the path */0), 1);
		if (result) {
			return result;
		} 
		smbc.setShare(.Curl_cstrdup((path == (byte)'/' || path == (byte)'\\') ? path + 1 : /* Parse the path for the share */path));
		.Curl_cfree(path);
		if (!smbc.getShare()) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		slash = .strchr(smbc.getShare(), (byte)'/');
		if (!slash) {
			slash = .strchr(smbc.getShare(), (byte)'\\');
		} 
		if (!/* The share must be present */slash) {
			do {
				.Curl_cfree((smbc.getShare()));
				(smbc.getShare()) = ((Object)0);
			} while (0);
			return .CURLE_URL_MALFORMAT;
		} 
		slash++ = /* Parse the path for the file path converting any forward slashes into
		     backslashes */0;
		req.setPath(slash);
		for (; slash; slash++) {
			if (slash == (byte)'/') {
				slash = (byte)'\\';
			} 
		}
		return .CURLE_OK/* !USE_WINDOWS_SSPI || USE_WIN32_CRYPTO *//* CURL_DISABLE_SMB && USE_NTLM && CURL_SIZEOF_CURL_OFF_T > 4 */;
	}
	/*
	 * SMB handler interface
	 */
	/* doing */
	/* proto_getsock */
	/* doing_getsock */
	/* domore_getsock */
	/* perform_getsock */
	/* disconnect */
	/* readwrite */
	/* connection_check */
	/* defport */
	/* protocol */
	/* flags */
	public static void close_secondarysocket(Object conn) {
		if ((SOCKET)(~0) != conn.getSock()[1]) {
			ModernizedCProgram.Curl_closesocket(conn, conn.getSock()[1]);
			conn.getSock()[1] = (SOCKET)(~0);
		} 
		conn.getBits().getTcpconnect()[1] = 0/*
		 * NOTE: back in the old days, we added code in the FTP code that made NOBODY
		 * requests on files respond with headers passed to the client/stdout that
		 * looked like HTTP ones.
		 *
		 * This approach is not very elegant, it causes confusion and is error-prone.
		 * It is subject for removal at the next (or at least a future) soname bump.
		 * Until then you can test the effects of the removal by undefining the
		 * following define named CURL_FTP_HTTPSTYLE_HEAD.
		 */;
	}
	public static void freedirs(Object ftpc) {
		if (ftpc.getDirs()) {
			int i;
			for (i = 0; i < ftpc.getDirdepth(); i++) {
				.Curl_cfree(ftpc.getDirs()[i]);
				ftpc.getDirs()[i] = ((Object)0);
			}
			.Curl_cfree(ftpc.getDirs());
			ftpc.setDirs(((Object)0));
			ftpc.setDirdepth(0);
		} 
		do {
			.Curl_cfree((ftpc.getFile()));
			(ftpc.getFile()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((ftpc.getNewhost()));
			(ftpc.getNewhost()) = ((Object)0);
		} while (/* no longer of any use */0/* Returns non-zero if the given string contains CR (\r) or LF (\n),
		   which are not allowed within RFC 959 <string>.
		   Note: The input string is in the client's encoding which might
		   not be ASCII, so escape sequences \r & \n must be used instead
		   of hex values 0x0d & 0x0a.
		*/);
	}
	public static  isBadFtpString(Object string) {
		return ((((Object)0) != .strchr(string, (byte)'\r')) || (((Object)0) != .strchr(string, (byte)'\n'))) ? 1 : 0/***********************************************************************
		 *
		 * AcceptServerConnect()
		 *
		 * After connection request is received from the server this function is
		 * called to accept the connection and close the listening socket
		 *
		 */;
	}
	public static  AcceptServerConnect(Object conn) {
		Curl_easy data = conn.getData();
		curl_socket_t sock = conn.getSock()[1];
		curl_socket_t s = (SOCKET)(~0);
		sockaddr_in add = new sockaddr_in();
		curl_socklen_t size = (curl_socklen_t);
		if (0 == .getsockname(sock, (sockaddr)add, size)) {
			size = ;
			s = .accept(sock, (sockaddr)add, size);
		} 
		ModernizedCProgram.Curl_closesocket(conn, /* close the first socket */sock);
		if ((SOCKET)(~0) == s) {
			ModernizedCProgram.Curl_failf(data, "Error accept()ing server connect");
			return .CURLE_FTP_PORT_FAILED;
		} 
		ModernizedCProgram.Curl_infof(data, "Connection accepted from server\n"/* when this happens within the DO state it is important that we mark us as
		     not needing DO_MORE anymore */);
		conn.getBits().setDo_more(0);
		conn.getSock()[1] = s;
		(Object)ModernizedCProgram.curlx_nonblock(s, /* enable non-blocking */1);
		conn.getSock_accepted()[1] = 1;
		if (data.getSet().getFsockopt()) {
			int error = 0;
			ModernizedCProgram.Curl_set_in_callback(data, /* activate callback for setting socket options */.bool_true);
			error = .UNRECOGNIZEDFUNCTIONNAME(data.getSet().getSockopt_client(), s, .CURLSOCKTYPE_ACCEPT);
			ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
			if (error) {
				ModernizedCProgram.close_secondarysocket(conn);
				return .CURLE_ABORTED_BY_CALLBACK;
			} 
		} 
		return .CURLE_OK/*
		 * ftp_timeleft_accept() returns the amount of milliseconds left allowed for
		 * waiting server to connect. If the value is negative, the timeout time has
		 * already elapsed.
		 *
		 * The start time is stored in progress.t_acceptdata - as set with
		 * Curl_pgrsTime(..., TIMER_STARTACCEPT);
		 *
		 */;
	}
	public static Object ftp_timeleft_accept(Object data) {
		timediff_t timeout_ms = 60000;
		timediff_t other = new timediff_t();
		curltime now = new curltime();
		if (data.getSet().getAccepttimeout() > 0) {
			timeout_ms = data.getSet().getAccepttimeout();
		} 
		curltime curltime = new curltime();
		now = curltime.Curl_now();
		other = ModernizedCProgram.Curl_timeleft(data, now, /* check if the generic timeout possibly is set shorter */0);
		if (other && (other < timeout_ms/* note that this also works fine for when other happens to be negative
		       due to it already having elapsed */)) {
			timeout_ms = other;
		} else {
				timeout_ms -= now.Curl_timediff(data.getProgress().getT_acceptdata());
				if (!timeout_ms) {
					return -/* avoid returning 0 as that means no timeout! */1;
				} 
		} 
		return timeout_ms/***********************************************************************
		 *
		 * ReceivedServerConnect()
		 *
		 * After allowing server to connect to us from data port, this function
		 * checks both data connection for connection establishment and ctrl
		 * connection for a negative response regarding a failure in connecting
		 *
		 */;
	}
	public static  ReceivedServerConnect(Object conn, Object received) {
		Curl_easy data = conn.getData();
		curl_socket_t ctrl_sock = conn.getSock()[0];
		curl_socket_t data_sock = conn.getSock()[1];
		ftp_conn ftpc = conn.getProto().getFtpc();
		pingpong pp = ftpc.getPp();
		int result;
		timediff_t timeout_ms = new timediff_t();
		ssize_t nread = new ssize_t();
		int ftpcode;
		received = 0;
		timeout_ms = ModernizedCProgram.ftp_timeleft_accept(data);
		ModernizedCProgram.Curl_infof(data, "Checking for server connect\n");
		if (timeout_ms < 0) {
			ModernizedCProgram.Curl_failf(data, /* if a timeout was already reached, bail out */"Accept timeout occurred while waiting server connect");
			return .CURLE_FTP_ACCEPT_TIMEOUT;
		} 
		if (pp.getCache_size() && pp.getCache() && pp.getCache()[0] > /* First check whether there is a cached response from server */(byte)'3') {
			ModernizedCProgram.Curl_infof(data, /* Data connection could not be established, let's return */"There is negative response in cache while serv connect\n");
			ModernizedCProgram.Curl_GetFTPResponse(nread, conn, ftpcode);
			return .CURLE_FTP_ACCEPT_FAILED;
		} 
		result = ModernizedCProgram.Curl_socket_check(ctrl_sock, data_sock, (SOCKET)(~0), 0);
		switch (/* see if the connection request is already here */result) {
		case -/* error */1:
				ModernizedCProgram.Curl_failf(data, /* let's die here */"Error while waiting for server connect");
				return .CURLE_FTP_ACCEPT_FAILED;
		case /* Server connect is not received yet */0:
				break;
		default:
				if (result & (-1024 << 1)) {
					ModernizedCProgram.Curl_infof(data, "Ready to accept data connection from server\n");
					received = 1;
				}  else if (result & -1024) {
					ModernizedCProgram.Curl_infof(data, "Ctrl conn has data while waiting for data conn\n");
					ModernizedCProgram.Curl_GetFTPResponse(nread, conn, ftpcode);
					if (ftpcode / 100 > 3) {
						return .CURLE_FTP_ACCEPT_FAILED;
					} 
					return .CURLE_WEIRD_SERVER_REPLY;
				} 
				break;
		}
		return .CURLE_OK/***********************************************************************
		 *
		 * InitiateTransfer()
		 *
		 * After connection from server is accepted this function is called to
		 * setup transfer parameters and initiate the data transfer.
		 *
		 */;
	}
	public static  InitiateTransfer(Object conn) {
		Curl_easy data = conn.getData();
		CURLcode result = .CURLE_OK;
		if (conn.getBits().getFtp_use_data_ssl()) {
			ModernizedCProgram.Curl_infof(data, "Doing the SSL/TLS handshake on the data stream\n");
			result = .CURLE_NOT_BUILT_IN;
			if (result) {
				return result;
			} 
		} 
		if (conn.getProto().getFtpc().getState_saved() == .FTP_STOR/* When we know we're uploading a specified file, we can get the file
		       size prior to the actual upload. */) {
			ModernizedCProgram.Curl_pgrsSetUploadSize(data, data.getState().getInfilesize());
			ModernizedCProgram.Curl_sndbufset(conn.getSock()[/* set the SO_SNDBUF for the secondary socket for those who need it */1]);
			ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, 1);
		} else {
				ModernizedCProgram.Curl_setup_transfer(data, /* FTP download: */1, conn.getProto().getFtpc().getRetr_size_saved(), 0, -1);
		} 
		conn.getProto().getFtpc().getPp().setPending_resp(/* expect server response */1);
		ModernizedCProgram._state(conn, .FTP_STOP);
		return .CURLE_OK/***********************************************************************
		 *
		 * AllowServerConnect()
		 *
		 * When we've issue the PORT command, we have told the server to connect to
		 * us. This function checks whether data connection is established if so it is
		 * accepted.
		 *
		 */;
	}
	public static  AllowServerConnect(Object conn, Object connected) {
		Curl_easy data = conn.getData();
		timediff_t timeout_ms = new timediff_t();
		CURLcode result = .CURLE_OK;
		connected = 0;
		ModernizedCProgram.Curl_infof(data, "Preparing for accepting server on data port\n");
		ModernizedCProgram.Curl_pgrsTime(data, /* Save the time we start accepting server connect */.TIMER_STARTACCEPT);
		timeout_ms = ModernizedCProgram.ftp_timeleft_accept(data);
		if (timeout_ms < 0) {
			ModernizedCProgram.Curl_failf(data, /* if a timeout was already reached, bail out */"Accept timeout occurred while waiting server connect");
			return .CURLE_FTP_ACCEPT_TIMEOUT;
		} 
		result = ModernizedCProgram.ReceivedServerConnect(conn, /* see if the connection request is already here */connected);
		if (result) {
			return result;
		} 
		if (connected) {
			result = ModernizedCProgram.AcceptServerConnect(conn);
			if (result) {
				return result;
			} 
			result = ModernizedCProgram.InitiateTransfer(conn);
			if (result) {
				return result;
			} 
		} else {
				if (connected == /* Add timeout to multi handle and break out of the loop */0) {
					ModernizedCProgram.Curl_expire(data, data.getSet().getAccepttimeout() > 0 ? data.getSet().getAccepttimeout() : 60000, 0);
				} 
		} 
		return result/* macro to check for a three-digit ftp status code at the start of the
		   given string */;
	}
	/* macro to check for the last line in an FTP server response */
	public static  ftp_endofresp(Object conn, Object line, Object len, Object code) {
		(Object)conn;
		if ((len > 3) && (((ModernizedCProgram.Curl_isdigit((int)((byte)line[0]))) && (ModernizedCProgram.Curl_isdigit((int)((byte)line[1]))) && (ModernizedCProgram.Curl_isdigit((int)((byte)line[2])))) && ((byte)' ' == line[3]))) {
			code = ModernizedCProgram.curlx_sltosi(.strtol(line, ((Object)0), 10));
			return 1;
		} 
		return 0;
	}
	public static  ftp_readresp(Object sockfd, Object pp, Object ftpcode, Object size) {
		connectdata conn = pp.getConn();
		Curl_easy data = conn.getData();
		int code;
		CURLcode result = ModernizedCProgram.Curl_pp_readresp(sockfd, pp, code, size/* handle the security-oriented responses 6xx ***/);
		data.getInfo().setHttpcode(/* normal ftp stuff we pass through! *//* store the latest code for later retrieval */code);
		if (ftpcode) {
			ftpcode = code;
		} 
		if (421 == code/* 421 means "Service not available, closing control connection." and FTP
		     * servers use it to signal that idle session timeout has been exceeded.
		     * If we ignored the response, it could end up hanging in some cases.
		     *
		     * This response code can come at any point so having it treated
		     * generically is a good idea.
		     */) {
			ModernizedCProgram.Curl_infof(data, "We got a 421 - timeout!\n");
			ModernizedCProgram._state(conn, .FTP_STOP);
			return .CURLE_OPERATION_TIMEDOUT;
		} 
		return result/* --- parse FTP server responses --- *//*
		 * Curl_GetFTPResponse() is a BLOCKING function to read the full response
		 * from a server after a command.
		 *
		 */;
	}
	/* return number of bytes read */
	public static  Curl_GetFTPResponse(Object nreadp, Object conn, Object ftpcode) {
		curl_socket_t sockfd = conn.getSock()[0];
		Curl_easy data = conn.getData();
		CURLcode result = .CURLE_OK;
		ftp_conn ftpc = conn.getProto().getFtpc();
		pingpong pp = ftpc.getPp();
		size_t nread = new size_t();
		int cache_skip = 0;
		int value_to_be_ignored = 0;
		if (ftpcode) {
			ftpcode = /* 0 for errors */0;
		} else {
				ftpcode = /* make the pointer point to something for the rest of this function */value_to_be_ignored;
		} 
		nreadp = 0;
		while (!ftpcode && !result) {
			time_t timeout = ModernizedCProgram.Curl_pp_state_timeout(pp, /* check and reset timeout value every lap */0);
			time_t interval_ms = new time_t();
			if (timeout <= 0) {
				ModernizedCProgram.Curl_failf(data, "FTP response timeout");
				return /* already too little time */.CURLE_OPERATION_TIMEDOUT;
			} 
			interval_ms = /* use 1 second timeout intervals */1000;
			if (timeout < interval_ms) {
				interval_ms = timeout/*
				     * Since this function is blocking, we need to wait here for input on the
				     * connection and only then we call the response reading function. We do
				     * timeout at least every second to make the timeout check run.
				     *
				     * A caution here is that the ftp_readresp() function has a cache that may
				     * contain pieces of a response from the previous invoke and we need to
				     * make sure we don't just wait for input while there is unhandled data in
				     * that cache. But also, if the cache is there, we call ftp_readresp() and
				     * the cache wasn't good enough to continue we must not just busy-loop
				     * around this function.
				     *
				     */;
			} 
			if (pp.getCache() && (cache_skip < 2/*
			       * There's a cache left since before. We then skipping the wait for
			       * socket action, unless this is the same cache like the previous round
			       * as then the cache was deemed not enough to act on and we then need to
			       * wait for more data anyway.
			       */)) {
			}  else if (!ModernizedCProgram.Curl_conn_data_pending(conn, 0)) {
				switch (ModernizedCProgram.Curl_socket_check(sockfd, (SOCKET)(~0), (SOCKET)(~0), (time_t)interval_ms)) {
				case /* timeout */0:
						if (ModernizedCProgram.Curl_pgrsUpdate(conn)) {
							return .CURLE_ABORTED_BY_CALLBACK;
						} 
						continue;
				case -/* select() error, stop reading */1:
						ModernizedCProgram.Curl_failf(data, "FTP response aborted due to select/poll error: %d", ((int).WSAGetLastError()));
						return .CURLE_RECV_ERROR;
				default:
						break;
				}
			} 
			result = ModernizedCProgram.ftp_readresp(sockfd, pp, ftpcode, nread);
			if (result) {
				break;
			} 
			if (!nread && pp.getCache()) {
				cache_skip++;
			} else {
					cache_skip = /* when we got data or there is no cache left, we reset the cache skip
					         counter */0;
			} 
			nreadp += nread;
		}
		pp.setPending_resp(/* while there's buffer left and loop is requested */0);
		return result/* for debug purposes */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* for HTTP proxy tunnel stuff */
	/* for the week day and month names */
	/* required for Curl_sockaddr_storage */
	/* The last 3 #include files should be in this order */
	/* Local API functions */
	/* This is the ONLY way to change FTP state! */
	public static void _state(Object conn,  newstate) {
		ftp_conn ftpc = conn.getProto().getFtpc();
		ftpc.setState(newstate);
	}
	public static  ftp_state_user(Object conn) {
		CURLcode result = new CURLcode();
		FTP ftp = conn.getData().getReq().getProtop();
		result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "USER %s", ftp.getUser() ? ftp.getUser() : "");
		if (result) {
			return /* send USER */result;
		} 
		ModernizedCProgram._state(conn, .FTP_USER);
		conn.getData().getState().setFtp_trying_alternative(0);
		return .CURLE_OK;
	}
	public static  ftp_state_pwd(Object conn) {
		CURLcode result = new CURLcode();
		result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "%s", "PWD");
		if (result) {
			return /* send PWD to discover our entry point */result;
		} 
		ModernizedCProgram._state(conn, .FTP_PWD);
		return .CURLE_OK;
	}
	/* For the FTP "protocol connect" and "doing" phases only */
	public static int ftp_getsock(Object conn, Object socks) {
		return ModernizedCProgram.Curl_pp_getsock(conn.getProto().getFtpc().getPp(), socks);
	}
	/* For the FTP "DO_MORE" phase only */
	public static int ftp_domore_getsock(Object conn, Object socks) {
		ftp_conn ftpc = conn.getProto().getFtpc();
		if (.FTP_STOP == ftpc.getState()) {
			int bits = (1 << (false));
			socks[0] = conn.getSock()[/* if stopped and still in this state, then we're also waiting for a
			       connect on the secondary connection */0];
			if (!conn.getData().getSet().getFtp_use_port()) {
				int s;
				int i;
				for (; i < 2; i++) {
					if (conn.getTempsock()[i] != (SOCKET)(~0)) {
						socks[s] = conn.getTempsock()[i];
						bits |=  (1 << (16 + (s++)));
					} 
				}
			} else {
					socks[1] = conn.getSock()[1];
					bits |=  (1 << (16 + (true))) | (1 << (true));
			} 
			return bits;
		} 
		return ModernizedCProgram.Curl_pp_getsock(conn.getProto().getFtpc().getPp(), socks/* This is called after the FTP_QUOTE state is passed.
		
		   ftp_state_cwd() sends the range of CWD commands to the server to change to
		   the correct directory. It may also need to send MKD commands to create
		   missing ones, if that option is enabled.
		*/);
	}
	public static  ftp_state_cwd(Object conn) {
		CURLcode result = .CURLE_OK;
		ftp_conn ftpc = conn.getProto().getFtpc();
		if (ftpc.getCwddone()) {
			result = ModernizedCProgram.ftp_state_mdtm(/* already done and fine */conn);
		} else {
				do {
				} while (/* FTPFILE_NOCWD with full path: expect ftpc->cwddone! */0);
				ftpc.setCount2(/* count2 counts failed CWDs */0/* count3 is set to allow a MKD to fail once. In the case when first CWD
				       fails and then MKD fails (due to another session raced it to create the
				       dir) this then allows for a second try to CWD to it */);
				ftpc.setCount3((conn.getData().getSet().getFtp_create_missing_dirs() == 2) ? 1 : 0);
				if (conn.getBits().getReuse() && ftpc.getEntrypath() && !(ftpc.getDirdepth() && ftpc.getDirs()[0][0] == /* no need to go to entrypath when we have an absolute path */(byte)'/'/* This is a re-used connection. Since we change directory to where the
				         transfer is taking place, we must first get back to the original dir
				         where we ended up after login: */)) {
					ftpc.setCwdcount(/* we count this as the first path, then we add one
					                             for all upcoming ones in the ftp->dirs[] array */0);
					result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "CWD %s", ftpc.getEntrypath());
					if (result) {
						return result;
					} 
					ModernizedCProgram._state(conn, .FTP_CWD);
				} else {
						if (ftpc.getDirdepth()) {
							ftpc.setCwdcount(1/* issue the first CWD, the rest is sent when the CWD responses are
							           received... */);
							result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "CWD %s", ftpc.getDirs()[ftpc.getCwdcount() - 1]);
							if (result) {
								return result;
							} 
							ModernizedCProgram._state(conn, .FTP_CWD);
						} else {
								result = ModernizedCProgram.ftp_state_mdtm(/* No CWD necessary */conn);
						} 
				} 
		} 
		return result;
	}
	public static  ftp_state_use_port(Object conn,  fcmd) {
		CURLcode result = .CURLE_OK;
		ftp_conn ftpc = conn.getProto().getFtpc();
		Curl_easy data = conn.getData();
		curl_socket_t portsock = (SOCKET)(~0);
		byte[] myhost = "";
		Curl_sockaddr_storage ss = new Curl_sockaddr_storage();
		Curl_addrinfo res = new Curl_addrinfo();
		Curl_addrinfo ai = new Curl_addrinfo();
		curl_socklen_t sslen = new curl_socklen_t();
		byte[] hbuf = new byte[1025];
		sockaddr sa = (sockaddr)ss;
		sockaddr_in sa4 = (Object)sa;
		byte[] tmp = new byte[1024];
		byte[][] mode = new byte[][]{"EPRT", "PORT"};
		int rc;
		int error;
		byte host = ((Object)0);
		byte string_ftpport = data.getSet().getStr()[dupstring.STRING_FTPPORT];
		Curl_dns_entry h = ((Object)0);
		int port_min = 0;
		int port_max = 0;
		int port;
		bool possibly_non_local = 1;
		byte[] buffer = new byte[128];
		byte addr = ((Object)0/* Step 1, figure out what is requested,
		   * accepted format :
		   * (ipv4|ipv6|domain|interface)?(:port(-range)?)?
		   */);
		if (data.getSet().getStr()[dupstring.STRING_FTPPORT] && (.strlen(data.getSet().getStr()[dupstring.STRING_FTPPORT]) > 1)) {
			size_t addrlen = 16 > .strlen(string_ftpport) ? 16 : .strlen(string_ftpport);
			byte ip_start = string_ftpport;
			byte ip_end = ((Object)0);
			byte port_start = ((Object)0);
			byte port_sep = ((Object)0);
			addr = .Curl_ccalloc(addrlen + 1, 1);
			if (!addr) {
				return .CURLE_OUT_OF_MEMORY/* [ipv6]:port(-range) */;
			} 
			if (string_ftpport == (byte)':') {
				ip_end = /* :port */string_ftpport;
			} else {
					ip_end = .strchr(string_ftpport, (byte)':');
					if (ip_end/* either ipv6 or (ipv4|domain|interface):port(-range) *//* ipv6 */) {
						.strncpy(addr, string_ftpport, ip_end - /* this got no port ! *//* (ipv4|domain|interface):port(-range) */ip_start);
					} else {
							.strcpy(addr, /* ipv4|interface */string_ftpport);
					} 
			} 
			if (ip_end != ((Object)/* parse the port */0)) {
				port_start = .strchr(ip_end, (byte)':');
				if (port_start) {
					port_min = ModernizedCProgram.curlx_ultous(.strtoul(port_start + 1, ((Object)0), 10));
					port_sep = .strchr(port_start, (byte)'-');
					if (port_sep) {
						port_max = ModernizedCProgram.curlx_ultous(.strtoul(port_sep + 1, ((Object)0), 10));
					} else {
							port_max = port_min/* correct errors like:
							     *  :1234-1230
							     *  :-4711,  in this case port_min is (unsigned)-1,
							     *           therefore port_min > port_max for all cases
							     *           but port_max = (unsigned)-1
							     */;
					} 
				} 
			} 
			if (port_min > port_max) {
				port_min = port_max = 0;
			} 
			if (addr != (byte)'\0') {
				switch (ModernizedCProgram.Curl_if2ip(conn.getIp_addr().getAi_family(), ModernizedCProgram.Curl_ipv6_scope(conn.getIp_addr().getAi_addr()), conn.getScope_id(), addr, hbuf, )) {
				case .IF2IP_AF_NOT_SUPPORTED:
						return .CURLE_FTP_PORT_FAILED;
				case .IF2IP_NOT_FOUND:
						host = /* not an interface, use the given string as host name instead */addr;
						break;
				case .IF2IP_FOUND:
						host = /* use the hbuf for host name */hbuf;
				}
			} else {
					host = ((Object)/* there was only a port(-range) given, default the host */0/* data->set.ftpport */);
			} 
		} 
		if (!host/* not an interface and not a host name, get default by extracting
		       the IP from the control connection */) {
			sslen = ;
			if (.getsockname(conn.getSock()[0], sa, sslen)) {
				ModernizedCProgram.Curl_failf(data, "getsockname() failed: %s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
				.Curl_cfree(addr);
				return .CURLE_FTP_PORT_FAILED;
			} 
			switch (sa.getSa_family()) {
			default:
					ModernizedCProgram.Curl_inet_ntop(sa.getSa_family(), sa4.getSin_addr(), hbuf, );
					break;
			}
			host = /* use this host name */hbuf;
			possibly_non_local = /* we know it is local now */0;
		} 
		rc = ModernizedCProgram.Curl_resolv(conn, host, 0, 0, /* resolv ip/host to ip */h);
		if (rc == 1) {
			(Object)ModernizedCProgram.Curl_resolver_wait_resolv(conn, h);
		} 
		if (h) {
			res = h.getAddr();
			ModernizedCProgram.Curl_resolv_unlock(data, h/* (h) */);
		} else {
				res = ((Object)/* failure! */0);
		} 
		if (res == ((Object)0)) {
			ModernizedCProgram.Curl_failf(data, "failed to resolve the address provided to PORT: %s", host);
			.Curl_cfree(addr);
			return .CURLE_FTP_PORT_FAILED;
		} 
		.Curl_cfree(addr);
		host = ((Object)0);
		portsock = (SOCKET)(~/* step 2, create a socket for the requested address */0);
		error = 0;
		for (ai = res; ai; ai = ai.getAi_next()) {
			result = ModernizedCProgram.Curl_socket(conn, ai, ((Object)0), portsock);
			if (result) {
				error = ((int).WSAGetLastError());
				continue;
			} 
			break;
		}
		if (!ai) {
			ModernizedCProgram.Curl_failf(data, "socket failure: %s", ModernizedCProgram.Curl_strerror(error, buffer, ));
			return .CURLE_FTP_PORT_FAILED;
		} 
		.memcpy(sa, ai.getAi_addr(), ai.getAi_addrlen());
		sslen = ai.getAi_addrlen();
		for (port = port_min; port <= port_max; ) {
			if (sa.getSa_family() == 2) {
				sa4.setSin_port(.htons(port));
			} 
			if (.bind(portsock, sa, /* Try binding the given address. */sslen)) {
				error = ((int).WSAGetLastError());
				if (possibly_non_local && (error == -1024/* The requested bind address is not local.  Use the address used for
				         * the control connection instead and restart the port loop
				         */)) {
					ModernizedCProgram.Curl_infof(data, "bind(port=%hu) on non-local address failed: %s\n", port, ModernizedCProgram.Curl_strerror(error, buffer, ));
					sslen = ;
					if (.getsockname(conn.getSock()[0], sa, sslen)) {
						ModernizedCProgram.Curl_failf(data, "getsockname() failed: %s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
						ModernizedCProgram.Curl_closesocket(conn, portsock);
						return .CURLE_FTP_PORT_FAILED;
					} 
					port = port_min;
					possibly_non_local = /* don't try this again */0;
					continue;
				} 
				if (error != -1024 && error != 13) {
					ModernizedCProgram.Curl_failf(data, "bind(port=%hu) failed: %s", port, ModernizedCProgram.Curl_strerror(error, buffer, ));
					ModernizedCProgram.Curl_closesocket(conn, portsock);
					return .CURLE_FTP_PORT_FAILED;
				} 
			} else {
					break;
			} 
			port++;
		}
		if (port > /* maybe all ports were in use already*/port_max) {
			ModernizedCProgram.Curl_failf(data, "bind() failed, we ran out of ports!");
			ModernizedCProgram.Curl_closesocket(conn, portsock);
			return .CURLE_FTP_PORT_FAILED;
		} 
		sslen = ;
		if (.getsockname(portsock, (sockaddr)sa, sslen)) {
			ModernizedCProgram.Curl_failf(data, "getsockname() failed: %s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
			ModernizedCProgram.Curl_closesocket(conn, portsock);
			return .CURLE_FTP_PORT_FAILED;
		} 
		if (.listen(portsock, /* step 4, listen on the socket */1)) {
			ModernizedCProgram.Curl_failf(data, "socket failure: %s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
			ModernizedCProgram.Curl_closesocket(conn, portsock);
			return .CURLE_FTP_PORT_FAILED/* step 5, send the proper FTP command */;
		} 
		ModernizedCProgram.Curl_printable_address(ai, myhost, );
		for (; fcmd != .DONE; fcmd++) {
			if (!conn.getBits().getFtp_use_eprt() && (.EPRT == fcmd/* if disabled, goto next */)) {
				continue;
			} 
			if ((.PORT == fcmd) && sa.getSa_family() != 2/* PORT is IPv4 only */) {
				continue;
			} 
			switch (sa.getSa_family()) {
			case 2:
					port = .ntohs(sa4.getSin_port());
					break;
			default:
					continue;
			}
			if (.EPRT == fcmd/*
			       * Two fine examples from RFC2428;
			       *
			       * EPRT |1|132.235.1.2|6275|
			       *
			       * EPRT |2|1080::8:800:200C:417A|5282|
			       */) {
				result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "%s |%d|%s|%hu|", mode[fcmd], sa.getSa_family() == 2 ? 1 : 2, myhost, port);
				if (result) {
					ModernizedCProgram.Curl_failf(data, "Failure sending EPRT command: %s", ModernizedCProgram.curl_easy_strerror(result));
					ModernizedCProgram.Curl_closesocket(conn, portsock);
					ftpc.setCount1(/* don't retry using PORT */.PORT);
					ModernizedCProgram._state(conn, /* bail out */.FTP_STOP);
					return result;
				} 
				break;
			} 
			if (.PORT == fcmd) {
				byte source = myhost;
				byte dest = tmp;
				while (source && /* translate x.x.x.x to x,x,x,x */source) {
					if (source == (byte)'.') {
						dest = (byte)',';
					} else {
							dest = source;
					} 
					dest++;
					source++;
				}
				dest = 0;
				ModernizedCProgram.curl_msnprintf(dest, 20, ",%d,%d", (int)(port >> 8), (int)(port & -1024));
				result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "%s %s", mode[fcmd], tmp);
				if (result) {
					ModernizedCProgram.Curl_failf(data, "Failure sending PORT command: %s", ModernizedCProgram.curl_easy_strerror(result));
					ModernizedCProgram.Curl_closesocket(conn, portsock);
					ModernizedCProgram._state(conn, /* bail out */.FTP_STOP);
					return result;
				} 
				break;
			} 
		}
		ftpc.setCount1(/* store which command was sent */fcmd);
		ModernizedCProgram.close_secondarysocket(conn/* we set the secondary socket variable to this for now, it is only so that
		     the cleanup function will close it in case we fail before the true
		     secondary stuff is made */);
		conn.getSock()[1] = portsock/* this tcpconnect assignment below is a hackish work-around to make the
		     multi interface with active FTP work - as it will not wait for a
		     (passive) connect in Curl_is_connected().
		
		     The *proper* fix is to make sure that the active connection from the
		     server is done in a non-blocking way. Currently, it is still BLOCKING.
		  */;
		conn.getBits().getTcpconnect()[1] = 1;
		ModernizedCProgram._state(conn, .FTP_PORT);
		return result;
	}
	/* start with this */
	public static  ftp_state_use_pasv(Object conn) {
		ftp_conn ftpc = conn.getProto().getFtpc();
		CURLcode result = .CURLE_OK/*
		    Here's the excecutive summary on what to do:
		
		    PASV is RFC959, expect:
		    227 Entering Passive Mode (a1,a2,a3,a4,p1,p2)
		
		    LPSV is RFC1639, expect:
		    228 Entering Long Passive Mode (4,4,a1,a2,a3,a4,2,p1,p2)
		
		    EPSV is RFC2428, expect:
		    229 Entering Extended Passive Mode (|||port|)
		
		  */;
		byte[][] mode = new byte[][]{"EPSV", "PASV"};
		int modeoff;
		if (!conn.getBits().getFtp_use_epsv() && conn.getBits().getIpv6()) {
			conn.getBits().setFtp_use_epsv(1);
		} 
		modeoff = conn.getBits().getFtp_use_epsv() ? 0 : 1;
		result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "%s", mode[modeoff]);
		if (result) {
			return result;
		} 
		ftpc.setCount1(modeoff);
		ModernizedCProgram._state(conn, .FTP_PASV);
		ModernizedCProgram.Curl_infof(conn.getData(), "Connect data stream passively\n");
		return result/*
		 * ftp_state_prepare_transfer() starts PORT, PASV or PRET etc.
		 *
		 * REST is the last command in the chain of commands when a "head"-like
		 * request is made. Thus, if an actual transfer is to be made this is where we
		 * take off for real.
		 */;
	}
	public static  ftp_state_prepare_transfer(Object conn) {
		CURLcode result = .CURLE_OK;
		FTP ftp = conn.getData().getReq().getProtop();
		Curl_easy data = conn.getData();
		if (ftp.getTransfer() != .FTPTRANSFER_BODY/* doesn't transfer any data */) {
			ModernizedCProgram._state(conn, /* still possibly do PRE QUOTE jobs */.FTP_RETR_PREQUOTE);
			result = ModernizedCProgram.ftp_state_quote(conn, 1, .FTP_RETR_PREQUOTE);
		}  else if (data.getSet().getFtp_use_port()) {
			result = ModernizedCProgram.ftp_state_use_port(conn, /* We have chosen to use the PORT (or similar) command */.EPRT);
		} else {
				if (data.getSet().getFtp_use_pret()) {
					if (!conn.getProto().getFtpc().getFile()) {
						result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "PRET %s", data.getSet().getStr()[dupstring.STRING_CUSTOMREQUEST] ? data.getSet().getStr()[dupstring.STRING_CUSTOMREQUEST] : (data.getSet().getFtp_list_only() ? "NLST" : "LIST"));
						if (result) {
							return result;
						} 
					}  else if (data.getSet().getUpload()) {
						result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "PRET STOR %s", conn.getProto().getFtpc().getFile());
						if (result) {
							return result;
						} 
					} else {
							result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "PRET RETR %s", conn.getProto().getFtpc().getFile());
							if (result) {
								return result;
							} 
					} 
					ModernizedCProgram._state(conn, .FTP_PRET);
				} else {
						result = ModernizedCProgram.ftp_state_use_pasv(conn);
				} 
		} 
		return result;
	}
	public static  ftp_state_rest(Object conn) {
		CURLcode result = .CURLE_OK;
		FTP ftp = conn.getData().getReq().getProtop();
		ftp_conn ftpc = conn.getProto().getFtpc();
		if ((ftp.getTransfer() != .FTPTRANSFER_BODY) && ftpc.getFile()) {
			result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "REST %d", 0);
			if (result) {
				return /* Determine if server can respond to REST command and therefore
				       whether it supports range */result;
			} 
			ModernizedCProgram._state(conn, .FTP_REST);
		} else {
				result = ModernizedCProgram.ftp_state_prepare_transfer(conn);
		} 
		return result;
	}
	public static  ftp_state_size(Object conn) {
		CURLcode result = .CURLE_OK;
		FTP ftp = conn.getData().getReq().getProtop();
		ftp_conn ftpc = conn.getProto().getFtpc();
		if ((ftp.getTransfer() == .FTPTRANSFER_INFO) && ftpc.getFile()) {
			result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "SIZE %s", ftpc.getFile());
			if (result) {
				return /* we know ftpc->file is a valid pointer to a file name */result;
			} 
			ModernizedCProgram._state(conn, .FTP_SIZE);
		} else {
				result = ModernizedCProgram.ftp_state_rest(conn);
		} 
		return result;
	}
	public static  ftp_state_list(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		FTP ftp = data.getReq().getProtop();
		byte lstArg = ((Object)0);
		byte cmd;
		if ((data.getSet().getFtp_filemethod() == .FTPFILE_NOCWD) && ftp.getPath()) {
			byte slashPos = ((Object)/* url-decode before evaluation: e.g. paths starting/ending with %2f */0);
			byte rawPath = ((Object)0);
			result = ModernizedCProgram.Curl_urldecode(data, ftp.getPath(), 0, rawPath, ((Object)0), 1);
			if (result) {
				return result;
			} 
			slashPos = .strrchr(rawPath, (byte)'/');
			if (slashPos/* chop off the file part if format is dir/file otherwise remove
			         the trailing slash for dir/dir/ except for absolute path / */) {
				size_t n = slashPos - rawPath;
				if (n == 0) {
					++n;
				} 
				lstArg = rawPath;
				lstArg[n] = (byte)'\0';
			} else {
					.Curl_cfree(rawPath);
			} 
		} 
		cmd = ModernizedCProgram.curl_maprintf("%s%s%s", data.getSet().getStr()[dupstring.STRING_CUSTOMREQUEST] ? data.getSet().getStr()[dupstring.STRING_CUSTOMREQUEST] : (data.getSet().getFtp_list_only() ? "NLST" : "LIST"), lstArg ? " " : "", lstArg ? lstArg : "");
		.Curl_cfree(lstArg);
		if (!cmd) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "%s", cmd);
		.Curl_cfree(cmd);
		if (result) {
			return result;
		} 
		ModernizedCProgram._state(conn, .FTP_LIST);
		return result;
	}
	public static  ftp_state_retr_prequote(Object conn) {
		return ModernizedCProgram.ftp_state_quote(conn, 1, /* We've sent the TYPE, now we must send the list of prequote strings */.FTP_RETR_PREQUOTE);
	}
	public static  ftp_state_stor_prequote(Object conn) {
		return ModernizedCProgram.ftp_state_quote(conn, 1, /* We've sent the TYPE, now we must send the list of prequote strings */.FTP_STOR_PREQUOTE);
	}
	public static  ftp_state_type(Object conn) {
		CURLcode result = .CURLE_OK;
		FTP ftp = conn.getData().getReq().getProtop();
		Curl_easy data = conn.getData();
		ftp_conn ftpc = conn.getProto().getFtpc();
		if (data.getSet().getOpt_no_body() && ftpc.getFile() && ModernizedCProgram.ftp_need_type(conn, data.getSet().getPrefer_ascii())) {
			ftp.setTransfer(.FTPTRANSFER_INFO/* this means no actual transfer will be made */);
			result = ModernizedCProgram.ftp_nb_type(conn, data.getSet().getPrefer_ascii(), /* Some servers return different sizes for different modes, and thus we
			       must set the proper type before we check the size */.FTP_TYPE);
			if (result) {
				return result;
			} 
		} else {
				result = ModernizedCProgram.ftp_state_size(conn);
		} 
		return result;
	}
	/* This is called after the CWD commands have been done in the beginning of
	   the DO phase */
	public static  ftp_state_mdtm(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		ftp_conn ftpc = conn.getProto().getFtpc();
		if ((data.getSet().getGet_filetime() || data.getSet().getTimecondition()) && ftpc.getFile()) {
			result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "MDTM %s", ftpc.getFile());
			if (result) {
				return /* we have requested to get the modified-time of the file, this is a white
				       spot as the MDTM is not mentioned in RFC959 */result;
			} 
			ModernizedCProgram._state(conn, .FTP_MDTM);
		} else {
				result = ModernizedCProgram.ftp_state_type(conn);
		} 
		return result;
	}
	/* This is called after the TYPE and possible quote commands have been sent */
	public static  ftp_state_ul_setup(Object conn,  sizechecked) {
		CURLcode result = .CURLE_OK;
		FTP ftp = conn.getData().getReq().getProtop();
		Curl_easy data = conn.getData();
		ftp_conn ftpc = conn.getProto().getFtpc();
		if ((data.getState().getResume_from() && !sizechecked) || ((data.getState().getResume_from() > 0) && sizechecked/* we're about to continue the uploading of a file *//* 1. get already existing file's size. We use the SIZE command for this
		       which may not exist in the server!  The SIZE command is not in
		       RFC959. *//* 2. This used to set REST. But since we can do append, we
		       don't another ftp command. We just skip the source file
		       offset and then we APPEND the rest on the file instead */)) {
			int seekerr = /* 3. pass file-size number of bytes in the source file *//* 4. lower the infilesize counter *//* => transfer as usual */0;
			if (data.getState().getResume_from() < 0) {
				result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "SIZE %s", ftpc.getFile());
				if (result) {
					return /* Got no given size to start from, figure it out */result;
				} 
				ModernizedCProgram._state(conn, .FTP_STOR_SIZE);
				return result;
			} 
			data.getSet().setFtp_append(/* enable append */1);
			if (conn.getSeek_func()) {
				ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
				seekerr = .UNRECOGNIZEDFUNCTIONNAME(conn.getSeek_client(), data.getState().getResume_from(), 0);
				ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
			} 
			if (seekerr != 0) {
				curl_off_t passed = 0;
				if (seekerr != 2) {
					ModernizedCProgram.Curl_failf(data, "Could not seek stream");
					return .CURLE_FTP_COULDNT_USE_REST;
				} 
				do {
					size_t readthisamountnow = (data.getState().getResume_from() - passed > data.getSet().getBuffer_size()) ? (size_t)data.getSet().getBuffer_size() : ModernizedCProgram.curlx_sotouz(data.getState().getResume_from() - passed);
					size_t actuallyread = .UNRECOGNIZEDFUNCTIONNAME(data.getState().getBuffer(), 1, readthisamountnow, data.getState().getIn());
					passed += actuallyread;
					if ((actuallyread == 0) || (actuallyread > readthisamountnow/* this checks for greater-than only to make sure that the
					             CURL_READFUNC_ABORT return code still aborts */)) {
						ModernizedCProgram.Curl_failf(data, "Failed to read data");
						return .CURLE_FTP_COULDNT_USE_REST;
					} 
				} while (passed < data.getState().getResume_from());
			} 
			if (data.getState().getInfilesize() > /* now, decrease the size of the read */0) {
				data.getState().getInfilesize() -= data.getState().getResume_from();
				if (data.getState().getInfilesize() <= 0) {
					ModernizedCProgram.Curl_infof(data, "File already completely uploaded\n");
					ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, -/* no data to transfer */1);
					ftp.setTransfer(/* Set ->transfer so that we won't get any error in
					         * ftp_done() because we didn't transfer anything! */.FTPTRANSFER_NONE);
					ModernizedCProgram._state(conn, .FTP_STOP);
					return .CURLE_OK;
				} 
			} 
		} 
		result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), data.getSet().getFtp_append() ? "APPE %s" : "STOR %s", ftpc.getFile());
		if (result) {
			return /* we've passed, proceed as normal *//* resume_from */result;
		} 
		ModernizedCProgram._state(conn, .FTP_STOR);
		return result;
	}
	public static  ftp_state_quote(Object conn,  init,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		FTP ftp = data.getReq().getProtop();
		ftp_conn ftpc = conn.getProto().getFtpc();
		bool quote = 0;
		curl_slist item = new curl_slist();
		switch (instate) {
		case .FTP_POSTQUOTE:
				item = data.getSet().getPostquote();
				break;
		case .FTP_QUOTE:
		case .FTP_STOR_PREQUOTE:
				item = data.getSet().getPrequote();
				break;
		case .FTP_RETR_PREQUOTE:
		default:
				item = data.getSet().getQuote();
				break;
		}
		if (init) {
			ftpc.setCount1(0);
		} else {
				ftpc.getCount1()++;
		} 
		if (item) {
			int i = 0;
			while ((i < ftpc.getCount1()) && /* Skip count1 items in the linked list */item) {
				item = item.getNext();
				i++;
			}
			if (item) {
				byte cmd = item.getData();
				if (cmd[0] == (byte)'*') {
					cmd++;
					ftpc.setCount2(/* the sent command is allowed to fail */1);
				} else {
						ftpc.setCount2(/* failure means cancel operation */0);
				} 
				result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "%s", cmd);
				if (result) {
					return result;
				} 
				ModernizedCProgram._state(conn, instate);
				quote = 1;
			} 
		} 
		if (!quote) {
			switch (/* No more quote to send, continue to ... */instate) {
			case .FTP_RETR_PREQUOTE:
					if (ftp.getTransfer() != .FTPTRANSFER_BODY) {
						ModernizedCProgram._state(conn, .FTP_STOP);
					} else {
							if (ftpc.getKnown_filesize() != -1) {
								ModernizedCProgram.Curl_pgrsSetDownloadSize(data, ftpc.getKnown_filesize());
								result = ModernizedCProgram.ftp_state_retr(conn, ftpc.getKnown_filesize());
							} else {
									if (data.getSet().getIgnorecl()) {
										result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "RETR %s", ftpc.getFile());
										if (result) {
											return result;
										} 
										ModernizedCProgram._state(conn, .FTP_RETR);
									} else {
											result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "SIZE %s", ftpc.getFile());
											if (result) {
												return result;
											} 
											ModernizedCProgram._state(conn, .FTP_RETR_SIZE);
									} 
							} 
					} 
					break;
			case .FTP_QUOTE:
			case .FTP_STOR_PREQUOTE:
					result = ModernizedCProgram.ftp_state_ul_setup(conn, 0);
					break;
			case .FTP_POSTQUOTE:
					break;
			default:
					result = ModernizedCProgram.ftp_state_cwd(conn);
					break;
			}
		} 
		return result;
	}
	/* called from ftp_state_pasv_resp to switch to PASV in case of EPSV
	   problems */
	public static  ftp_epsv_disable(Object conn) {
		CURLcode result = .CURLE_OK;
		if (conn.getBits().getIpv6() && !(conn.getBits().getTunnel_proxy() || conn.getBits().getSocksproxy())) {
			ModernizedCProgram.Curl_failf(conn.getData(), /* We can't disable EPSV when doing IPv6, so this is instead a fail */"Failed EPSV attempt, exiting\n");
			return .CURLE_WEIRD_SERVER_REPLY;
		} 
		ModernizedCProgram.Curl_infof(conn.getData(), "Failed EPSV attempt. Disabling EPSV\n");
		conn.getBits().setFtp_use_epsv(/* disable it for next transfer */0);
		conn.getData().getState().setErrorbuf(/* allow error message to get
		                                         rewritten */0);
		result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "%s", "PASV");
		if (result) {
			return result;
		} 
		conn.getProto().getFtpc().getCount1()++;
		ModernizedCProgram._state(conn, /* remain in/go to the FTP_PASV state */.FTP_PASV);
		return result;
	}
	public static Object control_address(Object conn) {
		if (conn.getBits().getTunnel_proxy() || conn.getBits().getSocksproxy()) {
			return conn.getHost().getName();
		} 
		return conn.getIp_addr_str();
	}
	/* Returns the control connection IP address.
	     If a proxy tunnel is used, returns the original host name instead, because
	     the effective control connection address is the proxy address,
	     not the ftp host. */
	public static  ftp_state_pasv_resp(Object conn, int ftpcode) {
		ftp_conn ftpc = conn.getProto().getFtpc();
		CURLcode result = new CURLcode();
		Curl_easy data = conn.getData();
		Curl_dns_entry addr = ((Object)0);
		int rc;
		/* the local port connect() should use! */int connectport;
		byte str = data.getState().getBuffer()[/* start on the first letter */4];
		do {
			.Curl_cfree((ftpc.getNewhost()));
			(ftpc.getNewhost()) = ((Object)0);
		} while (/* if we come here again, make sure the former name is cleared */0);
		if ((ftpc.getCount1() == 0) && (ftpcode == 229)) {
			byte ptr = .strchr(str, /* positive EPSV response */(byte)'(');
			if (ptr) {
				int num;
				byte[] separator = new byte[4];
				ptr++;
				if (5 == .sscanf(ptr, "%c%c%c%u%c", separator[0], separator[1], separator[2], num, separator[3])) {
					byte sep1 = separator[0];
					int i;
					for (i = 1; i < 4; /* The four separators should be identical, or else this is an oddly
					           formatted reply and we bail out immediately. */i++) {
						if (separator[i] != sep1) {
							ptr = ((Object)/* set to NULL to signal error */0);
							break;
						} 
					}
					if (num > -1024) {
						ModernizedCProgram.Curl_failf(data, "Illegal port number in EPSV reply");
						return .CURLE_FTP_WEIRD_PASV_REPLY;
					} 
					if (ptr) {
						ftpc.setNewport((int)(num & -1024));
						ftpc.setNewhost(.Curl_cstrdup(ModernizedCProgram.control_address(conn)));
						if (!ftpc.getNewhost()) {
							return .CURLE_OUT_OF_MEMORY;
						} 
					} 
				} else {
						ptr = ((Object)0);
				} 
			} 
			if (!ptr) {
				ModernizedCProgram.Curl_failf(data, "Weirdly formatted EPSV reply");
				return .CURLE_FTP_WEIRD_PASV_REPLY;
			} 
		}  else if ((ftpc.getCount1() == 1) && (ftpcode == 227)) {
			int[] ip = new int[/* positive PASV response */4];
			int[] port = new int[2/*
			     * Scan for a sequence of six comma-separated numbers and use them as
			     * IP+port indicators.
			     *
			     * Found reply-strings include:
			     * "227 Entering Passive Mode (127,0,0,1,4,51)"
			     * "227 Data transfer will passively listen to 127,0,0,1,4,51"
			     * "227 Entering passive mode. 127,0,0,1,4,51"
			     */];
			while (str) {
				if (6 == .sscanf(str, "%u,%u,%u,%u,%u,%u", ip[0], ip[1], ip[2], ip[3], port[0], port[1])) {
					break;
				} 
				str++;
			}
			if (!str || (ip[0] > 255) || (ip[1] > 255) || (ip[2] > 255) || (ip[3] > 255) || (port[0] > 255) || (port[1] > 255)) {
				ModernizedCProgram.Curl_failf(data, "Couldn't interpret the 227-response");
				return .CURLE_FTP_WEIRD_227_FORMAT;
			} 
			if (data.getSet().getFtp_skip_ip()) {
				ModernizedCProgram.Curl_infof(data, "Skip %u.%u.%u.%u for data connection, re-use %s instead\n", ip[0], ip[1], ip[2], ip[3], conn.getHost().getName());
				ftpc.setNewhost(.Curl_cstrdup(ModernizedCProgram.control_address(conn)));
			} else {
					ftpc.setNewhost(ModernizedCProgram.curl_maprintf("%u.%u.%u.%u", ip[0], ip[1], ip[2], ip[3]));
			} 
			if (!ftpc.getNewhost()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			ftpc.setNewport((int)(((port[0] << 8) + port[1]) & -1024));
		}  else if (ftpc.getCount1() == 0) {
			return ModernizedCProgram.ftp_epsv_disable(/* EPSV failed, move on to PASV */conn);
		} else {
				ModernizedCProgram.Curl_failf(data, "Bad PASV/EPSV response: %03d", ftpcode);
				return .CURLE_FTP_WEIRD_PASV_REPLY;
		} 
		if (conn.getBits().getProxy()) {
			byte host_name = conn.getBits().getSocksproxy() ? conn.getSocks_proxy().getHost().getName() : conn.getHttp_proxy().getHost().getName();
			rc = ModernizedCProgram.Curl_resolv(conn, host_name, (int)conn.getPort(), 0, addr);
			if (rc == 1/* BLOCKING, ignores the return code but 'addr' will be NULL in
			         case of failure */) {
				(Object)ModernizedCProgram.Curl_resolver_wait_resolv(conn, addr);
			} 
			connectport = (int)conn.getPort();
			if (!addr) {
				ModernizedCProgram.Curl_failf(data, "Can't resolve proxy host %s:%hu", host_name, connectport);
				return .CURLE_COULDNT_RESOLVE_PROXY;
			} 
		} else {
				rc = ModernizedCProgram.Curl_resolv(conn, ftpc.getNewhost(), ftpc.getNewport(), 0, /* normal, direct, ftp connection */addr);
				if (rc == 1) {
					(Object)ModernizedCProgram.Curl_resolver_wait_resolv(conn, /* BLOCKING */addr);
				} 
				connectport = ftpc.getNewport();
				if (!addr) {
					ModernizedCProgram.Curl_failf(data, "Can't resolve new host %s:%hu", ftpc.getNewhost(), connectport);
					return .CURLE_FTP_CANT_GET_HOST;
				} 
		} 
		conn.getBits().getTcpconnect()[1] = 0;
		result = ModernizedCProgram.Curl_connecthost(conn, addr);
		if (result) {
			ModernizedCProgram.Curl_resolv_unlock(data, /* we're done using this address */addr);
			if (ftpc.getCount1() == 0 && ftpcode == 229) {
				return ModernizedCProgram.ftp_epsv_disable(conn);
			} 
			return result/*
			   * When this is used from the multi interface, this might've returned with
			   * the 'connected' set to FALSE and thus we are now awaiting a non-blocking
			   * connect to connect.
			   */;
		} 
		if (data.getSet().getVerbose()) {
			ModernizedCProgram.ftp_pasv_verbose(conn, addr.getAddr(), ftpc.getNewhost(), /* this just dumps information about this second connection */connectport);
		} 
		ModernizedCProgram.Curl_resolv_unlock(data, /* we're done using this address */addr);
		do {
			.Curl_cfree((conn.getSecondaryhostname()));
			(conn.getSecondaryhostname()) = ((Object)0);
		} while (0);
		conn.setSecondary_port(ftpc.getNewport());
		conn.setSecondaryhostname(.Curl_cstrdup(ftpc.getNewhost()));
		if (!conn.getSecondaryhostname()) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		conn.getBits().setDo_more(1);
		ModernizedCProgram._state(conn, /* this phase is completed */.FTP_STOP);
		return result;
	}
	public static  ftp_state_port_resp(Object conn, int ftpcode) {
		Curl_easy data = conn.getData();
		ftp_conn ftpc = conn.getProto().getFtpc();
		ftpport fcmd = (ftpport)ftpc.getCount1();
		CURLcode result = .CURLE_OK;
		if (ftpcode / 100 != /* The FTP spec tells a positive response should have code 200.
		     Be more permissive here to tolerate deviant servers. */2/* the command failed */) {
			if (.EPRT == fcmd) {
				ModernizedCProgram.Curl_infof(data, "disabling EPRT usage\n");
				conn.getBits().setFtp_use_eprt(0);
			} 
			fcmd++;
			if (fcmd == .DONE) {
				ModernizedCProgram.Curl_failf(data, "Failed to do PORT");
				result = .CURLE_FTP_PORT_FAILED;
			} else {
					result = ModernizedCProgram.ftp_state_use_port(conn, /* try next */fcmd);
			} 
		} else {
				ModernizedCProgram.Curl_infof(data, "Connect data stream actively\n");
				ModernizedCProgram._state(conn, /* end of DO phase */.FTP_STOP);
				result = ModernizedCProgram.ftp_dophase_done(conn, 0);
		} 
		return result;
	}
	public static  ftp_state_mdtm_resp(Object conn, int ftpcode) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		FTP ftp = data.getReq().getProtop();
		ftp_conn ftpc = conn.getProto().getFtpc();
		switch (ftpcode) {
		case 213/* we got a time. Format should be: "YYYYMMDDHHMMSS[.sss]" where the
		         last .sss part is optional and means fractions of a second */:
				{ 
					int year;
					int month;
					int day;
					int hour;
					int minute;
					int second;
					if (6 == .sscanf(data.getState().getBuffer()[4], "%04d%02d%02d%02d%02d%02d", year, month, day, hour, minute, second)) {
						byte[] timebuf = new byte[/* we have a time, reformat it */24];
						time_t secs = .time(((Object)0));
						ModernizedCProgram.curl_msnprintf(timebuf, , "%04d%02d%02d %02d:%02d:%02d GMT", year, month, day, hour, minute, second);
						data.getInfo().setFiletime(ModernizedCProgram.curl_getdate(timebuf, /* now, convert this into a time() value: */secs));
					} 
					if (data.getSet().getOpt_no_body() && ftpc.getFile() && data.getSet().getGet_filetime() && (data.getInfo().getFiletime() >= 0)) {
						byte[] headerbuf = new byte[128];
						time_t filetime = data.getInfo().getFiletime();
						tm buffer = new tm();
						tm tm = buffer;
						result = ModernizedCProgram.Curl_gmtime(filetime, buffer);
						if (result) {
							return result;
						} 
						ModernizedCProgram.curl_msnprintf(headerbuf, , "Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n", ModernizedCProgram.Curl_wkday[tm.getTm_wday() ? tm.getTm_wday() - 1 : 6], tm.getTm_mday(), ModernizedCProgram.Curl_month[tm.getTm_mon()], tm.getTm_year() + 1900, tm.getTm_hour(), tm.getTm_min(), tm.getTm_sec());
						result = ModernizedCProgram.Curl_client_write(conn, ((1 << 0) | (1 << 1)), headerbuf, 0);
						if (result) {
							return result/* end of a ridiculous amount of conditionals */;
						} 
					} 
				}
				break;
		case /* "No such file or directory" */550:
				ModernizedCProgram.Curl_failf(data, "Given file does not exist");
				result = .CURLE_FTP_COULDNT_RETR_FILE;
				break;
		default:
				ModernizedCProgram.Curl_infof(data, "unsupported MDTM reply format\n");
				break;
		}
		if (data.getSet().getTimecondition()) {
			if ((data.getInfo().getFiletime() > 0) && (data.getSet().getTimevalue() > 0)) {
				switch (data.getSet().getTimecondition()) {
				case .CURL_TIMECOND_IFMODSINCE:
				case .CURL_TIMECOND_IFUNMODSINCE:
						if (data.getInfo().getFiletime() > data.getSet().getTimevalue()) {
							ModernizedCProgram.Curl_infof(data, "The requested document is not old enough\n");
							ftp.setTransfer(/* mark to not transfer data */.FTPTRANSFER_NONE);
							data.getInfo().setTimecond(1);
							ModernizedCProgram._state(conn, .FTP_STOP);
							return .CURLE_OK;
						} 
						break;
				default:
						if (data.getInfo().getFiletime() <= data.getSet().getTimevalue()) {
							ModernizedCProgram.Curl_infof(data, "The requested document is not new enough\n");
							ftp.setTransfer(/* mark to not transfer data */.FTPTRANSFER_NONE);
							data.getInfo().setTimecond(1);
							ModernizedCProgram._state(conn, .FTP_STOP);
							return .CURLE_OK;
						} 
						break;
				}
			} else {
					ModernizedCProgram.Curl_infof(data, "Skipping time comparison\n");
			} 
		} 
		if (!result) {
			result = ModernizedCProgram.ftp_state_type(conn);
		} 
		return result;
	}
	public static  ftp_state_type_resp(Object conn, int ftpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		if (ftpcode / 100 != 2/* "sasserftpd" and "(u)r(x)bot ftpd" both responds with 226 after a
		       successful 'TYPE I'. While that is not as RFC959 says, it is still a
		       positive response code and we allow that. */) {
			ModernizedCProgram.Curl_failf(data, "Couldn't set desired mode");
			return .CURLE_FTP_COULDNT_SET_TYPE;
		} 
		if (ftpcode != 200) {
			ModernizedCProgram.Curl_infof(data, "Got a %03d response code instead of the assumed 200\n", ftpcode);
		} 
		if (instate == .FTP_TYPE) {
			result = ModernizedCProgram.ftp_state_size(conn);
		}  else if (instate == .FTP_LIST_TYPE) {
			result = ModernizedCProgram.ftp_state_list(conn);
		}  else if (instate == .FTP_RETR_TYPE) {
			result = ModernizedCProgram.ftp_state_retr_prequote(conn);
		}  else if (instate == .FTP_STOR_TYPE) {
			result = ModernizedCProgram.ftp_state_stor_prequote(conn);
		} 
		return result;
	}
	public static  ftp_state_retr(Object conn, Object filesize) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		FTP ftp = data.getReq().getProtop();
		ftp_conn ftpc = conn.getProto().getFtpc();
		if (data.getSet().getMax_filesize() && (filesize > data.getSet().getMax_filesize())) {
			ModernizedCProgram.Curl_failf(data, "Maximum file size exceeded");
			return .CURLE_FILESIZE_EXCEEDED;
		} 
		ftp.setDownloadsize(filesize);
		if (data.getState().getResume_from()) {
			if (filesize == -1) {
				ModernizedCProgram.Curl_infof(data, "ftp server doesn't support SIZE\n"/* We couldn't get the size and therefore we can't know if there really
				         is a part of the file left to get, although the server will just
				         close the connection when we start the connection so it won't cause
				         us any harm, just not make us exit as nicely. */);
			} else {
					if (data.getState().getResume_from() < /* We got a file size report, so we check that there actually is a
					         part of the file left to get, or else we go home.  */0) {
						if (filesize < -data.getState().getResume_from()) {
							ModernizedCProgram.Curl_failf(data, "Offset (%I64d) was beyond file size (%I64d)", data.getState().getResume_from(), filesize);
							return .CURLE_BAD_DOWNLOAD_RESUME;
						} 
						ftp.setDownloadsize(-data.getState().getResume_from());
						data.getState().setResume_from(filesize - ftp.getDownloadsize());
					} else {
							if (filesize < data.getState().getResume_from()) {
								ModernizedCProgram.Curl_failf(data, "Offset (%I64d) was beyond file size (%I64d)", data.getState().getResume_from(), filesize);
								return .CURLE_BAD_DOWNLOAD_RESUME;
							} 
							ftp.setDownloadsize(filesize - data.getState().getResume_from());
					} 
			} 
			if (ftp.getDownloadsize() == 0) {
				ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, -/* no data to transfer */1);
				ModernizedCProgram.Curl_infof(data, "File already completely downloaded\n");
				ftp.setTransfer(/* Set ->transfer so that we won't get any error in ftp_done()
				       * because we didn't transfer the any file */.FTPTRANSFER_NONE);
				ModernizedCProgram._state(conn, .FTP_STOP);
				return .CURLE_OK;
			} 
			ModernizedCProgram.Curl_infof(data, /* Set resume file transfer offset */"Instructs server to resume from offset %I64d\n", data.getState().getResume_from());
			result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "REST %I64d", data.getState().getResume_from());
			if (result) {
				return result;
			} 
			ModernizedCProgram._state(conn, .FTP_RETR_REST);
		} else {
				result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "RETR %s", ftpc.getFile());
				if (result) {
					return /* no resume */result;
				} 
				ModernizedCProgram._state(conn, .FTP_RETR);
		} 
		return result;
	}
	public static  ftp_state_size_resp(Object conn, int ftpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		curl_off_t filesize = -1;
		byte buf = data.getState().getBuffer();
		if (ftpcode == /* get the size from the ascii string: */213/* To allow servers to prepend "rubbish" in the response string, we scan
		       for all the digits at the end of the response and parse only those as a
		       number. */) {
			byte start = buf[4];
			byte fdigit = .strchr(start, (byte)'\r');
			if (fdigit) {
				do {
					fdigit--;
				} while ((ModernizedCProgram.Curl_isdigit((int)((byte)fdigit))) && (fdigit > start));
				if (!(ModernizedCProgram.Curl_isdigit((int)((byte)fdigit)))) {
					fdigit++;
				} 
			} else {
					fdigit = start;
			} 
			(Object)ModernizedCProgram.curlx_strtoofft(fdigit, ((Object)0), 0, /* ignores parsing errors, which will make the size remain unknown */filesize);
		} 
		if (instate == .FTP_SIZE) {
			if (-1 != filesize) {
				byte[] clbuf = new byte[128];
				ModernizedCProgram.curl_msnprintf(clbuf, , "Content-Length: %I64d\r\n", filesize);
				result = ModernizedCProgram.Curl_client_write(conn, ((1 << 0) | (1 << 1)), clbuf, 0);
				if (result) {
					return result;
				} 
			} 
			ModernizedCProgram.Curl_pgrsSetDownloadSize(data, filesize);
			result = ModernizedCProgram.ftp_state_rest(conn);
		}  else if (instate == .FTP_RETR_SIZE) {
			ModernizedCProgram.Curl_pgrsSetDownloadSize(data, filesize);
			result = ModernizedCProgram.ftp_state_retr(conn, filesize);
		}  else if (instate == .FTP_STOR_SIZE) {
			data.getState().setResume_from(filesize);
			result = ModernizedCProgram.ftp_state_ul_setup(conn, 1);
		} 
		return result;
	}
	public static  ftp_state_rest_resp(Object conn, int ftpcode,  instate) {
		CURLcode result = .CURLE_OK;
		ftp_conn ftpc = conn.getProto().getFtpc();
		switch (instate) {
		case .FTP_REST:
		case .FTP_RETR_REST:
				if (ftpcode != 350) {
					ModernizedCProgram.Curl_failf(conn.getData(), "Couldn't use REST");
					result = .CURLE_FTP_COULDNT_USE_REST;
				} else {
						result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "RETR %s", ftpc.getFile());
						if (result) {
							return result;
						} 
						ModernizedCProgram._state(conn, .FTP_RETR);
				} 
				break;
		default:
				if (ftpcode == 350) {
					byte[] buffer = new byte[]{"Accept-ranges: bytes\r\n"};
					result = ModernizedCProgram.Curl_client_write(conn, ((1 << 0) | (1 << 1)), buffer, 0);
					if (result) {
						return result;
					} 
				} 
				result = ModernizedCProgram.ftp_state_prepare_transfer(conn);
				break;
		}
		return result;
	}
	public static  ftp_state_stor_resp(Object conn, int ftpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		if (ftpcode >= 400) {
			ModernizedCProgram.Curl_failf(data, "Failed FTP upload: %0d", ftpcode);
			ModernizedCProgram._state(conn, .FTP_STOP);
			return /* oops, we never close the sockets! */.CURLE_UPLOAD_FAILED;
		} 
		conn.getProto().getFtpc().setState_saved(instate);
		if (data.getSet().getFtp_use_port()) {
			bool connected = new bool();
			ModernizedCProgram._state(conn, /* no longer in STOR state */.FTP_STOP);
			result = ModernizedCProgram.AllowServerConnect(conn, connected);
			if (result) {
				return result;
			} 
			if (!connected) {
				ftp_conn ftpc = conn.getProto().getFtpc();
				ModernizedCProgram.Curl_infof(data, "Data conn was not available immediately\n");
				ftpc.setWait_data_conn(1);
			} 
			return .CURLE_OK;
		} 
		return ModernizedCProgram.InitiateTransfer(conn);
	}
	/* for LIST and RETR responses */
	public static  ftp_state_get_resp(Object conn, int ftpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		FTP ftp = data.getReq().getProtop();
		if ((ftpcode == 150) || (ftpcode == 125/*
		      A;
		      150 Opening BINARY mode data connection for /etc/passwd (2241
		      bytes).  (ok, the file is being transferred)
		
		      B:
		      150 Opening ASCII mode data connection for /bin/ls
		
		      C:
		      150 ASCII data connection for /bin/ls (137.167.104.91,37445) (0 bytes).
		
		      D:
		      150 Opening ASCII mode data connection for [file] (0.0.0.0,0) (545 bytes)
		
		      E:
		      125 Data connection already open; Transfer starting. */)) {
			curl_off_t size = -/* default unknown size */1/*
			     * It appears that there are FTP-servers that return size 0 for files when
			     * SIZE is used on the file while being in BINARY mode. To work around
			     * that (stupid) behavior, we attempt to parse the RETR response even if
			     * the SIZE returned size zero.
			     *
			     * Debugging help from Salvatore Sorrentino on February 26, 2003.
			     */;
			if ((instate != .FTP_LIST) && !data.getSet().getPrefer_ascii() && (ftp.getDownloadsize() < 1/*
			       * It seems directory listings either don't show the size or very
			       * often uses size 0 anyway. ASCII transfers may very well turn out
			       * that the transferred amount of data is not the same as this line
			       * tells, why using this number in those cases only confuses us.
			       *
			       * Example D above makes this parsing a little tricky */)) {
				byte bytes;
				byte buf = data.getState().getBuffer();
				bytes = .strstr(buf, " bytes");
				if (bytes) {
					long in = (long)(--bytes - buf);
					while (--/* this is a hint there is size information in there! ;-) */in) {
						if ((byte)'(' == /* scan for the left parenthesis and break there */bytes) {
							break;
						} 
						if (!(ModernizedCProgram.Curl_isdigit((int)((byte)/* skip only digits */bytes)))) {
							bytes = ((Object)0);
							break;
						} 
						/* one more estep backwards */bytes--;
					}
					if (/* if we have nothing but digits: */bytes++) {
						(Object)ModernizedCProgram.curlx_strtoofft(bytes, ((Object)0), 0, /* get the number! */size);
					} 
				} 
			}  else if (ftp.getDownloadsize() > -1) {
				size = ftp.getDownloadsize();
			} 
			if (size > data.getReq().getMaxdownload() && data.getReq().getMaxdownload() > 0) {
				size = data.getReq().setSize(data.getReq().getMaxdownload());
			}  else if ((instate != .FTP_LIST) && (data.getSet().getPrefer_ascii())) {
				size = -/* kludge for servers that understate ASCII mode file size */1;
			} 
			ModernizedCProgram.Curl_infof(data, "Maxdownload = %I64d\n", data.getReq().getMaxdownload());
			if (instate != .FTP_LIST) {
				ModernizedCProgram.Curl_infof(data, "Getting file with size: %I64d\n", size);
			} 
			conn.getProto().getFtpc().setState_saved(/* FTP download: */instate);
			conn.getProto().getFtpc().setRetr_size_saved(size);
			if (data.getSet().getFtp_use_port()) {
				bool connected = new bool();
				result = ModernizedCProgram.AllowServerConnect(conn, connected);
				if (result) {
					return result;
				} 
				if (!connected) {
					ftp_conn ftpc = conn.getProto().getFtpc();
					ModernizedCProgram.Curl_infof(data, "Data conn was not available immediately\n");
					ModernizedCProgram._state(conn, .FTP_STOP);
					ftpc.setWait_data_conn(1);
				} 
			} else {
					return ModernizedCProgram.InitiateTransfer(conn);
			} 
		} else {
				if ((instate == .FTP_LIST) && (ftpcode == 450)) {
					ftp.setTransfer(/* simply no matching files in the dir listing *//* don't download anything */.FTPTRANSFER_NONE);
					ModernizedCProgram._state(conn, /* this phase is over */.FTP_STOP);
				} else {
						ModernizedCProgram.Curl_failf(data, "RETR response: %03d", ftpcode);
						return instate == .FTP_RETR && ftpcode == 550 ? .CURLE_REMOTE_FILE_NOT_FOUND : .CURLE_FTP_COULDNT_RETR_FILE;
				} 
		} 
		return result;
	}
	/* after USER, PASS and ACCT */
	public static  ftp_state_loggedin(Object conn) {
		CURLcode result = .CURLE_OK;
		if (conn.getSsl()[0].getUse()) {
			result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "PBSZ %d", 0);
			if (result) {
				return result;
			} 
			ModernizedCProgram._state(conn, .FTP_PBSZ);
		} else {
				result = ModernizedCProgram.ftp_state_pwd(conn);
		} 
		return result;
	}
	/* for USER and PASS responses */
	public static  ftp_state_user_resp(Object conn, int ftpcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		FTP ftp = data.getReq().getProtop();
		ftp_conn ftpc = conn.getProto().getFtpc();
		(Object)/* no use for this yet */instate;
		if ((ftpcode == 331) && (ftpc.getState() == /* some need password anyway, and others just return 2xx ignored */.FTP_USER/* 331 Password required for ...
		       (the server requires to send the user's password too) */)) {
			result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "PASS %s", ftp.getPasswd() ? ftp.getPasswd() : "");
			if (result) {
				return result;
			} 
			ModernizedCProgram._state(conn, .FTP_PASS);
		}  else if (ftpcode / 100 == 2/* 230 User ... logged in.
		       (the user logged in with or without password) */) {
			result = ModernizedCProgram.ftp_state_loggedin(conn);
		}  else if (ftpcode == 332) {
			if (data.getSet().getStr()[dupstring.STRING_FTP_ACCOUNT]) {
				result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "ACCT %s", data.getSet().getStr()[dupstring.STRING_FTP_ACCOUNT]);
				if (result) {
					return result;
				} 
				ModernizedCProgram._state(conn, .FTP_ACCT);
			} else {
					ModernizedCProgram.Curl_failf(data, "ACCT requested but none available");
					result = .CURLE_LOGIN_DENIED/* All other response codes, like:
					
					    530 User ... access denied
					    (the server denies to log the specified user) */;
			} 
		} else {
				if (conn.getData().getSet().getStr()[dupstring.STRING_FTP_ALTERNATIVE_TO_USER] && !conn.getData().getState().getFtp_trying_alternative()) {
					result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "%s", conn.getData().getSet().getStr()[dupstring.STRING_FTP_ALTERNATIVE_TO_USER]);
					if (result) {
						return /* Ok, USER failed.  Let's try the supplied command. */result;
					} 
					conn.getData().getState().setFtp_trying_alternative(1);
					ModernizedCProgram._state(conn, .FTP_USER);
					result = .CURLE_OK;
				} else {
						ModernizedCProgram.Curl_failf(data, "Access denied: %03d", ftpcode);
						result = .CURLE_LOGIN_DENIED;
				} 
		} 
		return result;
	}
	/* for ACCT response */
	public static  ftp_state_acct_resp(Object conn, int ftpcode) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		if (ftpcode != 230) {
			ModernizedCProgram.Curl_failf(data, "ACCT rejected by server: %03d", ftpcode);
			result = /* FIX */.CURLE_FTP_WEIRD_PASS_REPLY;
		} else {
				result = ModernizedCProgram.ftp_state_loggedin(conn);
		} 
		return result;
	}
	public static  ftp_statemach_act(Object conn) {
		CURLcode result = new CURLcode();
		curl_socket_t sock = conn.getSock()[0];
		Curl_easy data = conn.getData();
		int ftpcode;
		ftp_conn ftpc = conn.getProto().getFtpc();
		pingpong pp = ftpc.getPp();
		byte[][] ftpauth = new byte[][]{"SSL", "TLS"};
		size_t nread = 0;
		if (pp.getSendleft()) {
			return ModernizedCProgram.Curl_pp_flushsend(pp);
		} 
		result = ModernizedCProgram.ftp_readresp(sock, pp, ftpcode, nread);
		if (result) {
			return result;
		} 
		if (ftpcode) {
			switch (ftpc.getState()) {
			case .FTP_USER:
			case .FTP_SIZE:
			case .FTP_SYST:
					if (ftpcode == 215) {
						byte ptr = data.getState().getBuffer()[/* start on the first letter */4];
						byte os;
						byte store;
						os = .Curl_cmalloc(nread + 1);
						if (!os) {
							return .CURLE_OUT_OF_MEMORY/* Reply format is like
							           215<space><OS-name><space><commentary>
							        */;
						} 
						while (ptr == (byte)' ') {
							ptr++;
						}
						for (store = os; ptr && ptr != (byte)' '; ) {
							store++ = ptr++;
						}
						store = /* zero terminate */(byte)'\0';
						if (ModernizedCProgram.Curl_strcasecompare(os, /* Check for special servers here. */"OS/400")) {
							result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "%s", /* Force OS400 name format 1. */"SITE NAMEFMT 1");
							if (result) {
								.Curl_cfree(os);
								return result;
							} 
							do {
								.Curl_cfree((ftpc.getServer_os()));
								(ftpc.getServer_os()) = ((Object)0);
							} while (/* remember target server OS */0);
							ftpc.setServer_os(os);
							ModernizedCProgram._state(conn, .FTP_NAMEFMT);
							break;
						} 
						do {
							.Curl_cfree((ftpc.getServer_os()));
							(ftpc.getServer_os()) = ((Object)0);
						} while (/* Nothing special for the target server. *//* remember target server OS */0);
						ftpc.setServer_os(os);
					} 
					ModernizedCProgram._state(conn, /* Cannot identify server OS. Continue anyway and cross fingers. *//* we are done with the CONNECT phase! */.FTP_STOP);
					do {
					} while (0);
					break;
			case .FTP_STOR_SIZE:
					result = ModernizedCProgram.ftp_state_size_resp(conn, ftpcode, ftpc.getState());
					break;
			case .FTP_MDTM:
					result = ModernizedCProgram.ftp_state_mdtm_resp(conn, ftpcode);
					break;
			case .FTP_ACCT:
					result = ModernizedCProgram.ftp_state_acct_resp(conn, ftpcode);
					break;
			case .FTP_RETR_REST:
					result = ModernizedCProgram.ftp_state_rest_resp(conn, ftpcode, ftpc.getState());
					break;
			case .FTP_PROT:
					if (ftpcode / 100 == 2) {
						conn.getBits().setFtp_use_data_ssl((data.getSet().getUse_ssl() != .CURLUSESSL_CONTROL) ? 1 : 0/* FTP servers typically responds with 500 if they decide to reject
						         our 'P' request */);
					}  else if (data.getSet().getUse_ssl() > .CURLUSESSL_CONTROL) {
						return /* we failed and bails out */.CURLE_USE_SSL_FAILED;
					} 
					if (data.getSet().getFtp_ccc()) {
						result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "%s", "CCC");
						if (result) {
							return result;
						} 
						ModernizedCProgram._state(conn, .FTP_CCC);
					} else {
							result = ModernizedCProgram.ftp_state_pwd(conn);
							if (result) {
								return result;
							} 
					} 
					break;
			case .FTP_WAIT220:
					if (ftpcode == 230) {
						return ModernizedCProgram.ftp_state_user_resp(conn, ftpcode, ftpc.getState());
					}  else if (ftpcode != 220) {
						ModernizedCProgram.Curl_failf(data, "Got a %03d ftp-server response when 220 was expected", ftpcode);
						return .CURLE_WEIRD_SERVER_REPLY/* We have received a 220 response fine, now we proceed. *//* If not anonymous login, try a secure login. Note that this
						           procedure is still BLOCKING. *//* We set private first as default, in case the line below fails to
						           set a valid level */;
					} 
					if (data.getSet().getUse_ssl() && (!conn.getSsl()[0].getUse() || (conn.getBits().getProxy_ssl_connected()[0] && !conn.getProxy_ssl()[0].getUse()))) {
						ftpc.setCount3(0);
						switch (data.getSet().getFtpsslauth()) {
						case .CURLFTPAUTH_TLS:
								ftpc.setCount2(-/* subtract one to get next */1);
								ftpc.setCount1(1);
								break;
						case .CURLFTPAUTH_DEFAULT:
						case .CURLFTPAUTH_SSL:
								ftpc.setCount2(/* add one to get next */1);
								ftpc.setCount1(0);
								break;
						default:
								ModernizedCProgram.Curl_failf(data, "unsupported parameter to CURLOPT_FTPSSLAUTH: %d", (int)data.getSet().getFtpsslauth());
								return /* we don't know what to do */.CURLE_UNKNOWN_OPTION;
						}
						result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "AUTH %s", ftpauth[ftpc.getCount1()]);
						if (result) {
							return result;
						} 
						ModernizedCProgram._state(conn, .FTP_AUTH);
					} else {
							result = ModernizedCProgram.ftp_state_user(conn);
							if (result) {
								return result;
							} 
					} 
					break;
			case .FTP_PASV:
					result = ModernizedCProgram.ftp_state_pasv_resp(conn, ftpcode);
					break;
			case .FTP_NAMEFMT:
					if (ftpcode == 250) {
						ModernizedCProgram.ftp_state_pwd(/* Name format change successful: reload initial path. */conn);
						break;
					} 
					ModernizedCProgram._state(conn, /* we are done with the CONNECT phase! */.FTP_STOP);
					do {
					} while (0);
					break;
			case .FTP_PRET:
					if (ftpcode != 200) {
						ModernizedCProgram.Curl_failf(data, "PRET command not accepted: %03d", /* there only is this one standard OK return code. */ftpcode);
						return .CURLE_FTP_PRET_FAILED;
					} 
					result = ModernizedCProgram.ftp_state_use_pasv(conn);
					break;
			case .FTP_POSTQUOTE:
			case .FTP_LIST_TYPE:
			case .FTP_CCC:
					if (ftpcode < 500) {
						result = /* First shut down the SSL layer (note: this call will block) */.CURLE_NOT_BUILT_IN;
						if (result) {
							ModernizedCProgram.Curl_failf(conn.getData(), "Failed to clear the command channel (CCC)");
							return result;
						} 
					} 
					result = ModernizedCProgram.ftp_state_pwd(/* Then continue as normal */conn);
					if (result) {
						return result;
					} 
					break;
			case .FTP_AUTH/* we have gotten the response to a previous AUTH command *//* RFC2228 (page 5) says:
			       *
			       * If the server is willing to accept the named security mechanism,
			       * and does not require any security data, it must respond with
			       * reply code 234/334.
			       */:
					if ((ftpcode == 234) || (ftpcode == 334)) {
						result = /* Curl_ssl_connect is BLOCKING */.CURLE_NOT_BUILT_IN;
						if (!result) {
							conn.getBits().setFtp_use_data_ssl(/* clear-text data */0);
							result = ModernizedCProgram.ftp_state_user(conn);
						} 
					}  else if (ftpc.getCount3() < 1) {
						ftpc.getCount3()++;
						ftpc.getCount1() += ftpc.getCount2();
						result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "AUTH %s", ftpauth[ftpc.getCount1()]);
					} else {
							if (data.getSet().getUse_ssl() > .CURLUSESSL_TRY) {
								result = /* we failed and CURLUSESSL_CONTROL or CURLUSESSL_ALL is set */.CURLE_USE_SSL_FAILED;
							} else {
									result = ModernizedCProgram.ftp_state_user(/* ignore the failure and continue */conn);
							} 
					} 
					if (result) {
						return result;
					} 
					break;
			case .FTP_RETR_PREQUOTE:
			case .FTP_QUIT/* fallthrough, just stop! */:
			case .FTP_STOR_PREQUOTE:
					if ((ftpcode >= 400) && !ftpc.getCount2()) {
						ModernizedCProgram.Curl_failf(conn.getData(), "QUOT command failed with %03d", /* failure response code, and not allowed to fail */ftpcode);
						return .CURLE_QUOTE_ERROR;
					} 
					result = ModernizedCProgram.ftp_state_quote(conn, 0, ftpc.getState());
					if (result) {
						return result;
					} 
					break;
			case .FTP_STOR_TYPE:
					result = ModernizedCProgram.ftp_state_type_resp(conn, ftpcode, ftpc.getState());
					break;
			case .FTP_RETR:
					result = ModernizedCProgram.ftp_state_get_resp(conn, ftpcode, ftpc.getState());
					break;
			case .FTP_RETR_SIZE:
			case .FTP_CWD:
					if (ftpcode / 100 != 2) {
						if (conn.getData().getSet().getFtp_create_missing_dirs() && ftpc.getCwdcount() && !ftpc.getCount2()) {
							ftpc.getCount2()++;
							result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "MKD %s", ftpc.getDirs()[ftpc.getCwdcount() - 1]);
							if (result) {
								return result;
							} 
							ModernizedCProgram._state(conn, .FTP_MKD);
						} else {
								ModernizedCProgram.Curl_failf(data, /* return failure */"Server denied you to change to the given directory");
								ftpc.setCwdfail(/* don't remember this path as we failed
								                                   to enter it */1);
								return .CURLE_REMOTE_ACCESS_DENIED;
						} 
					} else {
							ftpc.setCount2(/* success */0);
							if (++ftpc.getCwdcount() <= ftpc.getDirdepth()) {
								result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "CWD %s", ftpc.getDirs()[ftpc.getCwdcount() - 1]);
								if (result) {
									return /* send next CWD */result;
								} 
							} else {
									result = ModernizedCProgram.ftp_state_mdtm(conn);
									if (result) {
										return result;
									} 
							} 
					} 
					break;
			case .FTP_LIST:
			case .FTP_QUOTE:
			case .FTP_MKD:
					if ((ftpcode / 100 != 2) && !ftpc.getCount3()--) {
						ModernizedCProgram.Curl_failf(data, "Failed to MKD dir: %03d", /* failure to MKD the dir */ftpcode);
						return .CURLE_REMOTE_ACCESS_DENIED;
					} 
					ModernizedCProgram._state(conn, .FTP_CWD);
					result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "CWD %s", ftpc.getDirs()[ftpc.getCwdcount() - 1]);
					if (result) {
						return /* send CWD */result;
					} 
					break;
			case .FTP_PWD:
					if (ftpcode == 257) {
						byte ptr = data.getState().getBuffer()[/* start on the first letter */4];
						size_t buf_size = data.getSet().getBuffer_size();
						byte dir;
						bool entry_extracted = 0;
						dir = .Curl_cmalloc(nread + 1);
						if (!dir) {
							return .CURLE_OUT_OF_MEMORY/* Reply format is like
							           257<space>[rubbish]"<directory-name>"<space><commentary> and the
							           RFC959 says
							
							           The directory name can contain any character; embedded
							           double-quotes should be escaped by double-quotes (the
							           "quote-doubling" convention).
							        */;
						} 
						while (ptr < data.getState().getBuffer()[/* scan for the first double-quote for non-standard responses */buf_size] && ptr != (byte)'\n' && ptr != (byte)'\0' && ptr != (byte)'"') {
							ptr++;
						}
						if ((byte)'\"' == ptr/* it started good */) {
							byte store;
							ptr++;
							for (store = dir; ptr; ) {
								if ((byte)'\"' == ptr) {
									if ((byte)'\"' == ptr[1]) {
										store = ptr[/* "quote-doubling" */1];
										ptr++;
									} else {
											entry_extracted = /* end of path */1;
											break;
									} 
								} else {
										store = ptr;
								} 
								store++;
								ptr++;
							}
							store = /* zero terminate */(byte)'\0';
						} 
						if (entry_extracted/* If the path name does not look like an absolute path (i.e.: it
						             does not start with a '/'), we probably need some server-dependent
						             adjustments. For example, this is the case when connecting to
						             an OS400 FTP server: this server supports two name syntaxes,
						             the default one being incompatible with standard paths. In
						             addition, this server switches automatically to the regular path
						             syntax when one is encountered in a command: this results in
						             having an entrypath in the wrong syntax when later used in CWD.
						               The method used here is to check the server OS: we do it only
						             if the path name looks strange to minimize overhead on other
						             systems. */) {
							if (!ftpc.getServer_os() && dir[0] != (byte)'/') {
								result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "%s", "SYST");
								if (result) {
									.Curl_cfree(dir);
									return result;
								} 
								do {
									.Curl_cfree((ftpc.getEntrypath()));
									(ftpc.getEntrypath()) = ((Object)0);
								} while (0);
								ftpc.setEntrypath(/* remember this */dir);
								ModernizedCProgram.Curl_infof(data, "Entry path is '%s'\n", ftpc.getEntrypath());
								data.getState().setMost_recent_ftp_entrypath(ftpc.getEntrypath());
								ModernizedCProgram._state(conn, .FTP_SYST);
								break;
							} 
							do {
								.Curl_cfree((ftpc.getEntrypath()));
								(ftpc.getEntrypath()) = ((Object)0);
							} while (0);
							ftpc.setEntrypath(/* remember this */dir);
							ModernizedCProgram.Curl_infof(data, "Entry path is '%s'\n", ftpc.getEntrypath());
							data.getState().setMost_recent_ftp_entrypath(ftpc.getEntrypath());
						} else {
								.Curl_cfree(/* couldn't get the path */dir);
								ModernizedCProgram.Curl_infof(data, "Failed to figure out path\n");
						} 
					} 
					ModernizedCProgram._state(conn, /* we are done with the CONNECT phase! */.FTP_STOP);
					do {
					} while (0);
					break;
			case .FTP_PBSZ:
					result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "PROT %c", data.getSet().getUse_ssl() == .CURLUSESSL_CONTROL ? (byte)'C' : (byte)'P');
					if (result) {
						return result;
					} 
					ModernizedCProgram._state(conn, .FTP_PROT);
					break;
			case .FTP_TYPE:
			case .FTP_PORT:
					result = ModernizedCProgram.ftp_state_port_resp(conn, ftpcode);
					break;
			case .FTP_STOR:
					result = ModernizedCProgram.ftp_state_stor_resp(conn, ftpcode, ftpc.getState());
					break;
			case .FTP_REST:
			case .FTP_PASS:
					result = ModernizedCProgram.ftp_state_user_resp(conn, ftpcode, ftpc.getState());
					break;
			case .FTP_RETR_TYPE:
			default:
					ModernizedCProgram._state(conn, /* internal error */.FTP_STOP);
					break;
			}
		} 
		return /* if(ftpcode) */result;
	}
	/* called repeatedly until done from multi.c */
	public static  ftp_multi_statemach(Object conn, Object done) {
		ftp_conn ftpc = conn.getProto().getFtpc();
		CURLcode result = ModernizedCProgram.Curl_pp_statemach(ftpc.getPp(), 0, 0/* Check for the state outside of the Curl_socket_check() return code checks
		     since at times we are in fact already in this state when this function
		     gets called. */);
		done = (ftpc.getState() == .FTP_STOP) ? 1 : 0;
		return result;
	}
	public static  ftp_block_statemach(Object conn) {
		ftp_conn ftpc = conn.getProto().getFtpc();
		pingpong pp = ftpc.getPp();
		CURLcode result = .CURLE_OK;
		while (ftpc.getState() != .FTP_STOP) {
			result = ModernizedCProgram.Curl_pp_statemach(pp, 1, /* disconnecting */1);
			if (result) {
				break;
			} 
		}
		return result/*
		 * ftp_connect() should do everything that is to be considered a part of
		 * the connection phase.
		 *
		 * The variable 'done' points to will be TRUE if the protocol-layer connect
		 * phase is done when this function returns, or FALSE if not.
		 *
		 */;
	}
	public static  ftp_connect(Object conn, Object done) {
		CURLcode result = new CURLcode();
		ftp_conn ftpc = conn.getProto().getFtpc();
		pingpong pp = ftpc.getPp();
		done = /* default to not done yet */0;
		ModernizedCProgram.Curl_conncontrol(conn, /* We always support persistent connections on ftp */0);
		pp.setResponse_time((120 * /* set default response time-out */1000));
		pp.setStatemach_act(ftp_statemach_act);
		pp.setEndofresp(ftp_endofresp);
		pp.setConn(conn);
		if (conn.getHandler().getFlags() & (1 << 0)) {
			result = /* BLOCKING */.CURLE_NOT_BUILT_IN;
			if (result) {
				return result;
			} 
		} 
		ModernizedCProgram.Curl_pp_init(/* init the generic pingpong data */pp);
		ModernizedCProgram._state(conn, /* When we connect, we start in the state where we await the 220
		     response */.FTP_WAIT220);
		result = ModernizedCProgram.ftp_multi_statemach(conn, done);
		return result/***********************************************************************
		 *
		 * ftp_done()
		 *
		 * The DONE function. This does what needs to be done after a single DO has
		 * performed.
		 *
		 * Input argument is already checked for validity.
		 */;
	}
	/* see description above */
	public static  ftp_done(Object conn,  status,  premature) {
		Curl_easy data = conn.getData();
		FTP ftp = data.getReq().getProtop();
		ftp_conn ftpc = conn.getProto().getFtpc();
		pingpong pp = ftpc.getPp();
		ssize_t nread = new ssize_t();
		int ftpcode;
		CURLcode result = .CURLE_OK;
		byte rawPath = ((Object)0);
		size_t pathLen = 0;
		if (!ftp) {
			return .CURLE_OK;
		} 
		switch (status) {
		case .CURLE_FTP_COULDNT_RETR_FILE:
		case .CURLE_FTP_PORT_FAILED:
		case .CURLE_REMOTE_FILE_NOT_FOUND:
		case .CURLE_FTP_ACCEPT_FAILED:
		case .CURLE_UPLOAD_FAILED:
		case .CURLE_FTP_COULDNT_SET_TYPE:
		case .CURLE_WRITE_ERROR/* the connection stays alive fine even though this happened */:
		case .CURLE_FILESIZE_EXCEEDED:
		case .CURLE_FTP_ACCEPT_TIMEOUT:
		case /* fall-through *//* doesn't affect the control connection's status */.CURLE_OK:
				if (!premature) {
					break;
				} 
		case .CURLE_REMOTE_ACCESS_DENIED:
		case .CURLE_BAD_DOWNLOAD_RESUME:
		case .CURLE_FTP_WEIRD_PASV_REPLY:
		case .CURLE_PARTIAL_FILE:
		default:
				ftpc.setCtl_valid(0);
				ftpc.setCwdfail(/* set this TRUE to prevent us to remember the
				                             current path, as this connection is going */1);
				ModernizedCProgram.Curl_conncontrol(conn, 1);
				result = /* use the already set error code */status;
				break;
		}
		if (data.getState().getWildcardmatch()) {
			if (data.getSet().getChunk_end() && ftpc.getFile()) {
				ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
				.UNRECOGNIZEDFUNCTIONNAME(data.getWildcard().getCustomptr());
				ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
			} 
			ftpc.setKnown_filesize(-1);
		} 
		if (!result) {
			result = ModernizedCProgram.Curl_urldecode(data, ftp.getPath(), 0, rawPath, pathLen, /* get the url-decoded "raw" path */1);
		} 
		if (result/* We can limp along anyway (and should try to since we may already be in
		     * the error path) */) {
			ftpc.setCtl_valid(/* mark control connection as bad */0);
			ModernizedCProgram.Curl_conncontrol(conn, /* mark for connection closure */1);
			.Curl_cfree(ftpc.getPrevpath());
			ftpc.setPrevpath(((Object)/* no path remembering */0));
		} else {
				if ((data.getSet().getFtp_filemethod() == .FTPFILE_NOCWD) && (rawPath[0] == /* remember working directory for connection reuse */(byte)'/')) {
					.Curl_cfree(/* full path => no CWDs happened => keep ftpc->prevpath */rawPath);
				} else {
						.Curl_cfree(ftpc.getPrevpath());
						if (!ftpc.getCwdfail()) {
							if (data.getSet().getFtp_filemethod() == .FTPFILE_NOCWD) {
								pathLen = /* relative path => working directory is FTP home */0;
							} else {
									pathLen -= ftpc.getFile() ? .strlen(ftpc.getFile()) : /* file is url-decoded */0;
							} 
							rawPath[pathLen] = (byte)'\0';
							ftpc.setPrevpath(rawPath);
						} else {
								.Curl_cfree(rawPath);
								ftpc.setPrevpath(((Object)/* no path */0));
						} 
				} 
				if (ftpc.getPrevpath()) {
					ModernizedCProgram.Curl_infof(data, "Remembering we are in dir \"%s\"\n", ftpc.getPrevpath());
				} 
		} 
		ModernizedCProgram.freedirs(/* free the dir tree and file parts */ftpc/* shut down the socket to inform the server we're done */);
		if (conn.getSock()[1] != (SOCKET)(~/* SD_BOTH */0)) {
			if (!result && ftpc.getDont_check() && data.getReq().getMaxdownload() > 0) {
				result = ModernizedCProgram.Curl_pp_sendf(pp, "%s", /* partial download completed */"ABOR");
				if (result) {
					ModernizedCProgram.Curl_failf(data, "Failure sending ABOR command: %s", ModernizedCProgram.curl_easy_strerror(result));
					ftpc.setCtl_valid(/* mark control connection as bad */0);
					ModernizedCProgram.Curl_conncontrol(conn, /* connection closure */1);
				} 
			} 
			if (conn.getSsl()[1].getUse()) {
				do {
				} while (0/* Note that we keep "use" set to TRUE since that (next) connection is
				         still requested to use SSL */);
			} 
			ModernizedCProgram.close_secondarysocket(conn);
		} 
		curltime curltime = new curltime();
		if (!result && (ftp.getTransfer() == .FTPTRANSFER_BODY) && ftpc.getCtl_valid() && pp.getPending_resp() && !premature/*
		     * Let's see what the server says about the transfer we just performed,
		     * but lower the timeout as sometimes this connection has died while the
		     * data has been transferred. This happens when doing through NATs etc that
		     * abandon old silent connections.
		     */) {
			long old_time = pp.getResponse_time();
			pp.setResponse_time(60 * /* give it only a minute for now */1000);
			pp.setResponse(curltime.Curl_now());
			result = ModernizedCProgram.Curl_GetFTPResponse(nread, conn, ftpcode);
			pp.setResponse_time(/* set this back to previous value */old_time);
			if (!nread && (.CURLE_OPERATION_TIMEDOUT == result)) {
				ModernizedCProgram.Curl_failf(data, "control connection looks dead");
				ftpc.setCtl_valid(/* mark control connection as bad */0);
				ModernizedCProgram.Curl_conncontrol(conn, /* close */1);
			} 
			if (result) {
				return result;
			} 
			if (ftpc.getDont_check() && data.getReq().getMaxdownload() > 0/* we have just sent ABOR and there is no reliable way to check if it was
			       * successful or not; we have to close the connection now */) {
				ModernizedCProgram.Curl_infof(data, "partial download completed, closing connection\n");
				ModernizedCProgram.Curl_conncontrol(conn, 1);
				return result;
			} 
			if (!ftpc.getDont_check()) {
				if ((ftpcode != 226) && (ftpcode != /* 226 Transfer complete, 250 Requested file action okay, completed. */250)) {
					ModernizedCProgram.Curl_failf(data, "server did not report OK, got %d", ftpcode);
					result = .CURLE_PARTIAL_FILE;
				} 
			} 
		} 
		if (result || premature/* the response code from the transfer showed an error already so no
		       use checking further */) {
			;
		}  else if (data.getSet().getUpload()) {
			if ((-1 != data.getState().getInfilesize()) && (data.getState().getInfilesize() != data.getReq().getWritebytecount()) && !data.getSet().getCrlf() && (ftp.getTransfer() == .FTPTRANSFER_BODY)) {
				ModernizedCProgram.Curl_failf(data, "Uploaded unaligned file size (%I64d out of %I64d bytes)", data.getReq().getBytecount(), data.getState().getInfilesize());
				result = .CURLE_PARTIAL_FILE;
			} 
		} else {
				if ((-1 != data.getReq().getSize()) && (data.getReq().getSize() != data.getReq().getBytecount()) && (data.getReq().getMaxdownload() != data.getReq().getBytecount())) {
					ModernizedCProgram.Curl_failf(data, "Received only partial file: %I64d bytes", data.getReq().getBytecount());
					result = .CURLE_PARTIAL_FILE;
				}  else if (!ftpc.getDont_check() && !data.getReq().getBytecount() && (data.getReq().getSize() > 0)) {
					ModernizedCProgram.Curl_failf(data, "No data was received!");
					result = .CURLE_FTP_COULDNT_RETR_FILE;
				} 
		} 
		ftp.setTransfer(/* clear these for next connection */.FTPTRANSFER_BODY);
		ftpc.setDont_check(0);
		if (!status && !result && !premature && data.getSet().getPostquote()) {
			result = ModernizedCProgram.ftp_sendquote(conn, data.getSet().getPostquote());
		} 
		do {
			.Curl_cfree((ftp.getPathalloc()));
			(ftp.getPathalloc()) = ((Object)0);
		} while (0);
		return result/***********************************************************************
		 *
		 * ftp_sendquote()
		 *
		 * Where a 'quote' means a list of custom commands to send to the server.
		 * The quote list is passed as an argument.
		 *
		 * BLOCKING
		 */;
	}
	public static  ftp_sendquote(Object conn, Object quote) {
		curl_slist item = new curl_slist();
		ssize_t nread = new ssize_t();
		int ftpcode;
		CURLcode result = new CURLcode();
		ftp_conn ftpc = conn.getProto().getFtpc();
		pingpong pp = ftpc.getPp();
		item = quote;
		curltime curltime = new curltime();
		while (item) {
			if (item.getData()) {
				byte cmd = item.getData();
				bool acceptfail = 0/* if a command starts with an asterisk, which a legal FTP command never
				         can, the command will be allowed to fail without it causing any
				         aborts or cancels etc. It will cause libcurl to act as if the command
				         is successful, whatever the server reponds. */;
				if (cmd[0] == (byte)'*') {
					cmd++;
					acceptfail = 1;
				} 
				result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "%s", cmd);
				if (result) {
					return result;
				} 
				pp.setResponse(curltime.Curl_now());
				result = ModernizedCProgram.Curl_GetFTPResponse(nread, conn, ftpcode);
				if (result) {
					return result;
				} 
				if (!acceptfail && (ftpcode >= 400)) {
					ModernizedCProgram.Curl_failf(conn.getData(), "QUOT string not accepted: %s", cmd);
					return .CURLE_QUOTE_ERROR;
				} 
			} 
			item = item.getNext();
		}
		return .CURLE_OK/***********************************************************************
		 *
		 * ftp_need_type()
		 *
		 * Returns TRUE if we in the current situation should send TYPE
		 */;
	}
	public static int ftp_need_type(Object conn,  ascii_wanted) {
		return conn.getProto().getFtpc().getTransfertype() != (ascii_wanted ? (byte)'A' : (byte)'I'/***********************************************************************
		 *
		 * ftp_nb_type()
		 *
		 * Set TYPE. We only deal with ASCII or BINARY so this function
		 * sets one of them.
		 * If the transfer type is not sent, simulate on OK response in newstate
		 */);
	}
	public static  ftp_nb_type(Object conn,  ascii,  newstate) {
		ftp_conn ftpc = conn.getProto().getFtpc();
		CURLcode result = new CURLcode();
		byte want = (byte)(ascii ? (byte)'A' : (byte)'I');
		if (ftpc.getTransfertype() == want) {
			ModernizedCProgram._state(conn, newstate);
			return ModernizedCProgram.ftp_state_type_resp(conn, 200, newstate);
		} 
		result = ModernizedCProgram.Curl_pp_sendf(ftpc.getPp(), "TYPE %c", want);
		if (result) {
			return result;
		} 
		ModernizedCProgram._state(conn, newstate);
		ftpc.setTransfertype(/* keep track of our current transfer type */want);
		return .CURLE_OK/***************************************************************************
		 *
		 * ftp_pasv_verbose()
		 *
		 * This function only outputs some informationals about this second connection
		 * when we've issued a PASV command before and thus we have connected to a
		 * possibly new IP address.
		 *
		 */;
	}
	public static void ftp_pasv_verbose(Object conn, Object ai, Object newhost, int port) {
		byte[] buf = new byte[256];
		ModernizedCProgram.Curl_printable_address(ai, buf, );
		ModernizedCProgram.Curl_infof(conn.getData(), "Connecting to %s (%s) port %d\n", newhost, buf, port/*
		 * ftp_do_more()
		 *
		 * This function shall be called when the second FTP (data) connection is
		 * connected.
		 *
		 * 'complete' can return 0 for incomplete, 1 for done and -1 for go back
		 * (which basically is only for when PASV is being sent to retry a failed
		 * EPSV).
		 */);
	}
	/* ascii version */
	/* ascii version */
	public static  ftp_do_more(Object conn, Object completep) {
		Curl_easy data = conn.getData();
		ftp_conn ftpc = conn.getProto().getFtpc();
		CURLcode result = .CURLE_OK;
		bool connected = 0;
		bool complete = 0;
		FTP ftp = data.getReq().getProtop();
		if (!conn.getBits().getTcpconnect()[/* if the second connection isn't done yet, wait for it */1]) {
			if (ModernizedCProgram.Curl_connect_ongoing(conn/* As we're in TUNNEL_CONNECT state now, we know the proxy name and port
			         aren't used so we blank their arguments. */)) {
				result = ModernizedCProgram.Curl_proxyCONNECT(conn, 1, ((Object)0), 0);
				return result;
			} 
			result = ModernizedCProgram.Curl_is_connected(conn, 1, connected);
			if (/* Ready to do more? */connected) {
				do {
				} while (0);
			} else {
					if (result && (ftpc.getCount1() == 0)) {
						completep = -/* go back to DOING please */1;
						return ModernizedCProgram.ftp_epsv_disable(/* this is a EPSV connect failing, try PASV instead */conn);
					} 
					return result;
			} 
		} 
		result = ModernizedCProgram.Curl_proxy_connect(conn, 1);
		if (result) {
			return result;
		} 
		if ((conn.getHttp_proxy().getProxytype() == .CURLPROXY_HTTPS && !conn.getBits().getProxy_ssl_connected()[1])) {
			return result;
		} 
		if (conn.getBits().getTunnel_proxy() && conn.getBits().getHttpproxy() && ModernizedCProgram.Curl_connect_ongoing(conn)) {
			return result;
		} 
		if (ftpc.getState()) {
			result = ModernizedCProgram.ftp_multi_statemach(conn, complete);
			completep = (int)complete;
			if (result || !ftpc.getWait_data_conn()) {
				return result/* if we reach the end of the FTP state machine here, *complete will be
				       TRUE but so is ftpc->wait_data_conn, which says we need to wait for the
				       data connection and therefore we're not actually complete */;
			} 
			completep = 0;
		} 
		if (ftp.getTransfer() <= .FTPTRANSFER_INFO/* a transfer is about to take place, or if not a file name was given
		       so we'll do a SIZE on it later and then we need the right TYPE first */) {
			if (ftpc.getWait_data_conn() == 1) {
				bool serv_conned = new bool();
				result = ModernizedCProgram.ReceivedServerConnect(conn, serv_conned);
				if (result) {
					return /* Failed to accept data connection */result;
				} 
				if (serv_conned) {
					result = ModernizedCProgram.AcceptServerConnect(/* It looks data connection is established */conn);
					ftpc.setWait_data_conn(0);
					if (!result) {
						result = ModernizedCProgram.InitiateTransfer(conn);
					} 
					if (result) {
						return result;
					} 
					completep = /* this state is now complete when the server has
					                           connected back to us */1;
				} 
			}  else if (data.getSet().getUpload()) {
				result = ModernizedCProgram.ftp_nb_type(conn, data.getSet().getPrefer_ascii(), .FTP_STOR_TYPE);
				if (result) {
					return result;
				} 
				result = ModernizedCProgram.ftp_multi_statemach(conn, complete);
				completep = (int)/* ftpc->wait_data_conn is always false here */complete;
			} else {
					ftp.setDownloadsize(-/* download *//* unknown as of yet */1);
					result = ModernizedCProgram.Curl_range(conn);
					if (result == .CURLE_OK && data.getReq().getMaxdownload() >= 0) {
						ftpc.setDont_check(/* Don't check for successful transfer */1);
					} 
					if (result) {
						;
					}  else if (data.getSet().getFtp_list_only() || !ftpc.getFile()) {
						if (ftp.getTransfer() == /* But only if a body transfer was requested. */.FTPTRANSFER_BODY) {
							result = ModernizedCProgram.ftp_nb_type(conn, 1, .FTP_LIST_TYPE);
							if (result) {
								return result/* otherwise just fall through */;
							} 
						} 
					} else {
							result = ModernizedCProgram.ftp_nb_type(conn, data.getSet().getPrefer_ascii(), .FTP_RETR_TYPE);
							if (result) {
								return result;
							} 
					} 
					result = ModernizedCProgram.ftp_multi_statemach(conn, complete);
					completep = (int)complete;
			} 
			return result;
		} 
		ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, -/* no data to transfer */1);
		if (!ftpc.getWait_data_conn()) {
			completep = /* no waiting for the data connection so this is now complete */1;
			do {
			} while (0);
		} 
		return result/***********************************************************************
		 *
		 * ftp_perform()
		 *
		 * This is the actual DO function for FTP. Get a file/directory according to
		 * the options previously setup.
		 */;
	}
	public static  ftp_perform(Object conn, Object connected, Object dophase_done) {
		CURLcode result = /* this is FTP and no proxy */.CURLE_OK;
		do {
		} while (0);
		if (conn.getData().getSet().getOpt_no_body()) {
			FTP ftp = conn.getData().getReq().getProtop();
			ftp.setTransfer(.FTPTRANSFER_INFO);
		} 
		dophase_done = /* not done yet */0;
		result = ModernizedCProgram.ftp_state_quote(conn, 1, /* start the first command in the DO phase */.FTP_QUOTE);
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.ftp_multi_statemach(conn, /* run the state-machine */dophase_done);
		connected = conn.getBits().getTcpconnect()[1];
		ModernizedCProgram.Curl_infof(conn.getData(), "ftp_perform ends with SECONDARY: %d\n", connected);
		if (dophase_done) {
			do {
			} while (0);
		} 
		return result;
	}
	/* connect status after PASV / PORT */
	public static void wc_data_dtor(Object ptr) {
		ftp_wc ftpwc = ptr;
		if (ftpwc && ftpwc.getParser()) {
			ModernizedCProgram.Curl_ftp_parselist_data_free(ftpwc.getParser());
		} 
		.Curl_cfree(ftpwc);
	}
	public static  init_wc_data(Object conn) {
		byte last_slash;
		FTP ftp = conn.getData().getReq().getProtop();
		byte path = ftp.getPath();
		WildcardData wildcard = (conn.getData().getWildcard());
		CURLcode result = .CURLE_OK;
		ftp_wc ftpwc = ((Object)0);
		last_slash = .strrchr(ftp.getPath(), (byte)'/');
		if (last_slash) {
			last_slash++;
			if (last_slash[0] == (byte)'\0') {
				wildcard.setState(.CURLWC_CLEAN);
				result = ModernizedCProgram.ftp_parse_url_path(conn);
				return result;
			} 
			wildcard.setPattern(.Curl_cstrdup(last_slash));
			if (!wildcard.getPattern()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			last_slash[0] = /* cut file from path */(byte)'\0';
		} else {
				if (path[/* there is only 'wildcard pattern' or nothing */0]) {
					wildcard.setPattern(.Curl_cstrdup(path));
					if (!wildcard.getPattern()) {
						return .CURLE_OUT_OF_MEMORY;
					} 
					path[0] = (byte)'\0';
				} else {
						wildcard.setState(/* only list */.CURLWC_CLEAN);
						result = ModernizedCProgram.ftp_parse_url_path(conn);
						return result;
				} 
		} 
		ftpwc = .Curl_ccalloc(1, /* program continues only if URL is not ending with slash, allocate needed
		     resources for wildcard transfer *//* allocate ftp protocol specific wildcard data */);
		if (!ftpwc) {
			result = .CURLE_OUT_OF_MEMORY;
			;
		} 
		ftpwc.setParser(ModernizedCProgram.Curl_ftp_parselist_data_alloc());
		if (!ftpwc.getParser()) {
			result = .CURLE_OUT_OF_MEMORY;
			;
		} 
		wildcard.setProtdata(/* put it to the WildcardData tmp pointer */ftpwc);
		wildcard.setDtor(ModernizedCProgram.wc_data_dtor);
		if (conn.getData().getSet().getFtp_filemethod() == /* wildcard does not support NOCWD option (assert it?) */.FTPFILE_NOCWD) {
			conn.getData().getSet().setFtp_filemethod(.FTPFILE_MULTICWD);
		} 
		result = ModernizedCProgram.ftp_parse_url_path(/* try to parse ftp url */conn);
		if (result) {
			;
		} 
		wildcard.setPath(.Curl_cstrdup(ftp.getPath()));
		if (!wildcard.getPath()) {
			result = .CURLE_OUT_OF_MEMORY;
			;
		} 
		ftpwc.getBackup().setWrite_function(conn.getData().getSet().getFwrite_func());
		conn.getData().getSet().setFwrite_func(/* parsing write function */ModernizedCProgram.Curl_ftp_parselist);
		ftpwc.getBackup().setFile_descriptor(conn.getData().getSet().getOut());
		conn.getData().getSet().setOut(/* let the writefunc callback know what curl pointer is working with */conn);
		ModernizedCProgram.Curl_infof(conn.getData(), "Wildcard - Parsing started\n");
		return .CURLE_OK;
		do {
			.Curl_cfree((wildcard.getPattern()));
			(wildcard.getPattern()) = ((Object)0);
		} while (0);
		wildcard.setDtor(0);
		wildcard.setProtdata(((Object)0));
		return result;
	}
	/* This is called recursively */
	public static  wc_statemach(Object conn) {
		WildcardData wildcard = (conn.getData().getWildcard());
		CURLcode result = .CURLE_OK;
		switch (wildcard.getState()) {
		case .CURLWC_DOWNLOADING:
				{ 
					ftp_conn ftpc = conn.getProto().getFtpc();
					curl_fileinfo finfo = wildcard.getFilelist().getHead().getPtr();
					FTP ftp = conn.getData().getReq().getProtop();
					byte tmp_path = ModernizedCProgram.curl_maprintf("%s%s", wildcard.getPath(), finfo.getFilename());
					if (!tmp_path) {
						return .CURLE_OUT_OF_MEMORY;
					} 
					.Curl_cfree(ftp.getPathalloc());
					ftp.setPathalloc(ftp.setPath(tmp_path));
					ModernizedCProgram.Curl_infof(conn.getData(), "Wildcard - START of \"%s\"\n", finfo.getFilename());
					if (conn.getData().getSet().getChunk_bgn()) {
						long userresponse;
						ModernizedCProgram.Curl_set_in_callback(conn.getData(), .bool_true);
						userresponse = .UNRECOGNIZEDFUNCTIONNAME(finfo, wildcard.getCustomptr(), (int)wildcard.getFilelist().getSize());
						ModernizedCProgram.Curl_set_in_callback(conn.getData(), .bool_false);
						switch (userresponse) {
						case 2:
								ModernizedCProgram.Curl_infof(conn.getData(), "Wildcard - \"%s\" skipped by user\n", finfo.getFilename());
								wildcard.setState(.CURLWC_SKIP);
								return ModernizedCProgram.wc_statemach(conn);
						case 1:
								return .CURLE_CHUNK_FAILED;
						}
					} 
					if (finfo.getFiletype() != .CURLFILETYPE_FILE) {
						wildcard.setState(.CURLWC_SKIP);
						return ModernizedCProgram.wc_statemach(conn);
					} 
					if (finfo.getFlags() & (1 << 6)) {
						ftpc.setKnown_filesize(finfo.getSize());
					} 
					result = ModernizedCProgram.ftp_parse_url_path(conn);
					if (result) {
						return result;
					} 
					ModernizedCProgram.Curl_llist_remove(wildcard.getFilelist(), wildcard.getFilelist().getHead(), ((Object)/* we don't need the Curl_fileinfo of first file anymore */0));
					if (wildcard.getFilelist().getSize() == /* remains only one file to down. */0) {
						wildcard.setState(.CURLWC_CLEAN/* after that will be ftp_do called once again and no transfer
						         will be done because of CURLWC_CLEAN state */);
						return .CURLE_OK;
					} 
				}
				break;
		case .CURLWC_SKIP:
				{ 
					if (conn.getData().getSet().getChunk_end()) {
						ModernizedCProgram.Curl_set_in_callback(conn.getData(), .bool_true);
						.UNRECOGNIZEDFUNCTIONNAME(conn.getData().getWildcard().getCustomptr());
						ModernizedCProgram.Curl_set_in_callback(conn.getData(), .bool_false);
					} 
					ModernizedCProgram.Curl_llist_remove(wildcard.getFilelist(), wildcard.getFilelist().getHead(), ((Object)0));
					wildcard.setState((wildcard.getFilelist().getSize() == 0) ? .CURLWC_CLEAN : .CURLWC_DOWNLOADING);
					return ModernizedCProgram.wc_statemach(conn);
				}
		case .CURLWC_DONE:
		case .CURLWC_MATCHING/* In this state is LIST response successfully parsed, so lets restore
		       previous WRITEFUNCTION callback and WRITEDATA pointer */:
				{ 
					ftp_wc ftpwc = wildcard.getProtdata();
					conn.getData().getSet().setFwrite_func(ftpwc.getBackup().getWrite_function());
					conn.getData().getSet().setOut(ftpwc.getBackup().getFile_descriptor());
					ftpwc.getBackup().setWrite_function(0);
					ftpwc.getBackup().setFile_descriptor(((Object)0));
					wildcard.setState(.CURLWC_DOWNLOADING);
					if (ModernizedCProgram.Curl_ftp_parselist_geterror(ftpwc.getParser())) {
						wildcard.setState(/* error found in LIST parsing */.CURLWC_CLEAN);
						return ModernizedCProgram.wc_statemach(conn);
					} 
					if (wildcard.getFilelist().getSize() == 0) {
						wildcard.setState(/* no corresponding file */.CURLWC_CLEAN);
						return .CURLE_REMOTE_FILE_NOT_FOUND;
					} 
					return ModernizedCProgram.wc_statemach(conn);
				}
		case .CURLWC_INIT:
				result = ModernizedCProgram.init_wc_data(conn);
				if (wildcard.getState() == .CURLWC_CLEAN/* only listing! */) {
					break;
				} 
				wildcard.setState(result ? .CURLWC_ERROR : .CURLWC_MATCHING);
				break;
		case .CURLWC_CLEAN:
				{ 
					ftp_wc ftpwc = wildcard.getProtdata();
					result = .CURLE_OK;
					if (ftpwc) {
						result = ModernizedCProgram.Curl_ftp_parselist_geterror(ftpwc.getParser());
					} 
					wildcard.setState(result ? .CURLWC_ERROR : .CURLWC_DONE);
				}
				break;
		case .CURLWC_ERROR:
		case .CURLWC_CLEAR:
				if (wildcard.getDtor()) {
					.UNRECOGNIZEDFUNCTIONNAME(wildcard.getProtdata());
				} 
				break;
		}
		return result/***********************************************************************
		 *
		 * ftp_do()
		 *
		 * This function is registered as 'curl_do' function. It decodes the path
		 * parts etc as a wrapper to the actual DO function (ftp_perform).
		 *
		 * The input argument is already checked for validity.
		 */;
	}
	public static  ftp_do(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		ftp_conn ftpc = conn.getProto().getFtpc();
		done = /* default to false */0;
		ftpc.setWait_data_conn(/* default to no such wait */0);
		if (conn.getData().getState().getWildcardmatch()) {
			result = ModernizedCProgram.wc_statemach(conn);
			if (conn.getData().getWildcard().getState() == .CURLWC_SKIP || conn.getData().getWildcard().getState() == .CURLWC_DONE) {
				return /* do not call ftp_regular_transfer */.CURLE_OK;
			} 
			if (/* error, loop or skipping the file */result) {
				return result;
			} 
		} else {
				result = ModernizedCProgram.ftp_parse_url_path(/* no wildcard FSM needed */conn);
				if (result) {
					return result;
				} 
		} 
		result = ModernizedCProgram.ftp_regular_transfer(conn, done);
		return result;
	}
	public static  Curl_ftpsend(Object conn, Object cmd) {
		ssize_t bytes_written = new ssize_t();
		byte[] s = new byte[1024];
		size_t write_len = new size_t();
		byte sptr = s;
		CURLcode result = .CURLE_OK;
		if (!cmd) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		write_len = .strlen(cmd);
		if (!write_len || write_len > ( - 3)) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		.memcpy(s, cmd, write_len);
		.strcpy(s[write_len], /* append a trailing CRLF */"\r\n");
		write_len += 2;
		bytes_written = 0;
		result = ();
		if (/* Curl_convert_to_network calls failf if unsuccessful */result) {
			return result;
		} 
		for (; ; ) {
			result = ModernizedCProgram.Curl_write(conn, conn.getSock()[0], sptr, write_len, bytes_written);
			if (result) {
				break;
			} 
			if (conn.getData().getSet().getVerbose()) {
				ModernizedCProgram.Curl_debug(conn.getData(), .CURLINFO_HEADER_OUT, sptr, (size_t)bytes_written);
			} 
			if (bytes_written != (ssize_t)write_len) {
				write_len -= bytes_written;
				sptr += bytes_written;
			} else {
					break;
			} 
		}
		return result/***********************************************************************
		 *
		 * ftp_quit()
		 *
		 * This should be called before calling sclose() on an ftp control connection
		 * (not data connections). We should then wait for the response from the
		 * server before returning. The calling code should then try to close the
		 * connection.
		 *
		 */;
	}
	public static  ftp_quit(Object conn) {
		CURLcode result = .CURLE_OK;
		if (conn.getProto().getFtpc().getCtl_valid()) {
			result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getFtpc().getPp(), "%s", "QUIT");
			if (result) {
				ModernizedCProgram.Curl_failf(conn.getData(), "Failure sending QUIT command: %s", ModernizedCProgram.curl_easy_strerror(result));
				conn.getProto().getFtpc().setCtl_valid(/* mark control connection as bad */0);
				ModernizedCProgram.Curl_conncontrol(conn, /* mark for connection closure */1);
				ModernizedCProgram._state(conn, .FTP_STOP);
				return result;
			} 
			ModernizedCProgram._state(conn, .FTP_QUIT);
			result = ModernizedCProgram.ftp_block_statemach(conn);
		} 
		return result/***********************************************************************
		 *
		 * ftp_disconnect()
		 *
		 * Disconnect from an FTP server. Cleanup protocol-specific per-connection
		 * resources. BLOCKING.
		 */;
	}
	public static  ftp_disconnect(Object conn,  dead_connection) {
		ftp_conn ftpc = conn.getProto().getFtpc();
		pingpong pp = ftpc.getPp();
		if (dead_connection) {
			ftpc.setCtl_valid(0);
		} 
		(Object)ModernizedCProgram.ftp_quit(/* The FTP session may or may not have been allocated/setup at this point! *//* ignore errors on the QUIT */conn);
		if (ftpc.getEntrypath()) {
			Curl_easy data = conn.getData();
			if (data.getState().getMost_recent_ftp_entrypath() == ftpc.getEntrypath()) {
				data.getState().setMost_recent_ftp_entrypath(((Object)0));
			} 
			.Curl_cfree(ftpc.getEntrypath());
			ftpc.setEntrypath(((Object)0));
		} 
		ModernizedCProgram.freedirs(ftpc);
		.Curl_cfree(ftpc.getPrevpath());
		ftpc.setPrevpath(((Object)0));
		.Curl_cfree(ftpc.getServer_os());
		ftpc.setServer_os(((Object)0));
		ModernizedCProgram.Curl_pp_disconnect(pp);
		return .CURLE_OK/***********************************************************************
		 *
		 * ftp_parse_url_path()
		 *
		 * Parse the URL path into separate path components.
		 *
		 */;
	}
	public static  ftp_parse_url_path(Object conn) {
		Curl_easy data = conn.getData();
		FTP ftp = data.getReq().getProtop();
		ftp_conn ftpc = conn.getProto().getFtpc();
		byte slashPos = ((Object)0);
		byte fileName = ((Object)0);
		CURLcode result = .CURLE_OK;
		byte rawPath = ((Object)/* url-decoded "raw" path */0);
		size_t pathLen = 0;
		ftpc.setCtl_valid(0);
		ftpc.setCwdfail(0);
		result = ModernizedCProgram.Curl_urldecode(data, ftp.getPath(), 0, rawPath, pathLen, /* url-decode ftp path before further evaluation */1);
		if (result) {
			return result;
		} 
		switch (data.getSet().getFtp_filemethod()) {
		case .FTPFILE_MULTICWD:
				{ 
					byte curPos = /* current position: begin of next path component */rawPath;
					int dirAlloc = /* number of entries allocated for the 'dirs' array */0;
					byte str = rawPath;
					for (; str != 0; ++str) {
						if (str == (byte)'/') {
							++dirAlloc;
						} 
					}
					if (dirAlloc > 0) {
						ftpc.setDirs(.Curl_ccalloc(dirAlloc, ));
						if (!ftpc.getDirs()) {
							.Curl_cfree(rawPath);
							return .CURLE_OUT_OF_MEMORY;
						} 
						while ((slashPos = .strchr(curPos, (byte)'/')) != ((Object)/* parse the URL path into separate path components */0)) {
							size_t compLen = slashPos - curPos;
							if ((compLen == 0) && (ftpc.getDirdepth() == /* path starts with a slash: add that as a directory */0)) {
								++compLen/* we skip empty path components, like "x//y" since the FTP command
								             CWD requires a parameter and a non-existent parameter a) doesn't
								             work on many servers and b) has no effect on the others. */;
							} 
							if (compLen > 0) {
								byte comp = .Curl_ccalloc(1, compLen + 1);
								if (!comp) {
									.Curl_cfree(rawPath);
									return .CURLE_OUT_OF_MEMORY;
								} 
								.strncpy(comp, curPos, compLen);
								ftpc.getDirs()[ftpc.getDirdepth()++] = comp;
							} 
							curPos = slashPos + 1;
						}
					} 
					do {
					} while (0);
					fileName = /* the rest is the file name (or empty) */curPos;
				}
				break;
		case .FTPFILE_SINGLECWD:
				slashPos = .strrchr(rawPath, (byte)'/');
				if (slashPos) {
					size_t dirlen = slashPos - /* get path before last slash, except for / */rawPath;
					if (dirlen == 0) {
						dirlen++;
					} 
					ftpc.setDirs(.Curl_ccalloc(1, ));
					if (!ftpc.getDirs()) {
						.Curl_cfree(rawPath);
						return .CURLE_OUT_OF_MEMORY;
					} 
					ftpc.getDirs()[0] = .Curl_ccalloc(1, dirlen + 1);
					if (!ftpc.getDirs()[0]) {
						.Curl_cfree(rawPath);
						return .CURLE_OUT_OF_MEMORY;
					} 
					.strncpy(ftpc.getDirs()[0], rawPath, dirlen);
					ftpc.setDirdepth(/* we consider it to be a single dir */1);
					fileName = slashPos + /* rest is file name */1;
				} else {
						fileName = /* file name only (or empty) */rawPath;
				} 
				break;
		case /* fastest, but less standard-compliant */.FTPFILE_NOCWD:
				if ((pathLen > 0) && (rawPath[pathLen - 1] != (byte)'/')) {
					fileName = /* this is a full file path */rawPath/*
					        else: ftpc->file is not used anywhere other than for operations on
					              a file. In other words, never for directory operations.
					              So we can safely leave filename as NULL here and use it as a
					              argument in dir/file decisions.
					      */;
				} 
				break;
		default:
		}
		if (fileName && fileName) {
			ftpc.setFile(.Curl_cstrdup(fileName));
		} else {
				ftpc.setFile(((Object)/* instead of point to a zero byte,
				                            we make it a NULL pointer */0));
		} 
		if (data.getSet().getUpload() && !ftpc.getFile() && (ftp.getTransfer() == .FTPTRANSFER_BODY)) {
			ModernizedCProgram.Curl_failf(data, /* We need a file name when uploading. Return error! */"Uploading to a URL without a file name!");
			.Curl_cfree(rawPath);
			return .CURLE_URL_MALFORMAT;
		} 
		ftpc.setCwddone(/* default to not done */0);
		if ((data.getSet().getFtp_filemethod() == .FTPFILE_NOCWD) && (rawPath[0] == (byte)'/')) {
			ftpc.setCwddone(/* skip CWD for absolute paths */1);
		} else {
				byte oldPath = conn.getBits().getReuse() ? ftpc.getPrevpath() : /* newly created FTP connections are already in entry path */"";
				if (oldPath) {
					size_t n = pathLen;
					if (data.getSet().getFtp_filemethod() == .FTPFILE_NOCWD) {
						n = /* CWD to entry for relative paths */0;
					} else {
							n -= ftpc.getFile() ? .strlen(ftpc.getFile()) : 0;
					} 
					if ((.strlen(oldPath) == n) && !.strncmp(rawPath, oldPath, n)) {
						ModernizedCProgram.Curl_infof(data, "Request has same path as previous transfer\n");
						ftpc.setCwddone(1);
					} 
				} 
		} 
		.Curl_cfree(rawPath);
		return .CURLE_OK;
	}
	/* call this when the DO phase has completed */
	public static  ftp_dophase_done(Object conn,  connected) {
		FTP ftp = conn.getData().getReq().getProtop();
		ftp_conn ftpc = conn.getProto().getFtpc();
		if (connected) {
			int completed;
			CURLcode result = ModernizedCProgram.ftp_do_more(conn, completed);
			if (result) {
				ModernizedCProgram.close_secondarysocket(conn);
				return result;
			} 
		} 
		if (ftp.getTransfer() != .FTPTRANSFER_BODY) {
			ModernizedCProgram.Curl_setup_transfer(conn.getData(), -1, -1, 0, -/* no data to transfer */1);
		}  else if (!connected) {
			conn.getBits().setDo_more(/* since we didn't connect now, we want do_more to get called */1);
		} 
		ftpc.setCtl_valid(/* seems good */1);
		return .CURLE_OK;
	}
	/* easy-to-use macro: */
	/* called from multi.c while DOing */
	public static  ftp_doing(Object conn, Object dophase_done) {
		CURLcode result = ModernizedCProgram.ftp_multi_statemach(conn, dophase_done);
		if (result) {
			do {
			} while (0);
		}  else if (dophase_done) {
			result = ModernizedCProgram.ftp_dophase_done(conn, /* not connected */0);
			do {
			} while (0);
		} 
		return result/***********************************************************************
		 *
		 * ftp_regular_transfer()
		 *
		 * The input argument is already checked for validity.
		 *
		 * Performs all commands done before a regular transfer between a local and a
		 * remote host.
		 *
		 * ftp->ctl_valid starts out as FALSE, and gets set to TRUE if we reach the
		 * ftp_done() function without finding any major problem.
		 */;
	}
	public static  ftp_regular_transfer(Object conn, Object dophase_done) {
		CURLcode result = .CURLE_OK;
		bool connected = 0;
		Curl_easy data = conn.getData();
		ftp_conn ftpc = conn.getProto().getFtpc();
		data.getReq().setSize(-/* make sure this is unknown at this point */1);
		ModernizedCProgram.Curl_pgrsSetUploadCounter(data, 0);
		ModernizedCProgram.Curl_pgrsSetDownloadCounter(data, 0);
		ModernizedCProgram.Curl_pgrsSetUploadSize(data, -1);
		ModernizedCProgram.Curl_pgrsSetDownloadSize(data, -1);
		ftpc.setCtl_valid(/* starts good */1);
		result = ModernizedCProgram.ftp_perform(conn, /* have we connected after PASV/PORT */connected, /* all commands in the DO-phase done? */dophase_done);
		if (!result) {
			if (!dophase_done) {
				return /* the DO phase has not completed yet */.CURLE_OK;
			} 
			result = ModernizedCProgram.ftp_dophase_done(conn, connected);
			if (result) {
				return result;
			} 
		} else {
				ModernizedCProgram.freedirs(ftpc);
		} 
		return result;
	}
	public static  ftp_setup_connection(Object conn) {
		Curl_easy data = conn.getData();
		byte type;
		FTP ftp = new FTP();
		conn.getData().getReq().setProtop(ftp = .Curl_ccalloc(, 1));
		if (((Object)0) == ftp) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		ftp.setPath(data.getState().getUp().getPath()[/* don't include the initial slash */1]);
		type = .strstr(ftp.getPath(), /* FTP URLs support an extension like ";type=<typecode>" that
		   * we'll try to get now! */";type=");
		if (!type) {
			type = .strstr(conn.getHost().getRawalloc(), ";type=");
		} 
		if (type) {
			byte command;
			type = /* it was in the middle of the hostname */0;
			command = ModernizedCProgram.Curl_raw_toupper(type[6]);
			conn.getBits().setType_set(1);
			switch (command) {
			case /* ASCII mode */(byte)'A':
					data.getSet().setPrefer_ascii(1);
					break;
			case /* directory mode */(byte)'D':
					data.getSet().setFtp_list_only(1);
					break;
			case /* binary mode */(byte)'I':
			default:
					data.getSet().setPrefer_ascii(/* switch off ASCII */0);
					break;
			}
		} 
		ftp.setTransfer(/* get some initial data into the ftp struct */.FTPTRANSFER_BODY);
		ftp.setDownloadsize(0/* No need to duplicate user+password, the connectdata struct won't change
		     during a session, but we re-init them here since on subsequent inits
		     since the conn struct may have changed or been replaced.
		  */);
		ftp.setUser(conn.getUser());
		ftp.setPasswd(conn.getPasswd());
		if (ModernizedCProgram.isBadFtpString(ftp.getUser())) {
			return .CURLE_URL_MALFORMAT;
		} 
		if (ModernizedCProgram.isBadFtpString(ftp.getPasswd())) {
			return .CURLE_URL_MALFORMAT;
		} 
		conn.getProto().getFtpc().setKnown_filesize(-/* unknown size for now */1);
		return .CURLE_OK/* CURL_DISABLE_FTP */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * NTLM details:
	 *
	 * https://davenport.sourceforge.io/ntlm.html
	 * https://www.innovation.ch/java/ntlm.html
	 */
	/* Please keep the SSL backend-specific #if branches in this order:
	
	   1. USE_OPENSSL
	   2. USE_GNUTLS_NETTLE
	   3. USE_GNUTLS
	   4. USE_NSS
	   5. USE_MBEDTLS
	   6. USE_SECTRANSP
	   7. USE_OS400CRYPTO
	   8. USE_WIN32_CRYPTO
	
	   This ensures that:
	   - the same SSL branch gets activated throughout this source
	     file even if multiple backends are enabled at the same time.
	   - OpenSSL and NSS have higher priority than Windows Crypt, due
	     to issues with the latter supporting NTLM2Session responses
	     in NTLM type-3 messages.
	 */
	/* mih/cipher */
	/* The last 3 #include files should be in this order */
	/*
	* Turns a 56-bit key into being 64-bit wide.
	*/
	public static void extend_key_56_to_64(Object key_56, Object key) {
		key[0] = key_56[0];
		key[1] = (byte)(((key_56[0] << 7) & -1024) | (key_56[1] >> 1));
		key[2] = (byte)(((key_56[1] << 6) & -1024) | (key_56[2] >> 2));
		key[3] = (byte)(((key_56[2] << 5) & -1024) | (key_56[3] >> 3));
		key[4] = (byte)(((key_56[3] << 4) & -1024) | (key_56[4] >> 4));
		key[5] = (byte)(((key_56[4] << 3) & -1024) | (key_56[5] >> 5));
		key[6] = (byte)(((key_56[5] << 2) & -1024) | (key_56[6] >> 6));
		key[7] = (byte)((key_56[6] << 1) & -1024/*
		 * Turns a 56 bit key into the 64 bit, odd parity key and sets the key.  The
		 * key schedule ks is also set.
		 *//* Expand the 56-bit key to 64-bits *//* Set the key parity to odd *//* Set the key *//* Expand the 56-bit key to 64-bits *//* Set the key parity to odd *//* Set the key *//*
		 * Turns a 56 bit key into the 64 bit, odd parity key and sets the key.
		 *//* Expand the 56-bit key to 64-bits *//* Set the key parity to odd *//* Set the key *//*
		 * Expands a 56 bit key KEY_56 to 64 bit and encrypts 64 bit of data, using
		 * the expanded key.  The caller is responsible for giving 64 bit of valid
		 * data is IN and (at least) 64 bit large buffer as OUT.
		 *//* DES cipher in ECB mode *//* expanded 64 bit key *//* not used, required by NSS *//* use internal slot for DES encryption (requires NSS to be initialized) *//* Expand the 56-bit key to 64-bits *//* Set the key parity to odd *//* Import the key */);
	}
	/* Create the DES encryption context */
	/* no IV in ECB mode */
	/* Perform the encryption */
	/* outbuflen */
	/* inbuflen */
	/* all OK */
	/* cleanup */
	/* Expand the 56-bit key to 64-bits */
	/* Set the key parity to odd */
	/* Perform the encryption */
	/* Expand the 56-bit key to 64-bits */
	/* Set the key parity to odd */
	/* Perform the encryption */
	/* inbuflen */
	/* outbuflen */
	/* Setup the cipher control structure */
	/* Expand the 56-bit key to 64-bits */
	/* Set the key parity to odd */
	/* Perform the encryption */
	public static  encrypt_des(Object in, Object out, Object key_56) {
		HCRYPTPROV hprov = new HCRYPTPROV();
		HCRYPTKEY hkey = new HCRYPTKEY();
		Object blob;
		DWORD len = 8;
		if (!.CryptAcquireContextA(hprov, ((Object)0), ((Object)0), /* Acquire the crypto provider */1, -1024)) {
			return 0;
		} 
		.memset(blob, 0, );
		Object generatedHdr = blob.getHdr();
		generatedHdr.setBType(8);
		generatedHdr.setBVersion(2);
		generatedHdr.setAiKeyAlg((24576 | 1536 | 1));
		Object generatedKey = blob.getKey();
		blob.setLen();
		ModernizedCProgram.extend_key_56_to_64(key_56, generatedKey);
		ModernizedCProgram.Curl_des_set_odd_parity((byte)generatedKey, );
		if (!.CryptImportKey(hprov, (BYTE)blob, , 0, 0, /* Import the key */hkey)) {
			.CryptReleaseContext(hprov, 0);
			return 0;
		} 
		.memcpy(out, in, 8);
		.CryptEncrypt(hkey, 0, 0, 0, out, len, /* Perform the encryption */len);
		.CryptDestroyKey(hkey);
		.CryptReleaseContext(hprov, 0);
		return 1/* defined(USE_WIN32_CRYPTO) *//*
		  * takes a 21 byte array and treats it as 3 56-bit DES keys. The
		  * 8 byte plaintext is encrypted with each key and the resulting 24
		  * bytes are stored in the results array.
		  */;
	}
	public static void Curl_ntlm_core_lm_resp(Object keys, Object plaintext, Object results) {
		ModernizedCProgram.encrypt_des(plaintext, results, keys);
		ModernizedCProgram.encrypt_des(plaintext, results + 8, keys + 7);
		ModernizedCProgram.encrypt_des(plaintext, results + 16, keys + 14);
	}
	/*
	 * Set up lanmanager hashed password
	 */
	public static  Curl_ntlm_core_mk_lm_hash(Object data, Object password, Object lmbuffer) {
		/* 21 bytes */CURLcode result = new CURLcode();
		byte[] pw = new byte[14];
		byte[] magic = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, -1024, /* i.e. KGS!@#$% */-1024};
		size_t len = ((.strlen(password)) < (true) ? (.strlen(password)) : (true));
		ModernizedCProgram.Curl_strntoupper((byte)pw, password, len);
		.memset(pw[len], 0, 14 - len/*
		   * The LanManager hashed password needs to be created using the
		   * password in the network encoding not the host encoding.
		   */);
		result = ();
		if (result) {
			return result/* Create LanManager hashed password. */;
		} 
		{ 
			ModernizedCProgram.encrypt_des(magic, lmbuffer, pw);
			ModernizedCProgram.encrypt_des(magic, lmbuffer + 8, pw + 7);
			.memset(lmbuffer + 16, 0, 21 - 16);
		}
		return .CURLE_OK;
	}
	public static void ascii_to_unicode_le(Object dest, Object src, Object srclen) {
		size_t i = new size_t();
		for (i = 0; i < srclen; i++) {
			dest[2 * i] = (byte)src[i];
			dest[2 * i + 1] = (byte)'\0';
		}
	}
	public static void ascii_uppercase_to_unicode_le(Object dest, Object src, Object srclen) {
		size_t i = new size_t();
		for (i = 0; i < srclen; i++) {
			dest[2 * i] = (byte)(ModernizedCProgram.Curl_raw_toupper(src[i]));
			dest[2 * i + 1] = (byte)'\0'/* USE_NTLM_V2 && !USE_WINDOWS_SSPI */;
		}
	}
	/*
	 * Set up nt hashed passwords
	 * @unittest: 1600
	 */
	public static  Curl_ntlm_core_mk_nt_hash(Object data, Object password, Object ntbuffer) {
		size_t len = .strlen(/* 21 bytes */password);
		byte pw;
		CURLcode result = new CURLcode();
		if (len > -1024 / /* avoid integer overflow */2) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		pw = len ? .Curl_cmalloc(len * 2) : (byte).Curl_cstrdup("");
		if (!pw) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.ascii_to_unicode_le(pw, password, len/*
		   * The NT hashed password needs to be created using the password in the
		   * network encoding not the host encoding.
		   */);
		result = ();
		if (result) {
			return result;
		} 
		ModernizedCProgram.Curl_md4it(ntbuffer, pw, 2 * /* Create NT hashed password. */len);
		.memset(ntbuffer + 16, 0, 21 - 16);
		.Curl_cfree(pw);
		return .CURLE_OK;
	}
	/* This returns the HMAC MD5 digest */
	public static  hmac_md5(Object key, int keylen, Object data, int datalen, Object output) {
		HMAC_context ctxt = ModernizedCProgram.Curl_HMAC_init(ModernizedCProgram.Curl_HMAC_MD5, key, keylen);
		if (!ctxt) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.Curl_HMAC_update(ctxt, data, /* Update the digest with the given challenge */datalen);
		ModernizedCProgram.Curl_HMAC_final(ctxt, /* Finalise the digest */output);
		return .CURLE_OK/* This creates the NTLMv2 hash by using NTLM hash as the key and Unicode
		 * (uppercase UserName + Domain) as the data
		 */;
	}
	public static  Curl_ntlm_core_mk_ntlmv2_hash(Object user, Object userlen, Object domain, Object domlen, Object ntlmhash, Object ntlmv2hash) {
		/* Unicode representation */size_t identity_len = new size_t();
		byte identity;
		CURLcode result = .CURLE_OK;
		if ((userlen > -1024 / /* we do the length checks below separately to avoid integer overflow risk
		     on extreme data lengths */2) || (domlen > -1024 / 2) || ((userlen + domlen) > -1024 / 2)) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		identity_len = (userlen + domlen) * 2;
		identity = .Curl_cmalloc(identity_len);
		if (!identity) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.ascii_uppercase_to_unicode_le(identity, user, userlen);
		ModernizedCProgram.ascii_to_unicode_le(identity + (userlen << 1), domain, domlen);
		result = ModernizedCProgram.hmac_md5(ntlmhash, 16, identity, ModernizedCProgram.curlx_uztoui(identity_len), ntlmv2hash);
		.Curl_cfree(identity);
		return result/*
		 * Curl_ntlm_core_mk_ntlmv2_resp()
		 *
		 * This creates the NTLMv2 response as set in the ntlm type-3 message.
		 *
		 * Parameters:
		 *
		 * ntlmv2hash       [in] - The ntlmv2 hash (16 bytes)
		 * challenge_client [in] - The client nonce (8 bytes)
		 * ntlm             [in] - The ntlm data struct being used to read TargetInfo
		                           and Server challenge received in the type-2 message
		 * ntresp          [out] - The address where a pointer to newly allocated
		 *                         memory holding the NTLMv2 response.
		 * ntresp_len      [out] - The length of the output message.
		 *
		 * Returns CURLE_OK on success.
		 */;
	}
	public static  Curl_ntlm_core_mk_ntlmv2_resp(Object ntlmv2hash, Object challenge_client, Object ntlm, Object ntresp, Object ntresp_len) {
		int len = 0;
		byte ptr = ((Object)0);
		byte[] hmac_output = new byte[(true)];
		curl_off_t tw = new curl_off_t();
		CURLcode result = .CURLE_OK/* Calculate the timestamp */;
		tw = ((curl_off_t).time(((Object)0)) + -1024) * 10000000;
		len = (true) + (44 - 16 + ntlm.getTarget_info_len() + /* Calculate the response len */4);
		ptr = .Curl_ccalloc(1, /* Allocate the response */len);
		if (!ptr) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.curl_msnprintf((byte)ptr + (true), (44 - 16 + ntlm.getTarget_info_len() + /* Create the BLOB structure */4), /* NTLMv2_BLOB_SIGNATURE */"%c%c%c%c%c%c%c%c", "\x01\x01\x00\x00"[0], "\x01\x01\x00\x00"[/* Reserved = 0 */1], "\x01\x01\x00\x00"[2], "\x01\x01\x00\x00"[3], 0, 0, 0, 0);
		ModernizedCProgram.Curl_write64_le(tw, ptr + 24);
		.memcpy(ptr + 32, challenge_client, 8);
		.memcpy(ptr + 44, ntlm.getTarget_info(), ntlm.getTarget_info_len());
		.memcpy(ptr + 8, ntlm.getNonce()[0], /* Concatenate the Type 2 challenge with the BLOB and do HMAC MD5 */8);
		result = ModernizedCProgram.hmac_md5(ntlmv2hash, (true), ptr + 8, (44 - 16 + ntlm.getTarget_info_len() + 4) + 8, hmac_output);
		if (result) {
			.Curl_cfree(ptr);
			return result;
		} 
		.memcpy(ptr, hmac_output, (/* Concatenate the HMAC MD5 output  with the BLOB */true));
		ntresp = /* Return the response */ptr;
		ntresp_len = len;
		return result/*
		 * Curl_ntlm_core_mk_lmv2_resp()
		 *
		 * This creates the LMv2 response as used in the ntlm type-3 message.
		 *
		 * Parameters:
		 *
		 * ntlmv2hash        [in] - The ntlmv2 hash (16 bytes)
		 * challenge_client  [in] - The client nonce (8 bytes)
		 * challenge_client  [in] - The server challenge (8 bytes)
		 * lmresp           [out] - The LMv2 response (24 bytes)
		 *
		 * Returns CURLE_OK on success.
		 */;
	}
	public static  Curl_ntlm_core_mk_lmv2_resp(Object ntlmv2hash, Object challenge_client, Object challenge_server, Object lmresp) {
		byte[] data = new byte[16];
		byte[] hmac_output = new byte[16];
		CURLcode result = .CURLE_OK;
		.memcpy(data[0], challenge_server, 8);
		.memcpy(data[8], challenge_client, 8);
		result = ModernizedCProgram.hmac_md5(ntlmv2hash, 16, data[0], 16, hmac_output);
		if (result) {
			return result;
		} 
		.memcpy(lmresp, hmac_output, /* Concatenate the HMAC MD5 output  with the client nonce */16);
		.memcpy(lmresp + 16, challenge_client, 8);
		return result/* USE_NTLM_V2 && !USE_WINDOWS_SSPI *//* USE_NTRESPONSES *//* !USE_WINDOWS_SSPI || USE_WIN32_CRYPTO *//* USE_NTLM */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/*
	 * checkheaders() checks the linked list of custom headers for a
	 * particular header (prefix). Provide the prefix without colon!
	 *
	 * Returns a pointer to the first matching header or NULL if none matched.
	 */
	public static Object Curl_checkheaders(Object conn, Object thisheader) {
		curl_slist head = new curl_slist();
		size_t thislen = .strlen(thisheader);
		Curl_easy data = conn.getData();
		for (head = data.getSet().getHeaders(); head; head = head.getNext()) {
			if (ModernizedCProgram.Curl_strncasecompare(head.getData(), thisheader, thislen) && ((((head.getData()[thislen]) == (byte)':') || ((head.getData()[thislen]) == (byte)';')))) {
				return head.getData();
			} 
		}
		return ((Object)0);
	}
	public static  Curl_get_upload_buffer(Object data) {
		if (!data.getState().getUlbuf()) {
			data.getState().setUlbuf(.Curl_cmalloc(data.getSet().getUpload_buffer_size()));
			if (!data.getState().getUlbuf()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		return .CURLE_OK/*
		 * This function will be called to loop through the trailers buffer
		 * until no more data is available for sending.
		 *//*
		 * This function will be called to loop through the trailers buffer
		 * until no more data is available for sending.
		 */;
	}
	public static Object Curl_trailers_read(Object buffer, Object size, Object nitems, Object raw) {
		Curl_easy data = (Curl_easy)raw;
		Curl_send_buffer trailers_buf = data.getState().getTrailers_buf();
		size_t bytes_left = trailers_buf.getSize_used() - data.getState().getTrailers_bytes_sent();
		size_t to_copy = (size * nitems < bytes_left) ? size * nitems : bytes_left;
		if (to_copy) {
			.memcpy(buffer, trailers_buf.getBuffer()[data.getState().getTrailers_bytes_sent()], to_copy);
			data.getState().getTrailers_bytes_sent() += to_copy;
		} 
		return to_copy;
	}
	public static Object Curl_trailers_left(Object raw) {
		Curl_easy data = (Curl_easy)raw;
		Curl_send_buffer trailers_buf = data.getState().getTrailers_buf();
		return trailers_buf.getSize_used() - data.getState().getTrailers_bytes_sent();
	}
	public static  Curl_fillreadbuffer(Object conn, Object bytes, Object nreadp) {
		Curl_easy data = conn.getData();
		size_t buffersize = bytes;
		size_t nread = new size_t();
		curl_read_callback readfunc = ((Object)0);
		Object extra_data = ((Object)0);
		if (data.getState().getTrailers_state() == /* We're sending the HTTP request headers, not the data.
		         Remember that so we don't re-translate them into garbage. */.TRAILERS_INITIALIZED) {
			curl_slist trailers = ((Object)0);
			CURLcode result = new CURLcode();
			int trailers_ret_code;
			ModernizedCProgram.Curl_infof(/* at this point we already verified that the callback exists
			       so we compile and store the trailers buffer, then proceed */data, "Moving trailers state machine from initialized to sending.\n");
			data.getState().setTrailers_state(.TRAILERS_SENDING);
			data.getState().setTrailers_buf(ModernizedCProgram.Curl_add_buffer_init());
			if (!data.getState().getTrailers_buf()) {
				ModernizedCProgram.Curl_failf(data, "Unable to allocate trailing headers buffer !");
				return .CURLE_OUT_OF_MEMORY;
			} 
			data.getState().setTrailers_bytes_sent(0);
			ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
			trailers_ret_code = .UNRECOGNIZEDFUNCTIONNAME(trailers, data.getSet().getTrailer_data());
			ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
			if (trailers_ret_code == 0) {
				result = ModernizedCProgram.Curl_http_compile_trailers(trailers, data.getState().getTrailers_buf(), data);
			} else {
					ModernizedCProgram.Curl_failf(data, "operation aborted by trailing headers callback");
					nreadp = 0;
					result = .CURLE_ABORTED_BY_CALLBACK;
			} 
			if (result) {
				ModernizedCProgram.Curl_add_buffer_free(data.getState().getTrailers_buf());
				ModernizedCProgram.curl_slist_free_all(trailers);
				return result;
			} 
			ModernizedCProgram.Curl_infof(data, "Successfully compiled trailers.\r\n");
			ModernizedCProgram.curl_slist_free_all(trailers);
		} 
		if (data.getReq().getUpload_chunky() && data.getState().getTrailers_state() == .TRAILERS_NONE) {
			buffersize -= (8 + 2 + /* if chunked Transfer-Encoding *//* 32bit hex + CRLF + CRLF */2);
			data.getReq().getUpload_fromhere() += (8 + /* 32bit hex + CRLF */2);
		} 
		if (data.getState().getTrailers_state() == .TRAILERS_SENDING/* if we're here then that means that we already sent the last empty chunk
		       but we didn't send a final CR LF, so we sent 0 CR LF. We then start
		       pulling trailing data until we have no more at which point we
		       simply return to the previous point in the state machine as if
		       nothing happened.
		       */) {
			readfunc = Curl_trailers_read;
			extra_data = (Object)data;
		} else {
				readfunc = data.getState().getFread_func();
				extra_data = data.getState().getIn();
		} 
		ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
		nread = .readfunc(data.getReq().getUpload_fromhere(), 1, buffersize, extra_data);
		ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
		if (nread == -1024) {
			ModernizedCProgram.Curl_failf(data, "operation aborted by callback");
			nreadp = 0;
			return .CURLE_ABORTED_BY_CALLBACK;
		} 
		if (nread == -1024) {
			SingleRequest k = data.getReq();
			if (conn.getHandler().getFlags() & (1 << 4/* protocols that work without network cannot be paused. This is
			         actually only FILE:// just now, and it can't pause since the transfer
			         isn't done using the "normal" procedure. */)) {
				ModernizedCProgram.Curl_failf(data, "Read callback asked for PAUSE when not supported!");
				return .CURLE_READ_ERROR;
			} 
			k.getKeepon() |=  (1 << /* CURL_READFUNC_PAUSE pauses read callbacks that feed socket writes *//* mark socket send as paused */5);
			if (data.getReq().getUpload_chunky()) {
				data.getReq().getUpload_fromhere() -= (8 + /* Back out the preallocation done above */2);
			} 
			nreadp = 0;
			return /* nothing was read */.CURLE_OK;
		}  else if (nread > buffersize) {
			nreadp = /* the read function returned a too large value */0;
			ModernizedCProgram.Curl_failf(data, "read function returned funny value");
			return .CURLE_READ_ERROR;
		} 
		if (!data.getReq().getForbidchunk() && data.getReq().getUpload_chunky()) {
			bool added_crlf = 0;
			int hexlen = 0;
			byte endofline_native;
			byte endofline_network;
			if ((data.getSet().getCrlf())) {
				endofline_native = /* \n will become \r\n later on */"\n";
				endofline_network = "\x0a";
			} else {
					endofline_native = "\r\n";
					endofline_network = "\x0d\x0a";
			} 
			if (data.getState().getTrailers_state() != /* if we're not handling trailing data, proceed as usual */.TRAILERS_SENDING) {
				byte[] hexbuffer = "";
				hexlen = ModernizedCProgram.curl_msnprintf(hexbuffer, , "%zx%s", nread, endofline_native);
				data.getReq().getUpload_fromhere() -= /* move buffer pointer */hexlen;
				nread += hexlen;
				.memcpy(data.getReq().getUpload_fromhere(), hexbuffer, /* copy the prefix to the buffer, leaving out the NUL */hexlen/* always append ASCII CRLF to the data unless
				         we have a valid trailer callback */);
				if ((nread - hexlen) == 0 && data.getSet().getTrailer_callback() != ((Object)0) && data.getState().getTrailers_state() == .TRAILERS_NONE) {
					data.getState().setTrailers_state(.TRAILERS_INITIALIZED);
				} else {
						.memcpy(data.getReq().getUpload_fromhere() + nread, endofline_network, .strlen(endofline_network));
						added_crlf = 1/* translate the protocol and data *//* just translate the protocol portion */;
				} 
			} 
			if (data.getState().getTrailers_state() == /* Curl_convert_to_network calls failf if unsuccessful *//* CURL_DOES_CONVERSIONS */.TRAILERS_SENDING && !ModernizedCProgram.Curl_trailers_left(data)) {
				ModernizedCProgram.Curl_add_buffer_free(data.getState().getTrailers_buf());
				data.getState().setTrailers_state(.TRAILERS_DONE);
				data.getSet().setTrailer_data(((Object)0));
				data.getSet().setTrailer_callback(((Object)0));
				data.getReq().setUpload_done(/* mark the transfer as done */1);
				ModernizedCProgram.Curl_infof(data, "Signaling end of chunked upload after trailers.\n");
			}  else if ((nread - hexlen) == 0 && data.getState().getTrailers_state() != .TRAILERS_INITIALIZED) {
				data.getReq().setUpload_done(/* mark this as done once this chunk is transferred */1);
				ModernizedCProgram.Curl_infof(data, "Signaling end of chunked upload via terminating chunk.\n");
			} 
			if (added_crlf) {
				nread += .strlen(/* for the added end of line */endofline_network);
			} 
		} 
		nreadp = /* Curl_convert_to_network calls failf if unsuccessful *//* CURL_DOES_CONVERSIONS */nread;
		return .CURLE_OK/*
		 * Curl_readrewind() rewinds the read stream. This is typically used for HTTP
		 * POST/PUT with multi-pass authentication when a sending was denied and a
		 * resend is necessary.
		 */;
	}
	public static  Curl_readrewind(Object conn) {
		Curl_easy data = conn.getData();
		curl_mimepart mimepart = data.getSet().getMimepost();
		conn.getBits().setRewindaftersend(/* we rewind now */0/* explicitly switch off sending data on this connection now since we are
		     about to restart a new transfer and thus we want to avoid inadvertently
		     sending more data on the existing connection until the next transfer
		     starts */);
		data.getReq().getKeepon() &=  ~(1 << 1/* We have sent away data. If not using CURLOPT_POSTFIELDS or
		     CURLOPT_HTTPPOST, call app to rewind
		  */);
		if (conn.getHandler().getProtocol() & ((1 << 0) | (1 << 1))) {
			HTTP http = data.getReq().getProtop();
			if (http.getSendit()) {
				mimepart = http.getSendit();
			} 
		} 
		if (data.getSet().getPostfields()) {
			;
		}  else if (data.getSet().getHttpreq() == .HTTPREQ_POST_MIME || data.getSet().getHttpreq() == .HTTPREQ_POST_FORM) {
			if (ModernizedCProgram.Curl_mime_rewind(mimepart)) {
				ModernizedCProgram.Curl_failf(data, "Cannot rewind mime/post data");
				return .CURLE_SEND_FAIL_REWIND;
			} 
		} else {
				if (data.getSet().getSeek_func()) {
					int err;
					ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
					err = .UNRECOGNIZEDFUNCTIONNAME(data.getSet().getSeek_client(), 0, 0);
					ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
					if (err) {
						ModernizedCProgram.Curl_failf(data, "seek callback returned error %d", (int)err);
						return .CURLE_SEND_FAIL_REWIND;
					} 
				}  else if (data.getSet().getIoctl_func()) {
					curlioerr err = new curlioerr();
					ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
					err = .UNRECOGNIZEDFUNCTIONNAME(data, .CURLIOCMD_RESTARTREAD, data.getSet().getIoctl_client());
					ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
					ModernizedCProgram.Curl_infof(data, "the ioctl callback returned %d\n", (int)err);
					if (err) {
						ModernizedCProgram.Curl_failf(data, "ioctl callback returned error %d", (int)err);
						return .CURLE_SEND_FAIL_REWIND;
					} 
				} else {
						if (data.getState().getFread_func() == (curl_read_callback)/* If no CURLOPT_READFUNCTION is used, we know that we operate on a
						         given FILE * stream and we can actually attempt to rewind that
						         ourselves with fseek() */fread) {
							if (-1 != .fseek(data.getState().getIn(), 0, 0)) {
								return /* successful rewind */.CURLE_OK;
							} 
						} 
						ModernizedCProgram.Curl_failf(data, /* no callback set or failure above, makes us fail at once */"necessary data rewind wasn't possible");
						return .CURLE_SEND_FAIL_REWIND;
				} 
		} 
		return .CURLE_OK;
	}
	public static int data_pending(Object conn) {
		return conn.getHandler().getProtocol() & ((1 << 4) | (1 << /* in the case of libssh2, we can never be really sure that we have emptied
		     its internal buffers so we MUST always try until we get EAGAIN back */5/* For HTTP/2, we may read up everything including response body
		       with header fields in Curl_http_readwrite_headers. If no
		       content-length is provided, curl waits for the connection
		       close, which we emulate it using conn->proto.httpc.closed =
		       TRUE. The thing is if we read everything, then http2_recv won't
		       be called and we cannot signal the HTTP/2 stream has closed. As
		       a workaround, we return nonzero here to call http2_recv. */)) || false/*
		 * Check to see if CURLOPT_TIMECONDITION was met by comparing the time of the
		 * remote document with the time provided by CURLOPT_TIMEVAL
		 */;
	}
	public static  Curl_meets_timecondition(Object data, Object timeofdoc) {
		if ((timeofdoc == 0) || (data.getSet().getTimevalue() == 0)) {
			return 1;
		} 
		switch (data.getSet().getTimecondition()) {
		case .CURL_TIMECOND_IFUNMODSINCE:
				if (timeofdoc >= data.getSet().getTimevalue()) {
					ModernizedCProgram.Curl_infof(data, "The requested document is not old enough\n");
					data.getInfo().setTimecond(1);
					return 0;
				} 
				break;
		case .CURL_TIMECOND_IFMODSINCE:
		default:
				if (timeofdoc <= data.getSet().getTimevalue()) {
					ModernizedCProgram.Curl_infof(data, "The requested document is not new enough\n");
					data.getInfo().setTimecond(1);
					return 0;
				} 
				break;
		}
		return 1/*
		 * Go ahead and do a read if we have a readable socket or if
		 * the stream was rewound (in which case we have data in a
		 * buffer)
		 *
		 * return '*comeback' TRUE if we didn't properly drain the socket so this
		 * function should get called again without select() or similar in between!
		 */;
	}
	public static  readwrite_data(Object data, Object conn, Object k, Object didwhat, Object done, Object comeback) {
		CURLcode result = .CURLE_OK;
		/* number of bytes read */ssize_t nread = new ssize_t();
		size_t excess = /* excess bytes read */0;
		bool readmore = /* used by RTP to signal for more data */0;
		int maxloops = 100;
		done = 0;
		comeback = 0/* This is where we loop until we have read everything there is to
		     read or we get a CURLE_AGAIN */;
		curltime curltime = new curltime();
		do {
			bool is_empty_data = 0;
			size_t buffersize = data.getSet().getBuffer_size();
			size_t bytestoread = buffersize;
			if (k.getSize() != -1 && !k.getHeader()) {
				curl_off_t totalleft = k.getSize() - k.getBytecount();
				if (totalleft < (curl_off_t)bytestoread) {
					bytestoread = (size_t)totalleft;
				} 
			} 
			if (bytestoread) {
				result = ModernizedCProgram.Curl_read(conn, conn.getSockfd(), k.getBuf(), bytestoread, /* receive data from the network! */nread);
				if (.CURLE_AGAIN == /* read would've blocked */result) {
					break;
				} 
				if (result > 0) {
					return result;
				} 
			} else {
					do {
					} while (/* read nothing but since we wanted nothing we consider this an OK
					         situation to proceed from */0);
					nread = 0;
			} 
			if (!k.getBytecount()) {
				ModernizedCProgram.Curl_pgrsTime(data, .TIMER_STARTTRANSFER);
				if (k.getExp100() > expect100.EXP100_SEND_DATA) {
					k.setStart100(curltime.Curl_now());
				} 
			} 
			didwhat |=  (1 << 0);
			is_empty_data = ((nread == 0) && (k.getBodywrites() == 0)) ? 1 : /* indicates data of zero size, i.e. empty file */0;
			if (0 < nread || /* NUL terminate, allowing string ops to be used */is_empty_data) {
				k.getBuf()[nread] = 0;
			} else {
					do {
					} while (/* if we receive 0 or less here, the server closed the connection
					         and we bail out from this! */0);
					k.getKeepon() &=  ~(1 << 0);
					break;
			} 
			k.setStr(k.getBuf());
			if (conn.getHandler().getReadwrite()) {
				result = .UNRECOGNIZEDFUNCTIONNAME(data, conn, nread, readmore);
				if (result) {
					return result;
				} 
				if (readmore) {
					break;
				} 
			} 
			if (k.getHeader()) {
				bool stop_reading = /* we are in parse-the-header-mode */0;
				result = ModernizedCProgram.Curl_http_readwrite_headers(data, conn, nread, stop_reading);
				if (result) {
					return result;
				} 
				if (conn.getHandler().getReadwrite() && (k.getMaxdownload() <= 0 && nread > 0)) {
					result = .UNRECOGNIZEDFUNCTIONNAME(data, conn, nread, readmore);
					if (result) {
						return result;
					} 
					if (readmore) {
						break;
					} 
				} 
				if (stop_reading/* We've stopped dealing with input, get out of the do-while loop */) {
					if (nread > 0) {
						ModernizedCProgram.Curl_infof(data, "Excess found: excess = %zd url = %s (zero-length body)\n", nread, data.getState().getUp().getPath());
					} 
					break;
				} 
			} 
			if (k.getStr() && !k.getHeader() && (nread > 0 || /* This is not an 'else if' since it may be a rest from the header
			       parsing, where the beginning of the buffer is headers and the end
			       is non-headers. */is_empty_data)) {
				if (data.getSet().getOpt_no_body()) {
					ModernizedCProgram.Curl_conncontrol(conn, /* data arrives although we want none, bail out */2);
					done = 1;
					return .CURLE_WEIRD_SERVER_REPLY;
				} 
				if (0 == k.getBodywrites() && !is_empty_data/* These checks are only made the first time we are about to
				           write a piece of the body */) {
					if (conn.getHandler().getProtocol() & (((1 << 0) | (1 << 1)) | (1 << 18/* HTTP-only checks */))) {
						if (data.getReq().getNewurl()) {
							if (conn.getBits().getClose()) {
								k.getKeepon() &=  ~(1 << 0);
								done = 1;
								return .CURLE_OK/* We have a new url to load, but since we want to be able
								               to re-use this connection properly, we read the full
								               response in "ignore more" */;
							} 
							k.setIgnorebody(1);
							ModernizedCProgram.Curl_infof(data, "Ignoring the response-body\n");
						} 
						if (data.getState().getResume_from() && !k.getContent_range() && (data.getSet().getHttpreq() == .HTTPREQ_GET) && !k.getIgnorebody()) {
							if (k.getSize() == data.getState().getResume_from()) {
								ModernizedCProgram.Curl_infof(data, "The entire document is already downloaded");
								ModernizedCProgram.Curl_conncontrol(conn, 1);
								k.getKeepon() &=  ~(1 << /* Abort download */0);
								done = 1;
								return .CURLE_OK;
							} 
							ModernizedCProgram.Curl_failf(data, /* we wanted to resume a download, although the server doesn't
							             * seem to support this and we did this with a GET (if it
							             * wasn't a GET we did a POST or PUT resume) */"HTTP server doesn't seem to support byte ranges. Cannot resume.");
							return .CURLE_RANGE_ERROR;
						} 
						if (data.getSet().getTimecondition() && !data.getState().getRange()) {
							if (!ModernizedCProgram.Curl_meets_timecondition(data, k.getTimeofdoc())) {
								done = 1/* We're simulating a http 304 from server so we return
								                 what should have been returned from the server */;
								data.getInfo().setHttpcode(304);
								ModernizedCProgram.Curl_infof(data, "Simulate a HTTP 304 response!\n"/* we abort the transfer before it is completed == we ruin the
								                 re-use ability. Close the connection */);
								ModernizedCProgram.Curl_conncontrol(conn, 1);
								return .CURLE_OK/* we have a time condition */;
							} 
						} 
					} 
				} 
				k.getBodywrites()++;
				if (data.getSet().getVerbose()) {
					if (k.getBadheader()) {
						ModernizedCProgram.Curl_debug(data, .CURLINFO_DATA_IN, data.getState().getHeaderbuff(), (size_t)k.getHbuflen());
						if (k.getBadheader() == .HEADER_PARTHEADER) {
							ModernizedCProgram.Curl_debug(data, .CURLINFO_DATA_IN, k.getStr(), (size_t)nread);
						} 
					} else {
							ModernizedCProgram.Curl_debug(data, .CURLINFO_DATA_IN, k.getStr(), (size_t)nread);
					} 
				} 
				if (k.getChunk()) {
					CURLcode extra = new CURLcode();
					CHUNKcode res = ModernizedCProgram.Curl_httpchunk_read(conn, k.getStr(), nread, nread, extra);
					if (.CHUNKE_OK < res) {
						if (.CHUNKE_PASSTHRU_ERROR == res) {
							ModernizedCProgram.Curl_failf(data, "Failed reading the chunked-encoded stream");
							return extra;
						} 
						ModernizedCProgram.Curl_failf(data, "%s in chunked-encoding", ModernizedCProgram.Curl_chunked_strerror(res));
						return .CURLE_RECV_ERROR;
					} 
					if (.CHUNKE_STOP == res) {
						size_t dataleft = new size_t();
						k.getKeepon() &=  ~(1 << /* we're done reading chunks! *//* read no more */0/* There are now possibly N number of bytes at the end of the
						             str buffer that weren't written to the client.
						             Push it back to be read on the next pass. */);
						dataleft = conn.getChunk().getDataleft();
						if (dataleft != 0) {
							ModernizedCProgram.Curl_infof(conn.getData(), "Leftovers after chunking: %zu bytes\n", dataleft/* If it returned OK, we just keep going */);
						} 
					} 
				} 
				if ((k.getBadheader() == .HEADER_PARTHEADER) && !k.getIgnorebody()) {
					do {
					} while (0);
					k.getBytecount() += k.getHbuflen();
				} 
				if ((-1 != k.getMaxdownload()) && (k.getBytecount() + nread >= k.getMaxdownload())) {
					excess = (size_t)(k.getBytecount() + nread - k.getMaxdownload());
					if (excess > 0 && !k.getIgnorebody()) {
						ModernizedCProgram.Curl_infof(data, "Excess found in a read: excess = %zu, size = %I64d, maxdownload = %I64d, bytecount = %I64d\n", excess, k.getSize(), k.getMaxdownload(), k.getBytecount());
					} 
					nread = (ssize_t)(k.getMaxdownload() - k.getBytecount());
					if (nread < /* this should be unusual */0) {
						nread = 0;
					} 
					k.getKeepon() &=  ~(1 << /* we're done reading */0);
				} 
				k.getBytecount() += nread;
				ModernizedCProgram.Curl_pgrsSetDownloadCounter(data, k.getBytecount());
				if (!k.getChunk() && (nread || k.getBadheader() || is_empty_data/* If this is chunky transfer, it was already written */)) {
					if (k.getBadheader() && !k.getIgnorebody()) {
						if (k.getMaxdownload() == -1 || (curl_off_t)k.getHbuflen() <= k.getMaxdownload()) {
							result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), data.getState().getHeaderbuff(), k.getHbuflen());
						} else {
								result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), data.getState().getHeaderbuff(), (size_t)k.getMaxdownload());
						} 
						if (result) {
							return result;
						} 
					} 
					if (k.getBadheader() < .HEADER_ALLBAD/* This switch handles various content encodings. If there's an
					             error here, be sure to check over the almost identical code
					             in http_chunks.c.
					             Make sure that ALL_CONTENT_ENCODINGS contains all the
					             encodings handled here. */) {
						if (conn.getData().getSet().getHttp_ce_skip() || !k.getWriter_stack()) {
							if (!k.getIgnorebody()) {
								if (conn.getHandler().getProtocol() & ((1 << 14) | (1 << 15))) {
									result = ModernizedCProgram.Curl_pop3_write(conn, k.getStr(), nread);
								} else {
										result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), k.getStr(), nread);
								} 
							} 
						}  else if (!k.getIgnorebody()) {
							result = ModernizedCProgram.Curl_unencode_write(conn, k.getWriter_stack(), k.getStr(), nread);
						} 
					} 
					k.setBadheader(/* taken care of now */.HEADER_NORMAL);
					if (result) {
						return result;
					} 
				} 
			} 
			if (conn.getHandler().getReadwrite() && excess && !conn.getBits().getStream_was_rewound()) {
				k.getStr() += /* Parse the excess data */nread;
				if (k.getStr()[excess] > k.getBuf()[data.getSet().getBuffer_size()]) {
					excess = k.getBuf()[data.getSet().getBuffer_size()] - k.getStr();
				} 
				nread = (ssize_t)excess;
				result = .UNRECOGNIZEDFUNCTIONNAME(data, conn, nread, readmore);
				if (result) {
					return result;
				} 
				if (readmore) {
					k.getKeepon() |=  (1 << /* we're not done reading */0);
				} 
				break;
			} 
			if (is_empty_data/* if we received nothing, the server closed the connection and we
			         are done */) {
				k.getKeepon() &=  ~(1 << 0);
			} 
			if (k.getKeepon() & (1 << 4/* this is a paused transfer */)) {
				break;
			} 
		} while (ModernizedCProgram.data_pending(conn) && maxloops--);
		if (maxloops <= 0) {
			conn.setCselect_bits(/* we mark it as read-again-please */-1024);
			comeback = 1;
		} 
		if (((k.getKeepon() & ((1 << 0) | (1 << 1))) == (1 << 1)) && conn.getBits().getClose()) {
			ModernizedCProgram.Curl_infof(data, "we are done reading and this is set to close, stop send\n");
			k.getKeepon() &=  ~(1 << /* no writing anymore either */1);
		} 
		return .CURLE_OK;
	}
	public static  Curl_done_sending(Object conn, Object k) {
		k.getKeepon() &=  ~(1 << /* we're done writing */1);
		/* These functions should be moved into the handler struct! */;
		;
		if (conn.getBits().getRewindaftersend()) {
			CURLcode result = ModernizedCProgram.Curl_readrewind(conn);
			if (result) {
				return result;
			} 
		} 
		return .CURLE_OK;
	}
	public static void win_update_buffer_size(Object sockfd) {
		int result;
		ULONG ideal = new ULONG();
		DWORD ideallen = new DWORD();
		result = .WSAIoctl(sockfd, -1024, 0, 0, ideal, , ideallen, 0, 0);
		if (result == 0) {
			.setsockopt(sockfd, -1024, -1024, (byte)ideal, );
		} 
	}
	/*
	 * Send data to upload to the server, when the socket is writable.
	 */
	public static  readwrite_upload(Object data, Object conn, Object didwhat) {
		ssize_t i = new ssize_t();
		ssize_t si = new ssize_t();
		ssize_t bytes_written = new ssize_t();
		CURLcode result = new CURLcode();
		/* number of bytes read */ssize_t nread = new ssize_t();
		bool sending_http_headers = 0;
		SingleRequest k = data.getReq();
		if ((k.getBytecount() == 0) && (k.getWritebytecount() == 0)) {
			ModernizedCProgram.Curl_pgrsTime(data, .TIMER_STARTTRANSFER);
		} 
		didwhat |=  (1 << 1);
		curltime curltime = new curltime();
		do {
			if (0 == k.getUpload_present()) {
				result = ModernizedCProgram.Curl_get_upload_buffer(data);
				if (result) {
					return result;
				} 
				k.setUpload_fromhere(data.getState().getUlbuf());
				if (!k.getUpload_done()) {
					size_t fillcount = new size_t();
					HTTP http = k.getProtop();
					if ((k.getExp100() == expect100.EXP100_SENDING_REQUEST) && (http.getSending() == .HTTPSEND_BODY/* If this call is to send body data, we must take some action:
					             We have sent off the full HTTP 1.1 request, and we shall now
					             go into the Expect: 100 state and await such a header */)) {
						k.setExp100(/* wait for the header */expect100.EXP100_AWAITING_CONTINUE);
						k.getKeepon() &=  ~(1 << /* disable writing */1);
						k.setStart100(curltime.Curl_now());
						didwhat &=  ~(1 << /* we didn't write anything actually */1);
						ModernizedCProgram.Curl_expire(data, data.getSet().getExpect_100_timeout(), /* set a timeout for the multi interface */.EXPIRE_100_TIMEOUT);
						break;
					} 
					if (conn.getHandler().getProtocol() & (((1 << 0) | (1 << 1)) | (1 << 18))) {
						if (http.getSending() == .HTTPSEND_REQUEST/* We're sending the HTTP request headers, not the data.
						               Remember that so we don't change the line endings. */) {
							sending_http_headers = 1;
						} else {
								sending_http_headers = 0;
						} 
					} 
					result = ModernizedCProgram.Curl_fillreadbuffer(conn, data.getSet().getUpload_buffer_size(), fillcount);
					if (result) {
						return result;
					} 
					nread = fillcount;
				} else {
						nread = /* we're done uploading/reading */0;
				} 
				if (!nread && (k.getKeepon() & (1 << 5/* this is a paused transfer */))) {
					break;
				} 
				if (nread <= 0) {
					result = ModernizedCProgram.Curl_done_sending(conn, k);
					if (result) {
						return result;
					} 
					break;
				} 
				k.setUpload_present(/* store number of bytes available for upload */nread);
				if ((!sending_http_headers) && /* convert LF to CRLF if so asked */((data.getSet().getCrlf()))/* always convert if we're FTPing in ASCII mode */) {
					if (!data.getState().getScratch()) {
						data.getState().setScratch(.Curl_cmalloc(2 * data.getSet().getUpload_buffer_size()));
						if (!data.getState().getScratch()) {
							ModernizedCProgram.Curl_failf(data, "Failed to alloc scratch buffer!");
							return .CURLE_OUT_OF_MEMORY/*
							         * ASCII/EBCDIC Note: This is presumably a text (not binary)
							         * transfer so the data should already be in ASCII.
							         * That means the hex values for ASCII CR (0x0d) & LF (0x0a)
							         * must be used instead of the escape sequences \r & \n.
							         */;
						} 
					} 
					for (; i < nread; ) {
						if (k.getUpload_fromhere()[i] == -1024) {
							data.getState().getScratch()[si++] = -1024;
							data.getState().getScratch()[si] = -1024;
							if (!data.getSet().getCrlf()) {
								if (data.getState().getInfilesize() != -1) {
									data.getState().getInfilesize()++;
								} 
							} 
						} else {
								data.getState().getScratch()[si] = k.getUpload_fromhere()[i];
						} 
					}
					if (si != nread/* only perform the special operation if we really did replace
					             anything */) {
						nread = si;
						k.setUpload_fromhere(data.getState().getScratch());
						k.setUpload_present(/* set the new amount too */nread);
					} 
				} 
				if (conn.getHandler().getProtocol() & ((1 << 16) | (1 << 17))) {
					result = ModernizedCProgram.Curl_smtp_escape_eob(conn, nread);
					if (result) {
						return result/* CURL_DISABLE_SMTP *//* if 0 == k->upload_present */;
					} 
				} 
			} 
			result = ModernizedCProgram.Curl_write(/* We have a partial buffer left from a previous "round". Use
			         that instead of reading more data *//* write to socket (send away data) */conn, conn.getWritesockfd(), k.getUpload_fromhere(), k.getUpload_present(), /* actually sent */bytes_written);
			if (result) {
				return result;
			} 
			ModernizedCProgram.win_update_buffer_size(conn.getWritesockfd());
			if (data.getSet().getVerbose()) {
				ModernizedCProgram.Curl_debug(data, .CURLINFO_DATA_OUT, k.getUpload_fromhere(), (size_t)bytes_written);
			} 
			k.getWritebytecount() += bytes_written;
			ModernizedCProgram.Curl_pgrsSetUploadCounter(data, k.getWritebytecount());
			if ((!k.getUpload_chunky() || k.getForbidchunk()) && (k.getWritebytecount() == data.getState().getInfilesize())) {
				k.setUpload_done(/* we have sent all data we were supposed to */1);
				ModernizedCProgram.Curl_infof(data, "We are completely uploaded and fine\n");
			} 
			if (k.getUpload_present() != bytes_written/* we only wrote a part of the buffer (if anything), deal with it! */) {
				k.getUpload_present() -= /* store the amount of bytes left in the buffer to write */bytes_written;
				k.getUpload_fromhere() += /* advance the pointer where to find the buffer when the next send
				         is to happen */bytes_written;
			} else {
					result = ModernizedCProgram.Curl_get_upload_buffer(/* we've uploaded that buffer now */data);
					if (result) {
						return result;
					} 
					k.setUpload_fromhere(data.getState().getUlbuf());
					k.setUpload_present(/* no more bytes left */0);
					if (k.getUpload_done()) {
						result = ModernizedCProgram.Curl_done_sending(conn, k);
						if (result) {
							return result;
						} 
					} 
			} 
		} while (/* just to break out from! */0);/* only read more data if there's no upload data already
		       present in the upload buffer */
		return .CURLE_OK/*
		 * Curl_readwrite() is the low-level function to be called when data is to
		 * be read and written to/from the connection.
		 *
		 * return '*comeback' TRUE if we didn't properly drain the socket so this
		 * function should get called again without select() or similar in between!
		 */;
	}
	public static  Curl_readwrite(Object conn, Object data, Object done, Object comeback) {
		SingleRequest k = data.getReq();
		CURLcode result = new CURLcode();
		int didwhat = 0;
		curl_socket_t fd_read = new curl_socket_t();
		curl_socket_t fd_write = new curl_socket_t();
		int select_res = conn.getCselect_bits();
		conn.setCselect_bits(0/* only use the proper socket if the *_HOLD bit is not set simultaneously as
		     then we are in rate limiting state in that transfer direction */);
		if ((k.getKeepon() & ((1 << 0) | (1 << 2) | (1 << 4))) == (1 << 0)) {
			fd_read = conn.getSockfd();
		} else {
				fd_read = (SOCKET)(~0);
		} 
		if ((k.getKeepon() & ((1 << 1) | (1 << 3) | (1 << 5))) == (1 << 1)) {
			fd_write = conn.getWritesockfd();
		} else {
				fd_write = (SOCKET)(~0);
		} 
		if (conn.getData().getState().getDrain()) {
			select_res |=  -1024;
			do {
			} while (0);
		} 
		if (!/* Call for select()/poll() only, if read/write/error
		                     status is not known. */select_res) {
			select_res = ModernizedCProgram.Curl_socket_check(fd_read, (SOCKET)(~0), fd_write, 0);
		} 
		if (select_res == -1024) {
			ModernizedCProgram.Curl_failf(data, "select/poll returned error");
			return .CURLE_SEND_ERROR;
		} 
		if ((k.getKeepon() & (1 << /* We go ahead and do a read if we have a readable socket or if
		     the stream was rewound (in which case we have data in a
		     buffer) */0)) && ((select_res & -1024) || conn.getBits().getStream_was_rewound())) {
			result = ModernizedCProgram.readwrite_data(data, conn, k, didwhat, done, comeback);
			if (result || done) {
				return result;
			} 
		} 
		if ((k.getKeepon() & (1 << 1)) && (select_res & /* If we still have writing to do, we check if we have a writable socket. */-1024/* write */)) {
			result = ModernizedCProgram.readwrite_upload(data, conn, didwhat);
			if (result) {
				return result;
			} 
		} 
		curltime curltime = new curltime();
		k.setNow(curltime.Curl_now());
		if (didwhat) {
			;
		} else {
				if (k.getExp100() == /* no read no write, this is a timeout? */expect100.EXP100_AWAITING_CONTINUE/* This should allow some time for the header to arrive, but only a
				         very short time as otherwise it'll be too much wasted time too
				         often. *//* Quoting RFC2616, section "8.2.3 Use of the 100 (Continue) Status":
				
				         Therefore, when a client sends this header field to an origin server
				         (possibly via a proxy) from which it has never seen a 100 (Continue)
				         status, the client SHOULD NOT wait for an indefinite period before
				         sending the request body.
				
				      */) {
					timediff_t ms = k.getNow().Curl_timediff(k.getStart100());
					if (ms >= data.getSet().getExpect_100_timeout()) {
						k.setExp100(/* we've waited long enough, continue anyway */expect100.EXP100_SEND_DATA);
						k.getKeepon() |=  (1 << 1);
						ModernizedCProgram.Curl_expire_done(data, .EXPIRE_100_TIMEOUT);
						ModernizedCProgram.Curl_infof(data, "Done waiting for 100-continue\n");
					} 
				} 
		} 
		if (ModernizedCProgram.Curl_pgrsUpdate(conn)) {
			result = .CURLE_ABORTED_BY_CALLBACK;
		} else {
				result = k.getNow().Curl_speedcheck(data);
		} 
		if (result) {
			return result;
		} 
		if (k.getKeepon()) {
			if (0 > ModernizedCProgram.Curl_timeleft(data, k.getNow(), 0)) {
				if (k.getSize() != -1) {
					ModernizedCProgram.Curl_failf(data, "Operation timed out after %I64d milliseconds with %I64d out of %I64d bytes received", k.getNow().Curl_timediff(data.getProgress().getT_startsingle()), k.getBytecount(), k.getSize());
				} else {
						ModernizedCProgram.Curl_failf(data, "Operation timed out after %I64d milliseconds with %I64d bytes received", k.getNow().Curl_timediff(data.getProgress().getT_startsingle()), k.getBytecount());
				} 
				return .CURLE_OPERATION_TIMEDOUT/*
				     * The transfer has been performed. Just make some general checks before
				     * returning.
				     */;
			} 
		} else {
				if (!(data.getSet().getOpt_no_body()) && (k.getSize() != -1) && (k.getBytecount() != k.getSize()) && !k.getNewurl()) {
					ModernizedCProgram.Curl_failf(data, "transfer closed with %I64d bytes remaining to read", k.getSize() - k.getBytecount());
					return .CURLE_PARTIAL_FILE;
				} 
				if (!(data.getSet().getOpt_no_body()) && k.getChunk() && (conn.getChunk().getState() != .CHUNK_STOP/*
				       * In chunked mode, return an error if the connection is closed prior to
				       * the empty (terminating) chunk is read.
				       *
				       * The condition above used to check for
				       * conn->proto.http->chunk.datasize != 0 which is true after reading
				       * *any* chunk, not just the empty chunk.
				       *
				       */)) {
					ModernizedCProgram.Curl_failf(data, "transfer closed with outstanding read data remaining");
					return .CURLE_PARTIAL_FILE;
				} 
				if (ModernizedCProgram.Curl_pgrsUpdate(conn)) {
					return .CURLE_ABORTED_BY_CALLBACK;
				} 
		} 
		done = (0 == (k.getKeepon() & ((1 << 0) | (1 << /* Now update the "done" boolean we return */1) | (1 << 4) | (1 << 5)))) ? 1 : 0;
		return .CURLE_OK/*
		 * Curl_single_getsock() gets called by the multi interface code when the app
		 * has requested to get the sockets for the current connection. This function
		 * will then be called once for every connection that the multi interface
		 * keeps track of. This function will only be called for connections that are
		 * in the proper state to have this information available.
		 */;
	}
	public static int Curl_single_getsock(Object conn, Object sock) {
		Curl_easy data = conn.getData();
		int bitmap = 0;
		int sockindex = 0;
		if (conn.getHandler().getPerform_getsock()) {
			return .UNRECOGNIZEDFUNCTIONNAME(conn, sock);
		} 
		if ((data.getReq().getKeepon() & ((1 << 0) | (1 << 2) | (1 << 4))) == (1 << /* don't include HOLD and PAUSE connections */0)) {
			do {
			} while (0);
			bitmap |=  (1 << (sockindex));
			sock[sockindex] = conn.getSockfd();
		} 
		if ((data.getReq().getKeepon() & ((1 << 1) | (1 << 3) | (1 << 5))) == (1 << /* don't include HOLD and PAUSE connections */1)) {
			if ((conn.getSockfd() != conn.getWritesockfd()) || bitmap == 0/* only if they are not the same socket and we have a readable
			         one, we increase index */) {
				if (bitmap != 0) {
					/* increase index if we need two entries */sockindex++;
				} 
				do {
				} while (0);
				sock[sockindex] = conn.getWritesockfd();
			} 
			bitmap |=  (1 << (16 + (sockindex)));
		} 
		return bitmap;
	}
	/* Curl_init_CONNECT() gets called each time the handle switches to CONNECT
	   which means this gets called once for each subsequent redirect etc */
	public static void Curl_init_CONNECT(Object data) {
		data.getState().setFread_func(data.getSet().getFread_func_set());
		data.getState().setIn(data.getSet().getIn_set());
	}
	public static  Curl_pretransfer(Object data) {
		CURLcode result = new CURLcode();
		if (!data.getChange().getUrl() && !data.getSet().getUh()) {
			ModernizedCProgram.Curl_failf(data, /* we can't do anything without URL */"No URL set!");
			return .CURLE_URL_MALFORMAT;
		} 
		if (data.getChange().getUrl_alloc()) {
			do {
				.Curl_cfree((data.getChange().getUrl()));
				(data.getChange().getUrl()) = ((Object)0);
			} while (/* the already set URL is allocated, free it first! */0);
			data.getChange().setUrl_alloc(0);
		} 
		if (!data.getChange().getUrl() && data.getSet().getUh()) {
			CURLUcode uc = new CURLUcode();
			uc = ModernizedCProgram.curl_url_get(data.getSet().getUh(), .CURLUPART_URL, data.getSet().getStr()[dupstring.STRING_SET_URL], 0);
			if (uc) {
				ModernizedCProgram.Curl_failf(data, "No URL set!");
				return .CURLE_URL_MALFORMAT;
			} 
		} 
		data.getChange().setUrl(data.getSet().getStr()[dupstring.STRING_SET_URL/* Init the SSL session ID cache here. We do it here since we want to do it
		     after the *_setopt() calls (that could specify the size of the cache) but
		     before any transfer takes place. */]);
		result = .CURLE_OK;
		if (result) {
			return result;
		} 
		data.getState().setWildcardmatch(data.getSet().getWildcard_enabled());
		data.getSet().setFollowlocation(/* reset the location-follow counter */0);
		data.getState().setThis_is_a_follow(/* reset this */0);
		data.getState().setErrorbuf(/* no error has occurred */0);
		data.getState().setHttpversion(/* don't assume any particular server version */0);
		data.getState().setAuthproblem(0);
		data.getState().getAuthhost().setWant(data.getSet().getHttpauth());
		data.getState().getAuthproxy().setWant(data.getSet().getProxyauth());
		do {
			.Curl_cfree((data.getInfo().getWouldredirect()));
			(data.getInfo().getWouldredirect()) = ((Object)0);
		} while (0);
		data.getInfo().setWouldredirect(((Object)0));
		if (data.getSet().getHttpreq() == .HTTPREQ_PUT) {
			data.getState().setInfilesize(data.getSet().getFilesize());
		}  else if ((data.getSet().getHttpreq() != .HTTPREQ_GET) && (data.getSet().getHttpreq() != .HTTPREQ_HEAD)) {
			data.getState().setInfilesize(data.getSet().getPostfieldsize());
			if (data.getSet().getPostfields() && (data.getState().getInfilesize() == -1)) {
				data.getState().setInfilesize((curl_off_t).strlen(data.getSet().getPostfields()));
			} 
		} else {
				data.getState().setInfilesize(0);
		} 
		if (data.getChange().getCookielist()) {
			ModernizedCProgram.Curl_cookie_loadfiles(data);
		} 
		if (data.getChange().getResolve()) {
			result = ModernizedCProgram.Curl_loadhostpairs(data);
		} 
		if (!result/* Allow data->set.use_port to set which port to use. This needs to be
		     * disabled for example when we follow Location: headers to URLs using
		     * different ports! */) {
			data.getState().setAllow_port(1/*************************************************************
			     * Tell signal handler to ignore SIGPIPE
			     *************************************************************/);
			ModernizedCProgram.Curl_initinfo(/* reset session-specific information "variables" */data);
			ModernizedCProgram.Curl_pgrsResetTransferSizes(data);
			ModernizedCProgram.Curl_pgrsStartNow(data/* In case the handle is re-used and an authentication method was picked
			       in the session we need to make sure we only use the one(s) we now
			       consider to be fine */);
			data.getState().getAuthhost().getPicked() &=  data.getState().getAuthhost().getWant();
			data.getState().getAuthproxy().getPicked() &=  data.getState().getAuthproxy().getWant();
			if (data.getState().getWildcardmatch()) {
				WildcardData wc = data.getWildcard();
				if (wc.getState() < .CURLWC_INIT) {
					result = ModernizedCProgram.Curl_wildcard_init(/* init wildcard structures */wc);
					if (result) {
						return .CURLE_OUT_OF_MEMORY;
					} 
				} 
			} 
			;
		} 
		return result/*
		 * Curl_posttransfer() is called immediately after a transfer ends
		 */;
	}
	public static  Curl_posttransfer(Object data) {
		(Object)/* unused parameter */data;
		return .CURLE_OK/*
		 * Curl_follow() handles the URL redirect magic. Pass in the 'newurl' string
		 * as given by the remote server and set up the new URL to request.
		 *
		 * This function DOES NOT FREE the given url.
		 */;
	}
	/* restore the signal handler for SIGPIPE before we get back */
	public static  Curl_follow(Object data, Object newurl,  type) {
		bool disallowport = /* Location: following will not happen when HTTP is disabled *//* Location: redirect */0;
		bool reachedmax = 0;
		CURLUcode uc = new CURLUcode();
		if (type == .FOLLOW_REDIR) {
			if ((data.getSet().getMaxredirs() != -1) && (data.getSet().getFollowlocation() >= data.getSet().getMaxredirs())) {
				reachedmax = 1;
				type = /* switch to fake to store the would-be-redirected
				                             to URL */.FOLLOW_FAKE;
			} else {
					data.getState().setThis_is_a_follow(/* mark the next request as a followed location: */1);
					data.getSet().getFollowlocation()++;
					if (data.getSet().getHttp_auto_referer()) {
						if (data.getChange().getReferer_alloc()) {
							do {
								.Curl_cfree((data.getChange().getReferer()));
								(data.getChange().getReferer()) = ((Object)0);
							} while (0);
							data.getChange().setReferer_alloc(0);
						} 
						data.getChange().setReferer(.Curl_cstrdup(data.getChange().getUrl()));
						if (!data.getChange().getReferer()) {
							return .CURLE_OUT_OF_MEMORY;
						} 
						data.getChange().setReferer_alloc(/* yes, free this later */1);
					} 
			} 
		} 
		if (ModernizedCProgram.Curl_is_absolute_url(newurl, ((Object)0), 40)) {
			disallowport = /* This is an absolute URL, don't allow the custom port number */1;
		} 
		do {
		} while (0);
		uc = ModernizedCProgram.curl_url_set(data.getState().getUh(), .CURLUPART_URL, newurl, (type == .FOLLOW_FAKE) ? (1 << 3) : ((type == .FOLLOW_REDIR) ? (1 << 7) : 0));
		if (uc) {
			if (type != .FOLLOW_FAKE) {
				return ModernizedCProgram.Curl_uc_to_curlcode(uc);
			} 
			newurl = .Curl_cstrdup(/* the URL could not be parsed for some reason, but since this is FAKE
			       mode, just duplicate the field as-is */newurl);
			if (!newurl) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} else {
				uc = ModernizedCProgram.curl_url_get(data.getState().getUh(), .CURLUPART_URL, newurl, 0);
				if (uc) {
					return ModernizedCProgram.Curl_uc_to_curlcode(uc);
				} 
		} 
		if (type == .FOLLOW_FAKE/* we're only figuring out the new url if we would've followed locations
		       but now we're done so we can get out! */) {
			data.getInfo().setWouldredirect(newurl);
			if (reachedmax) {
				ModernizedCProgram.Curl_failf(data, "Maximum (%ld) redirects followed", data.getSet().getMaxredirs());
				return .CURLE_TOO_MANY_REDIRECTS;
			} 
			return .CURLE_OK;
		} 
		if (disallowport) {
			data.getState().setAllow_port(0);
		} 
		if (data.getChange().getUrl_alloc()) {
			do {
				.Curl_cfree((data.getChange().getUrl()));
				(data.getChange().getUrl()) = ((Object)0);
			} while (0);
		} 
		data.getChange().setUrl(newurl);
		data.getChange().setUrl_alloc(1);
		ModernizedCProgram.Curl_infof(data, "Issue another request to this URL: '%s'\n", data.getChange().getUrl());
		switch (data.getInfo().getHttpcode()) {
		case /* Found */302/* (quote from RFC7231, section 6.4.3)
		     *
		     * Note: For historical reasons, a user agent MAY change the request
		     * method from POST to GET for the subsequent request.  If this
		     * behavior is undesired, the 307 (Temporary Redirect) status code
		     * can be used instead.
		     *
		     * ----
		     *
		     * Many webservers expect this, so these servers often answers to a POST
		     * request with an error page. To be sure that libcurl gets the page that
		     * most user agents would get, libcurl has to force GET.
		     *
		     * This behaviour is forbidden by RFC1945 and the obsolete RFC2616, and
		     * can be overridden with CURLOPT_POSTREDIR.
		     */:
				if ((data.getSet().getHttpreq() == .HTTPREQ_POST || data.getSet().getHttpreq() == .HTTPREQ_POST_FORM || data.getSet().getHttpreq() == .HTTPREQ_POST_MIME) && !(data.getSet().getKeep_post() & 2)) {
					ModernizedCProgram.Curl_infof(data, "Switch from POST to GET\n");
					data.getSet().setHttpreq(.HTTPREQ_GET);
				} 
				break;
		case /* Not Modified */304/* 304 means we did a conditional request and it was "Not modified".
		     * We shouldn't get any Location: header in this response!
		     */:
				break;
		case /* See Other */303/* Disable both types of POSTs, unless the user explicitly
		       asks for POST after POST */:
				if (data.getSet().getHttpreq() != .HTTPREQ_GET && !(data.getSet().getKeep_post() & 4)) {
					data.getSet().setHttpreq(/* enforce GET request */.HTTPREQ_GET);
					ModernizedCProgram.Curl_infof(data, "Disables POST, goes with %s\n", data.getSet().getOpt_no_body() ? "HEAD" : "GET");
				} 
				break;
		case /* Use Proxy */305/* (quote from RFC2616, section 10.3.6):
		     * "The requested resource MUST be accessed through the proxy given
		     * by the Location field. The Location field gives the URI of the
		     * proxy.  The recipient is expected to repeat this single request
		     * via the proxy. 305 responses MUST only be generated by origin
		     * servers."
		     */:
				break;
		case /* Moved Permanently */301/* (quote from RFC7231, section 6.4.2)
		     *
		     * Note: For historical reasons, a user agent MAY change the request
		     * method from POST to GET for the subsequent request.  If this
		     * behavior is undesired, the 307 (Temporary Redirect) status code
		     * can be used instead.
		     *
		     * ----
		     *
		     * Many webservers expect this, so these servers often answers to a POST
		     * request with an error page. To be sure that libcurl gets the page that
		     * most user agents would get, libcurl has to force GET.
		     *
		     * This behaviour is forbidden by RFC1945 and the obsolete RFC2616, and
		     * can be overridden with CURLOPT_POSTREDIR.
		     */:
				if ((data.getSet().getHttpreq() == .HTTPREQ_POST || data.getSet().getHttpreq() == .HTTPREQ_POST_FORM || data.getSet().getHttpreq() == .HTTPREQ_POST_MIME) && !(data.getSet().getKeep_post() & 1)) {
					ModernizedCProgram.Curl_infof(data, "Switch from POST to GET\n");
					data.getSet().setHttpreq(.HTTPREQ_GET);
				} 
				break;
		default:
				break;
		}
		ModernizedCProgram.Curl_pgrsTime(data, .TIMER_REDIRECT);
		ModernizedCProgram.Curl_pgrsResetTransferSizes(data);
		return .CURLE_OK/* CURL_DISABLE_HTTP */;
	}
	/* the Location: string */
	/* see transfer.h */
	/* Returns CURLE_OK *and* sets '*url' if a request retry is wanted.
	
	   NOTE: that the *url is malloc()ed. */
	public static  Curl_retry_request(Object conn, Object url) {
		Curl_easy data = conn.getData();
		bool retry = 0;
		url = ((Object)0);
		if (data.getSet().getUpload() && !(conn.getHandler().getProtocol() & (((1 << 0) | (1 << 1)) | (1 << 18)))) {
			return .CURLE_OK;
		} 
		if ((data.getReq().getBytecount() + data.getReq().getHeaderbytecount() == 0) && conn.getBits().getReuse() && (!data.getSet().getOpt_no_body() || (conn.getHandler().getProtocol() & ((1 << 0) | (1 << 1)))) && (data.getSet().getRtspreq() != .RTSPREQ_RECEIVE/* We got no data, we attempted to re-use a connection. For HTTP this
		       can be a retry so we try again regardless if we expected a body.
		       For other protocols we only try again only if we expected a body.
		
		       This might happen if the connection was left alive when we were
		       done using it before, but that was closed when we wanted to read from
		       it again. Bad luck. Retry the same request on a fresh connect! */)) {
			retry = 1;
		}  else if (data.getState().getRefused_stream() && (data.getReq().getBytecount() + data.getReq().getHeaderbytecount() == 0/* This was sent on a refused stream, safe to rerun. A refused stream
		       error can typically only happen on HTTP/2 level if the stream is safe
		       to issue again, but the nghttp2 API can deliver the message to other
		       streams as well, which is why this adds the check the data counters
		       too. */)) {
			ModernizedCProgram.Curl_infof(conn.getData(), "REFUSED_STREAM, retrying a fresh connect\n");
			data.getState().setRefused_stream(/* clear again */0);
			retry = 1;
		} 
		if (retry) {
			ModernizedCProgram.Curl_infof(conn.getData(), "Connection died, retrying a fresh connect\n");
			url = .Curl_cstrdup(conn.getData().getChange().getUrl());
			if (!url) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			ModernizedCProgram.Curl_conncontrol(conn, /* close this connection */1);
			conn.getBits().setRetry(/* mark this as a connection we're about
			                                to retry. Marking it this way should
			                                prevent i.e HTTP transfers to return
			                                error just because nothing has been
			                                transferred! */1);
			if (conn.getHandler().getProtocol() & ((1 << 0) | (1 << 1))) {
				if (data.getReq().getWritebytecount()) {
					CURLcode result = ModernizedCProgram.Curl_readrewind(conn);
					if (result) {
						do {
							.Curl_cfree((url));
							(url) = ((Object)0);
						} while (0);
						return result;
					} 
				} 
			} 
		} 
		return .CURLE_OK/*
		 * Curl_setup_transfer() is called to setup some basic properties for the
		 * upcoming transfer.
		 */;
	}
	public static void Curl_setup_transfer(Object data, int sockindex, Object size,  getheader, int writesockindex) {
		SingleRequest k = data.getReq();
		connectdata conn = data.getConn();
		do {
		} while (0);
		do {
		} while (0);
		if (conn.getBits().getMultiplex() || conn.getHttpversion() == 20) {
			conn.setSockfd(sockindex == -/* when multiplexing, the read/write sockets need to be the same! */1 ? ((writesockindex == -1 ? (SOCKET)(~0) : conn.getSock()[writesockindex])) : conn.getSock()[sockindex]);
			conn.setWritesockfd(conn.getSockfd());
		} else {
				conn.setSockfd(sockindex == -1 ? (SOCKET)(~0) : conn.getSock()[sockindex]);
				conn.setWritesockfd(writesockindex == -1 ? (SOCKET)(~0) : conn.getSock()[writesockindex]);
		} 
		k.setGetheader(getheader);
		k.setSize(size/* The code sequence below is placed in this function just because all
		     necessary input is not always known in do_complete() as this function may
		     be called after that */);
		if (!k.getGetheader()) {
			k.setHeader(0);
			if (size > 0) {
				ModernizedCProgram.Curl_pgrsSetDownloadSize(data, size);
			} 
		} 
		curltime curltime = new curltime();
		if (k.getGetheader() || !data.getSet().getOpt_no_body()) {
			if (sockindex != -1) {
				k.getKeepon() |=  (1 << 0);
			} 
			if (writesockindex != -1) {
				HTTP http = data.getReq().getProtop();
				if ((data.getState().getExpect100header()) && (conn.getHandler().getProtocol() & ((1 << 0) | (1 << 1))) && (http.getSending() == .HTTPSEND_BODY)) {
					k.setExp100(/* wait with write until we either got 100-continue or a timeout */expect100.EXP100_AWAITING_CONTINUE);
					k.setStart100(curltime.Curl_now());
					ModernizedCProgram.Curl_expire(data, data.getSet().getExpect_100_timeout(), /* Set a timeout for the multi interface. Add the inaccuracy margin so
					           that we don't fire slightly too early and get denied to run. */.EXPIRE_100_TIMEOUT);
				} else {
						if (data.getState().getExpect100header()) {
							k.setExp100(expect100.EXP100_SENDING_REQUEST);
						} 
						k.getKeepon() |=  (1 << /* enable the write bit when we're not waiting for continue */1/* if(writesockindex != -1) *//* if(k->getheader || !data->set.opt_no_body) */);
				} 
			} 
		} 
	}
	public static int Curl_inet_pton(int af, Object src, Object dst) {
		switch (af) {
		case 2:
				return (ModernizedCProgram.inet_pton4(src, (byte)dst));
		default:
				(._errno()) = -1024;
				return (true/* NOTREACHED *//* int
				 * inet_pton4(src, dst)
				 *      like inet_aton() but without all the hexadecimal and shorthand.
				 * return:
				 *      1 if `src' is a valid dotted quad, else 0.
				 * notice:
				 *      does not touch `dst' unless it's returning 1.
				 * author:
				 *      Paul Vixie, 1996.
				 */);
		}
	}
	/* This is from the BIND 4.9.4 release, modified to compile by itself */
	/* Copyright (c) 1996 by Internet Software Consortium.
	 *
	 * Permission to use, copy, modify, and distribute this software for any
	 * purpose with or without fee is hereby granted, provided that the above
	 * copyright notice and this permission notice appear in all copies.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
	 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
	 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
	 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
	 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
	 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
	 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
	 * SOFTWARE.
	 */
	/*
	 * WARNING: Don't even consider trying to compile this on a system where
	 * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
	 */
	public static int inet_pton4(Object src, Object dst) {
		byte[] digits = "0123456789";
		int saw_digit;
		int octets;
		int ch;
		byte[] tmp = new byte[4];
		byte tp;
		saw_digit = 0;
		octets = 0;
		tp = tmp;
		tp = 0;
		while ((ch = src++) != (byte)'\0') {
			byte pch;
			pch = .strchr(digits, ch);
			if (pch) {
				int val = tp * 10 + (int)(pch - digits);
				if (saw_digit && tp == 0) {
					return (false);
				} 
				if (val > 255) {
					return (false);
				} 
				tp = (byte)val;
				if (!saw_digit) {
					if (++octets > 4) {
						return (false);
					} 
					saw_digit = 1;
				} 
			}  else if (ch == (byte)'.' && saw_digit) {
				if (octets == 4) {
					return (false);
				} 
				++tp = 0;
				saw_digit = 0;
			} else {
					return (false);
			} 
		}
		if (octets < 4) {
			return (false);
		} 
		.memcpy(dst, tmp, 4);
		return (true/* int
		 * inet_pton6(src, dst)
		 *      convert presentation level address to network order binary form.
		 * return:
		 *      1 if `src' is a valid [RFC1884 2.2] address, else 0.
		 * notice:
		 *      (1) does not touch `dst' unless it's returning 1.
		 *      (2) :: in a full address is silently ignored.
		 * credit:
		 *      inspired by Mark Andrews.
		 * author:
		 *      Paul Vixie, 1996.
		 *//* Leading :: requires some special handling. *//* '\0' was seen by inet_pton4(). *//*
		     * Since some memmove()'s erroneously fail to handle
		     * overlapping regions, we'll do the shift by hand.
		     *//* ENABLE_IPV6 *//* HAVE_INET_PTON */);
	}
	/* int
	 * inet_pton(af, src, dst)
	 *      convert from presentation format (which usually means ASCII printable)
	 *      to network format (which is usually some kind of binary format).
	 * return:
	 *      1 if the address was valid for the specified address family
	 *      0 if the address wasn't valid (`dst' is untouched in this case)
	 *      -1 if some other error occurred (`dst' is untouched in this case, too)
	 * notice:
	 *      On Windows we store the error in the thread errno, not
	 *      in the winsock error code. This is to avoid losing the
	 *      actual last winsock error. So when this function returns
	 *      -1, check errno not SOCKERRNO.
	 * author:
	 *      Paul Vixie, 1996.
	 */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2012, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/* OUR_MAX_SEEK_L has 'long' data type, OUR_MAX_SEEK_O has 'curl_off_t,
	   both represent the same value. Maximum offset used here when we lseek
	   using a 'long' data type offset */
	/*
	** callback for CURLOPT_SEEKFUNCTION
	**
	** Notice that this is not supposed to return the resulting offset. This
	** shall only return CURL_SEEKFUNC_* return codes.
	*/
	public static int tool_seek_cb(Object userdata, Object offset, int whence) {
		InStruct in = userdata/* The offset check following here is only interesting if curl_off_t is
		     larger than off_t and we are not using the WIN32 large file support
		     macros that provide the support to do 64bit seeks correctly *//* Some precaution code to work around problems with different data sizes
		       to allow seeking >32bit even if off_t is 32bit. Should be very rare and
		       is really valid on weirdo-systems. *//* this code path doesn't support other types */;
		if ((long)-1 == ._lseeki64(in.getFd(), offset, /* couldn't rewind to beginning *//* couldn't seek forwards the desired amount */whence/* couldn't rewind, the reason is in errno but errno is just not portable
		       enough and we don't actually care that much why we failed. We'll let
		       libcurl know that it may try other means if it wants to. */)) {
			return 2;
		} 
		return 0/* 64-bit lseek-like function unavailable *//* 64-bit lseek-like function unavailable */;
	}
	/* 64-bit lseek-like function unavailable */
	/*
	 * Truncate a file handle at a 64-bit position 'where'.
	 */
	public static int tool_ftruncate64(int fd, Object where) {
		intptr_t handle = ._get_osfhandle(fd);
		if (._lseeki64(fd, where, 0) < 0) {
			return -1;
		} 
		if (!.SetEndOfFile((HANDLE)handle)) {
			return -1;
		} 
		return 0/* WIN32  && ! __MINGW64__ */;
	}
	/* compress 512-bits */
	public static int sha256_compress(Object md, Object buf) {
		long[] S = new long[8];
		long[] W = new long[64];
		int i;
		for (i = 0; i < 8; /* copy state into S */i++) {
			S[i] = md.getState()[i];
		}
		for (i = 0; i < 16; /* copy the state into 512-bits into W[0..15] */i++) {
			W[i] = ((((long)(buf + (4 * i))[0]) << 24) | (((long)(buf + (4 * i))[1]) << 16) | (((long)(buf + (4 * i))[2]) << 8) | ((long)(buf + (4 * i))[3]));
		}
		for (i = 16; i < 64; /* fill W[16..63] */i++) {
			W[i] = ((((((long)((W[i - 2])) & -1024) >> (long)(((true)) & 31)) | ((long)((W[i - 2])) << (long)(32 - (((true)) & 31)))) & -1024) ^ (((((long)((W[i - 2])) & -1024) >> (long)(((true)) & 31)) | ((long)((W[i - 2])) << (long)(32 - (((true)) & 31)))) & -1024) ^ (((W[i - 2]) & -1024) >> (true))) + W[i - 7] + ((((((long)((W[i - 15])) & -1024) >> (long)(((true)) & 31)) | ((long)((W[i - 15])) << (long)(32 - (((true)) & 31)))) & -1024) ^ (((((long)((W[i - 15])) & -1024) >> (long)(((true)) & 31)) | ((long)((W[i - 15])) << (long)(32 - (((true)) & 31)))) & -1024) ^ (((W[i - 15]) & -1024) >> (true))) + W[i - 16/* Compress */];
		}
		for (i = 0; i < 64; ++i) {
			long t;
			long t0 = S[7] + ((((((long)((S[4])) & -1024) >> (long)(((true)) & 31)) | ((long)((S[4])) << (long)(32 - (((true)) & 31)))) & -1024) ^ (((((long)((S[4])) & -1024) >> (long)(((true)) & 31)) | ((long)((S[4])) << (long)(32 - (((true)) & 31)))) & -1024) ^ (((((long)((S[4])) & -1024) >> (long)(((true)) & 31)) | ((long)((S[4])) << (long)(32 - (((true)) & 31)))) & -1024)) + (S[6] ^ (S[4] & (S[5] ^ S[6]))) + ModernizedCProgram.K[i] + W[i];
			long t1 = ((((((long)((S[0])) & -1024) >> (long)(((true)) & 31)) | ((long)((S[0])) << (long)(32 - (((true)) & 31)))) & -1024) ^ (((((long)((S[0])) & -1024) >> (long)(((true)) & 31)) | ((long)((S[0])) << (long)(32 - (((true)) & 31)))) & -1024) ^ (((((long)((S[0])) & -1024) >> (long)(((true)) & 31)) | ((long)((S[0])) << (long)(32 - (((true)) & 31)))) & -1024)) + (((S[0] | S[1]) & S[2]) | (S[0] & S[1]));
			S[3] += t0;
			S[7] = t0 + t1;
			;
			t = S[7];
			S[7] = S[6];
			S[6] = S[5];
			S[5] = S[4];
			S[4] = S[3];
			S[3] = S[2];
			S[2] = S[1];
			S[1] = S[0];
			S[0] = t;
		}
		for (i = 0; i < 8; /* feedback */i++) {
			md.getState()[i] = md.getState()[i] + S[i];
		}
		return 0;
	}
	/* Initialize the hash state */
	public static void SHA256_Init(Object md) {
		md.setCurlen(0);
		md.setLength(0);
		md.getState()[0] = -1024;
		md.getState()[1] = -1024;
		md.getState()[2] = -1024;
		md.getState()[3] = -1024;
		md.getState()[4] = -1024;
		md.getState()[5] = -1024;
		md.getState()[6] = -1024;
		md.getState()[7] = -1024/**
		   Process a block of memory though the hash
		   @param md     The hash state
		   @param in     The data to hash
		   @param inlen  The length of the data (octets)
		   @return CRYPT_OK if successful
		*/;
	}
	public static int SHA256_Update(Object md, Object in, long inlen) {
		long n;
		if (md.getCurlen() > ) {
			return -1;
		} 
		while (inlen > 0) {
			if (md.getCurlen() == 0 && inlen >= 64) {
				if (ModernizedCProgram.sha256_compress(md, (byte)in) < 0) {
					return -1;
				} 
				md.getLength() += 64 * 8;
				in += 64;
				inlen -= 64;
			} else {
					n = ((inlen) < ((64 - md.getCurlen())) ? (inlen) : ((64 - md.getCurlen())));
					.memcpy(md.getBuf() + md.getCurlen(), in, n);
					md.getCurlen() += n;
					in += n;
					inlen -= n;
					if (md.getCurlen() == 64) {
						if (ModernizedCProgram.sha256_compress(md, md.getBuf()) < 0) {
							return -1;
						} 
						md.getLength() += 8 * 64;
						md.setCurlen(0);
					} 
			} 
		}
		return 0/**
		   Terminate the hash to get the digest
		   @param md  The hash state
		   @param out [out] The destination of the hash (32 bytes)
		   @return CRYPT_OK if successful
		*/;
	}
	public static int SHA256_Final(Object out, Object md) {
		int i;
		if (md.getCurlen() >= ) {
			return -1;
		} 
		md.getLength() += md.getCurlen() * /* increase the length of the message */8;
		md.getBuf()[md.getCurlen()++] = (byte)/* append the '1' bit */-1024/* if the length is currently above 56 bytes we append zeros
		   * then compress.  Then we can fall back to padding zeros and length
		   * encoding like normal.
		   */;
		if (md.getCurlen() > 56) {
			while (md.getCurlen() < 64) {
				md.getBuf()[md.getCurlen()++] = (byte)0;
			}
			ModernizedCProgram.sha256_compress(md, md.getBuf());
			md.setCurlen(0);
		} 
		while (md.getCurlen() < /* pad up to 56 bytes of zeroes */56) {
			md.getBuf()[md.getCurlen()++] = (byte)0;
		}
		do {
			(md.getBuf() + 56)[0] = (byte)(((long)(md.getLength())) >> 56);
			(md.getBuf() + 56)[1] = (byte)(((long)(md.getLength())) >> 48);
			(md.getBuf() + 56)[2] = (byte)(((long)(md.getLength())) >> 40);
			(md.getBuf() + 56)[3] = (byte)(((long)(md.getLength())) >> 32);
			(md.getBuf() + 56)[4] = (byte)(((long)(md.getLength())) >> 24);
			(md.getBuf() + 56)[5] = (byte)(((long)(md.getLength())) >> 16);
			(md.getBuf() + 56)[6] = (byte)(((long)(md.getLength())) >> 8);
			(md.getBuf() + 56)[7] = (byte)(((long)(md.getLength())) & -1024);
		} while (/* store length */0);
		ModernizedCProgram.sha256_compress(md, md.getBuf());
		for (i = 0; i < 8; /* copy output */i++) {
			do {
				(out + (4 * i))[0] = (byte)((((long)(md.getState()[i])) >> 24) & -1024);
				(out + (4 * i))[1] = (byte)((((long)(md.getState()[i])) >> 16) & -1024);
				(out + (4 * i))[2] = (byte)((((long)(md.getState()[i])) >> 8) & -1024);
				(out + (4 * i))[3] = (byte)(((long)(md.getState()[i])) & -1024);
			} while (0);
		}
		return 0/* ===== end - public domain SHA256 implementation ===== */;
	}
	/* 32 unsigned chars */
	public static void Curl_sha256it(Object outbuffer, Object input) {
		SHA256_CTX ctx = new SHA256_CTX();
		ModernizedCProgram.SHA256_Init(ctx);
		ModernizedCProgram.SHA256_Update(ctx, input, ModernizedCProgram.curlx_uztoui(.strlen((byte)input)));
		ModernizedCProgram.SHA256_Final(outbuffer, ctx/* CURL_DISABLE_CRYPTO_AUTH */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* __INTEL_COMPILER && __unix__ */
	/*
	** unsigned long to unsigned short
	*/
	public static int curlx_ultous(long ulnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(ulnum & (long)-1024);
	}
	/*
	** unsigned long to unsigned char
	*/
	public static byte curlx_ultouc(long ulnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (byte)(ulnum & (long)-1024);
	}
	/*
	** unsigned long to signed int
	*/
	public static int curlx_ultosi(long ulnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(ulnum & (long)-1024);
	}
	/*
	** unsigned size_t to signed curl_off_t
	*/
	public static Object curlx_uztoso(Object uznum) {
		do {
		} while (/* cast truncates constant value */0);
		return (curl_off_t)(uznum & (size_t)-1024);
	}
	/* conversion may lose significant bits */
	/*
	** unsigned size_t to signed int
	*/
	public static int curlx_uztosi(Object uznum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(uznum & (size_t)-1024);
	}
	/*
	** unsigned size_t to unsigned long
	*/
	public static long curlx_uztoul(Object uznum) {
		return (long)(uznum & (size_t)-1024);
	}
	/* conversion may lose significant bits */
	/*
	** unsigned size_t to unsigned int
	*/
	public static int curlx_uztoui(Object uznum) {
		return (int)(uznum & (size_t)-1024);
	}
	/* conversion may lose significant bits */
	/*
	** signed long to signed int
	*/
	public static int curlx_sltosi(long slnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(slnum & (long)-1024);
	}
	/*
	** signed long to unsigned int
	*/
	public static int curlx_sltoui(long slnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(slnum & (long)-1024);
	}
	/*
	** signed long to unsigned short
	*/
	public static int curlx_sltous(long slnum) {
		do {
		} while (/* conversion may lose significant bits */0);
		do {
		} while (0);
		return (int)(slnum & (long)-1024);
	}
	/*
	** unsigned size_t to signed ssize_t
	*/
	public static Object curlx_uztosz(Object uznum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (ssize_t)(uznum & (size_t)-1024);
	}
	/*
	** signed curl_off_t to unsigned size_t
	*/
	public static Object curlx_sotouz(Object sonum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (size_t)(sonum & (curl_off_t)-1024);
	}
	/*
	** signed ssize_t to signed int
	*/
	public static int curlx_sztosi(Object sznum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(sznum & (ssize_t)-1024);
	}
	/*
	** unsigned int to unsigned short
	*/
	public static int curlx_uitous(int uinum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (int)(uinum & (int)-1024);
	}
	/*
	** signed int to unsigned size_t
	*/
	public static Object curlx_sitouz(int sinum) {
		do {
		} while (/* conversion may lose significant bits */0);
		return (size_t)sinum;
	}
	/*
	** curl_socket_t to signed int
	*/
	public static int curlx_sktosi(Object s) {
		return (int)((ssize_t)s/*
		** signed int to curl_socket_t
		*/);
	}
	public static Object curlx_sitosk(int i) {
		return (curl_socket_t)((ssize_t)i/* USE_WINSOCK */);
	}
	public static Object curlx_read(int fd, Object buf, Object count) {
		return (ssize_t).read(fd, buf, ModernizedCProgram.curlx_uztoui(count));
	}
	public static Object curlx_write(int fd, Object buf, Object count) {
		return (ssize_t).write(fd, buf, ModernizedCProgram.curlx_uztoui(count/* WIN32 || _WIN32 *//* clobber ignored *//* clobber ignored *//* variable was set but never used *//* conversion may lose significant bits *//* conversion may lose significant bits *//* __INTEL_COMPILER && __unix__ */));
	}
	public static void parse_cert_parameter(Object cert_parameter, Object certname, Object passphrase) {
		size_t param_length = .strlen(cert_parameter);
		size_t span = new size_t();
		byte param_place = ((Object)0);
		byte certname_place = ((Object)0);
		certname = ((Object)0);
		passphrase = ((Object)0);
		if (param_length == /* most trivial assumption: cert_parameter is empty */0) {
			return ;
		} 
		if (ModernizedCProgram.curl_strnequal(cert_parameter, "pkcs11:", 7) || !.strpbrk(cert_parameter, ":\\")) {
			certname = .strdup(cert_parameter);
			return ;
		} 
		certname_place = .malloc(param_length + /* deal with escaped chars; find unescaped colon if it exists */1);
		if (!certname_place) {
			return ;
		} 
		certname = certname_place;
		param_place = cert_parameter;
		while (param_place) {
			span = .strcspn(param_place, ":\\");
			.strncpy(certname_place, param_place, span);
			param_place += span;
			certname_place += span/* we just ate all the non-special chars. now we're on either a special
			     * char or the end of the string. */;
			switch (param_place) {
			case (byte)'\0':
					break;
			case (byte)'\\':
					param_place++;
					switch (param_place) {
					case (byte)'\\':
							certname_place++ = (byte)'\\';
							param_place++;
							break;
					case (byte)':':
							certname_place++ = (byte)':';
							param_place++;
							break;
					case (byte)'\0':
							certname_place++ = (byte)'\\';
							break;
					default:
							certname_place++ = (byte)'\\';
							certname_place++ = param_place;
							param_place++;
							break;
					}
					break;
			case (byte)':'/* Since we live in a world of weirdness and confusion, the win32
			         dudes can use : when using drive letters and thus c:\file:password
			         needs to work. In order not to break compatibility, we still use : as
			         separator, but we try to detect when it is used for a file name! On
			         windows. */:
					if (param_place && (param_place == cert_parameter[1]) && (cert_parameter[2] == (byte)'\\' || cert_parameter[2] == (byte)'/') && ((ModernizedCProgram.Curl_isalpha((int)((byte)cert_parameter[0/* colon in the second column, followed by a backslash, and the
					           first character is an alphabetic letter:
					
					           this is a drive letter colon */]))))) {
						certname_place++ = (byte)':';
						param_place++;
						break;
					} 
					/* escaped colons and Windows drive letter colons were handled
					       * above; if we're still here, this is a separating colon */param_place++;
					if (.strlen(param_place) > 0) {
						passphrase = .strdup(param_place);
					} 
					;
			}
		}
	}
	public static void GetFileAndPassword(Object nextarg, Object file, Object password) {
		byte certname;
		byte passphrase;
		ModernizedCProgram.parse_cert_parameter(nextarg, certname, passphrase);
		do {
			.free((file));
			(file) = ((Object)0);
		} while (0);
		file = certname;
		if (passphrase) {
			do {
				.free((password));
				(password) = ((Object)0);
			} while (0);
			password = passphrase;
		} 
		ModernizedCProgram.cleanarg(nextarg/* Get a size parameter for '--limit-rate' or '--max-filesize'.
		 * We support a 'G', 'M' or 'K' suffix too.
		  */);
	}
	public static  GetSizeParameter(Object global, Object arg, Object which, Object value_out) {
		byte unit;
		curl_off_t value = new curl_off_t();
		if (ModernizedCProgram.curlx_strtoofft(arg, unit, 0, value)) {
			ModernizedCProgram.warnf(global, "invalid number specified for %s\n", which);
			return .PARAM_BAD_USE;
		} 
		if (!unit) {
			unit = (byte)"b";
		}  else if (.strlen(unit) > 1) {
			unit = (byte)/* unsupported */"w";
		} 
		switch (unit) {
		case (byte)'m':
				if (value > (-1024 / (1024 * 1024))) {
					return .PARAM_NUMBER_TOO_LARGE;
				} 
				value *= 1024 * 1024;
				break;
		case (byte)'K':
		case (byte)'B'/* for plain bytes, leave as-is */:
				break;
		case (byte)'k':
				if (value > (-1024 / 1024)) {
					return .PARAM_NUMBER_TOO_LARGE;
				} 
				value *= 1024;
				break;
		case (byte)'b':
		case (byte)'G':
		case (byte)'M':
		case (byte)'g':
				if (value > (-1024 / (1024 * 1024 * 1024))) {
					return .PARAM_NUMBER_TOO_LARGE;
				} 
				value *= 1024 * 1024 * 1024;
				break;
		default:
				ModernizedCProgram.warnf(global, "unsupported %s unit. Use G, M, K or B!\n", which);
				return .PARAM_BAD_USE;
		}
		value_out = value;
		return .PARAM_OK;
	}
	/* f or -long-flag */
	public static  getparameter(Object flag, Object nextarg, Object usedarg, Object global, Object config) {
		byte letter;
		byte subletter = /* subletters can only occur on long options */(byte)'\0';
		int rc;
		byte parse = ((Object)0);
		int j;
		time_t now = new time_t();
		int hit = -1;
		bool longopt = 0;
		bool singleopt = /* when true means '-o foo' used '-ofoo' */0;
		ParameterError err = new ParameterError();
		bool toggle = /* how to switch boolean options, on or off. Controlled
		                         by using --OPTION or --no-OPTION */1;
		usedarg = /* default is that we don't use the arg */0;
		if (((byte)'-' != flag[0]) || ((byte)'-' == flag[1])) {
			byte word = ((byte)'-' == flag[0]) ? flag + 2 : /* this should be a long name */flag;
			size_t fnam = .strlen(word);
			int numhits = 0;
			bool noflagged = 0;
			if (!.strncmp(word, "no-", 3)) {
				word += /* disable this option but ignore the "no-" part when looking for it */3;
				toggle = 0;
				noflagged = 1;
			} 
			for (j = 0; j <  / ; j++) {
				if (ModernizedCProgram.curl_strnequal(ModernizedCProgram.aliases[j].getLname(), word, fnam)) {
					longopt = 1;
					numhits++;
					if (ModernizedCProgram.curl_strequal(ModernizedCProgram.aliases[j].getLname(), word)) {
						parse = ModernizedCProgram.aliases[j].getLetter();
						hit = j;
						numhits = /* a single unique hit */1;
						break;
					} 
					parse = ModernizedCProgram.aliases[j].getLetter();
					hit = j;
				} 
			}
			if (numhits > 1) {
				return /* this is at least the second match! */.PARAM_OPTION_AMBIGUOUS;
			} 
			if (hit < 0) {
				return .PARAM_OPTION_UNKNOWN;
			} 
			if (noflagged && (ModernizedCProgram.aliases[hit].getDesc() != .ARG_BOOL)) {
				return /* --no- prefixed an option that isn't boolean! */.PARAM_NO_NOT_BOOLEAN;
			} 
		} else {
				/* prefixed with one dash, pass it */flag++;
				hit = -1;
				parse = flag;
		} 
		do {
			if (!longopt) {
				letter = (byte)parse;
				subletter = (byte)'\0';
			} else {
					letter = parse[0];
					subletter = parse[1];
			} 
			if (hit < 0) {
				for (j = 0; j <  / ; j++) {
					if (letter == ModernizedCProgram.aliases[j].getLetter()[0]) {
						hit = j;
						break;
					} 
				}
				if (hit < 0) {
					return .PARAM_OPTION_UNKNOWN;
				} 
			} 
			if (ModernizedCProgram.aliases[hit].getDesc() >= .ARG_STRING) {
				if (!longopt && parse[/* this option requires an extra parameter */1]) {
					nextarg = (byte)parse[/* this is the actual extra parameter */1];
					singleopt = /* don't loop anymore after this */1;
				}  else if (!nextarg) {
					return .PARAM_REQUIRES_PARAMETER;
				} else {
						usedarg = /* mark it as used */1;
				} 
				if ((ModernizedCProgram.aliases[hit].getDesc() == .ARG_FILENAME) && (nextarg[0] == (byte)'-') && nextarg[1]) {
					ModernizedCProgram.warnf(global, /* if the file name looks like a command line option */"The file name argument '%s' looks like a flag.\n", nextarg);
				} 
			}  else if ((ModernizedCProgram.aliases[hit].getDesc() == .ARG_NONE) && !toggle) {
				return .PARAM_NO_PREFIX;
			} 
			switch (letter) {
			case (byte)'H':
					if (nextarg[0] == /* A custom header to append to a list */(byte)'@'/* read many headers from a file or stdin */) {
						byte string;
						size_t len = new size_t();
						bool use_stdin = !.strcmp(nextarg[1], "-");
						FILE file = use_stdin ? (_iob[0]) : .fopen(nextarg[1], "rt");
						if (!file) {
							ModernizedCProgram.warnf(global, "Failed to open %s!\n", nextarg[1]);
						} else {
								err = ModernizedCProgram.file2memory(string, len, file);
								if (!err && string/* Allow strtok() here since this isn't used threaded */) {
									byte h = .strtok(string, /* !checksrc! disable BANNEDFUNC 2 */"\r\n");
									while (h) {
										if (subletter == /* --proxy-header */(byte)'p') {
											err = ModernizedCProgram.add2list(config.getProxyheaders(), h);
										} else {
												err = ModernizedCProgram.add2list(config.getHeaders(), h);
										} 
										if (err) {
											break;
										} 
										h = .strtok(((Object)0), "\r\n");
									}
									.free(string);
								} 
								if (!use_stdin) {
									.fclose(file);
								} 
								if (err) {
									return err;
								} 
						} 
					} else {
							if (subletter == /* --proxy-header */(byte)'p') {
								err = ModernizedCProgram.add2list(config.getProxyheaders(), nextarg);
							} else {
									err = ModernizedCProgram.add2list(config.getHeaders(), nextarg);
							} 
							if (err) {
								return err;
							} 
					} 
					break;
			case (byte)'P'/* This makes the FTP sessions use PORT instead of PASV *//* use <eth0> or <192.168.10.10> style addresses. Anything except
			         this will make us try to get the "default" address.
			         NOTE: this is a changed behaviour since the released 4.1!
			      */:
					do {
						if ((config.getFtpport())) {
							.free((config.getFtpport()));
							(config.getFtpport()) = ((Object)0);
						} 
						if ((nextarg)) {
							(config.getFtpport()) = .strdup((nextarg));
							if (!((config.getFtpport()))) {
								return .PARAM_NO_MEM;
							} 
						} 
					} while (0);
					break;
			case (byte)'X':
					do {
						if ((config.getCustomrequest())) {
							.free((config.getCustomrequest()));
							(config.getCustomrequest()) = ((Object)0);
						} 
						if ((nextarg)) {
							(config.getCustomrequest()) = .strdup((nextarg));
							if (!((config.getCustomrequest()))) {
								return .PARAM_NO_MEM;
							} 
						} 
					} while (/* set custom request */0);
					break;
			case /* --tlsv1* options */(byte)'1':
					switch (subletter) {
					case /* --proxy-tls13-ciphers */(byte)'B':
							do {
								if ((config.getProxy_cipher13_list())) {
									.free((config.getProxy_cipher13_list()));
									(config.getProxy_cipher13_list()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy_cipher13_list()) = .strdup((nextarg));
									if (!((config.getProxy_cipher13_list()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case (byte)'1':
							config.setSsl_version(/* TLS version 1.1 */.CURL_SSLVERSION_TLSv1_1);
							break;
					case /* --tls13-ciphers */(byte)'A':
							do {
								if ((config.getCipher13_list())) {
									.free((config.getCipher13_list()));
									(config.getCipher13_list()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getCipher13_list()) = .strdup((nextarg));
									if (!((config.getCipher13_list()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case (byte)'2':
							config.setSsl_version(/* TLS version 1.2 */.CURL_SSLVERSION_TLSv1_2);
							break;
					case (byte)'0':
							config.setSsl_version(/* TLS version 1.0 */.CURL_SSLVERSION_TLSv1_0);
							break;
					case (byte)'\0':
							config.setSsl_version(/* TLS version 1.x */.CURL_SSLVERSION_TLSv1);
							break;
					case (byte)'3':
							config.setSsl_version(/* TLS version 1.3 */.CURL_SSLVERSION_TLSv1_3);
							break;
					}
					break;
			case (byte)'p':
					config.setProxytunnel(/* proxy tunnel for non-http protocols */toggle);
					break;
			case (byte)'3':
					config.setSsl_version(/* SSL version 3 */.CURL_SSLVERSION_SSLv3);
					break;
			case (byte)'4':
					config.setIp_version(/* IPv4 */4);
					break;
			case (byte)'n':
					switch (subletter) {
					case /* use .netrc or URL */(byte)'o':
							config.setNetrc_opt(toggle);
							break;
					case /* netrc-file */(byte)'e':
							do {
								if ((config.getNetrc_file())) {
									.free((config.getNetrc_file()));
									(config.getNetrc_file()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getNetrc_file()) = .strdup((nextarg));
									if (!((config.getNetrc_file()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					default:
							config.setNetrc(toggle);
							break;
					}
					break;
			case (byte)'d'/* postfield data */:
					{ 
						byte postdata = ((Object)0);
						FILE file = new FILE();
						size_t size = 0;
						bool raw_mode = (subletter == (byte)'r');
						if (subletter == /* --data-urlencode*/(byte)'e'/* [name]=[content], we encode the content part only
						         * [name]@[file name]
						         *
						         * Case 2: we first load the file using that name and then encode
						         * the content.
						         */) {
							byte p = .strchr(nextarg, (byte)'=');
							size_t nlen = new size_t();
							byte is_file;
							if (!p) {
								p = .strchr(nextarg, /* there was no '=' letter, check for a '@' instead */(byte)'@');
							} 
							if (p) {
								nlen = p - /* length of the name part */nextarg;
								is_file = /* pass the separator */p++;
							} else {
									nlen = is_file = /* neither @ nor =, so no name and it isn't a file */0;
									p = nextarg;
							} 
							if ((byte)'@' == is_file) {
								if (!.strcmp("-", /* a '@' letter, it means that a file name or - (stdin) follows */p)) {
									file = (_iob[0]);
									ModernizedCProgram.set_binmode((_iob[0]));
								} else {
										file = .fopen(p, "rb");
										if (!file) {
											ModernizedCProgram.warnf(global, "Couldn't read data from file \"%s\", this makes an empty POST.\n", nextarg);
										} 
								} 
								err = ModernizedCProgram.file2memory(postdata, size, file);
								if (file && (file != (_iob[0]))) {
									.fclose(file);
								} 
								if (err) {
									return err;
								} 
							} else {
									do {
										if ((postdata)) {
											.free((postdata));
											(postdata) = ((Object)0);
										} 
										if ((p)) {
											(postdata) = .strdup((p));
											if (!((postdata))) {
												return .PARAM_NO_MEM;
											} 
										} 
									} while (0);
									if (postdata) {
										size = .strlen(postdata);
									} 
							} 
							if (!postdata/* no data from the file, point to a zero byte string to make this
							             get sent as a POST anyway */) {
								postdata = .strdup("");
								if (!postdata) {
									return .PARAM_NO_MEM;
								} 
								size = 0;
							} else {
									byte enc = ModernizedCProgram.curl_easy_escape(((Object)0), postdata, (int)size);
									do {
										.free((postdata));
										(postdata) = ((Object)0);
									} while (/* no matter if it worked or not */0);
									if (enc/* now make a string with the name from above and append the
									               encoded string */) {
										size_t outlen = nlen + .strlen(enc) + 2;
										byte n = .malloc(outlen);
										if (!n) {
											ModernizedCProgram.curl_free(enc);
											return .PARAM_NO_MEM;
										} 
										if (nlen > /* only append '=' if we have a name */0) {
											ModernizedCProgram.curl_msnprintf(n, outlen, "%.*s=%s", nlen, nextarg, enc);
											size = outlen - 1;
										} else {
												.strcpy(n, enc);
												size = outlen - /* since no '=' was inserted */2;
										} 
										ModernizedCProgram.curl_free(enc);
										postdata = n;
									} else {
											return .PARAM_NO_MEM;
									} 
							} 
						}  else if ((byte)'@' == nextarg && !raw_mode/* the data begins with a '@' letter, it means that a file name
						           or - (stdin) follows */) {
							/* pass the @ */nextarg++;
							if (!.strcmp("-", nextarg)) {
								file = (_iob[0]);
								if (subletter == /* forced data-binary */(byte)'b') {
									ModernizedCProgram.set_binmode((_iob[0]));
								} 
							} else {
									file = .fopen(nextarg, "rb");
									if (!file) {
										ModernizedCProgram.warnf(global, "Couldn't read data from file \"%s\", this makes an empty POST.\n", nextarg);
									} 
							} 
							if (subletter == (byte)'b') {
								err = ModernizedCProgram.file2memory(postdata, size, /* forced binary */file);
							} else {
									err = ModernizedCProgram.file2string(postdata, file);
									if (postdata) {
										size = .strlen(postdata);
									} 
							} 
							if (file && (file != (_iob[0]))) {
								.fclose(file);
							} 
							if (err) {
								return err;
							} 
							if (!postdata/* no data from the file, point to a zero byte string to make this
							             get sent as a POST anyway */) {
								postdata = .strdup("");
								if (!postdata) {
									return .PARAM_NO_MEM;
								} 
							} 
						} else {
								do {
									if ((postdata)) {
										.free((postdata));
										(postdata) = ((Object)0);
									} 
									if ((nextarg)) {
										(postdata) = .strdup((nextarg));
										if (!((postdata))) {
											return .PARAM_NO_MEM;
										} 
									} 
								} while (0);
								if (postdata) {
									size = .strlen(postdata/* NOT forced binary, convert to ASCII */);
								} 
						} 
						if (config.getPostfields()) {
							byte oldpost = config.getPostfields();
							curl_off_t oldlen = config.getPostfieldsize();
							curl_off_t newlen = oldlen + ModernizedCProgram.curlx_uztoso(size) + 2;
							config.setPostfields(.malloc((size_t)newlen));
							if (!config.getPostfields()) {
								do {
									.free((oldpost));
									(oldpost) = ((Object)0);
								} while (0);
								do {
									.free((postdata));
									(postdata) = ((Object)0);
								} while (0);
								return .PARAM_NO_MEM;
							} 
							.memcpy(config.getPostfields(), oldpost, (size_t)oldlen);
							config.getPostfields()[oldlen] = /* use byte value 0x26 for '&' to accommodate non-ASCII platforms */(byte)'\x26';
							.memcpy(config.getPostfields()[oldlen + 1], postdata, size);
							config.getPostfields()[oldlen + 1 + size] = (byte)'\0';
							do {
								.free((oldpost));
								(oldpost) = ((Object)0);
							} while (0);
							do {
								.free((postdata));
								(postdata) = ((Object)0);
							} while (0);
							config.getPostfieldsize() += size + 1;
						} else {
								config.setPostfields(postdata);
								config.setPostfieldsize(ModernizedCProgram.curlx_uztoso(size/*
								      We can't set the request type here, as this data might be used in
								      a simple GET if -G is used. Already or soon.
								
								      if(SetHTTPrequest(HTTPREQ_SIMPLEPOST, &config->httpreq)) {
								        Curl_safefree(postdata);
								        return PARAM_BAD_USE;
								      }
								    */));
						} 
					}
					break;
			case (byte)'u':
					do {
						if ((config.getUserpwd())) {
							.free((config.getUserpwd()));
							(config.getUserpwd()) = ((Object)0);
						} 
						if ((nextarg)) {
							(config.getUserpwd()) = .strdup((nextarg));
							if (!((config.getUserpwd()))) {
								return .PARAM_NO_MEM;
							} 
						} 
					} while (/* user:password  */0);
					ModernizedCProgram.cleanarg(nextarg);
					break;
			case /* --next */(byte)':':
					return .PARAM_NEXT_OPERATION;
			case (byte)'v':
					if (toggle) {
						do {
							.free((global.getTrace_dump()));
							(global.getTrace_dump()) = ((Object)0);
						} while (/* the '%' thing here will cause the trace get sent to stderr */0);
						global.setTrace_dump(.strdup("%"));
						if (!global.getTrace_dump()) {
							return .PARAM_NO_MEM;
						} 
						if (global.getTracetype() && (global.getTracetype() != .TRACE_PLAIN)) {
							ModernizedCProgram.warnf(global, "-v, --verbose overrides an earlier trace/verbose option\n");
						} 
						global.setTracetype(.TRACE_PLAIN);
					} else {
							global.setTracetype(/* verbose is disabled here */.TRACE_NONE);
					} 
					break;
			case (byte)'a':
					config.setFtp_append(/* This makes the FTP sessions use APPE instead of STOR */toggle);
					break;
			case (byte)'Y':
					err = ModernizedCProgram.str2unum(config.getLow_speed_limit(), /* low speed limit */nextarg);
					if (err) {
						return err;
					} 
					if (!config.getLow_speed_time()) {
						config.setLow_speed_time(30);
					} 
					break;
			case /* more options without a short option */(byte)'$':
					switch (subletter) {
					case /* --retry */(byte)'g':
							err = ModernizedCProgram.str2unum(config.getReq_retry(), nextarg);
							if (err) {
								return err;
							} 
							break;
					case /* --path-as-is */(byte)'N':
							config.setPath_as_is(toggle);
							break;
					case /* --post303 */(byte)'I':
							config.setPost303(toggle);
							break;
					case /* --resolve */(byte)'F':
							err = ModernizedCProgram.add2list(config.getResolve(), nextarg);
							if (err) {
								return err;
							} 
							break;
					case /* --socks4 specifies a socks4 proxy to use */(byte)'t':
							do {
								if ((config.getProxy())) {
									.free((config.getProxy()));
									(config.getProxy()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy()) = .strdup((nextarg));
									if (!((config.getProxy()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							config.setProxyver(.CURLPROXY_SOCKS4);
							break;
					case /* --tcp-nodelay option */(byte)'d':
							config.setTcp_nodelay(toggle);
							break;
					case /* --libcurl */(byte)'z':
							do {
								if ((global.getLibcurl())) {
									.free((global.getLibcurl()));
									(global.getLibcurl()) = ((Object)0);
								} 
								if ((nextarg)) {
									(global.getLibcurl()) = .strdup((nextarg));
									if (!((global.getLibcurl()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --unix-socket */(byte)'M':
							config.setAbstract_unix_socket(0);
							do {
								if ((config.getUnix_socket_path())) {
									.free((config.getUnix_socket_path()));
									(config.getUnix_socket_path()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getUnix_socket_path()) = .strdup((nextarg));
									if (!((config.getUnix_socket_path()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --proxy-negotiate */(byte)'k':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 8)) {
								config.setProxynegotiate(toggle);
							} else {
									return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							break;
					case /* --post301 */(byte)'0':
							config.setPost301(toggle);
							break;
					case /* --ignore-content-length */(byte)'p':
							config.setIgnorecl(toggle);
							break;
					case /* --proto-redir */(byte)'E':
							config.setProto_redir_present(1);
							if (ModernizedCProgram.proto2num(config, config.getProto_redir(), nextarg)) {
								return .PARAM_BAD_USE;
							} 
							break;
					case /* --ftp-ssl-ccc-mode */(byte)'j':
							config.setFtp_ssl_ccc(1);
							config.setFtp_ssl_ccc_mode(ModernizedCProgram.ftpcccmethod(config, nextarg));
							break;
					case /* --proxy-anyauth */(byte)'n':
							config.setProxyanyauth(toggle);
							break;
					case /* --happy-eyeballs-timeout-ms */(byte)'~':
							err = ModernizedCProgram.str2unum(config.getHappy_eyeballs_timeout_ms(), nextarg);
							if (err) {
								return err/* 0 is a valid value for this timeout */;
							} 
							break;
					case /* --proxy-digest */(byte)'e':
							config.setProxydigest(toggle);
							break;
					case /* --mail-auth */(byte)'H':
							do {
								if ((config.getMail_auth())) {
									.free((config.getMail_auth()));
									(config.getMail_auth()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getMail_auth()) = .strdup((nextarg));
									if (!((config.getMail_auth()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --compressed-ssh */(byte)'Z':
							config.setSsh_compression(toggle);
							break;
					case /* --service-name */(byte)'P':
							do {
								if ((config.getService_name())) {
									.free((config.getService_name()));
									(config.getService_name()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getService_name()) = .strdup((nextarg));
									if (!((config.getService_name()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --tftp-no-options */(byte)'S':
							config.setTftp_no_options(toggle);
							break;
					case /* --no-sessionid */(byte)'w':
							config.setDisable_sessionid((!toggle) ? 1 : 0);
							break;
					case /* --expect100-timeout */(byte)'R':
							err = ModernizedCProgram.str2udouble(config.getExpect100timeout(), nextarg, -1024 / 1000);
							if (err) {
								return err;
							} 
							break;
					case /* --proxy-service-name */(byte)'O':
							do {
								if ((config.getProxy_service_name())) {
									.free((config.getProxy_service_name()));
									(config.getProxy_service_name()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy_service_name()) = .strdup((nextarg));
									if (!((config.getProxy_service_name()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --delegation LEVEL */(byte)'G':
							config.setGssapi_delegation(ModernizedCProgram.delegation(config, nextarg));
							break;
					case /* --abstract-unix-socket */(byte)'W':
							config.setAbstract_unix_socket(1);
							do {
								if ((config.getUnix_socket_path())) {
									.free((config.getUnix_socket_path()));
									(config.getUnix_socket_path()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getUnix_socket_path()) = .strdup((nextarg));
									if (!((config.getUnix_socket_path()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --ftp-ssl-ccc */(byte)'y':
							config.setFtp_ssl_ccc(toggle);
							if (!config.getFtp_ssl_ccc_mode()) {
								config.setFtp_ssl_ccc_mode(.CURLFTPSSL_CCC_PASSIVE);
							} 
							break;
					case /* --socks4a specifies a socks4a proxy to use */(byte)'T':
							do {
								if ((config.getProxy())) {
									.free((config.getProxy()));
									(config.getProxy()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy()) = .strdup((nextarg));
									if (!((config.getProxy()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							config.setProxyver(.CURLPROXY_SOCKS4A);
							break;
					case /* --ftp-skip-pasv-ip */(byte)'q':
							config.setFtp_skip_ip(toggle);
							break;
					case /* --ftp-pret */(byte)'C':
							config.setFtp_pret(toggle);
							break;
					case /* --mail-from */(byte)'A':
							do {
								if ((config.getMail_from())) {
									.free((config.getMail_from()));
									(config.getMail_from()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getMail_from()) = .strdup((nextarg));
									if (!((config.getMail_from()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --connect-to */(byte)'U':
							err = ModernizedCProgram.add2list(config.getConnect_to(), nextarg);
							if (err) {
								return err;
							} 
							break;
					case /* --ftp-pasv */(byte)'b':
							do {
								.free((config.getFtpport()));
								(config.getFtpport()) = ((Object)0);
							} while (0);
							break;
					case /* --ftp-ssl-control */(byte)'x':
							if (toggle && !(ModernizedCProgram.curlinfo.getFeatures() & (1 << 2))) {
								return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							config.setFtp_ssl_control(toggle);
							break;
					case /* --trace-time */(byte)'o':
							global.setTracetime(toggle);
							break;
					case /* --retry-max-time */(byte)'i':
							err = ModernizedCProgram.str2unummax(config.getRetry_maxtime(), nextarg, -1024 / 1000);
							if (err) {
								return err;
							} 
							break;
					case /* --ftp-account */(byte)'m':
							do {
								if ((config.getFtp_account())) {
									.free((config.getFtp_account()));
									(config.getFtp_account()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getFtp_account()) = .strdup((nextarg));
									if (!((config.getFtp_account()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --sasl-ir */(byte)'K':
							config.setSasl_ir(toggle);
							break;
					case /* --retry-delay */(byte)'h':
							err = ModernizedCProgram.str2unummax(config.getRetry_delay(), nextarg, -1024 / 1000);
							if (err) {
								return err;
							} 
							break;
					case /* --noproxy */(byte)'5':
							do {
								if ((config.getNoproxy())) {
									.free((config.getNoproxy()));
									(config.getNoproxy()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getNoproxy()) = .strdup((nextarg));
									if (!((config.getNoproxy()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (/* This specifies the noproxy list */0);
							break;
					case /* --test-event */(byte)'L':
							ModernizedCProgram.warnf(global, "--test-event is ignored unless a debug build!\n");
							break;
					case /* --retry-connrefused */(byte)'V':
							config.setRetry_connrefused(toggle);
							break;
					case /* --tftp-blksize */(byte)'9':
							err = ModernizedCProgram.str2unum(config.getTftp_blksize(), nextarg);
							if (err) {
								return err;
							} 
							break;
					case /* --proxy1.0 */(byte)'8':
							do {
								if ((config.getProxy())) {
									.free((config.getProxy()));
									(config.getProxy()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy()) = .strdup((nextarg));
									if (!((config.getProxy()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (/* http 1.0 proxy */0);
							config.setProxyver(.CURLPROXY_HTTP_1_0);
							break;
					case /* --socks5 specifies a socks5 proxy to use, and resolves
					                   the name locally and passes on the resolved address */(byte)'c':
							do {
								if ((config.getProxy())) {
									.free((config.getProxy()));
									(config.getProxy()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy()) = .strdup((nextarg));
									if (!((config.getProxy()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							config.setProxyver(.CURLPROXY_SOCKS5);
							break;
					case /* --socks5-hostname specifies a socks5 proxy and enables name
					                   resolving with the proxy */(byte)'2':
							do {
								if ((config.getProxy())) {
									.free((config.getProxy()));
									(config.getProxy()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy()) = .strdup((nextarg));
									if (!((config.getProxy()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							config.setProxyver(.CURLPROXY_SOCKS5_HOSTNAME);
							break;
					case /* --socks5-gssapi-nec*/(byte)'7':
							config.setSocks5_gssapi_nec(toggle);
							break;
					case /* --ssl-reqd */(byte)'v':
							if (toggle && !(ModernizedCProgram.curlinfo.getFeatures() & (1 << 2))) {
								return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							config.setFtp_ssl_reqd(toggle);
							break;
					case /* --suppress-connect-headers */(byte)'Y':
							config.setSuppress_connect_headers(toggle);
							break;
					case /* --proxy-basic */(byte)'f':
							config.setProxybasic(toggle);
							break;
					case /* --ftp-method (undocumented at this point) */(byte)'r':
							config.setFtp_filemethod(ModernizedCProgram.ftpfilemethod(config, nextarg));
							break;
					case /* --no-keepalive */(byte)'1':
							config.setNokeepalive((!toggle) ? 1 : 0);
							break;
					case /* --post302 */(byte)'4':
							config.setPost302(toggle);
							break;
					case /* --ftp-alternative-to-user */(byte)'u':
							do {
								if ((config.getFtp_alternative_to_user())) {
									.free((config.getFtp_alternative_to_user()));
									(config.getFtp_alternative_to_user()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getFtp_alternative_to_user()) = .strdup((nextarg));
									if (!((config.getFtp_alternative_to_user()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --ssl */(byte)'a':
							if (toggle && !(ModernizedCProgram.curlinfo.getFeatures() & (1 << 2))) {
								return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							config.setFtp_ssl(toggle);
							break;
					case /* --metalink */(byte)'J':
							{ 
								ModernizedCProgram.warnf(global, "--metalink option is ignored because the binary is built without the Metalink support.\n");
								break;
							}
					case /* --local-port */(byte)'s':
							{ 
								byte[] lrange = new byte[/* 16bit base 10 is 5 digits, but we allow 6 so that
								                            this catches overflows, not just truncates */7];
								byte p = nextarg;
								while ((ModernizedCProgram.Curl_isdigit((int)((byte)p)))) {
									p++;
								}
								if (p) {
									rc = .sscanf(p, " - %6s", /* if there's anything more than a plain decimal number */lrange);
									p = /* zero terminate to make str2unum() work below */0;
								} else {
										rc = 0;
								} 
								err = ModernizedCProgram.str2unum(config.getLocalport(), nextarg);
								if (err || (config.getLocalport() > 65535)) {
									return .PARAM_BAD_USE;
								} 
								if (!rc) {
									config.setLocalportrange(/* default number of ports to try */1);
								} else {
										err = ModernizedCProgram.str2unum(config.getLocalportrange(), lrange);
										if (err || (config.getLocalportrange() > 65535)) {
											return .PARAM_BAD_USE;
										} 
										config.getLocalportrange() -= (config.getLocalport() - 1);
										if (config.getLocalportrange() < 1) {
											return .PARAM_BAD_USE;
										} 
								} 
								break;
							}
					case /* --proto */(byte)'D':
							config.setProto_present(1);
							if (ModernizedCProgram.proto2num(config, config.getProto(), nextarg)) {
								return .PARAM_BAD_USE;
							} 
							break;
					case /* --sasl-authzid */(byte)'6':
							do {
								if ((config.getSasl_authzid())) {
									.free((config.getSasl_authzid()));
									(config.getSasl_authzid()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getSasl_authzid()) = .strdup((nextarg));
									if (!((config.getSasl_authzid()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --raw */(byte)'#':
							config.setRaw(toggle);
							break;
					case /* --proto-default */(byte)'Q':
							do {
								if ((config.getProto_default())) {
									.free((config.getProto_default()));
									(config.getProto_default()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProto_default()) = .strdup((nextarg));
									if (!((config.getProto_default()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							err = ModernizedCProgram.check_protocol(config.getProto_default());
							if (err) {
								return err;
							} 
							break;
					case /* --keepalive-time */(byte)'3':
							err = ModernizedCProgram.str2unum(config.getAlivetime(), nextarg);
							if (err) {
								return err;
							} 
							break;
					case /* --mail-rcpt */(byte)'B':
							err = ModernizedCProgram.add2list(config.getMail_rcpt(), /* append receiver to a list */nextarg);
							if (err) {
								return err;
							} 
							break;
					case /* --tls-max */(byte)'X':
							err = ModernizedCProgram.str2tls_max(config.getSsl_version_max(), nextarg);
							if (err) {
								return err;
							} 
							break;
					}
					break;
			case (byte)'y':
					err = ModernizedCProgram.str2unum(config.getLow_speed_time(), /* low speed time */nextarg);
					if (err) {
						return err;
					} 
					if (!config.getLow_speed_limit()) {
						config.setLow_speed_limit(1);
					} 
					break;
			case (byte)'B':
					config.setUse_ascii(/* use ASCII/text when transferring */toggle);
					break;
			case /* M for manual, huge help */(byte)'M':
					if (/* --no-manual shows no manual... */toggle) {
						return .PARAM_MANUAL_REQUESTED;
					} 
					break;
			case /* options without a short option */(byte)'*':
					switch (subletter) {
					case /* --alpn */(byte)'H':
							config.setNoalpn((!toggle) ? 1 : 0);
							break;
					case /* --max-filesize */(byte)'y':
							{ 
								curl_off_t value = new curl_off_t();
								ParameterError pe = ModernizedCProgram.GetSizeParameter(global, nextarg, "max-filesize", value);
								if (pe != .PARAM_OK) {
									return pe;
								} 
								config.setMax_filesize(value);
							}
							break;
					case /* --ftp-create-dirs */(byte)'q':
							config.setFtp_create_dirs(toggle);
							break;
					case /* ciphers */(byte)'d':
							do {
								if ((config.getCipher_list())) {
									.free((config.getCipher_list()));
									(config.getCipher_list()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getCipher_list()) = .strdup((nextarg));
									if (!((config.getCipher_list()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --digest */(byte)'k':
							if (toggle) {
								config.getAuthtype() |=  (((long)1) << 1);
							} else {
									config.getAuthtype() &=  ~(((long)1) << 1);
							} 
							break;
					case /* --negotiate */(byte)'l':
							if (toggle) {
								if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 8)) {
									config.getAuthtype() |=  (((long)1) << 2);
								} else {
										return .PARAM_LIBCURL_DOESNT_SUPPORT;
								} 
							} else {
									config.getAuthtype() &=  ~(((long)1) << 2);
							} 
							break;
					case /* --dns-ipv6-addr */(byte)'6':
							do {
								if ((config.getDns_ipv6_addr())) {
									.free((config.getDns_ipv6_addr()));
									(config.getDns_ipv6_addr()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getDns_ipv6_addr()) = .strdup((nextarg));
									if (!((config.getDns_ipv6_addr()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (/* addr in dot notation */0);
							break;
					case /* --disable-eprt */(byte)'z':
							config.setDisable_eprt(toggle);
							break;
					case /* egd-file */(byte)'b':
							do {
								if ((config.getEgd_file())) {
									.free((config.getEgd_file()));
									(config.getEgd_file()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getEgd_file()) = .strdup((nextarg));
									if (!((config.getEgd_file()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --trace */(byte)'g':
							do {
								if ((global.getTrace_dump())) {
									.free((global.getTrace_dump()));
									(global.getTrace_dump()) = ((Object)0);
								} 
								if ((nextarg)) {
									(global.getTrace_dump()) = .strdup((nextarg));
									if (!((global.getTrace_dump()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							if (global.getTracetype() && (global.getTracetype() != .TRACE_BIN)) {
								ModernizedCProgram.warnf(global, "--trace overrides an earlier trace/verbose option\n");
							} 
							global.setTracetype(.TRACE_BIN);
							break;
					case /* --npn */(byte)'G':
							config.setNonpn((!toggle) ? 1 : 0);
							break;
					case /* --basic for completeness */(byte)'n':
							if (toggle) {
								config.getAuthtype() |=  (((long)1) << 0);
							} else {
									config.getAuthtype() &=  ~(((long)1) << 0);
							} 
							break;
					case /* --crlf */(byte)'u':
							config.setCrlf(/* LF -> CRLF conversion? */toggle);
							break;
					case /* --disable-epsv */(byte)'e':
							config.setDisable_epsv(toggle);
							break;
					case /* --epsv */(byte)'E':
							config.setDisable_epsv((!toggle) ? 1 : 0);
							break;
					case /* the URL! */(byte)'@':
							{ 
								getout url = new getout();
								if (!config.getUrl_get()) {
									config.setUrl_get(config.getUrl_list());
								} 
								if (config.getUrl_get()) {
									while (config.getUrl_get() && (config.getUrl_get().getFlags() & (1 << 1))) {
										config.setUrl_get(config.getUrl_get().getNext());
									}
								} 
								if (config.getUrl_get()) {
									url = config.getUrl_get();
								} else {
										config.setUrl_get(url = ModernizedCProgram.new_getout(/* there was no free node, create one! */config));
								} 
								if (!url) {
									return .PARAM_NO_MEM;
								} 
								do {
									if ((url.getUrl())) {
										.free((url.getUrl()));
										(url.getUrl()) = ((Object)0);
									} 
									if ((nextarg)) {
										(url.getUrl()) = .strdup((nextarg));
										if (!((url.getUrl()))) {
											return .PARAM_NO_MEM;
										} 
									} 
								} while (/* fill in the URL */0);
								url.getFlags() |=  (1 << 1);
							}
					case /* --krb */(byte)'x':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << /* kerberos level string */1)) {
								do {
									if ((config.getKrblevel())) {
										.free((config.getKrblevel()));
										(config.getKrblevel()) = ((Object)0);
									} 
									if ((nextarg)) {
										(config.getKrblevel()) = .strdup((nextarg));
										if (!((config.getKrblevel()))) {
											return .PARAM_NO_MEM;
										} 
									} 
								} while (0);
							} else {
									return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							break;
					case /* OAuth 2.0 bearer token */(byte)'B':
							do {
								if ((config.getOauth_bearer())) {
									.free((config.getOauth_bearer()));
									(config.getOauth_bearer()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getOauth_bearer()) = .strdup((nextarg));
									if (!((config.getOauth_bearer()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							config.getAuthtype() |=  (((long)1) << 6);
							break;
					case /* --interface */(byte)'w':
							do {
								if ((config.getIface())) {
									.free((config.getIface()));
									(config.getIface()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getIface()) = .strdup((nextarg));
									if (!((config.getIface()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (/* interface */0);
							break;
					case /* --dns-servers */(byte)'F':
							do {
								if ((config.getDns_servers())) {
									.free((config.getDns_servers()));
									(config.getDns_servers()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getDns_servers()) = .strdup((nextarg));
									if (!((config.getDns_servers()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (/* IP addrs of DNS servers */0);
							break;
					case /* random-file */(byte)'a':
							do {
								if ((config.getRandom_file())) {
									.free((config.getRandom_file()));
									(config.getRandom_file()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getRandom_file()) = .strdup((nextarg));
									if (!((config.getRandom_file()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* doh-url */(byte)'C':
							do {
								if ((config.getDoh_url())) {
									.free((config.getDoh_url()));
									(config.getDoh_url()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getDoh_url()) = .strdup((nextarg));
									if (!((config.getDoh_url()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --max-redirs */(byte)'s'/* specified max no of redirects (http(s)), this accepts -1 as a
					           special condition */:
							err = ModernizedCProgram.str2num(config.getMaxredirs(), nextarg);
							if (err) {
								return err;
							} 
							if (config.getMaxredirs() < -1) {
								return .PARAM_BAD_NUMERIC;
							} 
							break;
					case /* --xattr */(byte)'~':
							config.setXattr(toggle);
							break;
					case /* --disallow-username-in-url */(byte)'f':
							config.setDisallow_username_in_url(toggle);
							break;
					case /* --trace-ascii */(byte)'h':
							do {
								if ((global.getTrace_dump())) {
									.free((global.getTrace_dump()));
									(global.getTrace_dump()) = ((Object)0);
								} 
								if ((nextarg)) {
									(global.getTrace_dump()) = .strdup((nextarg));
									if (!((global.getTrace_dump()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							if (global.getTracetype() && (global.getTracetype() != .TRACE_ASCII)) {
								ModernizedCProgram.warnf(global, "--trace-ascii overrides an earlier trace/verbose option\n");
							} 
							global.setTracetype(.TRACE_ASCII);
							break;
					case /* --create-dirs */(byte)'r':
							config.setCreate_dirs(toggle);
							break;
					case /* --dns-interface */(byte)'D':
							do {
								if ((config.getDns_interface())) {
									.free((config.getDns_interface()));
									(config.getDns_interface()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getDns_interface()) = .strdup((nextarg));
									if (!((config.getDns_interface()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (/* interface name */0);
							break;
					case /* --eprt */(byte)'Z':
							config.setDisable_eprt((!toggle) ? 1 : 0);
							break;
					case /* --ntlm */(byte)'m':
							if (toggle) {
								if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 4)) {
									config.getAuthtype() |=  (((long)1) << 3);
								} else {
										return .PARAM_LIBCURL_DOESNT_SUPPORT;
								} 
							} else {
									config.getAuthtype() &=  ~(((long)1) << 3);
							} 
							break;
					case /* --dns-ipv4-addr */(byte)'4':
							do {
								if ((config.getDns_ipv4_addr())) {
									.free((config.getDns_ipv4_addr()));
									(config.getDns_ipv4_addr()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getDns_ipv4_addr()) = .strdup((nextarg));
									if (!((config.getDns_ipv4_addr()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (/* addr in dot notation */0);
							break;
					case /* connect-timeout */(byte)'c':
							err = ModernizedCProgram.str2udouble(config.getConnecttimeout(), nextarg, -1024 / 1000);
							if (err) {
								return err;
							} 
							break;
					case /* --haproxy-protocol */(byte)'X':
							config.setHaproxy_protocol(toggle);
							break;
					case /* --proxy-ntlm */(byte)'t':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 4)) {
								config.setProxyntlm(toggle);
							} else {
									return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							break;
					case /* --stderr */(byte)'v':
							if (.strcmp(nextarg, "-")) {
								FILE newfile = .fopen(nextarg, "wt");
								if (!newfile) {
									ModernizedCProgram.warnf(global, "Failed to open %s!\n", nextarg);
								} else {
										if (global.getErrors_fopened()) {
											.fclose(global.getErrors());
										} 
										global.setErrors(newfile);
										global.setErrors_fopened(1);
								} 
							} else {
									global.setErrors((_iob[1]));
							} 
							break;
					case /* --compressed */(byte)'j':
							if (toggle && !(ModernizedCProgram.curlinfo.getFeatures() & ((1 << 3) | (1 << 23)))) {
								return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							config.setEncoding(toggle);
							break;
					case /* --limit-rate */(byte)'i':
							{ 
								curl_off_t value = new curl_off_t();
								ParameterError pe = ModernizedCProgram.GetSizeParameter(global, nextarg, "rate", value);
								if (pe != .PARAM_OK) {
									return pe;
								} 
								config.setRecvpersecond(value);
								config.setSendpersecond(value);
							}
							break;
					case /* --anyauth, let libcurl pick it */(byte)'o':
							if (toggle) {
								config.setAuthtype((~(((long)1) << 4/* --no-anyauth simply doesn't touch it */)));
							} 
							break;
					case /* --ntlm-wb */(byte)'M':
							if (toggle) {
								if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 15)) {
									config.getAuthtype() |=  (((long)1) << 5);
								} else {
										return .PARAM_LIBCURL_DOESNT_SUPPORT;
								} 
							} else {
									config.getAuthtype() &=  ~(((long)1) << 5);
							} 
							break;
					case /* --tr-encoding */(byte)'J':
							config.setTr_encoding(toggle);
							break;
					}
					break;
			case /* HTTP GET */(byte)'G':
					if (subletter == /* --request-target */(byte)'a') {
						do {
							if ((config.getRequest_target())) {
								.free((config.getRequest_target()));
								(config.getRequest_target()) = ((Object)0);
							} 
							if ((nextarg)) {
								(config.getRequest_target()) = .strdup((nextarg));
								if (!((config.getRequest_target()))) {
									return .PARAM_NO_MEM;
								} 
							} 
						} while (0);
					} else {
							config.setUse_httpget(1);
					} 
					break;
			case (byte)'R':
					config.setRemote_time(/* use remote file's time */toggle);
					break;
			case /* parse config file */(byte)'K':
					if (ModernizedCProgram.parseconfig(nextarg, global)) {
						ModernizedCProgram.warnf(global, "error trying read config from the '%s' file\n", nextarg);
					} 
					break;
			case (byte)'Z':
					switch (subletter) {
					case /* --parallel-max */(byte)'b':
							err = ModernizedCProgram.str2unum(global.getParallel_max(), nextarg);
							if (err) {
								return err;
							} 
							if ((global.getParallel_max() > 300) || (global.getParallel_max() < 1)) {
								global.setParallel_max(50);
							} 
							break;
					case /* --parallel */(byte)'\0':
							global.setParallel(toggle);
							break;
					}
					break;
			case (byte)'i':
					config.setShow_headers(/* show the headers as well in the
					                                        general output stream */toggle);
					break;
			case (byte)'w':
					if ((byte)'@' == /* get the output string */nextarg/* the data begins with a '@' letter, it means that a file name
					           or - (stdin) follows */) {
						FILE file = new FILE();
						byte fname;
						/* pass the @ */nextarg++;
						if (!.strcmp("-", nextarg)) {
							fname = "<stdin>";
							file = (_iob[0]);
						} else {
								fname = nextarg;
								file = .fopen(nextarg, "rt");
						} 
						do {
							.free((config.getWriteout()));
							(config.getWriteout()) = ((Object)0);
						} while (0);
						err = ModernizedCProgram.file2string(config.getWriteout(), file);
						if (file && (file != (_iob[0]))) {
							.fclose(file);
						} 
						if (err) {
							return err;
						} 
						if (!config.getWriteout()) {
							ModernizedCProgram.warnf(global, "Failed to read %s", fname);
						} 
					} else {
							do {
								if ((config.getWriteout())) {
									.free((config.getWriteout()));
									(config.getWriteout()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getWriteout()) = .strdup((nextarg));
									if (!((config.getWriteout()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
					} 
					break;
			case (byte)'F'/* "form data" simulation, this is a little advanced so lets do our best
			         to sort this out slowly and carefully */:
					if (ModernizedCProgram.formparse(config, nextarg, config.getMimeroot(), config.getMimecurrent(), (subletter == (byte)'s') ? 1 : /* 's' is literal string */0)) {
						return .PARAM_BAD_USE;
					} 
					if (ModernizedCProgram.SetHTTPrequest(config, .HTTPREQ_MIMEPOST, config.getHttpreq())) {
						return .PARAM_BAD_USE;
					} 
					break;
			case (byte)'s':
					if (/* don't show progress meter, don't show errors : */toggle) {
						global.setMute(global.setNoprogress(1));
					} else {
							global.setMute(global.setNoprogress(0));
					} 
					if (global.getShowerror() < 0/* if still on the default value, set showerror to the reverse of
					           toggle. This is to allow -S and -s to be used in an independent
					           order but still have the same effect. */) {
						global.setShowerror((!toggle) ? 1 : /* toggle off */0);
					} 
					break;
			case (byte)'6':
					config.setIp_version(/* IPv6 */6);
					break;
			case (byte)'f':
					switch (subletter) {
					case /* --styled-output */(byte)'b':
							global.setStyled_output(toggle);
							break;
					case /* --fail-early */(byte)'a':
							global.setFail_early(toggle);
							break;
					default:
							config.setFailonerror(toggle);
					}
					break;
			case /* --http* options */(byte)'0':
					switch (subletter) {
					case (byte)'2':
							config.setHttpversion(/* HTTP version 2.0 */.CURL_HTTP_VERSION_2_0);
							break;
					case (byte)'1':
							config.setHttpversion(/* HTTP version 1.1 */.CURL_HTTP_VERSION_1_1);
							break;
					case (byte)'\0':
							config.setHttpversion(/* HTTP version 1.0 */.CURL_HTTP_VERSION_1_0);
							break;
					case /* --http2-prior-knowledge */(byte)'3':
							config.setHttpversion(/* HTTP version 2.0 over clean TCP*/.CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE);
							break;
					case /* --http3 */(byte)'4':
							config.setHttpversion(/* HTTP version 3 go over QUIC - at once */.CURL_HTTP_VERSION_3);
							break;
					case (byte)'9':
							config.setHttp09_allowed(/* Allow HTTP/0.9 responses! */toggle);
							break;
					}
					break;
			case (byte)'j':
					config.setCookiesession(toggle);
					break;
			case (byte)'A':
					do {
						if ((config.getUseragent())) {
							.free((config.getUseragent()));
							(config.getUseragent()) = ((Object)0);
						} 
						if ((nextarg)) {
							(config.getUseragent()) = .strdup((nextarg));
							if (!((config.getUseragent()))) {
								return .PARAM_NO_MEM;
							} 
						} 
					} while (/* This specifies the User-Agent name */0);
					break;
			case (byte)'N'/* disable the output I/O buffering. note that the option is called
			         --buffer but is mostly used in the negative form: --no-buffer */:
					if (longopt) {
						config.setNobuffer((!toggle) ? 1 : 0);
					} else {
							config.setNobuffer(toggle);
					} 
					break;
			case /* --head */(byte)'I':
					config.setNo_body(toggle);
					config.setShow_headers(toggle);
					if (ModernizedCProgram.SetHTTPrequest(config, (config.getNo_body()) ? .HTTPREQ_HEAD : .HTTPREQ_GET, config.getHttpreq())) {
						return .PARAM_BAD_USE;
					} 
					break;
			case /* FALLTHROUGH *//* --output */(byte)'o'/* output file */:
					{ 
						getout url = new getout();
						if (!config.getUrl_out()) {
							config.setUrl_out(config.getUrl_list());
						} 
						if (config.getUrl_out()) {
							while (config.getUrl_out() && (config.getUrl_out().getFlags() & (1 << 0))) {
								config.setUrl_out(config.getUrl_out().getNext());
							}
						} 
						if (config.getUrl_out()) {
							url = config.getUrl_out();
						} else {
								config.setUrl_out(url = ModernizedCProgram.new_getout(/* there was no free node, create one! */config));
						} 
						if (!url) {
							return .PARAM_NO_MEM;
						} 
						if ((byte)'o' == /* fill in the outfile */letter) {
							do {
								if ((url.getOutfile())) {
									.free((url.getOutfile()));
									(url.getOutfile()) = ((Object)0);
								} 
								if ((nextarg)) {
									(url.getOutfile()) = .strdup((nextarg));
									if (!((url.getOutfile()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							url.getFlags() &=  ~(1 << /* switch off */2);
						} else {
								url.setOutfile(((Object)/* leave it */0));
								if (toggle) {
									url.getFlags() |=  (1 << /* switch on */2);
								} else {
										url.getFlags() &=  ~(1 << /* switch off */2);
								} 
						} 
						url.getFlags() |=  (1 << 0);
					}
					break;
			case /* --remote-header-name */(byte)'J':
					if (config.getShow_headers()) {
						ModernizedCProgram.warnf(global, "--include and --remote-header-name cannot be combined.\n");
						return .PARAM_BAD_USE;
					} 
					config.setContent_disposition(toggle);
					break;
			case (byte)'e':
					{ 
						byte ptr = .strstr(nextarg, ";auto");
						if (ptr/* Automatic referer requested, this may be combined with a
						           set initial one */) {
							config.setAutoreferer(1);
							ptr = /* zero terminate here */0;
						} else {
								config.setAutoreferer(0);
						} 
						do {
							if ((config.getReferer())) {
								.free((config.getReferer()));
								(config.getReferer()) = ((Object)0);
							} 
							if ((nextarg)) {
								(config.getReferer()) = .strdup((nextarg));
								if (!((config.getReferer()))) {
									return .PARAM_NO_MEM;
								} 
							} 
						} while (0);
					}
					break;
			case (byte)'C':
					if (.strcmp(nextarg, /* This makes us continue an ftp transfer at given position */"-")) {
						err = ModernizedCProgram.str2offset(config.getResume_from(), nextarg);
						if (err) {
							return err;
						} 
						config.setResume_from_current(0);
					} else {
							config.setResume_from_current(1);
							config.setResume_from(0);
					} 
					config.setUse_resume(1);
					break;
			case /* allow insecure SSL connects */(byte)'k':
					config.setInsecure_ok(toggle);
					break;
			case (byte)'c':
					do {
						if ((config.getCookiejar())) {
							.free((config.getCookiejar()));
							(config.getCookiejar()) = ((Object)0);
						} 
						if ((nextarg)) {
							(config.getCookiejar()) = .strdup((nextarg));
							if (!((config.getCookiejar()))) {
								return .PARAM_NO_MEM;
							} 
						} 
					} while (/* get the file name to dump all cookies in */0);
					break;
			case /* g disables URLglobbing */(byte)'g':
					config.setGloboff(toggle);
					break;
			case (byte)'V':
					if (/* --no-version yields no output! */toggle) {
						return .PARAM_VERSION_INFO_REQUESTED;
					} 
					break;
			case (byte)'D':
					do {
						if ((config.getHeaderfile())) {
							.free((config.getHeaderfile()));
							(config.getHeaderfile()) = ((Object)0);
						} 
						if ((nextarg)) {
							(config.getHeaderfile()) = .strdup((nextarg));
							if (!((config.getHeaderfile()))) {
								return .PARAM_NO_MEM;
							} 
						} 
					} while (/* dump-header to given file name */0);
					break;
			case (byte)'T'/* we are uploading */:
					{ 
						getout url = new getout();
						if (!config.getUrl_ul()) {
							config.setUrl_ul(config.getUrl_list());
						} 
						if (config.getUrl_ul()) {
							while (config.getUrl_ul() && (config.getUrl_ul().getFlags() & (1 << 3))) {
								config.setUrl_ul(config.getUrl_ul().getNext());
							}
						} 
						if (config.getUrl_ul()) {
							url = config.getUrl_ul();
						} else {
								config.setUrl_ul(url = ModernizedCProgram.new_getout(/* there was no free node, create one! */config));
						} 
						if (!url) {
							return .PARAM_NO_MEM;
						} 
						url.getFlags() |=  (1 << /* mark -T used */3);
						if (!nextarg) {
							url.getFlags() |=  (1 << 4);
						} else {
								do {
									if ((url.getInfile())) {
										.free((url.getInfile()));
										(url.getInfile()) = ((Object)0);
									} 
									if ((nextarg)) {
										(url.getInfile()) = .strdup((nextarg));
										if (!((url.getInfile()))) {
											return .PARAM_NO_MEM;
										} 
									} 
								} while (/* "-" equals stdin, but keep the string around for now */0);
						} 
					}
					break;
			case /* if used first, already taken care of, we do it like
			                 this so we don't cause an error! */(byte)'q':
					break;
			case (byte)'#':
					switch (subletter) {
					case /* --progress-meter */(byte)'m':
							global.setNoprogress(!toggle);
							break;
					default:
							global.setProgressmode(toggle ? 1 : 0);
							break;
					}
					break;
			case (byte)'b':
					switch (subletter) {
					case /* --alt-svc */(byte)'a':
							do {
								if ((config.getAltsvc())) {
									.free((config.getAltsvc()));
									(config.getAltsvc()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getAltsvc()) = .strdup((nextarg));
									if (!((config.getAltsvc()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					default:
							if (nextarg[0] == (byte)'@') {
								nextarg++;
							}  else if (.strchr(nextarg, (byte)'=')) {
								do {
									if ((config.getCookie())) {
										.free((config.getCookie()));
										(config.getCookie()) = ((Object)0);
									} 
									if ((nextarg)) {
										(config.getCookie()) = .strdup((nextarg));
										if (!((config.getCookie()))) {
											return .PARAM_NO_MEM;
										} 
									} 
								} while (/* A cookie string must have a =-letter */0);
								break;
							} 
							do {
								if ((config.getCookiefile())) {
									.free((config.getCookiefile()));
									(config.getCookiefile()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getCookiefile()) = .strdup((nextarg));
									if (!((config.getCookiefile()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (/* We have a cookie file to read from! */0);
					}
					break;
			case (byte)'U':
					do {
						if ((config.getProxyuserpwd())) {
							.free((config.getProxyuserpwd()));
							(config.getProxyuserpwd()) = ((Object)0);
						} 
						if ((nextarg)) {
							(config.getProxyuserpwd()) = .strdup((nextarg));
							if (!((config.getProxyuserpwd()))) {
								return .PARAM_NO_MEM;
							} 
						} 
					} while (/* Proxy user:password  */0);
					ModernizedCProgram.cleanarg(nextarg);
					break;
			case /* --remote-name */(byte)'O':
					if (subletter == /* --remote-name-all */(byte)'a') {
						config.setDefault_node_flags(toggle ? (1 << 2) : 0);
						break;
					} 
			case (byte)'S':
					global.setShowerror(toggle ? 1 : /* show errors *//* toggle on if used with -s */0);
					break;
			case (byte)'2':
					config.setSsl_version(/* SSL version 2 */.CURL_SSLVERSION_SSLv2);
					break;
			case (byte)'l':
					config.setDirlistonly(/* only list the names of the FTP dir */toggle);
					break;
			case (byte)'E':
					switch (subletter) {
					case /* crypto engine */(byte)'f':
							do {
								if ((config.getEngine())) {
									.free((config.getEngine()));
									(config.getEngine()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getEngine()) = .strdup((nextarg));
									if (!((config.getEngine()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							if (config.getEngine() && ModernizedCProgram.curl_strequal(config.getEngine(), "list")) {
								return .PARAM_ENGINES_REQUESTED;
							} 
							break;
					case /* --pubkey public key file */(byte)'h':
							do {
								if ((config.getPubkey())) {
									.free((config.getPubkey()));
									(config.getPubkey()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getPubkey()) = .strdup((nextarg));
									if (!((config.getPubkey()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* proxy pinned public key */(byte)'P':
							do {
								if ((config.getProxy_pinnedpubkey())) {
									.free((config.getProxy_pinnedpubkey()));
									(config.getProxy_pinnedpubkey()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy_pinnedpubkey()) = .strdup((nextarg));
									if (!((config.getProxy_pinnedpubkey()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* CRL file */(byte)'j':
							do {
								if ((config.getCrlfile())) {
									.free((config.getCrlfile()));
									(config.getCrlfile()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getCrlfile()) = .strdup((nextarg));
									if (!((config.getCrlfile()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* certificate file for proxy */(byte)'x':
							ModernizedCProgram.GetFileAndPassword(nextarg, config.getProxy_cert(), config.getProxy_key_passwd());
							break;
					case /* private key passphrase for proxy */(byte)'1':
							do {
								if ((config.getProxy_key_passwd())) {
									.free((config.getProxy_key_passwd()));
									(config.getProxy_key_passwd()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy_key_passwd()) = .strdup((nextarg));
									if (!((config.getProxy_key_passwd()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							ModernizedCProgram.cleanarg(nextarg);
							break;
					case /* CA cert directory */(byte)'g':
							do {
								if ((config.getCapath())) {
									.free((config.getCapath()));
									(config.getCapath()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getCapath()) = .strdup((nextarg));
									if (!((config.getCapath()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --ssl-no-revoke */(byte)'s':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 2)) {
								config.setSsl_no_revoke(1);
							} 
							break;
					case /* private key file type for proxy */(byte)'0':
							do {
								if ((config.getProxy_key_type())) {
									.free((config.getProxy_key_type()));
									(config.getProxy_key_type()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy_key_type()) = .strdup((nextarg));
									if (!((config.getProxy_key_type()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case (byte)'B':
							if (/* --socks5-gssapi */toggle) {
								config.getSocks5_auth() |=  (((long)1) << 2);
							} else {
									config.getSocks5_auth() &=  ~(((long)1) << 2);
							} 
							break;
					case /* cert file type for proxy */(byte)'y':
							do {
								if ((config.getProxy_cert_type())) {
									.free((config.getProxy_cert_type()));
									(config.getProxy_cert_type()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy_cert_type()) = .strdup((nextarg));
									if (!((config.getProxy_cert_type()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* no empty SSL fragments for proxy */(byte)'4':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 2)) {
								config.setProxy_ssl_allow_beast(toggle);
							} 
							break;
					case /* --hostpubmd5 md5 of the host public key */(byte)'i':
							do {
								if ((config.getHostpubmd5())) {
									.free((config.getHostpubmd5()));
									(config.getHostpubmd5()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getHostpubmd5()) = .strdup((nextarg));
									if (!((config.getHostpubmd5()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							if (!config.getHostpubmd5() || .strlen(config.getHostpubmd5()) != 32) {
								return .PARAM_BAD_USE;
							} 
							break;
					case /* Pinned public key DER file */(byte)'p':
							do {
								if ((config.getPinnedpubkey())) {
									.free((config.getPinnedpubkey()));
									(config.getPinnedpubkey()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getPinnedpubkey()) = .strdup((nextarg));
									if (!((config.getPinnedpubkey()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* private key file for proxy */(byte)'z':
							do {
								if ((config.getProxy_key())) {
									.free((config.getProxy_key()));
									(config.getProxy_key()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy_key()) = .strdup((nextarg));
									if (!((config.getProxy_key()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* TLS authentication type */(byte)'m':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 14)) {
								do {
									if ((config.getTls_authtype())) {
										.free((config.getTls_authtype()));
										(config.getTls_authtype()) = ((Object)0);
									} 
									if ((nextarg)) {
										(config.getTls_authtype()) = .strdup((nextarg));
										if (!((config.getTls_authtype()))) {
											return .PARAM_NO_MEM;
										} 
									} 
								} while (0);
								if (!ModernizedCProgram.curl_strequal(config.getTls_authtype(), "SRP")) {
									return /* only support TLS-SRP */.PARAM_LIBCURL_DOESNT_SUPPORT;
								} 
							} else {
									return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							break;
					case /* TLS username for proxy */(byte)'u':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 14)) {
								do {
									if ((config.getProxy_tls_username())) {
										.free((config.getProxy_tls_username()));
										(config.getProxy_tls_username()) = ((Object)0);
									} 
									if ((nextarg)) {
										(config.getProxy_tls_username()) = .strdup((nextarg));
										if (!((config.getProxy_tls_username()))) {
											return .PARAM_NO_MEM;
										} 
									} 
								} while (0);
							} else {
									return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							break;
					case /* TLS authentication type for proxy */(byte)'w':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 14)) {
								do {
									if ((config.getProxy_tls_authtype())) {
										.free((config.getProxy_tls_authtype()));
										(config.getProxy_tls_authtype()) = ((Object)0);
									} 
									if ((nextarg)) {
										(config.getProxy_tls_authtype()) = .strdup((nextarg));
										if (!((config.getProxy_tls_authtype()))) {
											return .PARAM_NO_MEM;
										} 
									} 
								} while (0);
								if (!ModernizedCProgram.curl_strequal(config.getProxy_tls_authtype(), "SRP")) {
									return /* only support TLS-SRP */.PARAM_LIBCURL_DOESNT_SUPPORT;
								} 
							} else {
									return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							break;
					case /* private key file type */(byte)'d':
							do {
								if ((config.getKey_type())) {
									.free((config.getKey_type()));
									(config.getKey_type()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getKey_type()) = .strdup((nextarg));
									if (!((config.getKey_type()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --login-options */(byte)'5':
							do {
								if ((config.getLogin_options())) {
									.free((config.getLogin_options()));
									(config.getLogin_options()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getLogin_options()) = .strdup((nextarg));
									if (!((config.getLogin_options()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --proxy-tlsv1 */(byte)'9':
							config.setProxy_ssl_version(/* TLS version 1 for proxy */.CURL_SSLVERSION_TLSv1);
							break;
					case /* --cert-status */(byte)'q':
							config.setVerifystatus(1);
							break;
					case (byte)'A':
							if (/* --socks5-basic */toggle) {
								config.getSocks5_auth() |=  (((long)1) << 0);
							} else {
									config.getSocks5_auth() &=  ~(((long)1) << 0);
							} 
							break;
					case /* --false-start */(byte)'r':
							config.setFalsestart(1);
							break;
					case /* CA cert directory for proxy */(byte)'7':
							do {
								if ((config.getProxy_capath())) {
									.free((config.getProxy_capath()));
									(config.getProxy_capath()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy_capath()) = .strdup((nextarg));
									if (!((config.getProxy_capath()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* no empty SSL fragments, --ssl-allow-beast */(byte)'n':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 2)) {
								config.setSsl_allow_beast(toggle);
							} 
							break;
					case /* CRL file for proxy */(byte)'3':
							do {
								if ((config.getProxy_crlfile())) {
									.free((config.getProxy_crlfile()));
									(config.getProxy_crlfile()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy_crlfile()) = .strdup((nextarg));
									if (!((config.getProxy_crlfile()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* CA info PEM file */(byte)'a':
							do {
								if ((config.getCacert())) {
									.free((config.getCacert()));
									(config.getCacert()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getCacert()) = .strdup((nextarg));
									if (!((config.getCacert()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* private key file */(byte)'c':
							do {
								if ((config.getKey())) {
									.free((config.getKey()));
									(config.getKey()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getKey()) = .strdup((nextarg));
									if (!((config.getKey()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* TLS password */(byte)'l':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 14)) {
								do {
									if ((config.getTls_password())) {
										.free((config.getTls_password()));
										(config.getTls_password()) = ((Object)0);
									} 
									if ((nextarg)) {
										(config.getTls_password()) = .strdup((nextarg));
										if (!((config.getTls_password()))) {
											return .PARAM_NO_MEM;
										} 
									} 
								} while (0);
							} else {
									return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							break;
					case /* certificate file */(byte)'\0':
							ModernizedCProgram.GetFileAndPassword(nextarg, config.getCert(), config.getKey_passwd());
							break;
					case /* cert file type */(byte)'b':
							do {
								if ((config.getCert_type())) {
									.free((config.getCert_type()));
									(config.getCert_type()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getCert_type()) = .strdup((nextarg));
									if (!((config.getCert_type()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* --tcp-fastopen */(byte)'t':
							config.setTcp_fastopen(1);
							break;
					case /* TLS password for proxy */(byte)'v':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 14)) {
								do {
									if ((config.getProxy_tls_password())) {
										.free((config.getProxy_tls_password()));
										(config.getProxy_tls_password()) = ((Object)0);
									} 
									if ((nextarg)) {
										(config.getProxy_tls_password()) = .strdup((nextarg));
										if (!((config.getProxy_tls_password()))) {
											return .PARAM_NO_MEM;
										} 
									} 
								} while (0);
							} else {
									return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							break;
					case /* CA info PEM file for proxy */(byte)'6':
							do {
								if ((config.getProxy_cacert())) {
									.free((config.getProxy_cacert()));
									(config.getProxy_cacert()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy_cacert()) = .strdup((nextarg));
									if (!((config.getProxy_cacert()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* allow insecure SSL connects for proxy */(byte)'8':
							config.setProxy_insecure_ok(toggle);
							break;
					case /* ciphers for proxy */(byte)'2':
							do {
								if ((config.getProxy_cipher_list())) {
									.free((config.getProxy_cipher_list()));
									(config.getProxy_cipher_list()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy_cipher_list()) = .strdup((nextarg));
									if (!((config.getProxy_cipher_list()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					case /* private key passphrase */(byte)'e':
							do {
								if ((config.getKey_passwd())) {
									.free((config.getKey_passwd()));
									(config.getKey_passwd()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getKey_passwd()) = .strdup((nextarg));
									if (!((config.getKey_passwd()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							ModernizedCProgram.cleanarg(nextarg);
							break;
					case /* TLS username */(byte)'k':
							if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 14)) {
								do {
									if ((config.getTls_username())) {
										.free((config.getTls_username()));
										(config.getTls_username()) = ((Object)0);
									} 
									if ((nextarg)) {
										(config.getTls_username()) = .strdup((nextarg));
										if (!((config.getTls_username()))) {
											return .PARAM_NO_MEM;
										} 
									} 
								} while (0);
							} else {
									return .PARAM_LIBCURL_DOESNT_SUPPORT;
							} 
							break;
					default:
							return .PARAM_OPTION_UNKNOWN;
					}
					break;
			case (byte)'m':
					err = ModernizedCProgram.str2udouble(config.getTimeout(), nextarg, -1024 / /* specified max time */1000);
					if (err) {
						return err;
					} 
					break;
			case (byte)'x':
					switch (subletter) {
					case /* --preproxy */(byte)'a':
							do {
								if ((config.getPreproxy())) {
									.free((config.getPreproxy()));
									(config.getPreproxy()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getPreproxy()) = .strdup((nextarg));
									if (!((config.getPreproxy()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (0);
							break;
					default:
							do {
								if ((config.getProxy())) {
									.free((config.getProxy()));
									(config.getProxy()) = ((Object)0);
								} 
								if ((nextarg)) {
									(config.getProxy()) = .strdup((nextarg));
									if (!((config.getProxy()))) {
										return .PARAM_NO_MEM;
									} 
								} 
							} while (/* --proxy */0);
							config.setProxyver(.CURLPROXY_HTTP);
							break;
					}
					break;
			case /* h for help */(byte)'h':
					if (toggle) {
						return .PARAM_HELP_REQUESTED;
					} 
					break;
			case (byte)'t':
					err = ModernizedCProgram.add2list(config.getTelnet_options(), /* Telnet options */nextarg);
					if (err) {
						return err;
					} 
					break;
			case (byte)'Q':
					switch (nextarg[/* QUOTE command to send to FTP server */0]) {
					case (byte)'+':
							/* prefixed with a plus makes it a just-before-transfer one */nextarg++;
							err = ModernizedCProgram.add2list(config.getPrequote(), nextarg);
							break;
					case (byte)'-':
							/* prefixed with a dash makes it a POST TRANSFER one */nextarg++;
							err = ModernizedCProgram.add2list(config.getPostquote(), nextarg);
							break;
					default:
							err = ModernizedCProgram.add2list(config.getQuote(), nextarg);
							break;
					}
					if (err) {
						return err;
					} 
					break;
			case /* time condition coming up */(byte)'z':
					switch (nextarg) {
					case (byte)'=':
							config.setTimecond(/* Last-Modified:  (section 14.29 in RFC2068) */.CURL_TIMECOND_LASTMOD);
							nextarg++;
							break;
					case (byte)'+':
							nextarg/* FALLTHROUGH */++;
					case (byte)'-':
							config.setTimecond(/* If-Unmodified-Since:  (section 14.24 in RFC2068) */.CURL_TIMECOND_IFUNMODSINCE);
							nextarg++;
							break;
					default:
							config.setTimecond(/* If-Modified-Since: (section 14.28 in RFC2068) */.CURL_TIMECOND_IFMODSINCE);
							break;
					}
					now = .time(((Object)0));
					config.setCondtime((curl_off_t)ModernizedCProgram.curl_getdate(nextarg, now));
					if (-1 == config.getCondtime()) {
						curl_off_t filetime = ModernizedCProgram.getfiletime(nextarg, config.getGlobal().getErrors());
						if (filetime >= 0) {
							config.setCondtime(/* pull the time out from the file */filetime);
						} else {
								config.setTimecond(/* failed, remove time condition */.CURL_TIMECOND_NONE);
								ModernizedCProgram.warnf(global, "Illegal date format for -z, --time-cond (and not a file name). Disabling time condition. See curl_getdate(3) for valid date syntax.\n");
						} 
					} 
					break;
			case (byte)'r'/* Specifying a range WITHOUT A DASH will create an illegal HTTP range
			         (and won't actually be range by definition). The man page previously
			         claimed that to be a good way, why this code is added to work-around
			         it. */:
					if ((ModernizedCProgram.Curl_isdigit((int)((byte)nextarg))) && !.strchr(nextarg, (byte)'-')) {
						byte[] buffer = new byte[32];
						curl_off_t off = new curl_off_t();
						if (ModernizedCProgram.curlx_strtoofft(nextarg, ((Object)0), 10, off)) {
							ModernizedCProgram.warnf(global, "unsupported range point\n");
							return .PARAM_BAD_USE;
						} 
						ModernizedCProgram.warnf(global, "A specified range MUST include at least one dash (-). Appending one for you!\n");
						ModernizedCProgram.curl_msnprintf(buffer, , "%I64d-", off);
						do {
							.free((config.getRange()));
							(config.getRange()) = ((Object)0);
						} while (0);
						config.setRange(.strdup(buffer));
						if (!config.getRange()) {
							return .PARAM_NO_MEM;
						} 
					} 
					{ 
						byte tmp_range;
						tmp_range = nextarg;
						while (tmp_range != (byte)'\0') {
							if (!(ModernizedCProgram.Curl_isdigit((int)((byte)tmp_range))) && tmp_range != (byte)'-' && tmp_range != (byte)',') {
								ModernizedCProgram.warnf(global, "Invalid character is found in given range. A specified range MUST have only digits in \'start\'-\'stop\'. The server's response to this request is uncertain.\n");
								break;
							} 
							tmp_range++;
						}
						do {
							if ((config.getRange())) {
								.free((config.getRange()));
								(config.getRange()) = ((Object)0);
							} 
							if ((nextarg)) {
								(config.getRange()) = .strdup((nextarg));
								if (!((config.getRange()))) {
									return .PARAM_NO_MEM;
								} 
							} 
						} while (/* byte range requested */0);
					}
					break;
			case (byte)'L':
					config.setFollowlocation(/* Follow Location: HTTP headers */toggle);
					switch (subletter) {
					case (byte)'t'/* Continue to send authentication (user+password) when following
					         * locations, even when hostname changed */:
							config.setUnrestricted_auth(toggle);
							break;
					}
					break;
			default:
					return .PARAM_OPTION_UNKNOWN;
			}
			hit = -1;
		} while (!longopt && !singleopt && ++parse && !usedarg);/* we can loop here if we have multiple single-letters */
		return .PARAM_OK;
	}
	/* NULL if unset */
	/* set to TRUE if the arg
	                                                 has been used */
	public static  parse_args(Object global, int argc, Object argv) {
		int i;
		bool stillflags = new bool();
		byte orig_opt = ((Object)0);
		ParameterError result = .PARAM_OK;
		OperationConfig config = global.getFirst();
		for (; i < argc && !result; i++) {
			orig_opt = argv[i];
			if (stillflags && ((byte)'-' == argv[i][0])) {
				bool passarg = new bool();
				byte flag = argv[i];
				if (!.strcmp("--", argv[i/* This indicates the end of the flags and thus enables the
				           following (URL) argument to start with -. */])) {
					stillflags = 0;
				} else {
						byte nextarg = (i < (argc - 1)) ? argv[i + 1] : ((Object)0);
						result = ModernizedCProgram.getparameter(flag, nextarg, passarg, global, config);
						if (result == .PARAM_NEXT_OPERATION/* Reset result as PARAM_NEXT_OPERATION is only used here and not
						             returned from this function */) {
							result = .PARAM_OK;
							if (config.getUrl_list() && config.getUrl_list().getUrl()) {
								config.setNext(.malloc(/* Allocate the next config */));
								if (config.getNext()) {
									ModernizedCProgram.config_init(config.getNext());
									config.getNext().setGlobal(/* Set the global config pointer */global);
									global.setLast(config.getNext());
									config.getNext().setPrev(/* Move onto the new config */config);
									config = config.getNext();
								} else {
										result = .PARAM_NO_MEM;
								} 
							} 
						}  else if (!result && passarg) {
							/* we're supposed to skip this */i++;
						} 
				} 
			} else {
					bool used = new bool();
					result = ModernizedCProgram.getparameter((byte)"--url", argv[i], used, /* Just add the URL please */global, config);
			} 
		}
		if (result && result != .PARAM_HELP_REQUESTED && result != .PARAM_MANUAL_REQUESTED && result != .PARAM_VERSION_INFO_REQUESTED && result != .PARAM_ENGINES_REQUESTED) {
			byte reason = ModernizedCProgram.param2text(result);
			if (orig_opt && .strcmp(":", orig_opt)) {
				ModernizedCProgram.helpf(global.getErrors(), "option %s: %s\n", orig_opt, reason);
			} else {
					ModernizedCProgram.helpf(global.getErrors(), "%s\n", reason);
			} 
		} 
		return result;
	}
	public static Object unescape_word(Object data, Object inputbuff) {
		byte newp = ((Object)0);
		byte dictp;
		size_t len = new size_t();
		CURLcode result = ModernizedCProgram.Curl_urldecode(data, inputbuff, 0, newp, len, 0);
		if (!newp || result) {
			return ((Object)0);
		} 
		dictp = .Curl_cmalloc(len * 2 + /* add one for terminating zero */1);
		if (dictp) {
			byte ptr;
			byte ch;
			int olen = 0/* According to RFC2229 section 2.2, these letters need to be escaped with
			       \[letter] */;
			for (ptr = newp; (ch = ptr) != 0; ptr++) {
				if ((ch <= 32) || (ch == 127) || (ch == (byte)'\'') || (ch == (byte)'\"') || (ch == (byte)'\\')) {
					dictp[olen++] = (byte)'\\';
				} 
				dictp[olen++] = ch;
			}
			dictp[olen] = 0;
		} 
		.Curl_cfree(newp);
		return dictp;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/*
	 * Forward declarations.
	 */
	public static  dict_do(Object conn, Object done) {
		byte word;
		byte eword;
		byte ppath;
		byte database = ((Object)0);
		byte strategy = ((Object)0);
		byte nthdef = ((Object)/* This is not part of the protocol, but required
		                          by RFC 2229 */0);
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		curl_socket_t sockfd = conn.getSock()[0];
		byte path = data.getState().getUp().getPath();
		done = /* unconditionally */1;
		if (conn.getBits().getUser_passwd()) {
		} 
		if (ModernizedCProgram.Curl_strncasecompare(path, "/MATCH:",  - 1) || ModernizedCProgram.Curl_strncasecompare(path, "/M:",  - 1) || ModernizedCProgram.Curl_strncasecompare(path, "/FIND:",  - 1)) {
			word = .strchr(path, (byte)':');
			if (word) {
				word++;
				database = .strchr(word, (byte)':');
				if (database) {
					database++ = (byte)0;
					strategy = .strchr(database, (byte)':');
					if (strategy) {
						strategy++ = (byte)0;
						nthdef = .strchr(strategy, (byte)':');
						if (nthdef) {
							nthdef = (byte)0;
						} 
					} 
				} 
			} 
			if ((word == ((Object)0)) || (word == (byte)0)) {
				ModernizedCProgram.Curl_infof(data, "lookup word is missing\n");
				word = (byte)"default";
			} 
			if ((database == ((Object)0)) || (database == (byte)0)) {
				database = (byte)"!";
			} 
			if ((strategy == ((Object)0)) || (strategy == (byte)0)) {
				strategy = (byte)".";
			} 
			eword = ModernizedCProgram.unescape_word(data, word);
			if (!eword) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			result = ModernizedCProgram.Curl_sendf(sockfd, conn, "CLIENT libcurl 7.67.0-DEV\r\nMATCH %s %s %s\r\nQUIT\r\n"/* database *//* strategy */, /* word */database, strategy, eword);
			.Curl_cfree(eword);
			if (result) {
				ModernizedCProgram.Curl_failf(data, "Failed sending DICT request");
				return result;
			} 
			ModernizedCProgram.Curl_setup_transfer(data, 0, -1, 0, -/* no upload */1);
		}  else if (ModernizedCProgram.Curl_strncasecompare(path, "/DEFINE:",  - 1) || ModernizedCProgram.Curl_strncasecompare(path, "/D:",  - 1) || ModernizedCProgram.Curl_strncasecompare(path, "/LOOKUP:",  - 1)) {
			word = .strchr(path, (byte)':');
			if (word) {
				word++;
				database = .strchr(word, (byte)':');
				if (database) {
					database++ = (byte)0;
					nthdef = .strchr(database, (byte)':');
					if (nthdef) {
						nthdef = (byte)0;
					} 
				} 
			} 
			if ((word == ((Object)0)) || (word == (byte)0)) {
				ModernizedCProgram.Curl_infof(data, "lookup word is missing\n");
				word = (byte)"default";
			} 
			if ((database == ((Object)0)) || (database == (byte)0)) {
				database = (byte)"!";
			} 
			eword = ModernizedCProgram.unescape_word(data, word);
			if (!eword) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			result = ModernizedCProgram.Curl_sendf(sockfd, conn, "CLIENT libcurl 7.67.0-DEV\r\nDEFINE %s %s\r\nQUIT\r\n"/* database */, /* word */database, eword);
			.Curl_cfree(eword);
			if (result) {
				ModernizedCProgram.Curl_failf(data, "Failed sending DICT request");
				return result;
			} 
			ModernizedCProgram.Curl_setup_transfer(data, 0, -1, 0, -1);
		} else {
				ppath = .strchr(path, (byte)'/');
				if (ppath) {
					int i;
					ppath++;
					for (i = 0; ppath[i]; i++) {
						if (ppath[i] == (byte)':') {
							ppath[i] = (byte)' ';
						} 
					}
					result = ModernizedCProgram.Curl_sendf(sockfd, conn, "CLIENT libcurl 7.67.0-DEV\r\n%s\r\nQUIT\r\n", ppath);
					if (result) {
						ModernizedCProgram.Curl_failf(data, "Failed sending DICT request");
						return result;
					} 
					ModernizedCProgram.Curl_setup_transfer(data, 0, -1, 0, -1);
				} 
		} 
		return .CURLE_OK/*CURL_DISABLE_DICT*/;
	}
	/*
	 * DICT protocol handler.
	 */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* Portable, consistent toupper (remember EBCDIC). Do not use toupper() because
	   its behavior is altered by the current locale. */
	public static byte Curl_raw_toupper(byte in) {
		if (in >= (byte)'a' && in <= (byte)'z') {
			return (byte)((byte)'A' + in - (byte)'a');
		} 
		return in;
	}
	/* Portable, consistent tolower (remember EBCDIC). Do not use tolower() because
	   its behavior is altered by the current locale. */
	public static byte Curl_raw_tolower(byte in) {
		if (in >= (byte)'A' && in <= (byte)'Z') {
			return (byte)((byte)'a' + in - (byte)'A');
		} 
		return in/*
		 * Curl_strcasecompare() is for doing "raw" case insensitive strings. This is
		 * meant to be locale independent and only compare strings we know are safe
		 * for this.  See
		 * https://daniel.haxx.se/blog/2008/10/15/strcasecmp-in-turkish/ for some
		 * further explanation to why this function is necessary.
		 *
		 * The function is capable of comparing a-z case insensitively even for
		 * non-ascii.
		 *
		 * @unittest: 1301
		 */;
	}
	public static int Curl_strcasecompare(Object first, Object second) {
		while (first && second) {
			if (ModernizedCProgram.Curl_raw_toupper(first) != ModernizedCProgram.Curl_raw_toupper(second/* get out of the loop as soon as they don't match */)) {
				break;
			} 
			first++;
			second/* we do the comparison here (possibly again), just to make sure that if the
			     loop above is skipped because one of the strings reached zero, we must not
			     return this as a successful match */++;
		}
		return (ModernizedCProgram.Curl_raw_toupper(first) == ModernizedCProgram.Curl_raw_toupper(second));
	}
	public static int Curl_safe_strcasecompare(Object first, Object second) {
		if (first && second) {
			return ModernizedCProgram.Curl_strcasecompare(first, /* both pointers point to something then compare them */second);
		} 
		return (((Object)0) == first && ((Object)0) == /* if both pointers are NULL then treat them as equal */second/*
		 * @unittest: 1301
		 */);
	}
	public static int Curl_strncasecompare(Object first, Object second, Object max) {
		while (first && second && max) {
			if (ModernizedCProgram.Curl_raw_toupper(first) != ModernizedCProgram.Curl_raw_toupper(second)) {
				break;
			} 
			max--;
			first++;
			second++;
		}
		if (0 == max) {
			return /* they are equal this far */1;
		} 
		return ModernizedCProgram.Curl_raw_toupper(first) == ModernizedCProgram.Curl_raw_toupper(second/* Copy an upper case version of the string from src to dest.  The
		 * strings may overlap.  No more than n characters of the string are copied
		 * (including any NUL) and the destination string will NOT be
		 * NUL-terminated if that limit is reached.
		 */);
	}
	public static void Curl_strntoupper(Object dest, Object src, Object n) {
		if (n < 1) {
			return ;
		} 
		do {
			dest++ = ModernizedCProgram.Curl_raw_toupper(src);
		} while (src++ && --n/* Copy a lower case version of the string from src to dest.  The
		 * strings may overlap.  No more than n characters of the string are copied
		 * (including any NUL) and the destination string will NOT be
		 * NUL-terminated if that limit is reached.
		 */);
	}
	public static void Curl_strntolower(Object dest, Object src, Object n) {
		if (n < 1) {
			return ;
		} 
		do {
			dest++ = ModernizedCProgram.Curl_raw_tolower(src);
		} while (src++ && --n);
	}
	/* --- public functions --- */
	public static int curl_strequal(Object first, Object second) {
		return ModernizedCProgram.Curl_strcasecompare(first, second);
	}
	public static int curl_strnequal(Object first, Object second, Object max) {
		return ModernizedCProgram.Curl_strncasecompare(first, second, max);
	}
	public static void Curl_freeset(Object data) {
		/* Free all dynamic strings stored in the data->set substructure. */dupstring i;
		for (dupstring.i = (dupstring)0; dupstring.i < dupstring.STRING_LAST; dupstring.i++) {
			do {
				.Curl_cfree((data.getSet().getStr()[dupstring.i]));
				(data.getSet().getStr()[dupstring.i]) = ((Object)0);
			} while (0);
		}
		if (data.getChange().getReferer_alloc()) {
			do {
				.Curl_cfree((data.getChange().getReferer()));
				(data.getChange().getReferer()) = ((Object)0);
			} while (0);
			data.getChange().setReferer_alloc(0);
		} 
		data.getChange().setReferer(((Object)0));
		if (data.getChange().getUrl_alloc()) {
			do {
				.Curl_cfree((data.getChange().getUrl()));
				(data.getChange().getUrl()) = ((Object)0);
			} while (0);
			data.getChange().setUrl_alloc(0);
		} 
		data.getChange().setUrl(((Object)0));
		ModernizedCProgram.Curl_mime_cleanpart(data.getSet().getMimepost());
	}
	/* free the URL pieces */
	public static void up_free(Object data) {
		urlpieces up = data.getState().getUp();
		do {
			.Curl_cfree((up.getScheme()));
			(up.getScheme()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((up.getHostname()));
			(up.getHostname()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((up.getPort()));
			(up.getPort()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((up.getUser()));
			(up.getUser()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((up.getPassword()));
			(up.getPassword()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((up.getOptions()));
			(up.getOptions()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((up.getPath()));
			(up.getPath()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((up.getQuery()));
			(up.getQuery()) = ((Object)0);
		} while (0);
		ModernizedCProgram.curl_url_cleanup(data.getState().getUh());
		data.getState().setUh(((Object)0/*
		 * This is the internal function curl_easy_cleanup() calls. This should
		 * cleanup and free all resources associated with this sessionhandle.
		 *
		 * NOTE: if we ever add something that attempts to write to a socket or
		 * similar here, we must ignore SIGPIPE first. It is currently only done
		 * when curl_easy_perform() is invoked.
		 */));
	}
	public static  Curl_close(Object data) {
		Curl_multi m = new Curl_multi();
		if (!data) {
			return .CURLE_OK;
		} 
		ModernizedCProgram.Curl_expire_clear(/* shut off timers */data);
		m = data.getMulti();
		if (m/* This handle is still part of a multi handle, take care of this first
		       and detach this handle from there. */) {
			ModernizedCProgram.curl_multi_remove_handle(data.getMulti(), data);
		} 
		if (data.getMulti_easy()) {
			ModernizedCProgram.curl_multi_cleanup(data.getMulti_easy());
			data.setMulti_easy(((Object)0));
		} 
		ModernizedCProgram.Curl_llist_destroy(data.getState().getTimeoutlist(), ((Object)/* Destroy the timeout list that is held in the easy handle. It is
		     /normally/ done by curl_multi_remove_handle() but this is "just in
		     case" */0));
		data.setMagic(/* force a clear AFTER the possibly enforced removal from
		                      the multi handle, since that function uses the magic
		                      field! */0);
		if (data.getState().getRangestringalloc()) {
			.Curl_cfree(data.getState().getRange());
		} 
		ModernizedCProgram.Curl_free_request_state(/* freed here just in case DONE wasn't called */data);
		do {
		} while (/* Close down all open SSL info and sessions */0);
		do {
			.Curl_cfree((data.getState().getFirst_host()));
			(data.getState().getFirst_host()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((data.getState().getScratch()));
			(data.getState().getScratch()) = ((Object)0);
		} while (0);
		do {
		} while (0);
		.Curl_cfree(data.getReq().getNewurl());
		data.getReq().setNewurl(((Object)0));
		if (data.getChange().getReferer_alloc()) {
			do {
				.Curl_cfree((data.getChange().getReferer()));
				(data.getChange().getReferer()) = ((Object)0);
			} while (0);
			data.getChange().setReferer_alloc(0);
		} 
		data.getChange().setReferer(((Object)0));
		ModernizedCProgram.up_free(data);
		do {
			.Curl_cfree((data.getState().getBuffer()));
			(data.getState().getBuffer()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((data.getState().getHeaderbuff()));
			(data.getState().getHeaderbuff()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((data.getState().getUlbuf()));
			(data.getState().getUlbuf()) = ((Object)0);
		} while (0);
		ModernizedCProgram.Curl_flush_cookies(data, 1);
		ModernizedCProgram.Curl_http_auth_cleanup_digest(data);
		do {
			.Curl_cfree((data.getInfo().getContenttype()));
			(data.getInfo().getContenttype()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((data.getInfo().getWouldredirect()));
			(data.getInfo().getWouldredirect()) = ((Object)0);
		} while (0);
		ModernizedCProgram.Curl_resolver_cleanup(data.getState().getResolver());
		;
		do {
		} while (0);
		if (data.getShare()) {
			ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_SHARE, .CURL_LOCK_ACCESS_SINGLE);
			data.getShare().getCurl_share()--;
			ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_SHARE);
		} 
		ModernizedCProgram.Curl_close(data.getReq().getDoh().getProbe()[0].getEasy());
		ModernizedCProgram.Curl_close(data.getReq().getDoh().getProbe()[1].getEasy());
		.Curl_cfree(data.getReq().getDoh().getProbe()[0].getServerdoh().getMemory());
		.Curl_cfree(data.getReq().getDoh().getProbe()[1].getServerdoh().getMemory());
		ModernizedCProgram.curl_slist_free_all(data.getReq().getDoh().getHeaders());
		ModernizedCProgram.Curl_wildcard_dtor(data.getWildcard());
		ModernizedCProgram.Curl_freeset(data);
		.Curl_cfree(data);
		return .CURLE_OK/*
		 * Initialize the UserDefined fields within a Curl_easy.
		 * This may be safely called on a new or existing Curl_easy.
		 */;
	}
	public static  Curl_init_userdefined(Object data) {
		UserDefined set = data.getSet();
		CURLcode result = .CURLE_OK;
		set.setOut((_iob[/* default output to stdout */1]));
		set.setIn_set((_iob[/* default input from stdin */0]));
		set.setErr((_iob[/* default stderr to stderr */2]));
		set.setFwrite_func((curl_write_callback)/* use fwrite as default function to store output */fwrite);
		set.setFread_func_set((curl_read_callback)/* use fread as default function to read input */fread);
		set.setIs_fread_set(0);
		set.setIs_fwrite_set(0);
		set.setSeek_func(0);
		set.setSeek_client(0);
		set.setConvfromnetwork(/* conversion callbacks for non-ASCII hosts */0);
		set.setConvtonetwork(0);
		set.setConvfromutf8(0);
		set.setFilesize(-/* we don't know the size */1);
		set.setPostfieldsize(-/* unknown size */1);
		set.setMaxredirs(-/* allow any amount by default */1);
		set.setHttpreq(/* Default HTTP request */.HTTPREQ_GET);
		set.setRtspreq(/* Default RTSP request */.RTSPREQ_OPTIONS);
		set.setFtp_use_epsv(/* FTP defaults to EPSV operations */1);
		set.setFtp_use_eprt(/* FTP defaults to EPRT operations */1);
		set.setFtp_use_pret(/* mainly useful for drftpd servers */0);
		set.setFtp_filemethod(.FTPFILE_MULTICWD);
		set.setDns_cache_timeout(/* Timeout every 60 seconds by default */60);
		set.getGeneral_ssl().setMax_ssl_sessions(/* Set the default size of the SSL session ID cache */5);
		set.setProxyport(0);
		set.setProxytype(/* defaults to HTTP proxy */.CURLPROXY_HTTP);
		set.setHttpauth((((long)1) << /* defaults to basic */0));
		set.setProxyauth((((long)1) << /* defaults to basic */0));
		set.setSocks5auth((((long)1) << 0) | (((long)1) << /* SOCKS5 proxy auth defaults to username/password + GSS-API */2));
		set.setHide_progress(/* make libcurl quiet by default: *//* CURLOPT_NOPROGRESS changes these */1);
		ModernizedCProgram.Curl_mime_initpart(set.getMimepost(), data/*
		   * libcurl 7.10 introduced SSL verification *by default*! This needs to be
		   * switched off unless wanted.
		   */);
		set.getSsl().getPrimary().setVerifypeer(1);
		set.getSsl().getPrimary().setVerifyhost(1);
		set.setSsh_auth_types(~/* defaults to any auth
		                                                      type */0);
		set.getSsl().getPrimary().setSessionid(/* session ID caching enabled by
		                                        default */1);
		set.setProxy_ssl(set.getSsl());
		set.setNew_file_perms(/* Default permissions */644);
		set.setNew_directory_perms(/* Default permissions */755/* for the *protocols fields we don't use the CURLPROTO_ALL convenience
		     define since we internally only use the lower 16 bits for the passed
		     in bitmask to not conflict with the private bits */);
		set.setAllowed_protocols((~0));
		set.setRedir_protocols((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3/*
		   * disallow unprotected protection negotiation NEC reference implementation
		   * seem not to follow rfc1961 section 4.3/4.4
		   */));
		if (.Curl_ssl_backend() != /* Set the default CA cert bundle/path detected/specified at build time.
		   *
		   * If Schannel is the selected SSL backend then these locations are
		   * ignored. We allow setting CA location for schannel only when explicitly
		   * specified by the user via CURLOPT_CAINFO / --cacert.
		   */.CURLSSLBACKEND_SCHANNEL) {
		} 
		set.setWildcard_enabled(0);
		set.setChunk_bgn(0);
		set.setChunk_end(0);
		set.setTcp_keepalive(0);
		set.setTcp_keepintvl(60);
		set.setTcp_keepidle(60);
		set.setTcp_fastopen(0);
		set.setTcp_nodelay(1);
		set.setSsl_enable_npn(1);
		set.setSsl_enable_alpn(1);
		set.setExpect_100_timeout(/* Wait for a second by default. */-1024);
		set.setSep_headers(/* separated header lists by default */1);
		set.setBuffer_size(16384);
		set.setUpload_buffer_size(65536);
		set.setHappy_eyeballs_timeout(-1024);
		set.setFnmatch(0);
		set.setUpkeep_interval_ms(-1024);
		set.setMaxconnects(/* for easy handles */5);
		set.setMaxage_conn(118);
		set.setHttp09_allowed(0);
		set.setHttpversion(.CURL_HTTP_VERSION_1_1);
		;
		return result/**
		 * Curl_open()
		 *
		 * @param curl is a pointer to a sessionhandle pointer that gets set by this
		 * function.
		 * @return CURLcode
		 */;
	}
	public static  Curl_open(Object curl) {
		CURLcode result = new CURLcode();
		Curl_easy data = new Curl_easy();
		data = .Curl_ccalloc(1, /* Very simple start-up: alloc the struct, init it with zeroes and return */);
		if (!data) {
			do {
			} while (/* this is a very serious error */0);
			return .CURLE_OUT_OF_MEMORY;
		} 
		data.setMagic(-1024);
		result = ModernizedCProgram.Curl_resolver_init(data, data.getState().getResolver());
		if (result) {
			do {
			} while (0);
			.Curl_cfree(data);
			return result;
		} 
		data.getState().setBuffer(.Curl_cmalloc(16384 + /* We do some initial setup here, all those fields that can't be just 0 */1));
		if (!data.getState().getBuffer()) {
			do {
			} while (0);
			result = .CURLE_OUT_OF_MEMORY;
		} else {
				data.getState().setHeaderbuff(.Curl_cmalloc(256));
				if (!data.getState().getHeaderbuff()) {
					do {
					} while (0);
					result = .CURLE_OUT_OF_MEMORY;
				} else {
						result = ModernizedCProgram.Curl_init_userdefined(data);
						data.getState().setHeadersize(256);
						do {
						} while (0);
						ModernizedCProgram.Curl_initinfo(data);
						data.getState().setLastconnect(((Object)/* most recent connection is not yet defined */0));
						data.getProgress().getFlags() |=  (1 << 4);
						data.getState().setCurrent_speed(-/* init to negative == impossible */1);
				} 
		} 
		if (result) {
			ModernizedCProgram.Curl_resolver_cleanup(data.getState().getResolver());
			.Curl_cfree(data.getState().getBuffer());
			.Curl_cfree(data.getState().getHeaderbuff());
			ModernizedCProgram.Curl_freeset(data);
			.Curl_cfree(data);
			data = ((Object)0);
		} else {
				curl = data;
		} 
		return result;
	}
	public static void conn_reset_postponed_data(Object conn, int num) {
		postponed_data psnd = (conn.getPostponed()[num]);
		if (psnd.getBuffer()) {
			do {
			} while (0);
			do {
			} while (0);
			do {
			} while (0);
			do {
			} while (0);
			.Curl_cfree(psnd.getBuffer());
			psnd.setBuffer(((Object)0));
			psnd.setAllocated_size(0);
			psnd.setRecv_size(0);
			psnd.setRecv_processed(0/* used only for DEBUGASSERT */);
		} else {
				do {
				} while (/* DEBUGBUILD */0);
				do {
				} while (0);
				do {
				} while (0);
				do {
				} while (0);
		} 
	}
	public static void conn_reset_all_postponed_data(Object conn) {
		ModernizedCProgram.conn_reset_postponed_data(conn, 0);
		ModernizedCProgram.conn_reset_postponed_data(conn, 1/* ! USE_RECV_BEFORE_SEND_WORKAROUND *//* Use "do-nothing" macro instead of function when workaround not used */);
	}
	/* ! USE_RECV_BEFORE_SEND_WORKAROUND */
	public static void conn_shutdown(Object conn) {
		if (!conn) {
			return ;
		} 
		ModernizedCProgram.Curl_infof(conn.getData(), "Closing connection %ld\n", conn.getConnection_id());
		do {
		} while (0);
		ModernizedCProgram.Curl_resolver_cancel(/* possible left-overs from the async name resolvers */conn);
		do {
		} while (/* close the SSL stuff before we close any sockets since they will/may
		     write to the sockets */0);
		do {
		} while (0);
		if ((SOCKET)(~0) != conn.getSock()[/* close possibly still open sockets */1]) {
			ModernizedCProgram.Curl_closesocket(conn, conn.getSock()[1]);
		} 
		if ((SOCKET)(~0) != conn.getSock()[0]) {
			ModernizedCProgram.Curl_closesocket(conn, conn.getSock()[0]);
		} 
		if ((SOCKET)(~0) != conn.getTempsock()[0]) {
			ModernizedCProgram.Curl_closesocket(conn, conn.getTempsock()[0]);
		} 
		if ((SOCKET)(~0) != conn.getTempsock()[1]) {
			ModernizedCProgram.Curl_closesocket(conn, conn.getTempsock()[1]);
		} 
		ModernizedCProgram.Curl_conncache_remove_conn(conn.getData(), conn, /* unlink ourselves. this should be called last since other shutdown
		     procedures need a valid conn->data and this may clear it. */1);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* prototype for curl_win32_idn_to_ascii() */
	/* USE_LIBIDN2 */
	/* And now for the protocols */
	/* The last 3 #include files should be in this order */
	public static void conn_free(Object conn) {
		if (!conn) {
			return ;
		} 
		ModernizedCProgram.free_idnconverted_hostname(conn.getHost());
		ModernizedCProgram.free_idnconverted_hostname(conn.getConn_to_host());
		ModernizedCProgram.free_idnconverted_hostname(conn.getHttp_proxy().getHost());
		ModernizedCProgram.free_idnconverted_hostname(conn.getSocks_proxy().getHost());
		do {
			.Curl_cfree((conn.getUser()));
			(conn.getUser()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getPasswd()));
			(conn.getPasswd()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getOauth_bearer()));
			(conn.getOauth_bearer()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getSasl_authzid()));
			(conn.getSasl_authzid()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getOptions()));
			(conn.getOptions()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getHttp_proxy().getUser()));
			(conn.getHttp_proxy().getUser()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getSocks_proxy().getUser()));
			(conn.getSocks_proxy().getUser()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getHttp_proxy().getPasswd()));
			(conn.getHttp_proxy().getPasswd()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getSocks_proxy().getPasswd()));
			(conn.getSocks_proxy().getPasswd()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getAllocptr().getProxyuserpwd()));
			(conn.getAllocptr().getProxyuserpwd()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getAllocptr().getUagent()));
			(conn.getAllocptr().getUagent()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getAllocptr().getUserpwd()));
			(conn.getAllocptr().getUserpwd()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getAllocptr().getAccept_encoding()));
			(conn.getAllocptr().getAccept_encoding()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getAllocptr().getTe()));
			(conn.getAllocptr().getTe()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getAllocptr().getRangeline()));
			(conn.getAllocptr().getRangeline()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getAllocptr().getRef()));
			(conn.getAllocptr().getRef()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getAllocptr().getHost()));
			(conn.getAllocptr().getHost()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getAllocptr().getCookiehost()));
			(conn.getAllocptr().getCookiehost()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getAllocptr().getRtsp_transport()));
			(conn.getAllocptr().getRtsp_transport()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getTrailer()));
			(conn.getTrailer()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getHost().getRawalloc()));
			(conn.getHost().getRawalloc()) = ((Object)0);
		} while (/* host name buffer */0);
		do {
			.Curl_cfree((conn.getConn_to_host().getRawalloc()));
			(conn.getConn_to_host().getRawalloc()) = ((Object)0);
		} while (/* host name buffer */0);
		do {
			.Curl_cfree((conn.getHostname_resolve()));
			(conn.getHostname_resolve()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getSecondaryhostname()));
			(conn.getSecondaryhostname()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getHttp_proxy().getHost().getRawalloc()));
			(conn.getHttp_proxy().getHost().getRawalloc()) = ((Object)0);
		} while (/* http proxy name buffer */0);
		do {
			.Curl_cfree((conn.getSocks_proxy().getHost().getRawalloc()));
			(conn.getSocks_proxy().getHost().getRawalloc()) = ((Object)0);
		} while (/* socks proxy name buffer */0);
		do {
			.Curl_cfree((conn.getConnect_state()));
			(conn.getConnect_state()) = ((Object)0);
		} while (0);
		ModernizedCProgram.conn_reset_all_postponed_data(conn);
		ModernizedCProgram.Curl_llist_destroy(conn.getEasyq(), ((Object)0));
		do {
			.Curl_cfree((conn.getLocaldev()));
			(conn.getLocaldev()) = ((Object)0);
		} while (0);
		.Curl_free_primary_ssl_config(conn.getSsl_config());
		.Curl_free_primary_ssl_config(conn.getProxy_ssl_config());
		.Curl_cfree(/* free all the connection oriented data */conn/*
		 * Disconnects the given connection. Note the connection may not be the
		 * primary connection, like when freeing room in the connection cache or
		 * killing of a dead old connection.
		 *
		 * A connection needs an easy handle when closing down. We support this passed
		 * in separately since the connection to get closed here is often already
		 * disassociated from an easy handle.
		 *
		 * This function MUST NOT reset state in the Curl_easy struct if that
		 * isn't strictly bound to the life-time of *this* particular connection.
		 *
		 */);
	}
	public static  Curl_disconnect(Object data, Object conn,  dead_connection) {
		if (!conn) {
			return /* this is closed and fine already */.CURLE_OK;
		} 
		if (!data) {
			do {
			} while (0);
			return .CURLE_OK/*
			   * If this connection isn't marked to force-close, leave it open if there
			   * are other users of it
			   */;
		} 
		if (((conn).getEasyq().getSize()) && !dead_connection) {
			do {
			} while (0);
			return .CURLE_OK;
		} 
		if (conn.getDns_entry() != ((Object)0)) {
			ModernizedCProgram.Curl_resolv_unlock(data, conn.getDns_entry());
			conn.setDns_entry(((Object)0));
		} 
		ModernizedCProgram.Curl_hostcache_prune(/* kill old DNS cache entries */data);
		ModernizedCProgram.Curl_http_auth_cleanup_ntlm(/* Cleanup NTLM connection-related data */conn/* Cleanup NEGOTIATE connection-related data */);
		conn.setData(/* the protocol specific disconnect handler and conn_shutdown need a transfer
		     for the connection! */data);
		if (conn.getBits().getConnect_only()) {
			dead_connection = /* treat the connection as dead in CONNECT_ONLY situations */1;
		} 
		if (conn.getHandler().getDisconnect()) {
			.UNRECOGNIZEDFUNCTIONNAME(conn, /* This is set if protocol-specific cleanups should be made */dead_connection);
		} 
		ModernizedCProgram.conn_shutdown(conn);
		ModernizedCProgram.conn_free(conn);
		return .CURLE_OK/*
		 * This function should return TRUE if the socket is to be assumed to
		 * be dead. Most commonly this happens when the server has closed the
		 * connection due to inactivity.
		 */;
	}
	public static  SocketIsDead(Object sock) {
		int sval;
		bool ret_val = 1;
		sval = ModernizedCProgram.Curl_socket_check(sock, (SOCKET)(~0), (SOCKET)(~0), (time_t)0);
		if (sval == 0) {
			ret_val = /* timeout */0;
		} 
		return ret_val/*
		 * IsMultiplexingPossible()
		 *
		 * Return a bitmask with the available multiplexing options for the given
		 * requested connection.
		 */;
	}
	public static int IsMultiplexingPossible(Object handle, Object conn) {
		int avail = 0;
		if ((conn.getHandler().getProtocol() & ((1 << 0) | (1 << /* If a HTTP protocol and multiplexing is enabled */1))) && (!conn.getBits().getProtoconnstart() || !conn.getBits().getClose())) {
			if (ModernizedCProgram.Curl_multiplex_wanted(handle.getMulti()) && (handle.getSet().getHttpversion() >= .CURL_HTTP_VERSION_2_0)) {
				avail |=  /* allows HTTP/2 */-1024;
			} 
		} 
		return avail;
	}
	public static  proxy_info_matches(Object data, Object needle) {
		if ((data.getProxytype() == needle.getProxytype()) && (data.getPort() == needle.getPort()) && ModernizedCProgram.Curl_safe_strcasecompare(data.getHost().getName(), needle.getHost().getName())) {
			return 1;
		} 
		return 0/* disabled, won't get called */;
	}
	public static  extract_if_dead(Object conn, Object data) {
		curltime curltime = new curltime();
		if (!((conn).getEasyq().getSize()) && !conn.getData()) {
			bool dead = new bool();
			curltime now = curltime.Curl_now();
			if (now.conn_maxage(data, conn)) {
				dead = 1;
			}  else if (conn.getHandler().getConnection_check()) {
				int state;
				Curl_easy olddata = conn.getData();
				conn.setData(/* use this transfer for now */data);
				state = .UNRECOGNIZEDFUNCTIONNAME(conn, (1 << 0));
				conn.setData(olddata);
				dead = (state & (1 << 0));
			} else {
					dead = ModernizedCProgram.SocketIsDead(conn.getSock()[/* Use the general method for determining the death of a connection */0]);
			} 
			if (dead) {
				ModernizedCProgram.Curl_infof(data, "Connection %ld seems to be dead!\n", conn.getConnection_id());
				ModernizedCProgram.Curl_conncache_remove_conn(data, conn, 0);
				return 1;
			} 
		} 
		return 0;
	}
	public static int call_extract_if_dead(Object conn, Object param) {
		prunedead p = (prunedead)param;
		if (ModernizedCProgram.extract_if_dead(conn, p.getData())) {
			p.setExtracted(/* stop the iteration here, pass back the connection that was extracted */conn);
			return 1;
		} 
		return /* continue iteration */0/*
		 * This function scans the connection cache for half-open/dead connections,
		 * closes and removes them.
		 * The cleanup is done at most once per second.
		 */;
	}
	public static void prune_dead_connections(Object data) {
		curltime curltime = new curltime();
		curltime now = curltime.Curl_now();
		timediff_t elapsed = now.Curl_timediff(data.getState().getConn_cache().getLast_cleanup());
		Object generatedExtracted = prune.getExtracted();
		if (elapsed >= -1024) {
			prunedead prune = new prunedead();
			prune.setData(data);
			prune.setExtracted(((Object)0));
			while (ModernizedCProgram.Curl_conncache_foreach(data, data.getState().getConn_cache(), prune, call_extract_if_dead)) {
				(Object)ModernizedCProgram.Curl_disconnect(data, generatedExtracted, /* disconnect it *//* dead_connection */1);
			}
			data.getState().getConn_cache().setLast_cleanup(now/*
			 * Given one filled in connection struct (named needle), this function should
			 * detect if there already is one that has all the significant details
			 * exactly the same and thus should be used instead.
			 *
			 * If there is a match, this function returns TRUE - and has marked the
			 * connection as 'in-use'. It must later be called with ConnectionDone() to
			 * return back to 'idle' (unused) state.
			 *
			 * The force_reuse flag is set if the connection must be used.
			 */);
		} 
	}
	public static  ConnectionExists(Object data, Object needle, Object usethis, Object force_reuse, Object waitpipe) {
		connectdata check = new connectdata();
		connectdata chosen = 0;
		bool foundPendingCandidate = 0;
		bool canmultiplex = ModernizedCProgram.IsMultiplexingPossible(data, needle);
		connectbundle bundle = new connectbundle();
		byte hostbundle;
		bool wantNTLMhttp = ((data.getState().getAuthhost().getWant() & ((((long)1) << 3) | (((long)1) << 5))) && (needle.getHandler().getProtocol() & ((1 << 0) | (1 << 1))));
		bool wantProxyNTLMhttp = (needle.getBits().getProxy_user_passwd() && ((data.getState().getAuthproxy().getWant() & ((((long)1) << 3) | (((long)1) << 5))) && (needle.getHandler().getProtocol() & ((1 << 0) | (1 << 1)))));
		force_reuse = 0;
		waitpipe = 0;
		bundle = ModernizedCProgram.Curl_conncache_find_bundle(needle, data.getState().getConn_cache(), hostbundle);
		if (bundle/* Max pipe length is zero (unlimited) for multiplexed connections */) {
			curl_llist_element curr = new curl_llist_element();
			ModernizedCProgram.Curl_infof(data, "Found bundle for host %s: %p [%s]\n", hostbundle, (Object)bundle, (bundle.getMultiuse() == 2 ? "can multiplex" : "serially"));
			if (/* We can't multiplex if we don't know anything about the server */canmultiplex) {
				if (bundle.getMultiuse() == 0) {
					if (data.getSet().getPipewait()) {
						ModernizedCProgram.Curl_infof(data, "Server doesn't support multiplex yet, wait\n");
						waitpipe = 1;
						ModernizedCProgram.Curl_conncache_unlock(data);
						return /* no re-use */0;
					} 
					ModernizedCProgram.Curl_infof(data, "Server doesn't support multiplex (yet)\n");
					canmultiplex = 0;
				} 
				if ((bundle.getMultiuse() == 2) && !ModernizedCProgram.Curl_multiplex_wanted(data.getMulti())) {
					ModernizedCProgram.Curl_infof(data, "Could multiplex, but not asked to!\n");
					canmultiplex = 0;
				} 
				if (bundle.getMultiuse() == -1) {
					ModernizedCProgram.Curl_infof(data, "Can not multiplex, even if we wanted to!\n");
					canmultiplex = 0;
				} 
			} 
			curr = bundle.getConn_list().getHead();
			while (curr) {
				bool match = 0;
				size_t multiplexed = new size_t();
				check = curr.getPtr();
				curr = curr.getNext();
				if (check.getBits().getConnect_only()) {
					continue;
				} 
				multiplexed = ((check).getEasyq().getSize()) && (bundle.getMultiuse() == 2);
				if (canmultiplex) {
					if (check.getBits().getProtoconnstart() && check.getBits().getClose()) {
						continue;
					} 
				} else {
						if (multiplexed/* can only happen within multi handles, and means that another easy
						             handle is using this connection */) {
							continue;
						} 
						if (1/* ip_addr_str[0] is NUL only if the resolving of the name hasn't
						             completed yet and until then we don't re-use this connection */) {
							if (!check.getIp_addr_str()[0]) {
								ModernizedCProgram.Curl_infof(data, "Connection #%ld is still name resolving, can't reuse\n", check.getConnection_id());
								continue;
							} 
						} 
						if ((check.getSock()[0] == (SOCKET)(~0)) || check.getBits().getClose()) {
							if (!check.getBits().getClose()) {
								foundPendingCandidate = 1/* Don't pick a connection that hasn't connected yet or that is going
								             to get closed. */;
							} 
							ModernizedCProgram.Curl_infof(data, "Connection #%ld isn't open enough, can't reuse\n", check.getConnection_id());
							continue;
						} 
				} 
				if ((needle.getHandler().getFlags() & (1 << 0)) != (check.getHandler().getFlags() & (1 << 0))) {
					if (ModernizedCProgram.get_protocol_family(check.getHandler().getProtocol()) != needle.getHandler().getProtocol() || !check.getTls_upgraded()) {
						continue;
					} 
				} 
				if (needle.getBits().getHttpproxy() != check.getBits().getHttpproxy() || needle.getBits().getSocksproxy() != check.getBits().getSocksproxy()) {
					continue;
				} 
				if (needle.getBits().getSocksproxy() && !ModernizedCProgram.proxy_info_matches(needle.getSocks_proxy(), check.getSocks_proxy())) {
					continue;
				} 
				if (needle.getBits().getConn_to_host() != check.getBits().getConn_to_host()) {
					continue;
				} 
				if (needle.getBits().getConn_to_port() != check.getBits().getConn_to_port()) {
					continue;
				} 
				if (needle.getBits().getHttpproxy()) {
					if (!ModernizedCProgram.proxy_info_matches(needle.getHttp_proxy(), check.getHttp_proxy())) {
						continue;
					} 
					if (needle.getBits().getTunnel_proxy() != check.getBits().getTunnel_proxy()) {
						continue;
					} 
					if (needle.getHttp_proxy().getProxytype() == .CURLPROXY_HTTPS) {
						if (needle.getHandler().getFlags() & (1 << /* use https proxy */0)) {
							if (!.Curl_ssl_config_matches(needle.getProxy_ssl_config(), check.getProxy_ssl_config())) {
								continue;
							} 
							if (check.getProxy_ssl()[0].getState() != .ssl_connection_complete) {
								continue;
							} 
						} else {
								if (!.Curl_ssl_config_matches(needle.getSsl_config(), check.getSsl_config())) {
									continue;
								} 
								if (check.getSsl()[0].getState() != .ssl_connection_complete) {
									continue;
								} 
						} 
					} 
				} 
				if (!canmultiplex && check.getData()) {
					continue;
				} 
				if (((check).getEasyq().getSize()) && check.getData() && (check.getData().getMulti() != needle.getData().getMulti())) {
					continue;
				} 
				if (needle.getLocaldev() || needle.getLocalport()) {
					if ((check.getLocalport() != needle.getLocalport()) || (check.getLocalportrange() != needle.getLocalportrange()) || (needle.getLocaldev() && (!check.getLocaldev() || .strcmp(check.getLocaldev(), needle.getLocaldev())))) {
						continue;
					} 
				} 
				if (!(needle.getHandler().getFlags() & (1 << 7/* This protocol requires credentials per connection,
				           so verify that we're using the same name and password as well */))) {
					if (.strcmp(needle.getUser(), check.getUser()) || .strcmp(needle.getPasswd(), check.getPasswd())) {
						continue;
					} 
				} 
				if (!needle.getBits().getHttpproxy() || (needle.getHandler().getFlags() & (1 << 0)) || needle.getBits().getTunnel_proxy()) {
					if ((ModernizedCProgram.Curl_strcasecompare(needle.getHandler().getScheme(), check.getHandler().getScheme()) || (ModernizedCProgram.get_protocol_family(check.getHandler().getProtocol()) == needle.getHandler().getProtocol() && check.getTls_upgraded())) && (!needle.getBits().getConn_to_host() || ModernizedCProgram.Curl_strcasecompare(needle.getConn_to_host().getName(), check.getConn_to_host().getName())) && (!needle.getBits().getConn_to_port() || needle.getConn_to_port() == check.getConn_to_port()) && ModernizedCProgram.Curl_strcasecompare(needle.getHost().getName(), check.getHost().getName()) && needle.getRemote_port() == check.getRemote_port()) {
						if (needle.getHandler().getFlags() & (1 << 0/* This is a SSL connection so verify that we're using the same
						               SSL options as well */)) {
							if (!.Curl_ssl_config_matches(needle.getSsl_config(), check.getSsl_config())) {
								do {
								} while (0);
								continue;
							} 
							if (check.getSsl()[0].getState() != .ssl_connection_complete) {
								foundPendingCandidate = 1;
								do {
								} while (0);
								continue;
							} 
						} 
						match = 1;
					} 
				} else {
						match = /* The requested connection is using the same HTTP proxy in normal
						           mode (no tunneling) */1;
				} 
				if (match/* If we are looking for an HTTP+NTLM connection, check if this is
				           already authenticating with the right credentials. If not, keep
				           looking so that we can reuse NTLM connections if
				           possible. (Especially we must not reuse the same connection if
				           partway through a handshake!) */) {
					if (wantNTLMhttp) {
						if (.strcmp(needle.getUser(), check.getUser()) || .strcmp(needle.getPasswd(), check.getPasswd())) {
							if (check.getHttp_ntlm_state() == /* we prefer a credential match, but this is at least a connection
							               that can be reused and "upgraded" to NTLM */.NTLMSTATE_NONE) {
								chosen = check;
							} 
							continue;
						} 
					}  else if (check.getHttp_ntlm_state() != .NTLMSTATE_NONE/* Connection is using NTLM auth but we don't want NTLM */) {
						continue;
					} 
					if (/* Same for Proxy NTLM authentication */wantProxyNTLMhttp/* Both check->http_proxy.user and check->http_proxy.passwd can be
					           * NULL */) {
						if (!check.getHttp_proxy().getUser() || !check.getHttp_proxy().getPasswd()) {
							continue;
						} 
						if (.strcmp(needle.getHttp_proxy().getUser(), check.getHttp_proxy().getUser()) || .strcmp(needle.getHttp_proxy().getPasswd(), check.getHttp_proxy().getPasswd())) {
							continue;
						} 
					}  else if (check.getProxy_ntlm_state() != .NTLMSTATE_NONE/* Proxy connection is using NTLM auth but we don't want NTLM */) {
						continue;
					} 
					if (wantNTLMhttp || wantProxyNTLMhttp) {
						chosen = /* Credentials are already checked, we can use this connection */check;
						if ((wantNTLMhttp && (check.getHttp_ntlm_state() != .NTLMSTATE_NONE)) || (wantProxyNTLMhttp && (check.getProxy_ntlm_state() != .NTLMSTATE_NONE))) {
							force_reuse = /* We must use this connection, no other */1;
							break;
						} 
						continue;
					} 
					if (canmultiplex/* We can multiplex if we want to. Let's continue looking for
					             the optimal connection to use. */) {
						if (!multiplexed) {
							chosen = /* We have the optimal connection. Let's stop looking. */check;
							break;
						} 
						chosen = /* When not multiplexed, we have a match here! */check;
						ModernizedCProgram.Curl_infof(data, "Multiplexed connection found!\n");
						break;
					} else {
							chosen = /* We have found a connection. Let's stop searching. */check;
							break;
					} 
				} 
			}
		} 
		if (chosen) {
			chosen.setData(/* mark it as used before releasing the lock *//* own it! */data);
			ModernizedCProgram.Curl_conncache_unlock(data);
			usethis = chosen;
			return /* yes, we found one to use! */1;
		} 
		ModernizedCProgram.Curl_conncache_unlock(data);
		if (foundPendingCandidate && data.getSet().getPipewait()) {
			ModernizedCProgram.Curl_infof(data, "Found pending candidate for reuse and CURLOPT_PIPEWAIT is set\n");
			waitpipe = 1;
		} 
		return /* no matching connecting exists */0/*
		 * verboseconnect() displays verbose information after a connect
		 */;
	}
	public static void Curl_verboseconnect(Object conn) {
		if (conn.getData().getSet().getVerbose()) {
			ModernizedCProgram.Curl_infof(conn.getData(), "Connected to %s (%s) port %ld (#%ld)\n", conn.getBits().getSocksproxy() ? conn.getSocks_proxy().getHost().getDispname() : conn.getBits().getHttpproxy() ? conn.getHttp_proxy().getHost().getDispname() : conn.getBits().getConn_to_host() ? conn.getConn_to_host().getDispname() : conn.getHost().getDispname(), conn.getIp_addr_str(), conn.getPort(), conn.getConnection_id());
		} 
	}
	/*
	 * Helpers for IDNA conversions.
	 */
	public static  is_ASCII_name(Object hostname) {
		byte ch = (byte)hostname;
		while (ch) {
			if (ch++ & -1024) {
				return 0;
			} 
		}
		return 1/*
		 * Strip single trailing dot in the hostname,
		 * primarily for SNI and http host header.
		 */;
	}
	public static void strip_trailing_dot(Object host) {
		size_t len = new size_t();
		if (!host || !host.getName()) {
			return ;
		} 
		len = .strlen(host.getName());
		if (len && (host.getName()[len - 1] == (byte)'.')) {
			host.getName()[len - 1] = 0/*
			 * Perform any necessary IDN conversion of hostname
			 */;
		} 
	}
	public static  idnconvert_hostname(Object conn, Object host) {
		Curl_easy data = conn.getData();
		(Object)data;
		(Object)conn;
		host.setDispname(host.getName());
		if (!ModernizedCProgram.is_ASCII_name(host.getName())) {
			ModernizedCProgram.Curl_infof(data, /* change the name pointer to point to the encoded hostname */"IDN support not present, can't parse Unicode domains\n");
		} 
		return .CURLE_OK/*
		 * Frees data allocated by idnconvert_hostname()
		 */;
	}
	public static void free_idnconverted_hostname(Object host) {
		(Object)/* must be freed with free() since this was
		                           allocated by curl_win32_idn_to_ascii */host;
	}
	/* must be freed with idn2_free() since this was
	                                 allocated by libidn */
	public static Object allocate_conn(Object data) {
		connectdata conn = .Curl_ccalloc(1, );
		if (!conn) {
			return ((Object)0/* The SSL backend-specific data (ssl_backend_data) objects are allocated as
			     a separate array to ensure suitable alignment.
			     Note that these backend pointers can be swapped by vtls (eg ssl backend
			     data becomes proxy backend data). */);
		} 
		conn.setHandler(/* Be sure we have a handler defined
		                                           already from start to avoid NULL
		                                           situations and checks */ModernizedCProgram.Curl_handler_dummy);
		conn.getSock()[0] = (SOCKET)(~/* and we setup a few fields in case we end up actually using this struct *//* no file descriptor */0);
		conn.getSock()[1] = (SOCKET)(~/* no file descriptor */0);
		conn.getTempsock()[0] = (SOCKET)(~/* no file descriptor */0);
		conn.getTempsock()[1] = (SOCKET)(~/* no file descriptor */0);
		conn.setConnection_id(-/* no ID */1);
		conn.setPort(-/* unknown at this point */1);
		conn.setRemote_port(-/* unknown at this point */1/* no file descriptor *//* no file descriptor *//* USE_RECV_BEFORE_SEND_WORKAROUND && DEBUGBUILD */);
		ModernizedCProgram.Curl_conncontrol(conn, /* Default protocol-independent behavior doesn't support persistent
		     connections, so we set this to force-close. Protocols that support
		     this need to set this to FALSE in their "curl_do" functions. */1);
		curltime curltime = new curltime();
		conn.setCreated(curltime.Curl_now());
		conn.setKeepalive(curltime.Curl_now());
		conn.setUpkeep_interval_ms(data.getSet().getUpkeep_interval_ms());
		conn.setData(/* Setup the association between this connection
		                        and the Curl_easy */data);
		conn.getHttp_proxy().setProxytype(data.getSet().getProxytype());
		conn.getSocks_proxy().setProxytype(.CURLPROXY_SOCKS4);
		conn.getBits().setProxy((data.getSet().getStr()[/* note that these two proxy bits are now just on what looks to be
		     requested, they may be altered down the road */dupstring.STRING_PROXY] && data.getSet().getStr()[dupstring.STRING_PROXY]) ? 1 : 0);
		conn.getBits().setHttpproxy((conn.getBits().getProxy() && (conn.getHttp_proxy().getProxytype() == .CURLPROXY_HTTP || conn.getHttp_proxy().getProxytype() == .CURLPROXY_HTTP_1_0 || conn.getHttp_proxy().getProxytype() == .CURLPROXY_HTTPS)) ? 1 : 0);
		conn.getBits().setSocksproxy((conn.getBits().getProxy() && !conn.getBits().getHttpproxy()) ? 1 : 0);
		if (data.getSet().getStr()[dupstring.STRING_PRE_PROXY] && data.getSet().getStr()[dupstring.STRING_PRE_PROXY]) {
			conn.getBits().setProxy(1);
			conn.getBits().setSocksproxy(1);
		} 
		conn.getBits().setProxy_user_passwd((data.getSet().getStr()[dupstring.STRING_PROXYUSERNAME]) ? 1 : 0);
		conn.getBits().setTunnel_proxy(data.getSet().getTunnel_thru_httpproxy());
		conn.getBits().setUser_passwd((data.getSet().getStr()[dupstring.STRING_USERNAME]) ? 1 : 0);
		conn.getBits().setFtp_use_epsv(data.getSet().getFtp_use_epsv());
		conn.getBits().setFtp_use_eprt(data.getSet().getFtp_use_eprt());
		conn.getSsl_config().setVerifystatus(data.getSet().getSsl().getPrimary().getVerifystatus());
		conn.getSsl_config().setVerifypeer(data.getSet().getSsl().getPrimary().getVerifypeer());
		conn.getSsl_config().setVerifyhost(data.getSet().getSsl().getPrimary().getVerifyhost());
		conn.getProxy_ssl_config().setVerifystatus(data.getSet().getProxy_ssl().getPrimary().getVerifystatus());
		conn.getProxy_ssl_config().setVerifypeer(data.getSet().getProxy_ssl().getPrimary().getVerifypeer());
		conn.getProxy_ssl_config().setVerifyhost(data.getSet().getProxy_ssl().getPrimary().getVerifyhost());
		conn.setIp_version(data.getSet().getIpver());
		conn.getBits().setConnect_only(data.getSet().getConnect_only());
		conn.setTransport(/* most of them are TCP streams */.TRNSPRT_TCP);
		ModernizedCProgram.Curl_llist_init(conn.getEasyq(), ((Object)/* Initialize the easy handle list */0));
		if (data.getSet().getStr()[/* Store the local bind parameters that will be used for this connection */dupstring.STRING_DEVICE]) {
			conn.setLocaldev(.Curl_cstrdup(data.getSet().getStr()[dupstring.STRING_DEVICE]));
			if (!conn.getLocaldev()) {
				;
			} 
		} 
		conn.setLocalportrange(data.getSet().getLocalportrange());
		conn.setLocalport(data.getSet().getLocalport());
		conn.setFclosesocket(data.getSet().getFclosesocket());
		conn.setClosesocket_client(data.getSet().getClosesocket_client());
		return conn;
		.Curl_cfree(conn.getLocaldev());
		.Curl_cfree(conn);
		return ((Object)0);
	}
	public static Object Curl_builtin_scheme(Object scheme) {
		Curl_handler pp = new Curl_handler();
		Curl_handler p = new Curl_handler();
		/* Scan protocol handler table and match against 'scheme'. The handler may
		     be changed later when the protocol specific setup function is called. */
		for (pp = ModernizedCProgram.protocols; (p = pp) != ((Object)0); pp++) {
			if (ModernizedCProgram.Curl_strcasecompare(p.getScheme(), scheme)) {
				return /* Protocol found in table. Check if allowed */p;
			} 
		}
		return ((Object)/* not found */0);
	}
	public static  findprotocol(Object data, Object conn, Object protostr) {
		Curl_handler p = ModernizedCProgram.Curl_builtin_scheme(protostr);
		if (/* Protocol found in table. Check if allowed */p && (data.getSet().getAllowed_protocols() & p.getProtocol())) {
			if (data.getState().getThis_is_a_follow() && !(data.getSet().getRedir_protocols() & p.getProtocol())) {
				;
			} else {
					conn.setHandler(conn.setGiven(/* Perform setup complement if some. */p));
					return /* 'port' and 'remote_port' are set in setup_connection_internals() */.CURLE_OK;
			} 
		} 
		ModernizedCProgram.Curl_failf(data, /* The protocol was not found in the table, but we don't have to assign it
		     to anything since it is already assigned to a dummy-struct in the
		     create_conn() function when the connectdata struct is allocated. */"Protocol \"%s\" not supported or disabled in libcurl", protostr);
		return .CURLE_UNSUPPORTED_PROTOCOL;
	}
	public static  Curl_uc_to_curlcode( uc) {
		switch (uc) {
		case .CURLUE_OUT_OF_MEMORY:
				return .CURLE_OUT_OF_MEMORY;
		case .CURLUE_USER_NOT_ALLOWED:
				return .CURLE_LOGIN_DENIED/*
				 * If the URL was set with an IPv6 numerical address with a zone id part, set
				 * the scope_id based on that!
				 */;
		case .CURLUE_UNSUPPORTED_SCHEME:
				return .CURLE_UNSUPPORTED_PROTOCOL;
		default:
				return .CURLE_URL_MALFORMAT;
		}
	}
	public static void zonefrom_url(Object uh, Object conn) {
		byte zoneid;
		CURLUcode uc = new CURLUcode();
		uc = ModernizedCProgram.curl_url_get(uh, .CURLUPART_ZONEID, zoneid, 0);
		if (!uc && zoneid) {
			byte endp;
			long scope = .strtoul(zoneid, endp, 10);
			if (!endp && (scope < -1024)) {
				conn.setScope_id((int)/* A plain number, use it directly as a scope id. */scope);
			}  else if (ModernizedCProgram.Curl_if_nametoindex) {
				int scopeidx = /* Zone identifier is not numeric */0;
				scopeidx = .Curl_if_nametoindex(zoneid);
				if (!scopeidx) {
					ModernizedCProgram.Curl_infof(conn.getData(), "Invalid zoneid: %s; %s\n", zoneid, .strerror((._errno())));
				} else {
						conn.setScope_id(scopeidx);
				} 
			} 
			.Curl_cfree(/* HAVE_IF_NAMETOINDEX || WIN32 */zoneid);
		} 
	}
	/*
	 * Parse URL and fill in the relevant members of the connection struct.
	 */
	public static  parseurlandfillconn(Object data, Object conn) {
		CURLcode result = new CURLcode();
		CURLU uh = new CURLU();
		CURLUcode uc = new CURLUcode();
		byte hostname;
		ModernizedCProgram.up_free(/* cleanup previous leftovers first */data);
		if (data.getSet().getUh()) {
			uh = data.getState().setUh(ModernizedCProgram.curl_url_dup(data.getSet().getUh()));
		} else {
				uh = data.getState().setUh(ModernizedCProgram.curl_url());
		} 
		if (!uh) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		if (data.getSet().getStr()[dupstring.STRING_DEFAULT_PROTOCOL] && !ModernizedCProgram.Curl_is_absolute_url(data.getChange().getUrl(), ((Object)0), 40)) {
			byte url;
			if (data.getChange().getUrl_alloc()) {
				.Curl_cfree(data.getChange().getUrl());
			} 
			url = ModernizedCProgram.curl_maprintf("%s://%s", data.getSet().getStr()[dupstring.STRING_DEFAULT_PROTOCOL], data.getChange().getUrl());
			if (!url) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			data.getChange().setUrl(url);
			data.getChange().setUrl_alloc(1);
		} 
		if (!data.getSet().getUh()) {
			byte newurl;
			uc = ModernizedCProgram.curl_url_set(uh, .CURLUPART_URL, data.getChange().getUrl(), (1 << 9) | (1 << 3) | (data.getSet().getDisallow_username_in_url() ? (1 << 5) : 0) | (data.getSet().getPath_as_is() ? (1 << 4) : 0));
			if (uc) {
				do {
				} while (0);
				return ModernizedCProgram.Curl_uc_to_curlcode(uc);
			} 
			uc = ModernizedCProgram.curl_url_get(uh, .CURLUPART_URL, newurl, /* after it was parsed, get the generated normalized version */0);
			if (uc) {
				return ModernizedCProgram.Curl_uc_to_curlcode(uc);
			} 
			if (data.getChange().getUrl_alloc()) {
				.Curl_cfree(data.getChange().getUrl());
			} 
			data.getChange().setUrl(newurl);
			data.getChange().setUrl_alloc(1);
		} 
		uc = ModernizedCProgram.curl_url_get(uh, .CURLUPART_SCHEME, data.getState().getUp().getScheme(), 0);
		if (uc) {
			return ModernizedCProgram.Curl_uc_to_curlcode(uc);
		} 
		result = ModernizedCProgram.findprotocol(data, conn, data.getState().getUp().getScheme());
		if (result) {
			return result;
		} 
		uc = ModernizedCProgram.curl_url_get(uh, .CURLUPART_USER, data.getState().getUp().getUser(), (1 << 6));
		if (!uc) {
			conn.setUser(.Curl_cstrdup(data.getState().getUp().getUser()));
			if (!conn.getUser()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			conn.getBits().setUser_passwd(1);
		}  else if (uc != .CURLUE_NO_USER) {
			return ModernizedCProgram.Curl_uc_to_curlcode(uc);
		} 
		uc = ModernizedCProgram.curl_url_get(uh, .CURLUPART_PASSWORD, data.getState().getUp().getPassword(), (1 << 6));
		if (!uc) {
			conn.setPasswd(.Curl_cstrdup(data.getState().getUp().getPassword()));
			if (!conn.getPasswd()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			conn.getBits().setUser_passwd(1);
		}  else if (uc != .CURLUE_NO_PASSWORD) {
			return ModernizedCProgram.Curl_uc_to_curlcode(uc);
		} 
		uc = ModernizedCProgram.curl_url_get(uh, .CURLUPART_OPTIONS, data.getState().getUp().getOptions(), (1 << 6));
		if (!uc) {
			conn.setOptions(.Curl_cstrdup(data.getState().getUp().getOptions()));
			if (!conn.getOptions()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		}  else if (uc != .CURLUE_NO_OPTIONS) {
			return ModernizedCProgram.Curl_uc_to_curlcode(uc);
		} 
		uc = ModernizedCProgram.curl_url_get(uh, .CURLUPART_HOST, data.getState().getUp().getHostname(), 0);
		if (uc) {
			if (!ModernizedCProgram.Curl_strcasecompare("file", data.getState().getUp().getScheme())) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		uc = ModernizedCProgram.curl_url_get(uh, .CURLUPART_PATH, data.getState().getUp().getPath(), 0);
		if (uc) {
			return ModernizedCProgram.Curl_uc_to_curlcode(uc);
		} 
		uc = ModernizedCProgram.curl_url_get(uh, .CURLUPART_PORT, data.getState().getUp().getPort(), (1 << 0));
		if (uc) {
			if (!ModernizedCProgram.Curl_strcasecompare("file", data.getState().getUp().getScheme())) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} else {
				long port = .strtoul(data.getState().getUp().getPort(), ((Object)0), 10);
				conn.setPort(conn.setRemote_port(ModernizedCProgram.curlx_ultous(port)));
		} 
		(Object)ModernizedCProgram.curl_url_get(uh, .CURLUPART_QUERY, data.getState().getUp().getQuery(), 0);
		hostname = data.getState().getUp().getHostname();
		if (hostname && hostname[0] == (byte)'['/* This looks like an IPv6 address literal. See if there is an address
		       scope. */) {
			size_t hlen = new size_t();
			conn.getBits().setIpv6_ip(1);
			/* cut off the brackets! */hostname++;
			hlen = .strlen(hostname);
			hostname[hlen - 1] = 0;
			ModernizedCProgram.zonefrom_url(uh, conn);
		} 
		conn.getHost().setRawalloc(.Curl_cstrdup(hostname ? hostname : /* make sure the connect struct gets its own copy of the host name */""));
		if (!conn.getHost().getRawalloc()) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		conn.getHost().setName(conn.getHost().getRawalloc());
		if (data.getSet().getScope_id()) {
			conn.setScope_id(data.getSet().getScope_id());
		} 
		return .CURLE_OK/*
		 * If we're doing a resumed transfer, we need to setup our stuff
		 * properly.
		 */;
	}
	public static  setup_range(Object data) {
		UrlState s = data.getState();
		s.setResume_from(data.getSet().getSet_resume_from());
		if (s.getResume_from() || data.getSet().getStr()[dupstring.STRING_SET_RANGE]) {
			if (s.getRangestringalloc()) {
				.Curl_cfree(s.getRange());
			} 
			if (s.getResume_from()) {
				s.setRange(ModernizedCProgram.curl_maprintf("%I64d-", s.getResume_from()));
			} else {
					s.setRange(.Curl_cstrdup(data.getSet().getStr()[dupstring.STRING_SET_RANGE]));
			} 
			s.setRangestringalloc((s.getRange()) ? 1 : 0);
			if (!s.getRange()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			s.setUse_range(/* tell ourselves to fetch this range *//* enable range download */1);
		} else {
				s.setUse_range(/* disable range download */0);
		} 
		return .CURLE_OK/*
		 * setup_connection_internals() -
		 *
		 * Setup connection internals specific to the requested protocol in the
		 * Curl_easy. This is inited and setup before the connection is made but
		 * is about the particular protocol that is to be used.
		 *
		 * This MUST get called after proxy magic has been figured out.
		 */;
	}
	public static  setup_connection_internals(Object conn) {
		Curl_handler p = new Curl_handler();
		CURLcode result = new CURLcode();
		p = conn.getHandler();
		if (p.getSetup_connection()) {
			result = .UNRECOGNIZEDFUNCTIONNAME(conn);
			if (result) {
				return result;
			} 
			p = conn.getHandler();
		} 
		if (conn.getPort() < 0/* we check for -1 here since if proxy was detected already, this
		       was very likely already set to the proxy port */) {
			conn.setPort(p.getDefport());
		} 
		return .CURLE_OK/*
		 * Curl_free_request_state() should free temp data that was allocated in the
		 * Curl_easy for this single request.
		 */;
	}
	public static void Curl_free_request_state(Object data) {
		do {
			.Curl_cfree((data.getReq().getProtop()));
			(data.getReq().getProtop()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((data.getReq().getNewurl()));
			(data.getReq().getNewurl()) = ((Object)0);
		} while (0);
	}
	/****************************************************************
	* Checks if the host is in the noproxy list. returns true if it matches
	* and therefore the proxy should NOT be used.
	****************************************************************/
	/****************************************************************
	* Checks if the host is in the noproxy list. returns true if it matches
	* and therefore the proxy should NOT be used.
	****************************************************************/
	public static  check_noproxy(Object name, Object no_proxy) {
		if (no_proxy && no_proxy[0]) {
			size_t tok_start = new size_t();
			size_t tok_end = new size_t();
			byte separator = ", ";
			size_t no_proxy_len = new size_t();
			size_t namelen = new size_t();
			byte endptr;
			if (ModernizedCProgram.Curl_strcasecompare("*", no_proxy)) {
				return 1;
			} 
			no_proxy_len = .strlen(/* NO_PROXY was specified and it wasn't just an asterisk */no_proxy);
			if (name[0] == (byte)'[') {
				endptr = .strchr(name, /* IPv6 numerical address */(byte)']');
				if (!endptr) {
					return 0;
				} 
				name++;
				namelen = endptr - name;
			} else {
					namelen = .strlen(name);
			} 
			for (tok_start = 0; tok_start < no_proxy_len; tok_start = tok_end + 1) {
				while (tok_start < no_proxy_len && .strchr(separator, no_proxy[tok_start]) != ((Object)0)) {
					++/* Look for the beginning of the token. */tok_start;
				}
				if (tok_start == no_proxy_len) {
					break;
				} 
				for (tok_end = tok_start; tok_end < no_proxy_len && .strchr(separator, no_proxy[tok_end]) == ((Object)0); ++tok_end/* Look for the end of the token. */) {
					;
				}
				if (no_proxy[tok_start] == (byte)'.') {
					++tok_start;
				} 
				if ((tok_end - tok_start) <= namelen) {
					byte checkn = name + namelen - (tok_end - /* Match the last part of the name to the domain we are checking. */tok_start);
					if (ModernizedCProgram.Curl_strncasecompare(no_proxy + tok_start, checkn, tok_end - tok_start)) {
						if ((tok_end - tok_start) == namelen || (checkn - 1) == (byte)'.'/* We either have an exact match, or the previous character is a .
						             * so it is within the same domain, so no proxy for this host.
						             */) {
							return 1/* if((tok_end - tok_start) <= namelen) */;
						} 
					} 
				} 
			}
		} 
		return /* for(tok_start = 0; tok_start < no_proxy_len;
		         tok_start = tok_end + 1) *//* NO_PROXY was specified and it wasn't just an asterisk */0/****************************************************************
		* Detect what (if any) proxy to use. Remember that this selects a host
		* name and is not limited to HTTP proxies only.
		* The returned pointer must be freed by the caller (unless NULL)
		****************************************************************//****************************************************************
		* Detect what (if any) proxy to use. Remember that this selects a host
		* name and is not limited to HTTP proxies only.
		* The returned pointer must be freed by the caller (unless NULL)
		****************************************************************/;
	}
	/* no_proxy=domain1.dom,host.domain2.dom
	   *   (a comma-separated list of hosts which should
	   *   not be proxied, or an asterisk to override
	   *   all proxy variables)
	   */
	public static Object detect_proxy(Object conn) {
		byte proxy = ((Object)0/* If proxy was not specified, we check for default proxy environment
		   * variables, to enable i.e Lynx compliance:
		   *
		   * http_proxy=http://some.server.dom:port/
		   * https_proxy=http://some.server.dom:port/
		   * ftp_proxy=http://some.server.dom:port/
		   * no_proxy=domain1.dom,host.domain2.dom
		   *   (a comma-separated list of hosts which should
		   *   not be proxied, or an asterisk to override
		   *   all proxy variables)
		   * all_proxy=http://some.server.dom:port/
		   *   (seems to exist for the CERN www lib. Probably
		   *   the first to check for.)
		   *
		   * For compatibility, the all-uppercase versions of these variables are
		   * checked if the lowercase versions don't exist.
		   */);
		byte[] proxy_env = new byte[128];
		byte protop = conn.getHandler().getScheme();
		byte envp = proxy_env;
		byte prox;
		while (/* Now, build <protocol>_proxy and check for such a one to use */protop) {
			envp++ = (byte).tolower((int)protop++);
		}
		.strcpy(envp, /* append _proxy */"_proxy");
		prox = ModernizedCProgram.curl_getenv(/* read the protocol proxy: */proxy_env/*
		   * We don't try the uppercase version of HTTP_PROXY because of
		   * security reasons:
		   *
		   * When curl is used in a webserver application
		   * environment (cgi or php), this environment variable can
		   * be controlled by the web server user by setting the
		   * http header 'Proxy:' to some value.
		   *
		   * This can cause 'internal' http/ftp requests to be
		   * arbitrarily redirected by any external attacker.
		   */);
		if (!prox && !ModernizedCProgram.Curl_strcasecompare("http_proxy", proxy_env)) {
			ModernizedCProgram.Curl_strntoupper(proxy_env, proxy_env, );
			prox = ModernizedCProgram.curl_getenv(proxy_env);
		} 
		envp = proxy_env;
		if (prox) {
			proxy = /* use this */prox;
		} else {
				envp = (byte)"all_proxy";
				proxy = ModernizedCProgram.curl_getenv(/* default proxy to use */envp);
				if (!proxy) {
					envp = (byte)"ALL_PROXY";
					proxy = ModernizedCProgram.curl_getenv(envp);
				} 
		} 
		if (proxy) {
			ModernizedCProgram.Curl_infof(conn.getData(), "Uses proxy env variable %s == '%s'\n", envp, proxy);
		} 
		return proxy/* CURL_DISABLE_HTTP *//*
		 * If this is supposed to use a proxy, we need to figure out the proxy
		 * host name, so that we can re-use an existing connection
		 * that may exist registered to the same proxy host.
		 */;
	}
	public static  parse_proxy(Object data, Object conn, Object proxy,  proxytype) {
		byte portptr = ((Object)0);
		long port = -1;
		byte proxyuser = ((Object)0);
		byte proxypasswd = ((Object)0);
		byte host;
		bool sockstype = new bool();
		CURLUcode uc = new CURLUcode();
		proxy_info proxyinfo = new proxy_info();
		CURLU uhp = ModernizedCProgram.curl_url();
		CURLcode result = .CURLE_OK;
		byte scheme = ((Object)0);
		uc = ModernizedCProgram.curl_url_set(uhp, .CURLUPART_URL, /* When parsing the proxy, allowing non-supported schemes since we have
		     these made up ones for proxies. Guess scheme for URLs without it. */proxy, (1 << 3) | (1 << 9));
		if (!uc) {
			uc = ModernizedCProgram.curl_url_get(uhp, .CURLUPART_SCHEME, scheme, /* parsed okay as a URL */0);
			if (uc) {
				result = .CURLE_OUT_OF_MEMORY;
				;
			} 
			if (ModernizedCProgram.Curl_strcasecompare("https", scheme)) {
				proxytype = .CURLPROXY_HTTPS;
			}  else if (ModernizedCProgram.Curl_strcasecompare("socks5h", scheme)) {
				proxytype = .CURLPROXY_SOCKS5_HOSTNAME;
			}  else if (ModernizedCProgram.Curl_strcasecompare("socks5", scheme)) {
				proxytype = .CURLPROXY_SOCKS5;
			}  else if (ModernizedCProgram.Curl_strcasecompare("socks4a", scheme)) {
				proxytype = .CURLPROXY_SOCKS4A;
			}  else if (ModernizedCProgram.Curl_strcasecompare("socks4", scheme) || ModernizedCProgram.Curl_strcasecompare("socks", scheme)) {
				proxytype = .CURLPROXY_SOCKS4;
			}  else if (ModernizedCProgram.Curl_strcasecompare("http", scheme)) {
				;
			} else {
					ModernizedCProgram.Curl_failf(data, "Unsupported proxy scheme for \'%s\'", /* Any other xxx:// reject! */proxy);
					result = .CURLE_COULDNT_CONNECT;
					;
			} 
		} else {
				ModernizedCProgram.Curl_failf(data, "Unsupported proxy syntax in \'%s\'", proxy);
				result = .CURLE_COULDNT_RESOLVE_PROXY;
				;
		} 
		if (proxytype == .CURLPROXY_HTTPS) {
			ModernizedCProgram.Curl_failf(data, "Unsupported proxy \'%s\', libcurl is built without the HTTPS-proxy support.", proxy);
			result = .CURLE_NOT_BUILT_IN;
			;
		} 
		sockstype = proxytype == .CURLPROXY_SOCKS5_HOSTNAME || proxytype == .CURLPROXY_SOCKS5 || proxytype == .CURLPROXY_SOCKS4A || proxytype == .CURLPROXY_SOCKS4;
		proxyinfo = sockstype ? conn.getSocks_proxy() : conn.getHttp_proxy();
		proxyinfo.setProxytype(proxytype);
		ModernizedCProgram.curl_url_get(uhp, .CURLUPART_USER, proxyuser, (1 << /* Is there a username and password given in this proxy url? */6));
		ModernizedCProgram.curl_url_get(uhp, .CURLUPART_PASSWORD, proxypasswd, (1 << 6));
		if (proxyuser || proxypasswd) {
			do {
				.Curl_cfree((proxyinfo.getUser()));
				(proxyinfo.getUser()) = ((Object)0);
			} while (0);
			proxyinfo.setUser(proxyuser);
			do {
				.Curl_cfree((proxyinfo.getPasswd()));
				(proxyinfo.getPasswd()) = ((Object)0);
			} while (0);
			if (!proxypasswd) {
				proxypasswd = .Curl_cstrdup("");
				if (!proxypasswd) {
					result = .CURLE_OUT_OF_MEMORY;
					;
				} 
			} 
			proxyinfo.setPasswd(proxypasswd);
			conn.getBits().setProxy_user_passwd(/* enable it */1);
		} 
		ModernizedCProgram.curl_url_get(uhp, .CURLUPART_PORT, portptr, 0);
		if (portptr) {
			port = .strtol(portptr, ((Object)0), 10);
			.Curl_cfree(portptr);
		} else {
				if (data.getSet().getProxyport()) {
					port = data.getSet().getProxyport();
				} else {
						if (proxytype == .CURLPROXY_HTTPS) {
							port = 443;
						} else {
								port = 1080;
						} 
				} 
		} 
		if (port >= 0) {
			proxyinfo.setPort(port);
			if (conn.getPort() < 0 || sockstype || !conn.getSocks_proxy().getHost().getRawalloc()) {
				conn.setPort(port);
			} 
		} 
		uc = ModernizedCProgram.curl_url_get(uhp, .CURLUPART_HOST, host, (1 << /* now, clone the proxy host name */6));
		if (uc) {
			result = .CURLE_OUT_OF_MEMORY;
			;
		} 
		do {
			.Curl_cfree((proxyinfo.getHost().getRawalloc()));
			(proxyinfo.getHost().getRawalloc()) = ((Object)0);
		} while (0);
		proxyinfo.getHost().setRawalloc(host);
		if (host[0] == (byte)'[') {
			size_t len = .strlen(/* this is a numerical IPv6, strip off the brackets */host);
			host[len - 1] = /* clear the trailing bracket */0;
			host++;
			ModernizedCProgram.zonefrom_url(uhp, conn);
		} 
		proxyinfo.getHost().setName(host);
		ModernizedCProgram.curl_url_cleanup(uhp);
		return result/*
		 * Extract the user and password from the authentication string
		 */;
	}
	public static  parse_proxy_auth(Object data, Object conn) {
		byte[] proxyuser = "";
		byte[] proxypasswd = "";
		CURLcode result = new CURLcode();
		if (data.getSet().getStr()[dupstring.STRING_PROXYUSERNAME] != ((Object)0)) {
			.strncpy(proxyuser, data.getSet().getStr()[dupstring.STRING_PROXYUSERNAME], 256);
			proxyuser[256 - 1] = /*To be on safe side*/(byte)'\0';
		} 
		if (data.getSet().getStr()[dupstring.STRING_PROXYPASSWORD] != ((Object)0)) {
			.strncpy(proxypasswd, data.getSet().getStr()[dupstring.STRING_PROXYPASSWORD], 256);
			proxypasswd[256 - 1] = /*To be on safe side*/(byte)'\0';
		} 
		result = ModernizedCProgram.Curl_urldecode(data, proxyuser, 0, conn.getHttp_proxy().getUser(), ((Object)0), 0);
		if (!result) {
			result = ModernizedCProgram.Curl_urldecode(data, proxypasswd, 0, conn.getHttp_proxy().getPasswd(), ((Object)0), 0);
		} 
		return result;
	}
	/* create_conn helper to parse and init proxy values. to be called after unix
	   socket init but before any proxy vars are evaluated. */
	public static  create_conn_helper_init_proxy(Object conn) {
		byte proxy = ((Object)0);
		byte socksproxy = ((Object)0);
		byte no_proxy = ((Object)0);
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		if (conn.getBits().getProxy_user_passwd()) {
			result = ModernizedCProgram.parse_proxy_auth(data, conn);
			if (result) {
				;
			} 
		} 
		if (data.getSet().getStr()[/*************************************************************
		   * Detect what (if any) proxy to use
		   *************************************************************/dupstring.STRING_PROXY]) {
			proxy = .Curl_cstrdup(data.getSet().getStr()[dupstring.STRING_PROXY]);
			if (((Object)0) == /* if global proxy is set, this is it */proxy) {
				ModernizedCProgram.Curl_failf(data, "memory shortage");
				result = .CURLE_OUT_OF_MEMORY;
				;
			} 
		} 
		if (data.getSet().getStr()[dupstring.STRING_PRE_PROXY]) {
			socksproxy = .Curl_cstrdup(data.getSet().getStr()[dupstring.STRING_PRE_PROXY]);
			if (((Object)0) == /* if global socks proxy is set, this is it */socksproxy) {
				ModernizedCProgram.Curl_failf(data, "memory shortage");
				result = .CURLE_OUT_OF_MEMORY;
				;
			} 
		} 
		if (!data.getSet().getStr()[dupstring.STRING_NOPROXY]) {
			byte p = "no_proxy";
			no_proxy = ModernizedCProgram.curl_getenv(p);
			if (!no_proxy) {
				p = "NO_PROXY";
				no_proxy = ModernizedCProgram.curl_getenv(p);
			} 
			if (no_proxy) {
				ModernizedCProgram.Curl_infof(conn.getData(), "Uses proxy env variable %s == '%s'\n", p, no_proxy);
			} 
		} 
		if (ModernizedCProgram.check_noproxy(conn.getHost().getName(), data.getSet().getStr()[dupstring.STRING_NOPROXY] ? data.getSet().getStr()[dupstring.STRING_NOPROXY] : no_proxy)) {
			do {
				.Curl_cfree((proxy));
				(proxy) = ((Object)0);
			} while (0);
			do {
				.Curl_cfree((socksproxy));
				(socksproxy) = ((Object)0);
			} while (0);
		}  else if (!proxy && !socksproxy) {
			proxy = ModernizedCProgram.detect_proxy(/* if the host is not in the noproxy list, detect proxy. */conn/* CURL_DISABLE_HTTP */);
		} 
		do {
			.Curl_cfree((no_proxy));
			(no_proxy) = ((Object)0);
		} while (0/* For the time being do not mix proxy and unix domain sockets. See #1274 */);
		if (proxy && (!proxy || (conn.getHandler().getFlags() & (1 << 4)))) {
			.Curl_cfree(/* Don't bother with an empty proxy string or if the
			                     protocol doesn't work with network */proxy);
			proxy = ((Object)0);
		} 
		if (socksproxy && (!socksproxy || (conn.getHandler().getFlags() & (1 << 4)))) {
			.Curl_cfree(/* Don't bother with an empty socks proxy string or if
			                          the protocol doesn't work with network */socksproxy);
			socksproxy = ((Object)0/***********************************************************************
			   * If this is supposed to use a proxy, we need to figure out the proxy host
			   * name, proxy type and port number, so that we can re-use an existing
			   * connection that may exist registered to the same proxy host.
			   ***********************************************************************/);
		} 
		if (proxy || socksproxy) {
			if (proxy) {
				result = ModernizedCProgram.parse_proxy(data, conn, proxy, conn.getHttp_proxy().getProxytype());
				do {
					.Curl_cfree((proxy));
					(proxy) = ((Object)0);
				} while (/* parse_proxy copies the proxy string */0);
				if (result) {
					;
				} 
			} 
			if (socksproxy) {
				result = ModernizedCProgram.parse_proxy(data, conn, socksproxy, conn.getSocks_proxy().getProxytype());
				do {
					.Curl_cfree((socksproxy));
					(socksproxy) = ((Object)0);
				} while (/* parse_proxy copies the socks proxy string */0);
				if (result) {
					;
				} 
			} 
			if (conn.getHttp_proxy().getHost().getRawalloc()) {
				if (!(conn.getHandler().getProtocol() & ((1 << 0) | (1 << /* force this connection's protocol to become HTTP if compatible */1)))) {
					if ((conn.getHandler().getFlags() & (1 << 11)) && !conn.getBits().getTunnel_proxy()) {
						conn.setHandler(ModernizedCProgram.Curl_handler_http);
					} else {
							conn.getBits().setTunnel_proxy(/* if not converting to HTTP over the proxy, enforce tunneling */1);
					} 
				} 
				conn.getBits().setHttpproxy(1);
			} else {
					conn.getBits().setHttpproxy(/* not a HTTP proxy */0);
					conn.getBits().setTunnel_proxy(/* no tunneling if not HTTP */0);
			} 
			if (conn.getSocks_proxy().getHost().getRawalloc()) {
				if (!conn.getHttp_proxy().getHost().getRawalloc()) {
					if (!conn.getSocks_proxy().getUser()) {
						conn.getSocks_proxy().setUser(conn.getHttp_proxy().getUser());
						conn.getHttp_proxy().setUser(((Object)0));
						do {
							.Curl_cfree((conn.getSocks_proxy().getPasswd()));
							(conn.getSocks_proxy().getPasswd()) = ((Object)0);
						} while (0);
						conn.getSocks_proxy().setPasswd(conn.getHttp_proxy().getPasswd());
						conn.getHttp_proxy().setPasswd(((Object)0));
					} 
				} 
				conn.getBits().setSocksproxy(1);
			} else {
					conn.getBits().setSocksproxy(/* not a socks proxy */0);
			} 
		} else {
				conn.getBits().setSocksproxy(0);
				conn.getBits().setHttpproxy(0);
		} 
		conn.getBits().setProxy(conn.getBits().getHttpproxy() || conn.getBits().getSocksproxy());
		if (!conn.getBits().getProxy()) {
			conn.getBits().setProxy(/* we aren't using the proxy after all... */0);
			conn.getBits().setHttpproxy(0);
			conn.getBits().setSocksproxy(0);
			conn.getBits().setProxy_user_passwd(0);
			conn.getBits().setTunnel_proxy(0);
		} 
		.Curl_cfree(proxy);
		return result/* CURL_DISABLE_PROXY *//*
		 * Curl_parse_login_details()
		 *
		 * This is used to parse a login string for user name, password and options in
		 * the following formats:
		 *
		 *   user
		 *   user:password
		 *   user:password;options
		 *   user;options
		 *   user;options:password
		 *   :password
		 *   :password;options
		 *   ;options
		 *   ;options:password
		 *
		 * Parameters:
		 *
		 * login    [in]     - The login string.
		 * len      [in]     - The length of the login string.
		 * userp    [in/out] - The address where a pointer to newly allocated memory
		 *                     holding the user will be stored upon completion.
		 * passwdp  [in/out] - The address where a pointer to newly allocated memory
		 *                     holding the password will be stored upon completion.
		 * optionsp [in/out] - The address where a pointer to newly allocated memory
		 *                     holding the options will be stored upon completion.
		 *
		 * Returns CURLE_OK on success.
		 */;
	}
	public static  Curl_parse_login_details(Object login, Object len, Object userp, Object passwdp, Object optionsp) {
		CURLcode result = .CURLE_OK;
		byte ubuf = ((Object)0);
		byte pbuf = ((Object)0);
		byte obuf = ((Object)0);
		byte psep = ((Object)0);
		byte osep = ((Object)0);
		size_t ulen = new size_t();
		size_t plen = new size_t();
		size_t olen = new size_t();
		if (/* Attempt to find the password separator */passwdp) {
			psep = .strchr(login, (byte)':');
			if (psep >= login + /* Within the constraint of the login string */len) {
				psep = ((Object)0);
			} 
		} 
		if (/* Attempt to find the options separator */optionsp) {
			osep = .strchr(login, (byte)';');
			if (osep >= login + /* Within the constraint of the login string */len) {
				osep = ((Object)0);
			} 
		} 
		ulen = (/* Calculate the portion lengths */psep ? (size_t)(osep && psep > osep ? osep - login : psep - login) : (osep ? (size_t)(osep - login) : len));
		plen = (psep ? (osep && osep > psep ? (size_t)(osep - psep) : (size_t)(login + len - psep)) - 1 : 0);
		olen = (osep ? (psep && psep > osep ? (size_t)(psep - osep) : (size_t)(login + len - osep)) - 1 : 0);
		if (userp && /* Allocate the user portion buffer */ulen) {
			ubuf = .Curl_cmalloc(ulen + 1);
			if (!ubuf) {
				result = .CURLE_OUT_OF_MEMORY;
			} 
		} 
		if (!result && passwdp && /* Allocate the password portion buffer */plen) {
			pbuf = .Curl_cmalloc(plen + 1);
			if (!pbuf) {
				.Curl_cfree(ubuf);
				result = .CURLE_OUT_OF_MEMORY;
			} 
		} 
		if (!result && optionsp && /* Allocate the options portion buffer */olen) {
			obuf = .Curl_cmalloc(olen + 1);
			if (!obuf) {
				.Curl_cfree(pbuf);
				.Curl_cfree(ubuf);
				result = .CURLE_OUT_OF_MEMORY;
			} 
		} 
		if (!result) {
			if (/* Store the user portion if necessary */ubuf) {
				.memcpy(ubuf, login, ulen);
				ubuf[ulen] = (byte)'\0';
				do {
					.Curl_cfree((userp));
					(userp) = ((Object)0);
				} while (0);
				userp = ubuf;
			} 
			if (/* Store the password portion if necessary */pbuf) {
				.memcpy(pbuf, psep + 1, plen);
				pbuf[plen] = (byte)'\0';
				do {
					.Curl_cfree((passwdp));
					(passwdp) = ((Object)0);
				} while (0);
				passwdp = pbuf;
			} 
			if (/* Store the options portion if necessary */obuf) {
				.memcpy(obuf, osep + 1, olen);
				obuf[olen] = (byte)'\0';
				do {
					.Curl_cfree((optionsp));
					(optionsp) = ((Object)0);
				} while (0);
				optionsp = obuf;
			} 
		} 
		return result/*************************************************************
		 * Figure out the remote port number and fix it in the URL
		 *
		 * No matter if we use a proxy or not, we have to figure out the remote
		 * port number of various reasons.
		 *
		 * The port number embedded in the URL is replaced, if necessary.
		 *************************************************************/;
	}
	public static  parse_remote_port(Object data, Object conn) {
		if (data.getSet().getUse_port() && data.getState().getAllow_port()) {
			byte[] portbuf = new byte[/* if set, we use this instead of the port possibly given in the URL */16];
			CURLUcode uc = new CURLUcode();
			conn.setRemote_port((int)data.getSet().getUse_port());
			ModernizedCProgram.curl_msnprintf(portbuf, , "%d", conn.getRemote_port());
			uc = ModernizedCProgram.curl_url_set(data.getState().getUh(), .CURLUPART_PORT, portbuf, 0);
			if (uc) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		return .CURLE_OK/*
		 * Override the login details from the URL with that in the CURLOPT_USERPWD
		 * option or a .netrc file, if applicable.
		 */;
	}
	public static  override_login(Object data, Object conn, Object userp, Object passwdp, Object optionsp) {
		bool user_changed = 0;
		bool passwd_changed = 0;
		CURLUcode uc = new CURLUcode();
		if (data.getSet().getUse_netrc() == CURL_NETRC_OPTION.CURL_NETRC_REQUIRED && conn.getBits().getUser_passwd()) {
			if (/* ignore user+password in the URL */userp) {
				do {
					.Curl_cfree((userp));
					(userp) = ((Object)0);
				} while (0);
				user_changed = 1;
			} 
			if (passwdp) {
				do {
					.Curl_cfree((passwdp));
					(passwdp) = ((Object)0);
				} while (0);
				passwd_changed = 1;
			} 
			conn.getBits().setUser_passwd(/* disable user+password */0);
		} 
		if (data.getSet().getStr()[dupstring.STRING_USERNAME]) {
			.Curl_cfree(userp);
			userp = .Curl_cstrdup(data.getSet().getStr()[dupstring.STRING_USERNAME]);
			if (!userp) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			conn.getBits().setUser_passwd(/* enable user+password */1);
			user_changed = 1;
		} 
		if (data.getSet().getStr()[dupstring.STRING_PASSWORD]) {
			.Curl_cfree(passwdp);
			passwdp = .Curl_cstrdup(data.getSet().getStr()[dupstring.STRING_PASSWORD]);
			if (!passwdp) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			conn.getBits().setUser_passwd(/* enable user+password */1);
			passwd_changed = 1;
		} 
		if (data.getSet().getStr()[dupstring.STRING_OPTIONS]) {
			.Curl_cfree(optionsp);
			optionsp = .Curl_cstrdup(data.getSet().getStr()[dupstring.STRING_OPTIONS]);
			if (!optionsp) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		conn.getBits().setNetrc(0);
		if (data.getSet().getUse_netrc() != CURL_NETRC_OPTION.CURL_NETRC_IGNORED && (!userp || !userp || !passwdp || !passwdp)) {
			bool netrc_user_changed = 0;
			bool netrc_passwd_changed = 0;
			int ret;
			ret = ModernizedCProgram.Curl_parsenetrc(conn.getHost().getName(), userp, passwdp, netrc_user_changed, netrc_passwd_changed, data.getSet().getStr()[dupstring.STRING_NETRC_FILE]);
			if (ret > 0) {
				ModernizedCProgram.Curl_infof(data, "Couldn't find host %s in the .netrc file; using defaults\n", conn.getHost().getName());
			}  else if (ret < 0) {
				return .CURLE_OUT_OF_MEMORY;
			} else {
					conn.getBits().setNetrc(/* set bits.netrc TRUE to remember that we got the name from a .netrc
					         file, so that it is safe to use even if we followed a Location: to a
					         different host or similar. */1);
					conn.getBits().setUser_passwd(/* enable user+password */1);
					if (netrc_user_changed) {
						user_changed = 1;
					} 
					if (netrc_passwd_changed) {
						passwd_changed = 1;
					} 
			} 
		} 
		if (/* for updated strings, we update them in the URL */user_changed) {
			uc = ModernizedCProgram.curl_url_set(data.getState().getUh(), .CURLUPART_USER, userp, 0);
			if (uc) {
				return ModernizedCProgram.Curl_uc_to_curlcode(uc);
			} 
		} 
		if (passwd_changed) {
			uc = ModernizedCProgram.curl_url_set(data.getState().getUh(), .CURLUPART_PASSWORD, passwdp, 0);
			if (uc) {
				return ModernizedCProgram.Curl_uc_to_curlcode(uc);
			} 
		} 
		return .CURLE_OK/*
		 * Set the login details so they're available in the connection
		 */;
	}
	public static  set_login(Object conn) {
		CURLcode result = .CURLE_OK;
		byte setuser = "anonymous";
		byte setpasswd = "ftp@example.com";
		if ((conn.getHandler().getFlags() & (1 << 5)) && !conn.getBits().getUser_passwd()) {
			;
		} else {
				setuser = "";
				setpasswd = "";
		} 
		if (!conn.getUser()) {
			conn.setUser(.Curl_cstrdup(setuser));
			if (!conn.getUser()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		if (!conn.getPasswd()) {
			conn.setPasswd(.Curl_cstrdup(setpasswd));
			if (!conn.getPasswd()) {
				result = .CURLE_OUT_OF_MEMORY;
			} 
		} 
		return result/*
		 * Parses a "host:port" string to connect to.
		 * The hostname and the port may be empty; in this case, NULL is returned for
		 * the hostname and -1 for the port.
		 */;
	}
	public static  parse_connect_to_host_port(Object data, Object host, Object hostname_result, Object port_result) {
		byte host_dup;
		byte hostptr;
		byte host_portno;
		byte portptr;
		int port = -1;
		hostname_result = ((Object)0);
		port_result = -1;
		if (!host || !host) {
			return .CURLE_OK;
		} 
		host_dup = .Curl_cstrdup(host);
		if (!host_dup) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		hostptr = host_dup;
		portptr = /* start scanning for port number at this point */hostptr;
		if (hostptr == /* detect and extract RFC6874-style IPv6-addresses */(byte)'['/* advance beyond the initial bracket *//* There might be a zone identifier *//* Allow unreserved characters as defined in RFC 3986 */) {
			ModernizedCProgram.Curl_failf(data, /* yeps, it ended nicely with a bracket as well *//* Note that if this didn't end with a bracket, we still advanced the
			     * hostptr first, but I can't see anything wrong with that as no host
			     * name nor a numeric can legally start with a bracket.
			     */"Use of IPv6 in *_CONNECT_TO without IPv6 support built-in!");
			.Curl_cfree(host_dup);
			return .CURLE_NOT_BUILT_IN;
		} 
		host_portno = .strchr(portptr, /* Get port number off server.com:1080 */(byte)':');
		if (host_portno) {
			byte endp = ((Object)0);
			host_portno = /* cut off number from host name */(byte)'\0';
			host_portno++;
			if (host_portno) {
				long portparse = .strtol(host_portno, endp, 10);
				if ((endp && endp) || (portparse < 0) || (portparse > 65535)) {
					ModernizedCProgram.Curl_infof(data, "No valid port number in connect to host string (%s)\n", host_portno);
					hostptr = ((Object)0);
					port = -1;
				} else {
						port = (int)/* we know it will fit */portparse;
				} 
			} 
		} 
		if (/* now, clone the cleaned host name */hostptr) {
			hostname_result = .Curl_cstrdup(hostptr);
			if (!hostname_result) {
				.Curl_cfree(host_dup);
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		port_result = port;
		.Curl_cfree(host_dup);
		return .CURLE_OK/*
		 * Parses one "connect to" string in the form:
		 * "HOST:PORT:CONNECT-TO-HOST:CONNECT-TO-PORT".
		 */;
	}
	public static  parse_connect_to_string(Object data, Object conn, Object conn_to_host, Object host_result, Object port_result) {
		CURLcode result = .CURLE_OK;
		byte ptr = conn_to_host;
		int host_match = 0;
		int port_match = 0;
		host_result = ((Object)0);
		port_result = -1;
		if (ptr == (byte)':') {
			host_match = /* an empty hostname always matches */1;
			ptr++;
		} else {
				size_t hostname_to_match_len = new size_t();
				byte hostname_to_match = ModernizedCProgram.curl_maprintf("%s%s%s", conn.getBits().getIpv6_ip() ? "[" : "", conn.getHost().getName(), conn.getBits().getIpv6_ip() ? "]" : "");
				if (!hostname_to_match) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				hostname_to_match_len = .strlen(hostname_to_match);
				host_match = ModernizedCProgram.Curl_strncasecompare(ptr, hostname_to_match, hostname_to_match_len);
				.Curl_cfree(hostname_to_match);
				ptr += hostname_to_match_len;
				host_match = host_match && ptr == (byte)':';
				ptr++;
		} 
		if (host_match) {
			if (ptr == (byte)':') {
				port_match = /* an empty port always matches */1;
				ptr++;
			} else {
					byte ptr_next = .strchr(ptr, /* check whether the URL's port matches */(byte)':');
					if (ptr_next) {
						byte endp = ((Object)0);
						long port_to_match = .strtol(ptr, endp, 10);
						if ((endp == ptr_next) && (port_to_match == conn.getRemote_port())) {
							port_match = 1;
							ptr = ptr_next + 1;
						} 
					} 
			} 
		} 
		if (host_match && port_match) {
			result = ModernizedCProgram.parse_connect_to_host_port(data, ptr, host_result, /* parse the hostname and port to connect to */port_result);
		} 
		return result/*
		 * Processes all strings in the "connect to" slist, and uses the "connect
		 * to host" and "connect to port" of the first string that matches.
		 */;
	}
	public static  parse_connect_to_slist(Object data, Object conn, Object conn_to_host) {
		CURLcode result = .CURLE_OK;
		byte host = ((Object)0);
		int port = -1;
		while (conn_to_host && !host && port == -1) {
			result = ModernizedCProgram.parse_connect_to_string(data, conn, conn_to_host.getData(), host, port);
			if (result) {
				return result;
			} 
			if (host && host) {
				conn.getConn_to_host().setRawalloc(host);
				conn.getConn_to_host().setName(host);
				conn.getBits().setConn_to_host(1);
				ModernizedCProgram.Curl_infof(data, "Connecting to hostname: %s\n", host);
			} else {
					conn.getBits().setConn_to_host(/* no "connect to host" */0);
					do {
						.Curl_cfree((host));
						(host) = ((Object)0);
					} while (0);
			} 
			if (port >= 0) {
				conn.setConn_to_port(port);
				conn.getBits().setConn_to_port(1);
				ModernizedCProgram.Curl_infof(data, "Connecting to port: %d\n", port);
			} else {
					conn.getBits().setConn_to_port(/* no "connect to port" */0);
					port = -1;
			} 
			conn_to_host = conn_to_host.getNext();
		}
		return /* protocol version switch *//* shouldn't be possible */result/*************************************************************
		 * Resolve the address of the server or proxy
		 *************************************************************/;
	}
	public static  resolve_server(Object data, Object conn, Object async) {
		CURLcode result = .CURLE_OK;
		timediff_t timeout_ms = ModernizedCProgram.Curl_timeleft(data, ((Object)0), 1);
		do {
		} while (0);
		do {
		} while (0/*************************************************************
		   * Resolve the name of the server or proxy
		   *************************************************************/);
		if (conn.getBits().getReuse()) {
			async = 0;
		} else {
				int rc;
				Curl_dns_entry hostaddr = new Curl_dns_entry();
				if (!conn.getBits().getProxy()) {
					hostname connhost = new hostname();
					if (conn.getBits().getConn_to_host()) {
						connhost = conn.getConn_to_host();
					} else {
							connhost = conn.getHost();
					} 
					if (conn.getBits().getConn_to_port()) {
						conn.setPort(conn.getConn_to_port());
					} else {
							conn.setPort(conn.getRemote_port());
					} 
					conn.setHostname_resolve(.Curl_cstrdup(connhost.getName()));
					if (!conn.getHostname_resolve()) {
						return .CURLE_OUT_OF_MEMORY;
					} 
					rc = ModernizedCProgram.Curl_resolv_timeout(conn, conn.getHostname_resolve(), (int)conn.getPort(), hostaddr, timeout_ms);
					if (rc == 1) {
						async = 1;
					}  else if (rc == -2) {
						result = .CURLE_OPERATION_TIMEDOUT;
					}  else if (!hostaddr) {
						ModernizedCProgram.Curl_failf(data, "Couldn't resolve host '%s'", connhost.getDispname());
						result = .CURLE_COULDNT_RESOLVE_HOST/* don't return yet, we need to clean up the timeout first */;
					} 
				} else {
						hostname host = conn.getBits().getSocksproxy() ? conn.getSocks_proxy().getHost() : conn.getHttp_proxy().getHost();
						conn.setHostname_resolve(.Curl_cstrdup(host.getName()));
						if (!conn.getHostname_resolve()) {
							return .CURLE_OUT_OF_MEMORY;
						} 
						rc = ModernizedCProgram.Curl_resolv_timeout(conn, conn.getHostname_resolve(), (int)conn.getPort(), hostaddr, timeout_ms);
						if (rc == 1) {
							async = 1;
						}  else if (rc == -2) {
							result = .CURLE_OPERATION_TIMEDOUT;
						}  else if (!hostaddr) {
							ModernizedCProgram.Curl_failf(data, "Couldn't resolve proxy '%s'", host.getDispname());
							result = .CURLE_COULDNT_RESOLVE_PROXY/* don't return yet, we need to clean up the timeout first */;
						} 
				} 
				do {
				} while (0);
				conn.setDns_entry(hostaddr);
		} 
		return result/*
		 * Cleanup the connection just allocated before we can move along and use the
		 * previously existing one.  All relevant data is copied over and old_conn is
		 * ready for freeing once this function returns.
		 */;
	}
	public static void reuse_conn(Object old_conn, Object conn) {
		ModernizedCProgram.free_idnconverted_hostname(old_conn.getHttp_proxy().getHost());
		ModernizedCProgram.free_idnconverted_hostname(old_conn.getSocks_proxy().getHost());
		.Curl_cfree(old_conn.getHttp_proxy().getHost().getRawalloc());
		.Curl_cfree(old_conn.getSocks_proxy().getHost().getRawalloc());
		.Curl_free_primary_ssl_config(old_conn.getSsl_config());
		.Curl_free_primary_ssl_config(old_conn.getProxy_ssl_config());
		conn.setData(old_conn.getData());
		conn.getBits().setUser_passwd(old_conn.getBits().getUser_passwd());
		if (conn.getBits().getUser_passwd()) {
			do {
				.Curl_cfree((conn.getUser()));
				(conn.getUser()) = ((Object)0);
			} while (/* use the new user name and password though */0);
			do {
				.Curl_cfree((conn.getPasswd()));
				(conn.getPasswd()) = ((Object)0);
			} while (0);
			conn.setUser(old_conn.getUser());
			conn.setPasswd(old_conn.getPasswd());
			old_conn.setUser(((Object)0));
			old_conn.setPasswd(((Object)0));
		} 
		conn.getBits().setProxy_user_passwd(old_conn.getBits().getProxy_user_passwd());
		if (conn.getBits().getProxy_user_passwd()) {
			do {
				.Curl_cfree((conn.getHttp_proxy().getUser()));
				(conn.getHttp_proxy().getUser()) = ((Object)0);
			} while (/* use the new proxy user name and proxy password though */0);
			do {
				.Curl_cfree((conn.getSocks_proxy().getUser()));
				(conn.getSocks_proxy().getUser()) = ((Object)0);
			} while (0);
			do {
				.Curl_cfree((conn.getHttp_proxy().getPasswd()));
				(conn.getHttp_proxy().getPasswd()) = ((Object)0);
			} while (0);
			do {
				.Curl_cfree((conn.getSocks_proxy().getPasswd()));
				(conn.getSocks_proxy().getPasswd()) = ((Object)0);
			} while (0);
			conn.getHttp_proxy().setUser(old_conn.getHttp_proxy().getUser());
			conn.getSocks_proxy().setUser(old_conn.getSocks_proxy().getUser());
			conn.getHttp_proxy().setPasswd(old_conn.getHttp_proxy().getPasswd());
			conn.getSocks_proxy().setPasswd(old_conn.getSocks_proxy().getPasswd());
			old_conn.getHttp_proxy().setUser(((Object)0));
			old_conn.getSocks_proxy().setUser(((Object)0));
			old_conn.getHttp_proxy().setPasswd(((Object)0));
			old_conn.getSocks_proxy().setPasswd(((Object)0));
		} 
		ModernizedCProgram.free_idnconverted_hostname(conn.getHost());
		ModernizedCProgram.free_idnconverted_hostname(conn.getConn_to_host());
		do {
			.Curl_cfree((conn.getHost().getRawalloc()));
			(conn.getHost().getRawalloc()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((conn.getConn_to_host().getRawalloc()));
			(conn.getConn_to_host().getRawalloc()) = ((Object)0);
		} while (0);
		conn.setHost(old_conn.getHost());
		conn.setConn_to_host(old_conn.getConn_to_host());
		conn.setConn_to_port(old_conn.getConn_to_port());
		conn.setRemote_port(old_conn.getRemote_port());
		do {
			.Curl_cfree((conn.getHostname_resolve()));
			(conn.getHostname_resolve()) = ((Object)0);
		} while (0);
		conn.setHostname_resolve(old_conn.getHostname_resolve());
		old_conn.setHostname_resolve(((Object)0));
		ModernizedCProgram.Curl_persistconninfo(/* persist connection info in session handle */conn);
		ModernizedCProgram.conn_reset_all_postponed_data(/* free buffers */old_conn);
		conn.getBits().setReuse(/* re-use init *//* yes, we're re-using here */1);
		do {
			.Curl_cfree((old_conn.getUser()));
			(old_conn.getUser()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((old_conn.getPasswd()));
			(old_conn.getPasswd()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((old_conn.getOptions()));
			(old_conn.getOptions()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((old_conn.getHttp_proxy().getUser()));
			(old_conn.getHttp_proxy().getUser()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((old_conn.getSocks_proxy().getUser()));
			(old_conn.getSocks_proxy().getUser()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((old_conn.getHttp_proxy().getPasswd()));
			(old_conn.getHttp_proxy().getPasswd()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((old_conn.getSocks_proxy().getPasswd()));
			(old_conn.getSocks_proxy().getPasswd()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((old_conn.getLocaldev()));
			(old_conn.getLocaldev()) = ((Object)0);
		} while (0);
		ModernizedCProgram.Curl_llist_destroy(old_conn.getEasyq(), ((Object)0/**
		 * create_conn() sets up a new connectdata struct, or re-uses an already
		 * existing one, and resolves host name.
		 *
		 * if this function returns CURLE_OK and *async is set to TRUE, the resolve
		 * response will be coming asynchronously. If *async is FALSE, the name is
		 * already resolved.
		 *
		 * @param data The sessionhandle pointer
		 * @param in_connect is set to the next connection data pointer
		 * @param async is set TRUE when an async DNS resolution is pending
		 * @see Curl_setup_conn()
		 *
		 * *NOTE* this function assigns the conn->data pointer!
		 */));
	}
	public static  create_conn(Object data, Object in_connect, Object async) {
		CURLcode result = .CURLE_OK;
		connectdata conn = new connectdata();
		connectdata conn_temp = ((Object)0);
		bool reuse = new bool();
		bool connections_available = 1;
		bool force_reuse = 0;
		bool waitpipe = 0;
		size_t max_host_connections = ModernizedCProgram.Curl_multi_max_host_connections(data.getMulti());
		size_t max_total_connections = ModernizedCProgram.Curl_multi_max_total_connections(data.getMulti());
		async = 0;
		in_connect = ((Object)0/*************************************************************
		   * Check input data
		   *************************************************************/);
		if (!data.getChange().getUrl()) {
			result = .CURLE_URL_MALFORMAT;
			;
		} 
		conn = ModernizedCProgram.allocate_conn(data);
		if (!conn) {
			result = .CURLE_OUT_OF_MEMORY;
			;
		} 
		in_connect = /* We must set the return variable as soon as possible, so that our
		     parent can cleanup any possible allocs we may have done before
		     any failure */conn;
		result = ModernizedCProgram.parseurlandfillconn(data, conn);
		if (result) {
			;
		} 
		if (data.getSet().getStr()[dupstring.STRING_BEARER]) {
			conn.setOauth_bearer(.Curl_cstrdup(data.getSet().getStr()[dupstring.STRING_BEARER]));
			if (!conn.getOauth_bearer()) {
				result = .CURLE_OUT_OF_MEMORY;
				;
			} 
		} 
		if (data.getSet().getStr()[dupstring.STRING_SASL_AUTHZID]) {
			conn.setSasl_authzid(.Curl_cstrdup(data.getSet().getStr()[dupstring.STRING_SASL_AUTHZID]));
			if (!conn.getSasl_authzid()) {
				result = .CURLE_OUT_OF_MEMORY;
				;
			} 
		} 
		result = ModernizedCProgram.create_conn_helper_init_proxy(/* After the unix socket init but before the proxy vars are used, parse and
		     initialize the proxy vars */conn);
		if (result) {
			;
		} 
		if ((conn.getGiven().getFlags() & (1 << 0)) && conn.getBits().getHttpproxy()) {
			conn.getBits().setTunnel_proxy(1/*************************************************************
			   * Figure out the remote port number and fix it in the URL
			   *************************************************************/);
		} 
		result = ModernizedCProgram.parse_remote_port(data, conn);
		if (result) {
			;
		} 
		result = ModernizedCProgram.override_login(data, conn, conn.getUser(), conn.getPasswd(), conn.getOptions());
		if (result) {
			;
		} 
		result = ModernizedCProgram.set_login(/* default credentials */conn);
		if (result) {
			;
		} 
		result = ModernizedCProgram.parse_connect_to_slist(data, conn, data.getSet().getConnect_to());
		if (result) {
			;
		} 
		result = ModernizedCProgram.idnconvert_hostname(conn, conn.getHost());
		if (result) {
			;
		} 
		if (conn.getBits().getConn_to_host()) {
			result = ModernizedCProgram.idnconvert_hostname(conn, conn.getConn_to_host());
			if (result) {
				;
			} 
		} 
		if (conn.getBits().getHttpproxy()) {
			result = ModernizedCProgram.idnconvert_hostname(conn, conn.getHttp_proxy().getHost());
			if (result) {
				;
			} 
		} 
		if (conn.getBits().getSocksproxy()) {
			result = ModernizedCProgram.idnconvert_hostname(conn, conn.getSocks_proxy().getHost());
			if (result) {
				;
			} 
		} 
		if (conn.getBits().getConn_to_host() && ModernizedCProgram.Curl_strcasecompare(conn.getConn_to_host().getName(), conn.getHost().getName())) {
			conn.getBits().setConn_to_host(0/*************************************************************
			   * Check whether the port and the "connect to port" are equal.
			   * Do this after the remote port number has been fixed in the URL.
			   *************************************************************/);
		} 
		if (conn.getBits().getConn_to_port() && conn.getConn_to_port() == conn.getRemote_port()) {
			conn.getBits().setConn_to_port(0/*************************************************************
			   * If the "connect to" feature is used with an HTTP proxy,
			   * we set the tunnel_proxy bit.
			   *************************************************************/);
		} 
		if ((conn.getBits().getConn_to_host() || conn.getBits().getConn_to_port()) && conn.getBits().getHttpproxy()) {
			conn.getBits().setTunnel_proxy(1/*************************************************************
			   * Setup internals depending on protocol. Needs to be done after
			   * we figured out what/if proxy to use.
			   *************************************************************/);
		} 
		result = ModernizedCProgram.setup_connection_internals(conn);
		if (result) {
			;
		} 
		conn.getRecv()[0] = ModernizedCProgram.Curl_recv_plain;
		conn.getSend()[0] = ModernizedCProgram.Curl_send_plain;
		conn.getRecv()[1] = ModernizedCProgram.Curl_recv_plain;
		conn.getSend()[1] = ModernizedCProgram.Curl_send_plain;
		conn.getBits().setTcp_fastopen(data.getSet().getTcp_fastopen());
		if (conn.getHandler().getFlags() & (1 << 4)) {
			bool done = new bool();
			do {
			} while (0);
			ModernizedCProgram.Curl_persistconninfo(conn);
			result = .UNRECOGNIZEDFUNCTIONNAME(conn, done);
			if (!/* Setup a "faked" transfer that'll do nothing */result) {
				conn.getBits().getTcpconnect()[0] = /* we are "connected */1;
				result = ModernizedCProgram.Curl_conncache_add_conn(data.getState().getConn_cache(), conn);
				if (result) {
					;
				} 
				result = ModernizedCProgram.setup_range(data);
				if (result) {
					do {
					} while (0);
					(Object).UNRECOGNIZEDFUNCTIONNAME(conn, result, /* we ignore the return code for the protocol-specific DONE */0);
					;
				} 
				ModernizedCProgram.Curl_attach_connnection(data, conn);
				ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, -1);
			} 
			ModernizedCProgram.Curl_init_do(data, /* since we skip do_init() */conn);
			;
		} 
		data.getSet().getSsl().getPrimary().setCApath(data.getSet().getStr()[dupstring.STRING_SSL_CAPATH_ORIG]);
		data.getSet().getProxy_ssl().getPrimary().setCApath(data.getSet().getStr()[dupstring.STRING_SSL_CAPATH_PROXY]);
		data.getSet().getSsl().getPrimary().setCAfile(data.getSet().getStr()[dupstring.STRING_SSL_CAFILE_ORIG]);
		data.getSet().getProxy_ssl().getPrimary().setCAfile(data.getSet().getStr()[dupstring.STRING_SSL_CAFILE_PROXY]);
		data.getSet().getSsl().getPrimary().setRandom_file(data.getSet().getStr()[dupstring.STRING_SSL_RANDOM_FILE]);
		data.getSet().getProxy_ssl().getPrimary().setRandom_file(data.getSet().getStr()[dupstring.STRING_SSL_RANDOM_FILE]);
		data.getSet().getSsl().getPrimary().setEgdsocket(data.getSet().getStr()[dupstring.STRING_SSL_EGDSOCKET]);
		data.getSet().getProxy_ssl().getPrimary().setEgdsocket(data.getSet().getStr()[dupstring.STRING_SSL_EGDSOCKET]);
		data.getSet().getSsl().getPrimary().setCipher_list(data.getSet().getStr()[dupstring.STRING_SSL_CIPHER_LIST_ORIG]);
		data.getSet().getProxy_ssl().getPrimary().setCipher_list(data.getSet().getStr()[dupstring.STRING_SSL_CIPHER_LIST_PROXY]);
		data.getSet().getSsl().getPrimary().setCipher_list13(data.getSet().getStr()[dupstring.STRING_SSL_CIPHER13_LIST_ORIG]);
		data.getSet().getProxy_ssl().getPrimary().setCipher_list13(data.getSet().getStr()[dupstring.STRING_SSL_CIPHER13_LIST_PROXY]);
		data.getSet().getSsl().getPrimary().setPinned_key(data.getSet().getStr()[dupstring.STRING_SSL_PINNEDPUBLICKEY_ORIG]);
		data.getSet().getProxy_ssl().getPrimary().setPinned_key(data.getSet().getStr()[dupstring.STRING_SSL_PINNEDPUBLICKEY_PROXY]);
		data.getSet().getSsl().setCRLfile(data.getSet().getStr()[dupstring.STRING_SSL_CRLFILE_ORIG]);
		data.getSet().getProxy_ssl().setCRLfile(data.getSet().getStr()[dupstring.STRING_SSL_CRLFILE_PROXY]);
		data.getSet().getSsl().setIssuercert(data.getSet().getStr()[dupstring.STRING_SSL_ISSUERCERT_ORIG]);
		data.getSet().getProxy_ssl().setIssuercert(data.getSet().getStr()[dupstring.STRING_SSL_ISSUERCERT_PROXY]);
		data.getSet().getSsl().setCert(data.getSet().getStr()[dupstring.STRING_CERT_ORIG]);
		data.getSet().getProxy_ssl().setCert(data.getSet().getStr()[dupstring.STRING_CERT_PROXY]);
		data.getSet().getSsl().setCert_type(data.getSet().getStr()[dupstring.STRING_CERT_TYPE_ORIG]);
		data.getSet().getProxy_ssl().setCert_type(data.getSet().getStr()[dupstring.STRING_CERT_TYPE_PROXY]);
		data.getSet().getSsl().setKey(data.getSet().getStr()[dupstring.STRING_KEY_ORIG]);
		data.getSet().getProxy_ssl().setKey(data.getSet().getStr()[dupstring.STRING_KEY_PROXY]);
		data.getSet().getSsl().setKey_type(data.getSet().getStr()[dupstring.STRING_KEY_TYPE_ORIG]);
		data.getSet().getProxy_ssl().setKey_type(data.getSet().getStr()[dupstring.STRING_KEY_TYPE_PROXY]);
		data.getSet().getSsl().setKey_passwd(data.getSet().getStr()[dupstring.STRING_KEY_PASSWD_ORIG]);
		data.getSet().getProxy_ssl().setKey_passwd(data.getSet().getStr()[dupstring.STRING_KEY_PASSWD_PROXY]);
		data.getSet().getSsl().getPrimary().setClientcert(data.getSet().getStr()[dupstring.STRING_CERT_ORIG]);
		data.getSet().getProxy_ssl().getPrimary().setClientcert(data.getSet().getStr()[dupstring.STRING_CERT_PROXY]);
		if (!.Curl_clone_primary_ssl_config(data.getSet().getSsl().getPrimary(), conn.getSsl_config())) {
			result = .CURLE_OUT_OF_MEMORY;
			;
		} 
		if (!.Curl_clone_primary_ssl_config(data.getSet().getProxy_ssl().getPrimary(), conn.getProxy_ssl_config())) {
			result = .CURLE_OUT_OF_MEMORY;
			;
		} 
		ModernizedCProgram.prune_dead_connections(data/*************************************************************
		   * Check the current list of connections to see if we can
		   * re-use an already existing one or if we have to create a
		   * new one.
		   *************************************************************/);
		do {
		} while (0);
		do {
		} while (0/* reuse_fresh is TRUE if we are told to use a new connection by force, but
		     we only acknowledge this option if this is not a re-used connection
		     already (which happens due to follow-location or during a HTTP
		     authentication phase). CONNECT_ONLY transfers also refuse reuse. */);
		if ((data.getSet().getReuse_fresh() && !data.getState().getThis_is_a_follow()) || data.getSet().getConnect_only()) {
			reuse = 0;
		} else {
				reuse = ModernizedCProgram.ConnectionExists(data, conn, conn_temp, force_reuse, waitpipe);
		} 
		if (reuse && !force_reuse && ModernizedCProgram.IsMultiplexingPossible(data, /* If we found a reusable connection that is now marked as in use, we may
		     still want to open a new connection if we are multiplexing. */conn_temp)) {
			size_t multiplexed = ((conn_temp).getEasyq().getSize());
			if (multiplexed > 0) {
				ModernizedCProgram.Curl_infof(data, "Found connection %ld, with %zu requests on it\n", conn_temp.getConnection_id(), multiplexed);
				if (ModernizedCProgram.Curl_conncache_bundle_size(conn_temp) < max_host_connections && ModernizedCProgram.Curl_conncache_size(data) < max_total_connections) {
					reuse = /* We want a new connection anyway */0;
					ModernizedCProgram.Curl_infof(data, "We can reuse, but we want a new connection anyway\n");
					ModernizedCProgram.Curl_conncache_return_conn(conn_temp);
				} 
			} 
		} 
		if (reuse/*
		     * We already have a connection for this, we got the former connection
		     * in the conn_temp variable and thus we need to cleanup the one we
		     * just allocated before we can move along and use the previously
		     * existing one.
		     */) {
			ModernizedCProgram.reuse_conn(conn, conn_temp);
			.Curl_cfree(/* we don't need this anymore */conn);
			conn = conn_temp;
			in_connect = conn;
			ModernizedCProgram.Curl_infof(data, "Re-using existing connection! (#%ld) with %s %s\n", conn.getConnection_id(), conn.getBits().getProxy() ? "proxy" : "host", conn.getSocks_proxy().getHost().getName() ? conn.getSocks_proxy().getHost().getDispname() : conn.getHttp_proxy().getHost().getName() ? conn.getHttp_proxy().getHost().getDispname() : conn.getHost().getDispname());
		} else {
				if (conn.getHandler().getFlags() & (1 << 8/* The protocol wants it, so set the bits if enabled in the easy handle
				         (default) */)) {
					if (data.getSet().getSsl_enable_alpn()) {
						conn.getBits().setTls_enable_alpn(1);
					} 
					if (data.getSet().getSsl_enable_npn()) {
						conn.getBits().setTls_enable_npn(1);
					} 
				} 
				if (waitpipe/* There is a connection that *might* become usable for multiplexing
				         "soon", and we wait for that */) {
					connections_available = 0;
				} else {
						byte bundlehost;
						connectbundle bundle = ModernizedCProgram.Curl_conncache_find_bundle(conn, data.getState().getConn_cache(), bundlehost);
						if (max_host_connections > 0 && bundle && (bundle.getNum_connections() >= max_host_connections)) {
							connectdata conn_candidate = new connectdata();
							conn_candidate = ModernizedCProgram.Curl_conncache_extract_bundle(data, /* The bundle is full. Extract the oldest connection. */bundle);
							ModernizedCProgram.Curl_conncache_unlock(data);
							if (conn_candidate) {
								(Object)ModernizedCProgram.Curl_disconnect(data, conn_candidate, /* dead_connection */0);
							} else {
									ModernizedCProgram.Curl_infof(data, "No more connections allowed to host %s: %zu\n", bundlehost, max_host_connections);
									connections_available = 0;
							} 
						} else {
								ModernizedCProgram.Curl_conncache_unlock(data);
						} 
				} 
				if (connections_available && (max_total_connections > 0) && (ModernizedCProgram.Curl_conncache_size(data) >= max_total_connections)) {
					connectdata conn_candidate = new connectdata();
					conn_candidate = ModernizedCProgram.Curl_conncache_extract_oldest(/* The cache is full. Let's see if we can kill a connection. */data);
					if (conn_candidate) {
						(Object)ModernizedCProgram.Curl_disconnect(data, conn_candidate, /* dead_connection */0);
					} else {
							ModernizedCProgram.Curl_infof(data, "No connections available in cache\n");
							connections_available = 0;
					} 
				} 
				if (!connections_available) {
					ModernizedCProgram.Curl_infof(data, "No connections available.\n");
					ModernizedCProgram.conn_free(conn);
					in_connect = ((Object)0);
					result = .CURLE_NO_CONNECTION_AVAILABLE;
					;
				} else {
						result = ModernizedCProgram.Curl_conncache_add_conn(data.getState().getConn_cache(), conn);
						if (result) {
							;
						} 
				} 
				if ((data.getState().getAuthhost().getPicked() & ((((long)1) << 3) | (((long)1) << /* If NTLM is requested in a part of this connection, make sure we don't
				       assume the state is fine as this is a fresh connection and NTLM is
				       connection based. */5))) && data.getState().getAuthhost().getDone()) {
					ModernizedCProgram.Curl_infof(data, "NTLM picked AND auth done set, clear picked!\n");
					data.getState().getAuthhost().setPicked(((long)0));
					data.getState().getAuthhost().setDone(0);
				} 
				if ((data.getState().getAuthproxy().getPicked() & ((((long)1) << 3) | (((long)1) << 5))) && data.getState().getAuthproxy().getDone()) {
					ModernizedCProgram.Curl_infof(data, "NTLM-proxy picked AND auth done set, clear picked!\n");
					data.getState().getAuthproxy().setPicked(((long)0));
					data.getState().getAuthproxy().setDone(0);
				} 
		} 
		ModernizedCProgram.Curl_init_do(data, /* Setup and init stuff before DO starts, in preparing for the transfer. */conn/*
		   * Setup whatever necessary for a resumed transfer
		   */);
		result = ModernizedCProgram.setup_range(data);
		if (result) {
			;
		} 
		conn.setSeek_func(data.getSet().getSeek_func());
		conn.setSeek_client(data.getSet().getSeek_client());
		result = ModernizedCProgram.resolve_server(data, conn, async);
		ModernizedCProgram.strip_trailing_dot(conn.getHost());
		if (conn.getBits().getHttpproxy()) {
			ModernizedCProgram.strip_trailing_dot(conn.getHttp_proxy().getHost());
		} 
		if (conn.getBits().getSocksproxy()) {
			ModernizedCProgram.strip_trailing_dot(conn.getSocks_proxy().getHost());
		} 
		if (conn.getBits().getConn_to_host()) {
			ModernizedCProgram.strip_trailing_dot(conn.getConn_to_host());
		} 
	}
	public static  Curl_setup_conn(Object conn, Object protocol_done) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		ModernizedCProgram.Curl_pgrsTime(data, .TIMER_NAMELOOKUP);
		if (conn.getHandler().getFlags() & (1 << 4)) {
			protocol_done = /* nothing to setup when not using a network */1;
			return result;
		} 
		protocol_done = /* default to not done */0/* set proxy_connect_closed to false unconditionally already here since it
		     is used strictly to provide extra information to a parent function in the
		     case of proxy CONNECT failures and we must make sure we don't have it
		     lingering set from a previous invoke */;
		conn.getBits().setProxy_connect_closed(0/*
		   * Set user-agent. Used for HTTP, but since we can attempt to tunnel
		   * basically anything through a http proxy we can't limit this based on
		   * protocol.
		   */);
		if (data.getSet().getStr()[dupstring.STRING_USERAGENT]) {
			do {
				.Curl_cfree((conn.getAllocptr().getUagent()));
				(conn.getAllocptr().getUagent()) = ((Object)0);
			} while (0);
			conn.getAllocptr().setUagent(ModernizedCProgram.curl_maprintf("User-Agent: %s\r\n", data.getSet().getStr()[dupstring.STRING_USERAGENT]));
			if (!conn.getAllocptr().getUagent()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		data.getReq().setHeaderbytecount(0/* reset CRLF conversion counter */);
		curltime curltime = new curltime();
		conn.setNow(curltime.Curl_now());
		if ((SOCKET)(~0) == conn.getSock()[0]) {
			conn.getBits().getTcpconnect()[0] = 0;
			result = ModernizedCProgram.Curl_connecthost(conn, conn.getDns_entry());
			if (result) {
				return result;
			} 
		} else {
				ModernizedCProgram.Curl_pgrsTime(data, /* we're connected already */.TIMER_CONNECT);
				if (conn.getSsl()[0].getUse() || (conn.getHandler().getProtocol() & ((1 << 4) | (1 << 5)))) {
					ModernizedCProgram.Curl_pgrsTime(data, /* we're connected already */.TIMER_APPCONNECT);
				} 
				conn.getBits().getTcpconnect()[0] = 1;
				protocol_done = 1;
				ModernizedCProgram.Curl_updateconninfo(conn, conn.getSock()[0]);
				ModernizedCProgram.Curl_verboseconnect(conn);
		} 
		conn.setNow(curltime.Curl_now());
		return result;
	}
	public static  Curl_connect(Object data, Object asyncp, Object protocol_done) {
		CURLcode result = new CURLcode();
		connectdata conn = new connectdata();
		asyncp = /* assume synchronous resolves by default */0;
		ModernizedCProgram.Curl_free_request_state(/* init the single-transfer specific data */data);
		.memset(data.getReq(), 0, );
		data.getReq().setMaxdownload(-1);
		result = ModernizedCProgram.create_conn(data, conn, /* call the stuff that needs to be called */asyncp);
		if (!result) {
			if (((conn).getEasyq().getSize())) {
				protocol_done = /* multiplexed */1;
			}  else if (!asyncp/* DNS resolution is done: that's either because this is a reused
			         connection, in which case DNS was unnecessary, or because DNS
			         really did finish already (synch resolver/fast async resolve) */) {
				result = ModernizedCProgram.Curl_setup_conn(conn, protocol_done);
			} 
		} 
		if (result == .CURLE_NO_CONNECTION_AVAILABLE) {
			return result;
		}  else if (result && conn/* We're not allowed to return failure with memory left allocated in the
		       connectdata struct, free those here */) {
			ModernizedCProgram.Curl_disconnect(data, conn, 1);
		}  else if (!result && !data.getConn()) {
			ModernizedCProgram.Curl_attach_connnection(data, /* FILE: transfers already have the connection attached */conn);
		} 
		return result/*
		 * Curl_init_do() inits the readwrite session. This is inited each time (in
		 * the DO function before the protocol-specific DO functions are invoked) for
		 * a transfer, sometimes multiple times on the same Curl_easy. Make sure
		 * nothing in here depends on stuff that are setup dynamically for the
		 * transfer.
		 *
		 * Allow this function to get called with 'conn' set to NULL.
		 */;
	}
	public static  Curl_init_do(Object data, Object conn) {
		SingleRequest k = data.getReq();
		if (conn) {
			conn.getBits().setDo_more(/* by default there's no curl_do_more() to
			                                   use */0);
			if (data.getState().getWildcardmatch() && !(conn.getHandler().getFlags() & (1 << 12))) {
				data.getState().setWildcardmatch(0);
			} 
		} 
		data.getState().setDone(/* *_done() is not called yet */0);
		data.getState().setExpect100header(0);
		if (data.getSet().getOpt_no_body()) {
			data.getSet().setHttpreq(/* in HTTP lingo, no body means using the HEAD request... */.HTTPREQ_HEAD);
		}  else if (.HTTPREQ_HEAD == data.getSet().getHttpreq()) {
			data.getSet().setHttpreq(.HTTPREQ_GET);
		} 
		curltime curltime = new curltime();
		k.setStart(curltime.Curl_now());
		k.setNow(k.getStart());
		k.setHeader(/* assume header */1);
		k.setBytecount(0);
		k.setBuf(data.getState().getBuffer());
		k.setHbufp(data.getState().getHeaderbuff());
		k.setIgnorebody(0);
		ModernizedCProgram.Curl_speedinit(data);
		ModernizedCProgram.Curl_pgrsSetUploadCounter(data, 0);
		ModernizedCProgram.Curl_pgrsSetDownloadCounter(data, 0);
		return .CURLE_OK/*
		* get_protocol_family()
		*
		* This is used to return the protocol family for a given protocol.
		*
		* Parameters:
		*
		* protocol  [in]  - A single bit protocol identifier such as HTTP or HTTPS.
		*
		* Returns the family as a single bit protocol identifier.
		*/;
	}
	public static int get_protocol_family(int protocol) {
		int family;
		switch (protocol) {
		case (1 << 15):
				family = (1 << 14);
				break;
		case (1 << 26):
		case (1 << 1):
				family = (1 << 0);
				break;
		case (1 << 3):
				family = (1 << 2);
				break;
		case (1 << 27):
				family = (1 << 26);
				break;
		case (1 << 10):
				family = (1 << 10);
				break;
		case (1 << 11):
				family = (1 << 11);
				break;
		case (1 << 23):
				family = (1 << 19);
				break;
		case (1 << 0):
		case (1 << 7):
		case (1 << 9):
				family = (1 << 9);
				break;
		case (1 << 4):
				family = (1 << 4);
				break;
		case (1 << 14):
		case (1 << 25):
				family = (1 << 25);
				break;
		case (1 << 21):
				family = (1 << 21);
				break;
		case (1 << 17):
				family = (1 << 16);
				break;
		case (1 << 19):
		case (1 << 20):
		case (1 << 5):
				family = (1 << 5);
				break;
		case (1 << 16):
		case (1 << 18):
				family = (1 << 18);
				break;
		case (1 << 12):
		case (1 << 8):
				family = (1 << 7);
				break;
		case (1 << 22):
				family = (1 << 22);
				break;
		case (1 << 13):
				family = (1 << 12);
				break;
		case (1 << 2):
		case (1 << 24):
				family = (1 << 20);
				break;
		case (1 << 6):
				family = (1 << 6);
				break;
		default:
				family = 0;
				break;
		}
		return family;
	}
	/* Some parts of the code (e.g. chunked encoding) assume this buffer has at
	 * more than just a few bytes to play with. Don't let it become too small or
	 * bad things will happen.
	 */
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/***
	
	
	RECEIVING COOKIE INFORMATION
	============================
	
	struct CookieInfo *Curl_cookie_init(struct Curl_easy *data,
	                    const char *file, struct CookieInfo *inc, bool newsession);
	
	        Inits a cookie struct to store data in a local file. This is always
	        called before any cookies are set.
	
	struct Cookie *Curl_cookie_add(struct Curl_easy *data,
	                 struct CookieInfo *c, bool httpheader, char *lineptr,
	                 const char *domain, const char *path);
	
	        The 'lineptr' parameter is a full "Set-cookie:" line as
	        received from a server.
	
	        The function need to replace previously stored lines that this new
	        line supersedes.
	
	        It may remove lines that are expired.
	
	        It should return an indication of success/error.
	
	
	SENDING COOKIE INFORMATION
	==========================
	
	struct Cookies *Curl_cookie_getlist(struct CookieInfo *cookie,
	                                    char *host, char *path, bool secure);
	
	        For a given host and path, return a linked list of cookies that
	        the client should send to the server if used now. The secure
	        boolean informs the cookie if a secure connection is achieved or
	        not.
	
	        It shall only return cookies that haven't expired.
	
	
	Example set of cookies:
	
	    Set-cookie: PRODUCTINFO=webxpress; domain=.fidelity.com; path=/; secure
	    Set-cookie: PERSONALIZE=none;expires=Monday, 13-Jun-1988 03:04:55 GMT;
	    domain=.fidelity.com; path=/ftgw; secure
	    Set-cookie: FidHist=none;expires=Monday, 13-Jun-1988 03:04:55 GMT;
	    domain=.fidelity.com; path=/; secure
	    Set-cookie: FidOrder=none;expires=Monday, 13-Jun-1988 03:04:55 GMT;
	    domain=.fidelity.com; path=/; secure
	    Set-cookie: DisPend=none;expires=Monday, 13-Jun-1988 03:04:55 GMT;
	    domain=.fidelity.com; path=/; secure
	    Set-cookie: FidDis=none;expires=Monday, 13-Jun-1988 03:04:55 GMT;
	    domain=.fidelity.com; path=/; secure
	    Set-cookie:
	    Session_Key@6791a9e0-901a-11d0-a1c8-9b012c88aa77=none;expires=Monday,
	    13-Jun-1988 03:04:55 GMT; domain=.fidelity.com; path=/; secure
	****/
	/* The last 3 #include files should be in this order */
	public static void freecookie(Object co) {
		.Curl_cfree(co.getExpirestr());
		.Curl_cfree(co.getDomain());
		.Curl_cfree(co.getPath());
		.Curl_cfree(co.getSpath());
		.Curl_cfree(co.getName());
		.Curl_cfree(co.getValue());
		.Curl_cfree(co.getMaxage());
		.Curl_cfree(co.getVersion());
		.Curl_cfree(co);
	}
	public static  tailmatch(Object cooke_domain, Object hostname) {
		size_t cookie_domain_len = .strlen(cooke_domain);
		size_t hostname_len = .strlen(hostname);
		if (hostname_len < cookie_domain_len) {
			return 0;
		} 
		if (!ModernizedCProgram.Curl_strcasecompare(cooke_domain, hostname + hostname_len - cookie_domain_len)) {
			return 0/* A lead char of cookie_domain is not '.'.
			     RFC6265 4.1.2.3. The Domain Attribute says:
			       For example, if the value of the Domain attribute is
			       "example.com", the user agent will include the cookie in the Cookie
			       header when making HTTP requests to example.com, www.example.com, and
			       www.corp.example.com.
			   */;
		} 
		if (hostname_len == cookie_domain_len) {
			return 1;
		} 
		if ((byte)'.' == (hostname + hostname_len - cookie_domain_len - 1)) {
			return 1;
		} 
		return 0/*
		 * Return true if the given string is an IP(v4|v6) address.
		 */;
	}
	public static  isip(Object domain) {
		in_addr addr = new in_addr();
		if (ModernizedCProgram.Curl_inet_pton(2, domain, addr)) {
			return /* domain name given as IP address */1;
		} 
		return 0/*
		 * matching cookie path and url path
		 * RFC6265 5.1.4 Paths and Path-Match
		 */;
	}
	public static  pathmatch(Object cookie_path, Object request_uri) {
		size_t cookie_path_len = new size_t();
		size_t uri_path_len = new size_t();
		byte uri_path = ((Object)0);
		byte pos;
		bool ret = 0;
		cookie_path_len = .strlen(/* cookie_path must not have last '/' separator. ex: /sample */cookie_path);
		if (1 == cookie_path_len) {
			return /* cookie_path must be '/' */1;
		} 
		uri_path = .Curl_cstrdup(request_uri);
		if (!uri_path) {
			return 0;
		} 
		pos = .strchr(uri_path, (byte)'?');
		if (pos) {
			pos = -1024;
		} 
		if (0 == .strlen(uri_path) || uri_path[0] != /* #-fragments are already cut off! */(byte)'/') {
			.Curl_cfree(uri_path);
			uri_path = .Curl_cstrdup("/");
			if (!uri_path) {
				return 0/* here, RFC6265 5.1.4 says
				     4. Output the characters of the uri-path from the first character up
				        to, but not including, the right-most %x2F ("/").
				     but URL path /hoge?fuga=xxx means /hoge/index.cgi?fuga=xxx in some site
				     without redirect.
				     Ignore this algorithm because /hoge is uri path for this case
				     (uri path is not /).
				   */;
			} 
		} 
		uri_path_len = .strlen(uri_path);
		if (uri_path_len < cookie_path_len) {
			ret = 0;
			;
		} 
		if (.strncmp(cookie_path, uri_path, /* not using checkprefix() because matching should be case-sensitive */cookie_path_len)) {
			ret = 0;
			;
		} 
		if (cookie_path_len == /* The cookie-path and the uri-path are identical. */uri_path_len) {
			ret = 1;
			;
		} 
		if (uri_path[cookie_path_len] == /* here, cookie_path_len < uri_path_len */(byte)'/') {
			ret = 1;
			;
		} 
		ret = 0;
		return ret/*
		 * Return the top-level domain, for optimal hashing.
		 */;
	}
	public static Object get_top_domain(Object domain, Object outlen) {
		size_t len = new size_t();
		byte first = ((Object)0);
		byte last;
		if (!domain) {
			return ((Object)0);
		} 
		len = .strlen(domain);
		last = ModernizedCProgram.Curl_memrchr((domain), ((byte)'.'), (len));
		if (last) {
			first = ModernizedCProgram.Curl_memrchr((domain), ((byte)'.'), ((last - domain)));
			if (first) {
				len -= (++first - domain);
			} 
		} 
		if (outlen) {
			outlen = len;
		} 
		return first ? first : domain/*
		 * A case-insensitive hash for the cookie domains.
		 */;
	}
	public static Object cookie_hash_domain(Object domain, Object len) {
		byte end = domain + len;
		size_t h = 5381;
		while (domain < end) {
			h += h << 5;
			h ^=  ModernizedCProgram.Curl_raw_toupper(domain++);
		}
		return (h % 256/*
		 * Hash this domain.
		 */);
	}
	public static Object cookiehash(Object domain) {
		byte top;
		size_t len = new size_t();
		if (!domain || ModernizedCProgram.isip(domain)) {
			return 0;
		} 
		top = ModernizedCProgram.get_top_domain(domain, len);
		return ModernizedCProgram.cookie_hash_domain(top, len/*
		 * cookie path sanitize
		 */);
	}
	public static Object sanitize_cookie_path(Object cookie_path) {
		size_t len = new size_t();
		byte new_path = .Curl_cstrdup(cookie_path);
		if (!new_path) {
			return ((Object)0);
		} 
		len = .strlen(/* some stupid site sends path attribute with '"'. */new_path);
		if (new_path[0] == (byte)'\"') {
			.memmove((Object)new_path, (Object)(new_path + 1), len);
			len--;
		} 
		if (len && (new_path[len - 1] == (byte)'\"')) {
			new_path[len - 1] = -1024;
			len--;
		} 
		if (new_path[0] != /* RFC6265 5.2.4 The Path Attribute */(byte)'/') {
			.Curl_cfree(/* Let cookie-path be the default-path. */new_path);
			new_path = .Curl_cstrdup("/");
			return new_path;
		} 
		if (len && new_path[len - 1] == /* convert /hoge/ to /hoge */(byte)'/') {
			new_path[len - 1] = -1024;
		} 
		return new_path/*
		 * Load cookies from all given cookie files (CURLOPT_COOKIEFILE).
		 *
		 * NOTE: OOM or cookie parsing failures are ignored.
		 */;
	}
	public static void Curl_cookie_loadfiles(Object data) {
		curl_slist list = data.getChange().getCookielist();
		if (list) {
			ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_COOKIE, .CURL_LOCK_ACCESS_SINGLE);
			while (list) {
				CookieInfo newcookies = ModernizedCProgram.Curl_cookie_init(data, list.getData(), data.getCookies(), data.getSet().getCookiesession());
				if (!newcookies/* Failure may be due to OOM or a bad cookie; both are ignored
				         * but only the first should be
				         */) {
					ModernizedCProgram.Curl_infof(data, "ignoring failed cookie_init for %s\n", list.getData());
				} else {
						data.setCookies(newcookies);
				} 
				list = list.getNext();
			}
			ModernizedCProgram.curl_slist_free_all(data.getChange().getCookielist());
			data.getChange().setCookielist(((Object)/* don't do this again! */0));
			ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_COOKIE/*
			 * strstore() makes a strdup() on the 'newstr' and if '*str' is non-NULL
			 * that will be freed before the allocated string is stored there.
			 *
			 * It is meant to easily replace strdup()
			 */);
		} 
	}
	public static void strstore(Object str, Object newstr) {
		.Curl_cfree(str);
		str = .Curl_cstrdup(newstr/*
		 * remove_expired() removes expired cookies.
		 */);
	}
	public static void remove_expired(Object cookies) {
		Cookie co = new Cookie();
		Cookie nx = new Cookie();
		curl_off_t now = (curl_off_t).time(((Object)0));
		int i;
		for (i = 0; i < 256; i++) {
			Cookie pv = ((Object)0);
			co = cookies.getCookies()[i];
			while (co) {
				nx = co.getNext();
				if (co.getExpires() && co.getExpires() < now) {
					if (!pv) {
						cookies.getCookies()[i] = co.getNext();
					} else {
							pv.setNext(co.getNext());
					} 
					cookies.getNumcookies()--;
					ModernizedCProgram.freecookie(co);
				} else {
						pv = co;
				} 
				co = nx;
			}
		}
	}
	/* Make sure domain contains a dot or is localhost. */
	public static  bad_domain(Object domain) {
		return !.strchr(domain, (byte)'.') && !ModernizedCProgram.Curl_strcasecompare(domain, "localhost"/****************************************************************************
		 *
		 * Curl_cookie_add()
		 *
		 * Add a single cookie line to the cookie keeping object.
		 *
		 * Be aware that sometimes we get an IP-only host name, and that might also be
		 * a numerical IPv6 address.
		 *
		 * Returns NULL on out of memory or invalid cookie. This is suboptimal,
		 * as they should be treated separately.
		 ***************************************************************************/);
	}
	public static Object Curl_cookie_add(Object data, Object c,  httpheader,  noexpire, Object lineptr, Object domain, Object path,  secure) {
		/* TRUE if connection is over secure origin */Cookie clist = new Cookie();
		Cookie co = new Cookie();
		Cookie lastc = ((Object)0);
		time_t now = .time(((Object)0));
		bool replace_old = 0;
		bool badcookie = /* cookies are good by default. mmmmm yummy */0;
		size_t myhash = new size_t();
		co = .Curl_ccalloc(1, /* First, alloc and init a new struct for it */);
		if (!co) {
			return ((Object)/* bail out if we're this low on memory */0);
		} 
		if (httpheader) {
			byte[] name = new byte[/* This line was read off a HTTP-header */4096];
			byte[] what = new byte[4096];
			byte ptr;
			byte semiptr;
			size_t linelength = .strlen(lineptr);
			if (linelength > 5000) {
				.Curl_cfree(/* discard overly long lines at once */co);
				return ((Object)0);
			} 
			semiptr = .strchr(lineptr, /* first, find a semicolon */(byte)';');
			while (lineptr && (int)((((byte)lineptr) == (byte)' ') || (((byte)lineptr) == (byte)'\t'))) {
				lineptr++;
			}
			ptr = lineptr;
			do {
				name[0] = what[0] = /* we have a <what>=<this> pair or a stand-alone word here *//* init the buffers */0;
				if (1 <= .sscanf(ptr, "%4095[^;\r\n=] =%4095[^;\r\n]", name, what/* Use strstore() below to properly deal with received cookie
				           headers that have the same string property set more than once,
				           and then we use the last one. */)) {
					byte whatptr;
					bool done = 0;
					bool sep = new bool();
					size_t len = .strlen(what);
					size_t nlen = .strlen(name);
					byte endofn = ptr[nlen];
					if (nlen >= (4096 - 1) || len >= (4096 - 1) || ((nlen + len) > 4096/* too long individual name or contents, or too long combination of
					             name + contents. Chrome and Firefox support 4095 or 4096 bytes
					             combo. */)) {
						ModernizedCProgram.freecookie(co);
						ModernizedCProgram.Curl_infof(data, "oversized cookie dropped, name/val %zu + %zu bytes\n", nlen, len);
						return ((Object)0);
					} 
					sep = (endofn == (byte)'=') ? 1 : /* name ends with a '=' ? */0;
					if (nlen) {
						/* move to the last character */endofn--;
						if ((int)((((byte)endofn) == (byte)' ') || (((byte)endofn) == (byte)'\t'))) {
							while (endofn && (int)((((byte)endofn) == (byte)' ') || (((byte)endofn) == (byte)'\t')) && /* skip trailing spaces in name */nlen) {
								endofn--;
								nlen--;
							}
							name[nlen] = /* new end of name */0;
						} 
					} 
					while (len && (int)((((byte)what[len - 1]) == (byte)' ') || (((byte)what[len - 1]) == /* Strip off trailing whitespace from the 'what' */(byte)'\t'))) {
						what[len - 1] = 0;
						len--;
					}
					whatptr = /* Skip leading whitespace from the 'what' */what;
					while (whatptr && (int)((((byte)whatptr) == (byte)' ') || (((byte)whatptr) == (byte)'\t'))) {
						whatptr/*
						         * Check if we have a reserved prefix set before anything else, as we
						         * otherwise have to test for the prefix in both the cookie name and
						         * "the rest". Prefixes must start with '__' and end with a '-', so
						         * only test for names where that can possibly be true.
						         */++;
					}
					if (nlen > 3 && name[0] == (byte)'_' && name[1] == (byte)'_') {
						if (ModernizedCProgram.Curl_strncasecompare("__Secure-", name, 9)) {
							co.getPrefix() |=  (1 << 0);
						}  else if (ModernizedCProgram.Curl_strncasecompare("__Host-", name, 7)) {
							co.getPrefix() |=  (1 << 1);
						} 
					} 
					if (!co.getName()) {
						if (!/* The very first name/value pair is the actual cookie name */sep) {
							badcookie = /* Bad name/value pair. */1;
							break;
						} 
						co.setName(.Curl_cstrdup(name));
						co.setValue(.Curl_cstrdup(whatptr));
						done = 1;
						if (!co.getName() || !co.getValue()) {
							badcookie = 1;
							break;
						} 
					}  else if (!len/* this was a "<name>=" with no content, and we must allow
					             'secure' and 'httponly' specified this weirdly */) {
						done = 1/*
						           * secure cookies are only allowed to be set when the connection is
						           * using a secure protocol, or when the cookie is being set by
						           * reading from file
						           */;
						if (ModernizedCProgram.Curl_strcasecompare("secure", name)) {
							if (secure || !c.getRunning()) {
								co.setSecure(1);
							} else {
									badcookie = 1;
									break;
							} 
						}  else if (ModernizedCProgram.Curl_strcasecompare("httponly", name)) {
							co.setHttponly(1);
						}  else if (sep) {
							done = /* there was a '=' so we're not done parsing this field */0;
						} 
					} 
					if (done) {
						;
					}  else if (ModernizedCProgram.Curl_strcasecompare("path", name)) {
						ModernizedCProgram.strstore(co.getPath(), whatptr);
						if (!co.getPath()) {
							badcookie = /* out of memory bad */1;
							break;
						} 
						.Curl_cfree(co.getSpath());
						co.setSpath(ModernizedCProgram.sanitize_cookie_path(co.getPath()));
						if (!co.getSpath()) {
							badcookie = /* out of memory bad */1;
							break;
						} 
					}  else if (ModernizedCProgram.Curl_strcasecompare("domain", name)) {
						bool is_ip = new bool();
						if ((byte)'.' == whatptr[0]) {
							/* ignore preceding dot */whatptr/*
							           * Without PSL we don't know when the incoming cookie is set on a
							           * TLD or otherwise "protected" suffix. To reduce risk, we require a
							           * dot OR the exact host name being "localhost".
							           *//*
							           * Without PSL we don't know when the incoming cookie is set on a
							           * TLD or otherwise "protected" suffix. To reduce risk, we require a
							           * dot OR the exact host name being "localhost".
							           */++;
						} 
						if (ModernizedCProgram.bad_domain(whatptr)) {
							domain = ":";
						} 
						is_ip = ModernizedCProgram.isip(domain ? domain : whatptr);
						if (!domain || (is_ip && !.strcmp(whatptr, domain)) || (!is_ip && ModernizedCProgram.tailmatch(whatptr, domain))) {
							ModernizedCProgram.strstore(co.getDomain(), whatptr);
							if (!co.getDomain()) {
								badcookie = 1;
								break;
							} 
							if (!is_ip) {
								co.setTailmatch(/* we always do that if the domain name was
								                                       given */1);
							} 
						} else {
								badcookie = /* we did not get a tailmatch and then the attempted set domain
								               is not a domain to which the current host belongs. Mark as
								               bad. */1;
								ModernizedCProgram.Curl_infof(data, "skipped cookie with bad tailmatch domain: %s\n", whatptr);
						} 
					}  else if (ModernizedCProgram.Curl_strcasecompare("version", name)) {
						ModernizedCProgram.strstore(co.getVersion(), whatptr);
						if (!co.getVersion()) {
							badcookie = 1;
							break;
						} 
					}  else if (ModernizedCProgram.Curl_strcasecompare("max-age", name/* Defined in RFC2109:
					
					             Optional.  The Max-Age attribute defines the lifetime of the
					             cookie, in seconds.  The delta-seconds value is a decimal non-
					             negative integer.  After delta-seconds seconds elapse, the
					             client should discard the cookie.  A value of zero means the
					             cookie should be discarded immediately.
					
					          */)) {
						ModernizedCProgram.strstore(co.getMaxage(), whatptr);
						if (!co.getMaxage()) {
							badcookie = 1;
							break;
						} 
					}  else if (ModernizedCProgram.Curl_strcasecompare("expires", name)) {
						ModernizedCProgram.strstore(co.getExpirestr(), whatptr);
						if (!co.getExpirestr()) {
							badcookie = 1;
							break;
						} 
					} 
				} 
				if (!semiptr || !/* this is an "illegal" <what>=<this> pair */semiptr) {
					semiptr = ((Object)/* we already know there are no more cookies */0);
					continue;
				} 
				ptr = semiptr + 1;
				while (ptr && (int)((((byte)ptr) == (byte)' ') || (((byte)ptr) == (byte)'\t'))) {
					ptr++;
				}
				semiptr = .strchr(ptr, /* now, find the next semicolon */(byte)';');
				if (!semiptr && ptr/* There are no more semicolons, but there's a final name=value pair
				           coming up */) {
					semiptr = .strchr(ptr, (byte)'\0');
				} 
			} while (semiptr);
			if (co.getMaxage()) {
				CURLofft offt = new CURLofft();
				offt = ModernizedCProgram.curlx_strtoofft((co.getMaxage() == (byte)'\"') ? co.getMaxage()[1] : co.getMaxage()[0], ((Object)0), 10, co.getExpires());
				if (offt == .CURL_OFFT_FLOW) {
					co.setExpires(/* overflow, used max value */-1024);
				}  else if (!offt) {
					if (!co.getExpires()) {
						co.setExpires(/* already expired */1);
					}  else if (-1024 - now < co.getExpires()) {
						co.setExpires(/* would overflow */-1024);
					} else {
							co.getExpires() += now;
					} 
				} 
			}  else if (co.getExpirestr()) {
				co.setExpires(ModernizedCProgram.curl_getdate(co.getExpirestr(), ((Object)0/* Session cookies have expires set to 0 so if we get that back
				         from the date parser let's add a second to make it a
				         non-session cookie */)));
				if (co.getExpires() == 0) {
					co.setExpires(1);
				}  else if (co.getExpires() < 0) {
					co.setExpires(0);
				} 
			} 
			if (!badcookie && !co.getDomain()) {
				if (domain) {
					co.setDomain(.Curl_cstrdup(/* no domain was given in the header line, set the default */domain));
					if (!co.getDomain()) {
						badcookie = 1;
					} 
				} 
			} 
			if (!badcookie && !co.getPath() && path/* No path was given in the header line, set the default.
			         Note that the passed-in path to this function MAY have a '?' and
			         following part that MUST not be stored as part of the path. */) {
				byte queryp = .strchr(path, (byte)'?'/* queryp is where the interesting part of the path ends, so now we
				         want to the find the last */);
				byte endslash;
				if (!queryp) {
					endslash = .strrchr(path, (byte)'/');
				} else {
						endslash = ModernizedCProgram.Curl_memrchr((path), ((byte)'/'), ((queryp - path)));
				} 
				if (endslash) {
					size_t pathlen = (endslash - path + /* include end slash */1);
					co.setPath(.Curl_cmalloc(pathlen + /* one extra for the zero byte */1));
					if (co.getPath()) {
						.memcpy(co.getPath(), path, pathlen);
						co.getPath()[pathlen] = /* zero terminate */0;
						co.setSpath(ModernizedCProgram.sanitize_cookie_path(co.getPath()));
						if (!co.getSpath()) {
							badcookie = /* out of memory bad */1;
						} 
					} else {
							badcookie = 1;
					} 
				} 
			} 
			if (badcookie || !co.getName()) {
				ModernizedCProgram.freecookie(co);
				return ((Object)0);
			} 
		} else {
				byte ptr;
				byte firstptr;
				byte tok_buf = ((Object)0);
				int fields;
				if (.strncmp(lineptr, "#HttpOnly_", 10) == 0) {
					lineptr += 10;
					co.setHttponly(1);
				} 
				if (lineptr[0] == (byte)'#') {
					.Curl_cfree(/* don't even try the comments */co);
					return ((Object)0);
				} 
				ptr = .strchr(lineptr, /* strip off the possible end-of-line characters */(byte)'\r');
				if (ptr) {
					ptr = /* clear it */0;
				} 
				ptr = .strchr(lineptr, (byte)'\n');
				if (ptr) {
					ptr = /* clear it */0;
				} 
				firstptr = ModernizedCProgram.Curl_strtok_r(lineptr, "\t", /* tokenize it on the TAB */tok_buf);
				for (; ptr && !/* Now loop through the fields and init the struct we already have
				       allocated */badcookie; ) {
					switch (fields) {
					case 5:
							co.setName(.Curl_cstrdup(ptr));
							if (!co.getName()) {
								badcookie = 1;
							} else {
									if (ModernizedCProgram.Curl_strncasecompare("__Secure-", co.getName(), /* For Netscape file format cookies we check prefix on the name */9)) {
										co.getPrefix() |=  (1 << 0);
									}  else if (ModernizedCProgram.Curl_strncasecompare("__Host-", co.getName(), 7)) {
										co.getPrefix() |=  (1 << 1);
									} 
							} 
							break;
					case 6:
							co.setValue(.Curl_cstrdup(ptr));
							if (!co.getValue()) {
								badcookie = 1;
							} 
							break;
					case /* FALLTHROUGH */3:
							co.setSecure(0);
							if (ModernizedCProgram.Curl_strcasecompare(ptr, "TRUE")) {
								if (secure || c.getRunning()) {
									co.setSecure(1);
								} else {
										badcookie = 1;
								} 
							} 
							break;
					case 4:
							if (ModernizedCProgram.curlx_strtoofft(ptr, ((Object)0), 10, co.getExpires())) {
								badcookie = 1;
							} 
							break;
					case 2:
							if (.strcmp("TRUE", ptr) && .strcmp("FALSE", /* The file format allows the path field to remain not filled in */ptr)) {
								co.setPath(.Curl_cstrdup(/* only if the path doesn't look like a boolean option! */ptr));
								if (!co.getPath()) {
									badcookie = 1;
								} else {
										co.setSpath(ModernizedCProgram.sanitize_cookie_path(co.getPath()));
										if (!co.getSpath()) {
											badcookie = /* out of memory bad */1;
										} 
								} 
								break;
							} 
							co.setPath(.Curl_cstrdup(/* this doesn't look like a path, make one up! */"/"));
							if (!co.getPath()) {
								badcookie = 1;
							} 
							co.setSpath(.Curl_cstrdup("/"));
							if (!co.getSpath()) {
								badcookie = 1;
							} 
							/* add a field and fall down to secure */fields++;
					case 0:
							if (ptr[0] == /* skip preceding dots */(byte)'.') {
								ptr++;
							} 
							co.setDomain(.Curl_cstrdup(ptr));
							if (!co.getDomain()) {
								badcookie = 1;
							} 
							break;
					case 1/* flag: A TRUE/FALSE value indicating if all machines within a given
					           domain can access the variable. Set TRUE when the cookie says
					           .domain.com and to false when the domain is complete www.domain.com
					        */:
							co.setTailmatch(ModernizedCProgram.Curl_strcasecompare(ptr, "TRUE") ? 1 : 0);
							break;
					}
				}
				if (6 == fields) {
					co.setValue(.Curl_cstrdup(/* we got a cookie with blank contents, fix it */""));
					if (!co.getValue()) {
						badcookie = 1;
					} else {
							fields++;
					} 
				} 
				if (!badcookie && (7 != fields)) {
					badcookie = /* we did not find the sufficient number of fields */1;
				} 
				if (badcookie) {
					ModernizedCProgram.freecookie(co);
					return ((Object)0);
				} 
		} 
		if (co.getPrefix() & (1 << 0)) {
			if (!co.getSecure()) {
				ModernizedCProgram.freecookie(co);
				return ((Object)0);
			} 
		} 
		if (co.getPrefix() & (1 << 1/*
		     * The __Host- prefix requires the cookie to be secure, have a "/" path
		     * and not have a domain set.
		     */)) {
			if (co.getSecure() && co.getPath() && .strcmp(co.getPath(), "/") == 0 && !co.getTailmatch()) {
				;
			} else {
					ModernizedCProgram.freecookie(co);
					return ((Object)0);
			} 
		} 
		if (!c.getRunning() && c.getNewsession() && !co.getExpires()) {
			ModernizedCProgram.freecookie(co);
			return ((Object)0);
		} 
		co.setLivecookie(c.getRunning());
		co.setCreationtime(++c.getLastct());
		if (!/* at first, remove expired cookies */noexpire) {
			ModernizedCProgram.remove_expired(c/* Check if the domain is a Public Suffix and if yes, ignore the cookie. */);
		} 
		myhash = ModernizedCProgram.cookiehash(co.getDomain());
		clist = c.getCookies()[myhash];
		replace_old = 0;
		while (clist) {
			if (ModernizedCProgram.Curl_strcasecompare(clist.getName(), co.getName())) {
				if (clist.getDomain() && co.getDomain()) {
					if (ModernizedCProgram.Curl_strcasecompare(clist.getDomain(), co.getDomain()) && (clist.getTailmatch() == co.getTailmatch())) {
						replace_old = /* The domains are identical */1;
					} 
				}  else if (!clist.getDomain() && !co.getDomain()) {
					replace_old = 1;
				} 
				if (replace_old/* the domains were identical */) {
					if (clist.getSpath() && co.getSpath()) {
						if (clist.getSecure() && !co.getSecure() && !secure) {
							size_t cllen = new size_t();
							byte sep;
							sep = .strchr(clist.getSpath() + 1, (byte)'/');
							if (sep) {
								cllen = sep - clist.getSpath();
							} else {
									cllen = .strlen(clist.getSpath());
							} 
							if (ModernizedCProgram.Curl_strncasecompare(clist.getSpath(), co.getSpath(), cllen)) {
								ModernizedCProgram.freecookie(co);
								return ((Object)0);
							} 
						}  else if (ModernizedCProgram.Curl_strcasecompare(clist.getSpath(), co.getSpath())) {
							replace_old = 1;
						} else {
								replace_old = 0;
						} 
					}  else if (!clist.getSpath() && !co.getSpath()) {
						replace_old = 1;
					} else {
							replace_old = 0;
					} 
				} 
				if (replace_old && !co.getLivecookie() && clist.getLivecookie()) {
					ModernizedCProgram.freecookie(/* Free the newcomer and get out of here! */co);
					return ((Object)0);
				} 
				if (replace_old) {
					co.setNext(clist.getNext());
					co.setCreationtime(clist.getCreationtime());
					.Curl_cfree(clist.getName());
					.Curl_cfree(clist.getValue());
					.Curl_cfree(clist.getDomain());
					.Curl_cfree(clist.getPath());
					.Curl_cfree(clist.getSpath());
					.Curl_cfree(clist.getExpirestr());
					.Curl_cfree(clist.getVersion());
					.Curl_cfree(clist.getMaxage());
					clist = /* then store all the new data */co;
					.Curl_cfree(/* free the newly alloced memory */co);
					co = /* point to the previous struct instead */clist/* We have replaced a cookie, now skip the rest of the list but
					           make sure the 'lastc' pointer is properly set */;
					do {
						lastc = clist;
						clist = clist.getNext();
					} while (clist);
					break;
				} 
			} 
			lastc = clist;
			clist = clist.getNext();
		}
		if (c.getRunning()) {
			ModernizedCProgram.Curl_infof(data, /* Only show this when NOT reading the cookies from a file */"%s cookie %s=\"%s\" for domain %s, path %s, expire %I64d\n", replace_old ? "Replaced" : "Added", co.getName(), co.getValue(), co.getDomain(), co.getPath(), co.getExpires());
		} 
		if (!replace_old) {
			if (/* then make the last item point on this new one */lastc) {
				lastc.setNext(co);
			} else {
					c.getCookies()[myhash] = co;
			} 
			c.getNumcookies()++;
		} 
		return co/*****************************************************************************
		 *
		 * Curl_cookie_init()
		 *
		 * Inits a cookie struct to read data from a local file. This is always
		 * called before any cookies are set. File may be NULL.
		 *
		 * If 'newsession' is TRUE, discard all "session cookies" on read from file.
		 *
		 * Note that 'data' might be called as NULL pointer.
		 *
		 * Returns NULL on out of memory. Invalid cookies are ignored.
		 ****************************************************************************/;
	}
	/* The 'data' pointer here may be NULL at times, and thus
	                   must only be used very carefully for things that can deal
	                   with data being NULL. Such as infof() and similar */
	public static Object Curl_cookie_init(Object data, Object file, Object inc,  newsession) {
		CookieInfo c = new CookieInfo();
		FILE fp = ((Object)0);
		bool fromfile = 1;
		byte line = ((Object)0);
		if (((Object)0) == inc) {
			c = .Curl_ccalloc(1, /* we didn't get a struct, create one */);
			if (!c) {
				return ((Object)/* failed to get memory */0);
			} 
			c.setFilename(.Curl_cstrdup(file ? file : /* copy the name just in case */"none"));
			if (!c.getFilename()) {
				;
			} 
		} else {
				c = /* we got an already existing one, use that */inc;
		} 
		c.setRunning(/* this is not running, this is init */0);
		if (file && !.strcmp(file, "-")) {
			fp = (_iob[0]);
			fromfile = 0;
		}  else if (file && !file) {
			fp = ((Object)/* points to a "" string */0);
		} else {
				fp = file ? .fopen(file, "rt") : ((Object)0);
		} 
		c.setNewsession(/* new session? */newsession);
		if (fp) {
			byte lineptr;
			bool headerline = new bool();
			line = .Curl_cmalloc(5000);
			if (!line) {
				;
			} 
			while (ModernizedCProgram.Curl_get_line(line, 5000, fp)) {
				if (ModernizedCProgram.curl_strnequal("Set-Cookie:", line, .strlen("Set-Cookie:"))) {
					lineptr = line[/* This is a cookie line, get it! */11];
					headerline = 1;
				} else {
						lineptr = line;
						headerline = 0;
				} 
				while (lineptr && (int)((((byte)lineptr) == (byte)' ') || (((byte)lineptr) == (byte)'\t'))) {
					lineptr++;
				}
				ModernizedCProgram.Curl_cookie_add(data, c, headerline, 1, lineptr, ((Object)0), ((Object)0), 1);
			}
			.Curl_cfree(/* free the line buffer */line);
			ModernizedCProgram.remove_expired(/* run this once, not on every cookie */c);
			if (fromfile) {
				.fclose(fp);
			} 
		} 
		c.setRunning(/* now, we're running */1);
		if (data) {
			data.getState().setCookie_engine(1);
		} 
		return c;
		if (!inc/* Only clean up if we allocated it here, as the original could still be in
		     * use by a share handle */) {
			ModernizedCProgram.Curl_cookie_cleanup(c);
		} 
		if (fromfile && fp) {
			.fclose(fp);
		} 
		return ((Object)/* out of memory */0);
	}
	/* sort this so that the longest path gets before the shorter path */
	public static int cookie_sort(Object p1, Object p2) {
		Cookie c1 = (Cookie)p1;
		Cookie c2 = (Cookie)p2;
		size_t l1 = new size_t();
		size_t l2 = new size_t();
		l1 = c1.getPath() ? .strlen(c1.getPath()) : /* 1 - compare cookie path lengths */0;
		l2 = c2.getPath() ? .strlen(c2.getPath()) : 0;
		if (l1 != l2) {
			return (l2 > l1) ? 1 : -/* avoid size_t <=> int conversions */1;
		} 
		l1 = c1.getDomain() ? .strlen(c1.getDomain()) : /* 2 - compare cookie domain lengths */0;
		l2 = c2.getDomain() ? .strlen(c2.getDomain()) : 0;
		if (l1 != l2) {
			return (l2 > l1) ? 1 : -/* avoid size_t <=> int conversions */1;
		} 
		l1 = c1.getName() ? .strlen(c1.getName()) : /* 3 - compare cookie name lengths */0;
		l2 = c2.getName() ? .strlen(c2.getName()) : 0;
		if (l1 != l2) {
			return (l2 > l1) ? 1 : -1;
		} 
		return (c2.getCreationtime() > c1.getCreationtime()) ? 1 : -/* 4 - compare cookie creation time */1;
	}
	/* sort cookies only according to creation time */
	public static int cookie_sort_ct(Object p1, Object p2) {
		Cookie c1 = (Cookie)p1;
		Cookie c2 = (Cookie)p2;
		return (c2.getCreationtime() > c1.getCreationtime()) ? 1 : -1;
	}
	public static Object dup_cookie(Object src) {
		Cookie d = .Curl_ccalloc(, 1);
		if (d) {
			do {
				if (src.getExpirestr()) {
					d.setExpirestr(.Curl_cstrdup(src.getExpirestr()));
					if (!d.getExpirestr()) {
						;
					} 
				} 
			} while (0);
			do {
				if (src.getDomain()) {
					d.setDomain(.Curl_cstrdup(src.getDomain()));
					if (!d.getDomain()) {
						;
					} 
				} 
			} while (0);
			do {
				if (src.getPath()) {
					d.setPath(.Curl_cstrdup(src.getPath()));
					if (!d.getPath()) {
						;
					} 
				} 
			} while (0);
			do {
				if (src.getSpath()) {
					d.setSpath(.Curl_cstrdup(src.getSpath()));
					if (!d.getSpath()) {
						;
					} 
				} 
			} while (0);
			do {
				if (src.getName()) {
					d.setName(.Curl_cstrdup(src.getName()));
					if (!d.getName()) {
						;
					} 
				} 
			} while (0);
			do {
				if (src.getValue()) {
					d.setValue(.Curl_cstrdup(src.getValue()));
					if (!d.getValue()) {
						;
					} 
				} 
			} while (0);
			do {
				if (src.getMaxage()) {
					d.setMaxage(.Curl_cstrdup(src.getMaxage()));
					if (!d.getMaxage()) {
						;
					} 
				} 
			} while (0);
			do {
				if (src.getVersion()) {
					d.setVersion(.Curl_cstrdup(src.getVersion()));
					if (!d.getVersion()) {
						;
					} 
				} 
			} while (0);
			d.setExpires(src.getExpires());
			d.setTailmatch(src.getTailmatch());
			d.setSecure(src.getSecure());
			d.setLivecookie(src.getLivecookie());
			d.setHttponly(src.getHttponly());
			d.setCreationtime(src.getCreationtime());
		} 
		return d;
		return ((Object)0/*****************************************************************************
		 *
		 * Curl_cookie_getlist()
		 *
		 * For a given host and path, return a linked list of cookies that the
		 * client should send to the server if used now. The secure boolean informs
		 * the cookie if a secure connection is achieved or not.
		 *
		 * It shall only return cookies that haven't expired.
		 *
		 ****************************************************************************/);
	}
	public static Object Curl_cookie_getlist(Object c, Object host, Object path,  secure) {
		Cookie newco = new Cookie();
		Cookie co = new Cookie();
		Cookie mainco = ((Object)0);
		size_t matches = 0;
		bool is_ip = new bool();
		size_t myhash = ModernizedCProgram.cookiehash(host);
		if (!c || !c.getCookies()[myhash]) {
			return ((Object)/* no cookie struct or no cookies in the struct */0);
		} 
		ModernizedCProgram.remove_expired(/* at first, remove expired cookies */c);
		is_ip = ModernizedCProgram.isip(/* check if host is an IP(v4|v6) address */host);
		co = c.getCookies()[myhash];
		while (co) {
			if (co.getSecure() ? secure : /* if the cookie requires we're secure we must only continue if we are! */1) {
				if (!co.getDomain() || (co.getTailmatch() && !is_ip && ModernizedCProgram.tailmatch(co.getDomain(), host)) || ((!co.getTailmatch() || is_ip) && ModernizedCProgram.Curl_strcasecompare(host, co.getDomain()))) {
					if (!co.getSpath() || ModernizedCProgram.pathmatch(co.getSpath(), /* now check the left part of the path with the cookies path
					           requirement */path/* and now, we know this is a match and we should create an
					             entry for the return-linked-list */)) {
						newco = ModernizedCProgram.dup_cookie(co);
						if (newco) {
							newco.setNext(/* then modify our next */mainco);
							mainco = /* point the main to us */newco;
							matches++;
						} else {
								;
						} 
					} 
				} 
			} 
			co = co.getNext();
		}
		if (matches/* Now we need to make sure that if there is a name appearing more than
		       once, the longest specified path version comes first. To make this
		       the swiftest way, we just sort them all based on path length. */) {
			Cookie array = new Cookie();
			size_t i = new size_t();
			array = .Curl_cmalloc( * /* alloc an array and store all cookie pointers */matches);
			if (!array) {
				;
			} 
			co = mainco;
			for (i = 0; co; co = co.getNext()) {
				array[i++] = co;
			}
			.qsort(array, matches, , /* now sort the cookie pointers in path length order */cookie_sort);
			mainco = array[/* remake the linked list order according to the new order *//* start here */0];
			for (i = 0; i < matches - 1; i++) {
				array[i].setNext(array[i + 1]);
			}
			array[matches - 1].setNext(((Object)/* terminate the list */0));
			.Curl_cfree(/* remove the temporary data again */array);
		} 
		return /* return the new list */mainco;
		return ((Object)0/*****************************************************************************
		 *
		 * Curl_cookie_clearall()
		 *
		 * Clear all existing cookies and reset the counter.
		 *
		 ****************************************************************************/);
	}
	public static void Curl_cookie_clearall(Object cookies) {
		if (cookies) {
			int i;
			for (i = 0; i < 256; i++) {
				ModernizedCProgram.Curl_cookie_freelist(cookies.getCookies()[i]);
				cookies.getCookies()[i] = ((Object)0);
			}
			cookies.setNumcookies(0/*****************************************************************************
			 *
			 * Curl_cookie_freelist()
			 *
			 * Free a list of cookies previously returned by Curl_cookie_getlist();
			 *
			 ****************************************************************************/);
		} 
	}
	public static void Curl_cookie_freelist(Object co) {
		Cookie next = new Cookie();
		while (co) {
			next = co.getNext();
			ModernizedCProgram.freecookie(co);
			co = next/*****************************************************************************
			 *
			 * Curl_cookie_clearsess()
			 *
			 * Free all session cookies in the cookies list.
			 *
			 ****************************************************************************/;
		}
	}
	public static void Curl_cookie_clearsess(Object cookies) {
		Cookie first = new Cookie();
		Cookie curr = new Cookie();
		Cookie next = new Cookie();
		Cookie prev = ((Object)0);
		int i;
		if (!cookies) {
			return ;
		} 
		for (i = 0; i < 256; i++) {
			if (!cookies.getCookies()[i]) {
				continue;
			} 
			first = curr = prev = cookies.getCookies()[i];
			for (; curr; curr = next) {
				next = curr.getNext();
				if (!curr.getExpires()) {
					if (first == curr) {
						first = next;
					} 
					if (prev == curr) {
						prev = next;
					} else {
							prev.setNext(next);
					} 
					ModernizedCProgram.freecookie(curr);
					cookies.getNumcookies()--;
				} else {
						prev = curr;
				} 
			}
			cookies.getCookies()[i] = first/*****************************************************************************
			 *
			 * Curl_cookie_cleanup()
			 *
			 * Free a "cookie object" previous created with Curl_cookie_init().
			 *
			 ****************************************************************************/;
		}
	}
	public static void Curl_cookie_cleanup(Object c) {
		if (c) {
			int i;
			.Curl_cfree(c.getFilename());
			for (i = 0; i < 256; i++) {
				ModernizedCProgram.Curl_cookie_freelist(c.getCookies()[i]);
			}
			.Curl_cfree(/* free the base struct as well */c/* get_netscape_format()
			 *
			 * Formats a string for Netscape output file, w/o a newline at the end.
			 *
			 * Function returns a char * to a formatted line. Has to be free()d
			*/);
		} 
	}
	public static Object get_netscape_format(Object co) {
		return ModernizedCProgram.curl_maprintf(/* httponly preamble */"%s%s%s\t%s\t%s\t%s\t%I64d\t%s\t%s"/* domain *//* tailmatch *//* path */, co.getHttponly() ? "#HttpOnly_" : /* secure *//* expires *//* name *//* value */""/* Make sure all domains are prefixed with a dot if they allow
		       tailmatching. This is Mozilla-style. */, (co.getTailmatch() && co.getDomain() && co.getDomain()[0] != (byte)'.') ? "." : "", co.getDomain() ? co.getDomain() : "unknown", co.getTailmatch() ? "TRUE" : "FALSE", co.getPath() ? co.getPath() : "/", co.getSecure() ? "TRUE" : "FALSE", co.getExpires(), co.getName(), co.getValue() ? co.getValue() : ""/*
		 * cookie_output()
		 *
		 * Writes all internally known cookies to the specified file. Specify
		 * "-" as file name to write to stdout.
		 *
		 * The function returns non-zero on write failure.
		 */);
	}
	public static int cookie_output(Object c, Object dumphere) {
		Cookie co = new Cookie();
		FILE out = new FILE();
		bool use_stdout = 0;
		if (!c) {
			return /* no cookie engine alive */0;
		} 
		ModernizedCProgram.remove_expired(/* at first, remove expired cookies */c);
		if (!.strcmp("-", dumphere)) {
			out = (_iob[/* use stdout */1]);
			use_stdout = 1;
		} else {
				out = .fopen(dumphere, "wt");
				if (!out) {
					return /* failure */1;
				} 
		} 
		.fputs("# Netscape HTTP Cookie File\n# https://curl.haxx.se/docs/http-cookies.html\n# This file was generated by libcurl! Edit at your own risk.\n\n", out);
		if (c.getNumcookies()) {
			int i;
			size_t nvalid = 0;
			Cookie array = new Cookie();
			array = .Curl_ccalloc(1,  * c.getNumcookies());
			if (!array) {
				if (!use_stdout) {
					.fclose(out);
				} 
				return 1;
			} 
			for (i = 0; i < 256; /* only sort the cookies with a domain property */i++) {
				for (co = c.getCookies()[i]; co; co = co.getNext()) {
					if (!co.getDomain()) {
						continue;
					} 
					array[nvalid++] = co;
				}
			}
			.qsort(array, nvalid, , cookie_sort_ct);
			for (i = 0; i < nvalid; i++) {
				byte format_ptr = ModernizedCProgram.get_netscape_format(array[i]);
				if (format_ptr == ((Object)0)) {
					ModernizedCProgram.curl_mfprintf(out, "#\n# Fatal libcurl error\n");
					.Curl_cfree(array);
					if (!use_stdout) {
						.fclose(out);
					} 
					return 1;
				} 
				ModernizedCProgram.curl_mfprintf(out, "%s\n", format_ptr);
				.Curl_cfree(format_ptr);
			}
			.Curl_cfree(array);
		} 
		if (!use_stdout) {
			.fclose(out);
		} 
		return 0;
	}
	public static Object cookie_list(Object data) {
		curl_slist list = ((Object)0);
		curl_slist beg = new curl_slist();
		Cookie c = new Cookie();
		byte line;
		int i;
		if ((data.getCookies() == ((Object)0)) || (data.getCookies().getNumcookies() == 0)) {
			return ((Object)0);
		} 
		for (i = 0; i < 256; i++) {
			for (c = data.getCookies().getCookies()[i]; c; c = c.getNext()) {
				if (!c.getDomain()) {
					continue;
				} 
				line = ModernizedCProgram.get_netscape_format(c);
				if (!line) {
					ModernizedCProgram.curl_slist_free_all(list);
					return ((Object)0);
				} 
				beg = ModernizedCProgram.Curl_slist_append_nodup(list, line);
				if (!beg) {
					.Curl_cfree(line);
					ModernizedCProgram.curl_slist_free_all(list);
					return ((Object)0);
				} 
				list = beg;
			}
		}
		return list;
	}
	public static Object Curl_cookie_list(Object data) {
		curl_slist list = new curl_slist();
		ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_COOKIE, .CURL_LOCK_ACCESS_SINGLE);
		list = ModernizedCProgram.cookie_list(data);
		ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_COOKIE);
		return list;
	}
	public static void Curl_flush_cookies(Object data,  cleanup) {
		if (data.getSet().getStr()[dupstring.STRING_COOKIEJAR]) {
			if (data.getChange().getCookielist()) {
				ModernizedCProgram.Curl_cookie_loadfiles(data);
			} 
			ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_COOKIE, .CURL_LOCK_ACCESS_SINGLE);
			if (ModernizedCProgram.cookie_output(data.getCookies(), data.getSet().getStr()[/* if we have a destination file for all the cookies to get dumped to */dupstring.STRING_COOKIEJAR])) {
				ModernizedCProgram.Curl_infof(data, "WARNING: failed to save cookies in %s\n", data.getSet().getStr()[dupstring.STRING_COOKIEJAR]);
			} 
		} else {
				if (cleanup && data.getChange().getCookielist()) {
					ModernizedCProgram.curl_slist_free_all(data.getChange().getCookielist());
					data.getChange().setCookielist(((Object)0));
				} 
				ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_COOKIE, .CURL_LOCK_ACCESS_SINGLE);
		} 
		if (cleanup && (!data.getShare() || (data.getCookies() != data.getShare().getCurl_share()))) {
			ModernizedCProgram.Curl_cookie_cleanup(data.getCookies());
			data.setCookies(((Object)0));
		} 
		ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_COOKIE/* CURL_DISABLE_HTTP || CURL_DISABLE_COOKIES */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/***********************************************************************
	 * Only for plain IPv4 builds
	 **********************************************************************/
	/* plain IPv4 code coming up */
	/* The last 3 #include files should be in this order */
	/*
	 * Curl_ipvalid() checks what CURL_IPRESOLVE_* requirements that might've
	 * been set and returns TRUE if they are OK.
	 */
	public static  Curl_ipvalid(Object conn) {
		if (conn.getIp_version() == 2) {
			return /* An IPv6 address was requested and we can't get/use one */0;
		} 
		return /* OK, proceed */1/*
		 * Curl_getaddrinfo() - the IPv4 synchronous version.
		 *
		 * The original code to this function was from the Dancer source code, written
		 * by Bjorn Reese, it has since been patched and modified considerably.
		 *
		 * gethostbyname_r() is the thread-safe version of the gethostbyname()
		 * function. When we build for plain IPv4, we attempt to use this
		 * function. There are _three_ different gethostbyname_r() versions, and we
		 * detect which one this platform supports in the configure script and set up
		 * the HAVE_GETHOSTBYNAME_R_3, HAVE_GETHOSTBYNAME_R_5 or
		 * HAVE_GETHOSTBYNAME_R_6 defines accordingly. Note that HAVE_GETADDRBYNAME
		 * has the corresponding rules. This is primarily on *nix. Note that some unix
		 * flavours have thread-safe versions of the plain gethostbyname() etc.
		 *
		 */;
	}
	/* synchronous response only */
	/* CURLRES_SYNCH */
	/* CURLRES_IPV4 */
	/*
	 * Curl_ipv4_resolve_r() - ipv4 threadsafe resolver function.
	 *
	 * This is used for both synchronous and asynchronous resolver builds,
	 * implying that only threadsafe code and function calls may be used.
	 *
	 */
	public static Object Curl_ipv4_resolve_r(Object hostname, int port) {
		Curl_addrinfo ai = ((Object)0);
		hostent h = ((Object)0);
		in_addr in = new in_addr();
		hostent buf = ((Object)0);
		if (ModernizedCProgram.Curl_inet_pton(2, hostname, in) > 0) {
			return ModernizedCProgram.Curl_ip2addr(2, in, hostname, /* This is a dotted IP address 123.123.123.123-style */port/*
			   * gethostbyname_r() is the preferred resolve function for many platforms.
			   * Since there are three different versions of it, the following code is
			   * somewhat #ifdef-ridden.
			   *//* major failure *//*
			     * The clearing of the buffer is a workaround for a gethostbyname_r bug in
			     * qnx nto and it is also _required_ for some of these functions on some
			     * platforms.
			     *//* Solaris, IRIX and more *//* If the buffer is too small, it returns NULL and sets errno to
			     * ERANGE. The errno is thread safe if this is compiled with
			     * -D_REENTRANT as then the 'errno' variable is a macro defined to get
			     * used properly for threads.
			     *//* Linux *//* DIFFERENCE *//* Redhat 8, using glibc 2.2.93 changed the behavior. Now all of a
			     * sudden this function returns EAGAIN if the given buffer size is too
			     * small. Previous versions are known to return ERANGE for the same
			     * problem.
			     *
			     * This wouldn't be such a big problem if older versions wouldn't
			     * sometimes return EAGAIN on a common failure case. Alas, we can't
			     * assume that EAGAIN *or* ERANGE means ERANGE for any given version of
			     * glibc.
			     *
			     * For now, we do that and thus we may call the function repeatedly and
			     * fail for older glibc versions that return EAGAIN, until we run out of
			     * buffer size (step_size grows beyond CURL_HOSTENT_SIZE).
			     *
			     * If anyone has a better fix, please tell us!
			     *
			     * -------------------------------------------------------------------
			     *
			     * On October 23rd 2003, Dan C dug up more details on the mysteries of
			     * gethostbyname_r() in glibc:
			     *
			     * In glibc 2.2.5 the interface is different (this has also been
			     * discovered in glibc 2.1.1-6 as shipped by Redhat 6). What I can't
			     * explain, is that tests performed on glibc 2.2.4-34 and 2.2.4-32
			     * (shipped/upgraded by Redhat 7.2) don't show this behavior!
			     *
			     * In this "buggy" version, the return code is -1 on error and 'errno'
			     * is set to the ERANGE or EAGAIN code. Note that 'errno' is not a
			     * thread-safe variable.
			     */);
		} else {
				h = .gethostbyname((Object)/* failure *//* AIX, Digital Unix/Tru64, HPUX 10, more? *//* For AIX 4.3 or later, we don't use gethostbyname_r() at all, because of
				     * the plain fact that it does not return unique full buffers on each
				     * call, but instead several of the pointers in the hostent structs will
				     * point to the same actual data! This have the unfortunate down-side that
				     * our caching system breaks down horribly. Luckily for us though, AIX 4.3
				     * and more recent versions have a "completely thread-safe"[*] libc where
				     * all the data is stored in thread-specific memory areas making calls to
				     * the plain old gethostbyname() work fine even for multi-threaded
				     * programs.
				     *
				     * This AIX 4.3 or later detection is all made in the configure script.
				     *
				     * Troels Walsted Hansen helped us work this out on March 3rd, 2003.
				     *
				     * [*] = much later we've found out that it isn't at all "completely
				     * thread-safe", but at least the gethostbyname() function is.
				     *//* August 22nd, 2000: Albert Chin-A-Young brought an updated version
				       * that should work! September 20: Richard Prescott worked on the buffer
				       * size dilemma.
				       *//* we don't deal with this, but set it anyway *//* failure, too smallish buffer size *//* success *//* result expected in h *//* This is the worst kind of the different gethostbyname_r() interfaces.
				       * Since we don't know how big buffer this particular lookup required,
				       * we can't realloc down the huge alloc without doing closer analysis of
				       * the returned data. Thus, we always use CURL_HOSTENT_SIZE for every
				       * name lookup. Fixing this would require an extra malloc() and then
				       * calling Curl_addrinfo_copy() that subsequent realloc()s down the new
				       * memory area to the actually used amount.
				       *//* HAVE_...BYNAME_R_5 || HAVE_...BYNAME_R_6 || HAVE_...BYNAME_R_3 *//* set return code to NULL *//* HAVE_GETADDRINFO_THREADSAFE || HAVE_GETHOSTBYNAME_R *//*
				     * Here is code for platforms that don't have a thread safe
				     * getaddrinfo() nor gethostbyname_r() function or for which
				     * gethostbyname() is the preferred one.
				     */hostname/* HAVE_GETADDRINFO_THREADSAFE || HAVE_GETHOSTBYNAME_R */);
		} 
		if (h) {
			ai = ModernizedCProgram.Curl_he2ai(h, port);
			if (/* used a *_r() function */buf) {
				.Curl_cfree(buf);
			} 
		} 
		return ai/* defined(CURLRES_IPV4) && !defined(CURLRES_ARES) */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	public static Object GetEnv(Object variable) {
		byte[] env = new byte[4096];
		byte temp = .getenv(variable);
		env[0] = (byte)'\0';
		if (temp != ((Object)0)) {
			.ExpandEnvironmentStringsA(temp, env, );
		} 
		return (env[0] != (byte)'\0') ? .Curl_cstrdup(env) : ((Object)0);
		byte env = ((Object)0);
		byte[] buf1 = new byte[1024];
		byte[] buf2 = new byte[1024];
		DWORD rc = new DWORD();
		/* Don't use getenv(); it doesn't find variable added after program was
		   * started. Don't accept truncated results (i.e. rc >= sizeof(buf1)).  */
		rc = .GetEnvironmentVariableA(variable, buf1, );
		if (rc > 0 && rc < ) {
			env = buf1;
			variable = buf1;
		} 
		if (do_expand && .strchr(variable, (byte)'%')) {
			rc = .ExpandEnvironmentStringsA(variable, buf2, );
			if (rc > 0 && rc <  && !.strchr(buf2, /* no vars still unexpanded */(byte)'%')) {
				env = buf2;
			} 
		} 
		return (env && env[0]) ? .strdup(env) : ((Object)/* no length control */0);
	}
	public static Object curl_getenv(Object v) {
		return ModernizedCProgram.GetEnv(v);
	}
	public static Object AddHttpPost(Object name, Object namelength, Object value, Object contentslength, Object buffer, Object bufferlength, Object contenttype, long flags, Object contentHeader, Object showfilename, Object userp, Object parent_post, Object httppost, Object last_post) {
		curl_httppost post = new curl_httppost();
		post = .Curl_ccalloc(1, );
		if (post) {
			post.setName(name);
			post.setNamelength((long)(name ? (namelength ? namelength : .strlen(name)) : 0));
			post.setContents(value);
			post.setContentlen(contentslength);
			post.setBuffer(buffer);
			post.setBufferlength((long)bufferlength);
			post.setContenttype(contenttype);
			post.setContentheader(contentHeader);
			post.setShowfilename(showfilename);
			post.setUserp(userp);
			post.setFlags(flags | (1 << 7));
		} else {
				return ((Object)0);
		} 
		if (parent_post) {
			post.setMore(parent_post.getMore());
			parent_post.setMore(/* then move the original 'more' to point to ourselves */post);
		} else {
				if (/* make the previous point to this */last_post) {
					(last_post).setNext(post);
				} else {
						(httppost) = post;
				} 
				(last_post) = post;
		} 
		return post/***************************************************************************
		 *
		 * AddFormInfo()
		 *
		 * Adds a FormInfo structure to the list presented by parent_form_info.
		 *
		 * Returns newly allocated FormInfo on success and NULL if malloc failed/
		 * parent_form_info is NULL.
		 *
		 ***************************************************************************/;
	}
	public static Object AddFormInfo(Object value, Object contenttype, Object parent_form_info) {
		FormInfo form_info = new FormInfo();
		form_info = .Curl_ccalloc(1, );
		if (form_info) {
			if (value) {
				form_info.setValue(value);
			} 
			if (contenttype) {
				form_info.setContenttype(contenttype);
			} 
			form_info.setFlags((1 << 0));
		} else {
				return ((Object)0);
		} 
		if (parent_form_info) {
			form_info.setMore(parent_form_info.getMore());
			parent_form_info.setMore(/* then move the original 'more' to point to ourselves */form_info);
		} 
		return form_info/***************************************************************************
		 *
		 * FormAdd()
		 *
		 * Stores a formpost parameter and builds the appropriate linked list.
		 *
		 * Has two principal functionalities: using files and byte arrays as
		 * post parts. Byte arrays are either copied or just the pointer is stored
		 * (as the user requests) while for files only the filename and not the
		 * content is stored.
		 *
		 * While you may have only one byte array for each name, multiple filenames
		 * are allowed (and because of this feature CURLFORM_END is needed after
		 * using CURLFORM_FILE).
		 *
		 * Examples:
		 *
		 * Simple name/value pair with copied contents:
		 * curl_formadd (&post, &last, CURLFORM_COPYNAME, "name",
		 * CURLFORM_COPYCONTENTS, "value", CURLFORM_END);
		 *
		 * name/value pair where only the content pointer is remembered:
		 * curl_formadd (&post, &last, CURLFORM_COPYNAME, "name",
		 * CURLFORM_PTRCONTENTS, ptr, CURLFORM_CONTENTSLENGTH, 10, CURLFORM_END);
		 * (if CURLFORM_CONTENTSLENGTH is missing strlen () is used)
		 *
		 * storing a filename (CONTENTTYPE is optional!):
		 * curl_formadd (&post, &last, CURLFORM_COPYNAME, "name",
		 * CURLFORM_FILE, "filename1", CURLFORM_CONTENTTYPE, "plain/text",
		 * CURLFORM_END);
		 *
		 * storing multiple filenames:
		 * curl_formadd (&post, &last, CURLFORM_COPYNAME, "name",
		 * CURLFORM_FILE, "filename1", CURLFORM_FILE, "filename2", CURLFORM_END);
		 *
		 * Returns:
		 * CURL_FORMADD_OK             on success
		 * CURL_FORMADD_MEMORY         if the FormInfo allocation fails
		 * CURL_FORMADD_OPTION_TWICE   if one option is given twice for one Form
		 * CURL_FORMADD_NULL           if a null pointer was given for a char
		 * CURL_FORMADD_MEMORY         if the allocation of a FormInfo struct failed
		 * CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used
		 * CURL_FORMADD_INCOMPLETE     if the some FormInfo is not complete (or error)
		 * CURL_FORMADD_MEMORY         if a HttpPost struct cannot be allocated
		 * CURL_FORMADD_MEMORY         if some allocation for string copying failed.
		 * CURL_FORMADD_ILLEGAL_ARRAY  if an illegal option is used in an array
		 *
		 ***************************************************************************/;
	}
	public static  FormAdd(Object httppost, Object last_post, Object params) {
		FormInfo first_form = new FormInfo();
		FormInfo current_form = new FormInfo();
		FormInfo form = ((Object)0);
		CURLFORMcode return_value = .CURL_FORMADD_OK;
		byte prevtype = ((Object)0);
		curl_httppost post = ((Object)0);
		CURLformoption option = new CURLformoption();
		curl_forms forms = ((Object)0);
		byte array_value = ((Object)/* value read from an array */0/* This is a state variable, that if TRUE means that we're parsing an
		     array that we got passed to us. If FALSE we're parsing the input
		     va_list arguments. */);
		bool array_state = 0/*
		   * We need to allocate the first struct to fill in.
		   */;
		first_form = .Curl_ccalloc(1, );
		if (!first_form) {
			return .CURL_FORMADD_MEMORY;
		} 
		current_form = first_form/*
		   * Loop through all the options set. Break if we have an error to report.
		   */;
		while (return_value == .CURL_FORMADD_OK) {
			if (array_state && /* first see if we have more parts of the array param */forms) {
				option = forms.getOption();
				array_value = (byte)forms.getValue();
				/* advance this to next entry */forms++;
				if (.CURLFORM_END == option) {
					array_state = /* end of array state */0;
					continue;
				} 
			} else {
					option = (int)/* This is not array-state, get next option */params;
					if (.CURLFORM_END == option) {
						break;
					} 
			} 
			switch (option) {
			case /* We upload a file */.CURLFORM_FILE:
					{ 
						byte filename = array_state ? array_value : (int)params;
						if (current_form.getValue()) {
							if (current_form.getFlags() & (1 << 0)) {
								if (filename) {
									byte fname = .Curl_cstrdup(filename);
									if (!fname) {
										return_value = .CURL_FORMADD_MEMORY;
									} else {
											form = ModernizedCProgram.AddFormInfo(fname, ((Object)0), current_form);
											if (!form) {
												.Curl_cfree(fname);
												return_value = .CURL_FORMADD_MEMORY;
											} else {
													form.setValue_alloc(1);
													current_form = form;
													form = ((Object)0);
											} 
									} 
								} else {
										return_value = .CURL_FORMADD_NULL;
								} 
							} else {
									return_value = .CURL_FORMADD_OPTION_TWICE;
							} 
						} else {
								if (filename) {
									current_form.setValue(.Curl_cstrdup(filename));
									if (!current_form.getValue()) {
										return_value = .CURL_FORMADD_MEMORY;
									} else {
											current_form.getFlags() |=  (1 << 0);
											current_form.setValue_alloc(1);
									} 
								} else {
										return_value = .CURL_FORMADD_NULL;
								} 
						} 
						break;
					}
			case .CURLFORM_CONTENTSLENGTH:
					current_form.setContentslength(array_state ? (size_t)array_value : (size_t)(int)params);
					break;
			case .CURLFORM_CONTENTTYPE:
					{ 
						byte contenttype = array_state ? array_value : (int)params;
						if (current_form.getContenttype()) {
							if (current_form.getFlags() & (1 << 0)) {
								if (contenttype) {
									byte type = .Curl_cstrdup(contenttype);
									if (!type) {
										return_value = .CURL_FORMADD_MEMORY;
									} else {
											form = ModernizedCProgram.AddFormInfo(((Object)0), type, current_form);
											if (!form) {
												.Curl_cfree(type);
												return_value = .CURL_FORMADD_MEMORY;
											} else {
													form.setContenttype_alloc(1);
													current_form = form;
													form = ((Object)0);
											} 
									} 
								} else {
										return_value = .CURL_FORMADD_NULL;
								} 
							} else {
									return_value = .CURL_FORMADD_OPTION_TWICE;
							} 
						} else {
								if (contenttype) {
									current_form.setContenttype(.Curl_cstrdup(contenttype));
									if (!current_form.getContenttype()) {
										return_value = .CURL_FORMADD_MEMORY;
									} else {
											current_form.setContenttype_alloc(1);
									} 
								} else {
										return_value = .CURL_FORMADD_NULL;
								} 
						} 
						break;
					}
			case .CURLFORM_BUFFER:
					{ 
						byte filename = array_state ? array_value : (int)params;
						if (current_form.getShowfilename()) {
							return_value = .CURL_FORMADD_OPTION_TWICE;
						} else {
								current_form.setShowfilename(.Curl_cstrdup(filename));
								if (!current_form.getShowfilename()) {
									return_value = .CURL_FORMADD_MEMORY;
								} else {
										current_form.setShowfilename_alloc(1);
								} 
						} 
						break;
					}
			case .CURLFORM_BUFFERLENGTH:
					if (current_form.getBufferlength()) {
						return_value = .CURL_FORMADD_OPTION_TWICE;
					} else {
							current_form.setBufferlength(array_state ? (size_t)array_value : (size_t)(int)params);
					} 
					break;
			case .CURLFORM_STREAM:
					current_form.getFlags() |=  (1 << 6);
					if (current_form.getUserp()) {
						return_value = .CURL_FORMADD_OPTION_TWICE;
					} else {
							byte userp = array_state ? array_value : (int)params;
							if (userp) {
								current_form.setUserp(userp);
								current_form.setValue(/* this isn't strictly true but we
								                                          derive a value from this later on
								                                          and we need this non-NULL to be
								                                          accepted as a fine form part */userp);
							} else {
									return_value = .CURL_FORMADD_NULL;
							} 
					} 
					break;
			case /* FALLTHROUGH */.CURLFORM_COPYNAME:
					if (current_form.getName()) {
						return_value = .CURL_FORMADD_OPTION_TWICE;
					} else {
							byte name = array_state ? array_value : (int)params;
							if (name) {
								current_form.setName(/* store for the moment */name);
							} else {
									return_value = .CURL_FORMADD_NULL;
							} 
					} 
					break;
			case .CURLFORM_BUFFERPTR:
					current_form.getFlags() |=  (1 << 5) | (1 << 4);
					if (current_form.getBuffer()) {
						return_value = .CURL_FORMADD_OPTION_TWICE;
					} else {
							byte buffer = array_state ? array_value : (int)params;
							if (buffer) {
								current_form.setBuffer(/* store for the moment */buffer);
								current_form.setValue(/* make it non-NULL to be accepted
								                                           as fine */buffer);
							} else {
									return_value = .CURL_FORMADD_NULL;
							} 
					} 
					break;
			case .CURLFORM_NAMELENGTH:
					if (current_form.getNamelength()) {
						return_value = .CURL_FORMADD_OPTION_TWICE;
					} else {
							current_form.setNamelength(array_state ? (size_t)array_value : (size_t)(int)params);
					} 
					break;
			case /* FALLTHROUGH */.CURLFORM_COPYCONTENTS:
					if (current_form.getValue()) {
						return_value = .CURL_FORMADD_OPTION_TWICE;
					} else {
							byte value = array_state ? array_value : (int)params;
							if (value) {
								current_form.setValue(/* store for the moment */value);
							} else {
									return_value = .CURL_FORMADD_NULL;
							} 
					} 
					break;
			case .CURLFORM_ARRAY:
					if (array_state) {
						return_value = /* we don't support an array from within an array */.CURL_FORMADD_ILLEGAL_ARRAY;
					} else {
							forms = (int)params;
							if (forms) {
								array_state = 1;
							} else {
									return_value = .CURL_FORMADD_NULL;
							} 
					} 
					break;
			case .CURLFORM_CONTENTHEADER:
					{ 
						curl_slist list = /* this "cast increases required alignment of target type" but
						           we consider it OK anyway */array_state ? (curl_slist)(Object)array_value : (int)params;
						if (current_form.getContentheader()) {
							return_value = .CURL_FORMADD_OPTION_TWICE;
						} else {
								current_form.setContentheader(list);
						} 
						break;
					}
			case .CURLFORM_CONTENTLEN:
					current_form.getFlags() |=  (1 << 7);
					current_form.setContentslength(array_state ? (curl_off_t)(size_t)array_value : (int)params);
					break;
			case .CURLFORM_FILENAME:
			case .CURLFORM_PTRNAME/* Treat CURLFORM_PTR like CURLFORM_COPYNAME so that libcurl will copy
			       * the data in all cases so that we'll have safe memory for the eventual
			       * conversion.
			       */:
					current_form.getFlags() |=  (1 << /* fall through */2);
			case /* Get contents from a given file name */.CURLFORM_FILECONTENT:
					if (current_form.getFlags() & ((1 << 3) | (1 << 1))) {
						return_value = .CURL_FORMADD_OPTION_TWICE;
					} else {
							byte filename = array_state ? array_value : (int)params;
							if (filename) {
								current_form.setValue(.Curl_cstrdup(filename));
								if (!current_form.getValue()) {
									return_value = .CURL_FORMADD_MEMORY;
								} else {
										current_form.getFlags() |=  (1 << 1);
										current_form.setValue_alloc(1);
								} 
							} else {
									return_value = .CURL_FORMADD_NULL;
							} 
					} 
					break;
			case .CURLFORM_PTRCONTENTS:
					current_form.getFlags() |=  (1 << 3);
			default:
					return_value = .CURL_FORMADD_UNKNOWN_OPTION;
					break;
			}
		}
		if (.CURL_FORMADD_OK != return_value/* On error, free allocated fields for all nodes of the FormInfo linked
		       list without deallocating nodes. List nodes are deallocated later on */) {
			FormInfo ptr = new FormInfo();
			for (ptr = first_form; ptr != ((Object)0); ptr = ptr.getMore()) {
				if (ptr.getName_alloc()) {
					do {
						.Curl_cfree((ptr.getName()));
						(ptr.getName()) = ((Object)0);
					} while (0);
					ptr.setName_alloc(0);
				} 
				if (ptr.getValue_alloc()) {
					do {
						.Curl_cfree((ptr.getValue()));
						(ptr.getValue()) = ((Object)0);
					} while (0);
					ptr.setValue_alloc(0);
				} 
				if (ptr.getContenttype_alloc()) {
					do {
						.Curl_cfree((ptr.getContenttype()));
						(ptr.getContenttype()) = ((Object)0);
					} while (0);
					ptr.setContenttype_alloc(0);
				} 
				if (ptr.getShowfilename_alloc()) {
					do {
						.Curl_cfree((ptr.getShowfilename()));
						(ptr.getShowfilename()) = ((Object)0);
					} while (0);
					ptr.setShowfilename_alloc(0);
				} 
			}
		} 
		if (.CURL_FORMADD_OK == return_value/* go through the list, check for completeness and if everything is
		     * alright add the HttpPost item otherwise set return_value accordingly */) {
			post = ((Object)0);
			for (form = first_form; form != ((Object)0); form = form.getMore()) {
				if (((!form.getName() || !form.getValue()) && !post) || ((form.getContentslength()) && (form.getFlags() & (1 << 0))) || ((form.getFlags() & (1 << 0)) && (form.getFlags() & (1 << 3))) || ((!form.getBuffer()) && (form.getFlags() & (1 << 4)) && (form.getFlags() & (1 << 5))) || ((form.getFlags() & (1 << 1)) && (form.getFlags() & (1 << 3)))) {
					return_value = .CURL_FORMADD_INCOMPLETE;
					break;
				} 
				if (((form.getFlags() & (1 << 0)) || (form.getFlags() & (1 << 4))) && !form.getContenttype()) {
					byte f = (form.getFlags() & (1 << 4)) ? form.getShowfilename() : form.getValue();
					byte type;
					type = ModernizedCProgram.Curl_mime_contenttype(f);
					if (!type) {
						type = prevtype;
					} 
					if (!type) {
						type = "application/octet-stream";
					} 
					form.setContenttype(.Curl_cstrdup(/* our contenttype is missing */type));
					if (!form.getContenttype()) {
						return_value = .CURL_FORMADD_MEMORY;
						break;
					} 
					form.setContenttype_alloc(1);
				} 
				if (form.getName() && form.getNamelength()) {
					size_t i = new size_t();
					for (i = 0; i < form.getNamelength(); i++) {
						if (!form.getName()[i]) {
							return_value = .CURL_FORMADD_NULL;
							break;
						} 
					}
					if (return_value != .CURL_FORMADD_OK) {
						break;
					} 
				} 
				if (!(form.getFlags() & (1 << 2)) && (form == first_form/* Note that there's small risk that form->name is NULL here if the
				           app passed in a bad combo, so we better check for that first. */)) {
					if (form.getName()) {
						form.setName(ModernizedCProgram.Curl_memdup(form.getName(), form.getNamelength() ? form.getNamelength() : .strlen(form.getName()) + 1));
					} 
					if (!form.getName()) {
						return_value = .CURL_FORMADD_MEMORY;
						break;
					} 
					form.setName_alloc(1);
				} 
				if (!(form.getFlags() & ((1 << 0) | (1 << 1) | (1 << 3) | (1 << 5) | (1 << 6))) && form.getValue()) {
					size_t clen = (size_t)form.getContentslength();
					if (!clen) {
						clen = .strlen(form.getValue()) + 1;
					} 
					form.setValue(ModernizedCProgram.Curl_memdup(form.getValue(), clen));
					if (!form.getValue()) {
						return_value = .CURL_FORMADD_MEMORY;
						break;
					} 
					form.setValue_alloc(1);
				} 
				post = ModernizedCProgram.AddHttpPost(form.getName(), form.getNamelength(), form.getValue(), form.getContentslength(), form.getBuffer(), form.getBufferlength(), form.getContenttype(), form.getFlags(), form.getContentheader(), form.getShowfilename(), form.getUserp(), post, httppost, last_post);
				if (!post) {
					return_value = .CURL_FORMADD_MEMORY;
					break;
				} 
				if (form.getContenttype()) {
					prevtype = form.getContenttype();
				} 
			}
			if (.CURL_FORMADD_OK != return_value/* On error, free allocated fields for nodes of the FormInfo linked
			         list which are not already owned by the httppost linked list
			         without deallocating nodes. List nodes are deallocated later on */) {
				FormInfo ptr = new FormInfo();
				for (ptr = form; ptr != ((Object)0); ptr = ptr.getMore()) {
					if (ptr.getName_alloc()) {
						do {
							.Curl_cfree((ptr.getName()));
							(ptr.getName()) = ((Object)0);
						} while (0);
						ptr.setName_alloc(0);
					} 
					if (ptr.getValue_alloc()) {
						do {
							.Curl_cfree((ptr.getValue()));
							(ptr.getValue()) = ((Object)0);
						} while (0);
						ptr.setValue_alloc(0);
					} 
					if (ptr.getContenttype_alloc()) {
						do {
							.Curl_cfree((ptr.getContenttype()));
							(ptr.getContenttype()) = ((Object)0);
						} while (0);
						ptr.setContenttype_alloc(0);
					} 
					if (ptr.getShowfilename_alloc()) {
						do {
							.Curl_cfree((ptr.getShowfilename()));
							(ptr.getShowfilename()) = ((Object)0);
						} while (0);
						ptr.setShowfilename_alloc(0);
					} 
				}
			} 
		} 
		while (/* Always deallocate FormInfo linked list nodes without touching node
		     fields given that these have either been deallocated or are owned
		     now by the httppost linked list */first_form) {
			FormInfo ptr = first_form.getMore();
			.Curl_cfree(first_form);
			first_form = ptr;
		}
		return return_value/*
		 * curl_formadd() is a public API to add a section to the multipart formpost.
		 *
		 * @unittest: 1308
		 */;
	}
	public static  curl_formadd(Object httppost, Object last_post) {
		va_list arg = new va_list();
		CURLFORMcode result = new CURLFORMcode();
		.__builtin_va_start(arg, last_post);
		result = ModernizedCProgram.FormAdd(httppost, last_post, arg);
		.__builtin_va_end(arg);
		return result/*
		 * curl_formget()
		 * Serialize a curl_httppost struct.
		 * Returns 0 on success.
		 *
		 * @unittest: 1308
		 */;
	}
	public static int curl_formget(Object form, Object arg, Object append) {
		CURLcode result = new CURLcode();
		curl_mimepart toppart = new curl_mimepart();
		ModernizedCProgram.Curl_mime_initpart(toppart, ((Object)/* default form is empty */0));
		result = ModernizedCProgram.Curl_getformdata(((Object)0), toppart, form, ((Object)0));
		if (!result) {
			result = ModernizedCProgram.Curl_mime_prepare_headers(toppart, "multipart/form-data", ((Object)0), mimestrategy.MIMESTRATEGY_FORM);
		} 
		while (!result) {
			byte[] buffer = new byte[8192];
			size_t nread = ModernizedCProgram.Curl_mime_read(buffer, 1, , toppart);
			if (!nread) {
				break;
			} 
			switch (nread) {
			case -1024:
			case -1024:
					break;
			default:
					if (.append(arg, buffer, nread) != nread) {
						result = .CURLE_READ_ERROR;
					} 
					break;
			}
		}
		ModernizedCProgram.Curl_mime_cleanpart(toppart);
		return (int)result/*
		 * curl_formfree() is an external function to free up a whole form post
		 * chain
		 */;
	}
	public static void curl_formfree(Object form) {
		curl_httppost next = new curl_httppost();
		if (!form/* no form to free, just get out of this */) {
			return ;
		} 
		do {
			next = form.getNext();
			ModernizedCProgram.curl_formfree(form.getMore());
			if (!(form.getFlags() & (1 << 2))) {
				.Curl_cfree(form.getName());
			} 
			if (!(form.getFlags() & ((1 << 3) | (1 << 4) | (1 << 6)))) {
				.Curl_cfree(form.getContents());
			} 
			.Curl_cfree(form.getContenttype());
			.Curl_cfree(form.getShowfilename());
			.Curl_cfree(/* free the struct */form);
			form = next;
		} while (/* continue */form);
	}
	/* Set mime part name, taking care of non nul-terminated name string. */
	public static  setname(Object part, Object name, Object len) {
		byte zname;
		CURLcode res = new CURLcode();
		if (!name || !len) {
			return ModernizedCProgram.curl_mime_name(part, name);
		} 
		zname = .Curl_cmalloc(len + 1);
		if (!zname) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		.memcpy(zname, name, len);
		zname[len] = (byte)'\0';
		res = ModernizedCProgram.curl_mime_name(part, zname);
		.Curl_cfree(zname);
		return res/*
		 * Curl_getformdata() converts a linked list of "meta data" into a mime
		 * structure. The input list is in 'post', while the output is stored in
		 * mime part at '*finalform'.
		 *
		 * This function will not do a failf() for the potential memory failures but
		 * should for all other errors it spots. Just note that this function MAY get
		 * a NULL pointer in the 'data' argument.
		 */;
	}
	public static  Curl_getformdata(Object data, Object finalform, Object post, Object fread_func) {
		CURLcode result = .CURLE_OK;
		curl_mime form = ((Object)0);
		curl_mimepart part = new curl_mimepart();
		curl_httppost file = new curl_httppost();
		ModernizedCProgram.Curl_mime_cleanpart(/* default form is empty */finalform);
		if (!post) {
			return /* no input => no output! */result;
		} 
		form = ModernizedCProgram.curl_mime_init(data);
		if (!form) {
			result = .CURLE_OUT_OF_MEMORY;
		} 
		if (!result) {
			result = ModernizedCProgram.curl_mime_subparts(finalform, form);
		} 
		for (; !result && post; post = post.getNext()) {
			curl_mime multipart = /* If we have more than a file here, create a mime subpart and fill it. */form;
			if (post.getMore()) {
				part = ModernizedCProgram.curl_mime_addpart(form);
				if (!part) {
					result = .CURLE_OUT_OF_MEMORY;
				} 
				if (!result) {
					result = ModernizedCProgram.setname(part, post.getName(), post.getNamelength());
				} 
				if (!result) {
					multipart = ModernizedCProgram.curl_mime_init(data);
					if (!multipart) {
						result = .CURLE_OUT_OF_MEMORY;
					} 
				} 
				if (!result) {
					result = ModernizedCProgram.curl_mime_subparts(part, multipart);
				} 
			} 
			for (file = post; !result && file; file = file.getMore()) {
				part = ModernizedCProgram.curl_mime_addpart(/* Create the part. */multipart);
				if (!part) {
					result = .CURLE_OUT_OF_MEMORY;
				} 
				if (!/* Set the headers. */result) {
					result = ModernizedCProgram.curl_mime_headers(part, file.getContentheader(), 0);
				} 
				if (!result && file.getContenttype()) {
					result = ModernizedCProgram.curl_mime_type(part, file.getContenttype());
				} 
				if (!result && !post.getMore()) {
					result = ModernizedCProgram.setname(part, post.getName(), post.getNamelength());
				} 
				if (!/* Process contents. */result) {
					curl_off_t clen = post.getContentslength();
					if (post.getFlags() & (1 << 7)) {
						clen = post.getContentlen();
					} 
					if (!clen) {
						clen = -1;
					} 
					if (post.getFlags() & ((1 << 0) | (1 << 1))) {
						if (!.strcmp(file.getContents(), "-"/* There are a few cases where the code below won't work; in
						               particular, freopen(stdin) by the caller is not guaranteed
						               to result as expected. This feature has been kept for backward
						               compatibility: use of "-" pseudo file name should be avoided. */)) {
							result = ModernizedCProgram.curl_mime_data_cb(part, (curl_off_t)-1, (curl_read_callback)fread, (curl_seek_callback)(Object)(fseek), ((Object)0), (Object)(_iob[0]));
						} else {
								result = ModernizedCProgram.curl_mime_filedata(part, file.getContents());
						} 
						if (!result && (post.getFlags() & (1 << 1))) {
							result = ModernizedCProgram.curl_mime_filename(part, ((Object)0));
						} 
					}  else if (post.getFlags() & (1 << 4)) {
						result = ModernizedCProgram.curl_mime_data(part, post.getBuffer(), post.getBufferlength() ? post.getBufferlength() : -1);
					}  else if (post.getFlags() & (1 << 6/* the contents should be read with the callback and the size is set
					             with the contentslength */)) {
						result = ModernizedCProgram.curl_mime_data_cb(part, clen, fread_func, ((Object)0), ((Object)0), post.getUserp());
					} else {
							result = ModernizedCProgram.curl_mime_data(part, post.getContents(), (ssize_t)clen/* Convert textual contents now. */);
					} 
				} 
				if (!result && post.getShowfilename()) {
					if (post.getMore() || (post.getFlags() & ((1 << 0) | (1 << 4) | (1 << 6)))) {
						result = ModernizedCProgram.curl_mime_filename(part, post.getShowfilename());
					} 
				} 
			}
		}
		if (result) {
			ModernizedCProgram.Curl_mime_cleanpart(finalform);
		} 
		return result/* if disabled *//* does nothing HTTP is disabled *//* if disabled */;
	}
	public static int Curl_splayremovebyaddr(Object t, Object removenode, Object newroot) {
		curltime KEY_NOTUSED = new curltime((time_t)-1, (int)-1/* will *NEVER* appear */);
		Curl_tree x = new Curl_tree();
		if (!t || !removenode) {
			return 1;
		} 
		if (((((KEY_NOTUSED).getTv_sec()) < ((removenode.getKey()).getTv_sec())) ? -1 : ((((KEY_NOTUSED).getTv_sec()) > ((removenode.getKey()).getTv_sec())) ? 1 : ((((KEY_NOTUSED).getTv_usec()) < ((removenode.getKey()).getTv_usec())) ? -1 : ((((KEY_NOTUSED).getTv_usec()) > ((removenode.getKey()).getTv_usec())) ? 1 : 0)))) == 0/* Key set to NOTUSED means it is a subnode within a 'same' linked list
		       and thus we can unlink it easily. */) {
			if (removenode.getSamen() == removenode) {
				return /* A non-subnode should never be set to KEY_NOTUSED */3;
			} 
			removenode.getSamep().setSamen(removenode.getSamen());
			removenode.getSamen().setSamep(removenode.getSamep());
			removenode.setSamen(/* Ensures that double-remove gets caught. */removenode);
			newroot = /* return the same root */t;
			return 0;
		} 
		t = removenode.getKey().Curl_splay(t/* First make sure that we got the same root node as the one we want
		     to remove, as otherwise we might be trying to remove a node that
		     isn't actually in the tree.
		
		     We cannot just compare the keys here as a double remove in quick
		     succession of a node with key != KEY_NOTUSED && same != NULL
		     could return the same key but a different node. */);
		if (t != removenode) {
			return 2;
		} 
		x = t.getSamen();
		if (x != t/* 'x' is the new root node, we just make it use the root node's
		       smaller/larger links */) {
			x.setKey(t.getKey());
			x.setLarger(t.getLarger());
			x.setSmaller(t.getSmaller());
			x.setSamep(t.getSamep());
			t.getSamep().setSamen(x);
		} else {
				if (t.getSmaller() == ((Object)/* Remove the root node */0)) {
					x = t.getLarger();
				} else {
						x = removenode.getKey().Curl_splay(t.getSmaller());
						x.setLarger(t.getLarger());
				} 
		} 
		newroot = /* store new root pointer */x;
		return 0;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* ------------------------------------------------------------------ */
	/* Return the scope of the given address. */
	public static int Curl_ipv6_scope(Object sa) {
		(Object)sa/* Handle ULAs */;
		return 0/* We are interested only in interface addresses whose
		                   scope matches the remote address we want to
		                   connect to: global for global, link-local for
		                   link-local, etc... *//* Include the scope of this interface as part of the address *//* If given, scope id should match. */;
	}
	/* With SIOCGIFADDR, we cannot tell the difference between an interface
	       that does not exist and an interface that has no address of the
	       correct family. Assume the interface does not exist */
	public static  Curl_if2ip(int af, int remote_scope, int local_scope_id, Object interf, Object buf, int buf_size) {
		(Object)af;
		(Object)remote_scope;
		(Object)local_scope_id;
		(Object)interf;
		(Object)buf;
		(Object)buf_size;
		return .IF2IP_NOT_FOUND;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * NTLM details:
	 *
	 * https://davenport.sourceforge.io/ntlm.html
	 * https://www.innovation.ch/java/ntlm.html
	 */
	/* SSL backend-specific #if branches in this file must be kept in the order
	   documented in curl_ntlm_core. */
	/* The last 3 #include files should be in this order */
	public static  Curl_input_ntlm(Object conn,  proxy, Object header) {
		/* point to the correct struct with this */ntlmdata ntlm = new ntlmdata();
		curlntlm state = new curlntlm();
		CURLcode result = .CURLE_OK;
		ntlm = proxy ? conn.getProxyntlm() : conn.getNtlm();
		state = proxy ? conn.getProxy_ntlm_state() : conn.getHttp_ntlm_state();
		if (ModernizedCProgram.curl_strnequal("NTLM", header, .strlen("NTLM"))) {
			header += .strlen("NTLM");
			while (header && (ModernizedCProgram.Curl_isspace((int)((byte)header)))) {
				header++;
			}
			if (header) {
				result = .Curl_auth_decode_ntlm_type2_message(conn.getData(), header, ntlm);
				if (result) {
					return result;
				} 
				state = /* We got a type-2 message */.NTLMSTATE_TYPE2;
			} else {
					if (state == .NTLMSTATE_LAST) {
						ModernizedCProgram.Curl_infof(conn.getData(), "NTLM auth restarted\n");
						ModernizedCProgram.Curl_http_auth_cleanup_ntlm(conn);
					}  else if (state == .NTLMSTATE_TYPE3) {
						ModernizedCProgram.Curl_infof(conn.getData(), "NTLM handshake rejected\n");
						ModernizedCProgram.Curl_http_auth_cleanup_ntlm(conn);
						state = .NTLMSTATE_NONE;
						return .CURLE_REMOTE_ACCESS_DENIED;
					}  else if (state >= .NTLMSTATE_TYPE1) {
						ModernizedCProgram.Curl_infof(conn.getData(), "NTLM handshake failure (internal error)\n");
						return .CURLE_REMOTE_ACCESS_DENIED;
					} 
					state = /* We should send away a type-1 */.NTLMSTATE_TYPE1;
			} 
		} 
		return result/*
		 * This is for creating ntlm header output
		 */;
	}
	/* if proxy or not */
	/* rest of the www-authenticate:
	                                                header */
	public static  Curl_output_ntlm(Object conn,  proxy) {
		byte base64 = ((Object)0);
		size_t len = 0;
		CURLcode result = new CURLcode();
		/* point to the address of the pointer that holds the string to send to the
		     server, which is for a plain host or for a HTTP proxy */
		byte allocuserpwd;
		/* point to the username, password, service and host */byte userp;
		byte passwdp;
		byte service = ((Object)0);
		byte hostname = ((Object)0);
		/* point to the correct struct with this */ntlmdata ntlm = new ntlmdata();
		curlntlm state = new curlntlm();
		auth authp = new auth();
		do {
		} while (0);
		do {
		} while (0);
		if (proxy) {
			allocuserpwd = conn.getAllocptr().getProxyuserpwd();
			userp = conn.getHttp_proxy().getUser();
			passwdp = conn.getHttp_proxy().getPasswd();
			service = conn.getData().getSet().getStr()[dupstring.STRING_PROXY_SERVICE_NAME] ? conn.getData().getSet().getStr()[dupstring.STRING_PROXY_SERVICE_NAME] : "HTTP";
			hostname = conn.getHttp_proxy().getHost().getName();
			ntlm = conn.getProxyntlm();
			state = conn.getProxy_ntlm_state();
			authp = conn.getData().getState().getAuthproxy();
		} else {
				allocuserpwd = conn.getAllocptr().getUserpwd();
				userp = conn.getUser();
				passwdp = conn.getPasswd();
				service = conn.getData().getSet().getStr()[dupstring.STRING_SERVICE_NAME] ? conn.getData().getSet().getStr()[dupstring.STRING_SERVICE_NAME] : "HTTP";
				hostname = conn.getHost().getName();
				ntlm = conn.getNtlm();
				state = conn.getHttp_ntlm_state();
				authp = conn.getData().getState().getAuthhost();
		} 
		authp.setDone(0);
		if (!/* not set means empty */userp) {
			userp = "";
		} 
		if (!passwdp) {
			passwdp = ""/* not thread safe and leaks - use curl_global_init() to avoid */;
		} 
		switch (state) {
		case .NTLMSTATE_TYPE2:
				result = .Curl_auth_create_ntlm_type3_message(conn.getData(), userp, /* We already received the type-2 message, create a type-3 message */passwdp, ntlm, base64, len);
				if (result) {
					return result;
				} 
				if (base64) {
					.Curl_cfree(allocuserpwd);
					allocuserpwd = ModernizedCProgram.curl_maprintf("%sAuthorization: NTLM %s\r\n", proxy ? "Proxy-" : "", base64);
					.Curl_cfree(base64);
					if (!allocuserpwd) {
						return .CURLE_OUT_OF_MEMORY;
					} 
					do {
					} while (0);
					state = /* we send a type-3 */.NTLMSTATE_TYPE3;
					authp.setDone(1);
				} 
				break;
		case .NTLMSTATE_TYPE3/* connection is already authenticated,
		     * don't send a header in future requests */:
				state = .NTLMSTATE_LAST;
		case /* FALLTHROUGH */.NTLMSTATE_LAST:
				do {
					.Curl_cfree((allocuserpwd));
					(allocuserpwd) = ((Object)0);
				} while (0);
				authp.setDone(1);
				break;
		case .NTLMSTATE_TYPE1:
		default:
				result = .Curl_auth_create_ntlm_type1_message(conn.getData(), userp, /* Create a type-1 message */passwdp, service, hostname, ntlm, base64, len);
				if (result) {
					return result;
				} 
				if (base64) {
					.Curl_cfree(allocuserpwd);
					allocuserpwd = ModernizedCProgram.curl_maprintf("%sAuthorization: NTLM %s\r\n", proxy ? "Proxy-" : "", base64);
					.Curl_cfree(base64);
					if (!allocuserpwd) {
						return .CURLE_OUT_OF_MEMORY;
					} 
					do {
					} while (0);
				} 
				break;
		}
		return .CURLE_OK;
	}
	public static void Curl_http_auth_cleanup_ntlm(Object conn) {
		.Curl_auth_cleanup_ntlm(conn.getNtlm());
		.Curl_auth_cleanup_ntlm(conn.getProxyntlm());
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2012 - 2016, Linus Nielsen Feltzing, <linus@haxx.se>
	 * Copyright (C) 2012 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* the debug versions of these macros make extra certain that the lock is
	   never doubly locked or unlocked */
	public static void conn_llist_dtor(Object user, Object element) {
		connectdata conn = element;
		(Object)user;
		conn.setBundle(((Object)0));
	}
	public static  bundle_create(Object data, Object cb_ptr) {
		(Object)data;
		do {
		} while (0);
		cb_ptr = .Curl_cmalloc();
		if (!cb_ptr) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		(cb_ptr).setNum_connections(0);
		(cb_ptr).setMultiuse(0);
		ModernizedCProgram.Curl_llist_init((cb_ptr).getConn_list(), (curl_llist_dtor)conn_llist_dtor);
		return .CURLE_OK;
	}
	public static void bundle_destroy(Object cb_ptr) {
		if (!cb_ptr) {
			return ;
		} 
		ModernizedCProgram.Curl_llist_destroy(cb_ptr.getConn_list(), ((Object)0));
		.Curl_cfree(cb_ptr);
	}
	/* Add a connection to a bundle */
	public static void bundle_add_conn(Object cb_ptr, Object conn) {
		ModernizedCProgram.Curl_llist_insert_next(cb_ptr.getConn_list(), cb_ptr.getConn_list().getTail(), conn, conn.getBundle_node());
		conn.setBundle(cb_ptr);
		cb_ptr.getNum_connections()++;
	}
	/* Remove a connection from a bundle */
	public static int bundle_remove_conn(Object cb_ptr, Object conn) {
		curl_llist_element curr = new curl_llist_element();
		curr = cb_ptr.getConn_list().getHead();
		while (curr) {
			if (curr.getPtr() == conn) {
				ModernizedCProgram.Curl_llist_remove(cb_ptr.getConn_list(), curr, ((Object)0));
				cb_ptr.getNum_connections()--;
				conn.setBundle(((Object)0));
				return /* we removed a handle */1;
			} 
			curr = curr.getNext();
		}
		return 0;
	}
	public static void free_bundle_hash_entry(Object freethis) {
		connectbundle b = (connectbundle)freethis;
		ModernizedCProgram.bundle_destroy(b);
	}
	public static int Curl_conncache_init(Object connc, int size) {
		int rc;
		connc.setClosure_handle(ModernizedCProgram.curl_easy_init());
		if (!connc.getClosure_handle()) {
			return /* bad */1;
		} 
		rc = ModernizedCProgram.Curl_hash_init(connc.getHash(), size, ModernizedCProgram.Curl_hash_str, ModernizedCProgram.Curl_str_key_compare, free_bundle_hash_entry);
		if (rc) {
			ModernizedCProgram.Curl_close(connc.getClosure_handle());
			connc.setClosure_handle(((Object)0));
		} else {
				connc.getClosure_handle().getState().setConn_cache(connc);
		} 
		return rc;
	}
	public static void Curl_conncache_destroy(Object connc) {
		if (connc) {
			ModernizedCProgram.Curl_hash_destroy(connc.getHash());
		} 
	}
	/* creates a key to find a bundle for this connection */
	public static void hashkey(Object conn, Object buf, Object len, Object hostp) {
		byte hostname;
		long port = conn.getRemote_port();
		if (conn.getBits().getHttpproxy() && !conn.getBits().getTunnel_proxy()) {
			hostname = conn.getHttp_proxy().getHost().getName();
			port = conn.getPort();
		}  else if (conn.getBits().getConn_to_host()) {
			hostname = conn.getConn_to_host().getName();
		} else {
				hostname = conn.getHost().getName();
		} 
		if (hostp) {
			hostp = /* report back which name we used */hostname;
		} 
		ModernizedCProgram.curl_msnprintf(buf, len, "%ld%s", port, /* put the number first so that the hostname gets cut off if too long */hostname);
	}
	/* something like 128 is fine */
	public static void Curl_conncache_unlock(Object data) {
		if ((data).getShare()) {
			ModernizedCProgram.Curl_share_unlock((data), .CURL_LOCK_DATA_CONNECT/* Returns number of connections currently held in the connection cache.
			   Locks/unlocks the cache itself!
			*/);
		} 
	}
	public static Object Curl_conncache_size(Object data) {
		size_t num = new size_t();
		if ((data).getShare()) {
			ModernizedCProgram.Curl_share_lock((data), .CURL_LOCK_DATA_CONNECT, .CURL_LOCK_ACCESS_SINGLE);
		} 
		num = data.getState().getConn_cache().getNum_conn();
		if ((data).getShare()) {
			ModernizedCProgram.Curl_share_unlock((data), .CURL_LOCK_DATA_CONNECT);
		} 
		return num/* Returns number of connections currently held in the connections's bundle
		   Locks/unlocks the cache itself!
		*/;
	}
	public static Object Curl_conncache_bundle_size(Object conn) {
		size_t num = new size_t();
		if ((conn.getData()).getShare()) {
			ModernizedCProgram.Curl_share_lock((conn.getData()), .CURL_LOCK_DATA_CONNECT, .CURL_LOCK_ACCESS_SINGLE);
		} 
		num = conn.getBundle().getNum_connections();
		if ((conn.getData()).getShare()) {
			ModernizedCProgram.Curl_share_unlock((conn.getData()), .CURL_LOCK_DATA_CONNECT);
		} 
		return num/* Look up the bundle with all the connections to the same host this
		   connectdata struct is setup to use.
		
		   **NOTE**: When it returns, it holds the connection cache lock! */;
	}
	public static Object Curl_conncache_find_bundle(Object conn, Object connc, Object hostp) {
		connectbundle bundle = ((Object)0);
		if ((conn.getData()).getShare()) {
			ModernizedCProgram.Curl_share_lock((conn.getData()), .CURL_LOCK_DATA_CONNECT, .CURL_LOCK_ACCESS_SINGLE);
		} 
		if (connc) {
			byte[] key = new byte[128];
			ModernizedCProgram.hashkey(conn, key, , hostp);
			bundle = ModernizedCProgram.Curl_hash_pick(connc.getHash(), key, .strlen(key));
		} 
		return bundle;
	}
	public static  conncache_add_bundle(Object connc, Object key, Object bundle) {
		Object p = ModernizedCProgram.Curl_hash_add(connc.getHash(), key, .strlen(key), bundle);
		return p ? 1 : 0;
	}
	public static void conncache_remove_bundle(Object connc, Object bundle) {
		curl_hash_iterator iter = new curl_hash_iterator();
		curl_hash_element he = new curl_hash_element();
		if (!connc) {
			return ;
		} 
		ModernizedCProgram.Curl_hash_start_iterate(connc.getHash(), iter);
		he = ModernizedCProgram.Curl_hash_next_element(iter);
		while (he) {
			if (he.getPtr() == bundle/* The bundle is destroyed by the hash destructor function,
			         free_bundle_hash_entry() */) {
				ModernizedCProgram.Curl_hash_delete(connc.getHash(), he.getKey(), he.getKey_len());
				return ;
			} 
			he = ModernizedCProgram.Curl_hash_next_element(iter);
		}
	}
	public static  Curl_conncache_add_conn(Object connc, Object conn) {
		CURLcode result = .CURLE_OK;
		connectbundle bundle = new connectbundle();
		connectbundle new_bundle = ((Object)0);
		Curl_easy data = conn.getData();
		bundle = ModernizedCProgram.Curl_conncache_find_bundle(conn, data.getState().getConn_cache(), ((Object)/* *find_bundle() locks the connection cache */0));
		if (!bundle) {
			int rc;
			byte[] key = new byte[128];
			result = ModernizedCProgram.bundle_create(data, new_bundle);
			if (result) {
				;
			} 
			ModernizedCProgram.hashkey(conn, key, , ((Object)0));
			rc = ModernizedCProgram.conncache_add_bundle(data.getState().getConn_cache(), key, new_bundle);
			if (!rc) {
				ModernizedCProgram.bundle_destroy(new_bundle);
				result = .CURLE_OUT_OF_MEMORY;
				;
			} 
			bundle = new_bundle;
		} 
		ModernizedCProgram.bundle_add_conn(bundle, conn);
		conn.setConnection_id(connc.getNext_connection_id()++);
		connc.getNum_conn()++;
		do {
		} while (0);
		return result/*
		 * Removes the connectdata object from the connection cache *and* clears the
		 * ->data pointer association. Pass TRUE/FALSE in the 'lock' argument
		 * depending on if the parent function already holds the lock or not.
		 */;
	}
	public static void Curl_conncache_remove_conn(Object data, Object conn,  lock) {
		connectbundle bundle = conn.getBundle();
		conncache connc = data.getState().getConn_cache();
		if (/* The bundle pointer can be NULL, since this function can be called
		     due to a failed connection attempt, before being added to a bundle */bundle) {
			if (lock) {
				if ((data).getShare()) {
					ModernizedCProgram.Curl_share_lock((data), .CURL_LOCK_DATA_CONNECT, .CURL_LOCK_ACCESS_SINGLE);
				} 
			} 
			ModernizedCProgram.bundle_remove_conn(bundle, conn);
			if (bundle.getNum_connections() == 0) {
				ModernizedCProgram.conncache_remove_bundle(connc, bundle);
			} 
			conn.setBundle(((Object)/* removed from it */0));
			if (connc) {
				connc.getNum_conn()--;
				do {
				} while (0);
			} 
			conn.setData(((Object)/* clear the association */0));
			if (lock) {
				if ((data).getShare()) {
					ModernizedCProgram.Curl_share_unlock((data), .CURL_LOCK_DATA_CONNECT/* This function iterates the entire connection cache and calls the function
					   func() with the connection pointer as the first argument and the supplied
					   'param' argument as the other.
					
					   The conncache lock is still held when the callback is called. It needs it,
					   so that it can safely continue traversing the lists once the callback
					   returns.
					
					   Returns 1 if the loop was aborted due to the callback's return code.
					
					   Return 0 from func() to continue the loop, return 1 to abort it.
					 */);
				} 
			} 
		} 
	}
	public static  Curl_conncache_foreach(Object data, Object connc, Object param, Object func) {
		curl_hash_iterator iter = new curl_hash_iterator();
		curl_llist_element curr = new curl_llist_element();
		curl_hash_element he = new curl_hash_element();
		if (!connc) {
			return 0;
		} 
		if ((data).getShare()) {
			ModernizedCProgram.Curl_share_lock((data), .CURL_LOCK_DATA_CONNECT, .CURL_LOCK_ACCESS_SINGLE);
		} 
		ModernizedCProgram.Curl_hash_start_iterate(connc.getHash(), iter);
		he = ModernizedCProgram.Curl_hash_next_element(iter);
		while (he) {
			connectbundle bundle = new connectbundle();
			bundle = he.getPtr();
			he = ModernizedCProgram.Curl_hash_next_element(iter);
			curr = bundle.getConn_list().getHead();
			while (curr/* Yes, we need to update curr before calling func(), because func()
			         might decide to remove the connection */) {
				connectdata conn = curr.getPtr();
				curr = curr.getNext();
				if (1 == .func(conn, param)) {
					if ((data).getShare()) {
						ModernizedCProgram.Curl_share_unlock((data), .CURL_LOCK_DATA_CONNECT);
					} 
					return 1;
				} 
			}
		}
		if ((data).getShare()) {
			ModernizedCProgram.Curl_share_unlock((data), .CURL_LOCK_DATA_CONNECT);
		} 
		return 0/* Return the first connection found in the cache. Used when closing all
		   connections.
		
		   NOTE: no locking is done here as this is presumably only done when cleaning
		   up a cache!
		*/;
	}
	public static Object conncache_find_first_connection(Object connc) {
		curl_hash_iterator iter = new curl_hash_iterator();
		curl_hash_element he = new curl_hash_element();
		connectbundle bundle = new connectbundle();
		ModernizedCProgram.Curl_hash_start_iterate(connc.getHash(), iter);
		he = ModernizedCProgram.Curl_hash_next_element(iter);
		while (he) {
			curl_llist_element curr = new curl_llist_element();
			bundle = he.getPtr();
			curr = bundle.getConn_list().getHead();
			if (curr) {
				return curr.getPtr();
			} 
			he = ModernizedCProgram.Curl_hash_next_element(iter);
		}
		return ((Object)0/*
		 * Give ownership of a connection back to the connection cache. Might
		 * disconnect the oldest existing in there to make space.
		 *
		 * Return TRUE if stored, FALSE if closed.
		 */);
	}
	public static  Curl_conncache_return_conn(Object conn) {
		Curl_easy data = conn.getData();
		/* data->multi->maxconnects can be negative, deal with it. */size_t maxconnects = (data.getMulti().getMaxconnects() < 0) ? data.getMulti().getNum_easy() * 4 : data.getMulti().getMaxconnects();
		connectdata conn_candidate = ((Object)0);
		conn.setData(((Object)/* no owner anymore */0));
		curltime curltime = new curltime();
		conn.setLastused(curltime.Curl_now());
		if (maxconnects > 0 && ModernizedCProgram.Curl_conncache_size(data) > maxconnects) {
			ModernizedCProgram.Curl_infof(data, "Connection cache is full, closing the oldest one.\n");
			conn_candidate = ModernizedCProgram.Curl_conncache_extract_oldest(data);
			if (conn_candidate) {
				(Object)ModernizedCProgram.Curl_disconnect(data, conn_candidate, /* the winner gets the honour of being disconnected *//* dead_connection */0);
			} 
		} 
		return (conn_candidate == conn) ? 0 : 1/*
		 * This function finds the connection in the connection bundle that has been
		 * unused for the longest time.
		 *
		 * Does not lock the connection cache!
		 *
		 * Returns the pointer to the oldest idle connection, or NULL if none was
		 * found.
		 */;
	}
	public static Object Curl_conncache_extract_bundle(Object data, Object bundle) {
		curl_llist_element curr = new curl_llist_element();
		timediff_t highscore = -1;
		timediff_t score = new timediff_t();
		curltime now = new curltime();
		connectdata conn_candidate = ((Object)0);
		connectdata conn = new connectdata();
		(Object)data;
		curltime curltime = new curltime();
		now = curltime.Curl_now();
		curr = bundle.getConn_list().getHead();
		while (curr) {
			conn = curr.getPtr();
			if (!((conn).getEasyq().getSize()) && !conn.getData()) {
				score = now.Curl_timediff(conn.getLastused());
				if (score > highscore) {
					highscore = score;
					conn_candidate = conn;
				} 
			} 
			curr = curr.getNext();
		}
		if (conn_candidate) {
			ModernizedCProgram.bundle_remove_conn(bundle, /* remove it to prevent another thread from nicking it */conn_candidate);
			data.getState().getConn_cache().getNum_conn()--;
			do {
			} while (0);
			conn_candidate.setData(/* associate! */data);
		} 
		return conn_candidate/*
		 * This function finds the connection in the connection cache that has been
		 * unused for the longest time and extracts that from the bundle.
		 *
		 * Returns the pointer to the connection, or NULL if none was found.
		 */;
	}
	public static Object Curl_conncache_extract_oldest(Object data) {
		conncache connc = data.getState().getConn_cache();
		curl_hash_iterator iter = new curl_hash_iterator();
		curl_llist_element curr = new curl_llist_element();
		curl_hash_element he = new curl_hash_element();
		timediff_t highscore = -1;
		timediff_t score = new timediff_t();
		curltime now = new curltime();
		connectdata conn_candidate = ((Object)0);
		connectbundle bundle = new connectbundle();
		connectbundle bundle_candidate = ((Object)0);
		curltime curltime = new curltime();
		now = curltime.Curl_now();
		if ((data).getShare()) {
			ModernizedCProgram.Curl_share_lock((data), .CURL_LOCK_DATA_CONNECT, .CURL_LOCK_ACCESS_SINGLE);
		} 
		ModernizedCProgram.Curl_hash_start_iterate(connc.getHash(), iter);
		he = ModernizedCProgram.Curl_hash_next_element(iter);
		while (he) {
			connectdata conn = new connectdata();
			bundle = he.getPtr();
			curr = bundle.getConn_list().getHead();
			while (curr) {
				conn = curr.getPtr();
				if (!((conn).getEasyq().getSize()) && !conn.getData()) {
					score = now.Curl_timediff(conn.getLastused());
					if (score > highscore) {
						highscore = score;
						conn_candidate = conn;
						bundle_candidate = bundle;
					} 
				} 
				curr = curr.getNext();
			}
			he = ModernizedCProgram.Curl_hash_next_element(iter);
		}
		if (conn_candidate) {
			ModernizedCProgram.bundle_remove_conn(bundle_candidate, /* remove it to prevent another thread from nicking it */conn_candidate);
			connc.getNum_conn()--;
			do {
			} while (0);
			conn_candidate.setData(/* associate! */data);
		} 
		if ((data).getShare()) {
			ModernizedCProgram.Curl_share_unlock((data), .CURL_LOCK_DATA_CONNECT);
		} 
		return conn_candidate;
	}
	public static void Curl_conncache_close_all_connections(Object connc) {
		connectdata conn = new connectdata();
		conn = ModernizedCProgram.conncache_find_first_connection(connc);
		while (conn) {
			;
			conn.setData(connc.getClosure_handle());
			do {
			} while (0);
			ModernizedCProgram.Curl_conncontrol(conn, /* This will remove the connection from the cache */1);
			(Object)ModernizedCProgram.Curl_disconnect(connc.getClosure_handle(), conn, 0);
			do {
			} while (0);
			conn = ModernizedCProgram.conncache_find_first_connection(connc);
		}
		if (connc.getClosure_handle()) {
			;
			do {
			} while (0);
			ModernizedCProgram.Curl_hostcache_clean(connc.getClosure_handle(), connc.getClosure_handle().getDns().getHostcache());
			ModernizedCProgram.Curl_close(connc.getClosure_handle());
			do {
			} while (0/* Useful for debugging the connection cache */);
		} 
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/*
	 * get_line() makes sure to only return complete whole lines that fit in 'len'
	 * bytes and end with a newline.
	 */
	public static Object Curl_get_line(Object buf, int len, Object input) {
		bool partial = 0;
		while (1) {
			byte b = .fgets(buf, len, input);
			if (b) {
				size_t rlen = .strlen(b);
				if (rlen && (b[rlen - 1] == (byte)'\n')) {
					if (partial) {
						partial = 0;
						continue;
					} 
					return b;
				} 
				partial = /* read a partial, discard the next piece that ends with newline */1;
			} else {
					break;
			} 
		}
		return ((Object)0);
	}
	public static void fly(Object bar,  moved) {
		byte[] buf = new byte[256];
		int pos;
		int check = bar.getWidth() - 2;
		ModernizedCProgram.curl_msnprintf(buf, , "%*s\r", bar.getWidth() - 1, " ");
		.memcpy(buf[bar.getBar()], "-=O=-", 5);
		pos = ModernizedCProgram.sinus[bar.getTick() % 200] / (10000 / check);
		buf[pos] = (byte)'#';
		pos = ModernizedCProgram.sinus[(bar.getTick() + 5) % 200] / (10000 / check);
		buf[pos] = (byte)'#';
		pos = ModernizedCProgram.sinus[(bar.getTick() + 10) % 200] / (10000 / check);
		buf[pos] = (byte)'#';
		pos = ModernizedCProgram.sinus[(bar.getTick() + 15) % 200] / (10000 / check);
		buf[pos] = (byte)'#';
		.fputs(buf, bar.getOut());
		bar.getTick() += 2;
		if (bar.getTick() >= 200) {
			bar.getTick() -= 200;
		} 
		bar.getBar() += (moved ? bar.getBarmove() : 0);
		if (bar.getBar() >= (bar.getWidth() - 6)) {
			bar.setBarmove(-1);
			bar.setBar(bar.getWidth() - 6);
		}  else if (bar.getBar() < 0) {
			bar.setBarmove(1);
			bar.setBar(0/*
			** callback for CURLOPT_XFERINFOFUNCTION
			*/);
		} 
	}
	/* assume CURL_SIZEOF_CURL_OFF_T == 8 */
	public static int tool_progress_cb(Object clientp, Object dltotal, Object dlnow, Object ultotal, Object ulnow) {
		timeval timeval = new timeval();
		timeval now = timeval.tvnow();
		ProgressData bar = (ProgressData)clientp;
		curl_off_t total = new curl_off_t();
		curl_off_t point = new curl_off_t();
		/* Calculate expected transfer size. initial_size can be less than zero
		     when indicating that we are expecting to get the filesize from the
		     remote */
		if (bar.getInitial_size() < 0 || ((-1024 - bar.getInitial_size()) < (dltotal + ultotal))) {
			total = -1024;
		} else {
				total = dltotal + ultotal + bar.getInitial_size();
		} 
		if (bar.getInitial_size() < /* Calculate the current progress. initial_size can be less than zero when
		     indicating that we are expecting to get the filesize from the remote */0 || ((-1024 - bar.getInitial_size()) < (dlnow + ulnow))) {
			point = -1024;
		} else {
				point = dlnow + ulnow + bar.getInitial_size();
		} 
		if (bar.getCalls()) {
			if (/* after first call... */total) {
				if (bar.getPrev() == /* we know the total data to get... */point) {
					return /* progress didn't change since last invoke */0;
				}  else if ((now.tvdiff(bar.getPrevtime()) < -1024) && point < total) {
					return /* limit progress-bar updating to 10 Hz except when we're at 100% */0;
				} 
			} else {
					if (now.tvdiff(bar.getPrevtime()) < /* total is unknown */-1024) {
						return /* limit progress-bar updating to 10 Hz */0;
					} 
					ModernizedCProgram.fly(bar, point != bar.getPrev());
			} 
		} 
		bar.getCalls()++;
		if ((total > 0) && (point != bar.getPrev())) {
			byte[] line = new byte[256 + 1];
			byte[] format = new byte[40];
			double frac;
			double percent;
			int barwidth;
			int num;
			if (point > total) {
				total = /* we have got more than the expected total! */point;
			} 
			frac = (double)point / (double)total;
			percent = frac * 100.0;
			barwidth = bar.getWidth() - 7;
			num = (int)(((double)barwidth) * frac);
			if (num > 256) {
				num = 256;
			} 
			.memset(line, (byte)'#', num);
			line[num] = (byte)'\0';
			ModernizedCProgram.curl_msnprintf(format, , "\r%%-%ds %%5.1f%%%%", barwidth);
			ModernizedCProgram.curl_mfprintf(bar.getOut(), format, line, percent);
		} 
		.fflush(bar.getOut());
		bar.setPrev(point);
		bar.setPrevtime(now);
		return 0;
	}
	public static void progressbarinit(Object bar, Object config) {
		byte colp;
		.memset(bar, 0, /* pass this through to progress function so
		   * it can display progress towards total file
		   * not just the part that's left. (21-may-03, dbyron) */);
		if (config.getUse_resume()) {
			bar.setInitial_size(config.getResume_from());
		} 
		colp = ModernizedCProgram.curl_getenv("COLUMNS");
		if (colp) {
			byte endptr;
			long num = .strtol(colp, endptr, 10);
			if ((endptr != colp) && (endptr == colp + .strlen(colp)) && (num > 20) && (num < 10000)) {
				bar.setWidth((int)num);
			} 
			ModernizedCProgram.curl_free(colp);
		} 
		Object generatedSrWindow = console_info.getSrWindow();
		if (!bar.getWidth()) {
			int cols = 0;
			{ 
				HANDLE stderr_hnd = .GetStdHandle((DWORD)(true));
				CONSOLE_SCREEN_BUFFER_INFO console_info = new CONSOLE_SCREEN_BUFFER_INFO();
				if ((stderr_hnd != (HANDLE)(true)) && .GetConsoleScreenBufferInfo(stderr_hnd, console_info/*
				         * Do not use +1 to get the true screen-width since writing a
				         * character at the right edge will cause a line wrap.
				         */)) {
					cols = (int)(generatedSrWindow.getRight() - generatedSrWindow.getLeft());
				} 
			}
			bar.setWidth(/* TIOCGSIZE */cols);
		} 
		if (!bar.getWidth()) {
			bar.setWidth(79);
		}  else if (bar.getWidth() > 256) {
			bar.setWidth(256);
		} 
		bar.setOut(config.getGlobal().getErrors());
		bar.setTick(150);
		bar.setBarmove(1);
	}
	public static void MD4_Init(Object ctx) {
		ctx.setHCryptProv(0);
		ctx.setHHash(0);
		if (.CryptAcquireContextA(ctx.getHCryptProv(), ((Object)0), ((Object)0), 1, -1024)) {
			.CryptCreateHash(ctx.getHCryptProv(), (32768 | 0 | 2), 0, 0, ctx.getHHash());
		} 
	}
	public static void MD4_Update(Object ctx, Object data, long size) {
		.CryptHashData(ctx.getHHash(), data, (int)size, 0);
	}
	public static void MD4_Final(Object result, Object ctx) {
		long length = 0;
		.CryptGetHashParam(ctx.getHHash(), 2, ((Object)0), length, 0);
		if (length == 16) {
			.CryptGetHashParam(ctx.getHHash(), 2, result, length, 0);
		} 
		if (ctx.getHHash()) {
			.CryptDestroyHash(ctx.getHHash());
		} 
		if (ctx.getHCryptProv()) {
			.CryptReleaseContext(ctx.getHCryptProv(), 0/* The last #include file should be: *//* When no other crypto library is available, or the crypto library doesn't
			 * support MD4, we use this code segment this implementation of it
			 *
			 * This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.
			 * MD4 Message-Digest Algorithm (RFC 1320).
			 *
			 * Homepage:
			 https://openwall.info/wiki/people/solar/software/public-domain-source-code/md4
			 *
			 * Author:
			 * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>
			 *
			 * This software was written by Alexander Peslyak in 2001.  No copyright is
			 * claimed, and the software is hereby placed in the public domain.  In case
			 * this attempt to disclaim copyright and place the software in the public
			 * domain is deemed null and void, then the software is Copyright (c) 2001
			 * Alexander Peslyak and it is hereby released to the general public under the
			 * following terms:
			 *
			 * Redistribution and use in source and binary forms, with or without
			 * modification, are permitted.
			 *
			 * There's ABSOLUTELY NO WARRANTY, express or implied.
			 *
			 * (This is a heavily cut-down "BSD license".)
			 *
			 * This differs from Colin Plumb's older public domain implementation in that
			 * no exactly 32-bit integer data type is required (any 32-bit or wider
			 * unsigned integer data type will do), there's no compile-time endianness
			 * configuration, and the function prototypes match OpenSSL's.  No code from
			 * Colin Plumb's implementation has been reused; this comment merely compares
			 * the properties of the two independent implementations.
			 *
			 * The primary goals of this implementation are portability and ease of use.
			 * It is meant to be fast, but not as fast as possible.  Some known
			 * optimizations are not included to reduce source code size and avoid
			 * compile-time configuration.
			 *//* Any 32-bit or wider unsigned integer data type will do *//*
			 * The basic MD4 functions.
			 *
			 * F and G are optimized compared to their RFC 1320 definitions, with the
			 * optimization for F borrowed from Colin Plumb's MD5 implementation.
			 *//*
			 * The MD4 transformation for all three rounds.
			 *//*
			 * SET reads 4 input bytes in little-endian byte order and stores them
			 * in a properly aligned word in host byte order.
			 *
			 * The check for little-endian architectures that tolerate unaligned
			 * memory accesses is just an optimization.  Nothing will break if it
			 * doesn't work.
			 *//*
			 * This processes one or more 64-byte data blocks, but does NOT update
			 * the bit counters.  There are no alignment requirements.
			 *//* Round 1 */);
		} 
	}
	/* Round 2 */
	/* Round 3 */
	/* CRYPTO LIBS */
	public static void Curl_md4it(Object output, Object input, Object len) {
		MD4_CTX ctx = new MD4_CTX();
		ModernizedCProgram.MD4_Init(ctx);
		ModernizedCProgram.MD4_Update(ctx, input, ModernizedCProgram.curlx_uztoui(len));
		ModernizedCProgram.MD4_Final(output, ctx/* CURL_DISABLE_CRYPTO_AUTH */);
	}
	public static void Curl_init_completed(Object data) {
		ModernizedCProgram.detach_connnection(/* Important: reset the conn pointer so that we don't point to memory
		     that could be freed anytime */data);
		ModernizedCProgram.Curl_expire_clear(/* stop all timers */data);
	}
	/* this is a completed transfer */
	/* always use this function to change state, to make debugging easier */
	public static void mstate(Object data,  state) {
		CURLMstate oldstate = data.getMstate();
		init_multistate_func[] finit = new init_multistate_func[]{((Object)/* INIT */0), ((Object)/* CONNECT_PEND */0), /* CONNECT */ModernizedCProgram.Curl_init_CONNECT, ((Object)/* WAITRESOLVE */0), ((Object)/* WAITCONNECT */0), ((Object)/* WAITPROXYCONNECT */0), ((Object)/* SENDPROTOCONNECT */0), ((Object)/* PROTOCONNECT */0), /* DO */ModernizedCProgram.Curl_connect_free, ((Object)/* DOING */0), ((Object)/* DO_MORE */0), ((Object)/* DO_DONE */0), ((Object)/* PERFORM */0), ((Object)/* TOOFAST */0), ((Object)/* DONE */0), /* COMPLETED */Curl_init_completed, ((Object)/* MSGSENT */0)};
		if (oldstate == state/* don't bother when the new state is the same as the old state */) {
			return ;
		} 
		data.setMstate(state);
		if (state == .CURLM_STATE_COMPLETED) {
			data.getMulti().getNum_alive()--;
		} 
		if (finit[/* if this state has an init-function, run it */state]) {
			.UNRECOGNIZEDFUNCTIONNAME(data);
		} 
	}
	public static Object sh_getentry(Object sh, Object s) {
		if (s != (SOCKET)(~0)) {
			return ModernizedCProgram.Curl_hash_pick(sh, (byte)s, /* only look for proper sockets */);
		} 
		return ((Object)0);
	}
	public static Object trhash(Object key, Object key_length, Object slots_num) {
		size_t keyval = (size_t)(Curl_easy)key;
		(Object)key_length;
		return (keyval % slots_num);
	}
	public static Object trhash_compare(Object k1, Object k1_len, Object k2, Object k2_len) {
		(Object)k1_len;
		(Object)k2_len;
		return (Curl_easy)k1 == (Curl_easy)k2;
	}
	public static void trhash_dtor(Object nada) {
		(Object)nada;
	}
	public static Object sh_addentry(Object sh, Object s) {
		Curl_sh_entry there = ModernizedCProgram.sh_getentry(sh, s);
		Curl_sh_entry check = new Curl_sh_entry();
		if (there) {
			return /* it is present, return fine */there;
		} 
		check = .Curl_ccalloc(1, /* not present, add it */);
		if (!check) {
			return ((Object)/* major failure */0);
		} 
		if (ModernizedCProgram.Curl_hash_init(check.getTransfers(), 13, trhash, trhash_compare, trhash_dtor)) {
			.Curl_cfree(check);
			return ((Object)0);
		} 
		if (!ModernizedCProgram.Curl_hash_add(sh, (byte)s, , /* make/add new hash entry */check)) {
			.Curl_cfree(check);
			return ((Object)/* major failure */0);
		} 
		return /* things are good in sockhash land */check;
	}
	/* delete the given socket + handle from the hash */
	public static void sh_delentry(Object entry, Object sh, Object s) {
		ModernizedCProgram.Curl_hash_destroy(entry.getTransfers());
		ModernizedCProgram.Curl_hash_delete(sh, (byte)s, /* We remove the hash entry. This will end up in a call to
		     sh_freeentry(). *//*
		 * free a sockhash entry
		 */);
	}
	public static void sh_freeentry(Object freethis) {
		Curl_sh_entry p = (Curl_sh_entry)freethis;
		.Curl_cfree(p);
	}
	public static Object fd_key_compare(Object k1, Object k1_len, Object k2, Object k2_len) {
		(Object)k1_len;
		(Object)k2_len;
		return (((curl_socket_t)k1)) == (((curl_socket_t)k2));
	}
	public static Object hash_fd(Object key, Object key_length, Object slots_num) {
		curl_socket_t fd = ((curl_socket_t)key);
		(Object)key_length;
		return (fd % slots_num/*
		 * sh_init() creates a new socket hash and returns the handle for it.
		 *
		 * Quote from README.multi_socket:
		 *
		 * "Some tests at 7000 and 9000 connections showed that the socket hash lookup
		 * is somewhat of a bottle neck. Its current implementation may be a bit too
		 * limiting. It simply has a fixed-size array, and on each entry in the array
		 * it has a linked list with entries. So the hash only checks which list to
		 * scan through. The code I had used so for used a list with merely 7 slots
		 * (as that is what the DNS hash uses) but with 7000 connections that would
		 * make an average of 1000 nodes in each list to run through. I upped that to
		 * 97 slots (I believe a prime is suitable) and noticed a significant speed
		 * increase.  I need to reconsider the hash implementation or use a rather
		 * large default value like this. At 9000 connections I was still below 10us
		 * per call."
		 *
		 */);
	}
	public static int sh_init(Object hash, int hashsize) {
		return ModernizedCProgram.Curl_hash_init(hash, hashsize, hash_fd, fd_key_compare, sh_freeentry/*
		 * multi_addmsg()
		 *
		 * Called when a transfer is completed. Adds the given msg pointer to
		 * the list kept in the multi handle.
		 */);
	}
	public static  multi_addmsg(Object multi, Object msg) {
		ModernizedCProgram.Curl_llist_insert_next(multi.getMsglist(), multi.getMsglist().getTail(), msg, msg.getList());
		return .CURLM_OK;
	}
	public static Object Curl_multi_handle(int hashsize, int chashsize) {
		Curl_multi multi = .Curl_ccalloc(1, );
		if (!multi) {
			return ((Object)0);
		} 
		multi.setType(-1024);
		if (ModernizedCProgram.Curl_mk_dnscache(multi.getHostcache())) {
			;
		} 
		if (ModernizedCProgram.sh_init(multi.getSockhash(), hashsize)) {
			;
		} 
		if (ModernizedCProgram.Curl_conncache_init(multi.getConn_cache(), chashsize)) {
			;
		} 
		ModernizedCProgram.Curl_llist_init(multi.getMsglist(), ((Object)0));
		ModernizedCProgram.Curl_llist_init(multi.getPending(), ((Object)0));
		multi.setMultiplexing(1);
		multi.setMaxconnects(-/* -1 means it not set by user, use the default value */1);
		return multi;
		ModernizedCProgram.Curl_hash_destroy(multi.getHostcache());
		ModernizedCProgram.Curl_conncache_destroy(multi.getConn_cache());
		ModernizedCProgram.Curl_llist_destroy(multi.getMsglist(), ((Object)0));
		ModernizedCProgram.Curl_llist_destroy(multi.getPending(), ((Object)0));
		.Curl_cfree(multi);
		return ((Object)0);
	}
	public static Object curl_multi_init() {
		return ModernizedCProgram.Curl_multi_handle(911, 97);
	}
	public static  curl_multi_add_handle(Object multi, Object data) {
		if (!((multi) && (multi).getType() == /* First, make some basic checks that the CURLM handle is a good handle */-1024)) {
			return .CURLM_BAD_HANDLE;
		} 
		if (!((data) && ((data).getMagic() == /* Verify that we got a somewhat good easy handle too */-1024))) {
			return .CURLM_BAD_EASY_HANDLE;
		} 
		if (data.getMulti()) {
			return .CURLM_ADDED_ALREADY;
		} 
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		ModernizedCProgram.Curl_llist_init(data.getState().getTimeoutlist(), ((Object)/* Initialize timeout list for this handle */0/*
		   * No failure allowed in this function beyond this point. And no
		   * modification of easy nor multi handle allowed before this except for
		   * potential multi's connection cache growing which won't be undone in this
		   * function no matter what.
		   */));
		if (data.getSet().getErrorbuffer()) {
			data.getSet().getErrorbuffer()[0] = 0;
		} 
		ModernizedCProgram.mstate(data, /* set the easy handle */.CURLM_STATE_INIT);
		if (!data.getDns().getHostcache() || (data.getDns().getHostcachetype() == .HCACHE_NONE)) {
			data.getDns().setHostcache(multi.getHostcache());
			data.getDns().setHostcachetype(.HCACHE_MULTI);
		} 
		if (data.getShare() && (data.getShare().getCurl_share() & (1 << /* Point to the shared or multi handle connection cache */.CURL_LOCK_DATA_CONNECT))) {
			data.getState().setConn_cache(data.getShare().getCurl_share());
		} else {
				data.getState().setConn_cache(multi.getConn_cache());
		} 
		data.setNext(((Object)/* We add the new entry last in the list. *//* end of the line */0));
		if (multi.getEasyp()) {
			Curl_easy last = multi.getEasylp();
			last.setNext(data);
			data.setPrev(last);
			multi.setEasylp(/* the new last node */data);
		} else {
				data.setPrev(((Object)/* first node, make prev NULL! */0));
				multi.setEasylp(multi.setEasyp(/* both first and last */data));
		} 
		data.setMulti(/* make the Curl_easy refer back to this multi handle */multi/* Set the timeout for this handle to expire really soon so that it will
		     be taken care of even when this handle is added in the midst of operation
		     when only the curl_multi_socket() API is used. During that flow, only
		     sockets that time-out or have actions will be dealt with. Since this
		     handle has no action yet, we make sure it times out to get things to
		     happen. */);
		ModernizedCProgram.Curl_expire(data, 0, .EXPIRE_RUN_NOW);
		multi.getNum_easy()++;
		multi.getNum_alive()++;
		.memset(multi.getTimer_lastcall(), 0, );
		data.getState().getConn_cache().getClosure_handle().getSet().setTimeout(data.getSet().getTimeout());
		data.getState().getConn_cache().getClosure_handle().getSet().setServer_response_timeout(data.getSet().getServer_response_timeout());
		data.getState().getConn_cache().getClosure_handle().getSet().setNo_signal(data.getSet().getNo_signal());
		ModernizedCProgram.Curl_update_timer(multi);
		return .CURLM_OK/* Debug-function, used like this:
		 *
		 * Curl_hash_print(multi->sockhash, debug_print_sock_hash);
		 *
		 * Enable the hash print function first by editing hash.c
		 */;
	}
	public static  multi_done(Object data,  status,  premature) {
		CURLcode result = new CURLcode();
		connectdata conn = data.getConn();
		int i;
		do {
		} while (0);
		if (data.getState().getDone()) {
			return /* Stop if multi_done() has already been called */.CURLE_OK;
		} 
		ModernizedCProgram.Curl_resolver_kill(/* Stop the resolver and free its own resources (but not dns_entry yet). */conn);
		do {
			.Curl_cfree((data.getReq().getNewurl()));
			(data.getReq().getNewurl()) = ((Object)0);
		} while (/* Cleanup possible redirect junk */0);
		do {
			.Curl_cfree((data.getReq().getLocation()));
			(data.getReq().getLocation()) = ((Object)0);
		} while (0);
		switch (status) {
		case .CURLE_WRITE_ERROR/* When we're aborted due to a callback return code it basically have to
		       be counted as premature as there is trouble ahead if we don't. We have
		       many callbacks and protocols work differently, we could potentially do
		       this more fine-grained in the future. */:
				premature = 1;
		case .CURLE_READ_ERROR:
		case .CURLE_ABORTED_BY_CALLBACK:
		default:
				break;
		}
		if (conn.getHandler().getDone()) {
			result = .UNRECOGNIZEDFUNCTIONNAME(conn, status, premature);
		} else {
				result = status;
		} 
		if (.CURLE_ABORTED_BY_CALLBACK != result/* avoid this if we already aborted by callback to avoid this calling
		       another callback */) {
			CURLcode rc = ModernizedCProgram.Curl_pgrsDone(conn);
			if (!result && rc) {
				result = .CURLE_ABORTED_BY_CALLBACK;
			} 
		} 
		ModernizedCProgram.process_pending_handles(data.getMulti());
		ModernizedCProgram.detach_connnection(data);
		if (((conn).getEasyq().getSize())) {
			do {
			} while (/* Stop if still used. */0);
			return .CURLE_OK;
		} 
		data.getState().setDone(/* called just now! */1);
		if (conn.getDns_entry()) {
			ModernizedCProgram.Curl_resolv_unlock(data, conn.getDns_entry());
			conn.setDns_entry(((Object)0));
		} 
		ModernizedCProgram.Curl_hostcache_prune(data);
		do {
			.Curl_cfree((data.getState().getUlbuf()));
			(data.getState().getUlbuf()) = ((Object)0);
		} while (0);
		for (i = 0; i < data.getState().getTempcount(); /* if the transfer was completed in a paused state there can be buffered
		     data left to free */i++) {
			.Curl_cfree(data.getState().getTempwrite()[i].getBuf());
		}
		data.getState().setTempcount(0/* if data->set.reuse_forbid is TRUE, it means the libcurl client has
		     forced us to close this connection. This is ignored for requests taking
		     place in a NTLM/NEGOTIATE authentication handshake
		
		     if conn->bits.close is TRUE, it means that the connection should be
		     closed in spite of all our efforts to be nice, due to protocol
		     restrictions in our or the server's end
		
		     if premature is TRUE, it means this connection was said to be DONE before
		     the entire request operation is complete and thus we can't know in what
		     state it is for re-using, so we're forced to close it. In a perfect world
		     we can add code that keep track of if we really must close it here or not,
		     but currently we have no such detail knowledge.
		  */);
		if ((data.getSet().getReuse_forbid() && !(conn.getHttp_ntlm_state() == .NTLMSTATE_TYPE2 || conn.getProxy_ntlm_state() == .NTLMSTATE_TYPE2)) || conn.getBits().getClose() || (premature && !(conn.getHandler().getFlags() & (1 << 9)))) {
			CURLcode res2 = ModernizedCProgram.Curl_disconnect(data, conn, premature);
			if (!result && /* If we had an error already, make sure we return that one. But
			       if we got a new error, return that. */res2) {
				result = res2;
			} 
		} else {
				byte[] buffer = new byte[256];
				ModernizedCProgram.curl_msnprintf(buffer, , "Connection #%ld to host %s left intact", conn.getConnection_id(), conn.getBits().getSocksproxy() ? conn.getSocks_proxy().getHost().getDispname() : conn.getBits().getHttpproxy() ? conn.getHttp_proxy().getHost().getDispname() : conn.getBits().getConn_to_host() ? conn.getConn_to_host().getDispname() : conn.getHost().getDispname());
				if (ModernizedCProgram.Curl_conncache_return_conn(/* the connection is no longer in use by this transfer */conn)) {
					data.getState().setLastconnect(/* remember the most recently used connection */conn);
					ModernizedCProgram.Curl_infof(data, "%s\n", buffer);
				} else {
						data.getState().setLastconnect(((Object)0));
				} 
		} 
		ModernizedCProgram.Curl_free_request_state(data);
		return result;
	}
	/* an error if this is called
	                                                after an error was detected */
	public static  curl_multi_remove_handle(Object multi, Object data) {
		Curl_easy easy = data;
		bool premature = new bool();
		bool easy_owns_conn = new bool();
		curl_llist_element e = new curl_llist_element();
		if (!((multi) && (multi).getType() == /* First, make some basic checks that the CURLM handle is a good handle */-1024)) {
			return .CURLM_BAD_HANDLE;
		} 
		if (!((data) && ((data).getMagic() == /* Verify that we got a somewhat good easy handle too */-1024))) {
			return .CURLM_BAD_EASY_HANDLE;
		} 
		if (!data.getMulti()) {
			return /* it is already removed so let's say it is fine! */.CURLM_OK;
		} 
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		premature = (data.getMstate() < .CURLM_STATE_COMPLETED) ? 1 : 0;
		easy_owns_conn = (data.getConn() && (data.getConn().getData() == easy)) ? 1 : 0;
		if (/* If the 'state' is not INIT or COMPLETED, we might need to do something
		     nice to put the easy_handle in a good known state when this returns. */premature/* this handle is "alive" so we need to count down the total number of
		       alive connections when this is removed */) {
			multi.getNum_alive()--;
		} 
		if (data.getConn() && data.getMstate() > .CURLM_STATE_DO && data.getMstate() < .CURLM_STATE_COMPLETED/* Set connection owner so that the DONE function closes it.  We can
		       safely do this here since connection is killed. */) {
			data.getConn().setData(easy);
			ModernizedCProgram.Curl_conncontrol(data.getConn(), 2);
			easy_owns_conn = 1;
		} 
		ModernizedCProgram.Curl_expire_clear(/* The timer must be shut down before data->multi is set to NULL,
		     else the timenode will remain in the splay tree after
		     curl_easy_cleanup is called. */data);
		if (data.getConn()) {
			if (/* we must call multi_done() here (if we still own the connection) so that
			       we don't leave a half-baked one around */easy_owns_conn/* multi_done() clears the conn->data field to lose the association
			         between the easy handle and the connection
			
			         Note that this ignores the return code simply because there's
			         nothing really useful to do with it anyway! */) {
				(Object)ModernizedCProgram.multi_done(data, data.getResult(), premature);
			} 
		} 
		if (data.getConnect_queue().getPtr()) {
			ModernizedCProgram.Curl_llist_remove(multi.getPending(), data.getConnect_queue(), ((Object)0));
		} 
		if (data.getDns().getHostcachetype() == .HCACHE_MULTI/* stop using the multi handle's DNS cache, *after* the possible
		       multi_done() call above */) {
			data.getDns().setHostcache(((Object)0));
			data.getDns().setHostcachetype(.HCACHE_NONE);
		} 
		ModernizedCProgram.Curl_wildcard_dtor(data.getWildcard());
		ModernizedCProgram.Curl_llist_destroy(data.getState().getTimeoutlist(), ((Object)/* destroy the timeout list that is held in the easy handle, do this *after*
		     multi_done() as that may actually call Curl_expire that uses this */0));
		data.getState().setConn_cache(((Object)/* as this was using a shared connection cache we clear the pointer to that
		     since we're not part of that multi handle anymore */0));
		data.setMstate(/* change state without using multistate(), only to make singlesocket() do
		     what we want */.CURLM_STATE_COMPLETED);
		ModernizedCProgram.singlesocket(multi, /* to let the application know what sockets that
		                                vanish with this handle */easy);
		if (data.getConn()) {
			data.getConn().setData(((Object)0));
			ModernizedCProgram.detach_connnection(data/* Remove the PSL association. */);
		} 
		data.setMulti(((Object)/* clear the association to this multi handle */0/* make sure there's no pending message in the queue sent from this easy
		     handle */));
		for (e = multi.getMsglist().getHead(); e; e = e.getNext()) {
			Curl_message msg = e.getPtr();
			if (msg.getExtmsg().getEasy_handle() == easy) {
				ModernizedCProgram.Curl_llist_remove(multi.getMsglist(), e, ((Object)0/* there can only be one from this specific handle */));
				break;
			} 
		}
		if (data.getPrev()) {
			data.getPrev().setNext(data.getNext());
		} else {
				multi.setEasyp(data.getNext());
		} 
		if (data.getNext()) {
			data.getNext().setPrev(data.getPrev());
		} else {
				multi.setEasylp(data.getPrev());
		} 
		multi.getNum_easy()--;
		ModernizedCProgram.Curl_update_timer(multi);
		return .CURLM_OK;
	}
	/* Return TRUE if the application asked for multiplexing */
	public static  Curl_multiplex_wanted(Object multi) {
		return (multi && (multi.getMultiplexing()));
	}
	/* This is the only function that should clear data->conn. This will
	   occasionally be called with the pointer already cleared. */
	public static void detach_connnection(Object data) {
		connectdata conn = data.getConn();
		if (conn) {
			ModernizedCProgram.Curl_llist_remove(conn.getEasyq(), data.getConn_queue(), ((Object)0));
		} 
		data.setConn(((Object)0));
	}
	/* This is the only function that should assign data->conn */
	public static void Curl_attach_connnection(Object data, Object conn) {
		do {
		} while (0);
		do {
		} while (0);
		data.setConn(conn);
		ModernizedCProgram.Curl_llist_insert_next(conn.getEasyq(), conn.getEasyq().getTail(), data, data.getConn_queue());
	}
	public static int waitconnect_getsock(Object conn, Object sock) {
		int i;
		int s = 0;
		int rc = 0;
		for (i = 0; i < 2; i++) {
			if (conn.getTempsock()[i] != (SOCKET)(~0)) {
				sock[s] = conn.getTempsock()[i];
				rc |=  (1 << (16 + (s)));
				/* when connecting QUIC, we want to read the socket too */s++;
			} 
		}
		return rc;
	}
	public static int waitproxyconnect_getsock(Object conn, Object sock) {
		sock[0] = conn.getSock()[0];
		if (conn.getConnect_state()) {
			return (1 << (false));
		} 
		return (1 << (16 + (false)));
	}
	public static int domore_getsock(Object conn, Object socks) {
		if (conn && conn.getHandler().getDomore_getsock()) {
			return .UNRECOGNIZEDFUNCTIONNAME(conn, socks);
		} 
		return 0;
	}
	public static int doing_getsock(Object conn, Object socks) {
		if (conn && conn.getHandler().getDoing_getsock()) {
			return .UNRECOGNIZEDFUNCTIONNAME(conn, socks);
		} 
		return 0;
	}
	public static int protocol_getsock(Object conn, Object socks) {
		if (conn.getHandler().getProto_getsock()) {
			return .UNRECOGNIZEDFUNCTIONNAME(conn, socks/* Backup getsock logic. Since there is a live socket in use, we must wait
			     for it or it will be removed from watching when the multi_socket API is
			     used. */);
		} 
		socks[0] = conn.getSock()[0];
		return (1 << (false)) | (1 << (16 + (false)));
	}
	/* returns bitmapped flags for this handle and its sockets. The 'socks[]'
	   array contains MAX_SOCKSPEREASYHANDLE entries. */
	public static int multi_getsock(Object data, Object socks) {
		if (!data.getConn()) {
			return 0;
		} 
		if (data.getMstate() > .CURLM_STATE_CONNECT && data.getMstate() < .CURLM_STATE_COMPLETED) {
			data.getConn().setData(/* Set up ownership correctly */data);
		} 
		switch (data.getMstate()) {
		case .CURLM_STATE_SENDPROTOCONNECT:
				return ModernizedCProgram.protocol_getsock(data.getConn(), socks);
		case .CURLM_STATE_PERFORM:
				return ModernizedCProgram.Curl_single_getsock(data.getConn(), socks);
		case .CURLM_STATE_DOING:
				return ModernizedCProgram.doing_getsock(data.getConn(), socks);
		case .CURLM_STATE_WAITRESOLVE:
				return ModernizedCProgram.Curl_resolv_getsock(data.getConn(), socks);
		case /* since is set after DO is completed, we switch
		                               to waiting for the same as the *PERFORM
		                               states */.CURLM_STATE_DO_DONE:
		case .CURLM_STATE_DO:
		case .CURLM_STATE_DO_MORE:
				return ModernizedCProgram.domore_getsock(data.getConn(), socks);
		case .CURLM_STATE_PROTOCONNECT:
		case .CURLM_STATE_WAITPROXYCONNECT:
				return ModernizedCProgram.waitproxyconnect_getsock(data.getConn(), socks);
		case .CURLM_STATE_WAITCONNECT:
				return ModernizedCProgram.waitconnect_getsock(data.getConn(), socks);
		default:
				return /* this will get called with CURLM_STATE_COMPLETED when a handle is
				       removed */0;
		}
	}
	public static  curl_multi_fdset(Object multi, Object read_fd_set, Object write_fd_set, Object exc_fd_set, Object max_fd) {
		/* Scan through all the easy handles to get the file descriptors set.
		     Some easy handles may not have connected to the remote host yet,
		     and then we must make sure that is done. */Curl_easy data = new Curl_easy();
		int this_max_fd = -1;
		curl_socket_t[] sockbunch = new curl_socket_t();
		int i;
		(Object)/* not used */exc_fd_set;
		if (!((multi) && (multi).getType() == -1024)) {
			return .CURLM_BAD_HANDLE;
		} 
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		data = multi.getEasyp();
		while (data) {
			int bitmap = ModernizedCProgram.multi_getsock(data, sockbunch);
			for (i = 0; i < 5; i++) {
				curl_socket_t s = (SOCKET)(~0);
				if ((bitmap & (1 << (i))) && true) {
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(read_fd_set)).getFd_count(); __i++) {
							if (((fd_set)(read_fd_set)).getFd_array()[__i] == (sockbunch[i])) {
								break;
							} 
						}
						if (__i == ((fd_set)(read_fd_set)).getFd_count()) {
							if (((fd_set)(read_fd_set)).getFd_count() < 64) {
								((fd_set)(read_fd_set)).getFd_array()[__i] = (sockbunch[i]);
								((fd_set)(read_fd_set)).getFd_count()++;
							} 
						} 
					} while (0);
					s = sockbunch[i];
				} 
				if ((bitmap & (1 << (16 + (i)))) && true) {
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(write_fd_set)).getFd_count(); __i++) {
							if (((fd_set)(write_fd_set)).getFd_array()[__i] == (sockbunch[i])) {
								break;
							} 
						}
						if (__i == ((fd_set)(write_fd_set)).getFd_count()) {
							if (((fd_set)(write_fd_set)).getFd_count() < 64) {
								((fd_set)(write_fd_set)).getFd_array()[__i] = (sockbunch[i]);
								((fd_set)(write_fd_set)).getFd_count()++;
							} 
						} 
					} while (0);
					s = sockbunch[i];
				} 
				if (s == (SOCKET)(~0/* this socket is unused, break out of loop */)) {
					break;
				} 
				if ((int)s > this_max_fd) {
					this_max_fd = (int)s;
				} 
			}
			data = data.getNext();
		}
		max_fd = this_max_fd;
		return .CURLM_OK;
	}
	public static  Curl_multi_wait(Object multi, Object extra_fds, int extra_nfds, int timeout_ms, Object ret,  extrawait) {
		/* when no socket, wait */Curl_easy data = new Curl_easy();
		curl_socket_t[] sockbunch = new curl_socket_t();
		int bitmap;
		int i;
		int nfds = 0;
		int curlfds;
		bool ufds_malloc = 0;
		long timeout_internal;
		int retcode = 0;
		pollfd[] a_few_on_stack = new pollfd();
		pollfd ufds = a_few_on_stack[0];
		if (!((multi) && (multi).getType() == -1024)) {
			return .CURLM_BAD_HANDLE;
		} 
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		data = multi.getEasyp();
		while (data) {
			bitmap = ModernizedCProgram.multi_getsock(data, sockbunch);
			for (i = 0; i < 5; i++) {
				curl_socket_t s = (SOCKET)(~0);
				if (bitmap & (1 << (i))) {
					++nfds;
					s = sockbunch[i];
				} 
				if (bitmap & (1 << (16 + (i)))) {
					++nfds;
					s = sockbunch[i];
				} 
				if (s == (SOCKET)(~0)) {
					break;
				} 
			}
			data = data.getNext();
		}
		(Object)ModernizedCProgram.multi_timeout(multi, /* If the internally desired timeout is actually shorter than requested from
		     the outside, then use the shorter time! But only if the internal timer
		     is actually larger than -1! */timeout_internal);
		if ((timeout_internal >= 0) && (timeout_internal < (long)timeout_ms)) {
			timeout_ms = (int)timeout_internal;
		} 
		curlfds = /* number of internal file descriptors */nfds;
		nfds += /* add the externally provided ones */extra_nfds;
		if (nfds > 10/* 'nfds' is a 32 bit value and 'struct pollfd' is typically 8 bytes
		       big, so at 2^29 sockets this value might wrap. When a process gets
		       the capability to actually handle over 500 million sockets this
		       calculation needs a integer overflow check. */) {
			ufds = .Curl_cmalloc(nfds * );
			if (!ufds) {
				return .CURLM_OUT_OF_MEMORY;
			} 
			ufds_malloc = 1;
		} 
		nfds = 0/* only do the second loop if we found descriptors in the first stage run
		     above */;
		if (curlfds) {
			data = multi.getEasyp();
			while (data) {
				bitmap = ModernizedCProgram.multi_getsock(data, sockbunch);
				for (i = 0; i < 5; i++) {
					curl_socket_t s = (SOCKET)(~0);
					if (bitmap & (1 << (i))) {
						ufds[nfds].setFd(sockbunch[i]);
						ufds[nfds].setEvents(-1024);
						++nfds;
						s = sockbunch[i];
					} 
					if (bitmap & (1 << (16 + (i)))) {
						ufds[nfds].setFd(sockbunch[i]);
						ufds[nfds].setEvents(-1024);
						++nfds;
						s = sockbunch[i];
					} 
					if (s == (SOCKET)(~0)) {
						break;
					} 
				}
				data = data.getNext();
			}
		} 
		for (i = 0; i < extra_nfds; /* Add external file descriptions from poll-like struct curl_waitfd */i++) {
			ufds[nfds].setFd(extra_fds[i].getFd());
			ufds[nfds].setEvents(0);
			if (extra_fds[i].getEvents() & -1024) {
				ufds[nfds].getEvents() |=  -1024;
			} 
			if (extra_fds[i].getEvents() & -1024) {
				ufds[nfds].getEvents() |=  -1024;
			} 
			if (extra_fds[i].getEvents() & -1024) {
				ufds[nfds].getEvents() |=  -1024;
			} 
			++nfds;
		}
		if (nfds) {
			int pollrc;
			pollrc = ModernizedCProgram.Curl_poll(ufds, nfds, /* wait... */timeout_ms);
			if (pollrc > 0) {
				retcode = pollrc/* copy revents results from the poll to the curl_multi_wait poll
				         struct, the bit values of the actual underlying poll() implementation
				         may not be the same as the ones in the public libcurl API! */;
				for (i = 0; i < extra_nfds; i++) {
					int mask = 0;
					int r = ufds[curlfds + i].getRevents();
					if (r & -1024) {
						mask |=  -1024;
					} 
					if (r & -1024) {
						mask |=  -1024;
					} 
					if (r & -1024) {
						mask |=  -1024;
					} 
					extra_fds[i].setRevents(mask);
				}
			} 
		} 
		if (ufds_malloc) {
			.Curl_cfree(ufds);
		} 
		if (ret) {
			ret = retcode;
		} 
		if (!extrawait || extra_fds || curlfds/* if any socket was checked */) {
			;
		} else {
				long sleep_ms = 0;
				if (!ModernizedCProgram.curl_multi_timeout(multi, sleep_ms) && /* Avoid busy-looping when there's nothing particular to wait for */sleep_ms) {
					if (sleep_ms > timeout_ms) {
						sleep_ms = timeout_ms;
					} 
					ModernizedCProgram.Curl_wait_ms((int)sleep_ms);
				} 
		} 
		return .CURLM_OK;
	}
	public static  curl_multi_poll(Object multi, Object extra_fds, int extra_nfds, int timeout_ms, Object ret) {
		return ModernizedCProgram.Curl_multi_wait(multi, extra_fds, extra_nfds, timeout_ms, ret, 1/*
		 * multi_ischanged() is called
		 *
		 * Returns TRUE/FALSE whether the state is changed to trigger a CONNECT_PEND
		 * => CONNECT action.
		 *
		 * Set 'clear' to TRUE to have it also clear the state variable.
		 */);
	}
	public static  multi_ischanged(Object multi,  clear) {
		bool retval = multi.getRecheckstate();
		if (clear) {
			multi.setRecheckstate(0);
		} 
		return retval;
	}
	public static  Curl_multi_add_perform(Object multi, Object data, Object conn) {
		CURLMcode rc = new CURLMcode();
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		rc = ModernizedCProgram.curl_multi_add_handle(multi, data);
		if (!rc) {
			SingleRequest k = data.getReq();
			ModernizedCProgram.Curl_init_do(data, ((Object)/* pass in NULL for 'conn' here since we don't want to init the
			       connection, only this transfer */0));
			ModernizedCProgram.mstate(data, /* take this handle to the perform state right away */.CURLM_STATE_PERFORM);
			ModernizedCProgram.Curl_attach_connnection(data, conn);
			k.getKeepon() |=  (1 << /* setup to receive! */0);
		} 
		return rc/*
		 * do_complete is called when the DO actions are complete.
		 *
		 * We init chunking and trailer bits to their default values here immediately
		 * before receiving any header data for the current request.
		 */;
	}
	public static void do_complete(Object conn) {
		conn.getData().getReq().setChunk(0);
		ModernizedCProgram.Curl_pgrsTime(conn.getData(), .TIMER_PRETRANSFER);
	}
	public static  multi_do(Object data, Object done) {
		CURLcode result = .CURLE_OK;
		connectdata conn = data.getConn();
		do {
		} while (0);
		do {
		} while (0);
		if (conn.getHandler().getDo_it()) {
			result = .UNRECOGNIZEDFUNCTIONNAME(conn, /* generic protocol-specific function pointer set in curl_connect() */done);
			if (!result && done) {
				ModernizedCProgram.do_complete(/* do_complete must be called after the protocol-specific DO function */conn);
			} 
		} 
		return result/*
		 * multi_do_more() is called during the DO_MORE multi state. It is basically a
		 * second stage DO state which (wrongly) was introduced to support FTP's
		 * second connection.
		 *
		 * 'complete' can return 0 for incomplete, 1 for done and -1 for go back to
		 * DOING state there's more work to do!
		 */;
	}
	public static  multi_do_more(Object conn, Object complete) {
		CURLcode result = .CURLE_OK;
		complete = 0;
		if (conn.getHandler().getDo_more()) {
			result = .UNRECOGNIZEDFUNCTIONNAME(conn, complete);
		} 
		if (!result && (complete == 1)) {
			ModernizedCProgram.do_complete(/* do_complete must be called after the protocol-specific DO function */conn);
		} 
		return result/*
		 * We are doing protocol-specific connecting and this is being called over and
		 * over from the multi interface until the connection phase is done on
		 * protocol layer.
		 */;
	}
	public static  protocol_connecting(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		if (conn && conn.getHandler().getConnecting()) {
			done = 0;
			result = .UNRECOGNIZEDFUNCTIONNAME(conn, done);
		} else {
				done = 1;
		} 
		return result/*
		 * We are DOING this is being called over and over from the multi interface
		 * until the DOING phase is done on protocol layer.
		 */;
	}
	public static  protocol_doing(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		if (conn && conn.getHandler().getDoing()) {
			done = 0;
			result = .UNRECOGNIZEDFUNCTIONNAME(conn, done);
		} else {
				done = 1;
		} 
		return result/*
		 * We have discovered that the TCP connection has been successful, we can now
		 * proceed with some action.
		 *
		 */;
	}
	public static  protocol_connect(Object conn, Object protocol_done) {
		CURLcode result = .CURLE_OK;
		do {
		} while (0);
		do {
		} while (0);
		protocol_done = 0;
		if (conn.getBits().getTcpconnect()[0] && conn.getBits().getProtoconnstart()) {
			if (!conn.getHandler().getConnecting()) {
				protocol_done = 1;
			} 
			return .CURLE_OK;
		} 
		if (!conn.getBits().getProtoconnstart()) {
			result = ModernizedCProgram.Curl_proxy_connect(conn, 0);
			if (result) {
				return result;
			} 
			if ((conn.getHttp_proxy().getProxytype() == .CURLPROXY_HTTPS && !conn.getBits().getProxy_ssl_connected()[0])) {
				return /* wait for HTTPS proxy SSL initialization to complete */.CURLE_OK;
			} 
			if (conn.getBits().getTunnel_proxy() && conn.getBits().getHttpproxy() && ModernizedCProgram.Curl_connect_ongoing(conn/* when using an HTTP tunnel proxy, await complete tunnel establishment
			         before proceeding further. Return CURLE_OK so we'll be called again */)) {
				return .CURLE_OK;
			} 
			if (conn.getHandler().getConnect_it()) {
				result = .UNRECOGNIZEDFUNCTIONNAME(conn, /* Call the protocol-specific connect function */protocol_done);
			} else {
					protocol_done = 1;
			} 
			if (!/* it has started, possibly even completed but that knowledge isn't stored
			       in this bit! */result) {
				conn.getBits().setProtoconnstart(1);
			} 
		} 
		return /* pass back status */result;
	}
	public static  curl_multi_perform(Object multi, Object running_handles) {
		Curl_easy data = new Curl_easy();
		CURLMcode returncode = .CURLM_OK;
		Curl_tree t = new Curl_tree();
		curltime curltime = new curltime();
		curltime now = curltime.Curl_now();
		if (!((multi) && (multi).getType() == -1024)) {
			return .CURLM_BAD_HANDLE;
		} 
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		data = multi.getEasyp();
		while (data) {
			CURLMcode result = new CURLMcode();
			;
			do {
			} while (0);
			result = now.multi_runsingle(multi, data);
			do {
			} while (0);
			if (result) {
				returncode = result;
			} 
			data = data.getNext();
		}
		do {
			multi.setTimetree(now.Curl_splaygetbest(multi.getTimetree(), t));
			if (t) {
				(Object)now.add_next_timeout(multi, t.getPayload());
			} 
		} while (t);
		running_handles = multi.getNum_alive();
		if (.CURLM_OK >= returncode) {
			ModernizedCProgram.Curl_update_timer(multi);
		} 
		return returncode;
	}
	public static  curl_multi_cleanup(Object multi) {
		Curl_easy data = new Curl_easy();
		Curl_easy nextdata = new Curl_easy();
		if (((multi) && (multi).getType() == -1024)) {
			if (multi.getIn_callback()) {
				return .CURLM_RECURSIVE_API_CALL;
			} 
			multi.setType(/* not good anymore */0);
			data = multi.getEasyp();
			while (data) {
				nextdata = data.getNext();
				if (!data.getState().getDone() && data.getConn()) {
					(Object)ModernizedCProgram.multi_done(data, .CURLE_OK, /* if DONE was never called for this handle */1);
				} 
				if (data.getDns().getHostcachetype() == .HCACHE_MULTI) {
					ModernizedCProgram.Curl_hostcache_clean(data, data.getDns().getHostcache());
					data.getDns().setHostcache(((Object)0));
					data.getDns().setHostcachetype(.HCACHE_NONE);
				} 
				data.getState().setConn_cache(((Object)/* Clear the pointer to the connection cache */0));
				data.setMulti(((Object)/* clear the association */0));
				data = nextdata;
			}
			ModernizedCProgram.Curl_conncache_close_all_connections(multi.getConn_cache());
			ModernizedCProgram.Curl_hash_destroy(multi.getSockhash());
			ModernizedCProgram.Curl_conncache_destroy(multi.getConn_cache());
			ModernizedCProgram.Curl_llist_destroy(multi.getMsglist(), ((Object)0));
			ModernizedCProgram.Curl_llist_destroy(multi.getPending(), ((Object)0));
			ModernizedCProgram.Curl_hash_destroy(multi.getHostcache());
			;
			.Curl_cfree(multi);
			return .CURLM_OK;
		} 
		return .CURLM_BAD_HANDLE/*
		 * curl_multi_info_read()
		 *
		 * This function is the primary way for a multi/multi_socket application to
		 * figure out if a transfer has ended. We MUST make this function as fast as
		 * possible as it will be polled frequently and we MUST NOT scan any lists in
		 * here to figure out things. We must scale fine to thousands of handles and
		 * beyond. The current design is fully O(1).
		 */;
	}
	public static Object curl_multi_info_read(Object multi, Object msgs_in_queue) {
		Curl_message msg = new Curl_message();
		msgs_in_queue = /* default to none */0;
		if (((multi) && (multi).getType() == -1024) && !multi.getIn_callback() && ModernizedCProgram.Curl_llist_count(multi.getMsglist())) {
			curl_llist_element e = new curl_llist_element();
			e = multi.getMsglist().getHead();
			msg = e.getPtr();
			ModernizedCProgram.Curl_llist_remove(multi.getMsglist(), e, ((Object)/* remove the extracted entry */0));
			msgs_in_queue = ModernizedCProgram.curlx_uztosi(ModernizedCProgram.Curl_llist_count(multi.getMsglist()));
			return msg.getExtmsg();
		} 
		return ((Object)0/*
		 * singlesocket() checks what sockets we deal with and their "action state"
		 * and if we have a different state in any of those sockets from last time we
		 * call the callback accordingly.
		 */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/*
	  CURL_SOCKET_HASH_TABLE_SIZE should be a prime number. Increasing it from 97
	  to 911 takes on a 32-bit machine 4 x 804 = 3211 more bytes.  Still, every
	  CURL handle takes 45-50 K memory, therefore this 3K are not significant.
	*/
	public static  singlesocket(Object multi, Object data) {
		curl_socket_t[] socks = new curl_socket_t();
		int i;
		Curl_sh_entry entry = new Curl_sh_entry();
		curl_socket_t s = new curl_socket_t();
		int num;
		int curraction;
		int[] actions = new int[5];
		for (i = 0; i < 5; i++) {
			socks[i] = (SOCKET)(~0);
		}
		curraction = ModernizedCProgram.multi_getsock(data, /* Fill in the 'current' struct with the state as it is now: what sockets to
		     supervise and for what actions */socks/* We have 0 .. N sockets already and we get to know about the 0 .. M
		     sockets we should have from now on. Detect the differences, remove no
		     longer supervised ones and add new ones */);
		for (i = 0; (i < /* walk over the sockets we got right now */5) && (curraction & ((1 << (i)) | (1 << (16 + (i))))); i++) {
			int action = 0;
			int prevaction = 0;
			int comboaction;
			bool sincebefore = 0;
			s = socks[i];
			entry = ModernizedCProgram.sh_getentry(multi.getSockhash(), /* get it from the hash */s);
			if (curraction & (1 << (i))) {
				action |=  1;
			} 
			if (curraction & (1 << (16 + (i)))) {
				action |=  2;
			} 
			actions[i] = action;
			if (entry/* check if new for this transfer */) {
				int j;
				for (j = 0; j < data.getNumsocks(); j++) {
					if (s == data.getSockets()[j]) {
						prevaction = data.getActions()[j];
						sincebefore = 1;
						break;
					} 
				}
			} else {
					entry = ModernizedCProgram.sh_addentry(multi.getSockhash(), /* this is a socket we didn't have before, add it to the hash! */s);
					if (!entry) {
						return /* fatal */.CURLM_OUT_OF_MEMORY;
					} 
			} 
			if (sincebefore && (prevaction != action)) {
				if (prevaction & /* Socket was used already, but different action now */1) {
					entry.getReaders()--;
				} 
				if (prevaction & 2) {
					entry.getWriters()--;
				} 
				if (action & 1) {
					entry.getReaders()++;
				} 
				if (action & 2) {
					entry.getWriters()++;
				} 
			}  else if (!sincebefore) {
				entry.getUsers()++;
				if (action & 1) {
					entry.getReaders()++;
				} 
				if (action & 2) {
					entry.getWriters()++;
				} 
				if (!ModernizedCProgram.Curl_hash_add(entry.getTransfers(), (byte)/* add 'data' to the transfer hash on this socket! *//* hash key */data, , data)) {
					return .CURLM_OUT_OF_MEMORY;
				} 
			} 
			comboaction = (entry.getWriters() ? 2 : 0) | (entry.getReaders() ? 1 : 0);
			if (sincebefore && (entry.getAction() == /* socket existed before and has the same action set as before */comboaction/* same, continue */)) {
				continue;
			} 
			if (multi.getSocket_cb()) {
				.UNRECOGNIZEDFUNCTIONNAME(data, s, comboaction, multi.getSocket_userp(), entry.getSocketp());
			} 
			entry.setAction(/* store the current action state */comboaction);
		}
		num = /* number of sockets */i;
		for (i = 0; i < data.getNumsocks(); /* when we've walked over all the sockets we should have right now, we must
		     make sure to detect sockets that are removed */i++) {
			int j;
			bool stillused = 0;
			s = data.getSockets()[i];
			for (j = 0; j < num; j++) {
				if (s == socks[j]) {
					stillused = /* this is still supervised */1;
					break;
				} 
			}
			if (stillused) {
				continue;
			} 
			entry = ModernizedCProgram.sh_getentry(multi.getSockhash(), s/* if this is NULL here, the socket has been closed and notified so
			       already by Curl_multi_closed() */);
			if (entry) {
				int oldactions = data.getActions()[i];
				entry.getUsers()--;
				if (oldactions & 2) {
					entry.getWriters()--;
				} 
				if (oldactions & 1) {
					entry.getReaders()--;
				} 
				if (!entry.getUsers()) {
					if (multi.getSocket_cb()) {
						.UNRECOGNIZEDFUNCTIONNAME(data, s, 4, multi.getSocket_userp(), entry.getSocketp());
					} 
					ModernizedCProgram.sh_delentry(entry, multi.getSockhash(), s);
				} else {
						if (ModernizedCProgram.Curl_hash_delete(entry.getTransfers(), (byte)/* still users, but remove this handle as a user of this socket */data, )) {
							do {
							} while (0);
						} 
				} 
			} 
		}
		.memcpy(data.getSockets(), socks, num * /* for loop over numsocks */);
		.memcpy(data.getActions(), actions, num * );
		data.setNumsocks(num);
		return .CURLM_OK;
	}
	public static void Curl_updatesocket(Object data) {
		ModernizedCProgram.singlesocket(data.getMulti(), data/*
		 * Curl_multi_closed()
		 *
		 * Used by the connect code to tell the multi_socket code that one of the
		 * sockets we were using is about to be closed.  This function will then
		 * remove it from the sockethash for this handle to make the multi_socket API
		 * behave properly, especially for the case when libcurl will create another
		 * socket again and it gets the same file descriptor number.
		 */);
	}
	public static void Curl_multi_closed(Object data, Object s) {
		if (data) {
			Curl_multi multi = data.getMulti();
			if (multi/* this is set if this connection is part of a handle that is added to
			         a multi handle, and only then this is necessary */) {
				Curl_sh_entry entry = ModernizedCProgram.sh_getentry(multi.getSockhash(), s);
				if (entry) {
					if (multi.getSocket_cb()) {
						.UNRECOGNIZEDFUNCTIONNAME(data, s, 4, multi.getSocket_userp(), entry.getSocketp());
					} 
					ModernizedCProgram.sh_delentry(entry, multi.getSockhash(), /* now remove it from the socket hash */s/*
					 * add_next_timeout()
					 *
					 * Each Curl_easy has a list of timeouts. The add_next_timeout() is called
					 * when it has just been removed from the splay tree because the timeout has
					 * expired. This function is then to advance in the list to pick the next
					 * timeout to use (skip the already expired ones) and add this node back to
					 * the splay tree again.
					 *
					 * The splay tree only has each sessionhandle as a single node and the nearest
					 * timeout is used to sort it on.
					 */);
				} 
			} 
		} 
	}
	public static  multi_socket(Object multi,  checkall, Object s, int ev_bitmask, Object running_handles) {
		CURLMcode result = .CURLM_OK;
		Curl_easy data = ((Object)0);
		Curl_tree t = new Curl_tree();
		curltime curltime = new curltime();
		curltime now = curltime.Curl_now();
		if (checkall) {
			result = ModernizedCProgram.curl_multi_perform(multi, /* *perform() deals with running_handles on its own */running_handles);
			if (result != /* walk through each easy handle and do the socket state change magic
			       and callbacks */.CURLM_BAD_HANDLE) {
				data = multi.getEasyp();
				while (data && !result) {
					result = ModernizedCProgram.singlesocket(multi, data);
					data = data.getNext();
				}
			} 
			return /* or should we fall-through and do the timer-based stuff? */result;
		} 
		if (s != (SOCKET)(~0)) {
			Curl_sh_entry entry = ModernizedCProgram.sh_getentry(multi.getSockhash(), s);
			if (!entry/* Unmatched socket, we can't act on it but we ignore this fact.  In
			         real-world tests it has been proved that libevent can in fact give
			         the application actions even though the socket was just previously
			         asked to get removed, so thus we better survive stray socket actions
			         and just move on. */) {
				;
			} else {
					curl_hash_iterator iter = new curl_hash_iterator();
					curl_hash_element he = new curl_hash_element();
					ModernizedCProgram.Curl_hash_start_iterate(entry.getTransfers(), /* the socket can be shared by many transfers, iterate */iter);
					for (he = ModernizedCProgram.Curl_hash_next_element(iter); he; he = ModernizedCProgram.Curl_hash_next_element(iter)) {
						data = (Curl_easy)he.getPtr();
						do {
						} while (0);
						do {
						} while (0);
						if (data.getConn() && !(data.getConn().getHandler().getFlags() & (1 << 3))) {
							data.getConn().setCselect_bits(/* set socket event bitmask if they're not locked */ev_bitmask);
						} 
						ModernizedCProgram.Curl_expire(data, 0, .EXPIRE_RUN_NOW/* Now we fall-through and do the timer-based stuff, since we don't want
						         to force the user to have to deal with timeouts as long as at least
						         one connection in fact has traffic. */);
					}
					data = ((Object)/* set data to NULL again to avoid calling
					                      multi_runsingle() in case there's no need to */0);
					now = curltime.Curl_now();
			} 
		} else {
				.memset(multi.getTimer_lastcall(), 0, );
		} 
		do {
			if (/* the first loop lap 'data' can be NULL */data) {
				;
				do {
				} while (0);
				result = now.multi_runsingle(multi, data);
				do {
				} while (0);
				if (.CURLM_OK >= result/* get the socket(s) and check if the state has been changed since
				           last */) {
					result = ModernizedCProgram.singlesocket(multi, data);
					if (result) {
						return result;
					} 
				} 
			} 
			multi.setTimetree(now.Curl_splaygetbest(multi.getTimetree(), /* Check if there's one (more) expired timer to deal with! This function
			       extracts a matching node if there is one */t));
			if (t) {
				data = t.getPayload();
				(Object)now.add_next_timeout(multi, t.getPayload());
			} 
		} while (t);
		running_handles = multi.getNum_alive();
		return result;
	}
	public static  curl_multi_setopt(Object multi,  option) {
		CURLMcode res = .CURLM_OK;
		va_list param = new va_list();
		if (!((multi) && (multi).getType() == -1024)) {
			return .CURLM_BAD_HANDLE;
		} 
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		.__builtin_va_start(param, option);
		switch (option) {
		case .CURLMOPT_SOCKETDATA:
				multi.setSocket_userp((int)param);
				break;
		case .CURLMOPT_PUSHDATA:
				multi.setPush_userp((int)param);
				break;
		case .CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE:
				break;
		case .CURLMOPT_MAX_HOST_CONNECTIONS:
				multi.setMax_host_connections((int)param);
				break;
		case .CURLMOPT_PIPELINING_SERVER_BL:
				break;
		case .CURLMOPT_PIPELINING_SITE_BL:
				break;
		case .CURLMOPT_PUSHFUNCTION:
				multi.setPush_cb((int)param);
				break;
		case /* options formerly used for pipelining */.CURLMOPT_MAX_PIPELINE_LENGTH:
				break;
		case .CURLMOPT_SOCKETFUNCTION:
				multi.setSocket_cb((int)param);
				break;
		case .CURLMOPT_PIPELINING:
				multi.setMultiplexing((int)param & -1024);
				break;
		case .CURLMOPT_MAXCONNECTS:
				multi.setMaxconnects((int)param);
				break;
		case .CURLMOPT_TIMERFUNCTION:
				multi.setTimer_cb((int)param);
				break;
		case .CURLMOPT_MAX_CONCURRENT_STREAMS:
				{ 
					long streams = (int)param;
					if (streams < 1) {
						streams = 100;
					} 
					multi.setMax_concurrent_streams((streams > (long)((-1024 << 31) - 1)) ? (long)((-1024 << 31) - 1) : streams);
				}
				break;
		case .CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE:
				break;
		case .CURLMOPT_MAX_TOTAL_CONNECTIONS:
				multi.setMax_total_connections((int)param);
				break;
		case .CURLMOPT_TIMERDATA:
				multi.setTimer_userp((int)param);
				break;
		default:
				res = .CURLM_UNKNOWN_OPTION;
				break;
		}
		.__builtin_va_end(param);
		return res/* we define curl_multi_socket() in the public multi.h header */;
	}
	public static  curl_multi_socket(Object multi, Object s, Object running_handles) {
		CURLMcode result = new CURLMcode();
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		result = ModernizedCProgram.multi_socket(multi, 0, s, 0, running_handles);
		if (.CURLM_OK >= result) {
			ModernizedCProgram.Curl_update_timer(multi);
		} 
		return result;
	}
	public static  curl_multi_socket_action(Object multi, Object s, int ev_bitmask, Object running_handles) {
		CURLMcode result = new CURLMcode();
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		result = ModernizedCProgram.multi_socket(multi, 0, s, ev_bitmask, running_handles);
		if (.CURLM_OK >= result) {
			ModernizedCProgram.Curl_update_timer(multi);
		} 
		return result;
	}
	public static  curl_multi_socket_all(Object multi, Object running_handles) {
		CURLMcode result = new CURLMcode();
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		result = ModernizedCProgram.multi_socket(multi, 1, (SOCKET)(~0), 0, running_handles);
		if (.CURLM_OK >= result) {
			ModernizedCProgram.Curl_update_timer(multi);
		} 
		return result;
	}
	public static  multi_timeout(Object multi, Object timeout_ms) {
		curltime tv_zero = new curltime(0, 0);
		curltime curltime = new curltime();
		Object generatedTv_sec = now.getTv_sec();
		int generatedTv_usec = now.getTv_usec();
		if (multi.getTimetree()) {
			curltime now = curltime.Curl_now();
			multi.setTimetree(tv_zero.Curl_splay(multi.getTimetree()));
			if ((((multi.getTimetree().getKey().getTv_sec()) < (generatedTv_sec)) ? -1 : (((generatedTv_sec) > (generatedTv_sec)) ? 1 : (((multi.getTimetree().getKey().getTv_usec()) < (generatedTv_usec)) ? -1 : (((generatedTv_usec) > (generatedTv_usec)) ? 1 : 0)))) > 0) {
				timediff_t diff = multi.getTimetree().getKey().Curl_timediff(/* some time left before expiration */now);
				if (diff <= 0/*
				         * Since we only provide millisecond resolution on the returned value
				         * and the diff might be less than one millisecond here, we don't
				         * return zero as that may cause short bursts of busyloops on fast
				         * processors while the diff is still present but less than one
				         * millisecond! instead we return 1 until the time is ripe.
				         */) {
					timeout_ms = 1;
				} else {
						timeout_ms = (long)/* this should be safe even on 64 bit archs, as we don't use that
						           overly long timeouts */diff;
				} 
			} else {
					timeout_ms = /* 0 means immediately */0;
			} 
		} else {
				timeout_ms = -1;
		} 
		return .CURLM_OK;
	}
	public static  curl_multi_timeout(Object multi, Object timeout_ms) {
		if (!((multi) && (multi).getType() == /* First, make some basic checks that the CURLM handle is a good handle */-1024)) {
			return .CURLM_BAD_HANDLE;
		} 
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		return ModernizedCProgram.multi_timeout(multi, timeout_ms/*
		 * Tell the application it should update its timers, if it subscribes to the
		 * update timer callback.
		 */);
	}
	public static void Curl_update_timer(Object multi) {
		long timeout_ms;
		if (!multi.getTimer_cb()) {
			return ;
		} 
		if (ModernizedCProgram.multi_timeout(multi, timeout_ms)) {
			return ;
		} 
		if (timeout_ms < 0) {
			curltime none = new curltime(0, 0);
			if ((((none.getTv_sec()) < (multi.getTimer_lastcall().getTv_sec())) ? -1 : (((none.getTv_sec()) > (multi.getTimer_lastcall().getTv_sec())) ? 1 : (((none.getTv_usec()) < (multi.getTimer_lastcall().getTv_usec())) ? -1 : (((none.getTv_usec()) > (multi.getTimer_lastcall().getTv_usec())) ? 1 : 0))))) {
				multi.setTimer_lastcall(none/* there's no timeout now but there was one previously, tell the app to
				         disable it */);
				.UNRECOGNIZEDFUNCTIONNAME(multi, -1, multi.getTimer_userp());
				return ;
			} 
			return ;
		} 
		if ((((multi.getTimetree().getKey().getTv_sec()) < (multi.getTimer_lastcall().getTv_sec())) ? -1 : (((multi.getTimetree().getKey().getTv_sec()) > (multi.getTimer_lastcall().getTv_sec())) ? 1 : (((multi.getTimetree().getKey().getTv_usec()) < (multi.getTimer_lastcall().getTv_usec())) ? -1 : (((multi.getTimetree().getKey().getTv_usec()) > (multi.getTimer_lastcall().getTv_usec())) ? 1 : 0)))) == 0) {
			return ;
		} 
		multi.setTimer_lastcall(multi.getTimetree().getKey());
		.UNRECOGNIZEDFUNCTIONNAME(multi, timeout_ms, multi.getTimer_userp());
	}
	public static void multi_deltimeout(Object data,  eid) {
		curl_llist_element e = new curl_llist_element();
		curl_llist timeoutlist = data.getState().getTimeoutlist();
		for (e = timeoutlist.getHead(); e; e = e.getNext()) {
			time_node n = (time_node)e.getPtr();
			if (n.getEid() == eid) {
				ModernizedCProgram.Curl_llist_remove(timeoutlist, e, ((Object)0));
				return ;
			} 
		}
	}
	public static  multi_addtimeout(Object data, Object stamp,  eid) {
		curl_llist_element e = new curl_llist_element();
		time_node node = new time_node();
		curl_llist_element prev = ((Object)0);
		size_t n = new size_t();
		curl_llist timeoutlist = data.getState().getTimeoutlist();
		node = data.getState().getExpires()[eid];
		.memcpy(node.getTime(), stamp, );
		node.setEid(/* also marks it as in use */eid);
		n = ModernizedCProgram.Curl_llist_count(timeoutlist);
		if (n) {
			for (e = timeoutlist.getHead(); e; e = e.getNext()) {
				time_node check = (time_node)e.getPtr();
				timediff_t diff = check.getTime().Curl_timediff(node.getTime());
				if (diff > 0) {
					break;
				} 
				prev = e;
			}
		} 
		ModernizedCProgram.Curl_llist_insert_next(timeoutlist, prev, node, node.getList());
		return .CURLM_OK/*
		 * Curl_expire()
		 *
		 * given a number of milliseconds from now to use to set the 'act before
		 * this'-time for the transfer, to be extracted by curl_multi_timeout()
		 *
		 * The timeout will be added to a queue of timeouts if it defines a moment in
		 * time that is later than the current head of queue.
		 *
		 * Expire replaces a former timeout using the same id if already set.
		 */;
	}
	public static void Curl_expire(Object data, Object milli,  id) {
		Curl_multi multi = data.getMulti();
		curltime nowp = data.getState().getExpiretime();
		curltime set = new curltime();
		if (!/* this is only interesting while there is still an associated multi struct
		     remaining! */multi) {
			return ;
		} 
		do {
		} while (0);
		curltime curltime = new curltime();
		set = curltime.Curl_now();
		Object generatedTv_sec = set.getTv_sec();
		generatedTv_sec += (time_t)(milli / /* might be a 64 to 32 bit conversion */1000);
		int generatedTv_usec = set.getTv_usec();
		generatedTv_usec += (int)(milli % 1000) * 1000;
		if (generatedTv_usec >= 1000000) {
			generatedTv_sec++;
			generatedTv_usec -= 1000000;
		} 
		ModernizedCProgram.multi_deltimeout(data, /* Remove any timer with the same id just in case. */id);
		ModernizedCProgram.multi_addtimeout(data, set, /* Add it to the timer list.  It must stay in the list until it has expired
		     in case we need to recompute the minimum timer later. */id);
		if (generatedTv_sec || generatedTv_usec) {
			timediff_t diff = set.Curl_timediff(nowp);
			int rc;
			if (diff > 0/* The current splay tree entry is sooner than this new expiry time.
			         We don't need to update our splay tree entry. */) {
				return ;
			} 
			rc = ModernizedCProgram.Curl_splayremovebyaddr(multi.getTimetree(), data.getState().getTimenode(), multi.getTimetree());
			if (rc) {
				ModernizedCProgram.Curl_infof(data, "Internal error removing splay node = %d\n", rc);
			} 
		} 
		nowp = /* Indicate that we are in the splay tree and insert the new timer expiry
		     value since it is our local minimum. */set;
		data.getState().getTimenode().setPayload(data);
		multi.setTimetree(nowp.Curl_splayinsert(multi.getTimetree(), data.getState().getTimenode()));
	}
	public static void Curl_expire_done(Object data,  id) {
		ModernizedCProgram.multi_deltimeout(data, /* remove the timer, if there */id/*
		 * Curl_expire_clear()
		 *
		 * Clear ALL timeout values for this handle.
		 */);
	}
	public static void Curl_expire_clear(Object data) {
		Curl_multi multi = data.getMulti();
		curltime nowp = data.getState().getExpiretime();
		if (!/* this is only interesting while there is still an associated multi struct
		     remaining! */multi) {
			return ;
		} 
		if (nowp.getTv_sec() || nowp.getTv_usec()) {
			curl_llist list = data.getState().getTimeoutlist();
			int rc;
			rc = ModernizedCProgram.Curl_splayremovebyaddr(multi.getTimetree(), data.getState().getTimenode(), multi.getTimetree());
			if (rc) {
				ModernizedCProgram.Curl_infof(data, "Internal error clearing splay node = %d\n", rc);
			} 
			while (list.getSize() > /* flush the timeout list too */0) {
				ModernizedCProgram.Curl_llist_remove(list, list.getTail(), ((Object)0));
			}
			nowp.setTv_sec(0);
			nowp.setTv_usec(0);
		} 
	}
	public static  curl_multi_assign(Object multi, Object s, Object hashp) {
		Curl_sh_entry there = ((Object)0);
		if (multi.getIn_callback()) {
			return .CURLM_RECURSIVE_API_CALL;
		} 
		there = ModernizedCProgram.sh_getentry(multi.getSockhash(), s);
		if (!there) {
			return .CURLM_BAD_SOCKET;
		} 
		there.setSocketp(hashp);
		return .CURLM_OK;
	}
	public static Object Curl_multi_max_host_connections(Object multi) {
		return multi ? multi.getMax_host_connections() : 0;
	}
	public static Object Curl_multi_max_total_connections(Object multi) {
		return multi ? multi.getMax_total_connections() : 0/*
		 * When information about a connection has appeared, call this!
		 */;
	}
	public static void Curl_multiuse_state(Object conn, int bundlestate) {
		do {
		} while (0);
		do {
		} while (0);
		do {
		} while (0);
		do {
		} while (0);
		conn.getBundle().setMultiuse(bundlestate);
		ModernizedCProgram.process_pending_handles(conn.getData().getMulti());
	}
	/* use BUNDLE_* defines */
	public static void process_pending_handles(Object multi) {
		curl_llist_element e = multi.getPending().getHead();
		if (e) {
			Curl_easy data = e.getPtr();
			do {
			} while (0);
			ModernizedCProgram.mstate(data, .CURLM_STATE_CONNECT);
			ModernizedCProgram.Curl_llist_remove(multi.getPending(), e, ((Object)/* Remove this node from the list */0));
			ModernizedCProgram.Curl_expire(data, 0, /* Make sure that the handle will be processed soonish. */.EXPIRE_RUN_NOW);
			data.getState().setPreviouslypending(/* mark this as having been in the pending queue */1);
		} 
	}
	public static void Curl_set_in_callback(Object data,  value) {
		if (/* might get called when there is no data pointer! */data) {
			if (data.getMulti_easy()) {
				data.getMulti_easy().setIn_callback(value);
			}  else if (data.getMulti()) {
				data.getMulti().setIn_callback(value);
			} 
		} 
	}
	public static  Curl_is_in_callback(Object easy) {
		return ((easy.getMulti() && easy.getMulti().getIn_callback()) || (easy.getMulti_easy() && easy.getMulti_easy().getIn_callback()));
	}
	public static Object Curl_multi_max_concurrent_streams(Object multi) {
		return multi ? ((size_t)multi.getMax_concurrent_streams() ? (size_t)multi.getMax_concurrent_streams() : 100) : 0;
	}
	public static int Curl_wait_ms(int timeout_ms) {
		int r = 0;
		if (!timeout_ms) {
			return 0;
		} 
		if (timeout_ms < 0) {
			(.WSASetLastError((int)(true)));
			return -1;
		} 
		.Sleep(timeout_ms/* HAVE_POLL_FINE */);
		if (/* Simulate a "call timed out" case *//* USE_WINSOCK */r) {
			r = -1;
		} 
		return r/*
		 * Wait for read or write events on a set of file descriptors. It uses poll()
		 * when a fine poll() is available, in order to avoid limits with FD_SETSIZE,
		 * otherwise select() is used.  An error is returned if select() is being used
		 * and a file descriptor is too large for FD_SETSIZE.
		 *
		 * A negative timeout value makes this function wait indefinitely,
		 * unless no valid file descriptor is given, when this happens the
		 * negative timeout is ignored and the function times out immediately.
		 *
		 * Return values:
		 *   -1 = system call error or fd >= FD_SETSIZE
		 *    0 = timeout
		 *    [bitmask] = action as described below
		 *
		 * CURL_CSELECT_IN - first socket is readable
		 * CURL_CSELECT_IN2 - second socket is readable
		 * CURL_CSELECT_OUT - write socket is writable
		 * CURL_CSELECT_ERR - an error condition occurred
		 */;
	}
	/* two sockets to read from */
	public static int Curl_socket_check(Object readfd0, Object readfd1, Object writefd, Object timeout_ms) {
		timeval pending_tv = new timeval();
		timeval ptimeout = new timeval();
		fd_set fds_read = new fd_set();
		fd_set fds_write = new fd_set();
		fd_set fds_err = new fd_set();
		curl_socket_t maxfd = new curl_socket_t();
		curltime initial_tv = new curltime(0, 0);
		int pending_ms = 0;
		int r;
		int ret;
		/* wrap-around precaution */
		if ((readfd0 == (SOCKET)(~0)) && (readfd1 == (SOCKET)(~0)) && (writefd == (SOCKET)(~0))) {
			r = ModernizedCProgram.Curl_wait_ms((int)/* no sockets, just wait */timeout_ms);
			return r/* Avoid initial timestamp, avoid Curl_now() call, when elapsed
			     time in this function does not need to be measured. This happens
			     when function is called with a zero timeout or a negative timeout
			     value indicating a blocking call should be performed. */;
		} 
		curltime curltime = new curltime();
		if (timeout_ms > 0) {
			pending_ms = (int)timeout_ms;
			initial_tv = curltime.Curl_now();
		} 
		(((fd_set)(fds_err)).setFd_count(/* Simulate a "call timed out" case *//* HAVE_POLL_FINE */0));
		maxfd = (curl_socket_t)-1;
		(((fd_set)(fds_read)).setFd_count(0));
		if (readfd0 != (SOCKET)(~0)) {
			do {
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
					if (((fd_set)(fds_read)).getFd_array()[__i] == (readfd0)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_read)).getFd_count()) {
					if (((fd_set)(fds_read)).getFd_count() < 64) {
						((fd_set)(fds_read)).getFd_array()[__i] = (readfd0);
						((fd_set)(fds_read)).getFd_count()++;
					} 
				} 
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_err)).getFd_count(); __i++) {
					if (((fd_set)(fds_err)).getFd_array()[__i] == (readfd0)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_err)).getFd_count()) {
					if (((fd_set)(fds_err)).getFd_count() < 64) {
						((fd_set)(fds_err)).getFd_array()[__i] = (readfd0);
						((fd_set)(fds_err)).getFd_count()++;
					} 
				} 
			} while (0);
			maxfd = readfd0;
		} 
		if (readfd1 != (SOCKET)(~0)) {
			do {
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
					if (((fd_set)(fds_read)).getFd_array()[__i] == (readfd1)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_read)).getFd_count()) {
					if (((fd_set)(fds_read)).getFd_count() < 64) {
						((fd_set)(fds_read)).getFd_array()[__i] = (readfd1);
						((fd_set)(fds_read)).getFd_count()++;
					} 
				} 
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_err)).getFd_count(); __i++) {
					if (((fd_set)(fds_err)).getFd_array()[__i] == (readfd1)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_err)).getFd_count()) {
					if (((fd_set)(fds_err)).getFd_count() < 64) {
						((fd_set)(fds_err)).getFd_array()[__i] = (readfd1);
						((fd_set)(fds_err)).getFd_count()++;
					} 
				} 
			} while (0);
			if (readfd1 > maxfd) {
				maxfd = readfd1;
			} 
		} 
		(((fd_set)(fds_write)).setFd_count(0));
		if (writefd != (SOCKET)(~0)) {
			do {
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_write)).getFd_count(); __i++) {
					if (((fd_set)(fds_write)).getFd_array()[__i] == (writefd)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_write)).getFd_count()) {
					if (((fd_set)(fds_write)).getFd_count() < 64) {
						((fd_set)(fds_write)).getFd_array()[__i] = (writefd);
						((fd_set)(fds_write)).getFd_count()++;
					} 
				} 
			} while (0);
			do {
				u_int __i = new u_int();
				for (__i = 0; __i < ((fd_set)(fds_err)).getFd_count(); __i++) {
					if (((fd_set)(fds_err)).getFd_array()[__i] == (writefd)) {
						break;
					} 
				}
				if (__i == ((fd_set)(fds_err)).getFd_count()) {
					if (((fd_set)(fds_err)).getFd_count() < 64) {
						((fd_set)(fds_err)).getFd_array()[__i] = (writefd);
						((fd_set)(fds_err)).getFd_count()++;
					} 
				} 
			} while (0);
			if (writefd > maxfd) {
				maxfd = writefd;
			} 
		} 
		ptimeout = (timeout_ms < 0) ? ((Object)0) : pending_tv;
		Object generatedFd_count = fds_read.getFd_count();
		do {
			int error;
			if (timeout_ms > 0) {
				pending_tv.setTv_sec(pending_ms / 1000);
				pending_tv.setTv_usec((pending_ms % 1000) * 1000);
			}  else if (!timeout_ms) {
				pending_tv.setTv_sec(0);
				pending_tv.setTv_usec(0/* WinSock select() must not be called with an fd_set that contains zero
				       fd flags, or it will return WSAEINVAL.  But, it also can't be called
				       with no fd_sets at all!  From the documentation:
				
				         Any two of the parameters, readfds, writefds, or exceptfds, can be
				         given as null. At least one must be non-null, and any non-null
				         descriptor set must contain at least one handle to a socket.
				
				       We know that we have at least one bit set in at least two fd_sets in
				       this case, but we may have no bits set in either fds_read or fd_write,
				       so check for that and handle it.  Luckily, with WinSock, we can _also_
				       ask how many bits are set on an fd_set.
				
				       It is unclear why WinSock doesn't just handle this for us instead of
				       calling this an error.
				
				       Note also that WinSock ignores the first argument, so we don't worry
				       about the fact that maxfd is computed incorrectly with WinSock (since
				       curl_socket_t is unsigned in such cases and thus -1 is the largest
				       value).
				    */);
			} 
			r = .select((int)maxfd + 1, generatedFd_count ? fds_read : ((Object)0), generatedFd_count ? fds_write : ((Object)0), fds_err, ptimeout);
			if (r != -1) {
				break;
			} 
			error = ((int).WSAGetLastError());
			if (error && (ModernizedCProgram.Curl_ack_eintr || error != -1024)) {
				break;
			} 
			if (timeout_ms > 0) {
				pending_ms = (int)(timeout_ms - (int)curltime.Curl_now().Curl_timediff(initial_tv));
				if (pending_ms <= 0) {
					r = /* Simulate a "call timed out" case */0;
					break;
				} 
			} 
		} while (r == -1);
		if (r < 0) {
			return -1;
		} 
		if (r == 0) {
			return 0;
		} 
		ret = 0;
		if (readfd0 != (SOCKET)(~0)) {
			if (.__WSAFDIsSet((SOCKET)(readfd0), (fd_set)(fds_read))) {
				ret |=  -1024;
			} 
			if (.__WSAFDIsSet((SOCKET)(readfd0), (fd_set)(fds_err))) {
				ret |=  -1024;
			} 
		} 
		if (readfd1 != (SOCKET)(~0)) {
			if (.__WSAFDIsSet((SOCKET)(readfd1), (fd_set)(fds_read))) {
				ret |=  (-1024 << 1);
			} 
			if (.__WSAFDIsSet((SOCKET)(readfd1), (fd_set)(fds_err))) {
				ret |=  -1024;
			} 
		} 
		if (writefd != (SOCKET)(~0)) {
			if (.__WSAFDIsSet((SOCKET)(writefd), (fd_set)(fds_write))) {
				ret |=  -1024;
			} 
			if (.__WSAFDIsSet((SOCKET)(writefd), (fd_set)(fds_err))) {
				ret |=  -1024;
			} 
		} 
		return ret/* HAVE_POLL_FINE *//*
		 * This is a wrapper around poll().  If poll() does not exist, then
		 * select() is used instead.  An error is returned if select() is
		 * being used and a file descriptor is too large for FD_SETSIZE.
		 * A negative timeout value makes this function wait indefinitely,
		 * unless no valid file descriptor is given, when this happens the
		 * negative timeout is ignored and the function times out immediately.
		 *
		 * Return values:
		 *   -1 = system call error or fd >= FD_SETSIZE
		 *    0 = timeout
		 *    N = number of structures with non zero revent fields
		 */;
	}
	/* socket to write to */
	/* milliseconds to wait */
	public static int Curl_poll(Object ufds, int nfds, int timeout_ms) {
		timeval pending_tv = new timeval();
		timeval ptimeout = new timeval();
		fd_set fds_read = new fd_set();
		fd_set fds_write = new fd_set();
		fd_set fds_err = new fd_set();
		curl_socket_t maxfd = new curl_socket_t();
		curltime initial_tv = new curltime(0, 0);
		bool fds_none = 1;
		int i;
		int pending_ms = 0;
		int r;
		if (ufds) {
			for (i = 0; i < nfds; i++) {
				if (ufds[i].getFd() != (SOCKET)(~0)) {
					fds_none = 0;
					break;
				} 
			}
		} 
		if (fds_none) {
			r = ModernizedCProgram.Curl_wait_ms(timeout_ms);
			return r/* Avoid initial timestamp, avoid Curl_now() call, when elapsed
			     time in this function does not need to be measured. This happens
			     when function is called with a zero timeout or a negative timeout
			     value indicating a blocking call should be performed. */;
		} 
		curltime curltime = new curltime();
		if (timeout_ms > 0) {
			pending_ms = timeout_ms;
			initial_tv = curltime.Curl_now();
		} 
		(((fd_set)(fds_read)).setFd_count(/* HAVE_POLL_FINE */0));
		(((fd_set)(fds_write)).setFd_count(0));
		(((fd_set)(fds_err)).setFd_count(0));
		maxfd = (curl_socket_t)-1;
		for (i = 0; i < nfds; i++) {
			ufds[i].setRevents(0);
			if (ufds[i].getFd() == (SOCKET)(~0)) {
				continue;
			} 
			do {
			} while (0);
			if (ufds[i].getEvents() & (-1024 | -1024 | -1024 | -1024 | -1024 | -1024)) {
				if (ufds[i].getFd() > maxfd) {
					maxfd = ufds[i].getFd();
				} 
				if (ufds[i].getEvents() & (-1024 | -1024)) {
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(fds_read)).getFd_count(); __i++) {
							if (((fd_set)(fds_read)).getFd_array()[__i] == (ufds[i].getFd())) {
								break;
							} 
						}
						if (__i == ((fd_set)(fds_read)).getFd_count()) {
							if (((fd_set)(fds_read)).getFd_count() < 64) {
								((fd_set)(fds_read)).getFd_array()[__i] = (ufds[i].getFd());
								((fd_set)(fds_read)).getFd_count()++;
							} 
						} 
					} while (0);
				} 
				if (ufds[i].getEvents() & (-1024 | -1024)) {
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(fds_write)).getFd_count(); __i++) {
							if (((fd_set)(fds_write)).getFd_array()[__i] == (ufds[i].getFd())) {
								break;
							} 
						}
						if (__i == ((fd_set)(fds_write)).getFd_count()) {
							if (((fd_set)(fds_write)).getFd_count() < 64) {
								((fd_set)(fds_write)).getFd_array()[__i] = (ufds[i].getFd());
								((fd_set)(fds_write)).getFd_count()++;
							} 
						} 
					} while (0);
				} 
				if (ufds[i].getEvents() & (-1024 | -1024)) {
					do {
						u_int __i = new u_int();
						for (__i = 0; __i < ((fd_set)(fds_err)).getFd_count(); __i++) {
							if (((fd_set)(fds_err)).getFd_array()[__i] == (ufds[i].getFd())) {
								break;
							} 
						}
						if (__i == ((fd_set)(fds_err)).getFd_count()) {
							if (((fd_set)(fds_err)).getFd_count() < 64) {
								((fd_set)(fds_err)).getFd_array()[__i] = (ufds[i].getFd());
								((fd_set)(fds_err)).getFd_count()++;
							} 
						} 
					} while (0);
				} 
			} 
		}
		Object generatedFd_count = fds_read.getFd_count();
		if (generatedFd_count == 0 && generatedFd_count == /* WinSock select() can't handle zero events.  See the comment about this in
		     Curl_check_socket(). */0 && generatedFd_count == 0) {
			r = ModernizedCProgram.Curl_wait_ms(timeout_ms);
			return r;
		} 
		ptimeout = (timeout_ms < 0) ? ((Object)0) : pending_tv;
		do {
			int error;
			if (timeout_ms > 0) {
				pending_tv.setTv_sec(pending_ms / 1000);
				pending_tv.setTv_usec((pending_ms % 1000) * 1000);
			}  else if (!timeout_ms) {
				pending_tv.setTv_sec(0);
				pending_tv.setTv_usec(0);
			} 
			r = .select((int)maxfd + 1/* WinSock select() can't handle fd_sets with zero bits set, so
			                  don't give it such arguments.  See the comment about this in
			                  Curl_check_socket().
			               */, generatedFd_count ? fds_read : ((Object)0), generatedFd_count ? fds_write : ((Object)0), generatedFd_count ? fds_err : ((Object)0), ptimeout);
			if (r != -1) {
				break;
			} 
			error = ((int).WSAGetLastError());
			if (error && (ModernizedCProgram.Curl_ack_eintr || error != -1024)) {
				break;
			} 
			if (timeout_ms > 0) {
				pending_ms = timeout_ms - (int)curltime.Curl_now().Curl_timediff(initial_tv);
				if (pending_ms <= 0) {
					r = /* Simulate a "call timed out" case */0;
					break;
				} 
			} 
		} while (r == -1);
		if (r < 0) {
			return -1;
		} 
		if (r == 0) {
			return 0;
		} 
		r = 0;
		for (i = 0; i < nfds; i++) {
			ufds[i].setRevents(0);
			if (ufds[i].getFd() == (SOCKET)(~0)) {
				continue;
			} 
			if (.__WSAFDIsSet((SOCKET)(ufds[i].getFd()), (fd_set)(fds_read))) {
				ufds[i].getRevents() |=  -1024;
			} 
			if (.__WSAFDIsSet((SOCKET)(ufds[i].getFd()), (fd_set)(fds_write))) {
				ufds[i].getRevents() |=  -1024;
			} 
			if (.__WSAFDIsSet((SOCKET)(ufds[i].getFd()), (fd_set)(fds_err))) {
				ufds[i].getRevents() |=  -1024;
			} 
			if (ufds[i].getRevents() != 0) {
				r++;
			} 
		}
		return /* HAVE_POLL_FINE */r/*
		 * This is a replacement for select() on the TPF platform.
		 * It is used whenever libcurl calls select().
		 * The call below to tpf_process_signals() is required because
		 * TPF's select calls are not signal interruptible.
		 *
		 * Return values are the same as select's.
		 *//* TPF */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2014, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* keep this as LAST include */
	public static void set_binmode(Object stream) {
		(Object).setmode(((stream).get_file()), -1024/* HAVE_SETMODE */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* nghttp2_session_callbacks_set_error_callback is present in nghttp2 1.9.0 or
	   later */
	/*
	 * Curl_http2_init_state() is called when the easy handle is created and
	 * allows for HTTP/2 specific init of state.
	 */
	/*
	 * Curl_http2_init_userset() is called when the easy handle is created and
	 * allows for HTTP/2 specific user-set fields.
	 */
	/* in a HTTP/2 connection we can basically always get a frame so we should
	     always be ready for one */
	/* we're still uploading or the HTTP/2 layer wants to send data */
	/*
	 * http2_stream_free() free HTTP2 stream related data
	 */
	/*
	 * Disconnects *a* connection used for HTTP/2. It might be an old one from the
	 * connection cache and not the "main" one. Don't touch the easy handle!
	 */
	/*
	 * The server may send us data at any point (e.g. PING frames). Therefore,
	 * we cannot assume that an HTTP/2 socket is dead just because it is readable.
	 *
	 * Instead, if it is readable, run Curl_connalive() to peek at the socket
	 * and distinguish between closed and data.
	 */
	/* timeout */
	/* socket is in an error state */
	/* readable with no error. could still be closed */
	/* This happens before we've sent off a request and the connection is
	         not in use by any other transfer, there shouldn't be any data here,
	         only "protocol frames" */
	/* if called "too early", this pointer isn't setup yet! */
	/* the read failed so let's say this is dead anyway */
	/* Perform an HTTP/2 PING */
	/* Successfully added a PING frame to the session. Need to flag this
	           so the frame is sent. */
	/* called from http_setup_conn */
	/* called from http_setup_conn */
	/*
	 * HTTP2 handler interface. This isn't added to the general list of protocols
	 * but will be used at run-time when the protocol is dynamically switched from
	 * HTTP to HTTP2.
	 */
	/* scheme */
	/* setup_connection */
	/* do_it */
	/* done */
	/* do_more */
	/* connect_it */
	/* connecting */
	/* doing */
	/* proto_getsock */
	/* doing_getsock */
	/* domore_getsock */
	/* perform_getsock */
	/* disconnect */
	/* readwrite */
	/* connection_check */
	/* defport */
	/* protocol */
	/* flags */
	/* scheme */
	/* setup_connection */
	/* do_it */
	/* done */
	/* do_more */
	/* connect_it */
	/* connecting */
	/* doing */
	/* proto_getsock */
	/* doing_getsock */
	/* domore_getsock */
	/* perform_getsock */
	/* disconnect */
	/* readwrite */
	/* connection_check */
	/* defport */
	/* protocol */
	/* flags */
	/*
	 * Store nghttp2 version info in this buffer, Prefix with a space.  Return
	 * total length written.
	 */
	/* HTTP/2 error code to name based on the Error Code Registry.
	https://tools.ietf.org/html/rfc7540#page-77
	nghttp2_error_code enums are identical.
	*/
	/* 0x0 */
	/* 0x1 */
	/* 0x2 */
	/* 0x3 */
	/* 0x4 */
	/* 0x5 */
	/* 0x6 */
	/* 0x7 */
	/* 0x8 */
	/* 0x9 */
	/* 0xA */
	/* 0xB */
	/* 0xC */
	/* 0xD */
	/*
	 * The implementation of nghttp2_send_callback type. Here we write |data| with
	 * size |length| to the network and return the number of bytes actually
	 * written. See the documentation of nghttp2_send_callback for the details.
	 */
	/* called before setup properly! */
	/* We pass a pointer to this struct in the push callback, but the contents of
	   the struct are hidden from the user. */
	/*
	 * push header access function. Only to be used from within the push callback
	 */
	/* Verify that we got a good easy handle in the push header struct, mostly to
	     detect rubbish input fast(er). */
	/*
	 * push header access function. Only to be used from within the push callback
	 */
	/* Verify that we got a good easy handle in the push header struct,
	     mostly to detect rubbish input fast(er). Also empty header name
	     is just a rubbish too. We have to allow ":" at the beginning of
	     the header, but header == ":" must be rejected. If we have ':' in
	     the middle of header, it could be matched in middle of the value,
	     this is because we do prefix match.*/
	/* sub-match, make sure that it is followed by a colon */
	/*
	 * This specific transfer on this connection has been "drained".
	 */
	/*
	 * Mark this transfer to get "drained".
	 */
	/* setup the request struct */
	/* clone the parent */
	/* FAIL HARD */
	/* ask the application */
	/* free the headers again */
	/* denied, kill off the new handle again */
	/* approved, add to the multi handle and immediately switch to PERFORM
	       state with the given connection !*/
	/*
	 * multi_connchanged() is called to tell that there is a connection in
	 * this multi handle that has changed state (multiplexing become possible, the
	 * number of allowed streams changed or similar), and a subsequent use of this
	 * multi handle should move CONNECT_PEND handles back to CONNECT to have them
	 * retry.
	 */
	/* stream ID zero is for connection-oriented stuff */
	/* only signal change if the value actually changed */
	/* If body started on this stream, then receiving DATA is illegal. */
	/* Only valid HEADERS after body started is trailer HEADERS.  We
	         buffer them in on_header callback. */
	/* nghttp2 guarantees that :status is received, and we store it to
	       stream->status_code. Fuzzing has proven this can still be reached
	       without status code having been set. */
	/* Only final status code signals the end of header */
	/* get the pointer from userp again since it was re-assigned above */
	/* if we receive data for another handle, wake that up */
	/* deny! */
	/* should never be a zero stream ID here */
	/* get the stream from the hash based on Stream ID */
	/* Receiving a Stream ID not in the hash should not happen, this is an
	       internal error more than anything else! */
	/* if we receive data for another handle, wake that up */
	/* pause execution of nghttp2 if we received data for another handle
	     in order to process them first. */
	/* get the stream from the hash based on Stream ID, stream ID zero is for
	       connection-oriented stuff */
	/* We could get stream ID not in the hash.  For example, if we
	         decided to reject stream (e.g., PUSH_PROMISE). */
	/* remove the entry from the hash as the stream is now gone */
	/* cleared */
	/* Decode HTTP status code.  Returns -1 if no valid status code was
	   decoded. */
	/* frame->hd.type is either NGHTTP2_HEADERS or NGHTTP2_PUSH_PROMISE */
	/* should never be a zero stream ID here */
	/* get the stream from the hash based on Stream ID */
	/* Receiving a Stream ID not in the hash should not happen, this is an
	       internal error more than anything else! */
	/* Store received PUSH_PROMISE headers to be used when the subsequent
	     PUSH_PROMISE callback comes */
	/* pseudo headers are lower case */
	/* no memory */
	/* This is push is not for the same authority that was asked for in
	         * the URL. RFC 7540 section 8.2 says: "A client MUST treat a
	         * PUSH_PROMISE for which the server is not authoritative as a stream
	         * error of type PROTOCOL_ERROR."
	         */
	/* This is trailer fields. */
	/* 4 is for ": " and "\r\n". */
	/* nghttp2 guarantees :status is received first and only once, and
	       value is 3 digits status code, and decode_status_code always
	       succeeds. */
	/* the space character after the status code is mandatory */
	/* if we receive data for another handle, wake that up */
	/* nghttp2 guarantees that namelen > 0, and :status was already
	     received, and this is not pseudo-header field . */
	/* convert to a HTTP1-style header */
	/* if we receive data for another handle, wake that up */
	/* 0 is successful */
	/* get the stream from the hash based on Stream ID, stream ID zero is for
	       connection-oriented stuff */
	/* Receiving a Stream ID not in the hash should not happen, this is an
	         internal error more than anything else! */
	/* there might be allocated resources done before this got the 'h2' pointer
	     setup */
	/* if they weren't used and then freed before */
	/* not HTTP/2 ? */
	/* RST_STREAM */
	/* -1 means unassigned and 0 means cleared */
	/*
	 * Initialize nghttp2 for a Curl connection
	 */
	/* most likely at least */
	/* nghttp2_send_callback */
	/* nghttp2_on_frame_recv_callback */
	/* nghttp2_on_data_chunk_recv_callback */
	/* nghttp2_on_stream_close_callback */
	/* nghttp2_on_begin_headers_callback */
	/* nghttp2_on_header_callback */
	/* The nghttp2 session is not yet setup, do it */
	/* most likely at least */
	/*
	 * Append headers to ask for a HTTP1.1 to HTTP2 upgrade.
	 */
	/* this returns number of bytes it wrote */
	/*
	 * Returns nonzero if current HTTP/2 session should be closed.
	 */
	/*
	 * h2_process_pending_input() processes pending input left in
	 * httpc->inbuf.  Then, call h2_session_send() to send pending data.
	 * This function returns 0 if it succeeds, or -1 and error code will
	 * be assigned to *err.
	 */
	/* not an error per se, but should still close the connection */
	/*
	 * Called from transfer.c:done_sending when we stop uploading.
	 */
	/* make sure this is only attempted for HTTP/2 transfers */
	/* If the stream still thinks there's data left to upload. */
	/* DONE! */
	/* resume sending here to trigger the callback to get called again so
	         that it can signal EOF to nghttp2 */
	/* Reset to FALSE to prevent infinite loop in readwrite_data function. */
	/* don't use this anymore */
	/* trigger Curl_retry_request() later */
	/*
	 * h2_pri_spec() fills in the pri_spec struct, used by nghttp2 to send weight
	 * and dependency to the peer. It also stores the updated values in the state
	 * struct.
	 */
	/*
	 * h2_session_send() checks if there's been an update in the priority /
	 * dependency settings and if so it submits a PRIORITY frame with the updated
	 * info.
	 */
	/* send new weight and/or dependency */
	/* we always do HTTP2 on sockindex 0 */
	/* already marked for closure, return OK and we're done */
	/* Nullify here because we call nghttp2_session_send() and they
	     might refer to the old buffer. */
	/*
	   * At this point 'stream' is just in the Curl_easy the connection
	   * identifies as its owner at this time.
	   */
	/* If there is body data pending for this stream to return, do that */
	/* if we didn't get the same buffer this time, we must move the data to
	         the beginning */
	/* We have paused nghttp2, but we have no pause data (see
	         on_data_chunk_recv). */
	/* When NGHTTP2_ERR_PAUSE is returned from
	         data_source_read_callback, we might not process DATA frame
	         fully.  Calling nghttp2_session_mem_recv() again will
	         continue to process DATA frame, but if there is no incoming
	         frames, then we have to call it again with 0-length data.
	         Without this, on_stream_close callback will not be called,
	         and stream could be hanged. */
	/* If a stream paused nghttp2_session_mem_recv previously, and has
	       not processed all data, it still refers to the buffer in
	       nghttp2_session.  If we call nghttp2_session_mem_recv(), we may
	       overwrite that buffer.  To avoid that situation, just return
	       here with CURLE_AGAIN.  This could be busy loop since data in
	       socket is not read.  But it seems that usually streams are
	       notified with its drain property, and socket is read again
	       quickly. */
	/* closed overrides paused */
	/* remember where to store incoming data for this stream and how big the
	       buffer is */
	/* received when the stream was already closed! */
	/* Always send pending frames in nghttp2 session, because
	       nghttp2_session_mem_recv() may queue new frame */
	/* data for this stream is returned now, but this stream caused a pause
	         already so we need it called again asap */
	/* this stream is closed, trigger a another read ASAP to detect that */
	/* If this stream is closed, return 0 to signal the http routine to close
	     the connection */
	/* Index where :authority header field will appear in request header
	   field list. */
	/* USHRT_MAX is 65535 == 0xffff */
	/*
	 * Check header memory for the token "trailers".
	 * Parse the tokens as separated by comma and surrounded by whitespace.
	 * Returns TRUE if found or FALSE if not.
	 */
	/* skip to next token */
	/* Send header to server */
	/* Don't send header to server */
	/* Discard header, and replace it with "te: trailers" */
	/* Decides how to treat given header field. */
	/*
	   * Currently, we send request in this function, but this function is also
	   * used to send request body. It would be nice to add dedicated function for
	   * request.
	   */
	/* If stream_id != -1, we have dispatched request HEADERS, and now
	       are going to send or sending request body in DATA frame */
	/* Nullify here because we call nghttp2_session_send() and they
	       might refer to the old buffer. */
	/* we are sure that we have more data to send here.  Calling the
	         following API will make nghttp2_session_want_write() return
	         nonzero if remote window allows it, which then libcurl checks
	         socket is writable or not.  See http2_perform_getsock(). */
	/* Calculate number of headers contained in [mem, mem + len) */
	/* Here, we assume the curl http code generate *correct* HTTP header
	     field block */
	/* We counted additional 2 \r\n in the first and last line. We need 3
	     new headers: :method, :path and :scheme. Therefore we need one
	     more space. */
	/* Extract :method, :path from request line
	     We do line endings with CRLF so checking for CR is enough */
	/* Method does not contain spaces */
	/* Path may contain spaces so scan backwards */
	/* check for next CR, but only within the piece of data left in the given
	       buffer */
	/* header continuation lines are not supported */
	/* Lower case the header name for HTTP/2 */
	/* skip header fields prohibited by HTTP/2 specification. */
	/* :authority must come before non-pseudo header fields */
	/* Warn stream may be rejected if cumulative length of headers is too large.
	     It appears nghttp2 will not send a header frame larger than 64KB. */
	/* <64KB to account for some overhead */
	/* data sending without specifying the data amount up front */
	/* unknown, but not zero */
	/* this does not call h2_session_send() since there can not have been any
	   * priority upodate since the nghttp2_submit_request() call above */
	/* If whole HEADERS frame was sent off to the underlying socket, the nghttp2
	     library calls data_source_read_callback. But only it found that no data
	     available, so it deferred the DATA transmission. Which means that
	     nghttp2_session_want_write() returns 0 on http2_perform_getsock(), which
	     results that no writable socket check is performed. To workaround this,
	     we issue nghttp2_session_resume_data() here to bring back DATA
	     transmission from deferred state. */
	/* already done */
	/* at least potentially multiplexed */
	/* stream 1 is opened implicitly on upgrade */
	/* queue SETTINGS frame (again) */
	/* stream ID is unknown at this point */
	/* we are going to copy mem to httpc->inbuf.  This is required since
	     mem is part of buffer pointed by stream->mem, and callbacks
	     called by nghttp2_session_mem_recv() will write stream specific
	     data into stream->mem, overwriting data already there. */
	/* Try to send some frames since we may read SETTINGS already. */
	/* Only call this function for a transfer that already got a HTTP/2
	   CURLE_HTTP2_STREAM error! */
	/* !USE_NGHTTP2 */
	/* Satisfy external references even if http2 is not compiled in. */
	public static Object curl_pushheader_bynum(Object h, Object num) {
		(Object)h;
		(Object)num;
		return ((Object)0);
	}
	public static Object curl_pushheader_byname(Object h, Object header) {
		(Object)h;
		(Object)header;
		return ((Object)0/* USE_NGHTTP2 */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2015, 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	public static void voutf(Object config, Object prefix, Object fmt, Object ap) {
		size_t width = (79 - .strlen(prefix));
		if (!config.getMute()) {
			size_t len = new size_t();
			byte ptr;
			byte print_buffer;
			print_buffer = ModernizedCProgram.curl_mvaprintf(fmt, ap);
			if (!print_buffer) {
				return ;
			} 
			len = .strlen(print_buffer);
			ptr = print_buffer;
			while (len > 0) {
				.fputs(prefix, config.getErrors());
				if (len > width) {
					size_t cut = width - 1;
					while (!(ModernizedCProgram.Curl_isspace((int)((byte)ptr[cut]))) && cut) {
						cut--;
					}
					if (0 == cut/* not a single cutting position was found, just cut it at the
					             max text width then! */) {
						cut = width - 1;
					} 
					(Object).fwrite(ptr, cut + 1, 1, config.getErrors());
					.fputs("\n", config.getErrors());
					ptr += cut + /* skip the space too */1;
					len -= cut + 1;
				} else {
						.fputs(ptr, config.getErrors());
						len = 0;
				} 
			}
			ModernizedCProgram.curl_free(print_buffer/*
			 * Emit 'note' formatted message on configured 'errors' stream, if verbose was
			 * selected.
			 */);
		} 
	}
	public static void notef(Object config, Object fmt) {
		va_list ap = new va_list();
		.__builtin_va_start(ap, fmt);
		if (config.getTracetype()) {
			ModernizedCProgram.voutf(config, "Note: ", fmt, ap);
		} 
		.__builtin_va_end(ap/*
		 * Emit warning formatted message on configured 'errors' stream unless
		 * mute (--silent) was selected.
		 */);
	}
	public static void warnf(Object config, Object fmt) {
		va_list ap = new va_list();
		.__builtin_va_start(ap, fmt);
		ModernizedCProgram.voutf(config, "Warning: ", fmt, ap);
		.__builtin_va_end(ap/*
		 * Emit help formatted message on given stream.
		 */);
	}
	public static void helpf(Object errors, Object fmt) {
		if (fmt) {
			va_list ap = new va_list();
			.__builtin_va_start(ap, fmt);
			.fputs("curl: ", /* prefix it */errors);
			ModernizedCProgram.curl_mvfprintf(errors, fmt, ap);
			.__builtin_va_end(ap);
		} 
		ModernizedCProgram.curl_mfprintf(errors, "curl: try 'curl --help' or 'curl --manual' for more information\n");
	}
	/***********************************************************************
	 *
	 * pop3_endofresp()
	 *
	 * Checks for an ending POP3 status code at the start of the given string, but
	 * also detects the APOP timestamp from the server greeting and various
	 * capabilities from the CAPA response including the supported authentication
	 * types and allowed SASL mechanisms.
	 */
	public static  pop3_endofresp(Object conn, Object line, Object len, Object resp) {
		pop3_conn pop3c = conn.getProto().getPop3c();
		if (len >= 4 && !.memcmp("-ERR", line, /* Do we have an error response? */4)) {
			resp = (byte)'-';
			return 1;
		} 
		if (pop3c.getState() == /* Are we processing CAPA command responses? */.POP3_CAPA) {
			if (len >= 1 && line[0] == /* Do we have the terminating line? */(byte)'.') {
				resp = /* Treat the response as a success */(byte)'+';
			} else {
					resp = /* Treat the response as an untagged continuation */(byte)'*';
			} 
			return 1;
		} 
		if (len >= 3 && !.memcmp("+OK", line, /* Do we have a success response? */3)) {
			resp = (byte)'+';
			return 1;
		} 
		if (len >= 1 && line[0] == /* Do we have a continuation response? */(byte)'+') {
			resp = (byte)'*';
			return 1;
		} 
		return /* Nothing for us */0/***********************************************************************
		 *
		 * pop3_get_message()
		 *
		 * Gets the authentication message from the response buffer.
		 */;
	}
	public static void pop3_get_message(Object buffer, Object outptr) {
		size_t len = .strlen(buffer);
		byte message = ((Object)0);
		if (len > 2) {
			len -= /* Find the start of the message */2;
			for (message = buffer + 2; message == (byte)' ' || message == (byte)'\t'; ) {
				;
			}
			for (; /* Find the end of the message */len--; ) {
				if (message[len] != (byte)'\r' && message[len] != (byte)'\n' && message[len] != (byte)' ' && message[len] != (byte)'\t') {
					break;
				} 
			}
			if (++/* Terminate the message */len) {
				message[len] = (byte)'\0';
			} 
		} else {
				message = buffer[/* junk input => zero length output */len];
		} 
		outptr = message/***********************************************************************
		 *
		 * state()
		 *
		 * This is the ONLY way to change POP3 state!
		 */;
	}
	/*
	 * POP3 protocol handler.
	 */
	public static  pop3_perform_capa(Object conn) {
		CURLcode result = .CURLE_OK;
		pop3_conn pop3c = conn.getProto().getPop3c();
		pop3c.getSasl().setAuthmechs(/* No known auth. mechanisms yet */0);
		pop3c.getSasl().setAuthused(/* Clear the auth. mechanism used */0);
		pop3c.setTls_supported(/* Clear the TLS capability */0);
		result = ModernizedCProgram.Curl_pp_sendf(pop3c.getPp(), "%s", /* Send the CAPA command */"CAPA");
		if (!result) {
			ModernizedCProgram.state(conn, .POP3_CAPA);
		} 
		return result/***********************************************************************
		 *
		 * pop3_perform_starttls()
		 *
		 * Sends the STLS command to start the upgrade to TLS.
		 */;
	}
	public static  pop3_perform_starttls(Object conn) {
		CURLcode result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getPop3c().getPp(), "%s", /* Send the STLS command */"STLS");
		if (!result) {
			ModernizedCProgram.state(conn, .POP3_STARTTLS);
		} 
		return result/***********************************************************************
		 *
		 * pop3_perform_upgrade_tls()
		 *
		 * Performs the upgrade to TLS.
		 */;
	}
	public static  pop3_perform_upgrade_tls(Object conn) {
		pop3_conn pop3c = conn.getProto().getPop3c();
		CURLcode result = .CURLE_NOT_BUILT_IN;
		if (!result) {
			if (pop3c.getState() != .POP3_UPGRADETLS) {
				ModernizedCProgram.state(conn, .POP3_UPGRADETLS);
			} 
			if (pop3c.getSsldone()) {
				do {
				} while (0);
				result = ModernizedCProgram.pop3_perform_capa(conn);
			} 
		} 
		return result/***********************************************************************
		 *
		 * pop3_perform_user()
		 *
		 * Sends a clear text USER command to authenticate with.
		 */;
	}
	public static  pop3_perform_user(Object conn) {
		CURLcode result = .CURLE_OK;
		if (!conn.getBits().getUser_passwd()) {
			ModernizedCProgram.state(conn, .POP3_STOP);
			return result;
		} 
		result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getPop3c().getPp(), /* Send the USER command */"USER %s", conn.getUser() ? conn.getUser() : "");
		if (!result) {
			ModernizedCProgram.state(conn, .POP3_USER);
		} 
		return result/***********************************************************************
		 *
		 * pop3_perform_apop()
		 *
		 * Sends an APOP command to authenticate with.
		 *//***********************************************************************
		 *
		 * pop3_perform_apop()
		 *
		 * Sends an APOP command to authenticate with.
		 */;
	}
	public static  pop3_perform_apop(Object conn) {
		CURLcode result = .CURLE_OK;
		pop3_conn pop3c = conn.getProto().getPop3c();
		size_t i = new size_t();
		MD5_context ctxt = new MD5_context();
		byte[] digest = new byte[16];
		byte[] secret = new byte[2 * 16 + 1];
		if (!conn.getBits().getUser_passwd()) {
			ModernizedCProgram.state(conn, .POP3_STOP);
			return result;
		} 
		ctxt = ModernizedCProgram.Curl_MD5_init(/* Create the digest */ModernizedCProgram.Curl_DIGEST_MD5);
		if (!ctxt) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.Curl_MD5_update(ctxt, (byte)pop3c.getApoptimestamp(), ModernizedCProgram.curlx_uztoui(.strlen(pop3c.getApoptimestamp())));
		ModernizedCProgram.Curl_MD5_update(ctxt, (byte)conn.getPasswd(), ModernizedCProgram.curlx_uztoui(.strlen(conn.getPasswd())));
		ModernizedCProgram.Curl_MD5_final(ctxt, /* Finalise the digest */digest);
		for (i = 0; i < 16; /* Convert the calculated 16 octet digest into a 32 byte hex string */i++) {
			ModernizedCProgram.curl_msnprintf(secret[2 * i], 3, "%02x", digest[i]);
		}
		result = ModernizedCProgram.Curl_pp_sendf(pop3c.getPp(), "APOP %s %s", conn.getUser(), secret);
		if (!result) {
			ModernizedCProgram.state(conn, .POP3_APOP);
		} 
		return result/***********************************************************************
		 *
		 * pop3_perform_auth()
		 *
		 * Sends an AUTH command allowing the client to login with the given SASL
		 * authentication mechanism.
		 */;
	}
	public static  pop3_perform_auth(Object conn, Object mech, Object initresp) {
		CURLcode result = .CURLE_OK;
		pop3_conn pop3c = conn.getProto().getPop3c();
		if (/* AUTH <mech> ...<crlf> */initresp) {
			result = ModernizedCProgram.Curl_pp_sendf(pop3c.getPp(), "AUTH %s %s", mech, /* Send the AUTH command with the initial response */initresp);
		} else {
				result = ModernizedCProgram.Curl_pp_sendf(pop3c.getPp(), "AUTH %s", /* Send the AUTH command */mech);
		} 
		return result/***********************************************************************
		 *
		 * pop3_continue_auth()
		 *
		 * Sends SASL continuation data or cancellation.
		 */;
	}
	public static  pop3_continue_auth(Object conn, Object resp) {
		pop3_conn pop3c = conn.getProto().getPop3c();
		return ModernizedCProgram.Curl_pp_sendf(pop3c.getPp(), "%s", resp/***********************************************************************
		 *
		 * pop3_perform_authentication()
		 *
		 * Initiates the authentication sequence, with the appropriate SASL
		 * authentication mechanism, falling back to APOP and clear text should a
		 * common mechanism not be available between the client and server.
		 */);
	}
	public static  pop3_perform_authentication(Object conn) {
		CURLcode result = .CURLE_OK;
		pop3_conn pop3c = conn.getProto().getPop3c();
		saslprogress progress = .SASL_IDLE;
		if (!ModernizedCProgram.Curl_sasl_can_authenticate(pop3c.getSasl(), /* Check we have enough data to authenticate with and end the
		     connect phase if we don't */conn)) {
			ModernizedCProgram.state(conn, .POP3_STOP);
			return result;
		} 
		if (pop3c.getAuthtypes() & pop3c.getPreftype() & (1 << 2)) {
			result = ModernizedCProgram.Curl_sasl_start(pop3c.getSasl(), conn, 0, /* Calculate the SASL login details */progress);
			if (!result) {
				if (progress == .SASL_INPROGRESS) {
					ModernizedCProgram.state(conn, .POP3_AUTH);
				} 
			} 
		} 
		if (!result && progress == .SASL_IDLE) {
			if (pop3c.getAuthtypes() & pop3c.getPreftype() & (1 << 1)) {
				result = ModernizedCProgram.pop3_perform_apop(/* Perform APOP authentication */conn);
			}  else if (pop3c.getAuthtypes() & pop3c.getPreftype() & (1 << 0)) {
				result = ModernizedCProgram.pop3_perform_user(/* Perform clear text authentication */conn);
			} else {
					ModernizedCProgram.Curl_infof(conn.getData(), /* Other mechanisms not supported */"No known authentication mechanisms supported!\n");
					result = .CURLE_LOGIN_DENIED;
			} 
		} 
		return result/***********************************************************************
		 *
		 * pop3_perform_command()
		 *
		 * Sends a POP3 based command.
		 */;
	}
	public static  pop3_perform_command(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		POP3 pop3 = data.getReq().getProtop();
		byte command = ((Object)0);
		if (pop3.getId()[0] == (byte)'\0' || conn.getData().getSet().getFtp_list_only()) {
			command = "LIST";
			if (pop3.getId()[0] != (byte)'\0') {
				pop3.setTransfer(/* Message specific LIST so skip the BODY transfer */.FTPTRANSFER_INFO);
			} 
		} else {
				command = "RETR";
		} 
		if (pop3.getId()[0] != /* Send the command */(byte)'\0') {
			result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getPop3c().getPp(), "%s %s", (pop3.getCustom() && pop3.getCustom()[0] != (byte)'\0' ? pop3.getCustom() : command), pop3.getId());
		} else {
				result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getPop3c().getPp(), "%s", (pop3.getCustom() && pop3.getCustom()[0] != (byte)'\0' ? pop3.getCustom() : command));
		} 
		if (!result) {
			ModernizedCProgram.state(conn, .POP3_COMMAND);
		} 
		return result/***********************************************************************
		 *
		 * pop3_perform_quit()
		 *
		 * Performs the quit action prior to sclose() be called.
		 */;
	}
	public static  pop3_perform_quit(Object conn) {
		CURLcode result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getPop3c().getPp(), "%s", /* Send the QUIT command */"QUIT");
		if (!result) {
			ModernizedCProgram.state(conn, .POP3_QUIT);
		} 
		return result;
	}
	/* For the initial server greeting */
	public static  pop3_state_servergreet_resp(Object conn, int pop3code,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		pop3_conn pop3c = conn.getProto().getPop3c();
		byte line = data.getState().getBuffer();
		size_t len = .strlen(line);
		(Object)/* no use for this yet */instate;
		if (pop3code != (byte)'+') {
			ModernizedCProgram.Curl_failf(data, "Got unexpected pop3-server response");
			result = .CURLE_WEIRD_SERVER_REPLY;
		} else {
				if (len >= 4 && line[len - 2] == /* Does the server support APOP authentication? */(byte)'>'/* Look for the APOP timestamp */) {
					size_t i = new size_t();
					for (i = 3; i < len - 2; ++i) {
						if (line[i] == (byte)'<') {
							size_t timestamplen = len - 1 - /* Calculate the length of the timestamp */i;
							byte at;
							if (!timestamplen) {
								break;
							} 
							pop3c.setApoptimestamp((byte).Curl_ccalloc(1, timestamplen + /* Allocate some memory for the timestamp */1));
							if (!pop3c.getApoptimestamp()) {
								break;
							} 
							.memcpy(pop3c.getApoptimestamp(), line + i, /* Copy the timestamp */timestamplen);
							pop3c.getApoptimestamp()[timestamplen] = (byte)'\0'/* If the timestamp does not contain '@' it is not (as required by
							             RFC-1939) conformant to the RFC-822 message id syntax, and we
							             therefore do not use APOP authentication. */;
							at = .strchr(pop3c.getApoptimestamp(), (byte)'@');
							if (!at) {
								do {
									.Curl_cfree((pop3c.getApoptimestamp()));
									(pop3c.getApoptimestamp()) = ((Object)0);
								} while (0);
							} else {
									pop3c.getAuthtypes() |=  (1 << /* Store the APOP capability */1);
							} 
							break;
						} 
					}
				} 
				result = ModernizedCProgram.pop3_perform_capa(conn);
		} 
		return result;
	}
	/* For CAPA responses */
	public static  pop3_state_capa_resp(Object conn, int pop3code,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		pop3_conn pop3c = conn.getProto().getPop3c();
		byte line = data.getState().getBuffer();
		size_t len = .strlen(line);
		(Object)/* no use for this yet */instate;
		if (pop3code == /* Do we have a untagged continuation response? */(byte)'*') {
			if (len >= 4 && !.memcmp(line, "STLS", /* Does the server support the STLS capability? */4)) {
				pop3c.setTls_supported(1);
			}  else if (len >= 4 && !.memcmp(line, "USER", /* Does the server support clear text authentication? */4)) {
				pop3c.getAuthtypes() |=  (1 << 0);
			}  else if (len >= 5 && !.memcmp(line, "SASL ", /* Does the server support SASL based authentication? */5)) {
				pop3c.getAuthtypes() |=  (1 << 2);
				line += /* Advance past the SASL keyword */5;
				len -= 5;
				for (; ; ) {
					size_t llen = new size_t();
					size_t wordlen = new size_t();
					int mechbit;
					while (len && (line == (byte)' ' || line == (byte)'\t' || line == (byte)'\r' || line == (byte)'\n')) {
						line++;
						len--;
					}
					if (!len) {
						break;
					} 
					for (wordlen = 0; wordlen < len && line[wordlen] != /* Extract the word */(byte)' ' && line[wordlen] != (byte)'\t' && line[wordlen] != (byte)'\r' && line[wordlen] != (byte)'\n'; ) {
						wordlen++;
					}
					mechbit = ModernizedCProgram.Curl_sasl_decode_mech(line, wordlen, /* Test the word for a matching authentication mechanism */llen);
					if (mechbit && llen == wordlen) {
						pop3c.getSasl().getAuthmechs() |=  mechbit;
					} 
					line += wordlen;
					len -= wordlen;
				}
			} 
		}  else if (pop3code == (byte)'+') {
			if (data.getSet().getUse_ssl() && !conn.getSsl()[0].getUse()) {
				if (pop3c.getTls_supported()) {
					result = ModernizedCProgram.pop3_perform_starttls(/* Switch to TLS connection now */conn);
				}  else if (data.getSet().getUse_ssl() == .CURLUSESSL_TRY) {
					result = ModernizedCProgram.pop3_perform_authentication(/* Fallback and carry on with authentication */conn);
				} else {
						ModernizedCProgram.Curl_failf(data, "STLS not supported.");
						result = .CURLE_USE_SSL_FAILED;
				} 
			} else {
					result = ModernizedCProgram.pop3_perform_authentication(conn);
			} 
		} else {
				pop3c.getAuthtypes() |=  (1 << /* Clear text is supported when CAPA isn't recognised */0);
				result = ModernizedCProgram.pop3_perform_authentication(conn);
		} 
		return result;
	}
	/* For STARTTLS responses */
	public static  pop3_state_starttls_resp(Object conn, int pop3code,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (pop3code != (byte)'+') {
			if (data.getSet().getUse_ssl() != .CURLUSESSL_TRY) {
				ModernizedCProgram.Curl_failf(data, "STARTTLS denied");
				result = .CURLE_USE_SSL_FAILED;
			} else {
					result = ModernizedCProgram.pop3_perform_authentication(conn);
			} 
		} else {
				result = ModernizedCProgram.pop3_perform_upgrade_tls(conn);
		} 
		return result;
	}
	/* For SASL authentication responses */
	public static  pop3_state_auth_resp(Object conn, int pop3code,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		pop3_conn pop3c = conn.getProto().getPop3c();
		saslprogress progress = new saslprogress();
		(Object)/* no use for this yet */instate;
		result = ModernizedCProgram.Curl_sasl_continue(pop3c.getSasl(), conn, pop3code, progress);
		if (!result) {
			switch (progress) {
			case .SASL_DONE:
					ModernizedCProgram.state(conn, /* Authenticated */.POP3_STOP);
					break;
			case /* No mechanism left after cancellation */.SASL_IDLE:
					if (pop3c.getAuthtypes() & pop3c.getPreftype() & (1 << 1)) {
						result = ModernizedCProgram.pop3_perform_apop(/* Perform APOP authentication */conn);
					}  else if (pop3c.getAuthtypes() & pop3c.getPreftype() & (1 << 0)) {
						result = ModernizedCProgram.pop3_perform_user(/* Perform clear text authentication */conn);
					} else {
							ModernizedCProgram.Curl_failf(data, "Authentication cancelled");
							result = .CURLE_LOGIN_DENIED;
					} 
					break;
			default:
					break;
			}
		} 
		return result;
	}
	/* For APOP responses */
	/* For APOP responses */
	public static  pop3_state_apop_resp(Object conn, int pop3code,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (pop3code != (byte)'+') {
			ModernizedCProgram.Curl_failf(data, "Authentication failed: %d", pop3code);
			result = .CURLE_LOGIN_DENIED;
		} else {
				ModernizedCProgram.state(conn, /* End of connect phase */.POP3_STOP);
		} 
		return result;
	}
	/* For USER responses */
	public static  pop3_state_user_resp(Object conn, int pop3code,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (pop3code != (byte)'+') {
			ModernizedCProgram.Curl_failf(data, "Access denied. %c", pop3code);
			result = .CURLE_LOGIN_DENIED;
		} else {
				result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getPop3c().getPp(), /* Send the PASS command */"PASS %s", conn.getPasswd() ? conn.getPasswd() : "");
		} 
		if (!result) {
			ModernizedCProgram.state(conn, .POP3_PASS);
		} 
		return result;
	}
	/* For PASS responses */
	public static  pop3_state_pass_resp(Object conn, int pop3code,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (pop3code != (byte)'+') {
			ModernizedCProgram.Curl_failf(data, "Access denied. %c", pop3code);
			result = .CURLE_LOGIN_DENIED;
		} else {
				ModernizedCProgram.state(conn, /* End of connect phase */.POP3_STOP);
		} 
		return result;
	}
	/* For command responses */
	public static  pop3_state_command_resp(Object conn, int pop3code,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		POP3 pop3 = data.getReq().getProtop();
		pop3_conn pop3c = conn.getProto().getPop3c();
		pingpong pp = pop3c.getPp();
		(Object)/* no use for this yet */instate;
		if (pop3code != (byte)'+') {
			ModernizedCProgram.state(conn, .POP3_STOP);
			return .CURLE_RECV_ERROR/* This 'OK' line ends with a CR LF pair which is the two first bytes of the
			     EOB string so count this is two matching bytes. This is necessary to make
			     the code detect the EOB if the only data than comes now is %2e CR LF like
			     when there is no body to return. */;
		} 
		pop3c.setEob(2);
		pop3c.setStrip(/* But since this initial CR LF pair is not part of the actual body, we set
		     the strip counter here so that these bytes won't be delivered. */2);
		if (pop3.getTransfer() == .FTPTRANSFER_BODY) {
			ModernizedCProgram.Curl_setup_transfer(data, 0, -1, 0, -/* POP3 download */1);
			if (pp.getCache()) {
				if (!data.getSet().getOpt_no_body()) {
					result = ModernizedCProgram.Curl_pop3_write(conn, pp.getCache(), pp.getCache_size());
					if (result) {
						return result;
					} 
				} 
				do {
					.Curl_cfree((pp.getCache()));
					(pp.getCache()) = ((Object)0);
				} while (/* Free the cache */0);
				pp.setCache_size(/* Reset the cache size */0);
			} 
		} 
		ModernizedCProgram.state(conn, /* End of DO phase */.POP3_STOP);
		return result;
	}
	public static  pop3_statemach_act(Object conn) {
		CURLcode result = .CURLE_OK;
		curl_socket_t sock = conn.getSock()[0];
		int pop3code;
		pop3_conn pop3c = conn.getProto().getPop3c();
		pingpong pp = pop3c.getPp();
		size_t nread = 0;
		if (pop3c.getState() == /* Busy upgrading the connection; right now all I/O is SSL/TLS, not POP3 */.POP3_UPGRADETLS) {
			return ModernizedCProgram.pop3_perform_upgrade_tls(conn);
		} 
		if (pp.getSendleft()) {
			return ModernizedCProgram.Curl_pp_flushsend(pp);
		} 
		do {
			result = ModernizedCProgram.Curl_pp_readresp(sock, pp, pop3code, /* Read the response from the server */nread);
			if (result) {
				return result;
			} 
			if (!pop3code) {
				break;
			} 
			switch (pop3c.getState()) {
			case .POP3_CAPA:
					result = ModernizedCProgram.pop3_state_capa_resp(conn, pop3code, pop3c.getState());
					break;
			case .POP3_STARTTLS:
					result = ModernizedCProgram.pop3_state_starttls_resp(conn, pop3code, pop3c.getState());
					break;
			case .POP3_AUTH:
					result = ModernizedCProgram.pop3_state_auth_resp(conn, pop3code, pop3c.getState());
					break;
			case .POP3_APOP:
					result = ModernizedCProgram.pop3_state_apop_resp(conn, pop3code, pop3c.getState());
					break;
			case .POP3_SERVERGREET:
					result = ModernizedCProgram.pop3_state_servergreet_resp(conn, pop3code, pop3c.getState());
					break;
			case .POP3_QUIT/* fallthrough, just stop! */:
			case .POP3_PASS:
					result = ModernizedCProgram.pop3_state_pass_resp(conn, pop3code, pop3c.getState());
					break;
			case .POP3_USER:
					result = ModernizedCProgram.pop3_state_user_resp(conn, pop3code, pop3c.getState());
					break;
			case .POP3_COMMAND:
					result = ModernizedCProgram.pop3_state_command_resp(conn, pop3code, pop3c.getState());
					break;
			default:
					ModernizedCProgram.state(conn, /* internal error */.POP3_STOP);
					break;
			}
		} while (!result && pop3c.getState() != .POP3_STOP && ModernizedCProgram.Curl_pp_moredata(pp));
		return result;
	}
	/* Called repeatedly until done from multi.c */
	public static  pop3_multi_statemach(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		pop3_conn pop3c = conn.getProto().getPop3c();
		if ((conn.getHandler().getFlags() & (1 << 0)) && !pop3c.getSsldone()) {
			result = .CURLE_NOT_BUILT_IN;
			if (result || !pop3c.getSsldone()) {
				return result;
			} 
		} 
		result = ModernizedCProgram.Curl_pp_statemach(pop3c.getPp(), 0, 0);
		done = (pop3c.getState() == .POP3_STOP) ? 1 : 0;
		return result;
	}
	public static  pop3_block_statemach(Object conn,  disconnecting) {
		CURLcode result = .CURLE_OK;
		pop3_conn pop3c = conn.getProto().getPop3c();
		while (pop3c.getState() != .POP3_STOP && !result) {
			result = ModernizedCProgram.Curl_pp_statemach(pop3c.getPp(), 1, disconnecting);
		}
		return result;
	}
	/* Allocate and initialize the POP3 struct for the current Curl_easy if
	   required */
	public static  pop3_init(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		POP3 pop3 = new POP3();
		pop3 = data.getReq().setProtop(.Curl_ccalloc(, 1));
		if (!pop3) {
			result = .CURLE_OUT_OF_MEMORY;
		} 
		return result;
	}
	/* For the POP3 "protocol connect" and "doing" phases only */
	public static int pop3_getsock(Object conn, Object socks) {
		return ModernizedCProgram.Curl_pp_getsock(conn.getProto().getPop3c().getPp(), socks/***********************************************************************
		 *
		 * pop3_connect()
		 *
		 * This function should do everything that is to be considered a part of the
		 * connection phase.
		 *
		 * The variable 'done' points to will be TRUE if the protocol-layer connect
		 * phase is done when this function returns, or FALSE if not.
		 */);
	}
	public static  pop3_connect(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		pop3_conn pop3c = conn.getProto().getPop3c();
		pingpong pp = pop3c.getPp();
		done = /* default to not done yet */0;
		ModernizedCProgram.Curl_conncontrol(conn, /* We always support persistent connections in POP3 */0);
		pp.setResponse_time((120 * /* Set the default response time-out */1000));
		pp.setStatemach_act(pop3_statemach_act);
		pp.setEndofresp(pop3_endofresp);
		pp.setConn(conn);
		pop3c.setPreftype(~/* Set the default preferred authentication type and mechanism */-1024);
		ModernizedCProgram.Curl_sasl_init(pop3c.getSasl(), ModernizedCProgram.saslpop3);
		ModernizedCProgram.Curl_pp_init(/* Initialise the pingpong layer */pp);
		result = ModernizedCProgram.pop3_parse_url_options(/* Parse the URL options */conn);
		if (result) {
			return result;
		} 
		ModernizedCProgram.state(conn, /* Start off waiting for the server greeting response */.POP3_SERVERGREET);
		result = ModernizedCProgram.pop3_multi_statemach(conn, done);
		return result/***********************************************************************
		 *
		 * pop3_done()
		 *
		 * The DONE function. This does what needs to be done after a single DO has
		 * performed.
		 *
		 * Input argument is already checked for validity.
		 */;
	}
	public static  pop3_done(Object conn,  status,  premature) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		POP3 pop3 = data.getReq().getProtop();
		(Object)premature;
		if (!pop3) {
			return .CURLE_OK;
		} 
		if (status) {
			ModernizedCProgram.Curl_conncontrol(conn, 1);
			result = /* use the already set error code */status;
		} 
		do {
			.Curl_cfree((pop3.getId()));
			(pop3.getId()) = ((Object)0);
		} while (/* Cleanup our per-request based variables */0);
		do {
			.Curl_cfree((pop3.getCustom()));
			(pop3.getCustom()) = ((Object)0);
		} while (0);
		pop3.setTransfer(/* Clear the transfer mode for the next request */.FTPTRANSFER_BODY);
		return result/***********************************************************************
		 *
		 * pop3_perform()
		 *
		 * This is the actual DO function for POP3. Get a message/listing according to
		 * the options previously setup.
		 */;
	}
	public static  pop3_perform(Object conn, Object connected, Object dophase_done) {
		CURLcode result = /* This is POP3 and no proxy */.CURLE_OK;
		POP3 pop3 = conn.getData().getReq().getProtop();
		do {
		} while (0);
		if (conn.getData().getSet().getOpt_no_body()) {
			pop3.setTransfer(/* Requested no body means no transfer */.FTPTRANSFER_INFO);
		} 
		dophase_done = /* not done yet */0;
		result = ModernizedCProgram.pop3_perform_command(/* Start the first command in the DO phase */conn);
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.pop3_multi_statemach(conn, /* Run the state-machine */dophase_done);
		connected = conn.getBits().getTcpconnect()[0];
		if (dophase_done) {
			do {
			} while (0);
		} 
		return result/***********************************************************************
		 *
		 * pop3_do()
		 *
		 * This function is registered as 'curl_do' function. It decodes the path
		 * parts etc as a wrapper to the actual DO function (pop3_perform).
		 *
		 * The input argument is already checked for validity.
		 */;
	}
	public static  pop3_do(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		done = /* default to false */0;
		result = ModernizedCProgram.pop3_parse_url_path(/* Parse the URL path */conn);
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.pop3_parse_custom_request(/* Parse the custom request */conn);
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.pop3_regular_transfer(conn, done);
		return result/***********************************************************************
		 *
		 * pop3_disconnect()
		 *
		 * Disconnect from an POP3 server. Cleanup protocol-specific per-connection
		 * resources. BLOCKING.
		 */;
	}
	public static  pop3_disconnect(Object conn,  dead_connection) {
		pop3_conn pop3c = conn.getProto().getPop3c();
		if (!dead_connection && pop3c.getPp().getConn() && pop3c.getPp().getConn().getBits().getProtoconnstart()) {
			if (!ModernizedCProgram.pop3_perform_quit(conn)) {
				(Object)ModernizedCProgram.pop3_block_statemach(conn, /* ignore errors on QUIT */1);
			} 
		} 
		ModernizedCProgram.Curl_pp_disconnect(pop3c.getPp());
		ModernizedCProgram.Curl_sasl_cleanup(conn, pop3c.getSasl().getAuthused());
		do {
			.Curl_cfree((pop3c.getApoptimestamp()));
			(pop3c.getApoptimestamp()) = ((Object)0);
		} while (/* Cleanup our connection based variables */0);
		return .CURLE_OK;
	}
	/* Call this when the DO phase has completed */
	public static  pop3_dophase_done(Object conn,  connected) {
		(Object)conn;
		(Object)connected;
		return .CURLE_OK;
	}
	/* Called from multi.c while DOing */
	public static  pop3_doing(Object conn, Object dophase_done) {
		CURLcode result = ModernizedCProgram.pop3_multi_statemach(conn, dophase_done);
		if (result) {
			do {
			} while (0);
		}  else if (dophase_done) {
			result = ModernizedCProgram.pop3_dophase_done(conn, /* not connected */0);
			do {
			} while (0);
		} 
		return result/***********************************************************************
		 *
		 * pop3_regular_transfer()
		 *
		 * The input argument is already checked for validity.
		 *
		 * Performs all commands done before a regular transfer between a local and a
		 * remote host.
		 */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 * RFC1734 POP3 Authentication
	 * RFC1939 POP3 protocol
	 * RFC2195 CRAM-MD5 authentication
	 * RFC2384 POP URL Scheme
	 * RFC2449 POP3 Extension Mechanism
	 * RFC2595 Using TLS with IMAP, POP3 and ACAP
	 * RFC2831 DIGEST-MD5 authentication
	 * RFC4422 Simple Authentication and Security Layer (SASL)
	 * RFC4616 PLAIN authentication
	 * RFC4752 The Kerberos V5 ("GSSAPI") SASL Mechanism
	 * RFC5034 POP3 SASL Authentication Mechanism
	 * RFC6749 OAuth 2.0 Authorization Framework
	 * RFC8314 Use of TLS for Email Submission and Access
	 * Draft   LOGIN SASL Mechanism <draft-murchison-sasl-login-00.txt>
	 *
	 ***************************************************************************/
	/* for HTTP proxy tunnel stuff */
	/* The last 3 #include files should be in this order */
	/* Local API functions */
	public static  pop3_regular_transfer(Object conn, Object dophase_done) {
		CURLcode result = .CURLE_OK;
		bool connected = 0;
		Curl_easy data = conn.getData();
		data.getReq().setSize(-/* Make sure size is unknown at this point */1);
		ModernizedCProgram.Curl_pgrsSetUploadCounter(data, /* Set the progress data */0);
		ModernizedCProgram.Curl_pgrsSetDownloadCounter(data, 0);
		ModernizedCProgram.Curl_pgrsSetUploadSize(data, -1);
		ModernizedCProgram.Curl_pgrsSetDownloadSize(data, -1);
		result = ModernizedCProgram.pop3_perform(conn, connected, /* Carry out the perform */dophase_done);
		if (!result && /* Perform post DO phase operations if necessary */dophase_done) {
			result = ModernizedCProgram.pop3_dophase_done(conn, connected);
		} 
		return result;
	}
	public static  pop3_setup_connection(Object conn) {
		CURLcode result = ModernizedCProgram.pop3_init(/* Initialise the POP3 layer */conn);
		if (result) {
			return result;
		} 
		conn.setTls_upgraded(/* Clear the TLS upgraded flag */0);
		return .CURLE_OK/***********************************************************************
		 *
		 * pop3_parse_url_options()
		 *
		 * Parse the URL login options.
		 */;
	}
	public static  pop3_parse_url_options(Object conn) {
		CURLcode result = .CURLE_OK;
		pop3_conn pop3c = conn.getProto().getPop3c();
		byte ptr = conn.getOptions();
		pop3c.getSasl().setResetprefs(1);
		while (!result && ptr && ptr) {
			byte key = ptr;
			byte value;
			while (ptr && ptr != (byte)'=') {
				ptr++;
			}
			value = ptr + 1;
			while (ptr && ptr != (byte)';') {
				ptr++;
			}
			if (ModernizedCProgram.Curl_strncasecompare(key, "AUTH=", 5)) {
				result = ModernizedCProgram.Curl_sasl_parse_url_auth_option(pop3c.getSasl(), value, ptr - value);
				if (result && ModernizedCProgram.Curl_strncasecompare(value, "+APOP", ptr - value)) {
					pop3c.setPreftype((1 << 1));
					pop3c.getSasl().setPrefmech(0);
					result = .CURLE_OK;
				} 
			} else {
					result = .CURLE_URL_MALFORMAT;
			} 
			if (ptr == (byte)';') {
				ptr++;
			} 
		}
		if (pop3c.getPreftype() != (1 << 1)) {
			switch (pop3c.getSasl().getPrefmech()) {
			case 0:
					pop3c.setPreftype(0);
					break;
			case (~-1024 & ~(1 << 5)):
					pop3c.setPreftype(~-1024);
					break;
			default:
					pop3c.setPreftype((1 << 2));
					break;
			}
		} 
		return result/***********************************************************************
		 *
		 * pop3_parse_url_path()
		 *
		 * Parse the URL path into separate path components.
		 */;
	}
	public static  pop3_parse_url_path(Object conn) {
		Curl_easy data = conn.getData();
		POP3 pop3 = data.getReq().getProtop();
		byte path = data.getState().getUp().getPath()[/* skip leading path */1];
		return ModernizedCProgram.Curl_urldecode(data, path, 0, pop3.getId(), ((Object)0), /* URL decode the path for the message ID */1/***********************************************************************
		 *
		 * pop3_parse_custom_request()
		 *
		 * Parse the custom request.
		 */);
	}
	public static  pop3_parse_custom_request(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		POP3 pop3 = data.getReq().getProtop();
		byte custom = data.getSet().getStr()[dupstring.STRING_CUSTOMREQUEST];
		if (/* URL decode the custom request */custom) {
			result = ModernizedCProgram.Curl_urldecode(data, custom, 0, pop3.getCustom(), ((Object)0), 1);
		} 
		return result/***********************************************************************
		 *
		 * Curl_pop3_write()
		 *
		 * This function scans the body after the end-of-body and writes everything
		 * until the end is found.
		 */;
	}
	public static  Curl_pop3_write(Object conn, Object str, Object nread) {
		CURLcode result = /* This code could be made into a special function in the handler struct */.CURLE_OK;
		Curl_easy data = conn.getData();
		SingleRequest k = data.getReq();
		pop3_conn pop3c = conn.getProto().getPop3c();
		bool strip_dot = 0;
		size_t last = 0;
		size_t i = new size_t();
		/* Search through the buffer looking for the end-of-body marker which is
		     5 bytes (0d 0a 2e 0d 0a). Note that a line starting with a dot matches
		     the eob so the server will have prefixed it with an extra dot which we
		     need to strip out. Additionally the marker could of course be spread out
		     over 5 different data chunks. */
		for (i = 0; i < nread; i++) {
			size_t prev = pop3c.getEob();
			switch (str[i]) {
			case -1024:
					if (pop3c.getEob() == 2) {
						pop3c.getEob()++;
					}  else if (pop3c.getEob() == 3) {
						strip_dot = /* We have an extra dot after the CRLF which we need to strip off */1;
						pop3c.setEob(0);
					} else {
							pop3c.setEob(/* If the character match wasn't at position 2 then start the search
							           again */0);
					} 
					break;
			case -1024:
					if (pop3c.getEob() == 1 || pop3c.getEob() == 4) {
						pop3c.getEob()++;
					} else {
							pop3c.setEob(/* If the character match wasn't at position 1 or 4 then start the
							           search again */0);
					} 
					break;
			case -1024:
					if (pop3c.getEob() == 0) {
						pop3c.getEob()++;
						if (i) {
							result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), str[/* Write out the body part that didn't match */last], i - last);
							if (result) {
								return result;
							} 
							last = i;
						} 
					}  else if (pop3c.getEob() == 3) {
						pop3c.getEob()++;
					} else {
							pop3c.setEob(/* If the character match wasn't at position 0 or 3 then restart the
							           pattern matching */1);
					} 
					break;
			default:
					pop3c.setEob(0);
					break;
			}
			if (prev && prev >= pop3c.getEob()) {
				while (prev && pop3c.getStrip()) {
					prev--;
					pop3c.getStrip()--;
				}
				if (prev/* If the partial match was the CRLF and dot then only write the CRLF
				           as the server would have inserted the dot */) {
					result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)"\x0d\x0a\x2e\x0d\x0a", strip_dot ? prev - 1 : prev);
					if (result) {
						return result;
					} 
					last = i;
					strip_dot = 0;
				} 
			} 
		}
		if (pop3c.getEob() == 5/* We have a full match so the transfer is done, however we must transfer
		    the CRLF at the start of the EOB as this is considered to be part of the
		    message as per RFC-1939, sect. 3 */) {
			result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)"\x0d\x0a\x2e\x0d\x0a", 2);
			k.getKeepon() &=  ~(1 << 0);
			pop3c.setEob(0);
			return result;
		} 
		if (pop3c.getEob()) {
			return /* While EOB is matching nothing should be output */.CURLE_OK;
		} 
		if (nread - last) {
			result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), str[last], nread - last);
		} 
		return result/* CURL_DISABLE_POP3 */;
	}
	public static void MD5_Init(Object ctx) {
		if (.CryptAcquireContextA(ctx.getHCryptProv(), ((Object)0), ((Object)0), 1, -1024)) {
			.CryptCreateHash(ctx.getHCryptProv(), (32768 | 0 | 3), 0, 0, ctx.getHHash());
		} 
	}
	public static void MD5_Update(Object ctx, Object input, int inputLen) {
		.CryptHashData(ctx.getHHash(), (byte)input, inputLen, 0);
	}
	public static void MD5_Final(Object digest, Object ctx) {
		long length = 0;
		.CryptGetHashParam(ctx.getHHash(), 2, ((Object)0), length, 0);
		if (length == 16) {
			.CryptGetHashParam(ctx.getHHash(), 2, digest, length, 0);
		} 
		if (ctx.getHHash()) {
			.CryptDestroyHash(ctx.getHHash());
		} 
		if (ctx.getHCryptProv()) {
			.CryptReleaseContext(ctx.getHCryptProv(), 0/* When no other crypto library is available we use this code segment *//*
			 * This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.
			 * MD5 Message-Digest Algorithm (RFC 1321).
			 *
			 * Homepage:
			 https://openwall.info/wiki/people/solar/software/public-domain-source-code/md5
			 *
			 * Author:
			 * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>
			 *
			 * This software was written by Alexander Peslyak in 2001.  No copyright is
			 * claimed, and the software is hereby placed in the public domain.
			 * In case this attempt to disclaim copyright and place the software in the
			 * public domain is deemed null and void, then the software is
			 * Copyright (c) 2001 Alexander Peslyak and it is hereby released to the
			 * general public under the following terms:
			 *
			 * Redistribution and use in source and binary forms, with or without
			 * modification, are permitted.
			 *
			 * There's ABSOLUTELY NO WARRANTY, express or implied.
			 *
			 * (This is a heavily cut-down "BSD license".)
			 *
			 * This differs from Colin Plumb's older public domain implementation in that
			 * no exactly 32-bit integer data type is required (any 32-bit or wider
			 * unsigned integer data type will do), there's no compile-time endianness
			 * configuration, and the function prototypes match OpenSSL's.  No code from
			 * Colin Plumb's implementation has been reused; this comment merely compares
			 * the properties of the two independent implementations.
			 *
			 * The primary goals of this implementation are portability and ease of use.
			 * It is meant to be fast, but not as fast as possible.  Some known
			 * optimizations are not included to reduce source code size and avoid
			 * compile-time configuration.
			 *//* The last #include files should be: *//* Any 32-bit or wider unsigned integer data type will do *//*
			 * The basic MD5 functions.
			 *
			 * F and G are optimized compared to their RFC 1321 definitions for
			 * architectures that lack an AND-NOT instruction, just like in Colin Plumb's
			 * implementation.
			 *//*
			 * The MD5 transformation for all four rounds.
			 *//*
			 * SET reads 4 input bytes in little-endian byte order and stores them
			 * in a properly aligned word in host byte order.
			 *
			 * The check for little-endian architectures that tolerate unaligned
			 * memory accesses is just an optimization.  Nothing will break if it
			 * doesn't work.
			 *//*
			 * This processes one or more 64-byte data blocks, but does NOT update
			 * the bit counters.  There are no alignment requirements.
			 *//* Round 1 *//* Round 2 */);
		} 
	}
	/*
	 * @unittest: 1601
	 */
	/* 16 bytes */
	public static void Curl_md5it(Object outbuffer, Object input) {
		MD5_CTX ctx = new MD5_CTX();
		ModernizedCProgram.MD5_Init(ctx);
		ModernizedCProgram.MD5_Update(ctx, input, ModernizedCProgram.curlx_uztoui(.strlen((byte)input)));
		ModernizedCProgram.MD5_Final(outbuffer, ctx);
	}
	public static Object Curl_MD5_init(Object md5params) {
		MD5_context ctxt = new MD5_context();
		ctxt = .Curl_cmalloc();
		if (!ctxt) {
			return ctxt;
		} 
		ctxt.setMd5_hashctx(.Curl_cmalloc(md5params.getMd5_ctxtsize()));
		if (!ctxt.getMd5_hashctx()) {
			.Curl_cfree(ctxt);
			return ((Object)0);
		} 
		ctxt.setMd5_hash(md5params);
		.UNRECOGNIZEDFUNCTIONNAME(ctxt.getMd5_hashctx());
		return ctxt;
	}
	public static  Curl_MD5_update(Object context, Object data, int len) {
		.UNRECOGNIZEDFUNCTIONNAME(context.getMd5_hashctx(), data, len);
		return .CURLE_OK;
	}
	public static  Curl_MD5_final(Object context, Object result) {
		.UNRECOGNIZEDFUNCTIONNAME(result, context.getMd5_hashctx());
		.Curl_cfree(context.getMd5_hashctx());
		.Curl_cfree(context);
		return .CURLE_OK/* CURL_DISABLE_CRYPTO_AUTH */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* Only include this function if one or more of FTP, FILE are enabled. */
	/*
	  Check if this is a range download, and if so, set the internal variables
	  properly.
	 */
	public static  Curl_range(Object conn) {
		curl_off_t from = new curl_off_t();
		curl_off_t to = new curl_off_t();
		byte ptr;
		byte ptr2;
		Curl_easy data = conn.getData();
		if (data.getState().getUse_range() && data.getState().getRange()) {
			CURLofft from_t = new CURLofft();
			CURLofft to_t = new CURLofft();
			from_t = ModernizedCProgram.curlx_strtoofft(data.getState().getRange(), ptr, 0, from);
			if (from_t == .CURL_OFFT_FLOW) {
				return .CURLE_RANGE_ERROR;
			} 
			while (ptr && ((ModernizedCProgram.Curl_isspace((int)((byte)ptr))) || (ptr == (byte)'-'))) {
				ptr++;
			}
			to_t = ModernizedCProgram.curlx_strtoofft(ptr, ptr2, 0, to);
			if (to_t == .CURL_OFFT_FLOW) {
				return .CURLE_RANGE_ERROR;
			} 
			if ((to_t == .CURL_OFFT_INVAL) && !from_t) {
				data.getState().setResume_from(/* X - */from);
				do {
				} while (0);
			}  else if ((from_t == .CURL_OFFT_INVAL) && !to_t) {
				data.getReq().setMaxdownload(/* -Y */to);
				data.getState().setResume_from(-to);
				do {
				} while (0);
			} else {
					curl_off_t totalsize = new curl_off_t();
					if (from > /* Ensure the range is sensible - to should follow from. */to) {
						return .CURLE_RANGE_ERROR;
					} 
					totalsize = to - from;
					if (totalsize == -1024) {
						return .CURLE_RANGE_ERROR;
					} 
					data.getReq().setMaxdownload(totalsize + /* include last byte */1);
					data.getState().setResume_from(from);
					do {
					} while (0);
			} 
			do {
			} while (0);
		} else {
				data.getReq().setMaxdownload(-1);
		} 
		return .CURLE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	public static  Curl_setstropt(Object charp, Object s) {
		do {
			.Curl_cfree((charp));
			(charp) = ((Object)0);
		} while (0);
		if (s) {
			byte str = .Curl_cstrdup(s);
			if (str) {
				size_t len = .strlen(str);
				if (len > 8000000) {
					.Curl_cfree(str);
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
			} 
			if (!str) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			charp = str;
		} 
		return .CURLE_OK;
	}
	/* Release the previous storage at `charp' and replace by a dynamic storage
	     copy of `s'. Return CURLE_OK or CURLE_OUT_OF_MEMORY. */
	public static  setstropt_userpwd(Object option, Object userp, Object passwdp) {
		CURLcode result = .CURLE_OK;
		byte user = ((Object)0);
		byte passwd = ((Object)0);
		if (/* Parse the login details if specified. It not then we treat NULL as a hint
		     to clear the existing data */option) {
			result = ModernizedCProgram.Curl_parse_login_details(option, .strlen(option), (userp ? user : ((Object)0)), (passwdp ? passwd : ((Object)0)), ((Object)0));
		} 
		if (!result) {
			if (/* Store the username part of option if required */userp) {
				if (!user && option && option[0] == (byte)':') {
					user = .Curl_cstrdup(/* Allocate an empty string instead of returning NULL as user name */"");
					if (!user) {
						result = .CURLE_OUT_OF_MEMORY;
					} 
				} 
				do {
					.Curl_cfree((userp));
					(userp) = ((Object)0);
				} while (0);
				userp = user;
			} 
			if (/* Store the password part of option if required */passwdp) {
				do {
					.Curl_cfree((passwdp));
					(passwdp) = ((Object)0);
				} while (0);
				passwdp = passwd;
			} 
		} 
		return result;
	}
	/*
	 * Do not make Curl_vsetopt() static: it is called from
	 * packages/OS400/ccsidcurl.c.
	 */
	public static  Curl_vsetopt(Object data,  option, Object param) {
		byte argptr;
		CURLcode result = .CURLE_OK;
		long arg;
		long uarg;
		curl_off_t bigsize = new curl_off_t();
		switch (option) {
		case .CURLOPT_ERRORBUFFER/*
		     * Error buffer provided by the caller to get the human readable
		     * error string in.
		     */:
				data.getSet().setErrorbuffer((int)param);
				break;
		case .CURLOPT_FTP_FILEMETHOD/*
		     * How do access files over FTP.
		     */:
				arg = (int)param;
				if ((arg < .CURLFTPMETHOD_DEFAULT) || (arg >= .CURLFTPMETHOD_LAST)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setFtp_filemethod((curl_ftpfile)arg);
				break;
		case .CURLOPT_CAPATH/*
		     * Set CA path info for SSL connection. Specify directory name of the CA
		     * certificates which have been prepared using openssl c_rehash utility.
		     */:
				result = /* This does not work on windows. */.CURLE_NOT_BUILT_IN;
				break;
		case .CURLOPT_MAXFILESIZE/*
		     * Set the maximum size of a file to download.
		     */:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setMax_filesize(arg);
				break;
		case .CURLOPT_DEBUGFUNCTION/*
		     * stderr write callback.
		     */:
				data.getSet().setFdebug((int)param/*
				     * if the callback provided is NULL, it'll use the default callback
				     */);
				break;
		case .CURLOPT_ISSUERCERT/*
		     * Set Issuer certificate file
		     * to check certificates issuer
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SSL_ISSUERCERT_ORIG], (int)param);
				break;
		case .CURLOPT_SHARE:
				{ 
					Curl_share set = new Curl_share();
					set = (int)param;
					if (data.getShare()) {
						ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_SHARE, .CURL_LOCK_ACCESS_SINGLE);
						if (data.getDns().getHostcachetype() == .HCACHE_SHARED) {
							data.getDns().setHostcache(((Object)0));
							data.getDns().setHostcachetype(.HCACHE_NONE);
						} 
						if (data.getShare().getCookies() == data.getCookies()) {
							data.setCookies(((Object)0));
						} 
						if (data.getShare().getSslsession() == data.getState().getSession()) {
							data.getState().setSession(((Object)0));
						} 
						data.getShare().getDirty()--;
						ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_SHARE);
						data.setShare(((Object)0));
					} 
					data.setShare(/* use new share if it set */set);
					if (data.getShare()) {
						ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_SHARE, .CURL_LOCK_ACCESS_SINGLE);
						data.getShare().getDirty()++;
						if (data.getShare().getSpecifier() & (1 << .CURL_LOCK_DATA_DNS)) {
							data.getDns().setHostcache(data.getShare().getHostcache());
							data.getDns().setHostcachetype(.HCACHE_SHARED);
						} 
						if (data.getShare().getCookies()) {
							ModernizedCProgram.Curl_cookie_cleanup(data.getCookies());
							data.setCookies(data.getShare().getCookies());
						} 
						if (data.getShare().getSslsession()) {
							data.getSet().getGeneral_ssl().setMax_ssl_sessions(data.getShare().getMax_ssl_sessions());
							data.getState().setSession(data.getShare().getSslsession());
						} 
						ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_SHARE/* check for host cache not needed,
						     * it will be done by curl_easy_perform */);
					} 
				}
				break;
		case .CURLOPT_SSLCERTTYPE/*
		     * String that holds file type of the SSL certificate to use
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_CERT_TYPE_ORIG], (int)param);
				break;
		case .CURLOPT_SSL_CIPHER_LIST:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[/* set a list of cipher we want to use in the SSL connection */dupstring.STRING_SSL_CIPHER_LIST_ORIG], (int)param);
				break;
		case .CURLOPT_SOCKOPTFUNCTION/*
		     * socket callback function: called after socket() but before connect()
		     */:
				data.getSet().setFsockopt((int)param);
				break;
		case .CURLOPT_VERBOSE/*
		     * Verbose means infof() calls that give a lot of information about
		     * the connection and transfer procedures as well as internal choices.
		     */:
				data.getSet().setVerbose((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_PROXY_SSLKEY/*
		     * String that holds file name of the SSL key to use for proxy
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_KEY_PROXY], (int)param);
				break;
		case .CURLOPT_UPKEEP_INTERVAL_MS:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setUpkeep_interval_ms(arg);
				break;
		case .CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setHappy_eyeballs_timeout(arg);
				break;
		case .CURLOPT_NETRC_FILE/*
		     * Use this file instead of the $HOME/.netrc file
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_NETRC_FILE], (int)param);
				break;
		case .CURLOPT_REFERER/*
		     * String to set in the HTTP Referer: field.
		     */:
				if (data.getChange().getReferer_alloc()) {
					do {
						.Curl_cfree((data.getChange().getReferer()));
						(data.getChange().getReferer()) = ((Object)0);
					} while (0);
					data.getChange().setReferer_alloc(0);
				} 
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SET_REFERER], (int)param);
				data.getChange().setReferer(data.getSet().getStr()[dupstring.STRING_SET_REFERER]);
				break;
		case .CURLOPT_HTTP200ALIASES/*
		     * Set a list of aliases for HTTP 200 in response header
		     */:
				data.getSet().setHttp200aliases((int)param);
				break;
		case .CURLOPT_TIMEVALUE_LARGE/*
		     * This is the value to compare with the remote document with the
		     * method set with CURLOPT_TIMECONDITION
		     */:
				data.getSet().setTimevalue((time_t)(int)param);
				break;
		case .CURLOPT_CONNECTTIMEOUT_MS:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setConnecttimeout(arg);
				break;
		case .CURLOPT_SASL_AUTHZID:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[/* Authorisation identity (identity to act as) */dupstring.STRING_SASL_AUTHZID], (int)param);
				break;
		case .CURLOPT_TRAILERDATA:
				data.getSet().setTrailer_data((int)param);
				break;
		case .CURLOPT_TCP_KEEPINTVL:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setTcp_keepintvl(arg);
				break;
		case .CURLOPT_MAXAGE_CONN:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setMaxage_conn(arg);
				break;
		case .CURLOPT_SEEKFUNCTION/*
		     * Seek callback. Might be NULL.
		     */:
				data.getSet().setSeek_func((int)param);
				break;
		case .CURLOPT_CRLF/*
		     * Kludgy option to enable CRLF conversions. Subject for removal.
		     */:
				data.getSet().setCrlf((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_PORT/*
		     * The port number to use when getting the URL
		     */:
				arg = (int)param;
				if ((arg < 0) || (arg > 65535)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setUse_port(arg);
				break;
		case .CURLOPT_SSL_CTX_DATA/*
		     * Set a SSL_CTX callback parameter pointer
		     */:
				result = .CURLE_NOT_BUILT_IN;
				break;
		case .CURLOPT_CONNECT_ONLY/*
		     * No data transfer, set up connection and let application use the socket
		     */:
				data.getSet().setConnect_only((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_CONV_FROM_NETWORK_FUNCTION/*
		     * "Convert from network encoding" callback
		     */:
				data.getSet().setConvfromnetwork((int)param);
				break;
		case .CURLOPT_COOKIESESSION/*
		     * Set this option to TRUE to start a new "cookie session". It will
		     * prevent the forthcoming read-cookies-from-file actions to accept
		     * cookies that are marked as being session cookies, as they belong to a
		     * previous session.
		     *
		     * In the original Netscape cookie spec, "session cookies" are cookies
		     * with no expire date set. RFC2109 describes the same action if no
		     * 'Max-Age' is set and RFC2965 includes the RFC2109 description and adds
		     * a 'Discard' action that can enforce the discard even for cookies that
		     * have a Max-Age.
		     *
		     * We run mostly with the original cookie spec, as hardly anyone implements
		     * anything else.
		     */:
				data.getSet().setCookiesession((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_PROXYUSERNAME/*
		     * authentication user name to use in the operation
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_PROXYUSERNAME], (int)param);
				break;
		case .CURLOPT_MAIL_AUTH:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[/* Set the SMTP auth originator */dupstring.STRING_MAIL_AUTH], (int)param);
				break;
		case .CURLOPT_LOCALPORTRANGE/*
		     * Set number of local ports to try, starting with CURLOPT_LOCALPORT.
		     */:
				arg = (int)param;
				if ((arg < 0) || (arg > 65535)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setLocalportrange(ModernizedCProgram.curlx_sltosi(arg));
				break;
		case .CURLOPT_SUPPRESS_CONNECT_HEADERS:
				data.getSet().setSuppress_connect_headers((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_CURLU/*
		     * pass CURLU to set URL
		     */:
				data.getSet().setUh((int)param);
				break;
		case .CURLOPT_PREQUOTE/*
		     * List of RAW FTP commands to use prior to RETR (Wesley Laxton)
		     */:
				data.getSet().setPrequote((int)param);
				break;
		case .CURLOPT_RESUME_FROM/*
		     * Resume transfer at the given file position
		     */:
				arg = (int)param;
				if (arg < -1) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setSet_resume_from(arg);
				break;
		case .CURLOPT_USERAGENT/*
		     * String to use in the HTTP User-Agent field
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_USERAGENT], (int)param);
				break;
		case .CURLOPT_COOKIEJAR/*
		     * Set cookie file name to dump all cookies to when we're done.
		     */:
				{ 
					CookieInfo newcookies = new CookieInfo();
					result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_COOKIEJAR], (int)param/*
					     * Activate the cookie parser. This may or may not already
					     * have been made.
					     */);
					newcookies = ModernizedCProgram.Curl_cookie_init(data, ((Object)0), data.getCookies(), data.getSet().getCookiesession());
					if (!newcookies) {
						result = .CURLE_OUT_OF_MEMORY;
					} 
					data.setCookies(newcookies);
				}
				break;
		case .CURLOPT_TFTP_BLKSIZE/*
		     * TFTP option that specifies the block size to use for data transmission.
		     */:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setTftp_blksize(arg);
				break;
		case .CURLOPT_STREAM_DEPENDS_E:
				{ 
					return .CURLE_NOT_BUILT_IN;
				}
		case .CURLOPT_RESOLVER_START_DATA/*
		     * resolver start callback data pointer. Might be NULL.
		     */:
				data.getSet().setResolver_start_client((int)param);
				break;
		case .CURLOPT_POSTREDIR/*
		     * Set the behaviour of POST when redirecting
		     * CURL_REDIR_GET_ALL - POST is changed to GET after 301 and 302
		     * CURL_REDIR_POST_301 - POST is kept as POST after 301
		     * CURL_REDIR_POST_302 - POST is kept as POST after 302
		     * CURL_REDIR_POST_303 - POST is kept as POST after 303
		     * CURL_REDIR_POST_ALL - POST is kept as POST after 301, 302 and 303
		     * other - POST is kept as POST after 301 and 302
		     */:
				arg = (int)param;
				if (arg < 0/* no return error on too high numbers since the bitmask could be
				         extended in a future */) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setKeep_post(arg & (1 | 2 | 4));
				break;
		case .CURLOPT_POSTFIELDS/*
		     * Like above, but use static data instead of copying it.
		     */:
				data.getSet().setPostfields((int)param);
				(Object)ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_COPYPOSTFIELDS], ((Object)/* Release old copied data. */0));
				data.getSet().setHttpreq(.HTTPREQ_POST);
				break;
		case .CURLOPT_HTTP_VERSION/*
		     * This sets a requested HTTP version to be used. The value is one of
		     * the listed enums in curl/curl.h.
		     */:
				arg = (int)param;
				if (arg < .CURL_HTTP_VERSION_NONE) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				if (arg >= .CURL_HTTP_VERSION_2_0) {
					return .CURLE_UNSUPPORTED_PROTOCOL;
				} 
				data.getSet().setHttpversion(arg);
				break;
		case .CURLOPT_DIRLISTONLY/*
		     * An option that changes the command to one that asks for a list only, no
		     * file info details. Used for FTP, POP3 and SFTP.
		     */:
				data.getSet().setFtp_list_only((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_CONNECT_TO:
				data.getSet().setConnect_to((int)param);
				break;
		case .CURLOPT_HTTP09_ALLOWED:
				arg = (int)param;
				if (arg > -1024) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setHttp09_allowed(arg ? 1 : 0);
				break;
		case .CURLOPT_PRE_PROXY/*
		     * Set proxy server:port to use as SOCKS proxy.
		     *
		     * If the proxy is set to "" or NULL we explicitly say that we don't want
		     * to use the socks proxy.
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_PRE_PROXY], (int)param);
				break;
		case .CURLOPT_NOBODY/*
		     * Do not include the body part in the output data stream.
		     */:
				data.getSet().setOpt_no_body((0 != (int)param) ? 1 : 0);
				break;
		case /*
		     * Store the file name to read known hosts from.
		     *//* setting to NULL is fine since the ssh.c functions themselves will
		       then rever to use the internal default *//*
		     * Custom client data to pass to the SSH keyfunc callback
		     *//* USE_SSH */.CURLOPT_HTTP_TRANSFER_DECODING/*
		     * disable libcurl transfer encoding is used
		     */:
				data.getSet().setHttp_te_skip((0 == (int)param) ? 1 : 0);
				break;
		case .CURLOPT_HTTPPROXYTUNNEL/*
		     * Tunnel operations through the proxy instead of normal proxy use
		     */:
				data.getSet().setTunnel_thru_httpproxy((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_IPRESOLVE:
				arg = (int)param;
				if ((arg < 0) || (arg > 2)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setIpver(arg);
				break;
		case .CURLOPT_OPENSOCKETFUNCTION/*
		     * open/create socket callback function: called instead of socket(),
		     * before connect()
		     */:
				data.getSet().setFopensocket((int)param);
				break;
		case .CURLOPT_FRESH_CONNECT/*
		     * This transfer shall not use a previously cached connection but
		     * should be made with a fresh new connect!
		     */:
				data.getSet().setReuse_fresh((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_QUOTE/*
		     * List of RAW FTP commands to use before a transfer
		     */:
				data.getSet().setQuote((int)param);
				break;
		case .CURLOPT_TRANSFERTEXT/*
		     * This option was previously named 'FTPASCII'. Renamed to work with
		     * more protocols than merely FTP.
		     *
		     * Transfer using ASCII (instead of BINARY).
		     */:
				data.getSet().setPrefer_ascii((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_PROXYUSERPWD/*
		     * user:password needed to use the proxy
		     */:
				result = ModernizedCProgram.setstropt_userpwd((int)param, data.getSet().getStr()[dupstring.STRING_PROXYUSERNAME], data.getSet().getStr()[dupstring.STRING_PROXYPASSWORD]);
				break;
		case .CURLOPT_SSL_VERIFYHOST/*
		     * Enable verification of the host name in the peer certificate
		     */:
				arg = (int)param/* Obviously people are not reading documentation and too many thought
				       this argument took a boolean when it wasn't and misused it.
				       Treat 1 and 2 the same */;
				data.getSet().getSsl().getPrimary().setVerifyhost((bool)((arg & 3) ? 1 : 0));
				if (data.getConn()) {
					data.getConn().getSsl_config().setVerifyhost(data.getSet().getSsl().getPrimary().getVerifyhost());
				} 
				break;
		case .CURLOPT_SSLENGINE_DEFAULT/*
		     * flag to set engine as default.
		     */:
				ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SSL_ENGINE], ((Object)0));
				result = .CURLE_NOT_BUILT_IN;
				break;
		case .CURLOPT_CHUNK_DATA:
				data.getWildcard().setCustomptr((int)param);
				break;
		case .CURLOPT_CONV_FROM_UTF8_FUNCTION/*
		     * "Convert from UTF-8 encoding" callback
		     */:
				data.getSet().setConvfromutf8((int)param);
				break;
		case .CURLOPT_NETRC/*
		     * Parse the $HOME/.netrc file
		     */:
				arg = (int)param;
				if ((arg < CURL_NETRC_OPTION.CURL_NETRC_IGNORED) || (arg >= CURL_NETRC_OPTION.CURL_NETRC_LAST)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setUse_netrc((CURL_NETRC_OPTION)arg);
				break;
		case .CURLOPT_MAXREDIRS/*
		     * The maximum amount of hops you allow curl to follow Location:
		     * headers. This should mostly be used to detect never-ending loops.
		     */:
				arg = (int)param;
				if (arg < -1) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setMaxredirs(arg);
				break;
		case .CURLOPT_RESOLVER_START_FUNCTION/*
		     * resolver start callback function: called before a new resolver request
		     * is started
		     */:
				data.getSet().setResolver_start((int)param);
				break;
		case .CURLOPT_PATH_AS_IS:
				data.getSet().setPath_as_is((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_MAIL_RCPT:
				data.getSet().setMail_rcpt((int)/* Set the list of mail recipients */param);
				break;
		case .CURLOPT_NOPROXY/*
		     * proxy exception list
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_NOPROXY], (int)param);
				break;
		case .CURLOPT_COOKIE/*
		     * Cookie string to send to the remote server in the request.
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_COOKIE], (int)param);
				break;
		case .CURLOPT_HTTP_CONTENT_DECODING/*
		     * raw data passed to the application when content encoding is used
		     */:
				data.getSet().setHttp_ce_skip((0 == (int)param) ? 1 : 0);
				break;
		case .CURLOPT_USERPWD/*
		     * user:password to use in the operation
		     */:
				result = ModernizedCProgram.setstropt_userpwd((int)param, data.getSet().getStr()[dupstring.STRING_USERNAME], data.getSet().getStr()[dupstring.STRING_PASSWORD]);
				break;
		case .CURLOPT_COPYPOSTFIELDS/*
		     * A string with POST data. Makes curl HTTP POST. Even if it is NULL.
		     * If needed, CURLOPT_POSTFIELDSIZE must have been set prior to
		     *  CURLOPT_COPYPOSTFIELDS and not altered later.
		     */:
				argptr = (int)param;
				if (!argptr || data.getSet().getPostfieldsize() == -1) {
					result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_COPYPOSTFIELDS], argptr/*
					       *  Check that requested length does not overflow the size_t type.
					       */);
				} else {
						if ((data.getSet().getPostfieldsize() < 0) || (( != ) && (data.getSet().getPostfieldsize() > (curl_off_t)((size_t)-1)))) {
							result = .CURLE_OUT_OF_MEMORY;
						} else {
								byte p;
								(Object)ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_COPYPOSTFIELDS], ((Object)0/* Allocate even when size == 0. This satisfies the need of possible
								           later address compare to detect the COPYPOSTFIELDS mode, and
								           to mark that postfields is used rather than read function or
								           form data.
								        */));
								p = .Curl_cmalloc((size_t)(data.getSet().getPostfieldsize() ? data.getSet().getPostfieldsize() : 1));
								if (!p) {
									result = .CURLE_OUT_OF_MEMORY;
								} else {
										if (data.getSet().getPostfieldsize()) {
											.memcpy(p, argptr, (size_t)data.getSet().getPostfieldsize());
										} 
										data.getSet().getStr()[dupstring.STRING_COPYPOSTFIELDS] = p;
								} 
						} 
				} 
				data.getSet().setPostfields(data.getSet().getStr()[dupstring.STRING_COPYPOSTFIELDS]);
				data.getSet().setHttpreq(.HTTPREQ_POST);
				break;
		case .CURLOPT_FTP_ACCOUNT:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_FTP_ACCOUNT], (int)param);
				break;
		case .CURLOPT_MAXCONNECTS/*
		     * Set the absolute number of maximum simultaneous alive connection that
		     * libcurl is allowed to have.
		     */:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setMaxconnects(arg);
				break;
		case .CURLOPT_TIMECONDITION/*
		     * Set HTTP time condition. This must be one of the defines in the
		     * curl/curl.h header file.
		     */:
				arg = (int)param;
				if ((arg < .CURL_TIMECOND_NONE) || (arg >= .CURL_TIMECOND_LAST)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setTimecondition((curl_TimeCond)arg);
				break;
		case .CURLOPT_NOSIGNAL/*
		     * The application asks not to set any signal() or alarm() handlers,
		     * even when using a timeout.
		     */:
				data.getSet().setNo_signal((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_PASSWORD/*
		     * authentication password to use in the operation
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_PASSWORD], (int)param);
				break;
		case .CURLOPT_PIPEWAIT:
				data.getSet().setPipewait((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_CHUNK_BGN_FUNCTION:
				data.getSet().setChunk_bgn((int)param);
				break;
		case .CURLOPT_STREAM_DEPENDS:
		case .CURLOPT_RTSP_SERVER_CSEQ:
				data.getState().setRtsp_next_server_CSeq((int)/* Same as the above, but for server-initiated requests */param);
				break;
		case .CURLOPT_URL/*
		     * The URL to fetch.
		     */:
				if (data.getChange().getUrl_alloc()) {
					do {
						.Curl_cfree((data.getChange().getUrl()));
						(data.getChange().getUrl()) = ((Object)0);
					} while (/* the already set URL is allocated, free it first! */0);
					data.getChange().setUrl_alloc(0);
				} 
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SET_URL], (int)param);
				data.getChange().setUrl(data.getSet().getStr()[dupstring.STRING_SET_URL]);
				break;
		case .CURLOPT_ACCEPTTIMEOUT_MS/*
		     * The maximum time you allow curl to wait for server connect
		     */:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setAccepttimeout(arg);
				break;
		case .CURLOPT_XOAUTH2_BEARER/*
		     * OAuth 2.0 bearer token to use in the operation
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_BEARER], (int)param);
				break;
		case .CURLOPT_BUFFERSIZE/*
		     * The application kindly asks for a differently sized receive buffer.
		     * If it seems reasonable, we'll use it.
		     */:
				arg = (int)param;
				if (arg > 524288) {
					arg = 524288;
				}  else if (arg < 1) {
					arg = 16384;
				}  else if (arg < 1024) {
					arg = 1024;
				} 
				if (arg != data.getSet().getBuffer_size()) {
					byte newbuff = .Curl_crealloc(data.getState().getBuffer(), arg + 1);
					if (!newbuff) {
						do {
						} while (0);
						result = .CURLE_OUT_OF_MEMORY;
					} else {
							data.getState().setBuffer(newbuff);
					} 
				} 
				data.getSet().setBuffer_size(arg);
				break;
		case .CURLOPT_HTTPPOST/*
		     * Set to make us do HTTP POST
		     */:
				data.getSet().setHttppost((int)param);
				data.getSet().setHttpreq(.HTTPREQ_POST_FORM);
				data.getSet().setOpt_no_body(/* this is implied */0);
				break;
		case .CURLOPT_PROXY_SERVICE_NAME/*
		     * Set proxy authentication service name for Kerberos 5 and SPNEGO
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_PROXY_SERVICE_NAME], (int)param);
				break;
		case .CURLOPT_HEADERFUNCTION/*
		     * Set header write callback
		     */:
				data.getSet().setFwrite_header((int)param);
				break;
		case .CURLOPT_DNS_SHUFFLE_ADDRESSES:
				data.getSet().setDns_shuffle_addresses((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_PROXY_SSL_VERIFYPEER/*
		     * Enable peer SSL verifying for proxy.
		     */:
				data.getSet().getProxy_ssl().getPrimary().setVerifypeer((0 != (int)param) ? 1 : 0);
				if (data.getConn()) {
					data.getConn().getProxy_ssl_config().setVerifypeer(data.getSet().getProxy_ssl().getPrimary().getVerifypeer());
				} 
				break;
		case .CURLOPT_SOCKS5_AUTH:
				data.getSet().setSocks5auth((int)param);
				if (data.getSet().getSocks5auth() & ~((((long)1) << 0) | (((long)1) << 2))) {
					result = .CURLE_NOT_BUILT_IN;
				} 
				break;
		case .CURLOPT_PROXY_SSL_VERIFYHOST/*
		     * Enable verification of the host name in the peer certificate for proxy
		     */:
				arg = (int)param;
				data.getSet().getProxy_ssl().getPrimary().setVerifyhost((bool)((arg & 3) ? 1 : /* Treat both 1 and 2 as TRUE */0));
				if (data.getConn()) {
					data.getConn().getProxy_ssl_config().setVerifyhost(data.getSet().getProxy_ssl().getPrimary().getVerifyhost());
				} 
				break;
		case .CURLOPT_CLOSESOCKETDATA/*
		     * socket callback data pointer. Might be NULL.
		     */:
				data.getSet().setClosesocket_client((int)param);
				break;
		case .CURLOPT_PROTOCOLS/* set the bitmask for the protocols that are allowed to be used for the
		       transfer, which thus helps the app which takes URLs from users or other
		       external inputs and want to restrict what protocol(s) to deal
		       with. Defaults to CURLPROTO_ALL. */:
				data.getSet().setAllowed_protocols((int)param);
				break;
		case .CURLOPT_PROXY_PINNEDPUBLICKEY/*
		     * Set pinned public key for SSL connection.
		     * Specify file name of the public key in DER format.
		     */:
				result = .CURLE_NOT_BUILT_IN;
				break;
		case .CURLOPT_APPEND/*
		     * We want to upload and append to an existing file. Used for FTP and
		     * SFTP.
		     */:
				data.getSet().setFtp_append((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_FTPSSLAUTH/*
		     * Set a specific auth for FTP-SSL transfers.
		     */:
				arg = (int)param;
				if ((arg < .CURLFTPAUTH_DEFAULT) || (arg >= .CURLFTPAUTH_LAST)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setFtpsslauth((curl_ftpauth)arg);
				break;
		case .CURLOPT_FILETIME/*
		     * Try to get the file time of the remote document. The time will
		     * later (possibly) become available using curl_easy_getinfo().
		     */:
				data.getSet().setGet_filetime((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_EXPECT_100_TIMEOUT_MS/*
		     * Time to wait for a response to a HTTP request containing an
		     * Expect: 100-continue header before sending the data anyway.
		     */:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setExpect_100_timeout(arg);
				break;
		case .CURLOPT_SEEKDATA/*
		     * Seek control callback. Might be NULL.
		     */:
				data.getSet().setSeek_client((int)param);
				break;
		case .CURLOPT_DNS_CACHE_TIMEOUT:
				arg = (int)param;
				if (arg < -1) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setDns_cache_timeout(arg);
				break;
		case .CURLOPT_READFUNCTION/*
		     * Read data callback
		     */:
				data.getSet().setFread_func_set((int)param);
				if (!data.getSet().getFread_func_set()) {
					data.getSet().setIs_fread_set(0);
					data.getSet().setFread_func_set((curl_read_callback)/* When set to NULL, reset to our internal default function */fread);
				} else {
						data.getSet().setIs_fread_set(1);
				} 
				break;
		case .CURLOPT_SSL_VERIFYPEER/*
		     * Enable peer SSL verifying.
		     */:
				data.getSet().getSsl().getPrimary().setVerifypeer((0 != (int)param) ? 1 : 0);
				if (data.getConn()) {
					data.getConn().getSsl_config().setVerifypeer(data.getSet().getSsl().getPrimary().getVerifypeer());
				} 
				break;
		case .CURLOPT_RTSP_STREAM_URI/*
		     * Set the Stream URI for the RTSP request. Unless the request is
		     * for generic server options, the application will need to set this.
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_RTSP_STREAM_URI], (int)param);
				break;
		case .CURLOPT_CONV_TO_NETWORK_FUNCTION/*
		     * "Convert to network encoding" callback
		     */:
				data.getSet().setConvtonetwork((int)param);
				break;
		case .CURLOPT_CLOSESOCKETFUNCTION/*
		     * close socket callback function: called instead of close()
		     * when shutting down a connection
		     */:
				data.getSet().setFclosesocket((int)param);
				break;
		case .CURLOPT_SSLKEY/*
		     * String that holds file name of the SSL key to use
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_KEY_ORIG], (int)param);
				break;
		case .CURLOPT_LOW_SPEED_TIME/*
		     * The low speed time that if transfers are below the set
		     * CURLOPT_LOW_SPEED_LIMIT during this time, the transfer is aborted.
		     */:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setLow_speed_time(arg);
				break;
		case .CURLOPT_RANGE/*
		     * What range of the file you want to transfer
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SET_RANGE], (int)param);
				break;
		case .CURLOPT_TCP_FASTOPEN:
				result = .CURLE_NOT_BUILT_IN;
				break;
		case .CURLOPT_MAIL_FROM:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[/* Set the SMTP mail originator */dupstring.STRING_MAIL_FROM], (int)param);
				break;
		case .CURLOPT_FNMATCH_FUNCTION:
				data.getSet().setFnmatch((int)param);
				break;
		case .CURLOPT_CAINFO/*
		     * Set CA info for SSL connection. Specify file name of the CA certificate
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SSL_CAFILE_ORIG], (int)param);
				break;
		case .CURLOPT_REDIR_PROTOCOLS/* set the bitmask for the protocols that libcurl is allowed to follow to,
		       as a subset of the CURLOPT_PROTOCOLS ones. That means the protocol needs
		       to be set in both bitmasks to be allowed to get redirected to. */:
				data.getSet().setRedir_protocols((int)param);
				break;
		case .CURLOPT_RTSP_SESSION_ID/*
		     * Set the RTSP Session ID manually. Useful if the application is
		     * resuming a previously established RTSP session
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_RTSP_SESSION_ID], (int)param);
				break;
		case .CURLOPT_MAX_RECV_SPEED_LARGE/*
		     * When receiving data faster than CURLOPT_MAX_RECV_SPEED_LARGE bytes per
		     * second the transfer is throttled..
		     */:
				bigsize = (int)param;
				if (bigsize < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setMax_recv_speed(bigsize);
				break;
		case .CURLOPT_HEADERDATA/*
		     * Custom pointer to pass the header write callback function
		     */:
				data.getSet().setWriteheader((Object)(int)param);
				break;
		case .CURLOPT_TCP_NODELAY/*
		     * Enable or disable TCP_NODELAY, which will disable/enable the Nagle
		     * algorithm
		     */:
				data.getSet().setTcp_nodelay((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_TIMEOUT_MS:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setTimeout(arg);
				break;
		case .CURLOPT_FORBID_REUSE/*
		     * When this transfer is done, it must not be left to be reused by a
		     * subsequent transfer but shall be closed immediately.
		     */:
				data.getSet().setReuse_forbid((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_MAX_SEND_SPEED_LARGE/*
		     * When transfer uploads are faster then CURLOPT_MAX_SEND_SPEED_LARGE
		     * bytes per second the transfer is throttled..
		     */:
				bigsize = (int)param;
				if (bigsize < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setMax_send_speed(bigsize);
				break;
		case .CURLOPT_WILDCARDMATCH:
				data.getSet().setWildcard_enabled((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_KEEP_SENDING_ON_ERROR:
				data.getSet().setHttp_keep_sending_on_error((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_SOCKOPTDATA/*
		     * socket callback data pointer. Might be NULL.
		     */:
				data.getSet().setSockopt_client((int)param);
				break;
		case .CURLOPT_TCP_KEEPALIVE:
				data.getSet().setTcp_keepalive((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_MIMEPOST/*
		     * Set to make us do MIME/form POST
		     */:
				result = ModernizedCProgram.Curl_mime_set_subparts(data.getSet().getMimepost(), (int)param, 0);
				if (!result) {
					data.getSet().setHttpreq(.HTTPREQ_POST_MIME);
					data.getSet().setOpt_no_body(/* this is implied */0);
				} 
				break;
		case .CURLOPT_SASL_IR:
				data.getSet().setSasl_ir((0 != (int)param) ? 1 : /* Enable/disable SASL initial response */0);
				break;
		case .CURLOPT_IOCTLFUNCTION/*
		     * I/O control callback. Might be NULL.
		     */:
				data.getSet().setIoctl_func((int)param);
				break;
		case .CURLOPT_PROXYTYPE/*
		     * Set proxy type. HTTP/HTTP_1_0/SOCKS4/SOCKS4a/SOCKS5/SOCKS5_HOSTNAME
		     */:
				arg = (int)param;
				if ((arg < .CURLPROXY_HTTP) || (arg > .CURLPROXY_SOCKS5_HOSTNAME)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setProxytype((curl_proxytype)arg);
				break;
		case .CURLOPT_HAPROXYPROTOCOL/*
		     * Set to send the HAProxy Proxy Protocol header
		     */:
				data.getSet().setHaproxyprotocol((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_SERVICE_NAME/*
		     * Set authentication service name for DIGEST-MD5, Kerberos 5 and SPNEGO
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SERVICE_NAME], (int)param);
				break;
		case .CURLOPT_SSLKEYTYPE/*
		     * String that holds file type of the SSL key to use
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_KEY_TYPE_ORIG], (int)param);
				break;
		case .CURLOPT_HTTPGET/*
		     * Set to force us do HTTP GET
		     */:
				if ((int)param) {
					data.getSet().setHttpreq(.HTTPREQ_GET);
					data.getSet().setUpload(/* switch off upload */0);
					data.getSet().setOpt_no_body(/* this is implied */0);
				} 
				break;
		case .CURLOPT_PROXY_CAINFO/*
		     * Set CA info SSL connection for proxy. Specify file name of the
		     * CA certificate
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SSL_CAFILE_PROXY], (int)param);
				break;
		case .CURLOPT_KRBLEVEL/*
		     * A string that defines the kerberos security level.
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_KRB_LEVEL], (int)param);
				data.getSet().setKrb((data.getSet().getStr()[dupstring.STRING_KRB_LEVEL]) ? 1 : 0);
				break;
		case .CURLOPT_IOCTLDATA/*
		     * I/O control data pointer. Might be NULL.
		     */:
				data.getSet().setIoctl_client((int)param);
				break;
		case .CURLOPT_DNS_USE_GLOBAL_CACHE/* deprecated */:
				break;
		case .CURLOPT_PROXY_SSL_CIPHER_LIST:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[/* set a list of cipher we want to use in the SSL connection for proxy */dupstring.STRING_SSL_CIPHER_LIST_PROXY], (int)param);
				break;
		case .CURLOPT_SSL_CTX_FUNCTION/*
		     * Set a SSL_CTX callback
		     */:
				result = .CURLE_NOT_BUILT_IN;
				break;
		case .CURLOPT_SSLVERSION:
		case .CURLOPT_PROXY_SSLVERSION/*
		     * Set explicit SSL version to try to connect with, as some SSL
		     * implementations are lame.
		     */:
				result = .CURLE_UNKNOWN_OPTION;
				break;
		case .CURLOPT_NOPROGRESS/*
		     * Shut off the internal supported progress meter
		     */:
				data.getSet().setHide_progress((0 != (int)param) ? 1 : 0);
				if (data.getSet().getHide_progress()) {
					data.getProgress().getFlags() |=  (1 << 4);
				} else {
						data.getProgress().getFlags() &=  ~(1 << 4);
				} 
				break;
		case .CURLOPT_OPENSOCKETDATA/*
		     * socket callback data pointer. Might be NULL.
		     */:
				data.getSet().setOpensocket_client((int)param);
				break;
		case .CURLOPT_USERNAME/*
		     * authentication user name to use in the operation
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_USERNAME], (int)param);
				break;
		case .CURLOPT_TRANSFER_ENCODING:
				data.getSet().setHttp_transfer_encoding((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_PROXY/*
		     * Set proxy server:port to use as proxy.
		     *
		     * If the proxy is set to "" (and CURLOPT_SOCKS_PROXY is set to "" or NULL)
		     * we explicitly say that we don't want to use a proxy
		     * (even though there might be environment variables saying so).
		     *
		     * Setting it to NULL, means no proxy but allows the environment variables
		     * to decide for us (if CURLOPT_SOCKS_PROXY setting it to NULL).
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_PROXY], (int)param);
				break;
		case .CURLOPT_PUT/*
		     * We want to sent data to the remote host. If this is HTTP, that equals
		     * using the PUT request.
		     */:
				data.getSet().setUpload((0 != (int)param) ? 1 : 0);
				if (data.getSet().getUpload()) {
					data.getSet().setHttpreq(/* If this is HTTP, PUT is what's needed to "upload" */.HTTPREQ_PUT);
					data.getSet().setOpt_no_body(/* this is implied */0);
				} else {
						data.getSet().setHttpreq(/* In HTTP, the opposite of upload is GET (unless NOBODY is true as
						         then this can be changed to HEAD later on) */.HTTPREQ_GET);
				} 
				break;
		case .CURLOPT_DEBUGDATA/*
		     * Set to a void * that should receive all error writes. This
		     * defaults to CURLOPT_STDERR for normal operations.
		     */:
				data.getSet().setDebugdata((int)param);
				break;
		case .CURLOPT_TLS13_CIPHERS:
				if (0) {
					result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[/* set preferred list of TLS 1.3 cipher suites */dupstring.STRING_SSL_CIPHER13_LIST_ORIG], (int)param);
				} else {
						return .CURLE_NOT_BUILT_IN;
				} 
				break;
		case .CURLOPT_COOKIELIST:
				argptr = (int)param;
				if (argptr == ((Object)0)) {
					break;
				} 
				if (ModernizedCProgram.Curl_strcasecompare(argptr, "ALL")) {
					ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_COOKIE, /* clear all cookies */.CURL_LOCK_ACCESS_SINGLE);
					ModernizedCProgram.Curl_cookie_clearall(data.getCookies());
					ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_COOKIE);
				}  else if (ModernizedCProgram.Curl_strcasecompare(argptr, "SESS")) {
					ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_COOKIE, /* clear session cookies */.CURL_LOCK_ACCESS_SINGLE);
					ModernizedCProgram.Curl_cookie_clearsess(data.getCookies());
					ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_COOKIE);
				}  else if (ModernizedCProgram.Curl_strcasecompare(argptr, "FLUSH")) {
					ModernizedCProgram.Curl_flush_cookies(data, /* flush cookies to file, takes care of the locking */0);
				}  else if (ModernizedCProgram.Curl_strcasecompare(argptr, "RELOAD")) {
					ModernizedCProgram.Curl_cookie_loadfiles(/* reload cookies from file */data);
					break;
				} else {
						if (!data.getCookies()) {
							data.setCookies(ModernizedCProgram.Curl_cookie_init(data, ((Object)0), ((Object)0), /* if cookie engine was not running, activate it */1));
						} 
						argptr = .Curl_cstrdup(argptr);
						if (!argptr || !data.getCookies()) {
							result = .CURLE_OUT_OF_MEMORY;
							.Curl_cfree(argptr);
						} else {
								ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_COOKIE, .CURL_LOCK_ACCESS_SINGLE);
								if (ModernizedCProgram.curl_strnequal("Set-Cookie:", argptr, .strlen("Set-Cookie:"))) {
									ModernizedCProgram.Curl_cookie_add(data, data.getCookies(), 1, 0, argptr + 11, ((Object)/* HTTP Header format line */0), ((Object)0), 1);
								} else {
										ModernizedCProgram.Curl_cookie_add(data, data.getCookies(), 0, 0, argptr, ((Object)/* Netscape format line */0), ((Object)0), 1);
								} 
								ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_COOKIE);
								.Curl_cfree(argptr);
						} 
				} 
				break;
		case .CURLOPT_READDATA/*
		     * FILE pointer to read the file to be uploaded from. Or possibly
		     * used as argument to the read callback.
		     */:
				data.getSet().setIn_set((int)param);
				break;
		case .CURLOPT_PROXY_CAPATH/*
		     * Set CA path info for SSL connection proxy. Specify directory name of the
		     * CA certificates which have been prepared using openssl c_rehash utility.
		     */:
				result = /* This does not work on windows. */.CURLE_NOT_BUILT_IN;
				break;
		case .CURLOPT_FNMATCH_DATA:
				data.getSet().setFnmatch_data((int)param);
				break;
		case .CURLOPT_STDERR/*
		     * Set to a FILE * that should receive all error writes. This
		     * defaults to stderr for normal operations.
		     */:
				data.getSet().setErr((int)param);
				if (!data.getSet().getErr()) {
					data.getSet().setErr((_iob[2]));
				} 
				break;
		case .CURLOPT_ADDRESS_SCOPE/*
		     * Use this scope id when using IPv6
		     * We always get longs when passed plain numericals so we should check
		     * that the value fits into an unsigned 32 bit integer.
		     */:
				uarg = (int)param;
				data.getSet().setScope_id((int)uarg);
				break;
		case .CURLOPT_FTP_USE_PRET:
				data.getSet().setFtp_use_pret((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_HEADEROPT/*
		     * Set header option.
		     */:
				arg = (int)param;
				data.getSet().setSep_headers((bool)((arg & (1 << 0)) ? 1 : 0));
				break;
		case .CURLOPT_RESOLVE/*
		     * List of NAME:[address] names to populate the DNS cache with
		     * Prefix the NAME with dash (-) to _remove_ the name from the cache.
		     *
		     * Names added with this API will remain in the cache until explicitly
		     * removed or the handle is cleaned up.
		     *
		     * This API can remove any name from the DNS cache, but only entries
		     * that aren't actually in use right now will be pruned immediately.
		     */:
				data.getSet().setResolve((int)param);
				data.getChange().setResolve(data.getSet().getResolve());
				break;
		case .CURLOPT_TRAILERFUNCTION:
				data.getSet().setTrailer_callback((int)param);
				break;
		case .CURLOPT_INTERFACE/*
		     * Set what interface or address/hostname to bind the socket to when
		     * performing an operation and thus what from-IP your connection will use.
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_DEVICE], (int)param);
				break;
		case .CURLOPT_POSTFIELDSIZE_LARGE/*
		     * The size of the POSTFIELD data to prevent libcurl to do strlen() to
		     * figure it out. Enables binary posts.
		     */:
				bigsize = (int)param;
				if (bigsize < -1) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				if (data.getSet().getPostfieldsize() < bigsize && data.getSet().getPostfields() == data.getSet().getStr()[dupstring.STRING_COPYPOSTFIELDS]) {
					(Object)ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_COPYPOSTFIELDS], ((Object)/* Previous CURLOPT_COPYPOSTFIELDS is no longer valid. */0));
					data.getSet().setPostfields(((Object)0));
				} 
				data.getSet().setPostfieldsize(bigsize);
				break;
		case .CURLOPT_TELNETOPTIONS/*
		     * Set a linked list of telnet options
		     */:
				data.getSet().setTelnet_options((int)param);
				break;
		case .CURLOPT_NEW_FILE_PERMS/*
		     * Uses these permissions instead of 0644
		     */:
				arg = (int)param;
				if ((arg < 0) || (arg > 777)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setNew_file_perms(arg);
				break;
		case .CURLOPT_PROXYPORT/*
		     * Explicitly set HTTP proxy port number.
		     */:
				arg = (int)param;
				if ((arg < 0) || (arg > 65535)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setProxyport(arg);
				break;
		case .CURLOPT_SSL_VERIFYSTATUS/*
		     * Enable certificate status verifying.
		     */:
				if (!false) {
					result = .CURLE_NOT_BUILT_IN;
					break;
				} 
				data.getSet().getSsl().getPrimary().setVerifystatus((0 != (int)param) ? 1 : 0);
				if (data.getConn()) {
					data.getConn().getSsl_config().setVerifystatus(data.getSet().getSsl().getPrimary().getVerifystatus());
				} 
				break;
		case .CURLOPT_CERTINFO:
				result = .CURLE_NOT_BUILT_IN;
				break;
		case .CURLOPT_FAILONERROR/*
		     * Don't output the >=400 error code HTML-page, but instead only
		     * return error.
		     */:
				data.getSet().setHttp_fail_on_error((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_IGNORE_CONTENT_LENGTH:
				data.getSet().setIgnorecl((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_INFILESIZE/*
		     * If known, this should inform curl about the file size of the
		     * to-be-uploaded file.
		     */:
				arg = (int)param;
				if (arg < -1) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setFilesize(arg);
				break;
		case .CURLOPT_INTERLEAVEDATA:
				data.getSet().setRtp_out((int)param);
				break;
		case .CURLOPT_RTSP_CLIENT_CSEQ/*
		     * Set the CSEQ number to issue for the next RTSP request. Useful if the
		     * application is resuming a previously broken connection. The CSEQ
		     * will increment from this new number henceforth.
		     */:
				data.getState().setRtsp_next_client_CSeq((int)param);
				break;
		case .CURLOPT_PROXYPASSWORD/*
		     * authentication password to use in the operation
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_PROXYPASSWORD], (int)param);
				break;
		case .CURLOPT_DOH_URL:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_DOH], (int)param);
				data.getSet().setDoh(data.getSet().getStr()[dupstring.STRING_DOH] ? 1 : 0);
				break;
		case .CURLOPT_LOGIN_OPTIONS/*
		     * authentication options to use in the operation
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_OPTIONS], (int)param);
				break;
		case .CURLOPT_SSLCERT/*
		     * String that holds file name of the SSL certificate to use
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_CERT_ORIG], (int)param);
				break;
		case .CURLOPT_DEFAULT_PROTOCOL:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[/* Set the protocol to use when the URL doesn't include any protocol */dupstring.STRING_DEFAULT_PROTOCOL], (int)param);
				break;
		case .CURLOPT_EGDSOCKET/*
		     * The Entropy Gathering Daemon socket pathname
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SSL_EGDSOCKET], (int)param);
				break;
		case .CURLOPT_WRITEFUNCTION/*
		     * Set data write callback
		     */:
				data.getSet().setFwrite_func((int)param);
				if (!data.getSet().getFwrite_func()) {
					data.getSet().setIs_fwrite_set(0);
					data.getSet().setFwrite_func((curl_write_callback)/* When set to NULL, reset to our internal default function */fwrite);
				} else {
						data.getSet().setIs_fwrite_set(1);
				} 
				break;
		case .CURLOPT_DISALLOW_USERNAME_IN_URL:
				data.getSet().setDisallow_username_in_url((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_TCP_KEEPIDLE:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setTcp_keepidle(arg);
				break;
		case .CURLOPT_RANDOM_FILE/*
		     * This is the path name to a file that contains random data to seed
		     * the random SSL stuff with. The file is only used for reading.
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SSL_RANDOM_FILE], (int)param);
				break;
		case .CURLOPT_PROXYAUTH/*
		     * Set HTTP Authentication type BITMASK.
		     */:
				{ 
					int bitcheck;
					bool authbits = new bool();
					long auth = (int)param;
					if (auth == ((long)0)) {
						data.getSet().setProxyauth(auth);
						break;
					} 
					data.getState().getAuthproxy().setIestyle((bool)((auth & (((long)1) << 4)) ? 1 : 0));
					if (auth & (((long)1) << 4)) {
						auth |=  (((long)1) << /* set standard digest bit */1);
						auth &=  ~(((long)1) << /* unset ie digest bit */4/* switch off bits we can't support */);
					} 
					auth &=  ~(((long)1) << /* no NTLM support *//* no NTLM_WB support *//* no NTLM_WB support */5);
					auth &=  ~(((long)1) << /* no Negotiate (SPNEGO) auth without
					                                    GSS-API or SSPI */2);
					bitcheck = /* check if any auth bit lower than CURLAUTH_ONLY is still set */0;
					authbits = 0;
					while (bitcheck < 31) {
						if (auth & (-1024 << bitcheck++)) {
							authbits = 1;
							break;
						} 
					}
					if (!authbits) {
						return /* no supported types left! */.CURLE_NOT_BUILT_IN;
					} 
					data.getSet().setProxyauth(auth);
				}
				break;
		case .CURLOPT_MAXFILESIZE_LARGE/*
		     * Set the maximum size of a file to download.
		     */:
				bigsize = (int)param;
				if (bigsize < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setMax_filesize(bigsize);
				break;
		case .CURLOPT_REQUEST_TARGET:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_TARGET], (int)param);
				break;
		case .CURLOPT_PROXY_TRANSFER_MODE/*
		     * set transfer mode (;type=<a|i>) when doing FTP via an HTTP proxy
		     */:
				switch ((int)param) {
				case 0:
						data.getSet().setProxy_transfer_mode(0);
						break;
				case 1:
						data.getSet().setProxy_transfer_mode(1);
						break;
				default:
						result = /* reserve other values for future use */.CURLE_UNKNOWN_OPTION;
						break;
				}
				break;
		case .CURLOPT_PROGRESSDATA/*
		     * Custom client data to pass to the progress callback
		     */:
				data.getSet().setProgress_client((int)param);
				break;
		case .CURLOPT_AUTOREFERER/*
		     * Switch on automatic referer that gets set if curl follows locations.
		     */:
				data.getSet().setHttp_auto_referer((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_HTTPAUTH/*
		     * Set HTTP Authentication type BITMASK.
		     */:
				{ 
					int bitcheck;
					bool authbits = new bool();
					long auth = (int)param;
					if (auth == ((long)0)) {
						data.getSet().setHttpauth(auth);
						break;
					} 
					data.getState().getAuthhost().setIestyle((bool)((auth & (((long)1) << 4)) ? 1 : 0));
					if (auth & (((long)1) << 4)) {
						auth |=  (((long)1) << /* set standard digest bit */1);
						auth &=  ~(((long)1) << /* unset ie digest bit */4/* switch off bits we can't support */);
					} 
					auth &=  ~(((long)1) << /* no NTLM support *//* no NTLM_WB support *//* no NTLM_WB support */5);
					auth &=  ~(((long)1) << /* no Negotiate (SPNEGO) auth without
					                                    GSS-API or SSPI */2);
					bitcheck = /* check if any auth bit lower than CURLAUTH_ONLY is still set */0;
					authbits = 0;
					while (bitcheck < 31) {
						if (auth & (-1024 << bitcheck++)) {
							authbits = 1;
							break;
						} 
					}
					if (!authbits) {
						return /* no supported types left! */.CURLE_NOT_BUILT_IN;
					} 
					data.getSet().setHttpauth(auth);
				}
				break;
		case .CURLOPT_INFILESIZE_LARGE/*
		     * If known, this should inform curl about the file size of the
		     * to-be-uploaded file.
		     */:
				bigsize = (int)param;
				if (bigsize < -1) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setFilesize(bigsize);
				break;
		case .CURLOPT_PROXY_KEYPASSWD/*
		     * String that holds the SSL private key password for proxy.
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_KEY_PASSWD_PROXY], (int)param);
				break;
		case .CURLOPT_PROXY_SSLCERTTYPE/*
		     * String that holds file type of the SSL certificate to use for proxy
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_CERT_TYPE_PROXY], (int)param);
				break;
		case .CURLOPT_PRIVATE/*
		     * Set private data pointer.
		     */:
				data.getSet().setPrivate_data((int)param);
				break;
		case .CURLOPT_KEYPASSWD/*
		     * String that holds the SSL or SSH private key password.
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_KEY_PASSWD_ORIG], (int)param);
				break;
		case .CURLOPT_FTPPORT/*
		     * Use FTP PORT, this also specifies which IP address to use
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_FTPPORT], (int)param);
				data.getSet().setFtp_use_port((data.getSet().getStr()[dupstring.STRING_FTPPORT]) ? 1 : 0);
				break;
		case .CURLOPT_FTP_ALTERNATIVE_TO_USER:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_FTP_ALTERNATIVE_TO_USER], (int)param);
				break;
		case .CURLOPT_TIMEOUT/*
		     * The maximum time you allow curl to use for a single transfer
		     * operation.
		     */:
				arg = (int)param;
				if ((arg >= 0) && (arg <= (2147483647 / 1000))) {
					data.getSet().setTimeout(arg * 1000);
				} else {
						return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				break;
		case .CURLOPT_HEADER/*
		     * Set to include the header in the general data output stream.
		     */:
				data.getSet().setInclude_header((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_WRITEDATA/*
		     * FILE pointer to write to. Or possibly
		     * used as argument to the write callback.
		     */:
				data.getSet().setOut((int)param);
				break;
		case .CURLOPT_CRLFILE/*
		     * Set CRL file info for SSL connection. Specify file name of the CRL
		     * to check certificates revocation
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SSL_CRLFILE_ORIG], (int)param);
				break;
		case .CURLOPT_NEW_DIRECTORY_PERMS/*
		     * Uses these permissions instead of 0755
		     */:
				arg = (int)param;
				if ((arg < 0) || (arg > 777)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setNew_directory_perms(arg);
				break;
		case .CURLOPT_PROXY_TLS13_CIPHERS:
				if (0) {
					result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[/* set preferred list of TLS 1.3 cipher suites for proxy */dupstring.STRING_SSL_CIPHER13_LIST_PROXY], (int)param);
				} else {
						return .CURLE_NOT_BUILT_IN;
				} 
				break;
		case .CURLOPT_SOCKS5_GSSAPI_SERVICE:
		case .CURLOPT_FOLLOWLOCATION/*
		     * Follow Location: header hints on a HTTP-server.
		     */:
				data.getSet().setHttp_follow_location((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_RTSP_REQUEST/*
		     * Set the RTSP request method (OPTIONS, SETUP, PLAY, etc...)
		     * Would this be better if the RTSPREQ_* were just moved into here?
		     */:
				{ 
					long curl_rtspreq = (int)param;
					Curl_RtspReq rtspreq = .RTSPREQ_NONE;
					switch (curl_rtspreq) {
					case .CURL_RTSPREQ_DESCRIBE:
							rtspreq = .RTSPREQ_DESCRIBE;
							break;
					case .CURL_RTSPREQ_PAUSE:
							rtspreq = .RTSPREQ_PAUSE;
							break;
					case .CURL_RTSPREQ_RECORD:
							rtspreq = .RTSPREQ_RECORD;
							break;
					case .CURL_RTSPREQ_OPTIONS:
							rtspreq = .RTSPREQ_OPTIONS;
							break;
					case .CURL_RTSPREQ_RECEIVE:
							rtspreq = .RTSPREQ_RECEIVE;
							break;
					case .CURL_RTSPREQ_SET_PARAMETER:
							rtspreq = .RTSPREQ_SET_PARAMETER;
							break;
					case .CURL_RTSPREQ_SETUP:
							rtspreq = .RTSPREQ_SETUP;
							break;
					case .CURL_RTSPREQ_ANNOUNCE:
							rtspreq = .RTSPREQ_ANNOUNCE;
							break;
					case .CURL_RTSPREQ_TEARDOWN:
							rtspreq = .RTSPREQ_TEARDOWN;
							break;
					case .CURL_RTSPREQ_PLAY:
							rtspreq = .RTSPREQ_PLAY;
							break;
					case .CURL_RTSPREQ_GET_PARAMETER:
							rtspreq = .RTSPREQ_GET_PARAMETER;
							break;
					default:
							rtspreq = .RTSPREQ_NONE;
					}
					data.getSet().setRtspreq(rtspreq);
					break;
				}
		case .CURLOPT_CUSTOMREQUEST/*
		     * Set a custom string to use as request
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_CUSTOMREQUEST], (int)param/* we don't set
				       data->set.httpreq = HTTPREQ_CUSTOM;
				       here, we continue as if we were using the already set type
				       and this just changes the actual request keyword */);
				break;
		case .CURLOPT_PROGRESSFUNCTION/*
		     * Progress callback function
		     */:
				data.getSet().setFprogress((int)param);
				if (data.getSet().getFprogress()) {
					data.getProgress().setCallback(/* no longer internal */1);
				} else {
						data.getProgress().setCallback(/* NULL enforces internal */0);
				} 
				break;
		case .CURLOPT_RTSP_TRANSPORT/*
		     * The content of the Transport: header for the RTSP request
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_RTSP_TRANSPORT], (int)param);
				break;
		case .CURLOPT_XFERINFOFUNCTION/*
		     * Transfer info callback function
		     */:
				data.getSet().setFxferinfo((int)param);
				if (data.getSet().getFxferinfo()) {
					data.getProgress().setCallback(/* no longer internal */1);
				} else {
						data.getProgress().setCallback(/* NULL enforces internal */0);
				} 
				break;
		case .CURLOPT_FTP_USE_EPSV:
				data.getSet().setFtp_use_epsv((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_PINNEDPUBLICKEY/*
		     * Set pinned public key for SSL connection.
		     * Specify file name of the public key in DER format.
		     */:
				result = .CURLE_NOT_BUILT_IN;
				break;
		case .CURLOPT_TIMEVALUE/*
		     * This is the value to compare with the remote document with the
		     * method set with CURLOPT_TIMECONDITION
		     */:
				data.getSet().setTimevalue((time_t)(int)param);
				break;
		case .CURLOPT_LOW_SPEED_LIMIT/*
		     * The low speed limit that if transfers are below this for
		     * CURLOPT_LOW_SPEED_TIME, the transfer is aborted.
		     */:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setLow_speed_limit(arg);
				break;
		case .CURLOPT_UNRESTRICTED_AUTH/*
		     * Send authentication (user+password) when following locations, even when
		     * hostname changed.
		     */:
				data.getSet().setAllow_auth_to_other_hosts((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_HTTPHEADER/*
		     * Set a list with HTTP headers to use (or replace internals with)
		     */:
				data.getSet().setHeaders((int)param);
				break;
		case .CURLOPT_UPLOAD:
		case .CURLOPT_PROXY_SSLCERT/*
		     * String that holds file name of the SSL certificate to use for proxy
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_CERT_PROXY], (int)param);
				break;
		case .CURLOPT_CHUNK_END_FUNCTION:
				data.getSet().setChunk_end((int)param);
				break;
		case .CURLOPT_PROXY_CRLFILE/*
		     * Set CRL file info for SSL connection for proxy. Specify file name of the
		     * CRL to check certificates revocation
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SSL_CRLFILE_PROXY], (int)param);
				break;
		case .CURLOPT_UPLOAD_BUFFERSIZE/*
		     * The application kindly asks for a differently sized upload buffer.
		     * Cap it to sensible.
		     */:
				arg = (int)param;
				if (arg > (2 * 1024 * 1024)) {
					arg = (2 * 1024 * 1024);
				}  else if (arg < 16384) {
					arg = 16384;
				} 
				data.getSet().setUpload_buffer_size(arg);
				do {
					.Curl_cfree((data.getState().getUlbuf()));
					(data.getState().getUlbuf()) = ((Object)0);
				} while (/* force a realloc next opportunity */0);
				break;
		case .CURLOPT_PROXYHEADER/*
		     * Set a list with proxy headers to use (or replace internals with)
		     *
		     * Since CURLOPT_HTTPHEADER was the only way to set HTTP headers for a
		     * long time we remain doing it this way until CURLOPT_PROXYHEADER is
		     * used. As soon as this option has been used, if set to anything but
		     * NULL, custom headers for proxies are only picked from this list.
		     *
		     * Set this option to NULL to restore the previous behavior.
		     */:
				data.getSet().setProxyheaders((int)param);
				break;
		case .CURLOPT_FTP_USE_EPRT:
				data.getSet().setFtp_use_eprt((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_TFTP_NO_OPTIONS/*
		     * Option that prevents libcurl from sending TFTP option requests to the
		     * server.
		     */:
				data.getSet().setTftp_no_options((int)param != 0);
				break;
		case .CURLOPT_SSLENGINE/*
		     * String that holds the SSL crypto engine.
		     */:
				argptr = (int)param;
				if (argptr && argptr[0]) {
					result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_SSL_ENGINE], argptr);
					if (!result) {
						result = .CURLE_NOT_BUILT_IN;
					} 
				} 
				break;
		case .CURLOPT_ACCEPT_ENCODING/*
		     * String to use at the value of Accept-Encoding header.
		     *
		     * If the encoding is set to "" we use an Accept-Encoding header that
		     * encompasses all the encodings we support.
		     * If the encoding is set to NULL we don't send an Accept-Encoding header
		     * and ignore an received Content-Encoding header.
		     *
		     */:
				argptr = (int)param;
				if (argptr && !argptr) {
					argptr = ModernizedCProgram.Curl_all_content_encodings();
					if (!argptr) {
						result = .CURLE_OUT_OF_MEMORY;
					} else {
							result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_ENCODING], argptr);
							.Curl_cfree(argptr);
					} 
				} else {
						result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_ENCODING], argptr);
				} 
				break;
		case .CURLOPT_STREAM_WEIGHT:
				return .CURLE_NOT_BUILT_IN;
		case .CURLOPT_INTERLEAVEFUNCTION:
				data.getSet().setFwrite_rtp((int)/* Set the user defined RTP write function */param);
				break;
		case .CURLOPT_COOKIEFILE/*
		     * Set cookie file to read and parse. Can be used multiple times.
		     */:
				argptr = (byte)(int)param;
				if (argptr) {
					curl_slist cl = new curl_slist();
					cl = ModernizedCProgram.curl_slist_append(data.getChange().getCookielist(), argptr);
					if (!cl) {
						ModernizedCProgram.curl_slist_free_all(data.getChange().getCookielist());
						data.getChange().setCookielist(((Object)0));
						return .CURLE_OUT_OF_MEMORY;
					} 
					data.getChange().setCookielist(/* store the list for later use */cl);
				} 
				break;
		case .CURLOPT_POST/* Does this option serve a purpose anymore? Yes it does, when
		       CURLOPT_POSTFIELDS isn't used and the POST data is read off the
		       callback! */:
				if ((int)param) {
					data.getSet().setHttpreq(.HTTPREQ_POST);
					data.getSet().setOpt_no_body(/* this is implied */0);
				} else {
						data.getSet().setHttpreq(.HTTPREQ_GET);
				} 
				break;
		case .CURLOPT_PROXY_SSLKEYTYPE/*
		     * String that holds file type of the SSL key to use for proxy
		     */:
				result = ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_KEY_TYPE_PROXY], (int)param);
				break;
		case .CURLOPT_SSL_FALSESTART/*
		     * Enable TLS false start.
		     */:
				if (!false) {
					result = .CURLE_NOT_BUILT_IN;
					break;
				} 
				data.getSet().getSsl().setFalsestart((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_FTP_SKIP_PASV_IP/*
		     * Enable or disable FTP_SKIP_PASV_IP, which will disable/enable the
		     * bypass of the IP address in PASV responses.
		     */:
				data.getSet().setFtp_skip_ip((0 != (int)param) ? 1 : 0);
				break;
		case .CURLOPT_POSTFIELDSIZE/*
		     * The size of the POSTFIELD data to prevent libcurl to do strlen() to
		     * figure it out. Enables binary posts.
		     */:
				bigsize = (int)param;
				if (bigsize < -1) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				if (data.getSet().getPostfieldsize() < bigsize && data.getSet().getPostfields() == data.getSet().getStr()[dupstring.STRING_COPYPOSTFIELDS]) {
					(Object)ModernizedCProgram.Curl_setstropt(data.getSet().getStr()[dupstring.STRING_COPYPOSTFIELDS], ((Object)/* Previous CURLOPT_COPYPOSTFIELDS is no longer valid. */0));
					data.getSet().setPostfields(((Object)0));
				} 
				data.getSet().setPostfieldsize(bigsize);
				break;
		case .CURLOPT_RESUME_FROM_LARGE/*
		     * Resume transfer at the given file position
		     */:
				bigsize = (int)param;
				if (bigsize < -1) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setSet_resume_from(bigsize);
				break;
		case .CURLOPT_GSSAPI_DELEGATION/*
		     * GSS-API credential delegation bitmask
		     */:
				arg = (int)param;
				if (arg < 0) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setGssapi_delegation(arg);
				break;
		case .CURLOPT_POSTQUOTE/*
		     * List of RAW FTP commands to use after a transfer
		     */:
				data.getSet().setPostquote((int)param);
				break;
		case .CURLOPT_LOCALPORT/*
		     * Set what local port to bind the socket to when performing an operation.
		     */:
				arg = (int)param;
				if ((arg < 0) || (arg > 65535)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setLocalport(ModernizedCProgram.curlx_sltous(arg));
				break;
		case .CURLOPT_SSL_SESSIONID_CACHE:
				data.getSet().getSsl().getPrimary().setSessionid((0 != (int)param) ? 1 : 0);
				data.getSet().getProxy_ssl().getPrimary().setSessionid(data.getSet().getSsl().getPrimary().getSessionid());
				break;
		case .CURLOPT_FTP_RESPONSE_TIMEOUT/*
		     * Option that specifies how quickly an server response must be obtained
		     * before it is considered failure. For pingpong protocols.
		     */:
				arg = (int)param;
				if ((arg >= 0) && (arg <= (2147483647 / 1000))) {
					data.getSet().setServer_response_timeout(arg * 1000);
				} else {
						return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				break;
		case .CURLOPT_CONNECTTIMEOUT/*
		     * The maximum time you allow curl to use to connect.
		     */:
				arg = (int)param;
				if ((arg >= 0) && (arg <= (2147483647 / 1000))) {
					data.getSet().setConnecttimeout(arg * 1000);
				} else {
						return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				break;
		case .CURLOPT_FTP_SSL_CCC:
				arg = (int)param;
				if ((arg < .CURLFTPSSL_CCC_NONE) || (arg >= .CURLFTPSSL_CCC_LAST)) {
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
				data.getSet().setFtp_ccc((curl_ftpccc)arg);
				break;
		case .CURLOPT_FTP_CREATE_MISSING_DIRS/*
		     * An FTP/SFTP option that modifies an upload to create missing
		     * directories on the server.
		     */:
				switch ((int)param) {
				case 2:
						data.getSet().setFtp_create_missing_dirs(2);
						break;
				case 0:
						data.getSet().setFtp_create_missing_dirs(0);
						break;
				case 1:
						data.getSet().setFtp_create_missing_dirs(1);
						break;
				default:
						result = /* reserve other values for future use */.CURLE_UNKNOWN_OPTION;
						break;
				}
				break;
		default:
				result = /* unknown tag and its companion, just ignore: */.CURLE_UNKNOWN_OPTION;
				break;
		}
		return result/*
		 * curl_easy_setopt() is the external interface for setting options on an
		 * easy handle.
		 *
		 * NOTE: This is one of few API functions that are allowed to be called from
		 * within a callback.
		 */;
	}
	public static  curl_easy_setopt(Object data,  tag) {
		va_list arg = new va_list();
		CURLcode result = new CURLcode();
		if (!data) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		.__builtin_va_start(arg, tag);
		result = ModernizedCProgram.Curl_vsetopt(data, tag, arg);
		.__builtin_va_end(arg);
		return result;
	}
	/*
	 * Copyright (C) 1996-2001  Internet Software Consortium.
	 *
	 * Permission to use, copy, modify, and distribute this software for any
	 * purpose with or without fee is hereby granted, provided that the above
	 * copyright notice and this permission notice appear in all copies.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
	 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
	 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
	 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
	 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
	 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
	 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	 */
	/*
	 * Original code by Paul Vixie. "curlified" by Gisle Vanem.
	 */
	/*
	 * Format an IPv4 address, more or less like inet_ntoa().
	 *
	 * Returns `dst' (as a const)
	 * Note:
	 *  - uses no statics
	 *  - takes a unsigned char* not an in_addr as input
	 */
	public static Object inet_ntop4(Object src, Object dst, Object size) {
		byte[] tmp = new byte[];
		size_t len = new size_t();
		do {
		} while (0);
		tmp[0] = (byte)'\0';
		(Object)ModernizedCProgram.curl_msnprintf(tmp, , "%d.%d.%d.%d", ((int)((byte)src[0])) & -1024, ((int)((byte)src[1])) & -1024, ((int)((byte)src[2])) & -1024, ((int)((byte)src[3])) & -1024);
		len = .strlen(tmp);
		if (len == 0 || len >= size) {
			(._errno()) = 28;
			return (((Object)0));
		} 
		.strcpy(dst, tmp);
		return dst/*
		 * Convert IPv6 binary address into presentation (printable) format.
		 *//*
		   * Note that int32_t and int16_t need only be "at least" large enough
		   * to contain a value of the specified size.  On some systems, like
		   * Crays, there is no such thing as an integer variable with 16 bits.
		   * Keep this in mind if you think this function should have been coded
		   * to use pointer overlays.  All the world's not a VAX.
		   *//* Preprocess:
		   *  Copy the input (bytewise) array into a wordwise array.
		   *  Find the longest run of 0x00's in src[] for :: shorthanding.
		   *//* Format the result. */;
	}
	/* Are we inside the best run of 0x00's? */
	/* Are we following an initial run of 0x00s or any real hex?
	     */
	/* Is this address an encapsulated IPv4?
	     */
	/* Was it a trailing run of 0x00's?
	   */
	/* Check for overflow, copy, and we're done.
	   */
	/* ENABLE_IPV6 */
	/*
	 * Convert a network format address to presentation format.
	 *
	 * Returns pointer to presentation format address (`buf').
	 * Returns NULL on error and errno set with the specific
	 * error, EAFNOSUPPORT or ENOSPC.
	 *
	 * On Windows we store the error in the thread errno, not
	 * in the winsock error code. This is to avoid losing the
	 * actual last winsock error. So when this function returns
	 * NULL, check errno not SOCKERRNO.
	 */
	public static Object Curl_inet_ntop(int af, Object src, Object buf, Object size) {
		switch (af) {
		case 2:
				return ModernizedCProgram.inet_ntop4((byte)src, buf, size);
		default:
				(._errno()) = -1024;
				return ((Object)0/* HAVE_INET_NTOP */);
		}
	}
	/* return the home directory of the current user as an allocated string */
	public static Object homedir() {
		byte home;
		home = ModernizedCProgram.GetEnv("CURL_HOME", 0);
		if (home) {
			return home;
		} 
		home = ModernizedCProgram.GetEnv("HOME", 0);
		if (home) {
			return home;
		} 
		home = ModernizedCProgram.GetEnv("APPDATA", /* PWD-stuff */1);
		if (!home) {
			home = ModernizedCProgram.GetEnv("%USERPROFILE%\\Application Data", /* Normally only
			                                                               on Win-2K/XP */1);
		} 
		return /* WIN32 */home;
	}
	public static  is_fatal_error( code) {
		switch (code) {
		case .CURLE_BAD_FUNCTION_ARGUMENT:
				return /* critical error */1;
		case .CURLE_FUNCTION_NOT_FOUND:
		case .CURLE_UNKNOWN_OPTION:
		case .CURLE_FAILED_INIT:
		case .CURLE_OUT_OF_MEMORY:
		default:
				break;
		}
		return /* no error or not critical */0/*
		 * Check if a given string is a PKCS#11 URI
		 */;
	}
	public static  is_pkcs11_uri(Object string) {
		if (ModernizedCProgram.curl_strnequal(string, "pkcs11:", 7)) {
			return 1;
		} else {
				return 0/*
				 * get_vms_file_size does what it takes to get the real size of the file
				 *
				 * For fixed files, find out the size of the EOF block and adjust.
				 *
				 * For all others, have to read the entire file in, discarding the contents.
				 * Most posted text files will be small, and binary files like zlib archives
				 * and CD/DVD images should be either a STREAM_LF format or a fixed format.
				 *
				 *//* !checksrc! disable FOPENMODE 1 *//* VMS */;
		} 
	}
	public static  add_per_transfer(Object per) {
		per_transfer p = new per_transfer();
		p = .calloc(, 1);
		if (!p) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		if (!ModernizedCProgram.transfers) {
			ModernizedCProgram.transfersl = ModernizedCProgram.transfers = /* first entry */p;
		} else {
				ModernizedCProgram.transfersl.setNext(/* make the last node point to the new node */p);
				p.setPrev(/* make the new node point back to the formerly last node */ModernizedCProgram.transfersl);
				ModernizedCProgram.transfersl = /* move the last node pointer to the new entry */p;
		} 
		per = p;
		/* count total number of transfers added */ModernizedCProgram.all_xfers++;
		return .CURLE_OK;
	}
	public static Object del_per_transfer(Object per) {
		per_transfer n = new per_transfer();
		per_transfer p = new per_transfer();
		do {
		} while (0);
		do {
		} while (0);
		do {
		} while (0);
		n = per.getNext();
		p = per.getPrev();
		if (p) {
			p.setNext(n);
		} else {
				ModernizedCProgram.transfers = n;
		} 
		if (n) {
			n.setPrev(p);
		} else {
				ModernizedCProgram.transfersl = p;
		} 
		.free(per);
		return n;
	}
	public static  pre_transfer(Object global, Object per) {
		curl_off_t uploadfilesize = -1;
		_stati64 fileinfo = new _stati64();
		CURLcode result = .CURLE_OK;
		if (per.getSeparator_err()) {
			ModernizedCProgram.curl_mfprintf(global.getErrors(), "%s\n", per.getSeparator_err());
		} 
		if (per.getSeparator()) {
			ModernizedCProgram.curl_mprintf("%s\n", per.getSeparator());
		} 
		Object generatedSt_mode = fileinfo.getSt_mode();
		Object generatedSt_size = fileinfo.getSt_size();
		if (per.getUploadfile() && !ModernizedCProgram.stdin_upload(per.getUploadfile())) {
			per.setInfd(.open(per.getUploadfile(), 0 | -1024));
			if ((per.getInfd() == -1) || ._fstati64(per.getInfd(), fileinfo)) {
				ModernizedCProgram.helpf(global.getErrors(), "Can't open '%s'!\n", per.getUploadfile());
				if (per.getInfd() != -1) {
					.close(per.getInfd());
					per.setInfd(0);
				} 
				return .CURLE_READ_ERROR;
			} 
			per.setInfdopen(1);
			if ((((generatedSt_mode) & -1024) == /* we ignore file size for char/block devices, sockets, etc. */-1024)) {
				uploadfilesize = generatedSt_size;
			} 
			if (uploadfilesize != -1) {
				do {
					if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_INFILESIZE_LARGE)) {
						result = (ModernizedCProgram.tool_setopt(per.getCurl(), 0, global, "CURLOPT_INFILESIZE_LARGE", .CURLOPT_INFILESIZE_LARGE, uploadfilesize));
						if (result) {
							break;
						} 
					} 
				} while (0);
			} 
			per.getInput().setFd(per.getInfd());
		} 
		return result/*
		 * Call this after a transfer has completed.
		 */;
	}
	public static  post_per_transfer(Object global, Object per,  result, Object retryp) {
		OutStruct outs = per.getOuts();
		CURL curl = per.getCurl();
		OperationConfig config = per.getConfig();
		if (!curl || !config) {
			return result;
		} 
		retryp = 0;
		if (per.getInfdopen()) {
			.close(per.getInfd());
		} 
		if (config.getSynthetic_error()) {
			;
		}  else if (result && global.getShowerror()) {
			ModernizedCProgram.curl_mfprintf(global.getErrors(), "curl: (%d) %s\n", result, (per.getErrorbuffer()[0]) ? per.getErrorbuffer() : ModernizedCProgram.curl_easy_strerror(result));
			if (result == .CURLE_PEER_FAILED_VERIFICATION) {
				.fputs("More details here: https://curl.haxx.se/docs/sslcerts.html\n\ncurl failed to verify the legitimacy of the server and therefore could not\nestablish a secure connection to it. To learn more about this situation and\nhow to fix it, please visit the web page mentioned above.\n", global.getErrors());
			} 
		} 
		if (!result && config.getXattr() && outs.getFopened() && outs.getStream()) {
			int rc = ModernizedCProgram.fwrite_xattr(curl, ((outs.getStream()).get_file()));
			if (rc) {
				ModernizedCProgram.warnf(config.getGlobal(), "Error setting extended attributes: %s\n", .strerror((._errno())));
			} 
		} 
		if (!result && !outs.getStream() && !outs.getBytes()) {
			long cond_unmet = -1024/* do not create (or even overwrite) the file in case we get no
			       data because of unmet condition */;
			;
			if (!cond_unmet && !ModernizedCProgram.tool_create_output_file(outs)) {
				result = .CURLE_WRITE_ERROR;
			} 
		} 
		if (!outs.getS_isreg() && outs.getStream()) {
			int rc = .fflush(outs.getStream());
			if (!result && rc) {
				result = /* something went wrong in the writing process */.CURLE_WRITE_ERROR;
				ModernizedCProgram.curl_mfprintf(global.getErrors(), "(%d) Failed writing body\n", result);
			} 
		} 
		if (outs.getIs_cd_filename() && outs.getStream() && !global.getMute() && outs.getFilename()) {
			ModernizedCProgram.curl_mprintf("curl: Saved to filename '%s'\n", outs.getFilename());
		} 
		timeval timeval = new timeval();
		if (per.getRetry_numretries() && (!config.getRetry_maxtime() || (timeval.tvnow().tvdiff(per.getRetrystart()) < config.getRetry_maxtime() * -1024))) {
			Object retry = /* not used */.RETRY_NO;
			long response;
			if ((.CURLE_OPERATION_TIMEDOUT == result) || (.CURLE_COULDNT_RESOLVE_HOST == result) || (.CURLE_COULDNT_RESOLVE_PROXY == result) || (.CURLE_FTP_ACCEPT_TIMEOUT == result)) {
				.retry = /* retry timeout always */.RETRY_TIMEOUT;
			}  else if (config.getRetry_connrefused() && (.CURLE_COULDNT_CONNECT == result)) {
				long oserrno;
				;
				if (-1024 == oserrno) {
					.retry = .RETRY_CONNREFUSED;
				} 
			}  else if ((.CURLE_OK == result) || (config.getFailonerror() && (.CURLE_HTTP_RETURNED_ERROR == result/* If it returned OK. _or_ failonerror was enabled and it
			         returned due to such an error, check for HTTP transient
			         errors to retry on. */))) {
				long protocol;
				;
				if ((protocol == (1 << 0)) || (protocol == (1 << 1))) {
					;
					switch (response) {
					case /* Gateway Timeout */504:
							.retry = .RETRY_HTTP/*
							           * At this point, we have already written data to the output
							           * file (or terminal). If we write to a file, we must rewind
							           * or close/re-open the file so that the next attempt starts
							           * over from the beginning.
							           *
							           * TODO: similar action for the upload case. We might need
							           * to start over reading from a previous point if we have
							           * uploaded something when this was returned.
							           */;
							break;
					case /* Internal Server Error */500:
					case /* Bad Gateway */502:
					case /* Service Unavailable */503:
					case /* Too Many Requests (RFC6585) */429:
					}
				} 
			}  else if (/* if CURLE_OK */result) {
				long protocol;
				;
				;
				if ((protocol == (1 << 2) || protocol == (1 << 3)) && response / 100 == 4/*
				         * This is typically when the FTP server only allows a certain
				         * amount of users and we are not one of them.  All 4xx codes
				         * are transient.
				         */) {
					.retry = .RETRY_FTP;
				} 
			} 
			if (.retry) {
				long sleeptime = 0;
				curl_off_t retry_after = 0;
				byte[] m = new byte[]{((Object)0), "timeout", "connection refused", "HTTP error", "FTP error"};
				sleeptime = per.getRetry_sleep();
				if (.RETRY_HTTP == .retry) {
					;
					if (retry_after) {
						if (retry_after > -1024 / /* store in a 'long', make sure it doesn't overflow */1000) {
							sleeptime = -1024;
						} else {
								sleeptime = (long)retry_after * /* milliseconds */1000;
						} 
					} 
				} 
				ModernizedCProgram.warnf(config.getGlobal(), "Transient problem: %s Will retry in %ld seconds. %ld retries left.\n", m[.retry], sleeptime / -1024, per.getRetry_numretries());
				per.getRetry_numretries()--;
				ModernizedCProgram.tool_go_sleep(sleeptime);
				if (!config.getRetry_delay()) {
					per.getRetry_sleep() *= 2;
					if (per.getRetry_sleep() > -1024) {
						per.setRetry_sleep(-1024);
					} 
				} 
				if (outs.getBytes() && outs.getFilename() && outs.getStream()) {
					int rc;
					if (!global.getMute()) {
						ModernizedCProgram.curl_mfprintf(global.getErrors(), "Throwing away %I64d bytes\n", outs.getBytes());
					} 
					.fflush(outs.getStream());
					if (ModernizedCProgram.tool_ftruncate64(((outs.getStream()).get_file()), outs.getInit())) {
						if (!global.getMute()) {
							ModernizedCProgram.curl_mfprintf(global.getErrors(), "failed to truncate, exiting\n");
						} 
						return .CURLE_WRITE_ERROR;
					} 
					rc = .fseek(outs.getStream(), 0, /* now seek to the end of the file, the position where we
					           just truncated the file in a large file-safe way */2/* ftruncate is not available, so just reposition the file
					           to the location we would have truncated it. This won't
					           work properly with large files on 32-bit systems, but
					           most of those will have ftruncate. */);
					if (rc) {
						if (!global.getMute()) {
							ModernizedCProgram.curl_mfprintf(global.getErrors(), "failed seeking to end of file, exiting\n");
						} 
						return .CURLE_WRITE_ERROR;
					} 
					outs.setBytes(/* clear for next round */0);
				} 
				retryp = /* curl_easy_perform loop */1;
				return .CURLE_OK;
			} 
		}  else if (per.getMetalink()) {
			long response;
			if (.CURLE_OK == result/* TODO We want to try next resource when download was
			         not successful. How to know that? */) {
				byte effective_url = ((Object)0);
				;
				if (effective_url && ModernizedCProgram.curl_strnequal(effective_url, "http", 4)) {
					;
					if (response != 200 && response != 206) {
						per.setMetalink_next_res(1);
						ModernizedCProgram.curl_mfprintf(global.getErrors(), "Metalink: fetching (%s) from (%s) FAILED (HTTP status code %ld)\n", per.getMlfile().getFilename(), per.getThis_url(), response);
					} 
				} 
			} else {
					per.setMetalink_next_res(1);
					ModernizedCProgram.curl_mfprintf(global.getErrors(), "Metalink: fetching (%s) from (%s) FAILED (%s)\n", per.getMlfile().getFilename(), per.getThis_url(), ModernizedCProgram.curl_easy_strerror(result));
			} 
		} 
		if ((global.getProgressmode() == 1) && per.getProgressbar().getCalls()) {
			.fputs("\n", per.getProgressbar().getOut());
		} 
		if (config.getWriteout()) {
			ModernizedCProgram.ourWriteOut(per.getCurl(), per.getOuts(), config.getWriteout());
		} 
		if (outs.getFopened() && outs.getStream()) {
			int rc = .fclose(outs.getStream());
			if (!result && rc) {
				result = /* something went wrong in the writing process */.CURLE_WRITE_ERROR;
				ModernizedCProgram.curl_mfprintf(global.getErrors(), "(%d) Failed writing body\n", result);
			} 
		} 
		if (!result && config.getRemote_time() && outs.getS_isreg() && outs.getFilename()) {
			curl_off_t filetime = -/* Ask libcurl if we got a remote file time */1;
			;
			ModernizedCProgram.setfiletime(filetime, outs.getFilename(), config.getGlobal().getErrors());
		} 
		if (per.getHeads().getFopened() && per.getHeads().getStream()) {
			.fclose(per.getHeads().getStream());
		} 
		if (per.getHeads().getAlloc_filename()) {
			do {
				.free((per.getHeads().getFilename()));
				(per.getHeads().getFilename()) = ((Object)0);
			} while (0);
		} 
		ModernizedCProgram.curl_easy_cleanup(per.getCurl());
		if (outs.getAlloc_filename()) {
			.free(outs.getFilename());
		} 
		.free(per.getThis_url());
		.free(per.getSeparator_err());
		.free(per.getSeparator());
		.free(per.getOutfile());
		.free(per.getUploadfile());
		return .CURLE_OK;
	}
	public static void single_transfer_cleanup(Object config) {
		if (config) {
			State state = config.getState();
			if (state.getUrls()) {
				ModernizedCProgram.glob_cleanup(state.getUrls());
				state.setUrls(((Object)0));
			} 
			do {
				.free((state.getOutfiles()));
				(state.getOutfiles()) = ((Object)0);
			} while (0);
			do {
				.free((state.getHttpgetfields()));
				(state.getHttpgetfields()) = ((Object)0);
			} while (0);
			do {
				.free((state.getUploadfile()));
				(state.getUploadfile()) = ((Object)0);
			} while (0);
			if (state.getInglob()) {
				ModernizedCProgram.glob_cleanup(state.getInglob());
				state.setInglob(((Object)0));
			} 
		} 
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/* libcurl's debug builds provide an extra function */
	/* since O_BINARY as used in bitmasks, setting it to zero makes it usable in
	   source code but yet it doesn't ruin anything */
	/* since O_BINARY as used in bitmasks, setting it to zero makes it usable in
	   source code but yet it doesn't ruin anything */
	/* create the next (singular) transfer */
	public static  single_transfer(Object global, Object config, Object share,  capath_from_env, Object added) {
		CURLcode result = .CURLE_OK;
		getout urlnode = new getout();
		metalinkfile mlfile_last = ((Object)0);
		bool orig_noprogress = global.getNoprogress();
		bool orig_isatty = global.getIsatty();
		State state = config.getState();
		byte httpgetfields = state.getHttpgetfields();
		added = /* not yet */0;
		if (config.getPostfields()) {
			if (config.getUse_httpget()) {
				if (!httpgetfields) {
					httpgetfields = state.setHttpgetfields(.strdup(config.getPostfields()));
					do {
						.free((config.getPostfields()));
						(config.getPostfields()) = ((Object)0);
					} while (0);
					if (!httpgetfields) {
						ModernizedCProgram.helpf(global.getErrors(), "out of memory\n");
						result = .CURLE_OUT_OF_MEMORY;
					}  else if (ModernizedCProgram.SetHTTPrequest(config, (config.getNo_body() ? .HTTPREQ_HEAD : .HTTPREQ_GET), config.getHttpreq())) {
						result = .CURLE_FAILED_INIT;
					} 
				} 
			} else {
					if (ModernizedCProgram.SetHTTPrequest(config, .HTTPREQ_SIMPLEPOST, config.getHttpreq())) {
						result = .CURLE_FAILED_INIT;
					} 
			} 
			if (result) {
				return result;
			} 
		} 
		if (!state.getUrlnode()) {
			state.setUrlnode(config.getUrl_list());
			state.setInfilenum(1);
		} 
		Object generatedSt_size = fileinfo.getSt_size();
		timeval timeval = new timeval();
		while (config.getState().getUrlnode()) {
			byte infiles;
			URLGlob inglob = state.getInglob();
			bool metalink = /* metalink download? */0;
			metalinkfile mlfile = new metalinkfile();
			metalink_resource mlres = new metalink_resource();
			urlnode = config.getState().getUrlnode();
			if (urlnode.getFlags() & (1 << 5)) {
				metalink = 1;
				if (mlfile_last == ((Object)0)) {
					mlfile_last = config.getMetalinkfile_list();
				} 
				mlfile = mlfile_last;
				mlfile_last = mlfile_last.getNext();
				mlres = mlfile.getResource();
			} else {
					mlfile = ((Object)0);
					mlres = ((Object)0);
			} 
			if (!urlnode.getUrl()) {
				do {
					.free((urlnode.getOutfile()));
					(urlnode.getOutfile()) = ((Object)0);
				} while (0);
				do {
					.free((urlnode.getInfile()));
					(urlnode.getInfile()) = ((Object)0);
				} while (0);
				urlnode.setFlags(0);
				config.getState().setUrlnode(urlnode.getNext());
				state.setUp(0);
				continue;
			} 
			if (urlnode.getOutfile() && !state.getOutfiles()) {
				state.setOutfiles(.strdup(urlnode.getOutfile()));
				if (!state.getOutfiles()) {
					ModernizedCProgram.helpf(global.getErrors(), "out of memory\n");
					result = .CURLE_OUT_OF_MEMORY;
					break;
				} 
			} 
			infiles = urlnode.getInfile();
			if (!config.getGloboff() && infiles && !inglob) {
				result = ModernizedCProgram.glob_url(inglob, infiles, state.getInfilenum(), global.getShowerror() ? global.getErrors() : ((Object)0));
				if (result) {
					break;
				} 
				config.getState().setInglob(inglob);
			} 
			{ 
				int separator;
				long urlnum;
				if (!state.getUp() && !infiles) {
					do {
					} while (0);
				} else {
						if (!state.getUploadfile()) {
							if (inglob) {
								result = ModernizedCProgram.glob_next_url(state.getUploadfile(), inglob);
								if (result == .CURLE_OUT_OF_MEMORY) {
									ModernizedCProgram.helpf(global.getErrors(), "out of memory\n");
								} 
							}  else if (!state.getUp()) {
								state.setUploadfile(.strdup(infiles));
								if (!state.getUploadfile()) {
									ModernizedCProgram.helpf(global.getErrors(), "out of memory\n");
									result = .CURLE_OUT_OF_MEMORY;
								} 
							} 
						} 
						if (result) {
							break;
						} 
				} 
				if (!state.getUrlnum()) {
					if (metalink/* For Metalink download, we don't use glob. Instead we use
					             the number of resources as urlnum. */) {
						urlnum = 0;
					}  else if (!config.getGloboff()) {
						result = ModernizedCProgram.glob_url(state.getUrls(), urlnode.getUrl(), state.getUrlnum(), global.getShowerror() ? global.getErrors() : ((Object)0));
						if (result) {
							break;
						} 
						urlnum = state.getUrlnum();
					} else {
							urlnum = /* without globbing, this is a single URL */1;
					} 
				} else {
						urlnum = state.getUrlnum();
				} 
				separator = ((!state.getOutfiles() || !.strcmp(state.getOutfiles(), "-")) && urlnum > 1);
				if (state.getLi() >= /* Here's looping around each globbed URL */urlnum) {
					state.setLi(0);
					state.getUp()++;
				} 
				if (state.getUp() < state.getInfilenum()) {
					per_transfer per = new per_transfer();
					OutStruct outs = new OutStruct();
					InStruct input = new InStruct();
					OutStruct heads = new OutStruct();
					HdrCbData hdrcbdata = ((Object)0);
					CURL curl = ModernizedCProgram.curl_easy_init();
					result = ModernizedCProgram.add_per_transfer(per);
					if (result || !curl) {
						ModernizedCProgram.curl_easy_cleanup(curl);
						result = .CURLE_OUT_OF_MEMORY;
						break;
					} 
					if (state.getUploadfile()) {
						per.setUploadfile(.strdup(state.getUploadfile()));
						if (!per.getUploadfile()) {
							ModernizedCProgram.curl_easy_cleanup(curl);
							result = .CURLE_OUT_OF_MEMORY;
							break;
						} 
					} 
					added = 1;
					per.setConfig(config);
					per.setCurl(curl);
					heads = per.getHeads();
					heads.setStream((_iob[1]));
					heads.setConfig(config);
					if (config.getHeaderfile()) {
						if (.strcmp(config.getHeaderfile(), /* open file for output: */"-")) {
							FILE newfile = .fopen(config.getHeaderfile(), "wb");
							if (!newfile) {
								ModernizedCProgram.warnf(config.getGlobal(), "Failed to open %s\n", config.getHeaderfile());
								result = .CURLE_WRITE_ERROR;
								break;
							} else {
									heads.setFilename(config.getHeaderfile());
									heads.setS_isreg(1);
									heads.setFopened(1);
									heads.setStream(newfile);
							} 
						} else {
								ModernizedCProgram.set_binmode(heads.getStream());
						} 
					} 
					hdrcbdata = per.getHdrcbdata();
					outs = per.getOuts();
					input = per.getInput();
					per.setOutfile(((Object)0));
					per.setInfdopen(0);
					per.setInfd(0);
					outs.setStream((_iob[/* default output stream is stdout */1]));
					outs.setConfig(config);
					if (metalink/* For Metalink download, use name in Metalink file as
					             filename. */) {
						per.setOutfile(.strdup(mlfile.getFilename()));
						if (!per.getOutfile()) {
							result = .CURLE_OUT_OF_MEMORY;
							break;
						} 
						per.setThis_url(.strdup(mlres.getUrl()));
						if (!per.getThis_url()) {
							result = .CURLE_OUT_OF_MEMORY;
							break;
						} 
						per.setMlfile(mlfile);
					} else {
							if (state.getUrls()) {
								result = ModernizedCProgram.glob_next_url(per.getThis_url(), state.getUrls());
								if (result) {
									break;
								} 
							}  else if (!state.getLi()) {
								per.setThis_url(.strdup(urlnode.getUrl()));
								if (!per.getThis_url()) {
									result = .CURLE_OUT_OF_MEMORY;
									break;
								} 
							} else {
									per.setThis_url(((Object)0));
							} 
							if (!per.getThis_url()) {
								break;
							} 
							if (state.getOutfiles()) {
								per.setOutfile(.strdup(state.getOutfiles()));
								if (!per.getOutfile()) {
									result = .CURLE_OUT_OF_MEMORY;
									break;
								} 
							} 
					} 
					if (((urlnode.getFlags() & (1 << 2)) || (per.getOutfile() && .strcmp("-", per.getOutfile()))) && (metalink || !config.getUse_metalink())) {
						if (!per.getOutfile()) {
							result = ModernizedCProgram.get_url_file_name(per.getOutfile(), per.getThis_url());
							if (result) {
								break;
							} 
							if (!per.getOutfile() && !config.getContent_disposition()) {
								ModernizedCProgram.helpf(global.getErrors(), "Remote file name has no length!\n");
								result = .CURLE_WRITE_ERROR;
								break;
							} 
						}  else if (state.getUrls()) {
							byte storefile = per.getOutfile();
							result = ModernizedCProgram.glob_match_url(per.getOutfile(), storefile, state.getUrls());
							do {
								.free((storefile));
								(storefile) = ((Object)0);
							} while (0);
							if (result) {
								ModernizedCProgram.warnf(config.getGlobal(), /* bad globbing */"bad output glob!\n");
								break;
							} 
						} 
						if (config.getCreate_dirs() || /* Create the directory hierarchy, if not pre-existent to a multiple
						             file output call */metalink) {
							result = ModernizedCProgram.create_dir_hierarchy(per.getOutfile(), global.getErrors());
							if (/* create_dir_hierarchy shows error upon CURLE_WRITE_ERROR */result) {
								break;
							} 
						} 
						if ((urlnode.getFlags() & (1 << 2)) && config.getContent_disposition()) {
							do {
							} while (/* Our header callback MIGHT set the filename */0);
						} 
						if (config.getResume_from_current()) {
							_stati64 fileinfo = new _stati64();
							if (0 == ._stati64(per.getOutfile(), /* VMS -- Danger, the filesize is only valid for stream files */fileinfo)) {
								config.setResume_from(generatedSt_size);
							} else {
									config.setResume_from(/* let offset be 0 */0);
							} 
						} 
						if (config.getResume_from()) {
							FILE file = .fopen(per.getOutfile(), /* open file for output: */"ab");
							if (!file) {
								ModernizedCProgram.helpf(global.getErrors(), "Can't open '%s'!\n", per.getOutfile());
								result = .CURLE_WRITE_ERROR;
								break;
							} 
							outs.setFopened(1);
							outs.setStream(file);
							outs.setInit(config.getResume_from());
						} else {
								outs.setStream(((Object)/* open when needed */0));
						} 
						outs.setFilename(per.getOutfile());
						outs.setS_isreg(1);
					} 
					if (per.getUploadfile() && !ModernizedCProgram.stdin_upload(per.getUploadfile())) {
						byte nurl = ModernizedCProgram.add_file_name_to_url(per.getThis_url(), per.getUploadfile());
						if (!nurl) {
							result = .CURLE_OUT_OF_MEMORY;
							break;
						} 
						per.setThis_url(nurl);
					}  else if (per.getUploadfile() && ModernizedCProgram.stdin_upload(per.getUploadfile())) {
						int authbits = 0;
						int bitcheck = 0;
						while (bitcheck < 32) {
							if (config.getAuthtype() & (-1024 << bitcheck++)) {
								authbits++;
								if (authbits > 1/* more than one, we're done! */) {
									break;
								} 
							} 
						}
						if (config.getProxyanyauth() || (authbits > /*
						           * If the user has also selected --anyauth or --proxy-anyauth
						           * we should warn him/her.
						           */1)) {
							ModernizedCProgram.warnf(config.getGlobal(), "Using --anyauth or --proxy-anyauth with upload from stdin involves a big risk of it not working. Use a temporary file or a fixed auth type instead!\n");
						} 
						do {
						} while (0);
						do {
						} while (0);
						ModernizedCProgram.set_binmode((_iob[0]));
						if (!.strcmp(per.getUploadfile(), ".")) {
							if (ModernizedCProgram.curlx_nonblock((curl_socket_t)per.getInfd(), 1) < 0) {
								ModernizedCProgram.warnf(config.getGlobal(), "fcntl failed on fd=%d: %s\n", per.getInfd(), .strerror((._errno())));
							} 
						} 
					} 
					if (per.getUploadfile() && config.getResume_from_current()) {
						config.setResume_from(-/* -1 will then force get-it-yourself */1);
					} 
					if (ModernizedCProgram.output_expected(per.getThis_url(), per.getUploadfile()) && outs.getStream() && .isatty(((outs.getStream()).get_file()))) {
						global.setNoprogress(global.setIsatty(1));
					} else {
							global.setNoprogress(/* progress meter is per download, so restore config
							             values */orig_noprogress);
							global.setIsatty(orig_isatty);
					} 
					if (urlnum > 1 && !global.getMute()) {
						per.setSeparator_err(ModernizedCProgram.curl_maprintf("\n[%lu/%lu]: %s --> %s", state.getLi() + 1, urlnum, per.getThis_url(), per.getOutfile() ? per.getOutfile() : "<stdout>"));
						if (separator) {
							per.setSeparator(ModernizedCProgram.curl_maprintf("%s%s", "--_curl_--", per.getThis_url()));
						} 
					} 
					if (httpgetfields) {
						byte urlbuffer;
						byte pc = .strstr(per.getThis_url(), /* Find out whether the url contains a file name */"://");
						byte sep = (byte)'?';
						if (pc) {
							pc += 3;
						} else {
								pc = per.getThis_url();
						} 
						pc = .strrchr(pc, /* check for a slash */(byte)'/');
						if (pc/* there is a slash present in the URL */) {
							if (.strchr(pc, (byte)'?'/* Ouch, there's already a question mark in the URL string, we
							                 then append the data with an ampersand separator instead! */)) {
								sep = (byte)'&'/*
								           * Then append ? followed by the get fields to the url.
								           */;
							} 
						} 
						if (pc) {
							urlbuffer = ModernizedCProgram.curl_maprintf("%s%c%s", per.getThis_url(), sep, httpgetfields/* Append  / before the ? to create a well-formed url
							               if the url contains a hostname only
							            */);
						} else {
								urlbuffer = ModernizedCProgram.curl_maprintf("%s/?%s", per.getThis_url(), httpgetfields);
						} 
						if (!urlbuffer) {
							result = .CURLE_OUT_OF_MEMORY;
							break;
						} 
						do {
							.free((per.getThis_url()));
							(per.getThis_url()) = ((Object)0);
						} while (/* free previous URL */0);
						per.setThis_url(/* use our new URL instead! */urlbuffer);
					} 
					if (!global.getErrors()) {
						global.setErrors((_iob[2]));
					} 
					if ((!per.getOutfile() || !.strcmp(per.getOutfile(), "-")) && !config.getUse_ascii()) {
						ModernizedCProgram.set_binmode((_iob[1]));
					} 
					/* explicitly passed to stdout means okaying binary gunk */config.setTerminal_binary_ok((per.getOutfile() && !.strcmp(per.getOutfile(), "-")));
					result = ;
					if (result) {
						break;
					} 
					if (!config.getTcp_nodelay()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TCP_NODELAY)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TCP_NODELAY", .CURLOPT_TCP_NODELAY, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getTcp_fastopen()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TCP_FASTOPEN)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TCP_FASTOPEN", .CURLOPT_TCP_FASTOPEN, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_WRITEDATA)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_WRITEDATA", .CURLOPT_WRITEDATA, per));
							if (result) {
								break;
							} 
						} 
					} while (/* where to store */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_INTERLEAVEDATA)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_INTERLEAVEDATA", .CURLOPT_INTERLEAVEDATA, per));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (metalink || !config.getUse_metalink()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_WRITEFUNCTION)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_WRITEFUNCTION", .CURLOPT_WRITEFUNCTION, ModernizedCProgram.tool_write_cb));
								if (result) {
									break;
								} 
							} 
						} while (/* what call to write */0/* Set Metalink specific write callback function to parse
						             XML data progressively. */);
					} 
					input.setConfig(/* USE_METALINK *//* for uploads */config/* Note that if CURLOPT_READFUNCTION is fread (the default), then
					         * lib/telnet.c will Curl_poll() on the input file descriptor
					         * rather then calling the READFUNCTION at regular intervals.
					         * The circumstances in which it is preferable to enable this
					         * behaviour, by omitting to set the READFUNCTION & READDATA options,
					         * have not been determined.
					         */);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_READDATA)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_READDATA", .CURLOPT_READDATA, input));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_READFUNCTION)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_READFUNCTION", .CURLOPT_READFUNCTION, ModernizedCProgram.tool_read_cb));
							if (result) {
								break;
							} 
						} 
					} while (/* what call to read */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SEEKDATA)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SEEKDATA", .CURLOPT_SEEKDATA, input));
							if (result) {
								break;
							} 
						} 
					} while (/* in 7.18.0, the CURLOPT_SEEKFUNCTION/DATA pair is taking over what
					           CURLOPT_IOCTLFUNCTION/DATA pair previously provided for seeking */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SEEKFUNCTION)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SEEKFUNCTION", .CURLOPT_SEEKFUNCTION, ModernizedCProgram.tool_seek_cb));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (config.getRecvpersecond() && (config.getRecvpersecond() < (100 * 1024))) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_BUFFERSIZE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_BUFFERSIZE", .CURLOPT_BUFFERSIZE, (long)config.getRecvpersecond()));
								if (result) {
									break;
								} 
							} 
						} while (/* use a smaller sized buffer for better sleeps */0);
					} else {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_BUFFERSIZE)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_BUFFERSIZE", .CURLOPT_BUFFERSIZE, (long)(100 * 1024)));
									if (result) {
										break;
									} 
								} 
							} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_URL)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_URL", .CURLOPT_URL, per.getThis_url()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_NOPROGRESS)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_NOPROGRESS", .CURLOPT_NOPROGRESS, global.getNoprogress() ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (config.getNo_body()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_NOBODY)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_NOBODY", .CURLOPT_NOBODY, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getOauth_bearer()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_XOAUTH2_BEARER)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_XOAUTH2_BEARER", .CURLOPT_XOAUTH2_BEARER, config.getOauth_bearer()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					{ 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY", .CURLOPT_PROXY, config.getProxy()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						if (config.getProxy()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXYTYPE)) {
									result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_PROXYTYPE", .CURLOPT_PROXYTYPE, ModernizedCProgram.setopt_nv_CURLPROXY, config.getProxyver()));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXYUSERPWD)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXYUSERPWD", .CURLOPT_PROXYUSERPWD, config.getProxyuserpwd()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HTTPPROXYTUNNEL)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_HTTPPROXYTUNNEL", .CURLOPT_HTTPPROXYTUNNEL, config.getProxytunnel() ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.3 */0);
						if (config.getPreproxy()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PRE_PROXY)) {
									result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PRE_PROXY", .CURLOPT_PRE_PROXY, config.getPreproxy()));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (config.getProxyanyauth()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXYAUTH)) {
									result = (ModernizedCProgram.tool_setopt_bitmask(curl, global, "CURLOPT_PROXYAUTH", .CURLOPT_PROXYAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)(~(((long)1) << 4))));
									if (result) {
										break;
									} 
								} 
							} while (0);
						}  else if (config.getProxynegotiate()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXYAUTH)) {
									result = (ModernizedCProgram.tool_setopt_bitmask(curl, global, "CURLOPT_PROXYAUTH", .CURLOPT_PROXYAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)(((long)1) << 2)));
									if (result) {
										break;
									} 
								} 
							} while (0);
						}  else if (config.getProxyntlm()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXYAUTH)) {
									result = (ModernizedCProgram.tool_setopt_bitmask(curl, global, "CURLOPT_PROXYAUTH", .CURLOPT_PROXYAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)(((long)1) << 3)));
									if (result) {
										break;
									} 
								} 
							} while (0);
						}  else if (config.getProxydigest()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXYAUTH)) {
									result = (ModernizedCProgram.tool_setopt_bitmask(curl, global, "CURLOPT_PROXYAUTH", .CURLOPT_PROXYAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)(((long)1) << 1)));
									if (result) {
										break;
									} 
								} 
							} while (0);
						}  else if (config.getProxybasic()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXYAUTH)) {
									result = (ModernizedCProgram.tool_setopt_bitmask(curl, global, "CURLOPT_PROXYAUTH", .CURLOPT_PROXYAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)(((long)1) << 0)));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_NOPROXY)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_NOPROXY", .CURLOPT_NOPROXY, config.getNoproxy()));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.19.4 */0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SUPPRESS_CONNECT_HEADERS)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SUPPRESS_CONNECT_HEADERS", .CURLOPT_SUPPRESS_CONNECT_HEADERS, config.getSuppress_connect_headers() ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FAILONERROR)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_FAILONERROR", .CURLOPT_FAILONERROR, config.getFailonerror() ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_REQUEST_TARGET)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_REQUEST_TARGET", .CURLOPT_REQUEST_TARGET, config.getRequest_target()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_UPLOAD)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_UPLOAD", .CURLOPT_UPLOAD, per.getUploadfile() ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_DIRLISTONLY)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_DIRLISTONLY", .CURLOPT_DIRLISTONLY, config.getDirlistonly() ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_APPEND)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_APPEND", .CURLOPT_APPEND, config.getFtp_append() ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (config.getNetrc_opt()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_NETRC)) {
								result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_NETRC", .CURLOPT_NETRC, ModernizedCProgram.setopt_nv_CURL_NETRC, (long)CURL_NETRC_OPTION.CURL_NETRC_OPTIONAL));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}  else if (config.getNetrc() || config.getNetrc_file()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_NETRC)) {
								result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_NETRC", .CURLOPT_NETRC, ModernizedCProgram.setopt_nv_CURL_NETRC, (long)CURL_NETRC_OPTION.CURL_NETRC_REQUIRED));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} else {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_NETRC)) {
									result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_NETRC", .CURLOPT_NETRC, ModernizedCProgram.setopt_nv_CURL_NETRC, (long)CURL_NETRC_OPTION.CURL_NETRC_IGNORED));
									if (result) {
										break;
									} 
								} 
							} while (0);
					} 
					if (config.getNetrc_file()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_NETRC_FILE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_NETRC_FILE", .CURLOPT_NETRC_FILE, config.getNetrc_file()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TRANSFERTEXT)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TRANSFERTEXT", .CURLOPT_TRANSFERTEXT, config.getUse_ascii() ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (config.getLogin_options()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_LOGIN_OPTIONS)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_LOGIN_OPTIONS", .CURLOPT_LOGIN_OPTIONS, config.getLogin_options()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_USERPWD)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_USERPWD", .CURLOPT_USERPWD, config.getUserpwd()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_RANGE)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_RANGE", .CURLOPT_RANGE, config.getRange()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_ERRORBUFFER)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_ERRORBUFFER", .CURLOPT_ERRORBUFFER, per.getErrorbuffer()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TIMEOUT_MS)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TIMEOUT_MS", .CURLOPT_TIMEOUT_MS, (long)(config.getTimeout() * 1000)));
							if (result) {
								break;
							} 
						} 
					} while (0);
					switch (config.getHttpreq()) {
					case .HTTPREQ_SIMPLEPOST:
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_POSTFIELDS)) {
									result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_POSTFIELDS", .CURLOPT_POSTFIELDS, config.getPostfields()));
									if (result) {
										break;
									} 
								} 
							} while (0);
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_POSTFIELDSIZE_LARGE)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_POSTFIELDSIZE_LARGE", .CURLOPT_POSTFIELDSIZE_LARGE, config.getPostfieldsize()));
									if (result) {
										break;
									} 
								} 
							} while (0);
							break;
					case .HTTPREQ_MIMEPOST:
							result = ModernizedCProgram.tool2curlmime(curl, config.getMimeroot(), config.getMimepost());
							if (result) {
								break;
							} 
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_MIMEPOST)) {
									result = (ModernizedCProgram.tool_setopt_mimepost(curl, global, "CURLOPT_MIMEPOST", .CURLOPT_MIMEPOST, config.getMimepost()));
									if (result) {
										break;
									} 
								} 
							} while (0);
							break;
					default:
							break;
					}
					if (result) {
						break;
					} 
					if (config.getAuthtype()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HTTPAUTH)) {
								result = (ModernizedCProgram.tool_setopt_bitmask(curl, global, "CURLOPT_HTTPAUTH", .CURLOPT_HTTPAUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)config.getAuthtype()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HTTPHEADER)) {
							result = (ModernizedCProgram.tool_setopt_slist(curl, global, "CURLOPT_HTTPHEADER", .CURLOPT_HTTPHEADER, config.getHeaders()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (ModernizedCProgram.built_in_protos & ((1 << 0) | (1 << 18))) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_REFERER)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_REFERER", .CURLOPT_REFERER, config.getReferer()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_USERAGENT)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_USERAGENT", .CURLOPT_USERAGENT, config.getUseragent()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (ModernizedCProgram.built_in_protos & (1 << 0)) {
						long postRedir = 0;
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FOLLOWLOCATION)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_FOLLOWLOCATION", .CURLOPT_FOLLOWLOCATION, config.getFollowlocation() ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_UNRESTRICTED_AUTH)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_UNRESTRICTED_AUTH", .CURLOPT_UNRESTRICTED_AUTH, config.getUnrestricted_auth() ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_AUTOREFERER)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_AUTOREFERER", .CURLOPT_AUTOREFERER, config.getAutoreferer() ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
						if (config.getProxyheaders()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXYHEADER)) {
									result = (ModernizedCProgram.tool_setopt_slist(curl, global, "CURLOPT_PROXYHEADER", .CURLOPT_PROXYHEADER, config.getProxyheaders()));
									if (result) {
										break;
									} 
								} 
							} while (0);
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HEADEROPT)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_HEADEROPT", .CURLOPT_HEADEROPT, (1 << 0)));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_MAXREDIRS)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_MAXREDIRS", .CURLOPT_MAXREDIRS, config.getMaxredirs()));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.5 */0);
						if (config.getHttpversion()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HTTP_VERSION)) {
									result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_HTTP_VERSION", .CURLOPT_HTTP_VERSION, ModernizedCProgram.setopt_nv_CURL_HTTP_VERSION, config.getHttpversion()));
									if (result) {
										break;
									} 
								} 
							} while (0);
						}  else if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 16)) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HTTP_VERSION)) {
									result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_HTTP_VERSION", .CURLOPT_HTTP_VERSION, ModernizedCProgram.setopt_nv_CURL_HTTP_VERSION, .CURL_HTTP_VERSION_2TLS));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (config.getPost301()) {
							postRedir |=  1;
						} 
						if (config.getPost302()) {
							postRedir |=  2;
						} 
						if (config.getPost303()) {
							postRedir |=  4;
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_POSTREDIR)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_POSTREDIR", .CURLOPT_POSTREDIR, postRedir));
								if (result) {
									break;
								} 
							} 
						} while (0);
						if (config.getEncoding()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_ACCEPT_ENCODING)) {
									result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_ACCEPT_ENCODING", .CURLOPT_ACCEPT_ENCODING, ""));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (config.getTr_encoding()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TRANSFER_ENCODING)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TRANSFER_ENCODING", .CURLOPT_TRANSFER_ENCODING, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HTTP09_ALLOWED)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_HTTP09_ALLOWED", .CURLOPT_HTTP09_ALLOWED, config.getHttp09_allowed() ? -1024 : -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.64.0 */0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FTPPORT)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_FTPPORT", .CURLOPT_FTPPORT, config.getFtpport()));
							if (result) {
								break;
							} 
						} 
					} while (/* (built_in_protos & CURLPROTO_HTTP) */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_LOW_SPEED_LIMIT)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_LOW_SPEED_LIMIT", .CURLOPT_LOW_SPEED_LIMIT, config.getLow_speed_limit()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_LOW_SPEED_TIME)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_LOW_SPEED_TIME", .CURLOPT_LOW_SPEED_TIME, config.getLow_speed_time()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_MAX_SEND_SPEED_LARGE)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_MAX_SEND_SPEED_LARGE", .CURLOPT_MAX_SEND_SPEED_LARGE, config.getSendpersecond()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_MAX_RECV_SPEED_LARGE)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_MAX_RECV_SPEED_LARGE", .CURLOPT_MAX_RECV_SPEED_LARGE, config.getRecvpersecond()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (config.getUse_resume()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_RESUME_FROM_LARGE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_RESUME_FROM_LARGE", .CURLOPT_RESUME_FROM_LARGE, config.getResume_from()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} else {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_RESUME_FROM_LARGE)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_RESUME_FROM_LARGE", .CURLOPT_RESUME_FROM_LARGE, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_KEYPASSWD)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_KEYPASSWD", .CURLOPT_KEYPASSWD, config.getKey_passwd()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_KEYPASSWD)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_KEYPASSWD", .CURLOPT_PROXY_KEYPASSWD, config.getProxy_key_passwd()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (ModernizedCProgram.built_in_protos & ((1 << 4) | (1 << 5))) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSH_PRIVATE_KEYFILE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SSH_PRIVATE_KEYFILE", .CURLOPT_SSH_PRIVATE_KEYFILE, config.getKey()));
								if (result) {
									break;
								} 
							} 
						} while (/* SSH and SSL private key uses same command-line option *//* new in libcurl 7.16.1 */0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSH_PUBLIC_KEYFILE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SSH_PUBLIC_KEYFILE", .CURLOPT_SSH_PUBLIC_KEYFILE, config.getPubkey()));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.16.1 */0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSH_HOST_PUBLIC_KEY_MD5)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SSH_HOST_PUBLIC_KEY_MD5", .CURLOPT_SSH_HOST_PUBLIC_KEY_MD5, config.getHostpubmd5()));
								if (result) {
									break;
								} 
							} 
						} while (/* new in libcurl 7.17.1: SSH host key md5 checking allows us
						             to fail if we are not talking to who we think we should */0);
						if (config.getSsh_compression()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSH_COMPRESSION)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SSH_COMPRESSION", .CURLOPT_SSH_COMPRESSION, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
					} 
					if (config.getCacert()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_CAINFO)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_CAINFO", .CURLOPT_CAINFO, config.getCacert()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getProxy_cacert()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_CAINFO)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_CAINFO", .CURLOPT_PROXY_CAINFO, config.getProxy_cacert()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getCapath()) {
						result = ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_CAPATH", .CURLOPT_CAPATH, config.getCapath());
						if (result == .CURLE_NOT_BUILT_IN) {
							ModernizedCProgram.warnf(config.getGlobal(), "ignoring %s, not supported by libcurl\n", capath_from_env ? "SSL_CERT_DIR environment variable" : "--capath");
						}  else if (result) {
							break;
						} 
					} 
					if ((config.getProxy_capath() || config.getCapath()) && !ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_CAPATH)) {
						result = ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_CAPATH", .CURLOPT_PROXY_CAPATH, (config.getProxy_capath() ? config.getProxy_capath() : config.getCapath()));
						if (result == .CURLE_NOT_BUILT_IN) {
							if (config.getProxy_capath()) {
								ModernizedCProgram.warnf(config.getGlobal(), "ignoring --proxy-capath, not supported by libcurl\n");
							} 
						}  else if (result) {
							break;
						} 
					} 
					if (config.getCrlfile()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_CRLFILE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_CRLFILE", .CURLOPT_CRLFILE, config.getCrlfile()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getProxy_crlfile()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_CRLFILE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_CRLFILE", .CURLOPT_PROXY_CRLFILE, config.getProxy_crlfile()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}  else if (config.getCrlfile()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_CRLFILE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_CRLFILE", .CURLOPT_PROXY_CRLFILE, config.getCrlfile()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getPinnedpubkey()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PINNEDPUBLICKEY)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PINNEDPUBLICKEY", .CURLOPT_PINNEDPUBLICKEY, config.getPinnedpubkey()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (ModernizedCProgram.curlinfo.getFeatures() & (1 << 2/* Check if config->cert is a PKCS#11 URI and set the
					           * config->cert_type if necessary */)) {
						if (config.getCert()) {
							if (!config.getCert_type()) {
								if (ModernizedCProgram.is_pkcs11_uri(config.getCert())) {
									config.setCert_type(.strdup("ENG"));
								} 
							} 
						} 
						if (config.getKey()) {
							if (!config.getKey_type()) {
								if (ModernizedCProgram.is_pkcs11_uri(config.getKey())) {
									config.setKey_type(.strdup("ENG"));
								} 
							} 
						} 
						if (config.getProxy_cert()) {
							if (!config.getProxy_cert_type()) {
								if (ModernizedCProgram.is_pkcs11_uri(config.getProxy_cert())) {
									config.setProxy_cert_type(.strdup("ENG"));
								} 
							} 
						} 
						if (config.getProxy_key()) {
							if (!config.getProxy_key_type()) {
								if (ModernizedCProgram.is_pkcs11_uri(config.getProxy_key())) {
									config.setProxy_key_type(.strdup("ENG"));
								} 
							} 
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSLCERT)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SSLCERT", .CURLOPT_SSLCERT, config.getCert()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_SSLCERT)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_SSLCERT", .CURLOPT_PROXY_SSLCERT, config.getProxy_cert()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSLCERTTYPE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SSLCERTTYPE", .CURLOPT_SSLCERTTYPE, config.getCert_type()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_SSLCERTTYPE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_SSLCERTTYPE", .CURLOPT_PROXY_SSLCERTTYPE, config.getProxy_cert_type()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSLKEY)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SSLKEY", .CURLOPT_SSLKEY, config.getKey()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_SSLKEY)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_SSLKEY", .CURLOPT_PROXY_SSLKEY, config.getProxy_key()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSLKEYTYPE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SSLKEYTYPE", .CURLOPT_SSLKEYTYPE, config.getKey_type()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_SSLKEYTYPE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_SSLKEYTYPE", .CURLOPT_PROXY_SSLKEYTYPE, config.getProxy_key_type()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						if (config.getInsecure_ok()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSL_VERIFYPEER)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SSL_VERIFYPEER", .CURLOPT_SSL_VERIFYPEER, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSL_VERIFYHOST)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SSL_VERIFYHOST", .CURLOPT_SSL_VERIFYHOST, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} else {
								do {
									if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSL_VERIFYPEER)) {
										result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SSL_VERIFYPEER", .CURLOPT_SSL_VERIFYPEER, -1024));
										if (result) {
											break;
										} 
									} 
								} while (0/* libcurl default is strict verifyhost -> 2L   */);
						} 
						if (config.getProxy_insecure_ok()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_SSL_VERIFYPEER)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_PROXY_SSL_VERIFYPEER", .CURLOPT_PROXY_SSL_VERIFYPEER, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_SSL_VERIFYHOST)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_PROXY_SSL_VERIFYHOST", .CURLOPT_PROXY_SSL_VERIFYHOST, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} else {
								do {
									if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_SSL_VERIFYPEER)) {
										result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_PROXY_SSL_VERIFYPEER", .CURLOPT_PROXY_SSL_VERIFYPEER, -1024));
										if (result) {
											break;
										} 
									} 
								} while (0);
						} 
						if (config.getVerifystatus()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSL_VERIFYSTATUS)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SSL_VERIFYSTATUS", .CURLOPT_SSL_VERIFYSTATUS, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (config.getFalsestart()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSL_FALSESTART)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SSL_FALSESTART", .CURLOPT_SSL_FALSESTART, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSLVERSION)) {
								result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_SSLVERSION", .CURLOPT_SSLVERSION, ModernizedCProgram.setopt_nv_CURL_SSLVERSION, config.getSsl_version() | config.getSsl_version_max()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_SSLVERSION)) {
								result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_PROXY_SSLVERSION", .CURLOPT_PROXY_SSLVERSION, ModernizedCProgram.setopt_nv_CURL_SSLVERSION, config.getProxy_ssl_version()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getPath_as_is()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PATH_AS_IS)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_PATH_AS_IS", .CURLOPT_PATH_AS_IS, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (ModernizedCProgram.built_in_protos & ((1 << 4) | (1 << 5))) {
						if (!config.getInsecure_ok()) {
							byte home;
							byte file;
							result = .CURLE_OUT_OF_MEMORY;
							home = ModernizedCProgram.homedir();
							if (home) {
								file = ModernizedCProgram.curl_maprintf("%s/.ssh/known_hosts", home);
								if (file) {
									result = ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SSH_KNOWNHOSTS", .CURLOPT_SSH_KNOWNHOSTS, /* new in curl 7.19.6 */file);
									ModernizedCProgram.curl_free(file);
									if (result == .CURLE_UNKNOWN_OPTION) {
										result = /* libssh2 version older than 1.1.1 */.CURLE_OK;
									} 
								} 
								do {
									.free((home));
									(home) = ((Object)0);
								} while (0);
							} 
							if (result) {
								break;
							} 
						} 
					} 
					if (config.getNo_body() || config.getRemote_time()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FILETIME)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_FILETIME", .CURLOPT_FILETIME, -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* no body or use remote time */0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_CRLF)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_CRLF", .CURLOPT_CRLF, config.getCrlf() ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_QUOTE)) {
							result = (ModernizedCProgram.tool_setopt_slist(curl, global, "CURLOPT_QUOTE", .CURLOPT_QUOTE, config.getQuote()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_POSTQUOTE)) {
							result = (ModernizedCProgram.tool_setopt_slist(curl, global, "CURLOPT_POSTQUOTE", .CURLOPT_POSTQUOTE, config.getPostquote()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PREQUOTE)) {
							result = (ModernizedCProgram.tool_setopt_slist(curl, global, "CURLOPT_PREQUOTE", .CURLOPT_PREQUOTE, config.getPrequote()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (config.getCookie()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_COOKIE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_COOKIE", .CURLOPT_COOKIE, config.getCookie()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getCookiefile()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_COOKIEFILE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_COOKIEFILE", .CURLOPT_COOKIEFILE, config.getCookiefile()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getCookiejar()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_COOKIEJAR)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_COOKIEJAR", .CURLOPT_COOKIEJAR, config.getCookiejar()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_COOKIESESSION)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_COOKIESESSION", .CURLOPT_COOKIESESSION, config.getCookiesession() ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (/* new in libcurl 7.9.7 */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TIMECONDITION)) {
							result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_TIMECONDITION", .CURLOPT_TIMECONDITION, ModernizedCProgram.setopt_nv_CURL_TIMECOND, (long)config.getTimecond()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TIMEVALUE_LARGE)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TIMEVALUE_LARGE", .CURLOPT_TIMEVALUE_LARGE, config.getCondtime()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_CUSTOMREQUEST)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_CUSTOMREQUEST", .CURLOPT_CUSTOMREQUEST, config.getCustomrequest()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					ModernizedCProgram.customrequest_helper(config, config.getHttpreq(), config.getCustomrequest());
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_STDERR)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_STDERR", .CURLOPT_STDERR, global.getErrors()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_INTERFACE)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_INTERFACE", .CURLOPT_INTERFACE, config.getIface()));
							if (result) {
								break;
							} 
						} 
					} while (/* three new ones in libcurl 7.3: */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_KRBLEVEL)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_KRBLEVEL", .CURLOPT_KRBLEVEL, config.getKrblevel()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					ModernizedCProgram.progressbarinit(per.getProgressbar(), config);
					if ((global.getProgressmode() == 1) && !global.getNoprogress() && !global.getMute()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_XFERINFOFUNCTION)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_XFERINFOFUNCTION", .CURLOPT_XFERINFOFUNCTION, ModernizedCProgram.tool_progress_cb));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROGRESSDATA)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_XFERINFODATA", .CURLOPT_PROGRESSDATA, per.getProgressbar()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getDns_servers()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_DNS_SERVERS)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_DNS_SERVERS", .CURLOPT_DNS_SERVERS, config.getDns_servers()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getDns_interface()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_DNS_INTERFACE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_DNS_INTERFACE", .CURLOPT_DNS_INTERFACE, config.getDns_interface()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getDns_ipv4_addr()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_DNS_LOCAL_IP4)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_DNS_LOCAL_IP4", .CURLOPT_DNS_LOCAL_IP4, config.getDns_ipv4_addr()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getDns_ipv6_addr()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_DNS_LOCAL_IP6)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_DNS_LOCAL_IP6", .CURLOPT_DNS_LOCAL_IP6, config.getDns_ipv6_addr()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TELNETOPTIONS)) {
							result = (ModernizedCProgram.tool_setopt_slist(curl, global, "CURLOPT_TELNETOPTIONS", .CURLOPT_TELNETOPTIONS, config.getTelnet_options()));
							if (result) {
								break;
							} 
						} 
					} while (/* new in libcurl 7.6.2: */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_RANDOM_FILE)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_RANDOM_FILE", .CURLOPT_RANDOM_FILE, config.getRandom_file()));
							if (result) {
								break;
							} 
						} 
					} while (/* new in libcurl 7.7: */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_EGDSOCKET)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_EGDSOCKET", .CURLOPT_EGDSOCKET, config.getEgd_file()));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_CONNECTTIMEOUT_MS)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_CONNECTTIMEOUT_MS", .CURLOPT_CONNECTTIMEOUT_MS, (long)(config.getConnecttimeout() * 1000)));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (config.getDoh_url()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_DOH_URL)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_DOH_URL", .CURLOPT_DOH_URL, config.getDoh_url()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getCipher_list()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSL_CIPHER_LIST)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SSL_CIPHER_LIST", .CURLOPT_SSL_CIPHER_LIST, config.getCipher_list()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getProxy_cipher_list()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_SSL_CIPHER_LIST)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_SSL_CIPHER_LIST", .CURLOPT_PROXY_SSL_CIPHER_LIST, config.getProxy_cipher_list()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getCipher13_list()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TLS13_CIPHERS)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_TLS13_CIPHERS", .CURLOPT_TLS13_CIPHERS, config.getCipher13_list()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getProxy_cipher13_list()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_TLS13_CIPHERS)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_TLS13_CIPHERS", .CURLOPT_PROXY_TLS13_CIPHERS, config.getProxy_cipher13_list()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getDisable_epsv()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FTP_USE_EPSV)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_FTP_USE_EPSV", .CURLOPT_FTP_USE_EPSV, -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* disable it */0);
					} 
					if (config.getDisable_eprt()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FTP_USE_EPRT)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_FTP_USE_EPRT", .CURLOPT_FTP_USE_EPRT, -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* disable it */0);
					} 
					if (global.getTracetype() != .TRACE_NONE) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_DEBUGFUNCTION)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_DEBUGFUNCTION", .CURLOPT_DEBUGFUNCTION, ModernizedCProgram.tool_debug_cb));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_DEBUGDATA)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_DEBUGDATA", .CURLOPT_DEBUGDATA, config));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_VERBOSE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_VERBOSE", .CURLOPT_VERBOSE, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getEngine()) {
						result = ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SSLENGINE", .CURLOPT_SSLENGINE, config.getEngine());
						if (result) {
							break;
						} 
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FTP_CREATE_MISSING_DIRS)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_FTP_CREATE_MISSING_DIRS", .CURLOPT_FTP_CREATE_MISSING_DIRS, (long)(config.getFtp_create_dirs() ? .CURLFTP_CREATE_DIR_RETRY : .CURLFTP_CREATE_DIR_NONE)));
							if (result) {
								break;
							} 
						} 
					} while (/* new in curl 7.10.7, extended in 7.19.4. Modified to use
					           CREATE_DIR_RETRY in 7.49.0 */0);
					if (config.getMax_filesize()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_MAXFILESIZE_LARGE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_MAXFILESIZE_LARGE", .CURLOPT_MAXFILESIZE_LARGE, config.getMax_filesize()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (4 == config.getIp_version()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_IPRESOLVE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_IPRESOLVE", .CURLOPT_IPRESOLVE, 1));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}  else if (6 == config.getIp_version()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_IPRESOLVE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_IPRESOLVE", .CURLOPT_IPRESOLVE, 2));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} else {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_IPRESOLVE)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_IPRESOLVE", .CURLOPT_IPRESOLVE, 0));
									if (result) {
										break;
									} 
								} 
							} while (0);
					} 
					if (config.getFtp_ssl_reqd()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_USE_SSL)) {
								result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_USE_SSL", .CURLOPT_USE_SSL, ModernizedCProgram.setopt_nv_CURLUSESSL, (long).CURLUSESSL_ALL));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}  else if (config.getFtp_ssl()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_USE_SSL)) {
								result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_USE_SSL", .CURLOPT_USE_SSL, ModernizedCProgram.setopt_nv_CURLUSESSL, (long).CURLUSESSL_TRY));
								if (result) {
									break;
								} 
							} 
						} while (0);
					}  else if (config.getFtp_ssl_control()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_USE_SSL)) {
								result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_USE_SSL", .CURLOPT_USE_SSL, ModernizedCProgram.setopt_nv_CURLUSESSL, (long).CURLUSESSL_CONTROL));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getFtp_ssl_ccc()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FTP_SSL_CCC)) {
								result = (ModernizedCProgram.tool_setopt_enum(curl, global, "CURLOPT_FTP_SSL_CCC", .CURLOPT_FTP_SSL_CCC, ModernizedCProgram.setopt_nv_CURLFTPSSL_CCC, (long)config.getFtp_ssl_ccc_mode()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getSocks5_gssapi_nec()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SOCKS5_GSSAPI_NEC)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SOCKS5_GSSAPI_NEC", .CURLOPT_SOCKS5_GSSAPI_NEC, config.getSocks5_gssapi_nec()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getSocks5_auth()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SOCKS5_AUTH)) {
								result = (ModernizedCProgram.tool_setopt_bitmask(curl, global, "CURLOPT_SOCKS5_AUTH", .CURLOPT_SOCKS5_AUTH, ModernizedCProgram.setopt_nv_CURLAUTH, (long)config.getSocks5_auth()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getProxy_service_name()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_SERVICE_NAME)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_SERVICE_NAME", .CURLOPT_PROXY_SERVICE_NAME, config.getProxy_service_name()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getService_name()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SERVICE_NAME)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SERVICE_NAME", .CURLOPT_SERVICE_NAME, config.getService_name()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FTP_ACCOUNT)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_FTP_ACCOUNT", .CURLOPT_FTP_ACCOUNT, config.getFtp_account()));
							if (result) {
								break;
							} 
						} 
					} while (/* curl 7.13.0 */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_IGNORE_CONTENT_LENGTH)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_IGNORE_CONTENT_LENGTH", .CURLOPT_IGNORE_CONTENT_LENGTH, config.getIgnorecl() ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FTP_SKIP_PASV_IP)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_FTP_SKIP_PASV_IP", .CURLOPT_FTP_SKIP_PASV_IP, config.getFtp_skip_ip() ? -1024 : -1024));
							if (result) {
								break;
							} 
						} 
					} while (/* curl 7.14.2 */0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FTP_FILEMETHOD)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_FTP_FILEMETHOD", .CURLOPT_FTP_FILEMETHOD, (long)config.getFtp_filemethod()));
							if (result) {
								break;
							} 
						} 
					} while (/* curl 7.15.1 */0);
					if (config.getLocalport()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_LOCALPORT)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_LOCALPORT", .CURLOPT_LOCALPORT, config.getLocalport()));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_LOCALPORTRANGE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_LOCALPORTRANGE", .CURLOPT_LOCALPORTRANGE, config.getLocalportrange()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FTP_ALTERNATIVE_TO_USER)) {
							result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_FTP_ALTERNATIVE_TO_USER", .CURLOPT_FTP_ALTERNATIVE_TO_USER, config.getFtp_alternative_to_user()));
							if (result) {
								break;
							} 
						} 
					} while (/* curl 7.15.5 */0);
					if (config.getDisable_sessionid()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSL_SESSIONID_CACHE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SSL_SESSIONID_CACHE", .CURLOPT_SSL_SESSIONID_CACHE, -1024));
								if (result) {
									break;
								} 
							} 
						} while (/* disable it */0);
					} 
					if (config.getRaw()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HTTP_CONTENT_DECODING)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_HTTP_CONTENT_DECODING", .CURLOPT_HTTP_CONTENT_DECODING, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HTTP_TRANSFER_DECODING)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_HTTP_TRANSFER_DECODING", .CURLOPT_HTTP_TRANSFER_DECODING, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (!config.getNokeepalive()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TCP_KEEPALIVE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TCP_KEEPALIVE", .CURLOPT_TCP_KEEPALIVE, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
						if (config.getAlivetime() != 0) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TCP_KEEPIDLE)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TCP_KEEPIDLE", .CURLOPT_TCP_KEEPIDLE, config.getAlivetime()));
									if (result) {
										break;
									} 
								} 
							} while (0);
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TCP_KEEPINTVL)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TCP_KEEPINTVL", .CURLOPT_TCP_KEEPINTVL, config.getAlivetime()));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
					} else {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TCP_KEEPALIVE)) {
									result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TCP_KEEPALIVE", .CURLOPT_TCP_KEEPALIVE, -1024));
									if (result) {
										break;
									} 
								} 
							} while (0);
					} 
					if (config.getTftp_blksize()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TFTP_BLKSIZE)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TFTP_BLKSIZE", .CURLOPT_TFTP_BLKSIZE, config.getTftp_blksize()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getMail_from()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_MAIL_FROM)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_MAIL_FROM", .CURLOPT_MAIL_FROM, config.getMail_from()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getMail_rcpt()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_MAIL_RCPT)) {
								result = (ModernizedCProgram.tool_setopt_slist(curl, global, "CURLOPT_MAIL_RCPT", .CURLOPT_MAIL_RCPT, config.getMail_rcpt()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getFtp_pret()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_FTP_USE_PRET)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_FTP_USE_PRET", .CURLOPT_FTP_USE_PRET, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getProto_present()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROTOCOLS)) {
								result = (ModernizedCProgram.tool_setopt_flags(curl, global, "CURLOPT_PROTOCOLS", .CURLOPT_PROTOCOLS, ModernizedCProgram.setopt_nv_CURLPROTO, config.getProto()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getProto_redir_present()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_REDIR_PROTOCOLS)) {
								result = (ModernizedCProgram.tool_setopt_flags(curl, global, "CURLOPT_REDIR_PROTOCOLS", .CURLOPT_REDIR_PROTOCOLS, ModernizedCProgram.setopt_nv_CURLPROTO, config.getProto_redir()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getContent_disposition() && (urlnode.getFlags() & (1 << 2))) {
						hdrcbdata.setHonor_cd_filename(1);
					} else {
							hdrcbdata.setHonor_cd_filename(0);
					} 
					hdrcbdata.setOuts(outs);
					hdrcbdata.setHeads(heads);
					hdrcbdata.setGlobal(global);
					hdrcbdata.setConfig(config);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HEADERFUNCTION)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_HEADERFUNCTION", .CURLOPT_HEADERFUNCTION, ModernizedCProgram.tool_header_cb));
							if (result) {
								break;
							} 
						} 
					} while (0);
					do {
						if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HEADERDATA)) {
							result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_HEADERDATA", .CURLOPT_HEADERDATA, per));
							if (result) {
								break;
							} 
						} 
					} while (0);
					if (config.getResolve()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_RESOLVE)) {
								result = (ModernizedCProgram.tool_setopt_slist(curl, global, "CURLOPT_RESOLVE", .CURLOPT_RESOLVE, config.getResolve()));
								if (result) {
									break;
								} 
							} 
						} while (/* new in 7.21.3 */0);
					} 
					if (config.getConnect_to()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_CONNECT_TO)) {
								result = (ModernizedCProgram.tool_setopt_slist(curl, global, "CURLOPT_CONNECT_TO", .CURLOPT_CONNECT_TO, config.getConnect_to()));
								if (result) {
									break;
								} 
							} 
						} while (/* new in 7.49.0 */0);
					} 
					if (ModernizedCProgram.curlinfo.getFeatures() & (1 << /* new in 7.21.4 */14)) {
						if (config.getTls_username()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TLSAUTH_USERNAME)) {
									result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_TLSAUTH_USERNAME", .CURLOPT_TLSAUTH_USERNAME, config.getTls_username()));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (config.getTls_password()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TLSAUTH_PASSWORD)) {
									result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_TLSAUTH_PASSWORD", .CURLOPT_TLSAUTH_PASSWORD, config.getTls_password()));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (config.getTls_authtype()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TLSAUTH_TYPE)) {
									result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_TLSAUTH_TYPE", .CURLOPT_TLSAUTH_TYPE, config.getTls_authtype()));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (config.getProxy_tls_username()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_TLSAUTH_USERNAME)) {
									result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_TLSAUTH_USERNAME", .CURLOPT_PROXY_TLSAUTH_USERNAME, config.getProxy_tls_username()));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (config.getProxy_tls_password()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_TLSAUTH_PASSWORD)) {
									result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_TLSAUTH_PASSWORD", .CURLOPT_PROXY_TLSAUTH_PASSWORD, config.getProxy_tls_password()));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
						if (config.getProxy_tls_authtype()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_TLSAUTH_TYPE)) {
									result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_PROXY_TLSAUTH_TYPE", .CURLOPT_PROXY_TLSAUTH_TYPE, config.getProxy_tls_authtype()));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
					} 
					if (config.getGssapi_delegation()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_GSSAPI_DELEGATION)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_GSSAPI_DELEGATION", .CURLOPT_GSSAPI_DELEGATION, config.getGssapi_delegation()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					{ 
						long mask = (config.getSsl_allow_beast() ? (1 << 0) : /* new in 7.25.0 and 7.44.0 */0) | (config.getSsl_no_revoke() ? (1 << 1) : 0);
						if (mask) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSL_OPTIONS)) {
									result = (ModernizedCProgram.tool_setopt_bitmask(curl, global, "CURLOPT_SSL_OPTIONS", .CURLOPT_SSL_OPTIONS, ModernizedCProgram.setopt_nv_CURLSSLOPT, mask));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} 
					}
					if (config.getProxy_ssl_allow_beast()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_PROXY_SSL_OPTIONS)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_PROXY_SSL_OPTIONS", .CURLOPT_PROXY_SSL_OPTIONS, (long)(1 << 0)));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getMail_auth()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_MAIL_AUTH)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_MAIL_AUTH", .CURLOPT_MAIL_AUTH, config.getMail_auth()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getSasl_authzid()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SASL_AUTHZID)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_SASL_AUTHZID", .CURLOPT_SASL_AUTHZID, config.getSasl_authzid()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getSasl_ir()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SASL_IR)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SASL_IR", .CURLOPT_SASL_IR, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getNonpn()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSL_ENABLE_NPN)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SSL_ENABLE_NPN", .CURLOPT_SSL_ENABLE_NPN, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getNoalpn()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_SSL_ENABLE_ALPN)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_SSL_ENABLE_ALPN", .CURLOPT_SSL_ENABLE_ALPN, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getUnix_socket_path()) {
						if (config.getAbstract_unix_socket()) {
							do {
								if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_ABSTRACT_UNIX_SOCKET)) {
									result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_ABSTRACT_UNIX_SOCKET", .CURLOPT_ABSTRACT_UNIX_SOCKET, config.getUnix_socket_path()));
									if (result) {
										break;
									} 
								} 
							} while (0);
						} else {
								do {
									if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_UNIX_SOCKET_PATH)) {
										result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_UNIX_SOCKET_PATH", .CURLOPT_UNIX_SOCKET_PATH, config.getUnix_socket_path()));
										if (result) {
											break;
										} 
									} 
								} while (0);
						} 
					} 
					if (config.getProto_default()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_DEFAULT_PROTOCOL)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_DEFAULT_PROTOCOL", .CURLOPT_DEFAULT_PROTOCOL, config.getProto_default()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getExpect100timeout() > /* new in 7.47.0 */0) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_EXPECT_100_TIMEOUT_MS)) {
								result = (ModernizedCProgram.tool_setopt(curl, 1, global, "CURLOPT_EXPECT_100_TIMEOUT_MS", .CURLOPT_EXPECT_100_TIMEOUT_MS, (long)(config.getExpect100timeout() * 1000)));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getTftp_no_options()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_TFTP_NO_OPTIONS)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_TFTP_NO_OPTIONS", .CURLOPT_TFTP_NO_OPTIONS, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getHappy_eyeballs_timeout_ms() != /* new in 7.59.0 */-1024) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS", .CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS, config.getHappy_eyeballs_timeout_ms()));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getHaproxy_protocol()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_HAPROXYPROTOCOL)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_HAPROXYPROTOCOL", .CURLOPT_HAPROXYPROTOCOL, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0);
					} 
					if (config.getDisallow_username_in_url()) {
						do {
							if (!ModernizedCProgram.tool_setopt_skip(.CURLOPT_DISALLOW_USERNAME_IN_URL)) {
								result = (ModernizedCProgram.tool_setopt(curl, 0, global, "CURLOPT_DISALLOW_USERNAME_IN_URL", .CURLOPT_DISALLOW_USERNAME_IN_URL, -1024));
								if (result) {
									break;
								} 
							} 
						} while (0/* only if explicitly enabled in configure */);
					} 
					per.setMetalink(/* USE_METALINK */metalink);
					per.setRetry_sleep_default((config.getRetry_delay()) ? config.getRetry_delay() * -1024 : /* ms */-1024);
					per.setRetry_numretries(config.getReq_retry());
					per.setRetry_sleep(per.getRetry_sleep_default());
					per.setRetrystart(timeval.tvnow());
					state.getLi()++;
				} else {
						do {
							.free((urlnode.getOutfile()));
							(urlnode.getOutfile()) = ((Object)0);
						} while (/* Free this URL node data without destroying the
						           the node itself nor modifying next pointer. */0);
						do {
							.free((urlnode.getInfile()));
							(urlnode.getInfile()) = ((Object)0);
						} while (0);
						urlnode.setFlags(0);
						ModernizedCProgram.glob_cleanup(state.getUrls());
						state.setUrls(((Object)0));
						state.setUrlnum(0);
						do {
							.free((state.getOutfiles()));
							(state.getOutfiles()) = ((Object)0);
						} while (0);
						do {
							.free((state.getUploadfile()));
							(state.getUploadfile()) = ((Object)0);
						} while (0);
						if (state.getInglob()) {
							ModernizedCProgram.glob_cleanup(state.getInglob());
							state.setInglob(((Object)0));
						} 
						config.getState().setUrlnode(urlnode.getNext());
						state.setUp(0);
						continue;
				} 
			}
			break;
		}
		if (!added || result) {
			added = 0;
			ModernizedCProgram.single_transfer_cleanup(config);
		} 
		return result/* number of easy handles currently added *//*
		 * add_parallel_transfers() sets 'morep' to TRUE if there are more transfers
		 * to add even after this call returns. sets 'addedp' to TRUE if one or more
		 * transfers were added.
		 */;
	}
	public static  add_parallel_transfers(Object global, Object multi, Object share, Object morep, Object addedp) {
		per_transfer per = new per_transfer();
		CURLcode result = .CURLE_OK;
		CURLMcode mcode = new CURLMcode();
		addedp = 0;
		morep = 0;
		result = ModernizedCProgram.create_transfer(global, share, addedp);
		if (result || !addedp) {
			return result;
		} 
		for (per = ModernizedCProgram.transfers; per && (ModernizedCProgram.all_added < global.getParallel_max()); per = per.getNext()) {
			bool getadded = 0;
			if (per.getAdded()) {
				continue;
			} 
			result = ModernizedCProgram.pre_transfer(global, per);
			if (result) {
				break;
			} 
			(Object);
			(Object);
			(Object);
			mcode = ModernizedCProgram.curl_multi_add_handle(multi, per.getCurl());
			if (mcode) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			result = ModernizedCProgram.create_transfer(global, share, getadded);
			if (result) {
				return result;
			} 
			per.setAdded(1);
			ModernizedCProgram.all_added++;
			addedp = 1;
		}
		morep = per ? 1 : 0;
		return .CURLE_OK;
	}
	public static  parallel_transfers(Object global, Object share) {
		CURLM multi = new CURLM();
		CURLMcode mcode = .CURLM_OK;
		CURLcode result = .CURLE_OK;
		int still_running = 1;
		timeval timeval = new timeval();
		timeval start = timeval.tvnow();
		bool more_transfers = new bool();
		bool added_transfers = new bool();
		multi = ModernizedCProgram.curl_multi_init();
		if (!multi) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		result = ModernizedCProgram.add_parallel_transfers(global, multi, share, more_transfers, added_transfers);
		if (result) {
			return result;
		} 
		while (!mcode && (still_running || more_transfers)) {
			mcode = ModernizedCProgram.curl_multi_poll(multi, ((Object)0), 0, 1000, ((Object)0));
			if (!mcode) {
				mcode = ModernizedCProgram.curl_multi_perform(multi, still_running);
			} 
			ModernizedCProgram.progress_meter(global, start, 0);
			if (!mcode) {
				int rc;
				CURLMsg msg = new CURLMsg();
				bool removed = 0;
				do {
					msg = ModernizedCProgram.curl_multi_info_read(multi, rc);
					if (msg) {
						bool retry = new bool();
						per_transfer ended = new per_transfer();
						CURL easy = msg.getEasy_handle();
						result = msg.getData().getResult();
						;
						ModernizedCProgram.curl_multi_remove_handle(multi, easy);
						result = ModernizedCProgram.post_per_transfer(global, ended, result, retry);
						if (retry) {
							continue;
						} 
						ModernizedCProgram.progress_finalize(/* before it goes away */ended);
						/* one fewer added */ModernizedCProgram.all_added--;
						removed = 1;
						(Object)ModernizedCProgram.del_per_transfer(ended);
					} 
				} while (msg);
				if (removed) {
					(Object)ModernizedCProgram.add_parallel_transfers(global, multi, /* one or more transfers completed, add more! */share, more_transfers, added_transfers);
					if (added_transfers) {
						still_running = /* we added new ones, make sure the loop doesn't exit yet */1;
					} 
				} 
			} 
		}
		(Object)ModernizedCProgram.progress_meter(global, start, 1);
		if (/* Make sure to return some kind of error if there was a multi problem */mcode) {
			result = (mcode == .CURLM_OUT_OF_MEMORY) ? .CURLE_OUT_OF_MEMORY/* The other multi errors should never happen, so return
			         something suitably generic */ : .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		ModernizedCProgram.curl_multi_cleanup(multi);
		return result;
	}
	public static  serial_transfers(Object global, Object share) {
		CURLcode returncode = .CURLE_OK;
		CURLcode result = .CURLE_OK;
		per_transfer per = new per_transfer();
		bool added = 0;
		result = ModernizedCProgram.create_transfer(global, share, added);
		if (result || !added) {
			return result;
		} 
		for (per = ModernizedCProgram.transfers; per; ) {
			bool retry = new bool();
			bool bailout = 0;
			result = ModernizedCProgram.pre_transfer(global, per);
			if (result) {
				break;
			} 
			if (global.getLibcurl()) {
				result = ModernizedCProgram.easysrc_perform();
				if (result) {
					break;
				} 
			} 
			result = ModernizedCProgram.curl_easy_perform(per.getCurl());
			returncode = /* store the result of the actual transfer */result;
			result = ModernizedCProgram.post_per_transfer(global, per, result, retry);
			if (retry) {
				continue;
			} 
			if (result || ModernizedCProgram.is_fatal_error(/* Bail out upon critical errors or --fail-early */returncode) || (returncode && global.getFail_early())) {
				bailout = 1;
			} else {
					result = ModernizedCProgram.create_transfer(global, share, /* setup the next one just before we delete this */added);
					if (result) {
						bailout = 1;
					} 
			} 
			(Object)per.getMlfile();
			per = ModernizedCProgram.del_per_transfer(per);
			if (bailout) {
				break;
			} 
		}
		if (returncode) {
			result = /* returncode errors have priority */returncode;
		} 
		if (result) {
			ModernizedCProgram.single_transfer_cleanup(global.getCurrent());
		} 
		return result;
	}
	/* setup a transfer for the given config */
	public static  transfer_per_config(Object global, Object config, Object share, Object added) {
		CURLcode result = .CURLE_OK;
		bool capath_from_env = new bool();
		added = 0;
		if (!config.getUrl_list() || !config.getUrl_list().getUrl()) {
			ModernizedCProgram.helpf(global.getErrors(), "no URL specified!\n");
			return .CURLE_FAILED_INIT/* On WIN32 we can't set the path to curl-ca-bundle.crt
			   * at compile time. So we look here for the file in two ways:
			   * 1: look at the environment variable CURL_CA_BUNDLE for a path
			   * 2: if #1 isn't found, use the windows API function SearchPath()
			   *    to find it along the app's path (includes app's dir and CWD)
			   *
			   * We support the environment variable thing for non-Windows platforms
			   * too. Just for the sake of it.
			   */;
		} 
		capath_from_env = .bool_false;
		if (!config.getCacert() && !config.getCapath() && !config.getInsecure_ok()) {
			CURL curltls = ModernizedCProgram.curl_easy_init();
			curl_tlssessioninfo tls_backend_info = ((Object)0/* With the addition of CAINFO support for Schannel, this search could find
			     * a certificate bundle that was previously ignored. To maintain backward
			     * compatibility, only perform this search if not using Schannel.
			     */);
			result = ;
			if (result) {
				return result/* Set the CA cert locations specified in the environment. For Windows if
				     * no environment-specified filename is found then check for CA bundle
				     * default filename curl-ca-bundle.crt in the user's PATH.
				     *
				     * If Schannel is the selected SSL backend then these locations are
				     * ignored. We allow setting CA location for schannel only when explicitly
				     * specified by the user via CURLOPT_CAINFO / --cacert.
				     */;
			} 
			if (tls_backend_info.getBackend() != .CURLSSLBACKEND_SCHANNEL) {
				byte env;
				env = ModernizedCProgram.curl_getenv("CURL_CA_BUNDLE");
				if (env) {
					config.setCacert(.strdup(env));
					if (!config.getCacert()) {
						ModernizedCProgram.curl_free(env);
						ModernizedCProgram.helpf(global.getErrors(), "out of memory\n");
						return .CURLE_OUT_OF_MEMORY;
					} 
				} else {
						env = ModernizedCProgram.curl_getenv("SSL_CERT_DIR");
						if (env) {
							config.setCapath(.strdup(env));
							if (!config.getCapath()) {
								ModernizedCProgram.curl_free(env);
								ModernizedCProgram.helpf(global.getErrors(), "out of memory\n");
								return .CURLE_OUT_OF_MEMORY;
							} 
							capath_from_env = .bool_true;
						} else {
								env = ModernizedCProgram.curl_getenv("SSL_CERT_FILE");
								if (env) {
									config.setCacert(.strdup(env));
									if (!config.getCacert()) {
										ModernizedCProgram.curl_free(env);
										ModernizedCProgram.helpf(global.getErrors(), "out of memory\n");
										return .CURLE_OUT_OF_MEMORY;
									} 
								} 
						} 
				} 
				if (env) {
					ModernizedCProgram.curl_free(env);
				} else {
						result = ModernizedCProgram.FindWin32CACert(config, tls_backend_info.getBackend(), "curl-ca-bundle.crt");
				} 
			} 
			ModernizedCProgram.curl_easy_cleanup(curltls);
		} 
		if (!result) {
			result = ModernizedCProgram.single_transfer(global, config, share, capath_from_env, added);
		} 
		return result/*
		 * 'create_transfer' gets the details and sets up a new transfer if 'added'
		 * returns TRUE.
		 */;
	}
	public static  create_transfer(Object global, Object share, Object added) {
		CURLcode result = .CURLE_OK;
		added = 0;
		while (global.getCurrent()) {
			result = ModernizedCProgram.transfer_per_config(global, global.getCurrent(), share, added);
			if (!result && !added) {
				global.setCurrent(global.getCurrent().getNext());
				continue;
			} 
			break;
		}
		return result;
	}
	public static  run_all_transfers(Object global, Object share,  result) {
		bool orig_noprogress = global.getNoprogress();
		bool orig_isatty = global.getIsatty();
		per_transfer per = new per_transfer();
		if (!/* Time to actually do the transfers */result) {
			if (global.getParallel()) {
				result = ModernizedCProgram.parallel_transfers(global, share);
			} else {
					result = ModernizedCProgram.serial_transfers(global, share);
			} 
		} 
		for (per = ModernizedCProgram.transfers; /* cleanup if there are any left */per; ) {
			bool retry = new bool();
			CURLcode result2 = ModernizedCProgram.post_per_transfer(global, per, result, retry);
			if (!result) {
				result = /* don't overwrite the original error */result2;
			} 
			ModernizedCProgram.clean_getout(per.getConfig());
			(Object)per.getConfig();
			per = ModernizedCProgram.del_per_transfer(per);
		}
		global.setNoprogress(/* Reset the global config variables */orig_noprogress);
		global.setIsatty(orig_isatty);
		return result;
	}
	public static  operate(Object global, int argc, Object argv) {
		CURLcode result = .CURLE_OK;
		.setlocale(0, /* Setup proper locale from environment */"");
		if ((argc == /* Parse .curlrc if necessary */1) || (!ModernizedCProgram.curl_strequal(argv[1], "-q") && !ModernizedCProgram.curl_strequal(argv[1], "--disable"))) {
			ModernizedCProgram.parseconfig(((Object)0), /* ignore possible failure */global);
			if ((argc < 2) && (!global.getFirst().getUrl_list())) {
				ModernizedCProgram.helpf(global.getErrors(), ((Object)0));
				result = .CURLE_FAILED_INIT;
			} 
		} 
		if (!result) {
			ParameterError res = ModernizedCProgram.parse_args(global, argc, /* Parse the command line arguments */argv);
			if (res) {
				result = .CURLE_OK;
				if (res == /* Check if we were asked for the help */.PARAM_HELP_REQUESTED) {
					ModernizedCProgram.tool_help();
				}  else if (res == /* Check if we were asked for the manual */.PARAM_MANUAL_REQUESTED) {
					.hugehelp();
				}  else if (res == /* Check if we were asked for the version information */.PARAM_VERSION_INFO_REQUESTED) {
					ModernizedCProgram.tool_version_info();
				}  else if (res == /* Check if we were asked to list the SSL engines */.PARAM_ENGINES_REQUESTED) {
					ModernizedCProgram.tool_list_engines();
				}  else if (res == .PARAM_LIBCURL_UNSUPPORTED_PROTOCOL) {
					result = .CURLE_UNSUPPORTED_PROTOCOL;
				} else {
						result = .CURLE_FAILED_INIT;
				} 
			} else {
					if (global.getLibcurl()) {
						result = ModernizedCProgram.easysrc_init();
					} 
					if (!/* Perform the main operations */result) {
						size_t count = 0;
						OperationConfig operation = global.getFirst();
						CURLSH share = ModernizedCProgram.curl_share_init();
						if (!share) {
							if (global.getLibcurl()) {
								ModernizedCProgram.easysrc_cleanup();
							} 
							return .CURLE_OUT_OF_MEMORY;
						} 
						ModernizedCProgram.curl_share_setopt(share, .CURLSHOPT_SHARE, .CURL_LOCK_DATA_COOKIE);
						ModernizedCProgram.curl_share_setopt(share, .CURLSHOPT_SHARE, .CURL_LOCK_DATA_DNS);
						ModernizedCProgram.curl_share_setopt(share, .CURLSHOPT_SHARE, .CURL_LOCK_DATA_SSL_SESSION);
						ModernizedCProgram.curl_share_setopt(share, .CURLSHOPT_SHARE, .CURL_LOCK_DATA_CONNECT);
						ModernizedCProgram.curl_share_setopt(share, .CURLSHOPT_SHARE, .CURL_LOCK_DATA_PSL);
						do {
							result = ModernizedCProgram.get_args(operation, count++);
							operation = operation.getNext();
						} while (!result && operation);
						global.setCurrent(global.getFirst());
						result = ModernizedCProgram.run_all_transfers(global, share, /* now run! */result);
						ModernizedCProgram.curl_share_cleanup(share);
						if (global.getLibcurl()) {
							ModernizedCProgram.easysrc_cleanup();
							ModernizedCProgram.dumpeasysrc(/* Dump the libcurl code if previously enabled */global);
						} 
					} else {
							ModernizedCProgram.helpf(global.getErrors(), "out of memory\n");
					} 
			} 
		} 
		return result;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * Curl_read16_le()
	 *
	 * This function converts a 16-bit integer from the little endian format, as
	 * used in the incoming package to whatever endian format we're using
	 * natively.
	 *
	 * Parameters:
	 *
	 * buf      [in]     - A pointer to a 2 byte buffer.
	 *
	 * Returns the integer.
	 */
	public static int Curl_read16_le(Object buf) {
		return (int)(((int)buf[0]) | ((int)buf[1] << 8/*
		 * Curl_read32_le()
		 *
		 * This function converts a 32-bit integer from the little endian format, as
		 * used in the incoming package to whatever endian format we're using
		 * natively.
		 *
		 * Parameters:
		 *
		 * buf      [in]     - A pointer to a 4 byte buffer.
		 *
		 * Returns the integer.
		 */));
	}
	public static int Curl_read32_le(Object buf) {
		return ((int)buf[0]) | ((int)buf[1] << 8) | ((int)buf[2] << 16) | ((int)buf[3] << 24/*
		 * Curl_read16_be()
		 *
		 * This function converts a 16-bit integer from the big endian format, as
		 * used in the incoming package to whatever endian format we're using
		 * natively.
		 *
		 * Parameters:
		 *
		 * buf      [in]     - A pointer to a 2 byte buffer.
		 *
		 * Returns the integer.
		 */);
	}
	public static int Curl_read16_be(Object buf) {
		return (int)(((int)buf[0] << 8) | ((int)buf[1/*
		 * write32_le()
		 *
		 * This function converts a 32-bit integer from the native endian format,
		 * to little endian format ready for sending down the wire.
		 *
		 * Parameters:
		 *
		 * value    [in]     - The 32-bit integer value.
		 * buffer   [in]     - A pointer to the output buffer.
		 */]));
	}
	public static void write32_le(Object value, Object buffer) {
		buffer[0] = (byte)(value & -1024);
		buffer[1] = (byte)((value & -1024) >> 8);
		buffer[2] = (byte)((value & -1024) >> 16);
		buffer[3] = (byte)((value & -1024) >> 24/*
		 * Curl_write64_le()
		 *
		 * This function converts a 64-bit integer from the native endian format,
		 * to little endian format ready for sending down the wire.
		 *
		 * Parameters:
		 *
		 * value    [in]     - The 64-bit integer value.
		 * buffer   [in]     - A pointer to the output buffer.
		 */);
	}
	public static void Curl_write64_le(Object value, Object buffer) {
		ModernizedCProgram.write32_le((int)value, buffer);
		ModernizedCProgram.write32_le((int)(value >> 32), buffer + 4/* CURL_SIZEOF_CURL_OFF_T > 4 */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* Escape and unescape URL encoding in strings. The functions return a new
	 * allocated string or NULL if an error occurred.  */
	/* The last 3 #include files should be in this order */
	/* Portable character check (remember EBCDIC). Do not use isalnum() because
	   its behavior is altered by the current locale.
	   See https://tools.ietf.org/html/rfc3986#section-2.3
	*/
	public static  Curl_isunreserved(byte in) {
		switch (in) {
		case (byte)'d':
		case (byte)'2':
		case (byte)'n':
		case (byte)'t':
		case (byte)'G':
		case (byte)'K':
		case (byte)'_':
		case (byte)'4':
		case (byte)'R':
		case (byte)'p':
		case (byte)'k':
		case (byte)'I':
		case (byte)'3':
		case (byte)'O':
		case (byte)'D':
		case (byte)'C':
		case (byte)'Y':
		case (byte)'F':
		case (byte)'P':
		case (byte)'x':
		case (byte)'f':
		case (byte)'L':
		case (byte)'Q':
		case (byte)'u':
		case (byte)'y':
		case (byte)'T':
		case (byte)'1':
		case (byte)'l':
		case (byte)'S':
		case (byte)'~':
				return 1;
		case (byte)'V':
		case (byte)'v':
		case (byte)'o':
		case (byte)'E':
		case (byte)'c':
		case (byte)'m':
		case (byte)'H':
		case (byte)'B':
		case (byte)'M':
		case (byte)'5':
		case (byte)'e':
		case (byte)'J':
		case (byte)'W':
		case (byte)'0':
		case (byte)'s':
		case (byte)'-':
		case (byte)'N':
		case (byte)'6':
		case (byte)'i':
		case (byte)'w':
		case (byte)'8':
		case (byte)'q':
		case (byte)'U':
		case (byte)'z':
		case (byte)'A':
		case (byte)'Z':
		case (byte)'h':
		case (byte)'9':
		case (byte)'b':
		case (byte)'j':
		case (byte)'g':
		case (byte)'.':
		case (byte)'X':
		case (byte)'7':
		case (byte)'a':
		case (byte)'r':
		default:
				break;
		}
		return 0;
	}
	/* for ABI-compatibility with previous versions */
	public static Object curl_escape(Object string, int inlength) {
		return ModernizedCProgram.curl_easy_escape(((Object)0), string, inlength);
	}
	/* for ABI-compatibility with previous versions */
	public static Object curl_unescape(Object string, int length) {
		return ModernizedCProgram.curl_easy_unescape(((Object)0), string, length, ((Object)0));
	}
	public static Object curl_easy_escape(Object data, Object string, int inlength) {
		size_t alloc = new size_t();
		byte ns;
		byte testing_ptr = ((Object)0);
		size_t newlen = new size_t();
		size_t strindex = 0;
		size_t length = new size_t();
		CURLcode result = new CURLcode();
		if (inlength < 0) {
			return ((Object)0);
		} 
		alloc = (inlength ? (size_t)inlength : .strlen(string)) + 1;
		newlen = alloc;
		ns = .Curl_cmalloc(alloc);
		if (!ns) {
			return ((Object)0);
		} 
		length = alloc - 1;
		while (length--) {
			byte in = /* we need to treat the characters unsigned */string;
			if (ModernizedCProgram.Curl_isunreserved(in)) {
				ns[strindex++] = /* just copy this */in;
			} else {
					newlen += /* encode it *//* the size grows with two, since this'll become a %XX */2;
					if (newlen > alloc) {
						alloc *= 2;
						testing_ptr = ModernizedCProgram.Curl_saferealloc(ns, alloc);
						if (!testing_ptr) {
							return ((Object)0);
						} 
						ns = testing_ptr;
					} 
					result = ();
					if (result) {
						.Curl_cfree(/* Curl_convert_to_network calls failf if unsuccessful */ns);
						return ((Object)0);
					} 
					ModernizedCProgram.curl_msnprintf(ns[strindex], 4, "%%%02X", in);
					strindex += 3;
			} 
			string++;
		}
		ns[strindex] = /* terminate it */0;
		return ns/*
		 * Curl_urldecode() URL decodes the given string.
		 *
		 * Optionally detects control characters (byte codes lower than 32) in the
		 * data and rejects such data.
		 *
		 * Returns a pointer to a malloced string in *ostring with length given in
		 * *olen. If length == 0, the length is assumed to be strlen(string).
		 *
		 * 'data' can be set to NULL but then this function can't convert network
		 * data to host for non-ascii.
		 */;
	}
	public static  Curl_urldecode(Object data, Object string, Object length, Object ostring, Object olen,  reject_ctrl) {
		size_t alloc = (length ? length : .strlen(string)) + 1;
		byte ns = .Curl_cmalloc(alloc);
		size_t strindex = 0;
		long hex;
		CURLcode result = .CURLE_OK;
		if (!ns) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		while (--alloc > 0) {
			byte in = string;
			if (((byte)'%' == in) && (alloc > 2) && (ModernizedCProgram.Curl_isxdigit((int)((byte)string[1]))) && (ModernizedCProgram.Curl_isxdigit((int)((byte)string[2])))) {
				byte[] hexstr = new byte[/* this is two hexadecimal digits following a '%' */3];
				byte ptr;
				hexstr[0] = string[1];
				hexstr[1] = string[2];
				hexstr[2] = 0;
				hex = .strtoul(hexstr, ptr, 16);
				in = ModernizedCProgram.curlx_ultouc(/* this long is never bigger than 255 anyway */hex);
				if (data) {
					result = ();
					if (result) {
						.Curl_cfree(/* Curl_convert_from_network calls failf if unsuccessful */ns);
						return result;
					} 
				} 
				string += 2;
				alloc -= 2;
			} 
			if (reject_ctrl && (in < -1024)) {
				.Curl_cfree(ns);
				return .CURLE_URL_MALFORMAT;
			} 
			ns[strindex++] = in;
			string++;
		}
		ns[strindex] = /* terminate it */0;
		if (olen) {
			olen = /* store output size */strindex;
		} 
		ostring = /* store output string */ns;
		return .CURLE_OK/*
		 * Unescapes the given URL escaped string of given length. Returns a
		 * pointer to a malloced string with length given in *olen.
		 * If length == 0, the length is assumed to be strlen(string).
		 * If olen == NULL, no output length is stored.
		 */;
	}
	public static Object curl_easy_unescape(Object data, Object string, int length, Object olen) {
		byte str = ((Object)0);
		if (length >= 0) {
			size_t inputlen = length;
			size_t outputlen = new size_t();
			CURLcode res = ModernizedCProgram.Curl_urldecode(data, string, inputlen, str, outputlen, 0);
			if (res) {
				return ((Object)0);
			} 
			if (olen) {
				if (outputlen <= (size_t)2147483647) {
					olen = ModernizedCProgram.curlx_uztosi(outputlen);
				} else {
						do {
							.Curl_cfree((str));
							(str) = ((Object)0);
						} while (/* too large to return in an int, fail! */0);
				} 
			} 
		} 
		return str/* For operating systems/environments that use different malloc/free
		   systems for the app and for this library, we provide a free that uses
		   the library's memory system */;
	}
	public static void curl_free(Object p) {
		.Curl_cfree(p);
	}
	/* doing */
	/* proto_getsock */
	/* doing_getsock */
	/* domore_getsock */
	/* perform_getsock */
	/* disconnect */
	/* readwrite */
	/* connection_check */
	/* defport */
	/* protocol */
	/* flags */
	public static  http_setup_conn(Object conn) {
		/* allocate the HTTP-specific struct for the Curl_easy, only to survive
		     during this request */HTTP http = new HTTP();
		Curl_easy data = conn.getData();
		do {
		} while (0);
		http = .Curl_ccalloc(1, );
		if (!http) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.Curl_mime_initpart(http.getForm(), conn.getData());
		data.getReq().setProtop(http);
		if (data.getSet().getHttpversion() == .CURL_HTTP_VERSION_3) {
			if (conn.getHandler().getFlags() & (1 << 0/* Only go HTTP/3 directly on HTTPS URLs. It needs a UDP socket and does
			         the QUIC dance. */)) {
				conn.setTransport(.TRNSPRT_QUIC);
			} else {
					ModernizedCProgram.Curl_failf(data, "HTTP/3 requested for non-HTTPS URL");
					return .CURLE_URL_MALFORMAT;
			} 
		} else {
				if (!((conn).getEasyq().getSize())) {
					do {
					} while (/* if not already multi-using, setup connection details */0);
				} 
				;
		} 
		return .CURLE_OK/*
		 * checkProxyHeaders() checks the linked list of custom proxy headers
		 * if proxy headers are not available, then it will lookup into http header
		 * link list
		 *
		 * It takes a connectdata struct as input instead of the Curl_easy simply to
		 * know if this is a proxy request or not, as it then might check a different
		 * header list. Provide the header prefix without colon!.
		 *//*
		 * checkProxyHeaders() checks the linked list of custom proxy headers
		 * if proxy headers are not available, then it will lookup into http header
		 * link list
		 *
		 * It takes a connectdata struct as input instead of the Curl_easy simply to
		 * know if this is a proxy request or not, as it then might check a different
		 * header list. Provide the header prefix without colon!.
		 */;
	}
	/*
	 * HTTP handler interface.
	 */
	public static Object Curl_checkProxyheaders(Object conn, Object thisheader) {
		curl_slist head = new curl_slist();
		size_t thislen = .strlen(thisheader);
		Curl_easy data = conn.getData();
		for (head = (conn.getBits().getProxy() && data.getSet().getSep_headers()) ? data.getSet().getProxyheaders() : data.getSet().getHeaders(); head; head = head.getNext()) {
			if (ModernizedCProgram.Curl_strncasecompare(head.getData(), thisheader, thislen) && ((((head.getData()[thislen]) == (byte)':') || ((head.getData()[thislen]) == (byte)';')))) {
				return head.getData();
			} 
		}
		return ((Object)0/* disabled */);
	}
	/*
	 * Strip off leading and trailing whitespace from the value in the
	 * given HTTP header line and return a strdupped copy. Returns NULL in
	 * case of allocation failure. Returns an empty string if the header value
	 * consists entirely of whitespace.
	 */
	public static Object Curl_copy_header_value(Object header) {
		byte start;
		byte end;
		byte value;
		size_t len = new size_t();
		while (header && (header != /* Find the end of the header name */(byte)':')) {
			++header;
		}
		if (header) {
			++/* Skip over colon */header;
		} 
		start = /* Find the first non-space letter */header;
		while (start && (ModernizedCProgram.Curl_isspace((int)((byte)start)))) {
			start++;
		}
		end = .strchr(start, /* data is in the host encoding so
		     use '\r' and '\n' instead of 0x0d and 0x0a */(byte)'\r');
		if (!end) {
			end = .strchr(start, (byte)'\n');
		} 
		if (!end) {
			end = .strchr(start, (byte)'\0');
		} 
		if (!end) {
			return ((Object)0);
		} 
		while ((end > start) && (ModernizedCProgram.Curl_isspace((int)((byte)/* skip all trailing space letters */end)))) {
			end--;
		}
		len = end - start + /* get length of the type */1;
		value = .Curl_cmalloc(len + 1);
		if (!value) {
			return ((Object)0);
		} 
		.memcpy(value, start, len);
		value[len] = /* zero terminate */0;
		return value/*
		 * http_output_basic() sets up an Authorization: header (or the proxy version)
		 * for HTTP Basic authentication.
		 *
		 * Returns CURLcode.
		 *//*
		 * http_output_basic() sets up an Authorization: header (or the proxy version)
		 * for HTTP Basic authentication.
		 *
		 * Returns CURLcode.
		 */;
	}
	public static  http_output_basic(Object conn,  proxy) {
		size_t size = 0;
		byte authorization = ((Object)0);
		Curl_easy data = conn.getData();
		byte userp;
		byte user;
		byte pwd;
		CURLcode result = new CURLcode();
		byte out;
		if (proxy) {
			userp = conn.getAllocptr().getProxyuserpwd();
			user = conn.getHttp_proxy().getUser();
			pwd = conn.getHttp_proxy().getPasswd();
		} else {
				userp = conn.getAllocptr().getUserpwd();
				user = conn.getUser();
				pwd = conn.getPasswd();
		} 
		out = ModernizedCProgram.curl_maprintf("%s:%s", user, pwd);
		if (!out) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		result = ModernizedCProgram.Curl_base64_encode(data, out, .strlen(out), authorization, size);
		if (result) {
			;
		} 
		if (!authorization) {
			result = .CURLE_REMOTE_ACCESS_DENIED;
			;
		} 
		.Curl_cfree(userp);
		userp = ModernizedCProgram.curl_maprintf("%sAuthorization: Basic %s\r\n", proxy ? "Proxy-" : "", authorization);
		.Curl_cfree(authorization);
		if (!userp) {
			result = .CURLE_OUT_OF_MEMORY;
			;
		} 
		return result/*
		 * http_output_bearer() sets up an Authorization: header
		 * for HTTP Bearer authentication.
		 *
		 * Returns CURLcode.
		 */;
	}
	public static  http_output_bearer(Object conn) {
		byte userp;
		CURLcode result = .CURLE_OK;
		userp = conn.getAllocptr().getUserpwd();
		.Curl_cfree(userp);
		userp = ModernizedCProgram.curl_maprintf("Authorization: Bearer %s\r\n", conn.getOauth_bearer());
		if (!userp) {
			result = .CURLE_OUT_OF_MEMORY;
			;
		} 
	}
	public static  pickoneauth(Object pick, long mask) {
		bool picked = new bool();
		long avail = pick.getAvail() & pick.getWant() & /* only deal with authentication we want */mask;
		picked = 1;
		if (avail & (((long)1) << /* The order of these checks is highly relevant, as this will be the order
		     of preference in case of the existence of multiple accepted types. */2)) {
			pick.setPicked((((long)1) << 2));
		}  else if (avail & (((long)1) << 6)) {
			pick.setPicked((((long)1) << 6));
		}  else if (avail & (((long)1) << 1)) {
			pick.setPicked((((long)1) << 1));
		}  else if (avail & (((long)1) << 3)) {
			pick.setPicked((((long)1) << 3));
		}  else if (avail & (((long)1) << 5)) {
			pick.setPicked((((long)1) << 5));
		}  else if (avail & (((long)1) << 0)) {
			pick.setPicked((((long)1) << 0));
		} else {
				pick.setPicked((1 << /* we select to use nothing */30));
				picked = 0;
		} 
		pick.setAvail(((long)/* clear it here */0));
		return picked/*
		 * http_perhapsrewind()
		 *
		 * If we are doing POST or PUT {
		 *   If we have more data to send {
		 *     If we are doing NTLM {
		 *       Keep sending since we must not disconnect
		 *     }
		 *     else {
		 *       If there is more than just a little data left to send, close
		 *       the current connection by force.
		 *     }
		 *   }
		 *   If we have sent any data {
		 *     If we don't have track of all the data {
		 *       call app to tell it to rewind
		 *     }
		 *     else {
		 *       rewind internally so that the operation can restart fine
		 *     }
		 *   }
		 * }
		 */;
	}
	public static  http_perhapsrewind(Object conn) {
		Curl_easy data = conn.getData();
		HTTP http = data.getReq().getProtop();
		curl_off_t bytessent = new curl_off_t();
		curl_off_t expectsend = -/* default is unknown */1;
		if (!http/* If this is still NULL, we have not reach very far and we can safely
		       skip this rewinding stuff */) {
			return .CURLE_OK;
		} 
		switch (data.getSet().getHttpreq()) {
		case .HTTPREQ_HEAD:
				return .CURLE_OK;
		case .HTTPREQ_GET:
		default:
				break;
		}
		bytessent = data.getReq().getWritebytecount();
		if (conn.getBits().getAuthneg()) {
			expectsend = 0;
		}  else if (!conn.getBits().getProtoconnstart()) {
			expectsend = /* HTTP CONNECT in progress: there is no body */0;
		} else {
				switch (data.getSet().getHttpreq()) {
				case .HTTPREQ_POST_MIME:
						expectsend = http.getPostsize();
						break;
				case .HTTPREQ_PUT:
						if (data.getState().getInfilesize() != -1) {
							expectsend = data.getState().getInfilesize();
						} 
						break;
				case .HTTPREQ_POST_FORM:
				case .HTTPREQ_POST:
				default:
						break;
				}
		} 
		conn.getBits().setRewindaftersend(/* default */0);
		if ((expectsend == -1) || (expectsend > bytessent)) {
			if ((data.getState().getAuthproxy().getPicked() == (((long)1) << /* There is still data left to send */3)) || (data.getState().getAuthhost().getPicked() == (((long)1) << 3)) || (data.getState().getAuthproxy().getPicked() == (((long)1) << 5)) || (data.getState().getAuthhost().getPicked() == (((long)1) << 5))) {
				if (((expectsend - bytessent) < 2000) || (conn.getHttp_ntlm_state() != .NTLMSTATE_NONE) || (conn.getProxy_ntlm_state() != .NTLMSTATE_NONE/* The NTLM-negotiation has started *OR* there is just a little (<2K)
				           data left to send, keep on sending. */)) {
					if (!conn.getBits().getAuthneg() && (conn.getWritesockfd() != (SOCKET)(~/* rewind data when completely done sending! */0))) {
						conn.getBits().setRewindaftersend(1);
						ModernizedCProgram.Curl_infof(data, "Rewind stream after send\n");
					} 
					return .CURLE_OK;
				} 
				if (conn.getBits().getClose()) {
					return /* this is already marked to get closed */.CURLE_OK;
				} 
				ModernizedCProgram.Curl_infof(data, "NTLM send, close instead of sending %I64d bytes\n", (curl_off_t)(expectsend - bytessent/* There is still data left to send *//* The NEGOTIATE-negotiation has started *OR*
				        there is just a little (<2K) data left to send, keep on sending. *//* rewind data when completely done sending! */));
			} 
			ModernizedCProgram.Curl_conncontrol(conn, /* this is already marked to get closed *//* This is not NEGOTIATE/NTLM or many bytes left to send: close */2);
			data.getReq().setSize(/* don't download any more than 0 bytes */0/* There still is data left to send, but this connection is marked for
			       closure so we can safely do the rewind right now */);
		} 
		if (bytessent) {
			return ModernizedCProgram.Curl_readrewind(/* we rewind now at once since if we already sent something */conn);
		} 
		return .CURLE_OK/*
		 * Curl_http_auth_act() gets called when all HTTP headers have been received
		 * and it checks what authentication methods that are available and decides
		 * which one (if any) to use. It will set 'newurl' if an auth method was
		 * picked.
		 */;
	}
	public static  Curl_http_auth_act(Object conn) {
		Curl_easy data = conn.getData();
		bool pickhost = 0;
		bool pickproxy = 0;
		CURLcode result = .CURLE_OK;
		long authmask = ~-1024;
		if (!conn.getOauth_bearer()) {
			authmask &=  (long)~(((long)1) << 6);
		} 
		if (100 <= data.getReq().getHttpcode() && 199 >= data.getReq().getHttpcode()) {
			return /* this is a transient response code, ignore */.CURLE_OK;
		} 
		if (data.getState().getAuthproblem()) {
			return data.getSet().getHttp_fail_on_error() ? .CURLE_HTTP_RETURNED_ERROR : .CURLE_OK;
		} 
		if ((conn.getBits().getUser_passwd() || conn.getOauth_bearer()) && ((data.getReq().getHttpcode() == 401) || (conn.getBits().getAuthneg() && data.getReq().getHttpcode() < 300))) {
			pickhost = ModernizedCProgram.pickoneauth(data.getState().getAuthhost(), authmask);
			if (!pickhost) {
				data.getState().setAuthproblem(1);
			} 
			if (data.getState().getAuthhost().getPicked() == (((long)1) << 3) && conn.getHttpversion() > 11) {
				ModernizedCProgram.Curl_infof(data, "Forcing HTTP/1.1 for NTLM");
				ModernizedCProgram.Curl_conncontrol(conn, 1);
				conn.getData().getSet().setHttpversion(.CURL_HTTP_VERSION_1_1);
			} 
		} 
		if (conn.getBits().getProxy_user_passwd() && ((data.getReq().getHttpcode() == 407) || (conn.getBits().getAuthneg() && data.getReq().getHttpcode() < 300))) {
			pickproxy = ModernizedCProgram.pickoneauth(data.getState().getAuthproxy(), authmask & ~(((long)1) << 6));
			if (!pickproxy) {
				data.getState().setAuthproblem(1);
			} 
		} 
		if (pickhost || pickproxy) {
			if ((data.getSet().getHttpreq() != .HTTPREQ_GET) && (data.getSet().getHttpreq() != .HTTPREQ_HEAD) && !conn.getBits().getRewindaftersend()) {
				result = ModernizedCProgram.http_perhapsrewind(conn);
				if (result) {
					return result/* In case this is GSS auth, the newurl field is already allocated so
					       we must make sure to free it before allocating a new one. As figured
					       out in bug #2284386 */;
				} 
			} 
			do {
				.Curl_cfree((data.getReq().getNewurl()));
				(data.getReq().getNewurl()) = ((Object)0);
			} while (0);
			data.getReq().setNewurl(.Curl_cstrdup(data.getChange().getUrl()));
			if (!data.getReq().getNewurl()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		}  else if ((data.getReq().getHttpcode() < 300) && (!data.getState().getAuthhost().getDone()) && conn.getBits().getAuthneg()) {
			if ((data.getSet().getHttpreq() != .HTTPREQ_GET) && (data.getSet().getHttpreq() != .HTTPREQ_HEAD)) {
				data.getReq().setNewurl(.Curl_cstrdup(data.getChange().getUrl()));
				if (!data.getReq().getNewurl()) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				data.getState().getAuthhost().setDone(1);
			} 
		} 
		if (ModernizedCProgram.http_should_fail(conn)) {
			ModernizedCProgram.Curl_failf(data, "The requested URL returned error: %d", data.getReq().getHttpcode());
			result = .CURLE_HTTP_RETURNED_ERROR;
		} 
		return result/*
		 * Output the correct authentication header depending on the auth type
		 * and whether or not it is to a proxy.
		 *//*
		 * Output the correct authentication header depending on the auth type
		 * and whether or not it is to a proxy.
		 */;
	}
	public static  output_auth_headers(Object conn, Object authstatus, Object request, Object path,  proxy) {
		byte auth = ((Object)0);
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		if (authstatus.getPicked() == (((long)1) << 3)) {
			auth = "NTLM";
			result = ModernizedCProgram.Curl_output_ntlm(conn, proxy);
			if (result) {
				return result;
			} 
		}  else if (authstatus.getPicked() == (((long)1) << 1)) {
			auth = "Digest";
			result = ModernizedCProgram.Curl_output_digest(conn, proxy, (byte)request, (byte)path);
			if (result) {
				return result;
			} 
		}  else if (authstatus.getPicked() == (((long)1) << 0)) {
			if ((proxy && conn.getBits().getProxy_user_passwd() && !ModernizedCProgram.Curl_checkProxyheaders(conn, "Proxy-authorization")) || (!proxy && conn.getBits().getUser_passwd() && !ModernizedCProgram.Curl_checkheaders(conn, "Authorization"))) {
				auth = "Basic";
				result = ModernizedCProgram.http_output_basic(conn, proxy);
				if (result) {
					return result;
				} 
			} 
			authstatus.setDone(/* NOTE: this function should set 'done' TRUE, as the other auth
			       functions work that way */1);
		} 
		if (authstatus.getPicked() == (((long)1) << 6)) {
			if ((!proxy && conn.getOauth_bearer() && !ModernizedCProgram.Curl_checkheaders(conn, "Authorization:"))) {
				auth = "Bearer";
				result = ModernizedCProgram.http_output_bearer(conn);
				if (result) {
					return result;
				} 
			} 
			authstatus.setDone(/* NOTE: this function should set 'done' TRUE, as the other auth
			       functions work that way */1);
		} 
		if (auth) {
			ModernizedCProgram.Curl_infof(data, "%s auth using %s with user '%s'\n", proxy ? "Proxy" : "Server", auth, proxy ? (conn.getHttp_proxy().getUser() ? conn.getHttp_proxy().getUser() : "") : (conn.getUser() ? conn.getUser() : ""));
			authstatus.setMultipass((!authstatus.getDone()) ? 1 : 0);
		} else {
				authstatus.setMultipass(0);
		} 
		return .CURLE_OK/**
		 * Curl_http_output_auth() setups the authentication headers for the
		 * host/proxy and the correct authentication
		 * method. conn->data->state.authdone is set to TRUE when authentication is
		 * done.
		 *
		 * @param conn all information about the current connection
		 * @param request pointer to the request keyword
		 * @param path pointer to the requested path; should include query part
		 * @param proxytunnel boolean if this is the request setting up a "proxy
		 * tunnel"
		 *
		 * @returns CURLcode
		 */;
	}
	public static  Curl_http_output_auth(Object conn, Object request, Object path,  proxytunnel) {
		CURLcode result = /* TRUE if this is the request setting
		                                           up the proxy tunnel */.CURLE_OK;
		Curl_easy data = conn.getData();
		auth authhost = new auth();
		auth authproxy = new auth();
		do {
		} while (0);
		authhost = data.getState().getAuthhost();
		authproxy = data.getState().getAuthproxy();
		if ((conn.getBits().getHttpproxy() && conn.getBits().getProxy_user_passwd()) || conn.getBits().getUser_passwd() || conn.getOauth_bearer()) {
			;
		} else {
				authhost.setDone(1);
				authproxy.setDone(1);
				return /* no authentication with no user or password */.CURLE_OK;
		} 
		if (authhost.getWant() && !authhost.getPicked()) {
			authhost.setPicked(authhost.getWant());
		} 
		if (authproxy.getWant() && !authproxy.getPicked()) {
			authproxy.setPicked(authproxy.getWant());
		} 
		if (conn.getBits().getHttpproxy() && (conn.getBits().getTunnel_proxy() == (bit)proxytunnel)) {
			result = ModernizedCProgram.output_auth_headers(conn, authproxy, request, path, 1);
			if (result) {
				return result;
			} 
		} else {
				authproxy.setDone(/* CURL_DISABLE_PROXY *//* we have no proxy so let's pretend we're done authenticating
				       with it */1);
		} 
		if (!data.getState().getThis_is_a_follow() || conn.getBits().getNetrc() || !data.getState().getFirst_host() || data.getSet().getAllow_auth_to_other_hosts() || ModernizedCProgram.Curl_strcasecompare(data.getState().getFirst_host(), conn.getHost().getName())) {
			result = ModernizedCProgram.output_auth_headers(conn, authhost, request, path, 0);
		} else {
				authhost.setDone(1);
		} 
		return result/* when disabled */;
	}
	/*
	 * Curl_http_input_auth() deals with Proxy-Authenticate: and WWW-Authenticate:
	 * headers. They are dealt with both in the transfer.c main loop and in the
	 * proxy CONNECT loop.
	 */
	public static  Curl_http_input_auth(Object conn,  proxy, Object auth) {
		Curl_easy data = conn.getData();
		long availp;
		auth authp = new auth();
		if (proxy) {
			availp = data.getInfo().getProxyauthavail();
			authp = data.getState().getAuthproxy();
		} else {
				availp = data.getInfo().getHttpauthavail();
				authp = data.getState().getAuthhost();
		} 
		while (auth) {
			if (ModernizedCProgram.curl_strnequal("NTLM", auth, .strlen(/* we received a GSS auth token and we dealt with it fine *//* NTLM support requires the SSL crypto libs */"NTLM"))) {
				if ((authp.getAvail() & (((long)1) << 3)) || (authp.getAvail() & (((long)1) << 5)) || .Curl_auth_is_ntlm_supported()) {
					availp |=  (((long)1) << 3);
					authp.getAvail() |=  (((long)1) << 3);
					if (authp.getPicked() == (((long)1) << 3) || authp.getPicked() == (((long)1) << 5)) {
						CURLcode result = ModernizedCProgram.Curl_input_ntlm(conn, proxy, /* NTLM authentication is picked and activated */auth);
						if (!result) {
							data.getState().setAuthproblem(0);
						} else {
								ModernizedCProgram.Curl_infof(data, "Authentication problem. Ignoring this.\n");
								data.getState().setAuthproblem(1);
						} 
					} 
				} 
			}  else if (ModernizedCProgram.curl_strnequal("Digest", auth, .strlen("Digest"))) {
				if ((authp.getAvail() & (((long)1) << 1)) != 0) {
					ModernizedCProgram.Curl_infof(data, "Ignoring duplicate digest auth header.\n");
				}  else if (.Curl_auth_is_digest_supported()) {
					CURLcode result = new CURLcode();
					availp |=  (((long)1) << 1);
					authp.getAvail() |=  (((long)1) << 1/* We call this function on input Digest headers even if Digest
					             * authentication isn't activated yet, as we need to store the
					             * incoming data from this header in case we are going to use
					             * Digest */);
					result = ModernizedCProgram.Curl_input_digest(conn, proxy, auth);
					if (result) {
						ModernizedCProgram.Curl_infof(data, "Authentication problem. Ignoring this.\n");
						data.getState().setAuthproblem(1);
					} 
				} 
			}  else if (ModernizedCProgram.curl_strnequal("Basic", auth, .strlen("Basic"))) {
				availp |=  (((long)1) << 0);
				authp.getAvail() |=  (((long)1) << 0);
				if (authp.getPicked() == (((long)1) << 0/* We asked for Basic authentication but got a 40X back
				                 anyway, which basically means our name+password isn't
				                 valid. */)) {
					authp.setAvail(((long)0));
					ModernizedCProgram.Curl_infof(data, "Authentication problem. Ignoring this.\n");
					data.getState().setAuthproblem(1);
				} 
			}  else if (ModernizedCProgram.curl_strnequal("Bearer", auth, .strlen("Bearer"))) {
				availp |=  (((long)1) << 6);
				authp.getAvail() |=  (((long)1) << 6);
				if (authp.getPicked() == (((long)1) << 6/* We asked for Bearer authentication but got a 40X back
				                  anyway, which basically means our token isn't valid. */)) {
					authp.setAvail(((long)0));
					ModernizedCProgram.Curl_infof(data, "Authentication problem. Ignoring this.\n");
					data.getState().setAuthproblem(1);
				} 
			} 
			while (auth && auth != /* there may be multiple methods on one line, so keep reading *//* read up to the next comma */(byte)',') {
				auth++;
			}
			if (auth == /* if we're on a comma, skip it */(byte)',') {
				auth++;
			} 
			while (auth && (ModernizedCProgram.Curl_isspace((int)((byte)auth)))) {
				auth++;
			}
		}
		return .CURLE_OK/**
		 * http_should_fail() determines whether an HTTP response has gotten us
		 * into an error state or not.
		 *
		 * @param conn all information about the current connection
		 *
		 * @retval 0 communications should continue
		 *
		 * @retval 1 communications should not continue
		 */;
	}
	/* the first non-space */
	public static int http_should_fail(Object conn) {
		Curl_easy data = new Curl_easy();
		int httpcode;
		do {
		} while (0);
		data = conn.getData();
		do {
		} while (0);
		httpcode = data.getReq().getHttpcode();
		if (!data.getSet().getHttp_fail_on_error()) {
			return 0/*
			  ** Any code < 400 is never terminal.
			  */;
		} 
		if (httpcode < 400) {
			return 0/*
			  ** Any code >= 400 that's not 401 or 407 is always
			  ** a terminal error
			  */;
		} 
		if ((httpcode != 401) && (httpcode != 407)) {
			return 1/*
			  ** All we have left to deal with is 401 and 407
			  */;
		} 
		do {
		} while (0/*
		  ** Examine the current authentication state to see if this
		  ** is an error.  The idea is for this function to get
		  ** called after processing all the headers in a response
		  ** message.  So, if we've been to asked to authenticate a
		  ** particular stage, and we've done it, we're OK.  But, if
		  ** we're already completely authenticated, it's not OK to
		  ** get another 401 or 407.
		  **
		  ** It is possible for authentication to go stale such that
		  ** the client needs to reauthenticate.  Once that info is
		  ** available, use it here.
		  */);
		if ((httpcode == 401) && !conn.getBits().getUser_passwd()) {
			return 1;
		} 
		if ((httpcode == 407) && !conn.getBits().getProxy_user_passwd()) {
			return 1;
		} 
		return data.getState().getAuthproblem();
	}
	public static Object readmoredata(Object buffer, Object size, Object nitems, Object userp) {
		connectdata conn = (connectdata)userp;
		HTTP http = conn.getData().getReq().getProtop();
		size_t fullsize = size * nitems;
		if (!http.getPostsize()) {
			return /* nothing to return */0;
		} 
		conn.getData().getReq().setForbidchunk((http.getSending() == .HTTPSEND_REQUEST) ? 1 : /* make sure that a HTTP request is never sent away chunked! */0);
		if (http.getPostsize() <= (curl_off_t)fullsize) {
			.memcpy(buffer, http.getPostdata(), (size_t)http.getPostsize());
			fullsize = (size_t)http.getPostsize();
			if (http.getBackup().getPostsize()) {
				http.setPostdata(http.getBackup().getPostdata());
				http.setPostsize(http.getBackup().getPostsize());
				conn.getData().getState().setFread_func(http.getBackup().getFread_func());
				conn.getData().getState().setIn(http.getBackup().getFread_in());
				http.getSending()++;
				http.getBackup().setPostsize(0);
			} else {
					http.setPostsize(0);
			} 
			return fullsize;
		} 
		.memcpy(buffer, http.getPostdata(), fullsize);
		http.getPostdata() += fullsize;
		http.getPostsize() -= fullsize;
		return fullsize/* ------------------------------------------------------------------------- *//* add_buffer functions */;
	}
	/*
	 * Curl_add_buffer_init() sets up and returns a fine buffer struct
	 */
	public static Object Curl_add_buffer_init() {
		return .Curl_ccalloc(1, /*
		 * Curl_add_buffer_free() frees all associated resources.
		 */);
	}
	public static void Curl_add_buffer_free(Object inp) {
		Curl_send_buffer in = new Curl_send_buffer();
		if (!inp) {
			return ;
		} 
		in = inp;
		if (/* deal with NULL input */in) {
			.Curl_cfree(in.getBuffer());
			.Curl_cfree(in);
		} 
		inp = ((Object)0/*
		 * Curl_add_buffer_send() sends a header buffer and frees all associated
		 * memory.  Body data may be appended to the header data if desired.
		 *
		 * Returns CURLcode
		 */);
	}
	public static  Curl_add_buffer_send(Object inp, Object conn, Object bytes_written, Object included_body_bytes, int socketindex) {
		/* how much of the buffer contains body data */ssize_t amount = new ssize_t();
		CURLcode result = new CURLcode();
		byte ptr;
		size_t size = new size_t();
		Curl_easy data = conn.getData();
		HTTP http = data.getReq().getProtop();
		size_t sendsize = new size_t();
		curl_socket_t sockfd = new curl_socket_t();
		size_t headersize = new size_t();
		Curl_send_buffer in = inp;
		do {
		} while (0);
		sockfd = conn.getSock()[socketindex/* The looping below is required since we use non-blocking sockets, but due
		     to the circumstances we will just loop and try again and again etc */];
		ptr = in.getBuffer();
		size = in.getSize_used();
		headersize = size - /* the initial part that isn't body
		                                              is header */included_body_bytes;
		do {
		} while (0);
		result = ();
		if (/* Curl_convert_to_network calls failf if unsuccessful */result) {
			ModernizedCProgram.Curl_add_buffer_free(/* conversion failed, free memory and return to the caller */inp);
			return result;
		} 
		if ((conn.getHandler().getFlags() & (1 << 0) || conn.getHttp_proxy().getProxytype() == .CURLPROXY_HTTPS) && conn.getHttpversion() != 20/* We never send more than CURL_MAX_WRITE_SIZE bytes in one single chunk
		       when we speak HTTPS, as if only a fraction of it is sent now, this data
		       needs to fit into the normal read-callback buffer later on and that
		       buffer is using this size.
		    */) {
			sendsize = ((size) < (true) ? (size) : (true/* OpenSSL is very picky and we must send the SAME buffer pointer to the
			       library when we attempt to re-send this buffer. Sending the same data
			       is not enough, we must use the exact same address. For this reason, we
			       must copy the data to the uploadbuffer first, since that is the buffer
			       we will be using if this send is retried later.
			    */));
			result = ModernizedCProgram.Curl_get_upload_buffer(data);
			if (result) {
				ModernizedCProgram.Curl_add_buffer_free(/* malloc failed, free memory and return to the caller */in);
				return result;
			} 
			.memcpy(data.getState().getUlbuf(), ptr, sendsize);
			ptr = data.getState().getUlbuf();
		} else {
				sendsize = size;
		} 
		result = ModernizedCProgram.Curl_write(conn, sockfd, ptr, sendsize, amount);
		if (!result/*
		     * Note that we may not send the entire chunk at once, and we have a set
		     * number of data bytes at the end of the big buffer (out of which we may
		     * only send away a part).
		     */) {
			size_t headlen = (size_t)amount > headersize ? headersize : (size_t)/* how much of the header that was sent */amount;
			size_t bodylen = amount - headlen;
			if (data.getSet().getVerbose()) {
				ModernizedCProgram.Curl_debug(data, .CURLINFO_HEADER_OUT, ptr, /* this data _may_ contain binary stuff */headlen);
				if (bodylen/* there was body data sent beyond the initial header part, pass that
				           on to the debug callback too */) {
					ModernizedCProgram.Curl_debug(data, .CURLINFO_DATA_OUT, ptr + headlen, bodylen);
				} 
			} 
			bytes_written += (long)/* 'amount' can never be a very large value here so typecasting it so a
			       signed 31 bit value should not cause problems even if ssize_t is
			       64bit */amount;
			if (http/* if we sent a piece of the body here, up the byte counter for it
			         accordingly */) {
				data.getReq().getWritebytecount() += bodylen;
				ModernizedCProgram.Curl_pgrsSetUploadCounter(data, data.getReq().getWritebytecount());
				if ((size_t)amount != size/* The whole request could not be sent in one system call. We must
				           queue it up and send it later when we get the chance. We must not
				           loop here and wait until it might work again. */) {
					size -= amount;
					ptr = in.getBuffer() + amount;
					http.getBackup().setFread_func(data.getState().getFread_func());
					http.getBackup().setFread_in(data.getState().getIn());
					http.getBackup().setPostdata(http.getPostdata());
					http.getBackup().setPostsize(http.getPostsize());
					data.getState().setFread_func((curl_read_callback)/* set the new pointers for the request-sending */readmoredata);
					data.getState().setIn((Object)conn);
					http.setPostdata(ptr);
					http.setPostsize((curl_off_t)size);
					http.setSend_buffer(in);
					http.setSending(.HTTPSEND_REQUEST);
					return .CURLE_OK;
				} 
				http.setSending(.HTTPSEND_BODY/* the full buffer was sent, clean up and return */);
			} else {
					if ((size_t)amount != size/* We have no continue-send mechanism now, fail. This can only happen
					           when this function is used from the CONNECT sending function. We
					           currently (stupidly) assume that the whole request is always sent
					           away in the first single chunk.
					
					           This needs FIXing.
					        */) {
						return .CURLE_SEND_ERROR;
					} 
			} 
		} 
		ModernizedCProgram.Curl_add_buffer_free(in);
		return result;
	}
	/*
	 * add_bufferf() add the formatted input to the buffer.
	 */
	public static  Curl_add_bufferf(Object inp, Object fmt) {
		byte s;
		va_list ap = new va_list();
		Curl_send_buffer in = inp;
		.__builtin_va_start(ap, fmt);
		s = ModernizedCProgram.curl_mvaprintf(fmt, /* this allocs a new string to append */ap);
		.__builtin_va_end(ap);
		if (s) {
			CURLcode result = ModernizedCProgram.Curl_add_buffer(inp, s, .strlen(s));
			.Curl_cfree(s);
			return result;
		} 
		.Curl_cfree(in.getBuffer());
		.Curl_cfree(in);
		inp = ((Object)0);
		return .CURLE_OUT_OF_MEMORY/*
		 * Curl_add_buffer() appends a memory chunk to the existing buffer
		 */;
	}
	public static  Curl_add_buffer(Object inp, Object inptr, Object size) {
		byte new_rb;
		Curl_send_buffer in = inp;
		if (~size < in.getSize_used()) {
			do {
				.Curl_cfree((in.getBuffer()));
				(in.getBuffer()) = ((Object)0);
			} while (0);
			.Curl_cfree(in);
			inp = ((Object)0);
			return .CURLE_OUT_OF_MEMORY;
		} 
		if (!in.getBuffer() || ((in.getSize_used() + size) > (in.getSize_max() - 1/* If current buffer size isn't enough to hold the result, use a
		       buffer size that doubles the required size. If this new size
		       would wrap size_t, then just use the largest possible one */))) {
			size_t new_size = new size_t();
			if ((size > (size_t)-1 / 2) || (in.getSize_used() > (size_t)-1 / 2) || (~(size * 2) < (in.getSize_used() * 2))) {
				new_size = (size_t)-1;
			} else {
					new_size = (in.getSize_used() + size) * 2;
			} 
			if (in.getBuffer()) {
				new_rb = ModernizedCProgram.Curl_saferealloc(in.getBuffer(), /* we have a buffer, enlarge the existing one */new_size);
			} else {
					new_rb = .Curl_cmalloc(/* create a new buffer */new_size);
			} 
			if (!new_rb) {
				.Curl_cfree(/* If we failed, we cleanup the whole buffer and return error */in);
				inp = ((Object)0);
				return .CURLE_OUT_OF_MEMORY;
			} 
			in.setBuffer(new_rb);
			in.setSize_max(new_size);
		} 
		.memcpy(in.getBuffer()[in.getSize_used()], inptr, size);
		in.getSize_used() += size;
		return .CURLE_OK/* end of the add_buffer functions *//* ------------------------------------------------------------------------- */;
	}
	/*
	 * Curl_compareheader()
	 *
	 * Returns TRUE if 'headerline' contains the 'header' with given 'content'.
	 * Pass headers WITH the colon.
	 */
	/* line to check */
	public static  Curl_compareheader(Object headerline, Object header, Object content) {
		size_t hlen = .strlen(header);
		size_t clen = new size_t();
		size_t len = new size_t();
		byte start;
		byte end;
		if (!ModernizedCProgram.Curl_strncasecompare(headerline, header, hlen)) {
			return /* doesn't start with header */0;
		} 
		start = headerline[/* pass the header */hlen];
		while (start && (ModernizedCProgram.Curl_isspace((int)((byte)/* pass all white spaces */start)))) {
			start++;
		}
		end = .strchr(start, /* find the end of the header line *//* lines end with CRLF */(byte)'\r');
		if (!end) {
			end = .strchr(start, /* in case there's a non-standard compliant line here */(byte)'\n');
			if (!end) {
				end = .strchr(start, /* hm, there's no line ending here, use the zero byte! */(byte)'\0');
			} 
		} 
		len = end - /* length of the content part of the input line */start;
		clen = .strlen(/* length of the word to find */content);
		for (; len >= clen; ) {
			if (ModernizedCProgram.Curl_strncasecompare(start, content, clen)) {
				return /* match! */1;
			} 
		}
		return /* no match */0/*
		 * Curl_http_connect() performs HTTP stuff to do at connect-time, called from
		 * the generic Curl_connect().
		 */;
	}
	/* header keyword _with_ colon */
	/* content string to find */
	/* RFC2616, section 4.2 says: "Each header field consists of a name followed
	   * by a colon (":") and the field value. Field names are case-insensitive.
	   * The field value MAY be preceded by any amount of LWS, though a single SP
	   * is preferred." */
	public static  Curl_http_connect(Object conn, Object done) {
		CURLcode result = new CURLcode();
		ModernizedCProgram.Curl_conncontrol(conn, /* We default to persistent connections. We set this already in this connect
		     function to make the re-use checks properly be able to check this bit. */0);
		result = ModernizedCProgram.Curl_proxy_connect(conn, /* the CONNECT procedure might not have been completed */0);
		if (result) {
			return result;
		} 
		if (conn.getBits().getProxy_connect_closed()) {
			return /* this is not an error, just part of the connection negotiation */.CURLE_OK;
		} 
		if ((conn.getHttp_proxy().getProxytype() == .CURLPROXY_HTTPS && !conn.getBits().getProxy_ssl_connected()[0])) {
			return /* wait for HTTPS proxy SSL initialization to complete */.CURLE_OK;
		} 
		if (ModernizedCProgram.Curl_connect_ongoing(conn)) {
			return /* nothing else to do except wait right now - we're not done here. */.CURLE_OK;
		} 
		if (conn.getData().getSet().getHaproxyprotocol()) {
			result = ModernizedCProgram.add_haproxy_protocol_header(/* add HAProxy PROXY protocol header */conn);
			if (result) {
				return result;
			} 
		} 
		if (conn.getGiven().getProtocol() & (1 << 1)) {
			result = /* perform SSL initialization */.CURLE_COULDNT_CONNECT;
			if (result) {
				return result;
			} 
		} else {
				done = 1;
		} 
		return .CURLE_OK/* this returns the socket to wait for in the DO and DOING state for the multi
		   interface and then we're always _sending_ a request and thus we wait for
		   the single socket to become writable only */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* for the week day and month names */
	/* The last 3 #include files should be in this order */
	/*
	 * Forward declarations.
	 */
	public static int http_getsock_do(Object conn, Object socks) {
		socks[0] = conn.getSock()[/* write mode */0];
		return (1 << (16 + (false)));
	}
	public static  add_haproxy_protocol_header(Object conn) {
		byte[] proxy_header = new byte[128];
		Curl_send_buffer req_buffer = new Curl_send_buffer();
		CURLcode result = new CURLcode();
		byte[] tcp_version = new byte[5];
		if (conn.getBits().getIpv6()) {
			.strcpy(tcp_version, "TCP6");
		} else {
				.strcpy(tcp_version, "TCP4");
		} 
		ModernizedCProgram.curl_msnprintf(proxy_header, , "PROXY %s %s %s %li %li\r\n", tcp_version, conn.getData().getInfo().getConn_local_ip(), conn.getData().getInfo().getConn_primary_ip(), conn.getData().getInfo().getConn_local_port(), conn.getData().getInfo().getConn_primary_port());
		req_buffer = ModernizedCProgram.Curl_add_buffer_init();
		if (!req_buffer) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		result = ModernizedCProgram.Curl_add_bufferf(req_buffer, proxy_header);
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.Curl_add_buffer_send(req_buffer, conn, conn.getData().getInfo().getRequest_size(), 0, 0);
		return result/* perform SSL initialization for this socket */;
	}
	/* USE_SSL */
	/*
	 * Curl_http_done() gets called after a single HTTP request has been
	 * performed.
	 */
	public static  Curl_http_done(Object conn,  status,  premature) {
		Curl_easy data = conn.getData();
		HTTP http = data.getReq().getProtop();
		data.getState().getAuthhost().setMultipass(/* Clear multipass flag. If authentication isn't done yet, then it will get
		   * a chance to be set back to true when we output the next auth header */0);
		data.getState().getAuthproxy().setMultipass(0);
		ModernizedCProgram.Curl_unencode_cleanup(conn);
		conn.setSeek_func(data.getSet().getSeek_func());
		conn.setSeek_client(data.getSet().getSeek_client());
		if (!http) {
			return .CURLE_OK;
		} 
		if (http.getSend_buffer()) {
			ModernizedCProgram.Curl_add_buffer_free(http.getSend_buffer());
		} 
		;
		ModernizedCProgram.Curl_mime_cleanpart(http.getForm());
		if (status) {
			return status;
		} 
		if (!/* this check is pointless when DONE is called before the
		                      entire operation is complete */premature && !conn.getBits().getRetry() && !data.getSet().getConnect_only() && (data.getReq().getBytecount() + data.getReq().getHeaderbytecount() - data.getReq().getDeductheadercount()) <= 0/* If this connection isn't simply closed to be retried, AND nothing was
		       read from the HTTP server (that counts), this can't be right so we
		       return an error here */) {
			ModernizedCProgram.Curl_failf(data, "Empty reply from server");
			return .CURLE_GOT_NOTHING;
		} 
		return .CURLE_OK/*
		 * Determine if we should use HTTP 1.1 (OR BETTER) for this request. Reasons
		 * to avoid it include:
		 *
		 * - if the user specifically requested HTTP 1.0
		 * - if the server we are connected to only supports 1.0
		 * - if any server previously contacted to handle this request only supports
		 * 1.0.
		 */;
	}
	public static  use_http_1_1plus(Object data, Object conn) {
		if ((data.getState().getHttpversion() == 10) || (conn.getHttpversion() == 10)) {
			return 0;
		} 
		if ((data.getSet().getHttpversion() == .CURL_HTTP_VERSION_1_0) && (conn.getHttpversion() <= 10)) {
			return 0;
		} 
		return ((data.getSet().getHttpversion() == .CURL_HTTP_VERSION_NONE) || (data.getSet().getHttpversion() >= .CURL_HTTP_VERSION_1_1));
	}
	public static Object get_http_string(Object data, Object conn) {
		if (ModernizedCProgram.use_http_1_1plus(data, conn)) {
			return "1.1";
		} 
		return "1.0";
	}
	/* check and possibly add an Expect: header */
	public static  expect100(Object data, Object conn, Object req_buffer) {
		CURLcode result = .CURLE_OK;
		data.getState().setExpect100header(/* default to false unless it is set
		                                          to TRUE below */0);
		if (ModernizedCProgram.use_http_1_1plus(data, conn) && (conn.getHttpversion() < 20/* if not doing HTTP 1.0 or version 2, or disabled explicitly, we add an
		       Expect: 100-continue to the headers which actually speeds up post
		       operations (as there is one packet coming back from the web server) */)) {
			byte ptr = ModernizedCProgram.Curl_checkheaders(conn, "Expect");
			if (ptr) {
				data.getState().setExpect100header(ModernizedCProgram.Curl_compareheader(ptr, "Expect:", "100-continue"));
			} else {
					result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "Expect: 100-continue\r\n");
					if (!result) {
						data.getState().setExpect100header(1);
					} 
			} 
		} 
		return result;
	}
	/* used to compile the provided trailers into one buffer
	   will return an error code if one of the headers is
	   not formatted correctly */
	public static  Curl_http_compile_trailers(Object trailers, Object buffer, Object handle) {
		byte ptr = ((Object)0);
		CURLcode result = .CURLE_OK;
		byte endofline_native = ((Object)0);
		byte endofline_network = ((Object)0);
		if ((handle.getSet().getCrlf())) {
			endofline_native = /* \n will become \r\n later on */"\n";
			endofline_network = "\x0a";
		} else {
				endofline_native = "\r\n";
				endofline_network = "\x0d\x0a";
		} 
		while (trailers) {
			ptr = .strchr(trailers.getData(), /* only add correctly formatted trailers */(byte)':');
			if (ptr && (ptr + 1) == (byte)' ') {
				result = ModernizedCProgram.Curl_add_bufferf(buffer, "%s%s", trailers.getData(), endofline_native);
				if (result) {
					return result;
				} 
			} else {
					ModernizedCProgram.Curl_infof(handle, "Malformatted trailing header ! Skipping trailer.");
			} 
			trailers = trailers.getNext();
		}
		result = ModernizedCProgram.Curl_add_buffer(buffer, endofline_network, .strlen(endofline_network));
		return result;
	}
	public static  Curl_add_custom_headers(Object conn,  is_connect, Object req_buffer) {
		byte ptr;
		curl_slist[] h = new curl_slist();
		curl_slist headers = new curl_slist();
		int numlists = /* by default */1;
		Curl_easy data = conn.getData();
		int i;
		proxy_use proxy;
		if (is_connect) {
			proxy_use.proxy = proxy_use.HEADER_CONNECT;
		} else {
				proxy_use.proxy = conn.getBits().getHttpproxy() && !conn.getBits().getTunnel_proxy() ? proxy_use.HEADER_PROXY : proxy_use.HEADER_SERVER;
		} 
		switch (proxy_use.proxy) {
		case proxy_use.HEADER_SERVER:
				h[0] = data.getSet().getHeaders();
				break;
		case proxy_use.HEADER_CONNECT:
				if (data.getSet().getSep_headers()) {
					h[0] = data.getSet().getProxyheaders();
				} else {
						h[0] = data.getSet().getHeaders();
				} 
				break;
		case proxy_use.HEADER_PROXY:
				h[0] = data.getSet().getHeaders();
				if (data.getSet().getSep_headers()) {
					h[1] = data.getSet().getProxyheaders();
					numlists++;
				} 
				break;
		}
		for (i = 0; i < numlists; /* loop through one or two lists */i++) {
			headers = h[i];
			while (headers) {
				byte semicolonp = ((Object)0);
				ptr = .strchr(headers.getData(), (byte)':');
				if (!ptr) {
					byte optr;
					ptr = .strchr(headers.getData(), /* no colon, semicolon? */(byte)';');
					if (ptr) {
						optr = ptr;
						/* pass the semicolon */ptr++;
						while (ptr && (ModernizedCProgram.Curl_isspace((int)((byte)ptr)))) {
							ptr++;
						}
						if (ptr) {
							optr = ((Object)/* this may be used for something else in the future */0);
						} else {
								if ((--ptr) == (byte)';') {
									semicolonp = .Curl_cstrdup(headers.getData());
									if (!semicolonp) {
										ModernizedCProgram.Curl_add_buffer_free(req_buffer);
										return .CURLE_OUT_OF_MEMORY;
									} 
									semicolonp[ptr - headers.getData()] = /* put a colon where the semicolon is */(byte)':';
									optr = semicolonp[ptr - headers.getData()];
								} 
						} 
						ptr = optr;
					} 
				} 
				if (ptr/* we require a colon for this to be a true header */) {
					/* pass the colon */ptr++;
					while (ptr && (ModernizedCProgram.Curl_isspace((int)((byte)ptr)))) {
						ptr++;
					}
					if (ptr || semicolonp) {
						CURLcode result = /* only send this if the contents was non-blank or done special */.CURLE_OK;
						byte compare = semicolonp ? semicolonp : headers.getData();
						if (conn.getAllocptr().getHost() && ModernizedCProgram.curl_strnequal("Host:", compare, .strlen("Host:"))) {
							;
						}  else if (data.getSet().getHttpreq() == .HTTPREQ_POST_FORM && ModernizedCProgram.curl_strnequal("Content-Type:", compare, .strlen(/* this header (extended by formdata.c) is sent later */"Content-Type:"))) {
							;
						}  else if (data.getSet().getHttpreq() == .HTTPREQ_POST_MIME && ModernizedCProgram.curl_strnequal("Content-Type:", compare, .strlen(/* this header is sent later */"Content-Type:"))) {
							;
						}  else if (conn.getBits().getAuthneg() && ModernizedCProgram.curl_strnequal("Content-Length:", compare, .strlen("Content-Length:"))) {
							;
						}  else if (conn.getAllocptr().getTe() && ModernizedCProgram.curl_strnequal("Connection:", compare, .strlen("Connection:"))) {
							;
						}  else if ((conn.getHttpversion() >= 20) && ModernizedCProgram.curl_strnequal("Transfer-Encoding:", compare, .strlen("Transfer-Encoding:"/* HTTP/2 doesn't support chunked requests */))) {
							;
						}  else if ((ModernizedCProgram.curl_strnequal("Authorization:", compare, .strlen("Authorization:")) || ModernizedCProgram.curl_strnequal("Cookie:", compare, .strlen("Cookie:"/* be careful of sending this potentially sensitive header to
						                     other hosts */))) && (data.getState().getThis_is_a_follow() && data.getState().getFirst_host() && !data.getSet().getAllow_auth_to_other_hosts() && !ModernizedCProgram.Curl_strcasecompare(data.getState().getFirst_host(), conn.getHost().getName()))) {
							;
						} else {
								result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "%s\r\n", compare);
						} 
						if (semicolonp) {
							.Curl_cfree(semicolonp);
						} 
						if (result) {
							return result;
						} 
					} 
				} 
				headers = headers.getNext();
			}
		}
		return .CURLE_OK;
	}
	public static  Curl_add_timecondition(Object conn, Object req_buffer) {
		Curl_easy data = conn.getData();
		tm tm = new tm();
		tm keeptime = new tm();
		CURLcode result = new CURLcode();
		byte[] datestr = new byte[80];
		byte condp;
		if (data.getSet().getTimecondition() == .CURL_TIMECOND_NONE) {
			return /* no condition was asked for */.CURLE_OK;
		} 
		result = ModernizedCProgram.Curl_gmtime(data.getSet().getTimevalue(), keeptime);
		if (result) {
			ModernizedCProgram.Curl_failf(data, "Invalid TIMEVALUE");
			return result;
		} 
		tm = keeptime;
		switch (data.getSet().getTimecondition()) {
		case .CURL_TIMECOND_IFMODSINCE:
				condp = "If-Modified-Since";
				break;
		case .CURL_TIMECOND_IFUNMODSINCE:
				condp = "If-Unmodified-Since";
				break;
		case .CURL_TIMECOND_LASTMOD:
				condp = "Last-Modified";
				break;
		default:
				return .CURLE_BAD_FUNCTION_ARGUMENT;
		}
		if (ModernizedCProgram.Curl_checkheaders(conn, condp)) {
			return /* A custom header was specified; it will be sent instead. */.CURLE_OK/* The If-Modified-Since header family should have their times set in
			   * GMT as RFC2616 defines: "All HTTP date/time stamps MUST be
			   * represented in Greenwich Mean Time (GMT), without exception. For the
			   * purposes of HTTP, GMT is exactly equal to UTC (Coordinated Universal
			   * Time)." (see page 20 of RFC2616).
			   */;
		} 
		ModernizedCProgram.curl_msnprintf(datestr, , "%s: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n", condp, ModernizedCProgram.Curl_wkday[tm.getTm_wday() ? tm.getTm_wday() - 1 : 6], tm.getTm_mday(), ModernizedCProgram.Curl_month[tm.getTm_mon()], tm.getTm_year() + 1900, tm.getTm_hour(), tm.getTm_min(), tm.getTm_sec());
		result = ModernizedCProgram.Curl_add_buffer(req_buffer, datestr, .strlen(datestr));
		return result/* disabled */;
	}
	/*
	 * Curl_http() gets called from the generic multi_do() function when a HTTP
	 * request is to be performed. This creates and sends a properly constructed
	 * HTTP request.
	 */
	public static  Curl_http(Object conn, Object done) {
		Curl_easy data = conn.getData();
		CURLcode result = .CURLE_OK;
		HTTP http = new HTTP();
		byte path = data.getState().getUp().getPath();
		byte query = data.getState().getUp().getQuery();
		bool paste_ftp_userpwd = 0;
		byte[] ftp_typecode = "";
		byte host = conn.getHost().getName();
		byte te = /* transfer-encoding */"";
		byte ptr;
		byte request;
		Curl_HttpReq httpreq = data.getSet().getHttpreq();
		byte addcookies = ((Object)0);
		curl_off_t included_body = 0;
		byte httpstring;
		Curl_send_buffer req_buffer = new Curl_send_buffer();
		curl_off_t postsize = /* curl_off_t to handle large file sizes */0;
		byte altused = ((Object)0/* Always consider the DO phase done after this function call, even if there
		     may be parts of the request that is not yet sent, since we can deal with
		     the rest of the request in the PERFORM phase. */);
		done = 1;
		if (conn.getTransport() != .TRNSPRT_QUIC) {
			if (conn.getHttpversion() < /* unless the connection is re-used and
			                                    already http2 */20) {
				switch (conn.getNegnpn()) {
				case .CURL_HTTP_VERSION_1_1/* continue with HTTP/1.1 when explicitly requested */:
						break;
				case .CURL_HTTP_VERSION_2_0:
						conn.setHttpversion(/* we know we're on HTTP/2 now */20);
						result = .CURLE_UNSUPPORTED_PROTOCOL;
						if (result) {
							return result;
						} 
						break;
				default:
						break;
				}
			} else {
					result = /* prepare for a http2 request */.CURLE_UNSUPPORTED_PROTOCOL;
					if (result) {
						return result;
					} 
			} 
		} 
		http = data.getReq().getProtop();
		do {
		} while (0);
		if (!data.getState().getThis_is_a_follow()) {
			.Curl_cfree(data.getState().getFirst_host());
			data.getState().setFirst_host(.Curl_cstrdup(conn.getHost().getName()));
			if (!data.getState().getFirst_host()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			data.getState().setFirst_remote_port(conn.getRemote_port());
		} 
		if ((conn.getHandler().getProtocol() & (((1 << 0) | (1 << 1)) | (1 << 2))) && data.getSet().getUpload()) {
			httpreq = .HTTPREQ_PUT;
		} 
		if (data.getSet().getStr()[/* Now set the 'request' pointer to the proper request string */dupstring.STRING_CUSTOMREQUEST]) {
			request = data.getSet().getStr()[dupstring.STRING_CUSTOMREQUEST];
		} else {
				if (data.getSet().getOpt_no_body()) {
					request = "HEAD";
				} else {
						do {
						} while (0);
						switch (httpreq) {
						case .HTTPREQ_POST:
						case .HTTPREQ_POST_FORM:
						case .HTTPREQ_GET:
								request = "GET";
								break;
						case .HTTPREQ_HEAD:
								request = "HEAD";
								break;
						case .HTTPREQ_PUT:
								request = "PUT";
								break;
						case .HTTPREQ_OPTIONS:
								request = "OPTIONS";
								break;
						case .HTTPREQ_POST_MIME:
								request = "POST";
								break;
						default:
						}
				} 
		} 
		if (ModernizedCProgram.Curl_checkheaders(conn, /* The User-Agent string might have been allocated in url.c already, because
		     it might have been used in the proxy connect, but if we have got a header
		     with the user-agent string specified, we erase the previously made string
		     here. */"User-Agent")) {
			.Curl_cfree(conn.getAllocptr().getUagent());
			conn.getAllocptr().setUagent(((Object)0));
		} 
		{ 
			byte pq = ((Object)/* setup the authentication headers */0);
			if (query && query) {
				pq = ModernizedCProgram.curl_maprintf("%s?%s", path, query);
				if (!pq) {
					return .CURLE_OUT_OF_MEMORY;
				} 
			} 
			result = ModernizedCProgram.Curl_http_output_auth(conn, request, (pq ? pq : path), 0);
			.Curl_cfree(pq);
			if (result) {
				return result;
			} 
		}
		if (((data.getState().getAuthhost().getMultipass() && !data.getState().getAuthhost().getDone()) || (data.getState().getAuthproxy().getMultipass() && !data.getState().getAuthproxy().getDone())) && (httpreq != .HTTPREQ_GET) && (httpreq != .HTTPREQ_HEAD/* Auth is required and we are not authenticated yet. Make a PUT or POST
		       with content-length zero as a "probe". */)) {
			conn.getBits().setAuthneg(1);
		} else {
				conn.getBits().setAuthneg(0);
		} 
		do {
			.Curl_cfree((conn.getAllocptr().getRef()));
			(conn.getAllocptr().getRef()) = ((Object)0);
		} while (0);
		if (data.getChange().getReferer() && !ModernizedCProgram.Curl_checkheaders(conn, "Referer")) {
			conn.getAllocptr().setRef(ModernizedCProgram.curl_maprintf("Referer: %s\r\n", data.getChange().getReferer()));
			if (!conn.getAllocptr().getRef()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} else {
				conn.getAllocptr().setRef(((Object)0));
		} 
		if (data.getSet().getStr()[dupstring.STRING_COOKIE] && !ModernizedCProgram.Curl_checkheaders(conn, "Cookie")) {
			addcookies = data.getSet().getStr()[dupstring.STRING_COOKIE];
		} 
		if (!ModernizedCProgram.Curl_checkheaders(conn, "Accept-Encoding") && data.getSet().getStr()[dupstring.STRING_ENCODING]) {
			do {
				.Curl_cfree((conn.getAllocptr().getAccept_encoding()));
				(conn.getAllocptr().getAccept_encoding()) = ((Object)0);
			} while (0);
			conn.getAllocptr().setAccept_encoding(ModernizedCProgram.curl_maprintf("Accept-Encoding: %s\r\n", data.getSet().getStr()[dupstring.STRING_ENCODING]));
			if (!conn.getAllocptr().getAccept_encoding()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} else {
				do {
					.Curl_cfree((conn.getAllocptr().getAccept_encoding()));
					(conn.getAllocptr().getAccept_encoding()) = ((Object)0);
				} while (0);
				conn.getAllocptr().setAccept_encoding(((Object)0/* we only consider transfer-encoding magic if libz support is built-in *//* When we are to insert a TE: header in the request, we must also insert
				       TE in a Connection: header, so we need to merge the custom provided
				       Connection: header and prevent the original to get sent. Note that if
				       the user has inserted his/hers own TE: header we don't do this magic
				       but then assume that the user will handle it all! */));
		} 
		switch (/* Create the (updated) Connection: header */httpreq) {
		case .HTTPREQ_POST_FORM:
				ModernizedCProgram.Curl_mime_cleanpart(http.getForm());
				result = ModernizedCProgram.Curl_getformdata(data, http.getForm(), data.getSet().getHttppost(), data.getState().getFread_func());
				if (result) {
					return result;
				} 
				http.setSendit(http.getForm());
				break;
		case .HTTPREQ_POST_MIME:
				http.setSendit(data.getSet().getMimepost());
				break;
		default:
				http.setSendit(((Object)0));
		}
		if (http.getSendit()) {
			byte cthdr = ModernizedCProgram.Curl_checkheaders(conn, "Content-Type");
			http.getSendit().getFlags() |=  (1 << /* Read and seek body only. */1);
			if (/* Prepare the mime structure headers & set content type. */cthdr) {
				for (cthdr += 13; cthdr == (byte)' '; cthdr++) {
					;
				}
			}  else if (http.getSendit().getKind() == mimekind.MIMEKIND_MULTIPART) {
				cthdr = "multipart/form-data";
			} 
			ModernizedCProgram.curl_mime_headers(http.getSendit(), data.getSet().getHeaders(), 0);
			result = ModernizedCProgram.Curl_mime_prepare_headers(http.getSendit(), cthdr, ((Object)0), mimestrategy.MIMESTRATEGY_FORM);
			ModernizedCProgram.curl_mime_headers(http.getSendit(), ((Object)0), 0);
			if (!result) {
				result = ModernizedCProgram.Curl_mime_rewind(http.getSendit());
			} 
			if (result) {
				return result;
			} 
			http.setPostsize(ModernizedCProgram.Curl_mime_size(http.getSendit()));
		} 
		ptr = ModernizedCProgram.Curl_checkheaders(conn, "Transfer-Encoding");
		if (ptr) {
			data.getReq().setUpload_chunky(ModernizedCProgram.Curl_compareheader(ptr, "Transfer-Encoding:", "chunked"));
		} else {
				if ((conn.getHandler().getProtocol() & ((1 << 0) | (1 << 1))) && (((httpreq == .HTTPREQ_POST_MIME || httpreq == .HTTPREQ_POST_FORM) && http.getPostsize() < 0) || ((data.getSet().getUpload() || httpreq == .HTTPREQ_POST) && data.getState().getInfilesize() == -1))) {
					if (conn.getBits().getAuthneg()) {
						;
					}  else if (ModernizedCProgram.use_http_1_1plus(data, conn)) {
						if (conn.getHttpversion() < 20) {
							data.getReq().setUpload_chunky(/* HTTP, upload, unknown file size and not HTTP 1.0 */1);
						} 
					} else {
							ModernizedCProgram.Curl_failf(data, "Chunky upload is not supported by HTTP 1.0");
							return .CURLE_UPLOAD_FAILED;
					} 
				} else {
						data.getReq().setUpload_chunky(/* else, no chunky upload */0);
				} 
				if (data.getReq().getUpload_chunky()) {
					te = "Transfer-Encoding: chunked\r\n";
				} 
		} 
		do {
			.Curl_cfree((conn.getAllocptr().getHost()));
			(conn.getAllocptr().getHost()) = ((Object)0);
		} while (0);
		ptr = ModernizedCProgram.Curl_checkheaders(conn, "Host");
		if (ptr && (!data.getState().getThis_is_a_follow() || ModernizedCProgram.Curl_strcasecompare(data.getState().getFirst_host(), conn.getHost().getName()))) {
			byte cookiehost = ModernizedCProgram.Curl_copy_header_value(ptr);
			if (!cookiehost) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			if (!cookiehost) {
				.Curl_cfree(/* ignore empty data */cookiehost);
			} else {
					if (cookiehost == /* If the host begins with '[', we start searching for the port after
					         the bracket has been closed */(byte)'[') {
						byte closingbracket;
						.memmove(cookiehost, cookiehost + 1, .strlen(cookiehost) - 1);
						closingbracket = .strchr(cookiehost, (byte)']');
						if (closingbracket) {
							closingbracket = 0;
						} 
					} else {
							int startsearch = 0;
							byte colon = .strchr(cookiehost + startsearch, (byte)':');
							if (colon) {
								colon = /* The host must not include an embedded port number */0;
							} 
					} 
					do {
						.Curl_cfree((conn.getAllocptr().getCookiehost()));
						(conn.getAllocptr().getCookiehost()) = ((Object)0);
					} while (0);
					conn.getAllocptr().setCookiehost(cookiehost);
			} 
			if (.strcmp("Host:", ptr)) {
				conn.getAllocptr().setHost(ModernizedCProgram.curl_maprintf("Host:%s\r\n", ptr[5]));
				if (!conn.getAllocptr().getHost()) {
					return .CURLE_OUT_OF_MEMORY;
				} 
			} else {
					conn.getAllocptr().setHost(((Object)/* when clearing the header */0));
			} 
		} else {
				if (((conn.getGiven().getProtocol() & (1 << /* When building Host: headers, we must put the host name within
				       [brackets] if the host name is a plain IPv6-address. RFC2732-style. */1)) && (conn.getRemote_port() == 443)) || ((conn.getGiven().getProtocol() & (1 << 0)) && (conn.getRemote_port() == 80/* if(HTTPS on port 443) OR (HTTP on port 80) then don't include
				         the port number in the host string */))) {
					conn.getAllocptr().setHost(ModernizedCProgram.curl_maprintf("Host: %s%s%s\r\n", conn.getBits().getIpv6_ip() ? "[" : "", host, conn.getBits().getIpv6_ip() ? "]" : ""));
				} else {
						conn.getAllocptr().setHost(ModernizedCProgram.curl_maprintf("Host: %s%s%s:%d\r\n", conn.getBits().getIpv6_ip() ? "[" : "", host, conn.getBits().getIpv6_ip() ? "]" : "", conn.getRemote_port()));
				} 
				if (!conn.getAllocptr().getHost()) {
					return /* without Host: we can't make a nice request */.CURLE_OUT_OF_MEMORY;
				} 
		} 
		if (conn.getBits().getHttpproxy() && !conn.getBits().getTunnel_proxy()) {
			CURLUcode uc = new CURLUcode();
			CURLU h = ModernizedCProgram.curl_url_dup(data.getState().getUh());
			if (!h) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			if (conn.getHost().getDispname() != conn.getHost().getName()) {
				uc = ModernizedCProgram.curl_url_set(h, .CURLUPART_HOST, conn.getHost().getName(), 0);
				if (uc) {
					ModernizedCProgram.curl_url_cleanup(h);
					return .CURLE_OUT_OF_MEMORY;
				} 
			} 
			uc = ModernizedCProgram.curl_url_set(h, .CURLUPART_FRAGMENT, ((Object)0), 0);
			if (uc) {
				ModernizedCProgram.curl_url_cleanup(h);
				return .CURLE_OUT_OF_MEMORY;
			} 
			if (ModernizedCProgram.Curl_strcasecompare("http", data.getState().getUp().getScheme())) {
				uc = ModernizedCProgram.curl_url_set(h, .CURLUPART_USER, ((Object)0), /* when getting HTTP, we don't want the userinfo the URL */0);
				if (uc) {
					ModernizedCProgram.curl_url_cleanup(h);
					return .CURLE_OUT_OF_MEMORY;
				} 
				uc = ModernizedCProgram.curl_url_set(h, .CURLUPART_PASSWORD, ((Object)0), 0);
				if (uc) {
					ModernizedCProgram.curl_url_cleanup(h);
					return .CURLE_OUT_OF_MEMORY;
				} 
			} 
			uc = ModernizedCProgram.curl_url_get(h, .CURLUPART_URL, data.getSet().getStr()[dupstring.STRING_TEMP_URL], /* Extract the the URL to use in the request. Store in STRING_TEMP_URL for
			       clean-up reasons if the function returns before the free() further
			       down. */0);
			if (uc) {
				ModernizedCProgram.curl_url_cleanup(h);
				return .CURLE_OUT_OF_MEMORY;
			} 
			ModernizedCProgram.curl_url_cleanup(h);
			if (ModernizedCProgram.Curl_strcasecompare("ftp", data.getState().getUp().getScheme())) {
				if (data.getSet().getProxy_transfer_mode()) {
					byte type = .strstr(path, /* when doing ftp, append ;type=<a|i> if not present */";type=");
					if (type && type[6] && type[7] == 0) {
						switch (ModernizedCProgram.Curl_raw_toupper(type[6])) {
						case (byte)'A':
						case (byte)'D':
						case (byte)'I':
								break;
						default:
								type = ((Object)0);
						}
					} 
					if (!type) {
						byte p = ftp_typecode/* avoid sending invalid URLs like ftp://example.com;type=i if the
						           * user specified ftp://example.com without the slash */;
						if (!data.getState().getUp().getPath() && path[.strlen(path) - 1] != (byte)'/') {
							p++ = (byte)'/';
						} 
						ModernizedCProgram.curl_msnprintf(p,  - 1, ";type=%c", data.getSet().getPrefer_ascii() ? (byte)'a' : (byte)'i');
					} 
				} 
				if (conn.getBits().getUser_passwd() && !conn.getBits().getUserpwd_in_url()) {
					paste_ftp_userpwd = 1;
				} 
			} 
		} 
		http.setP_accept(ModernizedCProgram.Curl_checkheaders(conn, "Accept") ? ((Object)0) : /* CURL_DISABLE_PROXY */"Accept: */*\r\n");
		if ((.HTTPREQ_POST == httpreq || .HTTPREQ_PUT == httpreq) && data.getState().getResume_from()) {
			if (data.getState().getResume_from() < 0/*
			       * This is meant to get the size of the present remote-file by itself.
			       * We don't support this now. Bail out!
			       */) {
				data.getState().setResume_from(0);
			} 
			if (data.getState().getResume_from() && !data.getState().getThis_is_a_follow()) {
				int seekerr = /* Now, let's read off the proper amount of bytes from the
				         input. */2;
				if (conn.getSeek_func()) {
					ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
					seekerr = .UNRECOGNIZEDFUNCTIONNAME(conn.getSeek_client(), data.getState().getResume_from(), 0);
					ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
				} 
				if (seekerr != 0) {
					curl_off_t passed = 0;
					if (seekerr != 2) {
						ModernizedCProgram.Curl_failf(data, "Could not seek stream");
						return .CURLE_READ_ERROR;
					} 
					do {
						size_t readthisamountnow = (data.getState().getResume_from() - passed > data.getSet().getBuffer_size()) ? (size_t)data.getSet().getBuffer_size() : ModernizedCProgram.curlx_sotouz(data.getState().getResume_from() - passed);
						size_t actuallyread = .UNRECOGNIZEDFUNCTIONNAME(data.getState().getBuffer(), 1, readthisamountnow, data.getState().getIn());
						passed += actuallyread;
						if ((actuallyread == 0) || (actuallyread > readthisamountnow/* this checks for greater-than only to make sure that the
						               CURL_READFUNC_ABORT return code still aborts */)) {
							ModernizedCProgram.Curl_failf(data, "Could only read %I64d bytes from the input", passed);
							return .CURLE_READ_ERROR;
						} 
					} while (passed < data.getState().getResume_from());
				} 
				if (data.getState().getInfilesize() > /* now, decrease the size of the read */0) {
					data.getState().getInfilesize() -= data.getState().getResume_from();
					if (data.getState().getInfilesize() <= 0) {
						ModernizedCProgram.Curl_failf(data, "File already completely uploaded");
						return .CURLE_PARTIAL_FILE;
					} 
				} 
			} 
		} 
		if (data.getState().getUse_range()) {
			if (((httpreq == .HTTPREQ_GET) || (httpreq == .HTTPREQ_HEAD)) && !ModernizedCProgram.Curl_checkheaders(conn, "Range")) {
				.Curl_cfree(conn.getAllocptr().getRangeline());
				conn.getAllocptr().setRangeline(ModernizedCProgram.curl_maprintf("Range: bytes=%s\r\n", data.getState().getRange()));
			}  else if ((httpreq == .HTTPREQ_POST || httpreq == .HTTPREQ_PUT) && !ModernizedCProgram.Curl_checkheaders(conn, "Content-Range")) {
				.Curl_cfree(conn.getAllocptr().getRangeline());
				if (data.getSet().getSet_resume_from() < 0/* Upload resume was asked for, but we don't know the size of the
				           remote part so we tell the server (and act accordingly) that we
				           upload the whole file (again) */) {
					conn.getAllocptr().setRangeline(ModernizedCProgram.curl_maprintf("Content-Range: bytes 0-%I64d/%I64d\r\n", data.getState().getInfilesize() - 1, data.getState().getInfilesize()));
				}  else if (data.getState().getResume_from()) {
					curl_off_t total_expected_size = data.getState().getResume_from() + data.getState().getInfilesize();
					conn.getAllocptr().setRangeline(ModernizedCProgram.curl_maprintf("Content-Range: bytes %s%I64d/%I64d\r\n", data.getState().getRange(), total_expected_size - 1, total_expected_size));
				} else {
						conn.getAllocptr().setRangeline(ModernizedCProgram.curl_maprintf("Content-Range: bytes %s/%I64d\r\n", data.getState().getRange(), data.getState().getInfilesize()));
				} 
				if (!conn.getAllocptr().getRangeline()) {
					return .CURLE_OUT_OF_MEMORY;
				} 
			} 
		} 
		httpstring = ModernizedCProgram.get_http_string(data, conn);
		req_buffer = ModernizedCProgram.Curl_add_buffer_init();
		if (!req_buffer) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "%s ", /* add the main request stuff *//* GET/HEAD/POST/PUT */request);
		if (result) {
			return result;
		} 
		if (data.getSet().getStr()[dupstring.STRING_TARGET]) {
			path = data.getSet().getStr()[dupstring.STRING_TARGET];
			query = ((Object)0);
		} 
		if (conn.getBits().getHttpproxy() && !conn.getBits().getTunnel_proxy()) {
			byte url = data.getSet().getStr()[dupstring.STRING_TEMP_URL];
			result = ModernizedCProgram.Curl_add_buffer(req_buffer, url, .strlen(url));
			do {
				.Curl_cfree((data.getSet().getStr()[dupstring.STRING_TEMP_URL]));
				(data.getSet().getStr()[dupstring.STRING_TEMP_URL]) = ((Object)0);
			} while (0);
		}  else if (paste_ftp_userpwd) {
			result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "ftp://%s:%s@%s", conn.getUser(), conn.getPasswd(), path +  - 1);
		} else {
				result = ModernizedCProgram.Curl_add_buffer(req_buffer, path, .strlen(path));
				if (result) {
					return result;
				} 
				if (query) {
					result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "?%s", query);
				} 
		} 
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.Curl_add_bufferf(req_buffer, /* ftp typecode (;type=x) */"%s HTTP/%s\r\n%s%s%s%s%s%s%s%s%s%s%s%s"/* HTTP version *//* host *//* proxyuserpwd *//* userpwd *//* range *//* user agent *//* accept */, /* TE: *//* accept-encoding *//* referer *//* Proxy-Connection *//* transfer-encoding *//* Alt-Used */ftp_typecode, httpstring, (conn.getAllocptr().getHost() ? conn.getAllocptr().getHost() : ""), conn.getAllocptr().getProxyuserpwd() ? conn.getAllocptr().getProxyuserpwd() : "", conn.getAllocptr().getUserpwd() ? conn.getAllocptr().getUserpwd() : "", (data.getState().getUse_range() && conn.getAllocptr().getRangeline()) ? conn.getAllocptr().getRangeline() : "", (data.getSet().getStr()[dupstring.STRING_USERAGENT] && data.getSet().getStr()[dupstring.STRING_USERAGENT] && conn.getAllocptr().getUagent()) ? conn.getAllocptr().getUagent() : "", http.getP_accept() ? http.getP_accept() : "", conn.getAllocptr().getTe() ? conn.getAllocptr().getTe() : "", (data.getSet().getStr()[dupstring.STRING_ENCODING] && data.getSet().getStr()[dupstring.STRING_ENCODING] && conn.getAllocptr().getAccept_encoding()) ? conn.getAllocptr().getAccept_encoding() : "", (data.getChange().getReferer() && conn.getAllocptr().getRef()) ? conn.getAllocptr().getRef() : /* Referer: <data> */"", (conn.getBits().getHttpproxy() && !conn.getBits().getTunnel_proxy() && !ModernizedCProgram.Curl_checkProxyheaders(conn, "Proxy-Connection")) ? "Proxy-Connection: Keep-Alive\r\n" : "", te, altused ? altused : "");
		do {
			.Curl_cfree((conn.getAllocptr().getUserpwd()));
			(conn.getAllocptr().getUserpwd()) = ((Object)0);
		} while (/* clear userpwd and proxyuserpwd to avoid re-using old credentials
		   * from re-used connections */0);
		do {
			.Curl_cfree((conn.getAllocptr().getProxyuserpwd()));
			(conn.getAllocptr().getProxyuserpwd()) = ((Object)0);
		} while (0);
		.Curl_cfree(altused);
		if (result) {
			return result;
		} 
		if (!(conn.getHandler().getFlags() & (1 << 0)) && conn.getHttpversion() != 20 && (data.getSet().getHttpversion() == .CURL_HTTP_VERSION_2_0/* append HTTP2 upgrade magic stuff to the HTTP request if it isn't done
		       over SSL */)) {
			result = .CURLE_UNSUPPORTED_PROTOCOL;
			if (result) {
				return result;
			} 
		} 
		if (data.getCookies() || addcookies) {
			Cookie co = ((Object)/* no cookies from start */0);
			int count = 0;
			if (data.getCookies() && data.getState().getCookie_engine()) {
				ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_COOKIE, .CURL_LOCK_ACCESS_SINGLE);
				co = ModernizedCProgram.Curl_cookie_getlist(data.getCookies(), conn.getAllocptr().getCookiehost() ? conn.getAllocptr().getCookiehost() : host, data.getState().getUp().getPath(), (conn.getHandler().getProtocol() & (1 << 1)) ? 1 : 0);
				ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_COOKIE);
			} 
			if (co) {
				Cookie store = co;
				while (/* now loop through all cookies that matched */co) {
					if (co.getValue()) {
						if (0 == count) {
							result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "Cookie: ");
							if (result) {
								break;
							} 
						} 
						result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "%s%s=%s", count ? "; " : "", co.getName(), co.getValue());
						if (result) {
							break;
						} 
						count++;
					} 
					co = co.getNext();
				}
				ModernizedCProgram.Curl_cookie_freelist(store);
			} 
			if (addcookies && !result) {
				if (!count) {
					result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "Cookie: ");
				} 
				if (!result) {
					result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "%s%s", count ? "; " : "", addcookies);
					count++;
				} 
			} 
			if (count && !result) {
				result = ModernizedCProgram.Curl_add_buffer(req_buffer, "\r\n", 2);
			} 
			if (result) {
				return result;
			} 
		} 
		result = ModernizedCProgram.Curl_add_timecondition(conn, req_buffer);
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.Curl_add_custom_headers(conn, 0, req_buffer);
		if (result) {
			return result;
		} 
		http.setPostdata(((Object)/* nothing to post at this point */0));
		ModernizedCProgram.Curl_pgrsSetUploadSize(data, -/* upload size is unknown atm */1/* If 'authdone' is FALSE, we must not set the write socket index to the
		     Curl_transfer() call below, as we're not ready to actually upload any
		     data yet. */);
		switch (httpreq) {
		case .HTTPREQ_POST_FORM:
		case .HTTPREQ_POST_MIME:
				if (conn.getBits().getAuthneg()) {
					result = ModernizedCProgram.Curl_add_bufferf(req_buffer, /* nothing to post! */"Content-Length: 0\r\n\r\n");
					if (result) {
						return result;
					} 
					result = ModernizedCProgram.Curl_add_buffer_send(req_buffer, conn, data.getInfo().getRequest_size(), 0, 0);
					if (result) {
						ModernizedCProgram.Curl_failf(data, "Failed sending POST request");
					} else {
							ModernizedCProgram.Curl_setup_transfer(data, 0, -1, 1, -/* setup variables for the upcoming transfer */1);
					} 
					break;
				} 
				data.getState().setInfilesize(postsize = http.getPostsize());
				if (postsize != -1 && !data.getReq().getUpload_chunky() && (conn.getBits().getAuthneg() || !ModernizedCProgram.Curl_checkheaders(conn, "Content-Length"/* we allow replacing this header if not during auth negotiation,
				         although it isn't very wise to actually set your own */))) {
					result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "Content-Length: %I64d\r\n", postsize);
					if (result) {
						return result;
					} 
				} 
				{ 
					curl_slist hdr = new curl_slist();
					for (hdr = http.getSendit().getCurlheaders(); hdr; hdr = hdr.getNext()) {
						result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "%s\r\n", hdr.getData());
						if (result) {
							return result;
						} 
					}
				}
				ptr = ModernizedCProgram.Curl_checkheaders(conn, /* For really small posts we don't use Expect: headers at all, and for
				       the somewhat bigger ones we allow the app to disable it. Just make
				       sure that the expect100header is always set to the preferred value
				       here. */"Expect");
				if (ptr) {
					data.getState().setExpect100header(ModernizedCProgram.Curl_compareheader(ptr, "Expect:", "100-continue"));
				}  else if (postsize > 1024 || postsize < 0) {
					result = ModernizedCProgram.expect100(data, conn, req_buffer);
					if (result) {
						return result;
					} 
				} else {
						data.getState().setExpect100header(0);
				} 
				result = ModernizedCProgram.Curl_add_buffer(req_buffer, "\r\n", /* make the request end in a true CRLF */2);
				if (result) {
					return result;
				} 
				ModernizedCProgram.Curl_pgrsSetUploadSize(data, /* set the upload size to the progress meter */postsize);
				data.getState().setFread_func((curl_read_callback)/* Read from mime structure. */ModernizedCProgram.Curl_mime_read);
				data.getState().setIn((Object)http.getSendit());
				http.setSending(.HTTPSEND_BODY);
				result = ModernizedCProgram.Curl_add_buffer_send(req_buffer, /* this sends the buffer and frees all the buffer resources */conn, data.getInfo().getRequest_size(), 0, 0);
				if (result) {
					ModernizedCProgram.Curl_failf(data, "Failed sending POST request");
				} else {
						ModernizedCProgram.Curl_setup_transfer(data, 0, -1, /* prepare for transfer */1, postsize ? 0 : -1);
				} 
				if (result) {
					return result;
				} 
				break;
		case /* Let's PUT the data to the server! */.HTTPREQ_PUT:
				if (conn.getBits().getAuthneg()) {
					postsize = 0;
				} else {
						postsize = data.getState().getInfilesize();
				} 
				if ((postsize != -1) && !data.getReq().getUpload_chunky() && (conn.getBits().getAuthneg() || !ModernizedCProgram.Curl_checkheaders(conn, "Content-Length"))) {
					result = ModernizedCProgram.Curl_add_bufferf(/* only add Content-Length if not uploading chunked */req_buffer, "Content-Length: %I64d\r\n", postsize);
					if (result) {
						return result;
					} 
				} 
				if (postsize != 0) {
					result = ModernizedCProgram.expect100(data, conn, req_buffer);
					if (result) {
						return result;
					} 
				} 
				result = ModernizedCProgram.Curl_add_buffer(req_buffer, "\r\n", /* end of headers */2);
				if (result) {
					return result;
				} 
				ModernizedCProgram.Curl_pgrsSetUploadSize(data, /* set the upload size to the progress meter */postsize);
				result = ModernizedCProgram.Curl_add_buffer_send(req_buffer, /* this sends the buffer and frees all the buffer resources */conn, data.getInfo().getRequest_size(), 0, 0);
				if (result) {
					ModernizedCProgram.Curl_failf(data, "Failed sending PUT request");
				} else {
						ModernizedCProgram.Curl_setup_transfer(data, 0, -1, /* prepare for transfer */1, postsize ? 0 : -1);
				} 
				if (result) {
					return result;
				} 
				break;
		case .HTTPREQ_POST/* this is the simple POST, using x-www-form-urlencoded style */:
				if (conn.getBits().getAuthneg()) {
					postsize = 0;
				} else {
						postsize = data.getState().getInfilesize();
				} 
				if ((postsize != -1) && !data.getReq().getUpload_chunky() && (conn.getBits().getAuthneg() || !ModernizedCProgram.Curl_checkheaders(conn, "Content-Length"/* we allow replacing this header if not during auth negotiation,
				         although it isn't very wise to actually set your own */))) {
					result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "Content-Length: %I64d\r\n", postsize);
					if (result) {
						return result;
					} 
				} 
				if (!ModernizedCProgram.Curl_checkheaders(conn, "Content-Type")) {
					result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "Content-Type: application/x-www-form-urlencoded\r\n");
					if (result) {
						return result/* For really small posts we don't use Expect: headers at all, and for
						       the somewhat bigger ones we allow the app to disable it. Just make
						       sure that the expect100header is always set to the preferred value
						       here. */;
					} 
				} 
				ptr = ModernizedCProgram.Curl_checkheaders(conn, "Expect");
				if (ptr) {
					data.getState().setExpect100header(ModernizedCProgram.Curl_compareheader(ptr, "Expect:", "100-continue"));
				}  else if (postsize > 1024 || postsize < 0) {
					result = ModernizedCProgram.expect100(data, conn, req_buffer);
					if (result) {
						return result;
					} 
				} else {
						data.getState().setExpect100header(0);
				} 
				if (data.getSet().getPostfields()) {
					if (conn.getHttpversion() != /* In HTTP2, we send request body in DATA frame regardless of
					         its size. */20 && !data.getState().getExpect100header() && (postsize < (64 * 1024/* if we don't use expect: 100  AND
					           postsize is less than MAX_INITIAL_POST_SIZE
					
					           then append the post data to the HTTP request header. This limit
					           is no magic limit but only set to prevent really huge POSTs to
					           get the data duplicated with malloc() and family. */))) {
						result = ModernizedCProgram.Curl_add_buffer(req_buffer, "\r\n", /* end of headers! */2);
						if (result) {
							return result;
						} 
						if (!data.getReq().getUpload_chunky()) {
							result = ModernizedCProgram.Curl_add_buffer(req_buffer, data.getSet().getPostfields(), (size_t)postsize);
							included_body = postsize;
						} else {
								if (postsize) {
									result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "%x\r\n", (int)/* Append the POST data chunky-style */postsize);
									if (!result) {
										result = ModernizedCProgram.Curl_add_buffer(req_buffer, data.getSet().getPostfields(), (size_t)postsize);
										if (!result) {
											result = ModernizedCProgram.Curl_add_buffer(req_buffer, "\r\n", 2);
										} 
										included_body = postsize + 2;
									} 
								} 
								if (!result) {
									result = ModernizedCProgram.Curl_add_buffer(req_buffer, "\x30\x0d\x0a\x0d\x0a", 5);
								} 
								included_body += /* 0  CR  LF  CR  LF */5;
						} 
						if (result) {
							return result;
						} 
						ModernizedCProgram.Curl_pgrsSetUploadSize(data, /* Make sure the progress information is accurate */postsize);
					} else {
							http.setPostsize(/* A huge POST coming up, do data separate from the request */postsize);
							http.setPostdata(data.getSet().getPostfields());
							http.setSending(.HTTPSEND_BODY);
							data.getState().setFread_func((curl_read_callback)readmoredata);
							data.getState().setIn((Object)conn);
							ModernizedCProgram.Curl_pgrsSetUploadSize(data, http.getPostsize());
							result = ModernizedCProgram.Curl_add_buffer(req_buffer, "\r\n", /* end of headers! */2);
							if (result) {
								return result;
							} 
					} 
				} else {
						result = ModernizedCProgram.Curl_add_buffer(req_buffer, "\r\n", /* end of headers! */2);
						if (result) {
							return result;
						} 
						if (data.getReq().getUpload_chunky() && conn.getBits().getAuthneg()) {
							result = ModernizedCProgram.Curl_add_buffer(req_buffer, "\x30\x0d\x0a\x0d\x0a", 5);
							if (/* 0  CR  LF  CR  LF */result) {
								return result;
							} 
						}  else if (data.getState().getInfilesize()) {
							ModernizedCProgram.Curl_pgrsSetUploadSize(data, postsize ? postsize : -/* set the upload size to the progress meter */1/* set the pointer to mark that we will send the post body using the
							           read callback, but only if we're not in authenticate
							           negotiation  */);
							if (!conn.getBits().getAuthneg()) {
								http.setPostdata((byte)http.getPostdata());
								http.setPostsize(postsize);
							} 
						} 
				} 
				result = ModernizedCProgram.Curl_add_buffer_send(req_buffer, conn, data.getInfo().getRequest_size(), (size_t)included_body, 0);
				if (result) {
					ModernizedCProgram.Curl_failf(data, "Failed sending HTTP POST request");
				} else {
						ModernizedCProgram.Curl_setup_transfer(data, 0, -1, 1, http.getPostdata() ? 0 : -1);
				} 
				break;
		default:
				result = ModernizedCProgram.Curl_add_buffer(req_buffer, "\r\n", 2);
				if (result) {
					return result;
				} 
				result = ModernizedCProgram.Curl_add_buffer_send(req_buffer, /* issue the request */conn, data.getInfo().getRequest_size(), 0, 0);
				if (result) {
					ModernizedCProgram.Curl_failf(data, "Failed sending HTTP request");
				} else {
						ModernizedCProgram.Curl_setup_transfer(data, 0, -1, 1, -/* HTTP GET/HEAD download: */1);
				} 
		}
		if (result) {
			return result;
		} 
		if (data.getReq().getWritebytecount()) {
			ModernizedCProgram.Curl_pgrsSetUploadCounter(data, data.getReq().getWritebytecount());
			if (ModernizedCProgram.Curl_pgrsUpdate(conn)) {
				result = .CURLE_ABORTED_BY_CALLBACK;
			} 
			if (data.getReq().getWritebytecount() >= postsize/* already sent the entire request body, mark the "upload" as
			         complete */) {
				ModernizedCProgram.Curl_infof(data, "upload completely sent off: %I64d out of %I64d bytes\n", data.getReq().getWritebytecount(), postsize);
				data.getReq().setUpload_done(1);
				data.getReq().getKeepon() &=  ~(1 << /* we're done writing */1);
				data.getReq().setExp100(/* already sent */expect100.EXP100_SEND_DATA);
				ModernizedCProgram.Curl_expire_done(data, .EXPIRE_100_TIMEOUT);
			} 
		} 
		if ((conn.getHttpversion() == 20) && data.getReq().getUpload_chunky()) {
			data.getReq().setUpload_chunky(0);
		} 
		return result/* not enough data to tell yet *//* a status line was read */;
	}
	/* not a status line */
	/* Check a string for a prefix. Check no more than 'len' bytes */
	public static  checkprefixmax(Object prefix, Object buffer, Object len) {
		size_t ch = ((.strlen(prefix)) < (len) ? (.strlen(prefix)) : (len));
		return ModernizedCProgram.curl_strnequal(prefix, buffer, ch/*
		 * checkhttpprefix()
		 *
		 * Returns TRUE if member of the list matches prefix of string
		 */);
	}
	public static  checkhttpprefix(Object data, Object s, Object len) {
		curl_slist head = data.getSet().getHttp200aliases();
		statusline rc = .STATUS_BAD;
		statusline onmatch = len >= 5 ? .STATUS_DONE : .STATUS_UNKNOWN/* convert from the network encoding using a scratch area *//* can't return CURLE_OUT_OF_MEMORY so return FALSE */;
		while (/* Curl_convert_from_network calls failf if unsuccessful *//* can't return CURLE_foobar so return FALSE *//* CURL_DOES_CONVERSIONS */head) {
			if (ModernizedCProgram.checkprefixmax(head.getData(), s, len)) {
				rc = onmatch;
				break;
			} 
			head = head.getNext();
		}
		if ((rc != .STATUS_DONE) && (ModernizedCProgram.checkprefixmax("HTTP/", s, len))) {
			rc = onmatch;
		} 
		return /* CURL_DOES_CONVERSIONS */rc;
	}
	public static  checkrtspprefix(Object data, Object s, Object len) {
		statusline result = .STATUS_BAD;
		statusline onmatch = len >= 5 ? .STATUS_DONE : .STATUS_UNKNOWN/* convert from the network encoding using a scratch area *//* can't return CURLE_OUT_OF_MEMORY so return FALSE */;
		(Object)/* Curl_convert_from_network calls failf if unsuccessful *//* can't return CURLE_foobar so return FALSE *//* unused */data;
		if (ModernizedCProgram.checkprefixmax("RTSP/", s, len)) {
			result = onmatch/* CURL_DOES_CONVERSIONS */;
		} 
		return result/* CURL_DISABLE_RTSP */;
	}
	public static  checkprotoprefix(Object data, Object conn, Object s, Object len) {
		if (conn.getHandler().getProtocol() & (1 << 18)) {
			return ModernizedCProgram.checkrtspprefix(data, s, len);
		} 
		return ModernizedCProgram.checkhttpprefix(data, s, /* CURL_DISABLE_RTSP */len/*
		 * header_append() copies a chunk of data to the end of the already received
		 * header. We make sure that the full string fit in the allocated header
		 * buffer, or else we enlarge it.
		 */);
	}
	public static  header_append(Object data, Object k, Object length) {
		size_t newsize = k.getHbuflen() + /* length is at most the size of a full read buffer, for which the upper
		     bound is CURL_MAX_READ_SIZE. There is thus no chance of overflow in this
		     calculation. */length;
		if (newsize > (100 * 1024/* The reason to have a max limit for this is to avoid the risk of a bad
		       server feeding libcurl with a never-ending header that will cause
		       reallocs infinitely */)) {
			ModernizedCProgram.Curl_failf(data, "Rejected %zu bytes header (max is %d)!", newsize, (100 * 1024));
			return .CURLE_OUT_OF_MEMORY;
		} 
		if (newsize >= data.getState().getHeadersize()) {
			byte newbuff;
			size_t hbufp_index = new size_t();
			newsize = (((k.getHbuflen() + length) * 3 / 2) > (data.getState().getHeadersize() * 2) ? ((k.getHbuflen() + length) * 3 / 2) : (data.getState().getHeadersize() * 2));
			hbufp_index = k.getHbufp() - data.getState().getHeaderbuff();
			newbuff = .Curl_crealloc(data.getState().getHeaderbuff(), newsize);
			if (!newbuff) {
				ModernizedCProgram.Curl_failf(data, "Failed to alloc memory for big header!");
				return .CURLE_OUT_OF_MEMORY;
			} 
			data.getState().setHeadersize(newsize);
			data.getState().setHeaderbuff(newbuff);
			k.setHbufp(data.getState().getHeaderbuff() + hbufp_index);
		} 
		.memcpy(k.getHbufp(), k.getStr_start(), length);
		k.getHbufp() += length;
		k.getHbuflen() += length;
		k.getHbufp() = 0;
		return .CURLE_OK;
	}
	public static void print_http_error(Object data) {
		SingleRequest k = data.getReq();
		byte beg = k.getP();
		if (!.strncmp(beg, "HTTP", /* make sure that data->req.p points to the HTTP status line */4)) {
			beg = .strchr(beg, /* skip to HTTP status code */(byte)' ');
			if (beg && ++beg) {
				byte end_char = /* find trailing CR */(byte)'\r';
				byte end = .strchr(beg, end_char);
				if (!end) {
					end_char = /* try to find LF (workaround for non-compliant HTTP servers) */(byte)'\n';
					end = .strchr(beg, end_char);
				} 
				if (end) {
					end = /* temporarily replace CR or LF by NUL and print the error message */(byte)'\0';
					ModernizedCProgram.Curl_failf(data, "The requested URL returned error: %s", beg);
					end = /* restore the previously replaced CR or LF */end_char;
					return ;
				} 
			} 
		} 
		ModernizedCProgram.Curl_failf(data, "The requested URL returned error: %d", k.getHttpcode());
	}
	public static  Curl_http_readwrite_headers(Object data, Object conn, Object nread, Object stop_reading) {
		CURLcode result = new CURLcode();
		SingleRequest k = data.getReq();
		ssize_t onread = nread;
		byte ostr = k.getStr();
		/* header line within buffer loop */do {
			size_t rest_length = new size_t();
			size_t full_length = new size_t();
			int writetype;
			k.setStr_start(k.getStr());
			k.setEnd_ptr(.memchr(k.getStr_start(), -1024, /* data is in network encoding so use 0x0a instead of '\n' */nread));
			if (!k.getEnd_ptr()) {
				result = ModernizedCProgram.header_append(data, k, nread);
				if (result) {
					return result;
				} 
				if (!k.getHeaderline()) {
					statusline st = ModernizedCProgram.checkprotoprefix(data, conn, data.getState().getHeaderbuff(), k.getHbuflen());
					if (st == .STATUS_BAD) {
						k.setHeader(/* this is not the beginning of a protocol first header line */0);
						k.setBadheader(.HEADER_ALLBAD);
						ModernizedCProgram.Curl_conncontrol(conn, 2);
						if (!data.getSet().getHttp09_allowed()) {
							ModernizedCProgram.Curl_failf(data, "Received HTTP/0.9 when not allowed\n");
							return .CURLE_UNSUPPORTED_PROTOCOL;
						} 
						break;
					} 
				} 
				break;
			} 
			rest_length = (k.getEnd_ptr() - k.getStr()) + /* decrease the size of the remaining (supposed) header line */1;
			nread -= (ssize_t)rest_length;
			k.setStr(k.getEnd_ptr() + /* move past new line */1);
			full_length = k.getStr() - k.getStr_start();
			result = ModernizedCProgram.header_append(data, k, full_length);
			if (result) {
				return result;
			} 
			k.setEnd_ptr(k.getHbufp());
			k.setP(data.getState().getHeaderbuff());
			if (!k.getHeaderline()) {
				statusline st = ModernizedCProgram.checkprotoprefix(data, conn, data.getState().getHeaderbuff(), k.getHbuflen());
				if (st == .STATUS_BAD) {
					ModernizedCProgram.Curl_conncontrol(conn, 2);
					if (!data.getSet().getHttp09_allowed()) {
						ModernizedCProgram.Curl_failf(data, "Received HTTP/0.9 when not allowed\n");
						return .CURLE_UNSUPPORTED_PROTOCOL;
					} 
					k.setHeader(0);
					if (nread) {
						k.setBadheader(/* since there's more, this is a partial bad header */.HEADER_PARTHEADER);
					} else {
							k.setBadheader(/* this was all we read so it's all a bad header */.HEADER_ALLBAD);
							nread = onread;
							k.setStr(ostr);
							return .CURLE_OK;
					} 
					break;
				} 
			} 
			if ((-1024 == k.getP()) || (-1024 == k.getP())) {
				size_t headerlen = new size_t();
				if ((byte)'\r' == k.getP()) {
					k.getP()++;
				} 
				if ((byte)'\n' == k.getP()) {
					k.getP()++;
				} 
				if (100 <= k.getHttpcode() && 199 >= k.getHttpcode()) {
					switch (k.getHttpcode()) {
					case 101:
							if (k.getUpgr101() == /* Switching Protocols */upgrade101.UPGR101_REQUESTED) {
								ModernizedCProgram.Curl_infof(data, /* Switching to HTTP/2 */"Received 101\n");
								k.setUpgr101(upgrade101.UPGR101_RECEIVED);
								k.setHeader(/* we'll get more headers (HTTP/2 response) */1);
								k.setHeaderline(/* restart the header line counter */0);
								result = /* switch to http2 now. The bytes after response headers
								               are also processed here, otherwise they are lost. */.CURLE_UNSUPPORTED_PROTOCOL;
								if (result) {
									return result;
								} 
								nread = 0;
							} else {
									k.setHeader(/* Switching to another protocol (e.g. WebSocket) *//* no more header to parse! */0);
							} 
							break;
					case 100/*
					           * We have made a HTTP PUT or POST and this is 1.1-lingo
					           * that tells us that the server is OK with this and ready
					           * to receive the data.
					           * However, we'll get more headers now so we must get
					           * back into the header-parsing state!
					           */:
							k.setHeader(1);
							k.setHeaderline(/* restart the header line counter */0);
							if (k.getExp100() > /* if we did wait for this do enable write now! */expect100.EXP100_SEND_DATA) {
								k.setExp100(expect100.EXP100_SEND_DATA);
								k.getKeepon() |=  (1 << 1);
								ModernizedCProgram.Curl_expire_done(data, .EXPIRE_100_TIMEOUT);
							} 
							break;
					default:
							k.setHeader(1);
							k.setHeaderline(/* restart the header line counter */0);
							break;
					}
				} else {
						k.setHeader(/* no more header to parse! */0);
						if ((k.getSize() == -1) && !k.getChunk() && !conn.getBits().getClose() && (conn.getHttpversion() == 11) && !(conn.getHandler().getProtocol() & (1 << 18)) && data.getSet().getHttpreq() != .HTTPREQ_HEAD/* On HTTP 1.1, when connection is not to get closed, but no
						             Content-Length nor Transfer-Encoding chunked have been
						             received, according to RFC2616 section 4.4 point 5, we
						             assume that the server will close the connection to
						             signal the end of the document. */) {
							ModernizedCProgram.Curl_infof(data, "no chunk, no close, no size. Assume close to signal end\n");
							ModernizedCProgram.Curl_conncontrol(conn, 2);
						} 
				} 
				if (conn.getBits().getClose() && (((data.getReq().getHttpcode() == 401) && (conn.getHttp_ntlm_state() == .NTLMSTATE_TYPE2)) || ((data.getReq().getHttpcode() == 407) && (conn.getProxy_ntlm_state() == .NTLMSTATE_TYPE2)))) {
					ModernizedCProgram.Curl_infof(data, "Connection closure while negotiating auth (HTTP 1.0?)\n");
					data.getState().setAuthproblem(1);
				} 
				if (ModernizedCProgram.http_should_fail(/*
				       * When all the headers have been parsed, see if we should give
				       * up and return an error.
				       */conn)) {
					ModernizedCProgram.Curl_failf(data, "The requested URL returned error: %d", k.getHttpcode());
					return .CURLE_HTTP_RETURNED_ERROR;
				} 
				writetype = (1 << /* now, only output this if the header AND body are requested:
				       */1);
				if (data.getSet().getInclude_header()) {
					writetype |=  (1 << 0);
				} 
				headerlen = k.getP() - data.getState().getHeaderbuff();
				result = ModernizedCProgram.Curl_client_write(conn, writetype, data.getState().getHeaderbuff(), headerlen);
				if (result) {
					return result;
				} 
				data.getInfo().getHeader_size() += (long)headerlen;
				data.getReq().getHeaderbytecount() += (long)headerlen;
				data.getReq().setDeductheadercount((100 <= k.getHttpcode() && 199 >= k.getHttpcode()) ? data.getReq().getHeaderbytecount() : 0/* Curl_http_auth_act() checks what authentication methods
				       * that are available and decides which one (if any) to
				       * use. It will set 'newurl' if an auth method was picked. */);
				result = ModernizedCProgram.Curl_http_auth_act(conn);
				if (result) {
					return result;
				} 
				if (k.getHttpcode() >= 300) {
					if ((!conn.getBits().getAuthneg()) && !conn.getBits().getClose() && !conn.getBits().getRewindaftersend()) {
						switch (data.getSet().getHttpreq()) {
						case .HTTPREQ_POST_MIME/* We got an error response. If this happened before the whole
						             * request body has been sent we stop sending and mark the
						             * connection for closure after we've read the entire response.
						             */:
								ModernizedCProgram.Curl_expire_done(data, .EXPIRE_100_TIMEOUT);
								if (!k.getUpload_done()) {
									if (data.getSet().getHttp_keep_sending_on_error()) {
										ModernizedCProgram.Curl_infof(data, "HTTP error before end of send, keep sending\n");
										if (k.getExp100() > expect100.EXP100_SEND_DATA) {
											k.setExp100(expect100.EXP100_SEND_DATA);
											k.getKeepon() |=  (1 << 1);
										} 
									} else {
											ModernizedCProgram.Curl_infof(data, "HTTP error before end of send, stop sending\n");
											ModernizedCProgram.Curl_conncontrol(conn, 2);
											result = ModernizedCProgram.Curl_done_sending(conn, k);
											if (result) {
												return result;
											} 
											k.setUpload_done(1);
											if (data.getState().getExpect100header()) {
												k.setExp100(expect100.EXP100_FAILED);
											} 
									} 
								} 
								break;
						case .HTTPREQ_POST:
						case .HTTPREQ_PUT:
						case .HTTPREQ_POST_FORM:
						default:
								break;
						}
					} 
					if (conn.getBits().getRewindaftersend()) {
						ModernizedCProgram.Curl_infof(data, "Keep sending data to get tossed away!\n");
						k.getKeepon() |=  (1 << 1);
					} 
				} 
				if (!k.getHeader()) {
					if (data.getSet().getOpt_no_body()) {
						stop_reading = 1;
					}  else if ((conn.getHandler().getProtocol() & (1 << 18)) && (data.getSet().getRtspreq() == .RTSPREQ_DESCRIBE) && (k.getSize() <= -1/* Respect section 4.4 of rfc2326: If the Content-Length header is
					             absent, a length 0 must be assumed.  It will prevent libcurl from
					             hanging on DESCRIBE request that got refused for whatever
					             reason */)) {
						stop_reading = 1/* If we know the expected size of this document, we set the
						             maximum download size to the size of the expected
						             document or else, we won't know when to stop reading!
						
						             Note that we set the download maximum even if we read a
						             "Connection: close" header, to make sure that
						             "Content-Length: 0" still prevents us from attempting to
						             read the (missing) response-body.
						          */;
					} else {
							if (k.getChunk()) {
								k.setMaxdownload(k.setSize(-1));
							} 
					} 
					if (-1 != k.getSize()) {
						ModernizedCProgram.Curl_pgrsSetDownloadSize(data, k.getSize());
						k.setMaxdownload(k.getSize());
					} 
					if (0 == k.getMaxdownload()) {
						stop_reading = 1;
					} 
					if (stop_reading) {
						k.getKeepon() &=  ~(1 << /* we make sure that this socket isn't read more now */0);
					} 
					if (data.getSet().getVerbose()) {
						ModernizedCProgram.Curl_debug(data, .CURLINFO_HEADER_IN, k.getStr_start(), headerlen);
					} 
					break;
				} 
				k.setHbufp(data.getState().getHeaderbuff());
				k.setHbuflen(0);
				continue;
			} 
			if (!k.getHeaderline()++) {
				int httpversion_major;
				int rtspversion_major;
				int nc = 0/* "HTTP/major.minor 123" *//* We can't really convert this yet because we
				         don't know if it's the 1st header line or the body.
				         So we do a partial conversion into a scratch area,
				         leaving the data at k->p as-is.
				      */;
				if (conn.getHandler().getProtocol() & ((1 << 0) | (1 << /* null terminate *//* Curl_convert_from_network calls failf if unsuccessful *//* no conversion needed, just use k->p *//* CURL_DOES_CONVERSIONS */1/*
				         * https://tools.ietf.org/html/rfc7230#section-3.1.2
				         *
				         * The response code is always a three-digit number in HTTP as the spec
				         * says. We try to allow any number here, but we cannot make
				         * guarantees on future behaviors since it isn't within the protocol.
				         */))) {
					byte separator;
					byte[] twoorthree = new byte[2];
					nc = .sscanf(k.getP(), " HTTP/%1d.%1d%c%3d", httpversion_major, conn.getHttpversion(), separator, k.getHttpcode());
					if (nc == 1 && httpversion_major >= 2 && 2 == .sscanf(k.getP(), " HTTP/%1[23] %d", twoorthree, k.getHttpcode())) {
						conn.setHttpversion(0);
						nc = 4;
						separator = (byte)' ';
					} 
					if ((nc == 4) && ((byte)' ' == separator)) {
						conn.getHttpversion() += 10 * httpversion_major;
						if (k.getUpgr101() == upgrade101.UPGR101_RECEIVED) {
							if (conn.getHttpversion() != /* supposedly upgraded to http2 now */20) {
								ModernizedCProgram.Curl_infof(data, "Lying server, not serving HTTP/2\n");
							} 
						} 
						if (conn.getHttpversion() < 20) {
							conn.getBundle().setMultiuse(-1);
							ModernizedCProgram.Curl_infof(data, "Mark bundle as not supporting multiuse\n");
						} 
					}  else if (!nc/* this is the real world, not a Nirvana
					             NCSA 1.5.x returns this crap when asked for HTTP/1.1
					          */) {
						nc = .sscanf(k.getP(), " HTTP %3d", k.getHttpcode());
						conn.setHttpversion(10/* If user has set option HTTP200ALIASES,
						             compare header line against list of aliases
						          */);
						if (!nc) {
							if (ModernizedCProgram.checkhttpprefix(data, k.getP(), k.getHbuflen()) == .STATUS_DONE) {
								nc = 1;
								k.setHttpcode(200);
								conn.setHttpversion(10);
							} 
						} 
					} else {
							ModernizedCProgram.Curl_failf(data, "Unsupported HTTP version in response");
							return .CURLE_UNSUPPORTED_PROTOCOL;
					} 
				}  else if (conn.getHandler().getProtocol() & (1 << 18)) {
					byte separator;
					nc = .sscanf(k.getP(), " RTSP/%1d.%1d%c%3d", rtspversion_major, conn.getRtspversion(), separator, k.getHttpcode());
					if ((nc == 4) && ((byte)' ' == separator)) {
						conn.getRtspversion() += 10 * rtspversion_major;
						conn.setHttpversion(/* For us, RTSP acts like HTTP 1.1 */11);
					} else {
							nc = 0;
					} 
				} 
				if (nc) {
					data.getInfo().setHttpcode(k.getHttpcode());
					data.getInfo().setHttpversion(conn.getHttpversion());
					if (!data.getState().getHttpversion() || data.getState().getHttpversion() > conn.getHttpversion()) {
						data.getState().setHttpversion(conn.getHttpversion());
					} 
					if (data.getState().getResume_from() && data.getSet().getHttpreq() == .HTTPREQ_GET && k.getHttpcode() == 416/* "Requested Range Not Satisfiable", just proceed and
					             pretend this is no error */) {
						k.setIgnorebody(/* Avoid appending error msg to good data. */1);
					}  else if (data.getSet().getHttp_fail_on_error() && (k.getHttpcode() >= 400) && ((k.getHttpcode() != 401) || !conn.getBits().getUser_passwd()) && ((k.getHttpcode() != 407) || !conn.getBits().getProxy_user_passwd())) {
						ModernizedCProgram.print_http_error(/* serious error, go home! */data);
						return .CURLE_HTTP_RETURNED_ERROR;
					} 
					if (conn.getHttpversion() == 10/* Default action for HTTP/1.0 must be to close, unless
					             we get one of those fancy headers that tell us the
					             server keeps it open for us! */) {
						ModernizedCProgram.Curl_infof(data, "HTTP 1.0, assume close after body\n");
						ModernizedCProgram.Curl_conncontrol(conn, 1);
					}  else if (conn.getHttpversion() == 20 || (k.getUpgr101() == upgrade101.UPGR101_REQUESTED && k.getHttpcode() == 101)) {
						do {
						} while (0);
						conn.getBundle().setMultiuse(/* HTTP/2 cannot blacklist multiplexing since it is a core
						             functionality of the protocol */2);
					}  else if (conn.getHttpversion() >= 11 && !conn.getBits().getClose()) {
						do {
						} while (/* If HTTP version is >= 1.1 and connection is persistent */0);
					} 
					k.setHttp_bodyless(k.getHttpcode() >= 100 && k.getHttpcode() < 200);
					switch (k.getHttpcode()) {
					case 304/* (quote from RFC2616, section 10.3.5): The 304 response
					           * MUST NOT contain a message-body, and thus is always
					           * terminated by the first empty line after the header
					           * fields.  */:
							if (data.getSet().getTimecondition()) {
								data.getInfo().setTimecond(1);
							} 
					case /* FALLTHROUGH */204/* (quote from RFC2616, section 10.2.5): The server has
					           * fulfilled the request but does not need to return an
					           * entity-body ... The 204 response MUST NOT include a
					           * message-body, and thus is always terminated by the first
					           * empty line after the header fields. */:
							k.setSize(0);
							k.setMaxdownload(0);
							k.setHttp_bodyless(1);
							break;
					default:
							break;
					}
				} else {
						k.setHeader(/* this is not a header line */0);
						break;
				} 
			} 
			result = ();
			if (/* Curl_convert_from_network calls failf if unsuccessful */result) {
				return result;
			} 
			if (!k.getHttp_bodyless() && !data.getSet().getIgnorecl() && ModernizedCProgram.curl_strnequal("Content-Length:", k.getP(), .strlen("Content-Length:"))) {
				curl_off_t contentlength = new curl_off_t();
				CURLofft offt = ModernizedCProgram.curlx_strtoofft(k.getP() + 15, ((Object)0), 10, contentlength);
				if (offt == .CURL_OFFT_OK) {
					if (data.getSet().getMax_filesize() && contentlength > data.getSet().getMax_filesize()) {
						ModernizedCProgram.Curl_failf(data, "Maximum file size exceeded");
						return .CURLE_FILESIZE_EXCEEDED;
					} 
					k.setSize(contentlength);
					k.setMaxdownload(k.getSize());
					ModernizedCProgram.Curl_pgrsSetDownloadSize(data, k.getSize());
				}  else if (offt == .CURL_OFFT_FLOW) {
					if (data.getSet().getMax_filesize()) {
						ModernizedCProgram.Curl_failf(data, "Maximum file size exceeded");
						return .CURLE_FILESIZE_EXCEEDED;
					} 
					ModernizedCProgram.Curl_conncontrol(conn, 2);
					ModernizedCProgram.Curl_infof(data, "Overflow Content-Length: value!\n");
				} else {
						ModernizedCProgram.Curl_failf(data, /* negative or just rubbish - bad HTTP */"Invalid Content-Length: value");
						return .CURLE_WEIRD_SERVER_REPLY;
				} 
			}  else if (ModernizedCProgram.curl_strnequal("Content-Type:", k.getP(), .strlen(/* check for Content-Type: header lines to get the MIME-type */"Content-Type:"))) {
				byte contenttype = ModernizedCProgram.Curl_copy_header_value(k.getP());
				if (!contenttype) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				if (!contenttype) {
					.Curl_cfree(/* ignore empty data */contenttype);
				} else {
						do {
							.Curl_cfree((data.getInfo().getContenttype()));
							(data.getInfo().getContenttype()) = ((Object)0);
						} while (0);
						data.getInfo().setContenttype(contenttype);
				} 
			}  else if ((conn.getHttpversion() == 10) && conn.getBits().getHttpproxy() && ModernizedCProgram.Curl_compareheader(k.getP(), "Proxy-Connection:", "keep-alive"/*
			       * When a HTTP/1.0 reply comes when using a proxy, the
			       * 'Proxy-Connection: keep-alive' line tells us the
			       * connection will be kept alive for our pleasure.
			       * Default action for 1.0 is to close.
			       */)) {
				ModernizedCProgram.Curl_conncontrol(conn, /* don't close */0);
				ModernizedCProgram.Curl_infof(data, "HTTP/1.0 proxy connection set to keep alive!\n");
			}  else if ((conn.getHttpversion() == 11) && conn.getBits().getHttpproxy() && ModernizedCProgram.Curl_compareheader(k.getP(), "Proxy-Connection:", "close"/*
			       * We get a HTTP/1.1 response from a proxy and it says it'll
			       * close down after this transfer.
			       */)) {
				ModernizedCProgram.Curl_conncontrol(conn, 1);
				ModernizedCProgram.Curl_infof(data, "HTTP/1.1 proxy connection set close!\n");
			}  else if ((conn.getHttpversion() == 10) && ModernizedCProgram.Curl_compareheader(k.getP(), "Connection:", "keep-alive"/*
			       * A HTTP/1.0 reply with the 'Connection: keep-alive' line
			       * tells us the connection will be kept alive for our
			       * pleasure.  Default action for 1.0 is to close.
			       *
			       * [RFC2068, section 19.7.1] */)) {
				ModernizedCProgram.Curl_conncontrol(conn, 0);
				ModernizedCProgram.Curl_infof(data, "HTTP/1.0 connection set to keep alive!\n");
			}  else if (ModernizedCProgram.Curl_compareheader(k.getP(), "Connection:", "close"/*
			       * [RFC 2616, section 8.1.2.1]
			       * "Connection: close" is HTTP/1.1 language and means that
			       * the connection will close when this request has been
			       * served.
			       */)) {
				ModernizedCProgram.Curl_conncontrol(conn, 2);
			}  else if (!k.getHttp_bodyless() && ModernizedCProgram.curl_strnequal("Transfer-Encoding:", k.getP(), .strlen("Transfer-Encoding:"/* One or more encodings. We check for chunked and/or a compression
			         algorithm. *//*
			       * [RFC 2616, section 3.6.1] A 'chunked' transfer encoding
			       * means that the server will send a series of "chunks". Each
			       * chunk starts with line with info (including size of the
			       * coming block) (terminated with CRLF), then a block of data
			       * with the previously mentioned size. There can be any amount
			       * of chunks, and a chunk-data set to zero signals the
			       * end-of-chunks. */))) {
				result = ModernizedCProgram.Curl_build_unencoding_stack(conn, k.getP() + 18, 1);
				if (result) {
					return result;
				} 
			}  else if (!k.getHttp_bodyless() && ModernizedCProgram.curl_strnequal("Content-Encoding:", k.getP(), .strlen("Content-Encoding:")) && data.getSet().getStr()[dupstring.STRING_ENCODING/*
			       * Process Content-Encoding. Look for the values: identity,
			       * gzip, deflate, compress, x-gzip and x-compress. x-gzip and
			       * x-compress are the same as gzip and compress. (Sec 3.5 RFC
			       * 2616). zlib cannot handle compress.  However, errors are
			       * handled further down when the response body is processed
			       */]) {
				result = ModernizedCProgram.Curl_build_unencoding_stack(conn, k.getP() + 17, 0);
				if (result) {
					return result;
				} 
			}  else if (ModernizedCProgram.curl_strnequal("Retry-After:", k.getP(), .strlen("Retry-After:"))) {
				curl_off_t retry_after = /* Retry-After = HTTP-date / delay-seconds *//* zero for unknown or "now" */0;
				time_t date = ModernizedCProgram.curl_getdate(k.getP()[12], ((Object)0));
				if (-1 == date) {
					(Object)ModernizedCProgram.curlx_strtoofft(k.getP()[12], ((Object)0), 10, /* not a date, try it as a decimal number */retry_after);
				} else {
						retry_after = date - .time(((Object)/* convert date to number of seconds into the future */0));
				} 
				data.getInfo().setRetry_after(/* store it */retry_after);
			}  else if (!k.getHttp_bodyless() && ModernizedCProgram.curl_strnequal("Content-Range:", k.getP(), .strlen("Content-Range:"/* Content-Range: bytes [num]-
			         Content-Range: bytes: [num]-
			         Content-Range: [num]-
			         Content-Range: [asterisk]/[total]
			
			         The second format was added since Sun's webserver
			         JavaWebServer/1.1.1 obviously sends the header this way!
			         The third added since some servers use that!
			         The forth means the requested range was unsatisfied.
			      */))) {
				byte ptr = k.getP() + 14;
				while (ptr && !(ModernizedCProgram.Curl_isdigit((int)((byte)ptr))) && ptr != /* Move forward until first digit or asterisk */(byte)'*') {
					ptr++;
				}
				if ((ModernizedCProgram.Curl_isdigit((int)((byte)/* if it truly stopped on a digit */ptr)))) {
					if (!ModernizedCProgram.curlx_strtoofft(ptr, ((Object)0), 10, k.getOffset())) {
						if (data.getState().getResume_from() == k.getOffset()) {
							k.setContent_range(/* we asked for a resume and we got it */1);
						} 
					} 
				} else {
						data.getState().setResume_from(/* get everything */0);
				} 
			}  else if (data.getCookies() && data.getState().getCookie_engine() && ModernizedCProgram.curl_strnequal("Set-Cookie:", k.getP(), .strlen("Set-Cookie:"))) {
				ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_COOKIE, .CURL_LOCK_ACCESS_SINGLE);
				ModernizedCProgram.Curl_cookie_add(data, data.getCookies(), 1, 0, k.getP() + 11/* If there is a custom-set Host: name, use it
				                         here, or else use real peer host name. */, conn.getAllocptr().getCookiehost() ? conn.getAllocptr().getCookiehost() : conn.getHost().getName(), data.getState().getUp().getPath(), (conn.getHandler().getProtocol() & (1 << 1)) ? 1 : 0);
				ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_COOKIE);
			}  else if (!k.getHttp_bodyless() && ModernizedCProgram.curl_strnequal("Last-Modified:", k.getP(), .strlen("Last-Modified:")) && (data.getSet().getTimecondition() || data.getSet().getGet_filetime())) {
				time_t secs = .time(((Object)0));
				k.setTimeofdoc(ModernizedCProgram.curl_getdate(k.getP() + .strlen("Last-Modified:"), secs));
				if (data.getSet().getGet_filetime()) {
					data.getInfo().setFiletime(k.getTimeofdoc());
				} 
			}  else if ((ModernizedCProgram.curl_strnequal("WWW-Authenticate:", k.getP(), .strlen("WWW-Authenticate:")) && (401 == k.getHttpcode())) || (ModernizedCProgram.curl_strnequal("Proxy-authenticate:", k.getP(), .strlen("Proxy-authenticate:")) && (407 == k.getHttpcode()))) {
				bool proxy = (k.getHttpcode() == 407) ? 1 : 0;
				byte auth = ModernizedCProgram.Curl_copy_header_value(k.getP());
				if (!auth) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				result = ModernizedCProgram.Curl_http_input_auth(conn, proxy, auth);
				.Curl_cfree(auth);
				if (result) {
					return result;
				} 
			}  else if ((k.getHttpcode() >= 300 && k.getHttpcode() < 400) && ModernizedCProgram.curl_strnequal("Location:", k.getP(), .strlen("Location:")) && !data.getReq().getLocation()) {
				byte location = ModernizedCProgram.Curl_copy_header_value(k.getP());
				if (!location) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				if (!location) {
					.Curl_cfree(/* ignore empty data */location);
				} else {
						data.getReq().setLocation(location);
						if (data.getSet().getHttp_follow_location()) {
							do {
							} while (0);
							data.getReq().setNewurl(.Curl_cstrdup(data.getReq().getLocation()));
							if (!data.getReq().getNewurl()) {
								return .CURLE_OUT_OF_MEMORY;
							} 
							result = ModernizedCProgram.http_perhapsrewind(/* some cases of POST and PUT etc needs to rewind the data
							             stream at this point */conn);
							if (result) {
								return result/* If enabled, the header is incoming and this is over HTTPS *//* allow debug builds to circumvent the HTTPS restriction */;
							} 
						} 
				} 
			}  else if (conn.getHandler().getProtocol() & (1 << /* the ALPN of the current request */18)) {
				result = ModernizedCProgram.Curl_rtsp_parseheader(conn, k.getP());
				if (result) {
					return result/*
					     * End of header-checks. Write them to the client.
					     */;
				} 
			} 
			writetype = (1 << 1);
			if (data.getSet().getInclude_header()) {
				writetype |=  (1 << 0);
			} 
			if (data.getSet().getVerbose()) {
				ModernizedCProgram.Curl_debug(data, .CURLINFO_HEADER_IN, k.getP(), (size_t)k.getHbuflen());
			} 
			result = ModernizedCProgram.Curl_client_write(conn, writetype, k.getP(), k.getHbuflen());
			if (result) {
				return result;
			} 
			data.getInfo().getHeader_size() += (long)k.getHbuflen();
			data.getReq().getHeaderbytecount() += (long)k.getHbuflen();
			k.setHbufp(data.getState().getHeaderbuff());
			k.setHbuflen(0);
		} while (k.getStr());
		return .CURLE_OK/* CURL_DISABLE_HTTP */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/***********************************************************************
	 * Only for builds using asynchronous name resolves
	 **********************************************************************/
	/* The last #include file should be: */
	/*
	 * Curl_addrinfo_callback() gets called by ares, gethostbyname_thread()
	 * or getaddrinfo_thread() when we got the name resolved (or not!).
	 *
	 * If the status argument is CURL_ASYNC_SUCCESS, this function takes
	 * ownership of the Curl_addrinfo passed, storing the resolved data
	 * in the DNS cache.
	 *
	 * The storage operation locks and unlocks the DNS cache.
	 */
	public static  Curl_addrinfo_callback(Object conn, int status, Object ai) {
		Curl_dns_entry dns = ((Object)0);
		CURLcode result = .CURLE_OK;
		conn.getAsync().setStatus(status);
		if (.CURLE_OK == status) {
			if (ai) {
				Curl_easy data = conn.getData();
				if (data.getShare()) {
					ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_DNS, .CURL_LOCK_ACCESS_SINGLE);
				} 
				dns = ModernizedCProgram.Curl_cache_addr(data, ai, conn.getAsync().getHostname(), conn.getAsync().getPort());
				if (data.getShare()) {
					ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_DNS);
				} 
				if (!dns) {
					ModernizedCProgram.Curl_freeaddrinfo(/* failed to store, cleanup and return error */ai);
					result = .CURLE_OUT_OF_MEMORY;
				} 
			} else {
					result = .CURLE_OUT_OF_MEMORY;
			} 
		} 
		conn.getAsync().setDns(dns/* Set async.done TRUE last in this function since it may be used multi-
		    threaded and once this is TRUE the other thread may read fields from the
		    async struct */);
		conn.getAsync().setDone(1);
		return /* IPv4: The input hostent struct will be freed by ares when we return from
		     this function */result/*
		 * Curl_getaddrinfo() is the generic low-level name resolve API within this
		 * source file. There are several versions of this function - for different
		 * name resolve layers (selected at build-time). They all take this same set
		 * of arguments
		 */;
	}
	public static Object Curl_getaddrinfo(Object conn, Object hostname, int port, Object waitp) {
		return ModernizedCProgram.Curl_resolver_getaddrinfo(conn, hostname, port, waitp/* CURLRES_ASYNCH */);
	}
	public static void main_checkfds() {
	}
	/* Out of handles. This isn't really a big problem now, but
	                   will be when we try to create a socket later. */
	/* if CURL_MEMDEBUG is set, this starts memory tracking message logging */
	/* use the value as file name */
	/* this weird stuff here is to make curl_free() get called before
	       curl_gdb_memdebug() as otherwise memory tracking will log a free()
	       without an alloc! */
	/* if CURL_MEMLIMIT is set, this enables fail-on-alloc-number-N feature */
	/*
	 * This is the main global constructor for the app. Call this before
	 * _any_ libcurl usage. If this fails, *NO* libcurl functions may be
	 * used, or havoc may be the result.
	 */
	public static  main_init(Object config) {
		CURLcode result = .CURLE_OK/* stop stat() wasting time */;
		config.setShowerror(-/* Initialise the global config *//* Will show errors */1);
		config.setErrors((_iob[/* Default errors to stderr */2]));
		config.setStyled_output(/* enable detection */1);
		config.setParallel_max(50);
		config.setFirst(config.setLast(.malloc(/* Allocate the initial operate config */)));
		if (config.getFirst()) {
			result = ModernizedCProgram.curl_global_init(((1 << 0) | (1 << /* Perform the libcurl initialization */1)));
			if (!result) {
				result = ModernizedCProgram.get_libcurl_info();
				if (!result) {
					ModernizedCProgram.config_init(config.getFirst());
					config.getFirst().setGlobal(config);
				} else {
						ModernizedCProgram.helpf((_iob[2]), "error retrieving curl library information\n");
						.free(config.getFirst());
				} 
			} else {
					ModernizedCProgram.helpf((_iob[2]), "error initializing curl library\n");
					.free(config.getFirst());
			} 
		} else {
				ModernizedCProgram.helpf((_iob[2]), "error initializing curl\n");
				result = .CURLE_FAILED_INIT;
		} 
		return result;
	}
	public static void free_globalconfig(Object config) {
		do {
			.free((config.getTrace_dump()));
			(config.getTrace_dump()) = ((Object)0);
		} while (0);
		if (config.getErrors_fopened() && config.getErrors()) {
			.fclose(config.getErrors());
		} 
		config.setErrors(((Object)0));
		if (config.getTrace_fopened() && config.getTrace_stream()) {
			.fclose(config.getTrace_stream());
		} 
		config.setTrace_stream(((Object)0));
		do {
			.free((config.getLibcurl()));
			(config.getLibcurl()) = ((Object)0);
		} while (0/*
		 * This is the main global destructor for the app. Call this after
		 * _all_ libcurl usage is done.
		 */);
	}
	public static void main_free(Object config) {
		ModernizedCProgram.curl_global_cleanup();
		do {
		} while (0);
		do {
		} while (0/* prevent valgrind from reporting still reachable mem from NSRP arenas */);
		ModernizedCProgram.free_globalconfig(/* prevent valgrind from reporting possibly lost memory (fd cache, ...) */config);
		ModernizedCProgram.config_free(config.getLast());
		config.setFirst(((Object)0));
		config.setLast(((Object)0));
	}
	public static void configure_terminal() {
		.memset(TerminalSettings, 0, );
		TerminalSettings.setHStdOut(.GetStdHandle((DWORD)(/* Enable VT output */true)));
		Object generatedHStdOut = TerminalSettings.getHStdOut();
		Object generatedDwOutputMode = TerminalSettings.getDwOutputMode();
		if ((generatedHStdOut != (HANDLE)(true)) && (.GetConsoleMode(generatedHStdOut, generatedDwOutputMode))) {
			.SetConsoleMode(generatedHStdOut, generatedDwOutputMode | -1024);
		} 
	}
	/*
	   * If we're running Windows, enable VT output.
	   * Note: VT mode flag can be set on any version of Windows, but VT
	   * processing only performed on Win10 >= Creators Update)
	   */
	public static void restore_terminal() {
		Object generatedHStdOut = TerminalSettings.getHStdOut();
		Object generatedDwOutputMode = TerminalSettings.getDwOutputMode();
		.SetConsoleMode(generatedHStdOut, generatedDwOutputMode);
	}
	/*
	** curl tool main function.
	*/
	public static int main(int argc, Object argv) {
		CURLcode result = .CURLE_OK;
		GlobalConfig global = new GlobalConfig();
		.memset(global, 0, );
		ModernizedCProgram.configure_terminal();
		ModernizedCProgram.main_checkfds();
		do {
		} while (/* Initialize memory tracking */0);
		result = ModernizedCProgram.main_init(/* Initialize the curl library - do not call any libcurl functions before
		     this point */global);
		if (argc == 2 && !.strcmp(argv[1], /* Undocumented diagnostic option to list the full paths of all loaded
		     modules, regardless of whether or not initialization succeeded. */"--dump-module-paths")) {
			curl_slist item = new curl_slist();
			curl_slist head = ModernizedCProgram.GetLoadedModulePaths();
			for (item = head; item; item = item.getNext()) {
				ModernizedCProgram.curl_mprintf("%s\n", item.getData());
			}
			ModernizedCProgram.curl_slist_free_all(head);
			if (!result) {
				ModernizedCProgram.main_free(global);
			} 
		}  else if (!/* WIN32 */result) {
			result = ModernizedCProgram.operate(global, argc, /* Start our curl operation */argv);
			ModernizedCProgram.main_free(/* Perform the main cleanup */global);
		} 
		ModernizedCProgram.restore_terminal();
		return (int)result/* ndef UNITTESTS */;
	}
	public static Object Curl_ftp_parselist_data_alloc() {
		return .Curl_ccalloc(1, );
	}
	public static void Curl_ftp_parselist_data_free(Object parserp) {
		ftp_parselist_data parser = parserp;
		if (parser) {
			ModernizedCProgram.Curl_fileinfo_cleanup(parser.getFile_data());
		} 
		.Curl_cfree(parser);
		parserp = ((Object)0);
	}
	public static  Curl_ftp_parselist_geterror(Object pl_data) {
		return pl_data.getError();
	}
	public static int ftp_pl_get_permission(Object str) {
		int permissions = 0;
		if (str[0] == /* USER */(byte)'r') {
			permissions |=  1 << 8;
		}  else if (str[0] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[1] == (byte)'w') {
			permissions |=  1 << 7;
		}  else if (str[1] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[2] == (byte)'x') {
			permissions |=  1 << 6;
		}  else if (str[2] == (byte)'s') {
			permissions |=  1 << 6;
			permissions |=  1 << 11;
		}  else if (str[2] == (byte)'S') {
			permissions |=  1 << 11;
		}  else if (str[2] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[3] == /* GROUP */(byte)'r') {
			permissions |=  1 << 5;
		}  else if (str[3] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[4] == (byte)'w') {
			permissions |=  1 << 4;
		}  else if (str[4] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[5] == (byte)'x') {
			permissions |=  1 << 3;
		}  else if (str[5] == (byte)'s') {
			permissions |=  1 << 3;
			permissions |=  1 << 10;
		}  else if (str[5] == (byte)'S') {
			permissions |=  1 << 10;
		}  else if (str[5] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[6] == /* others */(byte)'r') {
			permissions |=  1 << 2;
		}  else if (str[6] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[7] == (byte)'w') {
			permissions |=  1 << 1;
		}  else if (str[7] != (byte)'-') {
			permissions |=  -1024;
		} 
		if (str[8] == (byte)'x') {
			permissions |=  1;
		}  else if (str[8] == (byte)'t') {
			permissions |=  1;
			permissions |=  1 << 9;
		}  else if (str[8] == (byte)'T') {
			permissions |=  1 << 9;
		}  else if (str[8] != (byte)'-') {
			permissions |=  -1024;
		} 
		return permissions;
	}
	public static  ftp_pl_insert_finfo(Object conn, Object infop) {
		curl_fnmatch_callback compare = new curl_fnmatch_callback();
		WildcardData wc = conn.getData().getWildcard();
		ftp_wc ftpwc = wc.getProtdata();
		curl_llist llist = wc.getFilelist();
		ftp_parselist_data parser = ftpwc.getParser();
		bool add = 1;
		curl_fileinfo finfo = infop.getInfo();
		byte str = finfo.getB_data();
		finfo.setFilename(str + parser.getOffsets().getFilename());
		finfo.getStrings().setGroup(parser.getOffsets().getGroup() ? str + parser.getOffsets().getGroup() : ((Object)0));
		finfo.getStrings().setPerm(parser.getOffsets().getPerm() ? str + parser.getOffsets().getPerm() : ((Object)0));
		finfo.getStrings().setTarget(parser.getOffsets().getSymlink_target() ? str + parser.getOffsets().getSymlink_target() : ((Object)0));
		finfo.getStrings().setTime(str + parser.getOffsets().getTime());
		finfo.getStrings().setUser(parser.getOffsets().getUser() ? str + parser.getOffsets().getUser() : ((Object)0));
		compare = conn.getData().getSet().getFnmatch();
		if (!compare) {
			compare = ModernizedCProgram.Curl_fnmatch;
		} 
		ModernizedCProgram.Curl_set_in_callback(conn.getData(), /* filter pattern-corresponding filenames */.bool_true);
		if (.compare(conn.getData().getSet().getFnmatch_data(), wc.getPattern(), finfo.getFilename()) == 0) {
			if ((finfo.getFiletype() == .CURLFILETYPE_SYMLINK) && finfo.getStrings().getTarget() && (.strstr(finfo.getStrings().getTarget(), " -> "))) {
				add = 0;
			} 
		} else {
				add = 0;
		} 
		ModernizedCProgram.Curl_set_in_callback(conn.getData(), .bool_false);
		if (add) {
			ModernizedCProgram.Curl_llist_insert_next(llist, llist.getTail(), finfo, infop.getList());
		} else {
				ModernizedCProgram.Curl_fileinfo_cleanup(infop);
		} 
		ftpwc.getParser().setFile_data(((Object)0));
		return .CURLE_OK;
	}
	public static Object Curl_ftp_parselist(Object buffer, Object size, Object nmemb, Object connptr) {
		size_t bufflen = size * nmemb;
		connectdata conn = (connectdata)connptr;
		ftp_wc ftpwc = conn.getData().getWildcard().getProtdata();
		ftp_parselist_data parser = ftpwc.getParser();
		fileinfo infop = new fileinfo();
		curl_fileinfo finfo = new curl_fileinfo();
		long i = 0;
		CURLcode result = new CURLcode();
		size_t retsize = bufflen;
		if (parser.getError()) {
			;
		} 
		if (parser.getOs_type() == .OS_TYPE_UNKNOWN && bufflen > 0) {
			parser.setOs_type((buffer[0] >= (byte)'0' && buffer[0] <= /* considering info about FILE response format */(byte)'9') ? .OS_TYPE_WIN_NT : .OS_TYPE_UNIX);
		} 
		while (i < /* FSM */bufflen) {
			byte c = buffer[i];
			if (!parser.getFile_data()) {
				parser.setFile_data(ModernizedCProgram.Curl_fileinfo_alloc());
				if (!parser.getFile_data()) {
					parser.setError(.CURLE_OUT_OF_MEMORY);
					;
				} 
				parser.getFile_data().getInfo().setB_data(.Curl_cmalloc(160));
				if (!parser.getFile_data().getInfo().getB_data()) {
					parser.setError(.CURLE_OUT_OF_MEMORY);
					;
				} 
				parser.getFile_data().getInfo().setB_size(160);
				parser.setItem_offset(0);
				parser.setItem_length(0);
			} 
			infop = parser.getFile_data();
			finfo = infop.getInfo();
			finfo.getB_data()[finfo.getB_used()++] = c;
			if (finfo.getB_used() >= finfo.getB_size() - 1) {
				byte tmp = .Curl_crealloc(finfo.getB_data(), finfo.getB_size() + /* if it is important, extend buffer space for file data */160);
				if (tmp) {
					finfo.getB_size() += 160;
					finfo.setB_data(tmp);
				} else {
						ModernizedCProgram.Curl_fileinfo_cleanup(parser.getFile_data());
						parser.setFile_data(((Object)0));
						parser.setError(.CURLE_OUT_OF_MEMORY);
						;
				} 
			} 
			switch (parser.getOs_type()) {
			case .OS_TYPE_UNIX:
					switch (parser.getState().getUNIX().getMain()) {
					case .PL_UNIX_TOTALSIZE:
							switch (parser.getState().getUNIX().getSub().getTotal_dirsize()) {
							case .PL_UNIX_TOTALSIZE_INIT:
									if (c == (byte)'t') {
										parser.getState().getUNIX().getSub().setTotal_dirsize(.PL_UNIX_TOTALSIZE_READING);
										parser.getItem_length()++;
									} else {
											parser.getState().getUNIX().setMain(.PL_UNIX_FILETYPE);
											finfo.setB_used(/* start FSM again not considering size of directory */0);
											continue;
									} 
									break;
							case .PL_UNIX_TOTALSIZE_READING:
									parser.getItem_length()++;
									if (c == (byte)'\r') {
										parser.getItem_length()--;
										finfo.getB_used()--;
									}  else if (c == (byte)'\n') {
										finfo.getB_data()[parser.getItem_length() - 1] = 0;
										if (.strncmp("total ", finfo.getB_data(), 6) == 0) {
											byte endptr = finfo.getB_data() + 6/* here we can deal with directory size, pass the leading white
											                 spaces and then the digits */;
											while ((ModernizedCProgram.Curl_isspace((int)((byte)endptr)))) {
												endptr++;
											}
											while ((ModernizedCProgram.Curl_isdigit((int)((byte)endptr)))) {
												endptr++;
											}
											if (endptr != 0) {
												parser.setError(.CURLE_FTP_BAD_FILE_LIST);
												;
											} 
											parser.getState().getUNIX().setMain(.PL_UNIX_FILETYPE);
											finfo.setB_used(0);
										} else {
												parser.setError(.CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							}
							break;
					case .PL_UNIX_USER:
							switch (parser.getState().getUNIX().getSub().getUser()) {
							case .PL_UNIX_USER_PARSING:
									parser.getItem_length()++;
									if (c == (byte)' ') {
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 1] = 0;
										parser.getOffsets().setUser(parser.getItem_offset());
										parser.getState().getUNIX().setMain(.PL_UNIX_GROUP);
										parser.getState().getUNIX().getSub().setGroup(.PL_UNIX_GROUP_PRESPACE);
										parser.setItem_offset(0);
										parser.setItem_length(0);
									} 
									break;
							case .PL_UNIX_USER_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(finfo.getB_used() - 1);
										parser.setItem_length(1);
										parser.getState().getUNIX().getSub().setUser(.PL_UNIX_USER_PARSING);
									} 
									break;
							}
							break;
					case .PL_UNIX_SIZE:
							switch (parser.getState().getUNIX().getSub().getSize()) {
							case .PL_UNIX_SIZE_NUMBER:
									parser.getItem_length()++;
									if (c == (byte)' ') {
										byte p;
										curl_off_t fsize = new curl_off_t();
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 1] = 0;
										if (!ModernizedCProgram.curlx_strtoofft(finfo.getB_data() + parser.getItem_offset(), p, 10, fsize)) {
											if (p[0] == (byte)'\0' && fsize != -1024 && fsize != (--1024 - -1024)) {
												parser.getFile_data().getInfo().getFlags() |=  (1 << 6);
												parser.getFile_data().getInfo().setSize(fsize);
											} 
											parser.setItem_length(0);
											parser.setItem_offset(0);
											parser.getState().getUNIX().setMain(.PL_UNIX_TIME);
											parser.getState().getUNIX().getSub().setTime(.PL_UNIX_TIME_PREPART1);
										} 
									}  else if (!(ModernizedCProgram.Curl_isdigit((int)((byte)c)))) {
										parser.setError(.CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							case .PL_UNIX_SIZE_PRESPACE:
									if (c != (byte)' ') {
										if (c >= (byte)'0' && c <= (byte)'9') {
											parser.setItem_offset(finfo.getB_used() - 1);
											parser.setItem_length(1);
											parser.getState().getUNIX().getSub().setSize(.PL_UNIX_SIZE_NUMBER);
										} else {
												parser.setError(.CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							}
							break;
					case .PL_UNIX_PERMISSION:
							parser.getItem_length()++;
							if (parser.getItem_length() <= 9) {
								if (!.strchr("rwx-tTsS", c)) {
									parser.setError(.CURLE_FTP_BAD_FILE_LIST);
									;
								} 
							}  else if (parser.getItem_length() == 10) {
								int perm;
								if (c != (byte)' ') {
									parser.setError(.CURLE_FTP_BAD_FILE_LIST);
									;
								} 
								finfo.getB_data()[10] = /* terminate permissions */0;
								perm = ModernizedCProgram.ftp_pl_get_permission(finfo.getB_data() + parser.getItem_offset());
								if (perm & -1024) {
									parser.setError(.CURLE_FTP_BAD_FILE_LIST);
									;
								} 
								parser.getFile_data().getInfo().getFlags() |=  (1 << 3);
								parser.getFile_data().getInfo().setPerm(perm);
								parser.getOffsets().setPerm(parser.getItem_offset());
								parser.setItem_length(0);
								parser.getState().getUNIX().setMain(.PL_UNIX_HLINKS);
								parser.getState().getUNIX().getSub().setHlinks(.PL_UNIX_HLINKS_PRESPACE);
							} 
							break;
					case .PL_UNIX_FILETYPE:
							switch (c) {
							case (byte)'b':
									finfo.setFiletype(.CURLFILETYPE_DEVICE_BLOCK);
									break;
							case (byte)'s':
									finfo.setFiletype(.CURLFILETYPE_SOCKET);
									break;
							case (byte)'p':
									finfo.setFiletype(.CURLFILETYPE_NAMEDPIPE);
									break;
							case (byte)'c':
									finfo.setFiletype(.CURLFILETYPE_DEVICE_CHAR);
									break;
							case (byte)'-':
									finfo.setFiletype(.CURLFILETYPE_FILE);
									break;
							case (byte)'D':
									finfo.setFiletype(.CURLFILETYPE_DOOR);
									break;
							case (byte)'l':
									finfo.setFiletype(.CURLFILETYPE_SYMLINK);
									break;
							case (byte)'d':
									finfo.setFiletype(.CURLFILETYPE_DIRECTORY);
									break;
							default:
									parser.setError(.CURLE_FTP_BAD_FILE_LIST);
									;
							}
							parser.getState().getUNIX().setMain(.PL_UNIX_PERMISSION);
							parser.setItem_length(0);
							parser.setItem_offset(1);
							break;
					case .PL_UNIX_TIME:
							switch (parser.getState().getUNIX().getSub().getTime()) {
							case .PL_UNIX_TIME_PREPART2:
									parser.getItem_length()++;
									if (c != (byte)' ') {
										if ((ModernizedCProgram.Curl_isalnum((int)((byte)c)))) {
											parser.getState().getUNIX().getSub().setTime(.PL_UNIX_TIME_PART2);
										} else {
												parser.setError(.CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							case .PL_UNIX_TIME_PART1:
									parser.getItem_length()++;
									if (c == (byte)' ') {
										parser.getState().getUNIX().getSub().setTime(.PL_UNIX_TIME_PREPART2);
									}  else if (!(ModernizedCProgram.Curl_isalnum((int)((byte)c))) && c != (byte)'.') {
										parser.setError(.CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							case .PL_UNIX_TIME_PART3:
									parser.getItem_length()++;
									if (c == (byte)' ') {
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 1] = 0;
										parser.getOffsets().setTime(parser.getItem_offset());
										if (finfo.getFiletype() == .CURLFILETYPE_SYMLINK) {
											parser.getState().getUNIX().setMain(.PL_UNIX_SYMLINK);
											parser.getState().getUNIX().getSub().setSymlink(.PL_UNIX_SYMLINK_PRESPACE);
										} else {
												parser.getState().getUNIX().setMain(.PL_UNIX_FILENAME);
												parser.getState().getUNIX().getSub().setFilename(.PL_UNIX_FILENAME_PRESPACE);
										} 
									}  else if (!(ModernizedCProgram.Curl_isalnum((int)((byte)c))) && c != (byte)'.' && c != (byte)':') {
										parser.setError(.CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							case .PL_UNIX_TIME_PART2:
									parser.getItem_length()++;
									if (c == (byte)' ') {
										parser.getState().getUNIX().getSub().setTime(.PL_UNIX_TIME_PREPART3);
									}  else if (!(ModernizedCProgram.Curl_isalnum((int)((byte)c))) && c != (byte)'.') {
										parser.setError(.CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							case .PL_UNIX_TIME_PREPART3:
									parser.getItem_length()++;
									if (c != (byte)' ') {
										if ((ModernizedCProgram.Curl_isalnum((int)((byte)c)))) {
											parser.getState().getUNIX().getSub().setTime(.PL_UNIX_TIME_PART3);
										} else {
												parser.setError(.CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							case .PL_UNIX_TIME_PREPART1:
									if (c != (byte)' ') {
										if ((ModernizedCProgram.Curl_isalnum((int)((byte)c)))) {
											parser.setItem_offset(finfo.getB_used() - 1);
											parser.setItem_length(1);
											parser.getState().getUNIX().getSub().setTime(.PL_UNIX_TIME_PART1);
										} else {
												parser.setError(.CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							}
							break;
					case .PL_UNIX_HLINKS:
							switch (parser.getState().getUNIX().getSub().getHlinks()) {
							case .PL_UNIX_HLINKS_PRESPACE:
									if (c != (byte)' ') {
										if (c >= (byte)'0' && c <= (byte)'9') {
											parser.setItem_offset(finfo.getB_used() - 1);
											parser.setItem_length(1);
											parser.getState().getUNIX().getSub().setHlinks(.PL_UNIX_HLINKS_NUMBER);
										} else {
												parser.setError(.CURLE_FTP_BAD_FILE_LIST);
												;
										} 
									} 
									break;
							case .PL_UNIX_HLINKS_NUMBER:
									parser.getItem_length()++;
									if (c == (byte)' ') {
										byte p;
										long hlinks;
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 1] = 0;
										hlinks = .strtol(finfo.getB_data() + parser.getItem_offset(), p, 10);
										if (p[0] == (byte)'\0' && hlinks != -1024 && hlinks != (--1024 - 1)) {
											parser.getFile_data().getInfo().getFlags() |=  (1 << 7);
											parser.getFile_data().getInfo().setHardlinks(hlinks);
										} 
										parser.setItem_length(0);
										parser.setItem_offset(0);
										parser.getState().getUNIX().setMain(.PL_UNIX_USER);
										parser.getState().getUNIX().getSub().setUser(.PL_UNIX_USER_PRESPACE);
									}  else if (c < (byte)'0' || c > (byte)'9') {
										parser.setError(.CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							}
							break;
					case .PL_UNIX_SYMLINK:
							switch (parser.getState().getUNIX().getSub().getSymlink()) {
							case .PL_UNIX_SYMLINK_PRETARGET2:
									parser.getItem_length()++;
									if (c == (byte)'>') {
										parser.getState().getUNIX().getSub().setSymlink(.PL_UNIX_SYMLINK_PRETARGET3);
									}  else if (c == (byte)'\r' || c == (byte)'\n') {
										parser.setError(.CURLE_FTP_BAD_FILE_LIST);
										;
									} else {
											parser.getState().getUNIX().getSub().setSymlink(.PL_UNIX_SYMLINK_NAME);
									} 
									break;
							case .PL_UNIX_SYMLINK_WINDOWSEOL:
									if (c == (byte)'\n') {
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 1] = 0;
										parser.getOffsets().setSymlink_target(parser.getItem_offset());
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
										parser.getState().getUNIX().setMain(.PL_UNIX_FILETYPE);
									} else {
											parser.setError(.CURLE_FTP_BAD_FILE_LIST);
											;
									} 
									break;
							case .PL_UNIX_SYMLINK_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(finfo.getB_used() - 1);
										parser.setItem_length(1);
										parser.getState().getUNIX().getSub().setSymlink(.PL_UNIX_SYMLINK_NAME);
									} 
									break;
							case .PL_UNIX_SYMLINK_PRETARGET1:
									parser.getItem_length()++;
									if (c == (byte)'-') {
										parser.getState().getUNIX().getSub().setSymlink(.PL_UNIX_SYMLINK_PRETARGET2);
									}  else if (c == (byte)'\r' || c == (byte)'\n') {
										parser.setError(.CURLE_FTP_BAD_FILE_LIST);
										;
									} else {
											parser.getState().getUNIX().getSub().setSymlink(.PL_UNIX_SYMLINK_NAME);
									} 
									break;
							case .PL_UNIX_SYMLINK_PRETARGET4:
									if (c != (byte)'\r' && c != (byte)'\n') {
										parser.getState().getUNIX().getSub().setSymlink(.PL_UNIX_SYMLINK_TARGET);
										parser.setItem_offset(finfo.getB_used() - 1);
										parser.setItem_length(1);
									} else {
											parser.setError(.CURLE_FTP_BAD_FILE_LIST);
											;
									} 
									break;
							case .PL_UNIX_SYMLINK_PRETARGET3:
									parser.getItem_length()++;
									if (c == (byte)' ') {
										parser.getState().getUNIX().getSub().setSymlink(.PL_UNIX_SYMLINK_PRETARGET4);
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 4] = /* now place where is symlink following */0;
										parser.getOffsets().setFilename(parser.getItem_offset());
										parser.setItem_length(0);
										parser.setItem_offset(0);
									}  else if (c == (byte)'\r' || c == (byte)'\n') {
										parser.setError(.CURLE_FTP_BAD_FILE_LIST);
										;
									} else {
											parser.getState().getUNIX().getSub().setSymlink(.PL_UNIX_SYMLINK_NAME);
									} 
									break;
							case .PL_UNIX_SYMLINK_TARGET:
									parser.getItem_length()++;
									if (c == (byte)'\r') {
										parser.getState().getUNIX().getSub().setSymlink(.PL_UNIX_SYMLINK_WINDOWSEOL);
									}  else if (c == (byte)'\n') {
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 1] = 0;
										parser.getOffsets().setSymlink_target(parser.getItem_offset());
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
										parser.getState().getUNIX().setMain(.PL_UNIX_FILETYPE);
									} 
									break;
							case .PL_UNIX_SYMLINK_NAME:
									parser.getItem_length()++;
									if (c == (byte)' ') {
										parser.getState().getUNIX().getSub().setSymlink(.PL_UNIX_SYMLINK_PRETARGET1);
									}  else if (c == (byte)'\r' || c == (byte)'\n') {
										parser.setError(.CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							}
							break;
					case .PL_UNIX_FILENAME:
							switch (parser.getState().getUNIX().getSub().getFilename()) {
							case .PL_UNIX_FILENAME_WINDOWSEOL:
									if (c == (byte)'\n') {
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 1] = 0;
										parser.getOffsets().setFilename(parser.getItem_offset());
										parser.getState().getUNIX().setMain(.PL_UNIX_FILETYPE);
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
									} else {
											parser.setError(.CURLE_FTP_BAD_FILE_LIST);
											;
									} 
									break;
							case .PL_UNIX_FILENAME_NAME:
									parser.getItem_length()++;
									if (c == (byte)'\r') {
										parser.getState().getUNIX().getSub().setFilename(.PL_UNIX_FILENAME_WINDOWSEOL);
									}  else if (c == (byte)'\n') {
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 1] = 0;
										parser.getOffsets().setFilename(parser.getItem_offset());
										parser.getState().getUNIX().setMain(.PL_UNIX_FILETYPE);
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
									} 
									break;
							case .PL_UNIX_FILENAME_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(finfo.getB_used() - 1);
										parser.setItem_length(1);
										parser.getState().getUNIX().getSub().setFilename(.PL_UNIX_FILENAME_NAME);
									} 
									break;
							}
							break;
					case .PL_UNIX_GROUP:
							switch (parser.getState().getUNIX().getSub().getGroup()) {
							case .PL_UNIX_GROUP_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(finfo.getB_used() - 1);
										parser.setItem_length(1);
										parser.getState().getUNIX().getSub().setGroup(.PL_UNIX_GROUP_NAME);
									} 
									break;
							case .PL_UNIX_GROUP_NAME:
									parser.getItem_length()++;
									if (c == (byte)' ') {
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 1] = 0;
										parser.getOffsets().setGroup(parser.getItem_offset());
										parser.getState().getUNIX().setMain(.PL_UNIX_SIZE);
										parser.getState().getUNIX().getSub().setSize(.PL_UNIX_SIZE_PRESPACE);
										parser.setItem_offset(0);
										parser.setItem_length(0);
									} 
									break;
							}
							break;
					}
					break;
			case .OS_TYPE_WIN_NT:
					switch (parser.getState().getNT().getMain()) {
					case .PL_WINNT_FILENAME:
							switch (parser.getState().getNT().getSub().getFilename()) {
							case .PL_WINNT_FILENAME_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(finfo.getB_used() - 1);
										parser.setItem_length(1);
										parser.getState().getNT().getSub().setFilename(.PL_WINNT_FILENAME_CONTENT);
									} 
									break;
							case .PL_WINNT_FILENAME_CONTENT:
									parser.getItem_length()++;
									if (c == (byte)'\r') {
										parser.getState().getNT().getSub().setFilename(.PL_WINNT_FILENAME_WINEOL);
										finfo.getB_data()[finfo.getB_used() - 1] = 0;
									}  else if (c == (byte)'\n') {
										parser.getOffsets().setFilename(parser.getItem_offset());
										finfo.getB_data()[finfo.getB_used() - 1] = 0;
										parser.getOffsets().setFilename(parser.getItem_offset());
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
										parser.getState().getNT().setMain(.PL_WINNT_DATE);
										parser.getState().getNT().getSub().setFilename(.PL_WINNT_FILENAME_PRESPACE);
									} 
									break;
							case .PL_WINNT_FILENAME_WINEOL:
									if (c == (byte)'\n') {
										parser.getOffsets().setFilename(parser.getItem_offset());
										result = ModernizedCProgram.ftp_pl_insert_finfo(conn, infop);
										if (result) {
											parser.setError(result);
											;
										} 
										parser.getState().getNT().setMain(.PL_WINNT_DATE);
										parser.getState().getNT().getSub().setFilename(.PL_WINNT_FILENAME_PRESPACE);
									} else {
											parser.setError(.CURLE_FTP_BAD_FILE_LIST);
											;
									} 
									break;
							}
							break;
					case .PL_WINNT_DATE:
							parser.getItem_length()++;
							if (parser.getItem_length() < 9) {
								if (!.strchr("0123456789-", /* only simple control */c)) {
									parser.setError(.CURLE_FTP_BAD_FILE_LIST);
									;
								} 
							}  else if (parser.getItem_length() == 9) {
								if (c == (byte)' ') {
									parser.getState().getNT().setMain(.PL_WINNT_TIME);
									parser.getState().getNT().getSub().setTime(.PL_WINNT_TIME_PRESPACE);
								} else {
										parser.setError(.CURLE_FTP_BAD_FILE_LIST);
										;
								} 
							} else {
									parser.setError(.CURLE_FTP_BAD_FILE_LIST);
									;
							} 
							break;
					case .PL_WINNT_TIME:
							parser.getItem_length()++;
							switch (parser.getState().getNT().getSub().getTime()) {
							case .PL_WINNT_TIME_PRESPACE:
									if (!(ModernizedCProgram.Curl_isspace((int)((byte)c)))) {
										parser.getState().getNT().getSub().setTime(.PL_WINNT_TIME_TIME);
									} 
									break;
							case .PL_WINNT_TIME_TIME:
									if (c == (byte)' ') {
										parser.getOffsets().setTime(parser.getItem_offset());
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 1] = 0;
										parser.getState().getNT().setMain(.PL_WINNT_DIRORSIZE);
										parser.getState().getNT().getSub().setDirorsize(.PL_WINNT_DIRORSIZE_PRESPACE);
										parser.setItem_length(0);
									}  else if (!.strchr("APM0123456789:", c)) {
										parser.setError(.CURLE_FTP_BAD_FILE_LIST);
										;
									} 
									break;
							}
							break;
					case .PL_WINNT_DIRORSIZE:
							switch (parser.getState().getNT().getSub().getDirorsize()) {
							case .PL_WINNT_DIRORSIZE_PRESPACE:
									if (c != (byte)' ') {
										parser.setItem_offset(finfo.getB_used() - 1);
										parser.setItem_length(1);
										parser.getState().getNT().getSub().setDirorsize(.PL_WINNT_DIRORSIZE_CONTENT);
									} 
									break;
							case .PL_WINNT_DIRORSIZE_CONTENT:
									parser.getItem_length()++;
									if (c == (byte)' ') {
										finfo.getB_data()[parser.getItem_offset() + parser.getItem_length() - 1] = 0;
										if (.strcmp("<DIR>", finfo.getB_data() + parser.getItem_offset()) == 0) {
											finfo.setFiletype(.CURLFILETYPE_DIRECTORY);
											finfo.setSize(0);
										} else {
												byte endptr;
												if (ModernizedCProgram.curlx_strtoofft(finfo.getB_data() + parser.getItem_offset(), endptr, 10, finfo.getSize())) {
													parser.setError(.CURLE_FTP_BAD_FILE_LIST);
													;
												} 
												parser.getFile_data().getInfo().setFiletype(/* correct file type */.CURLFILETYPE_FILE);
										} 
										parser.getFile_data().getInfo().getFlags() |=  (1 << 6);
										parser.setItem_length(0);
										parser.getState().getNT().setMain(.PL_WINNT_FILENAME);
										parser.getState().getNT().getSub().setFilename(.PL_WINNT_FILENAME_PRESPACE);
									} 
									break;
							}
							break;
					}
					break;
			default:
					retsize = bufflen + 1;
					;
			}
			i++;
		}
		return retsize;
		return retsize/* CURL_DISABLE_FTP */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2015, Steve Holme, <steve_holme@hotmail.com>.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * Curl_des_set_odd_parity()
	 *
	 * This is used to apply odd parity to the given byte array. It is typically
	 * used by when a cryptography engines doesn't have it's own version.
	 *
	 * The function is a port of the Java based oddParity() function over at:
	 *
	 * https://davenport.sourceforge.io/ntlm.html
	 *
	 * Parameters:
	 *
	 * bytes       [in/out] - The data whose parity bits are to be adjusted for
	 *                        odd parity.
	 * len         [out]    - The length of the data.
	 */
	public static void Curl_des_set_odd_parity(Object bytes, Object len) {
		size_t i = new size_t();
		for (i = 0; i < len; i++) {
			byte b = bytes[i];
			bool needs_parity = (((b >> 7) ^ (b >> 6) ^ (b >> 5) ^ (b >> 4) ^ (b >> 3) ^ (b >> 2) ^ (b >> 1)) & -1024) == 0;
			if (needs_parity) {
				bytes[i] |=  -1024;
			} else {
					bytes[i] &=  -1024/* USE_NTLM && !USE_OPENSSL */;
			} 
		}
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2015, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	 * curlx_nonblock() set the given socket to either blocking or non-blocking
	 * mode based on the 'nonblock' boolean argument. This function is highly
	 * portable.
	 */
	/* operate on this */
	public static int curlx_nonblock(Object sockfd, int nonblock) {
		long flags = nonblock ? -1024 : /* older unix versions *//* Windows */-1024;
		return .ioctlsocket(sockfd, (-1024 | (((long) & -1024) << 16) | (((byte)'f') << 8) | (true)), flags/* Amiga *//* BeOS */);
	}
	/* TRUE or FALSE */
	/* returns success */
	/* most recent unix versions */
	public static Object curl_share_init() {
		Curl_share share = .Curl_ccalloc(1, );
		if (share) {
			share.getSpecifier() |=  (1 << .CURL_LOCK_DATA_SHARE);
			if (ModernizedCProgram.Curl_mk_dnscache(share.getHostcache())) {
				.Curl_cfree(share);
				return ((Object)0);
			} 
		} 
		return share;
	}
	public static  curl_share_setopt(Object share,  option) {
		va_list param = new va_list();
		int type;
		curl_lock_function lockfunc = new curl_lock_function();
		curl_unlock_function unlockfunc = new curl_unlock_function();
		Object ptr;
		CURLSHcode res = .CURLSHE_OK;
		if (share.getDirty()) {
			return .CURLSHE_IN_USE;
		} 
		.__builtin_va_start(param, option);
		switch (option) {
		case .CURLSHOPT_UNSHARE:
				type = (int)/* this is a type this share will no longer share */param;
				share.getSpecifier() &=  ~(1 << type);
				switch (type) {
				case .CURL_LOCK_DATA_COOKIE:
						if (share.getCookies()) {
							ModernizedCProgram.Curl_cookie_cleanup(share.getCookies());
							share.setCookies(((Object)0/* CURL_DISABLE_HTTP */));
						} 
						break;
				case .CURL_LOCK_DATA_DNS:
						break;
				case .CURL_LOCK_DATA_SSL_SESSION:
						res = .CURLSHE_NOT_BUILT_IN;
						break;
				case .CURL_LOCK_DATA_CONNECT:
						break;
				default:
						res = .CURLSHE_BAD_OPTION;
						break;
				}
				break;
		case .CURLSHOPT_USERDATA:
				ptr = (int)param;
				share.setClientdata(ptr);
				break;
		case .CURLSHOPT_UNLOCKFUNC:
				unlockfunc = (int)param;
				share.setUnlockfunc(unlockfunc);
				break;
		case .CURLSHOPT_LOCKFUNC:
				lockfunc = (int)param;
				share.setLockfunc(lockfunc);
				break;
		case .CURLSHOPT_SHARE:
				type = (int)/* this is a type this share will share */param;
				share.getSpecifier() |=  (1 << type);
				switch (type) {
				case .CURL_LOCK_DATA_COOKIE:
						if (!share.getCookies()) {
							share.setCookies(ModernizedCProgram.Curl_cookie_init(((Object)0), ((Object)0), ((Object)0), 1));
							if (!share.getCookies()) {
								res = .CURLSHE_NOMEM/* CURL_DISABLE_HTTP */;
							} 
						} 
						break;
				case /* not supported (yet) */.CURL_LOCK_DATA_CONNECT:
						if (ModernizedCProgram.Curl_conncache_init(share.getConn_cache(), 103)) {
							res = .CURLSHE_NOMEM;
						} 
						break;
				case .CURL_LOCK_DATA_SSL_SESSION:
						res = .CURLSHE_NOT_BUILT_IN;
						break;
				case .CURL_LOCK_DATA_DNS:
						break;
				case .CURL_LOCK_DATA_PSL:
						res = .CURLSHE_NOT_BUILT_IN;
						break;
				default:
						res = .CURLSHE_BAD_OPTION;
				}
				break;
		default:
				res = .CURLSHE_BAD_OPTION;
				break;
		}
		.__builtin_va_end(param);
		return res;
	}
	public static  curl_share_cleanup(Object share) {
		if (share == ((Object)0)) {
			return .CURLSHE_INVALID;
		} 
		if (share.getLockfunc()) {
			.UNRECOGNIZEDFUNCTIONNAME(((Object)0), .CURL_LOCK_DATA_SHARE, .CURL_LOCK_ACCESS_SINGLE, share.getClientdata());
		} 
		if (share.getDirty()) {
			if (share.getUnlockfunc()) {
				.UNRECOGNIZEDFUNCTIONNAME(((Object)0), .CURL_LOCK_DATA_SHARE, share.getClientdata());
			} 
			return .CURLSHE_IN_USE;
		} 
		ModernizedCProgram.Curl_conncache_close_all_connections(share.getConn_cache());
		ModernizedCProgram.Curl_conncache_destroy(share.getConn_cache());
		ModernizedCProgram.Curl_hash_destroy(share.getHostcache());
		ModernizedCProgram.Curl_cookie_cleanup(share.getCookies());
		;
		if (share.getUnlockfunc()) {
			.UNRECOGNIZEDFUNCTIONNAME(((Object)0), .CURL_LOCK_DATA_SHARE, share.getClientdata());
		} 
		.Curl_cfree(share);
		return .CURLSHE_OK;
	}
	public static  Curl_share_lock(Object data,  type,  accesstype) {
		Curl_share share = data.getShare();
		if (share == ((Object)0)) {
			return .CURLSHE_INVALID;
		} 
		if (share.getSpecifier() & (1 << type)) {
			if (share.getLockfunc()) {
				.UNRECOGNIZEDFUNCTIONNAME(data, type, accesstype, share.getClientdata());
			} 
		} 
		return /* else if we don't share this, pretend successful lock */.CURLSHE_OK;
	}
	public static  Curl_share_unlock(Object data,  type) {
		Curl_share share = data.getShare();
		if (share == ((Object)0)) {
			return .CURLSHE_INVALID;
		} 
		if (share.getSpecifier() & (1 << type)) {
			if (share.getUnlockfunc()) {
				.UNRECOGNIZEDFUNCTIONNAME(data, type, share.getClientdata());
			} 
		} 
		return .CURLSHE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/*
	 * Forward declarations.
	 */
	public static  gopher_do(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		curl_socket_t sockfd = conn.getSock()[0];
		byte gopherpath;
		byte path = data.getState().getUp().getPath();
		byte query = data.getState().getUp().getQuery();
		byte sel = ((Object)0);
		byte sel_org = ((Object)0);
		ssize_t amount = new ssize_t();
		ssize_t k = new ssize_t();
		size_t len = new size_t();
		done = /* unconditionally */1;
		do {
		} while (/* path is guaranteed non-NULL */0);
		if (query) {
			gopherpath = ModernizedCProgram.curl_maprintf("%s?%s", path, query);
		} else {
				gopherpath = .Curl_cstrdup(path);
		} 
		if (!gopherpath) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		if (.strlen(gopherpath) <= /* Create selector. Degenerate cases: / and /1 => convert to "" */2) {
			sel = (byte)"";
			len = .strlen(sel);
			.Curl_cfree(gopherpath);
		} else {
				byte newp;
				newp = /* Otherwise, drop / and the first character (i.e., item type) ... */gopherpath;
				newp += 2;
				result = ModernizedCProgram.Curl_urldecode(data, newp, 0, sel, len, /* ... and finally unescape */0);
				.Curl_cfree(gopherpath);
				if (result) {
					return result;
				} 
				sel_org = sel;
		} 
		k = ModernizedCProgram.curlx_uztosz(/* We use Curl_write instead of Curl_sendf to make sure the entire buffer is
		     sent, which could be sizeable with long selectors. */len);
		for (; ; ) {
			result = ModernizedCProgram.Curl_write(conn, sockfd, sel, k, amount);
			if (!/* Which may not have written it all! */result) {
				result = ModernizedCProgram.Curl_client_write(conn, (1 << 1), sel, amount);
				if (result) {
					break;
				} 
				k -= amount;
				sel += amount;
				if (k < 1) {
					break;
				} 
			} else {
					break;
			} 
			if (ModernizedCProgram.Curl_socket_check((SOCKET)(~0), (SOCKET)(~0), sockfd, (time_t)100) < 0) {
				result = .CURLE_SEND_ERROR;
				break;
			} 
		}
		.Curl_cfree(sel_org);
		if (!result/* We can use Curl_sendf to send the terminal \r\n relatively safely and
		       save allocing another string/doing another _write loop. */) {
			result = ModernizedCProgram.Curl_sendf(sockfd, conn, "\r\n");
		} 
		if (result) {
			ModernizedCProgram.Curl_failf(data, "Failed sending Gopher request");
			return result;
		} 
		result = ModernizedCProgram.Curl_client_write(conn, (1 << 1), (byte)"\r\n", 2);
		if (result) {
			return result;
		} 
		ModernizedCProgram.Curl_setup_transfer(data, 0, -1, 0, -1);
		return .CURLE_OK/*CURL_DISABLE_GOPHER*/;
	}
	/*
	 * Gopher protocol handler.
	 * This is also a nice simple template to build off for simple
	 * connect-command-download protocols.
	 */
	public static int xferinfo_cb(Object clientp, Object dltotal, Object dlnow, Object ultotal, Object ulnow) {
		per_transfer per = clientp;
		per.setDltotal(dltotal);
		per.setDlnow(dlnow);
		per.setUltotal(ultotal);
		per.setUlnow(ulnow);
		return 0;
	}
	public static void progress_finalize(Object per) {
		ModernizedCProgram.all_dlalready += per.getDlnow();
		ModernizedCProgram.all_ulalready += per.getUlnow();
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* it includes http_chunks.h */
	/* it includes http_chunks.h */
	/* for the client write stuff */
	/* for Curl_convert_to_network prototype */
	/* The last #include files should be: */
	/*
	 * Chunk format (simplified):
	 *
	 * <HEX SIZE>[ chunk extension ] CRLF
	 * <DATA> CRLF
	 *
	 * Highlights from RFC2616 section 3.6 say:
	
	   The chunked encoding modifies the body of a message in order to
	   transfer it as a series of chunks, each with its own size indicator,
	   followed by an OPTIONAL trailer containing entity-header fields. This
	   allows dynamically produced content to be transferred along with the
	   information necessary for the recipient to verify that it has
	   received the full message.
	
	       Chunked-Body   = *chunk
	                        last-chunk
	                        trailer
	                        CRLF
	
	       chunk          = chunk-size [ chunk-extension ] CRLF
	                        chunk-data CRLF
	       chunk-size     = 1*HEX
	       last-chunk     = 1*("0") [ chunk-extension ] CRLF
	
	       chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
	       chunk-ext-name = token
	       chunk-ext-val  = token | quoted-string
	       chunk-data     = chunk-size(OCTET)
	       trailer        = *(entity-header CRLF)
	
	   The chunk-size field is a string of hex digits indicating the size of
	   the chunk. The chunked encoding is ended by any chunk whose size is
	   zero, followed by the trailer, which is terminated by an empty line.
	
	 */
	/* Check for an ASCII hex digit.
	   We avoid the use of ISXDIGIT to accommodate non-ASCII hosts. */
	/* 0-9 */
	/* A-F */
	/* a-f */
	public static void Curl_httpchunk_init(Object conn) {
		Curl_chunker chunk = conn.getChunk();
		chunk.setHexindex(/* start at 0 */0);
		chunk.setDataleft(/* no data left yet! */0);
		chunk.setState(/* we get hex first! */.CHUNK_HEX/*
		 * chunk_read() returns a OK for normal operations, or a positive return code
		 * for errors. STOP means this sequence of chunks is complete.  The 'wrote'
		 * argument is set to tell the caller how many bytes we actually passed to the
		 * client (for byte-counting and whatever).
		 *
		 * The states and the state-machine is further explained in the header file.
		 *
		 * This function always uses ASCII hex values to accommodate non-ASCII hosts.
		 * For example, 0x0d and 0x0a are used instead of '\r' and '\n'.
		 */);
	}
	public static  Curl_httpchunk_read(Object conn, Object datap, Object datalen, Object wrotep, Object extrap) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		Curl_chunker ch = conn.getChunk();
		SingleRequest k = data.getReq();
		size_t piece = new size_t();
		curl_off_t length = (curl_off_t)datalen;
		size_t wrote = (size_t)wrotep;
		wrote = /* nothing's written yet */0;
		if (data.getSet().getHttp_te_skip() && !k.getIgnorebody()) {
			result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), datap, datalen);
			if (result) {
				extrap = result;
				return .CHUNKE_PASSTHRU_ERROR;
			} 
		} 
		while (length) {
			switch (ch.getState()) {
			case .CHUNK_DATA/* We expect 'datasize' of data. We have 'length' right now, it can be
			         more or less than 'datasize'. Get the smallest piece.
			      */:
					piece = ModernizedCProgram.curlx_sotouz((ch.getDatasize() >= length) ? length : ch.getDatasize());
					if (!conn.getData().getSet().getHttp_te_skip() && !k.getIgnorebody()) {
						if (!conn.getData().getSet().getHttp_ce_skip() && k.getWriter_stack()) {
							result = ModernizedCProgram.Curl_unencode_write(conn, k.getWriter_stack(), datap, piece);
						} else {
								result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), datap, piece);
						} 
						if (result) {
							extrap = result;
							return .CHUNKE_PASSTHRU_ERROR;
						} 
					} 
					wrote += piece;
					ch.getDatasize() -= /* decrease amount left to expect */piece;
					datap += /* move read pointer forward */piece;
					length -= /* decrease space left in this round */piece;
					if (0 == ch.getDatasize()) {
						ch.setState(/* end of data this round, we now expect a trailing CRLF */.CHUNK_POSTLF);
					} 
					break;
			case .CHUNK_TRAILER:
					if ((datap == -1024) || (datap == -1024/* this is the end of a trailer, but if the trailer was zero bytes
					           there was no trailer and we move on */)) {
						if (conn.getTrlPos()) {
							conn.getTrailer()[conn.getTrlPos()++] = /* we allocate trailer with 3 bytes extra room to fit this */-1024;
							conn.getTrailer()[conn.getTrlPos()++] = -1024;
							conn.getTrailer()[conn.getTrlPos()] = 0;
							result = ();
							if (result/* Curl_convert_from_network calls failf if unsuccessful */) {
								return /* Treat it as a bad chunk */.CHUNKE_BAD_CHUNK;
							} 
							if (!data.getSet().getHttp_te_skip()) {
								result = ModernizedCProgram.Curl_client_write(conn, (1 << 1), conn.getTrailer(), conn.getTrlPos());
								if (result) {
									extrap = result;
									return .CHUNKE_PASSTHRU_ERROR;
								} 
							} 
							conn.setTrlPos(0);
							ch.setState(.CHUNK_TRAILER_CR);
							if (datap == -1024/* already on the LF */) {
								break;
							} 
						} else {
								ch.setState(/* no trailer, we're on the final CRLF pair */.CHUNK_TRAILER_POSTCR);
								break;
						} 
					} else {
							if (conn.getTrlPos() >= conn.getTrlMax()) {
								byte ptr;
								if (conn.getTrlMax()) {
									conn.getTrlMax() *= 2;
									ptr = .Curl_crealloc(conn.getTrailer(), conn.getTrlMax() + 3);
								} else {
										conn.setTrlMax(128);
										ptr = .Curl_cmalloc(conn.getTrlMax() + 3);
								} 
								if (!ptr) {
									return .CHUNKE_OUT_OF_MEMORY;
								} 
								conn.setTrailer(ptr);
							} 
							conn.getTrailer()[conn.getTrlPos()++] = datap;
					} 
					datap++;
					length--;
					break;
			case .CHUNK_POSTLF:
					if (datap == -1024) {
						ModernizedCProgram.Curl_httpchunk_init(/* The last one before we go back to hex state and start all over. *//* sets state back to CHUNK_HEX */conn);
					}  else if (datap != -1024) {
						return .CHUNKE_BAD_CHUNK;
					} 
					datap++;
					length--;
					break;
			case .CHUNK_HEX:
					if (ModernizedCProgram.Curl_isxdigit(datap)) {
						if (ch.getHexindex() < 16) {
							ch.getHexbuffer()[ch.getHexindex()] = datap;
							datap++;
							length--;
							ch.getHexindex()++;
						} else {
								return /* longer hex than we support */.CHUNKE_TOO_LONG_HEX;
						} 
					} else {
							byte endptr;
							if (0 == ch.getHexindex()) {
								return .CHUNKE_ILLEGAL_HEX;
							} 
							ch.getHexbuffer()[ch.getHexindex()] = /* length and datap are unmodified */0;
							result = ();
							if (result/* Curl_convert_from_network calls failf if unsuccessful */) {
								return /* Treat it as a bad hex character */.CHUNKE_ILLEGAL_HEX;
							} 
							if (ModernizedCProgram.curlx_strtoofft(ch.getHexbuffer(), endptr, 16, ch.getDatasize())) {
								return .CHUNKE_ILLEGAL_HEX;
							} 
							ch.setState(/* now wait for the CRLF */.CHUNK_LF);
					} 
					break;
			case .CHUNK_LF:
					if (datap == /* waiting for the LF after a chunk size */-1024) {
						if (0 == ch.getDatasize()) {
							ch.setState(/* now check for trailers */.CHUNK_TRAILER);
							conn.setTrlPos(0);
						} else {
								ch.setState(.CHUNK_DATA);
						} 
					} 
					datap++;
					length--;
					break;
			case .CHUNK_TRAILER_CR:
					if (datap == -1024) {
						ch.setState(.CHUNK_TRAILER_POSTCR);
						datap++;
						length--;
					} else {
							return .CHUNKE_BAD_CHUNK;
					} 
					break;
			case .CHUNK_STOP:
					if (datap == -1024) {
						length--;
						ch.setDataleft(ModernizedCProgram.curlx_sotouz(/* Record the length of any data left in the end of the buffer
						           even if there's no more chunks to read */length));
						return /* return stop */.CHUNKE_STOP;
					} else {
							return .CHUNKE_BAD_CHUNK;
					} 
			case .CHUNK_TRAILER_POSTCR/* We enter this state when a CR should arrive so we expect to
			         have to first pass a CR before we wait for LF */:
					if ((datap != -1024) && (datap != -1024)) {
						ch.setState(/* not a CR then it must be another header in the trailer */.CHUNK_TRAILER);
						break;
					} 
					if (datap == -1024) {
						/* skip if CR */datap++;
						length--;
					} 
					ch.setState(/* now wait for the final LF */.CHUNK_STOP);
					break;
			}
		}
		return .CHUNKE_OK;
	}
	public static Object Curl_chunked_strerror( code) {
		switch (code) {
		case .CHUNKE_OUT_OF_MEMORY:
				return "Out of memory"/* CURL_DISABLE_HTTP */;
		case .CHUNKE_BAD_ENCODING:
				return "Bad content-encoding found";
		case .CHUNKE_ILLEGAL_HEX:
				return "Illegal or missing hexadecimal sequence";
		case .CHUNKE_BAD_CHUNK:
				return "Malformed encoding found";
		case .CHUNKE_PASSTHRU_ERROR:
				do {
				} while (/* never used */0);
				return "";
		case .CHUNKE_TOO_LONG_HEX:
				return "Too long hexadecimal number";
		default:
				return "OK";
		}
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	public static void Curl_speedinit(Object data) {
		.memset(data.getState().getKeeps_speed(), 0, /*
		 * @unittest: 1606
		 */);
	}
	public static void ourWriteOut(Object curl, Object outs, Object writeinfo) {
		FILE stream = (_iob[1]);
		byte ptr = writeinfo;
		byte stringp = ((Object)0);
		long longinfo;
		double doubleinfo;
		while (ptr && ptr) {
			if ((byte)'%' == ptr && ptr[1]) {
				if ((byte)'%' == ptr[1]) {
					.fputc((byte)'%', /* an escaped %-letter */stream);
					ptr += 2;
				} else {
						byte end;
						if ((byte)'{' == ptr[1]) {
							byte keepit;
							int i;
							bool match = 0;
							end = .strchr(ptr, (byte)'}');
							ptr += /* pass the % and the { */2;
							if (!end) {
								.fputs("%{", stream);
								continue;
							} 
							keepit = end;
							end = /* zero terminate */0;
							for (i = 0; ModernizedCProgram.replacements[i].getName(); i++) {
								if (ModernizedCProgram.curl_strequal(ptr, ModernizedCProgram.replacements[i].getName())) {
									match = 1;
									switch (ModernizedCProgram.replacements[i].getId()) {
									case .VAR_STARTTRANSFER_TIME:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%.6f", doubleinfo);
											} 
											break;
									case .VAR_STDERR:
											stream = (_iob[2]);
											break;
									case .VAR_APPCONNECT_TIME:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%.6f", doubleinfo);
											} 
											break;
									case .VAR_PROXY_SSL_VERIFY_RESULT:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%ld", longinfo);
											} 
											break;
									case .VAR_PRIMARY_PORT:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%ld", longinfo);
											} 
											break;
									case .VAR_SCHEME:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%s", stringp);
											} 
											break;
									case .VAR_REQUEST_SIZE:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%ld", longinfo);
											} 
											break;
									case .VAR_SPEED_UPLOAD:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%.3f", doubleinfo);
											} 
											break;
									case .VAR_REDIRECT_TIME:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%.6f", doubleinfo);
											} 
											break;
									case .VAR_NAMELOOKUP_TIME:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%.6f", doubleinfo);
											} 
											break;
									case .VAR_EFFECTIVE_FILENAME:
											if (outs.getFilename()) {
												ModernizedCProgram.curl_mfprintf(stream, "%s", outs.getFilename());
											} 
											break;
									case .VAR_LOCAL_IP:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%s", stringp);
											} 
											break;
									case .VAR_HTTP_VERSION:
											if (.CURLE_OK == ) {
												byte version = "0";
												switch (longinfo) {
												case .CURL_HTTP_VERSION_1_0:
														version = "1.0";
														break;
												case .CURL_HTTP_VERSION_2_0:
														version = "2";
														break;
												case .CURL_HTTP_VERSION_1_1:
														version = "1.1";
														break;
												case .CURL_HTTP_VERSION_3:
														version = "3";
														break;
												}
												ModernizedCProgram.curl_mfprintf(stream, version);
											} 
											break;
									case .VAR_PRETRANSFER_TIME:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%.6f", doubleinfo);
											} 
											break;
									case .VAR_REDIRECT_COUNT:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%ld", longinfo);
											} 
											break;
									case .VAR_HTTP_CODE:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%03ld", longinfo);
											} 
											break;
									case .VAR_PRIMARY_IP:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%s", stringp);
											} 
											break;
									case .VAR_TOTAL_TIME:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%.6f", doubleinfo);
											} 
											break;
									case .VAR_SIZE_UPLOAD:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%.0f", doubleinfo);
											} 
											break;
									case .VAR_HEADER_SIZE:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%ld", longinfo);
											} 
											break;
									case .VAR_LOCAL_PORT:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%ld", longinfo);
											} 
											break;
									case .VAR_NUM_CONNECTS:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%ld", longinfo);
											} 
											break;
									case .VAR_CONNECT_TIME:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%.6f", doubleinfo);
											} 
											break;
									case .VAR_CONTENT_TYPE:
											if ((.CURLE_OK == ) && stringp) {
												.fputs(stringp, stream);
											} 
											break;
									case .VAR_REDIRECT_URL:
											if ((.CURLE_OK == ) && stringp) {
												.fputs(stringp, stream);
											} 
											break;
									case .VAR_SPEED_DOWNLOAD:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%.3f", doubleinfo);
											} 
											break;
									case .VAR_SSL_VERIFY_RESULT:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%ld", longinfo);
											} 
											break;
									case .VAR_STDOUT:
											stream = (_iob[1]);
											break;
									case .VAR_EFFECTIVE_URL:
											if ((.CURLE_OK == ) && stringp) {
												.fputs(stringp, stream);
											} 
											break;
									case .VAR_HTTP_CODE_PROXY:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%03ld", longinfo);
											} 
											break;
									case .VAR_SIZE_DOWNLOAD:
											if (.CURLE_OK == ) {
												ModernizedCProgram.curl_mfprintf(stream, "%.0f", doubleinfo);
											} 
											break;
									case .VAR_FTP_ENTRY_PATH:
											if ((.CURLE_OK == ) && stringp) {
												.fputs(stringp, stream);
											} 
											break;
									default:
											break;
									}
									break;
								} 
							}
							if (!match) {
								ModernizedCProgram.curl_mfprintf((_iob[2]), "curl: unknown --write-out variable: '%s'\n", ptr);
							} 
							ptr = end + /* pass the end */1;
							end = keepit;
						} else {
								.fputc((byte)'%', /* illegal syntax, then just output the characters that are used */stream);
								.fputc(ptr[1], stream);
								ptr += 2;
						} 
				} 
			}  else if ((byte)'\\' == ptr && ptr[1]) {
				switch (ptr[1]) {
				case (byte)'t':
						.fputc((byte)'\t', stream);
						break;
				case (byte)'r':
						.fputc((byte)'\r', stream);
						break;
				case (byte)'n':
						.fputc((byte)'\n', stream);
						break;
				default:
						.fputc(ptr, /* unknown, just output this */stream);
						.fputc(ptr[1], stream);
						break;
				}
				ptr += 2;
			} else {
					.fputc(ptr, stream);
					ptr++;
			} 
		}
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/*
	 * Curl_freeaddrinfo()
	 *
	 * This is used to free a linked list of Curl_addrinfo structs along
	 * with all its associated allocated storage. This function should be
	 * called once for each successful call to Curl_getaddrinfo_ex() or to
	 * any function call which actually allocates a Curl_addrinfo struct.
	 */
	/* workaround icc 9.1 optimizer issue */
	public static void Curl_freeaddrinfo(Object cahead) {
		Curl_addrinfo canext = new Curl_addrinfo();
		Curl_addrinfo ca = new Curl_addrinfo();
		for (ca = cahead; ca != ((Object)0); ca = canext) {
			.Curl_cfree(ca.getAi_addr());
			.Curl_cfree(ca.getAi_canonname());
			canext = ca.getAi_next();
			.Curl_cfree(ca/*
			 * Curl_getaddrinfo_ex()
			 *
			 * This is a wrapper function around system's getaddrinfo(), with
			 * the only difference that instead of returning a linked list of
			 * addrinfo structs this one returns a linked list of Curl_addrinfo
			 * ones. The memory allocated by this function *MUST* be free'd with
			 * Curl_freeaddrinfo().  For each successful call to this function
			 * there must be an associated call later to Curl_freeaddrinfo().
			 *
			 * There should be no single call to system's getaddrinfo() in the
			 * whole library, any such call should be 'routed' through this one.
			 *//* assume failure *//* traverse the addrinfo list *//* ignore elements with unsupported address family, *//* settle family-specific sockaddr structure size.  *//* ignore elements without required address info *//* ignore elements with bogus address size *//* copy each structure member individually, member ordering, *//* size, or padding might be different for each platform.    */);
		}
	}
	/* if the return list is empty, this becomes the first element */
	/* add this element last in the return list */
	/* destroy the addrinfo list */
	/* if we failed, also destroy the Curl_addrinfo list */
	/* rfc3493 conformant */
	/* rfc3493 obsoleted */
	/* This is not a CURLcode */
	/* HAVE_GETADDRINFO */
	/*
	 * Curl_he2ai()
	 *
	 * This function returns a pointer to the first element of a newly allocated
	 * Curl_addrinfo struct linked list filled with the data of a given hostent.
	 * Curl_addrinfo is meant to work like the addrinfo struct does for a IPv6
	 * stack, but usable also for IPv4, all hosts and environments.
	 *
	 * The memory allocated by this function *MUST* be free'd later on calling
	 * Curl_freeaddrinfo().  For each successful call to this function there
	 * must be an associated call later to Curl_freeaddrinfo().
	 *
	 *   Curl_addrinfo defined in "lib/curl_addrinfo.h"
	 *
	 *     struct Curl_addrinfo {
	 *       int                   ai_flags;
	 *       int                   ai_family;
	 *       int                   ai_socktype;
	 *       int                   ai_protocol;
	 *       curl_socklen_t        ai_addrlen;   * Follow rfc3493 struct addrinfo *
	 *       char                 *ai_canonname;
	 *       struct sockaddr      *ai_addr;
	 *       struct Curl_addrinfo *ai_next;
	 *     };
	 *     typedef struct Curl_addrinfo Curl_addrinfo;
	 *
	 *   hostent defined in <netdb.h>
	 *
	 *     struct hostent {
	 *       char    *h_name;
	 *       char    **h_aliases;
	 *       int     h_addrtype;
	 *       int     h_length;
	 *       char    **h_addr_list;
	 *     };
	 *
	 *   for backward compatibility:
	 *
	 *     #define h_addr  h_addr_list[0]
	 */
	public static Object Curl_he2ai(Object he, int port) {
		Curl_addrinfo ai = new Curl_addrinfo();
		Curl_addrinfo prevai = ((Object)0);
		Curl_addrinfo firstai = ((Object)0);
		sockaddr_in addr = new sockaddr_in();
		CURLcode result = .CURLE_OK;
		int i;
		byte curr;
		if (!he) {
			return ((Object)/* no input == no output! */0);
		} 
		do {
		} while (0);
		for (i = 0; (curr = he.getH_addr_list()[i]) != ((Object)0); i++) {
			size_t ss_size = new size_t();
			ss_size = ;
			ai = .Curl_ccalloc(1, );
			if (!ai) {
				result = .CURLE_OUT_OF_MEMORY;
				break;
			} 
			ai.setAi_canonname(.Curl_cstrdup(he.getH_name()));
			if (!ai.getAi_canonname()) {
				result = .CURLE_OUT_OF_MEMORY;
				.Curl_cfree(ai);
				break;
			} 
			ai.setAi_addr(.Curl_ccalloc(1, ss_size));
			if (!ai.getAi_addr()) {
				result = .CURLE_OUT_OF_MEMORY;
				.Curl_cfree(ai.getAi_canonname());
				.Curl_cfree(ai);
				break;
			} 
			if (!firstai) {
				firstai = /* store the pointer we want to return from this function */ai;
			} 
			if (prevai) {
				prevai.setAi_next(/* make the previous entry point to this */ai);
			} 
			ai.setAi_family(he.getH_addrtype());
			ai.setAi_socktype(/* we return all names as STREAM, so when using this address for TFTP
			       the type must be ignored and conn->socktype be used instead! */1);
			ai.setAi_addrlen((curl_socklen_t)ss_size);
			switch (ai.getAi_family()) {
			case 2:
					addr = (Object)ai.getAi_addr();
					.memcpy(addr.getSin_addr(), curr, );
					addr.setSin_family((int)(he.getH_addrtype()));
					addr.setSin_port(.htons((int)port));
					break;
			}
			prevai = ai;
		}
		if (result) {
			ModernizedCProgram.Curl_freeaddrinfo(firstai);
			firstai = ((Object)0);
		} 
		return firstai;
	}
	public static Object Curl_ip2addr(int af, Object inaddr, Object hostname, int port) {
		Curl_addrinfo ai = new Curl_addrinfo();
		hostent h = new hostent();
		namebuff buf = new namebuff();
		byte addrentry;
		byte hoststr;
		size_t addrsize = new size_t();
		do {
		} while (0);
		buf = .Curl_cmalloc();
		if (!buf) {
			return ((Object)0);
		} 
		hoststr = .Curl_cstrdup(hostname);
		if (!hoststr) {
			.Curl_cfree(buf);
			return ((Object)0);
		} 
		switch (af) {
		case 2:
				addrsize = ;
				addrentry = (Object)buf.getAddrentry().getIna4();
				.memcpy(addrentry, inaddr, );
				break;
		default:
				.Curl_cfree(hoststr);
				.Curl_cfree(buf);
				return ((Object)0);
		}
		h = buf.getHostentry();
		h.setH_name(hoststr);
		h.setH_aliases(((Object)0));
		h.setH_addrtype((int)af);
		h.setH_length((int)addrsize);
		h.setH_addr_list(buf.getH_addr_list()[0]);
		h.getH_addr_list()[0] = addrentry;
		h.getH_addr_list()[1] = ((Object)/* terminate list of entries */0);
		ai = ModernizedCProgram.Curl_he2ai(h, port);
		.Curl_cfree(hoststr);
		.Curl_cfree(buf);
		return ai/*
		 * Given an IPv4 or IPv6 dotted string address, this converts it to a proper
		 * allocated Curl_addrinfo struct and returns it.
		 */;
	}
	public static Object Curl_str2addr(Object address, int port) {
		in_addr in = new in_addr();
		if (ModernizedCProgram.Curl_inet_pton(2, address, in) > 0) {
			return ModernizedCProgram.Curl_ip2addr(2, in, address, /* This is a dotted IP address 123.123.123.123-style */port);
		} 
		return ((Object)/* This is a dotted IPv6 address ::1-style *//* bad input format */0/**
		 * Given a path to a Unix domain socket, return a newly allocated Curl_addrinfo
		 * struct initialized with this path.
		 * Set '*longpath' to TRUE if the error is a too long path.
		 *//* sun_path must be able to store the NUL-terminated path *//* assume reliable transport for HTTP *//* Abstract Unix domain socket have NULL prefix instead of suffix *//* copy NUL byte *//*
		 * curl_dbg_freeaddrinfo()
		 *
		 * This is strictly for memory tracing and are using the same style as the
		 * family otherwise present in memdebug.c. I put these ones here since they
		 * require a bunch of structs I didn't want to include in memdebug.c
		 *//* defined(CURLDEBUG) && defined(HAVE_FREEADDRINFO) *//*
		 * curl_dbg_getaddrinfo()
		 *
		 * This is strictly for memory tracing and are using the same style as the
		 * family otherwise present in memdebug.c. I put these ones here since they
		 * require a bunch of structs I didn't want to include in memdebug.c
		 *//* success *//* defined(CURLDEBUG) && defined(HAVE_GETADDRINFO) *//*
		 * Work-arounds the sin6_port is always zero bug on iOS 9.3.2 and Mac OS X
		 * 10.11.5.
		 *//* storage area for this info *//* storage area for this info */);
	}
	public static  sanitize_file_name(Object sanitized, Object file_name, int flags) {
		byte p;
		byte target;
		size_t len = new size_t();
		SANITIZEcode sc = new SANITIZEcode();
		size_t max_sanitized_len = new size_t();
		if (!sanitized) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		sanitized = ((Object)0);
		if (!file_name) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		if ((flags & (1 << 1))) {
			if (file_name[0] == (byte)'\\' && file_name[1] == (byte)'\\') {
				max_sanitized_len = 32767 - /* UNC prefixed path \\ (eg \\?\C:\foo) */1;
			} else {
					max_sanitized_len = 260 - 1;
			} 
		} else {
				max_sanitized_len = (260 - 1 > 255) ? 255 : 260 - /* The maximum length of a filename.
				       FILENAME_MAX is often the same as PATH_MAX, in other words it is 260 and
				       does not discount the path information therefore we shouldn't use it. */1;
		} 
		len = .strlen(file_name);
		if (len > max_sanitized_len) {
			if (!(flags & (1 << 3)) || ModernizedCProgram.truncate_dryrun(file_name, max_sanitized_len)) {
				return .SANITIZE_ERR_INVALID_PATH;
			} 
			len = max_sanitized_len;
		} 
		target = .malloc(len + 1);
		if (!target) {
			return .SANITIZE_ERR_OUT_OF_MEMORY;
		} 
		.strncpy(target, file_name, len);
		target[len] = (byte)'\0';
		if ((flags & (1 << 1)) && !.strncmp(target, "\\\\?\\", 4)) {
			p = target + /* Skip the literal path prefix \\?\ */4;
		} else {
				p = target;
		} 
		for (; p; ++/* replace control characters and other banned characters */p) {
			byte banned;
			if ((1 <= p && p <= 31) || (!(flags & ((1 << 0) | (1 << 1))) && p == (byte)':') || (!(flags & (1 << 1)) && (p == (byte)'/' || p == (byte)'\\'))) {
				p = (byte)'_';
				continue;
			} 
			for (banned = "|<>\"?*"; banned; ++banned) {
				if (p == banned) {
					p = (byte)'_';
					break;
				} 
			}
		}
		if (!(flags & (1 << 1)) && /* remove trailing spaces and periods if not allowing paths */len) {
			byte clip = ((Object)0);
			p = target[len];
			do {
				--p;
				if (p != (byte)' ' && p != (byte)'.') {
					break;
				} 
				clip = p;
			} while (p != target);
			if (clip) {
				clip = (byte)'\0';
				len = clip - target;
			} 
		} 
		if (!(flags & (1 << 2))) {
			sc = ModernizedCProgram.rename_if_reserved_dos_device_name(p, target, flags);
			.free(target);
			if (sc) {
				return sc;
			} 
			target = p;
			len = .strlen(target);
			if (len > max_sanitized_len) {
				.free(target);
				return .SANITIZE_ERR_INVALID_PATH;
			} 
		} 
		sanitized = target;
		return .SANITIZE_ERR_OK/*
		Test if truncating a path to a file will leave at least a single character in
		the filename. Filenames suffixed by an alternate data stream can't be
		truncated. This performs a dry run, nothing is modified.
		
		Good truncate_pos 9:    C:\foo\bar  =>  C:\foo\ba
		Good truncate_pos 6:    C:\foo      =>  C:\foo
		Good truncate_pos 5:    C:\foo      =>  C:\fo
		Bad* truncate_pos 5:    C:foo       =>  C:foo
		Bad truncate_pos 5:     C:\foo:ads  =>  C:\fo
		Bad truncate_pos 9:     C:\foo:ads  =>  C:\foo:ad
		Bad truncate_pos 5:     C:\foo\bar  =>  C:\fo
		Bad truncate_pos 5:     C:\foo\     =>  C:\fo
		Bad truncate_pos 7:     C:\foo\     =>  C:\foo\
		Error truncate_pos 7:   C:\foo      =>  (pos out of range)
		Bad truncate_pos 1:     C:\foo\     =>  C
		
		* C:foo is ambiguous, C could end up being a drive or file therefore something
		  like C:superlongfilename can't be truncated.
		
		Returns
		SANITIZE_ERR_OK: Good -- 'path' can be truncated
		SANITIZE_ERR_INVALID_PATH: Bad -- 'path' cannot be truncated
		!= SANITIZE_ERR_OK && != SANITIZE_ERR_INVALID_PATH: Error
		*/;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* keep this as LAST include */
	/*
	 * Macros ALWAYS_TRUE and ALWAYS_FALSE are used to avoid compiler warnings.
	 */
	/* cannot tell if file is a device */
	/* long file names always available */
	/* DJGPP 2.0 has _use_lfn() */
	/* long file names never available */
	/* _use_lfn(f) prototype */
	public static  truncate_dryrun(Object path, Object truncate_pos) {
		size_t len = new size_t();
		if (!path) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		len = .strlen(path);
		if (truncate_pos > len) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		if (!len || !truncate_pos) {
			return .SANITIZE_ERR_INVALID_PATH;
		} 
		if (.strpbrk(path[truncate_pos - 1], "\\/:")) {
			return .SANITIZE_ERR_INVALID_PATH;
		} 
		if (truncate_pos > /* C:\foo can be truncated but C:\foo:ads can't */1) {
			byte p = path[truncate_pos - 1];
			do {
				--p;
				if (p == (byte)':') {
					return .SANITIZE_ERR_INVALID_PATH;
				} 
			} while (p != path && p != (byte)'\\' && p != (byte)'/');
		} 
		return .SANITIZE_ERR_OK/* The functions msdosify, rename_if_dos_device_name and __crt0_glob_function
		 * were taken with modification from the DJGPP port of tar 1.12. They use
		 * algorithms originally from DJTAR.
		 *//*
		Extra sanitization MSDOS for file_name.
		
		This is a supporting function for sanitize_file_name.
		
		Warning: This is an MSDOS legacy function and was purposely written in a way
		that some path information may pass through. For example drive letter names
		(C:, D:, etc) are allowed to pass through. For sanitizing a filename use
		sanitize_file_name.
		
		Success: (SANITIZE_ERR_OK) *sanitized points to a sanitized copy of file_name.
		Failure: (!= SANITIZE_ERR_OK) *sanitized is NULL.
		*//* illegal in DOS *//* illegal in DOS & W95 *//* Support for Windows 9X VFAT systems, when available. *//* Get past the drive letter, if any. *//* Dots are special: DOS doesn't allow them as the leading character,
		         and a file name cannot have more than a single dot.  We leave the
		         first non-leading dot alone, unless it comes too close to the
		         beginning of the name: we want sh.lex.c to become sh_lex.c, not
		         sh.lex-c.  *//* Copy "./" and "../" verbatim.  */;
	}
	/* 5 is a heuristic ad-hoc'ery */
	/* replace previous dot */
	/* .c++, .h++ etc. */
	/* libg++ etc.  */
	/* dos_name is truncated, check that truncation requirements are met,
	       specifically truncating a filename suffixed by an alternate data stream
	       or truncating the entire filename is not allowed. */
	/* MSDOS || UNITTESTS */
	/*
	Rename file_name if it's a reserved dos device name.
	
	This is a supporting function for sanitize_file_name.
	
	Warning: This is an MSDOS legacy function and was purposely written in a way
	that some path information may pass through. For example drive letter names
	(C:, D:, etc) are allowed to pass through. For sanitizing a filename use
	sanitize_file_name.
	
	Success: (SANITIZE_ERR_OK) *sanitized points to a sanitized copy of file_name.
	Failure: (!= SANITIZE_ERR_OK) *sanitized is NULL.
	*/
	public static  rename_if_reserved_dos_device_name(Object sanitized, Object file_name, int flags) {
		/* We could have a file whose name is a device on MS-DOS.  Trying to
		   * retrieve such a file would fail at best and wedge us at worst.  We need
		   * to rename such files. */byte p;
		byte base;
		byte[] fname = new byte[260];
		if (!sanitized) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		sanitized = ((Object)0);
		if (!file_name) {
			return .SANITIZE_ERR_BAD_ARGUMENT;
		} 
		if ((flags & (1 << /* Ignore UNC prefixed paths, they are allowed to contain a reserved name. */1)) && file_name[0] == (byte)'\\' && file_name[1] == (byte)'\\') {
			size_t len = .strlen(file_name);
			sanitized = .malloc(len + 1);
			if (!sanitized) {
				return .SANITIZE_ERR_OUT_OF_MEMORY;
			} 
			.strncpy(sanitized, file_name, len + 1);
			return .SANITIZE_ERR_OK;
		} 
		if (.strlen(file_name) > 260 - 1 && (!(flags & (1 << 3)) || ModernizedCProgram.truncate_dryrun(file_name, 260 - 1))) {
			return .SANITIZE_ERR_INVALID_PATH;
		} 
		.strncpy(fname, file_name, 260 - 1);
		fname[260 - 1] = (byte)'\0';
		base = ModernizedCProgram.tool_basename((fname/* Rename reserved device names that are known to be accessible without \\.\
		     Examples: CON => _CON, CON.EXT => CON_EXT, CON:ADS => CON_ADS
		     https://support.microsoft.com/en-us/kb/74496
		     https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx
		     */));
		for (p = fname; p; p = (p == fname && fname != base ? base : ((Object)0))) {
			size_t p_len = new size_t();
			int x = (ModernizedCProgram.curl_strnequal(p, "CON", 3) || ModernizedCProgram.curl_strnequal(p, "PRN", 3) || ModernizedCProgram.curl_strnequal(p, "AUX", 3) || ModernizedCProgram.curl_strnequal(p, "NUL", 3)) ? 3 : (ModernizedCProgram.curl_strnequal(p, "CLOCK$", 6)) ? 6 : (ModernizedCProgram.curl_strnequal(p, "COM", 3) || ModernizedCProgram.curl_strnequal(p, "LPT", 3)) ? (((byte)'1' <= p[3] && p[3] <= (byte)'9') ? 4 : 3) : 0;
			if (!x) {
				continue;
			} 
			for (; p[x] == (byte)' '; ++x) {
				;
			}
			if (p[x] == (byte)'.') {
				p[x] = (byte)'_';
				continue;
			}  else if (p[x] == (byte)':') {
				if (!(flags & ((1 << 0) | (1 << 1)))) {
					p[x] = (byte)'_';
					continue;
				} 
				++x;
			}  else if (p[/* no match */x]) {
				continue;
			} 
			p_len = .strlen(/* p points to 'CON' or 'CON ' or 'CON:', etc */p);
			if (.strlen(fname) == 260 - /* Prepend a '_' */1) {
				--p_len;
				if (!(flags & (1 << 3)) || ModernizedCProgram.truncate_dryrun(p, p_len)) {
					return .SANITIZE_ERR_INVALID_PATH;
				} 
				p[p_len] = (byte)'\0';
			} 
			.memmove(p + 1, p, p_len + 1);
			p[0] = (byte)'_';
			++p_len;
			if (p == /* if fname was just modified then the basename pointer must be updated */fname) {
				base = ModernizedCProgram.tool_basename((fname/* This is the legacy portion from rename_if_dos_device_name that checks for
				     reserved device names. It only works on MSDOS. On Windows XP the stat
				     check errors with EINVAL if the device name is reserved. On Windows
				     Vista/7/8 it sets mode S_IFREG (regular file or device). According to MSDN
				     stat doc the latter behavior is correct, but that doesn't help us identify
				     whether it's a reserved device name and not a regular file name. *//* Prepend a '_' */));
			} 
		}
		sanitized = .strdup(fname);
		return (sanitized ? .SANITIZE_ERR_OK : .SANITIZE_ERR_OUT_OF_MEMORY/*
		 * Disable program default argument globbing. We do it on our own.
		 *//* MSDOS && (__DJGPP__ || __GO32__) */);
	}
	/* !UNITTESTS (static declarations used if no unit tests) */
	/*
	Sanitize a file or path name.
	
	All banned characters are replaced by underscores, for example:
	f?*foo => f__foo
	f:foo::$DATA => f_foo__$DATA
	f:\foo:bar => f__foo_bar
	f:\foo:bar => f:\foo:bar   (flag SANITIZE_ALLOW_PATH)
	
	This function was implemented according to the guidelines in 'Naming Files,
	Paths, and Namespaces' section 'Naming Conventions'.
	https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx
	
	Flags
	-----
	SANITIZE_ALLOW_COLONS:     Allow colons.
	Without this flag colons are sanitized.
	
	SANITIZE_ALLOW_PATH:       Allow path separators and colons.
	Without this flag path separators and colons are sanitized.
	
	SANITIZE_ALLOW_RESERVED:   Allow reserved device names.
	Without this flag a reserved device name is renamed (COM1 => _COM1) unless it's
	in a UNC prefixed path.
	
	SANITIZE_ALLOW_TRUNCATE:   Allow truncating a long filename.
	Without this flag if the sanitized filename or path will be too long an error
	occurs. With this flag the filename --and not any other parts of the path-- may
	be truncated to at least a single character. A filename followed by an
	alternate data stream (ADS) cannot be truncated in any case.
	
	Success: (SANITIZE_ERR_OK) *sanitized points to a sanitized copy of file_name.
	Failure: (!= SANITIZE_ERR_OK) *sanitized is NULL.
	*/
	/*
	 * Function to find CACert bundle on a Win32 platform using SearchPath.
	 * (SearchPath is already declared via inclusions done in setup header file)
	 * (Use the ASCII version instead of the unicode one!)
	 * The order of the directories it searches is:
	 *  1. application's directory
	 *  2. current working directory
	 *  3. Windows System directory (e.g. C:\windows\system32)
	 *  4. Windows Directory (e.g. C:\windows)
	 *  5. all directories along %PATH%
	 *
	 * For WinXP and later search order actually depends on registry value:
	 * HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\SafeProcessSearchMode
	 */
	public static  FindWin32CACert(Object config,  backend, Object bundle_file) {
		CURLcode result = .CURLE_OK/* Search and set cert file only if libcurl supports SSL.
		   *
		   * If Schannel is the selected SSL backend then these locations are
		   * ignored. We allow setting CA location for schannel only when explicitly
		   * specified by the user via CURLOPT_CAINFO / --cacert.
		   */;
		if ((ModernizedCProgram.curlinfo.getFeatures() & (1 << 2)) && backend != .CURLSSLBACKEND_SCHANNEL) {
			DWORD res_len = new DWORD();
			byte[] buf = new byte[260];
			byte ptr = ((Object)0);
			buf[0] = (byte)'\0';
			res_len = .SearchPathA(((Object)0), bundle_file, ((Object)0), 260, buf, ptr);
			if (res_len > 0) {
				do {
					.free((config.getCacert()));
					(config.getCacert()) = ((Object)0);
				} while (0);
				config.setCacert(.strdup(buf));
				if (!config.getCacert()) {
					result = .CURLE_OUT_OF_MEMORY;
				} 
			} 
		} 
		return result;
	}
	public static Object GetLoadedModulePaths() {
		HANDLE hnd = (HANDLE)(true);
		MODULEENTRY32 mod = new MODULEENTRY32(0);
		curl_slist slist = ((Object)0);
		mod.setDwSize();
		do {
			hnd = .CreateToolhelp32Snapshot(-1024, 0);
		} while (hnd == (HANDLE)(true) && .GetLastError() == -1024);
		if (hnd == (HANDLE)(true)) {
			;
		} 
		if (!.Module32First(hnd, mod)) {
			;
		} 
		Object generatedSzExePath = mod.getSzExePath();
		do {
			byte path;
			curl_slist temp = new curl_slist();
			path = generatedSzExePath;
			temp = ModernizedCProgram.curl_slist_append(slist, path);
			if (!temp) {
				;
			} 
			slist = temp;
		} while (.Module32Next(hnd, mod));
		;
		slist = ((Object)0);
		return slist/* WIN32 *//* MSDOS || WIN32 */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	/*
	 * Curl_memrchr()
	 *
	 * Our memrchr() function clone for systems which lack this function. The
	 * memrchr() function is like the memchr() function, except that it searches
	 * backwards from the end of the n bytes pointed to by s instead of forward
	 * from the beginning.
	 */
	/*
	 * Curl_memrchr()
	 *
	 * Our memrchr() function clone for systems which lack this function. The
	 * memrchr() function is like the memchr() function, except that it searches
	 * backwards from the end of the n bytes pointed to by s instead of forward
	 * from the beginning.
	 */
	public static Object Curl_memrchr(Object s, int c, Object n) {
		if (n > 0) {
			byte p = s;
			byte q = s;
			p += n - 1;
			while (p >= q) {
				if (p == (byte)c) {
					return (Object)p;
				} 
				p--;
			}
		} 
		return ((Object)0/* HAVE_MEMRCHR */);
	}
	public static  file_setup_connection(Object conn) {
		conn.getData().getReq().setProtop(.Curl_ccalloc(1, /* allocate the FILE specific struct */));
		if (!conn.getData().getReq().getProtop()) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		return .CURLE_OK/*
		 * file_connect() gets called from Curl_protocol_connect() to allow us to
		 * do protocol-specific actions at connect-time.  We emulate a
		 * connect-then-transfer protocol and "connect" to the file here
		 */;
	}
	/*
	 * FILE scheme handler.
	 */
	public static  file_connect(Object conn, Object done) {
		Curl_easy data = conn.getData();
		byte real_path;
		FILEPROTO file = data.getReq().getProtop();
		int fd;
		size_t i = new size_t();
		byte actual_path;
		size_t real_path_len = new size_t();
		CURLcode result = ModernizedCProgram.Curl_urldecode(data, data.getState().getUp().getPath(), 0, real_path, real_path_len, 0);
		if (result) {
			return result/* If the first character is a slash, and there's
			     something that looks like a drive at the beginning of
			     the path, skip the slash.  If we remove the initial
			     slash in all cases, paths without drive letters end up
			     relative to the current directory which isn't how
			     browsers work.
			
			     Some browsers accept | instead of : as the drive letter
			     separator, so we do too.
			
			     On other platforms, we need the slash to indicate an
			     absolute pathname.  On Windows, absolute paths start
			     with a drive letter.
			  */;
		} 
		actual_path = real_path;
		if ((actual_path[0] == (byte)'/') && actual_path[1] && (actual_path[2] == (byte)':' || actual_path[2] == (byte)'|')) {
			actual_path[2] = (byte)':';
			actual_path++;
			real_path_len--;
		} 
		for (i = 0; i < real_path_len; ++/* change path separators from '/' to '\\' for DOS, Windows and OS/2 */i) {
			if (actual_path[i] == (byte)'/') {
				actual_path[i] = (byte)'\\';
			}  else if (!actual_path[/* binary zero */i]) {
				do {
					.Curl_cfree((real_path));
					(real_path) = ((Object)0);
				} while (0);
				return .CURLE_URL_MALFORMAT;
			} 
		}
		fd = .open((actual_path), (0 | -1024));
		file.setPath(actual_path/* binary zeroes indicate foul play */);
		file.setFreepath(/* free this when done */real_path);
		file.setFd(fd);
		if (!data.getSet().getUpload() && (fd == -1)) {
			ModernizedCProgram.Curl_failf(data, "Couldn't open file %s", data.getState().getUp().getPath());
			ModernizedCProgram.file_done(conn, .CURLE_FILE_COULDNT_READ_FILE, 0);
			return .CURLE_FILE_COULDNT_READ_FILE;
		} 
		done = 1;
		return .CURLE_OK;
	}
	public static  file_done(Object conn,  status,  premature) {
		FILEPROTO file = conn.getData().getReq().getProtop();
		(Object)/* not used */status;
		(Object)/* not used */premature;
		if (file) {
			do {
				.Curl_cfree((file.getFreepath()));
				(file.getFreepath()) = ((Object)0);
			} while (0);
			file.setPath(((Object)0));
			if (file.getFd() != -1) {
				.close(file.getFd());
			} 
			file.setFd(-1);
		} 
		return .CURLE_OK;
	}
	public static  file_disconnect(Object conn,  dead_connection) {
		FILEPROTO file = conn.getData().getReq().getProtop();
		(Object)/* not used */dead_connection;
		if (file) {
			do {
				.Curl_cfree((file.getFreepath()));
				(file.getFreepath()) = ((Object)0);
			} while (0);
			file.setPath(((Object)0));
			if (file.getFd() != -1) {
				.close(file.getFd());
			} 
			file.setFd(-1);
		} 
		return .CURLE_OK;
	}
	public static  file_upload(Object conn) {
		FILEPROTO file = conn.getData().getReq().getProtop();
		byte dir = .strchr(file.getPath(), (byte)'\\');
		int fd;
		int mode;
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		byte buf = data.getState().getBuffer();
		curl_off_t bytecount = 0;
		_stati64 file_stat = new _stati64();
		byte buf2;
		/*
		   * Since FILE: doesn't do the full init, we need to provide some extra
		   * assignments here.
		   */
		conn.getData().getReq().setUpload_fromhere(buf);
		if (!dir) {
			return /* fix: better error code */.CURLE_FILE_COULDNT_READ_FILE;
		} 
		if (!dir[1]) {
			return /* fix: better error code */.CURLE_FILE_COULDNT_READ_FILE;
		} 
		if (data.getState().getResume_from()) {
			mode = 1 | -1024 | -1024 | -1024;
		} else {
				mode = 1 | -1024 | -1024 | -1024;
		} 
		fd = .open(file.getPath(), mode, conn.getData().getSet().getNew_file_perms());
		if (fd < 0) {
			ModernizedCProgram.Curl_failf(data, "Can't open %s for writing", file.getPath());
			return .CURLE_WRITE_ERROR;
		} 
		if (-1 != data.getState().getInfilesize()) {
			ModernizedCProgram.Curl_pgrsSetUploadSize(data, data.getState().getInfilesize());
		} 
		Object generatedSt_size = file_stat.getSt_size();
		if (data.getState().getResume_from() < /* treat the negative resume offset value as the case of "-" */0) {
			if (._fstati64(fd, file_stat)) {
				.close(fd);
				ModernizedCProgram.Curl_failf(data, "Can't get the size of %s", file.getPath());
				return .CURLE_WRITE_ERROR;
			} 
			data.getState().setResume_from((curl_off_t)generatedSt_size);
		} 
		curltime curltime = new curltime();
		while (!result) {
			size_t nread = new size_t();
			size_t nwrite = new size_t();
			size_t readcount = new size_t();
			result = ModernizedCProgram.Curl_fillreadbuffer(conn, data.getSet().getBuffer_size(), readcount);
			if (result) {
				break;
			} 
			if (!readcount) {
				break;
			} 
			nread = readcount;
			if (data.getState().getResume_from()) {
				if ((curl_off_t)nread <= data.getState().getResume_from()) {
					data.getState().getResume_from() -= nread;
					nread = 0;
					buf2 = buf;
				} else {
						buf2 = buf + data.getState().getResume_from();
						nread -= (size_t)data.getState().getResume_from();
						data.getState().setResume_from(0);
				} 
			} else {
					buf2 = buf;
			} 
			nwrite = ModernizedCProgram.curlx_write(fd, buf2, /* write the data to the target */nread);
			if (nwrite != nread) {
				result = .CURLE_SEND_ERROR;
				break;
			} 
			bytecount += nread;
			ModernizedCProgram.Curl_pgrsSetUploadCounter(data, bytecount);
			if (ModernizedCProgram.Curl_pgrsUpdate(conn)) {
				result = .CURLE_ABORTED_BY_CALLBACK;
			} else {
					result = curltime.Curl_now().Curl_speedcheck(data);
			} 
		}
		if (!result && ModernizedCProgram.Curl_pgrsUpdate(conn)) {
			result = .CURLE_ABORTED_BY_CALLBACK;
		} 
		.close(fd);
		return result/*
		 * file_do() is the protocol-specific function for the do-phase, separated
		 * from the connect-phase above. Other protocols merely setup the transfer in
		 * the do-phase, to have it done in the main transfer loop but since some
		 * platforms we support don't allow select()ing etc on file handles (as
		 * opposed to sockets) we instead perform the whole do-operation in this
		 * function.
		 */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* for the week day and month names */
	/* The last 3 #include files should be in this order */
	/*
	 * Forward declarations.
	 */
	public static  file_do(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		/* struct_stat instead of struct stat just to allow the
		                          Windows version to have a different struct without
		                          having to redefine the simple word 'stat' */_stati64 statbuf = new _stati64();
		curl_off_t expected_size = 0;
		bool size_known = new bool();
		bool fstated = 0;
		Curl_easy data = conn.getData();
		byte buf = data.getState().getBuffer();
		curl_off_t bytecount = 0;
		int fd;
		FILEPROTO file = new FILEPROTO();
		done = /* unconditionally */1;
		ModernizedCProgram.Curl_pgrsStartNow(data);
		if (data.getSet().getUpload()) {
			return ModernizedCProgram.file_upload(conn);
		} 
		file = conn.getData().getReq().getProtop();
		fd = file.getFd();
		Object generatedSt_size = statbuf.getSt_size();
		Object generatedSt_mtime = statbuf.getSt_mtime();
		if (-1 != ._fstati64(fd, /* VMS: This only works reliable for STREAMLF files */statbuf)) {
			expected_size = generatedSt_size;
			data.getInfo().setFiletime(generatedSt_mtime);
			fstated = 1;
		} 
		if (fstated && !data.getState().getRange() && data.getSet().getTimecondition()) {
			if (!ModernizedCProgram.Curl_meets_timecondition(data, data.getInfo().getFiletime())) {
				done = 1;
				return .CURLE_OK;
			} 
		} 
		if (fstated) {
			time_t filetime = new time_t();
			tm buffer = new tm();
			tm tm = buffer;
			byte[] header = new byte[80];
			ModernizedCProgram.curl_msnprintf(header, , "Content-Length: %I64d\r\n", expected_size);
			result = ModernizedCProgram.Curl_client_write(conn, (1 << 1), header, 0);
			if (result) {
				return result;
			} 
			result = ModernizedCProgram.Curl_client_write(conn, (1 << 1), (byte)"Accept-ranges: bytes\r\n", 0);
			if (result) {
				return result;
			} 
			filetime = (time_t)generatedSt_mtime;
			result = ModernizedCProgram.Curl_gmtime(filetime, buffer);
			if (result) {
				return result;
			} 
			ModernizedCProgram.curl_msnprintf(header, , "Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n%s", ModernizedCProgram.Curl_wkday[tm.getTm_wday() ? tm.getTm_wday() - 1 : 6], tm.getTm_mday(), ModernizedCProgram.Curl_month[tm.getTm_mon()], tm.getTm_year() + 1900, tm.getTm_hour(), tm.getTm_min(), tm.getTm_sec(), data.getSet().getOpt_no_body() ? "" : "\r\n");
			result = ModernizedCProgram.Curl_client_write(conn, (1 << 1), header, 0);
			if (result) {
				return result;
			} 
			ModernizedCProgram.Curl_pgrsSetDownloadSize(data, /* set the file size to make it available post transfer */expected_size);
			if (data.getSet().getOpt_no_body()) {
				return result;
			} 
		} 
		result = ModernizedCProgram.Curl_range(/* Check whether file range has been specified */conn);
		if (result) {
			return result;
		} 
		if (data.getState().getResume_from() < /* Adjust the start offset in case we want to get the N last bytes
		   * of the stream if the filesize could be determined */0) {
			if (!fstated) {
				ModernizedCProgram.Curl_failf(data, "Can't get the size of file.");
				return .CURLE_READ_ERROR;
			} 
			data.getState().getResume_from() += (curl_off_t)generatedSt_size;
		} 
		if (data.getState().getResume_from() <= expected_size) {
			expected_size -= data.getState().getResume_from();
		} else {
				ModernizedCProgram.Curl_failf(data, "failed to resume file:// transfer");
				return .CURLE_BAD_DOWNLOAD_RESUME;
		} 
		if (data.getReq().getMaxdownload() > /* A high water mark has been specified so we obey... */0) {
			expected_size = data.getReq().getMaxdownload();
		} 
		if (!fstated || (expected_size == 0)) {
			size_known = 0;
		} else {
				size_known = 1/* The following is a shortcut implementation of file reading
				     this is both more efficient than the former call to download() and
				     it avoids problems with select() and recv() on file descriptors
				     in Winsock */;
		} 
		if (fstated) {
			ModernizedCProgram.Curl_pgrsSetDownloadSize(data, expected_size);
		} 
		if (data.getState().getResume_from()) {
			if (data.getState().getResume_from() != ._lseeki64(fd, data.getState().getResume_from(), 0)) {
				return .CURLE_BAD_DOWNLOAD_RESUME;
			} 
		} 
		ModernizedCProgram.Curl_pgrsTime(data, .TIMER_STARTTRANSFER);
		curltime curltime = new curltime();
		while (!result) {
			ssize_t nread = new ssize_t();
			size_t bytestoread = new size_t();
			if (size_known) {
				bytestoread = (expected_size < data.getSet().getBuffer_size()) ? ModernizedCProgram.curlx_sotouz(expected_size) : (size_t)data.getSet().getBuffer_size();
			} else {
					bytestoread = data.getSet().getBuffer_size() - 1;
			} 
			nread = ModernizedCProgram.curlx_read(fd, buf, bytestoread);
			if (nread > 0) {
				buf[nread] = 0;
			} 
			if (nread <= 0 || (size_known && (expected_size == 0))) {
				break;
			} 
			bytecount += nread;
			if (size_known) {
				expected_size -= nread;
			} 
			result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), buf, nread);
			if (result) {
				return result;
			} 
			ModernizedCProgram.Curl_pgrsSetDownloadCounter(data, bytecount);
			if (ModernizedCProgram.Curl_pgrsUpdate(conn)) {
				result = .CURLE_ABORTED_BY_CALLBACK;
			} else {
					result = curltime.Curl_now().Curl_speedcheck(data);
			} 
		}
		if (ModernizedCProgram.Curl_pgrsUpdate(conn)) {
			result = .CURLE_ABORTED_BY_CALLBACK;
		} 
		return result;
	}
	/* This implementation ignores the host name in conformance with
	     RFC 1738. Only local files (reachable via the standard file system)
	     are supported. This means that files on remotely mounted directories
	     (via NFS, Samba, NT sharing) can be accessed through a file:// URL
	  */
	public static void tcpkeepalive(Object data, Object sockfd) {
		int optval = data.getSet().getTcp_keepalive() ? 1 : 0;
		if (.setsockopt(sockfd, -1024, /* only set IDLE and INTVL if setting KEEPALIVE is successful */8, (Object)optval, ) < 0) {
			ModernizedCProgram.Curl_infof(data, "Failed to set SO_KEEPALIVE on fd %d\n", sockfd);
		} else {
				tcp_keepalive vals = new tcp_keepalive();
				DWORD dummy = new DWORD();
				vals.setOnoff(1);
				optval = ModernizedCProgram.curlx_sltosi(data.getSet().getTcp_keepidle());
				(optval *= 1000);
				vals.setKeepalivetime(optval);
				optval = ModernizedCProgram.curlx_sltosi(data.getSet().getTcp_keepintvl());
				(optval *= 1000);
				vals.setKeepaliveinterval(optval);
				if (.WSAIoctl(sockfd, (-1024 | (true) | (true)), (LPVOID)vals, , ((Object)0), 0, dummy, ((Object)0), ((Object)0)) != 0) {
					ModernizedCProgram.Curl_infof(data, "Failed to set SIO_KEEPALIVE_VALS on fd %d: %d\n", (int)sockfd, .WSAGetLastError());
				} 
		} 
	}
	public static Object Curl_timeleft(Object data, Object nowp,  duringconnect) {
		int timeout_set = 0;
		timediff_t timeout_ms = duringconnect ? 300000 : 0;
		curltime now = new curltime();
		if (data.getSet().getTimeout() > /* if a timeout is set, use the most restrictive one */0) {
			timeout_set |=  1;
		} 
		if (duringconnect && (data.getSet().getConnecttimeout() > 0)) {
			timeout_set |=  2;
		} 
		switch (timeout_set) {
		case 2:
				timeout_ms = data.getSet().getConnecttimeout();
				break;
		case 1:
				timeout_ms = data.getSet().getTimeout();
				break;
		case 3:
				if (data.getSet().getTimeout() < data.getSet().getConnecttimeout()) {
					timeout_ms = data.getSet().getTimeout();
				} else {
						timeout_ms = data.getSet().getConnecttimeout();
				} 
				break;
		default:
				if (!/* use the default */duringconnect/* if we're not during connect, there's no default timeout so if we're
				         at zero we better just return zero and not make it a negative number
				         by the math below */) {
					return 0;
				} 
				break;
		}
		curltime curltime = new curltime();
		if (!nowp) {
			now = curltime.Curl_now();
			nowp = now;
		} 
		if (/* subtract elapsed time */duringconnect) {
			timeout_ms -= nowp.Curl_timediff(data.getProgress().getT_startsingle());
		} else {
				timeout_ms -= nowp.Curl_timediff(data.getProgress().getT_startop());
		} 
		if (!timeout_ms) {
			return -/* avoid returning 0 as that means no timeout! */1;
		} 
		return timeout_ms;
	}
	public static  bindlocal(Object conn, Object sockfd, int af, int scope) {
		Curl_easy data = conn.getData();
		Curl_sockaddr_storage sa = new Curl_sockaddr_storage();
		sockaddr sock = (sockaddr)/* bind to this address */sa;
		curl_socklen_t sizeof_sa = /* size of the data sock points to */0;
		sockaddr_in si4 = (sockaddr_in)sa;
		Curl_dns_entry h = ((Object)0);
		int port = data.getSet().getLocalport();
		int portnum = data.getSet().getLocalportrange();
		byte dev = data.getSet().getStr()[dupstring.STRING_DEVICE];
		int error;
		/*************************************************************
		   * Select device to bind socket to
		   *************************************************************/
		if (!dev && !port) {
			return /* no local kind of binding was requested */.CURLE_OK;
		} 
		.memset(sa, 0, );
		if (dev && (.strlen(dev) < 255)) {
			byte[] myhost = "";
			int done = /* -1 for error, 1 for address found */0;
			bool is_interface = 0;
			bool is_host = 0;
			byte if_prefix = "if!";
			byte host_prefix = "host!";
			if (.strncmp(if_prefix, dev, .strlen(if_prefix)) == 0) {
				dev += .strlen(if_prefix);
				is_interface = 1;
			}  else if (.strncmp(host_prefix, dev, .strlen(host_prefix)) == 0) {
				dev += .strlen(host_prefix);
				is_host = 1;
			} 
			if (!/* interface */is_host/* I am not sure any other OSs than Linux that provide this feature,
			       * and at the least I cannot test. --Ben
			       *
			       * This feature allows one to tightly bind the local socket to a
			       * particular interface.  This will force even requests to other
			       * local interfaces to go out the external interface.
			       *
			       *
			       * Only bind to the interface when specified as interface, not just
			       * as a hostname or ip address.
			       *
			       * interface might be a VRF, eg: vrf-blue, which means it cannot be
			       * converted to an IP address and would fail Curl_if2ip. Simply try
			       * to use it straight away.
			       */) {
				switch (ModernizedCProgram.Curl_if2ip(af, scope, conn.getScope_id(), /* This is typically "errno 1, error: Operation not permitted" if
				         * you're not running as root or another suitable privileged
				         * user.
				         * If it succeeds it means the parameter was a valid interface and
				         * not an IP address. Return immediately.
				         */dev, myhost, )) {
				case .IF2IP_FOUND:
						is_interface = 1/*
						           * We now have the numerical IP address in the 'myhost' buffer
						           */;
						ModernizedCProgram.Curl_infof(data, "Local Interface %s is ip %s using address family %i\n", dev, myhost, af);
						done = 1;
						break;
				case .IF2IP_NOT_FOUND:
						if (is_interface) {
							ModernizedCProgram.Curl_failf(data, "Couldn't bind to interface '%s'", /* Do not fall back to treating it as a host name */dev);
							return .CURLE_INTERFACE_FAILED;
						} 
						break;
				case .IF2IP_AF_NOT_SUPPORTED:
						return /* Signal the caller to try another address family if available */.CURLE_UNSUPPORTED_PROTOCOL;
				}
			} 
			if (!is_interface/*
			       * This was not an interface, resolve the name as a host name
			       * or IP number
			       *
			       * Temporarily force name resolution to use only the address type
			       * of the connection. The resolve functions should really be changed
			       * to take a type parameter instead.
			       */) {
				long ipver = conn.getIp_version();
				int rc;
				if (af == 2) {
					conn.setIp_version(1);
				} 
				rc = ModernizedCProgram.Curl_resolv(conn, dev, 0, 0, h);
				if (rc == 1) {
					(Object)ModernizedCProgram.Curl_resolver_wait_resolv(conn, h);
				} 
				conn.setIp_version(ipver);
				if (h) {
					ModernizedCProgram.Curl_printable_address(h.getAddr(), myhost, );
					ModernizedCProgram.Curl_infof(data, "Name '%s' family %i resolved to '%s' family %i\n", dev, af, myhost, h.getAddr().getAi_family());
					ModernizedCProgram.Curl_resolv_unlock(data, h);
					if (af != h.getAddr().getAi_family()) {
						return .CURLE_UNSUPPORTED_PROTOCOL;
					} 
					done = 1/*
					         * provided dev was no interface (or interfaces are not supported
					         * e.g. solaris) no ip address and no domain we fail here
					         */;
				} else {
						done = -1;
				} 
			} 
			if (done > 0/* IPv6 address */) {
				if ((af == /* The "myhost" string either comes from Curl_if2ip or from
				               Curl_printable_address. The latter returns only numeric scope
				               IDs and the former returns none at all.  So the scope ID, if
				               present, is known to be numeric *//* IPv4 address */2) && (ModernizedCProgram.Curl_inet_pton(2, myhost, si4.getSin_addr()) > 0)) {
					si4.setSin_family(2);
					si4.setSin_port(.htons(port));
					sizeof_sa = ;
				} 
			} 
			if (done < 1/* errorbuf is set false so failf will overwrite any message already in
			         the error buffer, so the user receives this error message instead of a
			         generic resolve error. */) {
				data.getState().setErrorbuf(0);
				ModernizedCProgram.Curl_failf(data, "Couldn't bind to '%s'", dev);
				return .CURLE_INTERFACE_FAILED/* no device was given, prepare sa to match af's needs */;
			} 
		} else {
				if (af == 2) {
					si4.setSin_family(2);
					si4.setSin_port(.htons(port));
					sizeof_sa = ;
				} 
		} 
		for (; ; ) {
			if (.bind(sockfd, sock, sizeof_sa) >= 0/* we succeeded to bind */) {
				Curl_sockaddr_storage add = new Curl_sockaddr_storage();
				curl_socklen_t size = ;
				.memset(add, 0, );
				if (.getsockname(sockfd, (sockaddr)add, size) < 0) {
					byte[] buffer = new byte[128];
					data.getState().setOs_errno(error = ((int).WSAGetLastError()));
					ModernizedCProgram.Curl_failf(data, "getsockname() failed with errno %d: %s", error, ModernizedCProgram.Curl_strerror(error, buffer, ));
					return .CURLE_INTERFACE_FAILED;
				} 
				ModernizedCProgram.Curl_infof(data, "Local port: %hu\n", port);
				conn.getBits().setBound(1);
				return .CURLE_OK;
			} 
			if (--portnum > 0) {
				ModernizedCProgram.Curl_infof(data, "Bind to local port %hu failed, trying next\n", port);
				/* try next port */port++;
				if (sock.getSa_family() == /* We re-use/clobber the port variable here below */2) {
					si4.setSin_port(.ntohs(port));
				} 
			} else {
					break;
			} 
		}
		{ 
			byte[] buffer = new byte[128];
			data.getState().setOs_errno(error = ((int).WSAGetLastError()));
			ModernizedCProgram.Curl_failf(data, "bind failed with errno %d: %s", error, ModernizedCProgram.Curl_strerror(error, buffer, ));
		}
		return .CURLE_INTERFACE_FAILED/*
		 * verifyconnect() returns TRUE if the connect really has happened.
		 */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* <netinet/tcp.h> may need it */
	/* for sockaddr_un */
	/* for Curl_safefree() */
	/* required for Curl_sockaddr_storage */
	/* for Curl_ssl_check_cxn() */
	/* The last 3 #include files should be in this order */
	/* This isn't actually supported under Symbian OS */
	public static  verifyconnect(Object sockfd, Object error) {
		bool rc = 1;
		int err = 0;
		curl_socklen_t errSize = ;
		.SleepEx(0, 0);
		if (0 != .getsockopt(sockfd, -1024, -1024, (Object)err, errSize)) {
			err = ((int).WSAGetLastError());
		} 
		if ((0 == err) || (-1024 == /* Minix 3.1.x doesn't support getsockopt on UDP sockets */err)) {
			rc = /* we are connected, awesome! */1;
		} else {
				rc = /* This wasn't a successful connect */0;
		} 
		if (error) {
			error = err;
		} 
		return rc;
	}
	/* DragonFlyBSD and Windows use millisecond units */
	/* Used within the multi interface. Try next IP address, return TRUE if no
	   more address exists or error */
	public static  trynextip(Object conn, int sockindex, int tempindex) {
		int other = tempindex ^ 1;
		CURLcode result = .CURLE_COULDNT_CONNECT/* First clean up after the failed socket.
		     Don't close it yet to ensure that the next IP's socket gets a different
		     file descriptor, which can prevent bugs when the curl_multi_socket_action
		     interface is used with certain select() replacements such as kqueue. */;
		curl_socket_t fd_to_close = conn.getTempsock()[tempindex];
		conn.getTempsock()[tempindex] = (SOCKET)(~0);
		if (sockindex == 0) {
			Curl_addrinfo ai = ((Object)0);
			int family = 0;
			if (conn.getTempaddr()[tempindex]) {
				family = conn.getTempaddr()[tempindex].getAi_family();
				ai = conn.getTempaddr()[tempindex].getAi_next();
			} 
			while (ai) {
				if (conn.getTempaddr()[other]) {
					while (ai && ai.getAi_family() != /* we can safely skip addresses of the other protocol family */family) {
						ai = ai.getAi_next();
					}
				} 
				if (ai) {
					result = ModernizedCProgram.singleipconnect(conn, ai, tempindex);
					if (result == .CURLE_COULDNT_CONNECT) {
						ai = ai.getAi_next();
						continue;
					} 
					conn.getTempaddr()[tempindex] = ai;
				} 
				break;
			}
		} 
		if (fd_to_close != (SOCKET)(~0)) {
			ModernizedCProgram.Curl_closesocket(conn, fd_to_close);
		} 
		return result;
	}
	/* Copies connection info into the session handle to make it available
	   when the session handle is no longer associated with a connection. */
	public static void Curl_persistconninfo(Object conn) {
		.memcpy(conn.getData().getInfo().getConn_primary_ip(), conn.getPrimary_ip(), );
		.memcpy(conn.getData().getInfo().getConn_local_ip(), conn.getLocal_ip(), );
		conn.getData().getInfo().setConn_scheme(conn.getHandler().getScheme());
		conn.getData().getInfo().setConn_protocol(conn.getHandler().getProtocol());
		conn.getData().getInfo().setConn_primary_port(conn.getPrimary_port());
		conn.getData().getInfo().setConn_local_port(conn.getLocal_port());
	}
	/* retrieves ip address and port from a sockaddr structure.
	   note it calls Curl_inet_ntop which sets errno on fail, not SOCKERRNO. */
	public static  Curl_addr2string(Object sa, Object salen, Object addr, Object port) {
		sockaddr_in si = ((Object)0);
		(Object)salen;
		switch (sa.getSa_family()) {
		case 2:
				si = (sockaddr_in)(Object)sa;
				if (ModernizedCProgram.Curl_inet_ntop(sa.getSa_family(), si.getSin_addr(), addr, )) {
					int us_port = .ntohs(si.getSin_port());
					port = us_port;
					return 1;
				} 
				break;
		default:
				break;
		}
		addr[0] = (byte)'\0';
		port = 0;
		(._errno()) = -1024;
		return 0;
	}
	/* retrieves the start/end point information of a socket of an established
	   connection */
	public static void Curl_updateconninfo(Object conn, Object sockfd) {
		if (conn.getTransport() != .TRNSPRT_TCP/* there's no TCP connection! */) {
			return ;
		} 
		if (!conn.getBits().getReuse() && !conn.getBits().getTcp_fastopen()) {
			Curl_easy data = conn.getData();
			byte[] buffer = new byte[128];
			Curl_sockaddr_storage ssrem = new Curl_sockaddr_storage();
			Curl_sockaddr_storage ssloc = new Curl_sockaddr_storage();
			curl_socklen_t plen = new curl_socklen_t();
			curl_socklen_t slen = new curl_socklen_t();
			plen = ;
			if (.getpeername(sockfd, (sockaddr)ssrem, plen)) {
				int error = ((int).WSAGetLastError());
				ModernizedCProgram.Curl_failf(data, "getpeername() failed with errno %d: %s", error, ModernizedCProgram.Curl_strerror(error, buffer, ));
				return ;
			} 
			slen = ;
			.memset(ssloc, 0, );
			if (.getsockname(sockfd, (sockaddr)ssloc, slen)) {
				int error = ((int).WSAGetLastError());
				ModernizedCProgram.Curl_failf(data, "getsockname() failed with errno %d: %s", error, ModernizedCProgram.Curl_strerror(error, buffer, ));
				return ;
			} 
			if (!ModernizedCProgram.Curl_addr2string((sockaddr)ssrem, plen, conn.getPrimary_ip(), conn.getPrimary_port())) {
				ModernizedCProgram.Curl_failf(data, "ssrem inet_ntop() failed with errno %d: %s", (._errno()), ModernizedCProgram.Curl_strerror((._errno()), buffer, ));
				return ;
			} 
			.memcpy(conn.getIp_addr_str(), conn.getPrimary_ip(), );
			if (!ModernizedCProgram.Curl_addr2string((sockaddr)ssloc, slen, conn.getLocal_ip(), conn.getLocal_port())) {
				ModernizedCProgram.Curl_failf(data, "ssloc inet_ntop() failed with errno %d: %s", (._errno()), ModernizedCProgram.Curl_strerror((._errno()), buffer, ));
				return ;
			} 
		} 
		ModernizedCProgram.Curl_persistconninfo(/* unused *//* persist connection info in session handle */conn/* after a TCP connection to the proxy has been verified, this function does
		   the next magic step.
		
		   Note: this function's sub-functions call failf()
		
		*/);
	}
	public static  connected_proxy(Object conn, int sockindex) {
		CURLcode result = .CURLE_OK;
		if (conn.getBits().getSocksproxy()) {
			byte host = conn.getBits().getHttpproxy() ? conn.getHttp_proxy().getHost().getName() : conn.getBits().getConn_to_host() ? conn.getConn_to_host().getName() : sockindex == 1 ? conn.getSecondaryhostname() : conn.getHost().getName();
			int port = conn.getBits().getHttpproxy() ? (int)conn.getHttp_proxy().getPort() : sockindex == 1 ? conn.getSecondary_port() : conn.getBits().getConn_to_port() ? conn.getConn_to_port() : conn.getRemote_port();
			conn.getBits().setSocksproxy_connecting(1);
			switch (conn.getSocks_proxy().getProxytype()) {
			case .CURLPROXY_SOCKS5:
			case .CURLPROXY_SOCKS4:
			case .CURLPROXY_SOCKS5_HOSTNAME:
					result = ModernizedCProgram.Curl_SOCKS5(conn.getSocks_proxy().getUser(), conn.getSocks_proxy().getPasswd(), host, port, sockindex, conn);
					break;
			case .CURLPROXY_SOCKS4A:
					result = ModernizedCProgram.Curl_SOCKS4(conn.getSocks_proxy().getUser(), host, port, sockindex, conn);
					break;
			default:
					ModernizedCProgram.Curl_failf(conn.getData(), "unknown proxytype option given");
					result = .CURLE_COULDNT_CONNECT;
			}
			conn.getBits().setSocksproxy_connecting(/* switch proxytype */0);
		} 
		return /* CURL_DISABLE_PROXY */result/*
		 * Curl_is_connected() checks if the socket has connected.
		 */;
	}
	public static  Curl_is_connected(Object conn, int sockindex, Object connected) {
		Curl_easy data = conn.getData();
		CURLcode result = .CURLE_OK;
		timediff_t allow = new timediff_t();
		int error = 0;
		curltime now = new curltime();
		int rc;
		int i;
		do {
		} while (0);
		connected = /* a very negative world view is best */0;
		if (conn.getBits().getTcpconnect()[sockindex]) {
			connected = /* we are connected already! */1;
			return .CURLE_OK;
		} 
		curltime curltime = new curltime();
		now = curltime.Curl_now();
		allow = ModernizedCProgram.Curl_timeleft(data, now, /* figure out how long time we have left to connect */1);
		if (allow < 0) {
			ModernizedCProgram.Curl_failf(data, /* time-out, bail out, go home */"Connection time-out");
			return .CURLE_OPERATION_TIMEDOUT;
		} 
		for (i = 0; i < 2; i++) {
			int other = i ^ 1;
			if (conn.getTempsock()[i] == (SOCKET)(~0)) {
				continue;
			} 
			rc = ModernizedCProgram.Curl_socket_check((SOCKET)(~0), (SOCKET)(~0), conn.getTempsock()[i], (time_t)/* Call this function once now, and ignore the results. We do this to
			       "clear" the error state on the socket so that we can later read it
			       reliably. This is reported necessary on the MPE/iX operating system. *//* check socket for connect */0);
			if (rc == /* no connection yet */0) {
				error = 0;
				if (now.Curl_timediff(conn.getConnecttime()) >= conn.getTimeoutms_per_addr()) {
					ModernizedCProgram.Curl_infof(data, "After %I64dms connect time, move on!\n", conn.getTimeoutms_per_addr());
					error = -1024;
				} 
				if (i == 0 && conn.getTempaddr()[1] == ((Object)/* should we try another protocol family? */0) && (now.Curl_timediff(conn.getConnecttime()) >= data.getSet().getHappy_eyeballs_timeout())) {
					ModernizedCProgram.trynextip(conn, sockindex, 1);
				} 
			}  else if (rc == -1024 || conn.getBits().getTcp_fastopen()) {
				if (ModernizedCProgram.verifyconnect(conn.getTempsock()[i], error/* we are connected with TCP, awesome! */)) {
					conn.getSock()[sockindex] = conn.getTempsock()[/* use this socket from now on */i];
					conn.setIp_addr(conn.getTempaddr()[i]);
					conn.getTempsock()[i] = (SOCKET)(~0);
					if (conn.getTempsock()[other] != (SOCKET)(~/* close the other socket, if open */0)) {
						ModernizedCProgram.Curl_closesocket(conn, conn.getTempsock()[other]);
						conn.getTempsock()[other] = (SOCKET)(~0);
					} 
					result = ModernizedCProgram.connected_proxy(conn, /* see if we need to do any proxy magic first once we connected */sockindex);
					if (result) {
						return result;
					} 
					conn.getBits().getTcpconnect()[sockindex] = 1;
					connected = 1;
					if (sockindex == 0) {
						ModernizedCProgram.Curl_pgrsTime(data, /* connect done */.TIMER_CONNECT);
					} 
					ModernizedCProgram.Curl_updateconninfo(conn, conn.getSock()[sockindex]);
					ModernizedCProgram.Curl_verboseconnect(conn);
					return .CURLE_OK;
				} 
				ModernizedCProgram.Curl_infof(data, "Connection failed\n");
			}  else if (rc & -1024) {
				(Object)ModernizedCProgram.verifyconnect(conn.getTempsock()[i], error);
			} 
			if (/*
			     * The connection failed here, we should attempt to connect to the "next
			     * address" for the given host. But first remember the latest error.
			     */error) {
				data.getState().setOs_errno(error);
				(.WSASetLastError((int)(error)));
				if (conn.getTempaddr()[i]) {
					CURLcode status = new CURLcode();
					byte[] ipaddress = new byte[];
					byte[] buffer = new byte[128];
					ModernizedCProgram.Curl_printable_address(conn.getTempaddr()[i], ipaddress, );
					ModernizedCProgram.Curl_infof(data, "connect to %s port %ld failed: %s\n", ipaddress, conn.getPort(), ModernizedCProgram.Curl_strerror(error, buffer, ));
					conn.setTimeoutms_per_addr(conn.getTempaddr()[i].getAi_next() == ((Object)0) ? allow : allow / 2);
					status = ModernizedCProgram.trynextip(conn, sockindex, i);
					if ((status != .CURLE_COULDNT_CONNECT) || conn.getTempsock()[other] == (SOCKET)(~0)) {
						result = /* the last attempt failed and no other sockets remain open */status;
					} 
				} 
			} 
		}
		if (result/* no more addresses to try */) {
			byte hostname;
			byte[] buffer = new byte[128];
			if (conn.getTempaddr()[1] == ((Object)/* if the first address family runs out of addresses to try before
			       the happy eyeball timeout, go ahead and try the next family now */0)) {
				result = ModernizedCProgram.trynextip(conn, sockindex, 1);
				if (!result) {
					return result;
				} 
			} 
			if (conn.getBits().getSocksproxy()) {
				hostname = conn.getSocks_proxy().getHost().getName();
			}  else if (conn.getBits().getHttpproxy()) {
				hostname = conn.getHttp_proxy().getHost().getName();
			}  else if (conn.getBits().getConn_to_host()) {
				hostname = conn.getConn_to_host().getName();
			} else {
					hostname = conn.getHost().getName();
			} 
			ModernizedCProgram.Curl_failf(data, "Failed to connect to %s port %ld: %s", hostname, conn.getPort(), ModernizedCProgram.Curl_strerror(error, buffer, ));
			if (-1024 == data.getState().getOs_errno()) {
				result = .CURLE_OPERATION_TIMEDOUT;
			} 
		} 
		return result;
	}
	public static void tcpnodelay(Object conn, Object sockfd) {
		Curl_easy data = conn.getData();
		curl_socklen_t onoff = (curl_socklen_t)1;
		int level = 6;
		byte[] buffer = new byte[128];
		if (.setsockopt(sockfd, level, -1024, (Object)onoff, ) < 0) {
			ModernizedCProgram.Curl_infof(data, "Could not set TCP_NODELAY: %s\n", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
		} else {
				ModernizedCProgram.Curl_infof(data, "TCP_NODELAY set\n"/* The preferred method on Mac OS X (10.2 and later) to prevent SIGPIPEs when
				   sending data to a dead peer (instead of relying on the 4th argument to send
				   being MSG_NOSIGNAL). Possibly also existing and in use on other BSD
				   systems? */);
		} 
	}
	/* When you run a program that uses the Windows Sockets API, you may
	   experience slow performance when you copy data to a TCP server.
	
	   https://support.microsoft.com/kb/823764
	
	   Work-around: Make the Socket Send Buffer Size Larger Than the Program Send
	   Buffer Size
	
	   The problem described in this knowledge-base is applied only to pre-Vista
	   Windows.  Following function trying to detect OS version and skips
	   SO_SNDBUF adjustment for Windows Vista and above.
	*/
	public static void Curl_sndbufset(Object sockfd) {
		int val = 16384 + 32;
		int curval = 0;
		int curlen = ;
		int detectOsState = 0;
		if (detectOsState == 0) {
			if (ModernizedCProgram.Curl_verify_windows_version(6, 0, .PLATFORM_WINNT, .VERSION_GREATER_THAN_EQUAL)) {
				detectOsState = 2;
			} else {
					detectOsState = 1;
			} 
		} 
		if (detectOsState == 2) {
			return ;
		} 
		if (.getsockopt(sockfd, -1024, -1024, (byte)curval, curlen) == 0) {
			if (curval > val) {
				return ;
			} 
		} 
		.setsockopt(sockfd, -1024, -1024, (byte)val, );
	}
	/* Mac OS X style */
	public static  singleipconnect(Object conn, Object ai, int sockindex) {
		Curl_sockaddr_ex addr = new Curl_sockaddr_ex();
		int rc = -1;
		int error = 0;
		bool isconnected = 0;
		Curl_easy data = conn.getData();
		curl_socket_t sockfd = new curl_socket_t();
		CURLcode result = new CURLcode();
		byte[] ipaddress = new byte[];
		long port;
		bool is_tcp = new bool();
		byte[] buffer = new byte[128];
		curl_socket_t sockp = conn.getTempsock()[sockindex];
		sockp = (SOCKET)(~0);
		result = ModernizedCProgram.Curl_socket(conn, ai, addr, sockfd);
		if (result/* Failed to create the socket, but still return OK since we signal the
		       lack of socket as well. This allows the parent function to keep looping
		       over alternative addresses/socket families etc. */) {
			return .CURLE_OK;
		} 
		 generated_sa_ex_u = addr.get_sa_ex_u();
		Object generatedAddr = generated_sa_ex_u.getAddr();
		int generatedAddrlen = addr.getAddrlen();
		if (!ModernizedCProgram.Curl_addr2string((sockaddr)generatedAddr, generatedAddrlen, ipaddress, port)) {
			ModernizedCProgram.Curl_failf(data, /* malformed address or bug in inet_ntop, try next address */"sa_addr inet_ntop() failed with errno %d: %s", (._errno()), ModernizedCProgram.Curl_strerror((._errno()), buffer, ));
			ModernizedCProgram.Curl_closesocket(conn, sockfd);
			return .CURLE_OK;
		} 
		ModernizedCProgram.Curl_infof(data, "  Trying %s:%ld...\n", ipaddress, port);
		int generatedFamily = addr.getFamily();
		int generatedSocktype = addr.getSocktype();
		is_tcp = (generatedFamily == 2) && generatedSocktype == 1;
		if (is_tcp && data.getSet().getTcp_nodelay()) {
			ModernizedCProgram.tcpnodelay(conn, sockfd);
		} 
		do {
		} while (0);
		ModernizedCProgram.Curl_sndbufset(sockfd);
		if (is_tcp && data.getSet().getTcp_keepalive()) {
			ModernizedCProgram.tcpkeepalive(data, sockfd);
		} 
		if (data.getSet().getFsockopt()) {
			ModernizedCProgram.Curl_set_in_callback(data, /* activate callback for setting socket options */.bool_true);
			error = .UNRECOGNIZEDFUNCTIONNAME(data.getSet().getSockopt_client(), sockfd, .CURLSOCKTYPE_IPCXN);
			ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
			if (error == 2) {
				isconnected = 1;
			}  else if (error) {
				ModernizedCProgram.Curl_closesocket(conn, /* close the socket and bail out */sockfd);
				return .CURLE_ABORTED_BY_CALLBACK;
			} 
		} 
		if (generatedFamily == /* possibly bind the local end to an IP, interface or port */2) {
			result = ModernizedCProgram.bindlocal(conn, sockfd, generatedFamily, ModernizedCProgram.Curl_ipv6_scope((sockaddr)generatedAddr));
			if (result) {
				ModernizedCProgram.Curl_closesocket(conn, /* close socket and bail out */sockfd);
				if (result == .CURLE_UNSUPPORTED_PROTOCOL/* The address family is not supported on this interface.
				           We can continue trying addresses */) {
					return .CURLE_COULDNT_CONNECT;
				} 
				return result;
			} 
		} 
		(Object)ModernizedCProgram.curlx_nonblock(sockfd, /* set socket non-blocking */1);
		curltime curltime = new curltime();
		conn.setConnecttime(curltime.Curl_now());
		if (conn.getNum_addr() > 1) {
			ModernizedCProgram.Curl_expire(data, conn.getTimeoutms_per_addr(), .EXPIRE_DNS_PER_NAME);
		} 
		if (!isconnected && (conn.getTransport() != /* Connect TCP and QUIC sockets */.TRNSPRT_UDP)) {
			if (conn.getBits().getTcp_fastopen()) {
			} else {
					rc = .connect(sockfd, generatedAddr, generatedAddrlen);
			} 
			if (-1 == rc) {
				error = ((int).WSAGetLastError());
			} 
		} else {
				sockp = sockfd;
				return .CURLE_OK;
		} 
		if (-1 == rc) {
			switch (error) {
			case -1024:
			case -1024/* On some platforms EAGAIN and EWOULDBLOCK are the
			       * same value, and on others they are different, hence
			       * the odd #if
			       */:
			case 11:
					result = .CURLE_OK;
					break;
			default:
					ModernizedCProgram.Curl_infof(data, /* unknown error, fallthrough and try another address! */"Immediate connect fail for %s: %s\n", ipaddress, ModernizedCProgram.Curl_strerror(error, buffer, ));
					data.getState().setOs_errno(error);
					ModernizedCProgram.Curl_closesocket(conn, /* connect failed */sockfd);
					result = .CURLE_COULDNT_CONNECT;
			}
		} 
		if (!result) {
			sockp = sockfd;
		} 
		return result/*
		 * TCP connect to the given host with timeout, proxy or remote doesn't matter.
		 * There might be more than one IP address to try out. Fill in the passed
		 * pointer with the connected socket.
		 */;
	}
	/* start connecting to this */
	/* 0 or 1 among the temp ones */
	/*
	 * Curl_timeleft() returns the amount of milliseconds left allowed for the
	 * transfer/connection. If the value is negative, the timeout time has already
	 * elapsed.
	 *
	 * The start time is stored in progress.t_startsingle - as set with
	 * Curl_pgrsTime(..., TIMER_STARTSINGLE);
	 *
	 * If 'nowp' is non-NULL, it points to the current time.
	 * 'duringconnect' is FALSE if not during a connect, as then of course the
	 * connect timeout is not taken into account!
	 *
	 * @unittest: 1303
	 */
	/* context */
	public static  Curl_connecthost(Object conn, Object remotehost) {
		Curl_easy data = conn.getData();
		curltime curltime = new curltime();
		curltime before = curltime.Curl_now();
		CURLcode result = .CURLE_COULDNT_CONNECT;
		timediff_t timeout_ms = ModernizedCProgram.Curl_timeleft(data, before, 1);
		if (timeout_ms < 0) {
			ModernizedCProgram.Curl_failf(data, /* a precaution, no need to continue if time already is up */"Connection time-out");
			return .CURLE_OPERATION_TIMEDOUT;
		} 
		conn.setNum_addr(ModernizedCProgram.Curl_num_addresses(remotehost.getAddr()));
		conn.getTempaddr()[0] = remotehost.getAddr();
		conn.getTempaddr()[1] = ((Object)0);
		conn.getTempsock()[0] = (SOCKET)(~0);
		conn.getTempsock()[1] = (SOCKET)(~0);
		/* Max time for the next connection attempt */conn.setTimeoutms_per_addr(conn.getTempaddr()[0].getAi_next() == ((Object)0) ? timeout_ms : timeout_ms / 2);
		while (conn.getTempaddr()[/* start connecting to first IP */0]) {
			result = ModernizedCProgram.singleipconnect(conn, conn.getTempaddr()[0], 0);
			if (!result) {
				break;
			} 
			conn.getTempaddr()[0] = conn.getTempaddr()[0].getAi_next();
		}
		if (conn.getTempsock()[0] == (SOCKET)(~0)) {
			if (!result) {
				result = .CURLE_COULDNT_CONNECT;
			} 
			return result;
		} 
		data.getInfo().getNumconnects()++;
		ModernizedCProgram.Curl_expire(conn.getData(), data.getSet().getHappy_eyeballs_timeout(), .EXPIRE_HAPPY_EYEBALLS);
		return .CURLE_OK;
	}
	public static int conn_is_conn(Object conn, Object param) {
		connfind f = (connfind)param;
		if (conn == f.getTofind()) {
			f.setFound(1);
			return 1;
		} 
		return 0/*
		 * Used to extract socket and connectdata struct for the most recent
		 * transfer on the given Curl_easy.
		 *
		 * The returned socket will be CURL_SOCKET_BAD in case of failure!
		 */;
	}
	public static Object Curl_getconnectinfo(Object data, Object connp) {
		do {
		} while (0/* this works for an easy handle:
		   * - that has been used for curl_easy_perform()
		   * - that is associated with a multi handle, and whose connection
		   *   was detached with CURLOPT_CONNECT_ONLY
		   */);
		 generatedFound = find.getFound();
		if (data.getState().getLastconnect() && (data.getMulti_easy() || data.getMulti())) {
			connectdata c = data.getState().getLastconnect();
			connfind find = new connfind();
			find.setTofind(data.getState().getLastconnect());
			find.setFound(0);
			ModernizedCProgram.Curl_conncache_foreach(data, data.getMulti_easy() ? data.getMulti_easy().getConn_cache() : data.getMulti().getConn_cache(), find, conn_is_conn);
			if (!generatedFound) {
				data.getState().setLastconnect(((Object)0));
				return (SOCKET)(~0);
			} 
			if (connp) {
				connp = /* only store this if the caller cares for it */c;
				c.setData(data);
			} 
			return c.getSock()[0];
		} else {
				return (SOCKET)(~0/*
				 * Check if a connection seems to be alive.
				 */);
		} 
	}
	public static  Curl_connalive(Object conn) {
		if (conn.getSsl()[0].getUse()) {
			if (!/* use the SSL context */false) {
				return /* FIN received */.bool_false;
			} 
		}  else if (conn.getSock()[0] == (SOCKET)(~/* Minix 3.1 doesn't support any flags on recv; just assume socket is OK */0)) {
			return .bool_false;
		} else {
				byte buf;
				if (.recv((SOCKET)conn.getSock()[0], (byte)buf, (int)1, (int)2) == 0) {
					return /* FIN received */.bool_false;
				} 
		} 
		return .bool_true/*
		 * Close a socket.
		 *
		 * 'conn' can be NULL, beware!
		 */;
	}
	public static int Curl_closesocket(Object conn, Object sock) {
		if (conn && conn.getFclosesocket()) {
			if ((sock == conn.getSock()[1]) && conn.getSock_accepted()[1/* if this socket matches the second socket, and that was created with
			         accept, then we MUST NOT call the callback but clear the accepted
			         status */]) {
				conn.getSock_accepted()[1] = 0;
			} else {
					int rc;
					ModernizedCProgram.Curl_multi_closed(conn.getData(), sock);
					ModernizedCProgram.Curl_set_in_callback(conn.getData(), .bool_true);
					rc = .UNRECOGNIZEDFUNCTIONNAME(conn.getClosesocket_client(), sock);
					ModernizedCProgram.Curl_set_in_callback(conn.getData(), .bool_false);
					return rc;
			} 
		} 
		if (conn) {
			ModernizedCProgram.Curl_multi_closed(conn.getData(), /* tell the multi-socket code about this */sock);
		} 
		.closesocket((sock));
		return 0/*
		 * Create a socket based on info from 'conn' and 'ai'.
		 *
		 * 'addr' should be a pointer to the correct struct to get data back, or NULL.
		 * 'sockfd' must be a pointer to a socket descriptor.
		 *
		 * If the open socket callback is set, used that!
		 *
		 */;
	}
	public static  Curl_socket(Object conn, Object ai, Object addr, Object sockfd) {
		Curl_easy data = conn.getData();
		Curl_sockaddr_ex dummy = new Curl_sockaddr_ex();
		if (!addr) {
			addr = /* if the caller doesn't want info back, use a local temp copy */dummy/*
			   * The Curl_sockaddr_ex structure is basically libcurl's external API
			   * curl_sockaddr structure with enough space available to directly hold
			   * any protocol-specific address structures. The variable declared here
			   * will be used to pass / receive data to/from the fopensocket callback
			   * if this has been set, before that, it is initialized from parameters.
			   */;
		} 
		addr.setFamily(ai.getAi_family());
		addr.setSocktype((conn.getTransport() == .TRNSPRT_TCP) ? 1 : 2);
		addr.setProtocol(conn.getTransport() != .TRNSPRT_TCP ? 17 : ai.getAi_protocol());
		addr.setAddrlen(ai.getAi_addrlen());
		if (addr.getAddrlen() > ) {
			addr.setAddrlen();
		} 
		.memcpy(addr.get_sa_ex_u().getAddr(), ai.getAi_addr(), addr.getAddrlen());
		if (data.getSet().getFopensocket()) {
			ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
			sockfd = .UNRECOGNIZEDFUNCTIONNAME(data.getSet().getOpensocket_client(), .CURLSOCKTYPE_IPCXN, (curl_sockaddr)addr);
			ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
		} else {
				sockfd = .socket(addr.getFamily(), addr.getSocktype(), addr.getProtocol());
		} 
		if (sockfd == (SOCKET)(~0)) {
			return /* no socket, no connection */.CURLE_COULDNT_CONNECT;
		} 
		return .CURLE_OK;
	}
	/*
	 * Curl_conncontrol() marks streams or connection for closure.
	 */
	public static void Curl_conncontrol(Object conn, int ctrl) {
		bool closeit = (ctrl == /* close if a connection, or a stream that isn't multiplexed */1) || ((ctrl == 2) && !(conn.getHandler().getFlags() & (1 << 9)));
		if ((ctrl == 2) && (conn.getHandler().getFlags() & (1 << 9))) {
			do {
			} while (0);
		}  else if ((bit)closeit != conn.getBits().getClose()) {
			do {
			} while (0);
			conn.getBits().setClose(/* the only place in the source code that
			                                   should assign this bit */closeit);
		} 
	}
	/* see defines in header */
	/* Data received can be cached at various levels, so check them all here. */
	public static  Curl_conn_data_pending(Object conn, int sockindex) {
		int readable;
		if (false || ModernizedCProgram.Curl_recv_has_postponed_data(conn, sockindex)) {
			return .bool_true;
		} 
		readable = ModernizedCProgram.Curl_socket_check(conn.getSock()[sockindex], (SOCKET)(~0), (SOCKET)(~0), (time_t)0);
		return (readable > 0 && (readable & -1024));
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* zlib pollutes the namespace with this definition */
	/* buffer size for decompressed data */
	/* Comment this out if zlib is always going to be at least ver. 1.2.0.4
	   (doing so will reduce code size slightly). */
	/* gzip flag byte */
	/* bit 0 set: file probably ascii text */
	/* bit 1 set: header CRC present */
	/* bit 2 set: extra field present */
	/* bit 3 set: original file name present */
	/* bit 4 set: file comment present */
	/* bits 5..7: reserved */
	/* uninitialized */
	/* initialized */
	/* inflating started. */
	/* reading external trailer */
	/* reading gzip header */
	/* inflating gzip stream */
	/* initialized in transparent gzip mode */
	/* Writer parameters. */
	/* zlib init state */
	/* Remaining trailer byte count. */
	/* State structure for zlib. */
	/* not a typo, keep it calloc() */
	/* Consume expected trailer bytes. Terminate stream if exhausted.
	     Issue an error if unexpected bytes follow. */
	/* Only occurs for gzip with zlib < 1.2.0.4 or raw deflate. */
	/* zlib state structure */
	/* Curl_client_write status */
	/* Put the decompressed data here. */
	/* Check state. */
	/* Dynamically allocate a buffer for decompression because it's uncommonly
	     large to hold on the stack */
	/* because the buffer size is fixed, iteratively decompress and transfer to
	     the client via downstream_write function. */
	/* zlib status */
	/* (re)set buffer for decompressed output for every iteration */
	/* Z_BLOCK is only available in zlib ver. >= 1.2.0.5 */
	/* fallback for zlib ver. < 1.2.0.5 */
	/* Flush output data if some. */
	/* Data started. */
	/* Dispatch by inflate() status. */
	/* Always loop: there may be unflushed latched data in zlib state. */
	/* No more data to flush: just exit loop. */
	/* some servers seem to not generate zlib headers, so this is an attempt
	         to fix and continue anyway */
	/* Do not use inflateReset2(): only available since zlib 1.2.3.4. */
	/* don't care about the return code */
	/* Tolerate up to 4 unknown trailer bytes. */
	/* inflateEnd() already called. */
	/* FALLTHROUGH */
	/* We're about to leave this call so the `nread' data bytes won't be seen
	     again. If we are in a state that would wrongly allow restart in raw mode
	     at the next call, assume output has already started. */
	/* Cannot restart anymore. */
	/* Deflate handler. */
	/* zlib state structure */
	/* Initialize zlib */
	/* zlib state structure */
	/* Set the compressed input when this function is called */
	/* Now uncompress the data */
	/* zlib state structure */
	/* Gzip handler. */
	/* zlib state structure */
	/* Initialize zlib */
	/* zlib ver. >= 1.2.0.4 supports transparent gzip decompressing */
	/* Transparent gzip decompress state */
	/* we must parse the gzip header and trailer ourselves */
	/* A CRC-32 and a 32-bit input size (RFC 1952, 2.2) */
	/* Initial call state */
	/* Skip over the gzip header */
	/* The shortest header is 10 bytes */
	/* Can't handle this compression method or unknown flag */
	/* Skip over time, xflags, OS code and all previous bytes */
	/* Skip over NUL-terminated file name */
	/* Skip over the NUL */
	/* Skip over NUL-terminated comment */
	/* Skip over the NUL */
	/* zlib state structure */
	/* Let zlib handle the gzip decompression entirely */
	/* Now uncompress the data */
	/* Support for old zlib versions is compiled away and we are running with
	     an old version, so return an error. */
	/* This next mess is to get around the potential case where there isn't
	   * enough data passed in to skip over the gzip header.  If that happens, we
	   * malloc a block and copy what we have then wait for the next call.  If
	   * there still isn't enough (this is definitely a worst-case scenario), we
	   * make the block bigger, copy the next part in and keep waiting.
	   *
	   * This is only required with zlib versions < 1.2.0.4 as newer versions
	   * can handle the gzip header themselves.
	   */
	/* Skip over gzip header? */
	/* Initial call state */
	/* Inflating stream state */
	/* We need more data so we can find the end of the gzip header.  It's
	       * possible that the memory block we malloc here will never be freed if
	       * the transfer abruptly aborts after this point.  Since it's unlikely
	       * that circumstances will be right for this code path to be followed in
	       * the first place, and it's even more unlikely for a transfer to fail
	       * immediately afterwards, it should seldom be a problem.
	       */
	/* Need more gzip header data state */
	/* We don't have any data to inflate yet */
	/* Need more gzip header data state */
	/* Append the new block of data to the previous one */
	/* This is the zlib stream data */
	/* Don't point into the malloced block since we just freed it */
	/* Inflating stream state */
	/* We still don't have any data to inflate! */
	/* Inflating stream state */
	/* We don't have any data to inflate; wait until next time */
	/* We've parsed the header, now uncompress the data */
	/* zlib state structure */
	/* HAVE_LIBZ */
	/* Writer parameters. */
	/* State structure for brotli. */
	/* Stream already ended. */
	/* Identity handler. */
	public static  identity_init_writer(Object conn, Object writer) {
		(Object)conn;
		return writer.getDownstream() ? .CURLE_OK : .CURLE_WRITE_ERROR;
	}
	public static  identity_unencode_write(Object conn, Object writer, Object buf, Object nbytes) {
		return ModernizedCProgram.Curl_unencode_write(conn, writer.getDownstream(), buf, nbytes);
	}
	public static void identity_close_writer(Object conn, Object writer) {
		(Object)conn;
		(Object)writer;
	}
	/* Return a list of comma-separated names of supported encodings. */
	public static Object Curl_all_content_encodings() {
		size_t len = 0;
		content_encoding cep = new content_encoding();
		content_encoding ce = new content_encoding();
		byte ace;
		for (cep = ModernizedCProgram.encodings; cep; cep++) {
			ce = cep;
			if (!ModernizedCProgram.Curl_strcasecompare(ce.getName(), "identity")) {
				len += .strlen(ce.getName()) + 2;
			} 
		}
		if (!len) {
			return .Curl_cstrdup("identity");
		} 
		ace = .Curl_cmalloc(len);
		if (ace) {
			byte p = ace;
			for (cep = ModernizedCProgram.encodings; cep; cep++) {
				ce = cep;
				if (!ModernizedCProgram.Curl_strcasecompare(ce.getName(), "identity")) {
					.strcpy(p, ce.getName());
					p += .strlen(p);
					p++ = (byte)',';
					p++ = (byte)' ';
				} 
			}
			p[-2] = (byte)'\0';
		} 
		return ace;
	}
	/* Real client writer: no downstream. */
	public static  client_init_writer(Object conn, Object writer) {
		(Object)conn;
		return writer.getDownstream() ? .CURLE_WRITE_ERROR : .CURLE_OK;
	}
	public static  client_unencode_write(Object conn, Object writer, Object buf, Object nbytes) {
		Curl_easy data = conn.getData();
		SingleRequest k = data.getReq();
		(Object)writer;
		if (!nbytes || k.getIgnorebody()) {
			return .CURLE_OK;
		} 
		return ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)buf, nbytes);
	}
	public static void client_close_writer(Object conn, Object writer) {
		(Object)conn;
		(Object)writer;
	}
	/* Deferred error dummy writer. */
	public static  error_init_writer(Object conn, Object writer) {
		(Object)conn;
		return writer.getDownstream() ? .CURLE_OK : .CURLE_WRITE_ERROR;
	}
	public static  error_unencode_write(Object conn, Object writer, Object buf, Object nbytes) {
		byte all = ModernizedCProgram.Curl_all_content_encodings();
		(Object)writer;
		(Object)buf;
		(Object)nbytes;
		if (!all) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		ModernizedCProgram.Curl_failf(conn.getData(), "Unrecognized content encoding type. libcurl understands %s content encodings.", all);
		.Curl_cfree(all);
		return .CURLE_BAD_CONTENT_ENCODING;
	}
	public static void error_close_writer(Object conn, Object writer) {
		(Object)conn;
		(Object)writer;
	}
	/* Create an unencoding writer stage using the given handler. */
	public static Object new_unencoding_writer(Object conn, Object handler, Object downstream) {
		size_t sz = ((size_t)((contenc_writer)0).getParams()) + handler.getParamsize();
		contenc_writer writer = (contenc_writer).Curl_ccalloc(1, sz);
		if (writer) {
			writer.setHandler(handler);
			writer.setDownstream(downstream);
			if (.UNRECOGNIZEDFUNCTIONNAME(conn, writer)) {
				.Curl_cfree(writer);
				writer = ((Object)0);
			} 
		} 
		return writer;
	}
	/* Write data using an unencoding writer stack. */
	public static  Curl_unencode_write(Object conn, Object writer, Object buf, Object nbytes) {
		if (!nbytes) {
			return .CURLE_OK;
		} 
		return .UNRECOGNIZEDFUNCTIONNAME(conn, writer, buf, nbytes);
	}
	/* Close and clean-up the connection's writer stack. */
	public static void Curl_unencode_cleanup(Object conn) {
		Curl_easy data = conn.getData();
		SingleRequest k = data.getReq();
		contenc_writer writer = k.getWriter_stack();
		while (writer) {
			k.setWriter_stack(writer.getDownstream());
			.UNRECOGNIZEDFUNCTIONNAME(conn, writer);
			.Curl_cfree(writer);
			writer = k.getWriter_stack();
		}
	}
	/* Find the content encoding by name. */
	public static Object find_encoding(Object name, Object len) {
		content_encoding cep = new content_encoding();
		for (cep = ModernizedCProgram.encodings; cep; cep++) {
			content_encoding ce = cep;
			if ((ModernizedCProgram.Curl_strncasecompare(name, ce.getName(), len) && !ce.getName()[len]) || (ce.getAlias() && ModernizedCProgram.Curl_strncasecompare(name, ce.getAlias(), len) && !ce.getAlias()[len])) {
				return ce;
			} 
		}
		return ((Object)0);
	}
	/* Set-up the unencoding stack from the Content-Encoding header value.
	 * See RFC 7231 section 3.1.2.2. */
	public static  Curl_build_unencoding_stack(Object conn, Object enclist, int maybechunked) {
		Curl_easy data = conn.getData();
		SingleRequest k = data.getReq();
		do {
			byte name;
			size_t namelen = new size_t();
			while ((ModernizedCProgram.Curl_isspace((int)((byte)enclist))) || enclist == /* Parse a single encoding name. */(byte)',') {
				enclist++;
			}
			name = enclist;
			for (namelen = 0; enclist && enclist != (byte)','; enclist++) {
				if (!(ModernizedCProgram.Curl_isspace((int)((byte)enclist)))) {
					namelen = enclist - name + 1;
				} 
			}
			if (maybechunked && namelen == 7 && ModernizedCProgram.Curl_strncasecompare(name, "chunked", /* Special case: chunked encoding is handled at the reader level. */7)) {
				k.setChunk(/* chunks coming our way. */1);
				ModernizedCProgram.Curl_httpchunk_init(/* init our chunky engine. */conn);
			}  else if (namelen) {
				content_encoding encoding = ModernizedCProgram.find_encoding(name, namelen);
				contenc_writer writer = new contenc_writer();
				if (!k.getWriter_stack()) {
					k.setWriter_stack(ModernizedCProgram.new_unencoding_writer(conn, ModernizedCProgram.client_encoding, ((Object)0)));
					if (!k.getWriter_stack()) {
						return .CURLE_OUT_OF_MEMORY;
					} 
				} 
				if (!encoding) {
					encoding = /* Defer error at stack use. */ModernizedCProgram.error_encoding;
				} 
				writer = ModernizedCProgram.new_unencoding_writer(conn, encoding, k.getWriter_stack());
				if (!writer) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				k.setWriter_stack(writer);
			} 
		} while (enclist);
		return .CURLE_OK/* Stubs for builds without HTTP. *//* Satisfy caller. *//* CURL_DISABLE_HTTP */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	public static  randit(Object data, Object rnd) {
		int r;
		CURLcode result = .CURLE_OK;
		int randseed;
		bool seeded = 0;
		result = ();
		if (result != .CURLE_NOT_BUILT_IN/* only if there is no random function in the TLS backend do the non crypto
		       version, otherwise return result */) {
			return result/* ---- non-cryptographic version following ---- *//* if there's a random file to read a seed from, use it */;
		} 
		curltime curltime = new curltime();
		int generatedTv_usec = now.getTv_usec();
		Object generatedTv_sec = now.getTv_sec();
		if (!/* read random data into the randseed variable */seeded) {
			curltime now = curltime.Curl_now();
			ModernizedCProgram.Curl_infof(data, "WARNING: Using weak random seed\n");
			randseed += (int)generatedTv_usec + (int)generatedTv_sec;
			randseed = randseed * 1103515245 + 12345;
			randseed = randseed * 1103515245 + 12345;
			randseed = randseed * 1103515245 + 12345;
			seeded = 1;
		} 
		r = randseed = randseed * 1103515245 + /* Return an unsigned 32-bit pseudo-random number. */12345;
		rnd = (r << 16) | ((r >> 16) & -1024);
		return .CURLE_OK/*
		 * Curl_rand() stores 'num' number of random unsigned integers in the buffer
		 * 'rndptr' points to.
		 *
		 * If libcurl is built without TLS support or with a TLS backend that lacks a
		 * proper random API (Gskit or mbedTLS), this function will use "weak" random.
		 *
		 * When built *with* TLS support and a backend that offers strong random, it
		 * will return error if it cannot provide strong random values.
		 *
		 * NOTE: 'data' may be passed in as NULL when coming from external API without
		 * easy handle!
		 *
		 */;
	}
	public static  Curl_rand(Object data, Object rnd, Object num) {
		CURLcode result = .CURLE_BAD_FUNCTION_ARGUMENT;
		do {
		} while (0);
		while (num) {
			int r;
			size_t left = num <  ? num : ;
			result = ModernizedCProgram.randit(data, r);
			if (result) {
				return result;
			} 
			while (left) {
				rnd++ = (byte)(r & -1024);
				r >>=  8;
				--num;
				--left;
			}
		}
		return result/*
		 * Curl_rand_hex() fills the 'rnd' buffer with a given 'num' size with random
		 * hexadecimal digits PLUS a zero terminating byte. It must be an odd number
		 * size.
		 */;
	}
	public static  Curl_rand_hex(Object data, Object rnd, Object num) {
		CURLcode result = .CURLE_BAD_FUNCTION_ARGUMENT;
		byte hex = "0123456789abcdef";
		byte[] buffer = new byte[128];
		byte bufp = buffer;
		do {
		} while (0/* This silences a scan-build warning about accessing this buffer with
		     uninitialized memory. */);
		if ((num / 2 >= ) || !(num & 1)) {
			return /* make sure it fits in the local buffer and that it is an odd number! */.CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		/* save one for zero termination */num--;
		result = ModernizedCProgram.Curl_rand(data, buffer, num / 2);
		if (result) {
			return result;
		} 
		while (num/* clang-tidy warns on this line without this comment: */) {
			rnd++ = hex[(bufp & -1024) >> /* NOLINTNEXTLINE(clang-analyzer-core.UndefinedBinaryOperatorResult) */4];
			rnd++ = hex[bufp & -1024];
			bufp++;
			num -= 2;
		}
		rnd = 0;
		return result;
	}
	public static int checkday(Object check, Object len) {
		int i;
		byte what;
		bool found = 0;
		if (len > 3) {
			what = ModernizedCProgram.weekday[0];
		} else {
				what = ModernizedCProgram.Curl_wkday[0];
		} 
		for (i = 0; i < 7; i++) {
			if (ModernizedCProgram.Curl_strcasecompare(check, what[0])) {
				found = 1;
				break;
			} 
			what++;
		}
		return found ? i : -1;
	}
	public static int checkmonth(Object check) {
		int i;
		byte what;
		bool found = 0;
		what = ModernizedCProgram.Curl_month[0];
		for (i = 0; i < 12; i++) {
			if (ModernizedCProgram.Curl_strcasecompare(check, what[0])) {
				found = 1;
				break;
			} 
			what++;
		}
		return found ? i : -/* return the offset or -1, no real offset is -1 */1/* return the time zone offset between GMT and the input one, in number
		   of seconds or -1 if the timezone wasn't found/legal */;
	}
	public static int checktz(Object check) {
		int i;
		tzinfo what = new tzinfo();
		bool found = 0;
		what = ModernizedCProgram.tz;
		for (i = 0; i <  / ; i++) {
			if (ModernizedCProgram.Curl_strcasecompare(check, what.getName())) {
				found = 1;
				break;
			} 
			what++;
		}
		return found ? what.getOffset() * 60 : -1;
	}
	public static void skip(Object date) {
		while (date && !(ModernizedCProgram.Curl_isalnum((int)((byte)/* skip everything that aren't letters or digits */date)))) {
			(date)++;
		}
	}
	public static void my_timegm(Object tm, Object t) {
		int[] month_days_cumulative = new int[]{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
		int month;
		int year;
		int leap_days;
		year = tm.getTm_year();
		month = tm.getTm_mon();
		if (month < 0) {
			year += (11 - month) / 12;
			month = 11 - (11 - month) % 12;
		}  else if (month >= 12) {
			year -= month / 12;
			month = month % 12;
		} 
		leap_days = year - (tm.getTm_mon() <= 1);
		leap_days = ((leap_days / 4) - (leap_days / 100) + (leap_days / 400) - (1969 / 4) + (1969 / 100) - (1969 / 400));
		t = ((((time_t)(year - 1970) * 365 + leap_days + month_days_cumulative[month] + tm.getTm_mday() - 1) * 24 + tm.getTm_hour()) * 60 + tm.getTm_min()) * 60 + tm.getTm_sec();
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/*
	  A brief summary of the date string formats this parser groks:
	
	  RFC 2616 3.3.1
	
	  Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
	  Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
	  Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
	
	  we support dates without week day name:
	
	  06 Nov 1994 08:49:37 GMT
	  06-Nov-94 08:49:37 GMT
	  Nov  6 08:49:37 1994
	
	  without the time zone:
	
	  06 Nov 1994 08:49:37
	  06-Nov-94 08:49:37
	
	  weird order:
	
	  1994 Nov 6 08:49:37  (GNU date fails)
	  GMT 08:49:37 06-Nov-94 Sunday
	  94 6 Nov 08:49:37    (GNU date fails)
	
	  time left out:
	
	  1994 Nov 6
	  06-Nov-94
	  Sun Nov 6 94
	
	  unusual separators:
	
	  1994.Nov.6
	  Sun/Nov/6/94/GMT
	
	  commonly used time zone names:
	
	  Sun, 06 Nov 1994 08:49:37 CET
	  06 Nov 1994 08:49:37 EST
	
	  time zones specified using RFC822 style:
	
	  Sun, 12 Sep 2004 15:05:58 -0700
	  Sat, 11 Sep 2004 21:32:11 +0200
	
	  compact numerical date strings:
	
	  20040912 15:05:58 -0700
	  20040911 +0200
	
	*/
	/*
	 * parsedate()
	 *
	 * Returns:
	 *
	 * PARSEDATE_OK     - a fine conversion
	 * PARSEDATE_FAIL   - failed to convert
	 * PARSEDATE_LATER  - time overflow at the far end of time_t
	 * PARSEDATE_SOONER - time underflow at the low end of time_t
	 */
	public static int parsedate(Object date, Object output) {
		time_t t = 0;
		int wdaynum = -/* day of the week number, 0-6 (mon-sun) */1;
		int monnum = -/* month of the year number, 0-11 */1;
		int mdaynum = -/* day of month, 1 - 31 */1;
		int hournum = -1;
		int minnum = -1;
		int secnum = -1;
		int yearnum = -1;
		int tzoff = -1;
		my_tm tm = new my_tm();
		assume dignext = assume.DATE_MDAY;
		byte indate = /* save the original pointer */date;
		int part = /* max 6 parts */0;
		while (date && (part < 6)) {
			bool found = 0;
			ModernizedCProgram.skip(date);
			if ((ModernizedCProgram.Curl_isalpha((int)((byte)date)))) {
				byte[] buf = /* a name coming up */"";
				size_t len = new size_t();
				if (.sscanf(date, "%31[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]", buf)) {
					len = .strlen(buf);
				} else {
						len = 0;
				} 
				if (wdaynum == -1) {
					wdaynum = ModernizedCProgram.checkday(buf, len);
					if (wdaynum != -1) {
						found = 1;
					} 
				} 
				if (!found && (monnum == -1)) {
					monnum = ModernizedCProgram.checkmonth(buf);
					if (monnum != -1) {
						found = 1;
					} 
				} 
				if (!found && (tzoff == -1)) {
					tzoff = ModernizedCProgram.checktz(/* this just must be a time zone string */buf);
					if (tzoff != -1) {
						found = 1;
					} 
				} 
				if (!found) {
					return -/* bad string */1;
				} 
				date += len;
			}  else if ((ModernizedCProgram.Curl_isdigit((int)((byte)date/* a digit */)))) {
				int val;
				byte end;
				int len = 0;
				if ((secnum == -1) && (3 == .sscanf(date, "%02d:%02d:%02d%n", hournum, minnum, secnum, len))) {
					date += /* time stamp! */len;
				}  else if ((secnum == -1) && (2 == .sscanf(date, "%02d:%02d%n", hournum, minnum, len))) {
					date += /* time stamp without seconds */len;
					secnum = 0;
				} else {
						long lval;
						int error;
						int old_errno;
						old_errno = (._errno());
						(._errno()) = 0;
						lval = .strtol(date, end, 10);
						error = (._errno());
						if ((._errno()) != old_errno) {
							(._errno()) = old_errno;
						} 
						if (error) {
							return -1;
						} 
						val = ModernizedCProgram.curlx_sltosi(lval);
						if ((tzoff == -1) && ((end - date) == 4) && (val <= 1400) && (indate < date) && ((date[-1] == (byte)'+' || date[-1] == (byte)'-'/* four digits and a value less than or equal to 1400 (to take into
						             account all sorts of funny time zone diffs) and it is preceded
						             with a plus or minus. This is a time zone indication.  1400 is
						             picked since +1300 is frequently used and +1400 is mentioned as
						             an edge number in the document "ISO C 200X Proposal: Timezone
						             Functions" at http://david.tribble.com/text/c0xtimezone.html If
						             anyone has a more authoritative source for the exact maximum time
						             zone offsets, please speak up! */))) {
							found = 1;
							tzoff = (val / 100 * 60 + val % 100) * 60;
							tzoff = date[-1] == (byte)'+' ? -tzoff : /* the + and - prefix indicates the local time compared to GMT,
							             this we need their reversed math to get what we want */tzoff;
						} 
						if (((end - date) == 8) && (yearnum == -1) && (monnum == -1) && (mdaynum == -1)) {
							found = /* 8 digits, no year, month or day yet. This is YYYYMMDD */1;
							yearnum = val / 10000;
							monnum = (val % 10000) / 100 - /* month is 0 - 11 */1;
							mdaynum = val % 100;
						} 
						if (!found && (assume.dignext == assume.DATE_MDAY) && (mdaynum == -1)) {
							if ((val > 0) && (val < 32)) {
								mdaynum = val;
								found = 1;
							} 
							assume.dignext = assume.DATE_YEAR;
						} 
						if (!found && (assume.dignext == assume.DATE_YEAR) && (yearnum == -1)) {
							yearnum = val;
							found = 1;
							if (yearnum < 100) {
								if (yearnum > 70) {
									yearnum += 1900;
								} else {
										yearnum += 2000;
								} 
							} 
							if (mdaynum == -1) {
								assume.dignext = assume.DATE_MDAY;
							} 
						} 
						if (!found) {
							return -1;
						} 
						date = end;
				} 
			} 
			part++;
		}
		if (-1 == secnum) {
			secnum = minnum = hournum = /* no time, make it zero */0;
		} 
		if ((-1 == mdaynum) || (-1 == monnum) || (-1 == yearnum)) {
			return -/* lacks vital info, fail */1/* only positive numbers cannot return earlier */;
		} 
		if (yearnum > /* an unsigned 32 bit time_t can only hold dates to 2106 *//* a signed 32 bit time_t can only hold dates to the beginning of 2038 */2037) {
			output = 2147483647;
			return 1;
		} 
		if (yearnum < 1903) {
			output = (-2147483647 - 1);
			return 2;
		} 
		if ((mdaynum > 31) || (monnum > /* The Gregorian calendar was introduced 1582 */11) || (hournum > 23) || (minnum > 59) || (secnum > 60)) {
			return -/* clearly an illegal date */1;
		} 
		tm.setTm_sec(secnum);
		tm.setTm_min(minnum);
		tm.setTm_hour(hournum);
		tm.setTm_mday(mdaynum);
		tm.setTm_mon(monnum);
		tm.setTm_year(yearnum/* my_timegm() returns a time_t. time_t is often 32 bits, sometimes even on
		     architectures that feature 64 bit 'long' but ultimately time_t is the
		     correct data type to use.
		  */);
		ModernizedCProgram.my_timegm(tm, t);
		if (tzoff == -/* Add the time zone diff between local time zone and GMT. */1) {
			tzoff = 0;
		} 
		if ((tzoff > 0) && (t > 2147483647 - tzoff)) {
			output = 2147483647;
			return /* time_t overflow */1;
		} 
		t += tzoff;
		output = t;
		return 0/* disabled */;
	}
	/* a lie */
	public static Object curl_getdate(Object p, Object now) {
		time_t parsed = -1;
		int rc = ModernizedCProgram.parsedate(p, parsed);
		(Object)/* legacy argument from the past that we ignore */now;
		if (rc == 0) {
			if (parsed == -1) {
				/* avoid returning -1 for a working scenario */parsed++;
			} 
			return parsed;
		} 
		return -/* everything else is fail */1/*
		 * Curl_gmtime() is a gmtime() replacement for portability. Do not use the
		 * gmtime_r() or gmtime() functions anywhere else but here.
		 *
		 */;
	}
	public static  Curl_gmtime(Object intime, Object store) {
		tm tm = new tm();
		/* thread-safe version */
		tm = .gmtime(intime);
		if (tm) {
			store = /* copy the pointed struct to the local copy */tm;
		} 
		if (!tm) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		return .CURLE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* this file is only for systems without getpass_r() */
	/* this file is only for systems without getpass_r() */
	/* keep this as LAST include */
	/* VMS implementation */
	/* MSK, 23-JAN-2004, iosbdef.h wasn't in VAX V7.2 or CC 6.4  */
	/* distribution so I created this.  May revert back later to */
	/* struct _iosb iosb;                                        */
	/* status     */
	/* byte count */
	/* unused     */
	/* we always return success */
	/* __VMS */
	public static Object getpass_r(Object prompt, Object buffer, Object buflen) {
		size_t i = new size_t();
		.fputs(prompt, (_iob[2]));
		for (i = 0; i < buflen; i++) {
			buffer[i] = (byte).getch();
			if (buffer[i] == (byte)'\r' || buffer[i] == (byte)'\n') {
				buffer[i] = (byte)'\0';
				break;
			}  else if (buffer[i] == (byte)'\b'/* remove this letter and if this is not the first key, remove the
			           previous one as well */) {
				i = i - (i >= 1 ? 2 : 1);
			} 
		}
		.fputs("\n", (_iob[/* since echo is disabled, print a newline *//* since echo is disabled, print a newline */2]));
		if (i == /* if user didn't hit ENTER, terminate buffer */buflen) {
			buffer[buflen - 1] = (byte)'\0';
		} 
		return /* we always return success */buffer/* WIN32 || __SYMBIAN32__ *//* NetWare implementation *//* remove this letter and if this is not the first key,
		         remove the previous one as well *//* __NOVELL_LIBC__ *//* NETWARE *//* not previously provided *//* disable echo by extracting the current 'withecho' mode and remove the
		       ECHO bit and set back the struct *//* neither HAVE_TERMIO_H nor HAVE_TERMIOS_H, we can't disable echo! *//* not disabled *//* disabled *//* re-enable echo, assumes we disabled it before (and set the structs we
		     now use to reset the terminal status) *//* not enabled *//* enabled *//* prompt to display *//* buffer to store password in *//* size of buffer to store password in *//* use stdin if the tty couldn't be used *//* disable terminal echo *//* zero terminate where enter is stored *//* got nothing *//* if echo actually was disabled, add a newline *//* enable echo *//* return pointer to buffer *//* DONE *//* HAVE_GETPASS_R */;
	}
	public static int Curl_num_addresses(Object addr) {
		int i = 0;
		while (addr) {
			addr = addr.getAi_next();
			i++;
		}
		return i/*
		 * Curl_printable_address() returns a printable version of the 1st address
		 * given in the 'ai' argument. The result will be stored in the buf that is
		 * bufsize bytes big.
		 *
		 * If the conversion fails, it returns NULL.
		 */;
	}
	public static Object Curl_printable_address(Object ai, Object buf, Object bufsize) {
		sockaddr_in sa4 = new sockaddr_in();
		in_addr ipaddr4 = new in_addr();
		switch (ai.getAi_family()) {
		case 2:
				sa4 = (Object)ai.getAi_addr();
				ipaddr4 = sa4.getSin_addr();
				return ModernizedCProgram.Curl_inet_ntop(ai.getAi_family(), (Object)ipaddr4, buf, bufsize);
		default:
				break;
		}
		return ((Object)0/*
		 * Create a hostcache id string for the provided host + port, to be used by
		 * the DNS caching. Without alloc.
		 */);
	}
	public static void create_hostcache_id(Object name, int port, Object ptr, Object buflen) {
		size_t len = .strlen(name);
		if (len > (buflen - 7)) {
			len = buflen - 7;
		} 
		while (/* store and lower case the name */len--) {
			ptr++ = (byte)(.tolower((int)((byte)name++)));
		}
		ModernizedCProgram.curl_msnprintf(ptr, 7, ":%u", port);
	}
	public static int hostcache_timestamp_remove(Object datap, Object hc) {
		hostcache_prune_data data = (hostcache_prune_data)datap;
		Curl_dns_entry c = (Curl_dns_entry)hc;
		return (0 != c.getTimestamp()) && (data.getNow() - c.getTimestamp() >= data.getCache_timeout());
	}
	public static void hostcache_prune(Object hostcache, long cache_timeout, Object now) {
		hostcache_prune_data user = new hostcache_prune_data();
		user.setCache_timeout(cache_timeout);
		user.setNow(now);
		ModernizedCProgram.Curl_hash_clean_with_criterium(hostcache, (Object)user, hostcache_timestamp_remove/*
		 * Library-wide function for pruning the DNS cache. This function takes and
		 * returns the appropriate locks.
		 */);
	}
	public static void Curl_hostcache_prune(Object data) {
		time_t now = new time_t();
		if ((data.getSet().getDns_cache_timeout() == -1) || !data.getDns().getHostcache()) {
			return ;
		} 
		if (data.getShare()) {
			ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_DNS, .CURL_LOCK_ACCESS_SINGLE);
		} 
		.time(now);
		ModernizedCProgram.hostcache_prune(data.getDns().getHostcache(), data.getSet().getDns_cache_timeout(), now);
		if (data.getShare()) {
			ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_DNS/* Beware this is a global and unique instance. This is used to store the
			   return address that we can jump back to from inside a signal handler. This
			   is not thread-safe stuff. */);
		} 
	}
	public static Object fetch_addr(Object conn, Object hostname, int port) {
		Curl_dns_entry dns = ((Object)0);
		size_t entry_len = new size_t();
		Curl_easy data = conn.getData();
		byte[] entry_id = new byte[(255 + 7)];
		ModernizedCProgram.create_hostcache_id(hostname, port, entry_id, );
		entry_len = .strlen(entry_id);
		dns = ModernizedCProgram.Curl_hash_pick(data.getDns().getHostcache(), entry_id, entry_len + /* See if its already in our dns cache */1);
		if (!dns && data.getChange().getWildcard_resolve()) {
			ModernizedCProgram.create_hostcache_id("*", port, entry_id, );
			entry_len = .strlen(entry_id);
			dns = ModernizedCProgram.Curl_hash_pick(data.getDns().getHostcache(), entry_id, entry_len + /* See if it's already in our dns cache */1);
		} 
		Object generatedNow = user.getNow();
		if (dns && (data.getSet().getDns_cache_timeout() != -1/* See whether the returned entry is stale. Done before we release lock */)) {
			hostcache_prune_data user = new hostcache_prune_data();
			.time(generatedNow);
			user.setCache_timeout(data.getSet().getDns_cache_timeout());
			if (ModernizedCProgram.hostcache_timestamp_remove(user, dns)) {
				ModernizedCProgram.Curl_infof(data, "Hostname in DNS cache was stale, zapped\n");
				dns = ((Object)/* the memory deallocation is being handled by the hash */0);
				ModernizedCProgram.Curl_hash_delete(data.getDns().getHostcache(), entry_id, entry_len + 1);
			} 
		} 
		return dns/*
		 * Curl_fetch_addr() fetches a 'Curl_dns_entry' already in the DNS cache.
		 *
		 * Curl_resolv() checks initially and multi_runsingle() checks each time
		 * it discovers the handle in the state WAITRESOLVE whether the hostname
		 * has already been resolved and the address has already been stored in
		 * the DNS cache. This short circuits waiting for a lot of pending
		 * lookups for the same hostname requested by different handles.
		 *
		 * Returns the Curl_dns_entry entry pointer or NULL if not in the cache.
		 *
		 * The returned data *MUST* be "unlocked" with Curl_resolv_unlock() after
		 * use, or we'll leak memory!
		 */;
	}
	public static Object Curl_fetch_addr(Object conn, Object hostname, int port) {
		Curl_easy data = conn.getData();
		Curl_dns_entry dns = ((Object)0);
		if (data.getShare()) {
			ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_DNS, .CURL_LOCK_ACCESS_SINGLE);
		} 
		dns = ModernizedCProgram.fetch_addr(conn, hostname, port);
		if (dns) {
			dns.getInuse()++;
		} 
		if (data.getShare()) {
			ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_DNS);
		} 
		return dns;
	}
	public static  Curl_shuffle_addr(Object data, Object addr) {
		CURLcode result = .CURLE_OK;
		int num_addrs = ModernizedCProgram.Curl_num_addresses(addr);
		if (num_addrs > 1) {
			Curl_addrinfo nodes = new Curl_addrinfo();
			ModernizedCProgram.Curl_infof(data, "Shuffling %i addresses", num_addrs);
			nodes = .Curl_cmalloc(num_addrs * );
			if (nodes) {
				int i;
				int rnd;
				size_t rnd_size = num_addrs * ;
				nodes[0] = /* build a plain array of Curl_addrinfo pointers */addr;
				for (i = 1; i < num_addrs; i++) {
					nodes[i] = nodes[i - 1].getAi_next();
				}
				rnd = .Curl_cmalloc(rnd_size);
				if (rnd) {
					if (ModernizedCProgram.Curl_rand(data, (byte)rnd, rnd_size) == /* Fisher-Yates shuffle */.CURLE_OK) {
						Curl_addrinfo swap_tmp = new Curl_addrinfo();
						for (i = num_addrs - 1; i > 0; i--) {
							swap_tmp = nodes[rnd[i] % (i + 1)];
							nodes[rnd[i] % (i + 1)] = nodes[i];
							nodes[i] = swap_tmp;
						}
						for (i = 1; i < num_addrs; /* relink list in the new order */i++) {
							nodes[i - 1].setAi_next(nodes[i]);
						}
						nodes[num_addrs - 1].setAi_next(((Object)0));
						addr = nodes[0];
					} 
					.Curl_cfree(rnd);
				} else {
						result = .CURLE_OUT_OF_MEMORY;
				} 
				.Curl_cfree(nodes);
			} else {
					result = .CURLE_OUT_OF_MEMORY;
			} 
		} 
		return result/*
		 * Curl_cache_addr() stores a 'Curl_addrinfo' struct in the DNS cache.
		 *
		 * When calling Curl_resolv() has resulted in a response with a returned
		 * address, we call this function to store the information in the dns
		 * cache etc
		 *
		 * Returns the Curl_dns_entry entry pointer or NULL if the storage failed.
		 */;
	}
	/*
	 * Curl_shuffle_addr() shuffles the order of addresses in a 'Curl_addrinfo'
	 * struct by re-linking its linked list.
	 *
	 * The addr argument should be the address of a pointer to the head node of a
	 * `Curl_addrinfo` list and it will be modified to point to the new head after
	 * shuffling.
	 *
	 * Not declared static only to make it easy to use in a unit test!
	 *
	 * @unittest: 1608
	 */
	public static Object Curl_cache_addr(Object data, Object addr, Object hostname, int port) {
		byte[] entry_id = new byte[(255 + 7)];
		size_t entry_len = new size_t();
		Curl_dns_entry dns = new Curl_dns_entry();
		Curl_dns_entry dns2 = new Curl_dns_entry();
		if (data.getSet().getDns_shuffle_addresses()) {
			CURLcode result = ModernizedCProgram.Curl_shuffle_addr(data, addr);
			if (result) {
				return ((Object)0);
			} 
		} 
		dns = .Curl_ccalloc(1, /* Create a new cache entry */);
		if (!dns) {
			return ((Object)0);
		} 
		ModernizedCProgram.create_hostcache_id(hostname, port, entry_id, );
		entry_len = .strlen(entry_id);
		dns.setInuse(/* the cache has the first reference */1);
		dns.setAddr(/* this is the address(es) */addr);
		.time(dns.getTimestamp());
		if (dns.getTimestamp() == 0) {
			dns.setTimestamp(/* zero indicates CURLOPT_RESOLVE entry */1);
		} 
		dns2 = ModernizedCProgram.Curl_hash_add(data.getDns().getHostcache(), entry_id, entry_len + /* Store the resolved data in our DNS cache. */1, (Object)dns);
		if (!dns2) {
			.Curl_cfree(dns);
			return ((Object)0);
		} 
		dns = dns2;
		dns.getInuse()++;
		return dns/*
		 * Curl_resolv() is the main name resolve function within libcurl. It resolves
		 * a name and returns a pointer to the entry in the 'entry' argument (if one
		 * is provided). This function might return immediately if we're using asynch
		 * resolves. See the return codes.
		 *
		 * The cache entry we return will get its 'inuse' counter increased when this
		 * function is used. You MUST call Curl_resolv_unlock() later (when you're
		 * done using this struct) to decrease the counter again.
		 *
		 * In debug mode, we specifically test for an interface name "LocalHost"
		 * and resolve "localhost" instead as a means to permit test cases
		 * to connect to a local test server with any host name.
		 *
		 * Return codes:
		 *
		 * CURLRESOLV_ERROR   (-1) = error, no pointer
		 * CURLRESOLV_RESOLVED (0) = OK, pointer provided
		 * CURLRESOLV_PENDING  (1) = waiting for response, no pointer
		 */;
	}
	public static int Curl_resolv(Object conn, Object hostname, int port,  allowDOH, Object entry) {
		Curl_dns_entry dns = ((Object)0);
		Curl_easy data = conn.getData();
		CURLcode result = new CURLcode();
		int rc = -/* default to failure */1;
		entry = ((Object)0);
		if (data.getShare()) {
			ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_DNS, .CURL_LOCK_ACCESS_SINGLE);
		} 
		dns = ModernizedCProgram.fetch_addr(conn, hostname, port);
		if (dns) {
			ModernizedCProgram.Curl_infof(data, "Hostname %s was found in DNS cache\n", hostname);
			dns.getInuse()++;
			rc = 0;
		} 
		if (data.getShare()) {
			ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_DNS);
		} 
		if (!dns/* The entry was not in the cache. Resolve it to IP address */) {
			Curl_addrinfo addr = new Curl_addrinfo();
			int respwait = 0;
			if (!ModernizedCProgram.Curl_ipvalid(/* Check what IP specifics the app has requested and if we can provide it.
			     * If not, bail out. */conn)) {
				return -1;
			} 
			if (data.getSet().getResolver_start()) {
				int st;
				ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
				st = .UNRECOGNIZEDFUNCTIONNAME(data.getState().getResolver(), ((Object)0), data.getSet().getResolver_start_client());
				ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
				if (st) {
					return -1;
				} 
			} 
			if (allowDOH && data.getSet().getDoh()) {
				addr = ModernizedCProgram.Curl_doh(conn, hostname, port, respwait);
			} else {
					addr = ModernizedCProgram.Curl_getaddrinfo(/* If Curl_getaddrinfo() returns NULL, 'respwait' might be set to a
					         non-zero value indicating that we need to wait for the response to the
					         resolve call */conn, hostname, port, respwait);
			} 
			if (!addr) {
				if (respwait/* the response to our resolve call will come asynchronously at
				           a later time, good or bad */) {
					result = ModernizedCProgram.Curl_resolv_check(conn, /* First, check that we haven't received the info by now */dns);
					if (/* error detected */result) {
						return -1;
					} 
					if (dns) {
						rc = /* pointer provided */0;
					} else {
							rc = /* no info yet */1;
					} 
				} 
			} else {
					if (data.getShare()) {
						ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_DNS, .CURL_LOCK_ACCESS_SINGLE);
					} 
					dns = ModernizedCProgram.Curl_cache_addr(data, addr, hostname, /* we got a response, store it in the cache */port);
					if (data.getShare()) {
						ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_DNS);
					} 
					if (!dns) {
						ModernizedCProgram.Curl_freeaddrinfo(/* returned failure, bail out nicely */addr);
					} else {
							rc = 0;
					} 
			} 
		} 
		entry = dns;
		return rc/*
		 * This signal handler jumps back into the main libcurl code and continues
		 * execution.  This effectively causes the remainder of the application to run
		 * within a signal handler which is nonportable and could lead to problems.
		 *//* this is for "-ansi -Wall -pedantic" to stop complaining!   (rabe) *//* USE_ALARM_TIMEOUT *//*
		 * Curl_resolv_timeout() is the same as Curl_resolv() but specifies a
		 * timeout.  This function might return immediately if we're using asynch
		 * resolves. See the return codes.
		 *
		 * The cache entry we return will get its 'inuse' counter increased when this
		 * function is used. You MUST call Curl_resolv_unlock() later (when you're
		 * done using this struct) to decrease the counter again.
		 *
		 * If built with a synchronous resolver and use of signals is not
		 * disabled by the application, then a nonzero timeout will cause a
		 * timeout after the specified number of milliseconds. Otherwise, timeout
		 * is ignored.
		 *
		 * Return codes:
		 *
		 * CURLRESOLV_TIMEDOUT(-2) = warning, time too short or previous alarm expired
		 * CURLRESOLV_ERROR   (-1) = error, no pointer
		 * CURLRESOLV_RESOLVED (0) = OK, pointer provided
		 * CURLRESOLV_PENDING  (1) = waiting for response, no pointer
		 */;
	}
	public static int Curl_resolv_timeout(Object conn, Object hostname, int port, Object entry, Object timeoutms) {
		/* store the old handler here *//* HAVE_SIGNAL *//* HAVE_SIGACTION *//* USE_ALARM_TIMEOUT */int rc;
		entry = ((Object)0);
		if (timeoutms < 0) {
			return -/* got an already expired timeout */2/* Ignore the timeout when signals are disabled *//* USE_ALARM_TIMEOUT defined, but no timeout actually requested *//* The alarm() function only provides integer second resolution, so if
			       we want to wait less than one second we must bail out already now. *//* This allows us to time-out from the name resolver, as the timeout
			     will generate a signal and we will siglongjmp() from that here.
			     This technique has problems (see alarmfunc).
			     This should be the last thing we do before calling Curl_resolv(),
			     as otherwise we'd have to worry about variables that get modified
			     before we invoke Curl_resolv() (and thus use "volatile"). *//* this is coming from a siglongjmp() after an alarm signal */;
		} 
		(Object)/*************************************************************
		     * Set signal handler to catch SIGALRM
		     * Store the old value to be able to set it back later!
		     *************************************************************//* yes, we have a copy *//* HPUX doesn't have SA_RESTART but defaults to that behaviour! *//* now set the new struct *//* HAVE_SIGACTION *//* no sigaction(), revert to the much lamer signal() *//* HAVE_SIGACTION *//* alarm() makes a signal get sent when the timeout fires off, and that
		       will abort system calls *//* timeoutms not used with an async resolver */timeoutms/* USE_ALARM_TIMEOUT */;
		rc = ModernizedCProgram.Curl_resolv(conn, hostname, port, 1, /* Perform the actual name resolution. This might be interrupted by an
		   * alarm if it takes too long.
		   */entry/* deactivate a possibly active alarm before uninstalling the handler *//* we got a struct as it looked before, now put that one back nice
		       and clean *//* put it back *//* restore the previous SIGALRM handler *//* HAVE_SIGACTION *//* switch back the alarm() to either zero or to what it was before minus
		     the time we spent until now! */);
		return /* there was an alarm() set before us, now put it back *//* the alarm period is counted in even number of seconds *//* if the alarm time-left reached zero or turned "negative" (counted
		         with unsigned values), we should fire off a SIGALRM here, but we
		         won't, and zero would be to switch it off so we never set it to
		         less than 1! *//* USE_ALARM_TIMEOUT */rc/*
		 * Curl_resolv_unlock() unlocks the given cached DNS entry. When this has been
		 * made, the struct may be destroyed due to pruning. It is important that only
		 * one unlock is made for each Curl_resolv() call.
		 *
		 * May be called with 'data' == NULL for global cache.
		 */;
	}
	public static void Curl_resolv_unlock(Object data, Object dns) {
		if (data && data.getShare()) {
			ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_DNS, .CURL_LOCK_ACCESS_SINGLE);
		} 
		ModernizedCProgram.freednsentry(dns);
		if (data && data.getShare()) {
			ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_DNS/*
			 * File-internal: release cache dns entry reference, free if inuse drops to 0
			 */);
		} 
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* alarm-based timeouts can only be used with all the dependencies satisfied */
	/* max FQDN + colon + port number + zero */
	/*
	 * hostip.c explained
	 * ==================
	 *
	 * The main COMPILE-TIME DEFINES to keep in mind when reading the host*.c
	 * source file are these:
	 *
	 * CURLRES_IPV6 - this host has getaddrinfo() and family, and thus we use
	 * that. The host may not be able to resolve IPv6, but we don't really have to
	 * take that into account. Hosts that aren't IPv6-enabled have CURLRES_IPV4
	 * defined.
	 *
	 * CURLRES_ARES - is defined if libcurl is built to use c-ares for
	 * asynchronous name resolves. This can be Windows or *nix.
	 *
	 * CURLRES_THREADED - is defined if libcurl is built to run under (native)
	 * Windows, and then the name resolve will be done in a new thread, and the
	 * supported API will be the same as for ares-builds.
	 *
	 * If any of the two previous are defined, CURLRES_ASYNCH is defined too. If
	 * libcurl is not built to use an asynchronous resolver, CURLRES_SYNCH is
	 * defined.
	 *
	 * The host*.c sources files are split up like this:
	 *
	 * hostip.c   - method-independent resolver functions and utility functions
	 * hostasyn.c - functions for asynchronous name resolves
	 * hostsyn.c  - functions for synchronous name resolves
	 * hostip4.c  - IPv4 specific functions
	 * hostip6.c  - IPv6 specific functions
	 *
	 * The two asynchronous name resolver backends are implemented in:
	 * asyn-ares.c   - functions for ares-using name resolves
	 * asyn-thread.c - functions for threaded name resolves
	
	 * The hostip.h is the united header file for all this. It defines the
	 * CURLRES_* defines based on the config*.h and curl_setup.h defines.
	 */
	public static void freednsentry(Object freethis) {
		Curl_dns_entry dns = (Curl_dns_entry)freethis;
		do {
		} while (0);
		dns.getInuse()--;
		if (dns.getInuse() == 0) {
			ModernizedCProgram.Curl_freeaddrinfo(dns.getAddr());
			.Curl_cfree(dns);
		} 
	}
	/*
	 * Return # of addresses in a Curl_addrinfo struct
	 */
	/*
	 * Curl_mk_dnscache() inits a new DNS cache and returns success/failure.
	 */
	public static int Curl_mk_dnscache(Object hash) {
		return ModernizedCProgram.Curl_hash_init(hash, 7, ModernizedCProgram.Curl_hash_str, ModernizedCProgram.Curl_str_key_compare, ModernizedCProgram.freednsentry/*
		 * Curl_hostcache_clean()
		 *
		 * This _can_ be called with 'data' == NULL but then of course no locking
		 * can be done!
		 */);
	}
	public static void Curl_hostcache_clean(Object data, Object hash) {
		if (data && data.getShare()) {
			ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_DNS, .CURL_LOCK_ACCESS_SINGLE);
		} 
		ModernizedCProgram.Curl_hash_clean(hash);
		if (data && data.getShare()) {
			ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_DNS);
		} 
	}
	public static  Curl_loadhostpairs(Object data) {
		curl_slist hostp = new curl_slist();
		byte[] hostname = new byte[256];
		int port = 0;
		data.getChange().setWildcard_resolve(/* Default is no wildcard found */.bool_false);
		data.getChange().setResolve(((Object)/* dealt with now */0));
		return .CURLE_OK;
	}
	public static  Curl_resolv_check(Object conn, Object dns) {
		if (conn.getData().getSet().getDoh()) {
			return ModernizedCProgram.Curl_doh_is_resolved(conn, dns);
		} 
		return ModernizedCProgram.Curl_resolver_is_resolved(conn, dns);
	}
	public static int Curl_resolv_getsock(Object conn, Object socks) {
		if (conn.getData().getSet().getDoh()) {
			return 0;
		} 
		return ModernizedCProgram.Curl_resolver_getsock(conn, socks);
	}
	/* Call this function after Curl_connect() has returned async=TRUE and
	   then a successful name resolve has been received.
	
	   Note: this function disconnects and frees the conn data in case of
	   resolve failure */
	public static  Curl_once_resolved(Object conn, Object protocol_done) {
		CURLcode result = new CURLcode();
		if (conn.getAsync().getDns()) {
			conn.setDns_entry(conn.getAsync().getDns());
			conn.getAsync().setDns(((Object)0));
		} 
		result = ModernizedCProgram.Curl_setup_conn(conn, protocol_done);
		if (result/* We're not allowed to return failure with memory left allocated
		       in the connectdata struct, free those here */) {
			ModernizedCProgram.Curl_disconnect(conn.getData(), conn, /* close the connection */1);
		} 
		return result;
	}
	public static  get_libcurl_info() {
		Object[] possibly_built_in = new Object[]{{"dict", (1 << 9)}, {"file", (1 << 10)}, {"ftp", (1 << 2)}, {"ftps", (1 << 3)}, {"gopher", (1 << 25)}, {"http", (1 << 0)}, {"https", (1 << 1)}, {"imap", (1 << 12)}, {"imaps", (1 << 13)}, {"ldap", (1 << 7)}, {"ldaps", (1 << 8)}, {"pop3", (1 << 14)}, {"pop3s", (1 << 15)}, {"rtmp", (1 << 19)}, {"rtsp", (1 << 18)}, {"scp", (1 << 4)}, {"sftp", (1 << 5)}, {"smb", (1 << 26)}, {"smbs", (1 << 27)}, {"smtp", (1 << 16)}, {"smtps", (1 << 17)}, {"telnet", (1 << 6)}, {"tftp", (1 << 11)}, {((Object)0), 0}};
		byte proto;
		ModernizedCProgram.curlinfo = ModernizedCProgram.curl_version_info(/* Pointer to libcurl's run-time version information */.CURLVERSION_SIXTH);
		if (!ModernizedCProgram.curlinfo) {
			return .CURLE_FAILED_INIT;
		} 
		ModernizedCProgram.built_in_protos = /* Build CURLPROTO_* bit pattern with libcurl's built-in protocols */0;
		if (ModernizedCProgram.curlinfo.getProtocols()) {
			for (proto = ModernizedCProgram.curlinfo.getProtocols(); proto; proto++) {
				proto_name_pattern p = new proto_name_pattern();
				for (p = possibly_built_in; p.getProto_name(); p++) {
					if (ModernizedCProgram.curl_strequal(proto, p.getProto_name())) {
						ModernizedCProgram.built_in_protos |=  p.getProto_pattern();
						break;
					} 
				}
			}
		} 
		return .CURLE_OK;
	}
	public static Object Curl_fileinfo_alloc() {
		return .Curl_ccalloc(1, );
	}
	public static void Curl_fileinfo_cleanup(Object finfo) {
		if (!finfo) {
			return ;
		} 
		do {
			.Curl_cfree((finfo.getInfo().getB_data()));
			(finfo.getInfo().getB_data()) = ((Object)0);
		} while (0);
		.Curl_cfree(finfo);
	}
	public static Object slist_get_last(Object list) {
		curl_slist item = new curl_slist();
		if (!/* if caller passed us a NULL, return now */list) {
			return ((Object)0);
		} 
		item = /* loop through to find the last item */list;
		while (item.getNext()) {
			item = item.getNext();
		}
		return item/*
		 * Curl_slist_append_nodup() appends a string to the linked list. Rather than
		 * copying the string in dynamic storage, it takes its ownership. The string
		 * should have been malloc()ated. Curl_slist_append_nodup always returns
		 * the address of the first record, so that you can use this function as an
		 * initialization function as well as an append function.
		 * If an error occurs, NULL is returned and the string argument is NOT
		 * released.
		 */;
	}
	public static Object Curl_slist_append_nodup(Object list, Object data) {
		curl_slist last = new curl_slist();
		curl_slist new_item = new curl_slist();
		do {
		} while (0);
		new_item = .Curl_cmalloc();
		if (!new_item) {
			return ((Object)0);
		} 
		new_item.setNext(((Object)0));
		new_item.setData(data);
		if (!/* if this is the first item, then new_item *is* the list */list) {
			return new_item;
		} 
		last = ModernizedCProgram.slist_get_last(list);
		last.setNext(new_item);
		return list/*
		 * curl_slist_append() appends a string to the linked list. It always returns
		 * the address of the first record, so that you can use this function as an
		 * initialization function as well as an append function. If you find this
		 * bothersome, then simply create a separate _init function and call it
		 * appropriately from within the program.
		 */;
	}
	public static Object curl_slist_append(Object list, Object data) {
		byte dupdata = .Curl_cstrdup(data);
		if (!dupdata) {
			return ((Object)0);
		} 
		list = ModernizedCProgram.Curl_slist_append_nodup(list, dupdata);
		if (!list) {
			.Curl_cfree(dupdata);
		} 
		return list/*
		 * Curl_slist_duplicate() duplicates a linked list. It always returns the
		 * address of the first record of the cloned list or NULL in case of an
		 * error (or if the input list was NULL).
		 */;
	}
	public static Object Curl_slist_duplicate(Object inlist) {
		curl_slist outlist = ((Object)0);
		curl_slist tmp = new curl_slist();
		while (inlist) {
			tmp = ModernizedCProgram.curl_slist_append(outlist, inlist.getData());
			if (!tmp) {
				ModernizedCProgram.curl_slist_free_all(outlist);
				return ((Object)0);
			} 
			outlist = tmp;
			inlist = inlist.getNext();
		}
		return outlist;
	}
	/* be nice and clean up resources */
	public static void curl_slist_free_all(Object list) {
		curl_slist next = new curl_slist();
		curl_slist item = new curl_slist();
		if (!list) {
			return ;
		} 
		item = list;
		do {
			next = item.getNext();
			do {
				.Curl_cfree((item.getData()));
				(item.getData()) = ((Object)0);
			} while (0);
			.Curl_cfree(item);
			item = next;
		} while (next);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	public static void clean_getout(Object config) {
		if (config) {
			getout next = new getout();
			getout node = config.getUrl_list();
			while (node) {
				next = node.getNext();
				do {
					.free((node.getUrl()));
					(node.getUrl()) = ((Object)0);
				} while (0);
				do {
					.free((node.getOutfile()));
					(node.getOutfile()) = ((Object)0);
				} while (0);
				do {
					.free((node.getInfile()));
					(node.getInfile()) = ((Object)0);
				} while (0);
				do {
					.free((node));
					(node) = ((Object)0);
				} while (0);
				node = next;
			}
			config.setUrl_list(((Object)0));
		} 
	}
	public static  output_expected(Object url, Object uploadfile) {
		if (!uploadfile) {
			return /* download */1;
		} 
		if (ModernizedCProgram.curl_strnequal("http://", url, .strlen("http://")) || ModernizedCProgram.curl_strnequal("https://", url, .strlen("https://"))) {
			return /* HTTP(S) upload */1;
		} 
		return /* non-HTTP upload, probably no output should be expected */0;
	}
	public static  stdin_upload(Object uploadfile) {
		return (!.strcmp(uploadfile, "-") || !.strcmp(uploadfile, ".")) ? 1 : 0/*
		 * Adds the file name to the URL if it doesn't already have one.
		 * url will be freed before return if the returned pointer is different
		 */;
	}
	public static Object add_file_name_to_url(Object url, Object filename) {
		byte ptr = .strstr(url, /* If no file name part is given in the URL, we add this file name */"://");
		CURL curl = ModernizedCProgram.curl_easy_init();
		if (!curl) {
			return ((Object)/* error! */0);
		} 
		if (ptr) {
			ptr += 3;
		} else {
				ptr = url;
		} 
		ptr = .strrchr(ptr, (byte)'/');
		if (!ptr || !.strlen(++ptr/* The URL has no file name part, add the local file name. In order
		       to be able to do so, we have to create a new URL in another
		       buffer.*/)) {
			byte filep = .strrchr(filename, /* We only want the part of the local path that is on the right
			       side of the rightmost slash and backslash. */(byte)'/');
			byte file2 = .strrchr(filep ? filep : filename, (byte)'\\');
			byte encfile;
			if (file2) {
				filep = file2 + 1;
			}  else if (filep) {
				filep++;
			} else {
					filep = filename;
			} 
			encfile = ModernizedCProgram.curl_easy_escape(curl, filep, /* URL encode the file name *//* use strlen */0);
			if (encfile) {
				byte urlbuffer;
				if (ptr) {
					urlbuffer = ModernizedCProgram.curl_maprintf("%s%s", url, /* there is a trailing slash on the URL */encfile);
				} else {
						urlbuffer = ModernizedCProgram.curl_maprintf("%s/%s", url, /* there is no trailing slash on the URL */encfile);
				} 
				ModernizedCProgram.curl_free(encfile);
				do {
					.free((url));
					(url) = ((Object)0);
				} while (0);
				if (!urlbuffer) {
					return ((Object)0);
				} 
				url = /* use our new URL instead! */urlbuffer;
			} else {
					do {
						.free((url));
						(url) = ((Object)0);
					} while (0);
			} 
		} 
		ModernizedCProgram.curl_easy_cleanup(curl);
		return url/* Extracts the name portion of the URL.
		 * Returns a pointer to a heap-allocated string or NULL if
		 * no name part, at location indicated by first argument.
		 */;
	}
	public static  get_url_file_name(Object filename, Object url) {
		byte pc;
		byte pc2;
		filename = ((Object)0);
		pc = .strstr(url, /* Find and get the remote file name */"://");
		if (pc) {
			pc += 3;
		} else {
				pc = url;
		} 
		pc2 = .strrchr(pc, (byte)'\\');
		pc = .strrchr(pc, (byte)'/');
		if (pc2 && (!pc || pc < pc2)) {
			pc = pc2;
		} 
		if (pc) {
			/* duplicate the string beyond the slash */pc++;
		} else {
				pc = /* no slash => empty string */"";
		} 
		filename = .strdup(pc);
		if (!filename) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		{ 
			byte sanitized;
			SANITIZEcode sc = ModernizedCProgram.sanitize_file_name(sanitized, filename, 0);
			do {
				.free((filename));
				(filename) = ((Object)0);
			} while (0);
			if (sc) {
				return .CURLE_URL_MALFORMAT;
			} 
			filename = sanitized/* MSDOS || WIN32 *//* in case we built debug enabled, we allow an environment variable
			   * named CURL_TESTDIR to prefix the given file name to put it into a
			   * specific directory
			   */;
		}
		return /* suitably large *//* clone the buffer */.CURLE_OK;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last #include file should be: */
	public static void hash_element_dtor(Object user, Object element) {
		curl_hash h = (curl_hash)user;
		curl_hash_element e = (curl_hash_element)element;
		if (e.getPtr()) {
			.UNRECOGNIZEDFUNCTIONNAME(e.getPtr());
			e.setPtr(((Object)0));
		} 
		e.setKey_len(0);
		.Curl_cfree(e/* Initializes a hash structure.
		 * Return 1 on error, 0 is fine.
		 *
		 * @unittest: 1602
		 * @unittest: 1603
		 */);
	}
	public static int Curl_hash_init(Object h, int slots, Object hfunc, Object comparator, Object dtor) {
		if (!slots || !hfunc || !comparator || !dtor) {
			return /* failure */1;
		} 
		h.setHash_func(hfunc);
		h.setComp_func(comparator);
		h.setDtor(dtor);
		h.setSize(0);
		h.setSlots(slots);
		h.setTable(.Curl_cmalloc(slots * ));
		if (h.getTable()) {
			int i;
			for (i = 0; i < slots; ++i) {
				ModernizedCProgram.Curl_llist_init(h.getTable()[i], (curl_llist_dtor)hash_element_dtor);
			}
			return /* fine */0;
		} 
		h.setSlots(0);
		return /* failure */1;
	}
	public static Object mk_hash_element(Object key, Object key_len, Object p) {
		curl_hash_element he = .Curl_cmalloc( + /* allocate the struct plus memory after it to store the key */key_len);
		if (he) {
			.memcpy(he.getKey(), key, /* copy the key */key_len);
			he.setKey_len(key_len);
			he.setPtr((Object)p);
		} 
		return he/* Insert the data in the hash. If there already was a match in the hash,
		 * that data is replaced.
		 *
		 * @unittest: 1305
		 * @unittest: 1602
		 * @unittest: 1603
		 */;
	}
	public static Object Curl_hash_add(Object h, Object key, Object key_len, Object p) {
		curl_hash_element he = new curl_hash_element();
		curl_llist_element le = new curl_llist_element();
		curl_llist l = h.getTable()[.UNRECOGNIZEDFUNCTIONNAME(key, key_len, h.getSlots())];
		for (le = l.getHead(); le; le = le.getNext()) {
			he = (curl_hash_element)le.getPtr();
			if (.UNRECOGNIZEDFUNCTIONNAME(he.getKey(), he.getKey_len(), key, key_len)) {
				ModernizedCProgram.Curl_llist_remove(l, le, (Object)h);
				--h.getSize();
				break;
			} 
		}
		he = ModernizedCProgram.mk_hash_element(key, key_len, p);
		if (he) {
			ModernizedCProgram.Curl_llist_insert_next(l, l.getTail(), he, he.getList());
			++h.getSize();
			return /* return the new entry */p;
		} 
		return ((Object)/* failure */0/* Remove the identified hash entry.
		 * Returns non-zero on failure.
		 *
		 * @unittest: 1603
		 */);
	}
	public static int Curl_hash_delete(Object h, Object key, Object key_len) {
		curl_llist_element le = new curl_llist_element();
		curl_llist l = h.getTable()[.UNRECOGNIZEDFUNCTIONNAME(key, key_len, h.getSlots())];
		for (le = l.getHead(); le; le = le.getNext()) {
			curl_hash_element he = le.getPtr();
			if (.UNRECOGNIZEDFUNCTIONNAME(he.getKey(), he.getKey_len(), key, key_len)) {
				ModernizedCProgram.Curl_llist_remove(l, le, (Object)h);
				--h.getSize();
				return 0;
			} 
		}
		return 1/* Retrieves a hash element.
		 *
		 * @unittest: 1603
		 */;
	}
	public static Object Curl_hash_pick(Object h, Object key, Object key_len) {
		curl_llist_element le = new curl_llist_element();
		curl_llist l = new curl_llist();
		if (h) {
			l = h.getTable()[.UNRECOGNIZEDFUNCTIONNAME(key, key_len, h.getSlots())];
			for (le = l.getHead(); le; le = le.getNext()) {
				curl_hash_element he = le.getPtr();
				if (.UNRECOGNIZEDFUNCTIONNAME(he.getKey(), he.getKey_len(), key, key_len)) {
					return he.getPtr();
				} 
			}
		} 
		return ((Object)0);
	}
	/* Destroys all the entries in the given hash and resets its attributes,
	 * prepping the given hash for [static|dynamic] deallocation.
	 *
	 * @unittest: 1305
	 * @unittest: 1602
	 * @unittest: 1603
	 */
	public static void Curl_hash_destroy(Object h) {
		int i;
		for (i = 0; i < h.getSlots(); ++i) {
			ModernizedCProgram.Curl_llist_destroy(h.getTable()[i], (Object)h);
		}
		do {
			.Curl_cfree((h.getTable()));
			(h.getTable()) = ((Object)0);
		} while (0);
		h.setSize(0);
		h.setSlots(0/* Removes all the entries in the given hash.
		 *
		 * @unittest: 1602
		 */);
	}
	public static void Curl_hash_clean(Object h) {
		ModernizedCProgram.Curl_hash_clean_with_criterium(h, ((Object)0), ((Object)0));
	}
	/* Cleans all entries that pass the comp function criteria. */
	public static void Curl_hash_clean_with_criterium(Object h, Object user, Object comp) {
		curl_llist_element le = new curl_llist_element();
		curl_llist_element lnext = new curl_llist_element();
		curl_llist list = new curl_llist();
		int i;
		if (!h) {
			return ;
		} 
		for (i = 0; i < h.getSlots(); ++i) {
			list = h.getTable()[i];
			le = list.getHead();
			while (le) {
				curl_hash_element he = le.getPtr();
				lnext = le.getNext();
				if (comp == ((Object)0) || .comp(user, he.getPtr())) {
					ModernizedCProgram.Curl_llist_remove(list, le, (Object)h);
					--h.getSize();
				} 
				le = lnext;
			}
		}
	}
	public static Object Curl_hash_str(Object key, Object key_length, Object slots_num) {
		byte key_str = (byte)key;
		byte end = key_str + key_length;
		size_t h = 5381;
		while (key_str < end) {
			h += h << 5;
			h ^=  key_str++;
		}
		return (h % slots_num);
	}
	public static Object Curl_str_key_compare(Object k1, Object key1_len, Object k2, Object key2_len) {
		if ((key1_len == key2_len) && !.memcmp(k1, k2, key1_len)) {
			return 1;
		} 
		return 0;
	}
	public static void Curl_hash_start_iterate(Object hash, Object iter) {
		iter.setHash(hash);
		iter.setSlot_index(0);
		iter.setCurrent_element(((Object)0));
	}
	public static Object Curl_hash_next_element(Object iter) {
		curl_hash h = iter.getHash();
		if (iter.getCurrent_element()) {
			iter.setCurrent_element(iter.getCurrent_element().getNext());
		} 
		if (!iter.getCurrent_element()) {
			int i;
			for (i = iter.getSlot_index(); i < h.getSlots(); i++) {
				if (h.getTable()[i].getHead()) {
					iter.setCurrent_element(h.getTable()[i].getHead());
					iter.setSlot_index(i + 1);
					break;
				} 
			}
		} 
		if (iter.getCurrent_element()) {
			curl_hash_element he = iter.getCurrent_element().getPtr();
			return he;
		} 
		iter.setCurrent_element(((Object)0));
		return ((Object)0/* useful function for debugging hashes and their contents *//* useful function for debugging hashes and their contents */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	public static Object getfiletime(Object filename, Object error_stream) {
		curl_off_t result = -1/* Windows stat() may attempt to adjust the unix GMT file time by a daylight
		   saving time offset and since it's GMT that is bad behavior. When we have
		   access to a 64-bit type we can bypass stat and get the times directly. */;
		HANDLE hfile = new HANDLE();
		hfile = .CreateFileA(filename, -1024, (-1024 | -1024 | -1024), ((Object)0), 3, 0, ((Object)0));
		Object generatedDwLowDateTime = ft.getDwLowDateTime();
		Object generatedDwHighDateTime = ft.getDwHighDateTime();
		if (hfile != (HANDLE)(true)) {
			FILETIME ft = new FILETIME();
			if (.GetFileTime(hfile, ((Object)0), ((Object)0), ft)) {
				curl_off_t converted = (curl_off_t)generatedDwLowDateTime | ((curl_off_t)generatedDwHighDateTime) << 32;
				if (converted < -1024) {
					.fprintf(error_stream, "Failed to get filetime: underflow\n");
				} else {
						result = (converted - -1024) / 10000000;
				} 
			} else {
					.fprintf(error_stream, "Failed to get filetime: GetFileTime failed: GetLastError %u\n", (int).GetLastError());
			} 
			.CloseHandle(hfile);
		}  else if (.GetLastError() != -1024) {
			.fprintf(error_stream, "Failed to get filetime: CreateFile failed: GetLastError %u\n", (int).GetLastError());
		} 
		return result;
	}
	public static void setfiletime(Object filetime, Object filename, Object error_stream) {
		if (filetime >= 0/* Windows utime() may attempt to adjust the unix GMT file time by a daylight
		   saving time offset and since it's GMT that is bad behavior. When we have
		   access to a 64-bit type we can bypass utime and set the times directly. */) {
			HANDLE hfile = new HANDLE();
			if (filetime > /* 910670515199 is the maximum unix filetime that can be used as a
			       Windows FILETIME without overflow: 30827-12-31T23:59:59. */-1024) {
				.fprintf(error_stream, "Failed to set filetime %I64d on outfile: overflow\n", filetime);
				return ;
			} 
			hfile = .CreateFileA(filename, -1024, (-1024 | -1024 | -1024), ((Object)0), 3, 0, ((Object)0));
			if (hfile != (HANDLE)(true)) {
				curl_off_t converted = ((curl_off_t)filetime * 10000000) + -1024;
				FILETIME ft = new FILETIME();
				ft.setDwLowDateTime((DWORD)(converted & -1024));
				ft.setDwHighDateTime((DWORD)(converted >> 32));
				if (!.SetFileTime(hfile, ((Object)0), ft, ft)) {
					.fprintf(error_stream, "Failed to set filetime %I64d on outfile: SetFileTime failed: GetLastError %u\n", filetime, (int).GetLastError());
				} 
				.CloseHandle(hfile);
			} else {
					.fprintf(error_stream, "Failed to set filetime %I64d on outfile: CreateFile failed: GetLastError %u\n", filetime, (int).GetLastError());
			} 
		} 
	}
	public static Object Curl_HMAC_init(Object hashparams, Object key, int keylen) {
		size_t i = new size_t();
		HMAC_context ctxt = new HMAC_context();
		byte hkey;
		byte b;
		i =  + 2 * hashparams.getHmac_ctxtsize() + hashparams.getHmac_resultlen();
		ctxt = .Curl_cmalloc(i);
		if (!ctxt) {
			return ctxt;
		} 
		ctxt.setHmac_hash(hashparams);
		ctxt.setHmac_hashctxt1((Object)(ctxt + 1));
		ctxt.setHmac_hashctxt2((Object)((byte)ctxt.getHmac_hashctxt1() + hashparams.getHmac_ctxtsize()));
		if (keylen > hashparams.getHmac_maxkeylen()) {
			.UNRECOGNIZEDFUNCTIONNAME(ctxt.getHmac_hashctxt1());
			.UNRECOGNIZEDFUNCTIONNAME(ctxt.getHmac_hashctxt1(), key, keylen);
			hkey = (byte)ctxt.getHmac_hashctxt2() + hashparams.getHmac_ctxtsize();
			.UNRECOGNIZEDFUNCTIONNAME(hkey, ctxt.getHmac_hashctxt1());
			key = hkey;
			keylen = hashparams.getHmac_resultlen();
		} 
		.UNRECOGNIZEDFUNCTIONNAME(ctxt.getHmac_hashctxt1());
		.UNRECOGNIZEDFUNCTIONNAME(ctxt.getHmac_hashctxt2());
		for (i = 0; i < keylen; i++) {
			b = (byte)(key ^ ModernizedCProgram.hmac_ipad);
			.UNRECOGNIZEDFUNCTIONNAME(ctxt.getHmac_hashctxt1(), b, 1);
			b = (byte)(key++ ^ ModernizedCProgram.hmac_opad);
			.UNRECOGNIZEDFUNCTIONNAME(ctxt.getHmac_hashctxt2(), b, 1);
		}
		for (; i < hashparams.getHmac_maxkeylen(); i++) {
			.UNRECOGNIZEDFUNCTIONNAME(ctxt.getHmac_hashctxt1(), ModernizedCProgram.hmac_ipad, 1);
			.UNRECOGNIZEDFUNCTIONNAME(ctxt.getHmac_hashctxt2(), ModernizedCProgram.hmac_opad, 1);
		}
		return /* Done, return pointer to HMAC context. */ctxt;
	}
	public static int Curl_HMAC_update(Object ctxt, Object data, int len) {
		.UNRECOGNIZEDFUNCTIONNAME(ctxt.getHmac_hashctxt1(), data, /* Update first hash calculation. */len);
		return 0;
	}
	public static int Curl_HMAC_final(Object ctxt, Object result) {
		HMAC_params hashparams = ctxt.getHmac_hash();
		if (!result) {
			result = (byte)ctxt.getHmac_hashctxt2() + ctxt.getHmac_hash().getHmac_ctxtsize();
		} 
		.UNRECOGNIZEDFUNCTIONNAME(result, ctxt.getHmac_hashctxt1());
		.UNRECOGNIZEDFUNCTIONNAME(ctxt.getHmac_hashctxt2(), result, hashparams.getHmac_resultlen());
		.UNRECOGNIZEDFUNCTIONNAME(result, ctxt.getHmac_hashctxt2());
		.Curl_cfree((byte)ctxt);
		return 0/* CURL_DISABLE_CRYPTO_AUTH */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/* create a local file for writing, return TRUE on success */
	public static  tool_create_output_file(Object outs) {
		GlobalConfig global = outs.getConfig().getOperationConfig();
		FILE file = new FILE();
		if (!outs.getFilename() || !outs.getFilename()) {
			ModernizedCProgram.warnf(global, "Remote filename has no length!\n");
			return 0;
		} 
		if (outs.getIs_cd_filename()) {
			file = .fopen(outs.getFilename(), /* don't overwrite existing files */"rb");
			if (file) {
				.fclose(file);
				ModernizedCProgram.warnf(global, "Refusing to overwrite %s: %s\n", outs.getFilename(), .strerror(17));
				return 0;
			} 
		} 
		file = .fopen(outs.getFilename(), /* open file for writing */"wb");
		if (!file) {
			ModernizedCProgram.warnf(global, "Failed to create the file %s: %s\n", outs.getFilename(), .strerror((._errno())));
			return 0;
		} 
		outs.setS_isreg(1);
		outs.setFopened(1);
		outs.setStream(file);
		outs.setBytes(0);
		outs.setInit(0);
		return 1/*
		** callback for CURLOPT_WRITEFUNCTION
		*/;
	}
	public static Object tool_write_cb(Object buffer, Object sz, Object nmemb, Object userdata) {
		size_t rc = new size_t();
		per_transfer per = userdata;
		OutStruct outs = per.getOuts();
		OperationConfig config = outs.getConfig();
		size_t bytes = sz * nmemb;
		bool is_tty = config.getOperationConfig().getIsatty();
		CONSOLE_SCREEN_BUFFER_INFO console_info = new CONSOLE_SCREEN_BUFFER_INFO();
		intptr_t fhnd = new intptr_t();
		/*
		   * Once that libcurl has called back tool_write_cb() the returned value
		   * is checked against the amount that was intended to be written, if
		   * it does not match then it fails with CURLE_WRITE_ERROR. So at this
		   * point returning a value different from sz*nmemb indicates failure.
		   */
		size_t failure = bytes ? 0 : 1/* Some internal congruency checks on received OutStruct */;
		if (!outs.getStream() && !ModernizedCProgram.tool_create_output_file(/* regular file *//* standard stream */outs)) {
			return failure;
		} 
		if (is_tty && (outs.getBytes() < 2000) && !config.getOperationConfig()) {
			if (.memchr(buffer, 0, /* binary output to terminal? */bytes)) {
				ModernizedCProgram.warnf(config.getOperationConfig(), "Binary output can mess up your terminal. Use \"--output -\" to tell curl to output it to your terminal anyway, or consider \"--output <FILE>\" to save to a file.\n");
				config.setOperationConfig(.ERR_BINARY_TERMINAL);
				return failure;
			} 
		} 
		fhnd = ._get_osfhandle(((outs.getStream()).get_file()));
		if (.isatty(((outs.getStream()).get_file())) && .GetConsoleScreenBufferInfo((HANDLE)fhnd, console_info)) {
			DWORD in_len = (DWORD)(sz * nmemb);
			wchar_t wc_buf = new wchar_t();
			DWORD wc_len = new DWORD();
			wc_len = .MultiByteToWideChar(65001, 0, buffer, in_len, ((Object)0), /* calculate buffer size for wide characters */0);
			wc_buf = (wchar_t).malloc(wc_len * );
			if (!wc_buf) {
				return failure;
			} 
			wc_len = .MultiByteToWideChar(65001, 0, buffer, in_len, wc_buf, /* calculate buffer size for multi-byte characters */wc_len);
			if (!wc_len) {
				.free(wc_buf);
				return failure;
			} 
			if (!.WriteConsoleW((HANDLE)fhnd, wc_buf, wc_len, wc_len, ((Object)0))) {
				.free(wc_buf);
				return failure;
			} 
			.free(wc_buf);
			rc = bytes;
		} else {
				rc = .fwrite(buffer, sz, nmemb, outs.getStream());
		} 
		if (bytes == rc) {
			outs.getBytes() += /* we added this amount of data to the output */bytes;
		} 
		if (config.getOperationConfig()) {
			config.setOperationConfig(0);
			ModernizedCProgram.curl_easy_pause(per.getCurl(), ((false) | (false)));
		} 
		if (config.getOperationConfig()) {
			int res = .fflush(outs.getStream());
			if (res) {
				return failure;
			} 
		} 
		return rc;
	}
	/*
	** callback for CURLOPT_HEADERFUNCTION
	*/
	public static Object tool_header_cb(Object ptr, Object size, Object nmemb, Object userdata) {
		per_transfer per = userdata;
		HdrCbData hdrcbdata = per.getHdrcbdata();
		OutStruct outs = per.getOuts();
		OutStruct heads = per.getHeads();
		byte str = ptr;
		size_t cb = size * nmemb;
		byte end = (byte)ptr + cb;
		long protocol = 0/*
		   * Once that libcurl has called back tool_header_cb() the returned value
		   * is checked against the amount that was intended to be written, if
		   * it does not match then it fails with CURLE_WRITE_ERROR. So at this
		   * point returning a value different from sz*nmemb indicates failure.
		   */;
		size_t failure = (size && nmemb) ? 0 : 1;
		if (!heads.getConfig()) {
			return failure;
		} 
		if (heads.getConfig().getOperationConfig() && heads.getStream()) {
			size_t rc = .fwrite(ptr, size, nmemb, heads.getStream());
			if (rc != cb) {
				return rc;
			} 
			(Object).fflush(heads.getStream());
		} 
		;
		if (hdrcbdata.getHonor_cd_filename() && (cb > 20) && ModernizedCProgram.curl_strnequal("Content-disposition:", str, .strlen("Content-disposition:")) && (protocol & ((1 << 1) | (1 << 0)))) {
			byte p = str + 20/* look for the 'filename=' parameter
			       (encoded filenames (*=) are not supported) */;
			for (; ; ) {
				byte filename;
				size_t len = new size_t();
				while (p && (p < end) && !(ModernizedCProgram.Curl_isalpha((int)((byte)p)))) {
					p++;
				}
				if (p > end - 9) {
					break;
				} 
				if (.memcmp(p, "filename=", 9)) {
					while ((p < end) && (p != /* no match, find next parameter */(byte)';')) {
						p++;
					}
					continue;
				} 
				p += 9/* this expression below typecasts 'cb' only to avoid
				         warning: signed and unsigned type in conditional expression
				      */;
				len = (ssize_t)cb - (p - str);
				filename = ModernizedCProgram.parse_filename(p, len);
				if (filename) {
					if (outs.getStream()) {
						int rc;
						if (outs.getFopened()) {
							.fclose(outs.getStream());
						} 
						outs.setStream(((Object)0));
						rc = .rename(outs.getFilename(), /* rename the initial file name to the new file name */filename);
						if (rc != 0) {
							ModernizedCProgram.warnf(outs.getConfig().getOperationConfig(), "Failed to rename %s -> %s: %s\n", outs.getFilename(), filename, .strerror((._errno())));
						} 
						if (outs.getAlloc_filename()) {
							do {
								.free((outs.getFilename()));
								(outs.getFilename()) = ((Object)0);
							} while (0);
						} 
						if (rc != 0) {
							.free(filename);
							return failure;
						} 
					} 
					outs.setIs_cd_filename(1);
					outs.setS_isreg(1);
					outs.setFopened(0);
					outs.setFilename(filename);
					outs.setAlloc_filename(1);
					hdrcbdata.setHonor_cd_filename(/* done now! */0);
					if (!ModernizedCProgram.tool_create_output_file(outs)) {
						return failure;
					} 
				} 
				break;
			}
			if (!outs.getStream() && !ModernizedCProgram.tool_create_output_file(outs)) {
				return failure;
			} 
		} 
		if (hdrcbdata.getConfig().getOperationConfig() && (protocol & ((1 << 0) | (1 << 1) | (1 << 18) | (1 << 10)))) {
			byte value = ((Object)/* bold headers only for selected protocols */0);
			if (!outs.getStream() && !ModernizedCProgram.tool_create_output_file(outs)) {
				return failure;
			} 
			if (hdrcbdata.getGlobal().getIsatty() && hdrcbdata.getGlobal().getStyled_output()) {
				value = .memchr(ptr, (byte)':', cb);
			} 
			if (value) {
				size_t namelen = value - ptr;
				ModernizedCProgram.curl_mfprintf(outs.getStream(), "%.*s:", namelen, ptr);
				.fwrite(value[1], cb - namelen - 1, 1, outs.getStream());
			} else {
					.fwrite(ptr, cb, 1, outs.getStream());
			} 
		} 
		return cb/*
		 * Copies a file name part and returns an ALLOCATED data buffer.
		 */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	public static Object parse_filename(Object ptr, Object len) {
		byte copy;
		byte p;
		byte q;
		byte stop = (byte)'\0';
		copy = .malloc(len + /* simple implementation of strndup() */1);
		if (!copy) {
			return ((Object)0);
		} 
		.memcpy(copy, ptr, len);
		copy[len] = (byte)'\0';
		p = copy;
		if (p == (byte)'\'' || p == (byte)'"') {
			stop = /* store the starting quote */p;
			p++;
		} else {
				stop = (byte)';';
		} 
		q = .strchr(p, /* scan for the end letter and stop there */stop);
		if (q) {
			q = (byte)'\0';
		} 
		q = .strrchr(p, /* if the filename contains a path, only use filename portion */(byte)'/');
		if (q) {
			p = q + 1;
			if (!p) {
				do {
					.free((copy));
					(copy) = ((Object)0);
				} while (0);
				return ((Object)0);
			} 
		} 
		q = .strrchr(p, /* If the filename contains a backslash, only use filename portion. The idea
		     is that even systems that don't handle backslashes as path separators
		     probably want the path removed for convenience. */(byte)'\\');
		if (q) {
			p = q + 1;
			if (!p) {
				do {
					.free((copy));
					(copy) = ((Object)0);
				} while (0);
				return ((Object)0);
			} 
		} 
		q = .strchr(p, /* make sure the file name doesn't end in \r or \n */(byte)'\r');
		if (q) {
			q = (byte)'\0';
		} 
		q = .strchr(p, (byte)'\n');
		if (q) {
			q = (byte)'\0';
		} 
		if (copy != p) {
			.memmove(copy, p, .strlen(p) + 1);
		} 
		{ 
			byte sanitized;
			SANITIZEcode sc = ModernizedCProgram.sanitize_file_name(sanitized, copy, 0);
			do {
				.free((copy));
				(copy) = ((Object)0);
			} while (0);
			if (sc) {
				return ((Object)0);
			} 
			copy = sanitized/* MSDOS || WIN32 *//* in case we built debug enabled, we allow an environment variable
			   * named CURL_TESTDIR to prefix the given file name to put it into a
			   * specific directory
			   */;
		}
		return /* suitably large *//* clone the buffer, we don't use the libcurl
		                                aprintf() or similar since we want to use the
		                                same memory code as the "real" parse_filename
		                                function */copy;
	}
	/* Switch off bold by setting "all attributes off" since the explicit
	   bold-off code (21) isn't supported everywhere - like in the mac
	   Terminal. */
	public static  tftp_set_timeouts(Object state) {
		time_t maxtime = new time_t();
		time_t timeout = new time_t();
		timediff_t timeout_ms = new timediff_t();
		bool start = (state.getState() == .TFTP_STATE_START) ? 1 : 0;
		.time(state.getStart_time());
		timeout_ms = ModernizedCProgram.Curl_timeleft(state.getConn().getData(), ((Object)0), /* Compute drop-dead time */start);
		if (timeout_ms < 0) {
			ModernizedCProgram.Curl_failf(state.getConn().getData(), /* time-out, bail out, go home */"Connection time-out");
			return .CURLE_OPERATION_TIMEDOUT;
		} 
		if (start) {
			maxtime = (time_t)(timeout_ms + 500) / 1000;
			state.setMax_time(state.getStart_time() + maxtime);
			timeout = /* Set per-block timeout to total */maxtime;
			state.setRetry_max((int)timeout / /* Average restart after 5 seconds */5);
			if (state.getRetry_max() < 1) {
				state.setRetry_max(/* avoid division by zero below */1);
			} 
			state.setRetry_time((int)timeout / state.getRetry_max());
			if (state.getRetry_time() < 1) {
				state.setRetry_time(1);
			} 
		} else {
				if (timeout_ms > 0) {
					maxtime = (time_t)(timeout_ms + 500) / 1000;
				} else {
						maxtime = 3600;
				} 
				state.setMax_time(state.getStart_time() + maxtime);
				timeout = /* Set per-block timeout to total */maxtime;
				state.setRetry_max((int)timeout / /* Average reposting an ACK after 5 seconds */5);
		} 
		if (state.getRetry_max() < /* But bound the total number */3) {
			state.setRetry_max(3);
		} 
		if (state.getRetry_max() > 50) {
			state.setRetry_max(50);
		} 
		state.setRetry_time((int)(timeout / state.getRetry_max()));
		if (state.getRetry_time() < 1) {
			state.setRetry_time(1);
		} 
		ModernizedCProgram.Curl_infof(state.getConn().getData(), "set timeouts for state %d; Total %ld, retry %d maxtry %d\n", (int)state.getState(), (long)(state.getMax_time() - state.getStart_time()), state.getRetry_time(), state.getRetry_max());
		.time(state.getRx_time());
		return .CURLE_OK/**********************************************************
		 *
		 * tftp_set_send_first
		 *
		 * Event handler for the START state
		 *
		 **********************************************************/;
	}
	public static void setpacketevent(Object packet, int num) {
		packet.getData()[0] = (byte)(num >> 8);
		packet.getData()[1] = (byte)(num & -1024);
	}
	public static void setpacketblock(Object packet, int num) {
		packet.getData()[2] = (byte)(num >> 8);
		packet.getData()[3] = (byte)(num & -1024);
	}
	public static int getrpacketevent(Object packet) {
		return (int)((packet.getData()[0] << 8) | packet.getData()[1]);
	}
	public static int getrpacketblock(Object packet) {
		return (int)((packet.getData()[2] << 8) | packet.getData()[3]);
	}
	public static Object Curl_strnlen(Object string, Object maxlen) {
		byte end = .memchr(string, (byte)'\0', maxlen);
		return end ? (size_t)(end - string) : maxlen;
	}
	public static Object tftp_option_get(Object buf, Object len, Object option, Object value) {
		size_t loc = new size_t();
		loc = ModernizedCProgram.Curl_strnlen(buf, len);
		/* NULL term */loc++;
		if (loc >= len) {
			return ((Object)0);
		} 
		option = buf;
		loc += ModernizedCProgram.Curl_strnlen(buf + loc, len - loc);
		/* NULL term */loc++;
		if (loc > len) {
			return ((Object)0);
		} 
		value = buf[.strlen(option) + 1];
		return buf[loc];
	}
	public static  tftp_parse_option_ack(Object state, Object ptr, int len) {
		byte tmp = ptr;
		Curl_easy data = state.getConn().getData();
		state.setBlksize(/* if OACK doesn't contain blksize option, the default (512) must be used */512);
		while (tmp < ptr + len) {
			byte option;
			byte value;
			tmp = ModernizedCProgram.tftp_option_get(tmp, ptr + len - tmp, option, value);
			if (tmp == ((Object)0)) {
				ModernizedCProgram.Curl_failf(data, "Malformed ACK packet, rejecting");
				return .CURLE_TFTP_ILLEGAL;
			} 
			ModernizedCProgram.Curl_infof(data, "got option=(%s) value=(%s)\n", option, value);
			if (ModernizedCProgram.curl_strnequal(option, "blksize", .strlen(option))) {
				long blksize;
				blksize = .strtol(value, ((Object)0), 10);
				if (!blksize) {
					ModernizedCProgram.Curl_failf(data, "invalid blocksize value in OACK packet");
					return .CURLE_TFTP_ILLEGAL;
				} 
				if (blksize > 65464) {
					ModernizedCProgram.Curl_failf(data, "%s (%d)", "blksize is larger than max supported", 65464);
					return .CURLE_TFTP_ILLEGAL;
				}  else if (blksize < 8) {
					ModernizedCProgram.Curl_failf(data, "%s (%d)", "blksize is smaller than min supported", 8);
					return .CURLE_TFTP_ILLEGAL;
				}  else if (blksize > state.getRequested_blksize()) {
					ModernizedCProgram.Curl_failf(data, "%s (%ld)", "server requested blksize larger than allocated", blksize);
					return .CURLE_TFTP_ILLEGAL;
				} 
				state.setBlksize((int)blksize);
				ModernizedCProgram.Curl_infof(data, "%s (%d) %s (%d)\n", "blksize parsed from OACK", state.getBlksize(), "requested", state.getRequested_blksize());
			}  else if (ModernizedCProgram.curl_strnequal(option, "tsize", .strlen(option))) {
				long tsize = 0;
				tsize = .strtol(value, ((Object)0), 10);
				ModernizedCProgram.Curl_infof(data, "%s (%ld)\n", "tsize parsed from OACK", tsize);
				if (!data.getSet().getUpload()) {
					if (!tsize) {
						ModernizedCProgram.Curl_failf(data, "invalid tsize -:%s:- value in OACK packet", value);
						return .CURLE_TFTP_ILLEGAL;
					} 
					ModernizedCProgram.Curl_pgrsSetDownloadSize(data, tsize);
				} 
			} 
		}
		return .CURLE_OK;
	}
	public static  tftp_option_add(Object state, Object csize, Object buf, Object option) {
		if ((.strlen(option) + csize + 1) > (size_t)state.getBlksize()) {
			return .CURLE_TFTP_ILLEGAL;
		} 
		.strcpy(buf, option);
		csize += .strlen(option) + 1;
		return .CURLE_OK;
	}
	public static  tftp_connect_for_tx(Object state,  event) {
		CURLcode result = new CURLcode();
		Curl_easy data = state.getConn().getData();
		ModernizedCProgram.Curl_infof(data, "%s\n", "Connected for transmit");
		state.setState(.TFTP_STATE_TX);
		result = ModernizedCProgram.tftp_set_timeouts(state);
		if (result) {
			return result;
		} 
		return ModernizedCProgram.tftp_tx(state, event);
	}
	public static  tftp_connect_for_rx(Object state,  event) {
		CURLcode result = new CURLcode();
		Curl_easy data = state.getConn().getData();
		ModernizedCProgram.Curl_infof(data, "%s\n", "Connected for receive");
		state.setState(.TFTP_STATE_RX);
		result = ModernizedCProgram.tftp_set_timeouts(state);
		if (result) {
			return result;
		} 
		return ModernizedCProgram.tftp_rx(state, event);
	}
	public static  tftp_send_first(Object state,  event) {
		size_t sbytes = new size_t();
		ssize_t senddata = new ssize_t();
		byte mode = "octet";
		byte filename;
		Curl_easy data = state.getConn().getData();
		CURLcode result = .CURLE_OK;
		if (data.getSet().getPrefer_ascii()) {
			mode = "netascii";
		} 
		switch (event) {
		case /* Resend the first packet out */.TFTP_EVENT_TIMEOUT:
				state.getRetries()++;
				if (state.getRetries() > state.getRetry_max()) {
					state.setError(.TFTP_ERR_NORESPONSE);
					state.setState(.TFTP_STATE_FIN);
					return result;
				} 
				if (data.getSet().getUpload()) {
					ModernizedCProgram.setpacketevent(state.getSpacket(), /* If we are uploading, send an WRQ */.TFTP_EVENT_WRQ);
					state.getConn().getData().getReq().setUpload_fromhere((byte)state.getSpacket().getData() + 4);
					if (data.getState().getInfilesize() != -1) {
						ModernizedCProgram.Curl_pgrsSetUploadSize(data, data.getState().getInfilesize());
					} 
				} else {
						ModernizedCProgram.setpacketevent(state.getSpacket(), /* If we are downloading, send an RRQ */.TFTP_EVENT_RRQ/* As RFC3617 describes the separator slash is not actually part of the
						       file name so we skip the always-present first letter of the path
						       string. */);
				} 
				result = ModernizedCProgram.Curl_urldecode(data, state.getConn().getData().getState().getUp().getPath()[1], 0, filename, ((Object)0), 0);
				if (result) {
					return result;
				} 
				if (.strlen(filename) > (state.getBlksize() - .strlen(mode) - 4)) {
					ModernizedCProgram.Curl_failf(data, "TFTP file name too long\n");
					.Curl_cfree(filename);
					return /* too long file name field */.CURLE_TFTP_ILLEGAL;
				} 
				ModernizedCProgram.curl_msnprintf((byte)state.getSpacket().getData() + 2, state.getBlksize(), "%s%c%s%c", filename, (byte)'\0', mode, (byte)'\0');
				sbytes = 4 + .strlen(filename) + .strlen(mode);
				if (!data.getSet().getTftp_no_options()) {
					byte[] buf = new byte[64];
					if (data.getSet().getUpload() && (data.getState().getInfilesize() != -/* add tsize option */1)) {
						ModernizedCProgram.curl_msnprintf(buf, , "%I64d", data.getState().getInfilesize());
					} else {
							.strcpy(buf, /* the destination is large enough */"0");
					} 
					result = ModernizedCProgram.tftp_option_add(state, sbytes, (byte)state.getSpacket().getData() + sbytes, "tsize");
					if (result == .CURLE_OK) {
						result = ModernizedCProgram.tftp_option_add(state, sbytes, (byte)state.getSpacket().getData() + sbytes, buf);
					} 
					ModernizedCProgram.curl_msnprintf(buf, , "%d", state.getRequested_blksize());
					if (result == .CURLE_OK) {
						result = ModernizedCProgram.tftp_option_add(state, sbytes, (byte)state.getSpacket().getData() + sbytes, "blksize");
					} 
					if (result == .CURLE_OK) {
						result = ModernizedCProgram.tftp_option_add(state, sbytes, (byte)state.getSpacket().getData() + sbytes, buf);
					} 
					ModernizedCProgram.curl_msnprintf(buf, , "%d", state.getRetry_time());
					if (result == .CURLE_OK) {
						result = ModernizedCProgram.tftp_option_add(state, sbytes, (byte)state.getSpacket().getData() + sbytes, "timeout");
					} 
					if (result == .CURLE_OK) {
						result = ModernizedCProgram.tftp_option_add(state, sbytes, (byte)state.getSpacket().getData() + sbytes, buf);
					} 
					if (result != .CURLE_OK) {
						ModernizedCProgram.Curl_failf(data, "TFTP buffer too small for options");
						.Curl_cfree(filename);
						return .CURLE_TFTP_ILLEGAL;
					} 
				} 
				senddata = .sendto(state.getSockfd(), (Object)state.getSpacket().getData(), (int)sbytes, 0, state.getConn().getIp_addr().getAi_addr(), state.getConn().getIp_addr().getAi_addrlen());
				if (senddata != (ssize_t)sbytes) {
					byte[] buffer = new byte[128];
					ModernizedCProgram.Curl_failf(data, "%s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
				} 
				.Curl_cfree(filename);
				break;
		case /* Connected for receive */.TFTP_EVENT_DATA:
				result = ModernizedCProgram.tftp_connect_for_rx(state, event);
				break;
		case /* Send the first packet out */.TFTP_EVENT_INIT:
		case .TFTP_EVENT_OACK:
				if (data.getSet().getUpload()) {
					result = ModernizedCProgram.tftp_connect_for_tx(state, event);
				} else {
						result = ModernizedCProgram.tftp_connect_for_rx(state, event);
				} 
				break;
		case .TFTP_EVENT_ERROR:
				state.setState(.TFTP_STATE_FIN);
				break;
		case /* Connected for transmit */.TFTP_EVENT_ACK:
				result = ModernizedCProgram.tftp_connect_for_tx(state, event);
				break;
		default:
				ModernizedCProgram.Curl_failf(state.getConn().getData(), "tftp_send_first: internal error");
				break;
		}
		return result/* the next blocknum is x + 1 but it needs to wrap at an unsigned 16bit
		   boundary *//**********************************************************
		 *
		 * tftp_rx
		 *
		 * Event handler for the RX state
		 *
		 **********************************************************/;
	}
	/* Forward declarations */
	public static  tftp_rx(Object state,  event) {
		ssize_t sbytes = new ssize_t();
		int rblock;
		Curl_easy data = state.getConn().getData();
		byte[] buffer = new byte[128];
		switch (event) {
		case .TFTP_EVENT_OACK:
				state.setBlock(/* ACK option acknowledgement so we can move on to data */0);
				state.setRetries(0);
				ModernizedCProgram.setpacketevent(state.getSpacket(), .TFTP_EVENT_ACK);
				ModernizedCProgram.setpacketblock(state.getSpacket(), state.getBlock());
				sbytes = .sendto(state.getSockfd(), (Object)state.getSpacket().getData(), 4, 0, (sockaddr)state.getRemote_addr(), state.getRemote_addrlen());
				if (sbytes < 0) {
					ModernizedCProgram.Curl_failf(data, "%s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
					return .CURLE_SEND_ERROR;
				} 
				state.setState(/* we're ready to RX data */.TFTP_STATE_RX);
				.time(state.getRx_time());
				break;
		case .TFTP_EVENT_ERROR:
				ModernizedCProgram.setpacketevent(state.getSpacket(), .TFTP_EVENT_ERROR);
				ModernizedCProgram.setpacketblock(state.getSpacket(), state.getBlock());
				(Object).sendto(state.getSockfd(), (Object)state.getSpacket().getData(), 4, 0, (sockaddr)state.getRemote_addr(), state.getRemote_addrlen());
				state.setState(.TFTP_STATE_FIN);
				break;
		case .TFTP_EVENT_TIMEOUT:
				state.getRetries()++;
				ModernizedCProgram.Curl_infof(data, "Timeout waiting for block %d ACK.  Retries = %d\n", (((state.getBlock()) + 1) & -1024), state.getRetries());
				if (state.getRetries() > state.getRetry_max()) {
					state.setError(.TFTP_ERR_TIMEOUT);
					state.setState(.TFTP_STATE_FIN);
				} else {
						sbytes = .sendto(state.getSockfd(), (Object)state.getSpacket().getData(), 4, 0, (sockaddr)state.getRemote_addr(), state.getRemote_addrlen());
						if (sbytes < 0) {
							ModernizedCProgram.Curl_failf(data, "%s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
							return .CURLE_SEND_ERROR;
						} 
				} 
				break;
		case .TFTP_EVENT_DATA:
				rblock = ModernizedCProgram.getrpacketblock(state.getRpacket());
				if ((((state.getBlock()) + 1) & -1024) == rblock) {
					state.setRetries(/* This is the expected block.  Reset counters and ACK it. */0);
				}  else if (state.getBlock() == rblock/* This is the last recently received block again. Log it and ACK it
				         again. */) {
					ModernizedCProgram.Curl_infof(data, "Received last DATA packet block %d again.\n", rblock);
				} else {
						ModernizedCProgram.Curl_infof(/* totally unexpected, just log it */data, "Received unexpected DATA packet block %d, expecting block %d\n", rblock, (((state.getBlock()) + 1) & -1024));
						break;
				} 
				state.setBlock((int)/* ACK this block. */rblock);
				ModernizedCProgram.setpacketevent(state.getSpacket(), .TFTP_EVENT_ACK);
				ModernizedCProgram.setpacketblock(state.getSpacket(), state.getBlock());
				sbytes = .sendto(state.getSockfd(), (Object)state.getSpacket().getData(), 4, 0, (sockaddr)state.getRemote_addr(), state.getRemote_addrlen());
				if (sbytes < 0) {
					ModernizedCProgram.Curl_failf(data, "%s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
					return .CURLE_SEND_ERROR;
				} 
				if (state.getRbytes() < (ssize_t)state.getBlksize() + /* Check if completed (That is, a less than full packet is received) */4) {
					state.setState(.TFTP_STATE_FIN);
				} else {
						state.setState(.TFTP_STATE_RX);
				} 
				.time(state.getRx_time());
				break;
		default:
				ModernizedCProgram.Curl_failf(data, "%s", "tftp_rx: internal error");
				return /* not really the perfect return code for
				                                  this */.CURLE_TFTP_ILLEGAL;
		}
		return .CURLE_OK/**********************************************************
		 *
		 * tftp_tx
		 *
		 * Event handler for the TX state
		 *
		 **********************************************************/;
	}
	public static  tftp_tx(Object state,  event) {
		Curl_easy data = state.getConn().getData();
		ssize_t sbytes = new ssize_t();
		CURLcode result = .CURLE_OK;
		SingleRequest k = data.getReq();
		/* Bytes currently read */size_t cb = new size_t();
		byte[] buffer = new byte[128];
		switch (event) {
		case .TFTP_EVENT_ERROR:
				state.setState(.TFTP_STATE_FIN);
				ModernizedCProgram.setpacketevent(state.getSpacket(), .TFTP_EVENT_ERROR);
				ModernizedCProgram.setpacketblock(state.getSpacket(), state.getBlock());
				(Object).sendto(state.getSockfd(), (Object)state.getSpacket().getData(), 4, 0, (sockaddr)state.getRemote_addr(), state.getRemote_addrlen());
				state.setState(.TFTP_STATE_FIN);
				break;
		case .TFTP_EVENT_TIMEOUT:
				state.getRetries()++;
				ModernizedCProgram.Curl_infof(data, "Timeout waiting for block %d ACK.  Retries = %d\n", (((state.getBlock()) + 1) & -1024), state.getRetries());
				if (state.getRetries() > state.getRetry_max()) {
					state.setError(.TFTP_ERR_TIMEOUT);
					state.setState(.TFTP_STATE_FIN);
				} else {
						sbytes = .sendto(state.getSockfd(), (Object)state.getSpacket().getData(), 4 + state.getSbytes(), 0, (sockaddr)state.getRemote_addr(), state.getRemote_addrlen());
						if (sbytes < /* Check all sbytes were sent */0) {
							ModernizedCProgram.Curl_failf(data, "%s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
							return .CURLE_SEND_ERROR;
						} 
						ModernizedCProgram.Curl_pgrsSetUploadCounter(data, k.getWritebytecount());
				} 
				break;
		case .TFTP_EVENT_OACK:
				if (event == .TFTP_EVENT_ACK) {
					int rblock = ModernizedCProgram.getrpacketblock(state.getRpacket());
					if (rblock != state.getBlock() && !(state.getBlock() == 0 && rblock == 65535)) {
						ModernizedCProgram.Curl_infof(data, /* This isn't the expected block.  Log it and up the retry counter */"Received ACK for block %d, expecting %d\n", rblock, state.getBlock());
						state.getRetries()++;
						if (state.getRetries() > state.getRetry_max()) {
							ModernizedCProgram.Curl_failf(data, "tftp_tx: giving up waiting for block %d ack", state.getBlock());
							result = .CURLE_SEND_ERROR;
						} else {
								sbytes = .sendto(state.getSockfd(), (Object)state.getSpacket().getData(), 4 + state.getSbytes(), 0, (sockaddr)state.getRemote_addr(), state.getRemote_addrlen());
								if (sbytes < /* Check all sbytes were sent */0) {
									ModernizedCProgram.Curl_failf(data, "%s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
									result = .CURLE_SEND_ERROR;
								} 
						} 
						return result;
					} 
					.time(state.getRx_time());
					state.getBlock()++;
				} else {
						state.setBlock(/* first data block is 1 when using OACK */1);
				} 
				state.setRetries(0);
				ModernizedCProgram.setpacketevent(state.getSpacket(), .TFTP_EVENT_DATA);
				ModernizedCProgram.setpacketblock(state.getSpacket(), state.getBlock());
				if (state.getBlock() > 1 && state.getSbytes() < state.getBlksize()) {
					state.setState(.TFTP_STATE_FIN);
					return .CURLE_OK/* TFTP considers data block size < 512 bytes as an end of session. So
					     * in some cases we must wait for additional data to build full (512 bytes)
					     * data block.
					     * */;
				} 
				state.setSbytes(0);
				state.getConn().getData().getReq().setUpload_fromhere((byte)state.getSpacket().getData() + 4);
				do {
					result = ModernizedCProgram.Curl_fillreadbuffer(state.getConn(), state.getBlksize() - state.getSbytes(), cb);
					if (result) {
						return result;
					} 
					state.getSbytes() += (int)cb;
					state.getConn().getData().getReq().getUpload_fromhere() += cb;
				} while (state.getSbytes() < state.getBlksize() && cb != 0);
				sbytes = .sendto(state.getSockfd(), (Object)state.getSpacket().getData(), 4 + state.getSbytes(), 0, (sockaddr)state.getRemote_addr(), state.getRemote_addrlen());
				if (sbytes < /* Check all sbytes were sent */0) {
					ModernizedCProgram.Curl_failf(data, "%s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
					return .CURLE_SEND_ERROR;
				} 
				k.getWritebytecount() += state.getSbytes();
				ModernizedCProgram.Curl_pgrsSetUploadCounter(data, k.getWritebytecount());
				break;
		case .TFTP_EVENT_ACK:
		default:
				ModernizedCProgram.Curl_failf(data, "tftp_tx: internal error, event: %i", (int)(event));
				break;
		}
		return result/**********************************************************
		 *
		 * tftp_translate_code
		 *
		 * Translate internal error codes to CURL error codes
		 *
		 **********************************************************/;
	}
	public static  tftp_translate_code( error) {
		CURLcode result = .CURLE_OK;
		if (error != .TFTP_ERR_NONE) {
			switch (error) {
			case .TFTP_ERR_UNDEF:
			case .TFTP_ERR_NOSUCHUSER:
					result = .CURLE_TFTP_NOSUCHUSER;
					break;
			case .TFTP_ERR_PERM:
					result = .CURLE_TFTP_PERM;
					break;
			case .TFTP_ERR_UNKNOWNID:
					result = .CURLE_TFTP_UNKNOWNID;
					break;
			case .TFTP_ERR_TIMEOUT:
					result = .CURLE_OPERATION_TIMEDOUT;
					break;
			case .TFTP_ERR_DISKFULL:
					result = .CURLE_REMOTE_DISK_FULL;
					break;
			case .TFTP_ERR_NORESPONSE:
					result = .CURLE_COULDNT_CONNECT;
					break;
			case .TFTP_ERR_EXISTS:
					result = .CURLE_REMOTE_FILE_EXISTS;
					break;
			case .TFTP_ERR_ILLEGAL:
					result = .CURLE_TFTP_ILLEGAL;
					break;
			case .TFTP_ERR_NOTFOUND:
					result = .CURLE_TFTP_NOTFOUND;
					break;
			default:
					result = .CURLE_ABORTED_BY_CALLBACK;
					break;
			}
		} else {
				result = .CURLE_OK;
		} 
		return result/**********************************************************
		 *
		 * tftp_state_machine
		 *
		 * The tftp state machine event dispatcher
		 *
		 **********************************************************/;
	}
	/*
	 * TFTP protocol handler.
	 */
	public static  tftp_state_machine(Object state,  event) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = state.getConn().getData();
		switch (state.getState()) {
		case .TFTP_STATE_START:
				do {
				} while (0);
				result = ModernizedCProgram.tftp_send_first(state, event);
				break;
		case .TFTP_STATE_FIN:
				ModernizedCProgram.Curl_infof(data, "%s\n", "TFTP finished");
				break;
		case .TFTP_STATE_RX:
				do {
				} while (0);
				result = ModernizedCProgram.tftp_rx(state, event);
				break;
		case .TFTP_STATE_TX:
				do {
				} while (0);
				result = ModernizedCProgram.tftp_tx(state, event);
				break;
		default:
				do {
				} while (0);
				ModernizedCProgram.Curl_failf(data, "%s", "Internal state machine error");
				result = .CURLE_TFTP_ILLEGAL;
				break;
		}
		return result/**********************************************************
		 *
		 * tftp_disconnect
		 *
		 * The disconnect callback
		 *
		 **********************************************************/;
	}
	public static  tftp_disconnect(Object conn,  dead_connection) {
		tftp_state_data_t state = conn.getProto().getTftpc();
		(Object)dead_connection;
		if (/* done, free dynamically allocated pkt buffers */state) {
			do {
				.Curl_cfree((state.getRpacket().getData()));
				(state.getRpacket().getData()) = ((Object)0);
			} while (0);
			do {
				.Curl_cfree((state.getSpacket().getData()));
				(state.getSpacket().getData()) = ((Object)0);
			} while (0);
			.Curl_cfree(state);
		} 
		return .CURLE_OK/**********************************************************
		 *
		 * tftp_connect
		 *
		 * The connect callback
		 *
		 **********************************************************/;
	}
	public static  tftp_connect(Object conn, Object done) {
		tftp_state_data_t state = new tftp_state_data_t();
		int blksize;
		int need_blksize;
		blksize = 512;
		state = conn.getProto().setTftpc(.Curl_ccalloc(1, ));
		if (!state) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		if (conn.getData().getSet().getTftp_blksize()) {
			blksize = (int)conn.getData().getSet().getTftp_blksize();
			if (blksize > 65464 || blksize < 8) {
				return .CURLE_TFTP_ILLEGAL;
			} 
		} 
		need_blksize = blksize;
		if (need_blksize < /* default size is the fallback when no OACK is received */512) {
			need_blksize = 512;
		} 
		if (!state.getRpacket().getData()) {
			state.getRpacket().setData(.Curl_ccalloc(1, need_blksize + 2 + 2));
			if (!state.getRpacket().getData()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		if (!state.getSpacket().getData()) {
			state.getSpacket().setData(.Curl_ccalloc(1, need_blksize + 2 + 2));
			if (!state.getSpacket().getData()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		ModernizedCProgram.Curl_conncontrol(conn, /* we don't keep TFTP connections up basically because there's none or very
		   * little gain for UDP */1);
		state.setConn(conn);
		state.setSockfd(state.getConn().getSock()[0]);
		state.setState(.TFTP_STATE_START);
		state.setError(.TFTP_ERR_NONE);
		state.setBlksize(/* Unless updated by OACK response */512);
		state.setRequested_blksize(blksize);
		((sockaddr)state.getLocal_addr()).setSa_family((int)(conn.getIp_addr().getAi_family()));
		ModernizedCProgram.tftp_set_timeouts(state);
		if (!conn.getBits().getBound()) {
			int rc = .bind(state.getSockfd(), (sockaddr)state.getLocal_addr(), conn.getIp_addr().getAi_addrlen());
			if (rc) {
				byte[] buffer = new byte[128];
				ModernizedCProgram.Curl_failf(conn.getData(), "bind() failed; %s", ModernizedCProgram.Curl_strerror(((int).WSAGetLastError()), buffer, ));
				return .CURLE_COULDNT_CONNECT;
			} 
			conn.getBits().setBound(1);
		} 
		ModernizedCProgram.Curl_pgrsStartNow(conn.getData());
		done = 1;
		return .CURLE_OK/**********************************************************
		 *
		 * tftp_done
		 *
		 * The done callback
		 *
		 **********************************************************/;
	}
	public static  tftp_done(Object conn,  status,  premature) {
		CURLcode result = .CURLE_OK;
		tftp_state_data_t state = (tftp_state_data_t)conn.getProto().getTftpc();
		(Object)/* unused */status;
		(Object)/* not used */premature;
		if (ModernizedCProgram.Curl_pgrsDone(conn)) {
			return .CURLE_ABORTED_BY_CALLBACK;
		} 
		if (/* If we have encountered an error */state) {
			result = ModernizedCProgram.tftp_translate_code(state.getError());
		} 
		return result/**********************************************************
		 *
		 * tftp_getsock
		 *
		 * The getsock callback
		 *
		 **********************************************************/;
	}
	public static int tftp_getsock(Object conn, Object socks) {
		socks[0] = conn.getSock()[0];
		return (1 << (false/**********************************************************
		 *
		 * tftp_receive_packet
		 *
		 * Called once select fires and data is ready on the socket
		 *
		 **********************************************************/));
	}
	public static  tftp_receive_packet(Object conn) {
		Curl_sockaddr_storage fromaddr = new Curl_sockaddr_storage();
		curl_socklen_t fromlen = new curl_socklen_t();
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		tftp_state_data_t state = (tftp_state_data_t)conn.getProto().getTftpc();
		SingleRequest k = data.getReq();
		fromlen = ;
		state.setRbytes((int).recvfrom(state.getSockfd(), (Object)state.getRpacket().getData(), state.getBlksize() + 4, 0, (sockaddr)fromaddr, fromlen));
		if (state.getRemote_addrlen() == 0) {
			.memcpy(state.getRemote_addr(), fromaddr, fromlen);
			state.setRemote_addrlen(fromlen);
		} 
		if (state.getRbytes() < /* Sanity check packet length */4) {
			ModernizedCProgram.Curl_failf(data, "Received too short packet");
			state.setEvent(/* Not a timeout, but how best to handle it? */.TFTP_EVENT_TIMEOUT);
		} else {
				int event = ModernizedCProgram.getrpacketevent(state.getRpacket());
				state.setEvent((tftp_event_t)event);
				switch (state.getEvent()) {
				case .TFTP_EVENT_ERROR:
						{ 
							int error = ModernizedCProgram.getrpacketblock(state.getRpacket());
							byte str = (byte)state.getRpacket().getData() + 4;
							size_t strn = state.getRbytes() - 4;
							state.setError((tftp_error_t)error);
							if (ModernizedCProgram.Curl_strnlen(str, strn) < strn) {
								ModernizedCProgram.Curl_infof(data, "TFTP error: %s\n", str);
							} 
							break;
						}
				case .TFTP_EVENT_RRQ:
				case .TFTP_EVENT_ACK:
						break;
				case .TFTP_EVENT_DATA:
						if (state.getRbytes() > /* Don't pass to the client empty or retransmitted packets */4 && ((((state.getBlock()) + 1) & -1024) == ModernizedCProgram.getrpacketblock(state.getRpacket()))) {
							result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)state.getRpacket().getData() + 4, state.getRbytes() - 4);
							if (result) {
								ModernizedCProgram.tftp_state_machine(state, .TFTP_EVENT_ERROR);
								return result;
							} 
							k.getBytecount() += state.getRbytes() - 4;
							ModernizedCProgram.Curl_pgrsSetDownloadCounter(data, (curl_off_t)k.getBytecount());
						} 
						break;
				case .TFTP_EVENT_WRQ:
				case .TFTP_EVENT_OACK:
						result = ModernizedCProgram.tftp_parse_option_ack(state, (byte)state.getRpacket().getData() + 2, state.getRbytes() - 2);
						if (result) {
							return result;
						} 
						break;
				default:
						ModernizedCProgram.Curl_failf(data, "%s", "Internal error: Unexpected packet");
						break;
				}
				if (ModernizedCProgram.Curl_pgrsUpdate(/* Update the progress meter */conn)) {
					ModernizedCProgram.tftp_state_machine(state, .TFTP_EVENT_ERROR);
					return .CURLE_ABORTED_BY_CALLBACK;
				} 
		} 
		return result/**********************************************************
		 *
		 * tftp_state_timeout
		 *
		 * Check if timeouts have been reached
		 *
		 **********************************************************/;
	}
	public static long tftp_state_timeout(Object conn, Object event) {
		time_t current = new time_t();
		tftp_state_data_t state = (tftp_state_data_t)conn.getProto().getTftpc();
		if (event) {
			event = .TFTP_EVENT_NONE;
		} 
		.time(current);
		if (current > state.getMax_time()) {
			do {
			} while (0);
			state.setError(.TFTP_ERR_TIMEOUT);
			state.setState(.TFTP_STATE_FIN);
			return 0;
		} 
		if (current > state.getRx_time() + state.getRetry_time()) {
			if (event) {
				event = .TFTP_EVENT_TIMEOUT;
			} 
			.time(state.getRx_time());
		} 
		return (long)(state.getMax_time() - /* there's a typecast below here since 'time_t' may in fact be larger than
		     'long', but we estimate that a 'long' will still be able to hold number
		     of seconds even if "only" 32 bit */current/**********************************************************
		 *
		 * tftp_multi_statemach
		 *
		 * Handle single RX socket event and return
		 *
		 **********************************************************/);
	}
	public static  tftp_multi_statemach(Object conn, Object done) {
		tftp_event_t event = new tftp_event_t();
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		tftp_state_data_t state = (tftp_state_data_t)conn.getProto().getTftpc();
		long timeout_ms = ModernizedCProgram.tftp_state_timeout(conn, event);
		done = 0;
		if (timeout_ms <= 0) {
			ModernizedCProgram.Curl_failf(data, "TFTP response timeout");
			return .CURLE_OPERATION_TIMEDOUT;
		} 
		if (event != .TFTP_EVENT_NONE) {
			result = ModernizedCProgram.tftp_state_machine(state, event);
			if (result) {
				return result;
			} 
			done = (state.getState() == .TFTP_STATE_FIN) ? 1 : 0;
			if (done) {
				ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, -/* Tell curl we're done */1);
			} 
		} else {
				int rc = ModernizedCProgram.Curl_socket_check(state.getSockfd(), (SOCKET)(~0), (SOCKET)(~0), (time_t)/* no timeouts to handle, check our socket */0);
				if (rc == -1) {
					int error = ((int).WSAGetLastError());
					byte[] buffer = new byte[128];
					ModernizedCProgram.Curl_failf(data, "%s", ModernizedCProgram.Curl_strerror(error, buffer, ));
					state.setEvent(.TFTP_EVENT_ERROR);
				}  else if (rc != 0) {
					result = ModernizedCProgram.tftp_receive_packet(conn);
					if (result) {
						return result;
					} 
					result = ModernizedCProgram.tftp_state_machine(state, state.getEvent());
					if (result) {
						return result;
					} 
					done = (state.getState() == .TFTP_STATE_FIN) ? 1 : 0;
					if (done) {
						ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, -/* Tell curl we're done */1/* if rc == 0, then select() timed out */);
					} 
				} 
		} 
		return result/**********************************************************
		 *
		 * tftp_doing
		 *
		 * Called from multi.c while DOing
		 *
		 **********************************************************/;
	}
	public static  tftp_doing(Object conn, Object dophase_done) {
		CURLcode result = new CURLcode();
		result = ModernizedCProgram.tftp_multi_statemach(conn, dophase_done);
		curltime curltime = new curltime();
		if (dophase_done) {
			do {
			} while (0);
		}  else if (!result/* The multi code doesn't have this logic for the DOING state so we
		       provide it for TFTP since it may do the entire transfer in this
		       state. */) {
			if (ModernizedCProgram.Curl_pgrsUpdate(conn)) {
				result = .CURLE_ABORTED_BY_CALLBACK;
			} else {
					result = curltime.Curl_now().Curl_speedcheck(conn.getData());
			} 
		} 
		return result/**********************************************************
		 *
		 * tftp_peform
		 *
		 * Entry point for transfer from tftp_do, sarts state mach
		 *
		 **********************************************************/;
	}
	public static  tftp_perform(Object conn, Object dophase_done) {
		CURLcode result = .CURLE_OK;
		tftp_state_data_t state = (tftp_state_data_t)conn.getProto().getTftpc();
		dophase_done = 0;
		result = ModernizedCProgram.tftp_state_machine(state, .TFTP_EVENT_INIT);
		if ((state.getState() == .TFTP_STATE_FIN) || result) {
			return result;
		} 
		ModernizedCProgram.tftp_multi_statemach(conn, dophase_done);
		if (dophase_done) {
			do {
			} while (0);
		} 
		return result/**********************************************************
		 *
		 * tftp_do
		 *
		 * The do callback
		 *
		 * This callback initiates the TFTP transfer
		 *
		 **********************************************************/;
	}
	public static  tftp_do(Object conn, Object done) {
		tftp_state_data_t state = new tftp_state_data_t();
		CURLcode result = new CURLcode();
		done = 0;
		if (!conn.getProto().getTftpc()) {
			result = ModernizedCProgram.tftp_connect(conn, done);
			if (result) {
				return result;
			} 
		} 
		state = (tftp_state_data_t)conn.getProto().getTftpc();
		if (!state) {
			return .CURLE_TFTP_ILLEGAL;
		} 
		result = ModernizedCProgram.tftp_perform(conn, done);
		if (!/* If tftp_perform() returned an error, use that for return code. If it
		     was OK, see if tftp_translate_code() has an error. */result) {
			result = ModernizedCProgram.tftp_translate_code(state.getError());
		} 
		return result;
	}
	public static  tftp_setup_connection(Object conn) {
		Curl_easy data = conn.getData();
		byte type;
		conn.setTransport(.TRNSPRT_UDP);
		type = .strstr(data.getState().getUp().getPath(), /* TFTP URLs support an extension like ";mode=<typecode>" that
		   * we'll try to get now! */";mode=");
		if (!type) {
			type = .strstr(conn.getHost().getRawalloc(), ";mode=");
		} 
		if (type) {
			byte command;
			type = /* it was in the middle of the hostname */0;
			command = ModernizedCProgram.Curl_raw_toupper(type[6]);
			switch (command) {
			case /* NETASCII mode */(byte)'N':
					data.getSet().setPrefer_ascii(1);
					break;
			case /* octet mode */(byte)'O':
			case /* ASCII mode */(byte)'A':
			case /* binary mode */(byte)'I':
			default:
					data.getSet().setPrefer_ascii(/* switch off ASCII */0);
					break;
			}
		} 
		return .CURLE_OK;
	}
	public static void Curl_sasl_cleanup(Object conn, int authused) {
		if (authused == (1 << /* Cleanup the NTLM structure */6)) {
			.Curl_auth_cleanup_ntlm(conn.getNtlm());
		} 
	}
	/* Cleanup the gssapi structure */
	public static int Curl_sasl_decode_mech(Object ptr, Object maxlen, Object len) {
		int i;
		byte c;
		for (i = 0; mechtable[i].getName(); i++) {
			if (maxlen >= mechtable[i].getLen() && !.memcmp(ptr, mechtable[i].getName(), mechtable[i].getLen())) {
				if (len) {
					len = mechtable[i].getLen();
				} 
				if (maxlen == mechtable[i].getLen()) {
					return mechtable[i].getBit();
				} 
				c = ptr[mechtable[i].getLen()];
				if (!(ModernizedCProgram.Curl_isupper((int)((byte)c))) && !(ModernizedCProgram.Curl_isdigit((int)((byte)c))) && c != (byte)'-' && c != (byte)'_') {
					return mechtable[i].getBit();
				} 
			} 
		}
		return 0/*
		 * Curl_sasl_parse_url_auth_option()
		 *
		 * Parse the URL login options.
		 */;
	}
	public static  Curl_sasl_parse_url_auth_option(Object sasl, Object value, Object len) {
		CURLcode result = .CURLE_OK;
		size_t mechlen = new size_t();
		if (!len) {
			return .CURLE_URL_MALFORMAT;
		} 
		if (sasl.getResetprefs()) {
			sasl.setResetprefs(0);
			sasl.setPrefmech(0);
		} 
		if (!.strncmp(value, "*", len)) {
			sasl.setPrefmech((~-1024 & ~(1 << 5)));
		} else {
				int mechbit = ModernizedCProgram.Curl_sasl_decode_mech(value, len, mechlen);
				if (mechbit && mechlen == len) {
					sasl.getPrefmech() |=  mechbit;
				} else {
						result = .CURLE_URL_MALFORMAT;
				} 
		} 
		return result/*
		 * Curl_sasl_init()
		 *
		 * Initializes the SASL structure.
		 */;
	}
	public static void Curl_sasl_init(Object sasl, Object params) {
		sasl.setParams(/* Set protocol dependent parameters */params);
		sasl.setState(/* Not yet running */.SASL_STOP);
		sasl.setAuthmechs(/* No known authentication mechanism yet */0);
		sasl.setPrefmech((~-1024 & ~(1 << /* Prefer all mechanisms */5)));
		sasl.setAuthused(/* No the authentication mechanism used */0);
		sasl.setResetprefs(/* Reset prefmech upon AUTH parsing. */1);
		sasl.setMutual_auth(/* No mutual authentication (GSSAPI only) */0);
		sasl.setForce_ir(/* Respect external option */0/*
		 * state()
		 *
		 * This is the ONLY way to change SASL state!
		 */);
	}
	public static  Curl_sasl_can_authenticate(Object sasl, Object conn) {
		if (conn.getBits().getUser_passwd()) {
			return 1;
		} 
		if (sasl.getAuthmechs() & sasl.getPrefmech() & (1 << /* EXTERNAL can authenticate without a user name and/or password */5)) {
			return 1;
		} 
		return 0/*
		 * Curl_sasl_start()
		 *
		 * Calculate the required login details for SASL authentication.
		 */;
	}
	public static  Curl_sasl_start(Object sasl, Object conn,  force_ir, Object progress) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		int enabledmechs;
		byte mech = ((Object)0);
		byte resp = ((Object)0);
		size_t len = 0;
		saslstate state1 = .SASL_STOP;
		saslstate state2 = .SASL_FINAL;
		byte hostname = (.CURLPROXY_HTTPS == conn.getHttp_proxy().getProxytype() && .ssl_connection_complete != conn.getProxy_ssl()[conn.getSock()[1] == (SOCKET)(~0) ? 0 : 1].getState()) ? conn.getHttp_proxy().getHost().getName() : conn.getHost().getName();
		long port = (.CURLPROXY_HTTPS == conn.getHttp_proxy().getProxytype() && .ssl_connection_complete != conn.getProxy_ssl()[conn.getSock()[1] == (SOCKET)(~0) ? 0 : 1].getState()) ? conn.getPort() : conn.getRemote_port();
		byte service = data.getSet().getStr()[dupstring.STRING_SERVICE_NAME] ? data.getSet().getStr()[dupstring.STRING_SERVICE_NAME] : sasl.getParams().getService();
		sasl.setForce_ir(/* Latch for future use */force_ir);
		sasl.setAuthused(/* No mechanism used yet */0);
		enabledmechs = sasl.getAuthmechs() & sasl.getPrefmech();
		progress = .SASL_IDLE;
		if ((enabledmechs & (1 << 5)) && !conn.getPasswd()[/* Calculate the supported authentication mechanism, by decreasing order of
		     security, as well as the initial response where appropriate */0]) {
			mech = "EXTERNAL";
			state1 = .SASL_EXTERNAL;
			sasl.setAuthused((1 << 5));
			if (force_ir || data.getSet().getSasl_ir()) {
				result = .Curl_auth_create_external_message(data, conn.getUser(), resp, len);
			} 
		}  else if (conn.getBits().getUser_passwd()) {
			if ((enabledmechs & (1 << 3)) && .Curl_auth_is_digest_supported()) {
				mech = "DIGEST-MD5";
				state1 = .SASL_DIGESTMD5;
				sasl.setAuthused((1 << 3));
			}  else if (enabledmechs & (1 << 2)) {
				mech = "CRAM-MD5";
				state1 = .SASL_CRAMMD5;
				sasl.setAuthused((1 << 2));
			}  else if ((enabledmechs & (1 << 6)) && .Curl_auth_is_ntlm_supported()) {
				mech = "NTLM";
				state1 = .SASL_NTLM;
				state2 = .SASL_NTLM_TYPE2MSG;
				sasl.setAuthused((1 << 6));
				if (force_ir || data.getSet().getSasl_ir()) {
					result = .Curl_auth_create_ntlm_type1_message(data, conn.getUser(), conn.getPasswd(), service, hostname, conn.getNtlm(), resp, len);
				} 
			}  else if ((enabledmechs & (1 << 8)) && conn.getOauth_bearer()) {
				mech = "OAUTHBEARER";
				state1 = .SASL_OAUTH2;
				state2 = .SASL_OAUTH2_RESP;
				sasl.setAuthused((1 << 8));
				if (force_ir || data.getSet().getSasl_ir()) {
					result = .Curl_auth_create_oauth_bearer_message(data, conn.getUser(), hostname, port, conn.getOauth_bearer(), resp, len);
				} 
			}  else if ((enabledmechs & (1 << 7)) && conn.getOauth_bearer()) {
				mech = "XOAUTH2";
				state1 = .SASL_OAUTH2;
				sasl.setAuthused((1 << 7));
				if (force_ir || data.getSet().getSasl_ir()) {
					result = .Curl_auth_create_xoauth_bearer_message(data, conn.getUser(), conn.getOauth_bearer(), resp, len);
				} 
			}  else if (enabledmechs & (1 << 1)) {
				mech = "PLAIN";
				state1 = .SASL_PLAIN;
				sasl.setAuthused((1 << 1));
				if (force_ir || data.getSet().getSasl_ir()) {
					result = .Curl_auth_create_plain_message(data, conn.getSasl_authzid(), conn.getUser(), conn.getPasswd(), resp, len);
				} 
			}  else if (enabledmechs & (1 << 0)) {
				mech = "LOGIN";
				state1 = .SASL_LOGIN;
				state2 = .SASL_LOGIN_PASSWD;
				sasl.setAuthused((1 << 0));
				if (force_ir || data.getSet().getSasl_ir()) {
					result = .Curl_auth_create_login_message(data, conn.getUser(), resp, len);
				} 
			} 
		} 
		if (!result && mech) {
			if (resp && sasl.getParams().getMaxirlen() && .strlen(mech) + len > sasl.getParams().getMaxirlen()) {
				.Curl_cfree(resp);
				resp = ((Object)0);
			} 
			result = .UNRECOGNIZEDFUNCTIONNAME(conn, mech, resp);
			if (!result) {
				progress = .SASL_INPROGRESS;
				ModernizedCProgram.state(sasl, conn, resp ? state2 : state1);
			} 
		} 
		.Curl_cfree(resp);
		return result/*
		 * Curl_sasl_continue()
		 *
		 * Continue the authentication.
		 */;
	}
	public static  Curl_sasl_continue(Object sasl, Object conn, int code, Object progress) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		saslstate newstate = .SASL_FINAL;
		byte resp = ((Object)0);
		byte hostname = (.CURLPROXY_HTTPS == conn.getHttp_proxy().getProxytype() && .ssl_connection_complete != conn.getProxy_ssl()[conn.getSock()[1] == (SOCKET)(~0) ? 0 : 1].getState()) ? conn.getHttp_proxy().getHost().getName() : conn.getHost().getName();
		long port = (.CURLPROXY_HTTPS == conn.getHttp_proxy().getProxytype() && .ssl_connection_complete != conn.getProxy_ssl()[conn.getSock()[1] == (SOCKET)(~0) ? 0 : 1].getState()) ? conn.getPort() : conn.getRemote_port();
		byte chlg = ((Object)0);
		size_t chlglen = 0;
		byte service = data.getSet().getStr()[dupstring.STRING_SERVICE_NAME] ? data.getSet().getStr()[dupstring.STRING_SERVICE_NAME] : sasl.getParams().getService();
		byte serverdata;
		size_t len = 0;
		progress = .SASL_INPROGRESS;
		if (sasl.getState() == .SASL_FINAL) {
			if (code != sasl.getParams().getFinalcode()) {
				result = .CURLE_LOGIN_DENIED;
			} 
			progress = .SASL_DONE;
			ModernizedCProgram.state(sasl, conn, .SASL_STOP);
			return result;
		} 
		if (sasl.getState() != .SASL_CANCEL && sasl.getState() != .SASL_OAUTH2_RESP && code != sasl.getParams().getContcode()) {
			progress = .SASL_DONE;
			ModernizedCProgram.state(sasl, conn, .SASL_STOP);
			return .CURLE_LOGIN_DENIED;
		} 
		switch (sasl.getState()) {
		case .SASL_CRAMMD5:
				.UNRECOGNIZEDFUNCTIONNAME(data.getState().getBuffer(), serverdata);
				result = .Curl_auth_decode_cram_md5_message(serverdata, chlg, chlglen);
				if (!result) {
					result = .Curl_auth_create_cram_md5_message(data, chlg, conn.getUser(), conn.getPasswd(), resp, len);
				} 
				.Curl_cfree(chlg);
				break;
		case .SASL_DIGESTMD5:
				.UNRECOGNIZEDFUNCTIONNAME(data.getState().getBuffer(), serverdata);
				result = .Curl_auth_create_digest_md5_message(data, serverdata, conn.getUser(), conn.getPasswd(), service, resp, len);
				newstate = .SASL_DIGESTMD5_RESP;
				break;
		case .SASL_DIGESTMD5_RESP:
				resp = .Curl_cstrdup("");
				if (!resp) {
					result = .CURLE_OUT_OF_MEMORY;
				} 
				break;
		case .SASL_STOP:
				progress = .SASL_DONE;
				return result;
		case .SASL_OAUTH2_RESP:
				if (code == sasl.getParams().getFinalcode()) {
					progress = /* Final response was received so we are done */.SASL_DONE;
					ModernizedCProgram.state(sasl, conn, .SASL_STOP);
					return result;
				}  else if (code == sasl.getParams().getContcode()) {
					resp = .Curl_cstrdup("AQ==");
					if (!resp) {
						result = .CURLE_OUT_OF_MEMORY;
					} 
					break;
				} else {
						progress = .SASL_DONE;
						ModernizedCProgram.state(sasl, conn, .SASL_STOP);
						return .CURLE_LOGIN_DENIED;
				} 
		case .SASL_PLAIN:
				result = .Curl_auth_create_plain_message(data, conn.getSasl_authzid(), conn.getUser(), conn.getPasswd(), resp, len);
				break;
		case .SASL_EXTERNAL:
				result = .Curl_auth_create_external_message(data, conn.getUser(), resp, len);
				break;
		case .SASL_LOGIN:
				result = .Curl_auth_create_login_message(data, conn.getUser(), resp, len);
				newstate = .SASL_LOGIN_PASSWD;
				break;
		case .SASL_LOGIN_PASSWD:
				result = .Curl_auth_create_login_message(data, conn.getPasswd(), resp, len);
				break;
		case .SASL_NTLM:
				result = .Curl_auth_create_ntlm_type1_message(/* Create the type-1 message */data, conn.getUser(), conn.getPasswd(), service, hostname, conn.getNtlm(), resp, len);
				newstate = .SASL_NTLM_TYPE2MSG;
				break;
		case .SASL_CANCEL:
				sasl.getAuthmechs() ^=  sasl.getAuthused();
				result = ModernizedCProgram.Curl_sasl_start(sasl, conn, sasl.getForce_ir(), /* Start an alternative SASL authentication */progress);
				newstate = sasl.getState();
				break;
		case .SASL_NTLM_TYPE2MSG:
				.UNRECOGNIZEDFUNCTIONNAME(data.getState().getBuffer(), /* Decode the type-2 message */serverdata);
				result = .Curl_auth_decode_ntlm_type2_message(data, serverdata, conn.getNtlm());
				if (!result) {
					result = .Curl_auth_create_ntlm_type3_message(data, conn.getUser(), conn.getPasswd(), conn.getNtlm(), resp, len);
				} 
				break;
		case /* Decode the security challenge and create the response message *//* Decode the security challenge and create the response message */.SASL_OAUTH2:
				if (sasl.getAuthused() == (1 << /* Create the authorisation message */8)) {
					result = .Curl_auth_create_oauth_bearer_message(data, conn.getUser(), hostname, port, conn.getOauth_bearer(), resp, len);
					newstate = /* Failures maybe sent by the server as continuations for OAUTHBEARER */.SASL_OAUTH2_RESP;
				} else {
						result = .Curl_auth_create_xoauth_bearer_message(data, conn.getUser(), conn.getOauth_bearer(), resp, len);
				} 
				break;
		default:
				ModernizedCProgram.Curl_failf(data, "Unsupported SASL authentication mechanism");
				result = /* Should not happen */.CURLE_UNSUPPORTED_PROTOCOL;
				break;
		}
		switch (result) {
		case .CURLE_OK:
				if (resp) {
					result = .UNRECOGNIZEDFUNCTIONNAME(conn, resp);
				} 
				break;
		case .CURLE_BAD_CONTENT_ENCODING:
				result = .UNRECOGNIZEDFUNCTIONNAME(conn, /* Cancel dialog */"*");
				newstate = .SASL_CANCEL;
				break;
		default:
				newstate = /* Stop on error */.SASL_STOP;
				progress = .SASL_DONE;
				break;
		}
		.Curl_cfree(resp);
		ModernizedCProgram.state(sasl, conn, newstate);
		return result/* protocols are enabled that use SASL */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/*
	 * Perform SSL initialization for HTTPS proxy.  Sets
	 * proxy_ssl_connected connection bit when complete.  Can be
	 * called multiple times.
	 */
	public static  https_proxy_connect(Object conn, int sockindex) {
		(Object)/* a failed connection is marked for closure to
		                                  prevent (bad) re-use or similar */conn;
		(Object)sockindex;
		return .CURLE_NOT_BUILT_IN;
	}
	/* perform SSL initialization for this socket */
	public static  Curl_proxy_connect(Object conn, int sockindex) {
		if (conn.getHttp_proxy().getProxytype() == .CURLPROXY_HTTPS) {
			CURLcode result = ModernizedCProgram.https_proxy_connect(conn, sockindex);
			if (result) {
				return result;
			} 
			if (!conn.getBits().getProxy_ssl_connected()[sockindex]) {
				return /* wait for HTTPS proxy SSL initialization to complete */result;
			} 
		} 
		if (conn.getBits().getTunnel_proxy() && conn.getBits().getHttpproxy()) {
			HTTP http_proxy = new HTTP();
			Object prot_save;
			byte hostname;
			int remote_port;
			CURLcode result = new CURLcode();
			prot_save = conn.getData().getReq().getProtop();
			.memset(http_proxy, 0, );
			conn.getData().getReq().setProtop(http_proxy);
			ModernizedCProgram.Curl_conncontrol(conn, 0/* for the secondary socket (FTP), use the "connect to host"
			     * but ignore the "connect to port" (use the secondary port)
			     */);
			if (conn.getBits().getConn_to_host()) {
				hostname = conn.getConn_to_host().getName();
			}  else if (sockindex == 1) {
				hostname = conn.getSecondaryhostname();
			} else {
					hostname = conn.getHost().getName();
			} 
			if (sockindex == 1) {
				remote_port = conn.getSecondary_port();
			}  else if (conn.getBits().getConn_to_port()) {
				remote_port = conn.getConn_to_port();
			} else {
					remote_port = conn.getRemote_port();
			} 
			result = ModernizedCProgram.Curl_proxyCONNECT(conn, sockindex, hostname, remote_port);
			conn.getData().getReq().setProtop(prot_save);
			if (.CURLE_OK != result) {
				return result;
			} 
			do {
				.Curl_cfree((conn.getAllocptr().getProxyuserpwd()));
				(conn.getAllocptr().getProxyuserpwd()) = ((Object)0);
			} while (0);
		} 
		return /* no HTTP tunnel proxy, just return */.CURLE_OK;
	}
	public static  Curl_connect_complete(Object conn) {
		return !conn.getConnect_state() || (conn.getConnect_state().getTunnel_state() == .TUNNEL_COMPLETE);
	}
	public static  Curl_connect_ongoing(Object conn) {
		return conn.getConnect_state() && (conn.getConnect_state().getTunnel_state() != .TUNNEL_COMPLETE);
	}
	public static  connect_init(Object conn,  reinit) {
		http_connect_state s = new http_connect_state();
		if (!reinit) {
			do {
			} while (0);
			s = .Curl_ccalloc(1, );
			if (!s) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			ModernizedCProgram.Curl_infof(conn.getData(), "allocate connect buffer!\n");
			conn.setConnect_state(s);
		} else {
				do {
				} while (0);
				s = conn.getConnect_state();
		} 
		s.setTunnel_state(.TUNNEL_INIT);
		s.setKeepon(1);
		s.setLine_start(s.getConnect_buffer());
		s.setPtr(s.getLine_start());
		s.setCl(0);
		s.setClose_connection(0);
		return .CURLE_OK;
	}
	public static void connect_done(Object conn) {
		http_connect_state s = conn.getConnect_state();
		s.setTunnel_state(.TUNNEL_COMPLETE);
		ModernizedCProgram.Curl_infof(conn.getData(), "CONNECT phase completed!\n");
	}
	public static  CONNECT(Object conn, int sockindex, Object hostname, int remote_port) {
		int subversion = 0;
		Curl_easy data = conn.getData();
		SingleRequest k = data.getReq();
		CURLcode result = new CURLcode();
		curl_socket_t tunnelsocket = conn.getSock()[sockindex];
		http_connect_state s = conn.getConnect_state();
		if (ModernizedCProgram.Curl_connect_complete(conn)) {
			return /* CONNECT is already completed */.CURLE_OK;
		} 
		conn.getBits().setProxy_connect_closed(0);
		do {
			timediff_t check = new timediff_t();
			if (.TUNNEL_INIT == s.getTunnel_state()) {
				byte host_port;
				Curl_send_buffer req_buffer = new Curl_send_buffer();
				ModernizedCProgram.Curl_infof(data, "Establish HTTP proxy tunnel to %s:%d\n", hostname, remote_port/* This only happens if we've looped here due to authentication
				           reasons, and we don't really use the newly cloned URL here
				           then. Just free() it. */);
				.Curl_cfree(data.getReq().getNewurl());
				data.getReq().setNewurl(((Object)0));
				req_buffer = ModernizedCProgram.Curl_add_buffer_init();
				if (!req_buffer) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				host_port = ModernizedCProgram.curl_maprintf("%s:%d", hostname, remote_port);
				if (!host_port) {
					ModernizedCProgram.Curl_add_buffer_free(req_buffer);
					return .CURLE_OUT_OF_MEMORY;
				} 
				result = ModernizedCProgram.Curl_http_output_auth(conn, "CONNECT", host_port, /* Setup the proxy-authorization header, if any */1);
				.Curl_cfree(host_port);
				if (!result) {
					byte host = ((Object)0);
					byte proxyconn = "";
					byte useragent = "";
					byte http = (conn.getHttp_proxy().getProxytype() == .CURLPROXY_HTTP_1_0) ? "1.0" : "1.1";
					bool ipv6_ip = conn.getBits().getIpv6_ip();
					byte hostheader;
					if (hostname != conn.getHost().getName()) {
						ipv6_ip = (.strchr(hostname, (byte)':') != ((Object)0));
					} 
					/* host:port with IPv6 support */hostheader = ModernizedCProgram.curl_maprintf("%s%s%s:%d", ipv6_ip ? "[" : "", hostname, ipv6_ip ? "]" : "", remote_port);
					if (!hostheader) {
						ModernizedCProgram.Curl_add_buffer_free(req_buffer);
						return .CURLE_OUT_OF_MEMORY;
					} 
					if (!ModernizedCProgram.Curl_checkProxyheaders(conn, "Host")) {
						host = ModernizedCProgram.curl_maprintf("Host: %s\r\n", hostheader);
						if (!host) {
							.Curl_cfree(hostheader);
							ModernizedCProgram.Curl_add_buffer_free(req_buffer);
							return .CURLE_OUT_OF_MEMORY;
						} 
					} 
					if (!ModernizedCProgram.Curl_checkProxyheaders(conn, "Proxy-Connection")) {
						proxyconn = "Proxy-Connection: Keep-Alive\r\n";
					} 
					if (!ModernizedCProgram.Curl_checkProxyheaders(conn, "User-Agent") && data.getSet().getStr()[dupstring.STRING_USERAGENT]) {
						useragent = conn.getAllocptr().getUagent();
					} 
					result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "CONNECT %s HTTP/%s\r\n%s%s%s%s"/* Host: *//* Proxy-Authorization */, /* User-Agent *//* Proxy-Connection */hostheader, http, host ? host : "", conn.getAllocptr().getProxyuserpwd() ? conn.getAllocptr().getProxyuserpwd() : "", useragent, proxyconn);
					if (host) {
						.Curl_cfree(host);
					} 
					.Curl_cfree(hostheader);
					if (!result) {
						result = ModernizedCProgram.Curl_add_custom_headers(conn, 1, req_buffer);
					} 
					if (!result) {
						result = ModernizedCProgram.Curl_add_bufferf(req_buffer, /* CRLF terminate the request */"\r\n");
					} 
					if (!result/* Send the connect request to the proxy */) {
						/* BLOCKING */result = ModernizedCProgram.Curl_add_buffer_send(req_buffer, conn, data.getInfo().getRequest_size(), 0, sockindex);
					} 
					req_buffer = ((Object)0);
					if (result) {
						ModernizedCProgram.Curl_failf(data, "Failed sending CONNECT to proxy");
					} 
				} 
				ModernizedCProgram.Curl_add_buffer_free(req_buffer);
				if (result) {
					return result;
				} 
				s.setTunnel_state(.TUNNEL_CONNECT);
				s.setPerline(0/* END CONNECT PHASE */);
			} 
			check = ModernizedCProgram.Curl_timeleft(data, ((Object)0), 1);
			if (check <= 0) {
				ModernizedCProgram.Curl_failf(data, "Proxy CONNECT aborted due to timeout");
				return .CURLE_OPERATION_TIMEDOUT;
			} 
			if (!ModernizedCProgram.Curl_conn_data_pending(conn, sockindex)) {
				return /* return so we'll be called again polling-style */.CURLE_OK/* at this point, the tunnel_connecting phase is over. */;
			} 
			{ 
				int error = /* READING RESPONSE PHASE */0;
				while (s.getKeepon()) {
					ssize_t gotbytes = new ssize_t();
					if (s.getPtr() >= s.getConnect_buffer()[/* make sure we have space to read more data */16384]) {
						ModernizedCProgram.Curl_failf(data, "CONNECT response too large!");
						return .CURLE_RECV_ERROR;
					} 
					result = ModernizedCProgram.Curl_read(conn, tunnelsocket, s.getPtr(), 1, /* Read one byte at a time to avoid a race condition. Wait at most one
					           second before looping to ensure continuous pgrsUpdates. */gotbytes);
					if (result == .CURLE_AGAIN) {
						return /* socket buffer drained, return */.CURLE_OK;
					} 
					if (ModernizedCProgram.Curl_pgrsUpdate(conn)) {
						return .CURLE_ABORTED_BY_CALLBACK;
					} 
					if (result) {
						s.setKeepon(0);
						break;
					}  else if (gotbytes <= 0) {
						if (data.getSet().getProxyauth() && data.getState().getAuthproxy().getAvail()) {
							conn.getBits().setProxy_connect_closed(1);
							ModernizedCProgram.Curl_infof(data, "Proxy CONNECT connection closed\n");
						} else {
								error = 1;
								ModernizedCProgram.Curl_failf(data, "Proxy CONNECT aborted");
						} 
						s.setKeepon(0);
						break;
					} 
					if (s.getKeepon() > 1/* This means we are currently ignoring a response-body */) {
						s.setPtr(s.getConnect_buffer());
						if (s.getCl()) {
							s.getCl()--;
							if (s.getCl() <= 0) {
								s.setKeepon(0);
								s.setTunnel_state(.TUNNEL_COMPLETE);
								break;
							} 
						} else {
								CHUNKcode r = new CHUNKcode();
								CURLcode extra = new CURLcode();
								ssize_t tookcareof = 0;
								r = ModernizedCProgram.Curl_httpchunk_read(conn, s.getPtr(), 1, tookcareof, /* now parse the chunked piece of data so that we can
								               properly tell when the stream ends */extra);
								if (r == .CHUNKE_STOP) {
									ModernizedCProgram.Curl_infof(data, /* we're done reading chunks! */"chunk reading DONE\n");
									s.setKeepon(0);
									s.setTunnel_state(/* we did the full CONNECT treatment, go COMPLETE */.TUNNEL_COMPLETE);
								} 
						} 
						continue;
					} 
					s.getPerline()++;
					if (s.getPtr() != /* if this is not the end of a header line then continue */-1024) {
						s.getPtr()++;
						continue;
					} 
					result = ();
					if (/* Curl_convert_from_network calls failf if unsuccessful */result) {
						return result;
					} 
					if (data.getSet().getVerbose()) {
						ModernizedCProgram.Curl_debug(data, .CURLINFO_HEADER_IN, s.getLine_start(), (size_t)s.getPerline());
					} 
					if (!data.getSet().getSuppress_connect_headers()) {
						int writetype = (1 << /* send the header to the callback */1);
						if (data.getSet().getInclude_header()) {
							writetype |=  (1 << 0);
						} 
						result = ModernizedCProgram.Curl_client_write(conn, writetype, s.getLine_start(), s.getPerline());
						if (result) {
							return result;
						} 
					} 
					data.getInfo().getHeader_size() += (long)s.getPerline();
					data.getReq().getHeaderbytecount() += (long)s.getPerline();
					if (((byte)'\r' == s.getLine_start()[0]) || ((byte)'\n' == s.getLine_start()[0])) {
						s.setPtr(s.getConnect_buffer());
						if ((407 == k.getHttpcode()) && !data.getState().getAuthproblem()) {
							s.setKeepon(2);
							if (s.getCl()) {
								ModernizedCProgram.Curl_infof(data, "Ignore %I64d bytes of response-body\n", s.getCl());
							}  else if (s.getChunked_encoding()) {
								CHUNKcode r = new CHUNKcode();
								CURLcode extra = new CURLcode();
								ModernizedCProgram.Curl_infof(data, "Ignore chunked response-body\n"/* We set ignorebody true here since the chunked
								                 decoder function will acknowledge that. Pay
								                 attention so that this is cleared again when this
								                 function returns! */);
								k.setIgnorebody(1);
								if (s.getLine_start()[1] == (byte)'\n'/* this can only be a LF if the letter at index 0
								                   was a CR */) {
									s.getLine_start()++;
								} 
								r = ModernizedCProgram.Curl_httpchunk_read(conn, s.getLine_start() + 1, 1, /* now parse the chunked piece of data so that we can
								                 properly tell when the stream ends */gotbytes, extra);
								if (r == .CHUNKE_STOP) {
									ModernizedCProgram.Curl_infof(data, /* we're done reading chunks! */"chunk reading DONE\n");
									s.setKeepon(0);
									s.setTunnel_state(/* we did the full CONNECT treatment, go to COMPLETE */.TUNNEL_COMPLETE);
								} 
							} else {
									s.setKeepon(/* without content-length or chunked encoding, we
									                 can't keep the connection alive since the close is
									                 the end signal so we bail out at once instead */0);
							} 
						} else {
								s.setKeepon(0);
						} 
						if (!s.getCl()) {
							s.setTunnel_state(/* we did the full CONNECT treatment, go to COMPLETE */.TUNNEL_COMPLETE);
						} 
						continue;
					} 
					s.getLine_start()[s.getPerline()] = /* zero terminate the buffer */0;
					if ((ModernizedCProgram.curl_strnequal("WWW-Authenticate:", s.getLine_start(), .strlen("WWW-Authenticate:")) && (401 == k.getHttpcode())) || (ModernizedCProgram.curl_strnequal("Proxy-authenticate:", s.getLine_start(), .strlen("Proxy-authenticate:")) && (407 == k.getHttpcode()))) {
						bool proxy = (k.getHttpcode() == 407) ? 1 : 0;
						byte auth = ModernizedCProgram.Curl_copy_header_value(s.getLine_start());
						if (!auth) {
							return .CURLE_OUT_OF_MEMORY;
						} 
						result = ModernizedCProgram.Curl_http_input_auth(conn, proxy, auth);
						.Curl_cfree(auth);
						if (result) {
							return result;
						} 
					}  else if (ModernizedCProgram.curl_strnequal("Content-Length:", s.getLine_start(), .strlen("Content-Length:"))) {
						if (k.getHttpcode() / 100 == 2/* A client MUST ignore any Content-Length or Transfer-Encoding
						               header fields received in a successful response to CONNECT.
						               "Successful" described as: 2xx (Successful). RFC 7231 4.3.6 */) {
							ModernizedCProgram.Curl_infof(data, "Ignoring Content-Length in CONNECT %03d response\n", k.getHttpcode());
						} else {
								(Object)ModernizedCProgram.curlx_strtoofft(s.getLine_start() + .strlen("Content-Length:"), ((Object)0), 10, s.getCl());
						} 
					}  else if (ModernizedCProgram.Curl_compareheader(s.getLine_start(), "Connection:", "close")) {
						s.setClose_connection(1);
					}  else if (ModernizedCProgram.curl_strnequal("Transfer-Encoding:", s.getLine_start(), .strlen("Transfer-Encoding:"))) {
						if (k.getHttpcode() / 100 == 2/* A client MUST ignore any Content-Length or Transfer-Encoding
						               header fields received in a successful response to CONNECT.
						               "Successful" described as: 2xx (Successful). RFC 7231 4.3.6 */) {
							ModernizedCProgram.Curl_infof(data, "Ignoring Transfer-Encoding in CONNECT %03d response\n", k.getHttpcode());
						}  else if (ModernizedCProgram.Curl_compareheader(s.getLine_start(), "Transfer-Encoding:", "chunked")) {
							ModernizedCProgram.Curl_infof(data, "CONNECT responded chunked\n");
							s.setChunked_encoding(1);
							ModernizedCProgram.Curl_httpchunk_init(/* init our chunky engine */conn);
						} 
					}  else if (ModernizedCProgram.Curl_compareheader(s.getLine_start(), "Proxy-Connection:", "close")) {
						s.setClose_connection(1);
					}  else if (2 == .sscanf(s.getLine_start(), "HTTP/1.%d %d", subversion, k.getHttpcode())) {
						data.getInfo().setHttpproxycode(k.getHttpcode());
					} 
					s.setPerline(/* line starts over here */0);
					s.setPtr(s.getConnect_buffer());
					s.setLine_start(s.getPtr());
				}
				if (ModernizedCProgram.Curl_pgrsUpdate(conn)) {
					return .CURLE_ABORTED_BY_CALLBACK;
				} 
				if (error) {
					return .CURLE_RECV_ERROR;
				} 
				if (data.getInfo().getHttpproxycode() / 100 != 2/* Deal with the possibly already received authenticate
				           headers. 'newurl' is set to a new URL if we must loop. */) {
					result = ModernizedCProgram.Curl_http_auth_act(conn);
					if (result) {
						return result;
					} 
					if (conn.getBits().getClose()) {
						s.setClose_connection(1);
					} 
				} 
				if (s.getClose_connection() && data.getReq().getNewurl()) {
					ModernizedCProgram.Curl_closesocket(conn, conn.getSock()[/* Connection closed by server. Don't use it anymore */sockindex]);
					conn.getSock()[sockindex] = (SOCKET)(~0);
					break;
				} 
			}
			if (data.getReq().getNewurl() && (.TUNNEL_COMPLETE == s.getTunnel_state())) {
				ModernizedCProgram.connect_init(conn, /* reinit */1);
			} 
		} while (data.getReq().getNewurl());
		if (data.getInfo().getHttpproxycode() / 100 != 2) {
			if (s.getClose_connection() && data.getReq().getNewurl()) {
				conn.getBits().setProxy_connect_closed(1);
				ModernizedCProgram.Curl_infof(data, "Connect me again please\n");
				ModernizedCProgram.connect_done(conn);
			} else {
					.Curl_cfree(data.getReq().getNewurl());
					data.getReq().setNewurl(((Object)0));
					ModernizedCProgram.Curl_conncontrol(conn, /* failure, close this connection to avoid re-use */2);
					ModernizedCProgram.Curl_closesocket(conn, conn.getSock()[sockindex]);
					conn.getSock()[sockindex] = (SOCKET)(~0);
			} 
			s.setTunnel_state(/* to back to init state */.TUNNEL_INIT);
			if (conn.getBits().getProxy_connect_closed()) {
				return /* this is not an error, just part of the connection negotiation */.CURLE_OK;
			} 
			ModernizedCProgram.Curl_failf(data, "Received HTTP code %d from proxy after CONNECT", data.getReq().getHttpcode());
			return .CURLE_RECV_ERROR;
		} 
		s.setTunnel_state(.TUNNEL_COMPLETE/* If a proxy-authorization header was used for the proxy, then we should
		     make sure that it isn't accidentally used for the document request
		     after we've connected. So let's free and clear it here. */);
		do {
			.Curl_cfree((conn.getAllocptr().getProxyuserpwd()));
			(conn.getAllocptr().getProxyuserpwd()) = ((Object)0);
		} while (0);
		conn.getAllocptr().setProxyuserpwd(((Object)0));
		data.getState().getAuthproxy().setDone(1);
		data.getState().getAuthproxy().setMultipass(0);
		ModernizedCProgram.Curl_infof(data, "Proxy replied %d to CONNECT request\n", data.getInfo().getHttpproxycode());
		data.getReq().setIgnorebody(/* put it (back) to non-ignore state */0);
		conn.getBits().setRewindaftersend(/* make sure this isn't set for the
		                                         document request  */0);
		return .CURLE_OK;
	}
	public static void Curl_connect_free(Object data) {
		connectdata conn = data.getConn();
		http_connect_state s = conn.getConnect_state();
		if (s) {
			.Curl_cfree(s);
			conn.setConnect_state(((Object)0/*
			 * Curl_proxyCONNECT() requires that we're connected to a HTTP proxy. This
			 * function will issue the necessary commands to get a seamless tunnel through
			 * this proxy. After that, the socket can be used just as a normal socket.
			 */));
		} 
	}
	public static  Curl_proxyCONNECT(Object conn, int sockindex, Object hostname, int remote_port) {
		CURLcode result = new CURLcode();
		if (!conn.getConnect_state()) {
			result = ModernizedCProgram.connect_init(conn, 0);
			if (result) {
				return result;
			} 
		} 
		result = ModernizedCProgram.CONNECT(conn, sockindex, hostname, remote_port);
		if (result || ModernizedCProgram.Curl_connect_complete(conn)) {
			ModernizedCProgram.connect_done(conn);
		} 
		return result/* CURL_DISABLE_PROXY */;
	}
	public static int parsekeyword(Object pattern, Object charset) {
		parsekey_state state = .CURLFNM_PKW_INIT;
		byte[] keyword = new byte[]{0};
		int found = 0;
		int i;
		byte p = pattern;
		for (i = 0; !found; i++) {
			byte c = p++;
			if (i >= 10) {
				return 0;
			} 
			switch (state) {
			case .CURLFNM_PKW_INIT:
					if ((ModernizedCProgram.Curl_islower((int)((byte)c)))) {
						keyword[i] = c;
					}  else if (c == (byte)':') {
						state = .CURLFNM_PKW_DDOT;
					} else {
							return 0;
					} 
					break;
			case .CURLFNM_PKW_DDOT:
					if (c == (byte)']') {
						found = 1;
					} else {
							return 0;
					} 
			}
		}
		pattern = /* move caller's pattern pointer */p;
		if (.strcmp(keyword, "digit") == 0) {
			charset[(( * 256) + 2)] = 1;
		}  else if (.strcmp(keyword, "alnum") == 0) {
			charset[(( * 256) + 1)] = 1;
		}  else if (.strcmp(keyword, "alpha") == 0) {
			charset[(( * 256) + 4)] = 1;
		}  else if (.strcmp(keyword, "xdigit") == 0) {
			charset[(( * 256) + 3)] = 1;
		}  else if (.strcmp(keyword, "print") == 0) {
			charset[(( * 256) + 5)] = 1;
		}  else if (.strcmp(keyword, "graph") == 0) {
			charset[(( * 256) + 8)] = 1;
		}  else if (.strcmp(keyword, "space") == 0) {
			charset[(( * 256) + 9)] = 1;
		}  else if (.strcmp(keyword, "blank") == 0) {
			charset[(( * 256) + 6)] = 1;
		}  else if (.strcmp(keyword, "upper") == 0) {
			charset[(( * 256) + 10)] = 1;
		}  else if (.strcmp(keyword, "lower") == 0) {
			charset[(( * 256) + 7)] = 1;
		} else {
				return 0;
		} 
		return 1;
	}
	/* Return the character class. */
	public static  charclass(byte c) {
		if ((ModernizedCProgram.Curl_isupper((int)((byte)c)))) {
			return .CCLASS_UPPER;
		} 
		if ((ModernizedCProgram.Curl_islower((int)((byte)c)))) {
			return .CCLASS_LOWER;
		} 
		if ((ModernizedCProgram.Curl_isdigit((int)((byte)c)))) {
			return .CCLASS_DIGIT;
		} 
		return .CCLASS_OTHER;
	}
	/* Include a character or a range in set. */
	public static void setcharorrange(Object pp, Object charset) {
		byte p = (pp)++;
		byte c = p++;
		charset[c] = 1;
		if ((ModernizedCProgram.Curl_isalnum((int)((byte)c))) && p++ == (byte)'-') {
			char_class cc = ModernizedCProgram.charclass(c);
			byte endrange = p++;
			if (endrange == (byte)'\\') {
				endrange = p++;
			} 
			if (endrange >= c && ModernizedCProgram.charclass(endrange) == cc) {
				while (c++ != endrange) {
					if (ModernizedCProgram.charclass(c) == /* Chars in class may be not consecutive. */cc) {
						charset[c] = 1;
					} 
				}
				pp = p;
			} 
		} 
	}
	/* returns 1 (true) if pattern is OK, 0 if is bad ("p" is pattern pointer) */
	public static int setcharset(Object p, Object charset) {
		setcharset_state state = .CURLFNM_SCHS_DEFAULT;
		bool something_found = 0;
		byte c;
		.memset(charset, 0, (( * 256) + 15));
		for (; ; ) {
			c = p;
			if (!c) {
				return 0;
			} 
			switch (state) {
			case .CURLFNM_SCHS_DEFAULT:
					if (c == (byte)']') {
						if (something_found) {
							return 1;
						} 
						something_found = 1;
						state = .CURLFNM_SCHS_RIGHTBR;
						charset[c] = 1;
						(p)++;
					}  else if (c == (byte)'[') {
						byte pp = p + 1;
						if (pp++ == (byte)':' && ModernizedCProgram.parsekeyword(pp, charset)) {
							p = pp;
						} else {
								charset[c] = 1;
								(p)++;
						} 
						something_found = 1;
					}  else if (c == (byte)'^' || c == (byte)'!') {
						if (!something_found) {
							if (charset[( * 256)]) {
								charset[c] = 1;
								something_found = 1;
							} else {
									charset[( * 256)] = /* negate charset */1;
							} 
						} else {
								charset[c] = 1;
						} 
						(p)++;
					}  else if (c == (byte)'\\') {
						c = (++(p));
						if (c) {
							ModernizedCProgram.setcharorrange(p, charset);
						} else {
								charset[(byte)'\\'] = 1;
						} 
						something_found = 1;
					} else {
							ModernizedCProgram.setcharorrange(p, charset);
							something_found = 1;
					} 
					break;
			case .CURLFNM_SCHS_RIGHTBR:
					if (c == (byte)'[') {
						state = .CURLFNM_SCHS_RIGHTBRLEFTBR;
						charset[c] = 1;
						(p)++;
					}  else if (c == (byte)']') {
						return 1;
					}  else if ((ModernizedCProgram.Curl_isprint((int)((byte)c)))) {
						charset[c] = 1;
						(p)++;
						state = .CURLFNM_SCHS_DEFAULT/* used 'goto fail' instead of 'return SETCHARSET_FAIL' to avoid a
						         * nonsense warning 'statement not reached' at end of the fnc when
						         * compiling on Solaris */;
					} else {
							;
					} 
					break;
			case .CURLFNM_SCHS_RIGHTBRLEFTBR:
					if (c == (byte)']') {
						return 1;
					} 
					state = .CURLFNM_SCHS_DEFAULT;
					charset[c] = 1;
					(p)++;
					break;
			}
		}
	}
	public static int loop(Object pattern, Object string, int maxstars) {
		byte p = (byte)pattern;
		byte s = (byte)string;
		byte[] charset = new byte[]{0};
		for (; ; ) {
			byte pp;
			switch (p) {
			case (byte)'[':
					pp = p + /* Copy in case of syntax error in set. */1;
					if (ModernizedCProgram.setcharset(pp, charset)) {
						int found = 0;
						if (!s) {
							return 1;
						} 
						if (charset[(int)s]) {
							found = 1;
						}  else if (charset[(( * 256) + 1)]) {
							found = (ModernizedCProgram.Curl_isalnum((int)((byte)s)));
						}  else if (charset[(( * 256) + 4)]) {
							found = (ModernizedCProgram.Curl_isalpha((int)((byte)s)));
						}  else if (charset[(( * 256) + 2)]) {
							found = (ModernizedCProgram.Curl_isdigit((int)((byte)s)));
						}  else if (charset[(( * 256) + 3)]) {
							found = (ModernizedCProgram.Curl_isxdigit((int)((byte)s)));
						}  else if (charset[(( * 256) + 5)]) {
							found = (ModernizedCProgram.Curl_isprint((int)((byte)s)));
						}  else if (charset[(( * 256) + 9)]) {
							found = (ModernizedCProgram.Curl_isspace((int)((byte)s)));
						}  else if (charset[(( * 256) + 10)]) {
							found = (ModernizedCProgram.Curl_isupper((int)((byte)s)));
						}  else if (charset[(( * 256) + 7)]) {
							found = (ModernizedCProgram.Curl_islower((int)((byte)s)));
						}  else if (charset[(( * 256) + 6)]) {
							found = (int)((((byte)s) == (byte)' ') || (((byte)s) == (byte)'\t'));
						}  else if (charset[(( * 256) + 8)]) {
							found = (ModernizedCProgram.Curl_isgraph((int)((byte)s)));
						} 
						if (charset[( * 256)]) {
							found = !found;
						} 
						if (!found) {
							return 1;
						} 
						p = pp + 1;
						s++;
						break;
					} 
					return /* Syntax error in set; mismatch! */1;
			case (byte)'*':
					if (!maxstars) {
						return 1/* Regroup consecutive stars and question marks. This can be done because
						         '*?*?*' can be expressed as '??*'. */;
					} 
					for (; ; ) {
						if (++p == (byte)'\0') {
							return 0;
						} 
						if (p == (byte)'?') {
							if (!s++) {
								return 1;
							} 
						}  else if (p != (byte)'*') {
							break;
						} 
					}
					for (maxstars--; s; /* Skip string characters until we find a match with pattern suffix. */s++) {
						if (ModernizedCProgram.loop(p, s, maxstars) == 0) {
							return 0;
						} 
					}
					return 1;
			case (byte)'\0':
					return s ? 1 : 0;
			case (byte)'?':
					if (!s) {
						return 1;
					} 
					s++;
					p++;
					break;
			case (byte)'\\':
					if (p[1]) {
						p++;
					} 
					if (s++ != p++) {
						return 1;
					} 
					break;
			default:
					if (p++ != s++) {
						return 1;
					} 
					break;
			}
		}
	}
	/*
	 * @unittest: 1307
	 */
	public static int Curl_fnmatch(Object ptr, Object pattern, Object string) {
		(Object)/* the argument is specified by the curl_fnmatch_callback
		                prototype, but not used by Curl_fnmatch() */ptr;
		if (!pattern || !string) {
			return 2;
		} 
		return ModernizedCProgram.loop((byte)pattern, (byte)string, 2/*
		 * @unittest: 1307
		 *//* the argument is specified by the curl_fnmatch_callback
		                prototype, but not used by Curl_fnmatch() *//* not reached *//* if FTP is disabled */);
	}
	/* MSVC extension, dllimport identity */
	/**
	 * curl_global_init() globally initializes curl given a bitwise set of the
	 * different features of what to initialize.
	 */
	public static  global_init(long flags,  memoryfuncs) {
		if (ModernizedCProgram.initialized++) {
			return .CURLE_OK;
		} 
		if (memoryfuncs) {
			ModernizedCProgram.Curl_cmalloc = (curl_malloc_callback)/* Setup the default memory functions here (again) */malloc;
			ModernizedCProgram.Curl_cfree = (curl_free_callback)free;
			ModernizedCProgram.Curl_crealloc = (curl_realloc_callback)realloc;
			ModernizedCProgram.Curl_cstrdup = (curl_strdup_callback)strdup;
			ModernizedCProgram.Curl_ccalloc = (curl_calloc_callback)calloc;
		} 
		if (!true) {
			do {
			} while (0);
			return .CURLE_FAILED_INIT;
		} 
		if (ModernizedCProgram.Curl_win32_init(flags)) {
			do {
			} while (0);
			return .CURLE_FAILED_INIT;
		} 
		if (ModernizedCProgram.Curl_resolver_global_init()) {
			do {
			} while (0);
			return .CURLE_FAILED_INIT;
		} 
		(Object)0;
		if (flags & (1 << 2)) {
			ModernizedCProgram.Curl_ack_eintr = 1;
		} 
		ModernizedCProgram.init_flags = flags;
		ModernizedCProgram.Curl_version_init();
		return .CURLE_OK/**
		 * curl_global_init() globally initializes curl given a bitwise set of the
		 * different features of what to initialize.
		 */;
	}
	public static  curl_global_init(long flags) {
		return ModernizedCProgram.global_init(flags, 1/*
		 * curl_global_init_mem() globally initializes curl and also registers the
		 * user provided callback routines.
		 */);
	}
	public static  curl_global_init_mem(long flags, Object m, Object f, Object r, Object s, Object c) {
		if (!m || !f || !r || !s || !/* Invalid input, return immediately */c) {
			return .CURLE_FAILED_INIT;
		} 
		if (ModernizedCProgram.initialized/* Already initialized, don't do it again, but bump the variable anyway to
		       work like curl_global_init() and require the same amount of cleanup
		       calls. */) {
			ModernizedCProgram.initialized++;
			return .CURLE_OK;
		} 
		ModernizedCProgram.Curl_cmalloc = /* set memory functions before global_init() in case it wants memory
		     functions */m;
		ModernizedCProgram.Curl_cfree = f;
		ModernizedCProgram.Curl_cstrdup = s;
		ModernizedCProgram.Curl_crealloc = r;
		ModernizedCProgram.Curl_ccalloc = c;
		return ModernizedCProgram.global_init(flags, /* Call the actual init function, but without setting */0/**
		 * curl_global_cleanup() globally cleanups curl, uses the value of
		 * "init_flags" to determine what needs to be cleaned up and what doesn't.
		 */);
	}
	public static void curl_global_cleanup() {
		if (!ModernizedCProgram.initialized) {
			return ;
		} 
		if (--ModernizedCProgram.initialized) {
			return ;
		} 
		do {
		} while (0);
		ModernizedCProgram.Curl_resolver_global_cleanup();
		ModernizedCProgram.Curl_win32_cleanup(ModernizedCProgram.init_flags);
		do {
		} while (0);
		;
		ModernizedCProgram.init_flags = 0/*
		 * curl_easy_init() is the external interface to alloc, setup and init an
		 * easy handle that is returned. If anything goes wrong, NULL is returned.
		 */;
	}
	public static Object curl_easy_init() {
		CURLcode result = new CURLcode();
		Curl_easy data = new Curl_easy();
		if (!/* Make sure we inited the global SSL stuff */ModernizedCProgram.initialized) {
			result = ModernizedCProgram.curl_global_init(((1 << 0) | (1 << 1)));
			if (result) {
				do {
				} while (/* something in the global init failed, return nothing */0);
				return ((Object)0);
			} 
		} 
		result = ModernizedCProgram.Curl_open(/* We use curl_open() with undefined URL so far */data);
		if (result) {
			do {
			} while (0);
			return ((Object)0);
		} 
		return data/* the next node in the list or NULL *//* socket info of what to monitor *//* timeout, run the timeout function when reached *//* set TRUE when timeout is set by callback *//* number of nodes in the monitor list *//* list of sockets to monitor *//* store the returned number *//* events_timer
		 *
		 * Callback that gets called with a new value when the timeout should be
		 * updated.
		 *//* multi handle *//* see above *//* private callback pointer *//* timeout removed *//* timeout is already reached! *//* trigger asap *//* poll2cselect
		 *
		 * convert from poll() bit definitions to libcurl's CURL_CSELECT_* ones
		 *//* socketcb2poll
		 *
		 * convert from libcurl' CURL_POLL_* bit definitions to poll()'s
		 *//* events_socket
		 *
		 * Callback that gets called with information about socket activity to
		 * monitor.
		 *//* easy handle *//* socket *//* see above *//* private callback
		                                             pointer *//* private socket
		                                             pointer *//* remove this node from the list of monitored sockets *//* The socket 's' is already being monitored, update the activity
		           mask. Convert from libcurl bitmask to the poll one. *//* move to next node *//* this happens a bit too often, libcurl fix perhaps? *//* fprintf(stderr,
		         "%s: socket %d asked to be REMOVED but not present!\n",
		                 __func__, s); */;
	}
	/*
	 * events_setup()
	 *
	 * Do the multi handle setups that only event-based transfers need.
	 */
	/* timer callback */
	/* socket callback */
	/* wait_or_timeout()
	 *
	 * waits for activity on any of the given sockets, or the timeout to trigger.
	 */
	/* populate the fds[] array */
	/* fprintf(stderr, "poll() %d check socket %d\n", numfds, f->fd); */
	/* get the time stamp to use to figure out how long poll takes */
	/* wait for activity or timeout */
	/* reset here */
	/* timeout! */
	/* fprintf(stderr, "call curl_multi_socket_action(TIMEOUT)\n"); */
	/* loop over the monitored sockets to see which ones had activity */
	/* socket activity, tell libcurl */
	/* convert */
	/* If nothing updated the timeout, we decrease it by the spent time.
	         * If it was updated, it has the new timeout time stored already.
	         */
	/* we don't really care about the "msgs_in_queue" value returned in the
	       second argument */
	/* easy_events()
	 *
	 * Runs a transfer in a blocking manner using the events-based API
	 */
	/* this struct is made static to allow it to be used after this function
	     returns and curl_multi_remove_handle() is called */
	/* if running event-based, do some further multi inits */
	/* CURLDEBUG */
	/* when not built with debug, this function doesn't exist */
	public static  easy_transfer(Object multi) {
		bool done = 0;
		CURLMcode mcode = .CURLM_OK;
		CURLcode result = .CURLE_OK;
		while (!done && !mcode) {
			int still_running = 0;
			mcode = ModernizedCProgram.curl_multi_poll(multi, ((Object)0), 0, 1000, ((Object)0));
			if (!mcode) {
				mcode = ModernizedCProgram.curl_multi_perform(multi, still_running);
			} 
			if (!mcode && !/* only read 'still_running' if curl_multi_perform() return OK */still_running) {
				int rc;
				CURLMsg msg = ModernizedCProgram.curl_multi_info_read(multi, rc);
				if (msg) {
					result = msg.getData().getResult();
					done = 1;
				} 
			} 
		}
		if (/* Make sure to return some kind of error if there was a multi problem */mcode) {
			result = (mcode == .CURLM_OUT_OF_MEMORY) ? .CURLE_OUT_OF_MEMORY/* The other multi errors should never happen, so return
			                 something suitably generic */ : .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		return result/*
		 * easy_perform() is the external interface that performs a blocking
		 * transfer as previously setup.
		 *
		 * CONCEPT: This function creates a multi handle, adds the easy handle to it,
		 * runs curl_multi_perform() until the transfer is done, then detaches the
		 * easy handle, destroys the multi handle and returns the easy handle's return
		 * code.
		 *
		 * REALITY: it can't just create and destroy the multi handle that easily. It
		 * needs to keep it around since if this easy handle is used again by this
		 * function, the same multi handle must be re-used so that the same pools and
		 * caches can be used.
		 *
		 * DEBUG: if 'events' is set TRUE, this function will use a replacement engine
		 * instead of curl_multi_perform() and use curl_multi_socket_action().
		 */;
	}
	public static  easy_perform(Object data,  events) {
		Curl_multi multi = new Curl_multi();
		CURLMcode mcode = new CURLMcode();
		CURLcode result = .CURLE_OK;
		;
		if (!data) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		if (data.getSet().getErrorbuffer()) {
			data.getSet().getErrorbuffer()[0] = /* clear this as early as possible */0;
		} 
		if (data.getMulti()) {
			ModernizedCProgram.Curl_failf(data, "easy handle already used in multi handle");
			return .CURLE_FAILED_INIT;
		} 
		if (data.getMulti_easy()) {
			multi = data.getMulti_easy();
		} else {
				multi = ModernizedCProgram.Curl_multi_handle(1, /* this multi handle will only ever have a single easy handled attached
				       to it, so make it use minimal hashes */3);
				if (!multi) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				data.setMulti_easy(multi);
		} 
		if (multi.getIn_callback()) {
			return .CURLE_RECURSIVE_API_CALL;
		} 
		ModernizedCProgram.curl_multi_setopt(multi, .CURLMOPT_MAXCONNECTS, data.getSet().getMaxconnects());
		mcode = ModernizedCProgram.curl_multi_add_handle(multi, data);
		if (mcode) {
			ModernizedCProgram.curl_multi_cleanup(multi);
			if (mcode == .CURLM_OUT_OF_MEMORY) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			return .CURLE_FAILED_INIT;
		} 
		do {
		} while (0);
		data.setMulti(/* assign this after curl_multi_add_handle() since that function checks for
		     it and rejects this handle otherwise */multi);
		result = events ? .CURLE_NOT_BUILT_IN : ModernizedCProgram.easy_transfer(/* run the transfer */multi);
		(Object)ModernizedCProgram.curl_multi_remove_handle(multi, /* ignoring the return code isn't nice, but atm we can't really handle
		     a failure here, room for future improvement! */data);
		do {
		} while (0);
		return /* The multi handle is kept alive, owned by the easy handle */result/*
		 * curl_easy_perform() is the external interface that performs a blocking
		 * transfer as previously setup.
		 */;
	}
	public static  curl_easy_perform(Object data) {
		return ModernizedCProgram.easy_perform(data, 0/*
		 * curl_easy_perform_ev() is the external interface that performs a blocking
		 * transfer using the event-based API internally.
		 */);
	}
	/*
	 * curl_easy_cleanup() is the external interface to cleaning/freeing the given
	 * easy handle.
	 */
	public static void curl_easy_cleanup(Object data) {
		;
		if (!data) {
			return ;
		} 
		do {
		} while (0);
		ModernizedCProgram.Curl_close(data);
		do {
		} while (0/*
		 * curl_easy_getinfo() is an external interface that allows an app to retrieve
		 * information from a performed transfer and similar.
		 */);
	}
	public static  curl_easy_getinfo(Object data,  info) {
		va_list arg = new va_list();
		Object paramp;
		CURLcode result = new CURLcode();
		.__builtin_va_start(arg, info);
		paramp = (int)arg;
		result = ModernizedCProgram.Curl_getinfo(data, info, paramp);
		.__builtin_va_end(arg);
		return result;
	}
	public static  dupset(Object dst, Object src) {
		CURLcode result = .CURLE_OK;
		dupstring i;
		dst.setSet(src.getSet());
		ModernizedCProgram.Curl_mime_initpart(dst.getSet().getMimepost(), dst);
		.memset(dst.getSet().getStr(), 0, dupstring.STRING_LAST * /* clear all string pointers first */);
		for (dupstring.i = (dupstring)0; dupstring.i < dupstring.STRING_LASTZEROTERMINATED; /* duplicate all strings */dupstring.i++) {
			result = ModernizedCProgram.Curl_setstropt(dst.getSet().getStr()[dupstring.i], src.getSet().getStr()[dupstring.i]);
			if (result) {
				return result;
			} 
		}
		dupstring.i = /* duplicate memory areas pointed to */dupstring.STRING_COPYPOSTFIELDS;
		if (src.getSet().getPostfieldsize() && src.getSet().getStr()[dupstring.i]) {
			dst.getSet().getStr()[dupstring.i] = ModernizedCProgram.Curl_memdup(src.getSet().getStr()[/* postfieldsize is curl_off_t, Curl_memdup() takes a size_t ... */dupstring.i], ModernizedCProgram.curlx_sotouz(src.getSet().getPostfieldsize()));
			if (!dst.getSet().getStr()[dupstring.i]) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			dst.getSet().setPostfields(dst.getSet().getStr()[/* point to the new copy */dupstring.i]);
		} 
		result = ModernizedCProgram.Curl_mime_duppart(dst.getSet().getMimepost(), src.getSet().getMimepost());
		if (src.getSet().getResolve()) {
			dst.getChange().setResolve(dst.getSet().getResolve());
		} 
		return result/*
		 * curl_easy_duphandle() is an external interface to allow duplication of a
		 * given input easy handle. The returned handle will be a new working handle
		 * with all options set exactly as the input source handle.
		 */;
	}
	public static Object curl_easy_duphandle(Object data) {
		Curl_easy outcurl = .Curl_ccalloc(1, );
		if (((Object)0) == outcurl) {
			;
		} 
		outcurl.getSet().setBuffer_size(data.getSet().getBuffer_size());
		outcurl.getState().setBuffer(.Curl_cmalloc(outcurl.getSet().getBuffer_size() + 1));
		if (!outcurl.getState().getBuffer()) {
			;
		} 
		outcurl.getState().setHeaderbuff(.Curl_cmalloc(256));
		if (!outcurl.getState().getHeaderbuff()) {
			;
		} 
		outcurl.getState().setHeadersize(256);
		if (ModernizedCProgram.dupset(outcurl, /* copy all userdefined values */data)) {
			;
		} 
		outcurl.getState().setConn_cache(((Object)/* the connection cache is setup on demand */0));
		outcurl.getState().setLastconnect(((Object)0));
		outcurl.getProgress().setFlags(data.getProgress().getFlags());
		outcurl.getProgress().setCallback(data.getProgress().getCallback());
		if (data.getCookies()) {
			outcurl.setCookies(ModernizedCProgram.Curl_cookie_init(data, data.getCookies().getFilename(), outcurl.getCookies(), data.getSet().getCookiesession()));
			if (!outcurl.getCookies()) {
				;
			} 
		} 
		if (data.getChange().getCookielist()) {
			outcurl.getChange().setCookielist(ModernizedCProgram.Curl_slist_duplicate(data.getChange().getCookielist()));
			if (!outcurl.getChange().getCookielist()) {
				;
			} 
		} 
		if (data.getChange().getUrl()) {
			outcurl.getChange().setUrl(.Curl_cstrdup(data.getChange().getUrl()));
			if (!outcurl.getChange().getUrl()) {
				;
			} 
			outcurl.getChange().setUrl_alloc(1);
		} 
		if (data.getChange().getReferer()) {
			outcurl.getChange().setReferer(.Curl_cstrdup(data.getChange().getReferer()));
			if (!outcurl.getChange().getReferer()) {
				;
			} 
			outcurl.getChange().setReferer_alloc(1);
		} 
		if (outcurl.getSet().getStr()[/* Reinitialize an SSL engine for the new handle
		   * note: the engine name has already been copied by dupset */dupstring.STRING_SSL_ENGINE]) {
			if (.CURLE_NOT_BUILT_IN) {
				;
			} 
		} 
		if (ModernizedCProgram.Curl_resolver_duphandle(/* Clone the resolver handle, if present, for the new handle */outcurl, outcurl.getState().getResolver(), data.getState().getResolver())) {
			;
		} 
		do {
		} while (0);
		ModernizedCProgram.Curl_initinfo(outcurl);
		outcurl.setMagic(-1024);
		return /* we reach this point and thus we are OK */outcurl;
		return ((Object)0/*
		 * curl_easy_reset() is an external interface that allows an app to re-
		 * initialize a session handle to the default values.
		 */);
	}
	public static void curl_easy_reset(Object data) {
		long old_buffer_size = data.getSet().getBuffer_size();
		ModernizedCProgram.Curl_free_request_state(data);
		ModernizedCProgram.Curl_freeset(/* zero out UserDefined data: */data);
		.memset(data.getSet(), 0, );
		(Object)ModernizedCProgram.Curl_init_userdefined(data);
		.memset(data.getProgress(), 0, /* zero out Progress data: */);
		ModernizedCProgram.Curl_initinfo(/* zero out PureInfo data: */data);
		data.getProgress().getFlags() |=  (1 << 4);
		data.getState().setCurrent_speed(-/* init to negative == impossible */1);
		.memset(data.getState().getAuthhost(), 0, /* zero out authentication data: */);
		.memset(data.getState().getAuthproxy(), 0, );
		ModernizedCProgram.Curl_http_auth_cleanup_digest(data);
		if (old_buffer_size != data.getSet().getBuffer_size()) {
			byte newbuff = .Curl_crealloc(data.getState().getBuffer(), data.getSet().getBuffer_size() + 1);
			if (!newbuff) {
				do {
				} while (0);
				data.getSet().setBuffer_size(/* nothing we can do here except use the old size */old_buffer_size);
			} else {
					data.getState().setBuffer(newbuff/*
					 * curl_easy_pause() allows an application to pause or unpause a specific
					 * transfer and direction. This function sets the full new state for the
					 * current connection this easy handle operates on.
					 *
					 * NOTE: if you have the receiving paused and you call this function to remove
					 * the pausing, you may get your write callback called at this point.
					 *
					 * Action is a bitmask consisting of CURLPAUSE_* bits in curl/curl.h
					 *
					 * NOTE: This is one of few API functions that are allowed to be called from
					 * within a callback.
					 */);
			} 
		} 
	}
	public static  curl_easy_pause(Object data, int action) {
		SingleRequest k = data.getReq();
		CURLcode result = .CURLE_OK;
		int newstate = k.getKeepon() & ~((1 << 4) | (1 << /* first switch off both pause bits */5));
		newstate |=  ((action & (1 << 0)) ? (1 << 4) : /* set the new desired pause bits */0) | ((action & (1 << 2)) ? (1 << 5) : 0);
		k.setKeepon(/* put it back in the keepon */newstate);
		if (!(newstate & (1 << 4)) && data.getState().getTempcount()) {
			int i;
			int count = data.getState().getTempcount();
			tempbuf[] writebuf = new tempbuf();
			connectdata conn = data.getConn();
			Curl_easy saved_data = ((Object)0);
			for (i = 0; i < data.getState().getTempcount(); /* copy the structs to allow for immediate re-pausing */i++) {
				writebuf[i] = data.getState().getTempwrite()[i];
				data.getState().getTempwrite()[i].setBuf(((Object)0));
			}
			data.getState().setTempcount(0);
			if (conn.getData() != /* set the connection's current owner */data) {
				saved_data = conn.getData();
				conn.setData(data);
			} 
			for (i = 0; i < count; i/* even if one function returns error, this loops through and frees all
			         buffers */++) {
				if (!result) {
					result = ModernizedCProgram.Curl_client_write(conn, writebuf[i].getType(), writebuf[i].getBuf(), writebuf[i].getLen());
				} 
				.Curl_cfree(writebuf[i].getBuf());
			}
			if (/* recover previous owner of the connection */saved_data) {
				conn.setData(saved_data);
			} 
			if (result) {
				return result;
			} 
		} 
		if ((newstate & ((1 << 4) | (1 << /* if there's no error and we're not pausing both directions, we want
		     to have this handle checked soon */5))) != ((1 << 4) | (1 << 5))) {
			ModernizedCProgram.Curl_expire(data, 0, /* get this handle going again */.EXPIRE_RUN_NOW);
			if (data.getMulti()) {
				ModernizedCProgram.Curl_update_timer(data.getMulti());
			} 
		} 
		ModernizedCProgram.Curl_updatesocket(/* This transfer may have been moved in or out of the bundle, update
		     the corresponding socket callback, if used */data);
		return result;
	}
	public static  easy_connection(Object data, Object sfd, Object connp) {
		if (data == ((Object)0)) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		if (!data.getSet().getConnect_only()) {
			ModernizedCProgram.Curl_failf(data, "CONNECT_ONLY is required!");
			return .CURLE_UNSUPPORTED_PROTOCOL;
		} 
		sfd = ModernizedCProgram.Curl_getconnectinfo(data, connp);
		if (sfd == (SOCKET)(~0)) {
			ModernizedCProgram.Curl_failf(data, "Failed to get recent socket");
			return .CURLE_UNSUPPORTED_PROTOCOL;
		} 
		return .CURLE_OK/*
		 * Receives data from the connected socket. Use after successful
		 * curl_easy_perform() with CURLOPT_CONNECT_ONLY option.
		 * Returns CURLE_OK on success, error code on error.
		 */;
	}
	public static  curl_easy_recv(Object data, Object buffer, Object buflen, Object n) {
		curl_socket_t sfd = new curl_socket_t();
		CURLcode result = new CURLcode();
		ssize_t n1 = new ssize_t();
		connectdata c = new connectdata();
		if (ModernizedCProgram.Curl_is_in_callback(data)) {
			return .CURLE_RECURSIVE_API_CALL;
		} 
		result = ModernizedCProgram.easy_connection(data, sfd, c);
		if (result) {
			return result;
		} 
		n = 0;
		result = ModernizedCProgram.Curl_read(c, sfd, buffer, buflen, n1);
		if (result) {
			return result;
		} 
		n = (size_t)n1;
		return .CURLE_OK/*
		 * Sends data over the connected socket. Use after successful
		 * curl_easy_perform() with CURLOPT_CONNECT_ONLY option.
		 */;
	}
	public static  curl_easy_send(Object data, Object buffer, Object buflen, Object n) {
		curl_socket_t sfd = new curl_socket_t();
		CURLcode result = new CURLcode();
		ssize_t n1 = new ssize_t();
		connectdata c = ((Object)0);
		if (ModernizedCProgram.Curl_is_in_callback(data)) {
			return .CURLE_RECURSIVE_API_CALL;
		} 
		result = ModernizedCProgram.easy_connection(data, sfd, c);
		if (result) {
			return result;
		} 
		n = 0;
		result = ModernizedCProgram.Curl_write(c, sfd, buffer, buflen, n1);
		if (n1 == -1) {
			return .CURLE_SEND_ERROR;
		} 
		if (!result && !/* detect EAGAIN */n1) {
			return .CURLE_AGAIN;
		} 
		n = (size_t)n1;
		return result/*
		 * Wrapper to call functions in Curl_conncache_foreach()
		 *
		 * Returns always 0.
		 */;
	}
	public static int conn_upkeep(Object conn, Object param) {
		(Object)/* Param is unused. */param;
		if (conn.getHandler().getConnection_check()) {
			.UNRECOGNIZEDFUNCTIONNAME(conn, (1 << /* Do a protocol-specific keepalive check on the connection. */1));
		} 
		return /* continue iteration */0;
	}
	public static  upkeep(Object conn_cache, Object data) {
		ModernizedCProgram.Curl_conncache_foreach(/* Loop over every connection and make connection alive. */data, conn_cache, data, conn_upkeep);
		return .CURLE_OK/*
		 * Performs connection upkeep for the given session handle.
		 */;
	}
	public static  curl_easy_upkeep(Object data) {
		if (!((data) && ((data).getMagic() == /* Verify that we got an easy handle we can work with. */-1024))) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		if (data.getMulti_easy()) {
			return ModernizedCProgram.upkeep(data.getMulti_easy().getConn_cache(), /* Use the common function to keep connections alive. */data);
		} else {
				return /* No connections, so just return success */.CURLE_OK;
		} 
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* header from libc, not from libattr */
	/* keep this as LAST include */
	/* mapping table of curl metadata to extended attribute names */
	/* name of the xattr */
	/* mappings proposed by
	   * https://freedesktop.org/wiki/CommonExtendedAttributes/
	   */
	/* last element, abort loop here */
	/* returns TRUE if a new URL is returned, that then needs to be freed */
	/* @unittest: 1621 */
	/* store metadata from the curl request alongside the downloaded
	 * file using extended attributes
	 */
	/* loop through all xattr-curlinfo pairs and abort on a set error */
	/* FreeBSD's extattr_set_fd returns the length of the extended
	             attribute */
	public static int fwrite_xattr(Object curl, int fd) {
		(Object)curl;
		(Object)fd;
		return 0;
	}
	/*
	 * vmsfopenread
	 *
	 * For upload to work as expected on VMS, different optional
	 * parameters must be added to the fopen command based on
	 * record format of the file.
	 *
	 */
	/* VMS */
	/*
	  (Quote from The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004
	  Edition)
	
	  The basename() function shall take the pathname pointed to by path and
	  return a pointer to the final component of the pathname, deleting any
	  trailing '/' characters.
	
	  If the string pointed to by path consists entirely of the '/' character,
	  basename() shall return a pointer to the string "/". If the string pointed
	  to by path is exactly "//", it is implementation-defined whether '/' or "//"
	  is returned.
	
	  If path is a null pointer or points to an empty string, basename() shall
	  return a pointer to the string ".".
	
	  The basename() function may modify the string pointed to by path, and may
	  return a pointer to static storage that may then be overwritten by a
	  subsequent call to basename().
	
	  The basename() function need not be reentrant. A function that is not
	  required to be reentrant is not required to be thread-safe.
	
	*/
	/*
	  (Quote from The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004
	  Edition)
	
	  The basename() function shall take the pathname pointed to by path and
	  return a pointer to the final component of the pathname, deleting any
	  trailing '/' characters.
	
	  If the string pointed to by path consists entirely of the '/' character,
	  basename() shall return a pointer to the string "/". If the string pointed
	  to by path is exactly "//", it is implementation-defined whether '/' or "//"
	  is returned.
	
	  If path is a null pointer or points to an empty string, basename() shall
	  return a pointer to the string ".".
	
	  The basename() function may modify the string pointed to by path, and may
	  return a pointer to static storage that may then be overwritten by a
	  subsequent call to basename().
	
	  The basename() function need not be reentrant. A function that is not
	  required to be reentrant is not required to be thread-safe.
	
	*/
	public static Object Curl_basename(Object path) {
		/* Ignore all the details above for now and make a quick and simple
		     implementation here */byte s1;
		byte s2;
		s1 = .strrchr(path, (byte)'/');
		s2 = .strrchr(path, (byte)'\\');
		if (s1 && s2) {
			path = (s1 > s2 ? s1 : s2) + 1;
		}  else if (s1) {
			path = s1 + 1;
		}  else if (s2) {
			path = s2 + 1;
		} 
		return path;
	}
	/* Set readback state. */
	public static void mimesetstate(Object state, mimestate tok, Object ptr) {
		state.setState(mimestate.tok);
		state.setPtr(ptr);
		state.setOffset(0);
	}
	/* Escape header string into allocated memory. */
	public static Object escape_string(Object src) {
		size_t bytecount = 0;
		size_t i = new size_t();
		byte dst;
		for (i = 0; src[i]; i++) {
			if (src[i] == (byte)'"' || src[i] == (byte)'\\') {
				bytecount++;
			} 
		}
		bytecount += i;
		dst = .Curl_cmalloc(bytecount + 1);
		if (!dst) {
			return ((Object)0);
		} 
		for (i = 0; src; src++) {
			if (src == (byte)'"' || src == (byte)'\\') {
				dst[i++] = (byte)'\\';
			} 
			dst[i++] = src;
		}
		dst[i] = (byte)'\0';
		return dst;
	}
	/* Check if header matches. */
	public static Object match_header(Object hdr, Object lbl, Object len) {
		byte value = ((Object)0);
		if (ModernizedCProgram.Curl_strncasecompare(hdr.getData(), lbl, len) && hdr.getData()[len] == (byte)':') {
			for (value = hdr.getData() + len + 1; value == (byte)' '; value++) {
				;
			}
		} 
		return value;
	}
	/* Get a header from an slist. */
	public static Object search_header(Object hdrlist, Object hdr) {
		size_t len = .strlen(hdr);
		byte value = ((Object)0);
		for (; !value && hdrlist; hdrlist = hdrlist.getNext()) {
			value = ModernizedCProgram.match_header(hdrlist, hdr, len);
		}
		return value;
	}
	public static Object strippath(Object fullfile) {
		byte filename;
		byte base;
		filename = .Curl_cstrdup(/* duplicate since basename() may ruin the
		                                  buffer it works on */fullfile);
		if (!filename) {
			return ((Object)0);
		} 
		base = .Curl_cstrdup(ModernizedCProgram.Curl_basename((filename)));
		.Curl_cfree(/* free temporary buffer */filename);
		return /* returns an allocated string or NULL ! */base;
	}
	/* Initialize data encoder state. */
	public static void cleanup_encoder_state(Object p) {
		p.setPos(0);
		p.setBufbeg(0);
		p.setBufend(0);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* Encoders. */
	/* Dummy encoder. This is used for 8bit and binary content encodings. */
	public static Object encoder_nop_read(Object buffer, Object size,  ateof, Object part) {
		mime_encoder_state st = part.getEncstate();
		size_t insize = st.getBufend() - st.getBufbeg();
		(Object)ateof;
		if (size > insize) {
			size = insize;
		} 
		if (size) {
			.memcpy(buffer, st.getBuf(), size);
		} 
		st.getBufbeg() += size;
		return size;
	}
	public static Object encoder_nop_size(Object part) {
		return part.getDatasize();
	}
	/* 7bit encoder: the encoder is just a data validity check. */
	public static Object encoder_7bit_read(Object buffer, Object size,  ateof, Object part) {
		mime_encoder_state st = part.getEncstate();
		size_t cursize = st.getBufend() - st.getBufbeg();
		(Object)ateof;
		if (size > cursize) {
			size = cursize;
		} 
		for (cursize = 0; cursize < size; cursize++) {
			buffer = st.getBuf()[st.getBufbeg()];
			if (buffer++ & -1024) {
				return cursize ? cursize : ((size_t)-1);
			} 
			st.getBufbeg()++;
		}
		return cursize;
	}
	/* Base64 content encoder. */
	public static Object encoder_base64_read(Object buffer, Object size,  ateof, Object part) {
		mime_encoder_state st = part.getEncstate();
		size_t cursize = 0;
		int i;
		byte ptr = buffer;
		while (st.getBufbeg() < st.getBufend()) {
			if (st.getPos() > 76 - /* Line full ? */4) {
				if (size < /* Yes, we need 2 characters for CRLF. */2) {
					break;
				} 
				ptr++ = (byte)'\r';
				ptr++ = (byte)'\n';
				st.setPos(0);
				cursize += 2;
				size -= 2;
			} 
			if (size < 4 || st.getBufend() - st.getBufbeg() < /* Be sure there is enough space and input data for a base64 group. */3) {
				break;
			} 
			i = st.getBuf()[st.getBufbeg()++] & /* Encode three bytes as four characters. */-1024;
			i = (i << 8) | (st.getBuf()[st.getBufbeg()++] & -1024);
			i = (i << 8) | (st.getBuf()[st.getBufbeg()++] & -1024);
			ptr++ = ModernizedCProgram.base64[(i >> 18) & -1024];
			ptr++ = ModernizedCProgram.base64[(i >> 12) & -1024];
			ptr++ = ModernizedCProgram.base64[(i >> 6) & -1024];
			ptr++ = ModernizedCProgram.base64[i & -1024];
			cursize += 4;
			st.getPos() += 4;
			size -= 4;
		}
		if (ateof && size >= /* If at eof, we have to flush the buffered data. */4) {
			ptr[2] = ptr[3] = /* Buffered data size can only be 0, 1 or 2. */(byte)'=';
			i = 0;
			switch (st.getBufend() - st.getBufbeg()) {
			case 2:
					i = (st.getBuf()[st.getBufbeg() + 1] & -1024) << 8;
			case /* FALLTHROUGH */1:
					i |=  (st.getBuf()[st.getBufbeg()] & -1024) << 16;
					ptr[0] = ModernizedCProgram.base64[(i >> 18) & -1024];
					ptr[1] = ModernizedCProgram.base64[(i >> 12) & -1024];
					if (++st.getBufbeg() != st.getBufend()) {
						ptr[2] = ModernizedCProgram.base64[(i >> 6) & -1024];
						st.getBufbeg()++;
					} 
					cursize += 4;
					st.getPos() += 4;
					break;
			}
		} 
		return cursize;
	}
	public static Object encoder_base64_size(Object part) {
		curl_off_t size = part.getDatasize();
		if (size <= 0) {
			return /* Unknown size or no data. */size;
		} 
		size = 4 * (1 + (size - 1) / /* Compute base64 character count. */3);
		return size + 2 * ((size - 1) / /* Effective character count must include CRLFs. */76/* Quoted-printable lookahead.
		 *
		 * Check if a CRLF or end of data is in input buffer at current position + n.
		 * Return -1 if more data needed, 1 if CRLF or end of data, else 0.
		 */);
	}
	public static int qp_lookahead_eol(Object st, int ateof, Object n) {
		n += st.getBufbeg();
		if (n >= st.getBufend() && ateof) {
			return 1;
		} 
		if (n + 2 > st.getBufend()) {
			return ateof ? 0 : -1;
		} 
		if (ModernizedCProgram.qp_class[st.getBuf()[n] & -1024] == 3 && ModernizedCProgram.qp_class[st.getBuf()[n + 1] & -1024] == 4) {
			return 1;
		} 
		return 0;
	}
	/* Quoted-printable encoder. */
	public static Object encoder_qp_read(Object buffer, Object size,  ateof, Object part) {
		mime_encoder_state st = part.getEncstate();
		byte ptr = buffer;
		size_t cursize = 0;
		int softlinebreak;
		byte[] buf = new byte[4/* On all platforms, input is supposed to be ASCII compatible: for this
		     reason, we use hexadecimal ASCII codes in this function rather than
		     character constants that can be interpreted as non-ascii on some
		     platforms. Preserve ASCII encoding on output too. */];
		while (st.getBufbeg() < st.getBufend()) {
			size_t len = 1;
			size_t consumed = 1;
			int i = st.getBuf()[st.getBufbeg()];
			buf[0] = (byte)i;
			buf[1] = ModernizedCProgram.aschex[(i >> 4) & -1024];
			buf[2] = ModernizedCProgram.aschex[i & -1024];
			switch (ModernizedCProgram.qp_class[st.getBuf()[st.getBufbeg()] & -1024]) {
			case /* Space or tab. */2:
					switch (ModernizedCProgram.qp_lookahead_eol(st, ateof, /* Spacing must be escaped if followed by CRLF. */1)) {
					case /* No encoding needed. */0:
							break;
					case -/* More input data needed. */1:
							return cursize;
					default:
							buf[0] = /* '=' */(byte)'\x3D';
							len = 3;
							break;
					}
					break;
			case /* Not a special character. */1:
					break;
			case /* Carriage return. */3/* If followed by a line-feed, output the CRLF pair.
			         Else escape it. */:
					switch (ModernizedCProgram.qp_lookahead_eol(st, ateof, 0)) {
					case -/* Need more data. */1:
							return cursize;
					case /* CRLF found. */1:
							buf[len++] = /* Append '\n'. */(byte)'\x0A';
							consumed = 2;
							break;
					default:
							buf[0] = /* '=' */(byte)'\x3D';
							len = 3;
							break;
					}
					break;
			default:
					buf[0] = /* '=' */(byte)'\x3D';
					len = 3;
					break;
			}
			if (buf[len - 1] != /* Be sure the encoded character fits within maximum line length. *//* '\n' */(byte)'\x0A') {
				softlinebreak = st.getPos() + len > 76;
				if (!softlinebreak && st.getPos() + len == 76/* We may use the current line only if end of data or followed by
				           a CRLF. */) {
					switch (ModernizedCProgram.qp_lookahead_eol(st, ateof, consumed)) {
					case -/* Need more data. */1:
							return cursize;
							break;
					case /* Not followed by a CRLF. */0:
							softlinebreak = 1;
							break;
					}
				} 
				if (softlinebreak) {
					.strcpy(buf, /* "=\r\n" */"\x3D\x0D\x0A");
					len = 3;
					consumed = 0;
				} 
			} 
			if (len > /* If the output buffer would overflow, do not store. */size) {
				break;
			} 
			.memcpy(ptr, buf, /* Append to output buffer. */len);
			cursize += len;
			ptr += len;
			size -= len;
			st.getPos() += len;
			if (buf[len - 1] == /* '\n' */(byte)'\x0A') {
				st.setPos(0);
			} 
			st.getBufbeg() += consumed;
		}
		return cursize;
	}
	public static Object encoder_qp_size(Object part) {
		return part.getDatasize() ? -1 : /* Determining the size can only be done by reading the data: unless the
		     data size is 0, we return it as unknown (-1). */0;
	}
	/* In-memory data callbacks. */
	/* Argument is a pointer to the mime part. */
	public static Object mime_mem_read(Object buffer, Object size, Object nitems, Object instream) {
		curl_mimepart part = (curl_mimepart)instream;
		size_t sz = (size_t)part.getDatasize() - part.getState().getOffset();
		(Object)/* Always 1.*/size;
		if (sz > nitems) {
			sz = nitems;
		} 
		if (sz) {
			.memcpy(buffer, (byte)part.getData()[part.getState().getOffset()], sz);
		} 
		part.getState().getOffset() += sz;
		return sz;
	}
	public static int mime_mem_seek(Object instream, Object offset, int whence) {
		curl_mimepart part = (curl_mimepart)instream;
		switch (whence) {
		case 2:
				offset += part.getDatasize();
				break;
		case 1:
				offset += part.getState().getOffset();
				break;
		}
		if (offset < 0 || offset > part.getDatasize()) {
			return 1;
		} 
		part.getState().setOffset((size_t)offset);
		return 0;
	}
	public static void mime_mem_free(Object ptr) {
		do {
			.Curl_cfree((((curl_mimepart)ptr).getData()));
			(((curl_mimepart)ptr).getData()) = ((Object)0);
		} while (0);
	}
	/* Named file callbacks. */
	/* Argument is a pointer to the mime part. */
	public static int mime_open_file(Object part) {
		if (part.getFp()) {
			return 0;
		} 
		part.setFp(.fopen(part.getData(), "rb"));
		return part.getFp() ? 0 : -1;
	}
	public static Object mime_file_read(Object buffer, Object size, Object nitems, Object instream) {
		curl_mimepart part = (curl_mimepart)instream;
		if (ModernizedCProgram.mime_open_file(part)) {
			return ((size_t)-1);
		} 
		return .fread(buffer, size, nitems, part.getFp());
	}
	public static int mime_file_seek(Object instream, Object offset, int whence) {
		curl_mimepart part = (curl_mimepart)instream;
		if (whence == 0 && !offset && !part.getFp()) {
			return /* Not open: implicitly already at BOF. */0;
		} 
		if (ModernizedCProgram.mime_open_file(part)) {
			return 1;
		} 
		return .fseek(part.getFp(), (long)offset, whence) ? 2 : 0;
	}
	public static void mime_file_free(Object ptr) {
		curl_mimepart part = (curl_mimepart)ptr;
		if (part.getFp()) {
			.fclose(part.getFp());
			part.setFp(((Object)0));
		} 
		do {
			.Curl_cfree((part.getData()));
			(part.getData()) = ((Object)0);
		} while (0);
		part.setData(((Object)0/* Subparts callbacks. */));
	}
	/* Argument is a pointer to the mime structure. */
	/* Readback a byte string segment. */
	public static Object readback_bytes(Object state, Object buffer, Object bufsize, Object bytes, Object numbytes, Object trail) {
		size_t sz = new size_t();
		if (numbytes > state.getOffset()) {
			sz = numbytes - state.getOffset();
			bytes += state.getOffset();
		} else {
				size_t tsz = .strlen(trail);
				sz = state.getOffset() - numbytes;
				if (sz >= tsz) {
					return 0;
				} 
				bytes = trail + sz;
				sz = tsz - sz;
		} 
		if (sz > bufsize) {
			sz = bufsize;
		} 
		.memcpy(buffer, bytes, sz);
		state.getOffset() += sz;
		return sz;
	}
	/* Read a non-encoded part content. */
	public static Object read_part_content(Object part, Object buffer, Object bufsize) {
		size_t sz = 0;
		if (part.getReadfunc()) {
			sz = .UNRECOGNIZEDFUNCTIONNAME(buffer, 1, bufsize, part.getArg());
		} 
		return sz;
	}
	/* Read and encode part content. */
	public static Object read_encoded_part_content(Object part, Object buffer, Object bufsize) {
		mime_encoder_state st = part.getEncstate();
		size_t cursize = 0;
		size_t sz = new size_t();
		bool ateof = 0;
		while (bufsize) {
			if (st.getBufbeg() < st.getBufend() || ateof) {
				sz = .UNRECOGNIZEDFUNCTIONNAME(buffer, bufsize, ateof, /* Encode buffered data. */part);
				switch (sz) {
				case ((size_t)-1):
						return cursize ? cursize : sz;
				case -1024:
				case -1024:
				case 0:
						if (ateof) {
							return cursize;
						} 
						break;
				default:
						cursize += sz;
						buffer += sz;
						bufsize -= sz;
						continue;
				}
			} 
			if (st.getBufbeg()) {
				size_t len = st.getBufend() - st.getBufbeg();
				if (len) {
					.memmove(st.getBuf(), st.getBuf() + st.getBufbeg(), len);
				} 
				st.setBufbeg(0);
				st.setBufend(len);
			} 
			if (st.getBufend() >= ) {
				return cursize ? cursize : ((size_t)-/* Buffer full. */1);
			} 
			sz = ModernizedCProgram.read_part_content(part, st.getBuf() + st.getBufend(),  - st.getBufend());
			switch (sz) {
			case 0:
					ateof = 1;
					break;
			case -1024:
			case -1024:
			case ((size_t)-1):
					return cursize ? cursize : sz;
			default:
					st.getBufend() += sz;
					break;
			}
		}
		return cursize;
	}
	/* Readback a mime part. */
	public static Object readback_part(Object part, Object buffer, Object bufsize) {
		size_t cursize = 0;
		while (/* Readback from part. */bufsize) {
			size_t sz = 0;
			curl_slist hdr = (curl_slist)part.getState().getPtr();
			switch (part.getState().getState()) {
			case mimestate.MIMESTATE_EOH:
					sz = ModernizedCProgram.readback_bytes(part.getState(), buffer, bufsize, "\r\n", 2, "");
					if (!sz) {
						ModernizedCProgram.mimesetstate(part.getState(), mimestate.MIMESTATE_BODY, ((Object)0));
					} 
					break;
			case mimestate.MIMESTATE_BEGIN:
					ModernizedCProgram.mimesetstate(part.getState(), (part.getFlags() & (1 << 1)) ? mimestate.MIMESTATE_BODY : mimestate.MIMESTATE_CURLHEADERS, part.getCurlheaders());
					break;
			case mimestate.MIMESTATE_USERHEADERS:
					if (!hdr) {
						ModernizedCProgram.mimesetstate(part.getState(), mimestate.MIMESTATE_EOH, ((Object)0));
						break;
					} 
					if (ModernizedCProgram.match_header(hdr, "Content-Type", 12)) {
						ModernizedCProgram.mimesetstate(part.getState(), mimestate.MIMESTATE_USERHEADERS, hdr.getNext());
						break;
					} 
			case mimestate.MIMESTATE_END:
					return cursize;
			case mimestate.MIMESTATE_BODY:
					ModernizedCProgram.cleanup_encoder_state(part.getEncstate());
					ModernizedCProgram.mimesetstate(part.getState(), mimestate.MIMESTATE_CONTENT, ((Object)0));
					break;
			case mimestate.MIMESTATE_CONTENT:
					if (part.getEncoder()) {
						sz = ModernizedCProgram.read_encoded_part_content(part, buffer, bufsize);
					} else {
							sz = ModernizedCProgram.read_part_content(part, buffer, bufsize);
					} 
					switch (sz) {
					case ((size_t)-1):
							return cursize ? cursize : sz;
					case 0:
							ModernizedCProgram.mimesetstate(part.getState(), mimestate.MIMESTATE_END, ((Object)0));
							if (part.getKind() == mimekind.MIMEKIND_FILE && part.getFp()) {
								.fclose(part.getFp());
								part.setFp(((Object)0));
							} 
					case /* FALLTHROUGH */-1024:
					case -1024:
					}
					break;
			case /* FALLTHROUGH */mimestate.MIMESTATE_CURLHEADERS:
					if (!hdr) {
						ModernizedCProgram.mimesetstate(part.getState(), mimestate.MIMESTATE_USERHEADERS, part.getUserheaders());
					} else {
							sz = ModernizedCProgram.readback_bytes(part.getState(), buffer, bufsize, hdr.getData(), .strlen(hdr.getData()), "\r\n");
							if (!sz) {
								ModernizedCProgram.mimesetstate(part.getState(), part.getState().getState(), hdr.getNext());
							} 
					} 
					break;
			default:
					break;
			}
			cursize += /* Bump buffer and counters according to read size. */sz;
			buffer += sz;
			bufsize -= sz;
		}
		return cursize;
	}
	/* Readback from mime. */
	public static Object mime_subparts_read(Object buffer, Object size, Object nitems, Object instream) {
		curl_mime mime = (curl_mime)instream;
		size_t cursize = 0;
		(Object)/* Always 1. */size;
		while (nitems) {
			size_t sz = 0;
			curl_mimepart part = mime.getState().getPtr();
			switch (mime.getState().getState()) {
			case mimestate.MIMESTATE_BOUNDARY1:
					sz = ModernizedCProgram.readback_bytes(mime.getState(), buffer, nitems, "\r\n--", 4, "");
					if (!sz) {
						ModernizedCProgram.mimesetstate(mime.getState(), mimestate.MIMESTATE_BOUNDARY2, part);
					} 
					break;
			case mimestate.MIMESTATE_BODY:
					ModernizedCProgram.mimesetstate(mime.getState(), mimestate.MIMESTATE_BOUNDARY1, mime.getFirstpart());
					mime.getState().getOffset() += 2;
					break;
			case mimestate.MIMESTATE_BOUNDARY2:
					sz = ModernizedCProgram.readback_bytes(mime.getState(), buffer, nitems, mime.getBoundary(), .strlen(mime.getBoundary()), part ? "\r\n" : "--\r\n");
					if (!sz) {
						ModernizedCProgram.mimesetstate(mime.getState(), mimestate.MIMESTATE_CONTENT, part);
					} 
					break;
			case mimestate.MIMESTATE_BEGIN:
			case mimestate.MIMESTATE_CONTENT:
					if (!part) {
						ModernizedCProgram.mimesetstate(mime.getState(), mimestate.MIMESTATE_END, ((Object)0));
						break;
					} 
					sz = ModernizedCProgram.readback_part(part, buffer, nitems);
					switch (sz) {
					case -1024:
					case ((size_t)-1):
							return cursize ? cursize : sz;
					case -1024:
					case 0:
							ModernizedCProgram.mimesetstate(mime.getState(), mimestate.MIMESTATE_BOUNDARY1, part.getNextpart());
							break;
					}
					break;
			case mimestate.MIMESTATE_END:
					return cursize;
			default:
					break;
			}
			cursize += /* Bump buffer and counters according to read size. */sz;
			buffer += sz;
			nitems -= sz;
		}
		return cursize;
	}
	public static int mime_part_rewind(Object part) {
		int res = 0;
		mimestate targetstate = mimestate.MIMESTATE_BEGIN;
		if (part.getFlags() & (1 << 1)) {
			mimestate.targetstate = mimestate.MIMESTATE_BODY;
		} 
		ModernizedCProgram.cleanup_encoder_state(part.getEncstate());
		if (part.getState().getState() > mimestate.targetstate) {
			res = 2;
			if (part.getSeekfunc()) {
				res = .UNRECOGNIZEDFUNCTIONNAME(part.getArg(), (curl_off_t)0, 0);
				switch (res) {
				case 1:
				case 0:
				case 2:
						break;
				case -/* For fseek() error. */1:
						res = 2;
						break;
				default:
						res = 1;
						break;
				}
			} 
		} 
		if (res == 0) {
			ModernizedCProgram.mimesetstate(part.getState(), mimestate.targetstate, ((Object)0));
		} 
		return res;
	}
	public static int mime_subparts_seek(Object instream, Object offset, int whence) {
		curl_mime mime = (curl_mime)instream;
		curl_mimepart part = new curl_mimepart();
		int result = 0;
		if (whence != 0 || offset) {
			return /* Only support full rewind. */2;
		} 
		if (mime.getState().getState() == mimestate.MIMESTATE_BEGIN) {
			return /* Already rewound. */0;
		} 
		for (part = mime.getFirstpart(); part; part = part.getNextpart()) {
			int res = ModernizedCProgram.mime_part_rewind(part);
			if (res != 0) {
				result = res;
			} 
		}
		if (result == 0) {
			ModernizedCProgram.mimesetstate(mime.getState(), mimestate.MIMESTATE_BEGIN, ((Object)0));
		} 
		return result;
	}
	/* Release part content. */
	public static void cleanup_part_content(Object part) {
		if (part.getFreefunc()) {
			.UNRECOGNIZEDFUNCTIONNAME(part.getArg());
		} 
		part.setReadfunc(((Object)0));
		part.setSeekfunc(((Object)0));
		part.setFreefunc(((Object)0));
		part.setArg((Object)/* Defaults to part itself. */part);
		part.setData(((Object)0));
		part.setFp(((Object)0));
		part.setDatasize((curl_off_t)/* No size yet. */0);
		ModernizedCProgram.cleanup_encoder_state(part.getEncstate());
		part.setKind(mimekind.MIMEKIND_NONE);
	}
	public static void mime_subparts_free(Object ptr) {
		curl_mime mime = (curl_mime)ptr;
		if (mime && mime.getParent()) {
			mime.getParent().setFreefunc(((Object)/* Be sure we won't be called again. */0));
			ModernizedCProgram.cleanup_part_content(mime.getParent());
		} 
		ModernizedCProgram.curl_mime_free(mime);
	}
	/* Do not free subparts: unbind them. This is used for the top level only. */
	public static void mime_subparts_unbind(Object ptr) {
		curl_mime mime = (curl_mime)ptr;
		if (mime && mime.getParent()) {
			mime.getParent().setFreefunc(((Object)/* Be sure we won't be called again. */0));
			ModernizedCProgram.cleanup_part_content(mime.getParent());
			mime.setParent(((Object)0));
		} 
	}
	public static void Curl_mime_cleanpart(Object part) {
		ModernizedCProgram.cleanup_part_content(part);
		ModernizedCProgram.curl_slist_free_all(part.getCurlheaders());
		if (part.getFlags() & (1 << 0)) {
			ModernizedCProgram.curl_slist_free_all(part.getUserheaders());
		} 
		do {
			.Curl_cfree((part.getMimetype()));
			(part.getMimetype()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((part.getName()));
			(part.getName()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((part.getFilename()));
			(part.getFilename()) = ((Object)0);
		} while (0);
		ModernizedCProgram.Curl_mime_initpart(part, part.getEasy());
	}
	/* Recursively delete a mime handle and its parts. */
	public static void curl_mime_free(Object mime) {
		curl_mimepart part = new curl_mimepart();
		if (mime) {
			ModernizedCProgram.mime_subparts_unbind(/* Be sure it's not referenced anymore. */mime);
			while (mime.getFirstpart()) {
				part = mime.getFirstpart();
				mime.setFirstpart(part.getNextpart());
				ModernizedCProgram.Curl_mime_cleanpart(part);
				.Curl_cfree(part);
			}
			.Curl_cfree(mime);
		} 
	}
	public static  Curl_mime_duppart(Object dst, Object src) {
		curl_mime mime = new curl_mime();
		curl_mimepart d = new curl_mimepart();
		curl_mimepart s = new curl_mimepart();
		CURLcode res = .CURLE_OK;
		do {
		} while (0);
		switch (src.getKind()) {
		case mimekind.MIMEKIND_DATA:
				res = ModernizedCProgram.curl_mime_data(dst, src.getData(), (size_t)src.getDatasize());
				break;
		case mimekind.MIMEKIND_MULTIPART/* No one knows about the cloned subparts, thus always attach ownership
		       to the part. */:
				mime = ModernizedCProgram.curl_mime_init(dst.getEasy());
				res = mime ? ModernizedCProgram.curl_mime_subparts(dst, mime) : .CURLE_OUT_OF_MEMORY;
				for (s = ((curl_mime)src.getArg()).getFirstpart(); !res && s; s = s.getNextpart()) {
					d = ModernizedCProgram.curl_mime_addpart(mime);
					res = d ? ModernizedCProgram.Curl_mime_duppart(d, s) : .CURLE_OUT_OF_MEMORY;
				}
				break;
		case mimekind.MIMEKIND_NONE:
				break;
		case mimekind.MIMEKIND_CALLBACK:
				res = ModernizedCProgram.curl_mime_data_cb(dst, src.getDatasize(), src.getReadfunc(), src.getSeekfunc(), src.getFreefunc(), src.getArg());
				break;
		case mimekind.MIMEKIND_FILE:
				res = ModernizedCProgram.curl_mime_filedata(dst, src.getData());
				if (res == /* Do not abort duplication if file is not readable. */.CURLE_READ_ERROR) {
					res = .CURLE_OK;
				} 
				break;
		default:
				res = /* Internal error? */.CURLE_BAD_FUNCTION_ARGUMENT;
				break;
		}
		if (!res && src.getUserheaders()) {
			curl_slist hdrs = ModernizedCProgram.Curl_slist_duplicate(src.getUserheaders());
			if (!hdrs) {
				res = .CURLE_OUT_OF_MEMORY;
			} else {
					res = ModernizedCProgram.curl_mime_headers(dst, hdrs, /* No one but this procedure knows about the new header list,
					         so always take ownership. */1);
					if (res) {
						ModernizedCProgram.curl_slist_free_all(hdrs);
					} 
			} 
		} 
		if (!res) {
			dst.setEncoder(src.getEncoder());
			res = ModernizedCProgram.curl_mime_type(dst, src.getMimetype());
		} 
		if (!res) {
			res = ModernizedCProgram.curl_mime_name(dst, src.getName());
		} 
		if (!res) {
			res = ModernizedCProgram.curl_mime_filename(dst, src.getFilename());
		} 
		if (/* If an error occurred, rollback. */res) {
			ModernizedCProgram.Curl_mime_cleanpart(dst);
		} 
		return res/*
		 * Mime build functions.
		 */;
	}
	/* Create a mime handle. */
	public static Object curl_mime_init(Object easy) {
		curl_mime mime = new curl_mime();
		mime = (curl_mime).Curl_cmalloc();
		if (mime) {
			mime.setEasy(easy);
			mime.setParent(((Object)0));
			mime.setFirstpart(((Object)0));
			mime.setLastpart(((Object)0));
			.memset(mime.getBoundary(), (byte)'-', 24);
			if (ModernizedCProgram.Curl_rand_hex(easy, (byte)mime.getBoundary()[24], 16 + 1)) {
				.Curl_cfree(/* failed to get random separator, bail out */mime);
				return ((Object)0);
			} 
			ModernizedCProgram.mimesetstate(mime.getState(), mimestate.MIMESTATE_BEGIN, ((Object)0));
		} 
		return mime;
	}
	/* Initialize a mime part. */
	public static void Curl_mime_initpart(Object part, Object easy) {
		.memset((byte)part, 0, );
		part.setEasy(easy);
		ModernizedCProgram.mimesetstate(part.getState(), mimestate.MIMESTATE_BEGIN, ((Object)0));
	}
	/* Create a mime part and append it to a mime handle's part list. */
	public static Object curl_mime_addpart(Object mime) {
		curl_mimepart part = new curl_mimepart();
		if (!mime) {
			return ((Object)0);
		} 
		part = (curl_mimepart).Curl_cmalloc();
		if (part) {
			ModernizedCProgram.Curl_mime_initpart(part, mime.getEasy());
			part.setParent(mime);
			if (mime.getLastpart()) {
				mime.getLastpart().setNextpart(part);
			} else {
					mime.setFirstpart(part);
			} 
			mime.setLastpart(part);
		} 
		return part;
	}
	/* Set mime part name. */
	public static  curl_mime_name(Object part, Object name) {
		if (!part) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		do {
			.Curl_cfree((part.getName()));
			(part.getName()) = ((Object)0);
		} while (0);
		part.setName(((Object)0));
		if (name) {
			part.setName(.Curl_cstrdup(name));
			if (!part.getName()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		return .CURLE_OK;
	}
	/* Set mime part remote file name. */
	public static  curl_mime_filename(Object part, Object filename) {
		if (!part) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		do {
			.Curl_cfree((part.getFilename()));
			(part.getFilename()) = ((Object)0);
		} while (0);
		part.setFilename(((Object)0));
		if (filename) {
			part.setFilename(.Curl_cstrdup(filename));
			if (!part.getFilename()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		return .CURLE_OK;
	}
	/* Set mime part content from memory data. */
	public static  curl_mime_data(Object part, Object data, Object datasize) {
		if (!part) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		ModernizedCProgram.cleanup_part_content(part);
		if (data) {
			if (datasize == ((size_t)-1)) {
				datasize = .strlen(data);
			} 
			part.setData(.Curl_cmalloc(datasize + 1));
			if (!part.getData()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			part.setDatasize(datasize);
			if (datasize) {
				.memcpy(part.getData(), data, datasize);
			} 
			part.getData()[datasize] = /* Set a nul terminator as sentinel. */(byte)'\0';
			part.setReadfunc(mime_mem_read);
			part.setSeekfunc(mime_mem_seek);
			part.setFreefunc(mime_mem_free);
			part.setKind(mimekind.MIMEKIND_DATA);
		} 
		return .CURLE_OK;
	}
	/* Set mime part content from named local file. */
	public static  curl_mime_filedata(Object part, Object filename) {
		CURLcode result = .CURLE_OK;
		if (!part) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		ModernizedCProgram.cleanup_part_content(part);
		Object generatedSt_mode = sbuf.getSt_mode();
		Object generatedSt_size = sbuf.getSt_size();
		if (filename) {
			byte base;
			_stati64 sbuf = new _stati64();
			if (._stati64(filename, sbuf) || .access(filename, 4)) {
				result = .CURLE_READ_ERROR;
			} 
			part.setData(.Curl_cstrdup(filename));
			if (!part.getData()) {
				result = .CURLE_OUT_OF_MEMORY;
			} 
			part.setDatasize(-1);
			if (!result && (((generatedSt_mode) & -1024) == -1024)) {
				part.setDatasize((generatedSt_size));
				part.setSeekfunc(mime_file_seek);
			} 
			part.setReadfunc(mime_file_read);
			part.setFreefunc(mime_file_free);
			part.setKind(mimekind.MIMEKIND_FILE/* As a side effect, set the filename to the current file's base name.
			       It is possible to withdraw this by explicitly calling
			       curl_mime_filename() with a NULL filename argument after the current
			       call. */);
			base = ModernizedCProgram.strippath(filename);
			if (!base) {
				result = .CURLE_OUT_OF_MEMORY;
			} else {
					CURLcode res = ModernizedCProgram.curl_mime_filename(part, base);
					if (res) {
						result = res;
					} 
					.Curl_cfree(base);
			} 
		} 
		return result;
	}
	/* Set mime part type. */
	public static  curl_mime_type(Object part, Object mimetype) {
		if (!part) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		do {
			.Curl_cfree((part.getMimetype()));
			(part.getMimetype()) = ((Object)0);
		} while (0);
		part.setMimetype(((Object)0));
		if (mimetype) {
			part.setMimetype(.Curl_cstrdup(mimetype));
			if (!part.getMimetype()) {
				return .CURLE_OUT_OF_MEMORY;
			} 
		} 
		return .CURLE_OK;
	}
	/* Set mime data transfer encoder. */
	public static  curl_mime_encoder(Object part, Object encoding) {
		CURLcode result = .CURLE_BAD_FUNCTION_ARGUMENT;
		mime_encoder mep = new mime_encoder();
		if (!part) {
			return result;
		} 
		part.setEncoder(((Object)0));
		if (!encoding) {
			return /* Removing current encoder. */.CURLE_OK;
		} 
		for (mep = ModernizedCProgram.encoders; mep.getName(); mep++) {
			if (ModernizedCProgram.Curl_strcasecompare(encoding, mep.getName())) {
				part.setEncoder(mep);
				result = .CURLE_OK;
			} 
		}
		return result;
	}
	/* Set mime part headers. */
	public static  curl_mime_headers(Object part, Object headers, int take_ownership) {
		if (!part) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		if (part.getFlags() & (1 << 0)) {
			if (part.getUserheaders() != /* Allow setting twice the same list. */headers) {
				ModernizedCProgram.curl_slist_free_all(part.getUserheaders());
			} 
			part.getFlags() &=  ~(1 << 0);
		} 
		part.setUserheaders(headers);
		if (headers && take_ownership) {
			part.getFlags() |=  (1 << 0);
		} 
		return .CURLE_OK;
	}
	/* Set mime part content from callback. */
	public static  curl_mime_data_cb(Object part, Object datasize, Object readfunc, Object seekfunc, Object freefunc, Object arg) {
		if (!part) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		ModernizedCProgram.cleanup_part_content(part);
		if (readfunc) {
			part.setReadfunc(readfunc);
			part.setSeekfunc(seekfunc);
			part.setFreefunc(freefunc);
			part.setArg(arg);
			part.setDatasize(datasize);
			part.setKind(mimekind.MIMEKIND_CALLBACK);
		} 
		return .CURLE_OK;
	}
	/* Set mime part content from subparts. */
	public static  Curl_mime_set_subparts(Object part, Object subparts, int take_ownership) {
		curl_mime root = new curl_mime();
		if (!part) {
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		if (part.getKind() == mimekind.MIMEKIND_MULTIPART && part.getArg() == /* Accept setting twice the same subparts. */subparts) {
			return .CURLE_OK;
		} 
		ModernizedCProgram.cleanup_part_content(part);
		if (subparts) {
			if (part.getEasy() && subparts.getEasy() && part.getEasy() != subparts.getEasy()) {
				return .CURLE_BAD_FUNCTION_ARGUMENT;
			} 
			if (subparts.getParent()) {
				return .CURLE_BAD_FUNCTION_ARGUMENT;
			} 
			root = part.getParent();
			if (root) {
				while (root.getParent() && root.getParent().getParent()) {
					root = root.getParent().getParent();
				}
				if (subparts == root) {
					if (part.getEasy()) {
						ModernizedCProgram.Curl_failf(part.getEasy(), "Can't add itself as a subpart!");
					} 
					return .CURLE_BAD_FUNCTION_ARGUMENT;
				} 
			} 
			subparts.setParent(part);
			part.setReadfunc(mime_subparts_read);
			part.setSeekfunc(mime_subparts_seek);
			part.setFreefunc(take_ownership ? mime_subparts_free : mime_subparts_unbind);
			part.setArg(subparts);
			part.setDatasize(-1);
			part.setKind(mimekind.MIMEKIND_MULTIPART);
		} 
		return .CURLE_OK;
	}
	public static  curl_mime_subparts(Object part, Object subparts) {
		return ModernizedCProgram.Curl_mime_set_subparts(part, subparts, 1);
	}
	/* Readback from top mime. */
	/* Argument is the dummy top part. */
	public static Object Curl_mime_read(Object buffer, Object size, Object nitems, Object instream) {
		curl_mimepart part = (curl_mimepart)instream;
		(Object)/* Always 1. */size;
		return ModernizedCProgram.readback_part(part, buffer, nitems);
	}
	/* Rewind mime stream. */
	public static  Curl_mime_rewind(Object part) {
		return ModernizedCProgram.mime_part_rewind(part) == 0 ? .CURLE_OK : .CURLE_SEND_FAIL_REWIND;
	}
	/* Compute header list size. */
	public static Object slist_size(Object s, Object overhead, Object skip) {
		size_t size = 0;
		size_t skiplen = skip ? .strlen(skip) : 0;
		for (; s; s = s.getNext()) {
			if (!skip || !ModernizedCProgram.match_header(s, skip, skiplen)) {
				size += .strlen(s.getData()) + overhead;
			} 
		}
		return size;
	}
	/* Get/compute multipart size. */
	public static Object multipart_size(Object mime) {
		curl_off_t size = new curl_off_t();
		size_t boundarysize = new size_t();
		curl_mimepart part = new curl_mimepart();
		if (!mime) {
			return /* Not present -> empty. */0;
		} 
		boundarysize = 4 + .strlen(mime.getBoundary()) + 2;
		size = /* Final boundary - CRLF after headers. */boundarysize;
		for (part = mime.getFirstpart(); part; part = part.getNextpart()) {
			curl_off_t sz = ModernizedCProgram.Curl_mime_size(part);
			if (sz < 0) {
				size = sz;
			} 
			if (size >= 0) {
				size += boundarysize + sz;
			} 
		}
		return size;
	}
	/* Get/compute mime size. */
	public static Object Curl_mime_size(Object part) {
		curl_off_t size = new curl_off_t();
		if (part.getKind() == mimekind.MIMEKIND_MULTIPART) {
			part.setDatasize(ModernizedCProgram.multipart_size(part.getArg()));
		} 
		size = part.getDatasize();
		if (part.getEncoder()) {
			size = .UNRECOGNIZEDFUNCTIONNAME(part);
		} 
		if (size >= 0 && !(part.getFlags() & (1 << 1))) {
			size += ModernizedCProgram.slist_size(part.getCurlheaders(), 2, ((Object)/* Compute total part size. */0));
			size += ModernizedCProgram.slist_size(part.getUserheaders(), 2, "Content-Type");
			size += /* CRLF after headers. */2;
		} 
		return size;
	}
	/* Add a header. */
	/* VARARGS2 */
	public static  Curl_mime_add_header(Object slp, Object fmt) {
		curl_slist hdr = ((Object)0);
		byte s = ((Object)0);
		va_list ap = new va_list();
		.__builtin_va_start(ap, fmt);
		s = ModernizedCProgram.curl_mvaprintf(fmt, ap);
		.__builtin_va_end(ap);
		if (s) {
			hdr = ModernizedCProgram.Curl_slist_append_nodup(slp, s);
			if (hdr) {
				slp = hdr;
			} else {
					.Curl_cfree(s);
			} 
		} 
		return hdr ? .CURLE_OK : .CURLE_OUT_OF_MEMORY;
	}
	/* Add a content type header. */
	public static  add_content_type(Object slp, Object type, Object boundary) {
		return ModernizedCProgram.Curl_mime_add_header(slp, "Content-Type: %s%s%s", type, boundary ? "; boundary=" : "", boundary ? boundary : "");
	}
	public static Object Curl_mime_contenttype(Object filename) {
		ContentType[] ctts = new ContentType[]{new ContentType(".gif", "image/gif"), new ContentType(".jpg", "image/jpeg"), new ContentType(".jpeg", "image/jpeg"), new ContentType(".png", "image/png"), new ContentType(".svg", "image/svg+xml"), new ContentType(".txt", "text/plain"), new ContentType(".htm", "text/html"), new ContentType(".html", "text/html"), new ContentType(".pdf", "application/pdf"), new ContentType(".xml", "application/xml")};
		if (filename) {
			size_t len1 = .strlen(filename);
			byte nameend = filename + len1;
			int i;
			for (i = 0; i <  / ; i++) {
				size_t len2 = .strlen(ctts[i].getExtension());
				if (len1 >= len2 && ModernizedCProgram.Curl_strcasecompare(nameend - len2, ctts[i].getExtension())) {
					return ctts[i].getType();
				} 
			}
		} 
		return ((Object)0);
	}
	/*
	   * If no content type was specified, we scan through a few well-known
	   * extensions and pick the first we match!
	   */
	public static  Curl_mime_prepare_headers(Object part, Object contenttype, Object disposition, mimestrategy strategy) {
		curl_mime mime = ((Object)0);
		byte boundary = ((Object)0);
		byte customct;
		byte cte = ((Object)0);
		CURLcode ret = .CURLE_OK;
		ModernizedCProgram.curl_slist_free_all(part.getCurlheaders());
		part.setCurlheaders(((Object)0));
		if (part.getState().getState() == /* Be sure we won't access old headers later. */mimestate.MIMESTATE_CURLHEADERS) {
			ModernizedCProgram.mimesetstate(part.getState(), mimestate.MIMESTATE_CURLHEADERS, ((Object)0));
		} 
		customct = part.getMimetype();
		if (!customct) {
			customct = ModernizedCProgram.search_header(part.getUserheaders(), "Content-Type");
		} 
		if (customct) {
			contenttype = customct;
		} 
		if (!/* If content type is not specified, try to determine it. */contenttype) {
			switch (part.getKind()) {
			case mimekind.MIMEKIND_FILE:
					contenttype = ModernizedCProgram.Curl_mime_contenttype(part.getFilename());
					if (!contenttype) {
						contenttype = ModernizedCProgram.Curl_mime_contenttype(part.getData());
					} 
					if (!contenttype && part.getFilename()) {
						contenttype = "application/octet-stream";
					} 
					break;
			case mimekind.MIMEKIND_MULTIPART:
					contenttype = "multipart/mixed";
					break;
			default:
					contenttype = ModernizedCProgram.Curl_mime_contenttype(part.getFilename());
					break;
			}
		} 
		if (part.getKind() == mimekind.MIMEKIND_MULTIPART) {
			mime = (curl_mime)part.getArg();
			if (mime) {
				boundary = mime.getBoundary();
			} 
		}  else if (contenttype && !customct && ModernizedCProgram.Curl_strcasecompare(contenttype, "text/plain")) {
			if (mimestrategy.strategy == mimestrategy.MIMESTRATEGY_MAIL || !part.getFilename()) {
				contenttype = ((Object)0);
			} 
		} 
		if (!ModernizedCProgram.search_header(part.getUserheaders(), /* Issue content-disposition header only if not already set by caller. */"Content-Disposition")) {
			if (!disposition) {
				if (part.getFilename() || part.getName() || (contenttype && !ModernizedCProgram.Curl_strncasecompare(contenttype, "multipart/", 10))) {
					disposition = "attachment";
				} 
			} 
			if (disposition && ModernizedCProgram.curl_strequal(disposition, "attachment") && !part.getName() && !part.getFilename()) {
				disposition = ((Object)0);
			} 
			if (disposition) {
				byte name = ((Object)0);
				byte filename = ((Object)0);
				if (part.getName()) {
					name = ModernizedCProgram.escape_string(part.getName());
					if (!name) {
						ret = .CURLE_OUT_OF_MEMORY;
					} 
				} 
				if (!ret && part.getFilename()) {
					filename = ModernizedCProgram.escape_string(part.getFilename());
					if (!filename) {
						ret = .CURLE_OUT_OF_MEMORY;
					} 
				} 
				if (!ret) {
					ret = ModernizedCProgram.Curl_mime_add_header(part.getCurlheaders(), "Content-Disposition: %s%s%s%s%s%s%s", disposition, name ? "; name=\"" : "", name ? name : "", name ? "\"" : "", filename ? "; filename=\"" : "", filename ? filename : "", filename ? "\"" : "");
				} 
				do {
					.Curl_cfree((name));
					(name) = ((Object)0);
				} while (0);
				do {
					.Curl_cfree((filename));
					(filename) = ((Object)0);
				} while (0);
				if (ret) {
					return ret;
				} 
			} 
		} 
		if (/* Issue Content-Type header. */contenttype) {
			ret = ModernizedCProgram.add_content_type(part.getCurlheaders(), contenttype, boundary);
			if (ret) {
				return ret;
			} 
		} 
		if (!ModernizedCProgram.search_header(part.getUserheaders(), /* Content-Transfer-Encoding header. */"Content-Transfer-Encoding")) {
			if (part.getEncoder()) {
				cte = part.getEncoder().getName();
			}  else if (contenttype && mimestrategy.strategy == mimestrategy.MIMESTRATEGY_MAIL && part.getKind() != mimekind.MIMEKIND_MULTIPART) {
				cte = "8bit";
			} 
			if (cte) {
				ret = ModernizedCProgram.Curl_mime_add_header(part.getCurlheaders(), "Content-Transfer-Encoding: %s", cte);
				if (ret) {
					return ret;
				} 
			} 
		} 
		if (part.getState().getState() == /* If we were reading curl-generated headers, restart with new ones (this
		     should not occur). */mimestate.MIMESTATE_CURLHEADERS) {
			ModernizedCProgram.mimesetstate(part.getState(), mimestate.MIMESTATE_CURLHEADERS, part.getCurlheaders());
		} 
		if (part.getKind() == mimekind.MIMEKIND_MULTIPART && /* Process subparts. */mime) {
			curl_mimepart subpart = new curl_mimepart();
			disposition = ((Object)0);
			if (ModernizedCProgram.Curl_strcasecompare(contenttype, "multipart/form-data")) {
				disposition = "form-data";
			} 
			for (subpart = mime.getFirstpart(); subpart; subpart = subpart.getNextpart()) {
				ret = ModernizedCProgram.Curl_mime_prepare_headers(subpart, ((Object)0), disposition, mimestrategy.strategy);
				if (ret) {
					return ret;
				} 
			}
		} 
		return ret/* !CURL_DISABLE_HTTP || !CURL_DISABLE_SMTP || !CURL_DISABLE_IMAP *//* Mime not compiled in: define stubs for externally-referenced functions. *//* if disabled */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* this must be the last include file */
	/*
	 * @unittest: 1300
	 */
	public static void Curl_llist_init(Object l, Object dtor) {
		l.setSize(0);
		l.setDtor(dtor);
		l.setHead(((Object)0));
		l.setTail(((Object)0/*
		 * Curl_llist_insert_next()
		 *
		 * Inserts a new list element after the given one 'e'. If the given existing
		 * entry is NULL and the list already has elements, the new one will be
		 * inserted first in the list.
		 *
		 * The 'ne' argument should be a pointer into the object to store.
		 *
		 * @unittest: 1300
		 */));
	}
	public static void Curl_llist_insert_next(Object list, Object e, Object p, Object ne) {
		ne.setPtr((Object)p);
		if (list.getSize() == 0) {
			list.setHead(ne);
			list.getHead().setPrev(((Object)0));
			list.getHead().setNext(((Object)0));
			list.setTail(ne);
		} else {
				ne.setNext(e ? e.getNext() : list.getHead());
				ne.setPrev(e);
				if (!e) {
					list.getHead().setPrev(ne);
					list.setHead(ne);
				}  else if (e.getNext()) {
					e.getNext().setPrev(ne);
				} else {
						list.setTail(ne);
				} 
				if (e) {
					e.setNext(ne);
				} 
		} 
		++list.getSize();
	}
	public static void Curl_llist_remove(Object list, Object e, Object user) {
		Object ptr;
		if (e == ((Object)0) || list.getSize() == 0) {
			return ;
		} 
		if (e == list.getHead()) {
			list.setHead(e.getNext());
			if (list.getHead() == ((Object)0)) {
				list.setTail(((Object)0));
			} else {
					e.getNext().setPrev(((Object)0));
			} 
		} else {
				if (!e.getPrev()) {
					list.setHead(e.getNext());
				} else {
						e.getPrev().setNext(e.getNext());
				} 
				if (!e.getNext()) {
					list.setTail(e.getPrev());
				} else {
						e.getNext().setPrev(e.getPrev());
				} 
		} 
		ptr = e.getPtr();
		e.setPtr(((Object)0));
		e.setPrev(((Object)0));
		e.setNext(((Object)0));
		--list.getSize();
		if (list.getDtor()) {
			.UNRECOGNIZEDFUNCTIONNAME(user, ptr);
		} 
	}
	public static void Curl_llist_destroy(Object list, Object user) {
		if (list) {
			while (list.getSize() > 0) {
				ModernizedCProgram.Curl_llist_remove(list, list.getTail(), user);
			}
		} 
	}
	public static Object Curl_llist_count(Object list) {
		return list.getSize();
	}
	public static void Curl_llist_move(Object list, Object e, Object to_list, Object to_e) {
		if (e == ((Object)0) || list.getSize() == /* Remove element from list */0) {
			return ;
		} 
		if (e == list.getHead()) {
			list.setHead(e.getNext());
			if (list.getHead() == ((Object)0)) {
				list.setTail(((Object)0));
			} else {
					e.getNext().setPrev(((Object)0));
			} 
		} else {
				e.getPrev().setNext(e.getNext());
				if (!e.getNext()) {
					list.setTail(e.getPrev());
				} else {
						e.getNext().setPrev(e.getPrev());
				} 
		} 
		--list.getSize();
		if (to_list.getSize() == /* Add element to to_list after to_e */0) {
			to_list.setHead(e);
			to_list.getHead().setPrev(((Object)0));
			to_list.getHead().setNext(((Object)0));
			to_list.setTail(e);
		} else {
				e.setNext(to_e.getNext());
				e.setPrev(to_e);
				if (to_e.getNext()) {
					to_e.getNext().setPrev(e);
				} else {
						to_list.setTail(e);
				} 
				to_e.setNext(e);
		} 
		++to_list.getSize();
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 *   'pingpong' is for generic back-and-forth support functions used by FTP,
	 *   IMAP, POP3, SMTP and whatever more that likes them.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* Returns timeout in ms. 0 or negative number means the timeout has already
	   triggered */
	public static Object Curl_pp_state_timeout(Object pp,  disconnecting) {
		connectdata conn = pp.getConn();
		Curl_easy data = conn.getData();
		/* in milliseconds */time_t timeout_ms = new time_t();
		long response_time = (data.getSet().getServer_response_timeout()) ? data.getSet().getServer_response_timeout() : pp.getResponse_time();
		curltime curltime = new curltime();
		timeout_ms = /* Without a requested timeout, we only wait 'response_time' seconds for the
		     full response to arrive before we bail out */response_time - (time_t)curltime.Curl_now().Curl_timediff(pp.getResponse());
		if (data.getSet().getTimeout() && !disconnecting) {
			time_t timeout2_ms = data.getSet().getTimeout() - (time_t)curltime.Curl_now().Curl_timediff(conn.getNow());
			timeout_ms = ((timeout_ms) < (timeout2_ms) ? (timeout_ms) : (/* pick the lowest number */timeout2_ms));
		} 
		return timeout_ms/*
		 * Curl_pp_statemach()
		 */;
	}
	public static  Curl_pp_statemach(Object pp,  block,  disconnecting) {
		connectdata conn = pp.getConn();
		curl_socket_t sock = conn.getSock()[0];
		int rc;
		time_t interval_ms = new time_t();
		time_t timeout_ms = ModernizedCProgram.Curl_pp_state_timeout(pp, disconnecting);
		Curl_easy data = conn.getData();
		CURLcode result = .CURLE_OK;
		if (timeout_ms <= 0) {
			ModernizedCProgram.Curl_failf(data, "server response timeout");
			return /* already too little time */.CURLE_OPERATION_TIMEDOUT;
		} 
		if (block) {
			interval_ms = /* use 1 second timeout intervals */1000;
			if (timeout_ms < interval_ms) {
				interval_ms = timeout_ms;
			} 
		} else {
				interval_ms = /* immediate */0;
		} 
		if (0) {
			rc = 1;
		}  else if (ModernizedCProgram.Curl_pp_moredata(pp)) {
			rc = /* We are receiving and there is data in the cache so just read it */1;
		}  else if (!pp.getSendleft() && false) {
			rc = /* We are receiving and there is data ready in the SSL library */1;
		} else {
				rc = ModernizedCProgram.Curl_socket_check(pp.getSendleft() ? (SOCKET)(~0) : /* reading */sock, (SOCKET)(~0), pp.getSendleft() ? sock : (SOCKET)(~/* writing */0), interval_ms);
		} 
		curltime curltime = new curltime();
		if (block) {
			if (ModernizedCProgram.Curl_pgrsUpdate(/* if we didn't wait, we don't have to spend time on this now */conn)) {
				result = .CURLE_ABORTED_BY_CALLBACK;
			} else {
					result = curltime.Curl_now().Curl_speedcheck(data);
			} 
			if (result) {
				return result;
			} 
		} 
		if (rc == -1) {
			ModernizedCProgram.Curl_failf(data, "select/poll error");
			result = .CURLE_OUT_OF_MEMORY;
		}  else if (rc) {
			result = .UNRECOGNIZEDFUNCTIONNAME(conn);
		} 
		return result;
	}
	/* initialize stuff to prepare for reading a fresh new response */
	public static void Curl_pp_init(Object pp) {
		connectdata conn = pp.getConn();
		pp.setNread_resp(0);
		pp.setLinestart_resp(conn.getData().getState().getBuffer());
		pp.setPending_resp(1);
		curltime curltime = new curltime();
		pp.setResponse(curltime.Curl_now());
	}
	public static  Curl_pp_vsendf(Object pp, Object fmt, Object args) {
		ssize_t bytes_written = new ssize_t();
		size_t write_len = new size_t();
		byte fmt_crlf;
		byte s;
		CURLcode result = new CURLcode();
		connectdata conn = pp.getConn();
		Curl_easy data = new Curl_easy();
		do {
		} while (0);
		do {
		} while (0);
		do {
		} while (0);
		if (!conn) {
			return /* can't send without a connection! */.CURLE_SEND_ERROR;
		} 
		data = conn.getData();
		fmt_crlf = ModernizedCProgram.curl_maprintf("%s\r\n", /* append a trailing CRLF */fmt);
		if (!fmt_crlf) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		s = ModernizedCProgram.curl_mvaprintf(fmt_crlf, /* trailing CRLF appended */args);
		.Curl_cfree(fmt_crlf);
		if (!s) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		bytes_written = 0;
		write_len = .strlen(s);
		ModernizedCProgram.Curl_pp_init(pp);
		result = ();
		if (/* Curl_convert_to_network calls failf if unsuccessful */result) {
			.Curl_cfree(s);
			return result;
		} 
		result = ModernizedCProgram.Curl_write(conn, conn.getSock()[0], s, write_len, bytes_written);
		if (result) {
			.Curl_cfree(s);
			return result;
		} 
		if (conn.getData().getSet().getVerbose()) {
			ModernizedCProgram.Curl_debug(conn.getData(), .CURLINFO_HEADER_OUT, s, (size_t)bytes_written);
		} 
		curltime curltime = new curltime();
		if (bytes_written != (ssize_t)write_len) {
			pp.setSendthis(/* the whole chunk was not sent, keep it around and adjust sizes */s);
			pp.setSendsize(write_len);
			pp.setSendleft(write_len - bytes_written);
		} else {
				.Curl_cfree(s);
				pp.setSendthis(((Object)0));
				pp.setSendleft(pp.setSendsize(0));
				pp.setResponse(curltime.Curl_now());
		} 
		return .CURLE_OK/***********************************************************************
		 *
		 * Curl_pp_sendf()
		 *
		 * Send the formatted string as a command to a pingpong server. Note that
		 * the string should not have any CRLF appended, as this function will
		 * append the necessary things itself.
		 *
		 * made to never block
		 */;
	}
	public static  Curl_pp_sendf(Object pp, Object fmt) {
		CURLcode result = new CURLcode();
		va_list ap = new va_list();
		.__builtin_va_start(ap, fmt);
		result = ModernizedCProgram.Curl_pp_vsendf(pp, fmt, ap);
		.__builtin_va_end(ap);
		return result/*
		 * Curl_pp_readresp()
		 *
		 * Reads a piece of a server response.
		 */;
	}
	public static  Curl_pp_readresp(Object sockfd, Object pp, Object code, Object size) {
		/* count bytes per line */ssize_t perline = new ssize_t();
		bool keepon = 1;
		ssize_t gotbytes = new ssize_t();
		byte ptr;
		connectdata conn = pp.getConn();
		Curl_easy data = conn.getData();
		byte buf = data.getState().getBuffer();
		CURLcode result = .CURLE_OK;
		code = /* 0 for errors or not done */0;
		size = 0;
		ptr = buf + pp.getNread_resp();
		perline = (ssize_t)(ptr - pp.getLinestart_resp());
		while ((pp.getNread_resp() < (size_t)data.getSet().getBuffer_size()) && (keepon && !result)) {
			if (pp.getCache()) {
				if ((ptr + pp.getCache_size()) > (buf + data.getSet().getBuffer_size() + 1)) {
					ModernizedCProgram.Curl_failf(data, "cached response data too big to handle");
					return .CURLE_RECV_ERROR;
				} 
				.memcpy(ptr, pp.getCache(), pp.getCache_size());
				gotbytes = (ssize_t)pp.getCache_size();
				.Curl_cfree(pp.getCache());
				pp.setCache(((Object)/* clear the pointer */0));
				pp.setCache_size(/* zero the size just in case */0);
			} else {
					do {
					} while (0);
					result = ModernizedCProgram.Curl_read(conn, sockfd, ptr, data.getSet().getBuffer_size() - pp.getNread_resp(), gotbytes);
					if (result == .CURLE_AGAIN) {
						return /* return */.CURLE_OK;
					} 
					if (!result && (gotbytes > 0)) {
						result = ();
					} 
					if (result) {
						keepon = /* Set outer result variable to this error. */0;
					} 
			} 
			if (!keepon) {
				;
			}  else if (gotbytes <= 0) {
				keepon = 0;
				result = .CURLE_RECV_ERROR;
				ModernizedCProgram.Curl_failf(data, "response reading failed"/* we got a whole chunk of data, which can be anything from one
				       * byte to a set of lines and possible just a piece of the last
				       * line */);
			} else {
					ssize_t i = new ssize_t();
					ssize_t clipamount = 0;
					bool restart = 0;
					data.getReq().getHeaderbytecount() += (long)gotbytes;
					pp.getNread_resp() += gotbytes;
					for (i = 0; i < gotbytes; ) {
						perline++;
						if (ptr == (byte)'\n'/* a newline is CRLF in pp-talk, so the CR is ignored as
						             the line isn't really terminated until the LF comes */) {
							if (data.getSet().getVerbose()) {
								ModernizedCProgram.Curl_debug(data, .CURLINFO_HEADER_IN, pp.getLinestart_resp(), (size_t)perline/*
								           * We pass all response-lines to the callback function registered
								           * for "headers". The response lines can be seen as a kind of
								           * headers.
								           */);
							} 
							result = ModernizedCProgram.Curl_client_write(conn, (1 << 1), pp.getLinestart_resp(), perline);
							if (result) {
								return result;
							} 
							if (.UNRECOGNIZEDFUNCTIONNAME(conn, pp.getLinestart_resp(), perline, code/* This is the end of the last line, copy the last line to the
							               start of the buffer and zero terminate, for old times sake */)) {
								size_t n = ptr - pp.getLinestart_resp();
								.memmove(buf, pp.getLinestart_resp(), n);
								buf[n] = /* zero terminate */0;
								keepon = 0;
								pp.setLinestart_resp(ptr + /* advance pointer */1);
								/* skip this before getting out */i++;
								size = pp.getNread_resp();
								pp.setNread_resp(/* restart */0);
								break;
							} 
							perline = /* line starts over here */0;
							pp.setLinestart_resp(ptr + 1);
						} 
					}
					if (!keepon && (i != gotbytes/* We found the end of the response lines, but we didn't parse the
					           full chunk of data we have read from the server. We therefore need
					           to store the rest of the data to be checked on the next invoke as
					           it may actually contain another end of response already! */)) {
						clipamount = gotbytes - i;
						restart = 1;
						do {
						} while (0);
					}  else if (keepon) {
						if ((perline == gotbytes) && (gotbytes > data.getSet().getBuffer_size() / 2/* We got an excessive line without newlines and we need to deal
						             with it. We keep the first bytes of the line then we throw
						             away the rest. */)) {
							ModernizedCProgram.Curl_infof(data, "Excessive server response line length received, %zd bytes. Stripping\n", gotbytes);
							restart = 1;
							clipamount = /* we keep 40 bytes since all our pingpong protocols are only
							             interested in the first piece */40;
						}  else if (pp.getNread_resp() > (size_t)data.getSet().getBuffer_size() / 2/* We got a large chunk of data and there's potentially still
						             trailing data to take care of, so we put any such part in the
						             "cache", clear the buffer to make space and restart. */) {
							clipamount = perline;
							restart = 1;
						} 
					}  else if (i == gotbytes) {
						restart = 1;
					} 
					if (clipamount) {
						pp.setCache_size(clipamount);
						pp.setCache(.Curl_cmalloc(pp.getCache_size()));
						if (pp.getCache()) {
							.memcpy(pp.getCache(), pp.getLinestart_resp(), pp.getCache_size());
						} else {
								return .CURLE_OUT_OF_MEMORY;
						} 
					} 
					if (restart/* now reset a few variables to start over nicely from the start of
					           the big buffer */) {
						pp.setNread_resp(/* start over from scratch in the buffer */0);
						ptr = pp.setLinestart_resp(buf);
						perline = 0/* there was data */;
					} 
			} 
		}
		pp.setPending_resp(/* while there's buffer left and loop is requested */0);
		return result;
	}
	public static int Curl_pp_getsock(Object pp, Object socks) {
		connectdata conn = pp.getConn();
		socks[0] = conn.getSock()[0];
		if (pp.getSendleft()) {
			return (1 << (16 + (/* write mode */false)));
		} 
		return (1 << (/* read mode */false));
	}
	public static  Curl_pp_flushsend(Object pp) {
		connectdata conn = pp.getConn();
		ssize_t written = new ssize_t();
		curl_socket_t sock = conn.getSock()[0];
		CURLcode result = ModernizedCProgram.Curl_write(conn, sock, pp.getSendthis() + pp.getSendsize() - pp.getSendleft(), pp.getSendleft(), written);
		if (result) {
			return result;
		} 
		curltime curltime = new curltime();
		if (written != (ssize_t)pp.getSendleft()) {
			pp.getSendleft() -= /* only a fraction was sent */written;
		} else {
				.Curl_cfree(pp.getSendthis());
				pp.setSendthis(((Object)0));
				pp.setSendleft(pp.setSendsize(0));
				pp.setResponse(curltime.Curl_now());
		} 
		return .CURLE_OK;
	}
	public static  Curl_pp_disconnect(Object pp) {
		.Curl_cfree(pp.getCache());
		pp.setCache(((Object)0));
		return .CURLE_OK;
	}
	public static  Curl_pp_moredata(Object pp) {
		return (!pp.getSendleft() && pp.getCache() && pp.getNread_resp() < pp.getCache_size()) ? 1 : 0;
	}
	public static int tool_debug_cb(Object handle,  type, Object data, Object size, Object userdata) {
		OperationConfig operation = userdata;
		GlobalConfig config = operation.getGlobal();
		FILE output = config.getErrors();
		byte text;
		timeval tv = new timeval();
		byte[] timebuf = new byte[20];
		time_t secs = new time_t();
		(Object)/* not used */handle;
		timeval timeval = new timeval();
		long generatedTv_sec = tv.getTv_sec();
		long generatedTv_usec = tv.getTv_usec();
		if (config.getTracetime()) {
			tm now = new tm();
			time_t epoch_offset = new time_t();
			int known_offset;
			tv = timeval.tvnow();
			if (!known_offset) {
				epoch_offset = .time(((Object)0)) - generatedTv_sec;
				known_offset = 1;
			} 
			secs = epoch_offset + generatedTv_sec;
			now = .localtime(/* not thread safe but we don't care */secs);
			ModernizedCProgram.curl_msnprintf(timebuf, , "%02d:%02d:%02d.%06ld ", now.getTm_hour(), now.getTm_min(), now.getTm_sec(), (long)generatedTv_usec);
		} else {
				timebuf[0] = 0;
		} 
		if (!config.getTrace_stream()) {
			if (!.strcmp("-", config.getTrace_dump())) {
				config.setTrace_stream((_iob[1]));
			}  else if (!.strcmp("%", config.getTrace_dump())) {
				config.setTrace_stream(config.getErrors());
			} else {
					config.setTrace_stream(.fopen(config.getTrace_dump(), "wt"));
					config.setTrace_fopened(1);
			} 
		} 
		if (config.getTrace_stream()) {
			output = config.getTrace_stream();
		} 
		if (!output) {
			ModernizedCProgram.warnf(config, "Failed to create/open output");
			return 0;
		} 
		if (config.getTracetype() == .TRACE_PLAIN/*
		     * This is the trace look that is similar to what libcurl makes on its
		     * own.
		     */) {
			byte[] s_infotype = new byte[]{"*", "<", ">", "{", "}", "{", "}"};
			bool newl = 0;
			bool traced_data = 0;
			switch (type) {
			case .CURLINFO_TEXT:
			case .CURLINFO_SSL_DATA_OUT:
					if (!traced_data/* if the data is output to a tty and we're sending this debug trace
					           to stderr or stdout, we don't display the alert about the data not
					           being shown as the data _is_ shown then just not via this
					           function */) {
						if (!config.getIsatty() || ((output != (_iob[2])) && (output != (_iob[1])))) {
							if (!newl) {
								ModernizedCProgram.curl_mfprintf(output, "%s%s ", timebuf, s_infotype[type]);
							} 
							ModernizedCProgram.curl_mfprintf(output, "[%zu bytes data]\n", size);
							newl = 0;
							traced_data = 1;
						} 
					} 
					break;
			case .CURLINFO_DATA_IN:
			case .CURLINFO_SSL_DATA_IN:
			case .CURLINFO_HEADER_OUT:
					if (size > 0) {
						size_t st = 0;
						size_t i = new size_t();
						for (i = 0; i < size - 1; i++) {
							if (data[i] == /* LF */(byte)'\n') {
								if (!newl) {
									ModernizedCProgram.curl_mfprintf(output, "%s%s ", timebuf, s_infotype[type]);
								} 
								(Object).fwrite(data + st, i - st + 1, 1, output);
								st = i + 1;
								newl = 0;
							} 
						}
						if (!newl) {
							ModernizedCProgram.curl_mfprintf(output, "%s%s ", timebuf, s_infotype[type]);
						} 
						(Object).fwrite(data + st, i - st + 1, 1, output);
					} 
					newl = (size && (data[size - 1] != (byte)'\n')) ? 1 : 0;
					traced_data = 0;
					break;
			case .CURLINFO_HEADER_IN:
					if (!newl) {
						ModernizedCProgram.curl_mfprintf(output, "%s%s ", timebuf, s_infotype[type]);
					} 
					(Object).fwrite(data, size, 1, output);
					newl = (size && (data[size - 1] != (byte)'\n')) ? 1 : 0;
					traced_data = 0;
					break;
			case .CURLINFO_DATA_OUT:
			default:
					newl = 0;
					traced_data = 0;
					break;
			}
			return 0/* Special processing is needed for CURLINFO_HEADER_OUT blocks
			   * if they contain both headers and data (separated by CRLFCRLF).
			   * We dump the header text and then switch type to CURLINFO_DATA_OUT.
			   *//* dump everything through the CRLFCRLF as a sent header */;
		} 
		switch (/* CURL_DOES_CONVERSIONS */type) {
		case .CURLINFO_HEADER_OUT:
				text = "=> Send header";
				break;
		case .CURLINFO_SSL_DATA_IN:
				text = "<= Recv SSL data";
				break;
		case .CURLINFO_HEADER_IN:
				text = "<= Recv header";
				break;
		case .CURLINFO_TEXT:
				ModernizedCProgram.curl_mfprintf(output, "%s== Info: %s", timebuf, data/* FALLTHROUGH */);
		case .CURLINFO_DATA_OUT:
				text = "=> Send data";
				break;
		case .CURLINFO_DATA_IN:
				text = "<= Recv data";
				break;
		case .CURLINFO_SSL_DATA_OUT:
				text = "=> Send SSL data";
				break;
		default:
				return 0;
		}
		ModernizedCProgram.dump(timebuf, text, output, (byte)data, size, config.getTracetype(), type);
		return 0;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	public static void dump(Object timebuf, Object text, Object stream, Object ptr, Object size,  tracetype,  infotype) {
		size_t i = new size_t();
		size_t c = new size_t();
		int width = -1024;
		if (tracetype == .TRACE_ASCII) {
			width = /* without the hex output, we can fit more on screen */-1024;
		} 
		ModernizedCProgram.curl_mfprintf(stream, "%s%s, %zu bytes (0x%zx)\n", timebuf, text, size, size);
		for (i = 0; i < size; i += width) {
			ModernizedCProgram.curl_mfprintf(stream, "%04zx: ", i);
			if (tracetype == .TRACE_BIN) {
				for (c = 0; c < width; /* hex not disabled, show it */c++) {
					if (i + c < size) {
						ModernizedCProgram.curl_mfprintf(stream, "%02x ", ptr[i + c]);
					} else {
							.fputs("   ", stream);
					} 
				}
			} 
			for (c = 0; (c < width) && (i + c < size); c++) {
				if ((tracetype == /* check for 0D0A; if found, skip past and start a new line of output */.TRACE_ASCII) && (i + c + 1 < size) && (ptr[i + c] == -1024) && (ptr[i + c + 1] == -1024)) {
					i += (c + 2 - width);
					break;
				} 
				(Object)/* convert to host encoding and print this character */infotype;
				ModernizedCProgram.curl_mfprintf(stream, "%c", ((ptr[i + c] >= -1024) && (ptr[i + c] < -1024)) ? ptr[i + c] : (byte)'.'/* CURL_DOES_CONVERSIONS */);
				if ((tracetype == /* check again for 0D0A, to avoid an extra \n if it's at width */.TRACE_ASCII) && (i + c + 2 < size) && (ptr[i + c + 1] == -1024) && (ptr[i + c + 2] == -1024)) {
					i += (c + 3 - width);
					break;
				} 
			}
			.fputc((byte)'\n', /* newline */stream);
		}
		.fflush(stream);
	}
	/*
	** callback for CURLOPT_DEBUGFUNCTION
	*/
	public static Object slist_wc_append(Object list, Object data) {
		curl_slist new_item = ModernizedCProgram.curl_slist_append(((Object)0), data);
		if (!new_item) {
			return ((Object)0);
		} 
		if (!list) {
			list = .malloc();
			if (!list) {
				ModernizedCProgram.curl_slist_free_all(new_item);
				return ((Object)0);
			} 
			list.setFirst(new_item);
			list.setLast(new_item);
			return list;
		} 
		list.getLast().setNext(new_item);
		list.setLast(list.getLast().getNext());
		return list;
	}
	/* be nice and clean up resources */
	public static void slist_wc_free_all(Object list) {
		if (!list) {
			return ;
		} 
		ModernizedCProgram.curl_slist_free_all(list.getFirst());
		.free(list/* CURL_DISABLE_LIBCURL_OPTION */);
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2012, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* use our own printf() functions */
	/* keep this as LAST include */
	/*
	** callback for CURLOPT_READFUNCTION
	*/
	public static Object tool_read_cb(Object buffer, Object sz, Object nmemb, Object userdata) {
		ssize_t rc = new ssize_t();
		InStruct in = userdata;
		rc = ModernizedCProgram.curlx_read(in.getFd(), buffer, sz * nmemb);
		if (rc < 0) {
			if ((._errno()) == 11) {
				(._errno()) = 0;
				in.getConfig().setOperationConfig(1);
				return -1024;
			} 
			rc = /* since size_t is unsigned we can't return negative values fine */0;
		} 
		in.getConfig().setOperationConfig(0);
		return (size_t)rc;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* keep this as LAST include */
	public static void tool_go_sleep(long ms) {
		.Sleep(ms);
	}
	public static int rtsp_getsock_do(Object conn, Object socks) {
		socks[0] = conn.getSock()[/* write mode */0];
		return (1 << (16 + (false)));
	}
	/*
	 * Parse and write out any available RTP data.
	 *
	 * nread: amount of data left after k->str. will be modified if RTP
	 *        data is parsed and k->str is moved up
	 * readmore: whether or not the RTP parser needs more data right away
	 */
	public static  rtsp_setup_connection(Object conn) {
		RTSP rtsp = new RTSP();
		conn.getData().getReq().setProtop(rtsp = .Curl_ccalloc(1, ));
		if (!rtsp) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		return .CURLE_OK/*
		 * The server may send us RTP data at any point, and RTSPREQ_RECEIVE does not
		 * want to block the application forever while receiving a stream. Therefore,
		 * we cannot assume that an RTSP socket is dead just because it is readable.
		 *
		 * Instead, if it is readable, run Curl_connalive() to peek at the socket
		 * and distinguish between closed and data.
		 */;
	}
	public static  rtsp_connisdead(Object check) {
		int sval;
		bool ret_val = 1;
		sval = ModernizedCProgram.Curl_socket_check(check.getSock()[0], (SOCKET)(~0), (SOCKET)(~0), (time_t)0);
		if (sval == 0) {
			ret_val = /* timeout */0;
		}  else if (sval & -1024) {
			ret_val = /* socket is in an error state */1;
		}  else if (sval & -1024) {
			ret_val = !ModernizedCProgram.Curl_connalive(/* readable with no error. could still be closed */check);
		} 
		return ret_val/*
		 * Function to check on various aspects of a connection.
		 */;
	}
	public static int rtsp_conncheck(Object check, int checks_to_perform) {
		int ret_val = 0;
		if (checks_to_perform & (1 << 0)) {
			if (ModernizedCProgram.rtsp_connisdead(check)) {
				ret_val |=  (1 << 0);
			} 
		} 
		return ret_val;
	}
	/* this returns the socket to wait for in the DO and DOING state for the multi
	   interface and then we're always _sending_ a request and thus we wait for
	   the single socket to become writable only */
	public static  rtsp_connect(Object conn, Object done) {
		CURLcode httpStatus = new CURLcode();
		Curl_easy data = conn.getData();
		httpStatus = ModernizedCProgram.Curl_http_connect(conn, done);
		if (data.getState().getRtsp_next_client_CSeq() == /* Initialize the CSeq if not already done */0) {
			data.getState().setRtsp_next_client_CSeq(1);
		} 
		if (data.getState().getRtsp_next_server_CSeq() == 0) {
			data.getState().setRtsp_next_server_CSeq(1);
		} 
		conn.getProto().getRtspc().setRtp_channel(-1);
		return httpStatus;
	}
	public static  rtsp_disconnect(Object conn,  dead) {
		(Object)dead;
		do {
			.Curl_cfree((conn.getProto().getRtspc().getRtp_buf()));
			(conn.getProto().getRtspc().getRtp_buf()) = ((Object)0);
		} while (0);
		return .CURLE_OK;
	}
	public static  rtsp_done(Object conn,  status,  premature) {
		Curl_easy data = conn.getData();
		RTSP rtsp = data.getReq().getProtop();
		CURLcode httpStatus = new CURLcode();
		if (data.getSet().getRtspreq() == /* Bypass HTTP empty-reply checks on receive */.RTSPREQ_RECEIVE) {
			premature = 1;
		} 
		httpStatus = ModernizedCProgram.Curl_http_done(conn, status, premature);
		if (rtsp) {
			long CSeq_sent = rtsp.getCSeq_sent();
			long CSeq_recv = rtsp.getCSeq_recv();
			if ((data.getSet().getRtspreq() != .RTSPREQ_RECEIVE) && (CSeq_sent != CSeq_recv)) {
				ModernizedCProgram.Curl_failf(data, "The CSeq of this request %ld did not match the response %ld", CSeq_sent, CSeq_recv);
				return .CURLE_RTSP_CSEQ_ERROR;
			} 
			if (data.getSet().getRtspreq() == .RTSPREQ_RECEIVE && (conn.getProto().getRtspc().getRtp_channel() == -1)) {
				ModernizedCProgram.Curl_infof(data, "Got an RTP Receive with a CSeq of %ld\n", CSeq_recv);
			} 
		} 
		return httpStatus;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* protocol-specific functions set up to be called by the main engine */
	public static  rtsp_do(Object conn, Object done) {
		Curl_easy data = conn.getData();
		CURLcode result = .CURLE_OK;
		Curl_RtspReq rtspreq = data.getSet().getRtspreq();
		RTSP rtsp = data.getReq().getProtop();
		Curl_send_buffer req_buffer = new Curl_send_buffer();
		curl_off_t postsize = /* for ANNOUNCE and SET_PARAMETER */0;
		curl_off_t putsize = /* for ANNOUNCE and SET_PARAMETER */0;
		byte p_request = ((Object)0);
		byte p_session_id = ((Object)0);
		byte p_accept = ((Object)0);
		byte p_accept_encoding = ((Object)0);
		byte p_range = ((Object)0);
		byte p_referrer = ((Object)0);
		byte p_stream_uri = ((Object)0);
		byte p_transport = ((Object)0);
		byte p_uagent = ((Object)0);
		byte p_proxyuserpwd = ((Object)0);
		byte p_userpwd = ((Object)0);
		done = 1;
		rtsp.setCSeq_sent(data.getState().getRtsp_next_client_CSeq());
		rtsp.setCSeq_recv(0/* Setup the 'p_request' pointer to the proper p_request string
		   * Since all RTSP requests are included here, there is no need to
		   * support custom requests like HTTP.
		   **/);
		data.getSet().setOpt_no_body(/* most requests don't contain a body */1);
		switch (rtspreq) {
		case .RTSPREQ_OPTIONS:
				p_request = "OPTIONS";
				break;
		case .RTSPREQ_SETUP:
				p_request = "SETUP";
				break;
		case .RTSPREQ_SET_PARAMETER:
				p_request = "SET_PARAMETER";
				break;
		case .RTSPREQ_RECORD:
				p_request = "RECORD";
				break;
		case .RTSPREQ_LAST:
				ModernizedCProgram.Curl_failf(data, "Got invalid RTSP request: RTSPREQ_LAST");
				return .CURLE_BAD_FUNCTION_ARGUMENT;
		case .RTSPREQ_PAUSE:
				p_request = "PAUSE";
				break;
		case .RTSPREQ_ANNOUNCE:
				p_request = "ANNOUNCE";
				break;
		case .RTSPREQ_GET_PARAMETER:
				p_request = /* GET_PARAMETER's no_body status is determined later */"GET_PARAMETER";
				data.getSet().setOpt_no_body(0);
				break;
		case .RTSPREQ_PLAY:
				p_request = "PLAY";
				break;
		case .RTSPREQ_RECEIVE:
				p_request = "";
				data.getSet().setOpt_no_body(/* Treat interleaved RTP as body*/0);
				break;
		case .RTSPREQ_DESCRIBE:
				p_request = "DESCRIBE";
				data.getSet().setOpt_no_body(0);
				break;
		case .RTSPREQ_TEARDOWN:
				p_request = "TEARDOWN";
				break;
		default:
				ModernizedCProgram.Curl_failf(data, "Got invalid RTSP request");
				return .CURLE_BAD_FUNCTION_ARGUMENT;
		}
		if (rtspreq == .RTSPREQ_RECEIVE) {
			ModernizedCProgram.Curl_setup_transfer(data, 0, -1, 1, -1);
			return result;
		} 
		p_session_id = data.getSet().getStr()[dupstring.STRING_RTSP_SESSION_ID];
		if (!p_session_id && (rtspreq & ~(.RTSPREQ_OPTIONS | .RTSPREQ_DESCRIBE | .RTSPREQ_SETUP))) {
			ModernizedCProgram.Curl_failf(data, "Refusing to issue an RTSP request [%s] without a session ID.", p_request);
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		if (data.getSet().getStr()[/* Stream URI. Default to server '*' if not specified */dupstring.STRING_RTSP_STREAM_URI]) {
			p_stream_uri = data.getSet().getStr()[dupstring.STRING_RTSP_STREAM_URI];
		} else {
				p_stream_uri = "*";
		} 
		p_transport = ModernizedCProgram.Curl_checkheaders(conn, /* Transport Header for SETUP requests */"Transport");
		if (rtspreq == .RTSPREQ_SETUP && !p_transport) {
			if (data.getSet().getStr()[/* New Transport: setting? */dupstring.STRING_RTSP_TRANSPORT]) {
				do {
					.Curl_cfree((conn.getAllocptr().getRtsp_transport()));
					(conn.getAllocptr().getRtsp_transport()) = ((Object)0);
				} while (0);
				conn.getAllocptr().setRtsp_transport(ModernizedCProgram.curl_maprintf("Transport: %s\r\n", data.getSet().getStr()[dupstring.STRING_RTSP_TRANSPORT]));
				if (!conn.getAllocptr().getRtsp_transport()) {
					return .CURLE_OUT_OF_MEMORY;
				} 
			} else {
					ModernizedCProgram.Curl_failf(data, "Refusing to issue an RTSP SETUP without a Transport: header.");
					return .CURLE_BAD_FUNCTION_ARGUMENT;
			} 
			p_transport = conn.getAllocptr().getRtsp_transport();
		} 
		if (rtspreq == /* Accept Headers for DESCRIBE requests */.RTSPREQ_DESCRIBE) {
			p_accept = ModernizedCProgram.Curl_checkheaders(conn, /* Accept Header */"Accept") ? ((Object)0) : "Accept: application/sdp\r\n";
			if (!ModernizedCProgram.Curl_checkheaders(conn, /* Accept-Encoding header */"Accept-Encoding") && data.getSet().getStr()[dupstring.STRING_ENCODING]) {
				do {
					.Curl_cfree((conn.getAllocptr().getAccept_encoding()));
					(conn.getAllocptr().getAccept_encoding()) = ((Object)0);
				} while (0);
				conn.getAllocptr().setAccept_encoding(ModernizedCProgram.curl_maprintf("Accept-Encoding: %s\r\n", data.getSet().getStr()[dupstring.STRING_ENCODING]));
				if (!conn.getAllocptr().getAccept_encoding()) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				p_accept_encoding = conn.getAllocptr().getAccept_encoding();
			} 
		} 
		if (ModernizedCProgram.Curl_checkheaders(conn, "User-Agent") && conn.getAllocptr().getUagent()) {
			do {
				.Curl_cfree((conn.getAllocptr().getUagent()));
				(conn.getAllocptr().getUagent()) = ((Object)0);
			} while (0);
			conn.getAllocptr().setUagent(((Object)0));
		}  else if (!ModernizedCProgram.Curl_checkheaders(conn, "User-Agent") && data.getSet().getStr()[dupstring.STRING_USERAGENT]) {
			p_uagent = conn.getAllocptr().getUagent();
		} 
		result = ModernizedCProgram.Curl_http_output_auth(conn, p_request, p_stream_uri, /* setup the authentication headers */0);
		if (result) {
			return result;
		} 
		p_proxyuserpwd = conn.getAllocptr().getProxyuserpwd();
		p_userpwd = conn.getAllocptr().getUserpwd();
		do {
			.Curl_cfree((conn.getAllocptr().getRef()));
			(conn.getAllocptr().getRef()) = ((Object)0);
		} while (/* Referrer */0);
		if (data.getChange().getReferer() && !ModernizedCProgram.Curl_checkheaders(conn, "Referer")) {
			conn.getAllocptr().setRef(ModernizedCProgram.curl_maprintf("Referer: %s\r\n", data.getChange().getReferer()));
		} else {
				conn.getAllocptr().setRef(((Object)0));
		} 
		p_referrer = conn.getAllocptr().getRef();
		if (data.getState().getUse_range() && (rtspreq & (.RTSPREQ_PLAY | .RTSPREQ_PAUSE | .RTSPREQ_RECORD))) {
			if (!ModernizedCProgram.Curl_checkheaders(conn, "Range") && data.getState().getRange()) {
				do {
					.Curl_cfree((conn.getAllocptr().getRangeline()));
					(conn.getAllocptr().getRangeline()) = ((Object)0);
				} while (0);
				conn.getAllocptr().setRangeline(ModernizedCProgram.curl_maprintf("Range: %s\r\n", data.getState().getRange()));
				p_range = conn.getAllocptr().getRangeline();
			} 
		} 
		if (ModernizedCProgram.Curl_checkheaders(conn, /*
		   * Sanity check the custom headers
		   */"CSeq")) {
			ModernizedCProgram.Curl_failf(data, "CSeq cannot be set as a custom header.");
			return .CURLE_RTSP_CSEQ_ERROR;
		} 
		if (ModernizedCProgram.Curl_checkheaders(conn, "Session")) {
			ModernizedCProgram.Curl_failf(data, "Session ID cannot be set as a custom header.");
			return .CURLE_BAD_FUNCTION_ARGUMENT;
		} 
		req_buffer = ModernizedCProgram.Curl_add_buffer_init();
		if (!req_buffer) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		result = ModernizedCProgram.Curl_add_bufferf(req_buffer, /* Request Stream-URI RTSP/1.0 */"%s %s RTSP/1.0\r\nCSeq: %ld\r\n", p_request, p_stream_uri, rtsp.getCSeq_sent());
		if (result) {
			return result/*
			   * Rather than do a normal alloc line, keep the session_id unformatted
			   * to make comparison easier
			   */;
		} 
		if (p_session_id) {
			result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "Session: %s\r\n", p_session_id);
			if (result) {
				return result;
			} 
		} 
		result = ModernizedCProgram.Curl_add_bufferf(/*
		   * Shared HTTP-like options
		   */req_buffer, /* transport */"%s%s%s%s%s%s%s%s"/* accept *//* accept-encoding *//* range *//* referrer */, p_transport ? p_transport : /* user-agent *//* proxyuserpwd *//* userpwd */"", p_accept ? p_accept : "", p_accept_encoding ? p_accept_encoding : "", p_range ? p_range : "", p_referrer ? p_referrer : "", p_uagent ? p_uagent : "", p_proxyuserpwd ? p_proxyuserpwd : "", p_userpwd ? p_userpwd : ""/*
		   * Free userpwd now --- cannot reuse this for Negotiate and possibly NTLM
		   * with basic and digest, it will be freed anyway by the next request
		   */);
		do {
			.Curl_cfree((conn.getAllocptr().getUserpwd()));
			(conn.getAllocptr().getUserpwd()) = ((Object)0);
		} while (0);
		conn.getAllocptr().setUserpwd(((Object)0));
		if (result) {
			return result;
		} 
		if ((rtspreq == .RTSPREQ_SETUP) || (rtspreq == .RTSPREQ_DESCRIBE)) {
			result = ModernizedCProgram.Curl_add_timecondition(conn, req_buffer);
			if (result) {
				return result;
			} 
		} 
		result = ModernizedCProgram.Curl_add_custom_headers(conn, 0, req_buffer);
		if (result) {
			return result;
		} 
		if (rtspreq == .RTSPREQ_ANNOUNCE || rtspreq == .RTSPREQ_SET_PARAMETER || rtspreq == .RTSPREQ_GET_PARAMETER) {
			if (data.getSet().getUpload()) {
				putsize = data.getState().getInfilesize();
				data.getSet().setHttpreq(.HTTPREQ_PUT);
			} else {
					postsize = (data.getState().getInfilesize() != -1) ? data.getState().getInfilesize() : (data.getSet().getPostfields() ? (curl_off_t).strlen(data.getSet().getPostfields()) : 0);
					data.getSet().setHttpreq(.HTTPREQ_POST);
			} 
			if (putsize > 0 || postsize > 0/* As stated in the http comments, it is probably not wise to
			       * actually set a custom Content-Length in the headers */) {
				if (!ModernizedCProgram.Curl_checkheaders(conn, "Content-Length")) {
					result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "Content-Length: %I64d\r\n", (data.getSet().getUpload() ? putsize : postsize));
					if (result) {
						return result;
					} 
				} 
				if (rtspreq == .RTSPREQ_SET_PARAMETER || rtspreq == .RTSPREQ_GET_PARAMETER) {
					if (!ModernizedCProgram.Curl_checkheaders(conn, "Content-Type")) {
						result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "Content-Type: text/parameters\r\n");
						if (result) {
							return result;
						} 
					} 
				} 
				if (rtspreq == .RTSPREQ_ANNOUNCE) {
					if (!ModernizedCProgram.Curl_checkheaders(conn, "Content-Type")) {
						result = ModernizedCProgram.Curl_add_bufferf(req_buffer, "Content-Type: application/sdp\r\n");
						if (result) {
							return result;
						} 
					} 
				} 
				data.getState().setExpect100header(/* RTSP posts are simple/small */0);
			}  else if (rtspreq == .RTSPREQ_GET_PARAMETER) {
				data.getSet().setHttpreq(/* Check for an empty GET_PARAMETER (heartbeat) request */.HTTPREQ_HEAD);
				data.getSet().setOpt_no_body(1);
			} 
		} 
		data.getReq().setForbidchunk(/* RTSP never allows chunked transfer */1);
		result = ModernizedCProgram.Curl_add_buffer(req_buffer, "\r\n", /* Finish the request buffer */2);
		if (result) {
			return result;
		} 
		if (postsize > 0) {
			result = ModernizedCProgram.Curl_add_buffer(req_buffer, data.getSet().getPostfields(), (size_t)postsize);
			if (result) {
				return result;
			} 
		} 
		result = ModernizedCProgram.Curl_add_buffer_send(req_buffer, /* issue the request */conn, data.getInfo().getRequest_size(), 0, 0);
		if (result) {
			ModernizedCProgram.Curl_failf(data, "Failed sending RTSP request");
			return result;
		} 
		ModernizedCProgram.Curl_setup_transfer(data, 0, -1, 1, putsize ? 0 : -1);
		data.getState().getRtsp_next_client_CSeq()++;
		if (data.getReq().getWritebytecount()) {
			ModernizedCProgram.Curl_pgrsSetUploadCounter(data, data.getReq().getWritebytecount());
			if (ModernizedCProgram.Curl_pgrsUpdate(conn)) {
				result = .CURLE_ABORTED_BY_CALLBACK;
			} 
		} 
		return result;
	}
	public static  rtsp_rtp_readwrite(Object data, Object conn, Object nread, Object readmore) {
		SingleRequest k = data.getReq();
		rtsp_conn rtspc = (conn.getProto().getRtspc());
		/* moving pointer to rtp data */byte rtp;
		/* how much data left to parse in this round */ssize_t rtp_dataleft = new ssize_t();
		byte scratch;
		CURLcode result = new CURLcode();
		if (rtspc.getRtp_buf()) {
			byte newptr = ModernizedCProgram.Curl_saferealloc(rtspc.getRtp_buf(), rtspc.getRtp_bufsize() + nread);
			if (!newptr) {
				rtspc.setRtp_buf(((Object)0));
				rtspc.setRtp_bufsize(0);
				return .CURLE_OUT_OF_MEMORY;
			} 
			rtspc.setRtp_buf(newptr);
			.memcpy(rtspc.getRtp_buf() + rtspc.getRtp_bufsize(), k.getStr(), nread);
			rtspc.getRtp_bufsize() += nread;
			rtp = rtspc.getRtp_buf();
			rtp_dataleft = rtspc.getRtp_bufsize();
		} else {
				rtp = k.getStr();
				rtp_dataleft = nread;
		} 
		while ((rtp_dataleft > 0) && (rtp[0] == (byte)'$')) {
			if (rtp_dataleft > 4) {
				int rtp_length;
				rtspc.setRtp_channel(((int)((byte)((rtp)[/* Parse the header *//* The channel identifier immediately follows and is 1 byte */1]))));
				rtp_length = ((((int)((byte)((rtp)[2]))) << 8) | ((int)((byte)((rtp)[/* The length is two bytes */3]))));
				if (rtp_dataleft < rtp_length + 4) {
					readmore = /* Need more - incomplete payload*/1;
					break;
				} 
				do {
				} while (/* We have the full RTP interleaved packet
				       * Write out the header including the leading '$' */0);
				result = ModernizedCProgram.rtp_client_write(conn, rtp[0], rtp_length + 4);
				if (result) {
					ModernizedCProgram.Curl_failf(data, "Got an error writing an RTP packet");
					readmore = 0;
					do {
						.Curl_cfree((rtspc.getRtp_buf()));
						(rtspc.getRtp_buf()) = ((Object)0);
					} while (0);
					rtspc.setRtp_buf(((Object)0));
					rtspc.setRtp_bufsize(0);
					return result;
				} 
				rtp_dataleft -= rtp_length + /* Move forward in the buffer */4;
				rtp += rtp_length + 4;
				if (data.getSet().getRtspreq() == .RTSPREQ_RECEIVE/* If we are in a passive receive, give control back
				         * to the app as often as we can.
				         */) {
					k.getKeepon() &=  ~(1 << 0);
				} 
			} else {
					readmore = /* Need more - incomplete header */1;
					break;
			} 
		}
		if (rtp_dataleft != 0 && rtp[0] == (byte)'$') {
			do {
			} while (0);
			scratch = .Curl_cmalloc(/* Store the incomplete RTP packet for a "rewind" */rtp_dataleft);
			if (!scratch) {
				do {
					.Curl_cfree((rtspc.getRtp_buf()));
					(rtspc.getRtp_buf()) = ((Object)0);
				} while (0);
				rtspc.setRtp_buf(((Object)0));
				rtspc.setRtp_bufsize(0);
				return .CURLE_OUT_OF_MEMORY;
			} 
			.memcpy(scratch, rtp, rtp_dataleft);
			do {
				.Curl_cfree((rtspc.getRtp_buf()));
				(rtspc.getRtp_buf()) = ((Object)0);
			} while (0);
			rtspc.setRtp_buf(scratch);
			rtspc.setRtp_bufsize(rtp_dataleft);
			nread = /* As far as the transfer is concerned, this data is consumed */0;
			return .CURLE_OK;
		} 
		k.getStr() += nread - /* Fix up k->str to point just after the last RTP packet */rtp_dataleft/* either all of the data has been read or...
		   * rtp now points at the next byte to parse
		   */;
		if (rtp_dataleft > 0) {
			do {
			} while (0);
		} 
		do {
		} while (/* sanity check */0);
		nread = rtp_dataleft;
		do {
			.Curl_cfree((rtspc.getRtp_buf()));
			(rtspc.getRtp_buf()) = ((Object)0);
		} while (/* If we get here, we have finished with the leftover/merge buffer */0);
		rtspc.setRtp_buf(((Object)0));
		rtspc.setRtp_bufsize(0);
		return .CURLE_OK;
	}
	public static  rtp_client_write(Object conn, Object ptr, Object len) {
		Curl_easy data = conn.getData();
		size_t wrote = new size_t();
		curl_write_callback writeit = new curl_write_callback();
		Object user_ptr;
		if (len == 0) {
			ModernizedCProgram.Curl_failf(data, "Cannot write a 0 size RTP packet.");
			return .CURLE_WRITE_ERROR/* If the user has configured CURLOPT_INTERLEAVEFUNCTION then use that
			     function and any configured CURLOPT_INTERLEAVEDATA to write out the RTP
			     data. Otherwise, use the CURLOPT_WRITEFUNCTION with the CURLOPT_WRITEDATA
			     pointer to write out the RTP data. */;
		} 
		if (data.getSet().getFwrite_rtp()) {
			writeit = data.getSet().getFwrite_rtp();
			user_ptr = data.getSet().getRtp_out();
		} else {
				writeit = data.getSet().getFwrite_func();
				user_ptr = data.getSet().getOut();
		} 
		ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
		wrote = .writeit(ptr, 1, len, user_ptr);
		ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
		if (-1024 == wrote) {
			ModernizedCProgram.Curl_failf(data, "Cannot pause RTP");
			return .CURLE_WRITE_ERROR;
		} 
		if (wrote != len) {
			ModernizedCProgram.Curl_failf(data, "Failed writing RTP data");
			return .CURLE_WRITE_ERROR;
		} 
		return .CURLE_OK;
	}
	/*
	 * RTSP handler interface.
	 */
	public static  Curl_rtsp_parseheader(Object conn, Object header) {
		Curl_easy data = conn.getData();
		long CSeq = 0;
		if (ModernizedCProgram.curl_strnequal("CSeq:", header, .strlen("CSeq:"))) {
			int nc = .sscanf(header[4], ": %ld", /* Store the received CSeq. Match is verified in rtsp_done */CSeq);
			if (nc == 1) {
				RTSP rtsp = data.getReq().getProtop();
				rtsp.setCSeq_recv(/* mark the request */CSeq);
				data.getState().setRtsp_CSeq_recv(/* update the handle */CSeq);
			} else {
					ModernizedCProgram.Curl_failf(data, "Unable to read the CSeq header: [%s]", header);
					return .CURLE_RTSP_CSEQ_ERROR;
			} 
		}  else if (ModernizedCProgram.curl_strnequal("Session:", header, .strlen("Session:"))) {
			byte start;
			start = header + /* Find the first non-space letter */8;
			while (start && (ModernizedCProgram.Curl_isspace((int)((byte)start)))) {
				start++;
			}
			if (!start) {
				ModernizedCProgram.Curl_failf(data, "Got a blank Session ID");
			}  else if (data.getSet().getStr()[dupstring.STRING_RTSP_SESSION_ID]) {
				if (.strncmp(start, data.getSet().getStr()[/* If the Session ID is set, then compare */dupstring.STRING_RTSP_SESSION_ID], .strlen(data.getSet().getStr()[dupstring.STRING_RTSP_SESSION_ID])) != 0) {
					ModernizedCProgram.Curl_failf(data, "Got RTSP Session ID Line [%s], but wanted ID [%s]", start, data.getSet().getStr()[dupstring.STRING_RTSP_SESSION_ID]);
					return .CURLE_RTSP_SESSION_ERROR/* If the Session ID is not set, and we find it in a response, then set
					       * it.
					       *
					       * Allow any non whitespace content, up to the field separator or end of
					       * line. RFC 2326 isn't 100% clear on the session ID and for example
					       * gstreamer does url-encoded session ID's not covered by the standard.
					       */;
				} 
			} else {
					byte end = start;
					while (end && end != (byte)';' && !(ModernizedCProgram.Curl_isspace((int)((byte)end)))) {
						end++;
					}
					data.getSet().getStr()[dupstring.STRING_RTSP_SESSION_ID] = .Curl_cmalloc(end - start + /* Copy the id substring into a new buffer */1);
					if (data.getSet().getStr()[dupstring.STRING_RTSP_SESSION_ID] == ((Object)0)) {
						return .CURLE_OUT_OF_MEMORY;
					} 
					.memcpy(data.getSet().getStr()[dupstring.STRING_RTSP_SESSION_ID], start, end - start);
					(data.getSet().getStr()[dupstring.STRING_RTSP_SESSION_ID])[end - start] = (byte)'\0';
			} 
		} 
		return .CURLE_OK/* CURL_DISABLE_RTSP */;
	}
	/***********************************************************************
	 *
	 * imap_matchresp()
	 *
	 * Determines whether the untagged response is related to the specified
	 * command by checking if it is in format "* <command-name> ..." or
	 * "* <number> <command-name> ...".
	 *
	 * The "* " marker is assumed to have already been checked by the caller.
	 */
	public static  imap_matchresp(Object line, Object len, Object cmd) {
		byte end = line + len;
		size_t cmd_len = .strlen(cmd);
		line += /* Skip the untagged response marker */2;
		if (line < end && (ModernizedCProgram.Curl_isdigit((int)((byte)/* Do we have a number after the marker? */line/* Skip the number */)))) {
			do {
				line++;
			} while (line < end && (ModernizedCProgram.Curl_isdigit((int)((byte)line))));
			if (line == end || line != /* Do we have the space character? */(byte)' ') {
				return 0;
			} 
			line++;
		} 
		if (line + cmd_len <= end && ModernizedCProgram.Curl_strncasecompare(line, cmd, /* Does the command name match and is it followed by a space character or at
		     the end of line? */cmd_len) && (line[cmd_len] == (byte)' ' || line + cmd_len + 2 == end)) {
			return 1;
		} 
		return 0/***********************************************************************
		 *
		 * imap_endofresp()
		 *
		 * Checks whether the given string is a valid tagged, untagged or continuation
		 * response which can be processed by the response handler.
		 */;
	}
	public static  imap_endofresp(Object conn, Object line, Object len, Object resp) {
		IMAP imap = conn.getData().getReq().getProtop();
		imap_conn imapc = conn.getProto().getImapc();
		byte id = imapc.getResptag();
		size_t id_len = .strlen(id);
		if (len >= id_len + 1 && !.memcmp(id, line, id_len) && line[id_len] == /* Do we have a tagged command response? */(byte)' ') {
			line += id_len + 1;
			len -= id_len + 1;
			if (len >= 2 && !.memcmp(line, "OK", 2)) {
				resp = 1;
			}  else if (len >= 7 && !.memcmp(line, "PREAUTH", 7)) {
				resp = 3;
			} else {
					resp = 2;
			} 
			return 1;
		} 
		if (len >= 2 && !.memcmp("* ", line, /* Do we have an untagged command response? */2)) {
			switch (imapc.getState()) {
			case .IMAP_SEARCH:
					if (!ModernizedCProgram.imap_matchresp(line, len, "SEARCH")) {
						return 0;
					} 
					break;
			case .IMAP_FETCH:
					if (!ModernizedCProgram.imap_matchresp(line, len, "FETCH")) {
						return 0;
					} 
					break;
			case .IMAP_LIST:
					if ((!imap.getCustom() && !ModernizedCProgram.imap_matchresp(line, len, "LIST")) || (imap.getCustom() && !ModernizedCProgram.imap_matchresp(line, len, imap.getCustom()) && (!ModernizedCProgram.Curl_strcasecompare(imap.getCustom(), "STORE") || !ModernizedCProgram.imap_matchresp(line, len, "FETCH")) && !ModernizedCProgram.Curl_strcasecompare(imap.getCustom(), "SELECT") && !ModernizedCProgram.Curl_strcasecompare(imap.getCustom(), "EXAMINE") && !ModernizedCProgram.Curl_strcasecompare(imap.getCustom(), "SEARCH") && !ModernizedCProgram.Curl_strcasecompare(imap.getCustom(), "EXPUNGE") && !ModernizedCProgram.Curl_strcasecompare(imap.getCustom(), "LSUB") && !ModernizedCProgram.Curl_strcasecompare(imap.getCustom(), "UID") && !ModernizedCProgram.Curl_strcasecompare(imap.getCustom(), "NOOP"))) {
						return 0;
					} 
					break;
			case .IMAP_SELECT/* SELECT is special in that its untagged responses do not have a
			           common prefix so accept anything! */:
					break;
			case /* States which are interested in untagged responses */.IMAP_CAPABILITY:
					if (!ModernizedCProgram.imap_matchresp(line, len, "CAPABILITY")) {
						return 0;
					} 
					break;
			default:
					return 0;
			}
			resp = (byte)'*';
			return 1/* Do we have a continuation response? This should be a + symbol followed by
			     a space and optionally some text as per RFC-3501 for the AUTHENTICATE and
			     APPEND commands and as outlined in Section 4. Examples of RFC-4959 but
			     some e-mail servers ignore this and only send a single + instead. */;
		} 
		if (imap && !imap.getCustom() && ((len == 3 && line[0] == (byte)'+') || (len >= 2 && !.memcmp("+ ", line, 2)))) {
			switch (imapc.getState()) {
			case /* States which are interested in continuation responses */.IMAP_AUTHENTICATE:
			case .IMAP_APPEND:
					resp = (byte)'+';
					break;
			default:
					ModernizedCProgram.Curl_failf(conn.getData(), "Unexpected continuation response");
					resp = -1;
					break;
			}
			return 1;
		} 
		return /* Nothing for us */0/***********************************************************************
		 *
		 * imap_get_message()
		 *
		 * Gets the authentication message from the response buffer.
		 */;
	}
	public static void imap_get_message(Object buffer, Object outptr) {
		size_t len = .strlen(buffer);
		byte message = ((Object)0);
		if (len > 2) {
			len -= /* Find the start of the message */2;
			for (message = buffer + 2; message == (byte)' ' || message == (byte)'\t'; ) {
				;
			}
			for (; /* Find the end of the message */len--; ) {
				if (message[len] != (byte)'\r' && message[len] != (byte)'\n' && message[len] != (byte)' ' && message[len] != (byte)'\t') {
					break;
				} 
			}
			if (++/* Terminate the message */len) {
				message[len] = (byte)'\0';
			} 
		} else {
				message = buffer[/* junk input => zero length output */len];
		} 
		outptr = message/***********************************************************************
		 *
		 * state()
		 *
		 * This is the ONLY way to change IMAP state!
		 */;
	}
	/*
	 * IMAP protocol handler.
	 */
	public static  imap_perform_capability(Object conn) {
		CURLcode result = .CURLE_OK;
		imap_conn imapc = conn.getProto().getImapc();
		imapc.getSasl().setAuthmechs(/* No known auth. mechanisms yet */0);
		imapc.getSasl().setAuthused(/* Clear the auth. mechanism used */0);
		imapc.setTls_supported(/* Clear the TLS capability */0);
		result = ModernizedCProgram.imap_sendf(conn, /* Send the CAPABILITY command */"CAPABILITY");
		if (!result) {
			ModernizedCProgram.state(conn, .IMAP_CAPABILITY);
		} 
		return result/***********************************************************************
		 *
		 * imap_perform_starttls()
		 *
		 * Sends the STARTTLS command to start the upgrade to TLS.
		 */;
	}
	public static  imap_perform_starttls(Object conn) {
		CURLcode result = ModernizedCProgram.imap_sendf(conn, /* Send the STARTTLS command */"STARTTLS");
		if (!result) {
			ModernizedCProgram.state(conn, .IMAP_STARTTLS);
		} 
		return result/***********************************************************************
		 *
		 * imap_perform_upgrade_tls()
		 *
		 * Performs the upgrade to TLS.
		 */;
	}
	public static  imap_perform_upgrade_tls(Object conn) {
		imap_conn imapc = conn.getProto().getImapc();
		CURLcode result = .CURLE_NOT_BUILT_IN;
		if (!result) {
			if (imapc.getState() != .IMAP_UPGRADETLS) {
				ModernizedCProgram.state(conn, .IMAP_UPGRADETLS);
			} 
			if (imapc.getSsldone()) {
				do {
				} while (0);
				result = ModernizedCProgram.imap_perform_capability(conn);
			} 
		} 
		return result/***********************************************************************
		 *
		 * imap_perform_login()
		 *
		 * Sends a clear text LOGIN command to authenticate with.
		 */;
	}
	public static  imap_perform_login(Object conn) {
		CURLcode result = .CURLE_OK;
		byte user;
		byte passwd;
		if (!conn.getBits().getUser_passwd()) {
			ModernizedCProgram.state(conn, .IMAP_STOP);
			return result;
		} 
		user = ModernizedCProgram.imap_atom(conn.getUser(), /* Make sure the username and password are in the correct atom format */.bool_false);
		passwd = ModernizedCProgram.imap_atom(conn.getPasswd(), .bool_false);
		result = ModernizedCProgram.imap_sendf(conn, "LOGIN %s %s", user ? user : /* Send the LOGIN command */"", passwd ? passwd : "");
		.Curl_cfree(user);
		.Curl_cfree(passwd);
		if (!result) {
			ModernizedCProgram.state(conn, .IMAP_LOGIN);
		} 
		return result/***********************************************************************
		 *
		 * imap_perform_authenticate()
		 *
		 * Sends an AUTHENTICATE command allowing the client to login with the given
		 * SASL authentication mechanism.
		 */;
	}
	public static  imap_perform_authenticate(Object conn, Object mech, Object initresp) {
		CURLcode result = .CURLE_OK;
		if (initresp) {
			result = ModernizedCProgram.imap_sendf(conn, "AUTHENTICATE %s %s", mech, /* Send the AUTHENTICATE command with the initial response */initresp);
		} else {
				result = ModernizedCProgram.imap_sendf(conn, "AUTHENTICATE %s", /* Send the AUTHENTICATE command */mech);
		} 
		return result/***********************************************************************
		 *
		 * imap_continue_authenticate()
		 *
		 * Sends SASL continuation data or cancellation.
		 */;
	}
	public static  imap_continue_authenticate(Object conn, Object resp) {
		imap_conn imapc = conn.getProto().getImapc();
		return ModernizedCProgram.Curl_pp_sendf(imapc.getPp(), "%s", resp/***********************************************************************
		 *
		 * imap_perform_authentication()
		 *
		 * Initiates the authentication sequence, with the appropriate SASL
		 * authentication mechanism, falling back to clear text should a common
		 * mechanism not be available between the client and server.
		 */);
	}
	public static  imap_perform_authentication(Object conn) {
		CURLcode result = .CURLE_OK;
		imap_conn imapc = conn.getProto().getImapc();
		saslprogress progress = new saslprogress();
		if (imapc.getPreauth() || !ModernizedCProgram.Curl_sasl_can_authenticate(imapc.getSasl(), conn)) {
			ModernizedCProgram.state(conn, .IMAP_STOP);
			return result;
		} 
		result = ModernizedCProgram.Curl_sasl_start(imapc.getSasl(), conn, imapc.getIr_supported(), /* Calculate the SASL login details */progress);
		if (!result) {
			if (progress == .SASL_INPROGRESS) {
				ModernizedCProgram.state(conn, .IMAP_AUTHENTICATE);
			}  else if (!imapc.getLogin_disabled() && (imapc.getPreftype() & (1 << 0))) {
				result = ModernizedCProgram.imap_perform_login(/* Perform clear text authentication */conn);
			} else {
					ModernizedCProgram.Curl_infof(conn.getData(), /* Other mechanisms not supported */"No known authentication mechanisms supported!\n");
					result = .CURLE_LOGIN_DENIED;
			} 
		} 
		return result/***********************************************************************
		 *
		 * imap_perform_list()
		 *
		 * Sends a LIST command or an alternative custom request.
		 */;
	}
	public static  imap_perform_list(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		IMAP imap = data.getReq().getProtop();
		if (imap.getCustom()) {
			result = ModernizedCProgram.imap_sendf(conn, "%s%s", imap.getCustom(), imap.getCustom_params() ? imap.getCustom_params() : "");
		} else {
				byte mailbox = imap.getMailbox() ? ModernizedCProgram.imap_atom(imap.getMailbox(), /* Make sure the mailbox is in the correct atom format if necessary */.bool_true) : .Curl_cstrdup("");
				if (!mailbox) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				result = ModernizedCProgram.imap_sendf(conn, "LIST \"%s\" *", /* Send the LIST command */mailbox);
				.Curl_cfree(mailbox);
		} 
		if (!result) {
			ModernizedCProgram.state(conn, .IMAP_LIST);
		} 
		return result/***********************************************************************
		 *
		 * imap_perform_select()
		 *
		 * Sends a SELECT command to ask the server to change the selected mailbox.
		 */;
	}
	public static  imap_perform_select(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		IMAP imap = data.getReq().getProtop();
		imap_conn imapc = conn.getProto().getImapc();
		byte mailbox;
		do {
			.Curl_cfree((imapc.getMailbox()));
			(imapc.getMailbox()) = ((Object)0);
		} while (/* Invalidate old information as we are switching mailboxes */0);
		do {
			.Curl_cfree((imapc.getMailbox_uidvalidity()));
			(imapc.getMailbox_uidvalidity()) = ((Object)0);
		} while (0);
		if (!imap.getMailbox()) {
			ModernizedCProgram.Curl_failf(conn.getData(), "Cannot SELECT without a mailbox.");
			return .CURLE_URL_MALFORMAT;
		} 
		mailbox = ModernizedCProgram.imap_atom(imap.getMailbox(), /* Make sure the mailbox is in the correct atom format */.bool_false);
		if (!mailbox) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		result = ModernizedCProgram.imap_sendf(conn, "SELECT %s", /* Send the SELECT command */mailbox);
		.Curl_cfree(mailbox);
		if (!result) {
			ModernizedCProgram.state(conn, .IMAP_SELECT);
		} 
		return result/***********************************************************************
		 *
		 * imap_perform_fetch()
		 *
		 * Sends a FETCH command to initiate the download of a message.
		 */;
	}
	public static  imap_perform_fetch(Object conn) {
		CURLcode result = .CURLE_OK;
		IMAP imap = conn.getData().getReq().getProtop();
		if (imap.getUid()) {
			if (imap.getPartial()) {
				result = ModernizedCProgram.imap_sendf(conn, "UID FETCH %s BODY[%s]<%s>", imap.getUid(), imap.getSection() ? imap.getSection() : "", imap.getPartial());
			} else {
					result = ModernizedCProgram.imap_sendf(conn, "UID FETCH %s BODY[%s]", imap.getUid(), imap.getSection() ? imap.getSection() : "");
			} 
		}  else if (imap.getMindex()) {
			if (imap.getPartial()) {
				result = ModernizedCProgram.imap_sendf(conn, "FETCH %s BODY[%s]<%s>", imap.getMindex(), imap.getSection() ? imap.getSection() : "", imap.getPartial());
			} else {
					result = ModernizedCProgram.imap_sendf(conn, "FETCH %s BODY[%s]", imap.getMindex(), imap.getSection() ? imap.getSection() : "");
			} 
		} else {
				ModernizedCProgram.Curl_failf(conn.getData(), "Cannot FETCH without a UID.");
				return .CURLE_URL_MALFORMAT;
		} 
		if (!result) {
			ModernizedCProgram.state(conn, .IMAP_FETCH);
		} 
		return result/***********************************************************************
		 *
		 * imap_perform_append()
		 *
		 * Sends an APPEND command to initiate the upload of a message.
		 */;
	}
	public static  imap_perform_append(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		IMAP imap = data.getReq().getProtop();
		byte mailbox;
		if (!imap.getMailbox()) {
			ModernizedCProgram.Curl_failf(data, "Cannot APPEND without a mailbox.");
			return .CURLE_URL_MALFORMAT;
		} 
		if (data.getSet().getMimepost().getKind() != /* Prepare the mime data if some. */mimekind.MIMEKIND_NONE) {
			data.getSet().getMimepost().getFlags() &=  ~(1 << /* Use the whole structure as data. */1);
			ModernizedCProgram.curl_mime_headers(data.getSet().getMimepost(), data.getSet().getHeaders(), /* Add external headers and mime version. */0);
			result = ModernizedCProgram.Curl_mime_prepare_headers(data.getSet().getMimepost(), ((Object)0), ((Object)0), mimestrategy.MIMESTRATEGY_MAIL);
			if (!result) {
				if (!ModernizedCProgram.Curl_checkheaders(conn, "Mime-Version")) {
					result = ModernizedCProgram.Curl_mime_add_header(data.getSet().getMimepost().getCurlheaders(), "Mime-Version: 1.0");
				} 
			} 
			if (!/* Make sure we will read the entire mime structure. */result) {
				result = ModernizedCProgram.Curl_mime_rewind(data.getSet().getMimepost());
			} 
			if (result) {
				return result;
			} 
			data.getState().setInfilesize(ModernizedCProgram.Curl_mime_size(data.getSet().getMimepost()));
			data.getState().setFread_func((curl_read_callback)/* Read from mime structure. */ModernizedCProgram.Curl_mime_read);
			data.getState().setIn((Object)data.getSet().getMimepost());
		} 
		if (data.getState().getInfilesize() < /* Check we know the size of the upload */0) {
			ModernizedCProgram.Curl_failf(data, "Cannot APPEND with unknown input file size\n");
			return .CURLE_UPLOAD_FAILED;
		} 
		mailbox = ModernizedCProgram.imap_atom(imap.getMailbox(), /* Make sure the mailbox is in the correct atom format */.bool_false);
		if (!mailbox) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		result = ModernizedCProgram.imap_sendf(conn, /* Send the APPEND command */"APPEND %s (\\Seen) {%I64d}", mailbox, data.getState().getInfilesize());
		.Curl_cfree(mailbox);
		if (!result) {
			ModernizedCProgram.state(conn, .IMAP_APPEND);
		} 
		return result/***********************************************************************
		 *
		 * imap_perform_search()
		 *
		 * Sends a SEARCH command.
		 */;
	}
	public static  imap_perform_search(Object conn) {
		CURLcode result = .CURLE_OK;
		IMAP imap = conn.getData().getReq().getProtop();
		if (!imap.getQuery()) {
			ModernizedCProgram.Curl_failf(conn.getData(), "Cannot SEARCH without a query string.");
			return .CURLE_URL_MALFORMAT;
		} 
		result = ModernizedCProgram.imap_sendf(conn, "SEARCH %s", imap.getQuery());
		if (!result) {
			ModernizedCProgram.state(conn, .IMAP_SEARCH);
		} 
		return result/***********************************************************************
		 *
		 * imap_perform_logout()
		 *
		 * Performs the logout action prior to sclose() being called.
		 */;
	}
	public static  imap_perform_logout(Object conn) {
		CURLcode result = ModernizedCProgram.imap_sendf(conn, /* Send the LOGOUT command */"LOGOUT");
		if (!result) {
			ModernizedCProgram.state(conn, .IMAP_LOGOUT);
		} 
		return result;
	}
	/* For the initial server greeting */
	public static  imap_state_servergreet_resp(Object conn, int imapcode,  instate) {
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (imapcode == 3) {
			imap_conn imapc = conn.getProto().getImapc();
			imapc.setPreauth(1);
			ModernizedCProgram.Curl_infof(data, "PREAUTH connection, already authenticated!\n");
		}  else if (imapcode != 1) {
			ModernizedCProgram.Curl_failf(data, "Got unexpected imap-server response");
			return .CURLE_WEIRD_SERVER_REPLY;
		} 
		return ModernizedCProgram.imap_perform_capability(conn);
	}
	/* For CAPABILITY responses */
	public static  imap_state_capability_resp(Object conn, int imapcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		imap_conn imapc = conn.getProto().getImapc();
		byte line = data.getState().getBuffer();
		(Object)/* no use for this yet */instate;
		if (imapcode == /* Do we have a untagged response? */(byte)'*') {
			line += 2;
			for (; ; ) {
				size_t wordlen = new size_t();
				while (line && (line == (byte)' ' || line == (byte)'\t' || line == (byte)'\r' || line == (byte)'\n')) {
					line++;
				}
				if (!line) {
					break;
				} 
				for (wordlen = 0; line[wordlen] && line[wordlen] != /* Extract the word */(byte)' ' && line[wordlen] != (byte)'\t' && line[wordlen] != (byte)'\r' && line[wordlen] != (byte)'\n'; ) {
					wordlen++;
				}
				if (wordlen == 8 && !.memcmp(line, "STARTTLS", /* Does the server support the STARTTLS capability? */8)) {
					imapc.setTls_supported(1);
				}  else if (wordlen == 13 && !.memcmp(line, "LOGINDISABLED", /* Has the server explicitly disabled clear text authentication? */13)) {
					imapc.setLogin_disabled(1);
				}  else if (wordlen == 7 && !.memcmp(line, "SASL-IR", /* Does the server support the SASL-IR capability? */7)) {
					imapc.setIr_supported(1);
				}  else if (wordlen > 5 && !.memcmp(line, "AUTH=", /* Do we have a SASL based authentication mechanism? */5)) {
					size_t llen = new size_t();
					int mechbit;
					line += 5;
					wordlen -= 5;
					mechbit = ModernizedCProgram.Curl_sasl_decode_mech(line, wordlen, /* Test the word for a matching authentication mechanism */llen);
					if (mechbit && llen == wordlen) {
						imapc.getSasl().getAuthmechs() |=  mechbit;
					} 
				} 
				line += wordlen;
			}
		}  else if (imapcode == 1) {
			if (data.getSet().getUse_ssl() && !conn.getSsl()[0].getUse()) {
				if (imapc.getTls_supported()) {
					result = ModernizedCProgram.imap_perform_starttls(/* Switch to TLS connection now */conn);
				}  else if (data.getSet().getUse_ssl() == .CURLUSESSL_TRY) {
					result = ModernizedCProgram.imap_perform_authentication(/* Fallback and carry on with authentication */conn);
				} else {
						ModernizedCProgram.Curl_failf(data, "STARTTLS not supported.");
						result = .CURLE_USE_SSL_FAILED;
				} 
			} else {
					result = ModernizedCProgram.imap_perform_authentication(conn);
			} 
		} else {
				result = ModernizedCProgram.imap_perform_authentication(conn);
		} 
		return result;
	}
	/* For STARTTLS responses */
	public static  imap_state_starttls_resp(Object conn, int imapcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (imapcode != 1) {
			if (data.getSet().getUse_ssl() != .CURLUSESSL_TRY) {
				ModernizedCProgram.Curl_failf(data, "STARTTLS denied");
				result = .CURLE_USE_SSL_FAILED;
			} else {
					result = ModernizedCProgram.imap_perform_authentication(conn);
			} 
		} else {
				result = ModernizedCProgram.imap_perform_upgrade_tls(conn);
		} 
		return result;
	}
	/* For SASL authentication responses */
	public static  imap_state_auth_resp(Object conn, int imapcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		imap_conn imapc = conn.getProto().getImapc();
		saslprogress progress = new saslprogress();
		(Object)/* no use for this yet */instate;
		result = ModernizedCProgram.Curl_sasl_continue(imapc.getSasl(), conn, imapcode, progress);
		if (!result) {
			switch (progress) {
			case .SASL_DONE:
					ModernizedCProgram.state(conn, /* Authenticated */.IMAP_STOP);
					break;
			case /* No mechanism left after cancellation */.SASL_IDLE:
					if ((!imapc.getLogin_disabled()) && (imapc.getPreftype() & (1 << 0))) {
						result = ModernizedCProgram.imap_perform_login(/* Perform clear text authentication */conn);
					} else {
							ModernizedCProgram.Curl_failf(data, "Authentication cancelled");
							result = .CURLE_LOGIN_DENIED;
					} 
					break;
			default:
					break;
			}
		} 
		return result;
	}
	/* For LOGIN responses */
	public static  imap_state_login_resp(Object conn, int imapcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* no use for this yet */instate;
		if (imapcode != 1) {
			ModernizedCProgram.Curl_failf(data, "Access denied. %c", imapcode);
			result = .CURLE_LOGIN_DENIED;
		} else {
				ModernizedCProgram.state(conn, /* End of connect phase */.IMAP_STOP);
		} 
		return result;
	}
	/* For LIST and SEARCH responses */
	public static  imap_state_listsearch_resp(Object conn, int imapcode,  instate) {
		CURLcode result = .CURLE_OK;
		byte line = conn.getData().getState().getBuffer();
		size_t len = .strlen(line);
		(Object)/* No use for this yet */instate;
		if (imapcode == (byte)'*') {
			line[len] = /* Temporarily add the LF character back and send as body to the client */(byte)'\n';
			result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), line, len + 1);
			line[len] = (byte)'\0';
		}  else if (imapcode != 1) {
			result = .CURLE_QUOTE_ERROR;
		} else {
				ModernizedCProgram.state(conn, /* End of DO phase */.IMAP_STOP);
		} 
		return result;
	}
	/* For SELECT responses */
	public static  imap_state_select_resp(Object conn, int imapcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		IMAP imap = conn.getData().getReq().getProtop();
		imap_conn imapc = conn.getProto().getImapc();
		byte line = data.getState().getBuffer();
		(Object)/* no use for this yet */instate;
		if (imapcode == (byte)'*') {
			byte[] tmp = new byte[/* See if this is an UIDVALIDITY response */20];
			if (.sscanf(line + 2, "OK [UIDVALIDITY %19[0123456789]]", tmp) == 1) {
				do {
					.Curl_cfree((imapc.getMailbox_uidvalidity()));
					(imapc.getMailbox_uidvalidity()) = ((Object)0);
				} while (0);
				imapc.setMailbox_uidvalidity(.Curl_cstrdup(tmp));
			} 
		}  else if (imapcode == 1) {
			if (imap.getUidvalidity() && imapc.getMailbox_uidvalidity() && !ModernizedCProgram.Curl_strcasecompare(imap.getUidvalidity(), imapc.getMailbox_uidvalidity())) {
				ModernizedCProgram.Curl_failf(conn.getData(), "Mailbox UIDVALIDITY has changed");
				result = .CURLE_REMOTE_FILE_NOT_FOUND;
			} else {
					imapc.setMailbox(.Curl_cstrdup(imap.getMailbox()));
					if (imap.getCustom()) {
						result = ModernizedCProgram.imap_perform_list(conn);
					}  else if (imap.getQuery()) {
						result = ModernizedCProgram.imap_perform_search(conn);
					} else {
							result = ModernizedCProgram.imap_perform_fetch(conn);
					} 
			} 
		} else {
				ModernizedCProgram.Curl_failf(data, "Select failed");
				result = .CURLE_LOGIN_DENIED;
		} 
		return result;
	}
	/* For the (first line of the) FETCH responses */
	public static  imap_state_fetch_resp(Object conn, int imapcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		imap_conn imapc = conn.getProto().getImapc();
		pingpong pp = imapc.getPp();
		byte ptr = data.getState().getBuffer();
		bool parsed = 0;
		curl_off_t size = 0;
		(Object)/* no use for this yet */instate;
		if (imapcode != (byte)'*') {
			ModernizedCProgram.Curl_pgrsSetDownloadSize(data, -1);
			ModernizedCProgram.state(conn, .IMAP_STOP);
			return .CURLE_REMOTE_FILE_NOT_FOUND;
		} 
		while (ptr && (ptr != /* Something like this is received "* 1 FETCH (BODY[TEXT] {2021}\r" so parse
		     the continuation data contained within the curly brackets */(byte)'{')) {
			ptr++;
		}
		if (ptr == (byte)'{') {
			byte endptr;
			if (!ModernizedCProgram.curlx_strtoofft(ptr + 1, endptr, 10, size)) {
				if (endptr - ptr > 1 && endptr[0] == (byte)'}' && endptr[1] == (byte)'\r' && endptr[2] == (byte)'\0') {
					parsed = 1;
				} 
			} 
		} 
		if (parsed) {
			ModernizedCProgram.Curl_infof(data, "Found %I64d bytes to download\n", size);
			ModernizedCProgram.Curl_pgrsSetDownloadSize(data, size);
			if (pp.getCache()) {
				size_t chunk = pp.getCache_size();
				if (chunk > (size_t)size) {
					chunk = (size_t)/* The conversion from curl_off_t to size_t is always fine here */size;
				} 
				if (!chunk) {
					ModernizedCProgram.state(conn, /* no size, we're done with the data */.IMAP_STOP);
					return .CURLE_OK;
				} 
				result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), pp.getCache(), chunk);
				if (result) {
					return result;
				} 
				data.getReq().getBytecount() += chunk;
				ModernizedCProgram.Curl_infof(data, "Written %zu bytes, %I64u bytes are left for transfer\n", chunk, size - chunk);
				if (pp.getCache_size() > /* Have we used the entire cache or just part of it?*/chunk) {
					.memmove(pp.getCache(), pp.getCache() + chunk, pp.getCache_size() - /* Only part of it so shrink the cache to fit the trailing data */chunk);
					pp.getCache_size() -= chunk;
				} else {
						do {
							.Curl_cfree((pp.getCache()));
							(pp.getCache()) = ((Object)0);
						} while (/* Free the cache */0);
						pp.setCache_size(/* Reset the cache size */0);
				} 
			} 
			if (data.getReq().getBytecount() == size) {
				ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, -/* The entire data is already transferred! */1);
			} else {
					data.getReq().setMaxdownload(/* IMAP download */size);
					ModernizedCProgram.Curl_setup_transfer(data, 0, size, 0, -1);
			} 
		} else {
				ModernizedCProgram.Curl_failf(pp.getConn().getData(), /* We don't know how to parse this line */"Failed to parse FETCH response.");
				result = .CURLE_WEIRD_SERVER_REPLY;
		} 
		ModernizedCProgram.state(conn, /* End of DO phase */.IMAP_STOP);
		return result;
	}
	/* For final FETCH responses performed after the download */
	public static  imap_state_fetch_final_resp(Object conn, int imapcode,  instate) {
		CURLcode result = .CURLE_OK;
		(Object)/* No use for this yet */instate;
		if (imapcode != 1) {
			result = .CURLE_WEIRD_SERVER_REPLY;
		} else {
				ModernizedCProgram.state(conn, /* End of DONE phase */.IMAP_STOP);
		} 
		return result;
	}
	/* For APPEND responses */
	public static  imap_state_append_resp(Object conn, int imapcode,  instate) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		(Object)/* No use for this yet */instate;
		if (imapcode != (byte)'+') {
			result = .CURLE_UPLOAD_FAILED;
		} else {
				ModernizedCProgram.Curl_pgrsSetUploadSize(data, data.getState().getInfilesize());
				ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, /* IMAP upload */0);
				ModernizedCProgram.state(conn, /* End of DO phase */.IMAP_STOP);
		} 
		return result;
	}
	/* For final APPEND responses performed after the upload */
	public static  imap_state_append_final_resp(Object conn, int imapcode,  instate) {
		CURLcode result = .CURLE_OK;
		(Object)/* No use for this yet */instate;
		if (imapcode != 1) {
			result = .CURLE_UPLOAD_FAILED;
		} else {
				ModernizedCProgram.state(conn, /* End of DONE phase */.IMAP_STOP);
		} 
		return result;
	}
	public static  imap_statemach_act(Object conn) {
		CURLcode result = .CURLE_OK;
		curl_socket_t sock = conn.getSock()[0];
		int imapcode;
		imap_conn imapc = conn.getProto().getImapc();
		pingpong pp = imapc.getPp();
		size_t nread = 0;
		if (imapc.getState() == /* Busy upgrading the connection; right now all I/O is SSL/TLS, not IMAP */.IMAP_UPGRADETLS) {
			return ModernizedCProgram.imap_perform_upgrade_tls(conn);
		} 
		if (pp.getSendleft()) {
			return ModernizedCProgram.Curl_pp_flushsend(pp);
		} 
		do {
			result = ModernizedCProgram.Curl_pp_readresp(sock, pp, imapcode, /* Read the response from the server */nread);
			if (result) {
				return result;
			} 
			if (imapcode == -/* Was there an error parsing the response line? */1) {
				return .CURLE_WEIRD_SERVER_REPLY;
			} 
			if (!imapcode) {
				break;
			} 
			switch (imapc.getState()) {
			case .IMAP_CAPABILITY:
					result = ModernizedCProgram.imap_state_capability_resp(conn, imapcode, imapc.getState());
					break;
			case .IMAP_STARTTLS:
					result = ModernizedCProgram.imap_state_starttls_resp(conn, imapcode, imapc.getState());
					break;
			case .IMAP_SERVERGREET:
					result = ModernizedCProgram.imap_state_servergreet_resp(conn, imapcode, imapc.getState());
					break;
			case .IMAP_SELECT:
					result = ModernizedCProgram.imap_state_select_resp(conn, imapcode, imapc.getState());
					break;
			case .IMAP_LOGOUT/* fallthrough, just stop! */:
			case .IMAP_AUTHENTICATE:
					result = ModernizedCProgram.imap_state_auth_resp(conn, imapcode, imapc.getState());
					break;
			case .IMAP_APPEND:
					result = ModernizedCProgram.imap_state_append_resp(conn, imapcode, imapc.getState());
					break;
			case .IMAP_APPEND_FINAL:
					result = ModernizedCProgram.imap_state_append_final_resp(conn, imapcode, imapc.getState());
					break;
			case .IMAP_FETCH:
					result = ModernizedCProgram.imap_state_fetch_resp(conn, imapcode, imapc.getState());
					break;
			case .IMAP_LIST:
			case .IMAP_LOGIN:
					result = ModernizedCProgram.imap_state_login_resp(conn, imapcode, imapc.getState());
					break;
			case .IMAP_SEARCH:
					result = ModernizedCProgram.imap_state_listsearch_resp(conn, imapcode, imapc.getState());
					break;
			case .IMAP_FETCH_FINAL:
					result = ModernizedCProgram.imap_state_fetch_final_resp(conn, imapcode, imapc.getState());
					break;
			default:
					ModernizedCProgram.state(conn, /* internal error */.IMAP_STOP);
					break;
			}
		} while (!result && imapc.getState() != .IMAP_STOP && ModernizedCProgram.Curl_pp_moredata(pp));
		return result;
	}
	/* Called repeatedly until done from multi.c */
	public static  imap_multi_statemach(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		imap_conn imapc = conn.getProto().getImapc();
		if ((conn.getHandler().getFlags() & (1 << 0)) && !imapc.getSsldone()) {
			result = .CURLE_NOT_BUILT_IN;
			if (result || !imapc.getSsldone()) {
				return result;
			} 
		} 
		result = ModernizedCProgram.Curl_pp_statemach(imapc.getPp(), 0, 0);
		done = (imapc.getState() == .IMAP_STOP) ? 1 : 0;
		return result;
	}
	public static  imap_block_statemach(Object conn,  disconnecting) {
		CURLcode result = .CURLE_OK;
		imap_conn imapc = conn.getProto().getImapc();
		while (imapc.getState() != .IMAP_STOP && !result) {
			result = ModernizedCProgram.Curl_pp_statemach(imapc.getPp(), 1, disconnecting);
		}
		return result;
	}
	/* Allocate and initialize the struct IMAP for the current Curl_easy if
	   required */
	public static  imap_init(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		IMAP imap = new IMAP();
		imap = data.getReq().setProtop(.Curl_ccalloc(, 1));
		if (!imap) {
			result = .CURLE_OUT_OF_MEMORY;
		} 
		return result;
	}
	/* For the IMAP "protocol connect" and "doing" phases only */
	public static int imap_getsock(Object conn, Object socks) {
		return ModernizedCProgram.Curl_pp_getsock(conn.getProto().getImapc().getPp(), socks/***********************************************************************
		 *
		 * imap_connect()
		 *
		 * This function should do everything that is to be considered a part of the
		 * connection phase.
		 *
		 * The variable 'done' points to will be TRUE if the protocol-layer connect
		 * phase is done when this function returns, or FALSE if not.
		 */);
	}
	public static  imap_connect(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		imap_conn imapc = conn.getProto().getImapc();
		pingpong pp = imapc.getPp();
		done = /* default to not done yet */0;
		ModernizedCProgram.Curl_conncontrol(conn, /* We always support persistent connections in IMAP */0);
		pp.setResponse_time((120 * /* Set the default response time-out */1000));
		pp.setStatemach_act(imap_statemach_act);
		pp.setEndofresp(imap_endofresp);
		pp.setConn(conn);
		imapc.setPreftype(~/* Set the default preferred authentication type and mechanism */-1024);
		ModernizedCProgram.Curl_sasl_init(imapc.getSasl(), ModernizedCProgram.saslimap);
		ModernizedCProgram.Curl_pp_init(/* Initialise the pingpong layer */pp);
		result = ModernizedCProgram.imap_parse_url_options(/* Parse the URL options */conn);
		if (result) {
			return result;
		} 
		ModernizedCProgram.state(conn, /* Start off waiting for the server greeting response */.IMAP_SERVERGREET);
		.strcpy(imapc.getResptag(), /* Start off with an response id of '*' */"*");
		result = ModernizedCProgram.imap_multi_statemach(conn, done);
		return result/***********************************************************************
		 *
		 * imap_done()
		 *
		 * The DONE function. This does what needs to be done after a single DO has
		 * performed.
		 *
		 * Input argument is already checked for validity.
		 */;
	}
	public static  imap_done(Object conn,  status,  premature) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		IMAP imap = data.getReq().getProtop();
		(Object)premature;
		if (!imap) {
			return .CURLE_OK;
		} 
		if (status) {
			ModernizedCProgram.Curl_conncontrol(conn, /* marked for closure */1);
			result = /* use the already set error code */status;
		}  else if (!data.getSet().getConnect_only() && !imap.getCustom() && (imap.getUid() || imap.getMindex() || data.getSet().getUpload() || data.getSet().getMimepost().getKind() != mimekind.MIMEKIND_NONE/* Handle responses after FETCH or APPEND transfer has finished */)) {
			if (!data.getSet().getUpload() && data.getSet().getMimepost().getKind() == mimekind.MIMEKIND_NONE) {
				ModernizedCProgram.state(conn, .IMAP_FETCH_FINAL);
			} else {
					result = ModernizedCProgram.Curl_pp_sendf(conn.getProto().getImapc().getPp(), "%s", /* End the APPEND command first by sending an empty line */"");
					if (!result) {
						ModernizedCProgram.state(conn, .IMAP_APPEND_FINAL);
					} 
			} 
			if (!/* Run the state-machine */result) {
				result = ModernizedCProgram.imap_block_statemach(conn, 0);
			} 
		} 
		do {
			.Curl_cfree((imap.getMailbox()));
			(imap.getMailbox()) = ((Object)0);
		} while (/* Cleanup our per-request based variables */0);
		do {
			.Curl_cfree((imap.getUidvalidity()));
			(imap.getUidvalidity()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((imap.getUid()));
			(imap.getUid()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((imap.getMindex()));
			(imap.getMindex()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((imap.getSection()));
			(imap.getSection()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((imap.getPartial()));
			(imap.getPartial()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((imap.getQuery()));
			(imap.getQuery()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((imap.getCustom()));
			(imap.getCustom()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((imap.getCustom_params()));
			(imap.getCustom_params()) = ((Object)0);
		} while (0);
		imap.setTransfer(/* Clear the transfer mode for the next request */.FTPTRANSFER_BODY);
		return result/***********************************************************************
		 *
		 * imap_perform()
		 *
		 * This is the actual DO function for IMAP. Fetch or append a message, or do
		 * other things according to the options previously setup.
		 */;
	}
	public static  imap_perform(Object conn, Object connected, Object dophase_done) {
		CURLcode result = /* This is IMAP and no proxy */.CURLE_OK;
		Curl_easy data = conn.getData();
		IMAP imap = data.getReq().getProtop();
		imap_conn imapc = conn.getProto().getImapc();
		bool selected = 0;
		do {
		} while (0);
		if (conn.getData().getSet().getOpt_no_body()) {
			imap.setTransfer(/* Requested no body means no transfer */.FTPTRANSFER_INFO);
		} 
		dophase_done = /* not done yet */0;
		if (imap.getMailbox() && imapc.getMailbox() && ModernizedCProgram.Curl_strcasecompare(imap.getMailbox(), imapc.getMailbox()) && (!imap.getUidvalidity() || !imapc.getMailbox_uidvalidity() || ModernizedCProgram.Curl_strcasecompare(imap.getUidvalidity(), imapc.getMailbox_uidvalidity()))) {
			selected = 1;
		} 
		if (conn.getData().getSet().getUpload() || data.getSet().getMimepost().getKind() != /* Start the first command in the DO phase */mimekind.MIMEKIND_NONE) {
			result = ModernizedCProgram.imap_perform_append(/* APPEND can be executed directly */conn);
		}  else if (imap.getCustom() && (selected || !imap.getMailbox())) {
			result = ModernizedCProgram.imap_perform_list(/* Custom command using the same mailbox or no mailbox */conn);
		}  else if (!imap.getCustom() && selected && (imap.getUid() || imap.getMindex())) {
			result = ModernizedCProgram.imap_perform_fetch(/* FETCH from the same mailbox */conn);
		}  else if (!imap.getCustom() && selected && imap.getQuery()) {
			result = ModernizedCProgram.imap_perform_search(/* SEARCH the current mailbox */conn);
		}  else if (imap.getMailbox() && !selected && (imap.getCustom() || imap.getUid() || imap.getMindex() || imap.getQuery())) {
			result = ModernizedCProgram.imap_perform_select(/* SELECT the mailbox */conn);
		} else {
				result = ModernizedCProgram.imap_perform_list(/* LIST */conn);
		} 
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.imap_multi_statemach(conn, /* Run the state-machine */dophase_done);
		connected = conn.getBits().getTcpconnect()[0];
		if (dophase_done) {
			do {
			} while (0);
		} 
		return result/***********************************************************************
		 *
		 * imap_do()
		 *
		 * This function is registered as 'curl_do' function. It decodes the path
		 * parts etc as a wrapper to the actual DO function (imap_perform).
		 *
		 * The input argument is already checked for validity.
		 */;
	}
	public static  imap_do(Object conn, Object done) {
		CURLcode result = .CURLE_OK;
		done = /* default to false */0;
		result = ModernizedCProgram.imap_parse_url_path(/* Parse the URL path */conn);
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.imap_parse_custom_request(/* Parse the custom request */conn);
		if (result) {
			return result;
		} 
		result = ModernizedCProgram.imap_regular_transfer(conn, done);
		return result/***********************************************************************
		 *
		 * imap_disconnect()
		 *
		 * Disconnect from an IMAP server. Cleanup protocol-specific per-connection
		 * resources. BLOCKING.
		 */;
	}
	public static  imap_disconnect(Object conn,  dead_connection) {
		imap_conn imapc = conn.getProto().getImapc();
		if (!dead_connection && imapc.getPp().getConn() && imapc.getPp().getConn().getBits().getProtoconnstart()) {
			if (!ModernizedCProgram.imap_perform_logout(conn)) {
				(Object)ModernizedCProgram.imap_block_statemach(conn, /* ignore errors on LOGOUT */1);
			} 
		} 
		ModernizedCProgram.Curl_pp_disconnect(imapc.getPp());
		ModernizedCProgram.Curl_sasl_cleanup(conn, imapc.getSasl().getAuthused());
		do {
			.Curl_cfree((imapc.getMailbox()));
			(imapc.getMailbox()) = ((Object)0);
		} while (/* Cleanup our connection based variables */0);
		do {
			.Curl_cfree((imapc.getMailbox_uidvalidity()));
			(imapc.getMailbox_uidvalidity()) = ((Object)0);
		} while (0);
		return .CURLE_OK;
	}
	/* Call this when the DO phase has completed */
	public static  imap_dophase_done(Object conn,  connected) {
		IMAP imap = conn.getData().getReq().getProtop();
		(Object)connected;
		if (imap.getTransfer() != .FTPTRANSFER_BODY) {
			ModernizedCProgram.Curl_setup_transfer(conn.getData(), -1, -1, 0, -/* no data to transfer */1);
		} 
		return .CURLE_OK;
	}
	/* Called from multi.c while DOing */
	public static  imap_doing(Object conn, Object dophase_done) {
		CURLcode result = ModernizedCProgram.imap_multi_statemach(conn, dophase_done);
		if (result) {
			do {
			} while (0);
		}  else if (dophase_done) {
			result = ModernizedCProgram.imap_dophase_done(conn, /* not connected */0);
			do {
			} while (0);
		} 
		return result/***********************************************************************
		 *
		 * imap_regular_transfer()
		 *
		 * The input argument is already checked for validity.
		 *
		 * Performs all commands done before a regular transfer between a local and a
		 * remote host.
		 */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 * RFC2195 CRAM-MD5 authentication
	 * RFC2595 Using TLS with IMAP, POP3 and ACAP
	 * RFC2831 DIGEST-MD5 authentication
	 * RFC3501 IMAPv4 protocol
	 * RFC4422 Simple Authentication and Security Layer (SASL)
	 * RFC4616 PLAIN authentication
	 * RFC4752 The Kerberos V5 ("GSSAPI") SASL Mechanism
	 * RFC4959 IMAP Extension for SASL Initial Client Response
	 * RFC5092 IMAP URL Scheme
	 * RFC6749 OAuth 2.0 Authorization Framework
	 * RFC8314 Use of TLS for Email Submission and Access
	 * Draft   LOGIN SASL Mechanism <draft-murchison-sasl-login-00.txt>
	 *
	 ***************************************************************************/
	/* for HTTP proxy tunnel stuff */
	/* The last 3 #include files should be in this order */
	/* Local API functions */
	public static  imap_regular_transfer(Object conn, Object dophase_done) {
		CURLcode result = .CURLE_OK;
		bool connected = 0;
		Curl_easy data = conn.getData();
		data.getReq().setSize(-/* Make sure size is unknown at this point */1);
		ModernizedCProgram.Curl_pgrsSetUploadCounter(data, /* Set the progress data */0);
		ModernizedCProgram.Curl_pgrsSetDownloadCounter(data, 0);
		ModernizedCProgram.Curl_pgrsSetUploadSize(data, -1);
		ModernizedCProgram.Curl_pgrsSetDownloadSize(data, -1);
		result = ModernizedCProgram.imap_perform(conn, connected, /* Carry out the perform */dophase_done);
		if (!result && /* Perform post DO phase operations if necessary */dophase_done) {
			result = ModernizedCProgram.imap_dophase_done(conn, connected);
		} 
		return result;
	}
	public static  imap_setup_connection(Object conn) {
		CURLcode result = ModernizedCProgram.imap_init(/* Initialise the IMAP layer */conn);
		if (result) {
			return result;
		} 
		conn.setTls_upgraded(/* Clear the TLS upgraded flag */0);
		return .CURLE_OK/***********************************************************************
		 *
		 * imap_sendf()
		 *
		 * Sends the formatted string as an IMAP command to the server.
		 *
		 * Designed to never block.
		 */;
	}
	public static  imap_sendf(Object conn, Object fmt) {
		CURLcode result = .CURLE_OK;
		imap_conn imapc = conn.getProto().getImapc();
		byte taggedfmt;
		va_list ap = new va_list();
		do {
		} while (0);
		imapc.setCmdid((imapc.getCmdid() + 1) % /* Calculate the next command ID wrapping at 3 digits */1000);
		ModernizedCProgram.curl_msnprintf(imapc.getResptag(), , /* Calculate the tag based on the connection ID and command ID */"%c%03d", (byte)'A' + ModernizedCProgram.curlx_sltosi(conn.getConnection_id() % 26), imapc.getCmdid());
		taggedfmt = ModernizedCProgram.curl_maprintf("%s %s", imapc.getResptag(), /* Prefix the format with the tag */fmt);
		if (!taggedfmt) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		.__builtin_va_start(ap, /* Send the data with the tag */fmt);
		result = ModernizedCProgram.Curl_pp_vsendf(imapc.getPp(), taggedfmt, ap);
		.__builtin_va_end(ap);
		.Curl_cfree(taggedfmt);
		return result/***********************************************************************
		 *
		 * imap_atom()
		 *
		 * Checks the input string for characters that need escaping and returns an
		 * atom ready for sending to the server.
		 *
		 * The returned string needs to be freed.
		 *
		 */;
	}
	public static Object imap_atom(Object str,  escape_only) {
		byte[] atom_specials = /* !checksrc! disable PARENBRACE 1 */"(){ %*]";
		byte p1;
		byte p2;
		size_t backsp_count = 0;
		size_t quote_count = 0;
		bool others_exists = 0;
		size_t newlen = 0;
		byte newstr = ((Object)0);
		if (!str) {
			return ((Object)0);
		} 
		p1 = /* Look for "atom-specials", counting the backslash and quote characters as
		     these will need escaping */str;
		while (p1) {
			if (p1 == (byte)'\\') {
				backsp_count++;
			}  else if (p1 == (byte)'"') {
				quote_count++;
			}  else if (!escape_only) {
				byte p3 = atom_specials;
				while (p3 && !others_exists) {
					if (p1 == p3) {
						others_exists = 1;
					} 
					p3++;
				}
			} 
			p1++;
		}
		if (!backsp_count && !quote_count && !/* Does the input contain any "atom-special" characters? */others_exists) {
			return .Curl_cstrdup(str);
		} 
		newlen = .strlen(str) + backsp_count + quote_count + (escape_only ? 0 : /* Calculate the new string length */2);
		newstr = (byte).Curl_cmalloc((newlen + 1) * /* Allocate the new string */);
		if (!newstr) {
			return ((Object)0);
		} 
		p2 = /* Surround the string in quotes if necessary */newstr;
		if (!escape_only) {
			newstr[0] = (byte)'"';
			newstr[newlen - 1] = (byte)'"';
			p2++;
		} 
		p1 = /* Copy the string, escaping backslash and quote characters along the way */str;
		while (p1) {
			if (p1 == (byte)'\\' || p1 == (byte)'"') {
				p2 = (byte)'\\';
				p2++;
			} 
			p2 = p1;
			p1++;
			p2++;
		}
		newstr[newlen] = /* Terminate the string */(byte)'\0';
		return newstr/***********************************************************************
		 *
		 * imap_is_bchar()
		 *
		 * Portable test of whether the specified char is a "bchar" as defined in the
		 * grammar of RFC-5092.
		 */;
	}
	public static  imap_is_bchar(byte ch) {
		switch (ch) {
		case (byte)'8':
		case (byte)'S':
		case (byte)'\'':
		case (byte)'0':
		case (byte)'v':
		case (byte)'(':
		case (byte)'z':
		case (byte)'L':
		case (byte)'@':
		case (byte)'4':
		case (byte)'g':
		case (byte)'p':
		case (byte)'3':
		case (byte)'t':
		case (byte)'X':
		case (byte)'s':
		case /* bchar -> achar -> uchar -> pct-encoded *//* HEXDIG chars are already included above */(byte)'%':
				return .bool_true;
		case (byte)'D':
		case (byte)'m':
		case (byte)'j':
		case (byte)'B':
		case (byte)'y':
		case (byte)'G':
		case (byte)'!':
		case (byte)'+':
		case (byte)'1':
		case (byte)'N':
		case (byte)'x':
		case (byte)'K':
		case (byte)'T':
		case (byte)'c':
		case (byte)'n':
		case (byte)'2':
		case (byte)'b':
		case (byte)'I':
		case (byte)'u':
		case (byte)'Q':
		case (byte)'U':
		case (byte)'W':
		case (byte)'H':
		case (byte)'Y':
		case (byte)'&':
		case (byte)'E':
		case (byte)'F':
		case /* bchar -> achar -> uchar -> unreserved */(byte)'6':
		case (byte)'l':
		case (byte)'9':
		case (byte)'q':
		case (byte)'.':
		case (byte)'O':
		case (byte)'A':
		case (byte)'e':
		case (byte)'M':
		case (byte)'C':
		case (byte)'r':
		case (byte)'-':
		case (byte)'7':
		case (byte)'d':
		case (byte)'Z':
		case (byte)')':
		case (byte)'J':
		case (byte)'k':
		case (byte)'a':
		case (byte)'5':
		case (byte)'~':
		case (byte)'V':
		case (byte)'f':
		case (byte)'w':
		case (byte)'_':
		case /* bchar -> achar -> uchar -> sub-delims-sh */(byte)'*':
		case /* bchar */(byte)'/':
		case (byte)'i':
		case /* bchar -> achar */(byte)'=':
		case (byte)'P':
		case (byte)'R':
		case (byte)',':
		case (byte)'$':
		case (byte)':':
		case (byte)'o':
		case (byte)'h':
		default:
				return .bool_false/***********************************************************************
				 *
				 * imap_parse_url_options()
				 *
				 * Parse the URL login options.
				 */;
		}
	}
	public static  imap_parse_url_options(Object conn) {
		CURLcode result = .CURLE_OK;
		imap_conn imapc = conn.getProto().getImapc();
		byte ptr = conn.getOptions();
		imapc.getSasl().setResetprefs(1);
		while (!result && ptr && ptr) {
			byte key = ptr;
			byte value;
			while (ptr && ptr != (byte)'=') {
				ptr++;
			}
			value = ptr + 1;
			while (ptr && ptr != (byte)';') {
				ptr++;
			}
			if (ModernizedCProgram.Curl_strncasecompare(key, "AUTH=", 5)) {
				result = ModernizedCProgram.Curl_sasl_parse_url_auth_option(imapc.getSasl(), value, ptr - value);
			} else {
					result = .CURLE_URL_MALFORMAT;
			} 
			if (ptr == (byte)';') {
				ptr++;
			} 
		}
		switch (imapc.getSasl().getPrefmech()) {
		case (~-1024 & ~(1 << 5)):
				imapc.setPreftype(~-1024);
				break;
		case 0:
				imapc.setPreftype(0);
				break;
		default:
				imapc.setPreftype((1 << 1));
				break;
		}
		return result/***********************************************************************
		 *
		 * imap_parse_url_path()
		 *
		 * Parse the URL path into separate path components.
		 *
		 */;
	}
	public static  imap_parse_url_path(Object conn) {
		CURLcode result = /* The imap struct is already initialised in imap_connect() */.CURLE_OK;
		Curl_easy data = conn.getData();
		IMAP imap = data.getReq().getProtop();
		byte begin = data.getState().getUp().getPath()[/* skip leading slash */1];
		byte ptr = begin;
		while (ModernizedCProgram.imap_is_bchar(/* See how much of the URL is a valid path and decode it */ptr)) {
			ptr++;
		}
		if (ptr != begin) {
			byte end = /* Remove the trailing slash if present */ptr;
			if (end > begin && end[-1] == (byte)'/') {
				end--;
			} 
			result = ModernizedCProgram.Curl_urldecode(data, begin, end - begin, imap.getMailbox(), ((Object)0), 1);
			if (result) {
				return result;
			} 
		} else {
				imap.setMailbox(((Object)0));
		} 
		while (ptr == /* There can be any number of parameters in the form ";NAME=VALUE" */(byte)';') {
			byte name;
			byte value;
			size_t valuelen = new size_t();
			begin = ++/* Find the length of the name parameter */ptr;
			while (ptr && ptr != (byte)'=') {
				ptr++;
			}
			if (!ptr) {
				return .CURLE_URL_MALFORMAT;
			} 
			result = ModernizedCProgram.Curl_urldecode(data, begin, ptr - begin, name, ((Object)0), /* Decode the name parameter */1);
			if (result) {
				return result;
			} 
			begin = ++/* Find the length of the value parameter */ptr;
			while (ModernizedCProgram.imap_is_bchar(ptr)) {
				ptr++;
			}
			result = ModernizedCProgram.Curl_urldecode(data, begin, ptr - begin, value, valuelen, /* Decode the value parameter */1);
			if (result) {
				.Curl_cfree(name);
				return result;
			} 
			do {
			} while (0/* Process the known hierarchical parameters (UIDVALIDITY, UID, SECTION and
			       PARTIAL) stripping of the trailing slash character if it is present.
			
			       Note: Unknown parameters trigger a URL_MALFORMAT error. */);
			if (ModernizedCProgram.Curl_strcasecompare(name, "UIDVALIDITY") && !imap.getUidvalidity()) {
				if (valuelen > 0 && value[valuelen - 1] == (byte)'/') {
					value[valuelen - 1] = (byte)'\0';
				} 
				imap.setUidvalidity(value);
				value = ((Object)0);
			}  else if (ModernizedCProgram.Curl_strcasecompare(name, "UID") && !imap.getUid()) {
				if (valuelen > 0 && value[valuelen - 1] == (byte)'/') {
					value[valuelen - 1] = (byte)'\0';
				} 
				imap.setUid(value);
				value = ((Object)0);
			}  else if (ModernizedCProgram.Curl_strcasecompare(name, "MAILINDEX") && !imap.getMindex()) {
				if (valuelen > 0 && value[valuelen - 1] == (byte)'/') {
					value[valuelen - 1] = (byte)'\0';
				} 
				imap.setMindex(value);
				value = ((Object)0);
			}  else if (ModernizedCProgram.Curl_strcasecompare(name, "SECTION") && !imap.getSection()) {
				if (valuelen > 0 && value[valuelen - 1] == (byte)'/') {
					value[valuelen - 1] = (byte)'\0';
				} 
				imap.setSection(value);
				value = ((Object)0);
			}  else if (ModernizedCProgram.Curl_strcasecompare(name, "PARTIAL") && !imap.getPartial()) {
				if (valuelen > 0 && value[valuelen - 1] == (byte)'/') {
					value[valuelen - 1] = (byte)'\0';
				} 
				imap.setPartial(value);
				value = ((Object)0);
			} else {
					.Curl_cfree(name);
					.Curl_cfree(value);
					return .CURLE_URL_MALFORMAT;
			} 
			.Curl_cfree(name);
			.Curl_cfree(value);
		}
		if (imap.getMailbox() && !imap.getUid() && !imap.getMindex()) {
			(Object)ModernizedCProgram.curl_url_get(data.getState().getUh(), .CURLUPART_QUERY, imap.getQuery(), (1 << 6));
		} 
		if (/* Any extra stuff at the end of the URL is an error */ptr) {
			return .CURLE_URL_MALFORMAT;
		} 
		return .CURLE_OK/***********************************************************************
		 *
		 * imap_parse_custom_request()
		 *
		 * Parse the custom request.
		 */;
	}
	public static  imap_parse_custom_request(Object conn) {
		CURLcode result = .CURLE_OK;
		Curl_easy data = conn.getData();
		IMAP imap = data.getReq().getProtop();
		byte custom = data.getSet().getStr()[dupstring.STRING_CUSTOMREQUEST];
		if (custom) {
			result = ModernizedCProgram.Curl_urldecode(data, custom, 0, imap.getCustom(), ((Object)0), /* URL decode the custom request */1);
			if (!/* Extract the parameters if specified */result) {
				byte params = imap.getCustom();
				while (params && params != (byte)' ') {
					params++;
				}
				if (params) {
					imap.setCustom_params(.Curl_cstrdup(params));
					imap.getCustom()[params - imap.getCustom()] = (byte)'\0';
					if (!imap.getCustom_params()) {
						result = .CURLE_OUT_OF_MEMORY;
					} 
				} 
			} 
		} 
		return result/* CURL_DISABLE_IMAP */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/* For posterity:
	#define  CURL_SB_PEEK(x) ((*x->subpointer)&0xff)
	#define  CURL_SB_EOF(x) (x->subpointer >= x->subend) */
	public static  check_wsock2(Object data) {
		int err;
		WORD wVersionRequested = new WORD();
		WSADATA wsaData = new WSADATA();
		do {
		} while (0);
		wVersionRequested = ((WORD)(((BYTE)(true)) | (((WORD)((BYTE)(false))) << /* telnet requires at least WinSock 2.0 so ask for it. */8)));
		err = .WSAStartup(wVersionRequested, wsaData);
		if (err != /* We must've called this once already, so this call *//* should always succeed.  But, just in case... */0) {
			ModernizedCProgram.Curl_failf(data, "WSAStartup failed (%d)", err);
			return .CURLE_FAILED_INIT;
		} 
		.WSACleanup();
		Object generatedWVersion = wsaData.getWVersion();
		if (((BYTE)(generatedWVersion)) != ((BYTE)(/* Check that our version is supported */wVersionRequested)) || ((BYTE)(((WORD)(generatedWVersion) >> 8) & -1024)) != ((BYTE)(((WORD)(wVersionRequested) >> 8) & -1024))) {
			ModernizedCProgram.Curl_failf(data, /* Our version isn't supported */"insufficient winsock version to support telnet");
			return .CURLE_FAILED_INIT;
		} 
		return /* Our version is supported */.CURLE_OK;
	}
	public static  init_telnet(Object conn) {
		TELNET tn = new TELNET();
		tn = .Curl_ccalloc(1, );
		if (!tn) {
			return .CURLE_OUT_OF_MEMORY;
		} 
		conn.getData().getReq().setProtop(/* make us known */tn);
		tn.setTelrcv_state(.CURL_TS_DATA);
		tn.setSubpointer(tn.getSubbuffer());
		tn.getUs_preferred()[3] = /* Set the options we want by default */1;
		tn.getHim_preferred()[3] = 1/* To be compliant with previous releases of libcurl
		     we enable this option by default. This behaviour
		         can be changed thanks to the "BINARY" option in
		         CURLOPT_TELNETOPTIONS
		  */;
		tn.getUs_preferred()[0] = 1;
		tn.getHim_preferred()[0] = 1/* We must allow the server to echo what we sent
		         but it is not necessary to request the server
		         to do so (it might forces the server to close
		         the connection). Hence, we ignore ECHO in the
		         negotiate function
		  */;
		tn.getHim_preferred()[1] = 1/* Set the subnegotiation fields to send information
		    just after negotiation passed (do/will)
		
		     Default values are (0,0) initialized by calloc.
		     According to the RFC1013 it is valid:
		     A value equal to zero is acceptable for the width (or height),
		         and means that no character width (or height) is being sent.
		         In this case, the width (or height) that will be assumed by the
		         Telnet server is operating system specific (it will probably be
		         based upon the terminal type information that may have been sent
		         using the TERMINAL TYPE Telnet option). */;
		tn.getSubnegotiation()[31] = 1;
		return .CURLE_OK;
	}
	public static void negotiate(Object conn) {
		int i;
		TELNET tn = (TELNET)conn.getData().getReq().getProtop();
		for (i = 0; i < 40; i++) {
			if (i == 1) {
				continue;
			} 
			if (tn.getUs_preferred()[i] == 1) {
				ModernizedCProgram.set_local_option(conn, i, 1);
			} 
			if (tn.getHim_preferred()[i] == 1) {
				ModernizedCProgram.set_remote_option(conn, i, 1);
			} 
		}
	}
	public static void printoption(Object data, Object direction, int cmd, int option) {
		if (data.getSet().getVerbose()) {
			if (cmd == 255) {
				if ((((int)(option) >= 236) && ((int)(option) <= 255))) {
					ModernizedCProgram.Curl_infof(data, "%s IAC %s\n", direction, ModernizedCProgram.telnetcmds[(option) - 236]);
				} else {
						ModernizedCProgram.Curl_infof(data, "%s IAC %d\n", direction, option);
				} 
			} else {
					byte fmt = (cmd == 251) ? "WILL" : (cmd == 252) ? "WONT" : (cmd == 253) ? "DO" : (cmd == 254) ? "DONT" : 0;
					if (fmt) {
						byte opt;
						if (((option) <= 39)) {
							opt = ModernizedCProgram.telnetoptions[option];
						}  else if (option == 255) {
							opt = "EXOPL";
						} else {
								opt = ((Object)0);
						} 
						if (opt) {
							ModernizedCProgram.Curl_infof(data, "%s %s %s\n", direction, fmt, opt);
						} else {
								ModernizedCProgram.Curl_infof(data, "%s %s %d\n", direction, fmt, option);
						} 
					} else {
							ModernizedCProgram.Curl_infof(data, "%s %d %d\n", direction, cmd, option);
					} 
			} 
		} 
	}
	public static void send_negotiation(Object conn, int cmd, int option) {
		byte[] buf = new byte[3];
		ssize_t bytes_written = new ssize_t();
		Curl_easy data = conn.getData();
		buf[0] = 255;
		buf[1] = (byte)cmd;
		buf[2] = (byte)option;
		bytes_written = (ssize_t).send((SOCKET)(conn.getSock()[0]), (byte)(buf), (int)(true), (int)(false));
		if (bytes_written < 0) {
			int err = ((int).WSAGetLastError());
			ModernizedCProgram.Curl_failf(data, "Sending data failed (%d)", err);
		} 
		ModernizedCProgram.printoption(conn.getData(), "SENT", cmd, option);
	}
	public static void set_remote_option(Object conn, int option, int newstate) {
		TELNET tn = (TELNET)conn.getData().getReq().getProtop();
		if (newstate == 1) {
			switch (tn.getHim()[option]) {
			case 1/* Already enabled */:
					break;
			case 0:
					tn.getHim()[option] = 2;
					ModernizedCProgram.send_negotiation(conn, 253, option);
					break;
			case 3:
					switch (tn.getHimq()[option]) {
					case 1/* Error: already queued an enable request */:
							break;
					case 0:
							tn.getHimq()[option] = /* Already negotiating for CURL_YES, queue the request */1;
							break;
					}
					break;
			case 2:
					switch (tn.getHimq()[option]) {
					case 1:
							tn.getHimq()[option] = 0;
							break;
					case 0/* Error: already negotiating for enable */:
							break;
					}
					break;
			}
		} else {
				switch (tn.getHim()[/* NO */option]) {
				case 2:
						switch (tn.getHimq()[option]) {
						case 0:
								tn.getHimq()[option] = 1;
								break;
						case 1:
								break;
						}
						break;
				case 3:
						switch (tn.getHimq()[option]) {
						case 0/* Already negotiating for NO */:
								break;
						case 1:
								tn.getHimq()[option] = 0;
								break;
						}
						break;
				case 0/* Already disabled */:
						break;
				case 1:
						tn.getHim()[option] = 3;
						ModernizedCProgram.send_negotiation(conn, 254, option);
						break;
				}
		} 
	}
	public static void rec_will(Object conn, int option) {
		TELNET tn = (TELNET)conn.getData().getReq().getProtop();
		switch (tn.getHim()[option]) {
		case 2:
				switch (tn.getHimq()[option]) {
				case 0:
						tn.getHim()[option] = 1;
						break;
				case 1:
						tn.getHim()[option] = 3;
						tn.getHimq()[option] = 0;
						ModernizedCProgram.send_negotiation(conn, 254, option);
						break;
				}
				break;
		case 0:
				if (tn.getHim_preferred()[option] == 1) {
					tn.getHim()[option] = 1;
					ModernizedCProgram.send_negotiation(conn, 253, option);
				} else {
						ModernizedCProgram.send_negotiation(conn, 254, option);
				} 
				break;
		case 3:
				switch (tn.getHimq()[option]) {
				case 0:
						tn.getHim()[option] = /* Error: DONT answered by WILL */0;
						break;
				case 1:
						tn.getHim()[option] = /* Error: DONT answered by WILL */1;
						tn.getHimq()[option] = 0;
						break;
				}
				break;
		case 1/* Already enabled */:
				break;
		}
	}
	public static void rec_wont(Object conn, int option) {
		TELNET tn = (TELNET)conn.getData().getReq().getProtop();
		switch (tn.getHim()[option]) {
		case 3:
				switch (tn.getHimq()[option]) {
				case 0:
						tn.getHim()[option] = 0;
						break;
				case 1:
						tn.getHim()[option] = 2;
						tn.getHimq()[option] = 0;
						ModernizedCProgram.send_negotiation(conn, 253, option);
						break;
				}
				break;
		case 0/* Already disabled */:
				break;
		case 2:
				switch (tn.getHimq()[option]) {
				case 0:
						tn.getHim()[option] = 0;
						break;
				case 1:
						tn.getHim()[option] = 0;
						tn.getHimq()[option] = 0;
						break;
				}
				break;
		case 1:
				tn.getHim()[option] = 0;
				ModernizedCProgram.send_negotiation(conn, 254, option);
				break;
		}
	}
	public static void set_local_option(Object conn, int option, int newstate) {
		TELNET tn = (TELNET)conn.getData().getReq().getProtop();
		if (newstate == 1) {
			switch (tn.getUs()[option]) {
			case 0:
					tn.getUs()[option] = 2;
					ModernizedCProgram.send_negotiation(conn, 251, option);
					break;
			case 1/* Already enabled */:
					break;
			case 3:
					switch (tn.getUsq()[option]) {
					case 1/* Error: already queued an enable request */:
							break;
					case 0:
							tn.getUsq()[option] = /* Already negotiating for CURL_YES, queue the request */1;
							break;
					}
					break;
			case 2:
					switch (tn.getUsq()[option]) {
					case 0/* Error: already negotiating for enable */:
							break;
					case 1:
							tn.getUsq()[option] = 0;
							break;
					}
					break;
			}
		} else {
				switch (tn.getUs()[/* NO */option]) {
				case 3:
						switch (tn.getUsq()[option]) {
						case 1:
								tn.getUsq()[option] = 0;
								break;
						case 0/* Already negotiating for NO */:
								break;
						}
						break;
				case 0/* Already disabled */:
						break;
				case 2:
						switch (tn.getUsq()[option]) {
						case 1:
								break;
						case 0:
								tn.getUsq()[option] = 1;
								break;
						}
						break;
				case 1:
						tn.getUs()[option] = 3;
						ModernizedCProgram.send_negotiation(conn, 252, option);
						break;
				}
		} 
	}
	public static void rec_do(Object conn, int option) {
		TELNET tn = (TELNET)conn.getData().getReq().getProtop();
		switch (tn.getUs()[option]) {
		case 1/* Already enabled */:
				break;
		case 0:
				if (tn.getUs_preferred()[option] == 1) {
					tn.getUs()[option] = 1;
					ModernizedCProgram.send_negotiation(conn, 251, option);
					if (tn.getSubnegotiation()[option] == 1) {
						ModernizedCProgram.sendsuboption(conn, /* transmission of data option */option);
					} 
				}  else if (tn.getSubnegotiation()[option] == 1) {
					tn.getUs()[option] = /* send information to achieve this option*/1;
					ModernizedCProgram.send_negotiation(conn, 251, option);
					ModernizedCProgram.sendsuboption(conn, option);
				} else {
						ModernizedCProgram.send_negotiation(conn, 252, option);
				} 
				break;
		case 3:
				switch (tn.getUsq()[option]) {
				case 0:
						tn.getUs()[option] = /* Error: DONT answered by WILL */0;
						break;
				case 1:
						tn.getUs()[option] = /* Error: DONT answered by WILL */1;
						tn.getUsq()[option] = 0;
						break;
				}
				break;
		case 2:
				switch (tn.getUsq()[option]) {
				case 0:
						tn.getUs()[option] = 1;
						if (tn.getSubnegotiation()[option] == 1) {
							ModernizedCProgram.sendsuboption(conn, /* transmission of data option */option);
						} 
						break;
				case 1:
						tn.getUs()[option] = 3;
						tn.getHimq()[option] = 0;
						ModernizedCProgram.send_negotiation(conn, 252, option);
						break;
				}
				break;
		}
	}
	public static void rec_dont(Object conn, int option) {
		TELNET tn = (TELNET)conn.getData().getReq().getProtop();
		switch (tn.getUs()[option]) {
		case 1:
				tn.getUs()[option] = 0;
				ModernizedCProgram.send_negotiation(conn, 252, option);
				break;
		case 0/* Already disabled */:
				break;
		case 2:
				switch (tn.getUsq()[option]) {
				case 1:
						tn.getUs()[option] = 0;
						tn.getUsq()[option] = 0;
						break;
				case 0:
						tn.getUs()[option] = 0;
						break;
				}
				break;
		case 3:
				switch (tn.getUsq()[option]) {
				case 1:
						tn.getUs()[option] = 2;
						tn.getUsq()[option] = 0;
						ModernizedCProgram.send_negotiation(conn, 251, option);
						break;
				case 0:
						tn.getUs()[option] = 0;
						break;
				}
				break;
		}
	}
	public static void printsub(Object data, int direction, Object pointer, Object length) {
		if (data.getSet().getVerbose()) {
			int i = 0;
			if (direction) {
				ModernizedCProgram.Curl_infof(data, "%s IAC SB ", (direction == (byte)'<') ? "RCVD" : "SENT");
				if (length >= 3) {
					int j;
					i = pointer[length - 2];
					j = pointer[length - 1];
					if (i != 255 || j != 240) {
						ModernizedCProgram.Curl_infof(data, "(terminated by ");
						if (((i) <= 39)) {
							ModernizedCProgram.Curl_infof(data, "%s ", ModernizedCProgram.telnetoptions[i]);
						}  else if ((((int)(i) >= 236) && ((int)(i) <= 255))) {
							ModernizedCProgram.Curl_infof(data, "%s ", ModernizedCProgram.telnetcmds[(i) - 236]);
						} else {
								ModernizedCProgram.Curl_infof(data, "%u ", i);
						} 
						if (((j) <= 39)) {
							ModernizedCProgram.Curl_infof(data, "%s", ModernizedCProgram.telnetoptions[j]);
						}  else if ((((int)(j) >= 236) && ((int)(j) <= 255))) {
							ModernizedCProgram.Curl_infof(data, "%s", ModernizedCProgram.telnetcmds[(j) - 236]);
						} else {
								ModernizedCProgram.Curl_infof(data, "%d", j);
						} 
						ModernizedCProgram.Curl_infof(data, ", not IAC SE!) ");
					} 
				} 
				length -= 2;
			} 
			if (length < 1) {
				ModernizedCProgram.Curl_infof(data, "(Empty suboption?)");
				return ;
			} 
			if (((pointer[0]) <= 39)) {
				switch (pointer[0]) {
				case 39:
				case 24:
				case 35:
				case 31:
						ModernizedCProgram.Curl_infof(data, "%s", ModernizedCProgram.telnetoptions[pointer[0]]);
						break;
				default:
						ModernizedCProgram.Curl_infof(data, "%s (unsupported)", ModernizedCProgram.telnetoptions[pointer[0]]);
						break;
				}
			} else {
					ModernizedCProgram.Curl_infof(data, "%d (unknown)", pointer[i]);
			} 
			switch (pointer[0]) {
			case 31:
					if (length > 4) {
						ModernizedCProgram.Curl_infof(data, "Width: %d ; Height: %d", (pointer[1] << 8) | pointer[2], (pointer[3] << 8) | pointer[4]);
					} 
					break;
			default:
					switch (pointer[1]) {
					case 0:
							ModernizedCProgram.Curl_infof(data, " IS");
							break;
					case 1:
							ModernizedCProgram.Curl_infof(data, " SEND");
							break;
					case 2:
							ModernizedCProgram.Curl_infof(data, " INFO/REPLY");
							break;
					case 3:
							ModernizedCProgram.Curl_infof(data, " NAME");
							break;
					}
					switch (pointer[0]) {
					case 39:
							if (pointer[1] == 0) {
								ModernizedCProgram.Curl_infof(data, " ");
								for (i = 3; i < length; i++) {
									switch (pointer[i]) {
									case 1:
											ModernizedCProgram.Curl_infof(data, " = ");
											break;
									case 0:
											ModernizedCProgram.Curl_infof(data, ", ");
											break;
									default:
											ModernizedCProgram.Curl_infof(data, "%c", pointer[i]);
											break;
									}
								}
							} 
							break;
					case 35:
							pointer[length] = 0;
							ModernizedCProgram.Curl_infof(data, " \"%s\"", pointer[2]);
							break;
					case 24:
					default:
							for (i = 2; i < length; i++) {
								ModernizedCProgram.Curl_infof(data, " %.2x", pointer[i]);
							}
							break;
					}
			}
			if (direction) {
				ModernizedCProgram.Curl_infof(data, "\n");
			} 
		} 
	}
	/* '<' or '>' */
	/* where suboption data is */
	public static  check_telnet_options(Object conn) {
		curl_slist head = new curl_slist();
		curl_slist beg = new curl_slist();
		byte[] option_keyword = "";
		byte[] option_arg = "";
		Curl_easy data = conn.getData();
		TELNET tn = (TELNET)conn.getData().getReq().getProtop();
		CURLcode result = .CURLE_OK;
		int binary_option;
		if (conn.getBits().getUser_passwd()) {
			ModernizedCProgram.curl_msnprintf(option_arg, , "USER,%s", conn.getUser());
			beg = ModernizedCProgram.curl_slist_append(tn.getTelnet_vars(), option_arg);
			if (!beg) {
				ModernizedCProgram.curl_slist_free_all(tn.getTelnet_vars());
				tn.setTelnet_vars(((Object)0));
				return .CURLE_OUT_OF_MEMORY;
			} 
			tn.setTelnet_vars(beg);
			tn.getUs_preferred()[39] = 1;
		} 
		for (head = data.getSet().getTelnet_options(); head; head = head.getNext()) {
			if (.sscanf(head.getData(), "%127[^= ]%*[ =]%255s", option_keyword, option_arg) == 2) {
				if (ModernizedCProgram.Curl_strcasecompare(option_keyword, /* Terminal type */"TTYPE")) {
					.strncpy(tn.getSubopt_ttype(), option_arg, 31);
					tn.getSubopt_ttype()[31] = /* String termination */0;
					tn.getUs_preferred()[24] = 1;
					continue;
				} 
				if (ModernizedCProgram.Curl_strcasecompare(option_keyword, /* Display variable */"XDISPLOC")) {
					.strncpy(tn.getSubopt_xdisploc(), option_arg, 127);
					tn.getSubopt_xdisploc()[127] = /* String termination */0;
					tn.getUs_preferred()[35] = 1;
					continue;
				} 
				if (ModernizedCProgram.Curl_strcasecompare(option_keyword, /* Environment variable */"NEW_ENV")) {
					beg = ModernizedCProgram.curl_slist_append(tn.getTelnet_vars(), option_arg);
					if (!beg) {
						result = .CURLE_OUT_OF_MEMORY;
						break;
					} 
					tn.setTelnet_vars(beg);
					tn.getUs_preferred()[39] = 1;
					continue;
				} 
				if (ModernizedCProgram.Curl_strcasecompare(option_keyword, /* Window Size */"WS")) {
					if (.sscanf(option_arg, "%hu%*[xX]%hu", tn.getSubopt_wsx(), tn.getSubopt_wsy()) == 2) {
						tn.getUs_preferred()[31] = 1;
					} else {
							ModernizedCProgram.Curl_failf(data, "Syntax error in telnet option: %s", head.getData());
							result = .CURLE_TELNET_OPTION_SYNTAX;
							break;
					} 
					continue;
				} 
				if (ModernizedCProgram.Curl_strcasecompare(option_keyword, /* To take care or not of the 8th bit in data exchange */"BINARY")) {
					binary_option = .atoi(option_arg);
					if (binary_option != 1) {
						tn.getUs_preferred()[0] = 0;
						tn.getHim_preferred()[0] = 0;
					} 
					continue;
				} 
				ModernizedCProgram.Curl_failf(data, "Unknown telnet option %s", head.getData());
				result = .CURLE_UNKNOWN_OPTION;
				break;
			} 
			ModernizedCProgram.Curl_failf(data, "Syntax error in telnet option: %s", head.getData());
			result = .CURLE_TELNET_OPTION_SYNTAX;
			break;
		}
		if (result) {
			ModernizedCProgram.curl_slist_free_all(tn.getTelnet_vars());
			tn.setTelnet_vars(((Object)0));
		} 
		return result/*
		 * suboption()
		 *
		 * Look at the sub-option buffer, and try to be helpful to the other
		 * side.
		 */;
	}
	public static void suboption(Object conn) {
		curl_slist v = new curl_slist();
		byte[] temp = new byte[2048];
		ssize_t bytes_written = new ssize_t();
		size_t len = new size_t();
		int err;
		byte[] varname = "";
		byte[] varval = "";
		Curl_easy data = conn.getData();
		TELNET tn = (TELNET)data.getReq().getProtop();
		ModernizedCProgram.printsub(data, (byte)'<', (byte)tn.getSubbuffer(), (tn.getSubend() - tn.getSubpointer()) + 2);
		switch (((tn.getSubpointer()++) & -1024)) {
		case 24:
				len = .strlen(tn.getSubopt_ttype()) + 4 + 2;
				ModernizedCProgram.curl_msnprintf((byte)temp, , "%c%c%c%c%s%c%c", 255, 250, 24, 0, tn.getSubopt_ttype(), 255, 240);
				bytes_written = (ssize_t).send((SOCKET)(conn.getSock()[0]), (byte)(temp), (int)(len), (int)(false));
				if (bytes_written < 0) {
					err = ((int).WSAGetLastError());
					ModernizedCProgram.Curl_failf(data, "Sending data failed (%d)", err);
				} 
				ModernizedCProgram.printsub(data, (byte)'>', temp[2], len - 2);
				break;
		case 39:
				ModernizedCProgram.curl_msnprintf((byte)temp, , "%c%c%c%c", 255, 250, 39, 0);
				len = 4;
				for (v = tn.getTelnet_vars(); v; v = v.getNext()) {
					size_t tmplen = (.strlen(v.getData()) + 1);
					if (len + tmplen < (int) - /* Add the variable only if it fits */6) {
						if (.sscanf(v.getData(), "%127[^,],%127s", varname, varval)) {
							ModernizedCProgram.curl_msnprintf((byte)temp[len],  - len, "%c%s%c%s", 0, varname, 1, varval);
							len += tmplen;
						} 
					} 
				}
				ModernizedCProgram.curl_msnprintf((byte)temp[len],  - len, "%c%c", 255, 240);
				len += 2;
				bytes_written = (ssize_t).send((SOCKET)(conn.getSock()[0]), (byte)(temp), (int)(len), (int)(false));
				if (bytes_written < 0) {
					err = ((int).WSAGetLastError());
					ModernizedCProgram.Curl_failf(data, "Sending data failed (%d)", err);
				} 
				ModernizedCProgram.printsub(data, (byte)'>', temp[2], len - 2);
				break;
		case 35:
				len = .strlen(tn.getSubopt_xdisploc()) + 4 + 2;
				ModernizedCProgram.curl_msnprintf((byte)temp, , "%c%c%c%c%s%c%c", 255, 250, 35, 0, tn.getSubopt_xdisploc(), 255, 240);
				bytes_written = (ssize_t).send((SOCKET)(conn.getSock()[0]), (byte)(temp), (int)(len), (int)(false));
				if (bytes_written < 0) {
					err = ((int).WSAGetLastError());
					ModernizedCProgram.Curl_failf(data, "Sending data failed (%d)", err);
				} 
				ModernizedCProgram.printsub(data, (byte)'>', temp[2], len - 2);
				break;
		}
		return ;/*
		 * sendsuboption()
		 *
		 * Send suboption information to the server side.
		 */
	}
	public static void sendsuboption(Object conn, int option) {
		ssize_t bytes_written = new ssize_t();
		int err;
		int x;
		int y;
		byte uc1;
		byte uc2;
		Curl_easy data = conn.getData();
		TELNET tn = (TELNET)data.getReq().getProtop();
		switch (option) {
		case 31:
				tn.setSubpointer(tn.getSubbuffer());
				do {
					if (tn.getSubpointer() < (tn.getSubbuffer() + )) {
						tn.getSubpointer()++ = (true);
					} 
				} while (0);
				do {
					if (tn.getSubpointer() < (tn.getSubbuffer() + )) {
						tn.getSubpointer()++ = (true);
					} 
				} while (0);
				do {
					if (tn.getSubpointer() < (tn.getSubbuffer() + )) {
						tn.getSubpointer()++ = (true);
					} 
				} while (0/* We must deal either with little or big endian processors */);
				x = .htons(tn.getSubopt_wsx());
				y = .htons(tn.getSubopt_wsy());
				uc1 = (byte)x;
				uc2 = (byte)y;
				do {
					if (tn.getSubpointer() < (tn.getSubbuffer() + )) {
						tn.getSubpointer()++ = (uc1[0]);
					} 
				} while (0);
				do {
					if (tn.getSubpointer() < (tn.getSubbuffer() + )) {
						tn.getSubpointer()++ = (uc1[1]);
					} 
				} while (0);
				do {
					if (tn.getSubpointer() < (tn.getSubbuffer() + )) {
						tn.getSubpointer()++ = (uc2[0]);
					} 
				} while (0);
				do {
					if (tn.getSubpointer() < (tn.getSubbuffer() + )) {
						tn.getSubpointer()++ = (uc2[1]);
					} 
				} while (0);
				do {
					if (tn.getSubpointer() < (tn.getSubbuffer() + )) {
						tn.getSubpointer()++ = (true);
					} 
				} while (0);
				do {
					if (tn.getSubpointer() < (tn.getSubbuffer() + )) {
						tn.getSubpointer()++ = (true);
					} 
				} while (0);
				do {
					tn.setSubend(tn.getSubpointer());
					tn.setSubpointer(tn.getSubbuffer());
				} while (0/* data suboption is now ready */);
				ModernizedCProgram.printsub(data, (byte)'>', (byte)tn.getSubbuffer() + 2, (tn.getSubend() - tn.getSubpointer()) - 2);
				bytes_written = (ssize_t).send((SOCKET)(conn.getSock()[0]), (byte)(tn.getSubbuffer()), (int)(true), (int)(/* we send the header of the suboption... */false));
				if (bytes_written < 0) {
					err = ((int).WSAGetLastError());
					ModernizedCProgram.Curl_failf(data, "Sending data failed (%d)", err);
				} 
				ModernizedCProgram.send_telnet_data(conn, (byte)tn.getSubbuffer() + 3, /* ... then the window size with the send_telnet_data() function
				       to deal with 0xFF cases ... */4);
				bytes_written = (ssize_t).send((SOCKET)(conn.getSock()[0]), (byte)(tn.getSubbuffer() + 7), (int)(true), (int)(/* ... and the footer */false));
				if (bytes_written < 0) {
					err = ((int).WSAGetLastError());
					ModernizedCProgram.Curl_failf(data, "Sending data failed (%d)", err);
				} 
				break;
		}
	}
	public static  telrcv(Object conn, Object inbuf, Object count) {
		/* Number of bytes received */byte c;
		CURLcode result = new CURLcode();
		int in = 0;
		int startwrite = -1;
		Curl_easy data = conn.getData();
		TELNET tn = (TELNET)data.getReq().getProtop();
		if (startwrite >= 0) {
			result = ModernizedCProgram.Curl_client_write(conn, (1 << 0), (byte)inbuf[startwrite], in - startwrite);
			if (result) {
				return result;
			} 
		} 
		startwrite = -1;
		return .CURLE_OK;
	}
	/* Data received from socket */
	/* Number of bytes received */
	/* Data received from socket */
	/* Escape and send a telnet data block */
	public static  send_telnet_data(Object conn, Object buffer, Object nread) {
		ssize_t escapes = new ssize_t();
		ssize_t i = new ssize_t();
		ssize_t outlen = new ssize_t();
		byte outbuf = ((Object)0);
		CURLcode result = .CURLE_OK;
		ssize_t bytes_written = new ssize_t();
		ssize_t total_written = new ssize_t();
		escapes = /* Determine size of new buffer after escaping */0;
		for (i = 0; i < nread; i++) {
			if ((byte)buffer[i] == 255) {
				escapes++;
			} 
		}
		outlen = nread + escapes;
		if (outlen == nread) {
			outbuf = (byte)buffer;
		} else {
				ssize_t j = new ssize_t();
				outbuf = .Curl_cmalloc(nread + escapes + 1);
				if (!outbuf) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				j = 0;
				for (i = 0; i < nread; i++) {
					outbuf[j++] = buffer[i];
					if ((byte)buffer[i] == 255) {
						outbuf[j++] = 255;
					} 
				}
				outbuf[j] = (byte)'\0';
		} 
		total_written = 0;
		while (!result && total_written < outlen) {
			pollfd[] pfd = new pollfd();
			pfd[0].setFd(conn.getSock()[0]);
			pfd[0].setEvents(-1024);
			switch (ModernizedCProgram.Curl_poll(pfd, 1, -1)) {
			case /* timeout (will never happen) */0:
					result = .CURLE_SEND_ERROR;
					break;
			case -/* error, abort writing */1:
			default:
					bytes_written = 0;
					result = ModernizedCProgram.Curl_write(conn, conn.getSock()[0], outbuf + total_written, outlen - total_written, bytes_written);
					total_written += bytes_written;
					break;
			}
		}
		if (outbuf != (byte)/* Free malloc copy if escaped */buffer) {
			.Curl_cfree(outbuf);
		} 
		return result;
	}
	/* For negotiation compliant to RFC 1143 */
	public static  telnet_done(Object conn,  status,  premature) {
		TELNET tn = (TELNET)conn.getData().getReq().getProtop();
		(Object)/* unused */status;
		(Object)/* not used */premature;
		if (!tn) {
			return .CURLE_OK;
		} 
		ModernizedCProgram.curl_slist_free_all(tn.getTelnet_vars());
		tn.setTelnet_vars(((Object)0));
		do {
			.Curl_cfree((conn.getData().getReq().getProtop()));
			(conn.getData().getReq().getProtop()) = ((Object)0);
		} while (0);
		return .CURLE_OK;
	}
	public static  telnet_do(Object conn, Object done) {
		CURLcode result = new CURLcode();
		Curl_easy data = conn.getData();
		curl_socket_t sockfd = conn.getSock()[0];
		HMODULE wsock2 = new HMODULE();
		WSOCK2_FUNC close_event_func = new WSOCK2_FUNC();
		WSOCK2_EVENT create_event_func = new WSOCK2_EVENT();
		WSOCK2_FUNC event_select_func = new WSOCK2_FUNC();
		WSOCK2_FUNC enum_netevents_func = new WSOCK2_FUNC();
		HANDLE event_handle = new HANDLE();
		WSANETWORKEVENTS events = new WSANETWORKEVENTS();
		HANDLE stdin_handle = new HANDLE();
		HANDLE[] objs = new HANDLE();
		DWORD obj_count = new DWORD();
		DWORD wait_timeout = new DWORD();
		DWORD readfile_read = new DWORD();
		int err;
		ssize_t nread = new ssize_t();
		curltime now = new curltime();
		bool keepon = 1;
		byte buf = data.getState().getBuffer();
		TELNET tn = new TELNET();
		done = /* unconditionally */1;
		result = ModernizedCProgram.init_telnet(conn);
		if (result) {
			return result;
		} 
		tn = (TELNET)data.getReq().getProtop();
		result = ModernizedCProgram.check_telnet_options(conn);
		if (result) {
			return result/*
			  ** This functionality only works with WinSock >= 2.0.  So,
			  ** make sure we have it.
			  */;
		} 
		result = ModernizedCProgram.check_wsock2(data);
		if (result) {
			return result;
		} 
		wsock2 = ModernizedCProgram.Curl_load_library(/* OK, so we have WinSock 2.0.  We need to dynamically *//* load ws2_32.dll and get the function pointers we need. */"WS2_32.DLL");
		if (wsock2 == ((Object)0)) {
			ModernizedCProgram.Curl_failf(data, "failed to load WS2_32.DLL (%u)", .GetLastError());
			return .CURLE_FAILED_INIT;
		} 
		/* Grab a pointer to WSACreateEvent */create_event_func = (WSOCK2_EVENT)(Object)((.GetProcAddress(wsock2, "WSACreateEvent")));
		if (create_event_func == ((Object)0)) {
			ModernizedCProgram.Curl_failf(data, "failed to find WSACreateEvent function (%u)", .GetLastError());
			.FreeLibrary(wsock2);
			return .CURLE_FAILED_INIT;
		} 
		close_event_func = .GetProcAddress(wsock2, /* And WSACloseEvent */"WSACloseEvent");
		if (close_event_func == ((Object)0)) {
			ModernizedCProgram.Curl_failf(data, "failed to find WSACloseEvent function (%u)", .GetLastError());
			.FreeLibrary(wsock2);
			return .CURLE_FAILED_INIT;
		} 
		event_select_func = .GetProcAddress(wsock2, /* And WSAEventSelect */"WSAEventSelect");
		if (event_select_func == ((Object)0)) {
			ModernizedCProgram.Curl_failf(data, "failed to find WSAEventSelect function (%u)", .GetLastError());
			.FreeLibrary(wsock2);
			return .CURLE_FAILED_INIT;
		} 
		enum_netevents_func = .GetProcAddress(wsock2, /* And WSAEnumNetworkEvents */"WSAEnumNetworkEvents");
		if (enum_netevents_func == ((Object)0)) {
			ModernizedCProgram.Curl_failf(data, "failed to find WSAEnumNetworkEvents function (%u)", .GetLastError());
			.FreeLibrary(wsock2);
			return .CURLE_FAILED_INIT/* We want to wait for both stdin and the socket. Since
			  ** the select() function in winsock only works on sockets
			  ** we have to use the WaitForMultipleObjects() call.
			  */;
		} 
		event_handle = (HANDLE).create_event_func();
		if (event_handle == ((HANDLE)((Object)0))) {
			ModernizedCProgram.Curl_failf(data, "WSACreateEvent failed (%d)", ((int).WSAGetLastError()));
			.FreeLibrary(wsock2);
			return .CURLE_FAILED_INIT;
		} 
		if (.event_select_func(sockfd, event_handle, (1 << 0) | (1 << /* Tell winsock what events we want to listen to */5)) == (true)) {
			.close_event_func(event_handle);
			.FreeLibrary(wsock2);
			return .CURLE_OK;
		} 
		stdin_handle = .GetStdHandle((DWORD)(/* The get the Windows file handle for stdin */true));
		objs[0] = /* Create the list of objects to wait for */event_handle;
		objs[1] = stdin_handle;
		if (.GetFileType(stdin_handle) == /* If stdin_handle is a pipe, use PeekNamedPipe() method to check it,
		     else use the old WaitForMultipleObjects() way */3 || data.getSet().getIs_fread_set()) {
			obj_count = /* Don't wait for stdin_handle, just wait for event_handle */1;
			wait_timeout = /* Check stdin_handle per 100 milliseconds */100;
		} else {
				obj_count = 2;
				wait_timeout = 1000;
		} 
		Object generatedLNetworkEvents = events.getLNetworkEvents();
		curltime curltime = new curltime();
		while (/* Keep on listening and act on events */keepon) {
			DWORD buf_size = (DWORD)data.getSet().getBuffer_size();
			DWORD waitret = .WaitForMultipleObjects(obj_count, objs, 0, wait_timeout);
			switch (waitret) {
			case 0 + 1:
					{ 
						if (!.ReadFile(stdin_handle, buf, buf_size, readfile_read, ((Object)0))) {
							keepon = 0;
							result = .CURLE_READ_ERROR;
							break;
						} 
						result = ModernizedCProgram.send_telnet_data(conn, buf, readfile_read);
						if (result) {
							keepon = 0;
							break;
						} 
					}
					break;
			case 0:
					events.setLNetworkEvents(0);
					if ((true) == .enum_netevents_func(sockfd, event_handle, events)) {
						err = ((int).WSAGetLastError());
						if (err != -1024) {
							ModernizedCProgram.Curl_infof(data, "WSAEnumNetworkEvents failed (%d)", err);
							keepon = 0;
							result = .CURLE_READ_ERROR;
						} 
						break;
					} 
					if (generatedLNetworkEvents & (1 << 0)) {
						result = ModernizedCProgram.Curl_read(conn, sockfd, buf, data.getSet().getBuffer_size(), /* read data from network */nread);
						if (result == /* read would've blocked. Loop again */.CURLE_AGAIN) {
							break;
						}  else if (/* returned not-zero, this an error */result) {
							keepon = 0;
							break;
						}  else if (nread <= /* returned zero but actually received 0 or less here,
						           the server closed the connection and we bail out */0) {
							keepon = 0;
							break;
						} 
						result = ModernizedCProgram.telrcv(conn, (byte)buf, nread);
						if (result) {
							keepon = 0;
							break;
						} 
						if (tn.getPlease_negotiate() && !tn.getAlready_negotiated()) {
							ModernizedCProgram.negotiate(conn);
							tn.setAlready_negotiated(1);
						} 
					} 
					if (generatedLNetworkEvents & (1 << 5)) {
						keepon = 0;
					} 
					break;
			case -1024:
					{ 
						for (; ; ) {
							if (data.getSet().getIs_fread_set()) {
								size_t n = new size_t();
								n = .UNRECOGNIZEDFUNCTIONNAME(buf, 1, buf_size, data.getState().getIn());
								if (n == -1024) {
									keepon = 0;
									result = .CURLE_READ_ERROR;
									break;
								} 
								if (n == -1024) {
									break;
								} 
								if (n == /* no bytes */0) {
									break;
								} 
								readfile_read = (DWORD)/* fall through with number of bytes read */n;
							} else {
									if (!.PeekNamedPipe(stdin_handle, ((Object)0), 0, ((Object)/* read from stdin */0), readfile_read, ((Object)0))) {
										keepon = 0;
										result = .CURLE_READ_ERROR;
										break;
									} 
									if (!readfile_read) {
										break;
									} 
									if (!.ReadFile(stdin_handle, buf, buf_size, readfile_read, ((Object)0))) {
										keepon = 0;
										result = .CURLE_READ_ERROR;
										break;
									} 
							} 
							result = ModernizedCProgram.send_telnet_data(conn, buf, readfile_read);
							if (result) {
								keepon = 0;
								break;
							} 
						}
					}
					break;
			}
			if (data.getSet().getTimeout()) {
				now = curltime.Curl_now();
				if (now.Curl_timediff(conn.getCreated()) >= data.getSet().getTimeout()) {
					ModernizedCProgram.Curl_failf(data, "Time-out");
					result = .CURLE_OPERATION_TIMEDOUT;
					keepon = 0;
				} 
			} 
		}
		if (!.close_event_func(/* We called WSACreateEvent, so call WSACloseEvent */event_handle)) {
			ModernizedCProgram.Curl_infof(data, "WSACloseEvent failed (%d)", ((int).WSAGetLastError()));
		} 
		create_event_func = ((Object)/* "Forget" pointers into the library we're about to free */0);
		close_event_func = ((Object)0);
		event_select_func = ((Object)0);
		enum_netevents_func = ((Object)0);
		if (!.FreeLibrary(/* We called LoadLibrary, so call FreeLibrary */wsock2)) {
			ModernizedCProgram.Curl_infof(data, "FreeLibrary(wsock2) failed (%u)", .GetLastError());
		} 
		ModernizedCProgram.Curl_setup_transfer(data, -1, -1, 0, -/* read from in file *//* read from user-supplied method *//* poll switch statement *//* mark this as "no further transfer wanted" */1);
		return result;
	}
	public static void free_urlhandle(Object u) {
		.Curl_cfree(u.getScheme());
		.Curl_cfree(u.getUser());
		.Curl_cfree(u.getPassword());
		.Curl_cfree(u.getOptions());
		.Curl_cfree(u.getHost());
		.Curl_cfree(u.getZoneid());
		.Curl_cfree(u.getPort());
		.Curl_cfree(u.getPath());
		.Curl_cfree(u.getQuery());
		.Curl_cfree(u.getFragment());
		.Curl_cfree(u.getScratch());
		.Curl_cfree(u.getTemppath());
	}
	/* move the full contents of one handle onto another and
	   free the original */
	public static void mv_urlhandle(Object from, Object to) {
		ModernizedCProgram.free_urlhandle(to);
		to = from;
		.Curl_cfree(from/*
		 * Find the separator at the end of the host name, or the '?' in cases like
		 * http://www.url.com?id=2380
		 */);
	}
	public static Object find_host_sep(Object url) {
		byte sep;
		byte query;
		sep = .strstr(url, /* Find the start of the hostname */"//");
		if (!sep) {
			sep = url;
		} else {
				sep += 2;
		} 
		query = .strchr(sep, (byte)'?');
		sep = .strchr(sep, (byte)'/');
		if (!sep) {
			sep = url + .strlen(url);
		} 
		if (!query) {
			query = url + .strlen(url);
		} 
		return sep < query ? sep : query/*
		 * Decide in an encoding-independent manner whether a character in an
		 * URL must be escaped. The same criterion must be used in strlen_url()
		 * and strcpy_url().
		 */;
	}
	public static  urlchar_needs_escaping(int c) {
		return !((ModernizedCProgram.Curl_iscntrl((int)((byte)c))) || (ModernizedCProgram.Curl_isspace((int)((byte)c))) || (ModernizedCProgram.Curl_isgraph((int)((byte)c/*
		 * strlen_url() returns the length of the given URL if the spaces within the
		 * URL were properly URL encoded.
		 * URL encoding should be skipped for host names, otherwise IDN resolution
		 * will fail.
		 */))));
	}
	public static Object strlen_url(Object url,  relative) {
		byte ptr;
		size_t newlen = 0;
		bool left = /* left side of the ? */1;
		byte host_sep = (byte)url;
		if (!relative) {
			host_sep = (byte)ModernizedCProgram.find_host_sep(url);
		} 
		for (ptr = (byte)url; ptr; ptr++) {
			if (ptr < host_sep) {
				++newlen;
				continue;
			} 
			switch (ptr) {
			case (byte)' ':
					if (left) {
						newlen += 3;
					} else {
							newlen++;
					} 
					break;
			case (byte)'?':
					left = 0/* FALLTHROUGH */;
			default:
					if (ModernizedCProgram.urlchar_needs_escaping(ptr)) {
						newlen += 2;
					} 
					newlen++;
					break;
			}
		}
		return newlen/* strcpy_url() copies a url to a output buffer and URL-encodes the spaces in
		 * the source URL accordingly.
		 * URL encoding should be skipped for host names, otherwise IDN resolution
		 * will fail.
		 */;
	}
	public static void strcpy_url(Object output, Object url,  relative) {
		bool left = /* we must add this with whitespace-replacing */1;
		byte iptr;
		byte optr = output;
		byte host_sep = (byte)url;
		if (!relative) {
			host_sep = (byte)ModernizedCProgram.find_host_sep(url);
		} 
		for (iptr = (byte)/* read from here */url; /* until zero byte */iptr; iptr++) {
			if (iptr < host_sep) {
				optr++ = iptr;
				continue;
			} 
			switch (iptr) {
			case (byte)' ':
					if (left) {
						optr++ = /* add a '%' */(byte)'%';
						optr++ = /* add a '2' */(byte)'2';
						optr++ = /* add a '0' */(byte)'0';
					} else {
							optr++ = /* add a '+' here */(byte)'+';
					} 
					break;
			case (byte)'?':
					left = 0/* FALLTHROUGH */;
			default:
					if (ModernizedCProgram.urlchar_needs_escaping(iptr)) {
						ModernizedCProgram.curl_msnprintf(optr, 4, "%%%02x", iptr);
						optr += 3;
					} else {
							optr++ = iptr;
					} 
					break;
			}
		}
		optr = /* zero terminate output buffer */0/*
		 * Returns true if the given URL is absolute (as opposed to relative) within
		 * the buffer size. Returns the scheme in the buffer if TRUE and 'buf' is
		 * non-NULL.
		 */;
	}
	public static  Curl_is_absolute_url(Object url, Object buf, Object buflen) {
		size_t i = new size_t();
		if (((((byte)'a' <= url[0] && url[0] <= (byte)'z') || ((byte)'A' <= url[0] && url[0] <= (byte)'Z')) && (url[1] == (byte)':'))) {
			return 0;
		} 
		for (i = 0; i < buflen && url[i]; ++i) {
			byte s = url[i];
			if ((s == (byte)':') && (url[i + 1] == (byte)'/')) {
				if (buf) {
					buf[i] = 0;
				} 
				return 1/* RFC 3986 3.1 explains:
				      scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
				    */;
			}  else if ((ModernizedCProgram.Curl_isalnum((int)((byte)s))) || (s == (byte)'+') || (s == (byte)'-') || (s == (byte)'.')) {
				if (buf) {
					buf[i] = (byte)(.tolower((int)((byte)s)));
				} 
			} else {
					break;
			} 
		}
		return 0/*
		 * Concatenate a relative URL to a base URL making it absolute.
		 * URL-encodes any spaces.
		 * The returned pointer must be freed by the caller unless NULL
		 * (returns NULL on out of memory).
		 */;
	}
	public static Object concat_url(Object base, Object relurl) {
		byte newest;
		byte protsep;
		byte pathsep;
		size_t newlen = new size_t();
		bool host_changed = 0;
		byte useurl = relurl;
		size_t urllen = new size_t();
		byte url_clone = .Curl_cstrdup(/* we must make our own copy of the URL to play with, as it may
		     point to read-only data */base);
		if (!url_clone) {
			return ((Object)/* skip out of this NOW */0);
		} 
		protsep = .strstr(url_clone, /* protsep points to the start of the host name */"//");
		if (!protsep) {
			protsep = url_clone;
		} else {
				protsep += /* pass the slashes */2;
		} 
		if ((byte)'/' != relurl[0]) {
			int level = 0;
			pathsep = .strchr(protsep, /* First we need to find out if there's a ?-letter in the URL,
			       and cut it and the right-side of that off */(byte)'?');
			if (pathsep) {
				pathsep = 0/* we have a relative path to append to the last slash if there's one
				       available, or if the new URL is just a query string (starts with a
				       '?')  we append the new one at the end of the entire currently worked
				       out URL */;
			} 
			if (useurl[0] != (byte)'?') {
				pathsep = .strrchr(protsep, (byte)'/');
				if (pathsep) {
					pathsep = 0;
				} 
			} 
			pathsep = .strchr(protsep, /* Check if there's any slash after the host name, and if so, remember
			       that position instead */(byte)'/');
			if (pathsep) {
				protsep = pathsep + 1;
			} else {
					protsep = ((Object)0/* now deal with one "./" or any amount of "../" in the newurl
					       and act accordingly */);
			} 
			if ((useurl[0] == (byte)'.') && (useurl[1] == (byte)'/')) {
				useurl += /* just skip the "./" */2;
			} 
			while ((useurl[0] == (byte)'.') && (useurl[1] == (byte)'.') && (useurl[2] == (byte)'/')) {
				level++;
				useurl += /* pass the "../" */3;
			}
			if (protsep) {
				while (level--) {
					pathsep = .strrchr(protsep, /* cut off one more level from the right of the original URL */(byte)'/');
					if (pathsep) {
						pathsep = 0;
					} else {
							protsep = 0;
							break;
					} 
				}
			} 
		} else {
				if (relurl[1] == /* We got a new absolute path for this server */(byte)'/'/* the new URL starts with //, just keep the protocol part from the
				         original one */) {
					protsep = 0;
					useurl = relurl[/* we keep the slashes from the original, so we
					                              skip the new ones */2];
					host_changed = 1;
				} else {
						pathsep = .strchr(protsep, /* cut off the original URL from the first slash, or deal with URLs
						         without slash */(byte)'/');
						if (pathsep/* When people use badly formatted URLs, such as
						           "http://www.url.com?dir=/home/daniel" we must not use the first
						           slash, if there's a ?-letter before it! */) {
							byte sep = .strchr(protsep, (byte)'?');
							if (sep && (sep < pathsep)) {
								pathsep = sep;
							} 
							pathsep = 0/* There was no slash. Now, since we might be operating on a badly
							           formatted URL, such as "http://www.url.com?id=2380" which doesn't
							           use a slash separator as it is supposed to, we need to check for a
							           ?-letter as well! */;
						} else {
								pathsep = .strchr(protsep, (byte)'?');
								if (pathsep) {
									pathsep = 0;
								} 
						} 
				} 
		} 
		newlen = ModernizedCProgram.strlen_url(useurl, !/* If the new part contains a space, this is a mighty stupid redirect
		     but we still make an effort to do "right". To the left of a '?'
		     letter we replace each space with %20 while it is replaced with '+'
		     on the right side of the '?' letter.
		  */host_changed);
		urllen = .strlen(url_clone);
		newest = .Curl_cmalloc(urllen + 1 + newlen + /* possible slash */1/* zero byte */);
		if (!newest) {
			.Curl_cfree(/* don't leak this */url_clone);
			return ((Object)0);
		} 
		.memcpy(newest, url_clone, /* copy over the root url part */urllen);
		if (((byte)'/' == useurl[0]) || (protsep && !protsep) || ((byte)'?' == useurl[/* check if we need to append a slash */0])) {
			;
		} else {
				newest[urllen++] = (byte)'/';
		} 
		ModernizedCProgram.strcpy_url(newest[urllen], useurl, !/* then append the new piece on the right side */host_changed);
		.Curl_cfree(url_clone);
		return newest/*
		 * parse_hostname_login()
		 *
		 * Parse the login details (user name, password and options) from the URL and
		 * strip them out of the host name
		 *
		 */;
	}
	/***
	   TRY to append this new path to the old URL
	   to the right of the host part. Oh crap, this is doomed to cause
	   problems in the future...
	  */
	public static  parse_hostname_login(Object u, Object h, Object hostname, int flags) {
		CURLUcode result = .CURLUE_OK;
		CURLcode ccode = new CURLcode();
		byte userp = ((Object)0);
		byte passwdp = ((Object)0);
		byte optionsp = ((Object)0/* At this point, we're hoping all the other special cases have
		   * been taken care of, so conn->host.name is at most
		   *    [user[:password][;options]]@]hostname
		   *
		   * We need somewhere to put the embedded details, so do that first.
		   */);
		byte ptr = .strchr(hostname, (byte)'@');
		byte login = hostname;
		if (!ptr) {
			;
		} 
		hostname = ++ptr;
		ccode = ModernizedCProgram.Curl_parse_login_details(login, ptr - login - /* We could use the login information in the URL so extract it. Only parse
		     options if the handler says we should. Note that 'h' might be NULL! */1, userp, passwdp, (h && (h.getFlags() & (1 << 10))) ? optionsp : ((Object)0));
		if (ccode) {
			result = .CURLUE_MALFORMED_INPUT;
			;
		} 
		if (userp) {
			if (flags & (1 << 5)) {
				result = /* Option DISALLOW_USER is set and url contains username. */.CURLUE_USER_NOT_ALLOWED;
				;
			} 
			u.setUser(userp);
		} 
		if (passwdp) {
			u.setPassword(passwdp);
		} 
		if (optionsp) {
			u.setOptions(optionsp);
		} 
		return .CURLUE_OK;
		.Curl_cfree(passwdp);
		.Curl_cfree(optionsp);
		return result;
	}
	public static  Curl_parse_port(Object u, Object hostname) {
		byte portptr = ((Object)0);
		byte endbracket;
		int len;
		/*
		   * Find the end of an IPv6 address, either on the ']' ending bracket or
		   * a percent-encoded zone index.
		   */
		if (1 == .sscanf(hostname, "[%*45[0123456789abcdefABCDEF:.]%c%n", endbracket, len)) {
			if ((byte)']' == endbracket) {
				portptr = hostname[len];
			}  else if ((byte)'%' == endbracket) {
				int zonelen = len;
				if (1 == .sscanf(hostname + zonelen, "%*[^]]%c%n", endbracket, len)) {
					if ((byte)']' != endbracket) {
						return .CURLUE_MALFORMED_INPUT;
					} 
					portptr = hostname[--zonelen + len + 1];
				} else {
						return .CURLUE_MALFORMED_INPUT;
				} 
			} else {
					return .CURLUE_MALFORMED_INPUT;
			} 
			if (portptr && /* this is a RFC2732-style specified IP-address */portptr) {
				if (portptr != (byte)':') {
					return .CURLUE_MALFORMED_INPUT;
				} 
			} else {
					portptr = ((Object)0);
			} 
		} else {
				portptr = .strchr(hostname, (byte)':');
		} 
		if (portptr) {
			byte rest;
			long port;
			byte[] portbuf = new byte[7/* Browser behavior adaptation. If there's a colon with no digits after,
			       just cut off the name there which makes us ignore the colon and just
			       use the default port. Firefox, Chrome and Safari all do that. */];
			if (!portptr[1]) {
				portptr = (byte)'\0';
				return .CURLUE_OK;
			} 
			if (!(ModernizedCProgram.Curl_isdigit((int)((byte)portptr[1])))) {
				return .CURLUE_BAD_PORT_NUMBER;
			} 
			port = .strtol(portptr + 1, rest, /* Port number must be decimal */10);
			if ((port <= 0) || (port > -1024/* Single unix standard says port numbers are 16 bits long, but we don't
			         treat port zero as OK. */)) {
				return .CURLUE_BAD_PORT_NUMBER;
			} 
			if (rest[0]) {
				return .CURLUE_BAD_PORT_NUMBER;
			} 
			portptr++ = /* cut off the name there */(byte)'\0';
			rest = 0;
			ModernizedCProgram.curl_msnprintf(portbuf, , "%ld", /* generate a new port number string to get rid of leading zeroes etc */port);
			u.setPortnum(port);
			u.setPort(.Curl_cstrdup(portbuf));
			if (!u.getPort()) {
				return .CURLUE_OUT_OF_MEMORY;
			} 
		} 
		return .CURLUE_OK;
	}
	/* scan for byte values < 31 or 127 */
	public static  junkscan(Object part) {
		if (part) {
			byte[] badbytes = new byte[]{-1024, -1024, -1024, -1024, -1024, -1024, /* */-1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, /* zero terminate */-1024};
			size_t n = .strlen(part);
			size_t nfine = .strcspn(part, badbytes);
			if (nfine != n/* since we don't know which part is scanned, return a generic error
			         code */) {
				return .CURLUE_MALFORMED_INPUT;
			} 
		} 
		return .CURLUE_OK;
	}
	public static  hostname_check(Object u, Object hostname) {
		size_t len = new size_t();
		size_t hlen = .strlen(hostname);
		if (hostname[0] == (byte)'[') {
			byte l = /* fits a binary IPv6 address */"0123456789abcdefABCDEF:.";
			if (hlen < /* '[::1]' is the shortest possible valid string */5) {
				return .CURLUE_MALFORMED_INPUT;
			} 
			hostname++;
			hlen -= 2;
			if (hostname[hlen] != (byte)']') {
				return .CURLUE_MALFORMED_INPUT;
			} 
			len = .strspn(hostname, /* only valid letters are ok */l);
			if (hlen != len) {
				hlen = len;
				if (hostname[len] == (byte)'%') {
					byte[] zoneid = new byte[/* this could now be '%[zone id]' */16];
					int i = 0;
					byte h = hostname[len + 1];
					if (!.strncmp(h, "25", 2) && h[2] && (h[2] != /* pass '25' if present and is a url encoded percent sign */(byte)']')) {
						h += 2;
					} 
					while (h && (h != (byte)']') && (i < 15)) {
						zoneid[i++] = h++;
					}
					if (!i || ((byte)']' != h)) {
						return .CURLUE_MALFORMED_INPUT;
					} 
					zoneid[i] = 0;
					u.setZoneid(.Curl_cstrdup(zoneid));
					if (!u.getZoneid()) {
						return .CURLUE_OUT_OF_MEMORY;
					} 
					hostname[len] = /* insert end bracket */(byte)']';
					hostname[len + 1] = /* terminate the hostname */0;
				} else {
						return .CURLUE_MALFORMED_INPUT/* hostname is fine *//* end the address there */;
				} 
			} 
		} else {
				len = .strcspn(hostname, /* restore ending bracket *//* letters from the second string is not ok */" ");
				if (hlen != len) {
					return /* hostname with bad content */.CURLUE_MALFORMED_INPUT;
				} 
		} 
		if (!hostname[0]) {
			return .CURLUE_NO_HOST;
		} 
		return .CURLUE_OK;
	}
	public static  seturl(Object url, Object u, int flags) {
		byte path;
		bool path_alloced = 0;
		byte hostname;
		byte query = ((Object)0);
		byte fragment = ((Object)0);
		CURLUcode result = new CURLUcode();
		bool url_has_scheme = 0;
		byte[] schemebuf = new byte[40 + 1];
		byte schemep = ((Object)0);
		size_t schemelen = 0;
		size_t urllen = new size_t();
		Curl_handler h = ((Object)0);
		if (!url) {
			return .CURLUE_MALFORMED_INPUT/*************************************************************
			   * Parse the URL.
			   ************************************************************/;
		} 
		urllen = .strlen(/* allocate scratch area */url);
		if (urllen > 8000000) {
			return /* excessive input length */.CURLUE_MALFORMED_INPUT;
		} 
		path = u.setScratch(.Curl_cmalloc(urllen * 2 + 2));
		if (!path) {
			return .CURLUE_OUT_OF_MEMORY;
		} 
		hostname = path[urllen + 1];
		hostname[0] = 0;
		if (ModernizedCProgram.Curl_is_absolute_url(url, schemebuf, )) {
			url_has_scheme = 1;
			schemelen = .strlen(schemebuf);
		} 
		if (url_has_scheme && ModernizedCProgram.Curl_strcasecompare(schemebuf, /* handle the file: scheme */"file")) {
			.strcpy(path, url[/* path has been allocated large enough to hold this */5]);
			hostname = ((Object)/* no host for file: URLs */0);
			u.setScheme(.Curl_cstrdup("file"));
			if (!u.getScheme()) {
				return .CURLUE_OUT_OF_MEMORY/* Extra handling URLs with an authority component (i.e. that start with
				     * "file://")
				     *
				     * We allow omitted hostname (e.g. file:/<path>) -- valid according to
				     * RFC 8089, but not the (current) WHAT-WG URL spec.
				     */;
			} 
			if (path[0] == (byte)'/' && path[1] == (byte)'/') {
				byte ptr = path[/* swallow the two slashes */2/*
				       * According to RFC 8089, a file: URL can be reliably dereferenced if:
				       *
				       *  o it has no/blank hostname, or
				       *
				       *  o the hostname matches "localhost" (case-insensitively), or
				       *
				       *  o the hostname is a FQDN that resolves to this machine.
				       *
				       * For brevity, we only consider URLs with empty, "localhost", or
				       * "127.0.0.1" hostnames as local.
				       *
				       * Additionally, there is an exception for URLs with a Windows drive
				       * letter in the authority (which was accidentally omitted from RFC 8089
				       * Appendix E, but believe me, it was meant to be there. --MK)
				       */];
				if (ptr[0] != (byte)'/' && !((((byte)'a' <= (ptr)[0] && (ptr)[0] <= (byte)'z') || ((byte)'A' <= (ptr)[0] && (ptr)[0] <= (byte)'Z')) && ((ptr)[1] == (byte)':' || (ptr)[1] == (byte)'|') && ((ptr)[2] == (byte)'/' || (ptr)[2] == (byte)'\\' || (ptr)[2] == 0/* the URL includes a host name, it must match "localhost" or
				           "127.0.0.1" to be valid */))) {
					if (!ModernizedCProgram.curl_strnequal("localhost/", ptr, .strlen("localhost/")) && !ModernizedCProgram.curl_strnequal("127.0.0.1/", ptr, .strlen("127.0.0.1/"/* Invalid file://hostname/, expected localhost or 127.0.0.1 or
					             none */))) {
						return .CURLUE_MALFORMED_INPUT;
					} 
					ptr += /* now points to the slash after the host */9;
				} 
				path = ptr/* Don't allow Windows drive letters when not in Windows.
				     * This catches both "file:/c:" and "file:c:" */;
			} 
			if ((byte)'/' == path[0] && ((((byte)'a' <= (path[1])[0] && (path[1])[0] <= (byte)'z') || ((byte)'A' <= (path[1])[0] && (path[1])[0] <= (byte)'Z')) && ((path[1])[1] == (byte)':' || (path[1])[1] == (byte)'|') && ((path[1])[2] == (byte)'/' || (path[1])[2] == (byte)'\\' || (path[1])[2] == /* File drive letters are only accepted in MSDOS/Windows *//* If the path starts with a slash and a drive letter, ditch the slash */0))) {
				.memmove(path, path[1], .strlen(path[1]) + /* This cannot be done with strcpy, as the memory chunks overlap! */1);
			} 
		} else {
				byte p;
				byte hostp;
				size_t len = new size_t();
				path[0] = 0;
				if (url_has_scheme) {
					int i = 0;
					p = url[schemelen + 1];
					while (p && (p == (byte)'/') && (i < 4)) {
						p++;
						i++;
					}
					if ((i < 1) || (i > 3)) {
						return /* less than one or more than three slashes */.CURLUE_MALFORMED_INPUT;
					} 
					schemep = schemebuf;
					if (!ModernizedCProgram.Curl_builtin_scheme(schemep) && !(flags & (1 << 3))) {
						return .CURLUE_UNSUPPORTED_SCHEME;
					} 
					if (ModernizedCProgram.junkscan(schemep)) {
						return .CURLUE_MALFORMED_INPUT;
					} 
				} else {
						if (!(flags & ((1 << 2) | (1 << /* no scheme! */9)))) {
							return .CURLUE_MALFORMED_INPUT;
						} 
						if (flags & (1 << 2)) {
							schemep = (byte)"https"/*
							       * The URL was badly formatted, let's try without scheme specified.
							       */;
						} 
						p = url;
				} 
				hostp = /* host name starts here */p;
				while (p && !(((p) == (byte)'/') || ((p) == (byte)'?') || ((p) == /* find end of host name */(byte)'#'))) {
					p++;
				}
				len = p - hostp;
				if (len) {
					.memcpy(hostname, hostp, len);
					hostname[len] = 0;
				} else {
						if (!(flags & (1 << 10))) {
							return .CURLUE_MALFORMED_INPUT;
						} 
				} 
				if ((flags & (1 << 9)) && !schemep) {
					if (ModernizedCProgram.curl_strnequal("ftp.", hostname, .strlen(/* legacy curl-style guess based on host name */"ftp."))) {
						schemep = (byte)"ftp";
					}  else if (ModernizedCProgram.curl_strnequal("dict.", hostname, .strlen("dict."))) {
						schemep = (byte)"dict";
					}  else if (ModernizedCProgram.curl_strnequal("ldap.", hostname, .strlen("ldap."))) {
						schemep = (byte)"ldap";
					}  else if (ModernizedCProgram.curl_strnequal("imap.", hostname, .strlen("imap."))) {
						schemep = (byte)"imap";
					}  else if (ModernizedCProgram.curl_strnequal("smtp.", hostname, .strlen("smtp."))) {
						schemep = (byte)"smtp";
					}  else if (ModernizedCProgram.curl_strnequal("pop3.", hostname, .strlen("pop3."))) {
						schemep = (byte)"pop3";
					} else {
							schemep = (byte)"http";
					} 
				} 
				len = .strlen(p);
				.memcpy(path, p, len);
				path[len] = 0;
				u.setScheme(.Curl_cstrdup(schemep));
				if (!u.getScheme()) {
					return .CURLUE_OUT_OF_MEMORY;
				} 
		} 
		h = ModernizedCProgram.Curl_builtin_scheme(u.getScheme());
		if (ModernizedCProgram.junkscan(path)) {
			return .CURLUE_MALFORMED_INPUT;
		} 
		if ((flags & (1 << 7)) && path[0]) {
			byte newp = .Curl_cmalloc(.strlen(path) * /* worst case output length is 3x the original! */3);
			if (!newp) {
				return .CURLUE_OUT_OF_MEMORY;
			} 
			path_alloced = 1;
			ModernizedCProgram.strcpy_url(newp, path, /* consider it relative */1);
			u.setTemppath(path = newp);
		} 
		fragment = .strchr(path, (byte)'#');
		if (fragment) {
			fragment++ = 0;
			if (fragment[0]) {
				u.setFragment(.Curl_cstrdup(fragment));
				if (!u.getFragment()) {
					return .CURLUE_OUT_OF_MEMORY;
				} 
			} 
		} 
		query = .strchr(path, (byte)'?');
		if (query) {
			query++ = 0;
			u.setQuery(.Curl_cstrdup(/* done even if the query part is a blank string */query));
			if (!u.getQuery()) {
				return .CURLUE_OUT_OF_MEMORY;
			} 
		} 
		if (!path[0]) {
			path = ((Object)/* if there's no path left set, unset */0);
		} else {
				if (!(flags & (1 << 4))) {
					byte newp = ModernizedCProgram.Curl_dedotdotify(/* remove ../ and ./ sequences according to RFC3986 */path);
					if (!newp) {
						return .CURLUE_OUT_OF_MEMORY;
					} 
					if (.strcmp(newp, path)) {
						if (/* if we got a new version */path_alloced) {
							do {
								.Curl_cfree((u.getTemppath()));
								(u.getTemppath()) = ((Object)0);
							} while (0);
						} 
						u.setTemppath(path = newp);
						path_alloced = 1;
					} else {
							.Curl_cfree(newp);
					} 
				} 
				u.setPath(path_alloced ? path : .Curl_cstrdup(path));
				if (!u.getPath()) {
					return .CURLUE_OUT_OF_MEMORY;
				} 
				u.setTemppath(((Object)/* used now */0));
		} 
		if (hostname/*
		     * Parse the login details and strip them out of the host name.
		     */) {
			if (ModernizedCProgram.junkscan(hostname)) {
				return .CURLUE_MALFORMED_INPUT;
			} 
			result = ModernizedCProgram.parse_hostname_login(u, h, hostname, flags);
			if (result) {
				return result;
			} 
			result = ModernizedCProgram.Curl_parse_port(u, hostname);
			if (result) {
				return result;
			} 
			if (0 == .strlen(hostname) && (flags & (1 << 10/* Skip hostname check, it's allowed to be empty. */))) {
			} else {
					result = ModernizedCProgram.hostname_check(u, hostname);
					if (result) {
						return result;
					} 
			} 
			u.setHost(.Curl_cstrdup(hostname));
			if (!u.getHost()) {
				return .CURLUE_OUT_OF_MEMORY;
			} 
		} 
		do {
			.Curl_cfree((u.getScratch()));
			(u.getScratch()) = ((Object)0);
		} while (0);
		do {
			.Curl_cfree((u.getTemppath()));
			(u.getTemppath()) = ((Object)0);
		} while (0);
		return .CURLUE_OK/*
		 * Parse the URL and set the relevant members of the Curl_URL struct.
		 */;
	}
	public static  parseurl(Object url, Object u, int flags) {
		CURLUcode result = ModernizedCProgram.seturl(url, u, flags);
		if (result) {
			ModernizedCProgram.free_urlhandle(u);
			.memset(u, 0, );
		} 
		return result;
	}
	/*
	 */
	public static Object curl_url() {
		return .Curl_ccalloc(, 1);
	}
	public static void curl_url_cleanup(Object u) {
		if (u) {
			ModernizedCProgram.free_urlhandle(u);
			.Curl_cfree(u);
		} 
	}
	public static Object curl_url_dup(Object in) {
		Curl_URL u = .Curl_ccalloc(, 1);
		if (u) {
			if (in.getScheme()) {
				u.setScheme(.Curl_cstrdup(in.getScheme()));
				if (!u.getScheme()) {
					;
				} 
			} 
			;
			if (in.getUser()) {
				u.setUser(.Curl_cstrdup(in.getUser()));
				if (!u.getUser()) {
					;
				} 
			} 
			;
			if (in.getPassword()) {
				u.setPassword(.Curl_cstrdup(in.getPassword()));
				if (!u.getPassword()) {
					;
				} 
			} 
			;
			if (in.getOptions()) {
				u.setOptions(.Curl_cstrdup(in.getOptions()));
				if (!u.getOptions()) {
					;
				} 
			} 
			;
			if (in.getHost()) {
				u.setHost(.Curl_cstrdup(in.getHost()));
				if (!u.getHost()) {
					;
				} 
			} 
			;
			if (in.getPort()) {
				u.setPort(.Curl_cstrdup(in.getPort()));
				if (!u.getPort()) {
					;
				} 
			} 
			;
			if (in.getPath()) {
				u.setPath(.Curl_cstrdup(in.getPath()));
				if (!u.getPath()) {
					;
				} 
			} 
			;
			if (in.getQuery()) {
				u.setQuery(.Curl_cstrdup(in.getQuery()));
				if (!u.getQuery()) {
					;
				} 
			} 
			;
			if (in.getFragment()) {
				u.setFragment(.Curl_cstrdup(in.getFragment()));
				if (!u.getFragment()) {
					;
				} 
			} 
			;
			u.setPortnum(in.getPortnum());
		} 
		return u;
		return ((Object)0);
	}
	public static  curl_url_get(Object u,  what, Object part, int flags) {
		byte ptr;
		CURLUcode ifmissing = .CURLUE_UNKNOWN_PART;
		byte[] portbuf = new byte[7];
		bool urldecode = (flags & (1 << 6)) ? 1 : 0;
		bool plusdecode = 0;
		(Object)flags;
		if (!u) {
			return .CURLUE_BAD_HANDLE;
		} 
		if (!part) {
			return .CURLUE_BAD_PARTPOINTER;
		} 
		part = ((Object)0);
		switch (what) {
		case .CURLUPART_OPTIONS:
				ptr = u.getOptions();
				ifmissing = .CURLUE_NO_OPTIONS;
				break;
		case .CURLUPART_HOST:
				ptr = u.getHost();
				ifmissing = .CURLUE_NO_HOST;
				break;
		case .CURLUPART_FRAGMENT:
				ptr = u.getFragment();
				ifmissing = .CURLUE_NO_FRAGMENT;
				break;
		case .CURLUPART_SCHEME:
				ptr = u.getScheme();
				ifmissing = .CURLUE_NO_SCHEME;
				urldecode = /* never for schemes */0;
				break;
		case .CURLUPART_URL:
				{ 
					byte url;
					byte scheme;
					byte options = u.getOptions();
					byte port = u.getPort();
					byte allochost = ((Object)0);
					if (u.getScheme() && ModernizedCProgram.Curl_strcasecompare("file", u.getScheme())) {
						url = ModernizedCProgram.curl_maprintf("file://%s%s%s", u.getPath(), u.getFragment() ? "#" : "", u.getFragment() ? u.getFragment() : "");
					}  else if (!u.getHost()) {
						return .CURLUE_NO_HOST;
					} else {
							Curl_handler h = ((Object)0);
							if (u.getScheme()) {
								scheme = u.getScheme();
							}  else if (flags & (1 << 2)) {
								scheme = (byte)"https";
							} else {
									return .CURLUE_NO_SCHEME;
							} 
							h = ModernizedCProgram.Curl_builtin_scheme(scheme);
							if (!port && (flags & (1 << 0/* there's no stored port number, but asked to deliver
							           a default one for the scheme */))) {
								if (h) {
									ModernizedCProgram.curl_msnprintf(portbuf, , "%ld", h.getDefport());
									port = portbuf;
								} 
							}  else if (port/* there is a stored port number, but asked to inhibit if it matches
							           the default one for the scheme */) {
								if (h && (h.getDefport() == u.getPortnum()) && (flags & (1 << 1))) {
									port = ((Object)0);
								} 
							} 
							if (h && !(h.getFlags() & (1 << 10))) {
								options = ((Object)0);
							} 
							if ((u.getHost()[0] == (byte)'[') && u.getZoneid()) {
								size_t hostlen = .strlen(u.getHost());
								size_t alen = hostlen + 3 + .strlen(u.getZoneid()) + 1;
								allochost = .Curl_cmalloc(alen);
								if (!allochost) {
									return .CURLUE_OUT_OF_MEMORY;
								} 
								.memcpy(allochost, u.getHost(), hostlen - 1);
								ModernizedCProgram.curl_msnprintf(allochost[hostlen - 1], alen - hostlen + 1, "%%25%s]", u.getZoneid());
							} 
							url = ModernizedCProgram.curl_maprintf("%s://%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s", scheme, u.getUser() ? u.getUser() : "", u.getPassword() ? ":" : "", u.getPassword() ? u.getPassword() : "", options ? ";" : "", options ? options : "", (u.getUser() || u.getPassword() || options) ? "@" : "", allochost ? allochost : u.getHost(), port ? ":" : "", port ? port : "", (u.getPath() && (u.getPath()[0] != (byte)'/')) ? "/" : "", u.getPath() ? u.getPath() : "/", (u.getQuery() && u.getQuery()[0]) ? "?" : "", (u.getQuery() && u.getQuery()[0]) ? u.getQuery() : "", u.getFragment() ? "#" : "", u.getFragment() ? u.getFragment() : "");
							.Curl_cfree(allochost);
					} 
					if (!url) {
						return .CURLUE_OUT_OF_MEMORY;
					} 
					part = url;
					return .CURLUE_OK;
				}
		case .CURLUPART_PASSWORD:
				ptr = u.getPassword();
				ifmissing = .CURLUE_NO_PASSWORD;
				break;
		case .CURLUPART_USER:
				ptr = u.getUser();
				ifmissing = .CURLUE_NO_USER;
				break;
		case .CURLUPART_PORT:
				ptr = u.getPort();
				ifmissing = .CURLUE_NO_PORT;
				urldecode = /* never for port */0;
				if (!ptr && (flags & (1 << 0)) && u.getScheme()) {
					Curl_handler h = ModernizedCProgram.Curl_builtin_scheme(u.getScheme());
					if (h) {
						ModernizedCProgram.curl_msnprintf(portbuf, , "%ld", h.getDefport());
						ptr = portbuf;
					} 
				}  else if (ptr && u.getScheme()) {
					Curl_handler h = ModernizedCProgram.Curl_builtin_scheme(u.getScheme());
					if (h && (h.getDefport() == u.getPortnum()) && (flags & (1 << 1))) {
						ptr = ((Object)0);
					} 
				} 
				break;
		case .CURLUPART_ZONEID:
				ptr = u.getZoneid();
				break;
		case .CURLUPART_QUERY:
				ptr = u.getQuery();
				ifmissing = .CURLUE_NO_QUERY;
				plusdecode = urldecode;
				break;
		case .CURLUPART_PATH:
				ptr = u.getPath();
				if (!ptr) {
					ptr = u.setPath(.Curl_cstrdup("/"));
					if (!u.getPath()) {
						return .CURLUE_OUT_OF_MEMORY;
					} 
				} 
				break;
		default:
				ptr = ((Object)0);
				break;
		}
		if (ptr) {
			part = .Curl_cstrdup(ptr);
			if (!part) {
				return .CURLUE_OUT_OF_MEMORY;
			} 
			if (plusdecode/* convert + to space */) {
				byte plus;
				for (plus = part; plus; ++plus) {
					if (plus == (byte)'+') {
						plus = (byte)' ';
					} 
				}
			} 
			if (urldecode) {
				byte decoded;
				size_t dlen = new size_t();
				CURLcode res = ModernizedCProgram.Curl_urldecode(((Object)0), part, 0, decoded, dlen, 1);
				.Curl_cfree(part);
				if (res) {
					part = ((Object)0);
					return .CURLUE_URLDECODE;
				} 
				part = decoded;
			} 
			return .CURLUE_OK;
		} else {
				return ifmissing;
		} 
	}
	public static  curl_url_set(Object u,  what, Object part, int flags) {
		byte storep = ((Object)0);
		long port = 0;
		bool urlencode = (flags & (1 << 7)) ? 1 : 0;
		bool plusencode = 0;
		bool urlskipslash = 0;
		bool appendquery = 0;
		bool equalsencode = 0;
		if (!u) {
			return .CURLUE_BAD_HANDLE;
		} 
		if (!part) {
			switch (/* setting a part to NULL clears it */what) {
			case .CURLUPART_URL:
					break;
			case .CURLUPART_PATH:
					storep = u.getPath();
					break;
			case .CURLUPART_USER:
					storep = u.getUser();
					break;
			case .CURLUPART_HOST:
					storep = u.getHost();
					break;
			case .CURLUPART_PASSWORD:
					storep = u.getPassword();
					break;
			case .CURLUPART_QUERY:
					storep = u.getQuery();
					break;
			case .CURLUPART_FRAGMENT:
					storep = u.getFragment();
					break;
			case .CURLUPART_OPTIONS:
					storep = u.getOptions();
					break;
			case .CURLUPART_PORT:
					u.setPortnum(0);
					storep = u.getPort();
					break;
			case .CURLUPART_SCHEME:
					storep = u.getScheme();
					break;
			case .CURLUPART_ZONEID:
					storep = u.getZoneid();
					break;
			default:
					return .CURLUE_UNKNOWN_PART;
			}
			if (storep && storep) {
				.Curl_cfree(storep);
				storep = ((Object)0);
			} 
			return .CURLUE_OK;
		} 
		switch (what) {
		case .CURLUPART_QUERY:
				plusencode = urlencode;
				appendquery = (flags & (1 << 8)) ? 1 : 0;
				equalsencode = appendquery;
				storep = u.getQuery();
				break;
		case .CURLUPART_FRAGMENT:
				storep = u.getFragment();
				break;
		case .CURLUPART_SCHEME:
				if (.strlen(part) > 40) {
					return /* too long */.CURLUE_MALFORMED_INPUT;
				} 
				if (!(flags & (1 << 3)) && !ModernizedCProgram.Curl_builtin_scheme(/* verify that it is a fine scheme */part)) {
					return .CURLUE_UNSUPPORTED_SCHEME;
				} 
				storep = u.getScheme();
				urlencode = /* never */0;
				break;
		case .CURLUPART_PASSWORD:
				storep = u.getPassword();
				break;
		case .CURLUPART_HOST:
				storep = u.getHost();
				.Curl_cfree(u.getZoneid());
				u.setZoneid(((Object)0));
				break;
		case .CURLUPART_PORT:
				{ 
					byte endp;
					urlencode = /* never */0;
					port = .strtol(part, endp, /* Port number must be decimal */10);
					if ((port <= 0) || (port > -1024)) {
						return .CURLUE_BAD_PORT_NUMBER;
					} 
					if (endp) {
						return /* weirdly provided number, not good! */.CURLUE_MALFORMED_INPUT;
					} 
					storep = u.getPort();
				}
				break;
		case .CURLUPART_PATH:
				urlskipslash = 1;
				storep = u.getPath();
				break;
		case .CURLUPART_URL/*
		     * Allow a new URL to replace the existing (if any) contents.
		     *
		     * If the existing contents is enough for a URL, allow a relative URL to
		     * replace it.
		     */:
				{ 
					CURLUcode result = new CURLUcode();
					byte oldurl;
					byte redired_url;
					CURLU handle2 = new CURLU();
					if (ModernizedCProgram.Curl_is_absolute_url(part, ((Object)0), 40 + 1)) {
						handle2 = ModernizedCProgram.curl_url();
						if (!handle2) {
							return .CURLUE_OUT_OF_MEMORY;
						} 
						result = ModernizedCProgram.parseurl(part, handle2, flags);
						if (!result) {
							ModernizedCProgram.mv_urlhandle(handle2, u);
						} else {
								ModernizedCProgram.curl_url_cleanup(handle2);
						} 
						return result;
					} 
					result = ModernizedCProgram.curl_url_get(u, .CURLUPART_URL, oldurl, /* extract the full "old" URL to do the redirect on */flags);
					if (result) {
						handle2 = ModernizedCProgram.curl_url();
						if (!handle2) {
							return .CURLUE_OUT_OF_MEMORY;
						} 
						result = ModernizedCProgram.parseurl(part, handle2, flags);
						if (!result) {
							ModernizedCProgram.mv_urlhandle(handle2, u);
						} else {
								ModernizedCProgram.curl_url_cleanup(handle2);
						} 
						return result;
					} 
					redired_url = ModernizedCProgram.concat_url(oldurl, /* apply the relative part to create a new URL */part);
					.Curl_cfree(oldurl);
					if (!redired_url) {
						return .CURLUE_OUT_OF_MEMORY;
					} 
					handle2 = ModernizedCProgram.curl_url();
					if (!handle2) {
						.Curl_cfree(redired_url);
						return .CURLUE_OUT_OF_MEMORY;
					} 
					result = ModernizedCProgram.parseurl(redired_url, handle2, flags);
					.Curl_cfree(redired_url);
					if (!result) {
						ModernizedCProgram.mv_urlhandle(handle2, u);
					} else {
							ModernizedCProgram.curl_url_cleanup(handle2);
					} 
					return result;
				}
		case .CURLUPART_OPTIONS:
				storep = u.getOptions();
				break;
		case .CURLUPART_ZONEID:
				storep = u.getZoneid();
				break;
		case .CURLUPART_USER:
				storep = u.getUser();
				break;
		default:
				return .CURLUE_UNKNOWN_PART;
		}
		do {
		} while (0);
		{ 
			byte newp = part;
			size_t nalloc = .strlen(part);
			if (nalloc > 8000000) {
				return /* excessive input length */.CURLUE_MALFORMED_INPUT;
			} 
			if (urlencode) {
				byte i;
				byte o;
				bool free_part = 0;
				byte enc = .Curl_cmalloc(nalloc * 3 + /* for worst case! */1);
				if (!enc) {
					return .CURLUE_OUT_OF_MEMORY;
				} 
				if (plusencode) {
					i = (byte)/* space to plus */part;
					for (o = enc; i; ) {
						o = (i == (byte)' ') ? (byte)'+' : i;
					}
					o = /* zero terminate */0;
					part = .Curl_cstrdup(enc);
					if (!part) {
						.Curl_cfree(enc);
						return .CURLUE_OUT_OF_MEMORY;
					} 
					free_part = 1;
				} 
				for (; i; i++) {
					if (ModernizedCProgram.Curl_isunreserved(i) || ((i == (byte)'/') && urlskipslash) || ((i == (byte)'=') && equalsencode) || ((i == (byte)'+') && plusencode)) {
						if ((i == (byte)'=') && equalsencode) {
							equalsencode = /* only skip the first equals sign */0;
						} 
						o = i;
						o++;
					} else {
							ModernizedCProgram.curl_msnprintf(o, 4, "%%%02x", i);
							o += 3;
					} 
				}
				o = /* zero terminate */0;
				newp = enc;
				if (free_part) {
					.Curl_cfree((byte)part);
				} 
			} else {
					byte p;
					newp = .Curl_cstrdup(part);
					if (!newp) {
						return .CURLUE_OUT_OF_MEMORY;
					} 
					p = (byte)newp;
					while (p) {
						if ((p == (byte)'%') && (ModernizedCProgram.Curl_isxdigit((int)((byte)p[1]))) && (ModernizedCProgram.Curl_isxdigit((int)((byte)p[/* make sure percent encoded are lower case */2]))) && ((ModernizedCProgram.Curl_isupper((int)((byte)p[1]))) || (ModernizedCProgram.Curl_isupper((int)((byte)p[2]))))) {
							p[1] = (byte)(.tolower((int)((byte)p[1])));
							p[2] = (byte)(.tolower((int)((byte)p[2])));
							p += 3;
						} else {
								p++;
						} 
					}
			} 
			if (appendquery/* Append the string onto the old query. Add a '&' separator if none is
			         present at the end of the exsting query already */) {
				size_t querylen = u.getQuery() ? .strlen(u.getQuery()) : 0;
				bool addamperand = querylen && (u.getQuery()[querylen - 1] != (byte)'&');
				if (querylen) {
					size_t newplen = .strlen(newp);
					byte p = .Curl_cmalloc(querylen + addamperand + newplen + 1);
					if (!p) {
						.Curl_cfree((byte)newp);
						return .CURLUE_OUT_OF_MEMORY;
					} 
					.strcpy(p, u.getQuery());
					if (addamperand) {
						p[querylen] = /* ampersand */(byte)'&';
					} 
					.strcpy(p[querylen + addamperand], /* new suffix */newp);
					.Curl_cfree((byte)newp);
					.Curl_cfree(storep);
					storep = p;
					return .CURLUE_OK;
				} 
			} 
			if (what == .CURLUPART_HOST) {
				if (0 == .strlen(newp) && (flags & (1 << 10/* Skip hostname check, it's allowed to be empty. */))) {
				} else {
						if (ModernizedCProgram.hostname_check(u, (byte)newp)) {
							.Curl_cfree((byte)newp);
							return .CURLUE_MALFORMED_INPUT;
						} 
				} 
			} 
			.Curl_cfree(storep);
			storep = (byte)newp;
		}
		if (/* set after the string, to make it not assigned if the allocation above
		     fails */port) {
			u.setPortnum(port);
		} 
		return .CURLUE_OK;
	}
	public static Object doh_strerror( code) {
		if ((code >= .DOH_OK) && (code <= .DOH_DNS_BAD_ID)) {
			return ModernizedCProgram.errors[code];
		} 
		return "bad error code";
	}
	/* @unittest 1655
	 */
	public static  doh_encode(Object host,  dnstype, Object dnsp, Object len, Object olen) {
		size_t hostlen = .strlen(/* buffer size *//* output length */host);
		byte orig = dnsp;
		byte hostp = host/* The expected output length does not depend on the number of dots within
		   * the host name. It will always be two more than the length of the host
		   * name, one for the size and one trailing null. In case there are dots,
		   * each dot adds one size but removes the need to store the dot, net zero.
		   */;
		size_t expected_len = 12 + (1 + hostlen + 1) + 4;
		if (len < expected_len) {
			return .DOH_TOO_SMALL_BUFFER;
		} 
		dnsp++ = /* 16 bit id */0;
		dnsp++ = 0;
		dnsp++ = /* |QR|   Opcode  |AA|TC|RD| Set the RD bit */-1024;
		dnsp++ = /* |RA|   Z    |   RCODE   |                */(byte)'\0';
		dnsp++ = (byte)'\0';
		dnsp++ = /* QDCOUNT (number of entries in the question section) */1;
		dnsp++ = (byte)'\0';
		dnsp++ = /* ANCOUNT */(byte)'\0';
		dnsp++ = (byte)'\0';
		dnsp++ = /* NSCOUNT */(byte)'\0';
		dnsp++ = (byte)'\0';
		dnsp++ = /* ARCOUNT */(byte)'\0';
		/* store a QNAME */do {
			byte dot = .strchr(hostp, (byte)'.');
			size_t labellen = new size_t();
			bool found = .bool_false;
			if (dot) {
				found = .bool_true;
				labellen = dot - hostp;
			} else {
					labellen = .strlen(hostp);
			} 
			if (labellen > 63) {
				olen = /* too long label, error out */0;
				return .DOH_DNS_BAD_LABEL;
			} 
			dnsp++ = (byte)labellen;
			.memcpy(dnsp, hostp, labellen);
			dnsp += labellen;
			hostp += labellen + 1;
			if (!found) {
				dnsp++ = /* terminating zero */0;
				break;
			} 
		} while (1);
		dnsp++ = (byte)(255 & (dnstype >> /* There are assigned TYPE codes beyond 255: use range [1..65535]  *//* upper 8 bit TYPE */8));
		dnsp++ = (byte)(255 & /* lower 8 bit TYPE */dnstype);
		dnsp++ = /* upper 8 bit CLASS */(byte)'\0';
		dnsp++ = /* IN - "the Internet" */-1024;
		olen = dnsp - orig;
		do {
		} while (/* verify that our assumption of length is valid, since
		   * this has lead to buffer overflows in this function */0);
		return .DOH_OK;
	}
	/* buffer */
	public static Object doh_write_cb(Object contents, Object size, Object nmemb, Object userp) {
		size_t realsize = size * nmemb;
		dohresponse mem = (dohresponse)userp;
		if ((mem.getSize() + realsize) > 3000) {
			return /* suspiciously much for us */0;
		} 
		mem.setMemory(ModernizedCProgram.Curl_saferealloc(mem.getMemory(), mem.getSize() + realsize));
		if (!mem.getMemory()) {
			return /* out of memory! */0;
		} 
		.memcpy((mem.getMemory()[mem.getSize()]), contents, realsize);
		mem.getSize() += realsize;
		return realsize;
	}
	/* called from multi.c when this DOH transfer is complete */
	public static int Curl_doh_done(Object doh,  result) {
		Curl_easy data = doh.getSet().getDohfor();
		data.getReq().getDoh().getPending()--;
		ModernizedCProgram.Curl_infof(data, "a DOH request is completed, %u to go\n", data.getReq().getDoh().getPending());
		if (result) {
			ModernizedCProgram.Curl_infof(data, "DOH request %s\n", ModernizedCProgram.curl_easy_strerror(result));
		} 
		if (!data.getReq().getDoh().getPending()) {
			ModernizedCProgram.curl_slist_free_all(data.getReq().getDoh().getHeaders());
			data.getReq().getDoh().setHeaders(((Object)0));
			ModernizedCProgram.Curl_expire(data, 0, .EXPIRE_RUN_NOW);
		} 
		return 0;
	}
	public static  dohprobe(Object data, Object p,  dnstype, Object host, Object url, Object multi, Object headers) {
		Curl_easy doh = ((Object)0);
		byte nurl = ((Object)0);
		CURLcode result = .CURLE_OK;
		timediff_t timeout_ms = new timediff_t();
		DOHcode d = ModernizedCProgram.doh_encode(host, dnstype, p.getDohbuffer(), , p.getDohlen());
		if (d) {
			ModernizedCProgram.Curl_failf(data, "Failed to encode DOH packet [%d]\n", d);
			return .CURLE_OUT_OF_MEMORY;
		} 
		p.setDnstype(dnstype);
		p.getServerdoh().setMemory(((Object)0/* the memory will be grown as needed by realloc in the doh_write_cb
		     function */));
		p.getServerdoh().setSize(0/* Note: this is code for sending the DoH request with GET but there's still
		     no logic that actually enables this. We should either add that ability or
		     yank out the GET code. Discuss! */);
		if (data.getSet().getDoh_get()) {
			byte b64;
			size_t b64len = new size_t();
			result = ModernizedCProgram.Curl_base64url_encode(data, (byte)p.getDohbuffer(), p.getDohlen(), b64, b64len);
			if (result) {
				;
			} 
			nurl = ModernizedCProgram.curl_maprintf("%s?dns=%s", url, b64);
			.Curl_cfree(b64);
			if (!nurl) {
				result = .CURLE_OUT_OF_MEMORY;
				;
			} 
			url = nurl;
		} 
		timeout_ms = ModernizedCProgram.Curl_timeleft(data, ((Object)0), 1);
		if (timeout_ms <= 0) {
			result = .CURLE_OPERATION_TIMEDOUT;
			;
		} 
		result = ModernizedCProgram.Curl_open(/* Curl_open() is the internal version of curl_easy_init() */doh);
		if (!result/* pass in the struct pointer via a local variable to please coverity and
		       the gcc typecheck helpers */) {
			dohresponse resp = p.getServerdoh();
			do {
				result = ;
				if (result) {
					;
				} 
			} while (0);
			do {
				result = ;
				if (result) {
					;
				} 
			} while (0);
			do {
				result = ;
				if (result) {
					;
				} 
			} while (0);
			if (!data.getSet().getDoh_get()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			do {
				result = ;
				if (result) {
					;
				} 
			} while (0);
			do {
				result = ;
				if (result) {
					;
				} 
			} while (/* enforce HTTPS if not debug *//* enforce HTTPS if not debug */0/* in debug mode, also allow http */);
			do {
				result = ;
				if (result) {
					;
				} 
			} while (0);
			if (data.getSet().getVerbose()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getNo_signal()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getSsl().getFalsestart()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getSsl().getPrimary().getVerifyhost()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getProxy_ssl().getPrimary().getVerifyhost()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getSsl().getPrimary().getVerifypeer()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getProxy_ssl().getPrimary().getVerifypeer()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getSsl().getPrimary().getVerifystatus()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getStr()[dupstring.STRING_SSL_CAFILE_ORIG]) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getStr()[dupstring.STRING_SSL_CAFILE_PROXY]) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getStr()[dupstring.STRING_SSL_CAPATH_ORIG]) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getStr()[dupstring.STRING_SSL_CAPATH_PROXY]) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getStr()[dupstring.STRING_SSL_CRLFILE_ORIG]) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getStr()[dupstring.STRING_SSL_CRLFILE_PROXY]) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getSsl().getCertinfo()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getStr()[dupstring.STRING_SSL_RANDOM_FILE]) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getStr()[dupstring.STRING_SSL_EGDSOCKET]) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getSsl().getNo_revoke()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getProxy_ssl().getNo_revoke()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getSsl().getFsslctx()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			if (data.getSet().getSsl().getFsslctxp()) {
				do {
					result = ;
					if (result) {
						;
					} 
				} while (0);
			} 
			doh.getSet().setFmultidone(Curl_doh_done);
			doh.getSet().setDohfor(/* identify for which transfer this is done */data);
			p.setEasy(doh);
			if (ModernizedCProgram.curl_multi_add_handle(multi, /* add this transfer to the multi handle */doh)) {
				;
			} 
		} else {
				;
		} 
		.Curl_cfree(nurl);
		return .CURLE_OK;
		ModernizedCProgram.Curl_close(doh);
		return result/*
		 * Curl_doh() resolves a name using DOH. It resolves a name and returns a
		 * 'Curl_addrinfo *' with the address information.
		 */;
	}
	public static Object Curl_doh(Object conn, Object hostname, int port, Object waitp) {
		Curl_easy data = conn.getData();
		CURLcode result = .CURLE_OK;
		waitp = /* this never returns synchronously */1;
		(Object)conn;
		(Object)hostname;
		(Object)port;
		.memset(data.getReq().getDoh(), 0, /* start clean, consider allocating this struct on demand */);
		data.getReq().getDoh().setHost(hostname);
		data.getReq().getDoh().setPort(port);
		data.getReq().getDoh().setHeaders(ModernizedCProgram.curl_slist_append(((Object)0), "Content-Type: application/dns-message"));
		if (!data.getReq().getDoh().getHeaders()) {
			;
		} 
		if (conn.getIp_version() != 2) {
			result = ModernizedCProgram.dohprobe(data, data.getReq().getDoh().getProbe()[0], /* create IPv4 DOH request */.DNS_TYPE_A, hostname, data.getSet().getStr()[dupstring.STRING_DOH], data.getMulti(), data.getReq().getDoh().getHeaders());
			if (result) {
				;
			} 
			data.getReq().getDoh().getPending()++;
		} 
		if (conn.getIp_version() != 1) {
			result = ModernizedCProgram.dohprobe(data, data.getReq().getDoh().getProbe()[1], /* create IPv6 DOH request */.DNS_TYPE_AAAA, hostname, data.getSet().getStr()[dupstring.STRING_DOH], data.getMulti(), data.getReq().getDoh().getHeaders());
			if (result) {
				;
			} 
			data.getReq().getDoh().getPending()++;
		} 
		return ((Object)0);
		data.getReq().getDoh().setHeaders(((Object)0));
		ModernizedCProgram.Curl_close(data.getReq().getDoh().getProbe()[0].getEasy());
		data.getReq().getDoh().getProbe()[0].setEasy(((Object)0));
		ModernizedCProgram.Curl_close(data.getReq().getDoh().getProbe()[1].getEasy());
		data.getReq().getDoh().getProbe()[1].setEasy(((Object)0));
		return ((Object)0);
	}
	public static  skipqname(Object doh, Object dohlen, Object indexp) {
		byte length;
		do {
			if (dohlen < (indexp + 1)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			length = doh[indexp];
			if ((length & -1024) == -1024) {
				if (dohlen < (indexp + /* name pointer, advance over it and be done */2)) {
					return .DOH_DNS_OUT_OF_RANGE;
				} 
				indexp += 2;
				break;
			} 
			if (length & -1024) {
				return .DOH_DNS_BAD_LABEL;
			} 
			if (dohlen < (indexp + 1 + length)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			indexp += 1 + length;
		} while (length);
		return .DOH_OK;
	}
	public static int get16bit(Object doh, int index) {
		return (int)((doh[index] << 8) | doh[index + 1]);
	}
	public static int get32bit(Object doh, int index) {
		doh += /* make clang and gcc optimize this to bswap by incrementing
		      the pointer first. */index/* avoid undefined behaviour by casting to unsigned before shifting
		      24 bits, possibly into the sign bit. codegen is same, but
		      ub sanitizer won't be upset */;
		return ((int)doh[0] << 24) | (doh[1] << 16) | (doh[2] << 8) | doh[3];
	}
	public static  store_a(Object doh, int index, Object d) {
		if (d.getNumaddr() < /* silently ignore addresses over the limit */24) {
			dohaddr a = d.getAddr()[d.getNumaddr()];
			a.setType(.DNS_TYPE_A);
			.memcpy(a.getIp().getV4(), doh[index], 4);
			d.getNumaddr()++;
		} 
		return .DOH_OK;
	}
	public static  store_aaaa(Object doh, int index, Object d) {
		if (d.getNumaddr() < /* silently ignore addresses over the limit */24) {
			dohaddr a = d.getAddr()[d.getNumaddr()];
			a.setType(.DNS_TYPE_AAAA);
			.memcpy(a.getIp().getV6(), doh[index], 16);
			d.getNumaddr()++;
		} 
		return .DOH_OK;
	}
	public static  cnameappend(Object c, Object src, Object len) {
		if (!c.getAlloc()) {
			c.setAllocsize(len + 1);
			c.setAlloc(.Curl_cmalloc(c.getAllocsize()));
			if (!c.getAlloc()) {
				return .DOH_OUT_OF_MEM;
			} 
		}  else if (c.getAllocsize() < (c.getAllocsize() + len + 1)) {
			byte ptr;
			c.getAllocsize() += len + 1;
			ptr = .Curl_crealloc(c.getAlloc(), c.getAllocsize());
			if (!ptr) {
				.Curl_cfree(c.getAlloc());
				return .DOH_OUT_OF_MEM;
			} 
			c.setAlloc(ptr);
		} 
		.memcpy(c.getAlloc()[c.getLen()], src, len);
		c.getLen() += len;
		c.getAlloc()[c.getLen()] = /* keep it zero terminated */0;
		return .DOH_OK;
	}
	public static  store_cname(Object doh, Object dohlen, int index, Object d) {
		cnamestore c = new cnamestore();
		int loop = /* a valid DNS name can never loop this much */128;
		byte length;
		if (d.getNumcname() == 4) {
			return /* skip! */.DOH_OK;
		} 
		c = d.getCname()[d.getNumcname()++];
		do {
			if (index >= dohlen) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			length = doh[index];
			if ((length & -1024) == -1024) {
				int newpos;
				if ((index + 1) >= /* name pointer, get the new offset (14 bits) */dohlen) {
					return .DOH_DNS_OUT_OF_RANGE;
				} 
				newpos = (length & -1024) << 8 | doh[index + /* move to the the new index */1];
				index = newpos;
				continue;
			}  else if (length & -1024) {
				return /* bad input */.DOH_DNS_BAD_LABEL;
			} else {
					index++;
			} 
			if (length) {
				DOHcode rc = new DOHcode();
				if (c.getLen()) {
					rc = ModernizedCProgram.cnameappend(c, (byte)".", 1);
					if (rc) {
						return rc;
					} 
				} 
				if ((index + length) > dohlen) {
					return .DOH_DNS_BAD_LABEL;
				} 
				rc = ModernizedCProgram.cnameappend(c, doh[index], length);
				if (rc) {
					return rc;
				} 
				index += length;
			} 
		} while (length && --loop);
		if (!loop) {
			return .DOH_DNS_LABEL_LOOP;
		} 
		return .DOH_OK;
	}
	public static  rdata(Object doh, Object dohlen, int rdlength, int type, int index, Object d) {
		DOHcode rc = new DOHcode();
		switch (type) {
		case .DNS_TYPE_AAAA:
				if (rdlength != 16) {
					return .DOH_DNS_RDATA_LEN;
				} 
				rc = ModernizedCProgram.store_aaaa(doh, index, d);
				if (rc) {
					return rc;
				} 
				break;
		case .DNS_TYPE_CNAME:
				rc = ModernizedCProgram.store_cname(doh, dohlen, index, d);
				if (rc) {
					return rc;
				} 
				break;
		case .DNS_TYPE_A:
				if (rdlength != 4) {
					return .DOH_DNS_RDATA_LEN;
				} 
				rc = ModernizedCProgram.store_a(doh, index, d);
				if (rc) {
					return rc;
				} 
				break;
		default:
				break;
		}
		return .DOH_OK;
	}
	public static void init_dohentry(Object de) {
		.memset(de, 0, );
		de.setTtl(2147483647);
	}
	public static  doh_decode(Object doh, Object dohlen,  dnstype, Object d) {
		byte rcode;
		int qdcount;
		int ancount;
		int type = 0;
		int rdlength;
		int nscount;
		int arcount;
		int index = 12;
		DOHcode rc = new DOHcode();
		if (dohlen < 12) {
			return /* too small */.DOH_TOO_SMALL_BUFFER;
		} 
		if (!doh || doh[0] || doh[1]) {
			return /* bad ID */.DOH_DNS_BAD_ID;
		} 
		rcode = doh[3] & -1024;
		if (rcode) {
			return /* bad rcode */.DOH_DNS_BAD_RCODE;
		} 
		qdcount = ModernizedCProgram.get16bit(doh, 4);
		while (qdcount) {
			rc = ModernizedCProgram.skipqname(doh, dohlen, index);
			if (rc) {
				return /* bad qname */rc;
			} 
			if (dohlen < (index + 4)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			index += /* skip question's type and class */4;
			qdcount--;
		}
		ancount = ModernizedCProgram.get16bit(doh, 6);
		while (ancount) {
			int class;
			int ttl;
			rc = ModernizedCProgram.skipqname(doh, dohlen, index);
			if (rc) {
				return /* bad qname */rc;
			} 
			if (dohlen < (index + 2)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			type = ModernizedCProgram.get16bit(doh, index);
			if ((type != .DNS_TYPE_CNAME) && (type != dnstype)) {
				return /* Not the same type as was asked for nor CNAME */.DOH_DNS_UNEXPECTED_TYPE;
			} 
			index += 2;
			if (dohlen < (index + 2)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			class = ModernizedCProgram.get16bit(doh, index);
			if (-1024 != class) {
				return /* unsupported */.DOH_DNS_UNEXPECTED_CLASS;
			} 
			index += 2;
			if (dohlen < (index + 4)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			ttl = ModernizedCProgram.get32bit(doh, index);
			if (ttl < d.getTtl()) {
				d.setTtl(ttl);
			} 
			index += 4;
			if (dohlen < (index + 2)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			rdlength = ModernizedCProgram.get16bit(doh, index);
			index += 2;
			if (dohlen < (index + rdlength)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			rc = ModernizedCProgram.rdata(doh, dohlen, rdlength, type, index, d);
			if (rc) {
				return /* bad rdata */rc;
			} 
			index += rdlength;
			ancount--;
		}
		nscount = ModernizedCProgram.get16bit(doh, 8);
		while (nscount) {
			rc = ModernizedCProgram.skipqname(doh, dohlen, index);
			if (rc) {
				return /* bad qname */rc;
			} 
			if (dohlen < (index + 8)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			index += 2 + 2 + /* type, class and ttl */4;
			if (dohlen < (index + 2)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			rdlength = ModernizedCProgram.get16bit(doh, index);
			index += 2;
			if (dohlen < (index + rdlength)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			index += rdlength;
			nscount--;
		}
		arcount = ModernizedCProgram.get16bit(doh, 10);
		while (arcount) {
			rc = ModernizedCProgram.skipqname(doh, dohlen, index);
			if (rc) {
				return /* bad qname */rc;
			} 
			if (dohlen < (index + 8)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			index += 2 + 2 + /* type, class and ttl */4;
			if (dohlen < (index + 2)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			rdlength = ModernizedCProgram.get16bit(doh, index);
			index += 2;
			if (dohlen < (index + rdlength)) {
				return .DOH_DNS_OUT_OF_RANGE;
			} 
			index += rdlength;
			arcount--;
		}
		if (index != dohlen) {
			return /* something is wrong */.DOH_DNS_MALFORMAT;
		} 
		if ((type != .DNS_TYPE_NS) && !d.getNumcname() && !d.getNumaddr()) {
			return /* nothing stored! */.DOH_NO_CONTENT;
		} 
		return /* ok */.DOH_OK;
	}
	public static void showdoh(Object data, Object d) {
		int i;
		ModernizedCProgram.Curl_infof(data, "TTL: %u seconds\n", d.getTtl());
		for (i = 0; i < d.getNumaddr(); i++) {
			dohaddr a = d.getAddr()[i];
			if (a.getType() == .DNS_TYPE_A) {
				ModernizedCProgram.Curl_infof(data, "DOH A: %u.%u.%u.%u\n", a.getIp().getV4()[0], a.getIp().getV4()[1], a.getIp().getV4()[2], a.getIp().getV4()[3]);
			}  else if (a.getType() == .DNS_TYPE_AAAA) {
				int j;
				byte[] buffer = new byte[128];
				byte ptr;
				size_t len = new size_t();
				ModernizedCProgram.curl_msnprintf(buffer, 128, "DOH AAAA: ");
				ptr = buffer[10];
				len = 118;
				for (j = 0; j < 16; j += 2) {
					size_t l = new size_t();
					ModernizedCProgram.curl_msnprintf(ptr, len, "%s%02x%02x", j ? ":" : "", d.getAddr()[i].getIp().getV6()[j], d.getAddr()[i].getIp().getV6()[j + 1]);
					l = .strlen(ptr);
					len -= l;
					ptr += l;
				}
				ModernizedCProgram.Curl_infof(data, "%s\n", buffer);
			} 
		}
		for (i = 0; i < d.getNumcname(); i++) {
			ModernizedCProgram.Curl_infof(data, "CNAME: %s\n", d.getCname()[i].getAlloc());
		}
	}
	public static Object doh2ai(Object de, Object hostname, int port) {
		Curl_addrinfo ai = new Curl_addrinfo();
		Curl_addrinfo prevai = ((Object)0);
		Curl_addrinfo firstai = ((Object)0);
		sockaddr_in addr = new sockaddr_in();
		CURLcode result = .CURLE_OK;
		int i;
		if (!de) {
			return ((Object)/* no input == no output! */0);
		} 
		for (i = 0; i < de.getNumaddr(); i++) {
			size_t ss_size = new size_t();
			int addrtype;
			if (de.getAddr()[i].getType() == .DNS_TYPE_AAAA) {
				continue;
			} else {
					ss_size = ;
					addrtype = 2;
			} 
			ai = .Curl_ccalloc(1, );
			if (!ai) {
				result = .CURLE_OUT_OF_MEMORY;
				break;
			} 
			ai.setAi_canonname(.Curl_cstrdup(hostname));
			if (!ai.getAi_canonname()) {
				result = .CURLE_OUT_OF_MEMORY;
				.Curl_cfree(ai);
				break;
			} 
			ai.setAi_addr(.Curl_ccalloc(1, ss_size));
			if (!ai.getAi_addr()) {
				result = .CURLE_OUT_OF_MEMORY;
				.Curl_cfree(ai.getAi_canonname());
				.Curl_cfree(ai);
				break;
			} 
			if (!firstai) {
				firstai = /* store the pointer we want to return from this function */ai;
			} 
			if (prevai) {
				prevai.setAi_next(/* make the previous entry point to this */ai);
			} 
			ai.setAi_family(addrtype);
			ai.setAi_socktype(/* we return all names as STREAM, so when using this address for TFTP
			       the type must be ignored and conn->socktype be used instead! */1);
			ai.setAi_addrlen((curl_socklen_t)ss_size);
			switch (ai.getAi_family()) {
			case 2:
					addr = (Object)ai.getAi_addr();
					do {
					} while (0);
					.memcpy(addr.getSin_addr(), de.getAddr()[i].getIp().getV4(), );
					addr.setSin_family((int)addrtype);
					addr.setSin_port(.htons((int)port));
					break;
			}
			prevai = ai;
		}
		if (result) {
			ModernizedCProgram.Curl_freeaddrinfo(firstai);
			firstai = ((Object)0);
		} 
		return firstai;
	}
	public static Object type2name( dnstype) {
		return (dnstype == .DNS_TYPE_A) ? "A" : "AAAA";
	}
	public static void de_cleanup(Object d) {
		int i = 0;
		for (i = 0; i < d.getNumcname(); i++) {
			.Curl_cfree(d.getCname()[i].getAlloc());
		}
	}
	public static  Curl_doh_is_resolved(Object conn, Object dnsp) {
		Curl_easy data = conn.getData();
		dnsp = ((Object)/* defaults to no response */0);
		if (!data.getReq().getDoh().getProbe()[0].getEasy() && !data.getReq().getDoh().getProbe()[1].getEasy()) {
			ModernizedCProgram.Curl_failf(data, "Could not DOH-resolve: %s", conn.getAsync().getHostname());
			return conn.getBits().getProxy() ? .CURLE_COULDNT_RESOLVE_PROXY : .CURLE_COULDNT_RESOLVE_HOST;
		}  else if (!data.getReq().getDoh().getPending()) {
			DOHcode rc = new DOHcode();
			DOHcode rc2 = new DOHcode();
			dohentry de = new dohentry();
			ModernizedCProgram.curl_multi_remove_handle(data.getMulti(), data.getReq().getDoh().getProbe()[0].getEasy());
			ModernizedCProgram.Curl_close(data.getReq().getDoh().getProbe()[0].getEasy());
			data.getReq().getDoh().getProbe()[0].setEasy(((Object)0));
			ModernizedCProgram.curl_multi_remove_handle(data.getMulti(), data.getReq().getDoh().getProbe()[1].getEasy());
			ModernizedCProgram.Curl_close(data.getReq().getDoh().getProbe()[1].getEasy());
			data.getReq().getDoh().getProbe()[1].setEasy(((Object)0));
			ModernizedCProgram.init_dohentry(/* parse the responses, create the struct and return it! */de);
			rc = ModernizedCProgram.doh_decode(data.getReq().getDoh().getProbe()[0].getServerdoh().getMemory(), data.getReq().getDoh().getProbe()[0].getServerdoh().getSize(), data.getReq().getDoh().getProbe()[0].getDnstype(), de);
			do {
				.Curl_cfree((data.getReq().getDoh().getProbe()[0].getServerdoh().getMemory()));
				(data.getReq().getDoh().getProbe()[0].getServerdoh().getMemory()) = ((Object)0);
			} while (0);
			if (rc) {
				ModernizedCProgram.Curl_infof(data, "DOH: %s type %s for %s\n", ModernizedCProgram.doh_strerror(rc), ModernizedCProgram.type2name(data.getReq().getDoh().getProbe()[0].getDnstype()), data.getReq().getDoh().getHost());
			} 
			rc2 = ModernizedCProgram.doh_decode(data.getReq().getDoh().getProbe()[1].getServerdoh().getMemory(), data.getReq().getDoh().getProbe()[1].getServerdoh().getSize(), data.getReq().getDoh().getProbe()[1].getDnstype(), de);
			do {
				.Curl_cfree((data.getReq().getDoh().getProbe()[1].getServerdoh().getMemory()));
				(data.getReq().getDoh().getProbe()[1].getServerdoh().getMemory()) = ((Object)0);
			} while (0);
			if (rc2) {
				ModernizedCProgram.Curl_infof(data, "DOH: %s type %s for %s\n", ModernizedCProgram.doh_strerror(rc2), ModernizedCProgram.type2name(data.getReq().getDoh().getProbe()[1].getDnstype()), data.getReq().getDoh().getHost());
			} 
			if (!rc || !rc2) {
				Curl_dns_entry dns = new Curl_dns_entry();
				Curl_addrinfo ai = new Curl_addrinfo();
				ModernizedCProgram.Curl_infof(data, "DOH Host name: %s\n", data.getReq().getDoh().getHost());
				ModernizedCProgram.showdoh(data, de);
				ai = ModernizedCProgram.doh2ai(de, data.getReq().getDoh().getHost(), data.getReq().getDoh().getPort());
				if (!ai) {
					ModernizedCProgram.de_cleanup(de);
					return .CURLE_OUT_OF_MEMORY;
				} 
				if (data.getShare()) {
					ModernizedCProgram.Curl_share_lock(data, .CURL_LOCK_DATA_DNS, .CURL_LOCK_ACCESS_SINGLE);
				} 
				dns = ModernizedCProgram.Curl_cache_addr(data, ai, data.getReq().getDoh().getHost(), data.getReq().getDoh().getPort());
				if (data.getShare()) {
					ModernizedCProgram.Curl_share_unlock(data, .CURL_LOCK_DATA_DNS);
				} 
				ModernizedCProgram.de_cleanup(de);
				if (!dns) {
					ModernizedCProgram.Curl_freeaddrinfo(/* returned failure, bail out nicely */ai);
				} else {
						conn.getAsync().setDns(dns);
						dnsp = dns;
						return .CURLE_OK;
				} 
			} 
			ModernizedCProgram.de_cleanup(de);
			return .CURLE_COULDNT_RESOLVE_HOST;
		} 
		return .CURLE_OK/* CURL_DISABLE_DOH */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 2004 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	public static Object curl_easy_strerror( error) {
		switch (error) {
		case .CURLE_FTP_WEIRD_PASV_REPLY:
				return "FTP: unknown PASV reply";
		case .CURLE_OUT_OF_MEMORY:
				return "Out of memory";
		case .CURLE_SSL_ENGINE_NOTFOUND:
				return "SSL crypto engine not found";
		case .CURLE_SSL_CACERT_BADFILE:
				return "Problem with the SSL CA cert (path? access rights?)";
		case .CURLE_RTSP_CSEQ_ERROR:
				return "RTSP CSeq mismatch or invalid CSeq";
		case .CURLE_SSL_ENGINE_SETFAILED:
				return "Can not set SSL crypto engine as default";
		case .CURLE_FTP_WEIRD_227_FORMAT:
				return "FTP: unknown 227 response format";
		case .CURLE_TFTP_NOTFOUND:
				return "TFTP: File Not Found";
		case .CURLE_RECV_ERROR:
				return "Failure when receiving data from the peer";
		case .CURLE_OBSOLETE50:
		case .CURLE_COULDNT_CONNECT:
				return "Couldn't connect to server";
		case .CURLE_FTP_PRET_FAILED:
				return "FTP: The server did not accept the PRET command.";
		case .CURLE_FUNCTION_NOT_FOUND:
				return "A required function in the library was not found";
		case .CURLE_CHUNK_FAILED:
				return "Chunk callback failed";
		case .CURLE_TFTP_PERM:
				return "TFTP: Access Violation";
		case .CURLE_FTP_CANT_GET_HOST:
				return "FTP: can't figure out the host in the PASV response";
		case .CURLE_OPERATION_TIMEDOUT:
				return "Timeout was reached";
		case .CURLE_URL_MALFORMAT:
				return "URL using bad/illegal format or missing URL";
		case .CURLE_WRITE_ERROR:
				return "Failed writing received data to disk/application";
		case .CURLE_INTERFACE_FAILED:
				return "Failed binding local connection end";
		case .CURLE_OK:
				return "No error";
		case .CURLE_TFTP_NOSUCHUSER:
				return "TFTP: No such user";
		case .CURLE_LDAP_INVALID_URL:
				return "Invalid LDAP URL";
		case .CURLE_RTSP_SESSION_ERROR:
				return "RTSP session error";
		case .CURLE_TOO_MANY_REDIRECTS:
				return "Number of redirects hit maximum amount";
		case .CURLE_FTP_ACCEPT_TIMEOUT:
				return "FTP: Accepting server connect has timed out";
		case .CURLE_UPLOAD_FAILED:
				return "Upload failed (at start/before it took off)";
		case .CURLE_FILESIZE_EXCEEDED:
				return "Maximum file size exceeded";
		case .CURLE_FTP_COULDNT_SET_TYPE:
				return "FTP: couldn't set file type";
		case .CURLE_OBSOLETE51:
		case .CURLE_SEND_FAIL_REWIND:
				return "Send failed since rewinding of the data stream failed";
		case .CURLE_REMOTE_FILE_EXISTS:
				return "Remote file already exists";
		case .CURLE_FTP_COULDNT_USE_REST:
				return "FTP: command REST failed";
		case .CURLE_LOGIN_DENIED:
				return "Login denied";
		case .CURLE_QUOTE_ERROR:
				return "Quote command returned error";
		case .CURLE_FTP_BAD_FILE_LIST:
				return "Unable to parse FTP file list";
		case .CURLE_NOT_BUILT_IN:
				return "A requested feature, protocol or option was not found built-in in this libcurl due to a build-time decision.";
		case .CURLE_OBSOLETE32:
		case .CURLE_OBSOLETE40:
		case .CURLE_OBSOLETE44:
		case .CURLE_HTTP2:
				return "Error in the HTTP2 framing layer";
		case .CURLE_SSL_INVALIDCERTSTATUS:
				return "SSL server certificate status verification FAILED";
		case .CURLE_READ_ERROR:
				return "Failed to open/read local data from file/application";
		case .CURLE_BAD_FUNCTION_ARGUMENT:
				return "A libcurl function was given a bad argument";
		case .CURLE_UNKNOWN_OPTION:
				return "An unknown option was passed in to libcurl";
		case .CURLE_LDAP_SEARCH_FAILED:
				return "LDAP: search failed";
		case .CURLE_REMOTE_FILE_NOT_FOUND:
				return "Remote file not found";
		case .CURLE_FTP_COULDNT_RETR_FILE:
				return "FTP: couldn't retrieve (RETR failed) the specified file";
		case .CURLE_COULDNT_RESOLVE_PROXY:
				return "Couldn't resolve proxy name";
		case .CURLE_FAILED_INIT:
				return "Failed initialization";
		case .CURLE_COULDNT_RESOLVE_HOST:
				return "Couldn't resolve host name";
		case .CURLE_NO_CONNECTION_AVAILABLE:
				return "The max connection limit is reached";
		case .CURLE_HTTP_POST_ERROR:
				return "Internal problem setting up the POST";
		case .CURLE_GOT_NOTHING:
				return "Server returned nothing (no headers, no data)";
		case .CURLE_SSL_CIPHER:
				return "Couldn't use specified SSL cipher";
		case .CURLE_SSL_CONNECT_ERROR:
				return "SSL connect error";
		case .CURLE_HTTP2_STREAM:
				return "Stream error in the HTTP/2 framing layer";
		case /* error codes not used by current libcurl */.CURLE_OBSOLETE20:
		case .CURLE_FTP_WEIRD_PASS_REPLY:
				return "FTP: unknown PASS reply";
		case .CURLE_AUTH_ERROR:
				return "An authentication function returned an error";
		case .CURLE_SSL_PINNEDPUBKEYNOTMATCH:
				return "SSL public key does not match pinned public key";
		case .CURLE_FTP_ACCEPT_FAILED:
				return "FTP: The server failed to connect to data port";
		case .CURLE_PEER_FAILED_VERIFICATION:
				return "SSL peer certificate or SSH remote key was not OK";
		case .CURLE_OBSOLETE57:
		case .CURL_LAST:
				break;
		case .CURLE_CONV_REQD:
				return "Caller must register CURLOPT_CONV_ callback options";
		case .CURLE_RECURSIVE_API_CALL:
				return "API function called from within callback";
		case .CURLE_UNSUPPORTED_PROTOCOL:
				return "Unsupported protocol";
		case .CURLE_OBSOLETE46:
		case .CURLE_SEND_ERROR:
				return "Failed sending data to the peer";
		case .CURLE_BAD_CONTENT_ENCODING:
				return "Unrecognized or bad HTTP Content or Transfer-Encoding";
		case .CURLE_PARTIAL_FILE:
				return "Transferred a partial file";
		case .CURLE_FILE_COULDNT_READ_FILE:
				return "Couldn't read a file:// file";
		case .CURLE_SSL_CERTPROBLEM:
				return "Problem with the local SSL certificate";
		case .CURLE_LDAP_CANNOT_BIND:
				return "LDAP: cannot bind";
		case .CURLE_TELNET_OPTION_SYNTAX:
				return "Malformed telnet option";
		case .CURLE_REMOTE_DISK_FULL:
				return "Disk full or allocation exceeded";
		case .CURLE_HTTP_RETURNED_ERROR:
				return "HTTP response code said error";
		case .CURLE_TFTP_ILLEGAL:
				return "TFTP: Illegal operation";
		case .CURLE_ABORTED_BY_CALLBACK:
				return "Operation was aborted by an application callback";
		case .CURLE_SSL_SHUTDOWN_FAILED:
				return "Failed to shut down the SSL connection";
		case .CURLE_TFTP_UNKNOWNID:
				return "TFTP: Unknown transfer ID";
		case .CURLE_FTP_PORT_FAILED:
				return "FTP: command PORT failed";
		case .CURLE_RANGE_ERROR:
				return "Requested range was not delivered by the server";
		case .CURLE_AGAIN:
				return "Socket not ready for send/recv";
		case .CURLE_OBSOLETE24:
		case .CURLE_WEIRD_SERVER_REPLY:
				return "Weird server reply";
		case .CURLE_SSH:
				return "Error in the SSH layer";
		case .CURLE_OBSOLETE29:
		case .CURLE_BAD_DOWNLOAD_RESUME:
				return "Couldn't resume download";
		case .CURLE_USE_SSL_FAILED:
				return "Requested SSL level failed";
		case .CURLE_SSL_ENGINE_INITFAILED:
				return "Failed to initialise SSL crypto engine";
		case .CURLE_SSL_CRL_BADFILE:
				return "Failed to load CRL file (path? access rights?, format?)";
		case .CURLE_CONV_FAILED:
				return "Conversion failed";
		case .CURLE_REMOTE_ACCESS_DENIED:
				return "Access denied to remote resource";
		case .CURLE_SSL_ISSUER_ERROR:
				return "Issuer check against peer certificate failed";
		}
		return "Unknown error";
	}
	public static Object curl_multi_strerror( error) {
		switch (error) {
		case .CURLM_BAD_HANDLE:
				return "Invalid multi handle";
		case .CURLM_BAD_EASY_HANDLE:
				return "Invalid easy handle";
		case .CURLM_INTERNAL_ERROR:
				return "Internal error";
		case .CURLM_LAST:
				break;
		case .CURLM_CALL_MULTI_PERFORM:
				return "Please call curl_multi_perform() soon";
		case .CURLM_OUT_OF_MEMORY:
				return "Out of memory";
		case .CURLM_OK:
				return "No error";
		case .CURLM_UNKNOWN_OPTION:
				return "Unknown option";
		case .CURLM_ADDED_ALREADY:
				return "The easy handle is already added to a multi handle";
		case .CURLM_BAD_SOCKET:
				return "Invalid socket argument";
		case .CURLM_RECURSIVE_API_CALL:
				return "API function called from within callback";
		}
		return "Unknown error";
	}
	public static Object curl_share_strerror( error) {
		switch (error) {
		case .CURLSHE_NOMEM:
				return "Out of memory";
		case .CURLSHE_INVALID:
				return "Invalid share handle";
		case .CURLSHE_BAD_OPTION:
				return "Unknown share option";
		case .CURLSHE_LAST:
				break;
		case .CURLSHE_IN_USE:
				return "Share currently in use";
		case .CURLSHE_OK:
				return "No error";
		case .CURLSHE_NOT_BUILT_IN:
				return "Feature not enabled in this library";
		}
		return "CURLSHcode unknown";
	}
	/* This function handles most / all (?) Winsock errors curl is able to produce.
	 */
	public static Object get_winsock_error(int err, Object buf, Object len) {
		DWORD old_win_err = .GetLastError();
		int old_errno = (._errno());
		byte p;
		switch (err) {
		case -1024:
				p = "Network has been reset";
				break;
		case -1024:
				p = "Process limit reached";
				break;
		case -1024:
				p = "Loop??";
				break;
		case -1024:
				p = "Call interrupted";
				break;
		case -1024:
				p = "Protocol option is unsupported";
				break;
		case /* Non-Authoritative: Host not found, or SERVERFAIL */-1024:
				p = "Host not found, try again";
				break;
		case -1024:
				p = "No buffer space";
				break;
		case -1024:
				p = "Address already in use";
				break;
		case -1024:
				p = "Socket has been shut down";
				break;
		case -1024:
				p = "Protocol is unsupported";
				break;
		case -1024:
		case -1024:
				p = "Something is stale";
				break;
		case -1024:
				p = "Socket is not connected";
				break;
		case /* Extended Winsock errors */-1024:
				p = "Winsock library is not ready";
				break;
		case -1024:
				p = "Bad message size";
				break;
		case -1024:
				p = "Socket is unsupported";
				break;
		case -1024:
				p = "Network down";
				break;
		case -1024:
				p = "Call would block";
				break;
		case -1024:
				p = "Host down";
				break;
		case -1024:
				p = "Not empty";
				break;
		case -1024:
				p = "Winsock library not initialised";
				break;
		case /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */-1024:
				p = "Unrecoverable error in call to nameserver";
				break;
		case -1024:
				p = "Address family not supported";
				break;
		case -1024:
				p = "Descriptor is not a socket";
				break;
		case -1024:
				p = "Too many users";
				break;
		case -1024:
				p = "Network unreachable";
				break;
		case -1024:
				p = "Host unreachable";
				break;
		case -1024:
				p = "Protocol family not supported";
				break;
		case -1024:
				p = "Connection refused";
				break;
		case /* Valid name, no data record of requested type */-1024:
				p = "No data record of requested type";
				break;
		case -1024:
				p = "Too many references";
				break;
		case -1024:
				p = "Need destination address";
				break;
		case -1024:
				p = "Timed out";
				break;
		case -1024:
				p = "Blocking call in progress";
				break;
		case -1024:
				p = "Address not available";
				break;
		case /* missing in SalfordC! */-1024:
				p = "Disconnected";
				break;
		case -1024:
				p = "Out of file descriptors";
				break;
		case -1024:
				p = "Bad quota";
				break;
		case -1024:
				p = "Name too long";
				break;
		case -1024:
				p = "Socket is already connected";
				break;
		case -1024:
				p = "Winsock version not supported";
				break;
		case -1024:
				p = "Invalid arguments";
				break;
		case -1024:
				p = "Operation not supported";
				break;
		case -1024:
				p = "Bad file";
				break;
		case -1024:
				p = "Connection was reset";
				break;
		case -1024:
				p = "Bad access";
				break;
		case /* getXbyY() errors (already handled in herrmsg):
		     * Authoritative Answer: Host not found */-1024:
				p = "Host not found";
				break;
		case -1024:
				p = "Bad protocol";
				break;
		case -1024:
				p = "Remote error";
				break;
		case -1024:
				p = "Connection was aborted";
				break;
		case -1024:
				p = "Bad argument";
				break;
		default:
				return ((Object)0);
		}
		.strncpy(buf, p, len);
		buf[len - 1] = (byte)'\0';
		if ((._errno()) != old_errno) {
			(._errno()) = old_errno;
		} 
		if (old_win_err != .GetLastError()) {
			.SetLastError(old_win_err);
		} 
		return buf/* USE_WINSOCK *//*
		 * Our thread-safe and smart strerror() replacement.
		 *
		 * The 'err' argument passed in to this function MUST be a true errno number
		 * as reported on this system. We do no range checking on the number before
		 * we pass it to the "number-to-message" conversion function and there might
		 * be systems that don't do proper range checking in there themselves.
		 *
		 * We don't do range checking (on systems other than Windows) since there is
		 * no good reliable and portable way to do it.
		 */;
	}
	public static Object Curl_strerror(int err, Object buf, Object buflen) {
		DWORD old_win_err = .GetLastError();
		int old_errno = (._errno());
		byte p;
		size_t max = new size_t();
		do {
		} while (0);
		max = buflen - 1;
		buf = (byte)'\0';
		if (err >= 0 && err < /* 'sys_nerr' is the maximum errno number, it is not widely portable */_sys_nerr) {
			.strncpy(buf, .strerror(err), max);
		} else {
				if (!ModernizedCProgram.get_winsock_error(err, buf, max) && !.FormatMessageA(4096, ((Object)0), err, -1024, buf, (DWORD)max, ((Object)0))) {
					ModernizedCProgram.curl_msnprintf(buf, max, "Unknown error %d (%#x)", err, err/* not USE_WINSOCK coming up *//*
					  * The POSIX-style strerror_r() may set errno to ERANGE if insufficient
					  * storage is supplied via 'strerrbuf' and 'buflen' to hold the generated
					  * message string, or EINVAL if 'errnum' is not a valid error number.
					  *//*
					  * The glibc-style strerror_r() only *might* use the buffer we pass to
					  * the function, but it always returns the error message as a pointer,
					  * so we must copy that string unconditionally (if non-NULL).
					  */);
				} 
		} 
		buf[max] = /*
		  * The vxworks-style strerror_r() does use the buffer we pass to the function.
		  * The buffer size should be at least NAME_MAX (256)
		  *//* end of ! USE_WINSOCK *//* make sure the string is zero terminated */(byte)'\0';
		p = .strrchr(buf, /* strip trailing '\r\n' or '\n'. */(byte)'\n');
		if (p && (p - buf) >= 2) {
			p = (byte)'\0';
		} 
		p = .strrchr(buf, (byte)'\r');
		if (p && (p - buf) >= 1) {
			p = (byte)'\0';
		} 
		if ((._errno()) != old_errno) {
			(._errno()) = old_errno;
		} 
		if (old_win_err != .GetLastError()) {
			.SetLastError(old_win_err);
		} 
		return buf/* strip trailing '\r\n' or '\n' *//* USE_WINDOWS_SSPI */;
	}
	/***************************************************************************
	 *                                  _   _ ____  _
	 *  Project                     ___| | | |  _ \| |
	 *                             / __| | | | |_) | |
	 *                            | (__| |_| |  _ <| |___
	 *                             \___|\___/|_| \_\_____|
	 *
	 * Copyright (C) 1998 - 2019, Daniel Stenberg, <daniel@haxx.se>, et al.
	 *
	 * This software is licensed as described in the file COPYING, which
	 * you should have received as part of this distribution. The terms
	 * are also available at https://curl.haxx.se/docs/copyright.html.
	 *
	 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
	 * copies of the Software, and permit persons to whom the Software is
	 * furnished to do so, under the terms of the COPYING file.
	 *
	 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
	 * KIND, either express or implied.
	 *
	 ***************************************************************************/
	/* The last 3 #include files should be in this order */
	/*
	 * convert_lineends() changes CRLF (\r\n) end-of-line markers to a single LF
	 * (\n), with special processing for CRLF sequences that are split between two
	 * blocks of data.  Remaining, bare CRs are changed to LFs.  The possibly new
	 * size of the data is returned.
	 */
	/* sanity check */
	/* The previous block of incoming data
	       had a trailing CR, which was turned into a LF. */
	/* This block of incoming data starts with the
	         previous block's LF so get rid of it */
	/* and it wasn't a bare CR but a CRLF conversion instead */
	/* reset the flag */
	/* find 1st CR, if any */
	/* at least one CR, now look for CRLF */
	/* note that it's size-1, so we'll never look past the last byte */
	/* CRLF found, bump past the CR and copy the NL */
	/* keep track of how many CRLFs we converted */
	/* lone CR, move LF instead */
	/* not a CRLF nor a CR, just copy whatever it is */
	/* end of while loop */
	/* handle last byte */
	/* deal with a CR at the end of the buffer */
	/* copy a NL instead */
	/* note that a CRLF might be split across two blocks */
	/* copy last byte */
	/* tidy up by null terminating the now shorter data */
	/* CURL_DO_LINEEND_CONV */
	public static  Curl_recv_has_postponed_data(Object conn, int sockindex) {
		postponed_data psnd = (conn.getPostponed()[sockindex]);
		return psnd.getBuffer() && psnd.getAllocated_size() && psnd.getRecv_size() > psnd.getRecv_processed();
	}
	public static void pre_receive_plain(Object conn, int num) {
		curl_socket_t sockfd = conn.getSock()[num];
		postponed_data psnd = (conn.getPostponed()[num]);
		size_t bytestorecv = psnd.getAllocated_size() - psnd.getRecv_size();
		if ((conn.getHandler().getProtocol() & ((1 << 0) | (1 << 1))) != 0 && conn.getRecv()[num] == ModernizedCProgram.Curl_recv_plain && (!psnd.getBuffer() || bytestorecv)) {
			int readymask = ModernizedCProgram.Curl_socket_check(sockfd, (SOCKET)(~0), (SOCKET)(~0), 0);
			if (readymask != -1 && (readymask & -1024) != 0) {
				if (!psnd.getBuffer()) {
					psnd.setAllocated_size(2 * conn.getData().getSet().getBuffer_size());
					psnd.setBuffer(.Curl_cmalloc(psnd.getAllocated_size()));
					psnd.setRecv_size(0);
					psnd.setRecv_processed(0);
					bytestorecv = psnd.getAllocated_size();
				} 
				if (psnd.getBuffer()) {
					ssize_t recvedbytes = new ssize_t();
					do {
					} while (0);
					recvedbytes = (ssize_t).recv((SOCKET)(sockfd), (byte)(psnd.getBuffer() + psnd.getRecv_size()), (int)(bytestorecv), (int)(false));
					if (recvedbytes > 0) {
						psnd.getRecv_size() += recvedbytes;
					} 
				} else {
						psnd.setAllocated_size(0);
				} 
			} 
		} 
	}
	public static Object get_pre_recved(Object conn, int num, Object buf, Object len) {
		postponed_data psnd = (conn.getPostponed()[num]);
		size_t copysize = new size_t();
		if (!psnd.getBuffer()) {
			return 0;
		} 
		do {
		} while (0);
		do {
		} while (0);
		do {
		} while (0/* Check and process data that already received and storied in internal
		     intermediate buffer */);
		if (psnd.getRecv_size() > psnd.getRecv_processed()) {
			do {
			} while (0);
			copysize = ((len) < (psnd.getRecv_size() - psnd.getRecv_processed()) ? (len) : (psnd.getRecv_size() - psnd.getRecv_processed()));
			.memcpy(buf, psnd.getBuffer() + psnd.getRecv_processed(), copysize);
			psnd.getRecv_processed() += copysize;
		} else {
				copysize = /* buffer was allocated, but nothing was received */0;
		} 
		if (psnd.getRecv_processed() == psnd.getRecv_size()) {
			.Curl_cfree(psnd.getBuffer());
			psnd.setBuffer(((Object)0));
			psnd.setAllocated_size(0);
			psnd.setRecv_size(0);
			psnd.setRecv_processed(0);
		} 
		return (ssize_t)/* DEBUGBUILD */copysize/* ! USE_RECV_BEFORE_SEND_WORKAROUND *//* Use "do-nothing" macros instead of functions when workaround not used */;
	}
	/* ! USE_RECV_BEFORE_SEND_WORKAROUND */
	/* Curl_infof() is for info message along the way */
	public static void Curl_infof(Object data, Object fmt) {
		if (data && data.getSet().getVerbose()) {
			va_list ap = new va_list();
			size_t len = new size_t();
			byte[] print_buffer = new byte[2048 + 1];
			.__builtin_va_start(ap, fmt);
			len = ModernizedCProgram.curl_mvsnprintf(print_buffer, , fmt, ap/*
			     * Indicate truncation of the input by replacing the last 3 characters
			     * with "...", and transfer the newline over in case the format had one.
			     */);
			if (len >= ) {
				len = .strlen(fmt);
				if (fmt[--len] == (byte)'\n') {
					ModernizedCProgram.curl_msnprintf(print_buffer + ( - 5), 5, "...\n");
				} else {
						ModernizedCProgram.curl_msnprintf(print_buffer + ( - 4), 4, "...");
				} 
			} 
			.__builtin_va_end(ap);
			len = .strlen(print_buffer);
			ModernizedCProgram.Curl_debug(data, .CURLINFO_TEXT, print_buffer, len/* Curl_failf() is for messages stating why we failed.
			 * The message SHALL NOT include any LF or CR.
			 */);
		} 
	}
	public static void Curl_failf(Object data, Object fmt) {
		if (data.getSet().getVerbose() || data.getSet().getErrorbuffer()) {
			va_list ap = new va_list();
			size_t len = new size_t();
			byte[] error = new byte[256 + 2];
			.__builtin_va_start(ap, fmt);
			ModernizedCProgram.curl_mvsnprintf(error, 256, fmt, ap);
			len = .strlen(error);
			if (data.getSet().getErrorbuffer() && !data.getState().getErrorbuf()) {
				.strcpy(data.getSet().getErrorbuffer(), error);
				data.getState().setErrorbuf(/* wrote error string */1);
			} 
			if (data.getSet().getVerbose()) {
				error[len] = (byte)'\n';
				error[++len] = (byte)'\0';
				ModernizedCProgram.Curl_debug(data, .CURLINFO_TEXT, error, len);
			} 
			.__builtin_va_end(ap);
		} 
	}
	/* Curl_sendf() sends formatted data to the server */
	public static  Curl_sendf(Object sockfd, Object conn, Object fmt) {
		Curl_easy data = conn.getData();
		ssize_t bytes_written = new ssize_t();
		size_t write_len = new size_t();
		CURLcode result = .CURLE_OK;
		byte s;
		byte sptr;
		va_list ap = new va_list();
		.__builtin_va_start(ap, fmt);
		s = ModernizedCProgram.curl_mvaprintf(fmt, /* returns an allocated string */ap);
		.__builtin_va_end(ap);
		if (!s) {
			return /* failure */.CURLE_OUT_OF_MEMORY;
		} 
		bytes_written = 0;
		write_len = .strlen(s);
		sptr = s;
		for (; ; ) {
			result = ModernizedCProgram.Curl_write(conn, sockfd, sptr, write_len, /* Write the buffer to the socket */bytes_written);
			if (result) {
				break;
			} 
			if (data.getSet().getVerbose()) {
				ModernizedCProgram.Curl_debug(data, .CURLINFO_DATA_OUT, sptr, (size_t)bytes_written);
			} 
			if ((size_t)bytes_written != write_len/* if not all was written at once, we must advance the pointer, decrease
			         the size left and try again! */) {
				write_len -= bytes_written;
				sptr += bytes_written;
			} else {
					break;
			} 
		}
		.Curl_cfree(/* free the output string */s);
		return result/*
		 * Curl_write() is an internal write function that sends data to the
		 * server. Works with plain sockets, SCP, SSL or kerberos.
		 *
		 * If the write would block (CURLE_AGAIN), we return CURLE_OK and
		 * (*written == 0). Otherwise we return regular CURLcode value.
		 */;
	}
	public static  Curl_write(Object conn, Object sockfd, Object mem, Object len, Object written) {
		ssize_t bytes_written = new ssize_t();
		CURLcode result = .CURLE_OK;
		int num = (sockfd == conn.getSock()[1]);
		bytes_written = .UNRECOGNIZEDFUNCTIONNAME(conn, num, mem, len, result);
		written = bytes_written;
		if (bytes_written >= 0) {
			return /* we completely ignore the curlcode value when subzero is not returned */.CURLE_OK;
		} 
		switch (/* handle CURLE_AGAIN or a send failure */result) {
		case .CURLE_AGAIN:
				written = 0;
				return .CURLE_OK;
		case .CURLE_OK:
				return /* general send failure */.CURLE_SEND_ERROR;
		default:
				return /* we got a specific curlcode, forward it */result;
		}
	}
	public static Object Curl_send_plain(Object conn, int num, Object mem, Object len, Object code) {
		curl_socket_t sockfd = conn.getSock()[num];
		ssize_t bytes_written = new ssize_t();
		/* WinSock will destroy unread received data if send() is
		     failed.
		     To avoid lossage of received data, recv() must be
		     performed before every send() if any incoming data is
		     available. */
		ModernizedCProgram.pre_receive_plain(conn, num/* Linux */);
		bytes_written = (ssize_t).send((SOCKET)(sockfd), (byte)(mem), (int)(len), (int)(false));
		code = .CURLE_OK;
		if (-1 == bytes_written) {
			int err = ((int).WSAGetLastError());
			if ((-1024 == /* This is how Windows does it */err/* errno may be EWOULDBLOCK or on some systems EAGAIN when it returned
			         due to its inability to send off data without blocking. We therefore
			         treat both error codes the same here */)) {
				bytes_written = /* this is just a case of EWOULDBLOCK */0;
				code = .CURLE_AGAIN;
			} else {
					byte[] buffer = new byte[128];
					ModernizedCProgram.Curl_failf(conn.getData(), "Send failure: %s", ModernizedCProgram.Curl_strerror(err, buffer, ));
					conn.getData().getState().setOs_errno(err);
					code = .CURLE_SEND_ERROR;
			} 
		} 
		return bytes_written/*
		 * Curl_write_plain() is an internal write function that sends data to the
		 * server using plain sockets only. Otherwise meant to have the exact same
		 * proto as Curl_write()
		 */;
	}
	public static  Curl_write_plain(Object conn, Object sockfd, Object mem, Object len, Object written) {
		ssize_t bytes_written = new ssize_t();
		CURLcode result = new CURLcode();
		int num = (sockfd == conn.getSock()[1]);
		bytes_written = ModernizedCProgram.Curl_send_plain(conn, num, mem, len, result);
		written = bytes_written;
		return result;
	}
	public static Object Curl_recv_plain(Object conn, int num, Object buf, Object len, Object code) {
		curl_socket_t sockfd = conn.getSock()[num];
		ssize_t nread = new ssize_t();
		/* Check and return data that already received and storied in internal
		     intermediate buffer */
		nread = ModernizedCProgram.get_pre_recved(conn, num, buf, len);
		if (nread > 0) {
			code = .CURLE_OK;
			return nread;
		} 
		nread = (ssize_t).recv((SOCKET)(sockfd), (byte)(buf), (int)(len), (int)(false));
		code = .CURLE_OK;
		if (-1 == nread) {
			int err = ((int).WSAGetLastError());
			if ((-1024 == /* This is how Windows does it */err/* errno may be EWOULDBLOCK or on some systems EAGAIN when it returned
			         due to its inability to send off data without blocking. We therefore
			         treat both error codes the same here */)) {
				code = /* this is just a case of EWOULDBLOCK */.CURLE_AGAIN;
			} else {
					byte[] buffer = new byte[128];
					ModernizedCProgram.Curl_failf(conn.getData(), "Recv failure: %s", ModernizedCProgram.Curl_strerror(err, buffer, ));
					conn.getData().getState().setOs_errno(err);
					code = .CURLE_RECV_ERROR;
			} 
		} 
		return nread;
	}
	public static  pausewrite(Object data, int type, Object ptr, Object len) {
		SingleRequest k = data.getReq();
		UrlState s = data.getState();
		byte dupl;
		int i;
		bool newtype = 1;
		if (s.getTempcount()) {
			for (i = 0; i < s.getTempcount(); i++) {
				if (s.getTempwrite()[i].getType() == type) {
					newtype = /* data for this type exists */0;
					break;
				} 
			}
			do {
			} while (0);
		} else {
				i = 0;
		} 
		if (!newtype/* append new data to old data */) {
			size_t newlen = len + s.getTempwrite()[i].getLen();
			byte newptr = .Curl_crealloc(s.getTempwrite()[i].getBuf(), /* allocate the new memory area */newlen);
			if (!newptr) {
				return .CURLE_OUT_OF_MEMORY;
			} 
			.memcpy(newptr + s.getTempwrite()[i].getLen(), ptr, /* copy the new data to the end of the new area */len);
			s.getTempwrite()[i].setBuf(/* update the pointer and the size */newptr);
			s.getTempwrite()[i].setLen(newlen);
		} else {
				dupl = ModernizedCProgram.Curl_memdup(ptr, len);
				if (!dupl) {
					return .CURLE_OUT_OF_MEMORY;
				} 
				s.getTempwrite()[i].setBuf(/* store this information in the state struct for later use */dupl);
				s.getTempwrite()[i].setLen(len);
				s.getTempwrite()[i].setType(type);
				if (newtype) {
					s.getTempcount()++;
				} 
		} 
		k.getKeepon() |=  (1 << /* mark the connection as RECV paused */4);
		do {
		} while (0);
		return .CURLE_OK/* chop_write() writes chunks of data not larger than CURL_MAX_WRITE_SIZE via
		 * client write callback(s) and takes care of pause requests from the
		 * callbacks.
		 */;
	}
	/* what type of data */
	public static  chop_write(Object conn, int type, Object optr, Object olen) {
		Curl_easy data = conn.getData();
		curl_write_callback writeheader = ((Object)0);
		curl_write_callback writebody = ((Object)0);
		byte ptr = optr;
		size_t len = olen;
		if (!len) {
			return .CURLE_OK;
		} 
		if (data.getReq().getKeepon() & (1 << /* If reading is paused, append this data to the already held data for this
		     type. */4)) {
			return ModernizedCProgram.pausewrite(data, type, ptr, len);
		} 
		if (type & (1 << /* Determine the callback(s) to use. */0)) {
			writebody = data.getSet().getFwrite_func();
		} 
		if ((type & (1 << 1)) && (data.getSet().getFwrite_header() || data.getSet().getWriteheader())) {
			writeheader = data.getSet().getFwrite_header() ? data.getSet().getFwrite_header() : data.getSet().getFwrite_func();
		} 
		while (/* Chop data, write chunks. */len) {
			size_t chunklen = len <= 16384 ? len : 16384;
			if (writebody) {
				size_t wrote = new size_t();
				ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
				wrote = .writebody(ptr, 1, chunklen, data.getSet().getOut());
				ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
				if (-1024 == wrote) {
					if (conn.getHandler().getFlags() & (1 << 4/* Protocols that work without network cannot be paused. This is
					             actually only FILE:// just now, and it can't pause since the
					             transfer isn't done using the "normal" procedure. */)) {
						ModernizedCProgram.Curl_failf(data, "Write callback asked for PAUSE when not supported!");
						return .CURLE_WRITE_ERROR;
					} 
					return ModernizedCProgram.pausewrite(data, type, ptr, len);
				} 
				if (wrote != chunklen) {
					ModernizedCProgram.Curl_failf(data, "Failed writing body (%zu != %zu)", wrote, chunklen);
					return .CURLE_WRITE_ERROR;
				} 
			} 
			ptr += chunklen;
			len -= chunklen;
		}
		if (writeheader) {
			size_t wrote = new size_t();
			ptr = optr;
			len = olen;
			ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
			wrote = .writeheader(ptr, 1, len, data.getSet().getWriteheader());
			ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
			if (-1024 == wrote/* here we pass in the HEADER bit only since if this was body as well
			         then it was passed already and clearly that didn't trigger the
			         pause, so this is saved for later with the HEADER bit only */) {
				return ModernizedCProgram.pausewrite(data, (1 << 1), ptr, len);
			} 
			if (wrote != len) {
				ModernizedCProgram.Curl_failf(data, "Failed writing header");
				return .CURLE_WRITE_ERROR;
			} 
		} 
		return .CURLE_OK/* Curl_client_write() sends data to the write callback(s)
		
		   The bit pattern defines to what "streams" to write to. Body and/or header.
		   The defines are in sendf.h of course.
		
		   If CURL_DO_LINEEND_CONV is enabled, data is converted IN PLACE to the
		   local character encoding.  This is a problem and should be changed in
		   the future to leave the original data alone.
		 */;
	}
	public static  Curl_client_write(Object conn, int type, Object ptr, Object len) {
		Curl_easy data = conn.getData();
		if (0 == len) {
			len = .strlen(ptr);
		} 
		do {
		} while (0);
		if ((type & (1 << /* FTP data may need conversion. */0)) && (conn.getHandler().getProtocol() & ((1 << 2) | (1 << 3))) && conn.getProto().getFtpc().getTransfertype() == (byte)'A') {
			CURLcode result = ();
			if (/* Curl_convert_from_network calls failf if unsuccessful */result) {
				return result/* convert end-of-line markers */;
			} 
		} 
		return ModernizedCProgram.chop_write(conn, type, ptr, /* CURL_DO_LINEEND_CONV */len);
	}
	public static  Curl_read_plain(Object sockfd, Object buf, Object bytesfromsocket, Object n) {
		ssize_t nread = (ssize_t).recv((SOCKET)(sockfd), (byte)(buf), (int)(bytesfromsocket), (int)(false));
		if (-1 == nread) {
			int err = ((int).WSAGetLastError());
			int return_error;
			return_error = -1024 == err;
			if (return_error) {
				return .CURLE_AGAIN;
			} 
			return .CURLE_RECV_ERROR;
		} 
		n = /* we only return number of bytes read when we return OK */nread;
		return .CURLE_OK/*
		 * Internal read-from-socket function. This is meant to deal with plain
		 * sockets, SSL sockets and kerberos sockets.
		 *
		 * Returns a regular CURLcode value.
		 */;
	}
	/* connection data */
	public static  Curl_read(Object conn, Object sockfd, Object buf, Object sizerequested, Object n) {
		CURLcode result = /* max amount to read *//* amount bytes read */.CURLE_RECV_ERROR;
		ssize_t nread = 0;
		size_t bytesfromsocket = 0;
		byte buffertofill = ((Object)0);
		Curl_easy data = conn.getData();
		int num = (sockfd == conn.getSock()[1]);
		n = /* reset amount to zero */0;
		bytesfromsocket = ((sizerequested) < ((size_t)data.getSet().getBuffer_size()) ? (sizerequested) : ((size_t)data.getSet().getBuffer_size()));
		buffertofill = buf;
		nread = .UNRECOGNIZEDFUNCTIONNAME(conn, num, buffertofill, bytesfromsocket, result);
		if (nread < 0) {
			return result;
		} 
		n += nread;
		return .CURLE_OK;
	}
	/* read from this socket */
	/* store read data here */
	/* return 0 on success */
	public static int Curl_debug(Object data,  type, Object ptr, Object size) {
		byte[][] s_infotype = new byte[][]{"* ", "< ", "> ", "{ ", "} ", "{ ", "} "};
		int rc = 0/* Special processing is needed for this block if it
		     * contains both headers and data (separated by CRLFCRLF).
		     * We want to convert just the headers, leaving the data as-is.
		     */;
		if (data.getSet().getFdebug()) {
			ModernizedCProgram.Curl_set_in_callback(data, .bool_true);
			rc = .UNRECOGNIZEDFUNCTIONNAME(data, type, ptr, size, data.getSet().getDebugdata());
			ModernizedCProgram.Curl_set_in_callback(data, .bool_false);
		} else {
				switch (type) {
				case .CURLINFO_HEADER_IN:
						.fwrite(s_infotype[type], 2, 1, data.getSet().getErr());
						.fwrite(ptr, size, 1, data.getSet().getErr());
						break;
				case .CURLINFO_TEXT:
				case .CURLINFO_HEADER_OUT:
				default:
						break;
				}
		} 
		return rc;
	}
}
